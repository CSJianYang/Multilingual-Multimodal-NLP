[
    {
        "title": "Subsets II",
        "question_content": "Given an integer array nums that may contain duplicates, return all possible subsets (the power set).\nThe solution set must not contain duplicate subsets. Return the solution in any order.\n&nbsp;\nExample 1:\nInput: nums = [1,2,2]\nOutput: [[],[1],[1,2],[1,2,2],[2],[2,2]]\nExample 2:\nInput: nums = [0]\nOutput: [[],[0]]\n&nbsp;\nConstraints:\n\n\t1 <= nums.length <= 10\n\t-10 <= nums[i] <= 10",
        "solutions": [
            {
                "id": 30168,
                "title": "c-solution-and-explanation",
                "content": "To solve this problem, it is helpful to first think how many subsets are there. If there is no duplicate element, the answer is simply 2^n, where n is the number of elements. This is because you have two choices for each element, either putting it into the subset or not. So all subsets for this no-duplicate set can be easily constructed:\\nnum of subset\\n\\n -  (1        to 2^0) empty set is the first subset\\n -  (2^0+1 to 2^1) add the first element into subset from (1)\\n -  (2^1+1 to 2^2) add the second element into subset (1 to 2^1)\\n -  (2^2+1 to 2^3) add the third element into subset (1 to 2^2)\\n - ....\\n -  (2^(n-1)+1 to 2^n) add the nth element into subset(1 to 2^(n-1))\\n\\nThen how many subsets are there if there are duplicate elements? We can treat duplicate element as a spacial element. For example, if we have duplicate elements (5, 5), instead of treating them as two elements that are duplicate, we can treat it as one special element 5, but this element has more than two choices: you can either NOT put it into the subset, or put ONE 5 into the subset, or put TWO 5s into the subset. Therefore, we are given an array (a1, a2, a3, ..., an) with each of them appearing (k1, k2, k3, ..., kn) times, the number of subset is (k1+1)*(k2+1)*...(kn+1). We can easily see how to write down all the subsets similar to the approach above.\\n\\n        class Solution {\\n    public:\\n        vector<vector<int> > subsetsWithDup(vector<int> &S) {\\n            vector<vector<int> > totalset = {{}};\\n            sort(S.begin(),S.end());\\n            for(int i=0; i<S.size();){\\n                int count = 0; // num of elements are the same\\n                while(count + i<S.size() && S[count+i]==S[i])  count++;\\n                int previousN = totalset.size();\\n                for(int k=0; k<previousN; k++){\\n                    vector<int> instance = totalset[k];\\n                    for(int j=0; j<count; j++){\\n                        instance.push_back(S[i]);\\n                        totalset.push_back(instance);\\n                    }\\n                }\\n                i += count;\\n            }\\n            return totalset;\\n            }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<vector<int> > subsetsWithDup(vector<int> &S) {\\n            vector<vector<int> > totalset = {{}",
                "codeTag": "Java"
            },
            {
                "id": 30164,
                "title": "accepted-10ms-c-solution-use-backtracking-only-10-lines-easy-understand",
                "content": "**The characteristics of C++ reference is an outstanding tool for backtracking algorithm!**\\n\\nlet us use [1,2,3,4] as an example to explain my solution:\\n\\n    subsets([1,2,3,4]) = []\\n                         // push(1)\\n                         [1, subsets([2,3,4])] // if push N times in subsets([2,3,4]), the pop times is also N, so vec is also [1] after backtrack.\\n                         // pop(), push(2)\\n                         [2, subsets([3,4])]\\n                         // pop(), push(3)\\n                         [3, subsets([4])]\\n                         // pop(), push(4)\\n                         [4, subsets([])]\\n                         // pop()\\n\\nAccepted 10ms c++ solution use backtracking for [Subsets ][1]\\n\\n    class Solution {\\n    public:\\n        std::vector<std::vector<int> > subsets(std::vector<int> &nums) {\\n    \\t\\tstd::sort(nums.begin(), nums.end());\\n            std::vector<std::vector<int> > res;\\n    \\t\\tstd::vector<int> vec;\\n    \\t\\tsubsets(res, nums, vec, 0);\\n    \\t\\treturn res;\\n        }\\n    private:\\n    \\tvoid subsets(std::vector<std::vector<int> > &res, std::vector<int> &nums, std::vector<int> &vec, int begin) {\\n    \\t\\tres.push_back(vec);\\n    \\t\\tfor (int i = begin; i != nums.size(); ++i) {\\n    \\t\\t\\tvec.push_back(nums[i]);\\n    \\t\\t\\tsubsets(res, nums, vec, i + 1);\\n    \\t\\t\\tvec.pop_back();\\n    \\t\\t}\\n    \\t}\\n    };\\n\\n\\nAccepted 10ms c++ solution use backtracking for [Subsets II][2]\\n\\n    class Solution {\\n    public:\\n        std::vector<std::vector<int> > subsetsWithDup(std::vector<int> &nums) {\\n    \\t\\tstd::sort(nums.begin(), nums.end());\\n            std::vector<std::vector<int> > res;\\n    \\t\\tstd::vector<int> vec;\\n    \\t\\tsubsetsWithDup(res, nums, vec, 0);\\n    \\t\\treturn res;\\n        }\\n    private:\\n    \\tvoid subsetsWithDup(std::vector<std::vector<int> > &res, std::vector<int> &nums, std::vector<int> &vec, int begin) {\\n    \\t\\tres.push_back(vec);\\n    \\t\\tfor (int i = begin; i != nums.size(); ++i)\\n    \\t\\t\\tif (i == begin || nums[i] != nums[i - 1]) { \\n    \\t\\t\\t\\tvec.push_back(nums[i]);\\n    \\t\\t\\t\\tsubsetsWithDup(res, nums, vec, i + 1);\\n    \\t\\t\\t\\tvec.pop_back();\\n    \\t\\t\\t}\\n    \\t}\\n    };\\n\\n\\n  [1]: https://leetcode.com/problems/subsets/\\n  [2]: https://leetcode.com/problems/subsets-ii/",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "class Solution {\\n    public:\\n        std::vector<std::vector<int> > subsets(std::vector<int> &nums) {\\n    \\t\\tstd::sort(nums.begin(), nums.end());\\n            std::vector<std::vector<int> > res;\\n    \\t\\tstd::vector<int> vec;\\n    \\t\\tsubsets(res, nums, vec, 0);\\n    \\t\\treturn res;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 169226,
                "title": "java-two-way-of-recursive-thinking",
                "content": "1) Each recursion level focuses on all the following elements. We scan through all the following elements and decide whether to choose or not choose that element. (Every level split into N branches.)\\n```java\\nclass Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        Arrays.sort(nums);\\n        List<List<Integer>> res = new ArrayList<>();\\n        helper(res,new ArrayList<>(),nums,0);\\n        return res;\\n    }\\n    \\n    public void helper(List<List<Integer>> res, List<Integer> ls, int[] nums, int pos) {\\n        res.add(new ArrayList<>(ls));\\n        for(int i=pos;i<nums.length;i++) {\\n            if(i>pos&&nums[i]==nums[i-1]) continue;\\n            ls.add(nums[i]);\\n            helper(res,ls,nums,i+1);     \\n            ls.remove(ls.size()-1);\\n        }\\n    }\\n}\\n```\\n2) Each recursion level focuses on one element, we need to decide choose or not choose this element. (Every level split into 2 branches.)\\n```java\\nclass Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        Arrays.sort(nums);\\n        List<List<Integer>> res = new ArrayList<>();\\n        helper(res,new ArrayList<>(),nums,0,false);\\n        return res;\\n    }\\n    \\n    public void helper(List<List<Integer>> res, List<Integer> ls, int[] nums, int pos, boolean choosePre) {\\n        if(pos==nums.length) {\\n            res.add(new ArrayList<>(ls));\\n            return;\\n        }\\n        helper(res,ls,nums,pos+1,false);\\n        if(pos>=1&&nums[pos]==nums[pos-1]&&!choosePre) return;\\n        ls.add(nums[pos]);\\n        helper(res,ls,nums,pos+1,true);\\n        ls.remove(ls.size()-1);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        Arrays.sort(nums);\\n        List<List<Integer>> res = new ArrayList<>();\\n        helper(res,new ArrayList<>(),nums,0);\\n        return res;\\n    }\\n    \\n    public void helper(List<List<Integer>> res, List<Integer> ls, int[] nums, int pos) {\\n        res.add(new ArrayList<>(ls));\\n        for(int i=pos;i<nums.length;i++) {\\n            if(i>pos&&nums[i]==nums[i-1]) continue;\\n            ls.add(nums[i]);\\n            helper(res,ls,nums,i+1);     \\n            ls.remove(ls.size()-1);\\n        }\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        Arrays.sort(nums);\\n        List<List<Integer>> res = new ArrayList<>();\\n        helper(res,new ArrayList<>(),nums,0,false);\\n        return res;\\n    }\\n    \\n    public void helper(List<List<Integer>> res, List<Integer> ls, int[] nums, int pos, boolean choosePre) {\\n        if(pos==nums.length) {\\n            res.add(new ArrayList<>(ls));\\n            return;\\n        }\\n        helper(res,ls,nums,pos+1,false);\\n        if(pos>=1&&nums[pos]==nums[pos-1]&&!choosePre) return;\\n        ls.add(nums[pos]);\\n        helper(res,ls,nums,pos+1,true);\\n        ls.remove(ls.size()-1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 388566,
                "title": "subsets-i-ii-java-solution-with-detailed-explanation-and-comments-recursion-iteration",
                "content": "Reference: [Subsets I](https://leetcode.com/problems/subsets/) & [Subsets II](https://leetcode.com/problems/subsets-ii/) <span class=\"gray\">EPI 15.5</span>\\nDifficulty: <span class=\"orange\">Medium</span> (I think Subsets II should be hard)\\n\\n\\n\\n## Problem\\n\\n> Given a set of `distinct` integers, `nums`, return all possible subsets (the power set).\\n\\n**Note:** The solution set must not contain duplicate subsets.\\n\\n**Example:** \\n\\n```java\\nInput: nums = [1,2,3]\\nOutput: [\\n  [3],\\n  [1],\\n  [2],\\n  [1,2,3],\\n  [1,3],\\n  [2,3],\\n  [1,2],\\n  []\\n]\\n```\\n\\n**Follow up:** Check out the [Subsets II](#subsets_ii) section below.\\n\\n\\n## Analysis\\n\\nThe power set of a set `S` is the set of all subsets of `S`, including both the empty set `emptyset` and `S` itself. The power set of `{1, 2, 3}` is graphically illustrated as follows.\\n\\n![](https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/mgtg8.jpg)\\n\\n\\n### Backtracking\\n\\nThe idea is that we loop over the number list. For each number, we have two choices: pick it, or not. For example, in `[1, 2, 3]`, we pick `1` and then do the same thing for the subproblem `[2, 3]`; and we don\\'t pick `1` and then do the same thing for the subproblem `[2, 3]`.\\n\\nThe size of subproblems is decreasing. When picking `2`, the subproblem becomes `[3]` instead of `[1, 3]`.\\n\\nConsider the following questions:\\n\\n- What is the base case?\\n- When do we add the list to the result?\\n\\nHere is an illustration of recursive process on `[1, 2, 3]`.\\n\\n![](https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/gfdd3.jpg)\\n\\n\\n**Note:** Remember to add empty set manually.\\n\\n\\n```java\\npublic List<List<Integer>> subsets(int[] nums) {\\n  List<List<Integer>> result = new ArrayList<>();\\n  List<Integer> numList = new ArrayList<>();\\n  \\n  result.add(new ArrayList<>()); // empty set\\n  subsets(0, nums, numList, result);\\n  return result;\\n}\\n\\nprivate void subsets(int offset, int[] nums, List<Integer> numList, List<List<Integer>> result) {\\n  if (offset >= nums.length) {\\n    return;\\n  }\\n  int val = nums[offset];\\n  // pick\\n  numList.add(val);\\n  subsets(offset + 1, nums, numList, result);\\n  // add to result\\n  result.add(new ArrayList<>(numList));\\n  // not pick\\n  numList.remove(numList.size() - 1);\\n  subsets(offset + 1, nums, numList, result);\\n}\\n```\\n\\n**Time:** `O(N * 2^N)` since the recurrence is `T(N) = 2T(N - 1)` and we also spend at most `O(N)` time within a call.\\n**Space:** `O(N * 2^N)` since there are `2^N` subsets. If we only print the result, we just need `O(N)` space.\\n\\n\\n### Iteration\\n\\nThe idea is simple. We go through the elements in the `nums` list. For each element, we loop over the current `result` list we have constructed so far. For each list in the `result`, we make a copy of this list and append the current element to it (it means picking the element). It is based on the same idea in backtracking (in each step you have choices: `pick` or `not pick`).\\n\\nThe result list initially contains an empty list `[]`. We loop over each element of `nums`, e.g. `[1, 2, 3]`.\\n\\n- After the first round, we have `[[], [1]]`.\\n- After the second round, we have `[[], [1], [2], [1,2]]`.\\n- After the third round, we have `[[], [1], [2], [1,2], [3], [1,3], [2,3], [1,2,3]]`.\\n\\nFirst, let\\'s go over an incorrect version. There are two errors:\\n\\n1. We add a new element to `L`, but it changes the existed `L`. Thus, we should make a new copy of it.\\n2. While looping over `result`, we are modifying its size. In Java, the compiler would yell.\\n\\n**Incorrect version:**\\n\\n```java\\npublic List<List<Integer>> subsets(int[] nums) {\\n  List<List<Integer>> result = new ArrayList<>();\\n  result.add(new ArrayList<>());  // empty set\\n  for (int i = 0; i < nums.length; ++i) {\\n    for (List<Integer> L : result) {\\n      L.add(nums[i]);\\n      result.add(L);\\n    }\\n  }\\n  return result;\\n}\\n```\\n\\n**Correct version:**\\n\\n```java\\npublic List<List<Integer>> subsets(int[] nums) {\\n  List<List<Integer>> result = new ArrayList<>();\\n  result.add(new ArrayList<>());  // empty set\\n  for (int i = 0; i < nums.length; ++i) {\\n    List<List<Integer>> newResult = new ArrayList<>(); // used for new lists\\n    for (List<Integer> L : result) {\\n      L = new ArrayList<>(L); // copy\\n      L.add(nums[i]);\\n      newResult.add(L);\\n    }\\n    result.addAll(newResult);  // concatenate\\n  }\\n  return result;\\n}\\n```\\n\\n**Time:** `O(N * 2^N)`\\n- The outer loop takes `O(N)` time.\\n- The inner loop takes `2, 4, 8, ..., 2^N` time respectively.\\n- In inner loop, making a new copy of `L` takes at most `O(N)` time.\\n- Total runtime `T(N) = N * (2 + 4 + 8 + ... + 2^N) ~= N * 2^N`\\n\\n**Space:** `O(N * 2^N)`\\n\\n\\n\\n### K-Size Subsets\\n\\nActually, we can use the code in [77. Combinations](https://www.junhaow.com/lc/problems/backtracking/77_combinations.html) to solve this problem.\\n\\n\\n```java\\npublic List<List<Integer>> subsets(int[] nums) {\\n  List<List<Integer>> result = new ArrayList<>();\\n  List<Integer> numList = new ArrayList<>();\\n  \\n  int n = nums.length;\\n  for (int k = 0; k <= n; ++k) { // compatible with empty set\\n    combine(n, k, 1, nums, numList, result);\\n  }\\n  return result;\\n}\\n\\nprivate void combine(int n, int k, int d, int[] nums, List<Integer> numList, List<List<Integer>> result) {\\n  // base case (in order to handle empty set, ordering of two IFs matters)\\n  if (numList.size() == k) { // get a result\\n    result.add(new ArrayList<>(numList));\\n    return;\\n  }\\n  if (n - d + 1 < k - numList.size()) { // remaining elements are not enough\\n    return;\\n  }\\n\\n  for (int i = d; i <= n; ++i) {\\n    int val = nums[i - 1];\\n    numList.add(val);\\n    combine(n, k, i + 1, nums, numList, result);\\n    numList.remove(numList.size() - 1); // remove the last\\n  }\\n}\\n```\\n\\n**Time:** `O(N * 2^N)`\\n- `C(0, N) + C(1, N) + C(2, N) + C(3, N) + ... + C(N, N) = 2^N`\\n\\n**Space:** `O(N * 2^N)`\\n\\n\\n## Subsets II\\n\\nReference:\\n\\n- [[Java] Two Way of Recursive thinking](https://leetcode.com/problems/subsets-ii/discuss/169226/Java-Two-Way-of-Recursive-thinking)\\n- [Simple iterative solution](https://leetcode.com/problems/subsets-ii/discuss/30137/Simple-iterative-solution)\\n\\n> Given a collection of integers that might **contain duplicates**, `nums`, return all possible subsets (the power set).\\n\\n**Note:** The solution set must not contain duplicate subsets.\\n\\n```java\\nInput: [1,2,2]\\nOutput: [\\n  [2],\\n  [1],\\n  [1,2,2],\\n  [2,2],\\n  [1,2],\\n  []\\n]\\n```\\n\\n### Backtracking\\n\\nWe need to know when we **should not** add a list to the result list.\\n\\n![](https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/wek92.jpg)\\n\\nBy observation, a duplicate list occurs when `offset >= 1` (when `offset = 0`, duplicate cannot occur) and `nums[offset - 1] == nums[offset]` and in the previous step we did not pick `nums[offset - 1]`. The information of whether it picks or not could be passed down by a **boolean parameter** `isPicked`.\\n \\nIf the above condition is satisfied:\\n- Do not add the list to the result list.\\n- Do not do the subproblem after picking the current element.\\n- Only do the subproblem after not picking the current element.\\n\\n**Note:** Be careful where we should put the `numList.add(val)` and `numList.remove(numList.size() - 1)`.\\n\\n```java\\npublic List<List<Integer>> subsetsWithDup(int[] nums) {\\n  // sorting\\n  Arrays.sort(nums);\\n  \\n  List<List<Integer>> result = new ArrayList<>();\\n  List<Integer> numList = new ArrayList<>();\\n  result.add(new ArrayList<>());\\n  subsets(0, nums, numList, result, true);\\n  return result;\\n}\\n\\nprivate void subsets(int offset, int[] nums, List<Integer> numList, List<List<Integer>> result, boolean isPicked) {\\n  // base case\\n  if (offset >= nums.length) {\\n    return;\\n  }\\n  int val = nums[offset];\\n  // duplicate checking (convert && to ||)\\n  if (offset == 0 || nums[offset - 1] != nums[offset] || isPicked == true) {\\n    // pick\\n    numList.add(val);\\n    subsets(offset + 1, nums, numList, result, true);\\n    result.add(new ArrayList<>(numList));  // add to the result list\\n    numList.remove(numList.size() - 1);\\n  }\\n  // not pick\\n  subsets(offset + 1, nums, numList, result, false);\\n}\\n```\\n\\nAnother version (similar): \\n\\n```java\\nprivate void subsets(int offset, int[] nums, List<Integer> numList, List<List<Integer>> result, boolean isPicked) {\\n  // base case\\n  if (offset >= nums.length) {\\n    return;\\n  }\\n  int val = nums[offset];\\n  // not pick\\n  subsets(offset + 1, nums, numList, result, false);\\n  // duplicate check\\n  if (offset >= 1 && nums[offset - 1] == nums[offset] && isPicked == false) {\\n    return;\\n  }\\n  // pick\\n  numList.add(val);\\n  subsets(offset + 1, nums, numList, result, true);\\n  result.add(new ArrayList<>(numList));  // add to the result list\\n  numList.remove(numList.size() - 1); \\n}\\n```\\n\\n**Time:** `O(N * 2^N)`\\n**Space:** `O(N * 2^N)`\\n\\n\\n\\n\\n### Iteration\\n\\nUsing the same idea in backtracking, we need to figure out when we should add a list to the result list. Check out three examples below (`[1,2,3]`, `[1,2,2]`, `[5,5,5]`).\\n\\n![](https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/y0inx.jpg)\\n\\nBy observation, we learn that we should start from, if duplicate is detected, a specific location in the result list. In Subsets I, we always start from $0$.\\n\\nInterestingly, the specific location corresponds to the initial size of the result list in the previous round. Since we change the result list in each round, we should cache the size of the result list as `cachedSize`.\\n\\nThen we denote the starting index as `startIdx`. In each round, similar to what we\\'ve done in Subsets I, we set `startIdx` as:\\n\\n- `0` (no duplicate or `i == 0`)\\n- `cachedSize` (duplicate occurs)\\n\\nAfter setting `startIdx`, remember to do the caching job for the current size of the result list. Notice a fact that this cached size may not be used in the next round.\\n\\n\\n```java\\npublic List<List<Integer>> subsetsWithDup(int[] nums) {\\n  // sort\\n  Arrays.sort(nums);\\n  \\n  List<List<Integer>> result = new ArrayList<>();\\n  result.add(new ArrayList<>());  // empty set\\n  \\n  int cachedSize = 0, startIdx = 0;\\n  for (int i = 0; i < nums.length; ++i) {\\n    List<List<Integer>> newResult = new ArrayList<>();  // used for new lists\\n    // set startIdx first before we update cachedSize\\n    startIdx = (i > 0 && nums[i - 1] == nums[i]) ? cachedSize : 0; // if duplicate occurs\\n    cachedSize = result.size(); // cache the size for startIdx in the next round\\n    for (int j = startIdx; j < result.size(); ++j) {\\n      List<Integer> L = result.get(j);\\n      L = new ArrayList<>(L);  // copy\\n      L.add(nums[i]);\\n      newResult.add(L);\\n    }\\n    result.addAll(newResult);  // concatenate\\n  }\\n  return result;\\n}\\n```\\n\\n**Time:** `O(N * 2^N)`\\n**Space:** `O(N * 2^N)`\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```java\\nInput: nums = [1,2,3]\\nOutput: [\\n  [3],\\n  [1],\\n  [2],\\n  [1,2,3],\\n  [1,3],\\n  [2,3],\\n  [1,2],\\n  []\\n]\\n```\n```java\\npublic List<List<Integer>> subsets(int[] nums) {\\n  List<List<Integer>> result = new ArrayList<>();\\n  List<Integer> numList = new ArrayList<>();\\n  \\n  result.add(new ArrayList<>()); // empty set\\n  subsets(0, nums, numList, result);\\n  return result;\\n}\\n\\nprivate void subsets(int offset, int[] nums, List<Integer> numList, List<List<Integer>> result) {\\n  if (offset >= nums.length) {\\n    return;\\n  }\\n  int val = nums[offset];\\n  // pick\\n  numList.add(val);\\n  subsets(offset + 1, nums, numList, result);\\n  // add to result\\n  result.add(new ArrayList<>(numList));\\n  // not pick\\n  numList.remove(numList.size() - 1);\\n  subsets(offset + 1, nums, numList, result);\\n}\\n```\n```java\\npublic List<List<Integer>> subsets(int[] nums) {\\n  List<List<Integer>> result = new ArrayList<>();\\n  result.add(new ArrayList<>());  // empty set\\n  for (int i = 0; i < nums.length; ++i) {\\n    for (List<Integer> L : result) {\\n      L.add(nums[i]);\\n      result.add(L);\\n    }\\n  }\\n  return result;\\n}\\n```\n```java\\npublic List<List<Integer>> subsets(int[] nums) {\\n  List<List<Integer>> result = new ArrayList<>();\\n  result.add(new ArrayList<>());  // empty set\\n  for (int i = 0; i < nums.length; ++i) {\\n    List<List<Integer>> newResult = new ArrayList<>(); // used for new lists\\n    for (List<Integer> L : result) {\\n      L = new ArrayList<>(L); // copy\\n      L.add(nums[i]);\\n      newResult.add(L);\\n    }\\n    result.addAll(newResult);  // concatenate\\n  }\\n  return result;\\n}\\n```\n```java\\npublic List<List<Integer>> subsets(int[] nums) {\\n  List<List<Integer>> result = new ArrayList<>();\\n  List<Integer> numList = new ArrayList<>();\\n  \\n  int n = nums.length;\\n  for (int k = 0; k <= n; ++k) { // compatible with empty set\\n    combine(n, k, 1, nums, numList, result);\\n  }\\n  return result;\\n}\\n\\nprivate void combine(int n, int k, int d, int[] nums, List<Integer> numList, List<List<Integer>> result) {\\n  // base case (in order to handle empty set, ordering of two IFs matters)\\n  if (numList.size() == k) { // get a result\\n    result.add(new ArrayList<>(numList));\\n    return;\\n  }\\n  if (n - d + 1 < k - numList.size()) { // remaining elements are not enough\\n    return;\\n  }\\n\\n  for (int i = d; i <= n; ++i) {\\n    int val = nums[i - 1];\\n    numList.add(val);\\n    combine(n, k, i + 1, nums, numList, result);\\n    numList.remove(numList.size() - 1); // remove the last\\n  }\\n}\\n```\n```java\\nInput: [1,2,2]\\nOutput: [\\n  [2],\\n  [1],\\n  [1,2,2],\\n  [2,2],\\n  [1,2],\\n  []\\n]\\n```\n```java\\npublic List<List<Integer>> subsetsWithDup(int[] nums) {\\n  // sorting\\n  Arrays.sort(nums);\\n  \\n  List<List<Integer>> result = new ArrayList<>();\\n  List<Integer> numList = new ArrayList<>();\\n  result.add(new ArrayList<>());\\n  subsets(0, nums, numList, result, true);\\n  return result;\\n}\\n\\nprivate void subsets(int offset, int[] nums, List<Integer> numList, List<List<Integer>> result, boolean isPicked) {\\n  // base case\\n  if (offset >= nums.length) {\\n    return;\\n  }\\n  int val = nums[offset];\\n  // duplicate checking (convert && to ||)\\n  if (offset == 0 || nums[offset - 1] != nums[offset] || isPicked == true) {\\n    // pick\\n    numList.add(val);\\n    subsets(offset + 1, nums, numList, result, true);\\n    result.add(new ArrayList<>(numList));  // add to the result list\\n    numList.remove(numList.size() - 1);\\n  }\\n  // not pick\\n  subsets(offset + 1, nums, numList, result, false);\\n}\\n```\n```java\\nprivate void subsets(int offset, int[] nums, List<Integer> numList, List<List<Integer>> result, boolean isPicked) {\\n  // base case\\n  if (offset >= nums.length) {\\n    return;\\n  }\\n  int val = nums[offset];\\n  // not pick\\n  subsets(offset + 1, nums, numList, result, false);\\n  // duplicate check\\n  if (offset >= 1 && nums[offset - 1] == nums[offset] && isPicked == false) {\\n    return;\\n  }\\n  // pick\\n  numList.add(val);\\n  subsets(offset + 1, nums, numList, result, true);\\n  result.add(new ArrayList<>(numList));  // add to the result list\\n  numList.remove(numList.size() - 1); \\n}\\n```\n```java\\npublic List<List<Integer>> subsetsWithDup(int[] nums) {\\n  // sort\\n  Arrays.sort(nums);\\n  \\n  List<List<Integer>> result = new ArrayList<>();\\n  result.add(new ArrayList<>());  // empty set\\n  \\n  int cachedSize = 0, startIdx = 0;\\n  for (int i = 0; i < nums.length; ++i) {\\n    List<List<Integer>> newResult = new ArrayList<>();  // used for new lists\\n    // set startIdx first before we update cachedSize\\n    startIdx = (i > 0 && nums[i - 1] == nums[i]) ? cachedSize : 0; // if duplicate occurs\\n    cachedSize = result.size(); // cache the size for startIdx in the next round\\n    for (int j = startIdx; j < result.size(); ++j) {\\n      List<Integer> L = result.get(j);\\n      L = new ArrayList<>(L);  // copy\\n      L.add(nums[i]);\\n      newResult.add(L);\\n    }\\n    result.addAll(newResult);  // concatenate\\n  }\\n  return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 30137,
                "title": "simple-iterative-solution",
                "content": "If we want to insert an element which is a dup, we can only insert it after the newly inserted elements from last step.\\n\\n    vector<vector<int> > subsetsWithDup(vector<int> &S) {\\n        sort(S.begin(), S.end());\\n        vector<vector<int>> ret = {{}};\\n        int size = 0, startIndex = 0;\\n        for (int i = 0; i < S.size(); i++) {\\n            startIndex = i >= 1 && S[i] == S[i - 1] ? size : 0;\\n            size = ret.size();\\n            for (int j = startIndex; j < size; j++) {\\n                vector<int> temp = ret[j];\\n                temp.push_back(S[i]);\\n                ret.push_back(temp);\\n            }\\n        }\\n        return ret;\\n    }",
                "solutionTags": [],
                "code": "If we want to insert an element which is a dup, we can only insert it after the newly inserted elements from last step.\\n\\n    vector<vector<int> > subsetsWithDup(vector<int> &S) {\\n        sort(S.begin(), S.end());\\n        vector<vector<int>> ret = {{}};\\n        int size = 0, startIndex = 0;\\n        for (int i = 0; i < S.size(); i++) {\\n            startIndex = i >= 1 && S[i] == S[i - 1] ? size : 0;\\n            size = ret.size();\\n            for (int j = startIndex; j < size; j++) {\\n                vector<int> temp = ret[j];\\n                temp.push_back(S[i]);\\n                ret.push_back(temp);\\n            }\\n        }\\n        return ret;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 30166,
                "title": "simple-python-solution-without-extra-space",
                "content": "    class Solution:\\n        # @param num, a list of integer\\n        # @return a list of lists of integer\\n        def subsetsWithDup(self, S):\\n            res = [[]]\\n            S.sort()\\n            for i in range(len(S)):\\n                if i == 0 or S[i] != S[i - 1]:\\n                    l = len(res)\\n                for j in range(len(res) - l, len(res)):\\n                    res.append(res[j] + [S[i]])\\n            return res\\n\\nif S[i] is same to S[i - 1], then it needn't to be added to all of the subset, just add it to the last l subsets which are created by adding S[i - 1]",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution:\\n        # @param num, a list of integer\\n        # @return a list of lists of integer\\n        def subsetsWithDup(self, S):\\n            res = [[]]\\n            S.sort()\\n            for i in range(len(S)):\\n                if i == 0 or S[i] != S[i - 1]:\\n                    l = len(res)\\n                for j in range(len(res) - l, len(res)):\\n                    res.append(res[j] + [S[i]])\\n            return res\\n\\nif S[i] is same to S[i - 1], then it needn't to be added to all of the subset, just add it to the last l subsets which are created by adding S[i - 1]",
                "codeTag": "Java"
            },
            {
                "id": 1380237,
                "title": "c-python-bitmasking-backtracking-iterative-solutions-with-picture-clean-concise",
                "content": "**\\u2714\\uFE0F Solution 1: Bitmasking (with Hashing)**\\n- In a `nums` array of length `n`, there are total `2^n` possible subsets.\\n- The idea is that we use bitmasks of `n` bits to present the state of subsets, `mask` in `[0, 1, ... 2^n-1]`. If the `i`th bit in the `mask` is `1` means `nums[i]` exists in the subset presented by `mask`.\\n- Since the `nums` array may contain duplicate numbers, so in the `2^n` subsets, it may contain duplicate subsets. \\n\\t- We need to sort `nums` array to ensure all the generated subsets will also be sorted. This helps to identify duplicates. For example: subsets {3, 1, 3}, {1, 3, 3}, {3, 3, 1} will become {1, 3, 3}.\\n\\t- We need to hash the subset and add into a HashTable, let\\'s name `seen`, to check for duplicates.\\n\\n<iframe src=\"https://leetcode.com/playground/FqjVD8Dq/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\"></iframe>\\n\\n**Complexity**\\n- Time: `O(2^N * N)`, where `N <= 10` is length of `nums` array.\\n- Space: `O(2^N)`\\n---\\n**\\u2714\\uFE0F Solution 2: Backtracking version 1 (without Hashing)**\\n- We traverse the tree in PreOrder, starting with `index = 0`, for each `index`, we iterate elements from `nums[index]...nums[n-1]`.\\n- Since the `nums` array may contain duplicate numbers, so in the `2^n` subsets, it may contain duplicate subsets. \\n\\t- We need to sort `nums` array to ensure all the generated subsets will also be sorted. This helps to identify duplicates. For example: subsets {3, 1, 3}, {1, 3, 3}, {3, 3, 1} will become {1, 3, 3}.\\n\\t- If numbers are duplicates, we keep the first time, otherwise we skips. We can see it clearly through following picture.\\n\\n![image](https://assets.leetcode.com/users/images/f2fc14d2-fcf7-4d31-8844-0489a9b83281_1628047166.1461427.png)\\n\\n```python\\nclass Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        def backtrack(index, curSubset):\\n            ans.append(curSubset[::])\\n\\n            for i in range(index, len(nums)):\\n                if i > index and nums[i] == nums[i - 1]: continue  # Skip duplicates\\n                curSubset.append(nums[i])\\n                backtrack(i + 1, curSubset)\\n                curSubset.pop()\\n\\n        nums.sort()\\n        ans = []\\n        backtrack(0, [])\\n        return ans\\n```\\n\\n**Complexity**\\n- Time: `O(2^N * N)`, where `N <= 10` is length of `nums` array.\\n- Space: `O(2^N)`\\n\\n---\\n\\n**\\u2714\\uFE0F Solution 3: Backtracking version 2 (without Hasing)**\\n- For each elements of `nums`, there are 2 options: **pick** or **don\\'t pick** that number, so there is total **2^n** possible subsets.\\n- Since the `nums` array may contain duplicate numbers, so in the `2^n` subsets, it may contain duplicate subsets. \\n\\t- We need to sort `nums` array to ensure all the generated subsets will also be sorted. This helps to identify duplicates. For example: subsets {3, 1, 3}, {1, 3, 3}, {3, 3, 1} will become {1, 3, 3}.\\n\\t-  In don\\'t pick choice, we only call it if the last element in current subset different with  `nums[i]` otherwise duplicate occurs.\\n```python\\nclass Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        def backtrack(i, curSubset):\\n            if i == len(nums):\\n                ans.append(curSubset[::])\\n                return\\n\\n            curSubset.append(nums[i])\\n            backtrack(i + 1, curSubset)  # Pick\\n            curSubset.pop()\\n\\n            if not curSubset or curSubset[-1] != nums[i]:\\n                backtrack(i + 1, curSubset)  # Don\\'t pick\\n\\n        nums.sort()\\n        ans = []\\n        backtrack(0, [])\\n        return ans\\n```\\n**Complexity**\\n- Time: `O(2^N * N)`, where `N <= 10` is length of `nums` array.\\n- Space: `O(2^N)`\\n\\n---\\n\\n**\\u2714\\uFE0F Solution 4: Iterative (with Hashing)**\\n- The idea is that we start with an empty subset.\\n- For each element `num` in `nums`, we iterate all all previous subsets, create new subsets by adding each previous subsets with `num`.\\n- For example: `nums = [1, 2, 3]`\\n\\t- First at all, `ans = [[]]`\\n\\t- Step 1, with `nums[0] = 1`, `ans = [[], [1]]`\\n\\t- Step 2, with `nums[1] = 2`, `ans = [[], [1], [2], [1, 2]]`\\n\\t- Step 3, with `nums[2] = 3`, `ans = [[], [1], [2], [1, 2], [3], [1, 3], [2, 3], [1, 2, 3]]`\\n```python\\nclass Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        nums.sort()\\n        ans = set()\\n        ans.add(tuple())\\n        \\n        for num in nums:\\n            newSubsets = set()\\n            for subset in ans:  # Iterate previous subsets from ans\\n                newSubsets.add(tuple(list(subset) + [num]))\\n            ans.update(newSubsets)  # Add new subsets to ans\\n\\t\\t\\t\\n        return ans\\n```\\n**Complexity**\\n- Time: `O(2^N * N)`, where `N <= 10` is length of `nums` array.\\n- Space: `O(2^N)`\\n\\nIf you think this **post is useful**, I\\'m happy if you **give a vote**. Any **questions or discussions are welcome!** Thank a lot.",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        def backtrack(index, curSubset):\\n            ans.append(curSubset[::])\\n\\n            for i in range(index, len(nums)):\\n                if i > index and nums[i] == nums[i - 1]: continue  # Skip duplicates\\n                curSubset.append(nums[i])\\n                backtrack(i + 1, curSubset)\\n                curSubset.pop()\\n\\n        nums.sort()\\n        ans = []\\n        backtrack(0, [])\\n        return ans\\n```\n```python\\nclass Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        def backtrack(i, curSubset):\\n            if i == len(nums):\\n                ans.append(curSubset[::])\\n                return\\n\\n            curSubset.append(nums[i])\\n            backtrack(i + 1, curSubset)  # Pick\\n            curSubset.pop()\\n\\n            if not curSubset or curSubset[-1] != nums[i]:\\n                backtrack(i + 1, curSubset)  # Don\\'t pick\\n\\n        nums.sort()\\n        ans = []\\n        backtrack(0, [])\\n        return ans\\n```\n```python\\nclass Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        nums.sort()\\n        ans = set()\\n        ans.add(tuple())\\n        \\n        for num in nums:\\n            newSubsets = set()\\n            for subset in ans:  # Iterate previous subsets from ans\\n                newSubsets.add(tuple(list(subset) + [num]))\\n            ans.update(newSubsets)  # Add new subsets to ans\\n\\t\\t\\t\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 30305,
                "title": "simple-python-solution-dfs",
                "content": "```\\nclass Solution(object):\\n    def subsetsWithDup(self, nums):\\n        ret = []\\n        self.dfs(sorted(nums), [], ret)\\n        return ret\\n    \\n    def dfs(self, nums, path, ret):\\n        ret.append(path)\\n        for i in range(len(nums)):\\n            if i > 0 and nums[i] == nums[i-1]:\\n                continue\\n            self.dfs(nums[i+1:], path+[nums[i]], ret)\\n```",
                "solutionTags": [
                    "Python",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution(object):\\n    def subsetsWithDup(self, nums):\\n        ret = []\\n        self.dfs(sorted(nums), [], ret)\\n        return ret\\n    \\n    def dfs(self, nums, path, ret):\\n        ret.append(path)\\n        for i in range(len(nums)):\\n            if i > 0 and nums[i] == nums[i-1]:\\n                continue\\n            self.dfs(nums[i+1:], path+[nums[i]], ret)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 30156,
                "title": "subset-i-ii-and-perm-i-ii-difference-explained",
                "content": "There are many good posts explaining the backtrack idea of these two topics. \\n\\nThe subset and permutation problems all have similar code. However, I did not find one that explains the difference between them. And despite the fact that they have similar code, actually they are very different.\\n\\n\\n* subset I, II\\nMy codes are similar to many others: push one element into the vector and then recursively call the function. After that pop that element out.\\n**Explanation:** The subset problem is all about **choice**, whether you want certain element inside the vector or not. For example, [1, 2, 3], starting with pos = 0. At pos = 0, you push 1 into temp, then recursively call the function. Then this reclusive call is a \"crossroad\". Inside the call (with all other calls inside), you have the \"1\" chosen and every vector you produce will begin with 1. When the call returns (ie. you pop 1 out), you are on the other road of the crossroad, which does not contain 1. These are just the first \"choice\" you are faced. And after that you face with other similar choices. \\n```\\nclass Solution {\\n    void helper(vector<vector<int>>& res, vector<int>& temp, vector<int>& nums, int pos){\\n        res.push_back(temp);\\n\\n        for(int i=pos; i<nums.size(); ++i){\\n            temp.push_back(nums[i]);\\n            helper(res, temp, nums, i + 1);\\n            temp.pop_back();\\n        }\\n\\n    }\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> res;\\n        vector<int> temp;\\n        helper(res, temp, nums, 0);\\n        return res;\\n    }\\n};\\n```\\n\\n**subset II :** Eliminate the dup with sort and then the condition: do not put this element inside, if it has same element before && the former dup has not been put into it. Because otherwise, you better off put the former dup into the vector instead of this (latter dup) one. \\n```\\nclass Solution {\\n    void helper(vector<vector<int>>& res, vector<int>& temp, vector<int>& nums, int pos){\\n        res.push_back(temp);\\n        \\n        for(int i=pos; i<nums.size(); ++i){\\n            if(i != pos && nums[i] == nums[i - 1]) continue;\\n            temp.push_back(nums[i]);\\n            helper(res, temp, nums, i + 1);\\n            temp.pop_back();\\n            \\n        }\\n    }\\n    \\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        vector<vector<int>> res;\\n        vector<int> temp;\\n        sort(nums.begin(), nums.end());\\n        helper(res, temp, nums, 0);\\n        return res;\\n    }\\n};\\n```\\n\\n* Permutation I, II\\nPermutation I is a very typical problem. \\n\\n**Note:** the pos here is different with the pos in subset. The pos in subset is more like choice in front of crossroad while the pos in permutation is the \"digit\" you are considering. In other words, you you consider the elements one by one: which one should be the first? which one should be the second? ...and so on. The **pos** is just the \"first\", \"second\"...\\n\\nWhen you consider the n**th** element, you swap the n**th** with element from n**th** to the last one, so that every element after that will have a chance to stay in the n**th** position. You recursively call, after each case.\\n\\n```\\nclass Solution {\\n    void helper(vector<vector<int>>& res, vector<int>& nums, int pos){\\n        if(nums.size() == pos){\\n            res.push_back(nums);\\n            return ;\\n        }\\n        for(int i=pos; i < nums.size(); ++i){\\n            swap(nums[i], nums[pos]);\\n            helper(res, nums, pos + 1);\\n            swap(nums[i], nums[pos]);\\n        }\\n    }\\n    \\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> res;\\n        helper(res, nums, 0);\\n        return res;\\n    }\\n};\\n```\\n\\npermutation II\\nI prefer to use the unordered_map to solve the dup problem. How does it solve the problem? because it treats all the dup as one element with several copies. \\n\\nFor example, [1, 1, 2], when you iterate, in the same \"level\", the 1 will only be put once. We only put the other 1 into the vector in the recursive call in next levels.\\n\\n```\\nclass Solution {\\n    void helper(unordered_map<int, int>& bar, vector<int>& temp, vector<vector<int>>& res, int n){\\n        if(temp.size() == n){\\n            res.push_back(temp);\\n            return ;\\n        }\\n        for(auto &i : bar){\\n            if(i.second <= 0) continue;\\n            i.second --;\\n            temp.push_back(i.first);\\n            helper(bar, temp, res, n);\\n            temp.pop_back();\\n            i.second ++;\\n        }\\n    }\\n    \\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        vector<vector<int>> res;\\n        unordered_map<int, int> bar;\\n        for(int i : nums){\\n            bar[i] ++;\\n        }\\n        vector<int> temp;\\n        helper(bar, temp, res, nums.size());\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    void helper(vector<vector<int>>& res, vector<int>& temp, vector<int>& nums, int pos){\\n        res.push_back(temp);\\n\\n        for(int i=pos; i<nums.size(); ++i){\\n            temp.push_back(nums[i]);\\n            helper(res, temp, nums, i + 1);\\n            temp.pop_back();\\n        }\\n\\n    }\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> res;\\n        vector<int> temp;\\n        helper(res, temp, nums, 0);\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    void helper(vector<vector<int>>& res, vector<int>& temp, vector<int>& nums, int pos){\\n        res.push_back(temp);\\n        \\n        for(int i=pos; i<nums.size(); ++i){\\n            if(i != pos && nums[i] == nums[i - 1]) continue;\\n            temp.push_back(nums[i]);\\n            helper(res, temp, nums, i + 1);\\n            temp.pop_back();\\n            \\n        }\\n    }\\n    \\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        vector<vector<int>> res;\\n        vector<int> temp;\\n        sort(nums.begin(), nums.end());\\n        helper(res, temp, nums, 0);\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    void helper(vector<vector<int>>& res, vector<int>& nums, int pos){\\n        if(nums.size() == pos){\\n            res.push_back(nums);\\n            return ;\\n        }\\n        for(int i=pos; i < nums.size(); ++i){\\n            swap(nums[i], nums[pos]);\\n            helper(res, nums, pos + 1);\\n            swap(nums[i], nums[pos]);\\n        }\\n    }\\n    \\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> res;\\n        helper(res, nums, 0);\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    void helper(unordered_map<int, int>& bar, vector<int>& temp, vector<vector<int>>& res, int n){\\n        if(temp.size() == n){\\n            res.push_back(temp);\\n            return ;\\n        }\\n        for(auto &i : bar){\\n            if(i.second <= 0) continue;\\n            i.second --;\\n            temp.push_back(i.first);\\n            helper(bar, temp, res, n);\\n            temp.pop_back();\\n            i.second ++;\\n        }\\n    }\\n    \\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        vector<vector<int>> res;\\n        unordered_map<int, int> bar;\\n        for(int i : nums){\\n            bar[i] ++;\\n        }\\n        vector<int> temp;\\n        helper(bar, temp, res, nums.size());\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 30150,
                "title": "very-simple-and-fast-java-solution",
                "content": "    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        Arrays.sort(nums);\\n        List<List<Integer>> res = new ArrayList<>();\\n        List<Integer> each = new ArrayList<>();\\n        helper(res, each, 0, nums);\\n        return res;\\n    }\\n    public void helper(List<List<Integer>> res, List<Integer> each, int pos, int[] n) {\\n        if (pos <= n.length) {\\n            res.add(each);\\n        }\\n        int i = pos;\\n        while (i < n.length) {\\n            each.add(n[i]);\\n            helper(res, new ArrayList<>(each), i + 1, n);\\n            each.remove(each.size() - 1);\\n            i++;\\n            while (i < n.length && n[i] == n[i - 1]) {i++;}\\n        }\\n        return;\\n    }\\n\\n\\n----------\\nThe Basic idea is: use \"while (i < n.length && n[i] == n[i - 1]) {i++;}\" to avoid the duplicate. For example, the input is 2 2 2 3 4. Consider the helper function. The process is: \\n\\n - each.add(n[i]); --> add first 2 (index 0)\\n - helper(res, new ArrayList<>(each), i + 1, n); --> go to recursion part, list each is <2 (index 0)>\\n - while (i < n.length && n[i] == n[i - 1]) {i++;} --> after this, i == 3, add the element as in subset I",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        Arrays.sort(nums);\\n        List<List<Integer>> res = new ArrayList<>();\\n        List<Integer> each = new ArrayList<>();\\n        helper(res, each, 0, nums);\\n        return res;\\n    }\\n    public void helper(List<List<Integer>> res, List<Integer> each, int pos, int[] n) {\\n        if (pos <= n.length) {\\n            res.add(each);\\n        }\\n        int i = pos;\\n        while (i < n.length) {\\n            each.add(n[i]);\\n            helper(res, new ArrayList<>(each), i + 1, n);\\n            each.remove(each.size() - 1);\\n            i++;\\n            while (i < n.length && n[i] == n[i - 1]) {i++;}\\n        }\\n        return;\\n    }\\n\\n\\n----------\\nThe Basic idea is: use \"while (i < n.length && n[i] == n[i - 1]) {i++;}\" to avoid the duplicate. For example, the input is 2 2 2 3 4. Consider the helper function. The process is: \\n\\n - each.add(n[i]); --> add first 2 (index 0)\\n - helper(res, new ArrayList<>(each), i + 1, n); --> go to recursion part, list each is <2 (index 0)>\\n - while (i < n.length && n[i] == n[i - 1]) {i++;} --> after this, i == 3, add the element as in subset I",
                "codeTag": "Unknown"
            },
            {
                "id": 429537,
                "title": "general-backtracking-questions-solutions-in-python-for-reference",
                "content": "I have taken solutions of @caikehe from frequently asked backtracking questions which I found really helpful and had copied for my reference. I thought this post will be helpful for everybody as in an interview I think these basic solutions can come in handy. Please add any more questions in comments that you think might be important and I can add it in the post.\\n\\n#### Combinations :\\n```\\ndef combine(self, n, k):\\n    res = []\\n    self.dfs(xrange(1,n+1), k, 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, k, index, path, res):\\n    #if k < 0:  #backtracking\\n        #return \\n    if k == 0:\\n        res.append(path)\\n        return # backtracking \\n    for i in xrange(index, len(nums)):\\n        self.dfs(nums, k-1, i+1, path+[nums[i]], res)\\n```  \\n\\t\\n#### Permutations I\\n```\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        self.dfs(nums, [], res)\\n        return res\\n\\n    def dfs(self, nums, path, res):\\n        if not nums:\\n            res.append(path)\\n            #return # backtracking\\n        for i in range(len(nums)):\\n            self.dfs(nums[:i]+nums[i+1:], path+[nums[i]], res)\\n```        \\n\\n#### Permutations II\\n```\\ndef permuteUnique(self, nums):\\n    res, visited = [], [False]*len(nums)\\n    nums.sort()\\n    self.dfs(nums, visited, [], res)\\n    return res\\n    \\ndef dfs(self, nums, visited, path, res):\\n    if len(nums) == len(path):\\n        res.append(path)\\n        return \\n    for i in xrange(len(nums)):\\n        if not visited[i]: \\n            if i>0 and not visited[i-1] and nums[i] == nums[i-1]:  # here should pay attention\\n                continue\\n            visited[i] = True\\n            self.dfs(nums, visited, path+[nums[i]], res)\\n            visited[i] = False\\n```\\n\\n \\n#### Subsets 1\\n\\n\\n```\\ndef subsets1(self, nums):\\n    res = []\\n    self.dfs(sorted(nums), 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, index, path, res):\\n    res.append(path)\\n    for i in xrange(index, len(nums)):\\n        self.dfs(nums, i+1, path+[nums[i]], res)\\n```\\n\\n\\n#### Subsets II  \\n\\n\\n```\\ndef subsetsWithDup(self, nums):\\n    res = []\\n    nums.sort()\\n    self.dfs(nums, 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, index, path, res):\\n    res.append(path)\\n    for i in xrange(index, len(nums)):\\n        if i > index and nums[i] == nums[i-1]:\\n            continue\\n        self.dfs(nums, i+1, path+[nums[i]], res)\\n```\\n\\n\\n#### Combination Sum        \\n\\n\\n```\\ndef combinationSum(self, candidates, target):\\n    res = []\\n    candidates.sort()\\n    self.dfs(candidates, target, 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, target, index, path, res):\\n    if target < 0:\\n        return  # backtracking\\n    if target == 0:\\n        res.append(path)\\n        return \\n    for i in xrange(index, len(nums)):\\n        self.dfs(nums, target-nums[i], i, path+[nums[i]], res)\\n```\\n\\n        \\n        \\n#### Combination Sum II        \\n\\n```\\ndef combinationSum2(self, candidates, target):\\n    res = []\\n    candidates.sort()\\n    self.dfs(candidates, target, 0, [], res)\\n    return res\\n    \\ndef dfs(self, candidates, target, index, path, res):\\n    if target < 0:\\n        return  # backtracking\\n    if target == 0:\\n        res.append(path)\\n        return  # backtracking \\n    for i in xrange(index, len(candidates)):\\n        if i > index and candidates[i] == candidates[i-1]:\\n            continue\\n        self.dfs(candidates, target-candidates[i], i+1, path+[candidates[i]], res)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking"
                ],
                "code": "```\\ndef combine(self, n, k):\\n    res = []\\n    self.dfs(xrange(1,n+1), k, 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, k, index, path, res):\\n    #if k < 0:  #backtracking\\n        #return \\n    if k == 0:\\n        res.append(path)\\n        return # backtracking \\n    for i in xrange(index, len(nums)):\\n        self.dfs(nums, k-1, i+1, path+[nums[i]], res)\\n```\n```\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        self.dfs(nums, [], res)\\n        return res\\n\\n    def dfs(self, nums, path, res):\\n        if not nums:\\n            res.append(path)\\n            #return # backtracking\\n        for i in range(len(nums)):\\n            self.dfs(nums[:i]+nums[i+1:], path+[nums[i]], res)\\n```\n```\\ndef permuteUnique(self, nums):\\n    res, visited = [], [False]*len(nums)\\n    nums.sort()\\n    self.dfs(nums, visited, [], res)\\n    return res\\n    \\ndef dfs(self, nums, visited, path, res):\\n    if len(nums) == len(path):\\n        res.append(path)\\n        return \\n    for i in xrange(len(nums)):\\n        if not visited[i]: \\n            if i>0 and not visited[i-1] and nums[i] == nums[i-1]:  # here should pay attention\\n                continue\\n            visited[i] = True\\n            self.dfs(nums, visited, path+[nums[i]], res)\\n            visited[i] = False\\n```\n```\\ndef subsets1(self, nums):\\n    res = []\\n    self.dfs(sorted(nums), 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, index, path, res):\\n    res.append(path)\\n    for i in xrange(index, len(nums)):\\n        self.dfs(nums, i+1, path+[nums[i]], res)\\n```\n```\\ndef subsetsWithDup(self, nums):\\n    res = []\\n    nums.sort()\\n    self.dfs(nums, 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, index, path, res):\\n    res.append(path)\\n    for i in xrange(index, len(nums)):\\n        if i > index and nums[i] == nums[i-1]:\\n            continue\\n        self.dfs(nums, i+1, path+[nums[i]], res)\\n```\n```\\ndef combinationSum(self, candidates, target):\\n    res = []\\n    candidates.sort()\\n    self.dfs(candidates, target, 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, target, index, path, res):\\n    if target < 0:\\n        return  # backtracking\\n    if target == 0:\\n        res.append(path)\\n        return \\n    for i in xrange(index, len(nums)):\\n        self.dfs(nums, target-nums[i], i, path+[nums[i]], res)\\n```\n```\\ndef combinationSum2(self, candidates, target):\\n    res = []\\n    candidates.sort()\\n    self.dfs(candidates, target, 0, [], res)\\n    return res\\n    \\ndef dfs(self, candidates, target, index, path, res):\\n    if target < 0:\\n        return  # backtracking\\n    if target == 0:\\n        res.append(path)\\n        return  # backtracking \\n    for i in xrange(index, len(candidates)):\\n        if i > index and candidates[i] == candidates[i-1]:\\n            continue\\n        self.dfs(candidates, target-candidates[i], i+1, path+[candidates[i]], res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 30158,
                "title": "standard-dfs-java-solution",
                "content": "    public class Solution {\\n        public List<List<Integer>> subsetsWithDup(int[] nums) {\\n            Arrays.sort(nums);\\n            List<List<Integer>> result= new ArrayList<>();\\n            dfs(nums,0,new ArrayList<Integer>(),result);\\n            return result;\\n        }\\n        \\n        public void dfs(int[] nums,int index,List<Integer> path,List<List<Integer>> result){\\n            result.add(path);\\n            for(int i=index;i<nums.length;i++){\\n                if(i>index&&nums[i]==nums[i-1]) continue;\\n                List<Integer> nPath= new ArrayList<>(path);\\n                nPath.add(nums[i]);\\n                dfs(nums,i+1,nPath,result);\\n            }\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public List<List<Integer>> subsetsWithDup(int[] nums) {\\n            Arrays.sort(nums);\\n            List<List<Integer>> result= new ArrayList<>();\\n            dfs(nums,0,new ArrayList<Integer>(),result);\\n            return result;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1380366,
                "title": "java-python-recursion-visualization",
                "content": "Constraints:\\n\\n**1 <= nums.length <= 10**\\n-10 <= nums[i] <= 10\\n\\nthe input size give us a clear hint that it is a backtracking solution, if there were no duplicates then it would easy problem to backtrack, the trick is to skip the duplicates **except the first time**.\\n**backTrack( index, currentList )** \\n\\nExample -> nums = [1,2,2,3]\\n\\n![image](https://assets.leetcode.com/users/images/faa81e48-fd2d-4cea-ba2c-6daa7d187343_1628014649.6702619.gif)\\n\\n\\nPython -\\n```\\nclass Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        result=[]\\n        nums.sort()#To handle duplicate first we sort the array ( adjacent elements will be similar )\\n        def backtrack(nums,index=0,arr=[]):\\n            result.append( arr.copy() )\\n            for i in range( index, len(nums)):\\n                if i != index and nums[i] ==nums[i-1]: #skip the duplicates, except for the first time\\n                    continue\\n                arr.append(nums[i]) #include the element\\n                backtrack(nums,i+1,arr ) #explore\\n                arr.pop() #remove the element\\n            \\n        backtrack(nums)\\n        return result\\n```\\n\\t\\t\\n\\n\\nJava version -\\n\\n```\\nclass Solution {\\n    List<List<Integer>> output;\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        Arrays.sort( nums ); //To handle duplicate first we sort the array ( adjacent elements will be similar )\\n        output = new ArrayList();\\n        backTracking( 0, nums, new ArrayList() );\\n        return output;\\n    }\\n    \\n    public void backTracking( int index, int[] nums, List<Integer> list )\\n    {\\n        output.add( new ArrayList(list) );\\n        for( int i = index;i < nums.length; i++ )\\n        {\\n            if( i != index && nums[i] == nums[i-1] ) //skip the duplicates, except for the first time\\n                continue;\\n            list.add( nums[i]); //include\\n            backTracking(i+1,nums,list); //explore\\n            list.remove( list.size()-1);//backtrack, remove the element\\n        }\\n    }\\n}\\n```\\n![image](https://assets.leetcode.com/users/images/103350e1-7c5a-4cf1-836f-0af96d3c6359_1627981167.994198.png)\\n\\nPlease **upvote** if you find it **uselful**. Thanks.\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        result=[]\\n        nums.sort()#To handle duplicate first we sort the array ( adjacent elements will be similar )\\n        def backtrack(nums,index=0,arr=[]):\\n            result.append( arr.copy() )\\n            for i in range( index, len(nums)):\\n                if i != index and nums[i] ==nums[i-1]: #skip the duplicates, except for the first time\\n                    continue\\n                arr.append(nums[i]) #include the element\\n                backtrack(nums,i+1,arr ) #explore\\n                arr.pop() #remove the element\\n            \\n        backtrack(nums)\\n        return result\\n```\n```\\nclass Solution {\\n    List<List<Integer>> output;\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        Arrays.sort( nums ); //To handle duplicate first we sort the array ( adjacent elements will be similar )\\n        output = new ArrayList();\\n        backTracking( 0, nums, new ArrayList() );\\n        return output;\\n    }\\n    \\n    public void backTracking( int index, int[] nums, List<Integer> list )\\n    {\\n        output.add( new ArrayList(list) );\\n        for( int i = index;i < nums.length; i++ )\\n        {\\n            if( i != index && nums[i] == nums[i-1] ) //skip the duplicates, except for the first time\\n                continue;\\n            list.add( nums[i]); //include\\n            backTracking(i+1,nums,list); //explore\\n            list.remove( list.size()-1);//backtrack, remove the element\\n        }\\n    }\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1488442,
                "title": "c-backtracking-faster-than-100-c-submissions",
                "content": "Approach used- Backtracking\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        vector<vector<int>> ans;       //to store all susbets\\n        vector<int> curr;         //to store current individual subset (that we will build)\\n        sort(nums.begin(),nums.end());      //sort the array so that duplicates are adjacent \\n        helper(nums,ans,curr,0);       //we start from index 0\\n        return ans;\\n        \\n    }\\n    \\n    void helper(vector<int>& nums, vector<vector<int>>& ans, vector<int>& curr, int idx){\\n        ans.push_back(curr);       //we include current susbet into final ans\\n        for(int i=idx;i<nums.size();i++){     //check for all possibilites\\n            if(i>idx &&  nums[i]==nums[i-1]) continue;      //if duplicate then we continue\\n            curr.push_back(nums[i]);     //we include nums[i] in current subset\\n            helper(nums,ans,curr,i+1); \\n            curr.pop_back();         //to get subset without nums[i]\\n        }\\n    }  \\n};\\n```\\nHope you found this useful :)\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        vector<vector<int>> ans;       //to store all susbets\\n        vector<int> curr;         //to store current individual subset (that we will build)\\n        sort(nums.begin(),nums.end());      //sort the array so that duplicates are adjacent \\n        helper(nums,ans,curr,0);       //we start from index 0\\n        return ans;\\n        \\n    }\\n    \\n    void helper(vector<int>& nums, vector<vector<int>>& ans, vector<int>& curr, int idx){\\n        ans.push_back(curr);       //we include current susbet into final ans\\n        for(int i=idx;i<nums.size();i++){     //check for all possibilites\\n            if(i>idx &&  nums[i]==nums[i-1]) continue;      //if duplicate then we continue\\n            curr.push_back(nums[i]);     //we include nums[i] in current subset\\n            helper(nums,ans,curr,i+1); \\n            curr.pop_back();         //to get subset without nums[i]\\n        }\\n    }  \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 30242,
                "title": "share-my-2ms-java-iteration-solution-very-simple-and-short",
                "content": "    \\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        Arrays.sort(nums);\\n\\t\\tList<List<Integer>> result = new ArrayList<List<Integer>>();\\n\\t\\tresult.add(new ArrayList<Integer>());\\n\\t\\tint begin = 0;\\n\\t\\tfor(int i = 0; i < nums.length; i++){\\n\\t\\t\\tif(i == 0 || nums[i] != nums[i - 1]) begin = 0;\\n\\t\\t\\tint size = result.size();\\n\\t\\t\\tfor(int j = begin; j < size; j++){\\n\\t\\t\\t\\tList<Integer> cur = new ArrayList<Integer>(result.get(j));\\n\\t\\t\\t\\tcur.add(nums[i]);\\n\\t\\t\\t\\tresult.add(cur);\\n\\t\\t\\t}\\n\\t\\t\\tbegin = size;\\n\\t\\t}\\n\\t\\treturn result;\\n    }",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "    \\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        Arrays.sort(nums);\\n\\t\\tList<List<Integer>> result = new ArrayList<List<Integer>>();\\n\\t\\tresult.add(new ArrayList<Integer>());\\n\\t\\tint begin = 0;\\n\\t\\tfor(int i = 0; i < nums.length; i++){\\n\\t\\t\\tif(i == 0 || nums[i] != nums[i - 1]) begin = 0;\\n\\t\\t\\tint size = result.size();\\n\\t\\t\\tfor(int j = begin; j < size; j++){\\n\\t\\t\\t\\tList<Integer> cur = new ArrayList<Integer>(result.get(j));\\n\\t\\t\\t\\tcur.add(nums[i]);\\n\\t\\t\\t\\tresult.add(cur);\\n\\t\\t\\t}\\n\\t\\t\\tbegin = size;\\n\\t\\t}\\n\\t\\treturn result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 750386,
                "title": "python3-dfs-solutions-to-6-different-classic-backtracking-problems-more",
                "content": "I have compiled solutions for all the 6 classic backtracking problems, you can practise them together for better understanding. Good luck with your preparation/interviews! \\n\\n[39. Combination Sum](https://leetcode.com/problems/combination-sum/)\\n```\\nclass Solution:\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        if not candidates: return []\\n        res = []\\n        candidates.sort()\\n        def dfs(idx, path, cur):\\n            if cur > target: return\\n            if cur == target:\\n                res.append(path)\\n                return\\n            for i in range(idx, len(candidates)):\\n                dfs(i, path+[candidates[i]], cur+candidates[i])\\n        dfs(0, [], 0)\\n        return res\\n```\\n\\n[40. Combination Sum II](https://leetcode.com/problems/combination-sum-ii/discuss/?currentPage=1&orderBy=recent_activity&query=)\\n```\\nclass Solution:\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        res = []\\n        candidates.sort()\\n        def dfs(idx, path, cur):\\n            if cur > target: return\\n            if cur == target:\\n                res.append(path)\\n                return\\n            for i in range(idx, len(candidates)):\\n                if i > idx and candidates[i] == candidates[i-1]:\\n                    continue\\n                dfs(i+1, path+[candidates[i]], cur+candidates[i])\\n        dfs(0, [], 0)\\n        return res\\n```\\n[78. Subsets](https://leetcode.com/problems/subsets/)\\n```\\nclass Solution:\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        def dfs(idx, path):\\n            res.append(path)\\n            for i in range(idx, len(nums)):\\n                dfs(i+1, path+[nums[i]])\\n        dfs(0, [])\\n        return res\\n```\\n\\n[90. Subsets II](https://leetcode.com/problems/subsets-ii/)\\n```\\nclass Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        nums.sort()\\n        def dfs(idx, path):\\n            res.append(path)\\n            for i in range(idx, len(nums)):\\n                if i > idx and nums[i] == nums[i-1]:\\n                    continue\\n                dfs(i+1, path+[nums[i]])\\n        dfs(0, [])\\n        return res\\n```\\n\\n[46. Permutations](https://leetcode.com/problems/permutations/)\\n```\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        def dfs(counter, path):\\n            if len(path) == len(nums):\\n                res.append(path)\\n                return\\n            for x in counter:\\n                if counter[x]:\\n                    counter[x] -= 1\\n                    dfs(counter, path+[x])\\n                    counter[x] += 1\\n        dfs(Counter(nums), [])\\n        return res \\n```\\n\\n[47. Permutations II](https://leetcode.com/problems/permutations-ii/)\\n```\\nclass Solution:\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        def dfs(counter, path):\\n            if len(path) == len(nums):\\n                res.append(path)\\n                return\\n            for x in counter:\\n                if counter[x]:\\n                    counter[x] -= 1\\n                    dfs(counter, path+[x])\\n                    counter[x] += 1\\n        dfs(Counter(nums), [])\\n        return res\\n```\\n\\nMore good backtracking problems for practice:\\n[131. Palindrome Partitioning](https://leetcode.com/problems/palindrome-partitioning/)\\n[784. Lettercase Permutation](https://leetcode.com/problems/letter-case-permutation/)\\n[1087. Brace Expansion](https://leetcode.com/problems/brace-expansion/)\\n[93. Restore IP addresses](https://leetcode.com/problems/restore-ip-addresses/)\\n[1079 Letter Tile Possibilities](https://leetcode.com/problems/letter-tile-possibilities/)",
                "solutionTags": [
                    "Python3",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        if not candidates: return []\\n        res = []\\n        candidates.sort()\\n        def dfs(idx, path, cur):\\n            if cur > target: return\\n            if cur == target:\\n                res.append(path)\\n                return\\n            for i in range(idx, len(candidates)):\\n                dfs(i, path+[candidates[i]], cur+candidates[i])\\n        dfs(0, [], 0)\\n        return res\\n```\n```\\nclass Solution:\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        res = []\\n        candidates.sort()\\n        def dfs(idx, path, cur):\\n            if cur > target: return\\n            if cur == target:\\n                res.append(path)\\n                return\\n            for i in range(idx, len(candidates)):\\n                if i > idx and candidates[i] == candidates[i-1]:\\n                    continue\\n                dfs(i+1, path+[candidates[i]], cur+candidates[i])\\n        dfs(0, [], 0)\\n        return res\\n```\n```\\nclass Solution:\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        def dfs(idx, path):\\n            res.append(path)\\n            for i in range(idx, len(nums)):\\n                dfs(i+1, path+[nums[i]])\\n        dfs(0, [])\\n        return res\\n```\n```\\nclass Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        nums.sort()\\n        def dfs(idx, path):\\n            res.append(path)\\n            for i in range(idx, len(nums)):\\n                if i > idx and nums[i] == nums[i-1]:\\n                    continue\\n                dfs(i+1, path+[nums[i]])\\n        dfs(0, [])\\n        return res\\n```\n```\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        def dfs(counter, path):\\n            if len(path) == len(nums):\\n                res.append(path)\\n                return\\n            for x in counter:\\n                if counter[x]:\\n                    counter[x] -= 1\\n                    dfs(counter, path+[x])\\n                    counter[x] += 1\\n        dfs(Counter(nums), [])\\n        return res \\n```\n```\\nclass Solution:\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        def dfs(counter, path):\\n            if len(path) == len(nums):\\n                res.append(path)\\n                return\\n            for x in counter:\\n                if counter[x]:\\n                    counter[x] -= 1\\n                    dfs(counter, path+[x])\\n                    counter[x] += 1\\n        dfs(Counter(nums), [])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 30145,
                "title": "accepted-java-iterative-solution",
                "content": "for explanation plz see comments in the code \\n\\n    public List<List<Integer>> subsetsWithDup(int[] num) {\\n        Arrays.sort(num);\\n        List<List<Integer>> ans = new ArrayList<List<Integer>>();\\n        int len = num.length;\\n        if (len == 0) return ans; \\n        \\n        ans.add(new ArrayList<Integer>()); // first, need to add the subset of num[0]\\n        ans.add(new ArrayList<Integer>());\\n        ans.get(1).add(num[0]);\\n        \\n        int nprev = 1; // this is the number of lists that the previous number was added in.\\n                     // if the current number is same as the prev one, it'll be only added in the \\n                    // lists that has the prev number.\\n                    \\n        for (int i = 1; i < len ; ++i){\\n            int size = ans.size();\\n            if (num[i]!=num[i-1])   // if different\\n                nprev = size;        // this means add num[i] to all lists in ans;\\n            for (int j = size-nprev; j < size; ++j){\\n                List<Integer> l = new ArrayList<Integer>(ans.get(j));\\n                l.add(num[i]);\\n                ans.add(l);\\n            }\\n        }\\n        return ans;\\n    }",
                "solutionTags": [],
                "code": "for explanation plz see comments in the code \\n\\n    public List<List<Integer>> subsetsWithDup(int[] num) {\\n        Arrays.sort(num);\\n        List<List<Integer>> ans = new ArrayList<List<Integer>>();\\n        int len = num.length;\\n        if (len == 0) return ans; \\n        \\n        ans.add(new ArrayList<Integer>()); // first, need to add the subset of num[0]\\n        ans.add(new ArrayList<Integer>());\\n        ans.get(1).add(num[0]);\\n        \\n        int nprev = 1; // this is the number of lists that the previous number was added in.\\n                     // if the current number is same as the prev one, it'll be only added in the \\n                    // lists that has the prev number.\\n                    \\n        for (int i = 1; i < len ; ++i){\\n            int size = ans.size();\\n            if (num[i]!=num[i-1])   // if different\\n                nprev = size;        // this means add num[i] to all lists in ans;\\n            for (int j = size-nprev; j < size; ++j){\\n                List<Integer> l = new ArrayList<Integer>(ans.get(j));\\n                l.add(num[i]);\\n                ans.add(l);\\n            }\\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1380191,
                "title": "c-simple-and-short-solution-without-recursion",
                "content": "**Explanation:**\\nFor each element in nums, we loop through all previous sets in res and create a new set by adding num to each one of them.\\n**Example:**\\nnum = [5, 6, 8]\\nWe start with one empty set. res = { {} }.\\nIteration 1: num = 5, res = { {}, {5} }.\\nIteration 2: num = 6, res = { {}, {5}, {6}, {5,6} }.\\nIteration 3: num = 8, res = { {}, {5}, {6}, {5,6}, {8}, {5,8}, {6,8}, {5,6,8} }.\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        \\n        vector<vector<int>> res = {{}};\\n        vector<int> curr;\\n        int size;\\n        \\n        for (auto num : nums) {\\n            size = res.size();\\n            \\n            for (int i = 0; i < size; i++) {\\n                curr = res[i];\\n                curr.push_back(num);\\n                if (find(res.begin(), res.end(), curr) == res.end())\\n                    res.push_back(curr);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        \\n        vector<vector<int>> res = {{}};\\n        vector<int> curr;\\n        int size;\\n        \\n        for (auto num : nums) {\\n            size = res.size();\\n            \\n            for (int i = 0; i < size; i++) {\\n                curr = res[i];\\n                curr.push_back(num);\\n                if (find(res.begin(), res.end(), curr) == res.end())\\n                    res.push_back(curr);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1095672,
                "title": "cpp-using-recursion",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>m;\\n    set<vector<int>>s;\\n    void solve(vector<int>nums,vector<int>v)\\n    {\\n        if(nums.size()==0)\\n        {\\n            \\n            if(s.find(v)==s.end())\\n            {\\n            \\n                s.insert(v);\\n                m.push_back(v);\\n                \\n            }\\n            return ;\\n        }\\n        vector<int>v1=v,v2=v;\\n        v1.push_back(nums[0]);\\n        nums.erase(nums.begin()+0);\\n        solve(nums,v1);\\n        solve(nums,v2);\\n        \\n    }\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        vector<int>op;\\n        sort(nums.begin(),nums.end());\\n        solve(nums,op);\\n        return m;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>m;\\n    set<vector<int>>s;\\n    void solve(vector<int>nums,vector<int>v)\\n    {\\n        if(nums.size()==0)\\n        {\\n            \\n            if(s.find(v)==s.end())\\n            {\\n            \\n                s.insert(v);\\n                m.push_back(v);\\n                \\n            }\\n            return ;\\n        }\\n        vector<int>v1=v,v2=v;\\n        v1.push_back(nums[0]);\\n        nums.erase(nums.begin()+0);\\n        solve(nums,v1);\\n        solve(nums,v2);\\n        \\n    }\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        vector<int>op;\\n        sort(nums.begin(),nums.end());\\n        solve(nums,op);\\n        return m;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 30325,
                "title": "java-solution-using-bit-manipulation",
                "content": "    public class Solution {\\n        public List<List<Integer>> subsetsWithDup(int[] num) {\\n            Arrays.sort(num);\\n            List<List<Integer>> lists = new ArrayList<>();\\n            int subsetNum = 1<<num.length;\\n            for(int i=0;i<subsetNum;i++){\\n                List<Integer> list = new ArrayList<>();\\n                boolean illegal=false;\\n                for(int j=0;j<num.length;j++){\\n                    if((i>>j&1)==1){\\n                        if(j>0&&num[j]==num[j-1]&&(i>>(j-1)&1)==0){\\n                            illegal=true;\\n                            break;\\n                        }else{\\n                            list.add(num[j]);\\n                        }\\n                    }\\n                }\\n                if(!illegal){\\n                   lists.add(list); \\n                }\\n                \\n            }\\n            return lists;\\n        }\\n    }\\n\\nThe idea is using every bit to represent one element in the set. The total number is 2 to num.length. Then we need to avoid duplicates. After we sort the array, the same number will be adjacent to each other. \\n\\nFor example the set is {1,1,1}. We can get subset {} and {1} first. That's great.\\nThen we need to pay attention. Suppose we have a subset x, which including the second 1 but not the first 1, x is a duplicate. \\nThat's why I write the predicate:\\nif(j>0&&num[j]==num[j-1]&&(i>>(j-1)&1)==0){\\n                            illegal=true;\\n                            break;\\n}\\n\\nHope someone can explain it better. I will go to gym now.",
                "solutionTags": [],
                "code": "class Solution {\\n        public List<List<Integer>> subsetsWithDup(int[] num) {\\n            Arrays.sort(num);\\n            List<List<Integer>> lists = new ArrayList<>();\\n            int subsetNum = 1<<num.length;\\n            for(int i=0;i<subsetNum;i++){\\n                List<Integer> list = new ArrayList<>();\\n                boolean illegal=false;\\n                for(int j=0;j<num.length;j++){\\n                    if((i>>j&1)==1){\\n                        if(j>0&&num[j]==num[j-1]&&(i>>(j-1)&1)==0){\\n                            illegal=true;\\n                            break;\\n                        }",
                "codeTag": "Java"
            },
            {
                "id": 30270,
                "title": "share-my-5-lines-of-python-solution",
                "content": "From the previous question Subsets I, the iterate solution is \\n\\n    def subsets(self, nums):\\n        res = [[]]\\n        nums.sort()\\n        for num in nums: \\n            res += [ i + [num] for i in res]\\n        return res\\n\\nFor every number in nums, we add it to every i in res. Ex. [[]], we add [] + [1] to res. The new res is [ [], [1] ]. Then add [] + [2] and [1] + [2], the new res is [[],[1],[2],[1,2]]. \\n\\nTo void the duplicate, we check if i + [num] is already in res. So the iterate solution for Subsets II is: \\n\\n    def subsetsWithDup(self, nums):\\n        res = [[]]\\n        nums.sort()\\n        for num in nums: \\n            res += [ i + [num] for i in res if i + [num] not in res]\\n        return res",
                "solutionTags": [
                    "Python"
                ],
                "code": "From the previous question Subsets I, the iterate solution is \\n\\n    def subsets(self, nums):\\n        res = [[]]\\n        nums.sort()\\n        for num in nums: \\n            res += [ i + [num] for i in res]\\n        return res\\n\\nFor every number in nums, we add it to every i in res. Ex. [[]], we add [] + [1] to res. The new res is [ [], [1] ]. Then add [] + [2] and [1] + [2], the new res is [[],[1],[2],[1,2]]. \\n\\nTo void the duplicate, we check if i + [num] is already in res. So the iterate solution for Subsets II is: \\n\\n    def subsetsWithDup(self, nums):\\n        res = [[]]\\n        nums.sort()\\n        for num in nums: \\n            res += [ i + [num] for i in res if i + [num] not in res]\\n        return res",
                "codeTag": "Python3"
            },
            {
                "id": 688517,
                "title": "python-very-very-simple-python-solution",
                "content": "```\\nclass Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        ## RC ##\\n        ## APPROACH : BACKTRACKING ##\\n        ## Similar to Leetcode : 47. Permutations II ##\\n\\n\\t\\t## TIME COMPLEXICITY : O(2^N) ##\\n\\t\\t## SPACE COMPLEXICITY : O(2^N) ##\\n\\n        def dfs(curr, nums):                          \\n            \\n            result.append(curr[:])\\n\\n            if(len(nums) == 0):                                         \\n                return\\n            \\n            for i in range(len(nums)):\\n                if i > 0 and nums[i] == nums[i-1]:        # we dont create duplicate initial branches.\\n                    continue\\n                dfs(curr + [nums[i]], nums[i+1:])         # we are sending, nums[i+1:] for next loop\\n                \\n        result = []\\n        dfs([], sorted(nums))                             \\n        return result\\n```\\nPLEASE UPVOTE IF YOU LIKE MY SOLUTION",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        ## RC ##\\n        ## APPROACH : BACKTRACKING ##\\n        ## Similar to Leetcode : 47. Permutations II ##\\n\\n\\t\\t## TIME COMPLEXICITY : O(2^N) ##\\n\\t\\t## SPACE COMPLEXICITY : O(2^N) ##\\n\\n        def dfs(curr, nums):                          \\n            \\n            result.append(curr[:])\\n\\n            if(len(nums) == 0):                                         \\n                return\\n            \\n            for i in range(len(nums)):\\n                if i > 0 and nums[i] == nums[i-1]:        # we dont create duplicate initial branches.\\n                    continue\\n                dfs(curr + [nums[i]], nums[i+1:])         # we are sending, nums[i+1:] for next loop\\n                \\n        result = []\\n        dfs([], sorted(nums))                             \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 362743,
                "title": "python3-backtracking",
                "content": "```\\nclass Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        \"\"\"\\n        level0    []\\n        level1    [1]          [2] \\n        level2    [1,2]        [2,2]\\n        level3    [1,2,2]\\n        \"\"\"\\n        nums = sorted(nums)\\n        res = []\\n        self.backtracking(res,0,[],nums)\\n        return res\\n    def backtracking(self,res,start,subset,nums):\\n        res.append(list(subset))\\n        for i in range(start,len(nums)):\\n            if i > start and nums[i] == nums[i-1]:\\n                continue\\n            subset.append(nums[i])\\n            self.backtracking(res,i+1,subset,nums)\\n            subset.pop()\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        \"\"\"\\n        level0    []\\n        level1    [1]          [2] \\n        level2    [1,2]        [2,2]\\n        level3    [1,2,2]\\n        \"\"\"\\n        nums = sorted(nums)\\n        res = []\\n        self.backtracking(res,0,[],nums)\\n        return res\\n    def backtracking(self,res,start,subset,nums):\\n        res.append(list(subset))\\n        for i in range(start,len(nums)):\\n            if i > start and nums[i] == nums[i-1]:\\n                continue\\n            subset.append(nums[i])\\n            self.backtracking(res,i+1,subset,nums)\\n            subset.pop()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3209618,
                "title": "best-c-2-solution-ever-easy-solution-backtracking-one-stop-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can solve this problem using Array + Backtracking.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can easily understand the all the approaches by seeing the code which is easy to understand with comments.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime complexity is given in code comment.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace complexity is given in code comment.\\n\\n# Code\\n```\\n/*\\n\\n    Time complexity : O(2^N*2^N), For every index, we make 2 recursion calls and there are N elements and for\\n    every subset we are checking duplicates in output and in worst case it can contain 2^N-1 subset. so total time\\n    complexity is O(2^N*2^N).\\n\\n    Space complexity : O(2^N*N), In worst case there can be 2^N-1 subsets and for every subset, we need O(N) \\n    space on average so total space complexity is O(2^N*N).\\n\\n    Solved using Array + Backtracking.\\n\\n*/\\n\\n\\n/***************************************** Approach 1 *****************************************/\\n\\nclass Solution {\\nprivate: \\n    void subsetsWithDup(vector<int>& nums, vector<vector<int>> &output, vector<int> temp, int index) {\\n        if(nums.size() == index){\\n            bool isPresent = find(output.begin(), output.end(), temp) != output.end();\\n            if(!isPresent){\\n                output.push_back(temp);\\n            }\\n            return;\\n        }\\n        subsetsWithDup(nums, output, temp, index+1);\\n        temp.push_back(nums[index]);\\n        subsetsWithDup(nums, output, temp, index+1);\\n    }\\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        vector<int> temp;\\n        vector<vector<int>> output;\\n        subsetsWithDup(nums, output, temp, 0);\\n        return output;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time complexity : O(2^N).\\n\\n    Space complexity : O(2^N*N), In worst case there can be 2^N-1 subsets and for every subset, we need O(N) \\n    space on average so total space complexity is O(2^N*N).\\n\\n    Solved using Array + Backtracking.\\n\\n*/\\n\\n\\n/***************************************** Approach 2 *****************************************/\\n\\nclass Solution {\\npublic:\\n    void solve(vector<int> &nums, vector<int> &ds, vector<vector<int>> &ans, int ind){\\n        ans.push_back(ds);\\n        for(int i=ind;i<nums.size();i++)\\n        {\\n            if(i>ind && nums[i] == nums[i-1]){\\n                continue;\\n            }\\n            ds.push_back(nums[i]);\\n            solve(nums,ds,ans,i+1);\\n            ds.pop_back();\\n        }\\n    }\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums){\\n        vector<vector<int>> ans;\\n        sort(nums.begin(),nums.end());\\n        vector<int> ds;\\n        solve(nums,ds,ans,0);\\n        return ans;\\n    }\\n};\\n\\n\\n```\\n\\n***IF YOU LIKE THE SOLUTION THEN PLEASE UPVOTE MY SOLUTION BECAUSE IT GIVES ME MOTIVATION TO REGULARLY POST THE SOLUTION.***\\n\\n![WhatsApp Image 2023-02-10 at 19.01.02.jpeg](https://assets.leetcode.com/users/images/0a95fea4-64f4-4502-82aa-41db6d77c05c_1676054939.8270252.jpeg)",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Backtracking"
                ],
                "code": "```\\n/*\\n\\n    Time complexity : O(2^N*2^N), For every index, we make 2 recursion calls and there are N elements and for\\n    every subset we are checking duplicates in output and in worst case it can contain 2^N-1 subset. so total time\\n    complexity is O(2^N*2^N).\\n\\n    Space complexity : O(2^N*N), In worst case there can be 2^N-1 subsets and for every subset, we need O(N) \\n    space on average so total space complexity is O(2^N*N).\\n\\n    Solved using Array + Backtracking.\\n\\n*/\\n\\n\\n/***************************************** Approach 1 *****************************************/\\n\\nclass Solution {\\nprivate: \\n    void subsetsWithDup(vector<int>& nums, vector<vector<int>> &output, vector<int> temp, int index) {\\n        if(nums.size() == index){\\n            bool isPresent = find(output.begin(), output.end(), temp) != output.end();\\n            if(!isPresent){\\n                output.push_back(temp);\\n            }\\n            return;\\n        }\\n        subsetsWithDup(nums, output, temp, index+1);\\n        temp.push_back(nums[index]);\\n        subsetsWithDup(nums, output, temp, index+1);\\n    }\\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        vector<int> temp;\\n        vector<vector<int>> output;\\n        subsetsWithDup(nums, output, temp, 0);\\n        return output;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time complexity : O(2^N).\\n\\n    Space complexity : O(2^N*N), In worst case there can be 2^N-1 subsets and for every subset, we need O(N) \\n    space on average so total space complexity is O(2^N*N).\\n\\n    Solved using Array + Backtracking.\\n\\n*/\\n\\n\\n/***************************************** Approach 2 *****************************************/\\n\\nclass Solution {\\npublic:\\n    void solve(vector<int> &nums, vector<int> &ds, vector<vector<int>> &ans, int ind){\\n        ans.push_back(ds);\\n        for(int i=ind;i<nums.size();i++)\\n        {\\n            if(i>ind && nums[i] == nums[i-1]){\\n                continue;\\n            }\\n            ds.push_back(nums[i]);\\n            solve(nums,ds,ans,i+1);\\n            ds.pop_back();\\n        }\\n    }\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums){\\n        vector<vector<int>> ans;\\n        sort(nums.begin(),nums.end());\\n        vector<int> ds;\\n        solve(nums,ds,ans,0);\\n        return ans;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1380314,
                "title": "python-oneliner-with-product-explained",
                "content": "It is quite classical problem and in python we can use functionality of language to make it oneliner.\\nImagine, that we have case `[1, 1, 1, 2, 2, 3]`. Then what subsets we have? We cah take:\\n1. `[], [1], [1, 1], [1, 1, 1]` when we choose how many ones we take.\\n2. `[], [2], [2, 2]` when we choose how many twos we take.\\n3. `[], [3]` when we choose how many threes we take.\\n\\nOur answer is all options when we take one element from first line, one from second and one from third and concatenate them.\\nLet us look at `[[[k]*i for i in range(v+1)] for k, v in Counter(nums).items()]` in mor details: what we have is `A = [[[], [1], [1, 1], [1, 1, 1]], [[], [2], [2, 2]], [[], [3]]]`. Now, what we need to do is to use functionality of product: we want to take elements from `A[0]`, `A[1]` and `A[2]` and for this we use trick `[chain(*i) for i in product(*A)]`, where `*` used to let product know that we want to give each element `A[0], A[1], A[2]` as parameter of product: try to do `product([[1,2,3],[4,5]])` and `product(*[[1,2,3],[4,5]])` and see the difference. The same trick is used for chain.\\n\\n#### Complexity\\nNot very tight bound for time complexity is `O(2^n*n)`, where `n` is total number of elements, space complexity as well. In fact complexity (time and space) is `O((a1+1)*...*(ak+1)*n)`, where `a1, ..., ak` are frequencies of each element.\\n\\n```python\\nclass Solution:\\n    def subsetsWithDup(self, nums):\\n        return [chain(*i) for i in product(*[[[k]*i for i in range(v+1)] for k, v in Counter(nums).items()])]\\n```\\n\\nIf you have any question, feel free to ask. If you like the explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def subsetsWithDup(self, nums):\\n        return [chain(*i) for i in product(*[[[k]*i for i in range(v+1)] for k, v in Counter(nums).items()])]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 30292,
                "title": "share-my-12ms-c-solution",
                "content": "    class Solution {\\n    public:\\n        vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n            sort(nums.begin(), nums.end());\\n            vector<vector<int>> subsets;\\n            vector<int> subset;\\n            subsetsWithDupWorker(nums, subsets, subset, 0);\\n            return subsets;\\n        }\\n    private:\\n        void subsetsWithDupWorker(const vector<int>& nums, vector<vector<int>>& subsets, vector<int>& subset, int begin) {\\n            subsets.push_back(subset);\\n            for (int i = begin; i < nums.size(); i++) {\\n                if (i != begin && nums[i] == nums[i-1]) continue;\\n                subset.push_back(nums[i]);\\n                subsetsWithDupWorker(nums, subsets, subset, i+1);\\n                subset.pop_back();\\n            }\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n            sort(nums.begin(), nums.end());\\n            vector<vector<int>> subsets;\\n            vector<int> subset;\\n            subsetsWithDupWorker(nums, subsets, subset, 0);\\n            return subsets;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1303284,
                "title": "general-approach-to-backtracking-problems-in-c",
                "content": "Below I present a general approach to many standard backtracking problems. A similar version exists for JAVA [here](https://leetcode.com/problems/subsets/discuss/27281/A-general-approach-to-backtracking-questions-in-Java-(Subsets-Permutations-Combination-Sum-Palindrome-Partitioning)) but I thought it would be a good idea to do the same for C++ as well, even though  the essence of the solutions remains the same. Most of these problems follow a single template as given below. \\n\\n```\\n//Template\\nvoid Backtrack(int start)\\n{\\n    //Base case \\n\\n// loop for all possible values\\n{\\n    //include the current element at this position if possible in the ans \\n\\t//More generally, make a choice \\n\\n    Backtrack(start+1) \\n\\n    //backtrack by removing current element \\n}\\n```\\n\\n\\n**1**.[78. Subsets](https://leetcode.com/problems/subsets/)\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& a) {\\n        vector<vector<int>> ans;\\n        vector<int> subset;\\n        n=a.size();\\n        \\n        GenerateSubs(a,0,subset,ans);\\n        return ans;      \\n    }\\nprivate:\\n    int n;\\n    void GenerateSubs(vector<int>&a,int s,vector<int>&subset,vector<vector<int>>&ans)\\n    {\\n          for(int i=s;i<n;i++)\\n        {\\n            subset.push_back(a[i]); //include element at ith position\\n            GenerateSubs(a,i+1,subset,ans); //generate all subsets including ith element\\n            subset.pop_back(); //backtrack\\n        }\\n        ans.push_back(subset);\\n    }\\n};\\n```\\n\\n**2**.[90. Subsets II](https://leetcode.com/problems/subsets-ii/) (Subsets with duplicates)\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& a) {\\n        vector<vector<int>> ans;\\n        vector<int> subset;\\n        n=a.size();\\n        \\n        sort(a.begin(),a.end()); //sort the elements so that we can keep track of duplicates\\n        GenerateSubs(a,0,subset,ans);\\n        return ans;    \\n    }\\nprivate:\\n    int n;\\n    void GenerateSubs(vector<int>&a,int s,vector<int>&subset,vector<vector<int>>&ans)\\n    {\\n        for(int i=s;i<n;i++)\\n        {\\n            if(i==s||a[i]!=a[i-1]) \\n            {\\n              subset.push_back(a[i]); //include element at ith position\\n              GenerateSubs(a,i+1,subset,ans); //generate all subsets including ith element\\n              subset.pop_back(); //backtrack\\n            }\\n        }\\n        ans.push_back(subset);\\n    }\\n};\\n```\\n\\n**3.** [77. Combinations](https://leetcode.com/problems/combinations/)\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combine(int n, int k) {\\n        vector<vector<int>> ans;\\n        vector<int> combination;\\n        \\n        GenerateCombs(n,1,k,ans,combination);\\n        return ans;\\n    }\\nprivate:\\n    void GenerateCombs(int n,int s,int k,vector<vector<int>> &ans,vector<int> &combination)\\n    {\\n        if(combination.size()==k) //base case\\n        {\\n            ans.push_back(combination);\\n            return;\\n        }\\n        \\n        for(int i=s;i<=n;i++)\\n        {\\n            combination.push_back(i); //include i in a combination\\n            GenerateCombs(n,i+1,k,ans,combination);\\n            combination.pop_back(); //remove i, i.e. backtrack\\n        }\\n    }\\n};\\n```\\n\\n**4.** [39. Combination Sum\\n](https://leetcode.com/problems/combination-sum/)\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum(vector<int>& a, int sum) {\\n        n=a.size();\\n        sort(a.begin(),a.end()); // optimising by only including elements smaller than sum\\n        combs(a,0,sum);\\n        \\n        return ans;\\n        \\n    }\\nprivate:\\n    vector<vector<int>>ans;\\n    vector<int> combination;\\n    int n;\\n    \\n    void combs(vector<int>&a,int s,int sum)\\n    {\\n        if(sum<0) //base case1\\n            return;\\n        \\n        if(sum==0)\\n        {\\n            ans.push_back(combination); //base case 2\\n            return;\\n        }\\n        \\n        for(int i=s;i<n&&a[i]<=sum;i++)\\n        {\\n            combination.push_back(a[i]);\\n            combs(a,i,sum-a[i]);\\n            combination.pop_back();\\n        }\\n    }  \\n};\\n```\\n\\n**5.** [40. Combination Sum II\\n](https://leetcode.com/problems/combination-sum-ii/)\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& a, int sum) {\\n        n=a.size();\\n        sort(a.begin(),a.end()); // optimising by only including elements smaller than sum\\n        combs(a,0,sum);\\n        \\n        return ans;\\n        \\n    }\\nprivate:\\n    vector<vector<int>>ans;\\n    vector<int> combination;\\n    int n;\\n    \\n    void combs(vector<int>&a,int s,int sum)\\n    {\\n        if(sum<0)\\n            return;\\n        \\n        if(sum==0)\\n        {\\n            ans.push_back(combination);\\n            return;\\n        }\\n        \\n        for(int i=s;i<n&&a[i]<=sum;i++)\\n        {\\n                \\n            if(i==s||a[i]!=a[i-1])\\n            {\\n             combination.push_back(a[i]);\\n             combs(a,i+1,sum-a[i]);\\n             combination.pop_back();   \\n            }\\n        }\\n    }\\n};\\n```\\n\\n**6.**  [22. Generate Parentheses](https://leetcode.com/problems/generate-parentheses/)\\n```\\nclass Solution {\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        string s;\\n        Generate(0,0,s,n);\\n        return ans;\\n    }\\nprivate:\\n    vector<string>ans;\\n    void Generate(int left,int right,string &s,int n)\\n    {\\n        if(left==n&&right==n) // base case: when left and right parentheses are equal to n.\\n        {\\n            ans.push_back(s);\\n            return;\\n        }\\n\\t\\t\\n        // case I: if left parenteses are less than n, we can add a ( to the string. \\n\\t\\t//But we might also add a ) so we backtrack by poppping it.\\n        if(left<n)\\n\\t\\t{\\n            s+=\\'(\\';\\n            Generate(left+1,right,s,n);\\n            s.pop_back(); \\n        }\\n        \\n        if(left>right) //case II: follows from I.\\n        {\\n            s+=\\')\\';\\n            Generate(left,right+1,s,n);\\n            s.pop_back();\\n        } \\n    }\\n};\\n```\\n\\n**7.** [131. Palindrome Partitioning](https://leetcode.com/problems/palindrome-partitioning/)\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> partition(string s) {\\n        n=s.size();\\n        Generate(s,0);\\n        return ans;   \\n    }\\nprivate:\\n    vector<vector<string>>ans;\\n    vector<string>Partition;\\n    int n;\\n    \\n    bool is_pal(string &s,int start,int end)\\n    {\\n        while(start<=end)\\n        {\\n            if(s[start++]!=s[end--])\\n                return false;\\n        }\\n        return true;\\n    }\\n    \\n    void Generate(string &s,int start)\\n    {\\n        if(start==n)\\n        {\\n            ans.push_back(Partition);\\n            return;\\n        }\\n        \\n        for(int i=start;i<n;i++)\\n        {\\n            if(is_pal(s,start,i))\\n            {\\n                Partition.push_back(s.substr(start,i-start+1));\\n                Generate(s,i+1);\\n                Partition.pop_back();\\n            }\\n        }\\n    } \\n};\\n```\\n\\n**8.** [46. Permutations](https://leetcode.com/problems/permutations/)\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> permute(vector<int>& arr) {\\n        vector<vector<int>> ans;\\n        \\n        permutations(arr,0,ans);\\n        \\n        return ans;\\n    }\\n    void permutations(vector<int>&arr,int s,vector<vector<int>>&ans)\\n    {\\n        if(s==arr.size())\\n        {\\n            ans.push_back(arr);\\n            return;\\n        }\\n        for(int i=s;i<arr.size();i++)\\n        {\\n            swap(arr[s],arr[i]);\\n            permutations(arr,s+1,ans);\\n            swap(arr[s],arr[i]);\\n        }\\n    }\\n};\\n```\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\n//Template\\nvoid Backtrack(int start)\\n{\\n    //Base case \\n\\n// loop for all possible values\\n{\\n    //include the current element at this position if possible in the ans \\n\\t//More generally, make a choice \\n\\n    Backtrack(start+1) \\n\\n    //backtrack by removing current element \\n}\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& a) {\\n        vector<vector<int>> ans;\\n        vector<int> subset;\\n        n=a.size();\\n        \\n        GenerateSubs(a,0,subset,ans);\\n        return ans;      \\n    }\\nprivate:\\n    int n;\\n    void GenerateSubs(vector<int>&a,int s,vector<int>&subset,vector<vector<int>>&ans)\\n    {\\n          for(int i=s;i<n;i++)\\n        {\\n            subset.push_back(a[i]); //include element at ith position\\n            GenerateSubs(a,i+1,subset,ans); //generate all subsets including ith element\\n            subset.pop_back(); //backtrack\\n        }\\n        ans.push_back(subset);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& a) {\\n        vector<vector<int>> ans;\\n        vector<int> subset;\\n        n=a.size();\\n        \\n        sort(a.begin(),a.end()); //sort the elements so that we can keep track of duplicates\\n        GenerateSubs(a,0,subset,ans);\\n        return ans;    \\n    }\\nprivate:\\n    int n;\\n    void GenerateSubs(vector<int>&a,int s,vector<int>&subset,vector<vector<int>>&ans)\\n    {\\n        for(int i=s;i<n;i++)\\n        {\\n            if(i==s||a[i]!=a[i-1]) \\n            {\\n              subset.push_back(a[i]); //include element at ith position\\n              GenerateSubs(a,i+1,subset,ans); //generate all subsets including ith element\\n              subset.pop_back(); //backtrack\\n            }\\n        }\\n        ans.push_back(subset);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combine(int n, int k) {\\n        vector<vector<int>> ans;\\n        vector<int> combination;\\n        \\n        GenerateCombs(n,1,k,ans,combination);\\n        return ans;\\n    }\\nprivate:\\n    void GenerateCombs(int n,int s,int k,vector<vector<int>> &ans,vector<int> &combination)\\n    {\\n        if(combination.size()==k) //base case\\n        {\\n            ans.push_back(combination);\\n            return;\\n        }\\n        \\n        for(int i=s;i<=n;i++)\\n        {\\n            combination.push_back(i); //include i in a combination\\n            GenerateCombs(n,i+1,k,ans,combination);\\n            combination.pop_back(); //remove i, i.e. backtrack\\n        }\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum(vector<int>& a, int sum) {\\n        n=a.size();\\n        sort(a.begin(),a.end()); // optimising by only including elements smaller than sum\\n        combs(a,0,sum);\\n        \\n        return ans;\\n        \\n    }\\nprivate:\\n    vector<vector<int>>ans;\\n    vector<int> combination;\\n    int n;\\n    \\n    void combs(vector<int>&a,int s,int sum)\\n    {\\n        if(sum<0) //base case1\\n            return;\\n        \\n        if(sum==0)\\n        {\\n            ans.push_back(combination); //base case 2\\n            return;\\n        }\\n        \\n        for(int i=s;i<n&&a[i]<=sum;i++)\\n        {\\n            combination.push_back(a[i]);\\n            combs(a,i,sum-a[i]);\\n            combination.pop_back();\\n        }\\n    }  \\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& a, int sum) {\\n        n=a.size();\\n        sort(a.begin(),a.end()); // optimising by only including elements smaller than sum\\n        combs(a,0,sum);\\n        \\n        return ans;\\n        \\n    }\\nprivate:\\n    vector<vector<int>>ans;\\n    vector<int> combination;\\n    int n;\\n    \\n    void combs(vector<int>&a,int s,int sum)\\n    {\\n        if(sum<0)\\n            return;\\n        \\n        if(sum==0)\\n        {\\n            ans.push_back(combination);\\n            return;\\n        }\\n        \\n        for(int i=s;i<n&&a[i]<=sum;i++)\\n        {\\n                \\n            if(i==s||a[i]!=a[i-1])\\n            {\\n             combination.push_back(a[i]);\\n             combs(a,i+1,sum-a[i]);\\n             combination.pop_back();   \\n            }\\n        }\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        string s;\\n        Generate(0,0,s,n);\\n        return ans;\\n    }\\nprivate:\\n    vector<string>ans;\\n    void Generate(int left,int right,string &s,int n)\\n    {\\n        if(left==n&&right==n) // base case: when left and right parentheses are equal to n.\\n        {\\n            ans.push_back(s);\\n            return;\\n        }\\n\\t\\t\\n        // case I: if left parenteses are less than n, we can add a ( to the string. \\n\\t\\t//But we might also add a ) so we backtrack by poppping it.\\n        if(left<n)\\n\\t\\t{\\n            s+=\\'(\\';\\n            Generate(left+1,right,s,n);\\n            s.pop_back(); \\n        }\\n        \\n        if(left>right) //case II: follows from I.\\n        {\\n            s+=\\')\\';\\n            Generate(left,right+1,s,n);\\n            s.pop_back();\\n        } \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> partition(string s) {\\n        n=s.size();\\n        Generate(s,0);\\n        return ans;   \\n    }\\nprivate:\\n    vector<vector<string>>ans;\\n    vector<string>Partition;\\n    int n;\\n    \\n    bool is_pal(string &s,int start,int end)\\n    {\\n        while(start<=end)\\n        {\\n            if(s[start++]!=s[end--])\\n                return false;\\n        }\\n        return true;\\n    }\\n    \\n    void Generate(string &s,int start)\\n    {\\n        if(start==n)\\n        {\\n            ans.push_back(Partition);\\n            return;\\n        }\\n        \\n        for(int i=start;i<n;i++)\\n        {\\n            if(is_pal(s,start,i))\\n            {\\n                Partition.push_back(s.substr(start,i-start+1));\\n                Generate(s,i+1);\\n                Partition.pop_back();\\n            }\\n        }\\n    } \\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> permute(vector<int>& arr) {\\n        vector<vector<int>> ans;\\n        \\n        permutations(arr,0,ans);\\n        \\n        return ans;\\n    }\\n    void permutations(vector<int>&arr,int s,vector<vector<int>>&ans)\\n    {\\n        if(s==arr.size())\\n        {\\n            ans.push_back(arr);\\n            return;\\n        }\\n        for(int i=s;i<arr.size();i++)\\n        {\\n            swap(arr[s],arr[i]);\\n            permutations(arr,s+1,ans);\\n            swap(arr[s],arr[i]);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 250020,
                "title": "c-recursive-and-iterative",
                "content": "To skip duplicates, sort `nums`.\\n\\n**Recursive (Backtracking)**\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        vector<vector<int>> subs;\\n        vector<int> sub;\\n        subsets(nums, 0, sub, subs);\\n        return subs;\\n    }\\nprivate:\\n    void subsets(vector<int>& nums, int i, vector<int>& sub, vector<vector<int>>& subs) {\\n        subs.push_back(sub);\\n        for (int j = i; j < nums.size(); j++) {\\n            if (j == i || nums[j] != nums[j - 1]) {\\n                sub.push_back(nums[j]);\\n                subsets(nums, j + 1, sub, subs);\\n                sub.pop_back();\\n            }\\n        }\\n    }\\n};\\n```\\n\\n**Iterative**\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        vector<vector<int>> subs = {{}};\\n        for (int i = 0, n = 0; i < nums.size(); i++) {\\n            int j = !i || nums[i] != nums[i - 1] ? 0 : n;\\n            n = subs.size();\\n            for (; j < n; j++) {\\n                subs.push_back(subs[j]);\\n                subs.back().push_back(nums[i]);\\n            }\\n        }\\n        return subs;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        vector<vector<int>> subs;\\n        vector<int> sub;\\n        subsets(nums, 0, sub, subs);\\n        return subs;\\n    }\\nprivate:\\n    void subsets(vector<int>& nums, int i, vector<int>& sub, vector<vector<int>>& subs) {\\n        subs.push_back(sub);\\n        for (int j = i; j < nums.size(); j++) {\\n            if (j == i || nums[j] != nums[j - 1]) {\\n                sub.push_back(nums[j]);\\n                subsets(nums, j + 1, sub, subs);\\n                sub.pop_back();\\n            }\\n        }\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        vector<vector<int>> subs = {{}};\\n        for (int i = 0, n = 0; i < nums.size(); i++) {\\n            int j = !i || nums[i] != nums[i - 1] ? 0 : n;\\n            n = subs.size();\\n            for (; j < n; j++) {\\n                subs.push_back(subs[j]);\\n                subs.back().push_back(nums[i]);\\n            }\\n        }\\n        return subs;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 30304,
                "title": "48ms-solution-with-subset-construction-method",
                "content": "One possible solution is to generate all possible subset using bit-mask, and use a set to test the existence of a subset. However, this method may generate duplicate subsets during the process, and has unsatisfiable time complexity. E.g. for input <1 1 1 1 1 1 1 1 1>, the above method will generate too many duplicate subsets.\\n\\nI use a subset construction method, whose mechanism is illustrated with an example:\\n\\ninput: <1 2 2 3 3 3> (assumed to be sorted)\\n\\ninitialization: empty set <>. ret = {<>}\\n\\nfor element 1, add it to ret, and we get: <1>. ret = {<> <1>}\\n\\nfor element 2, add it to ret, and we get: <2> <1 2>; however, notice that we have two elements of 2, hence we further need to add <2 2> to {<> <1>}, and get <2 2> <1 2 2>. ret = {<> <1> <2> <1 2> <2 2> <1 2 2>}\\n\\nfor element 3, we newly construct the following:              \\n<3> <1 3> <2 3> <1 2 3> < 2 2 3> < 1 2 2 3>             \\n<3 3> <1 3 3> <2 3 3> <1 2 3 3> <2 2 3 3> <1 2 2 3 3>             \\n<3 3 3> <1 3 3 3> < 2 3 3 3> <1 2 3 3 3> <2 2 3 3 3> <1 2 2 3 3 3>                 \\nfinally, ret = {<> <1> <2> <1 2> <2 2> <1 2 2>   \\n<3> <1 3> <2 3> <1 2 3> < 2 2 3> < 1 2 2 3>   \\n<3 3> <1 3 3> <2 3 3> <1 2 3 3> <2 2 3 3> <1 2 2 3 3>   \\n<3 3 3> <1 3 3 3> < 2 3 3 3> <1 2 3 3 3> <2 2 3 3 3> <1 2 2 3 3 3>\\n}\\n\\n    class Solution {\\n    public:\\n        vector<vector<int> > subsetsWithDup(vector<int> &S) {\\n            vector<vector<int> > ret;\\n            ret.push_back(vector<int>());\\n            sort(S.begin(), S.end());\\n            for (int i = 0; i < S.size(); ) {\\n                int j = i;\\n                while (j < S.size() && S[j] == S[i]) j++;\\n                int size = ret.size();\\n                for (int len = 1; i + len <= j; len++) {\\n                    for (int cnt = 0; cnt < size; cnt++) {\\n                        vector<int> subset(ret[cnt]);\\n                        for (int k = 0; k < len; k++) subset.push_back(S[i]);\\n                        ret.push_back(subset);\\n                    }\\n                }\\n                i = j;\\n            }\\n            return ret;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<vector<int> > subsetsWithDup(vector<int> &S) {\\n            vector<vector<int> > ret;\\n            ret.push_back(vector<int>());\\n            sort(S.begin(), S.end());\\n            for (int i = 0; i < S.size(); ) {\\n                int j = i;\\n                while (j < S.size() && S[j] == S[i]) j++;\\n                int size = ret.size();\\n                for (int len = 1; i + len <= j; len++) {\\n                    for (int cnt = 0; cnt < size; cnt++) {\\n                        vector<int> subset(ret[cnt]);\\n                        for (int k = 0; k < len; k++) subset.push_back(S[i]);\\n                        ret.push_back(subset);\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 2697523,
                "title": "c-clean-code-subset-ii-brute-force-and-optimized",
                "content": "**1. Brute Force : Generate all subsets (Subset-II)** \\n\\n**Time Complexity :** **`O(2^n*( klog(x) )).2^n`**\\n**Space Complexity :** **`O(2^n * k)`**\\n```\\nclass Solution{\\npublic:\\n    \\n    void solve(vector<int>&nums, int i, vector<int>ds, set<vector<int>>&st) \\n    {\\n        if(i == nums.size()) \\n        {\\n            sort(ds.begin(), ds.end());\\n            st.insert(ds);\\n            return;\\n        }\\n        \\n        ds.push_back(nums[i]);\\n        solve(nums, i + 1, ds, st);\\n        ds.pop_back();\\n        solve(nums, i + 1, ds, st);\\n    }\\n    \\n    vector<vector<int>>subsetsWithDup(vector<int>& nums) \\n    {\\n        vector<vector<int>>ans;\\n        set<vector<int>>st;\\n        vector<int>ds;\\n        \\n        solve(nums, 0, ds, st);\\n        for(auto &v : st) \\n            ans.push_back(v);\\n        return ans;\\n    }\\n};\\n```\\n\\n**2. More Optimized - (Subset-II)**  \\n\\n**Time Complexity :** **`O(k * 2^n)`**\\n**Space Complexity :** **`O(2^n * k)`**\\n```\\nclass Solution {\\npublic:\\n    \\n    void solve(int ind, vector<int>&nums, vector<int>&path, vector<vector<int>>&paths)\\n    {\\n        paths.push_back(path);\\n        \\n        for(int i=ind;i<nums.size();i++)\\n        {    \\n            if(i!=ind and nums[i] == nums[i-1]) continue; // To avoid duplicate subsets\\n            \\n            path.push_back(nums[i]);\\n            solve(i+1, nums, path, paths);\\n            path.pop_back();\\n        }\\n    }\\n    \\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) \\n    {    \\n        vector<vector<int>>paths;\\n        vector<int>path;\\n        sort(nums.begin(), nums.end()); // sorting is most important --- so that order of duplicate subsets is same\\n        solve(0, nums, path, paths);    // [1,4,4] == [4,1,4] , both are same so no need to include both in answer\\n        return paths; \\n    }\\n};\\n```\\n***Thanks for Upvoting !***\\n\\uD83D\\uDE42",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution{\\npublic:\\n    \\n    void solve(vector<int>&nums, int i, vector<int>ds, set<vector<int>>&st) \\n    {\\n        if(i == nums.size()) \\n        {\\n            sort(ds.begin(), ds.end());\\n            st.insert(ds);\\n            return;\\n        }\\n        \\n        ds.push_back(nums[i]);\\n        solve(nums, i + 1, ds, st);\\n        ds.pop_back();\\n        solve(nums, i + 1, ds, st);\\n    }\\n    \\n    vector<vector<int>>subsetsWithDup(vector<int>& nums) \\n    {\\n        vector<vector<int>>ans;\\n        set<vector<int>>st;\\n        vector<int>ds;\\n        \\n        solve(nums, 0, ds, st);\\n        for(auto &v : st) \\n            ans.push_back(v);\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    void solve(int ind, vector<int>&nums, vector<int>&path, vector<vector<int>>&paths)\\n    {\\n        paths.push_back(path);\\n        \\n        for(int i=ind;i<nums.size();i++)\\n        {    \\n            if(i!=ind and nums[i] == nums[i-1]) continue; // To avoid duplicate subsets\\n            \\n            path.push_back(nums[i]);\\n            solve(i+1, nums, path, paths);\\n            path.pop_back();\\n        }\\n    }\\n    \\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) \\n    {    \\n        vector<vector<int>>paths;\\n        vector<int>path;\\n        sort(nums.begin(), nums.end()); // sorting is most important --- so that order of duplicate subsets is same\\n        solve(0, nums, path, paths);    // [1,4,4] == [4,1,4] , both are same so no need to include both in answer\\n        return paths; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1921938,
                "title": "100-fastest-swift-solution",
                "content": "```\\nclass Solution {\\n    func subsetsWithDup(_ nums: [Int]) -> [[Int]] {\\n        var ans = Set<[Int]>()\\n        var comb = [Int]()\\n        \\n        subset(nums.sorted(), 0, &comb, &ans)\\n        return Array(ans)\\n    }\\n    \\n    \\n    func subset(_ nums: [Int], _ index: Int, _ comb: inout [Int], _ ans: inout Set<[Int]>) {\\n        if index >= nums.count {\\n            ans.insert(comb)\\n            \\n        } else {\\n            subset(nums, index+1, &comb, &ans)\\n            \\n            comb.append(nums[index])\\n            subset(nums, index+1, &comb, &ans)\\n            comb.removeLast()\\n        }\\n    }\\n    \\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func subsetsWithDup(_ nums: [Int]) -> [[Int]] {\\n        var ans = Set<[Int]>()\\n        var comb = [Int]()\\n        \\n        subset(nums.sorted(), 0, &comb, &ans)\\n        return Array(ans)\\n    }\\n    \\n    \\n    func subset(_ nums: [Int], _ index: Int, _ comb: inout [Int], _ ans: inout Set<[Int]>) {\\n        if index >= nums.count {\\n            ans.insert(comb)\\n            \\n        } else {\\n            subset(nums, index+1, &comb, &ans)\\n            \\n            comb.append(nums[index])\\n            subset(nums, index+1, &comb, &ans)\\n            comb.removeLast()\\n        }\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1549662,
                "title": "java-tc-o-n-2-n-sc-o-uniquenums-space-optimized-iterative-backtracking-solutions",
                "content": "**Space Optimized Iterative Solution. This solution takes only O(Unique Nums) for countMap**\\n\\n```java\\n/**\\n * Space Optimized Iterative Solution\\n *\\n * S(n) = (0 \\xD7 (n C 0) + 1 \\xD7 (n C 1) + 2 \\xD7 (n C 2) + \\u2026 + n \\xD7 (n C n))\\n * Note that (n C k) = (n C n-k). Therefore:\\n * S(n) = 0 \\xD7 (n C n) + 1 \\xD7 (n C n-1) + 2 \\xD7 (n C n-2) + \\u2026 + n \\xD7 (n C 0)\\n * If we add these two together, we get\\n * 2S(n) = n \\xD7 (n C 0) + n \\xD7 (n C 1) + \\u2026 + n \\xD7 (n C n)\\n *       = n \\xD7 (n C 0 + n C 1 + \\u2026 + n C n)\\n * As per binomial theorem, (n C 0 + n C 1 + \\u2026 + n C n) = 2^n, so\\n * 2*S(n) = n * 2^n => S(n) = n * 2^(n-1)\\n *\\n * Time Complexity: O(S(N) + n C 0) = O(N * 2^(N-1) + 1) = O(N * 2^N)\\n *\\n * Space Complexity: O(Unique Nums) (Excluding the result space)\\n *\\n * N = Length of input nums array\\n */\\nclass Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        if (nums == null) {\\n            return result;\\n        }\\n\\n        Map<Integer, Integer> countMap = new HashMap<>();\\n        for (int n : nums) {\\n            countMap.put(n, countMap.getOrDefault(n, 0) + 1);\\n        }\\n\\n        result.add(new ArrayList<>());\\n\\n        for (int n : countMap.keySet()) {\\n            int size = result.size();\\n            int count = countMap.get(n);\\n\\n            for (int i = 0; i < size; i++) {\\n                List<Integer> cur = result.get(i);\\n                for (int k = 0; k < count; k++) {\\n                    List<Integer> temp = new ArrayList<>(cur);\\n                    temp.add(n);\\n                    result.add(temp);\\n                    cur = temp;\\n                }\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```\\n\\n---\\n**Backtracking (Recursion). This solution take O(N + Unique Nums) space for recursion depth, temp list and countMap**\\n\\n```java\\n/**\\n * Backtracking (Recursion)\\n *\\n * Time Complexity: O(N * 2 ^ N) Refer to above explanation\\n *\\n * Space Complexity: O(N + Unique Nums)\\n *\\n * N = Length of input nums array\\n */\\nclass Solution1 {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        if (nums == null) {\\n            return result;\\n        }\\n\\t\\t\\n\\t\\t// Avoid sorting by using a count Map\\n        Map<Integer, Integer> countMap = new HashMap<>();\\n        for (int n : nums) {\\n            countMap.put(n, countMap.getOrDefault(n, 0) + 1);\\n        }\\n\\n        subsetsWithDupHelper(countMap, new ArrayList<>(countMap.keySet()), 0, new ArrayList<>(), result);\\n        return result;\\n    }\\n\\n    private void subsetsWithDupHelper(Map<Integer, Integer> countMap, List<Integer> uniqueNums,\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t  int start, List<Integer> temp, List<List<Integer>> result) {\\n        result.add(new ArrayList<>(temp));\\n\\n        for (int i = start; i < uniqueNums.size(); i++) {\\n            int num = uniqueNums.get(i);\\n            int count = countMap.get(num);\\n            temp.add(num);\\n            countMap.put(num, count - 1);\\n\\n            subsetsWithDupHelper(countMap, uniqueNums, (count == 1 ? i + 1 : i), temp, result);\\n\\n            countMap.put(num, count);\\n            temp.remove(temp.size() - 1);\\n        }\\n    }\\n}\\n```\\n\\n---\\n\\nSolutions to other Subsets questions on LeetCode:\\n- [78. Subsets](https://leetcode.com/problems/subsets/discuss/1549657/Java-or-TC:-O(N*2N)-or-SC:-O(1)-or-Constant-Space-Iterative-and-Backtracking-solutions)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\n/**\\n * Space Optimized Iterative Solution\\n *\\n * S(n) = (0 \\xD7 (n C 0) + 1 \\xD7 (n C 1) + 2 \\xD7 (n C 2) + \\u2026 + n \\xD7 (n C n))\\n * Note that (n C k) = (n C n-k). Therefore:\\n * S(n) = 0 \\xD7 (n C n) + 1 \\xD7 (n C n-1) + 2 \\xD7 (n C n-2) + \\u2026 + n \\xD7 (n C 0)\\n * If we add these two together, we get\\n * 2S(n) = n \\xD7 (n C 0) + n \\xD7 (n C 1) + \\u2026 + n \\xD7 (n C n)\\n *       = n \\xD7 (n C 0 + n C 1 + \\u2026 + n C n)\\n * As per binomial theorem, (n C 0 + n C 1 + \\u2026 + n C n) = 2^n, so\\n * 2*S(n) = n * 2^n => S(n) = n * 2^(n-1)\\n *\\n * Time Complexity: O(S(N) + n C 0) = O(N * 2^(N-1) + 1) = O(N * 2^N)\\n *\\n * Space Complexity: O(Unique Nums) (Excluding the result space)\\n *\\n * N = Length of input nums array\\n */\\nclass Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        if (nums == null) {\\n            return result;\\n        }\\n\\n        Map<Integer, Integer> countMap = new HashMap<>();\\n        for (int n : nums) {\\n            countMap.put(n, countMap.getOrDefault(n, 0) + 1);\\n        }\\n\\n        result.add(new ArrayList<>());\\n\\n        for (int n : countMap.keySet()) {\\n            int size = result.size();\\n            int count = countMap.get(n);\\n\\n            for (int i = 0; i < size; i++) {\\n                List<Integer> cur = result.get(i);\\n                for (int k = 0; k < count; k++) {\\n                    List<Integer> temp = new ArrayList<>(cur);\\n                    temp.add(n);\\n                    result.add(temp);\\n                    cur = temp;\\n                }\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```\n```java\\n/**\\n * Backtracking (Recursion)\\n *\\n * Time Complexity: O(N * 2 ^ N) Refer to above explanation\\n *\\n * Space Complexity: O(N + Unique Nums)\\n *\\n * N = Length of input nums array\\n */\\nclass Solution1 {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        if (nums == null) {\\n            return result;\\n        }\\n\\t\\t\\n\\t\\t// Avoid sorting by using a count Map\\n        Map<Integer, Integer> countMap = new HashMap<>();\\n        for (int n : nums) {\\n            countMap.put(n, countMap.getOrDefault(n, 0) + 1);\\n        }\\n\\n        subsetsWithDupHelper(countMap, new ArrayList<>(countMap.keySet()), 0, new ArrayList<>(), result);\\n        return result;\\n    }\\n\\n    private void subsetsWithDupHelper(Map<Integer, Integer> countMap, List<Integer> uniqueNums,\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t  int start, List<Integer> temp, List<List<Integer>> result) {\\n        result.add(new ArrayList<>(temp));\\n\\n        for (int i = start; i < uniqueNums.size(); i++) {\\n            int num = uniqueNums.get(i);\\n            int count = countMap.get(num);\\n            temp.add(num);\\n            countMap.put(num, count - 1);\\n\\n            subsetsWithDupHelper(countMap, uniqueNums, (count == 1 ? i + 1 : i), temp, result);\\n\\n            countMap.put(num, count);\\n            temp.remove(temp.size() - 1);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1380213,
                "title": "subset-ii-2-approaches-backtracking-iterative-c-java-python",
                "content": "**THIS PROBLEM IS VERY SIMILAR TO [THIS PROBLEM](https://leetcode.com/problems/subsets/)**\\n**NOW COMING TO THE PROBLEM AT HAND**\\n**OBSERVATION TO BE MADE:**\\n* If there are no duplicates the answer is directly `2^N`\\n\\t* This is because you have two choices for each element, either putting it into the subset or not.\\n\\n# **APPORACH I: Iterative**\\n**Algorithm:**\\nSuppose we have {1,2,3,3,3}\\nNow after each iteration our 2-d vector becomes like this-\\n```\\n1. null\\n2. null | 1\\n3. null | 1 | 2 ; 1,2\\n4. null | 1 | 2 ; 1,2 | 3; 1,3; 2,3; 1,2,3\\n5. null | 1 | 2 ; 1,2 | 3; 1,3; 2,3; 1,2,3 | 3,3; 1,3,3; 2,3,3; 1,2,3,3\\n6. null | 1 | 2 ; 1,2 | 3; 1,3; 2,3; 1,2,3 | 3,3; 1,3,3; 2,3,3; 1,2,3,3 | 3,3,3; 1,3,3,3; 2,3,3,3; 1,2,3,3,3\\n```\\nIf the number is a duplicate one, we just need to add this number to the last created subsets in the previous step.\\n\\n`In C++`\\n```\\nvector<vector<int> > subsetsWithDup(vector<int> &S) {\\n    sort(S.begin(), S.end());\\n    vector<vector<int>> ret = {{}};\\n    int size = 0, startIndex = 0;\\n    for (int i = 0; i < S.size(); i++) {\\n        startIndex = i >= 1 && S[i] == S[i - 1] ? size : 0;\\n        size = ret.size();\\n        for (int j = startIndex; j < size; j++) {\\n            vector<int> temp = ret[j];\\n            temp.push_back(S[i]);\\n            ret.push_back(temp);\\n        }\\n    }\\n    return ret;\\n}\\n```\\n`In JAVA`\\n```\\nclass Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        Arrays.sort(nums);\\n        List<List<Integer>> result = new ArrayList<List<Integer>>();\\n        result.add(new ArrayList<Integer>());\\n        int begin = 0;\\n        for(int i = 0; i < nums.length; i++){\\n            if(i == 0 || nums[i] != nums[i - 1]) begin = 0;\\n            int size = result.size();\\n            for(int j = begin; j < size; j++){\\n                List<Integer> cur = new ArrayList<Integer>(result.get(j));\\n                cur.add(nums[i]);\\n                result.add(cur);\\n            }\\n            begin = size;\\n        }\\n        return result;\\n    }\\n}\\n```\\n`In Python`\\n```\\n def subsetsWithDup(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        res = [[ ]]\\n        nums.sort()\\n        size = 0\\n        for i in range(len(nums)):\\n            j = size if i > 0 and (nums[i] == nums[i-1]) else 0\\n            size = len(res)\\n            while j < size:\\n                temp = copy.copy(res[j])\\n                temp.append(nums[i])\\n                res.append(temp)\\n                j += 1    \\n        return res\\n```\\n**TIME COMPLEXITY: O(N)**\\n\\n# **APPROACH II: Backtracking**\\nThe characteristics of C++ reference is an outstanding tool for backtracking algorithm!\\n**Algorithm:**\\nLet us use [1,2,3,4] as an example to explain my solution:\\n```\\nsubsets([1,2,3,4]) = []\\n                     // push(1)\\n                     [1, subsets([2,3,4])] // if push N times in subsets([2,3,4]), the pop times is also N, so vec is also [1] after backtrack.\\n                     // pop(), push(2)\\n                     [2, subsets([3,4])]\\n                     // pop(), push(3)\\n                     [3, subsets([4])]\\n                     // pop(), push(4)\\n                     [4, subsets([])]\\n                     // pop()\\n```\\n**SOLUTION:**\\n`In C++`\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int> > subsetsWithDup(vector<int> &nums) {\\n\\t\\tsort(nums.begin(), nums.end());\\n        vector<std::vector<int>> res;\\n\\t\\tvector<int> vec;\\n\\t\\tsubsetsWithDup(res, nums, vec, 0);\\n\\t\\treturn res;\\n    }\\nprivate:\\n\\tvoid subsetsWithDup(vector<vector<int> > &res, vector<int> &nums, vector<int> &vec, int begin) {\\n\\t\\tres.push_back(vec);\\n\\t\\tfor (int i = begin; i != nums.size(); ++i)\\n\\t\\t\\tif (i == begin || nums[i] != nums[i - 1]) { \\n\\t\\t\\t\\tvec.push_back(nums[i]);\\n\\t\\t\\t\\tsubsetsWithDup(res, nums, vec, i + 1);\\n\\t\\t\\t\\tvec.pop_back();\\n\\t\\t\\t}\\n\\t}\\n};\\n```\\n**TIME COMPLEXITY: O(2^N)**\\n",
                "solutionTags": [],
                "code": "```\\n1. null\\n2. null | 1\\n3. null | 1 | 2 ; 1,2\\n4. null | 1 | 2 ; 1,2 | 3; 1,3; 2,3; 1,2,3\\n5. null | 1 | 2 ; 1,2 | 3; 1,3; 2,3; 1,2,3 | 3,3; 1,3,3; 2,3,3; 1,2,3,3\\n6. null | 1 | 2 ; 1,2 | 3; 1,3; 2,3; 1,2,3 | 3,3; 1,3,3; 2,3,3; 1,2,3,3 | 3,3,3; 1,3,3,3; 2,3,3,3; 1,2,3,3,3\\n```\n```\\nvector<vector<int> > subsetsWithDup(vector<int> &S) {\\n    sort(S.begin(), S.end());\\n    vector<vector<int>> ret = {{}};\\n    int size = 0, startIndex = 0;\\n    for (int i = 0; i < S.size(); i++) {\\n        startIndex = i >= 1 && S[i] == S[i - 1] ? size : 0;\\n        size = ret.size();\\n        for (int j = startIndex; j < size; j++) {\\n            vector<int> temp = ret[j];\\n            temp.push_back(S[i]);\\n            ret.push_back(temp);\\n        }\\n    }\\n    return ret;\\n}\\n```\n```\\nclass Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        Arrays.sort(nums);\\n        List<List<Integer>> result = new ArrayList<List<Integer>>();\\n        result.add(new ArrayList<Integer>());\\n        int begin = 0;\\n        for(int i = 0; i < nums.length; i++){\\n            if(i == 0 || nums[i] != nums[i - 1]) begin = 0;\\n            int size = result.size();\\n            for(int j = begin; j < size; j++){\\n                List<Integer> cur = new ArrayList<Integer>(result.get(j));\\n                cur.add(nums[i]);\\n                result.add(cur);\\n            }\\n            begin = size;\\n        }\\n        return result;\\n    }\\n}\\n```\n```\\n def subsetsWithDup(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        res = [[ ]]\\n        nums.sort()\\n        size = 0\\n        for i in range(len(nums)):\\n            j = size if i > 0 and (nums[i] == nums[i-1]) else 0\\n            size = len(res)\\n            while j < size:\\n                temp = copy.copy(res[j])\\n                temp.append(nums[i])\\n                res.append(temp)\\n                j += 1    \\n        return res\\n```\n```\\nsubsets([1,2,3,4]) = []\\n                     // push(1)\\n                     [1, subsets([2,3,4])] // if push N times in subsets([2,3,4]), the pop times is also N, so vec is also [1] after backtrack.\\n                     // pop(), push(2)\\n                     [2, subsets([3,4])]\\n                     // pop(), push(3)\\n                     [3, subsets([4])]\\n                     // pop(), push(4)\\n                     [4, subsets([])]\\n                     // pop()\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int> > subsetsWithDup(vector<int> &nums) {\\n\\t\\tsort(nums.begin(), nums.end());\\n        vector<std::vector<int>> res;\\n\\t\\tvector<int> vec;\\n\\t\\tsubsetsWithDup(res, nums, vec, 0);\\n\\t\\treturn res;\\n    }\\nprivate:\\n\\tvoid subsetsWithDup(vector<vector<int> > &res, vector<int> &nums, vector<int> &vec, int begin) {\\n\\t\\tres.push_back(vec);\\n\\t\\tfor (int i = begin; i != nums.size(); ++i)\\n\\t\\t\\tif (i == begin || nums[i] != nums[i - 1]) { \\n\\t\\t\\t\\tvec.push_back(nums[i]);\\n\\t\\t\\t\\tsubsetsWithDup(res, nums, vec, i + 1);\\n\\t\\t\\t\\tvec.pop_back();\\n\\t\\t\\t}\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3085695,
                "title": "same-code-with-tweaking-solved-2-problems-easy-to-understand",
                "content": "# CHECK THE RECURSION TREE BELOW FOR BETTER UNDERSTANDING .\\n\\n**SIMILAR QUESTION LINK WITH SOLUTION **\\nhttps://leetcode.com/problems/non-decreasing-subsequences/description/\\n\\nhttps://leetcode.com/problems/non-decreasing-subsequences/solutions/3085690/same-code-with-tweaking-solved-2-problems-easy-to-understand/\\n\\n# Intuition\\nSame code is used in solving Non decreasing Subsequence question .\\n\\n# Approach\\nWe are sorting given array. And find all subsequence it can can make ,along with the check that subset should not be repeated .\\ni.e.\\n if(ds.size()==0 || arr[ind]!=ds[ds.size()-1])\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>>ans;\\n    void subsequence(int ind,int n,vector<int>&arr,vector<int>&ds){\\n    if(ind==n){\\n        ans.push_back(ds);\\n        return;\\n    }\\n // Since in this question we can change the order of the array elements unlike question(https://leetcode.com/problems/non-decreasing-subsequences/description/).\\n    //  Therefore we sorted the nums vector initially.\\n    //  Therefore condition , if(ds.size()==0 || nums[index] >= ds[ds.size()-1]) is not required .\\n    ds.push_back(arr[ind]);\\n    subsequence(ind+1,n,arr,ds);\\n    ds.pop_back();\\n    if(ds.size()==0 || arr[ind]!=ds[ds.size()-1])subsequence(ind+1,n,arr,ds);\\n}\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        vector<int>ds;\\n        subsequence(0,nums.size(),nums,ds);\\n        return ans;\\n    }\\n};\\n```\\n\\n## ![image.png](https://assets.leetcode.com/users/images/b241b88c-e53b-42d2-9fb5-4e111c7e7d27_1674383113.75447.png)\\n\\n\\n#UPVOTE IF YOU LIKED THE EFFORT\\nTHANK YOU\\nCODE BY :) AMAN MAURYA\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>>ans;\\n    void subsequence(int ind,int n,vector<int>&arr,vector<int>&ds){\\n    if(ind==n){\\n        ans.push_back(ds);\\n        return;\\n    }\\n // Since in this question we can change the order of the array elements unlike question(https://leetcode.com/problems/non-decreasing-subsequences/description/).\\n    //  Therefore we sorted the nums vector initially.\\n    //  Therefore condition , if(ds.size()==0 || nums[index] >= ds[ds.size()-1]) is not required .\\n    ds.push_back(arr[ind]);\\n    subsequence(ind+1,n,arr,ds);\\n    ds.pop_back();\\n    if(ds.size()==0 || arr[ind]!=ds[ds.size()-1])subsequence(ind+1,n,arr,ds);\\n}\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        vector<int>ds;\\n        subsequence(0,nums.size(),nums,ds);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1953370,
                "title": "fully-explained-c-solution-with-example-time-space-complexity-analysis",
                "content": "> **If you\\u2019re interested in coding you can join my Discord Server, link in the comment section. Also if you find any mistakes please let me know. Thank you!\\u2764\\uFE0F**\\n>  \\n\\n---\\n\\n## Explanation:\\n\\n### Solution 01\\n\\n- Using ***Recursion & Backtracking.***\\n- Here we\\u2019ll first sort the array and for every index, we\\u2019ll try to push elements in such a way that it doesn\\u2019t contain any duplicates.\\n- In every function call, we\\u2019ll push our temp to ans vector. For the first call, it will push an empty subset.\\n- Now we will iterate from index to n-1 & try to pick & not pick an element.\\n- To avoid duplicates if we have already picked an element for the current index of temp with the same value as the index of the given array then we\\u2019ll continue.\\n- After every call we\\u2019ll pop our current element.\\n- Let\\'s explain this with an example:\\n    \\n    ```\\n    if the array is [1,2,2]\\n    \\n    help(0,num)\\n    -> ans=[[]]\\n    -> in for loop: \\n    \\t --> i=0, temp=[1], call help(1,num)\\n    \\t\\t\\t\\thelp(1,num)\\n    \\t\\t\\t\\t-> ans=[[],[1]]\\n    \\t\\t\\t\\t-> in for loop:\\n    \\t\\t\\t\\t\\t --> i=1, temp=[1,2], call help(2,num)\\n    \\t\\t\\t\\t\\t\\t\\t\\thelp(2,num)\\n    \\t\\t\\t\\t\\t\\t\\t\\t-> ans=[[],[1],[1,2]]\\n    \\t\\t\\t\\t\\t\\t\\t\\t-> in for loop:\\n    \\t\\t\\t\\t\\t\\t\\t\\t\\t --> i=2, temp=[1,2,2] & call help(3,num)\\n    \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\thelp(3,num)\\n    \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t-> ans=[[],[1],[1,2],[1,2,3]]\\n    \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t-> in for loop:\\n    \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t --> i=3, loop will terminate\\n    \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tNow it will go back to help(2,num) & pop last element first...  \\n    \\t\\t\\t\\t\\t\\t\\t\\t\\t --> i=3, temp=[1,2], loop will terminate\\n    \\t\\t\\t\\t\\t\\t\\t\\tNow it will go back to help(1,num) & pop the last element first...\\n    \\t\\t\\t\\t\\t --> i=2, temp=[1], now it will check the condition **if(i!=index && nums[i]==nums[i-1]),** here we already used 2 and our 2nd index element, so if we take 2 again it will give us duplicates. So we\\'ll simply skip this.\\n    \\t\\t\\t\\t\\t --> i=3, temp=[], loop will terminate\\n    \\t\\t\\t\\tNow it will go back to help(0,num) & pop the last element first...\\n    \\t --> i=1, temp=[2] & call help(2,num)\\n    \\t\\t\\t\\thelp(2,num)\\n    \\t\\t\\t\\t-> ans=[[],[1],[1,2],[1,2,3],[2]]\\n    \\t\\t\\t\\t-> in for loop:\\n    \\t\\t\\t\\t\\t --> i=2, temp=[2,2], call help(3,num)\\n    \\t\\t\\t\\t\\t\\t\\t\\thelp(3,num)\\n    \\t\\t\\t\\t\\t\\t\\t\\t-> ans=[[],[1],[1,2],[1,2,3],[2],[2,2]]\\n    \\t\\t\\t\\t\\t\\t\\t\\t-> in for loop:\\n    \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t--> i=3, temp=[2,2], loop will terminate\\n    \\t\\t\\t\\t\\t\\t\\t\\tNow it will go back to help(2,num) & pop last element first...\\n    \\t\\t\\t\\t\\t\\t--> i=3, temp=[2], loop will terminate\\n    \\t\\t\\t\\tNow it will go back to help(0,num) & pop last element first...\\n    \\t --> i=2, temp=[], again if condition satisfied and will skip this iteration.\\n    \\t --> i=3, temp=[], loop will terminate\\n    ```\\n    \\n- **Time complexity:** O(2^n * n).\\n- **Space complexity:** O(2^n * k).\\n\\n---\\n\\n## Code:\\n\\n```cpp\\n//Solution 01:\\nclass Solution {\\npublic:\\n    vector<int> temp;\\n    vector<vector<int>> ans;\\n        \\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        help(0, nums);\\n        return ans;\\n    }\\n    \\n    void help(int index, vector<int>& nums){\\n        ans.push_back(temp);\\n        \\n        for(int i=index; i<nums.size(); i++){\\n            if(i!=index && nums[i]==nums[i-1]) continue;\\n            temp.push_back(nums[i]);\\n            help(i+1, nums);\\n            temp.pop_back();\\n        }\\n    }\\n};\\n```\\n\\n---\\n\\n> **Please upvote this solution**\\n>",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n    if the array is [1,2,2]\\n    \\n    help(0,num)\\n    -> ans=[[]]\\n    -> in for loop: \\n    \\t --> i=0, temp=[1], call help(1,num)\\n    \\t\\t\\t\\thelp(1,num)\\n    \\t\\t\\t\\t-> ans=[[],[1]]\\n    \\t\\t\\t\\t-> in for loop:\\n    \\t\\t\\t\\t\\t --> i=1, temp=[1,2], call help(2,num)\\n    \\t\\t\\t\\t\\t\\t\\t\\thelp(2,num)\\n    \\t\\t\\t\\t\\t\\t\\t\\t-> ans=[[],[1],[1,2]]\\n    \\t\\t\\t\\t\\t\\t\\t\\t-> in for loop:\\n    \\t\\t\\t\\t\\t\\t\\t\\t\\t --> i=2, temp=[1,2,2] & call help(3,num)\\n    \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\thelp(3,num)\\n    \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t-> ans=[[],[1],[1,2],[1,2,3]]\\n    \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t-> in for loop:\\n    \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t --> i=3, loop will terminate\\n    \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tNow it will go back to help(2,num) & pop last element first...  \\n    \\t\\t\\t\\t\\t\\t\\t\\t\\t --> i=3, temp=[1,2], loop will terminate\\n    \\t\\t\\t\\t\\t\\t\\t\\tNow it will go back to help(1,num) & pop the last element first...\\n    \\t\\t\\t\\t\\t --> i=2, temp=[1], now it will check the condition **if(i!=index && nums[i]==nums[i-1]),** here we already used 2 and our 2nd index element, so if we take 2 again it will give us duplicates. So we\\'ll simply skip this.\\n    \\t\\t\\t\\t\\t --> i=3, temp=[], loop will terminate\\n    \\t\\t\\t\\tNow it will go back to help(0,num) & pop the last element first...\\n    \\t --> i=1, temp=[2] & call help(2,num)\\n    \\t\\t\\t\\thelp(2,num)\\n    \\t\\t\\t\\t-> ans=[[],[1],[1,2],[1,2,3],[2]]\\n    \\t\\t\\t\\t-> in for loop:\\n    \\t\\t\\t\\t\\t --> i=2, temp=[2,2], call help(3,num)\\n    \\t\\t\\t\\t\\t\\t\\t\\thelp(3,num)\\n    \\t\\t\\t\\t\\t\\t\\t\\t-> ans=[[],[1],[1,2],[1,2,3],[2],[2,2]]\\n    \\t\\t\\t\\t\\t\\t\\t\\t-> in for loop:\\n    \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t--> i=3, temp=[2,2], loop will terminate\\n    \\t\\t\\t\\t\\t\\t\\t\\tNow it will go back to help(2,num) & pop last element first...\\n    \\t\\t\\t\\t\\t\\t--> i=3, temp=[2], loop will terminate\\n    \\t\\t\\t\\tNow it will go back to help(0,num) & pop last element first...\\n    \\t --> i=2, temp=[], again if condition satisfied and will skip this iteration.\\n    \\t --> i=3, temp=[], loop will terminate\\n    ```\n```cpp\\n//Solution 01:\\nclass Solution {\\npublic:\\n    vector<int> temp;\\n    vector<vector<int>> ans;\\n        \\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        help(0, nums);\\n        return ans;\\n    }\\n    \\n    void help(int index, vector<int>& nums){\\n        ans.push_back(temp);\\n        \\n        for(int i=index; i<nums.size(); i++){\\n            if(i!=index && nums[i]==nums[i-1]) continue;\\n            temp.push_back(nums[i]);\\n            help(i+1, nums);\\n            temp.pop_back();\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 984188,
                "title": "java-simple-recursion",
                "content": "```\\n public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        Arrays.sort(nums);\\n        Set<List<Integer>>  result =new HashSet<>();\\n        solve(nums,0,new ArrayList<Integer>(),result);\\n        return new ArrayList<>(result);\\n    }\\n    \\n    public void solve(int[] arr,int pos,ArrayList<Integer> op,Set<List<Integer>> result){\\n        if(pos==(arr.length)){\\n            result.add(op);\\n            return;\\n        }\\n     \\n        ArrayList<Integer> op1=new ArrayList<>();\\n        op1.addAll(op);\\n        op1.add(arr[pos]);\\n        solve(arr,pos+1,op1,result);\\n        solve(arr,pos+1,op,result);\\n        return;\\n\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\n public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        Arrays.sort(nums);\\n        Set<List<Integer>>  result =new HashSet<>();\\n        solve(nums,0,new ArrayList<Integer>(),result);\\n        return new ArrayList<>(result);\\n    }\\n    \\n    public void solve(int[] arr,int pos,ArrayList<Integer> op,Set<List<Integer>> result){\\n        if(pos==(arr.length)){\\n            result.add(op);\\n            return;\\n        }\\n     \\n        ArrayList<Integer> op1=new ArrayList<>();\\n        op1.addAll(op);\\n        op1.add(arr[pos]);\\n        solve(arr,pos+1,op1,result);\\n        solve(arr,pos+1,op,result);\\n        return;\\n\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 647010,
                "title": "javascript-backtrack",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[][]}\\n */\\nvar subsetsWithDup = function(nums) {\\n    function findSubset(arr,curr){\\n        res.push([...curr])\\n        for(let i=0;i<arr.length;i++){\\n            if(i== 0 || arr[i] != arr[i-1]){\\n                curr.push(arr[i])\\n                findSubset(arr.slice(i+1),curr)\\n                curr.pop()\\n            }\\n        }\\n    }\\n    let res = []\\n    nums.sort((a,b)=>{return a-b})\\n    findSubset(nums,[])\\n    return res\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[][]}\\n */\\nvar subsetsWithDup = function(nums) {\\n    function findSubset(arr,curr){\\n        res.push([...curr])\\n        for(let i=0;i<arr.length;i++){\\n            if(i== 0 || arr[i] != arr[i-1]){\\n                curr.push(arr[i])\\n                findSubset(arr.slice(i+1),curr)\\n                curr.pop()\\n            }\\n        }\\n    }\\n    let res = []\\n    nums.sort((a,b)=>{return a-b})\\n    findSubset(nums,[])\\n    return res\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 30334,
                "title": "share-simple-recursive-java-solution",
                "content": "my method is simple, try to output all combination of the list and skip the same integer.\\n\\n    public class Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] num) {\\n        Arrays.sort(num);\\n        List<List<Integer>> result = new LinkedList<List<Integer>>();\\n        LinkedList<Integer> temp = new LinkedList<Integer>();\\n        Rec(num,result,temp,0);\\n        return result;\\n    }\\n    private static void Rec(int[] a,List<List<Integer>> result, LinkedList<Integer> temp, int current){\\n        result.add(new LinkedList(temp));\\n        for(int i=current;i<a.length;i++){\\n            if(i==current || a[i]!=a[i-1]){\\n                temp.add(a[i]);\\n                Rec(a,result,temp,i+1);\\n                temp.remove(temp.size()-1);\\n            }\\n        }\\n        return;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] num) {\\n        Arrays.sort(num);\\n        List<List<Integer>> result = new LinkedList<List<Integer>>();\\n        LinkedList<Integer> temp = new LinkedList<Integer>();\\n        Rec(num,result,temp,0);\\n        return result;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2626736,
                "title": "complete-walkthrough-with-pictures-working-explained-behind-the-approach",
                "content": "**Don\\'t have time to read at all. Read only conclusion part, guaranteed you\\'ll be able to write the code by yourself**\\n\\n```\\n/*\\n    Question is exactly similar to \\'Subset I\\' problem with slight modification\\n    --------------------------------------------------------------------------\\n        + We\\'ve to avoid duplicates.\\n        \\n    Recursion Tree Diagram Including Duplicate Subsets\\n    ===================================================\\n    \\n    NOTE:  T : Included ith indexed\\'s element, F : Excluded ith indexed\\'s element\\n    \\n                                  [1, 1, 2]                0th -> indicates making decisions for 0th indexed element\\n                           T         /   \\\\          F\\n                +------------------+      +----------------------+\\n               /                                                  \\\\\\n             {1}+--+                                                {}__   1st -> indexed\\'s decisions\\n           T/       \\\\F                                            /    \\\\ \\n           /         \\\\                                          T/      \\\\F\\n          {1, 1}       {1}+  (duplicate_subtree) --------->    {1}       {}     2nd -> indexed\\'s decisions\\n        T/    \\\\F      T/   \\\\F                                T/  \\\\    T /  \\\\F\\n        /      \\\\      /     \\\\                                /    \\\\    /    \\\\\\n     {1, 1, 2} {1, 1} {1, 2} {1}                            {1, 2} {1} {2}   {}     3rd -> elements are exhausted\\n     ^                         ^                              ^         ^     ^\\n     |                         |                              |         |     |              \\n     |                         |                              |         |     |  \\n     +-------------------------+                              +---------+     |\\n                ^                                               duplicates    ^  \\n                |                                               subsets       |         \\n                +-------------------------------------------------------------+\\n                                        required subsets\\n                                        \\n    \\n    \\n    If we look at the above recursion tree diagram, we\\'ll found that when we move the right subtree of 0th level\\n    i.e. after completing entire left subtree for 0th element. Entire Left sub-tree in this right-subtree, is computed\\n    twice which is already calculated in the left subtree of 0th level.\\n    \\n    Because when we made a decision for 1st element in the first(1st) level to include it in the empty \\n    set, at this point look the given array carefully the element at index 1 is equal to the previous index 0.\\n    \\n    Q: What would happen when made a dfs call to index 1 in the left subtree of 1st level?\\n    A: This entire DFS would give us duplicate subsets at the end, when elements are exhausted.\\n    \\n        Because when made a dfs call to the 0th index in the left subtree of 0th level, all possible\\n        subsets for the range of indices [1, 2] (inclusive) are already calculated{look at the left hand side of\\n        word \\'duplicate_subtree\\' in the recursion tree diagram}.\\n        \\n        So therefore, we can say that making dfs call to the index 1 as the left-subtree of 1st level\\n        is nothing but redundent.\\n  ======================================================================================================\\n  \\n  Conclusion [To keep in mind to avoid duplicates]\\n  ================================================\\n        When we\\'re ignoring any ith indexed element[i.e. going to the right subtree(i+1=level) of ith level]/excluding\\n        the ith element and moving to made the decisions for (i + 1) elemennt in (i + 1) level.\\n        \\n            If element_at_(i + 1)_index is equal to element at i(i.e. nums[i + 1] == nums[i]) and\\n            element at ith index is excluded then must excluded the element at (i + 1) index as well to\\n            avoid duplicates.\\n            \\n                    Because all the subsets in the range of indices [i + 1, n - 1] is already calculated\\n                    when we made a dfs[To include ith element] call to the ith index in the ith level.\\n  \\n        In simple words, basically we\\'ve to exclude the element x iff its previous adjacent\\n        element is also x and it\\'s previously execluded.\\n        \\n    \\n    Q: The biggest question is that what if two equal elements are at different[NOT adjacent] indices like i & j?\\n        where i < j and all possible subsets for the range of indices [j, n - 1] is already calculated\\n        for some dfs call(s) previously made to any index i.\\n        \\n    A: Well!! of course this case could occure but here in the question they stated that you can return the subsets\\n        in any order. Hence, to make the equal elements adjacent to each other we would sort the given \\'nums\\' array.\\n            + Sorting will only change the order of subsets in the resultant list but NOT the count.\\n            + Sorting will adjust all equal element adjacently.\\n*/\\n\\nclass Solution {\\n    \\n    //isPreviousElementExcluded : True -> Means previous element is excluded. NOT execlude[included] otherwise.\\n    \\n    private void generateUniqueSubsets(int[] nums, int idx, List<List<Integer>> subsets,\\n                                       List<Integer> runningSubset, boolean isPreviousElementExcluded) {\\n        if(idx == nums.length) {\\n            subsets.add(new ArrayList<>(runningSubset));\\n            return;\\n        }\\n        \\n        //Handling the reverse case of our conclusion\\n        if(!isPreviousElementExcluded || (isPreviousElementExcluded && idx > 0 && nums[idx] != nums[idx - 1])) {\\n            runningSubset.add(nums[idx]);\\n            generateUniqueSubsets(nums, idx + 1, subsets, runningSubset, false);\\n            runningSubset.remove(runningSubset.size() - 1);\\n        }\\n        \\n        //Exclude the ith element [Calling to right-subtree]\\n        generateUniqueSubsets(nums, idx + 1, subsets, runningSubset, true);\\n    }\\n    \\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        Arrays.sort(nums);\\n        List<List<Integer>> subsets = new ArrayList<>();\\n        generateUniqueSubsets(nums, 0, subsets, new ArrayList<>(), false);\\n        return subsets;\\n    }\\n}\\n```\\n\\n```\\nExact same Implementation what I\\'ve Discussed in the commented section\\n```\\n\\n```\\nclass Solution {\\n    \\n    private void generateUniqueSubsets(int[] nums, int idx, List<List<Integer>> subsets,\\n                                       List<Integer> runningSubset, boolean isPreviousElementIncluded) {\\n        if(idx == nums.length) {\\n            subsets.add(new ArrayList<>(runningSubset));\\n            return;\\n        }\\n        //Since this part : should always call\\n        generateUniqueSubsets(nums, idx + 1, subsets, runningSubset, false);\\n\\n        if(!isPreviousElementIncluded && nums[idx] == nums[idx - 1]) return; //Don\\'t repeat inclusion of \\'nums[idx]\\'\\n        \\n        runningSubset.add(nums[idx]);\\n        generateUniqueSubsets(nums, idx + 1, subsets, runningSubset, true);\\n        runningSubset.remove(runningSubset.size() - 1);\\n    }\\n    \\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        Arrays.sort(nums);\\n        List<List<Integer>> subsets = new ArrayList<>();\\n        generateUniqueSubsets(nums, 0, subsets, new ArrayList<>(), true);\\n        return subsets;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/*\\n    Question is exactly similar to \\'Subset I\\' problem with slight modification\\n    --------------------------------------------------------------------------\\n        + We\\'ve to avoid duplicates.\\n        \\n    Recursion Tree Diagram Including Duplicate Subsets\\n    ===================================================\\n    \\n    NOTE:  T : Included ith indexed\\'s element, F : Excluded ith indexed\\'s element\\n    \\n                                  [1, 1, 2]                0th -> indicates making decisions for 0th indexed element\\n                           T         /   \\\\          F\\n                +------------------+      +----------------------+\\n               /                                                  \\\\\\n             {1}+--+                                                {}__   1st -> indexed\\'s decisions\\n           T/       \\\\F                                            /    \\\\ \\n           /         \\\\                                          T/      \\\\F\\n          {1, 1}       {1}+  (duplicate_subtree) --------->    {1}       {}     2nd -> indexed\\'s decisions\\n        T/    \\\\F      T/   \\\\F                                T/  \\\\    T /  \\\\F\\n        /      \\\\      /     \\\\                                /    \\\\    /    \\\\\\n     {1, 1, 2} {1, 1} {1, 2} {1}                            {1, 2} {1} {2}   {}     3rd -> elements are exhausted\\n     ^                         ^                              ^         ^     ^\\n     |                         |                              |         |     |              \\n     |                         |                              |         |     |  \\n     +-------------------------+                              +---------+     |\\n                ^                                               duplicates    ^  \\n                |                                               subsets       |         \\n                +-------------------------------------------------------------+\\n                                        required subsets\\n                                        \\n    \\n    \\n    If we look at the above recursion tree diagram, we\\'ll found that when we move the right subtree of 0th level\\n    i.e. after completing entire left subtree for 0th element. Entire Left sub-tree in this right-subtree, is computed\\n    twice which is already calculated in the left subtree of 0th level.\\n    \\n    Because when we made a decision for 1st element in the first(1st) level to include it in the empty \\n    set, at this point look the given array carefully the element at index 1 is equal to the previous index 0.\\n    \\n    Q: What would happen when made a dfs call to index 1 in the left subtree of 1st level?\\n    A: This entire DFS would give us duplicate subsets at the end, when elements are exhausted.\\n    \\n        Because when made a dfs call to the 0th index in the left subtree of 0th level, all possible\\n        subsets for the range of indices [1, 2] (inclusive) are already calculated{look at the left hand side of\\n        word \\'duplicate_subtree\\' in the recursion tree diagram}.\\n        \\n        So therefore, we can say that making dfs call to the index 1 as the left-subtree of 1st level\\n        is nothing but redundent.\\n  ======================================================================================================\\n  \\n  Conclusion [To keep in mind to avoid duplicates]\\n  ================================================\\n        When we\\'re ignoring any ith indexed element[i.e. going to the right subtree(i+1=level) of ith level]/excluding\\n        the ith element and moving to made the decisions for (i + 1) elemennt in (i + 1) level.\\n        \\n            If element_at_(i + 1)_index is equal to element at i(i.e. nums[i + 1] == nums[i]) and\\n            element at ith index is excluded then must excluded the element at (i + 1) index as well to\\n            avoid duplicates.\\n            \\n                    Because all the subsets in the range of indices [i + 1, n - 1] is already calculated\\n                    when we made a dfs[To include ith element] call to the ith index in the ith level.\\n  \\n        In simple words, basically we\\'ve to exclude the element x iff its previous adjacent\\n        element is also x and it\\'s previously execluded.\\n        \\n    \\n    Q: The biggest question is that what if two equal elements are at different[NOT adjacent] indices like i & j?\\n        where i < j and all possible subsets for the range of indices [j, n - 1] is already calculated\\n        for some dfs call(s) previously made to any index i.\\n        \\n    A: Well!! of course this case could occure but here in the question they stated that you can return the subsets\\n        in any order. Hence, to make the equal elements adjacent to each other we would sort the given \\'nums\\' array.\\n            + Sorting will only change the order of subsets in the resultant list but NOT the count.\\n            + Sorting will adjust all equal element adjacently.\\n*/\\n\\nclass Solution {\\n    \\n    //isPreviousElementExcluded : True -> Means previous element is excluded. NOT execlude[included] otherwise.\\n    \\n    private void generateUniqueSubsets(int[] nums, int idx, List<List<Integer>> subsets,\\n                                       List<Integer> runningSubset, boolean isPreviousElementExcluded) {\\n        if(idx == nums.length) {\\n            subsets.add(new ArrayList<>(runningSubset));\\n            return;\\n        }\\n        \\n        //Handling the reverse case of our conclusion\\n        if(!isPreviousElementExcluded || (isPreviousElementExcluded && idx > 0 && nums[idx] != nums[idx - 1])) {\\n            runningSubset.add(nums[idx]);\\n            generateUniqueSubsets(nums, idx + 1, subsets, runningSubset, false);\\n            runningSubset.remove(runningSubset.size() - 1);\\n        }\\n        \\n        //Exclude the ith element [Calling to right-subtree]\\n        generateUniqueSubsets(nums, idx + 1, subsets, runningSubset, true);\\n    }\\n    \\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        Arrays.sort(nums);\\n        List<List<Integer>> subsets = new ArrayList<>();\\n        generateUniqueSubsets(nums, 0, subsets, new ArrayList<>(), false);\\n        return subsets;\\n    }\\n}\\n```\n```\\nExact same Implementation what I\\'ve Discussed in the commented section\\n```\n```\\nclass Solution {\\n    \\n    private void generateUniqueSubsets(int[] nums, int idx, List<List<Integer>> subsets,\\n                                       List<Integer> runningSubset, boolean isPreviousElementIncluded) {\\n        if(idx == nums.length) {\\n            subsets.add(new ArrayList<>(runningSubset));\\n            return;\\n        }\\n        //Since this part : should always call\\n        generateUniqueSubsets(nums, idx + 1, subsets, runningSubset, false);\\n\\n        if(!isPreviousElementIncluded && nums[idx] == nums[idx - 1]) return; //Don\\'t repeat inclusion of \\'nums[idx]\\'\\n        \\n        runningSubset.add(nums[idx]);\\n        generateUniqueSubsets(nums, idx + 1, subsets, runningSubset, true);\\n        runningSubset.remove(runningSubset.size() - 1);\\n    }\\n    \\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        Arrays.sort(nums);\\n        List<List<Integer>> subsets = new ArrayList<>();\\n        generateUniqueSubsets(nums, 0, subsets, new ArrayList<>(), true);\\n        return subsets;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1044127,
                "title": "c-solution-easy-to-understand-beats-100-0ms-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> result;\\n    void solve(vector<int>& nums , int start , vector<int>& subset){\\n        result.push_back(subset);\\n        for(int i=start ;i<nums.size();i++){\\n            if(i>start and nums[i-1] == nums[i])\\n                continue;\\n            subset.push_back(nums[i]);\\n            solve(nums , i+1 , subset);\\n            subset.pop_back();\\n        }\\n    }\\n    \\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        sort(nums.begin() , nums.end());\\n        vector<int> subset;\\n        solve(nums, 0 , subset);\\n        return result;\\n    }\\n};\\n```\\n\\n**Happy coding**",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> result;\\n    void solve(vector<int>& nums , int start , vector<int>& subset){\\n        result.push_back(subset);\\n        for(int i=start ;i<nums.size();i++){\\n            if(i>start and nums[i-1] == nums[i])\\n                continue;\\n            subset.push_back(nums[i]);\\n            solve(nums , i+1 , subset);\\n            subset.pop_back();\\n        }\\n    }\\n    \\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        sort(nums.begin() , nums.end());\\n        vector<int> subset;\\n        solve(nums, 0 , subset);\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 690114,
                "title": "python-backtracking-solution",
                "content": "Using sorting and comparison to prevent duplicates. \\n```\\nclass Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        nums.sort()\\n        self.res = []\\n        self.backtrack(nums, [], 0)\\n        return self.res\\n    \\n    def backtrack(self, nums, current, start):\\n        self.res.append(current)\\n        if start > len(nums):\\n            return\\n        for i in range(start, len(nums)):\\n            if i > start and nums[i-1] == nums[i]:\\n                continue\\n            self.backtrack(nums, current + [nums[i]], i + 1)\\n```\\nRuntime: 32 ms, faster than 92.15% of Python3 online submissions for Subsets II.\\nMemory Usage: 13.9 MB, less than 84.06% of Python3 online submissions for Subsets II.\\n",
                "solutionTags": [
                    "Python3",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        nums.sort()\\n        self.res = []\\n        self.backtrack(nums, [], 0)\\n        return self.res\\n    \\n    def backtrack(self, nums, current, start):\\n        self.res.append(current)\\n        if start > len(nums):\\n            return\\n        for i in range(start, len(nums)):\\n            if i > start and nums[i-1] == nums[i]:\\n                continue\\n            self.backtrack(nums, current + [nums[i]], i + 1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 630505,
                "title": "no-for-loop-more-intuitive",
                "content": "I noticed the for-loop is used for all the backtracing questions. It is fine. However, it\\'s more intuitive if each recursion focuses on itself - choose or not choose.\\n\\nThe non for-loop is a general solution if you don\\'t need to leap and inspect all other elements in the dataset.\\n\\nUse this question as example. Here\\'s the code:\\n```\\nclass Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        List<List<Integer>> ret = new ArrayList<>();\\n        Arrays.sort(nums);\\n        subset(nums, 0, new ArrayList<>(), ret);\\n        return ret;\\n    }\\n    \\n    private void subset(int[] nums, int index, List<Integer> parts, List<List<Integer>> ret) {\\n        if(index == nums.length) {\\n            ret.add(new ArrayList<>(parts));\\n            return;\\n        }\\n        parts.add(nums[index]);\\n        subset(nums, index+1, parts, ret);\\n        parts.remove(parts.size()-1);\\n        \\n        while(index+1 < nums.length && nums[index+1] == nums[index]) {\\n            ++index;\\n        }\\n        subset(nums, index+1, parts, ret);\\n    }\\n}\\n```\\n\\nUpdated on 08/16/2021: another example we can apply choose or not choose\\nhttps://leetcode.com/problems/partition-to-k-equal-sum-subsets/discuss/1407822/No-for-loop.-More-intuitive.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        List<List<Integer>> ret = new ArrayList<>();\\n        Arrays.sort(nums);\\n        subset(nums, 0, new ArrayList<>(), ret);\\n        return ret;\\n    }\\n    \\n    private void subset(int[] nums, int index, List<Integer> parts, List<List<Integer>> ret) {\\n        if(index == nums.length) {\\n            ret.add(new ArrayList<>(parts));\\n            return;\\n        }\\n        parts.add(nums[index]);\\n        subset(nums, index+1, parts, ret);\\n        parts.remove(parts.size()-1);\\n        \\n        while(index+1 < nums.length && nums[index+1] == nums[index]) {\\n            ++index;\\n        }\\n        subset(nums, index+1, parts, ret);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 267930,
                "title": "python-4-line-beats-99-42",
                "content": "```\\nclass Solution(object):\\n    def subsetsWithDup(self, nums):\\n        result = [[]]\\n        for num in sorted(nums):\\n            result += [i+[num] for i in result if i+[num] not in result]\\n        return result\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def subsetsWithDup(self, nums):\\n        result = [[]]\\n        for num in sorted(nums):\\n            result += [i+[num] for i in result if i+[num] not in result]\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 229447,
                "title": "python-backtracking-general-approach-beats-100",
                "content": "```python\\ndef backtrack(nums, res, temp, start):\\n    res.append(temp)\\n    for i in range(start, len(nums)):\\n\\t\\t# Skip duplicate numbers\\n        if not (i > start and nums[i-1] == nums[i]):\\n            backtrack(nums, res, temp + [nums[i]], i+1)\\n\\nclass Solution(object):\\n    def subsetsWithDup(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        nums.sort()\\n        res = []\\n        backtrack(nums, res, [], 0)\\n        return res\\n```\\n\\t\\nSimilar approach can be applied to the below and other problems:\\n\\n* https://leetcode.com/problems/subsets/\\n* https://leetcode.com/problems/subsets-ii/\\n* https://leetcode.com/problems/combinations/\\n* https://leetcode.com/problems/permutations/\\n* https://leetcode.com/problems/permutations-ii/\\n* https://leetcode.com/problems/combination-sum/\\n* https://leetcode.com/problems/combination-sum-ii/\\n* https://leetcode.com/problems/palindrome-partitioning/",
                "solutionTags": [],
                "code": "```python\\ndef backtrack(nums, res, temp, start):\\n    res.append(temp)\\n    for i in range(start, len(nums)):\\n\\t\\t# Skip duplicate numbers\\n        if not (i > start and nums[i-1] == nums[i]):\\n            backtrack(nums, res, temp + [nums[i]], i+1)\\n\\nclass Solution(object):\\n    def subsetsWithDup(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        nums.sort()\\n        res = []\\n        backtrack(nums, res, [], 0)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 30286,
                "title": "recursion-and-non-recursion-java-solution-for-your-reference",
                "content": "Two solution, recursion and non-recursion:\\n\\nRecursion solution:\\n\\n    public class Solution {\\n        Set<Integer> hash = new HashSet<>();\\n        List<List<Integer>> res = new ArrayList<>();\\n        int n;\\n        int[] nums;\\n        \\n        public void search(List<Integer> l, int p) {\\n            if (p == n) {\\n                int h = l.hashCode();\\n                if (!hash.contains(h)) {\\n                    hash.add(h);\\n                    res.add(new ArrayList<>(l));\\n                }\\n                return;\\n            }\\n            l.add(nums[p]);\\n            search(l, p+1);\\n            l.remove(l.size()-1);\\n            search(l, p+1);\\n        }\\n        \\n        public List<List<Integer>> subsetsWithDup(int[] nums) {\\n            this.n = nums.length; this.nums = nums;\\n            Arrays.sort(nums);\\n            search(new ArrayList<Integer>(), 0);\\n            return res;\\n        }\\n    }\\n\\nNon-recursion solution:\\n\\n    public class Solution {\\n        public List<List<Integer>> subsetsWithDup(int[] nums) {\\n            List<List<Integer>> res = new ArrayList<>();\\n            List<Integer> temp = new ArrayList<>();\\n            res.add(temp);\\n            Arrays.sort(nums);\\n            int l = 0, k;\\n            for (int i = 0; i < nums.length; i++) {\\n                if (i == 0 || nums[i] != nums[i-1])\\n                    l = res.size();\\n                k = res.size();\\n                for (int j = k-l; j < k; j++) {\\n                    temp = new ArrayList<>(res.get(j));\\n                    temp.add(nums[i]);\\n                    res.add(temp);\\n                }\\n            }\\n            return res;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        Set<Integer> hash = new HashSet<>();\\n        List<List<Integer>> res = new ArrayList<>();\\n        int n;\\n        int[] nums;\\n        \\n        public void search(List<Integer> l, int p) {\\n            if (p == n) {\\n                int h = l.hashCode();\\n                if (!hash.contains(h)) {\\n                    hash.add(h);\\n                    res.add(new ArrayList<>(l));\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 30315,
                "title": "c-ac-regular-backtracking-solution-for-both-subsets-i-and-ii",
                "content": "    void dfs(vector<int> &S, int start, vector<int> &output, vector<vector<int>> &result) {\\n        result.push_back(output);\\n        \\n        for (int i = start; i < S.size(); i++) {\\n            output.push_back(S[i]);\\n            dfs(S, i + 1, output, result);\\n            output.pop_back();\\n            // disable following line for subset I\\n            while (i + 1 < S.size() && S[i + 1] == S[i]) i++;\\n        }\\n    }\\n    \\n    vector<vector<int> > subsetsWithDup(vector<int> &S) {\\n        vector<vector<int>> result;\\n        vector<int> output;\\n        \\n        if (0 == S.size()) {\\n            result.push_back(output);\\n            return result;\\n        }\\n        \\n        sort(S.begin(), S.end());\\n        dfs(S, 0, output, result);\\n        return result;\\n    }",
                "solutionTags": [],
                "code": "    void dfs(vector<int> &S, int start, vector<int> &output, vector<vector<int>> &result) {\\n        result.push_back(output);\\n        \\n        for (int i = start; i < S.size(); i++) {\\n            output.push_back(S[i]);\\n            dfs(S, i + 1, output, result);\\n            output.pop_back();\\n            // disable following line for subset I\\n            while (i + 1 < S.size() && S[i + 1] == S[i]) i++;\\n        }\\n    }\\n    \\n    vector<vector<int> > subsetsWithDup(vector<int> &S) {\\n        vector<vector<int>> result;\\n        vector<int> output;\\n        \\n        if (0 == S.size()) {\\n            result.push_back(output);\\n            return result;\\n        }\\n        \\n        sort(S.begin(), S.end());\\n        dfs(S, 0, output, result);\\n        return result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2772818,
                "title": "subsets-ii-java-solution-2-lines-added-in-subsets-i-problem",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        Arrays.sort(nums);\\n        List<Integer> subset = new ArrayList<>();\\n        List<List<Integer>> ans = new ArrayList<>();\\n        helper(nums,0,ans,subset);\\n        return ans;\\n    }\\n        public void helper(int[] nums, int index, List<List<Integer>> ans, List<Integer> subset)\\n    {\\n        \\n        if(index==nums.length)\\n        {\\n            ans.add(new ArrayList(subset));\\n            return;\\n        }\\n        \\n        //include\\n        subset.add(nums[index]);\\n        helper(nums,index+1,ans,subset);\\n        \\n        //exclude\\n            while(index+1<nums.length && nums[index]==nums[index+1]){\\n                index++;\\n            }\\n        subset.remove(subset.size()-1);\\n        helper(nums,index+1,ans,subset);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        Arrays.sort(nums);\\n        List<Integer> subset = new ArrayList<>();\\n        List<List<Integer>> ans = new ArrayList<>();\\n        helper(nums,0,ans,subset);\\n        return ans;\\n    }\\n        public void helper(int[] nums, int index, List<List<Integer>> ans, List<Integer> subset)\\n    {\\n        \\n        if(index==nums.length)\\n        {\\n            ans.add(new ArrayList(subset));\\n            return;\\n        }\\n        \\n        //include\\n        subset.add(nums[index]);\\n        helper(nums,index+1,ans,subset);\\n        \\n        //exclude\\n            while(index+1<nums.length && nums[index]==nums[index+1]){\\n                index++;\\n            }\\n        subset.remove(subset.size()-1);\\n        helper(nums,index+1,ans,subset);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 882468,
                "title": "simple-java-solution-based-on-backtracking-with-comments-1ms",
                "content": "**Approach:**\\nThis is a classic backtracking problem is solved using the recommened template of\\n- make a choice\\n- backtrack\\n- undo your choice\\n\\n**Caveats:**\\nThe choice to sort the array introduces `O(n log n)` complexity but the worst-case complexity for generating the subsets is already `O(2^n)`.\\nThis allows us to use sorting without any impact on overall time complexity of the solution.\\n\\n```\\nclass Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        // sorting our array will allow us to skip repetitions easily\\n        Arrays.sort(nums);\\n        List<List<Integer>> res = new ArrayList<>();\\n        backtrack(nums, 0, new ArrayList<>(), res);\\n        return res;\\n    }\\n    \\n    private void backtrack(int[] a, int idx, List<Integer> curr, List<List<Integer>> res) {\\n        // Be careful to always add a copy of the list;\\n\\t\\t// else you would essentially be changing the same list over and over again\\n\\t\\tres.add(List.copyOf(curr));\\n        if(idx == a.length) return;\\n        \\n        for(int i=idx; i<a.length; i++) {\\n            curr.add(a[i]); // make a choice (add the number at index)\\n            backtrack(a, i+1, curr,res); // backtrack (generate dependent subsets)\\n            curr.remove(curr.size()-1); // undo your choice (remove the number)\\n            \\n            // This is the tricky part; we want to skip all the repetitions of the number\\n            while(i+1 < a.length && a[i] == a[i+1]) {\\n                i += 1;\\n            }\\n        }\\n    }\\n}\\n```\\n\\n**Please Vote up, if this helped you!!**\\n\\nHappy Coding!! :)",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        // sorting our array will allow us to skip repetitions easily\\n        Arrays.sort(nums);\\n        List<List<Integer>> res = new ArrayList<>();\\n        backtrack(nums, 0, new ArrayList<>(), res);\\n        return res;\\n    }\\n    \\n    private void backtrack(int[] a, int idx, List<Integer> curr, List<List<Integer>> res) {\\n        // Be careful to always add a copy of the list;\\n\\t\\t// else you would essentially be changing the same list over and over again\\n\\t\\tres.add(List.copyOf(curr));\\n        if(idx == a.length) return;\\n        \\n        for(int i=idx; i<a.length; i++) {\\n            curr.add(a[i]); // make a choice (add the number at index)\\n            backtrack(a, i+1, curr,res); // backtrack (generate dependent subsets)\\n            curr.remove(curr.size()-1); // undo your choice (remove the number)\\n            \\n            // This is the tricky part; we want to skip all the repetitions of the number\\n            while(i+1 < a.length && a[i] == a[i+1]) {\\n                i += 1;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 171626,
                "title": "python-solution",
                "content": "Use a dictionary to keep track of the number of appearances of each number. One can then easily construct the power set of `nums` based on this dictionary.\\n\\nE.g., `nums = [1,1,2,2,2,4,4,5]`. In this case `dic = {1:2, 2:3, 4:2, 5:1}`. We intialize `res = [[]]`, and build the solution iteratively as we loop over the dictionary. We first reach `key, val = 1, 2`. The power set of `[1,1]` is `res = [[], [1], [1,1]]`. Then we reach `key, val = 2, 3`. The power set of `[1,1,2,2,2]` is obtained by appending either `0`, `1`, `2`, or `3` 2\\'s to all elements in `res`. After which we get `res = [[], [1], [1,1], [2], [1,2], [1,1,2],[2,2], [1,2,2], [1,1,2,2],[2,2,2], [1,2,2,2], [1,1,2,2,2]]`. After we loop over `dic`, `res` will be the power set of `nums`.\\n\\nTime complexity: `O(2^n)`, space complexity: `O(2^n)`.\\n\\n```\\nclass Solution(object):\\n    def subsetsWithDup(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        if not nums:\\n            return [[]]\\n        res = [[]]\\n        dic = collections.Counter(nums)\\n        for key, val in dic.items():\\n            tmp = []\\n            for lst in res:\\n                for i in range(1, val+1):\\n                    tmp.append(lst+[key]*i)\\n            res += tmp\\n        return res\\n```\\n\\nSame idea, with a backtracking algorithm. Time complexity: `O(2^n)`, space complexity: `O(2^n)`.\\n\\n```\\nclass Solution(object):\\n    def subsetsWithDup(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        def helper(nums, i, j):\\n            if i > j:\\n                return [[]]\\n            if j == i:\\n                return [[],[nums[i]]]\\n            tail = nums[j]\\n            count = 0\\n            k = j\\n            while k >= i and nums[k] == tail:\\n                count += 1\\n                k -= 1\\n            res = helper(nums, i, k)\\n            for k in range(len(res)):\\n                for l in range(1, count+1):\\n                    res.append(res[k]+[tail]*l)\\n            return res\\n            \\n        nums = sorted(nums)\\n        return helper(nums, 0, len(nums)-1)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def subsetsWithDup(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        if not nums:\\n            return [[]]\\n        res = [[]]\\n        dic = collections.Counter(nums)\\n        for key, val in dic.items():\\n            tmp = []\\n            for lst in res:\\n                for i in range(1, val+1):\\n                    tmp.append(lst+[key]*i)\\n            res += tmp\\n        return res\\n```\n```\\nclass Solution(object):\\n    def subsetsWithDup(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        def helper(nums, i, j):\\n            if i > j:\\n                return [[]]\\n            if j == i:\\n                return [[],[nums[i]]]\\n            tail = nums[j]\\n            count = 0\\n            k = j\\n            while k >= i and nums[k] == tail:\\n                count += 1\\n                k -= 1\\n            res = helper(nums, i, k)\\n            for k in range(len(res)):\\n                for l in range(1, count+1):\\n                    res.append(res[k]+[tail]*l)\\n            return res\\n            \\n        nums = sorted(nums)\\n        return helper(nums, 0, len(nums)-1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 30196,
                "title": "backtrack-summary-general-solution-for-10-questions-python-combination-sum-subsets-permutation-palindrome",
                "content": "For Java version, please refer to [isssac3's answer.](https://discuss.leetcode.com/topic/46162/a-general-approach-to-backtracking-questions-in-java-subsets-permutations-combination-sum-palindrome-partioning)\\n\\n**39. Combination Sum**\\nhttps://leetcode.com/problems/combination-sum/\\n```\\n    def combinationSum(self, candidates, target):\\n        def backtrack(tmp, start, end, target):\\n            if target == 0:\\n                ans.append(tmp[:])\\n            elif target > 0:\\n                for i in range(start, end):\\n                    tmp.append(candidates[i])\\n                    backtrack(tmp, i, end, target - candidates[i])\\n                    tmp.pop()\\n        ans = [] \\n        candidates.sort(reverse= True)\\n        backtrack([], 0, len(candidates), target)\\n        return ans\\n```\\n\\n**40. Combination Sum II**\\nhttps://leetcode.com/problems/combination-sum-ii/\\n```\\n    def combinationSum2(self, candidates, target):\\n        def backtrack(start, end, tmp, target):\\n            if target == 0:\\n                ans.append(tmp[:])\\n            elif target > 0:\\n                for i in range(start, end):\\n                    if i > start and candidates[i] == candidates[i-1]:\\n                        continue\\n                    tmp.append(candidates[i])\\n                    backtrack(i+1, end, tmp, target - candidates[i])\\n                    tmp.pop()\\n        ans = []\\n        candidates.sort(reverse= True)\\n        backtrack(0, len(candidates), [], target)\\n        return ans\\n```\\n\\n**78. Subsets**\\nhttps://leetcode.com/problems/subsets/\\n```\\n    def subsets(self, nums):\\n        def backtrack(start, end, tmp):\\n            ans.append(tmp[:])\\n            for i in range(start, end):\\n                tmp.append(nums[i])\\n                backtrack(i+1, end, tmp)\\n                tmp.pop()\\n        ans = []\\n        backtrack(0, len(nums), [])\\n        return ans\\n```\\n\\n**90. Subsets II**\\nhttps://leetcode.com/problems/subsets-ii/\\n```\\n    def subsetsWithDup(self, nums):\\n        def backtrack(start, end, tmp):\\n            ans.append(tmp[:])\\n            for i in range(start, end):\\n                if i > start and nums[i] == nums[i-1]:\\n                    continue\\n                tmp.append(nums[i])\\n                backtrack(i+1, end, tmp)\\n                tmp.pop()\\n        ans = []\\n        nums.sort()\\n        backtrack(0, len(nums), [])\\n        return ans\\n```\\n\\n**46. Permutations**\\nhttps://leetcode.com/problems/permutations/\\n```\\n    def permute(self, nums):\\n        def backtrack(start, end):\\n            if start == end:\\n                ans.append(nums[:])\\n            for i in range(start, end):\\n                nums[start], nums[i] = nums[i], nums[start]\\n                backtrack(start+1, end)\\n                nums[start], nums[i] = nums[i], nums[start]\\n                \\n        ans = []\\n        backtrack(0, len(nums))\\n        return ans\\n```\\n\\n**47. Permutations II**\\nhttps://leetcode.com/problems/permutations-ii/\\n```\\n    def permuteUnique(self, nums):\\n        def backtrack(tmp, size):\\n            if len(tmp) == size:\\n                ans.append(tmp[:])\\n            else:\\n                for i in range(size):\\n                    if visited[i] or (i > 0 and nums[i-1] == nums[i] and not visited[i-1]):\\n                        continue\\n                    visited[i] = True\\n                    tmp.append(nums[i])\\n                    backtrack(tmp, size)\\n                    tmp.pop()\\n                    visited[i] = False\\n        ans = []\\n        visited = [False] * len(nums)\\n        nums.sort()\\n        backtrack([], len(nums))\\n        return ans\\n```\\n\\n**60. Permutation Sequence**\\nhttps://leetcode.com/problems/permutation-sequence/\\n```\\n    def getPermutation(self, n, k):\\n        nums = [str(i) for i in range(1, n+1)]\\n        fact = [1] * n\\n        for i in range(1,n):\\n            fact[i] = i*fact[i-1]\\n        k -= 1\\n        ans = []\\n        for i in range(n, 0, -1):\\n            id = k / fact[i-1]\\n            k %= fact[i-1]\\n            ans.append(nums[id])\\n            nums.pop(id)\\n        return ''.join(ans)\\n```\\n\\n**131. Palindrome Partitioning**\\nhttps://leetcode.com/problems/palindrome-partitioning/\\n```\\n    def partition(self, s):\\n        def backtrack(start, end, tmp):\\n            if start == end:\\n                ans.append(tmp[:])\\n            for i in range(start, end):\\n                cur = s[start:i+1]\\n                if cur == cur[::-1]:\\n                    tmp.append(cur)\\n                    backtrack(i+1, end, tmp)\\n                    tmp.pop()\\n        ans = []\\n        backtrack(0, len(s), [])\\n        return ans\\n```\\n\\n****\\n\\n\\n**267. Palindrome Permutation II**\\nhttps://leetcode.com/problems/palindrome-permutation-ii/\\nRelated to this two:\\n`31. Next Permutation`: https://leetcode.com/problems/next-permutation/\\n`266. Palindrome Permutation`: https://leetcode.com/problems/palindrome-permutation/\\n\\n```\\n    def generatePalindromes(self, s):\\n        kv = collections.Counter(s)\\n        mid = [k for k, v in kv.iteritems() if v%2]\\n        if len(mid) > 1:\\n            return []\\n        mid = '' if mid == [] else mid[0]\\n        half = ''.join([k * (v/2) for k, v in kv.iteritems()])\\n        half = [c for c in half]\\n        \\n        def backtrack(end, tmp):\\n            if len(tmp) == end:\\n                cur = ''.join(tmp)\\n                ans.append(cur + mid + cur[::-1])\\n            else:\\n                for i in range(end):\\n                    if visited[i] or (i>0 and half[i] == half[i-1] and not visited[i-1]):\\n                        continue\\n                    visited[i] = True\\n                    tmp.append(half[i])\\n                    backtrack(end, tmp)\\n                    visited[i] = False\\n                    tmp.pop()\\n                    \\n        ans = []\\n        visited = [False] * len(half)\\n        backtrack(len(half), [])\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\n    def combinationSum(self, candidates, target):\\n        def backtrack(tmp, start, end, target):\\n            if target == 0:\\n                ans.append(tmp[:])\\n            elif target > 0:\\n                for i in range(start, end):\\n                    tmp.append(candidates[i])\\n                    backtrack(tmp, i, end, target - candidates[i])\\n                    tmp.pop()\\n        ans = [] \\n        candidates.sort(reverse= True)\\n        backtrack([], 0, len(candidates), target)\\n        return ans\\n```\n```\\n    def combinationSum2(self, candidates, target):\\n        def backtrack(start, end, tmp, target):\\n            if target == 0:\\n                ans.append(tmp[:])\\n            elif target > 0:\\n                for i in range(start, end):\\n                    if i > start and candidates[i] == candidates[i-1]:\\n                        continue\\n                    tmp.append(candidates[i])\\n                    backtrack(i+1, end, tmp, target - candidates[i])\\n                    tmp.pop()\\n        ans = []\\n        candidates.sort(reverse= True)\\n        backtrack(0, len(candidates), [], target)\\n        return ans\\n```\n```\\n    def subsets(self, nums):\\n        def backtrack(start, end, tmp):\\n            ans.append(tmp[:])\\n            for i in range(start, end):\\n                tmp.append(nums[i])\\n                backtrack(i+1, end, tmp)\\n                tmp.pop()\\n        ans = []\\n        backtrack(0, len(nums), [])\\n        return ans\\n```\n```\\n    def subsetsWithDup(self, nums):\\n        def backtrack(start, end, tmp):\\n            ans.append(tmp[:])\\n            for i in range(start, end):\\n                if i > start and nums[i] == nums[i-1]:\\n                    continue\\n                tmp.append(nums[i])\\n                backtrack(i+1, end, tmp)\\n                tmp.pop()\\n        ans = []\\n        nums.sort()\\n        backtrack(0, len(nums), [])\\n        return ans\\n```\n```\\n    def permute(self, nums):\\n        def backtrack(start, end):\\n            if start == end:\\n                ans.append(nums[:])\\n            for i in range(start, end):\\n                nums[start], nums[i] = nums[i], nums[start]\\n                backtrack(start+1, end)\\n                nums[start], nums[i] = nums[i], nums[start]\\n                \\n        ans = []\\n        backtrack(0, len(nums))\\n        return ans\\n```\n```\\n    def permuteUnique(self, nums):\\n        def backtrack(tmp, size):\\n            if len(tmp) == size:\\n                ans.append(tmp[:])\\n            else:\\n                for i in range(size):\\n                    if visited[i] or (i > 0 and nums[i-1] == nums[i] and not visited[i-1]):\\n                        continue\\n                    visited[i] = True\\n                    tmp.append(nums[i])\\n                    backtrack(tmp, size)\\n                    tmp.pop()\\n                    visited[i] = False\\n        ans = []\\n        visited = [False] * len(nums)\\n        nums.sort()\\n        backtrack([], len(nums))\\n        return ans\\n```\n```\\n    def getPermutation(self, n, k):\\n        nums = [str(i) for i in range(1, n+1)]\\n        fact = [1] * n\\n        for i in range(1,n):\\n            fact[i] = i*fact[i-1]\\n        k -= 1\\n        ans = []\\n        for i in range(n, 0, -1):\\n            id = k / fact[i-1]\\n            k %= fact[i-1]\\n            ans.append(nums[id])\\n            nums.pop(id)\\n        return ''.join(ans)\\n```\n```\\n    def partition(self, s):\\n        def backtrack(start, end, tmp):\\n            if start == end:\\n                ans.append(tmp[:])\\n            for i in range(start, end):\\n                cur = s[start:i+1]\\n                if cur == cur[::-1]:\\n                    tmp.append(cur)\\n                    backtrack(i+1, end, tmp)\\n                    tmp.pop()\\n        ans = []\\n        backtrack(0, len(s), [])\\n        return ans\\n```\n```\\n    def generatePalindromes(self, s):\\n        kv = collections.Counter(s)\\n        mid = [k for k, v in kv.iteritems() if v%2]\\n        if len(mid) > 1:\\n            return []\\n        mid = '' if mid == [] else mid[0]\\n        half = ''.join([k * (v/2) for k, v in kv.iteritems()])\\n        half = [c for c in half]\\n        \\n        def backtrack(end, tmp):\\n            if len(tmp) == end:\\n                cur = ''.join(tmp)\\n                ans.append(cur + mid + cur[::-1])\\n            else:\\n                for i in range(end):\\n                    if visited[i] or (i>0 and half[i] == half[i-1] and not visited[i-1]):\\n                        continue\\n                    visited[i] = True\\n                    tmp.append(half[i])\\n                    backtrack(end, tmp)\\n                    visited[i] = False\\n                    tmp.pop()\\n                    \\n        ans = []\\n        visited = [False] * len(half)\\n        backtrack(len(half), [])\\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3513086,
                "title": "c-recursive-solution-100-beat-easy-to-understand",
                "content": "# Code\\n```\\nclass Solution {\\nprivate:\\n\\n    void subset(int index,vector<int>&nums,vector<int>&ds,vector<vector<int>>&ans){\\n        ans.push_back(ds);\\n        for(int i=index;i<nums.size();i++){\\n            if(i!=index && nums[i]==nums[i-1]) continue;\\n            ds.push_back(nums[i]);\\n            subset(i+1,nums,ds,ans);\\n            ds.pop_back();\\n        }\\n    }\\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        vector<vector<int>>ans;\\n        vector<int>ds;\\n        sort(nums.begin(),nums.end());\\n        subset(0,nums,ds,ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n\\n    void subset(int index,vector<int>&nums,vector<int>&ds,vector<vector<int>>&ans){\\n        ans.push_back(ds);\\n        for(int i=index;i<nums.size();i++){\\n            if(i!=index && nums[i]==nums[i-1]) continue;\\n            ds.push_back(nums[i]);\\n            subset(i+1,nums,ds,ans);\\n            ds.pop_back();\\n        }\\n    }\\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        vector<vector<int>>ans;\\n        vector<int>ds;\\n        sort(nums.begin(),nums.end());\\n        subset(0,nums,ds,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1728917,
                "title": "java-easy-to-understand-same-logic-of-subsets-1",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        HashSet<List<Integer>> res = new HashSet<>(); // No need to add duplicate subsets so hashset is used\\n        backtrack(nums,res,new ArrayList<>(),0); \\n        List<List<Integer>> ans = res.stream().map(i->i).collect(Collectors.toList()); // convert hashset to list\\n        return ans;\\n    }\\n    public void backtrack(int[] nums,HashSet<List<Integer>> res,List<Integer> list,int idx){\\n        if(idx == nums.length){\\n            List<Integer> l = new ArrayList<>(list); // new list so the orignal list does no get changed\\n            Collections.sort(l); // sorting the subsets \\n            res.add(l);\\n            return;\\n        }\\n        list.add(nums[idx]);  // number gets picked\\n        backtrack(nums,res,list,idx+1);\\n        list.remove(list.size()-1); // number does not get picked\\n        backtrack(nums,res,list,idx+1);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        HashSet<List<Integer>> res = new HashSet<>(); // No need to add duplicate subsets so hashset is used\\n        backtrack(nums,res,new ArrayList<>(),0); \\n        List<List<Integer>> ans = res.stream().map(i->i).collect(Collectors.toList()); // convert hashset to list\\n        return ans;\\n    }\\n    public void backtrack(int[] nums,HashSet<List<Integer>> res,List<Integer> list,int idx){\\n        if(idx == nums.length){\\n            List<Integer> l = new ArrayList<>(list); // new list so the orignal list does no get changed\\n            Collections.sort(l); // sorting the subsets \\n            res.add(l);\\n            return;\\n        }\\n        list.add(nums[idx]);  // number gets picked\\n        backtrack(nums,res,list,idx+1);\\n        list.remove(list.size()-1); // number does not get picked\\n        backtrack(nums,res,list,idx+1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1662559,
                "title": "java-solution-and-explanation-with-time-and-space-complexity",
                "content": "\\n```\\nclass Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        \\n        //make sure to sort the array in ascending order so that we can detect the dupicates side by side\\n        Arrays.sort(nums);\\n        \\n        //create a list of list of integer anslist to return in the end\\n        //this is the array list that will contain all the unique subsets lists\\n        ArrayList<List<Integer>> ansList = new ArrayList<>();\\n        \\n        //Now lets call the recursion\\n        findUniqueSubSets(0, nums, new ArrayList<Integer>(), ansList);\\n        //the ArrayList<Integer>() is here because we need to return List<List<Integer>> here so \\n        //our main arrayList is ansList which we\\'ve already defined\\n        //this ArrayList<Integer>() we\\'ve defined so that we can store our individual lists here\\n        //and we\\'ll add this list to main list i.e ansList\\n        \\n        return ansList;\\n    }\\n    \\n    public void findUniqueSubSets(int ind, int[] nums, ArrayList<Integer> ds, ArrayList<List<Integer>> ansList)\\n    {\\n        //initially we add an empty list to our ansList \\n        //to generate an empty list like this -> [] \\n        ansList.add(new ArrayList<Integer>(ds));\\n        \\n        //start chking from 0th to n-1th index. using for loop\\n        for(int i = ind; i< nums.length; i++)\\n        {\\n            //chk for duplicates if any just avoid them\\n            if( i != ind && nums[i] == nums[i-1]) continue;\\n            //i != ind . ind is the first index always for which we are chking \\n            //so if i is not ind then we are not visiting that element \\n            //for the first time and might be and that might be a duplicate \\n            //which we again chk using nums[i] == nums[i-1]\\n            \\n            //if we came across this if condition that only means that we are at an element \\n            //which is not a duplicate \\n            //so we have to add it to our arryalist ds\\n            ds.add(nums[i]);\\n            \\n            //again call recursion for the next index\\n            findUniqueSubSets(i+1, nums, ds, ansList);\\n            \\n            //while returning make sure to remove the element we added because \\n            //we wouldn\\'t want that to be present for the next recursion call\\n            ds.remove(ds.size() -1);\\n                \\n        }\\n    }\\n    \\n    }\\n    \\nTime Complexity: O(k * 2^n) -> O(2^n) for generating every subset + O(k) to insert every subset in another data structure. assuming average length of each subset is near about K.\\n\\nSpace Complexity: O(2^n * k) to store every subset and the Auxiliary space is O(n) if n is the depth of the recursion tree.\\n\\nI hope you find this helpful. Please do upvote in case you understood.\\nThankss!",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "class Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        \\n        //make sure to sort the array in ascending order so that we can detect the dupicates side by side\\n        Arrays.sort(nums);\\n        \\n        //create a list of list of integer anslist to return in the end\\n        //this is the array list that will contain all the unique subsets lists\\n        ArrayList<List<Integer>> ansList = new ArrayList<>();\\n        \\n        //Now lets call the recursion\\n        findUniqueSubSets(0, nums, new ArrayList<Integer>(), ansList);\\n        //the ArrayList<Integer>() is here because we need to return List<List<Integer>> here so \\n        //our main arrayList is ansList which we\\'ve already defined\\n        //this ArrayList<Integer>() we\\'ve defined so that we can store our individual lists here\\n        //and we\\'ll add this list to main list i.e ansList\\n        \\n        return ansList;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1380340,
                "title": "c-standard-backtracking-template",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> result;\\n    void backtrack(vector<int>& nums, vector<int> temp, int idx) {\\n        result.push_back(temp);\\n        if(idx >= nums.size())\\n            return;\\n        \\n        for(int i = idx; i<nums.size(); i++) {\\n            if(i > idx && nums[i] == nums[i-1]) continue; //avoid duplicates\\n            \\n            temp.push_back(nums[i]);     //include\\n            backtrack(nums, temp, i+1);  //explore\\n            temp.pop_back();             //exclude\\n        }\\n    }\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        result.clear();\\n        \\n        vector<int> temp;\\n        sort(begin(nums), end(nums)); //will help avoiding duplicates\\n        backtrack(nums, temp, 0);\\n        \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> result;\\n    void backtrack(vector<int>& nums, vector<int> temp, int idx) {\\n        result.push_back(temp);\\n        if(idx >= nums.size())\\n            return;\\n        \\n        for(int i = idx; i<nums.size(); i++) {\\n            if(i > idx && nums[i] == nums[i-1]) continue; //avoid duplicates\\n            \\n            temp.push_back(nums[i]);     //include\\n            backtrack(nums, temp, i+1);  //explore\\n            temp.pop_back();             //exclude\\n        }\\n    }\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        result.clear();\\n        \\n        vector<int> temp;\\n        sort(begin(nums), end(nums)); //will help avoiding duplicates\\n        backtrack(nums, temp, 0);\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1217790,
                "title": "simple-c-solution-with-explanation-easiest-way-to-remove-duplicates-not-using-sets",
                "content": "To get all the subsets, for each element in the array, we have 2 choices \\nEither include it in subset or not.\\nJust need to improve on that approach to **remove duplicates**, which can be done easily by just making sure that if the last element in our present subset is equal to our present element, then you have to surely include present element in the subset , i.e, dont skip the present element.\\nThe subset which will form if we don\\'t include the present element will lead to duplicacy.\\nBasically :\\n```\\nif nums[posn] = subset.back() //  subset.back() = last element in our present subset\\n\\t\\tnext recursion call after including nums[posn] in the subset\\nelse \\t\\n\\t\\t1. recursion call without including present element\\n\\t\\t2. recursion call after including present element\\n\\t\\t\\n```\\n###  C++ code \\n```\\nclass Solution {\\n    // Final 2d array/vector to hold the answer\\n    vector<vector<int>> ans;\\npublic:\\n    void fun(vector<int> nums,int n,vector<int> v,int i=0)\\n    {\\n        // when posn reaches the end of the input array, insert the present vector in to ans.     \\n        if(i==n){\\n            ans.push_back(v);\\n            return;\\n        }\\n        /* when present element is not equal to last element in vector,\\n        then only skip the                  \\n        present element */    \\n        if(v.empty()||v.back()!=nums[i])\\n        {\\n            fun(nums,n,v,i+1);\\n        }\\n        /* add the present element to the present subset and call for the remaining array */\\n        v.push_back(nums[i]);\\n        fun(nums,n,v,i+1);\\n    }\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        vector<int> v;\\n        // Sort the input array so that all duplicate elements are together.\\n        sort(nums.begin(),nums.end());\\n        \\n        fun(nums,nums.size(),v);\\n        \\n        return ans;\\n    }\\n};\\n```\\nps:- try to make the recursion tree for an example test case ( [1,2,2] ) to understand it better.",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nif nums[posn] = subset.back() //  subset.back() = last element in our present subset\\n\\t\\tnext recursion call after including nums[posn] in the subset\\nelse \\t\\n\\t\\t1. recursion call without including present element\\n\\t\\t2. recursion call after including present element\\n\\t\\t\\n```\n```\\nclass Solution {\\n    // Final 2d array/vector to hold the answer\\n    vector<vector<int>> ans;\\npublic:\\n    void fun(vector<int> nums,int n,vector<int> v,int i=0)\\n    {\\n        // when posn reaches the end of the input array, insert the present vector in to ans.     \\n        if(i==n){\\n            ans.push_back(v);\\n            return;\\n        }\\n        /* when present element is not equal to last element in vector,\\n        then only skip the                  \\n        present element */    \\n        if(v.empty()||v.back()!=nums[i])\\n        {\\n            fun(nums,n,v,i+1);\\n        }\\n        /* add the present element to the present subset and call for the remaining array */\\n        v.push_back(nums[i]);\\n        fun(nums,n,v,i+1);\\n    }\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        vector<int> v;\\n        // Sort the input array so that all duplicate elements are together.\\n        sort(nums.begin(),nums.end());\\n        \\n        fun(nums,nums.size(),v);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 726404,
                "title": "java-backtracking-easy-to-understand-explanation",
                "content": "\\n```\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        List<List<Integer>> resultList=new ArrayList();\\n        Arrays.sort(nums);\\n        backTrack(resultList,new ArrayList(),nums,0);\\n        return resultList;\\n    }\\n    \\n    private void backTrack(List<List<Integer>> resultList, List<Integer> currentList, int []nums, int start) {\\n\\t    resultList.add(new ArrayList(currentList));\\n        for(int i=start;i<nums.length;i++)  {\\n            if(i>start&&nums[i]==nums[i-1]) continue; // to avoid duplicates\\n            currentList.add(nums[i]);\\n            backTrack(resultList,currentList,nums,i+1);\\n            currentList.remove(currentList.size()-1);\\n        }\\n    }\\n}\\n```\\nIf you can follow the Numbers and the arrows you will get the idea \\nif you didn\\'t understand any point let me know and will try to explain it again\\n\\n![image](https://assets.leetcode.com/users/images/d81b304b-f002-4049-a57b-d0513f8f714b_1594493500.5942798.png)\\n",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        List<List<Integer>> resultList=new ArrayList();\\n        Arrays.sort(nums);\\n        backTrack(resultList,new ArrayList(),nums,0);\\n        return resultList;\\n    }\\n    \\n    private void backTrack(List<List<Integer>> resultList, List<Integer> currentList, int []nums, int start) {\\n\\t    resultList.add(new ArrayList(currentList));\\n        for(int i=start;i<nums.length;i++)  {\\n            if(i>start&&nums[i]==nums[i-1]) continue; // to avoid duplicates\\n            currentList.add(nums[i]);\\n            backTrack(resultList,currentList,nums,i+1);\\n            currentList.remove(currentList.size()-1);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 124257,
                "title": "javascript-68-ms-98-88",
                "content": "```\\nvar subsetsWithDup = function(nums) {\\n        \\n    nums = nums.sort((a,b) => a-b);\\n    \\n    const res = [];\\n    \\n    function fn(length, start=0, arr = []) {\\n        if (arr.length === length) {\\n            res.push(arr.slice());\\n            return;\\n        }\\n        for(let i=start; i<nums.length; i++) {       \\n            if (i !== start && nums[i-1] === nums[i]) continue;\\n            arr.push(nums[i]);\\n            fn(length, i+1, arr);\\n            arr.pop();            \\n        }\\n    }\\n    \\n    for(let length=0; length<=nums.length; length++) {\\n        fn(length);\\n    }\\n    \\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar subsetsWithDup = function(nums) {\\n        \\n    nums = nums.sort((a,b) => a-b);\\n    \\n    const res = [];\\n    \\n    function fn(length, start=0, arr = []) {\\n        if (arr.length === length) {\\n            res.push(arr.slice());\\n            return;\\n        }\\n        for(let i=start; i<nums.length; i++) {       \\n            if (i !== start && nums[i-1] === nums[i]) continue;\\n            arr.push(nums[i]);\\n            fn(length, i+1, arr);\\n            arr.pop();            \\n        }\\n    }\\n    \\n    for(let length=0; length<=nums.length; length++) {\\n        fn(length);\\n    }\\n    \\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 30146,
                "title": "c-subsets-and-subsets-ii-almost-same-recursive-method",
                "content": "Subset\\n```\\nclass Solution{\\npublic:\\n\\tvector<vector<int>> subsets(vector<int>& nums){\\n\\t\\tvector<vector<int>> res;\\n\\t\\tsubsets(res,nums,0,vector<int>());\\n\\t\\treturn res;\\n\\n\\t}\\n\\tvoid subsets(vector<vector<int>>& res,const vector<int>& nums,int pos,vector<int> temp){\\n\\t\\tif(pos==nums.size()){\\n\\t\\t\\tres.push_back(temp);\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tsubsets(res,nums,pos+1,temp);\\n\\t\\ttemp.push_back(nums[pos]);\\n\\t\\tsubsets(res,nums,pos+1,temp);\\n\\t}\\n};\\n```\\nSubset 2\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        vector<vector<int>> res;\\n        sort(nums.begin(),nums.end());\\n        subset(res,nums,vector<int>(),0);\\n        return res;\\n    }\\n    void subset(vector<vector<int>>& res,const vector<int>& nums,vector<int> temp,int pos){\\n        if(pos>=nums.size()){\\n            res.push_back(temp);\\n            return;\\n        }\\n        int cnt=0;\\n        while(pos+cnt<nums.size()&&nums[pos]==nums[pos+cnt]){\\n            cnt++;\\n        }\\n        subset(res,nums,temp,pos+cnt);\\n        for(int i=1;i<=cnt;++i){\\n            temp.push_back(nums[pos]);\\n            subset(res,nums,temp,pos+cnt);\\n        }\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution{\\npublic:\\n\\tvector<vector<int>> subsets(vector<int>& nums){\\n\\t\\tvector<vector<int>> res;\\n\\t\\tsubsets(res,nums,0,vector<int>());\\n\\t\\treturn res;\\n\\n\\t}\\n\\tvoid subsets(vector<vector<int>>& res,const vector<int>& nums,int pos,vector<int> temp){\\n\\t\\tif(pos==nums.size()){\\n\\t\\t\\tres.push_back(temp);\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tsubsets(res,nums,pos+1,temp);\\n\\t\\ttemp.push_back(nums[pos]);\\n\\t\\tsubsets(res,nums,pos+1,temp);\\n\\t}\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        vector<vector<int>> res;\\n        sort(nums.begin(),nums.end());\\n        subset(res,nums,vector<int>(),0);\\n        return res;\\n    }\\n    void subset(vector<vector<int>>& res,const vector<int>& nums,vector<int> temp,int pos){\\n        if(pos>=nums.size()){\\n            res.push_back(temp);\\n            return;\\n        }\\n        int cnt=0;\\n        while(pos+cnt<nums.size()&&nums[pos]==nums[pos+cnt]){\\n            cnt++;\\n        }\\n        subset(res,nums,temp,pos+cnt);\\n        for(int i=1;i<=cnt;++i){\\n            temp.push_back(nums[pos]);\\n            subset(res,nums,temp,pos+cnt);\\n        }\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 30202,
                "title": "c-6ms-dp-clean-code-explanation",
                "content": "C++, 6ms: DP, Simple & Clean Code\\n**Time:** O(n*2^n)\\n**Space:** O(2^n)\\n\\n**Solution:**\\n```\\nvector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n    sort(nums.begin(), nums.end());\\n\\n    vector<vector<int>> r;\\n    r.push_back(vector<int>());\\n    int prev = 1; \\n    \\n    for(int i = 0; i < nums.size(); ++i){\\n        int n = r.size();\\n        int start = (i == 0 || (i > 0 && nums[i] != nums[i-1]) ? 0 : (n - prev));\\n        \\n        prev = 0;\\n        for(int j = start; j < n; ++j){\\n            r.push_back(r[j]);\\n            r.back().push_back(nums[i]);\\n            ++prev;\\n        }\\n    }\\n    \\n    return r;\\n}\\n```\\n\\n**Explanation:**\\n\\nI will first show you how the algorithm works with an input array containing no duplication.\\n\\nFor example, Input: `[1, 2, 3]`\\n\\nWe first add the empty set to the result.\\nThen, for each number in the input, we will concatenate the current number with all the previous results to generate a new set. \\n```\\nBegin\\n1st Round: []\\n\\n[1, 2, 3]\\n ^\\n2nd Round: [].push_back(1)\\nSets generated: [1]\\n\\n[1, 2, 3]\\n    ^\\n3rd Round: [].push_back(2), [1].push_back(2)\\nSets generated: [2], [1,2]\\n\\n[1, 2, 3]\\n       ^\\n4th Round: [].push_back(3), [1].push_back(3), [2].push_back(3), [1, 2].push_back(3)\\nSets generated: [3], [1, 3], [2, 3], [1, 2, 3]\\n```\\nThen, ` { [ ], [1], [2], [1, 2], [3], [1, 3], [2, 3], [1, 2, 3] } ` is our answer.\\n\\nNow, let's take a look at an example with duplication.\\nFor example, Input: `[1, 2, 2]`\\n```\\nBegin\\n1st Round: []\\n\\n[1, 2, 2]\\n ^\\n2nd Round: [].push_back(1)\\nSets generated: [1]\\n\\n[1, 2, 2]\\n    ^\\n3rd Round: [].push_back(2), [1].push_back(2)\\nSets generated: [2], [1, 2]\\n\\n[1, 2, 2]\\n       ^\\n4th Round: [].push_back(2), [1].push_back(2), [2].push_back(2), [1, 2].push_back(2)\\nSets generated: [2], [1, 2], [2, 2], [1, 2, 2]\\n```\\n\\nYou can observe that the first 2 sets generated in the 4th round are duplication of 3rd round's sets.\\nTo fix this problem, we will need to remember how many items were added to our solution which was 2.\\nThen, we can avoid using [ ], [1] which were used in the 3rd round to generate those 2 sets.\\n```\\nBegin\\n1st Round: []\\n\\n[1, 2, 2]\\n ^\\n2nd Round: [].push_back(1)\\nSets generated: [1]\\n\\n[1, 2, 2]\\n    ^\\n3rd Round: [].push_back(2), [1].push_back(2)\\nSets generated: [2], [1, 2]\\n\\n[1, 2, 2]\\n       ^\\n4th Round: [2].push_back(2), [1, 2].push_back(2)\\nSets generated: [2, 2], [1, 2, 2]\\n```\\n\\nNow, you should be able to understand this part of the code.\\n```\\nint start = (i == 0 || (i > 0 && nums[i] != nums[i-1]) ? 0 : (n - prev));\\n```\\nDon't forget to sort the input array first, otherwise `nums[i] != nums[i-1]` comparison just does not make sense.",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nvector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n    sort(nums.begin(), nums.end());\\n\\n    vector<vector<int>> r;\\n    r.push_back(vector<int>());\\n    int prev = 1; \\n    \\n    for(int i = 0; i < nums.size(); ++i){\\n        int n = r.size();\\n        int start = (i == 0 || (i > 0 && nums[i] != nums[i-1]) ? 0 : (n - prev));\\n        \\n        prev = 0;\\n        for(int j = start; j < n; ++j){\\n            r.push_back(r[j]);\\n            r.back().push_back(nums[i]);\\n            ++prev;\\n        }\\n    }\\n    \\n    return r;\\n}\\n```\n```\\nBegin\\n1st Round: []\\n\\n[1, 2, 3]\\n ^\\n2nd Round: [].push_back(1)\\nSets generated: [1]\\n\\n[1, 2, 3]\\n    ^\\n3rd Round: [].push_back(2), [1].push_back(2)\\nSets generated: [2], [1,2]\\n\\n[1, 2, 3]\\n       ^\\n4th Round: [].push_back(3), [1].push_back(3), [2].push_back(3), [1, 2].push_back(3)\\nSets generated: [3], [1, 3], [2, 3], [1, 2, 3]\\n```\n```\\nBegin\\n1st Round: []\\n\\n[1, 2, 2]\\n ^\\n2nd Round: [].push_back(1)\\nSets generated: [1]\\n\\n[1, 2, 2]\\n    ^\\n3rd Round: [].push_back(2), [1].push_back(2)\\nSets generated: [2], [1, 2]\\n\\n[1, 2, 2]\\n       ^\\n4th Round: [].push_back(2), [1].push_back(2), [2].push_back(2), [1, 2].push_back(2)\\nSets generated: [2], [1, 2], [2, 2], [1, 2, 2]\\n```\n```\\nBegin\\n1st Round: []\\n\\n[1, 2, 2]\\n ^\\n2nd Round: [].push_back(1)\\nSets generated: [1]\\n\\n[1, 2, 2]\\n    ^\\n3rd Round: [].push_back(2), [1].push_back(2)\\nSets generated: [2], [1, 2]\\n\\n[1, 2, 2]\\n       ^\\n4th Round: [2].push_back(2), [1, 2].push_back(2)\\nSets generated: [2, 2], [1, 2, 2]\\n```\n```\\nint start = (i == 0 || (i > 0 && nums[i] != nums[i-1]) ? 0 : (n - prev));\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3742710,
                "title": "python3-simple-recursive-solution",
                "content": "# Intuition\\nThe intuition behind the code is to use a recursive approach to generate subsets. At each step, we have two choices: either include the current element in the subset or exclude it. By making these choices for each element in the array, we can generate all possible subsets.\\n\\n# Approach\\n**Sort the array nums** \\nSorting the array ensures that duplicate elements will appear next to each other, making it easier to handle them later in the code.\\n\\n**Create the recursive function subsets** \\nThis function takes two parameters: index (the current index being considered) and elements (the current subset being constructed).\\n\\n**Handle base case** \\nIf the current index reaches the length of the array (index == len(nums)), it means we have processed all elements. At this point, we check if the elements subset is already present in the res list. If not, we append it to res. This check is necessary to avoid duplicate subsets.\\n\\n**Make recursive calls**\\n**Not Pick**\\nCall subsets recursively with the next index without picking the current element (subsets(index + 1, elements)). This represents the choice of excluding the current element from the subset.\\n**Pick**\\nCall subsets recursively with the next index, including the current element (subsets(index + 1, elements + [nums[index]])). This represents the choice of picking the current element and adding it to the subset.\\n\\n**Duplicate Check**\\nThe code avoids duplicates by checking if a subset already exists in the res list before appending it. We sort the input array in the start to ensure that duplicate elements will be adjacent, simplifying the duplicate check.\\n\\nNow, we call the subsets function initially with index = 0 and an empty elements list.\\n\\nFinally, we return the final res list containing all the generated subsets.\\n\\n# Complexity\\n- Time complexity: **O(2^n)** \\n\\n- Space complexity: **O(2^n)** \\n\\n# Code\\n```\\nclass Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        nums.sort()\\n        def subsets(index, elements):\\n            # base case\\n            if index == len(nums):\\n                res.append(elements) if elements not in res else None\\n                return\\n\\n            subsets(index + 1, elements) # not pick\\n            subsets(index + 1, elements + [nums[index]]) # pick\\n\\n        subsets(0, [])\\n        return res\\n```",
                "solutionTags": [
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        nums.sort()\\n        def subsets(index, elements):\\n            # base case\\n            if index == len(nums):\\n                res.append(elements) if elements not in res else None\\n                return\\n\\n            subsets(index + 1, elements) # not pick\\n            subsets(index + 1, elements + [nums[index]]) # pick\\n\\n        subsets(0, [])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3596532,
                "title": "best-solution",
                "content": "# Approach\\nUsing Recursion\\n\\n# Complexity\\n- Time complexity:\\n$$O(2^n*k)$$ --> k is average length of every subset\\n\\n- Space complexity:\\n$$O(2^n*k)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:    \\n    void subsetHelper(int idx, vector<int>& nums, int n, vector<int> &temp, vector<vector<int>>& ans) {\\n        ans.push_back(temp);\\n        for (int i = idx; i < n; i++) {\\n            if (i != idx && nums[i] == nums[i-1])\\n                continue;\\n            temp.push_back(nums[i]);\\n            subsetHelper(i+1, nums, n, temp, ans);\\n            temp.pop_back();\\n        }\\n    }\\n\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<vector<int>> ans;\\n        vector<int> temp;\\n        sort(nums.begin(), nums.end());\\n        subsetHelper(0, nums, n, temp, ans);\\n        return ans;\\n    } \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:    \\n    void subsetHelper(int idx, vector<int>& nums, int n, vector<int> &temp, vector<vector<int>>& ans) {\\n        ans.push_back(temp);\\n        for (int i = idx; i < n; i++) {\\n            if (i != idx && nums[i] == nums[i-1])\\n                continue;\\n            temp.push_back(nums[i]);\\n            subsetHelper(i+1, nums, n, temp, ans);\\n            temp.pop_back();\\n        }\\n    }\\n\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<vector<int>> ans;\\n        vector<int> temp;\\n        sort(nums.begin(), nums.end());\\n        subsetHelper(0, nums, n, temp, ans);\\n        return ans;\\n    } \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3070879,
                "title": "c-easy-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    // vector<vector<int>>ans;\\n    void f(set<vector<int>>& res,const vector<int>& nums,int pos,vector<int> temp){\\n\\t\\tif(pos==nums.size()){\\n            sort(temp.begin(),temp.end());\\n\\t\\t\\tres.insert(temp);\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tf(res,nums,pos+1,temp);\\n\\t\\ttemp.push_back(nums[pos]);\\n\\t\\tf(res,nums,pos+1,temp);\\n        temp.pop_back();\\n\\t}\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        int n=nums.size();\\n        set<vector<int>>res;\\n        vector<int>temp;\\n        f(res,nums,0,temp);\\n        vector<vector<int>>ans;\\n        for(auto it : res){\\n            ans.push_back(it);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // vector<vector<int>>ans;\\n    void f(set<vector<int>>& res,const vector<int>& nums,int pos,vector<int> temp){\\n\\t\\tif(pos==nums.size()){\\n            sort(temp.begin(),temp.end());\\n\\t\\t\\tres.insert(temp);\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tf(res,nums,pos+1,temp);\\n\\t\\ttemp.push_back(nums[pos]);\\n\\t\\tf(res,nums,pos+1,temp);\\n        temp.pop_back();\\n\\t}\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        int n=nums.size();\\n        set<vector<int>>res;\\n        vector<int>temp;\\n        f(res,nums,0,temp);\\n        vector<vector<int>>ans;\\n        for(auto it : res){\\n            ans.push_back(it);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1506092,
                "title": "java-concise-4-solutions-0-ms-100-beats",
                "content": "**1. Regular recursion**\\n```\\n// Each recursion level focuses on all the following elements.\\n// We scan through all the following elements and decide whether to choose or not choose that element. (Every level split into N branches.)\\nclass Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        Arrays.sort(nums);\\n        subsets(nums, 0, new LinkedList<>(), result);\\n        return result;\\n    }\\n    \\n    private void subsets(int[] nums, int start, LinkedList<Integer> set, List<List<Integer>> sets) {\\n        sets.add(new ArrayList(set));\\n        for(int i=start; i<nums.length; i++) {\\n            // If candidate[i] equals candidate[i-1], then solutions for i is subset of solution of i-1\\n            // Refer: https://leetcode.com/problems/combination-sum-ii/discuss/16861/Java-solution-using-dfs-easy-understand/977097\\n            if (i==start || (i>start && nums[i] != nums[i-1])) {\\n                set.addLast(nums[i]);\\n                // \\'i+1\\' (not \\'i\\') because can\\'t reuse same element to help avoid duplicate subsets\\n                subsets(nums, i+1, set, sets);\\n                set.removeLast();\\n            }\\n        }\\n    }\\n}\\n```\\n**2. Optimized recursion**\\n```\\n// Each recursion level focuses on one element, we need to decide choose or not choose this element. (Every level split into 2 branches.)\\nclass Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n\\t    // Sort to assist check for adjacent elements to avoid duplicates\\n        Arrays.sort(nums);\\n        List<List<Integer>> res = new ArrayList<>();\\n        subsetsWithDup(res, new ArrayList<>(), nums, 0, false);\\n        return res;\\n    }\\n\\n    public void subsetsWithDup(List<List<Integer>> res, List<Integer> ls, int[] nums, int pos, boolean choosePre) {\\n\\t    // Update result with new set when all elements evaluated\\n        if(pos == nums.length) {\\n            res.add(new ArrayList<>(ls));\\n            return;\\n        }\\n        subsetsWithDup(res, ls, nums, pos+1, false);\\n\\t\\t// If previous is same and not chosen, then we can end up in duplicate set, hence skip\\n        if(pos>=1 && nums[pos]==nums[pos-1] && !choosePre) return;\\n        ls.add(nums[pos]);\\n        subsetsWithDup(res, ls, nums, pos+1, true);\\n        ls.remove(ls.size()-1);\\n    }\\n}\\n```\\n3. **Using Bit mask for set generation. Using sort (with hashset) for deduplication**\\n```\\nclass Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        // Get possible sets\\n        int possibleSets = 1<<nums.length;\\n        // Use hashset + sort to avoid duplicates\\n        Set<List<Integer>> sets = new HashSet<>();\\n        Arrays.sort(nums);\\n        // Pick a set to fill\\n        for (int i=0; i<possibleSets; i++) {\\n            List<Integer> set = new ArrayList<>();\\n            // Fill with nums[j] if the bit corresponding to the jth index in i is set\\n            for (int j=0; j<nums.length; j++) {\\n                if((1 & (i>>j)) == 1) {\\n                    set.add(nums[j]);\\n                }\\n            }\\n            sets.add(set);\\n        }\\n        return new ArrayList<>(sets);\\n    }\\n}\\n```\\n4. **Using Bit mask for set generation. Using sort (without hashset) for deduplication**\\n```\\nclass Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        // Get possible sets\\n        int possibleSets = 1<<nums.length;\\n        // Use sort + repeated element check to avoid duplicates\\n        List<List<Integer>> sets = new ArrayList<>();\\n        Arrays.sort(nums);\\n        // Pick a set to fill\\n        for (int i=0; i<possibleSets; i++) {\\n            List<Integer> set = new ArrayList<>();\\n            boolean duplicateSet = false;\\n            // Fill with nums[j] if the bit corresponding to the jth index in i is set\\n            for (int j=0; j<nums.length; j++) {\\n                // If jth element needs to be picked\\n                if ((1 & (i>>j)) == 1) {\\n                    // After we sort the array, the same number will be adjacent to each other.\\n                    // For example the set is {1,1,1}. We can get subset {} and {1} first. That\\'s great.\\n                    // Now, suppose we have a subset x, which including the second 1 but not the first 1, x is a duplicate.\\n                    if (j==0 || (j>0 && (nums[j] != nums[j-1] || (1 & (i>>(j-1))) == 1))) {\\n                        set.add(nums[j]);\\n                    } else {\\n                        duplicateSet = true;\\n                        break;\\n                    }\\n                }\\n            }\\n            if (!duplicateSet) {\\n                sets.add(set);\\n            }\\n        }\\n        return sets;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Bit Manipulation",
                    "Combinatorics"
                ],
                "code": "```\\n// Each recursion level focuses on all the following elements.\\n// We scan through all the following elements and decide whether to choose or not choose that element. (Every level split into N branches.)\\nclass Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        Arrays.sort(nums);\\n        subsets(nums, 0, new LinkedList<>(), result);\\n        return result;\\n    }\\n    \\n    private void subsets(int[] nums, int start, LinkedList<Integer> set, List<List<Integer>> sets) {\\n        sets.add(new ArrayList(set));\\n        for(int i=start; i<nums.length; i++) {\\n            // If candidate[i] equals candidate[i-1], then solutions for i is subset of solution of i-1\\n            // Refer: https://leetcode.com/problems/combination-sum-ii/discuss/16861/Java-solution-using-dfs-easy-understand/977097\\n            if (i==start || (i>start && nums[i] != nums[i-1])) {\\n                set.addLast(nums[i]);\\n                // \\'i+1\\' (not \\'i\\') because can\\'t reuse same element to help avoid duplicate subsets\\n                subsets(nums, i+1, set, sets);\\n                set.removeLast();\\n            }\\n        }\\n    }\\n}\\n```\n```\\n// Each recursion level focuses on one element, we need to decide choose or not choose this element. (Every level split into 2 branches.)\\nclass Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n\\t    // Sort to assist check for adjacent elements to avoid duplicates\\n        Arrays.sort(nums);\\n        List<List<Integer>> res = new ArrayList<>();\\n        subsetsWithDup(res, new ArrayList<>(), nums, 0, false);\\n        return res;\\n    }\\n\\n    public void subsetsWithDup(List<List<Integer>> res, List<Integer> ls, int[] nums, int pos, boolean choosePre) {\\n\\t    // Update result with new set when all elements evaluated\\n        if(pos == nums.length) {\\n            res.add(new ArrayList<>(ls));\\n            return;\\n        }\\n        subsetsWithDup(res, ls, nums, pos+1, false);\\n\\t\\t// If previous is same and not chosen, then we can end up in duplicate set, hence skip\\n        if(pos>=1 && nums[pos]==nums[pos-1] && !choosePre) return;\\n        ls.add(nums[pos]);\\n        subsetsWithDup(res, ls, nums, pos+1, true);\\n        ls.remove(ls.size()-1);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        // Get possible sets\\n        int possibleSets = 1<<nums.length;\\n        // Use hashset + sort to avoid duplicates\\n        Set<List<Integer>> sets = new HashSet<>();\\n        Arrays.sort(nums);\\n        // Pick a set to fill\\n        for (int i=0; i<possibleSets; i++) {\\n            List<Integer> set = new ArrayList<>();\\n            // Fill with nums[j] if the bit corresponding to the jth index in i is set\\n            for (int j=0; j<nums.length; j++) {\\n                if((1 & (i>>j)) == 1) {\\n                    set.add(nums[j]);\\n                }\\n            }\\n            sets.add(set);\\n        }\\n        return new ArrayList<>(sets);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        // Get possible sets\\n        int possibleSets = 1<<nums.length;\\n        // Use sort + repeated element check to avoid duplicates\\n        List<List<Integer>> sets = new ArrayList<>();\\n        Arrays.sort(nums);\\n        // Pick a set to fill\\n        for (int i=0; i<possibleSets; i++) {\\n            List<Integer> set = new ArrayList<>();\\n            boolean duplicateSet = false;\\n            // Fill with nums[j] if the bit corresponding to the jth index in i is set\\n            for (int j=0; j<nums.length; j++) {\\n                // If jth element needs to be picked\\n                if ((1 & (i>>j)) == 1) {\\n                    // After we sort the array, the same number will be adjacent to each other.\\n                    // For example the set is {1,1,1}. We can get subset {} and {1} first. That\\'s great.\\n                    // Now, suppose we have a subset x, which including the second 1 but not the first 1, x is a duplicate.\\n                    if (j==0 || (j>0 && (nums[j] != nums[j-1] || (1 & (i>>(j-1))) == 1))) {\\n                        set.add(nums[j]);\\n                    } else {\\n                        duplicateSet = true;\\n                        break;\\n                    }\\n                }\\n            }\\n            if (!duplicateSet) {\\n                sets.add(set);\\n            }\\n        }\\n        return sets;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1380488,
                "title": "c-easy-clean-solution-using-vector-set-and-multiset",
                "content": "**Solution:**\\n\\n1. Consider every subsequence as a collection of `bits`.\\n2. 0, 1, 10, 11, 100, 101, 110, 111, and so on.\\n3. We can observe that every `set bit(1)` indicates that we must include that particular element present in the array `nums` and every `unset bit(0)` indicates we must ignore that element.\\n4. Check for every number which particular bit is set or unset using `i & (1 << j)`. This formula helps us to know whether to include a particular element or not.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        int n = nums.size();\\n        int s = 1 << n;\\n        set<multiset<int>> ans;\\n        for(int i = 0; i < s; i++){\\n            multiset<int> temp;\\n            for(int j = 0; j < n; j++){\\n                if(i & (1 << j))\\n                    temp.insert(nums[j]);\\n            }\\n            ans.insert(temp);\\n        }\\n        vector<vector<int>> res;\\n        for(auto i: ans){\\n            multiset<int> temp = i;\\n            vector<int> set_to_vec{temp.begin(), temp.end()};\\n            res.push_back(set_to_vec);\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n**Feel free to share your ideas or any improvements as well.**",
                "solutionTags": [
                    "C",
                    "Bit Manipulation",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        int n = nums.size();\\n        int s = 1 << n;\\n        set<multiset<int>> ans;\\n        for(int i = 0; i < s; i++){\\n            multiset<int> temp;\\n            for(int j = 0; j < n; j++){\\n                if(i & (1 << j))\\n                    temp.insert(nums[j]);\\n            }\\n            ans.insert(temp);\\n        }\\n        vector<vector<int>> res;\\n        for(auto i: ans){\\n            multiset<int> temp = i;\\n            vector<int> set_to_vec{temp.begin(), temp.end()};\\n            res.push_back(set_to_vec);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 859563,
                "title": "python-sort-bfs-approach-without-additional-space",
                "content": "Hello,\\n\\nThis solution is similar to the subset I problem solution. The explaination is below.\\n\\n\\n```python\\n\\ndef subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        \\n\\t\\t# 1. Sort nums:\\n        nums.sort()\\n        \\n\\t\\t# 2. Find all subsets:\\n        combinations = [[]]\\n        combinations_len = 1\\n        for i in range(len(nums)):\\n            \\n\\t\\t\\t# If duplicate, start from the new items appended by the previous val\\n            start = combinations_len if i and nums[i] == nums[i - 1] else 0\\n\\t\\t\\t\\n            combinations_len = len(combinations)            \\n            for c in range(start, combinations_len):\\n                combinations.append(combinations[c] + [nums[i]])\\n                \\n        return combinations\\n\\n```\\n\\n1- Intuition:\\n- Subset problem (without duplicates):\\n\\t- Let\\'s have the following input: [1,2,3] and let\\'s `combinations` be our output\\n\\t- We\\'ll start with `combinations = [[]]`\\n\\t- For each value `n` in `nums`, merge it with every existing `combination` and append it to the output list\\n\\t- For `n: 1`:  append( `[] + [1]`)  into `combinations = [[], [1]]`\\n\\t- For `n: 2`:  append( `[] + [2]`, `[1] + [2]`)  into `combinations = [[], [1], [2], [1,2]]`\\n\\t- For `n: 3`:  append( `[] + [3]`, `[1] + [3]`, `[2] + [3]`, `[1,2] + [3]` )  into `combinations = [[], [1], [2], [1,2], [1,2,3]]`\\n\\n- Subset II problem (with duplicates):\\n\\t- It\\'s the same solution as the solution above. We just need to:\\n\\t\\t- (1). Identify duplicates => Sort `nums`\\n\\t\\t- (2). We need to avoid looping on all combinations when dealing with a duplicate. \\n\\t\\t- We need to start from a specific position of the list `combinations`\\n\\t- Let\\'s have the following input: [1,2,2,3,3] and suppose that it\\'s already sorted\\n\\t- For the `1st. n: 2`:  `combinations = [[], [1], [2], [1,2]]`\\n\\t- For the `2nd. n: 2`:  \\n\\t\\t- We need to avoid the existing combinations `[] + [2]`, `[1] + [2]` \\n\\t\\t- We need to consider only `[2] + [2]` and `[1,2] + [2]`\\n\\t\\t- In other words, we need to start from the combinations appended by previous `n: 2` \\n\\t\\t- `combinations = [[], [1], [2], [1,2], [2, 2], [1,2,2]]`\\n\\t- For the `1st. n: 3`:  `combinations = [[], [1], [2], [1,2], [2, 2], [1,2,2], [3], [1,3], [2,3], [1,2,3], [2,2,3],[1,2,2,3]]`\\n\\t- For the `2nd. n:3`\\n\\t\\t- We need to start from the combinations appended by previous `n: 3`: position: 6\\n\\t\\t- We\\'ll then append: `[3] + [3], [1,3] + [3] , ...,  [1,2,2,3] + [3]`\\n\\n2- Complexity Analysis:\\n- Let\\'s `n` be the number of values in `nums`\\n- Time Complexity: `O(n * 2^n)`\\n\\t\\t- The output `combinations` doubles for every value in `nums`: `O(2^n)` combinations (including duplicates)\\n\\t\\t- Every combination is created from merging a previous combination with a value: T(merge): `O(n)`\\n- Space Complexity: `O(n * 2^n)` (same as above)\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```python\\n\\ndef subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        \\n\\t\\t# 1. Sort nums:\\n        nums.sort()\\n        \\n\\t\\t# 2. Find all subsets:\\n        combinations = [[]]\\n        combinations_len = 1\\n        for i in range(len(nums)):\\n            \\n\\t\\t\\t# If duplicate, start from the new items appended by the previous val\\n            start = combinations_len if i and nums[i] == nums[i - 1] else 0\\n\\t\\t\\t\\n            combinations_len = len(combinations)            \\n            for c in range(start, combinations_len):\\n                combinations.append(combinations[c] + [nums[i]])\\n                \\n        return combinations\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 377184,
                "title": "easy-peasy-python-comments-best-iterative-solution",
                "content": "\\t# pos dict helps to prevent duplicates\\n\\t# frm = position in res(result) from where I have to start adding the current num\\n\\t# to understand this code, first take example of [1,2,3], and then [1,2,2]\\n\\t# Basically, I add my current num to the all the lists already in the result\\n\\t# however to prevent duplicates, I note down the position of the result where I start adding my num\\n\\t# and next time when I see a duplicate I start from the position from where I added my first duplicate element instead from 0th position of the result \\n\\t\\n\\t\\n\\tdef subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        res, pos, nums = [[]], {}, sorted(nums)\\n        for n in nums:\\n            frm, ln = pos.get(n, 0), len(res)\\n            for ls in res[frm:]:\\n                res.append(ls + [n])\\n            pos[n] = ln\\n            \\n        return res",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Recursion",
                    "Iterator"
                ],
                "code": "\\t# pos dict helps to prevent duplicates\\n\\t# frm = position in res(result) from where I have to start adding the current num\\n\\t# to understand this code, first take example of [1,2,3], and then [1,2,2]\\n\\t# Basically, I add my current num to the all the lists already in the result\\n\\t# however to prevent duplicates, I note down the position of the result where I start adding my num\\n\\t# and next time when I see a duplicate I start from the position from where I added my first duplicate element instead from 0th position of the result \\n\\t\\n\\t\\n\\tdef subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        res, pos, nums = [[]], {}, sorted(nums)\\n        for n in nums:\\n            frm, ln = pos.get(n, 0), len(res)\\n            for ls in res[frm:]:\\n                res.append(ls + [n])\\n            pos[n] = ln\\n            \\n        return res",
                "codeTag": "Python3"
            },
            {
                "id": 30322,
                "title": "my-solution-using-bit-masks",
                "content": "Here is my solution using bit masks.\\n\\n    public class Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] num) {\\n        //Sort the input\\n        Arrays.sort(num);\\n        int numberSets = 1 << num.length;\\n        List<List<Integer>> solution = new LinkedList<>();\\n        for(int i = 0; i<numberSets; i++){\\n            List<Integer> subset = new LinkedList<Integer>();\\n            for(int j = 0; j< num.length; j++){\\n                if((i & (1 << j)) > 0){\\n                    subset.add(num[j]);\\n                }\\n            }\\n            if(!solution.contains(subset))\\n                solution.add(subset);\\n        }\\n        \\n        return solution;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] num) {\\n        //Sort the input\\n        Arrays.sort(num);\\n        int numberSets = 1 << num.length;\\n        List<List<Integer>> solution = new LinkedList<>();\\n        for(int i = 0; i<numberSets; i++){\\n            List<Integer> subset = new LinkedList<Integer>();\\n            for(int j = 0; j< num.length; j++){\\n                if((i & (1 << j)) > 0){\\n                    subset.add(num[j]);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3683856,
                "title": "c-well-commented-backtracking-faster-than-100-c-submissions",
                "content": "# Complexity\\n- Time complexity: $$O(2^N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(2^N)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    void backTrack(vector<vector<int>>& ans, vector<int>& nums, vector<int>& curr, int index) {\\n        ans.push_back(curr);  // Add current subset to the answer vector\\n\\n        // Generate subsets by including elements starting from the given index\\n        for (int i = index; i < nums.size(); i++) {\\n            // Skip duplicate elements to avoid generating duplicate subsets\\n            if (i != index && nums[i] == nums[i - 1])\\n                continue;\\n\\n            curr.push_back(nums[i]);  // Include the current element in the current subset\\n            backTrack(ans, nums, curr, i + 1);\\n            curr.pop_back();  // Remove the current element to backtrack\\n        }\\n    }\\n\\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        vector<vector<int>> ans;\\n        vector<int> curr;  // Vector to store the current subset\\n\\n        backTrack(ans, nums, curr, 0);\\n        return ans\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    void backTrack(vector<vector<int>>& ans, vector<int>& nums, vector<int>& curr, int index) {\\n        ans.push_back(curr);  // Add current subset to the answer vector\\n\\n        // Generate subsets by including elements starting from the given index\\n        for (int i = index; i < nums.size(); i++) {\\n            // Skip duplicate elements to avoid generating duplicate subsets\\n            if (i != index && nums[i] == nums[i - 1])\\n                continue;\\n\\n            curr.push_back(nums[i]);  // Include the current element in the current subset\\n            backTrack(ans, nums, curr, i + 1);\\n            curr.pop_back();  // Remove the current element to backtrack\\n        }\\n    }\\n\\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        vector<vector<int>> ans;\\n        vector<int> curr;  // Vector to store the current subset\\n\\n        backTrack(ans, nums, curr, 0);\\n        return ans\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3631632,
                "title": "100-beats-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    void solve(int i,int &n,vector<int> &v,vector<int> &tmp,vector<vector<int>> &ans){\\n        if(i>=n){\\n            ans.push_back(tmp);\\n            return;\\n        }\\n        tmp.push_back(v[i]);\\n        solve(i+1,n,v,tmp,ans); \\n        tmp.pop_back();\\n        while(i+1<n&&v[i+1]==v[i])i++;\\n        solve(i+1,n,v,tmp,ans);\\n    }\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        vector<vector<int>> ans;\\n        vector<int> tmp;\\n        int n = nums.size();\\n        solve(0,n,nums,tmp,ans);\\n        // sort(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Backtracking",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(int i,int &n,vector<int> &v,vector<int> &tmp,vector<vector<int>> &ans){\\n        if(i>=n){\\n            ans.push_back(tmp);\\n            return;\\n        }\\n        tmp.push_back(v[i]);\\n        solve(i+1,n,v,tmp,ans); \\n        tmp.pop_back();\\n        while(i+1<n&&v[i+1]==v[i])i++;\\n        solve(i+1,n,v,tmp,ans);\\n    }\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        vector<vector<int>> ans;\\n        vector<int> tmp;\\n        int n = nums.size();\\n        solve(0,n,nums,tmp,ans);\\n        // sort(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3361683,
                "title": "easy-clear-solution-python3",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        nums = sorted(nums)\\n        res = []\\n        self.backtracking(res,0,[],nums)\\n        return res\\n    def backtracking(self,res,start,subset,nums):\\n        res.append(list(subset))\\n        for i in range(start,len(nums)):\\n            if i > start and nums[i] == nums[i-1]:\\n                continue\\n            self.backtracking(res,i+1,subset+[nums[i]],nums)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        nums = sorted(nums)\\n        res = []\\n        self.backtracking(res,0,[],nums)\\n        return res\\n    def backtracking(self,res,start,subset,nums):\\n        res.append(list(subset))\\n        for i in range(start,len(nums)):\\n            if i > start and nums[i] == nums[i-1]:\\n                continue\\n            self.backtracking(res,i+1,subset+[nums[i]],nums)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3346713,
                "title": "easy-to-understand-efficient-c-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nHere we need to make subsets so for each element \"Pick\" and \"Not Pick\" decision needs to be taken. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe entire approach is same as Subset I. \\n\\n- Just when we are about to not pick an element we need to not pick all the similar elements and increase the index \\'i\\'.\\n\\nAnd this job is done by the following code block -->\\n```\\nwhile(i+1 <nums.size() && nums[i]==nums[i+1]){\\n            i++;\\n        }\\n```\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n*O(2^n)*\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n*O(n^2)*\\n\\nMy Subset I solution link \\uD83D\\uDC47\\nhttps://leetcode.com/problems/subsets/solutions/3342538/100-beats-used-backtracking-efficient-c-code/\\nPlease upvote if you find it helpful \\u2B06\\uFE0F\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>>ans;\\n    void help(int i,vector<int>&nums,vector<int>&temp){\\n        if(i==nums.size()){\\n            ans.push_back(temp);\\n            return;\\n        }\\n        temp.push_back(nums[i]);\\n        help(i+1,nums,temp);\\n        \\n        temp.pop_back();\\n        while(i+1 <nums.size() && nums[i]==nums[i+1]){\\n            i++;\\n        }\\n        help(i+1,nums,temp);\\n        \\n    }\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        vector<int>temp;\\n        sort(nums.begin(),nums.end());\\n        help(0,nums,temp);\\n        //sort(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nwhile(i+1 <nums.size() && nums[i]==nums[i+1]){\\n            i++;\\n        }\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>>ans;\\n    void help(int i,vector<int>&nums,vector<int>&temp){\\n        if(i==nums.size()){\\n            ans.push_back(temp);\\n            return;\\n        }\\n        temp.push_back(nums[i]);\\n        help(i+1,nums,temp);\\n        \\n        temp.pop_back();\\n        while(i+1 <nums.size() && nums[i]==nums[i+1]){\\n            i++;\\n        }\\n        help(i+1,nums,temp);\\n        \\n    }\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        vector<int>temp;\\n        sort(nums.begin(),nums.end());\\n        help(0,nums,temp);\\n        //sort(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3217062,
                "title": "easy-c-solution-with-loop-and-backtracking-o-n-unique",
                "content": "# INTUITION \\nAs we have solved the question of finding subsets, here we will use similar approach to find the subsets for this question. make an array of all subsets and then **remove duplicates using inbuilt functions**\\n# APPROACH\\n1.  We are using here recursive technique. so firstly declare two vector ... one for answer and other as auxillary one.\\n2.  make a recursive function **solve** which will give all subsets recursively \\n3. **parameters for solve function** - answer vector, output vector, input vector and index for traversing.\\n4. HERE, we will play exclude and include game, in excluding step, just increase the index by 1.\\n5. for include, first we extract the elements from input vector and insert in the output vector ......and then make a recursive call.\\n6. when the **base case(index>= nums.size())** is reached, insert the output vector in answer vector and return.\\n\\n# COMPLEXITY\\n**TIME COMPLEXITY**-  overall is O(N)\\n**SPACE COMPLEXITY**- O(N)\\n```\\nclass Solution {\\npublic:\\n    void solve(vector <int> nums, vector<int> temp, int index, vector<vector<int>>& ans)\\n    {\\n        if(index >= nums.size())\\n        {\\n            ans.push_back(temp);\\n            return ;\\n        }\\n        \\n        solve(nums, temp, index+1, ans);\\n        \\n        int key = nums[index];\\n        temp.push_back(key);\\n        solve( nums, temp, index+1, ans);\\n    }\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        vector<vector<int>> ans;\\n        vector <int> temp;\\n        solve(nums, temp, 0, ans);\\n        sort(ans.begin(), ans.end());\\n        \\n        ans.erase(unique(ans.begin(), ans.end()), ans.end());\\n        \\n        return ans;\\n        \\n    }\\n};\\n```\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(vector <int> nums, vector<int> temp, int index, vector<vector<int>>& ans)\\n    {\\n        if(index >= nums.size())\\n        {\\n            ans.push_back(temp);\\n            return ;\\n        }\\n        \\n        solve(nums, temp, index+1, ans);\\n        \\n        int key = nums[index];\\n        temp.push_back(key);\\n        solve( nums, temp, index+1, ans);\\n    }\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        vector<vector<int>> ans;\\n        vector <int> temp;\\n        solve(nums, temp, 0, ans);\\n        sort(ans.begin(), ans.end());\\n        \\n        ans.erase(unique(ans.begin(), ans.end()), ans.end());\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1654821,
                "title": "c-backtracking-set-3ms",
                "content": "**Runtime:** 3 ms, faster than 73.08% of C++ online submissions for Subsets II.\\n**Memory Usage:** 7.8 MB, less than 54.76% of C++ online submissions for Subsets II.\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        set<vector<int>> ans;\\n        vector<int> curr;\\n        vector<vector<int>> ret;\\n        \\n        sort(nums.begin(), nums.end());\\n        backtrack(ans, curr, nums, 0);\\n        ret.assign(ans.begin(), ans.end());\\n        return ret;\\n    }\\n    void backtrack(set<vector<int>>& ans, vector<int>& curr, vector<int>& nums, int pos) {\\n        if(pos == nums.size()) {\\n            ans.insert(curr);\\n            return;\\n        }\\n        curr.push_back(nums[pos]);\\n        backtrack(ans, curr, nums, pos + 1);\\n        curr.pop_back();\\n        backtrack(ans, curr, nums, pos + 1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        set<vector<int>> ans;\\n        vector<int> curr;\\n        vector<vector<int>> ret;\\n        \\n        sort(nums.begin(), nums.end());\\n        backtrack(ans, curr, nums, 0);\\n        ret.assign(ans.begin(), ans.end());\\n        return ret;\\n    }\\n    void backtrack(set<vector<int>>& ans, vector<int>& curr, vector<int>& nums, int pos) {\\n        if(pos == nums.size()) {\\n            ans.insert(curr);\\n            return;\\n        }\\n        curr.push_back(nums[pos]);\\n        backtrack(ans, curr, nums, pos + 1);\\n        curr.pop_back();\\n        backtrack(ans, curr, nums, pos + 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1487304,
                "title": "aditya-verma-s-approach-simple-solution-using-set",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>ans;\\n    set<vector<int>>s;\\n    \\n    void solve(vector<int>input, vector<int>output){\\n        \\n        if(input.size() == 0){\\n            \\n            if(s.find(output) == s.end()){\\n                s.insert(output);\\n                ans.push_back(output);   \\n            }\\n            \\n            return;\\n        }\\n        \\n        vector<int>op1 = output, op2 = output;\\n        \\n        op1.push_back(input[0]);\\n        input.erase(input.begin() + 0);\\n        \\n        solve(input, op1);\\n        solve(input, op2);   \\n    }\\n    \\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        \\n        sort(nums.begin(), nums.end());\\n        vector<int>op;\\n        \\n        solve(nums, op);\\n        return ans; \\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion",
                    "Ordered Set"
                ],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>>ans;\\n    set<vector<int>>s;\\n    \\n    void solve(vector<int>input, vector<int>output){\\n        \\n        if(input.size() == 0){\\n            \\n            if(s.find(output) == s.end()){\\n                s.insert(output);\\n                ans.push_back(output);   \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1433693,
                "title": "java-backtracking-easy",
                "content": "```\\nclass Solution {\\n    Set<List<Integer>> res = new HashSet<>();\\n    \\n    void solve(int [] nums,int n,int idx,List<Integer>temp)\\n    {\\n        if(idx==n)\\n        {\\n            res.add(new ArrayList(temp));\\n            return ;\\n        }\\n        solve(nums,n,idx+1,temp);\\n        temp.add(nums[idx]);\\n        solve(nums,n,idx+1,temp);\\n        temp.remove(temp.size()-1);\\n    }\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        int n = nums.length;\\n        Arrays.sort(nums);\\n        solve(nums,n,0,new ArrayList());\\n        return new ArrayList(res);\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    Set<List<Integer>> res = new HashSet<>();\\n    \\n    void solve(int [] nums,int n,int idx,List<Integer>temp)\\n    {\\n        if(idx==n)\\n        {\\n            res.add(new ArrayList(temp));\\n            return ;\\n        }\\n        solve(nums,n,idx+1,temp);\\n        temp.add(nums[idx]);\\n        solve(nums,n,idx+1,temp);\\n        temp.remove(temp.size()-1);\\n    }\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        int n = nums.length;\\n        Arrays.sort(nums);\\n        solve(nums,n,0,new ArrayList());\\n        return new ArrayList(res);\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1333174,
                "title": "c-simple-and-short-solution-no-recursion",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        \\n        vector<vector<int>> res = {{}};\\n        vector<int> curr;\\n        int size;\\n        \\n        for (auto num : nums) {\\n            size = res.size();\\n            \\n            for (int i = 0; i < size; i++) {\\n                curr = res[i];\\n                curr.push_back(num);\\n                if (find(res.begin(), res.end(), curr) == res.end())\\n                    res.push_back(curr);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        \\n        vector<vector<int>> res = {{}};\\n        vector<int> curr;\\n        int size;\\n        \\n        for (auto num : nums) {\\n            size = res.size();\\n            \\n            for (int i = 0; i < size; i++) {\\n                curr = res[i];\\n                curr.push_back(num);\\n                if (find(res.begin(), res.end(), curr) == res.end())\\n                    res.push_back(curr);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1242864,
                "title": "recursion-using-aditya-verma-concept",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>ans;\\n    set<vector<int>>s;\\n    void solve(vector<int> ip,vector<int> op)\\n    {\\n        if(ip.size()==0)\\n        {\\n            if(s.find(op)==s.end())\\n            {\\n            \\n                s.insert(op);\\n                ans.push_back(op);\\n                \\n            }\\n            return ;\\n        }\\n        vector <int> op1=op;\\n        vector <int> op2=op;\\n        op2.push_back(ip[0]);\\n        ip.erase(ip.begin()+0);\\n        solve(ip,op1);\\n        solve(ip,op2);\\n        return;\\n    }\\n    vector<vector<int>> subsetsWithDup(vector<int>& ip) {\\n        sort(ip.begin(),ip.end());\\n        vector <int> op;\\n        solve(ip,op);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>ans;\\n    set<vector<int>>s;\\n    void solve(vector<int> ip,vector<int> op)\\n    {\\n        if(ip.size()==0)\\n        {\\n            if(s.find(op)==s.end())\\n            {\\n            \\n                s.insert(op);\\n                ans.push_back(op);\\n                \\n            }\\n            return ;\\n        }\\n        vector <int> op1=op;\\n        vector <int> op2=op;\\n        op2.push_back(ip[0]);\\n        ip.erase(ip.begin()+0);\\n        solve(ip,op1);\\n        solve(ip,op2);\\n        return;\\n    }\\n    vector<vector<int>> subsetsWithDup(vector<int>& ip) {\\n        sort(ip.begin(),ip.end());\\n        vector <int> op;\\n        solve(ip,op);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1087030,
                "title": "python-easy-to-understand-list-solution-by-changing-start-end-indexes",
                "content": "Consider the example [1, 5, 3, 3]\\n\\n1. Sort nums to place duplicates next to each other [1, 3, 3, 5]\\n2. Start with an empty set: [[]]\\n3. Add the first number (1) to all the existing subsets to create new subsets: [[], [1]];\\n4. Add the second number (3) to all the existing subsets: [[], [1], [3], [1,3]].\\n5. The next number (3) is a duplicate. If we add it to all existing subsets we will get:\\n    [[], [1], [3], [1,3], [3], [1,3], [3,3], [1,3,3]]\\n6. To handle this instead of adding (3) to all the existing subsets, we only add it to the new subsets which were created in the previous (4th) step ([3],[1,3]):\\n    [[], [1], [3], [1,3], [3,3], [1,3,3]]\\n\\t\\n7. Finally, add the forth number (5) to all the existing subsets: [[], [1], [3], [1,3], [3,3], [1,3,3], [5], [1,5], [3,5], [1,3,5], [3,3,5], [1,3,3,5]]\\n\\n```\\nclass Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        if not nums:\\n            return []\\n        \\n        subsets = []\\n        \\n        #Sorting nums so that duplicates are placed next to each other\\n        nums.sort()\\n        \\n        #Adding empty element to subsets\\n        subsets.append([])\\n        \\n        #Manipulating start, end indices\\n        startIndex, endIndex = 0, 0\\n        \\n        for i in range(len(nums)):\\n            #Initialize startIndex as 0 for every incoming number (normal unless duplicate)\\n            startIndex = 0\\n            \\n            #Checking duplicate condition\\n            if i > 0 and nums[i] == nums[i - 1]:\\n                #Update startIndex to only consider 2nd half, subsets added in the previous step\\n                startIndex = endIndex + 1\\n                \\n            #Set endIndex till the end of subsets \\n            endIndex = len(subsets) - 1\\n            \\n            #Adding current Number to all eligible subsets\\n            for j in range(startIndex, endIndex + 1):\\n                #Selecting subset to add element to \\n                set1 = list(subsets[j])\\n                set1.append(nums[i])\\n                subsets.append(set1)\\n        \\n        return subsets\\n```\\n\\nTime Complexity: O(N * 2^N) [Number of subsets double at each step for every element N (if not duplicate)]\\nSpace Complexity: O(N * 2^N) [O(2^N) subsets taking O(N) space]",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        if not nums:\\n            return []\\n        \\n        subsets = []\\n        \\n        #Sorting nums so that duplicates are placed next to each other\\n        nums.sort()\\n        \\n        #Adding empty element to subsets\\n        subsets.append([])\\n        \\n        #Manipulating start, end indices\\n        startIndex, endIndex = 0, 0\\n        \\n        for i in range(len(nums)):\\n            #Initialize startIndex as 0 for every incoming number (normal unless duplicate)\\n            startIndex = 0\\n            \\n            #Checking duplicate condition\\n            if i > 0 and nums[i] == nums[i - 1]:\\n                #Update startIndex to only consider 2nd half, subsets added in the previous step\\n                startIndex = endIndex + 1\\n                \\n            #Set endIndex till the end of subsets \\n            endIndex = len(subsets) - 1\\n            \\n            #Adding current Number to all eligible subsets\\n            for j in range(startIndex, endIndex + 1):\\n                #Selecting subset to add element to \\n                set1 = list(subsets[j])\\n                set1.append(nums[i])\\n                subsets.append(set1)\\n        \\n        return subsets\\n```",
                "codeTag": "Java"
            },
            {
                "id": 852051,
                "title": "almost-same-code-as-subset-i-problem-simple-recursive-cpp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n     void solve(vector<int>nums,vector<int>op,vector<vector<int>>& v)\\n    {  if(nums.size()==0)\\n        {   v.push_back(op);\\n            return;\\n        }\\n        vector<int>op1;\\n        vector<int>op2;\\n        for(int i=0;i<op.size();i++)\\n        {   op1.push_back(op[i]);\\n            op2.push_back(op[i]);\\n        }\\n        op2.push_back(nums[0]);\\n        vector<int>::iterator it;\\n        it=nums.begin();\\n        nums.erase(it);\\n        solve(nums,op1,v);\\n        solve(nums,op2,v);\\n        return;\\n    }\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        vector<vector<int>>v;\\n        vector<vector<int>>ans;\\n        vector<int>op;\\n        solve(nums,op,v);\\n        map<vector<int>,int>mp;\\n        for(int i=0;i<v.size();i++)\\n        {\\n            sort(v[i].begin(),v[i].end());\\n            mp[v[i]]++;\\n        }\\n        for(auto i:mp)\\n        {\\n            ans.push_back(i.first);\\n        }\\n        return ans;\\n    }\\n};\\n\\n```\\n\\n**Alternate method--**\\n```\\nclass Solution {\\npublic:\\n   void backtrack(int i,vector<int>& nums,int n,vector<int>curr,vector<vector<int>>&ans)\\n    {\\n        ans.push_back(curr);\\n        for(int j=i;j<nums.size();j++)\\n        {\\n            if(j>i&&nums[j]==nums[j-1])continue;\\n            curr.push_back(nums[j]);\\n            backtrack(j+1,nums,n,curr,ans);\\n            curr.pop_back();\\n        }\\n    }\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        int i=0;\\n        sort(nums.begin(),nums.end());\\n        vector<vector<int>>ans;\\n        vector<int>curr;\\n        int n=nums.size();\\n        backtrack(i,nums,n,curr,ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     void solve(vector<int>nums,vector<int>op,vector<vector<int>>& v)\\n    {  if(nums.size()==0)\\n        {   v.push_back(op);\\n            return;\\n        }\\n        vector<int>op1;\\n        vector<int>op2;\\n        for(int i=0;i<op.size();i++)\\n        {   op1.push_back(op[i]);\\n            op2.push_back(op[i]);\\n        }\\n        op2.push_back(nums[0]);\\n        vector<int>::iterator it;\\n        it=nums.begin();\\n        nums.erase(it);\\n        solve(nums,op1,v);\\n        solve(nums,op2,v);\\n        return;\\n    }\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        vector<vector<int>>v;\\n        vector<vector<int>>ans;\\n        vector<int>op;\\n        solve(nums,op,v);\\n        map<vector<int>,int>mp;\\n        for(int i=0;i<v.size();i++)\\n        {\\n            sort(v[i].begin(),v[i].end());\\n            mp[v[i]]++;\\n        }\\n        for(auto i:mp)\\n        {\\n            ans.push_back(i.first);\\n        }\\n        return ans;\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n   void backtrack(int i,vector<int>& nums,int n,vector<int>curr,vector<vector<int>>&ans)\\n    {\\n        ans.push_back(curr);\\n        for(int j=i;j<nums.size();j++)\\n        {\\n            if(j>i&&nums[j]==nums[j-1])continue;\\n            curr.push_back(nums[j]);\\n            backtrack(j+1,nums,n,curr,ans);\\n            curr.pop_back();\\n        }\\n    }\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        int i=0;\\n        sort(nums.begin(),nums.end());\\n        vector<vector<int>>ans;\\n        vector<int>curr;\\n        int n=nums.size();\\n        backtrack(i,nums,n,curr,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3773502,
                "title": "java-solution-recursion-beats-100",
                "content": "Here, I have used a recursive approach where we pick the first occurrence of every unique element in every recursive call.\\n\\nApproach:\\nBrute force: Follow a general subsequence pattern using recursion and add every subsequence to the final ArrayList. Then convert the ArrayList to a HashSet and again convert it back to an ArrayList. This process takes extra time while converting the ArrayList to a HashSet and then back to an ArrayList.\\n\\nWe can avoid these extra conversions while doing the subsequence recursion.\\n\\nOptimized approach: Initially, sort the array because we need all duplicate elements consecutively. Start the recursion and add the list to the \"ans\" (final ArrayList). Run a for loop because we need to go through every possibility of a subsequence from the current element to the end of the array.\\n\\nIf (i != ind && arr[i] == arr[i-1]), continue;\\n\\nThis condition is used to check if the current element is a duplicate or the first occurrence. If it is a duplicate, we continue the loop without adding it to the list. Otherwise, we add it to the list and make further recursive calls for other elements. Make sure to remove the last element of the list while backtracking to reconstruct the previous list.\\n\\nTime complexity: O(2^n * n)\\n- 2^n is the worst case of the number of subsequences formed. This occurs when all elements are unique.\\n- n is for adding the list to \"ans.\\n\\nSpace complexity : O(2^n * k)\\n\\n- 2^n is number of sub ArrayLists(list) in the final ArrayLists(ans)\\n- k is average size of sub ArrayList(list) \\n\\n```\\nclass Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        Arrays.sort(nums);\\n        List<List<Integer>> ans = new ArrayList<>();\\n        ArrayList<Integer> list=new ArrayList<>();\\n        subset2(0,nums,list,ans);\\n        return ans;\\n    }\\n\\n    private void subset2(int ind, int[] arr, ArrayList<Integer> list, List<List<Integer>> ans) {\\n        ans.add(new ArrayList<>(list));\\n        for(int i=ind;i<arr.length;i++){\\n            if(i!=ind && arr[i]==arr[i-1]) continue;\\n            list.add(arr[i]);\\n            subset2(i+1,arr,list,ans);\\n            list.remove(list.size()-1);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        Arrays.sort(nums);\\n        List<List<Integer>> ans = new ArrayList<>();\\n        ArrayList<Integer> list=new ArrayList<>();\\n        subset2(0,nums,list,ans);\\n        return ans;\\n    }\\n\\n    private void subset2(int ind, int[] arr, ArrayList<Integer> list, List<List<Integer>> ans) {\\n        ans.add(new ArrayList<>(list));\\n        for(int i=ind;i<arr.length;i++){\\n            if(i!=ind && arr[i]==arr[i-1]) continue;\\n            list.add(arr[i]);\\n            subset2(i+1,arr,list,ans);\\n            list.remove(list.size()-1);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3697570,
                "title": "same-approches-as-subset-i-with-brute-force-and-backtracking",
                "content": "# 1. Subset 1 Approach-->TC:[2^N*N]\\n```\\nclass Solution:\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        list1 = [[]]\\n        n=len(nums)\\n        for i in range(1,2**n):\\n            list2=[]\\n            for j in range(n):\\n                if (i&1<<j):\\n                    list2.append(nums[j])\\n            list1.append(list2)\\n        return list1\\n```\\n# 1. Backtracking--->TC:Log(2^N)\\n```\\nclass Solution:\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        def back(nums,ans,temp):\\n            ans.append(temp)\\n            for i in range(len(nums)):\\n                back(nums[i+1:],ans,temp+[nums[i]])\\n        ans=[]\\n        back(nums,ans,[])\\n        return ans\\n        \\n```\\n# 2. Backtracking Concept:TC:[N*log(N)+log(2^N)]\\n```\\nclass Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        def back(nums,ans,temp):\\n            ans.append(temp)\\n            for i in range(len(nums)):\\n                if i!=0 and nums[i]==nums[i-1]:\\n                    continue\\n                back(nums[i+1:],ans,temp+[nums[i]])\\n        ans=[]\\n        back(sorted(nums),ans,[])\\n        return ans\\n```\\n# 2. Same Approach as Subset I-->TC:[N^2X2^N*LogN] Heavy brute force but it works \\n```\\nclass Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        list1=[[]]\\n        n=len(nums)\\n        for i in range(1,2**n):\\n            list2=[]\\n            for j in range(n):\\n                if (i&1<<j):\\n                    list2.append(nums[j])\\n                list2.sort()\\n                if list2 not in list1:\\n                    list1.append(list2)\\n        return list1\\n```\\n# please upvote me it would encourage me alot\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        list1 = [[]]\\n        n=len(nums)\\n        for i in range(1,2**n):\\n            list2=[]\\n            for j in range(n):\\n                if (i&1<<j):\\n                    list2.append(nums[j])\\n            list1.append(list2)\\n        return list1\\n```\n```\\nclass Solution:\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        def back(nums,ans,temp):\\n            ans.append(temp)\\n            for i in range(len(nums)):\\n                back(nums[i+1:],ans,temp+[nums[i]])\\n        ans=[]\\n        back(nums,ans,[])\\n        return ans\\n        \\n```\n```\\nclass Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        def back(nums,ans,temp):\\n            ans.append(temp)\\n            for i in range(len(nums)):\\n                if i!=0 and nums[i]==nums[i-1]:\\n                    continue\\n                back(nums[i+1:],ans,temp+[nums[i]])\\n        ans=[]\\n        back(sorted(nums),ans,[])\\n        return ans\\n```\n```\\nclass Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        list1=[[]]\\n        n=len(nums)\\n        for i in range(1,2**n):\\n            list2=[]\\n            for j in range(n):\\n                if (i&1<<j):\\n                    list2.append(nums[j])\\n                list2.sort()\\n                if list2 not in list1:\\n                    list1.append(list2)\\n        return list1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3696610,
                "title": "c-backtracking-faster-than-100-c-submissions",
                "content": "\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    void backTrack(vector<vector<int>> &ans, vector<int> &nums, vector<int> &curr, int index) {\\n    ans.push_back(curr);\\n    for(int i = index; i < nums.size(); i++) {\\n        if(i != index && nums[i] == nums[i-1]) continue;\\n        curr.push_back(nums[i]);\\n        backTrack(ans, nums, curr, i+1);\\n        curr.pop_back();\\n    }\\n}\\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        vector<vector<int>> ans;\\n        vector<int> curr;\\n        backTrack(ans, nums, curr, 0);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    void backTrack(vector<vector<int>> &ans, vector<int> &nums, vector<int> &curr, int index) {\\n    ans.push_back(curr);\\n    for(int i = index; i < nums.size(); i++) {\\n        if(i != index && nums[i] == nums[i-1]) continue;\\n        curr.push_back(nums[i]);\\n        backTrack(ans, nums, curr, i+1);\\n        curr.pop_back();\\n    }\\n}\\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        vector<vector<int>> ans;\\n        vector<int> curr;\\n        backTrack(ans, nums, curr, 0);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3677317,
                "title": "c-solution-easiest-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nvoid solve(vector<vector<int>>&ans,vector<int>&output,int index,vector<int>& nums)\\n    {\\n        //base case\\n        if(index>=nums.size())\\n        {\\n            ans.push_back(output);\\n            return;\\n        }\\n\\n        //exclude\\n         solve(ans,output,index+1,nums);\\n\\n        //include\\n        output.push_back(nums[index]);\\n        solve(ans,output,index+1,nums);\\n        output.pop_back();\\n    } \\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n       sort(nums.begin(),nums.end());\\n        vector<vector<int>>ans;\\n        vector<int>output;\\n        int index=0;\\n        solve(ans,output,index,nums);\\n        set<vector<int>>st;\\n        for(int i=0;i<ans.size();i++)\\n        {\\n            st.insert(ans[i]);\\n        }\\n        vector<vector<int>>ans2;\\n        for(auto s:st)\\n        {\\n            ans2.push_back(s);\\n        }\\n        return ans2; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nvoid solve(vector<vector<int>>&ans,vector<int>&output,int index,vector<int>& nums)\\n    {\\n        //base case\\n        if(index>=nums.size())\\n        {\\n            ans.push_back(output);\\n            return;\\n        }\\n\\n        //exclude\\n         solve(ans,output,index+1,nums);\\n\\n        //include\\n        output.push_back(nums[index]);\\n        solve(ans,output,index+1,nums);\\n        output.pop_back();\\n    } \\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n       sort(nums.begin(),nums.end());\\n        vector<vector<int>>ans;\\n        vector<int>output;\\n        int index=0;\\n        solve(ans,output,index,nums);\\n        set<vector<int>>st;\\n        for(int i=0;i<ans.size();i++)\\n        {\\n            st.insert(ans[i]);\\n        }\\n        vector<vector<int>>ans2;\\n        for(auto s:st)\\n        {\\n            ans2.push_back(s);\\n        }\\n        return ans2; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3137672,
                "title": "c-easy-solution-recursion-faster-than-100",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void solve(vector<int> &nums, vector<int> &ds, vector<vector<int>> &ans, int ind)\\n    {\\n        ans.push_back(ds);\\n        for(int i =ind;i<nums.size();i++)\\n        {\\n            if(i>ind && nums[i] == nums[i-1])\\n            {\\n                continue;\\n            }\\n\\n            ds.push_back(nums[i]);\\n            solve(nums,ds,ans,i+1);\\n            ds.pop_back();\\n        }\\n    }\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        sort(nums.begin(),nums.end());\\n        vector<int> ds;\\n        solve(nums,ds,ans,0);\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(vector<int> &nums, vector<int> &ds, vector<vector<int>> &ans, int ind)\\n    {\\n        ans.push_back(ds);\\n        for(int i =ind;i<nums.size();i++)\\n        {\\n            if(i>ind && nums[i] == nums[i-1])\\n            {\\n                continue;\\n            }\\n\\n            ds.push_back(nums[i]);\\n            solve(nums,ds,ans,i+1);\\n            ds.pop_back();\\n        }\\n    }\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        sort(nums.begin(),nums.end());\\n        vector<int> ds;\\n        solve(nums,ds,ans,0);\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2851465,
                "title": "java-simple-java-solution-without-any-for-while-loop",
                "content": "# Code\\n```\\nclass Solution {\\n    static void subsequence(int i,int[] arr, List<Integer> lst, List<List<Integer>> res){\\n        if(res.contains(lst)) return;\\n        if(i==arr.length){\\n            res.add(new ArrayList<>(lst));\\n            return;\\n        }\\n        lst.add(arr[i]);\\n        subsequence(i+1, arr, lst, res);\\n        lst.remove(lst.size()-1);\\n        subsequence(i+1, arr, lst, res);\\n    }\\n\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        Arrays.sort(nums);\\n        List<List<Integer>> res=new ArrayList<>();\\n        subsequence(0, nums, new ArrayList<>(), res);\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Backtracking",
                    "Sort",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    static void subsequence(int i,int[] arr, List<Integer> lst, List<List<Integer>> res){\\n        if(res.contains(lst)) return;\\n        if(i==arr.length){\\n            res.add(new ArrayList<>(lst));\\n            return;\\n        }\\n        lst.add(arr[i]);\\n        subsequence(i+1, arr, lst, res);\\n        lst.remove(lst.size()-1);\\n        subsequence(i+1, arr, lst, res);\\n    }\\n\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        Arrays.sort(nums);\\n        List<List<Integer>> res=new ArrayList<>();\\n        subsequence(0, nums, new ArrayList<>(), res);\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2424966,
                "title": "easy-c-solution-using-backtracking-recursion",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    void subset(int i,vector<int>& nums,vector<int> sub){\\n        if(i==nums.size()){\\n            ans.push_back(sub);\\n            return;\\n        }\\n        sub.push_back(nums[i]);\\n        subset(i+1,nums,sub);\\n        sub.pop_back();\\n        while(i+1<nums.size() && nums[i]==nums[i+1]){\\n            i++;\\n        }\\n        subset(i+1,nums,sub);\\n    }\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        subset(0,nums,{});\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    void subset(int i,vector<int>& nums,vector<int> sub){\\n        if(i==nums.size()){\\n            ans.push_back(sub);\\n            return;\\n        }\\n        sub.push_back(nums[i]);\\n        subset(i+1,nums,sub);\\n        sub.pop_back();\\n        while(i+1<nums.size() && nums[i]==nums[i+1]){\\n            i++;\\n        }\\n        subset(i+1,nums,sub);\\n    }\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        subset(0,nums,{});\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2328340,
                "title": "c-solution-recursion-backtracking",
                "content": "**Code is availible in comment**",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 2237485,
                "title": "c-easy-solution-using-backtracking",
                "content": "class Solution {\\n    public:\\n  \\n     vector<int>v;\\n    vector<vector<int>>ans;\\n    void subset(vector<int> &arr, int N,int i){\\n        if(i==N){\\n            ans.push_back(v);\\n            return;\\n        }\\n        \\n            v.push_back(arr[i]); // take the number\\n        subset(arr,N,i+1);\\n        v.pop_back();\\n        while(i+1<N and arr[i]==arr[i+1]) i+=1; // to not include the same element as we have already taken \\n        subset(arr,N,i+1);//not take the number\\n        \\n        \\n    }\\n    vector<vector<int>> subsetsWithDup(vector<int>& arr) {\\n         int N = arr.size();\\n        sort(arr.begin(),arr.end()); // to get same value continously\\n        subset(arr,N,0);\\n        return ans;\\n    }\\n    };\\n\\n\\n",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "class Solution {\\n    public:\\n  \\n     vector<int>v;\\n    vector<vector<int>>ans;\\n    void subset(vector<int> &arr, int N,int i){\\n        if(i==N){\\n            ans.push_back(v);\\n            return;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1883021,
                "title": "c-bitwise-shift-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        vector<vector<int>> res;\\n        set<vector<int> > st;\\n        int size = nums.size();\\n        for(int i = 0; i < (1 << size); i++){\\n            vector<int> vc;\\n            for(int j = 0; j < size; j++){\\n                if(i & (1 << j)){\\n                    vc.push_back(nums[j]);\\n                }\\n            }\\n            sort(vc.begin(), vc.end());\\n            if (st.count(vc) == 0) {\\n                res.push_back(vc);\\n                st.insert(vc);\\n            }\\n        }\\n        return res;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        vector<vector<int>> res;\\n        set<vector<int> > st;\\n        int size = nums.size();\\n        for(int i = 0; i < (1 << size); i++){\\n            vector<int> vc;\\n            for(int j = 0; j < size; j++){\\n                if(i & (1 << j)){\\n                    vc.push_back(nums[j]);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1743898,
                "title": "accepted-7ms-c-solution-basic-concept",
                "content": "The basic concept is that if a number occurs x times, then we have x+1 alternatives, i.e., include it 0 times, 1 times, 2 times, ..... or x times. For eg. x=1 ,then we have two options either leave it (0 times)  or include it (1 times).\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        vector<int> curr;\\n        helper(nums,0,curr);\\n        return ans;\\n    }\\n    void helper(vector<int> &nums,int i,vector<int> curr){\\n        if(i==nums.size()){\\n            ans.push_back(curr);\\n            return;\\n        }\\n        int j=i;\\n        while(j<nums.size()&&nums[j]==nums[i]) j++;\\n        helper(nums,j,curr);\\n        for(int x=i;x<j;x++){\\n            curr.push_back(nums[i]);\\n            helper(nums,j,curr);\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        vector<int> curr;\\n        helper(nums,0,curr);\\n        return ans;\\n    }\\n    void helper(vector<int> &nums,int i,vector<int> curr){\\n        if(i==nums.size()){\\n            ans.push_back(curr);\\n            return;\\n        }\\n        int j=i;\\n        while(j<nums.size()&&nums[j]==nums[i]) j++;\\n        helper(nums,j,curr);\\n        for(int x=i;x<j;x++){\\n            curr.push_back(nums[i]);\\n            helper(nums,j,curr);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1557834,
                "title": "not-the-best-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    bool exist(vector<vector<int>> res , vector<int> cases)\\n    {\\n        for(auto it : res)\\n        {\\n            if(it == cases)\\n                return true;\\n        }\\n        return false;\\n    }\\n    \\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        int size = nums.size();\\n        int set = 1 << size;\\n        vector<vector<int>> res;\\n        sort(nums.begin() , nums.end());\\n        \\n        for(int index = 0 ; index < set ; index++)\\n        { \\n            vector<int> cases;\\n            for(int j = 0 ; j < size ; j++)\\n            {\\n                if(index &( 1 << j))\\n                    cases.push_back(nums[j]);\\n            }\\n            if(!exist(res,cases))\\n             res.push_back(cases);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool exist(vector<vector<int>> res , vector<int> cases)\\n    {\\n        for(auto it : res)\\n        {\\n            if(it == cases)\\n                return true;\\n        }\\n        return false;\\n    }\\n    \\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        int size = nums.size();\\n        int set = 1 << size;\\n        vector<vector<int>> res;\\n        sort(nums.begin() , nums.end());\\n        \\n        for(int index = 0 ; index < set ; index++)\\n        { \\n            vector<int> cases;\\n            for(int j = 0 ; j < size ; j++)\\n            {\\n                if(index &( 1 << j))\\n                    cases.push_back(nums[j]);\\n            }\\n            if(!exist(res,cases))\\n             res.push_back(cases);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1485015,
                "title": "c-backtracking-bit-manipulation-two-solution",
                "content": "**BACKTRACKING**\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        set<vector<int>> ans;\\n        vector<int> list;\\n        \\n        sort(nums.begin(),nums.end());\\n        \\n        help(nums,list,ans,0);\\n        \\n        vector<vector<int>> res(ans.begin(),ans.end());\\n        \\n        return res;\\n    }\\n    \\n    void help(vector<int> &nums,vector<int>& list, set<vector<int>>& ans,int start ){\\n        ans.insert(list);\\n       \\n        for(int i=start;i<nums.size();i++){\\n            list.push_back(nums[i]);\\n            help(nums,list,ans,i+1);\\n            list.pop_back();\\n        }\\n    }\\n};\\n```\\n\\n**BIT MANIPULATION**\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size(),p=1<<n;\\n        set<vector<int>> ans;\\n        \\n        for(int i=0;i<p;i++){\\n            vector<int> list;\\n            for(int j=0;j<n;j++){\\n                if(i&(1<<j)) list.push_back(nums[j]);\\n            }\\n            ans.insert(list);\\n        }\\n        \\n        vector<vector<int>> res(ans.begin(),ans.end());\\n        return res;  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Bit Manipulation",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        set<vector<int>> ans;\\n        vector<int> list;\\n        \\n        sort(nums.begin(),nums.end());\\n        \\n        help(nums,list,ans,0);\\n        \\n        vector<vector<int>> res(ans.begin(),ans.end());\\n        \\n        return res;\\n    }\\n    \\n    void help(vector<int> &nums,vector<int>& list, set<vector<int>>& ans,int start ){\\n        ans.insert(list);\\n       \\n        for(int i=start;i<nums.size();i++){\\n            list.push_back(nums[i]);\\n            help(nums,list,ans,i+1);\\n            list.pop_back();\\n        }\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size(),p=1<<n;\\n        set<vector<int>> ans;\\n        \\n        for(int i=0;i<p;i++){\\n            vector<int> list;\\n            for(int j=0;j<n;j++){\\n                if(i&(1<<j)) list.push_back(nums[j]);\\n            }\\n            ans.insert(list);\\n        }\\n        \\n        vector<vector<int>> res(ans.begin(),ans.end());\\n        return res;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1381390,
                "title": "c-solution-recursion-aditya-verma-s-subset-video",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>ans;\\n    set<vector<int>>s;\\n    void solve(vector<int>input, vector<int>output){\\n        if(input.size() == 0){\\n            if(s.find(output) == s.end()){\\n                s.insert(output);\\n                ans.push_back(output);   \\n            }\\n            return;\\n        }\\n        vector<int>op1 = output, op2 = output;\\n        op1.push_back(input[0]);\\n        input.erase(input.begin() + 0);\\n        solve(input, op1);\\n        solve(input, op2);   \\n    }\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        solve(nums, {});\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>ans;\\n    set<vector<int>>s;\\n    void solve(vector<int>input, vector<int>output){\\n        if(input.size() == 0){\\n            if(s.find(output) == s.end()){\\n                s.insert(output);\\n                ans.push_back(output);   \\n            }\\n            return;\\n        }\\n        vector<int>op1 = output, op2 = output;\\n        op1.push_back(input[0]);\\n        input.erase(input.begin() + 0);\\n        solve(input, op1);\\n        solve(input, op2);   \\n    }\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        solve(nums, {});\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1380224,
                "title": "python3-4-line-solution-faster-than-92-03-of-python3-online-submissions",
                "content": "Using Python, the solution can be written in 4 lines.\\n```\\nclass Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        ret = {()}\\n        for num in sorted(nums):\\n            ret = ret.union({s + (num,) for s in ret})\\n        return [list(elem) for elem in ret]\\n```\\nRuntime: 32 ms, faster than 92.03% of Python3 online submissions for Subsets II.",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        ret = {()}\\n        for num in sorted(nums):\\n            ret = ret.union({s + (num,) for s in ret})\\n        return [list(elem) for elem in ret]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1359678,
                "title": "without-sorting-very-simple-backtracking-solution",
                "content": "```\\ndef btrack(inp,out,ans):\\n    if not inp:\\n        ans.append(out)\\n        return\\n    btrack(inp[1:],out+[inp[0]],ans)\\n    if inp[0] not in out:\\n        btrack(inp[1:],out,ans)\\n\\n\\nclass Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        ans=[]\\n        btrack(nums,[],ans)\\n        return ans\\n```\\nIdea:\\n1. In every btrack() call, we explore 2 choices for inp[0] which are: adding it to \"out\" and not adding it \"out\".\\n2. But if inp[0] already has atleast one occurence in \"out\", then *We must make only one choice i.e., adding it to out*  (This is an observation)\\n\\nPlease comment if you have any doubt and upvote if you found this solution as helpful.",
                "solutionTags": [
                    "Python",
                    "Backtracking"
                ],
                "code": "```\\ndef btrack(inp,out,ans):\\n    if not inp:\\n        ans.append(out)\\n        return\\n    btrack(inp[1:],out+[inp[0]],ans)\\n    if inp[0] not in out:\\n        btrack(inp[1:],out,ans)\\n\\n\\nclass Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        ans=[]\\n        btrack(nums,[],ans)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1140408,
                "title": "clear-and-simple-explanation-with-intuition",
                "content": "**Intuition:** Since we are asked to calculate all the possible permutations, hence we will use backtracking , accepting the cases which satisfy conditions and reject the others.\\n\\n*Note :This question is very similar to the [Subsets](https://leetcode.com/problems/subsets/) problem and I already explained that in detail [here](https://leetcode.com/problems/subsets/discuss/1140388/Clear-and-simple-explanation-with-example-:-100-faster) , so I am going to just tell the change thats going to be made for this particular question .*\\n**Concept:** Since we have to avoid the duplicates , hence we are going to use **set** data structure here. \\n\\nBut that alone wont be enough, cause the *set* can\\'t distinguish between elements if they are in different order.\\nFor instance: `[1,2,3]  !=[3,2,1]` as per the needs of our question, but the *set* can\\'t distinguish between that, so we need a way to maintain the relatibve order of elements to be same for every same combination ....\\n\\n**Thats right, the correct answer is sorting.** Sorting will maintain the oder of elements and then we can use the set to eliminate the duplicates.\\n\\nAnd thats it!!! Keeping this in mind here is the code: \\n\\n**Code:**\\n```\\nclass Solution {\\npublic:\\n    set<vector<int>>subsets; // initialising set\\n    void helper(int index,vector<int>&current, vector<int>&nums)\\n    {\\n        subsets.insert(current); //inserting current array to the result\\n        for(int i=index;i<nums.size();i++)\\n        {\\n            current.push_back(nums[i]); // add the current element to consider the subsets corresponding to it\\n            helper(i+1,current,nums);  //generate subsets for this array\\n            current.pop_back();\\n        }\\n    }\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        vector<int>current;\\n        helper(0,current,nums);\\n        vector<vector<int>>ans(subsets.begin(),subsets.end()); //make vector from set\\n        return ans; //return answer\\n    }\\n};\\n```\\n**For similar problems: [Backtracking Collection](https://leetcode.com/discuss/interview-question/1141947/backtracking-study-and-analysis)**\\n\\nIf you like, please **UPVOTE**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    set<vector<int>>subsets; // initialising set\\n    void helper(int index,vector<int>&current, vector<int>&nums)\\n    {\\n        subsets.insert(current); //inserting current array to the result\\n        for(int i=index;i<nums.size();i++)\\n        {\\n            current.push_back(nums[i]); // add the current element to consider the subsets corresponding to it\\n            helper(i+1,current,nums);  //generate subsets for this array\\n            current.pop_back();\\n        }\\n    }\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        vector<int>current;\\n        helper(0,current,nums);\\n        vector<vector<int>>ans(subsets.begin(),subsets.end()); //make vector from set\\n        return ans; //return answer\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 939135,
                "title": "c-0ms-clean-concise-code-beats-100-time-12-lines",
                "content": "```\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        vector<vector<int>> res;\\n        res.push_back(vector<int>());\\n        int end = 0;\\n        for(int i = 0; i < nums.size(); i++){\\n            int start = 0;\\n            if(i > 0 && nums[i] == nums[i - 1]) start = end;\\n            end = res.size();\\n            for(int j = start; j < end; j++){\\n                vector<int> v(res[j]);\\n                v.push_back(nums[i]);\\n                res.push_back(v);\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        vector<vector<int>> res;\\n        res.push_back(vector<int>());\\n        int end = 0;\\n        for(int i = 0; i < nums.size(); i++){\\n            int start = 0;\\n            if(i > 0 && nums[i] == nums[i - 1]) start = end;\\n            end = res.size();\\n            for(int j = start; j < end; j++){\\n                vector<int> v(res[j]);\\n                v.push_back(nums[i]);\\n                res.push_back(v);\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 774097,
                "title": "python-solution-recursive-explanation",
                "content": "How Subsets II is different from Subset I codewise?\\n\\nExplanation:\\nThere are two important cases that helps us understand the solution.\\n\\nCase 1: Checking the use of sort() function.\\n```\\nInput1: [4,1, 4] \\nExpected Output: [[],[1],[1,4],[1,4,4],[4],[4,4]]\\n```\\n\\nIf the nums array is not sorted the output results into:\\n```\\nWrong output: [[],[4],[4,1],[4,1,4],[4,4],[1],[1,4],[4]]\\n```\\n\\nRecursive operation explanation step-by-step:\\n```\\nIndex 0:    \\n\\tnums = [4,1, 4]\\n\\tpath = []\\n\\tres = [[]]\\n\\t\\n\\tIndex 0.0:\\n\\t\\tnums = [1, 4]\\n\\t\\tpath = [4]\\n\\t\\tres= [[], [4]]\\n\\t\\t\\n\\t\\tIndex 0.0.0:\\n\\t\\t\\tnums = [4]\\n\\t\\t\\tpath = [4,1]\\n\\t\\t\\tres= [[], [4], [4,1]]\\n\\t\\t\\t\\n\\t\\t\\tIndex 0.0.0.0:\\n\\t\\t\\t\\tnums = []\\n\\t\\t\\t\\tpath = [4,1, 4]\\n\\t\\t\\t\\tres = [[], [4], [4,1], [4,1, 4]]\\n\\t\\t\\n\\t# Now the index gets incremented\\n\\tIndex 0.1: \\n\\t\\tnums = []\\n\\t\\tpath = [4,4]\\n\\t\\tres= [[], [4], [4,1], [4,1, 4], [4,4]]\\t\\n\\t\\t\\t\\n\\n# for index 1\\nIndex 1:\\n\\t# here if we don\\'t check the condition nums[i] == nums [i-1], \\n\\t# then it will start adding the duplicates in the result array which we don\\'t want in our result.\\n\\tnums = [4]\\n\\tpath = [1]    \\n\\tres =  [[], [4], [4,1], [4,1, 4], [4,4], [1]]\\t                \\n\\t\\n\\tIndex 1.1:\\n\\tnums = []\\n\\tpath = [1,4]    \\n\\tres =  [[], [4], [4,1], [4,1, 4], [4,4], [1], [1,4]]\\t                \\n\\t# here  nums[i] == nums [i-1] condition doesn\\'t satifies and the duplicate is generated. \\n\\t# we have two subsets with same elements [4,1] and [1,4].\\n\\n# If we sort the array and perform the operations then it helps in removing duplicates.\\n```\\n\\n\\n\\n\\n\\nCase 2: Recursive function explanation for the condition (if i > 0 and nums[i] == nums[i-1]) \\n```\\nInput: [4, 4, 1]\\nExpected Output: [[],[1],[1,4],[1,4,4],[4],[4,4]]\\n```\\n\\n```\\nIndex 0:    \\n\\tnums = [4,4,1]\\n\\tpath = []\\n\\tres = [[]]\\n\\t\\n\\tIndex 0.0:\\n\\t\\tnums = [4,1]\\n\\t\\tpath = [4]\\n\\t\\tres= [[], [4]]\\n\\t\\t\\n\\t\\tIndex 0.0.0:\\n\\t\\t\\tnums = [1]\\n\\t\\t\\tpath = [4,4]\\n\\t\\t\\tres= [[], [4], [4,4]]\\n\\t\\t\\t\\n\\t\\t\\tIndex 0.0.0.0:\\n\\t\\t\\t\\tnums = []\\n\\t\\t\\t\\tpath = [4,4,1]\\n\\t\\t\\t\\tres = [[], [4], [4,4], [4,4,1]]\\n\\t\\t\\n\\t# Now the index gets incremented\\n\\tIndex 0.1: \\n\\t\\tnums = []\\n\\t\\tpath = [4,1]\\n\\t\\tres= [[], [4], [4,4], [4,4,1], [4,1]]\\t\\n\\t\\t\\t\\n\\n# for index 1\\nIndex 1:\\n\\t# if we don\\'t check the condition nums[i] == nums [i-1], \\n\\t# then it will start adding the duplicates in the result array which we don\\'t want in our result.\\n\\tnums = [1]\\n\\tpath = [4]    \\n\\tres =  [[], [4], [4,4], [4,4,1], [4,1], [4]]                 \\n\\t\\n# every increment we need this condition to check any duplicates.\\n\\nIndex 2:\\n\\tnums = []\\n\\tpath = [1]\\n\\tres =  [ [], [4], [4,4], [4,4,1], [4,1], [1]]\\n```\\n\\n\\n\\nBelow is the solution: \\nTotal Runtime is 32 ms.\\n```\\nclass Solution(object):\\n    def subsetsWithDup(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        res = []\\n        nums.sort()\\n        self.dfs(nums, [], res)\\n        return res\\n    \\n    def dfs(self, nums, path, res):\\n        print(res)\\n        res.append(path)\\n        for i in range(len(nums)):\\n            if i > 0 and nums[i] == nums[i-1]:\\n                continue\\n            self.dfs(nums[i+1:], path + [nums[i]], res)\\n```\\n\\n===============================================\\nPlease let me know if you have issues in understanding any part of the solution.",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nInput1: [4,1, 4] \\nExpected Output: [[],[1],[1,4],[1,4,4],[4],[4,4]]\\n```\n```\\nWrong output: [[],[4],[4,1],[4,1,4],[4,4],[1],[1,4],[4]]\\n```\n```\\nIndex 0:    \\n\\tnums = [4,1, 4]\\n\\tpath = []\\n\\tres = [[]]\\n\\t\\n\\tIndex 0.0:\\n\\t\\tnums = [1, 4]\\n\\t\\tpath = [4]\\n\\t\\tres= [[], [4]]\\n\\t\\t\\n\\t\\tIndex 0.0.0:\\n\\t\\t\\tnums = [4]\\n\\t\\t\\tpath = [4,1]\\n\\t\\t\\tres= [[], [4], [4,1]]\\n\\t\\t\\t\\n\\t\\t\\tIndex 0.0.0.0:\\n\\t\\t\\t\\tnums = []\\n\\t\\t\\t\\tpath = [4,1, 4]\\n\\t\\t\\t\\tres = [[], [4], [4,1], [4,1, 4]]\\n\\t\\t\\n\\t# Now the index gets incremented\\n\\tIndex 0.1: \\n\\t\\tnums = []\\n\\t\\tpath = [4,4]\\n\\t\\tres= [[], [4], [4,1], [4,1, 4], [4,4]]\\t\\n\\t\\t\\t\\n\\n# for index 1\\nIndex 1:\\n\\t# here if we don\\'t check the condition nums[i] == nums [i-1], \\n\\t# then it will start adding the duplicates in the result array which we don\\'t want in our result.\\n\\tnums = [4]\\n\\tpath = [1]    \\n\\tres =  [[], [4], [4,1], [4,1, 4], [4,4], [1]]\\t                \\n\\t\\n\\tIndex 1.1:\\n\\tnums = []\\n\\tpath = [1,4]    \\n\\tres =  [[], [4], [4,1], [4,1, 4], [4,4], [1], [1,4]]\\t                \\n\\t# here  nums[i] == nums [i-1] condition doesn\\'t satifies and the duplicate is generated. \\n\\t# we have two subsets with same elements [4,1] and [1,4].\\n\\n# If we sort the array and perform the operations then it helps in removing duplicates.\\n```\n```\\nInput: [4, 4, 1]\\nExpected Output: [[],[1],[1,4],[1,4,4],[4],[4,4]]\\n```\n```\\nIndex 0:    \\n\\tnums = [4,4,1]\\n\\tpath = []\\n\\tres = [[]]\\n\\t\\n\\tIndex 0.0:\\n\\t\\tnums = [4,1]\\n\\t\\tpath = [4]\\n\\t\\tres= [[], [4]]\\n\\t\\t\\n\\t\\tIndex 0.0.0:\\n\\t\\t\\tnums = [1]\\n\\t\\t\\tpath = [4,4]\\n\\t\\t\\tres= [[], [4], [4,4]]\\n\\t\\t\\t\\n\\t\\t\\tIndex 0.0.0.0:\\n\\t\\t\\t\\tnums = []\\n\\t\\t\\t\\tpath = [4,4,1]\\n\\t\\t\\t\\tres = [[], [4], [4,4], [4,4,1]]\\n\\t\\t\\n\\t# Now the index gets incremented\\n\\tIndex 0.1: \\n\\t\\tnums = []\\n\\t\\tpath = [4,1]\\n\\t\\tres= [[], [4], [4,4], [4,4,1], [4,1]]\\t\\n\\t\\t\\t\\n\\n# for index 1\\nIndex 1:\\n\\t# if we don\\'t check the condition nums[i] == nums [i-1], \\n\\t# then it will start adding the duplicates in the result array which we don\\'t want in our result.\\n\\tnums = [1]\\n\\tpath = [4]    \\n\\tres =  [[], [4], [4,4], [4,4,1], [4,1], [4]]                 \\n\\t\\n# every increment we need this condition to check any duplicates.\\n\\nIndex 2:\\n\\tnums = []\\n\\tpath = [1]\\n\\tres =  [ [], [4], [4,4], [4,4,1], [4,1], [1]]\\n```\n```\\nclass Solution(object):\\n    def subsetsWithDup(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        res = []\\n        nums.sort()\\n        self.dfs(nums, [], res)\\n        return res\\n    \\n    def dfs(self, nums, path, res):\\n        print(res)\\n        res.append(path)\\n        for i in range(len(nums)):\\n            if i > 0 and nums[i] == nums[i-1]:\\n                continue\\n            self.dfs(nums[i+1:], path + [nums[i]], res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 501730,
                "title": "javascript-solution-easy-two-pointers",
                "content": "### The idea\\n1. Sort input `nums`\\n2. Use `prevIndex` to mark the start position of subsets to take considered of\\n``` javascript\\n/**\\n * @param {number[]} nums\\n * @return {number[][]}\\n */\\nvar subsetsWithDup = function(nums) {\\n    let prevIndex = 0;\\n    nums.sort((a,b)=>a-b);\\n    \\n    let res = [[]];\\n    for (let i=0;i<nums.length;i++) {    \\n        let l = res.length;\\n        for (let j=prevIndex;j<l;j++) res.push([...res[j], nums[i]]);\\n        if (nums[i+1] == nums[i]) prevIndex = l;\\n        else prevIndex = 0;\\n    }\\n    \\n    return res;\\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "``` javascript\\n/**\\n * @param {number[]} nums\\n * @return {number[][]}\\n */\\nvar subsetsWithDup = function(nums) {\\n    let prevIndex = 0;\\n    nums.sort((a,b)=>a-b);\\n    \\n    let res = [[]];\\n    for (let i=0;i<nums.length;i++) {    \\n        let l = res.length;\\n        for (let j=prevIndex;j<l;j++) res.push([...res[j], nums[i]]);\\n        if (nums[i+1] == nums[i]) prevIndex = l;\\n        else prevIndex = 0;\\n    }\\n    \\n    return res;\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 308274,
                "title": "java-1ms-simple-solution",
                "content": "```\\npublic void traverse(List<List<Integer>> resultList, List<Integer> currentList, int index, int[] nums) {\\n    resultList.add(new ArrayList<Integer>(currentList)); // 3. add currentList to final result list\\n    for(int i = index; i < nums.length; i++) {\\n        if( i > index && nums[i] == nums[i - 1] ) // 2. duplicate removal\\n            continue;\\n        currentList.add(nums[i]);\\n        traverse(resultList, currentList, i + 1, nums);\\n        currentList.remove(currentList.size() - 1);\\n    }\\n}\\n\\npublic List<List<Integer>> subsetsWithDup(int[] nums) {\\n    Arrays.sort(nums); // 1. sort the array\\n    List<List<Integer>> resultList = new ArrayList<List<Integer>>();\\n    traverse(resultList, new ArrayList<Integer>(), 0, nums);\\n    return resultList;\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\npublic void traverse(List<List<Integer>> resultList, List<Integer> currentList, int index, int[] nums) {\\n    resultList.add(new ArrayList<Integer>(currentList)); // 3. add currentList to final result list\\n    for(int i = index; i < nums.length; i++) {\\n        if( i > index && nums[i] == nums[i - 1] ) // 2. duplicate removal\\n            continue;\\n        currentList.add(nums[i]);\\n        traverse(resultList, currentList, i + 1, nums);\\n        currentList.remove(currentList.size() - 1);\\n    }\\n}\\n\\npublic List<List<Integer>> subsetsWithDup(int[] nums) {\\n    Arrays.sort(nums); // 1. sort the array\\n    List<List<Integer>> resultList = new ArrayList<List<Integer>>();\\n    traverse(resultList, new ArrayList<Integer>(), 0, nums);\\n    return resultList;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 110975,
                "title": "golang-simple-sort-backtrack-solution",
                "content": "Simply sort and if the same number appears skip it while iterating and backtracking.\\n\\n```\\nfunc subsetsWithDup(nums []int) [][]int {\\n\\tres := [][]int{[]int{}}\\n\\tvar cur []int\\n\\n\\tsort.Ints(nums)\\n\\tdoSubsetsWithDup(nums, cur, &res)\\n\\treturn res\\n}\\n\\nfunc doSubsetsWithDup(nums []int, cur []int, res *[][]int) {\\n\\tfor i := 0; i < len(nums); i++ {\\n\\t\\tif i > 0 && nums[i] == nums[i-1] {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tcur = append(cur, nums[i])\\n\\t\\tnewRes := make([]int, len(cur))\\n\\t\\tcopy(newRes, cur)\\n\\t\\t*res = append(*res, newRes)\\n\\n\\t\\tdoSubsetsWithDup(nums[i+1:], cur, res)\\n\\t\\tcur = cur[:len(cur)-1]\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc subsetsWithDup(nums []int) [][]int {\\n\\tres := [][]int{[]int{}}\\n\\tvar cur []int\\n\\n\\tsort.Ints(nums)\\n\\tdoSubsetsWithDup(nums, cur, &res)\\n\\treturn res\\n}\\n\\nfunc doSubsetsWithDup(nums []int, cur []int, res *[][]int) {\\n\\tfor i := 0; i < len(nums); i++ {\\n\\t\\tif i > 0 && nums[i] == nums[i-1] {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tcur = append(cur, nums[i])\\n\\t\\tnewRes := make([]int, len(cur))\\n\\t\\tcopy(newRes, cur)\\n\\t\\t*res = append(*res, newRes)\\n\\n\\t\\tdoSubsetsWithDup(nums[i+1:], cur, res)\\n\\t\\tcur = cur[:len(cur)-1]\\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 30159,
                "title": "subsets-vs-subsets-ii-add-only-3-more-lines-to-subsets-solution",
                "content": "The solution of subset II could be easily derived from the answer of subset I. \\n\\nHere is my answer of subset I: \\n```\\npublic class Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n        List<List<Integer>> res = new ArrayList<>(); \\n        res.add(new ArrayList<>()); \\n        \\n        for (int num: nums) {\\n            List<List<Integer>> resDup = new ArrayList<>(res);\\n            for (List<Integer> list:resDup) {\\n                List<Integer> tmpList = new ArrayList<>(list);\\n                list.add(num);\\n                res.add(tmpList); \\n            }\\n        }\\n        return res; \\n    }\\n}\\n```\\n\\nIn this problem, we need to change two things: \\n1. Sort the input nums, so that we won't get lists such as [1,4] and [4, 1] at the same time. \\n2. Check duplicates when adding new list to res. \\nHere is Subset II solution based on subset I solution: \\n```\\npublic class Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        List<List<Integer>> res = new ArrayList<>();\\n        res.add(new ArrayList<Integer>()); \\n        Arrays.sort(nums); //important: sort nums \\n        \\n        for (int num: nums) {\\n            List<List<Integer>> resDup = new ArrayList<>(res);\\n            for (List<Integer> list: resDup) {\\n                List<Integer> tmp = new ArrayList<>(list);\\n                tmp.add(num);\\n                if (!res.contains(tmp))  //check duplicates\\n                    res.add(tmp);\\n            }\\n        }\\n        return res; \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n        List<List<Integer>> res = new ArrayList<>(); \\n        res.add(new ArrayList<>()); \\n        \\n        for (int num: nums) {\\n            List<List<Integer>> resDup = new ArrayList<>(res);\\n            for (List<Integer> list:resDup) {\\n                List<Integer> tmpList = new ArrayList<>(list);\\n                list.add(num);\\n                res.add(tmpList); \\n            }\\n        }\\n        return res; \\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        List<List<Integer>> res = new ArrayList<>();\\n        res.add(new ArrayList<Integer>()); \\n        Arrays.sort(nums); //important: sort nums \\n        \\n        for (int num: nums) {\\n            List<List<Integer>> resDup = new ArrayList<>(res);\\n            for (List<Integer> list: resDup) {\\n                List<Integer> tmp = new ArrayList<>(list);\\n                tmp.add(num);\\n                if (!res.contains(tmp))  //check duplicates\\n                    res.add(tmp);\\n            }\\n        }\\n        return res; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3900796,
                "title": "retarded-way-to-solve-this-question-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. --> Generate all subsets, sort each subset to handle duplicates, use custom hash as key in a map to store and filter unique subsets.\\n\\n\\n# Complexity\\n- Time complexity:2^n\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    // Define a custom hash function for vector keys\\n    struct vectorkey { \\n        size_t operator()(const vector<int>& v) const { \\n            size_t hash = 0; \\n            for (auto x : v) { \\n                hash ^= std::hash<int>{}(x); \\n            }\\n            return hash; \\n        }\\n    };\\n\\n    // Use a map to store unique subsets and their counts\\n    unordered_map<vector<int>, int, vectorkey> map1;\\n\\n    // Function to generate subsets with handling duplicates\\n    void creator(vector<int> temp, int index, vector<int> nums) {\\n        if (temp.size() != 0) {\\n            sort(temp.begin(), temp.end()); // Sort the subset elements\\n            map1[temp]++; // Store the sorted subset in the map\\n        }\\n        for (int i = index; i < nums.size(); i++) {\\n            temp.push_back(nums[i]); // Include the current element\\n            creator(temp, i + 1, nums); // Generate subsets without current element\\n            temp.pop_back(); // Backtrack and remove the current element\\n        }\\n    }\\n\\n    // Generate unique subsets with duplicates removed\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        creator({}, 0, nums); // Start generating subsets\\n        vector<vector<int>> final; \\n        for (auto it : map1) { \\n            final.push_back(it.first); // Add each unique subset to the result\\n        }\\n        final.push_back({}); // Include an empty subset\\n        return final;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // Define a custom hash function for vector keys\\n    struct vectorkey { \\n        size_t operator()(const vector<int>& v) const { \\n            size_t hash = 0; \\n            for (auto x : v) { \\n                hash ^= std::hash<int>{}(x); \\n            }\\n            return hash; \\n        }\\n    };\\n\\n    // Use a map to store unique subsets and their counts\\n    unordered_map<vector<int>, int, vectorkey> map1;\\n\\n    // Function to generate subsets with handling duplicates\\n    void creator(vector<int> temp, int index, vector<int> nums) {\\n        if (temp.size() != 0) {\\n            sort(temp.begin(), temp.end()); // Sort the subset elements\\n            map1[temp]++; // Store the sorted subset in the map\\n        }\\n        for (int i = index; i < nums.size(); i++) {\\n            temp.push_back(nums[i]); // Include the current element\\n            creator(temp, i + 1, nums); // Generate subsets without current element\\n            temp.pop_back(); // Backtrack and remove the current element\\n        }\\n    }\\n\\n    // Generate unique subsets with duplicates removed\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        creator({}, 0, nums); // Start generating subsets\\n        vector<vector<int>> final; \\n        for (auto it : map1) { \\n            final.push_back(it.first); // Add each unique subset to the result\\n        }\\n        final.push_back({}); // Include an empty subset\\n        return final;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3759029,
                "title": "100-easy-fast-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n![download.png](https://assets.leetcode.com/users/images/bd5ee898-f275-4f33-b89f-c1c960bbe6ec_1689245864.4761305.png)\\n\\n# Code\\n// IF THIS WILL BE HELPFUL TO YOU, PLEASE UPVOTE \\u2B06\\uFE0F\\n```\\nclass Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) \\n    {\\n         Arrays.sort(nums);\\n        List<List<Integer>> outer=new ArrayList<>();\\n        outer.add(new ArrayList<>());\\n        int start=0;\\n        int end=0;\\n        for(int i=0;i<nums.length;i++)\\n        {    start=0;\\n            // if current and previous element is same,s=e+1;\\n            if(i >0 && nums[i]==nums[i -1])\\n            {\\n                start=end+1;\\n            }\\n            end=outer.size() - 1;\\n            int n=outer.size() ;\\n            for(int j=start;j<n;j++)\\n            {\\n        List<Integer> Internal=new ArrayList<>(outer.get(j));\\n                Internal.add(nums[i]);\\n                outer.add( Internal);\\n            }\\n        }\\n        return outer;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) \\n    {\\n         Arrays.sort(nums);\\n        List<List<Integer>> outer=new ArrayList<>();\\n        outer.add(new ArrayList<>());\\n        int start=0;\\n        int end=0;\\n        for(int i=0;i<nums.length;i++)\\n        {    start=0;\\n            // if current and previous element is same,s=e+1;\\n            if(i >0 && nums[i]==nums[i -1])\\n            {\\n                start=end+1;\\n            }\\n            end=outer.size() - 1;\\n            int n=outer.size() ;\\n            for(int j=start;j<n;j++)\\n            {\\n        List<Integer> Internal=new ArrayList<>(outer.get(j));\\n                Internal.add(nums[i]);\\n                outer.add( Internal);\\n            }\\n        }\\n        return outer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3608983,
                "title": "best-recursive-approach-no-sets-94-time-beats-80-space-beats",
                "content": "# Intuition\\n**My main goal was to not using sets and i found a solution. Best solution that i saw here.**\\n# Approach\\n1. It starts by initializing the result array with an empty subset [] as the first element. This will be the starting point for building other subsets.\\n2. The nums array is sorted in non-decreasing order using the sorted() method. Sorting the array is important to handle duplicates effectively.\\n3. A loop is iterated over the indices of nums from 0 to nums.count - 1. For each index num, the following steps are performed:\\nIf num is 0 or the current number nums[num] is different from the previous number nums[num - 1], indicating a new element or a distinct occurrence of a duplicate element, the following actions are taken:\\n- A new subset subset is created with the current number nums[num].\\n- The new subset subset is appended to the result array.\\n- The findingAllSubsets function is called recursively to find all subsets considering the current subset and the remaining elements starting from num.\\n4. The findingAllSubsets function takes the nums array, the result array, the current subset, and the current index as input parameters.\\n5. Inside the findingAllSubsets function:\\n- If the current index is equal to or greater than nums.count - 1, indicating that there are no more elements remaining, the function returns.\\n- The variable nextIndex is set to the current index plus 1.\\n- A while loop is used to increment nextIndex while it is within bounds and the next number at nums[nextIndex + 1] is equal to the current number at nums[nextIndex]. This handles consecutive duplicates and ensures that all occurrences of duplicates are considered only once.\\n- The findingAllSubsets function is called recursively to find subsets starting from the updated nextIndex.\\n- A new subset is created by appending the next number in nums (at index + 1) to the current subset.\\n- The new subset is appended to the result array.\\n- The findingAllSubsets function is called recursively to find subsets starting from the current index plus 1.\\n6. Finally, the result array, containing all the subsets, is returned.\\n\\n# Complexity\\n- Time complexity O(2^N):\\nThe time complexity of this code is O(2^N), where N is the number of elements in the input array \"nums\". This is because the code generates all possible subsets, and the number of subsets grows exponentially with the input size. For each element in the input array, the code generates two subsets: one that includes the element and one that doesn\\'t. Hence, the overall time complexity is exponential.\\n\\n\\n- Space complexity O(2^N):\\nThe space complexity of this code is O(2^N), which is the same as the time complexity. This is because the code generates all possible subsets and stores them in the \"result\" array. The number of subsets is exponential, and therefore the space required to store them also grows exponentially. Additionally, there are other variables and recursive function calls that contribute to the space complexity, but their impact is relatively small compared to the subsets.\\n\\n\\n# Uncommented code\\n```\\nclass Solution {\\n    func subsetsWithDup(_ nums: [Int]) -> [[Int]] {\\n        var result: [[Int]] = [[]]\\n        var nums = nums.sorted()\\n        //        var set = Set<Int>()\\n        \\n        for num in 0..<nums.count{\\n            if num == 0 || nums[num] != nums[num - 1]{\\n                let subset: [Int] = [nums[num]]\\n                result.append(subset)\\n                findingAllSubsets(nums, &result, subset, num)\\n            }\\n        }\\n        \\n        return result\\n    }\\n    \\n    func findingAllSubsets(_ nums: [Int],_ result: inout [[Int]],_ subset: [Int],_ index: Int){\\n        if index >= nums.count - 1{\\n            return\\n        }\\n        \\n        var nextIndex = index + 1\\n        while nextIndex + 1 <= nums.count - 1 && nums[nextIndex + 1] == nums[nextIndex]{\\n            nextIndex += 1\\n        }\\n        \\n        findingAllSubsets(nums, &result, subset, nextIndex)\\n        var subset = subset\\n        subset.append(nums[index + 1])\\n        result.append(subset)\\n        findingAllSubsets(nums, &result, subset, index + 1)\\n    }\\n}\\n```\\n\\n# Commented code\\n```\\nclass Solution {\\n    func subsetsWithDup(_ nums: [Int]) -> [[Int]] {\\n        var result: [[Int]] = [[]]\\n        var nums = nums.sorted()\\n        //        var set = Set<Int>()\\n        \\n        // Iterate over each number in the sorted array\\n        for num in 0..<nums.count {\\n            // Check if it\\'s the first number or different from the previous number\\n            if num == 0 || nums[num] != nums[num - 1] {\\n                // Create a subset with only the current number\\n                let subset: [Int] = [nums[num]]\\n                // Add the subset to the result array\\n                result.append(subset)\\n                // Call a recursive function to find all subsets containing the current number\\n                findingAllSubsets(nums, &result, subset, num)\\n            }\\n        }\\n        \\n        return result\\n    }\\n    \\n    func findingAllSubsets(_ nums: [Int],_ result: inout [[Int]],_ subset: [Int],_ index: Int) {\\n        // Check if we have reached the last index or beyond\\n        if index >= nums.count - 1 {\\n            return\\n        }\\n        \\n        var nextIndex = index + 1\\n        // Find the next index that has a different number than the current one\\n        while nextIndex + 1 <= nums.count - 1 && nums[nextIndex + 1] == nums[nextIndex] {\\n            nextIndex += 1\\n        }\\n        \\n        // Recursively call the function to find subsets starting from the next index\\n        findingAllSubsets(nums, &result, subset, nextIndex)\\n        var subset = subset\\n        // Add the next number to the subset\\n        subset.append(nums[index + 1])\\n        // Add the new subset to the result array\\n        result.append(subset)\\n        // Recursively call the function to find subsets starting from the next index\\n        findingAllSubsets(nums, &result, subset, index + 1)\\n    }\\n}\\n```\\nIf you liked this solution, then do not forget to rate it please \\uD83D\\uDC4D\\uD83C\\uDFFB",
                "solutionTags": [
                    "Swift",
                    "Array",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    func subsetsWithDup(_ nums: [Int]) -> [[Int]] {\\n        var result: [[Int]] = [[]]\\n        var nums = nums.sorted()\\n        //        var set = Set<Int>()\\n        \\n        for num in 0..<nums.count{\\n            if num == 0 || nums[num] != nums[num - 1]{\\n                let subset: [Int] = [nums[num]]\\n                result.append(subset)\\n                findingAllSubsets(nums, &result, subset, num)\\n            }\\n        }\\n        \\n        return result\\n    }\\n    \\n    func findingAllSubsets(_ nums: [Int],_ result: inout [[Int]],_ subset: [Int],_ index: Int){\\n        if index >= nums.count - 1{\\n            return\\n        }\\n        \\n        var nextIndex = index + 1\\n        while nextIndex + 1 <= nums.count - 1 && nums[nextIndex + 1] == nums[nextIndex]{\\n            nextIndex += 1\\n        }\\n        \\n        findingAllSubsets(nums, &result, subset, nextIndex)\\n        var subset = subset\\n        subset.append(nums[index + 1])\\n        result.append(subset)\\n        findingAllSubsets(nums, &result, subset, index + 1)\\n    }\\n}\\n```\n```\\nclass Solution {\\n    func subsetsWithDup(_ nums: [Int]) -> [[Int]] {\\n        var result: [[Int]] = [[]]\\n        var nums = nums.sorted()\\n        //        var set = Set<Int>()\\n        \\n        // Iterate over each number in the sorted array\\n        for num in 0..<nums.count {\\n            // Check if it\\'s the first number or different from the previous number\\n            if num == 0 || nums[num] != nums[num - 1] {\\n                // Create a subset with only the current number\\n                let subset: [Int] = [nums[num]]\\n                // Add the subset to the result array\\n                result.append(subset)\\n                // Call a recursive function to find all subsets containing the current number\\n                findingAllSubsets(nums, &result, subset, num)\\n            }\\n        }\\n        \\n        return result\\n    }\\n    \\n    func findingAllSubsets(_ nums: [Int],_ result: inout [[Int]],_ subset: [Int],_ index: Int) {\\n        // Check if we have reached the last index or beyond\\n        if index >= nums.count - 1 {\\n            return\\n        }\\n        \\n        var nextIndex = index + 1\\n        // Find the next index that has a different number than the current one\\n        while nextIndex + 1 <= nums.count - 1 && nums[nextIndex + 1] == nums[nextIndex] {\\n            nextIndex += 1\\n        }\\n        \\n        // Recursively call the function to find subsets starting from the next index\\n        findingAllSubsets(nums, &result, subset, nextIndex)\\n        var subset = subset\\n        // Add the next number to the subset\\n        subset.append(nums[index + 1])\\n        // Add the new subset to the result array\\n        result.append(subset)\\n        // Recursively call the function to find subsets starting from the next index\\n        findingAllSubsets(nums, &result, subset, index + 1)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3605755,
                "title": "java-easy-solution-with-comments",
                "content": "# Intuition\\n Idea: Here in this Question, the question is given that, the nums may contain duplicates so we have to skip duplicates. For skipping the duplicates, we have to sort the nums array\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n$$O(n log n + n * 2^n)$$ \\n\\n- Space complexity:\\n$$OO(2^n + n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        //Approach: Using BackTracking, T.C: O(n log n + n * 2^n), S.C: O(2^n + n)\\n        //Idea: Here in the Question, the instroction is given the the nums may contain duplicates\\n        //so we have to skip duplicates\\n        //for skipping the duplicates, we have to sort the nums array\\n\\n        List<List<Integer>> ans = new ArrayList<>();\\n        //sort the num array\\n        Arrays.sort(nums);\\n        backtrack(ans, nums, new ArrayList<>(), 0);\\n        return ans;\\n    }\\n    public void backtrack(List<List<Integer>> ans, int[] nums, List<Integer> temp, int idx){\\n        //don\\'t need any base case\\n        ans.add(new ArrayList<>(temp));\\n        //we have to skip duplicates\\n        for(int i=idx;i<nums.length;i++){\\n            if(i>idx && nums[i]==nums[i-1]){\\n                continue;\\n            }\\n\\n            //add to temp arrayList\\n            temp.add(nums[i]);\\n            //call recursion\\n            backtrack(ans, nums, temp, i+1);\\n            //do empty temp list\\n            temp.remove(temp.size()-1);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        //Approach: Using BackTracking, T.C: O(n log n + n * 2^n), S.C: O(2^n + n)\\n        //Idea: Here in the Question, the instroction is given the the nums may contain duplicates\\n        //so we have to skip duplicates\\n        //for skipping the duplicates, we have to sort the nums array\\n\\n        List<List<Integer>> ans = new ArrayList<>();\\n        //sort the num array\\n        Arrays.sort(nums);\\n        backtrack(ans, nums, new ArrayList<>(), 0);\\n        return ans;\\n    }\\n    public void backtrack(List<List<Integer>> ans, int[] nums, List<Integer> temp, int idx){\\n        //don\\'t need any base case\\n        ans.add(new ArrayList<>(temp));\\n        //we have to skip duplicates\\n        for(int i=idx;i<nums.length;i++){\\n            if(i>idx && nums[i]==nums[i-1]){\\n                continue;\\n            }\\n\\n            //add to temp arrayList\\n            temp.add(nums[i]);\\n            //call recursion\\n            backtrack(ans, nums, temp, i+1);\\n            //do empty temp list\\n            temp.remove(temp.size()-1);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3290882,
                "title": "java-recursion-easy-to-undestand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        Arrays.sort(nums);\\n        List<List<Integer>>ans=new ArrayList<>();\\n        solve(0,nums,new ArrayList<>(),ans);\\n        return ans;\\n    }\\n    public void solve(int ind,int[]nums,ArrayList<Integer>temp,List<List<Integer>>ans){\\n        ans.add(new ArrayList<>(temp));\\n        for(int i=ind;i<nums.length;i++){\\n            if(i!=ind && nums[i]==nums[i-1]) continue;//for duplicate checking\\n            temp.add(nums[i]);\\n            solve(i+1,nums,temp,ans);\\n            temp.remove(temp.size()-1);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        Arrays.sort(nums);\\n        List<List<Integer>>ans=new ArrayList<>();\\n        solve(0,nums,new ArrayList<>(),ans);\\n        return ans;\\n    }\\n    public void solve(int ind,int[]nums,ArrayList<Integer>temp,List<List<Integer>>ans){\\n        ans.add(new ArrayList<>(temp));\\n        for(int i=ind;i<nums.length;i++){\\n            if(i!=ind && nums[i]==nums[i-1]) continue;//for duplicate checking\\n            temp.add(nums[i]);\\n            solve(i+1,nums,temp,ans);\\n            temp.remove(temp.size()-1);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3162453,
                "title": "python-clean-backtracking-with-sets",
                "content": "# Intuition\\nAny time I am trying to find permutations using items from a set, I first try to determine whether I can use backtracking. It turns out this works fine in this case, since we know the input array size is 10 or less.\\n\\n# Approach\\nIn order to avoid duplicates, we should first sort the array of nums. Then we can be sure that our subsets will always occur in non-decreasing order. Here we perform backtracking, but since we are looking for all possible subsets, we don\\'t need to do any checks before adding our interim results to the output. At each step, we take our current subset and go through the remaining elements in the array and perform backtracking with the subset plus that element. We store the results in a set in order to avoid duplication.\\n\\n# Complexity\\n- Time complexity:\\n$$O(2^N * N)$$\\n\\n- Space complexity:\\n$$O(2^N)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        N = len(nums)\\n        output = set()\\n\\n        nums = sorted(nums)\\n\\n        def backtrack(subset, index):\\n            output.add(subset)\\n\\n            for i in range(index, N):\\n                backtrack(tuple(list(subset) + [nums[i]]), i + 1)\\n\\n        backtrack(tuple(), 0)\\n        return output\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        N = len(nums)\\n        output = set()\\n\\n        nums = sorted(nums)\\n\\n        def backtrack(subset, index):\\n            output.add(subset)\\n\\n            for i in range(index, N):\\n                backtrack(tuple(list(subset) + [nums[i]]), i + 1)\\n\\n        backtrack(tuple(), 0)\\n        return output\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3062151,
                "title": "accepted-easy-solution-short-simple-best-method",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    void dfs(vector<int>& nums, vector<int> s, int ind)\\n    {\\n       if(ind==nums.size())\\n       {\\n           ans.push_back(s);\\n           return;\\n       }\\n        s.push_back(nums[ind]);\\n        dfs(nums, s, ind+1);\\n        s.pop_back();\\n        while(ind+1<nums.size() && nums[ind]==nums[ind+1])\\n            ind++;\\n        dfs(nums, s, ind+1);\\n    }\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        vector<int> s;\\n        sort(nums.begin(), nums.end());\\n        dfs(nums, s, 0);\\n        return ans;\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    void dfs(vector<int>& nums, vector<int> s, int ind)\\n    {\\n       if(ind==nums.size())\\n       {\\n           ans.push_back(s);\\n           return;\\n       }\\n        s.push_back(nums[ind]);\\n        dfs(nums, s, ind+1);\\n        s.pop_back();\\n        while(ind+1<nums.size() && nums[ind]==nums[ind+1])\\n            ind++;\\n        dfs(nums, s, ind+1);\\n    }\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        vector<int> s;\\n        sort(nums.begin(), nums.end());\\n        dfs(nums, s, 0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2847966,
                "title": "100-submission-with-0ms-time-c-solution-of-simple-recursion-and-backtracing",
                "content": "Time complexity: O(2^n)\\nspace complexity: O(N)\\n\\n    class Solution {\\n    public:\\n        vector<vector<int>> ans;\\n        void solve(vector<int> &x,int i,vector<int> &a){\\n        ans.push_back(x);  \\n    /*whenever an element is add from the vector it should be push back \\n    as we need all the possible subset which will be generated in the recursive tree\\n     as we want all the value of the recursive tree rather than the end values like in other question\\n     hence we will have the ans.push_back on the top and will work ever time the recursive call take place*/\\n        if(i==a.size()) return; \\n    // this will end all the recursion as the i is now n that mean all values are taken onces\\n        for(int j=i;j<a.size();j++){    \\n    /*we start with j=i because if we have taken a value once then in next recursion\\n     we need that our code see the next element and not the element which it had already worked\\n     hence j=i where i will be increasing by 1 so that we can iterate the whole vector*/\\n            if(i==j or a[j]!=a[j-1]){ // this is important \\n                x.push_back(a[j]); \\n    /* in subset 2 we have dublicate elements so to remove them we will have a \\'if\\' condition\\n     where we will work only when the the current element is not equal to previous element\\n     but this will also ignore the current element which will give worng answer\\n     hence to make our code to work only once and take the current element\\n    then ignore the other if they are same we use or function with i==j and arr[j]!=arr[j-1] \\n    here i==j will allow use to take the element once rather than ignore all\\n     the other condition will remove all dublicates*/\\n                solve(x,j+1,a);\\n                x.pop_back(); \\n    // this is for backtracing as after one recursion we have to make our x empty again \\n    //eg: [],[1],[1,2][1,2,2] non we will empty the x so that we can insert other value \\n                }\\n\\t\\t\\t}   \\n\\t\\t}\\n   \\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        sort(nums.begin(),nums.end()); // sorting is must as our loop is checking only adjacent elements in the vector\\n        vector<int> x;\\n        solve(x,0,nums);\\n        return ans;\\n        }\\n    };\\n\\n\\n\\n\\nDO UPVOTE IF HELPED AND FEEDBACK PURELY WELLCOMED :)",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "class Solution {\\n    public:\\n        vector<vector<int>> ans;\\n        void solve(vector<int> &x,int i,vector<int> &a){\\n        ans.push_back(x);  \\n    /*whenever an element is add from the vector it should be push back \\n    as we need all the possible subset which will be generated in the recursive tree\\n     as we want all the value of the recursive tree rather than the end values like in other question\\n     hence we will have the ans.push_back on the top and will work ever time the recursive call take place*/\\n        if(i==a.size()) return; \\n    // this will end all the recursion as the i is now n that mean all values are taken onces\\n        for(int j=i;j<a.size();j++){    \\n    /*we start with j=i because if we have taken a value once then in next recursion\\n     we need that our code see the next element and not the element which it had already worked\\n     hence j=i where i will be increasing by 1 so that we can iterate the whole vector*/\\n            if(i==j or a[j]!=a[j-1]){ // this is important \\n                x.push_back(a[j]); \\n    /* in subset 2 we have dublicate elements so to remove them we will have a \\'if\\' condition\\n     where we will work only when the the current element is not equal to previous element\\n     but this will also ignore the current element which will give worng answer\\n     hence to make our code to work only once and take the current element\\n    then ignore the other if they are same we use or function with i==j and arr[j]!=arr[j-1] \\n    here i==j will allow use to take the element once rather than ignore all\\n     the other condition will remove all dublicates*/\\n                solve(x,j+1,a);\\n                x.pop_back(); \\n    // this is for backtracing as after one recursion we have to make our x empty again \\n    //eg: [],[1],[1,2][1,2,2] non we will empty the x so that we can insert other value \\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2768249,
                "title": "0ms-c-recursive-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    void subset_sum(int ind,vector<int> &nums,vector<int> &v,vector<vector<int>> &ans)\\n    {\\n        ans.push_back(v);\\n        for(int i=ind;i<nums.size();i++){\\n            if(i!=ind && nums[i]==nums[i-1]) continue;\\n            v.push_back(nums[i]);\\n            subset_sum(i+1,nums,v,ans);\\n            v.pop_back();\\n        }\\n    }\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        vector<int> v;\\n        sort(nums.begin(),nums.end());\\n        subset_sum(0,nums,v,ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void subset_sum(int ind,vector<int> &nums,vector<int> &v,vector<vector<int>> &ans)\\n    {\\n        ans.push_back(v);\\n        for(int i=ind;i<nums.size();i++){\\n            if(i!=ind && nums[i]==nums[i-1]) continue;\\n            v.push_back(nums[i]);\\n            subset_sum(i+1,nums,v,ans);\\n            v.pop_back();\\n        }\\n    }\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        vector<int> v;\\n        sort(nums.begin(),nums.end());\\n        subset_sum(0,nums,v,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2713874,
                "title": "subsets-ll",
                "content": "```\\nclass Solution {\\n    public static void Met(int i,int[]nums,List<List<Integer>>a,List<Integer>ds)\\n    {\\n        //base\\n        if(i==nums.length){\\n            if(!a.contains(new ArrayList<>(ds)))\\n            {\\n            a.add(new ArrayList<>(ds));\\n                \\n            }\\n            return;\\n        }\\n        //recurance\\n        ds.add(nums[i]);\\n        Met(i+1,nums,a,ds);//take\\n        ds.remove(ds.size()-1);\\n        Met(i+1,nums,a,ds);//not take\\n    }\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        Arrays.sort(nums);\\n        List<List<Integer>>a=new ArrayList<>();\\n        Met(0,nums,a,new ArrayList<>());\\n        return a;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public static void Met(int i,int[]nums,List<List<Integer>>a,List<Integer>ds)\\n    {\\n        //base\\n        if(i==nums.length){\\n            if(!a.contains(new ArrayList<>(ds)))\\n            {\\n            a.add(new ArrayList<>(ds));\\n                \\n            }\\n            return;\\n        }\\n        //recurance\\n        ds.add(nums[i]);\\n        Met(i+1,nums,a,ds);//take\\n        ds.remove(ds.size()-1);\\n        Met(i+1,nums,a,ds);//not take\\n    }\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        Arrays.sort(nums);\\n        List<List<Integer>>a=new ArrayList<>();\\n        Met(0,nums,a,new ArrayList<>());\\n        return a;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2664469,
                "title": "9ms-c-space-98-beats-simple",
                "content": "```\\nclass Solution {\\npublic:\\n    void solve(int i,int &n,vector<int> &tmp,vector<vector<int>> &ans,vector<int> &num)\\n    {\\n        ans.push_back(tmp);\\n        if(i>n)return;\\n        for(int j = i; j < n; j++){\\n            tmp.push_back(num[j]);\\n            solve(j+1,n,tmp,ans,num);\\n            while(j<n-1&&num[j]==num[j+1])j++;\\n            tmp.pop_back();\\n        }\\n    }    \\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        vector<int> tmp;\\n        int n = nums.size();\\n        sort(nums.begin(),nums.end());\\n        solve(0,n,tmp,ans,nums);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(int i,int &n,vector<int> &tmp,vector<vector<int>> &ans,vector<int> &num)\\n    {\\n        ans.push_back(tmp);\\n        if(i>n)return;\\n        for(int j = i; j < n; j++){\\n            tmp.push_back(num[j]);\\n            solve(j+1,n,tmp,ans,num);\\n            while(j<n-1&&num[j]==num[j+1])j++;\\n            tmp.pop_back();\\n        }\\n    }    \\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        vector<int> tmp;\\n        int n = nums.size();\\n        sort(nums.begin(),nums.end());\\n        solve(0,n,tmp,ans,nums);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2238100,
                "title": "subsets-ii-easy-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int> >v;\\n    void generate(vector<int>subset,int i,vector<int>&nums){\\n             v.push_back(subset);\\n       for(int j=i;j<nums.size();j++){\\n        if(j!=i && nums[j]==nums[j-1])\\n            continue;\\n        subset.push_back(nums[j]);\\n        generate(subset,j+1,nums);\\n        subset.pop_back();\\n       }\\n    }\\n    \\n    public:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        vector<int>empty;\\n        generate(empty,0,nums);\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int> >v;\\n    void generate(vector<int>subset,int i,vector<int>&nums){\\n             v.push_back(subset);\\n       for(int j=i;j<nums.size();j++){\\n        if(j!=i && nums[j]==nums[j-1])\\n            continue;\\n        subset.push_back(nums[j]);\\n        generate(subset,j+1,nums);\\n        subset.pop_back();\\n       }\\n    }\\n    \\n    public:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        vector<int>empty;\\n        generate(empty,0,nums);\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2210692,
                "title": "python-set-soooooo-easyyyyyyy",
                "content": "```\\nclass Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        output = [[]]\\n        nums.sort()\\n        \\n        for num in nums:\\n            output += [curr + [num] for curr in output]\\n        \\n        output = set(tuple(i) for i in output)\\n        return output",
                "solutionTags": [
                    "Python",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        output = [[]]\\n        nums.sort()\\n        \\n        for num in nums:\\n            output += [curr + [num] for curr in output]\\n        \\n        output = set(tuple(i) for i in output)\\n        return output",
                "codeTag": "Java"
            },
            {
                "id": 2178266,
                "title": "my-simple-recursive-solution-using-set-for-handling-duplicates",
                "content": "\\tpublic List<List<Integer>> subsetsWithDup(int[] nums) {\\n        Set<List<Integer>> ans= new HashSet<>();\\n        List<Integer> list = new ArrayList<>();\\n        Arrays.sort(nums);\\n        solve(nums,0,ans,list);\\n        return new ArrayList<>(ans);\\n    }\\n    \\n    private static void solve(int[] nums, int i, Set<List<Integer>> ans,List<Integer> list) {\\n        if(i==nums.length){\\n            //Collections.sort(list); either sort array at starting or sort list every time\\n            ans.add(list);\\n            return;\\n        }\\n        List<Integer> list1= new ArrayList<>(list);\\n        List<Integer> list2= new ArrayList<>(list);\\n        list2.add(nums[i]);\\n        solve(nums,i+1,ans,list1);\\n        solve(nums,i+1,ans,list2);\\n        return;\\n    }",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Sorting",
                    "Ordered Set"
                ],
                "code": "\\tpublic List<List<Integer>> subsetsWithDup(int[] nums) {\\n        Set<List<Integer>> ans= new HashSet<>();\\n        List<Integer> list = new ArrayList<>();\\n        Arrays.sort(nums);\\n        solve(nums,0,ans,list);\\n        return new ArrayList<>(ans);\\n    }\\n    \\n    private static void solve(int[] nums, int i, Set<List<Integer>> ans,List<Integer> list) {\\n        if(i==nums.length){\\n            //Collections.sort(list); either sort array at starting or sort list every time\\n            ans.add(list);\\n            return;\\n        }\\n        List<Integer> list1= new ArrayList<>(list);\\n        List<Integer> list2= new ArrayList<>(list);\\n        list2.add(nums[i]);\\n        solve(nums,i+1,ans,list1);\\n        solve(nums,i+1,ans,list2);\\n        return;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2135519,
                "title": "c-solution-simple-recursive-backtracking",
                "content": "```\\n\\n```class Solution {\\npublic:\\n   void help(int i,vector<int> &nums,vector<int> &subset,vector<vector<int>> &ans){\\n       int n = nums.size();\\n       //Base condition\\n       if(i == n){\\n           ans.push_back(subset);\\n           return;\\n       }else{\\n           //Including ith element\\n           subset.push_back(nums[i]);\\n           help(i+1,nums,subset,ans);\\n           subset.pop_back();  //Backtraking\\n           \\n           //Skip ith element\\n           while(i+1 <n && nums[i] == nums[i+1]) i++;\\n           help(i+1,nums,subset,ans);\\n       }\\n   }\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n       sort(nums.begin(),nums.end());\\n        vector<vector<int>> ans;\\n        vector<int> subset;\\n        help(0,nums,subset,ans);\\n        return ans;\\n    }\\n};````````\\n\\nIf it\\'s useful please vote :-:",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\n\\n```\n``````",
                "codeTag": "Unknown"
            },
            {
                "id": 1840236,
                "title": "easy-c-82-faster",
                "content": "```\\nclass Solution {\\n    void getsubset(vector<int>& nums,vector<int>&curr, set<vector<int>>&fin,int pos){\\n        if(pos==nums.size()){\\n            fin.insert(curr);\\n            return;}\\n        \\n        else{\\n            curr.push_back(nums[pos]);\\n            getsubset(nums,curr,fin,pos+1);\\n            curr.pop_back();\\n            getsubset(nums,curr,fin,pos+1);\\n        }\\n    }\\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        vector<int> curr;\\n        set<vector<int>> fin;\\n        vector<vector<int>> ans;\\n        getsubset(nums,curr,fin,0);\\n        for(auto i: fin)\\n            ans.push_back(i);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    void getsubset(vector<int>& nums,vector<int>&curr, set<vector<int>>&fin,int pos){\\n        if(pos==nums.size()){\\n            fin.insert(curr);\\n            return;}\\n        \\n        else{\\n            curr.push_back(nums[pos]);\\n            getsubset(nums,curr,fin,pos+1);\\n            curr.pop_back();\\n            getsubset(nums,curr,fin,pos+1);\\n        }\\n    }\\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        vector<int> curr;\\n        set<vector<int>> fin;\\n        vector<vector<int>> ans;\\n        getsubset(nums,curr,fin,0);\\n        for(auto i: fin)\\n            ans.push_back(i);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1821453,
                "title": "python-iterative-solution",
                "content": "This is similar to an iterative DP. We initialize an empty list then populate that list progressively. We have a new variable `prev` that keeps track of the previous length of our result. If current number is equal to the last number, we make sure to add only to those lists that already had that number (i.e.) we don\\'t replace it, just append. This makes sure there are 0 repetitions.\\n\\n\\nSuppose we have `[1,2,2]` and `res` right now is `[[], [1], [2], [1,2]]`\\nWe have `prev = 2`. Now we have one more `2` remaining. If we start from the beginning of res and append `2` to all of them, [2] and [1,2] will be repeated. Hence we start from prev (i.e.) 2nd index from which all lists already have a `2`. \\n\\nRemember we do not **replace** an already occurred element but **append**.\\n\\n\\n```python\\nclass Solution:\\n    def subsetsWithDup(self, a: List[int]) -> List[List[int]]:\\n        res = [[]]\\n        prev = 0\\n        a.sort()\\n\\n        for i, x in enumerate(a):\\n            temp = []\\n            if i and a[i] == a[i - 1]:\\n                for j in res[prev:]:\\n                    temp.append(j + [x])\\n            else:\\n                for j in res:\\n                    temp.append(j + [x])\\n            prev = len(res)\\n            res += temp\\n        return res\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Iterator"
                ],
                "code": "```python\\nclass Solution:\\n    def subsetsWithDup(self, a: List[int]) -> List[List[int]]:\\n        res = [[]]\\n        prev = 0\\n        a.sort()\\n\\n        for i, x in enumerate(a):\\n            temp = []\\n            if i and a[i] == a[i - 1]:\\n                for j in res[prev:]:\\n                    temp.append(j + [x])\\n            else:\\n                for j in res:\\n                    temp.append(j + [x])\\n            prev = len(res)\\n            res += temp\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1794784,
                "title": "c-100-faster-recursive-solution",
                "content": "\\tclass Solution {\\n\\t\\t  set<vector<int>> st;\\n\\tpublic:\\n\\t\\tvoid helper(vector<int> & nums,int idx,vector<int> &temp){\\n\\t\\t\\tif(idx==nums.size()){\\n\\t\\t\\t\\tst.insert(temp);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\ttemp.push_back(nums[idx]);\\n\\t\\t\\thelper(nums,idx+1,temp);\\n\\t\\t\\ttemp.pop_back();\\n\\t\\t\\thelper(nums,idx+1,temp);\\n\\t\\t}\\n\\t\\tvector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n\\t\\t\\tsort(nums.begin(),nums.end());   //to avoid duplicates\\n\\t\\t\\t vector<vector<int>> ans;\\n\\t\\t\\t vector<int> temp;\\n\\t\\t\\t helper(nums,0,temp);\\n\\t\\t\\t for(auto &it: st)\\n\\t\\t\\t\\t\\tans.push_back(it);\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "class Solution {\\n\\t\\t  set<vector<int>> st;\\n\\tpublic:\\n\\t\\tvoid helper(vector<int> & nums,int idx,vector<int> &temp){\\n\\t\\t\\tif(idx==nums.size()){\\n\\t\\t\\t\\tst.insert(temp);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1722060,
                "title": "java-easy-and-clean-code-with-comments",
                "content": "Runtime: 3 ms, faster than 42.29% of Java online submissions for Subsets II.\\n\\nSimilar to ```78. Subsets``` [Only have to make two changes as array contains duplicates:- 1)Sort the array. 2)Use HashSet to add the subset lists.]\\n\\n```\\n/*\\n\\nSubsets of an array of length n is (2 to the power n). We will loop i from 0 to (2 to the power n). \\nThen take binary form of i and make a subset. As binary form contains 0 or 1 only, so if 1 comes, \\nthen add the element from the array in the subset list, else not. In a subset of array, each element\\nhas 2 choices, either it will come in the subset, or not come in the subset. So, 1 represents that \\nelement  will come in the subset, 0 represents element will not come in the subset. \\n\\nExample : nums = [1,2,3]\\n          Number of subsets = (2 to the power 3) = 8. \\n          So, loop from 0 to 7.\\n\\nLoop (i)     |     Binary form     |     Subset we get\\n0            |       000           |       []\\n1            |       001           |       [3]\\n2            |       010           |       [2]\\n3            |       011           |       [2,3]\\n4            |       100           |       [1]\\n5            |       101           |       [1,3]\\n6            |       110           |       [1,2]\\n7            |       111           |       [1,2,3]\\n\\n*/\\n\\nclass Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        //Sort the nums array.\\n        Arrays.sort(nums);\\n        //Using HashSet to store subset lists, so that duplicate lists are not added.\\n        HashSet<List<Integer>> set = new HashSet<>();\\n        int n = nums.length;\\n        \\n        //total number of subsets = \\'2 to the power n\\' (1 << n = 1 * (2 to the power n) = 2 to the power n).\\n        int numOfSub = 1 << n;\\n        \\n        //As number of subsets of an array of length n is (2 to the power n), so loop i from 0 till (2 to the power n).\\n        for (int i = 0; i < numOfSub; i++) {\\n            //child list to store a subset.\\n            List<Integer> cl = new ArrayList<>();\\n            //Store i in a temp variable as i is controlling outer loop and cannot be messed with.\\n            int temp = i;\\n            \\n            //We are looping backwards, as when we are calculating binary of a number, the first bit that \\n\\t\\t\\t//comes after dividing the number with 2 is the LSB(Least Significant Bit) or the last bit of the \\n\\t\\t\\t//number\\'s binary form. \\n\\t\\t\\t//For more clarification :- When calculating binary form of a number we divide it repeatedly by 2 \\n\\t\\t\\t//until the remainder becomes 0. After that we write the remainder that has come at every step \\n\\t\\t\\t//of division backwards.\\n            for (int j = n - 1; j >= 0; j--) {\\n                //Taking remainder. (temp & 1) is equal to (temp % 2)\\n                int rem = temp & 1;\\n                //Then dividing it by 2. (temp >> 1) is equal to (temp / 2).\\n                temp = temp >> 1;\\n                \\n                //If rem is equal to 1, then add nums[j].\\n                if (rem == 1) {\\n                    cl.add(0, nums[j]);\\n                }\\n            }\\n            \\n            //After a subset is formed, add it in the set.\\n            set.add(cl);\\n        }\\n        \\n        //Convert HashSet to ArrayList and return it.\\n        List<List<Integer>> ml = new ArrayList<>(set);\\n        \\n        return ml;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```78. Subsets```\n```\\n/*\\n\\nSubsets of an array of length n is (2 to the power n). We will loop i from 0 to (2 to the power n). \\nThen take binary form of i and make a subset. As binary form contains 0 or 1 only, so if 1 comes, \\nthen add the element from the array in the subset list, else not. In a subset of array, each element\\nhas 2 choices, either it will come in the subset, or not come in the subset. So, 1 represents that \\nelement  will come in the subset, 0 represents element will not come in the subset. \\n\\nExample : nums = [1,2,3]\\n          Number of subsets = (2 to the power 3) = 8. \\n          So, loop from 0 to 7.\\n\\nLoop (i)     |     Binary form     |     Subset we get\\n0            |       000           |       []\\n1            |       001           |       [3]\\n2            |       010           |       [2]\\n3            |       011           |       [2,3]\\n4            |       100           |       [1]\\n5            |       101           |       [1,3]\\n6            |       110           |       [1,2]\\n7            |       111           |       [1,2,3]\\n\\n*/\\n\\nclass Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        //Sort the nums array.\\n        Arrays.sort(nums);\\n        //Using HashSet to store subset lists, so that duplicate lists are not added.\\n        HashSet<List<Integer>> set = new HashSet<>();\\n        int n = nums.length;\\n        \\n        //total number of subsets = \\'2 to the power n\\' (1 << n = 1 * (2 to the power n) = 2 to the power n).\\n        int numOfSub = 1 << n;\\n        \\n        //As number of subsets of an array of length n is (2 to the power n), so loop i from 0 till (2 to the power n).\\n        for (int i = 0; i < numOfSub; i++) {\\n            //child list to store a subset.\\n            List<Integer> cl = new ArrayList<>();\\n            //Store i in a temp variable as i is controlling outer loop and cannot be messed with.\\n            int temp = i;\\n            \\n            //We are looping backwards, as when we are calculating binary of a number, the first bit that \\n\\t\\t\\t//comes after dividing the number with 2 is the LSB(Least Significant Bit) or the last bit of the \\n\\t\\t\\t//number\\'s binary form. \\n\\t\\t\\t//For more clarification :- When calculating binary form of a number we divide it repeatedly by 2 \\n\\t\\t\\t//until the remainder becomes 0. After that we write the remainder that has come at every step \\n\\t\\t\\t//of division backwards.\\n            for (int j = n - 1; j >= 0; j--) {\\n                //Taking remainder. (temp & 1) is equal to (temp % 2)\\n                int rem = temp & 1;\\n                //Then dividing it by 2. (temp >> 1) is equal to (temp / 2).\\n                temp = temp >> 1;\\n                \\n                //If rem is equal to 1, then add nums[j].\\n                if (rem == 1) {\\n                    cl.add(0, nums[j]);\\n                }\\n            }\\n            \\n            //After a subset is formed, add it in the set.\\n            set.add(cl);\\n        }\\n        \\n        //Convert HashSet to ArrayList and return it.\\n        List<List<Integer>> ml = new ArrayList<>(set);\\n        \\n        return ml;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1675120,
                "title": "unique-java-solution-using-hashset-to-avoid-duplicates",
                "content": "The Basic Idea is to use HashSet to remove the duplicates and procede as you solve the Subset problem, that is either choose a particular element or not choose. \\nAlso don\\'t forget to sort the array beforehand so that there is no duplicate ordering of the numbers inside the final answer!\\n\\n```\\nclass Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        List<List<Integer>> ans = new ArrayList<List<Integer>>();\\n        Arrays.sort(nums);\\n        helper(nums,0,ans,new ArrayList<Integer>());\\n        List<List<Integer>> newAns = new ArrayList<List<Integer>>();\\n        HashSet<List<Integer>> set = new HashSet<>();\\n        for(List<Integer> curr : ans){\\n            set.add(curr);\\n        }\\n        for(List<Integer> curr : set){\\n            newAns.add(curr);\\n        }\\n        return newAns;\\n    }\\n    public void helper(int[] nums, int i, List<List<Integer>> ans, ArrayList<Integer> curr){\\n        if(i == nums.length){\\n            ans.add(new ArrayList<Integer>(curr));\\n            return;\\n        }\\n        curr.add(nums[i]);\\n        helper(nums,i+1,ans,curr);\\n        curr.remove(curr.size()-1);\\n        helper(nums,i+1,ans,curr);\\n    }\\n}\\n```\\nPlease upvote if found helpful!!",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        List<List<Integer>> ans = new ArrayList<List<Integer>>();\\n        Arrays.sort(nums);\\n        helper(nums,0,ans,new ArrayList<Integer>());\\n        List<List<Integer>> newAns = new ArrayList<List<Integer>>();\\n        HashSet<List<Integer>> set = new HashSet<>();\\n        for(List<Integer> curr : ans){\\n            set.add(curr);\\n        }\\n        for(List<Integer> curr : set){\\n            newAns.add(curr);\\n        }\\n        return newAns;\\n    }\\n    public void helper(int[] nums, int i, List<List<Integer>> ans, ArrayList<Integer> curr){\\n        if(i == nums.length){\\n            ans.add(new ArrayList<Integer>(curr));\\n            return;\\n        }\\n        curr.add(nums[i]);\\n        helper(nums,i+1,ans,curr);\\n        curr.remove(curr.size()-1);\\n        helper(nums,i+1,ans,curr);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1490893,
                "title": "c-solution-aditya-verma-recursive-method-cpp",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>ans;\\n    set<vector<int>>s;\\n    void solve(vector<int>nums,vector<int>op)\\n    {\\n        if(nums.size()==0)\\n        {\\n            if(s.find(op)==s.end())\\n            {\\n                s.insert(op);\\n                ans.push_back(op);\\n            }\\n            return;\\n        }\\n        vector<int>op1=op;\\n        vector<int>op2=op;\\n        op2.push_back(nums[0]);\\n        nums.erase(nums.begin()+0);\\n        solve (nums,op1);\\n        solve (nums,op2);\\n        \\n    }\\n    \\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        vector<int>op;\\n        sort(nums.begin(),nums.end());\\n        solve(nums,op);\\n        return ans;\\n    }\\n};\\n*Hats off To Aditya Verma & P.D.*```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>ans;\\n    set<vector<int>>s;\\n    void solve(vector<int>nums,vector<int>op)\\n    {\\n        if(nums.size()==0)\\n        {\\n            if(s.find(op)==s.end())\\n            {\\n                s.insert(op);\\n                ans.push_back(op);\\n            }\\n            return;\\n        }\\n        vector<int>op1=op;\\n        vector<int>op2=op;\\n        op2.push_back(nums[0]);\\n        nums.erase(nums.begin()+0);\\n        solve (nums,op1);\\n        solve (nums,op2);\\n        \\n    }\\n    \\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        vector<int>op;\\n        sort(nums.begin(),nums.end());\\n        solve(nums,op);\\n        return ans;\\n    }\\n};\\n*Hats off To Aditya Verma & P.D.*```",
                "codeTag": "Java"
            },
            {
                "id": 1458912,
                "title": "javascript-backtracking",
                "content": "```\\nvar subsetsWithDup = function(nums) {\\n    nums.sort();\\n    let output = [];\\n    backtracking(0, [], nums, output);\\n    return output\\n};\\n\\nfunction backtracking(index, list, nums, output) {\\n    if(index > nums.length) return\\n    console.log(\"output: \",output);\\n    console.log(\"list: \",list);\\n    output.push([...list]);\\n    for(let i = index; i < nums.length; i++) {\\n        if(i > index && nums[i] === nums[i - 1]) continue\\n        list.push(nums[i]);\\n        backtracking(i+1, list, nums, output);\\n        list.pop();\\n    }\\n    return output;\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking"
                ],
                "code": "```\\nvar subsetsWithDup = function(nums) {\\n    nums.sort();\\n    let output = [];\\n    backtracking(0, [], nums, output);\\n    return output\\n};\\n\\nfunction backtracking(index, list, nums, output) {\\n    if(index > nums.length) return\\n    console.log(\"output: \",output);\\n    console.log(\"list: \",list);\\n    output.push([...list]);\\n    for(let i = index; i < nums.length; i++) {\\n        if(i > index && nums[i] === nums[i - 1]) continue\\n        list.push(nums[i]);\\n        backtracking(i+1, list, nums, output);\\n        list.pop();\\n    }\\n    return output;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1448506,
                "title": "c-easy-solution",
                "content": "**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**\\n```\\nclass Solution {\\npublic:\\n    void recurse(int i,vector<int> &v,vector<vector<int>> &ans,vector<int>& nums)\\n    {\\n        if(i==nums.size())\\n        {\\n            if(find(ans.begin(),ans.end(),v)==ans.end())\\n            ans.push_back(v);\\n            return;\\n        }   \\n        recurse(i+1,v,ans,nums);\\n        v.push_back(nums[i]);\\n        recurse(i+1,v,ans,nums);\\n        v.pop_back();\\n    }\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        vector<int> empty;\\n        vector<vector<int>> ans;\\n        sort(nums.begin(),nums.end());\\n        recurse(0,empty,ans,nums);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void recurse(int i,vector<int> &v,vector<vector<int>> &ans,vector<int>& nums)\\n    {\\n        if(i==nums.size())\\n        {\\n            if(find(ans.begin(),ans.end(),v)==ans.end())\\n            ans.push_back(v);\\n            return;\\n        }   \\n        recurse(i+1,v,ans,nums);\\n        v.push_back(nums[i]);\\n        recurse(i+1,v,ans,nums);\\n        v.pop_back();\\n    }\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        vector<int> empty;\\n        vector<vector<int>> ans;\\n        sort(nums.begin(),nums.end());\\n        recurse(0,empty,ans,nums);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1437563,
                "title": "js-backtracking",
                "content": "```\\n//approach: backtracking(dfs)\\n//basic template of backtracking would be to loop, choose, explore and unchoose\\n//loop: you want to iterate over all the numbers so that you can find it\\'s possible values\\n//choose: you start with the index value(the 0th index number), so that you can find the next combined possible values for the 0th value\\n//explore: basically recursion to add all the next values to the 0th value\\n//unchoose: you pop the value (Oth value), so then you can now start with other value to make that other value 0th value\\n//in this case: \\n//when drawing the recursive tree, we can see that,\\n//               = we can take each element from the nums array and recurse down until we are at the end of the length of the nums array\\n//               = after recursing the element we are on, we can move on to the next element in the array and continue till the i < nums array.length\\n//we pass in index so that we can reset i when we want to, however i will most likely be ahead of the index value, when we recurse back\\n//\\n//before we backtrack: \\n//we will sort the the given array in ascending order which is time of (nlogn)  (i might be wrong about the time complexity, but 95% sure)\\n//and doing so, we can always check if the previous value is the same as the current value while iterating, \\n//we will be adding the value as we iterate on to the subsets array, but just not when we encounter the same value we previously saw\\nvar subsetsWithDup = function(nums) {\\n    nums = nums.sort((a,b)=> a-b);\\n    let resultArray = new Array();\\n    \\n    function helper(nums, subSets, index){\\n        resultArray.push([...subSets]);\\n        \\n        for(let i = index; i < nums.length; i++){\\n            \\n            //making sure i > 0  so when we subtract nums[i - 1] we dont get nums[-1]\\n            //to avoid going back to duplicate sets, we can check previous value is not equal to the same value  nums[i-1] === nums[i]\\n            if(i > index && nums[i-1] === nums[i]) \\n                continue;\\n            \\n            //choose\\n            subSets.push(nums[i]);\\n            \\n            //explore\\n            helper(nums, subSets, i+1);\\n            \\n            //unchoose\\n            subSets.pop();\\n            \\n        }\\n    }\\n    helper(nums, new Array(), 0);\\n    \\n    return resultArray;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\n//approach: backtracking(dfs)\\n//basic template of backtracking would be to loop, choose, explore and unchoose\\n//loop: you want to iterate over all the numbers so that you can find it\\'s possible values\\n//choose: you start with the index value(the 0th index number), so that you can find the next combined possible values for the 0th value\\n//explore: basically recursion to add all the next values to the 0th value\\n//unchoose: you pop the value (Oth value), so then you can now start with other value to make that other value 0th value\\n//in this case: \\n//when drawing the recursive tree, we can see that,\\n//               = we can take each element from the nums array and recurse down until we are at the end of the length of the nums array\\n//               = after recursing the element we are on, we can move on to the next element in the array and continue till the i < nums array.length\\n//we pass in index so that we can reset i when we want to, however i will most likely be ahead of the index value, when we recurse back\\n//\\n//before we backtrack: \\n//we will sort the the given array in ascending order which is time of (nlogn)  (i might be wrong about the time complexity, but 95% sure)\\n//and doing so, we can always check if the previous value is the same as the current value while iterating, \\n//we will be adding the value as we iterate on to the subsets array, but just not when we encounter the same value we previously saw\\nvar subsetsWithDup = function(nums) {\\n    nums = nums.sort((a,b)=> a-b);\\n    let resultArray = new Array();\\n    \\n    function helper(nums, subSets, index){\\n        resultArray.push([...subSets]);\\n        \\n        for(let i = index; i < nums.length; i++){\\n            \\n            //making sure i > 0  so when we subtract nums[i - 1] we dont get nums[-1]\\n            //to avoid going back to duplicate sets, we can check previous value is not equal to the same value  nums[i-1] === nums[i]\\n            if(i > index && nums[i-1] === nums[i]) \\n                continue;\\n            \\n            //choose\\n            subSets.push(nums[i]);\\n            \\n            //explore\\n            helper(nums, subSets, i+1);\\n            \\n            //unchoose\\n            subSets.pop();\\n            \\n        }\\n    }\\n    helper(nums, new Array(), 0);\\n    \\n    return resultArray;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1431473,
                "title": "one-simple-python-solution",
                "content": "```\\nclass Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n\\t\\n        nums.sort()\\n        ans = [[]]\\n        \\n        for num in nums:\\n            for index in range(len(ans)):\\n                temp = ans[index] + [num]\\n                if temp not in ans:\\n                    ans.append(temp)\\n        \\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n\\t\\n        nums.sort()\\n        ans = [[]]\\n        \\n        for num in nums:\\n            for index in range(len(ans)):\\n                temp = ans[index] + [num]\\n                if temp not in ans:\\n                    ans.append(temp)\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1414383,
                "title": "java-dfs-using-sorted-nums-to-skip-duplicate-subtrees-with-diagram-faster-than-99-5",
                "content": "This is a typical DFS solution, except we say that if we\\'re at a number with a repeating value, the left subtree will not choose an edge corresponding with the repeated value.\\n\\nSo general structure:\\nAt each step, recurse left excluding the duplicate number.\\nThen (unless this subtree is ignoring this value) recurse right with no limits.\\n\\nHere\\'s an example of how the execution for nums = [1, 2, 2] would go.\\n\\n![image](https://assets.leetcode.com/users/images/40155b43-c4c7-4ef2-b1ed-80431f7102d4_1629418968.448155.png)\\n\\n```\\nclass Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        return generateSubsets(nums, new ArrayList<List<Integer>>());\\n    }\\n    \\n    private ArrayList<List<Integer>> generateSubsets(int[] nums, ArrayList<List<Integer>> output){\\n        Arrays.sort(nums);\\n        generateSubsetsHelper(nums, 0, new ArrayList<Integer>(), output, false);\\n        \\n        return output;\\n    }\\n    \\n    private void generateSubsetsHelper(int[] nums, int depth, List<Integer> currentSequence, ArrayList<List<Integer>> output, boolean ignoreValue){\\n        if(depth == nums.length){\\n            // Add a finished sequence to the result\\n            output.add(new ArrayList<Integer>(currentSequence));\\n            return;\\n        }\\n        \\n        // If the next two numbers are repeating, then our left subtree will ignore it.\\n        boolean ignoreNext =  depth < nums.length - 1 && nums[depth] == nums[depth + 1];\\n        generateSubsetsHelper(nums, depth + 1, currentSequence, output, ignoreNext);\\n        \\n        if(!ignoreValue) {\\n            // Include current num\\n            currentSequence.add(nums[depth]);\\n            generateSubsetsHelper(nums, depth + 1, currentSequence, output, false);\\n        \\n            // Clean up before backtracking\\n            currentSequence.remove(currentSequence.size() - 1);\\n        }\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        return generateSubsets(nums, new ArrayList<List<Integer>>());\\n    }\\n    \\n    private ArrayList<List<Integer>> generateSubsets(int[] nums, ArrayList<List<Integer>> output){\\n        Arrays.sort(nums);\\n        generateSubsetsHelper(nums, 0, new ArrayList<Integer>(), output, false);\\n        \\n        return output;\\n    }\\n    \\n    private void generateSubsetsHelper(int[] nums, int depth, List<Integer> currentSequence, ArrayList<List<Integer>> output, boolean ignoreValue){\\n        if(depth == nums.length){\\n            // Add a finished sequence to the result\\n            output.add(new ArrayList<Integer>(currentSequence));\\n            return;\\n        }\\n        \\n        // If the next two numbers are repeating, then our left subtree will ignore it.\\n        boolean ignoreNext =  depth < nums.length - 1 && nums[depth] == nums[depth + 1];\\n        generateSubsetsHelper(nums, depth + 1, currentSequence, output, ignoreNext);\\n        \\n        if(!ignoreValue) {\\n            // Include current num\\n            currentSequence.add(nums[depth]);\\n            generateSubsetsHelper(nums, depth + 1, currentSequence, output, false);\\n        \\n            // Clean up before backtracking\\n            currentSequence.remove(currentSequence.size() - 1);\\n        }\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1398718,
                "title": "python-solution-with-memoization-similar-to-subset-problem",
                "content": "Subset :\\n\\n\\t\\tres = []\\n        i=0\\n        temp=[]\\n        def dfs(nums,i,res,temp):\\n            if i >= len(nums):\\n                res.append(temp)\\n                return res\\n            dfs(nums,i+1,res,temp+[nums[i]])\\n            dfs(nums,i+1,res,temp)\\n            return res\\n        dfs(nums,i,res,temp)\\n        return res\\n\\nSubset 2\\t: using above approach and passing sorted num\\n\\n\\t\\tres = []\\n        i = 0\\n        temp = []\\n        nums.sort()\\n        memo = {}\\n        def dfs(i,nums,res,temp):\\n            if i>=len(nums):\\n                res.append(temp)\\n                return res\\n            if tuple(temp+[nums[i]]) not in memo:\\n                memo[tuple(temp+[nums[i]])] = 1\\n                dfs(i+1,nums,res,temp+[nums[i]])\\n            \\n            dfs(i+1,nums,res,temp)\\n            return res\\n        dfs(i,nums,res,temp)\\n        return res",
                "solutionTags": [],
                "code": "Subset :\\n\\n\\t\\tres = []\\n        i=0\\n        temp=[]\\n        def dfs(nums,i,res,temp):\\n            if i >= len(nums):\\n                res.append(temp)\\n                return res\\n            dfs(nums,i+1,res,temp+[nums[i]])\\n            dfs(nums,i+1,res,temp)\\n            return res\\n        dfs(nums,i,res,temp)\\n        return res\\n\\nSubset 2\\t: using above approach and passing sorted num\\n\\n\\t\\tres = []\\n        i = 0\\n        temp = []\\n        nums.sort()\\n        memo = {}\\n        def dfs(i,nums,res,temp):\\n            if i>=len(nums):\\n                res.append(temp)\\n                return res\\n            if tuple(temp+[nums[i]]) not in memo:\\n                memo[tuple(temp+[nums[i]])] = 1\\n                dfs(i+1,nums,res,temp+[nums[i]])\\n            \\n            dfs(i+1,nums,res,temp)\\n            return res\\n        dfs(i,nums,res,temp)\\n        return res",
                "codeTag": "Python3"
            },
            {
                "id": 1381403,
                "title": "python-solution-97-75-faster-just-used-tuple-instead-of-array",
                "content": "```\\nclass Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        \\n        nums.sort()\\n        def recur(index,asf):\\n\\t\\t\\n            ans.append(asf)\\n\\t\\t\\t\\n            if index>=len(nums): #base case\\n                return\\n\\t\\t\\t\\t\\n            s=set()\\n            for i in range(index,len(nums)):\\n                if nums[i] not in s:\\n                    s.add(nums[i])\\n                    recur(i+1,asf+(nums[i],))\\n\\t\\t#main====================================\\t\\t\\t\\n        ans=[]               \\n        recur(0,tuple())\\n        return ans\\n```\\n![image](https://assets.leetcode.com/users/images/ff697d3b-343d-4657-a867-36e3999c60bd_1628015519.1739736.png)\\n\\nanyone with 100% solution?",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        \\n        nums.sort()\\n        def recur(index,asf):\\n\\t\\t\\n            ans.append(asf)\\n\\t\\t\\t\\n            if index>=len(nums): #base case\\n                return\\n\\t\\t\\t\\t\\n            s=set()\\n            for i in range(index,len(nums)):\\n                if nums[i] not in s:\\n                    s.add(nums[i])\\n                    recur(i+1,asf+(nums[i],))\\n\\t\\t#main====================================\\t\\t\\t\\n        ans=[]               \\n        recur(0,tuple())\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1381101,
                "title": "python-easy-bitmasks",
                "content": "SIMILAR PROBLEM: \\nhttps://leetcode.com/problems/subsets\\nSOLUTION:\\nhttps://leetcode.com/problems/subsets/discuss/1381094/PYTHON-oror-BITMASK\\n\\n\\nApproach:\\nWe map each subset to a bitmask of length n, where 1 on the ith position in bitmask means\\nthe presence of nums[i] in the subset, and 0 means its absence.\\n\\nNow we want our subsets without duplicates, so we need to filter out the repeated subsets!\\nWho better can do this work except SET !!\\nAfter finding all subsets, we push them in set and get only unique subset entries, and we return that set as our output.\\n\\nTC: O(Nx2^N)\\nSC: O(N) to store \\'ans\\'\\n\\n```\\nclass Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        s = set()\\n        nums.sort()\\n        for i in range(2**len(nums)):\\n            ans = []\\n            for j in range(len(nums)):\\n                if i & (1<<j):\\n                    ans.append(nums[j])\\n\\t\\t\\t\\t\\t\\n            s.add(ans)\\n\\t\\t\\t\\n        return list(s)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        s = set()\\n        nums.sort()\\n        for i in range(2**len(nums)):\\n            ans = []\\n            for j in range(len(nums)):\\n                if i & (1<<j):\\n                    ans.append(nums[j])\\n\\t\\t\\t\\t\\t\\n            s.add(ans)\\n\\t\\t\\t\\n        return list(s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1380607,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        \\n        int resultSize = 1;\\n        \\n        Arrays.sort(nums);\\n        result.add(new ArrayList<>());\\n        \\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            int startIndex = 0;\\n\\n            if (i > 0 && nums[i] == nums[i - 1]) {\\n                startIndex = resultSize;\\n            }\\n            \\n            resultSize = result.size();\\n            \\n            while (startIndex < resultSize) {\\n                List<Integer> list = new ArrayList<>(result.get(startIndex));\\n                \\n                list.add(nums[i]);\\n                \\n                result.add(list);\\n                \\n                startIndex++;\\n            }\\n        }\\n        \\n        return result;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        \\n        int resultSize = 1;\\n        \\n        Arrays.sort(nums);\\n        result.add(new ArrayList<>());\\n        \\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            int startIndex = 0;\\n\\n            if (i > 0 && nums[i] == nums[i - 1]) {\\n                startIndex = resultSize;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1380270,
                "title": "subset-ii-simple-backtracking-java-solution",
                "content": "**Approach:**\\nThe Magic happens at 3 places.\\n\\n1.) Sorting the input array\\n2.) checking for duplicates\\n3.) if(i > index) condition\\n\\nSo after sorting, all the duplicates are next to each other.\\n\\nFor Example: 1,3,5,2,5,3,2,3 becomes 1,2,2,3,3,3,5,5\\n\\nAfter sorting, as per the backtracking flow we can avoid making calls to duplicate numbers because the same pattern will follow again. \\nIn case of above example,\\n1,2,3,3,3,5,5\\nThe above subset will come for both 2\\'s at index 1 and 2.\\n\\nAnd finally the condition \"if(i > index &&  nums[i] == nums[i-1])\",\\nif the condition was if(i > 0), the code will still return some duplicate subset.\\nIn order to avoid duplicate subsets, you need to set the codition from the current index position of recursion. i.e if(i > index)\\n\\nHope this was helpful.\\n\\n\\n\\n\\tclass Solution {\\n\\t\\tpublic List<List<Integer>> subsetsWithDup(int[] nums) {\\n\\n\\t\\t\\tList<List<Integer>> subsetList = new ArrayList<>();\\n\\n\\t\\t\\tArrays.sort(nums);\\n\\n\\t\\t\\tdfs(subsetList, nums, 0, new ArrayList<>());\\n\\n\\t\\t\\treturn subsetList;\\n\\t\\t}\\n\\n\\t\\tprivate void dfs(List<List<Integer>> subsetList, int nums[], int index, List<Integer> tempList){\\n\\n\\t\\t\\tsubsetList.add(new ArrayList<>(tempList));\\n\\n\\t\\t\\tif(index>= nums.length)\\n\\t\\t\\t\\treturn;\\n\\n\\t\\t\\tfor(int i = index; i < nums.length; i++){\\n\\n\\t\\t\\t\\tif(i > index &&  nums[i] == nums[i-1])\\n\\t\\t\\t\\t\\tcontinue;\\n\\n\\t\\t\\t\\ttempList.add(nums[i]);\\n\\t\\t\\t\\tdfs(subsetList, nums, i+1, tempList);\\n\\t\\t\\t\\ttempList.remove(tempList.size() - 1);\\n\\n\\t\\t\\t} \\n\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic List<List<Integer>> subsetsWithDup(int[] nums) {\\n\\n\\t\\t\\tList<List<Integer>> subsetList = new ArrayList<>();\\n\\n\\t\\t\\tArrays.sort(nums);\\n\\n\\t\\t\\tdfs(subsetList, nums, 0, new ArrayList<>());\\n\\n\\t\\t\\treturn subsetList;\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1357701,
                "title": "easy-backtracking-using-python-3",
                "content": "```\\ndef subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n\\tnums.sort()\\n\\tres = []\\n\\tstack = [([], 0)]\\n\\tl = len(nums)\\n\\n\\twhile stack:\\n\\t\\tsub, pos = stack.pop()\\n\\t\\tres.append(sub)\\n\\t\\tlast = None\\n\\n\\t\\twhile pos<l:\\n\\t\\t\\tif nums[pos]!=last:\\n\\t\\t\\t\\tstack.append((sub+[nums[pos]], pos+1))\\n\\t\\t\\t\\tlast = nums[pos]\\n\\t\\t\\tpos+=1\\n\\treturn res\\n```",
                "solutionTags": [
                    "Python3",
                    "Backtracking"
                ],
                "code": "```\\ndef subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n\\tnums.sort()\\n\\tres = []\\n\\tstack = [([], 0)]\\n\\tl = len(nums)\\n\\n\\twhile stack:\\n\\t\\tsub, pos = stack.pop()\\n\\t\\tres.append(sub)\\n\\t\\tlast = None\\n\\n\\t\\twhile pos<l:\\n\\t\\t\\tif nums[pos]!=last:\\n\\t\\t\\t\\tstack.append((sub+[nums[pos]], pos+1))\\n\\t\\t\\t\\tlast = nums[pos]\\n\\t\\t\\tpos+=1\\n\\treturn res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1316241,
                "title": "c-backtracking-4ms",
                "content": "```\\nclass Solution {\\npublic:\\n    void sub(vector<int>& n,vector<vector<int>>& res,vector<int>& v,int idx){\\n        for(int i=idx;i!=n.size();++i){\\n            if(i==idx || n[i]!=n[i-1]){\\n                v.push_back(n[i]);\\n                res.push_back(v);\\n                sub(n,res,v,i+1);\\n                v.pop_back();\\n            }\\n            \\n        }\\n        \\n    }\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        vector<vector<int>> res;\\n        vector<int> v;\\n        res.push_back(v);\\n        sub(nums,res,v,0);\\n        return res;\\n    }\\n};\\n```\\n\\nWe can use `unordered_set<vector<int>>` and sort it or `set<vector<int>>` for storing the possible subsets and after the recursion store all the possible subset in 2-D array and return it but that method increase the space as well as time . That approach is basically brute because we are only storing distinct subset without doing anything . Therefore we can use the above approach , and stop for call when we have duplicate elements.\\n\\nHope you liked the solution. If you have , pls upvote it.",
                "solutionTags": [
                    "C++",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void sub(vector<int>& n,vector<vector<int>>& res,vector<int>& v,int idx){\\n        for(int i=idx;i!=n.size();++i){\\n            if(i==idx || n[i]!=n[i-1]){\\n                v.push_back(n[i]);\\n                res.push_back(v);\\n                sub(n,res,v,i+1);\\n                v.pop_back();\\n            }\\n            \\n        }\\n        \\n    }\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        vector<vector<int>> res;\\n        vector<int> v;\\n        res.push_back(v);\\n        sub(nums,res,v,0);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1300129,
                "title": "0-ms-faster-than-100-percent-c",
                "content": "```\\nclass Solution {\\npublic:\\n    void find(int index,vector<vector<int>>&ans,vector<int>&ds,vector<int>&nums){\\n        ans.push_back(ds);\\n        for(int i=index;i<nums.size();i++){\\n            if(i!=index && nums[i]==nums[i-1])continue;\\n            ds.push_back(nums[i]);\\n            find(i+1,ans,ds,nums);\\n            ds.pop_back();\\n        }\\n    }\\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        vector<vector<int>>ans;\\n        sort(nums.begin(),nums.end());\\n        vector<int>ds;\\n        find(0,ans,ds,nums);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void find(int index,vector<vector<int>>&ans,vector<int>&ds,vector<int>&nums){\\n        ans.push_back(ds);\\n        for(int i=index;i<nums.size();i++){\\n            if(i!=index && nums[i]==nums[i-1])continue;\\n            ds.push_back(nums[i]);\\n            find(i+1,ans,ds,nums);\\n            ds.pop_back();\\n        }\\n    }\\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        vector<vector<int>>ans;\\n        sort(nums.begin(),nums.end());\\n        vector<int>ds;\\n        find(0,ans,ds,nums);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1255330,
                "title": "c-back-tracking-bit-masking-2-methods",
                "content": "**1. Back Tracking : Runtime: 4 ms, Memory Usage: 7.4 MB**\\n```\\nclass Solution {\\npublic:\\n    \\n    void helper(vector<int>& v, vector<vector<int>> &res, vector<int>& temp, int start)\\n    {\\n        res.push_back(temp);\\n        for(int i=start;i!=v.size();i++)\\n        {\\n            if(i==start or v[i]!=v[i-1])\\n            {\\n                temp.push_back(v[i]);\\n                helper(v,res,temp,i+1);\\n                temp.pop_back();\\n            }\\n        }\\n    }\\n    vector<vector<int>> subsetsWithDup(vector<int>& arr) {\\n\\n        sort(arr.begin(),arr.end());\\n        vector<int> temp;\\n        vector<vector<int>> res;\\n        helper(arr,res,temp,0);\\n        return res;        \\n    }\\n};\\n```\\n\\n**2. Bit Masking: Runtime: 20 ms, Memory Usage: 12.2 MB**\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    map<multiset<int>,int>m;\\n    vector<vector<int>> subsetsWithDup(vector<int>& arr) {\\n        \\n        m.clear();\\n        int n=arr.size();\\n        sort(arr.begin(),arr.end());\\n        vector<multiset<int>> ans;\\n        vector<vector<int> > res;\\n        \\n        for(int i=0;i<(1<<n);i++)\\n        {\\n            multiset<int>temp;\\n            for(int j=0;j<n;j++)\\n            {\\n                if(i&(1<<j))\\n                    temp.insert(arr[j]);\\n            }\\n            if(m[temp]==0)\\n                ans.push_back(temp);\\n            m[temp]++;\\n        }\\n        \\n        for(auto s: ans)\\n        {\\n            vector<int>temp;\\n            for(auto i: s)\\n                temp.push_back(i);\\n\\t\\t\\t\\t\\n            res.push_back(temp);\\n        }\\n        \\n        return res;   \\n    }\\n};\\n```\\n\\n**Important :** Back Tracking returns all the unique subsets in Lexicographical order.\\n\\t\\t",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    void helper(vector<int>& v, vector<vector<int>> &res, vector<int>& temp, int start)\\n    {\\n        res.push_back(temp);\\n        for(int i=start;i!=v.size();i++)\\n        {\\n            if(i==start or v[i]!=v[i-1])\\n            {\\n                temp.push_back(v[i]);\\n                helper(v,res,temp,i+1);\\n                temp.pop_back();\\n            }\\n        }\\n    }\\n    vector<vector<int>> subsetsWithDup(vector<int>& arr) {\\n\\n        sort(arr.begin(),arr.end());\\n        vector<int> temp;\\n        vector<vector<int>> res;\\n        helper(arr,res,temp,0);\\n        return res;        \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    map<multiset<int>,int>m;\\n    vector<vector<int>> subsetsWithDup(vector<int>& arr) {\\n        \\n        m.clear();\\n        int n=arr.size();\\n        sort(arr.begin(),arr.end());\\n        vector<multiset<int>> ans;\\n        vector<vector<int> > res;\\n        \\n        for(int i=0;i<(1<<n);i++)\\n        {\\n            multiset<int>temp;\\n            for(int j=0;j<n;j++)\\n            {\\n                if(i&(1<<j))\\n                    temp.insert(arr[j]);\\n            }\\n            if(m[temp]==0)\\n                ans.push_back(temp);\\n            m[temp]++;\\n        }\\n        \\n        for(auto s: ans)\\n        {\\n            vector<int>temp;\\n            for(auto i: s)\\n                temp.push_back(i);\\n\\t\\t\\t\\t\\n            res.push_back(temp);\\n        }\\n        \\n        return res;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1244947,
                "title": "python-and-cpp-sort-bit-masking-simple-solution",
                "content": "Python Solution : \\n```\\nclass Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        \\n        nums.sort()\\n        n = len(nums)\\n        res = []\\n        for i in range(2**n):\\n            ans = []\\n            for j in range(n):\\n                if(i&(1<<j)):\\n                    ans.append(nums[j])\\n            if(ans not in res):\\n                res.append(ans)\\n                \\n        return res\\n```\\n\\n\\nC++ Solution :\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        set<vector<int>>  res;\\n        for(int i = 0; i < (1<<n); i++){\\n            vector<int> ans;\\n            for(int bit =0; bit < n; bit++){\\n                if(i&(1<<bit)){\\n                    ans.push_back(nums[bit]);\\n                }\\n            }\\n            sort(ans.begin(), ans.end());\\n            res.insert(ans);\\n        }\\n        \\n        vector<vector<int>> r(res.begin(), res.end());\\n\\n        return r;\\n    }\\n};\\n```\\n\\n\\n\\nLike Than Upvote This",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        \\n        nums.sort()\\n        n = len(nums)\\n        res = []\\n        for i in range(2**n):\\n            ans = []\\n            for j in range(n):\\n                if(i&(1<<j)):\\n                    ans.append(nums[j])\\n            if(ans not in res):\\n                res.append(ans)\\n                \\n        return res\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        set<vector<int>>  res;\\n        for(int i = 0; i < (1<<n); i++){\\n            vector<int> ans;\\n            for(int bit =0; bit < n; bit++){\\n                if(i&(1<<bit)){\\n                    ans.push_back(nums[bit]);\\n                }\\n            }\\n            sort(ans.begin(), ans.end());\\n            res.insert(ans);\\n        }\\n        \\n        vector<vector<int>> r(res.begin(), res.end());\\n\\n        return r;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1221403,
                "title": "simple-java-solution",
                "content": "\\n\\tpublic List<List<Integer>> subsetsWithDup(int[] nums) \\n    {\\n        List<List<Integer>> res = new ArrayList<List<Integer>>();\\n        int n=nums.length;\\n        for(int i=0;i<(1<<n);i++)\\n        {\\n            List<Integer> al = new ArrayList<Integer>();\\n            for(int j=0;j<n;j++)\\n            {\\n                if((i&(1<<j))!=0)\\n                {\\n                   al.add(nums[j]);\\n                }\\n                Collections.sort(al);\\n            }\\n            if(!res.contains(al))\\n            res.add(al);\\n        }\\n        return res;\\n    }",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "\\n\\tpublic List<List<Integer>> subsetsWithDup(int[] nums) \\n    {\\n        List<List<Integer>> res = new ArrayList<List<Integer>>();\\n        int n=nums.length;\\n        for(int i=0;i<(1<<n);i++)\\n        {\\n            List<Integer> al = new ArrayList<Integer>();\\n            for(int j=0;j<n;j++)\\n            {\\n                if((i&(1<<j))!=0)\\n                {\\n                   al.add(nums[j]);\\n                }\\n                Collections.sort(al);\\n            }\\n            if(!res.contains(al))\\n            res.add(al);\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1161736,
                "title": "python3-easy-solution",
                "content": "Runtime: 40 ms, faster than 45.92% of Python3 online submissions for Subsets II.\\nMemory Usage: 14.2 MB, less than 99.14% of Python3 online submissions for Subsets II.\\n\\n    class Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        \\n        output = [[]]\\n        \\n        nums.sort()\\n        \\n        for i in nums:\\n            \\n            output += [lst+[i] for lst in output if lst+[i] not in output]\\n            \\n        return output\\n\\t\\t\\nRECURSIVE APPROACH:\\n\\n    class Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        \\n        output = [[]]\\n        \\n        nums.sort()\\n        \\n        def backtrack(start,lst):\\n            if len(lst) == len(nums):\\n                return \\n            for i in range(start,len(nums)):\\n                if i>start and nums[i-1]==nums[i]:\\n                    continue\\n                output.append(lst+[nums[i]])\\n                \\n                backtrack(i+1,lst+[nums[i]])\\n        backtrack(0,[])\\n        return output",
                "solutionTags": [],
                "code": "Runtime: 40 ms, faster than 45.92% of Python3 online submissions for Subsets II.\\nMemory Usage: 14.2 MB, less than 99.14% of Python3 online submissions for Subsets II.\\n\\n    class Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        \\n        output = [[]]\\n        \\n        nums.sort()\\n        \\n        for i in nums:\\n            \\n            output += [lst+[i] for lst in output if lst+[i] not in output]\\n            \\n        return output\\n\\t\\t\\nRECURSIVE APPROACH:\\n\\n    class Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        \\n        output = [[]]\\n        \\n        nums.sort()\\n        \\n        def backtrack(start,lst):\\n            if len(lst) == len(nums):\\n                return \\n            for i in range(start,len(nums)):\\n                if i>start and nums[i-1]==nums[i]:\\n                    continue\\n                output.append(lst+[nums[i]])\\n                \\n                backtrack(i+1,lst+[nums[i]])\\n        backtrack(0,[])\\n        return output",
                "codeTag": "Java"
            },
            {
                "id": 1042854,
                "title": "python-solution-with-explanation",
                "content": "We will keep on adding stuff to result variable which will be a list of lists. The idea is that we first sort the array to just know if the current number is not same as previous number. If it is not same then it means we need to append this number to all the lists already there in result. If it is same, then in order to avoid duplicate we can only append current number to the lists which were generated(and added to result) using previous number. So we need to track previous which will contain a lists of lists generated from previous number. \\n\\n```\\nclass Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        nums = sorted(nums)\\n\\t\\t# Will store all unique subsets\\n        result = [[]]\\n        i = 0\\n\\t\\t# will store subsets generated by previous number\\n        prev = []\\n        while i < len(nums):\\n            temp = []\\n\\t\\t\\t# if it is first number or if current number is not same as previous number then we    know that we need to append current number to all the subsets already generated. So we make prev = result \\n            if i == 0 or nums[i] != nums[i-1]:\\n                prev = result\\n            k = len(prev)\\n            for j in range(k):\\n                tup = prev[j]\\n                temp.append(tup+[nums[i]])\\n                result.append(tup+[nums[i]])\\n            prev = temp    \\n            i += 1    \\n        return result        \\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        nums = sorted(nums)\\n\\t\\t# Will store all unique subsets\\n        result = [[]]\\n        i = 0\\n\\t\\t# will store subsets generated by previous number\\n        prev = []\\n        while i < len(nums):\\n            temp = []\\n\\t\\t\\t# if it is first number or if current number is not same as previous number then we    know that we need to append current number to all the subsets already generated. So we make prev = result \\n            if i == 0 or nums[i] != nums[i-1]:\\n                prev = result\\n            k = len(prev)\\n            for j in range(k):\\n                tup = prev[j]\\n                temp.append(tup+[nums[i]])\\n                result.append(tup+[nums[i]])\\n            prev = temp    \\n            i += 1    \\n        return result        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 963168,
                "title": "python-3",
                "content": "\\n\\n```\\nclass Solution:\\n    def DFS(self, i, ans, res, nums):\\n        if i == len(nums):\\n            if ans not in res:\\n                res.append(ans)\\n            return res\\n        self.DFS(i+1, ans, res, nums)\\n        self.DFS(i+1, ans+[nums[i]], res, nums)\\n        \\n        \\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        nums.sort()\\n        self.DFS(0, [], res, nums)\\n\\t\\treturn res",
                "solutionTags": [],
                "code": "\\n\\n```\\nclass Solution:\\n    def DFS(self, i, ans, res, nums):\\n        if i == len(nums):\\n            if ans not in res:\\n                res.append(ans)\\n            return res\\n        self.DFS(i+1, ans, res, nums)\\n        self.DFS(i+1, ans+[nums[i]], res, nums)\\n        \\n        \\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        nums.sort()\\n        self.DFS(0, [], res, nums)\\n\\t\\treturn res",
                "codeTag": "Java"
            },
            {
                "id": 926489,
                "title": "very-simple-backtrack-python-solution",
                "content": "I think (not sure) space and time complexity would be O(N*2^N), any thoughts?\\n```\\nclass Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        \\n        def backtrack(nums,path):\\n            res.append(path)\\n            \\n            for i in range(len(nums)):\\n                if i>0 and nums[i]==nums[i-1]:\\n                    continue\\n                backtrack(nums[i+1:],path+[nums[i]])\\n        res=[]\\n        backtrack(sorted(nums),[])\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        \\n        def backtrack(nums,path):\\n            res.append(path)\\n            \\n            for i in range(len(nums)):\\n                if i>0 and nums[i]==nums[i-1]:\\n                    continue\\n                backtrack(nums[i+1:],path+[nums[i]])\\n        res=[]\\n        backtrack(sorted(nums),[])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 851791,
                "title": "c-an-easy-solutions-for-subsets-i-and-subsets-ii",
                "content": "```\\n``----->>>>>>>>>>>>>>>>>>subsets I```\\n```class Solution {\\npublic:vector<vector<int>>ans;\\n    \\n    void solve(vector<int> nums,vector<int>temp,int start){\\n        ans.push_back(temp);\\n        for(int i=start;i<nums.size();i++){\\n            temp.push_back(nums[i]);\\n            solve(nums,temp,i+1);\\n            temp.pop_back();\\n        }\\n    }\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<int>temp;\\n        solve(nums,temp,0);\\n        return ans;\\n    }\\n};\\n\\n---------->>>>>>>>>>>>>>Subsets II\\nclass Solution {\\npublic:\\n    vector<vector<int>>ans;vector<int>curr; //creating vector globally\\n    void solve(vector<int>A,int id ){\\n        ans.push_back(curr);\\n        if(id>A.size()){          //edge case\\n            ans.push_back(curr);\\n            return;\\n        }\\n        for(int i=id;i<A.size();i++){\\n            if(i>id&&A[i]==A[i-1])continue;// to check for duplicates\\n            curr.push_back(A[i]);\\n            solve(A,i+1); //backtrack\\n            curr.pop_back();\\n        }\\n    }\\n    vector<vector<int>> subsetsWithDup(vector<int>& A) {\\n        sort(A.begin(),A.end());\\n        solve(A,0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n``----->>>>>>>>>>>>>>>>>>subsets I```\n```class Solution {\\npublic:vector<vector<int>>ans;\\n    \\n    void solve(vector<int> nums,vector<int>temp,int start){\\n        ans.push_back(temp);\\n        for(int i=start;i<nums.size();i++){\\n            temp.push_back(nums[i]);\\n            solve(nums,temp,i+1);\\n            temp.pop_back();\\n        }\\n    }\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<int>temp;\\n        solve(nums,temp,0);\\n        return ans;\\n    }\\n};\\n\\n---------->>>>>>>>>>>>>>Subsets II\\nclass Solution {\\npublic:\\n    vector<vector<int>>ans;vector<int>curr; //creating vector globally\\n    void solve(vector<int>A,int id ){\\n        ans.push_back(curr);\\n        if(id>A.size()){          //edge case\\n            ans.push_back(curr);\\n            return;\\n        }\\n        for(int i=id;i<A.size();i++){\\n            if(i>id&&A[i]==A[i-1])continue;// to check for duplicates\\n            curr.push_back(A[i]);\\n            solve(A,i+1); //backtrack\\n            curr.pop_back();\\n        }\\n    }\\n    vector<vector<int>> subsetsWithDup(vector<int>& A) {\\n        sort(A.begin(),A.end());\\n        solve(A,0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 836880,
                "title": "c-backtracking-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>>& subset, int idx, vector<int>& nums, vector<int>& curr)\\n    {\\n        if(find(subset.begin(), subset.end(), curr) == subset.end())\\n            subset.push_back(curr);\\n        for(int i = idx; i < nums.size(); i++)\\n        {\\n            curr.push_back(nums[i]);\\n            dfs(subset, i+1, nums, curr);\\n            curr.pop_back();\\n        }\\n    }\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        vector<vector<int>> subset;\\n        vector<int> curr;\\n        dfs(subset, 0, nums, curr);\\n        return subset;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>>& subset, int idx, vector<int>& nums, vector<int>& curr)\\n    {\\n        if(find(subset.begin(), subset.end(), curr) == subset.end())\\n            subset.push_back(curr);\\n        for(int i = idx; i < nums.size(); i++)\\n        {\\n            curr.push_back(nums[i]);\\n            dfs(subset, i+1, nums, curr);\\n            curr.pop_back();\\n        }\\n    }\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        vector<vector<int>> subset;\\n        vector<int> curr;\\n        dfs(subset, 0, nums, curr);\\n        return subset;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 654330,
                "title": "javascript-concise-recursive-solution",
                "content": "```\\nvar subsetsWithDup = function(nums) {\\n    nums.sort()\\n    const powerset = [];\\n    \\n    function permute(arr, index) {\\n        powerset.push(arr)\\n        \\n        for(let i = index; i < nums.length; i++) {\\n            if(i !== index && nums[i] === nums[i-1]) continue;\\n            permute([...arr, nums[i]], i+1)\\n        }\\n    }\\n    permute([], 0);\\n    return powerset;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\nvar subsetsWithDup = function(nums) {\\n    nums.sort()\\n    const powerset = [];\\n    \\n    function permute(arr, index) {\\n        powerset.push(arr)\\n        \\n        for(let i = index; i < nums.length; i++) {\\n            if(i !== index && nums[i] === nums[i-1]) continue;\\n            permute([...arr, nums[i]], i+1)\\n        }\\n    }\\n    permute([], 0);\\n    return powerset;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 619897,
                "title": "simple-python-solution-using-set-and-bit-manipulation",
                "content": "```\\nclass Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        s = set()\\n        nums.sort()\\n        for i in range(2**len(nums)):\\n            ans = []\\n            for j in range(len(nums)):\\n                if i & (1<<j):\\n                    ans.append(nums[j])\\n            s.add(tuple(ans))\\n        return list(s)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        s = set()\\n        nums.sort()\\n        for i in range(2**len(nums)):\\n            ans = []\\n            for j in range(len(nums)):\\n                if i & (1<<j):\\n                    ans.append(nums[j])\\n            s.add(tuple(ans))\\n        return list(s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 576618,
                "title": "general-iterative-approach-with-queue-in-swift",
                "content": "**General Approach**\\nI prefer solving backtracking problems iteratively with a simple queue. The general approach I take:\\n1. Add element to queue\\n2. Loop over input\\n3. Loop over current queue size\\n4. Remove first element from queue\\n5. Use the removed element\\n\\n**Permutations**\\nhttps://leetcode.com/problems/permutations/\\n\\n```\\nInput: [1, 2, 3]\\n[] // Add Element\\n[1] // inserted 1 at 0th index\\n[2, 1] [1, 2] // inserted 2 in indexes 0-2 for prior queue element\\n[3, 2, 1][2, 3, 1][2,1,3][3,1,2][1,3,2][1,2,3] // inserted 3 in indexes 0-3 for prior queue elements\\n```\\n\\n```\\nfunc permute(_ nums: [Int]) -> [[Int]] {\\n\\tvar result = [[Int]]()\\n\\tif nums.isEmpty { return result }\\n\\tresult.append( [] )\\n\\tfor num in nums {\\n\\t\\tlet count = result.count\\n\\t\\tfor _ in 0 ..< count {\\n\\t\\t\\tlet prefix = result.removeFirst()\\n\\t\\t\\tfor j in 0 ... prefix.count {\\n\\t\\t\\t\\tvar tmp = prefix\\n\\t\\t\\t\\ttmp.insert(num, at: j)\\n\\t\\t\\t\\tresult.append(tmp)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn result\\n}\\n```\\n\\n**Permutations II**\\n```\\n// Input: [1,1,2,2]\\n//                                              []                                INSERT 1\\n//                                             [1]                                INSERT 1\\n//                                            [1,1]                               INSERT 2\\n//           [2,1,1]                         [1,2,1]               [1,1,2]        INSERT 2\\n// [2,2,1,1][2,1,2,1] [1,2,2,1]        [2,1,1,2],[1,2,1,2]        [1,1,2,2]\\n```\\n\\n```\\nfunc permuteUnique(_ nums: [Int]) -> [[Int]] {\\n\\tvar result = [[Int]]()\\n\\tif nums.isEmpty { return result }\\n\\tresult.append( [] )\\n\\tfor num in nums {\\n\\t\\tlet count = result.count\\n\\t\\tfor _ in 0 ..< count {\\n\\t\\t\\tlet prefix = result.removeFirst()\\n\\t\\t\\tfor j in 0 ... prefix.count {\\n\\t\\t\\t\\tvar tmp = prefix\\n\\t\\t\\t\\ttmp.insert(num, at: j)\\n\\t\\t\\t\\tresult.append(tmp)   \\n\\t\\t\\t\\tif j < prefix.count && prefix[j] == num { break }\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn result\\n}\\n```\\n\\n**Subset**\\nhttps://leetcode.com/problems/subsets/\\n```\\nInput: [1, 2, 3]\\n[] // Add Element\\n[1] // Add to []\\n[2] // Add to []\\n[3] // Add to []\\n[1, 3] // Add to [1]\\n[2, 3] // Add to [2]\\n[1, 2, 3] // Add to [1, 2]\\n```\\n\\n```\\nfunc subsets(_ nums: [Int]) -> [[Int]] {\\n\\tvar q = [[Int]]()\\n\\tq.append([])\\n\\tfor num in nums {\\n\\t\\tlet count = q.count\\n\\t\\tfor i in 0 ..< count {\\n\\t\\t\\tq.append(q[i] + [num])\\n\\t\\t}\\n\\t}\\n\\treturn q\\n}\\n```\\n\\n**Subsets II**\\nhttps://leetcode.com/problems/subsets-ii/\\n\\n```\\nInput: [1,2,2]\\n[] // Add Empty Case\\n[1] // Add 1 to []\\n[2] // Add 2 to []\\n[1, 2] // Add 2 to [1]\\n[2, 2] // Add 2 to [2]\\n[1, 2, 2] // Add 2 to [1,2]\\n```\\n\\n```\\nfunc subsetsWithDup(_ nums: [Int]) -> [[Int]] {\\n\\tvar q = [[Int]]()\\n\\tq.append([])\\n\\tvar count = q.count\\n\\tvar nums = nums.sorted() // Simplifies skipping duplicates\\n\\tfor (i, num) in nums.enumerated() {\\n\\t\\tlet start = (i > 0 && nums[i-1] == num) ? count : 0\\n\\t\\tcount = q.count\\n\\t\\tfor j in start ..< count {\\n\\t\\t\\tq.append( q[j] + [num] )\\n\\t\\t}\\n\\t}\\n\\treturn q\\n}\\n```\\n\\n**Letter Combinations of a Phone Number**\\nhttps://leetcode.com/problems/letter-combinations-of-a-phone-number/\\n\\n```\\nInput: \"23\"\\n[] // Empty\\na\\na b\\na b c\\nb c ad\\nb c ad ae \\nb c ad ae af \\n... and so on...\\n```\\n\\n```\\nfunc letterCombinations(_ digits: String) -> [String] {\\n    var phoneDict = [\"2\" : \"abc\", \"3\" : \"def\", \"4\" : \"ghi\", \"5\" : \"jkl\", \"6\" : \"mno\", \"7\" : \"pqrs\", \"8\" : \"tuv\", \"9\" : \"wxyz\"]\\n    if digits.count == 0 { return [] }\\n    var res = [\"\"]\\n    for (i, digit) in digits.enumerated() {\\n        let size = res.count\\n        for _ in 0 ..< size {\\n            let stringDigit = String(digit) // digit is Character so must convert to String\\n            let prefix = res.removeFirst()\\n            for letter in phoneDict[stringDigit]! {\\n                res.append(prefix + String(letter))\\n            }\\n        }\\n    }\\n    return res\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Backtracking",
                    "Queue"
                ],
                "code": "```\\nInput: [1, 2, 3]\\n[] // Add Element\\n[1] // inserted 1 at 0th index\\n[2, 1] [1, 2] // inserted 2 in indexes 0-2 for prior queue element\\n[3, 2, 1][2, 3, 1][2,1,3][3,1,2][1,3,2][1,2,3] // inserted 3 in indexes 0-3 for prior queue elements\\n```\n```\\nfunc permute(_ nums: [Int]) -> [[Int]] {\\n\\tvar result = [[Int]]()\\n\\tif nums.isEmpty { return result }\\n\\tresult.append( [] )\\n\\tfor num in nums {\\n\\t\\tlet count = result.count\\n\\t\\tfor _ in 0 ..< count {\\n\\t\\t\\tlet prefix = result.removeFirst()\\n\\t\\t\\tfor j in 0 ... prefix.count {\\n\\t\\t\\t\\tvar tmp = prefix\\n\\t\\t\\t\\ttmp.insert(num, at: j)\\n\\t\\t\\t\\tresult.append(tmp)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn result\\n}\\n```\n```\\n// Input: [1,1,2,2]\\n//                                              []                                INSERT 1\\n//                                             [1]                                INSERT 1\\n//                                            [1,1]                               INSERT 2\\n//           [2,1,1]                         [1,2,1]               [1,1,2]        INSERT 2\\n// [2,2,1,1][2,1,2,1] [1,2,2,1]        [2,1,1,2],[1,2,1,2]        [1,1,2,2]\\n```\n```\\nfunc permuteUnique(_ nums: [Int]) -> [[Int]] {\\n\\tvar result = [[Int]]()\\n\\tif nums.isEmpty { return result }\\n\\tresult.append( [] )\\n\\tfor num in nums {\\n\\t\\tlet count = result.count\\n\\t\\tfor _ in 0 ..< count {\\n\\t\\t\\tlet prefix = result.removeFirst()\\n\\t\\t\\tfor j in 0 ... prefix.count {\\n\\t\\t\\t\\tvar tmp = prefix\\n\\t\\t\\t\\ttmp.insert(num, at: j)\\n\\t\\t\\t\\tresult.append(tmp)   \\n\\t\\t\\t\\tif j < prefix.count && prefix[j] == num { break }\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn result\\n}\\n```\n```\\nInput: [1, 2, 3]\\n[] // Add Element\\n[1] // Add to []\\n[2] // Add to []\\n[3] // Add to []\\n[1, 3] // Add to [1]\\n[2, 3] // Add to [2]\\n[1, 2, 3] // Add to [1, 2]\\n```\n```\\nfunc subsets(_ nums: [Int]) -> [[Int]] {\\n\\tvar q = [[Int]]()\\n\\tq.append([])\\n\\tfor num in nums {\\n\\t\\tlet count = q.count\\n\\t\\tfor i in 0 ..< count {\\n\\t\\t\\tq.append(q[i] + [num])\\n\\t\\t}\\n\\t}\\n\\treturn q\\n}\\n```\n```\\nInput: [1,2,2]\\n[] // Add Empty Case\\n[1] // Add 1 to []\\n[2] // Add 2 to []\\n[1, 2] // Add 2 to [1]\\n[2, 2] // Add 2 to [2]\\n[1, 2, 2] // Add 2 to [1,2]\\n```\n```\\nfunc subsetsWithDup(_ nums: [Int]) -> [[Int]] {\\n\\tvar q = [[Int]]()\\n\\tq.append([])\\n\\tvar count = q.count\\n\\tvar nums = nums.sorted() // Simplifies skipping duplicates\\n\\tfor (i, num) in nums.enumerated() {\\n\\t\\tlet start = (i > 0 && nums[i-1] == num) ? count : 0\\n\\t\\tcount = q.count\\n\\t\\tfor j in start ..< count {\\n\\t\\t\\tq.append( q[j] + [num] )\\n\\t\\t}\\n\\t}\\n\\treturn q\\n}\\n```\n```\\nInput: \"23\"\\n[] // Empty\\na\\na b\\na b c\\nb c ad\\nb c ad ae \\nb c ad ae af \\n... and so on...\\n```\n```\\nfunc letterCombinations(_ digits: String) -> [String] {\\n    var phoneDict = [\"2\" : \"abc\", \"3\" : \"def\", \"4\" : \"ghi\", \"5\" : \"jkl\", \"6\" : \"mno\", \"7\" : \"pqrs\", \"8\" : \"tuv\", \"9\" : \"wxyz\"]\\n    if digits.count == 0 { return [] }\\n    var res = [\"\"]\\n    for (i, digit) in digits.enumerated() {\\n        let size = res.count\\n        for _ in 0 ..< size {\\n            let stringDigit = String(digit) // digit is Character so must convert to String\\n            let prefix = res.removeFirst()\\n            for letter in phoneDict[stringDigit]! {\\n                res.append(prefix + String(letter))\\n            }\\n        }\\n    }\\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 557116,
                "title": "scala-beautifully-elegant-fold",
                "content": "```\\ndef subsetsWithDup(nums: Array[Int]): List[List[Int]] = {\\n\\tnums\\n\\t\\t.sorted\\n\\t\\t.foldLeft(Set(List.empty[Int])){ case(prev, n) =>\\n\\t\\t\\tprev ++ prev.map(_ :+ n) + List(n)\\n\\t\\t}.toList\\n}\\n```",
                "solutionTags": [],
                "code": "```\\ndef subsetsWithDup(nums: Array[Int]): List[List[Int]] = {\\n\\tnums\\n\\t\\t.sorted\\n\\t\\t.foldLeft(Set(List.empty[Int])){ case(prev, n) =>\\n\\t\\t\\tprev ++ prev.map(_ :+ n) + List(n)\\n\\t\\t}.toList\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 528323,
                "title": "issac3-general-approach-to-backtracking-questions-in-cpp",
                "content": "Thanks ```Issac3``` for sharing. Here is same approach in C++. \\n\\nPermutation:\\nGiven a collection of distinct integers, return all possible permutations.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> result; \\n        vector<int> temp;\\n        backtrack(nums, temp, result);\\n        return result;\\n    }\\n    void backtrack(vector<int>& nums, vector<int>& temp, vector<vector<int>>& result){\\n        \\n        if(temp.size() == nums.size()){\\n            result.emplace_back(temp);\\n        }else{\\n            \\n            for(int i=0; i<nums.size(); i++){\\n                if(find(temp.begin(), temp.end(), nums[i]) != temp.end()) continue; \\n                \\n                temp.push_back(nums[i]);\\n                backtrack(nums, temp, result);\\n                temp.pop_back();\\n            }\\n        }   \\n    } \\n};\\n```\\n\\nPermutation-II \\n\\n47. Permutations II\\nGiven a collection of numbers that might contain duplicates, return all possible unique permutations.\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {   \\n        vector<vector<int>> result; \\n        vector<int> temp;\\n        vector<bool> used(nums.size(), false);\\n        sort(nums.begin(), nums.end());\\n        backtrack(nums, temp, result, used);\\n        return result;        \\n    }\\n    \\n    void backtrack(vector<int>& nums, vector<int>& temp, vector<vector<int>>& result, vector<bool>& used){\\n        \\n        if(temp.size() == nums.size()){\\n            result.emplace_back(temp);\\n        }else{\\n            \\n            for(int i=0; i<nums.size(); i++){\\n                if(used[i] || i>0 && nums[i] == nums[i-1] && !used[i-1]) continue; \\n                used[i] = true;\\n                temp.push_back(nums[i]);\\n                backtrack(nums, temp, result, used);\\n                used[i] = false;\\n                temp.pop_back();\\n            }            \\n        }        \\n    }    \\n};\\n```\\n\\n78. Subsets\\nGiven a set of distinct integers, nums, return all possible subsets (the power set).\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> result;\\n        vector<int> temp;\\n        \\n        backtrack(nums, temp, result, 0);\\n        return result;\\n    }\\n    \\n    void backtrack(vector<int>& nums, vector<int>& temp, vector<vector<int>>& result, int start){\\n        \\n        result.emplace_back(temp);\\n        \\n        for(int i=start; i<nums.size(); i++){\\n            temp.emplace_back(nums[i]);\\n            backtrack(nums, temp, result, i+1);\\n            temp.pop_back();\\n        }                \\n    }\\n    \\n};\\n```\\n\\n90. Subsets II\\nGiven a collection of integers that might contain duplicates, nums, return all possible subsets (the power set).\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        vector<vector<int>> result;\\n        vector<int> temp; \\n        \\n        sort(nums.begin(), nums.end());\\n        backtrack(nums, temp, result, 0);\\n        return result;\\n    }\\n    \\n    void backtrack(vector<int>& nums, vector<int>& temp, vector<vector<int>>& result, int start){\\n        \\n        result.emplace_back(temp);\\n        \\n        for(int i=start; i<nums.size(); i++){\\n            if(i>start && nums[i]== nums[i-1]) continue;\\n            temp.emplace_back(nums[i]);\\n            backtrack(nums, temp, result, i+1);\\n            temp.pop_back();\\n        }\\n        \\n    }\\n    \\n};\\n\\n```\\n39. Combination Sum\\nGiven a set of candidate numbers (candidates) (without duplicates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target.\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum(vector<int>& nums, int target) {\\n        \\n        vector<vector<int>> result; \\n        vector<int> temp;\\n        backtrack(nums, temp, result, 0, target);\\n        return result;\\n    }\\n    \\n    void backtrack(vector<int>& nums, vector<int>& temp, vector<vector<int>>& result, int start, int remain){\\n        \\n        if(remain<0){ \\n            return;\\n        }else if(remain == 0){\\n            result.emplace_back(temp);\\n        }else{\\n            \\n            for(int i=start; i<nums.size(); i++){\\n                temp.emplace_back(nums[i]);\\n                backtrack(nums, temp, result, i, remain - nums[i]); // not i+1 because we CAN reuse same elements\\n                temp.pop_back();\\n            }\\n            \\n        }\\n    }\\n    \\n};\\n```\\n\\n40. Combination Sum II\\nGiven a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& nums, int target) {\\n        vector<vector<int>> result;\\n        vector<int> temp; \\n        \\n        sort(nums.begin(), nums.end());\\n        \\n        backtrack(nums, temp, result, 0, target);\\n        return result;\\n    }\\n    \\n    void backtrack(vector<int>& nums, vector<int> temp, vector<vector<int>>& result, int start, int remain){\\n        \\n        if(remain <0){ \\n            return;\\n        }else if(remain == 0){\\n            result.emplace_back(temp);\\n        }else{\\n            \\n            for(int i=start; i<nums.size(); i++){\\n                if(i>start && nums[i] == nums[i-1]) continue; \\n                \\n                temp.emplace_back(nums[i]);\\n                backtrack(nums, temp, result, i+1, remain - nums[i]); // here i+1 because each numer can be choosen only \\'once\\'\\n                \\n                temp.pop_back();                \\n            }           \\n        }        \\n    }\\n    \\n};\\n```\\n131. Palindrome Partitioning\\nGiven a string s, partition s such that every substring of the partition is a palindrome. Return all possible palindrome partitioning of s.\\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>> result;\\n        vector<string> temp;\\n        backtrack(s, temp, result, 0);\\n        return result;        \\n    }\\n    \\n    void backtrack(string& s, vector<string>& temp, vector<vector<string>>& result, int start){\\n        \\n        if(start == s.size()){\\n            result.emplace_back(temp);\\n        }else{\\n            \\n            for(int i=start; i<s.size(); i++){\\n                if(isPalindrome(s, start, i)){\\n                    temp.emplace_back(s.substr(start, i-start+1));\\n                    backtrack(s, temp, result, i+1);\\n                    temp.pop_back();\\n                }\\n            }            \\n        }        \\n    }\\n    \\n    bool isPalindrome(string s, int low, int high){\\n        while(low<high){\\n            if(s[low++] != s[high--]) return false;\\n        }\\n        return true;\\n    }\\n    \\n};\\n",
                "solutionTags": [],
                "code": "```Issac3```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> result; \\n        vector<int> temp;\\n        backtrack(nums, temp, result);\\n        return result;\\n    }\\n    void backtrack(vector<int>& nums, vector<int>& temp, vector<vector<int>>& result){\\n        \\n        if(temp.size() == nums.size()){\\n            result.emplace_back(temp);\\n        }else{\\n            \\n            for(int i=0; i<nums.size(); i++){\\n                if(find(temp.begin(), temp.end(), nums[i]) != temp.end()) continue; \\n                \\n                temp.push_back(nums[i]);\\n                backtrack(nums, temp, result);\\n                temp.pop_back();\\n            }\\n        }   \\n    } \\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {   \\n        vector<vector<int>> result; \\n        vector<int> temp;\\n        vector<bool> used(nums.size(), false);\\n        sort(nums.begin(), nums.end());\\n        backtrack(nums, temp, result, used);\\n        return result;        \\n    }\\n    \\n    void backtrack(vector<int>& nums, vector<int>& temp, vector<vector<int>>& result, vector<bool>& used){\\n        \\n        if(temp.size() == nums.size()){\\n            result.emplace_back(temp);\\n        }else{\\n            \\n            for(int i=0; i<nums.size(); i++){\\n                if(used[i] || i>0 && nums[i] == nums[i-1] && !used[i-1]) continue; \\n                used[i] = true;\\n                temp.push_back(nums[i]);\\n                backtrack(nums, temp, result, used);\\n                used[i] = false;\\n                temp.pop_back();\\n            }            \\n        }        \\n    }    \\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> result;\\n        vector<int> temp;\\n        \\n        backtrack(nums, temp, result, 0);\\n        return result;\\n    }\\n    \\n    void backtrack(vector<int>& nums, vector<int>& temp, vector<vector<int>>& result, int start){\\n        \\n        result.emplace_back(temp);\\n        \\n        for(int i=start; i<nums.size(); i++){\\n            temp.emplace_back(nums[i]);\\n            backtrack(nums, temp, result, i+1);\\n            temp.pop_back();\\n        }                \\n    }\\n    \\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        vector<vector<int>> result;\\n        vector<int> temp; \\n        \\n        sort(nums.begin(), nums.end());\\n        backtrack(nums, temp, result, 0);\\n        return result;\\n    }\\n    \\n    void backtrack(vector<int>& nums, vector<int>& temp, vector<vector<int>>& result, int start){\\n        \\n        result.emplace_back(temp);\\n        \\n        for(int i=start; i<nums.size(); i++){\\n            if(i>start && nums[i]== nums[i-1]) continue;\\n            temp.emplace_back(nums[i]);\\n            backtrack(nums, temp, result, i+1);\\n            temp.pop_back();\\n        }\\n        \\n    }\\n    \\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum(vector<int>& nums, int target) {\\n        \\n        vector<vector<int>> result; \\n        vector<int> temp;\\n        backtrack(nums, temp, result, 0, target);\\n        return result;\\n    }\\n    \\n    void backtrack(vector<int>& nums, vector<int>& temp, vector<vector<int>>& result, int start, int remain){\\n        \\n        if(remain<0){ \\n            return;\\n        }else if(remain == 0){\\n            result.emplace_back(temp);\\n        }else{\\n            \\n            for(int i=start; i<nums.size(); i++){\\n                temp.emplace_back(nums[i]);\\n                backtrack(nums, temp, result, i, remain - nums[i]); // not i+1 because we CAN reuse same elements\\n                temp.pop_back();\\n            }\\n            \\n        }\\n    }\\n    \\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& nums, int target) {\\n        vector<vector<int>> result;\\n        vector<int> temp; \\n        \\n        sort(nums.begin(), nums.end());\\n        \\n        backtrack(nums, temp, result, 0, target);\\n        return result;\\n    }\\n    \\n    void backtrack(vector<int>& nums, vector<int> temp, vector<vector<int>>& result, int start, int remain){\\n        \\n        if(remain <0){ \\n            return;\\n        }else if(remain == 0){\\n            result.emplace_back(temp);\\n        }else{\\n            \\n            for(int i=start; i<nums.size(); i++){\\n                if(i>start && nums[i] == nums[i-1]) continue; \\n                \\n                temp.emplace_back(nums[i]);\\n                backtrack(nums, temp, result, i+1, remain - nums[i]); // here i+1 because each numer can be choosen only \\'once\\'\\n                \\n                temp.pop_back();                \\n            }           \\n        }        \\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1572369,
                "content": [
                    {
                        "username": "pengel1",
                        "content": "Where does the output should be in sorted order?  This may need further explination or refinement."
                    },
                    {
                        "username": "TerpsX",
                        "content": "Input:\\n[4,4,4,1,4]\\nOutput:\\n[[],[4],[1],[1,4],[4,4],[4,1],[4,1,4],[4,4,4],[4,4,1],[4,4,1,4],[4,4,4,4],[4,4,4,1],[4,4,4,1,4]]\\nExpected:\\n[[],[1],[1,4],[1,4,4],[1,4,4,4],[1,4,4,4,4],[4],[4,4],[4,4,4],[4,4,4,4]]\\n\\nHow come [1,4,4,4] a subset for [4,4,4,1,4]??"
                    },
                    {
                        "username": "2uringTested",
                        "content": "its a subset not a subsequence so [4,4,1,4] is same as [4,4,4,1], the order does not matter and so it should only be counted once."
                    },
                    {
                        "username": "goldenwind",
                        "content": "The subset of a set A is a set that contains some elements of A or all elements of A. If it is a set, the order does not matter. [1,4,4,4] is the same as [4,1,4,4] as a set."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "proper explanation of question is not given, nums needs to be sorted."
                    },
                    {
                        "username": "rakeshks7",
                        "content": "I think you\\'re confusing subset with sub-sequence"
                    },
                    {
                        "username": "lampuiho",
                        "content": "you have [4,4,1,4], and [4,4,4,1] in your output. I fixed my code when I sorted the numbers first so that all the duplicates are grouped together. This is because my recursion relies on a position tracking parameter for skipping the duplicates in subsequent loops."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "There, the catch is to sort the nums array first.\\nThank you."
                    },
                    {
                        "username": "ankitk742",
                        "content": "Thanks bro, helped me allot "
                    },
                    {
                        "username": "athravmehta06",
                        "content": "saved my day .. lol thanks"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "fuck yAAR!THANK HYOU IT WORKED\\n"
                    },
                    {
                        "username": "srapol",
                        "content": "bro how did you come up with it ?? whats the logic??\\nP.S: it worked"
                    },
                    {
                        "username": "mochiball",
                        "content": "Facts. I was running into errors until I sorted. The weird thing is Sets don\\'t seem to account for the unsorted  "
                    },
                    {
                        "username": "Ninjabdul",
                        "content": "thanks bro, stuff like this is why i read discussion post"
                    },
                    {
                        "username": "Oleas",
                        "content": "This problem is NOT asking for the power set of a set. It is asking for all, sorted, unique combinations of the terms in the input. This caused me a great deal of grief. This problem\\'s description should be changed to remove the power set  wording."
                    },
                    {
                        "username": "charonme",
                        "content": "This is clearly wrong. When the array contains duplicates, the duplicate elements are either the same element or they are different elements. If they are the same, then [1, 2, 2] and [1, 2] are the same subset of an array given as [1, 2, 2]. But the problem solution expects both [1, 2] and [1, 2, 2], so clearly the first 2 and the second 2 must be different elements, in which case subsets [1, 2] (with the first 2) and [1, 2] (with the second 2) should be accepted too, but they are not."
                    },
                    {
                        "username": "piyushshah12327",
                        "content": "I went through some of the solutions to understand but why the need to sort?"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "You need to sort the array so, we can compare that previous element is same as current element or not. If you don\\'t sort the array, then it can\\'t find that element is same or different. ex,\\nint[] arr = {1,2,1};\\nhere you can see element at 0 index is equal to element at 2nd index.\\nIf you sort the array.  then it became \\nint[] arr = {1,1,2};\\nnow you can see that element at 0 index and 1 index are same and you can also easily write the code don\\'t run code from start. "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets-ii/solutions/2986411/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "coldz",
                        "content": "Find a way to adapt subset I solution to subsets II problem."
                    },
                    {
                        "username": "rahul_jain89",
                        "content": "I think description is not clear.\\n\\nI guess they want \"each subset should be sorted and unique\".\\n\\nThat\\'s why first we need to sort to input array, so that it will generate sorted subsets,\\nAnd then we can use a set to store the subsets, it will ensure that only unique subsets will be stored to result."
                    },
                    {
                        "username": "OmarNaru",
                        "content": "Idk why we need sorting here :\\nif the given input array is : [3,2,1]\\nthe output if we didn\\'t use sort will be :\\n1\\n2\\n2 1\\n3\\n3 1\\n3 2\\n3 2 1\\n_____________________\\nbut if we used sort it will be :\\n1\\n1 2\\n1 2 3\\n1 3\\n2\\n2 3\\n3\\n\\nit\\'s literally different output, how this even works !?\\nI guess I understood something wrong in the description\\ncan anyone explain ?"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "why sorting of input array is need here?"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "[@yadav_sahil](/yadav_sahil)  that\\'s not correct. It is because there are duplicate subsets [1,4] , [4,1] ,[4,4,1],[4,1,4] and [4,4,4,1],[4,4,1,4]. In the expected the total count of subarray is 10 while in output it is 13."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "Input:\\n[4,4,4,1,4]\\nOutput:\\n[[],[4],[1],[1,4],[4,4],[4,1],[4,1,4],[4,4,4],[4,4,1],[4,4,1,4],[4,4,4,4],[4,4,4,1],[4,4,4,1,4]]\\nExpected:\\n[[],[1],[1,4],[1,4,4],[1,4,4,4],[1,4,4,4,4],[4],[4,4],[4,4,4],[4,4,4,4]]\\nlook in this testcase expected output there is subset 1,4,4,4 which is not possible if 4,4,4,1,4 is not sorted as there is only one 4 after 1.\\n"
                    }
                ]
            },
            {
                "id": 1571199,
                "content": [
                    {
                        "username": "pengel1",
                        "content": "Where does the output should be in sorted order?  This may need further explination or refinement."
                    },
                    {
                        "username": "TerpsX",
                        "content": "Input:\\n[4,4,4,1,4]\\nOutput:\\n[[],[4],[1],[1,4],[4,4],[4,1],[4,1,4],[4,4,4],[4,4,1],[4,4,1,4],[4,4,4,4],[4,4,4,1],[4,4,4,1,4]]\\nExpected:\\n[[],[1],[1,4],[1,4,4],[1,4,4,4],[1,4,4,4,4],[4],[4,4],[4,4,4],[4,4,4,4]]\\n\\nHow come [1,4,4,4] a subset for [4,4,4,1,4]??"
                    },
                    {
                        "username": "2uringTested",
                        "content": "its a subset not a subsequence so [4,4,1,4] is same as [4,4,4,1], the order does not matter and so it should only be counted once."
                    },
                    {
                        "username": "goldenwind",
                        "content": "The subset of a set A is a set that contains some elements of A or all elements of A. If it is a set, the order does not matter. [1,4,4,4] is the same as [4,1,4,4] as a set."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "proper explanation of question is not given, nums needs to be sorted."
                    },
                    {
                        "username": "rakeshks7",
                        "content": "I think you\\'re confusing subset with sub-sequence"
                    },
                    {
                        "username": "lampuiho",
                        "content": "you have [4,4,1,4], and [4,4,4,1] in your output. I fixed my code when I sorted the numbers first so that all the duplicates are grouped together. This is because my recursion relies on a position tracking parameter for skipping the duplicates in subsequent loops."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "There, the catch is to sort the nums array first.\\nThank you."
                    },
                    {
                        "username": "ankitk742",
                        "content": "Thanks bro, helped me allot "
                    },
                    {
                        "username": "athravmehta06",
                        "content": "saved my day .. lol thanks"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "fuck yAAR!THANK HYOU IT WORKED\\n"
                    },
                    {
                        "username": "srapol",
                        "content": "bro how did you come up with it ?? whats the logic??\\nP.S: it worked"
                    },
                    {
                        "username": "mochiball",
                        "content": "Facts. I was running into errors until I sorted. The weird thing is Sets don\\'t seem to account for the unsorted  "
                    },
                    {
                        "username": "Ninjabdul",
                        "content": "thanks bro, stuff like this is why i read discussion post"
                    },
                    {
                        "username": "Oleas",
                        "content": "This problem is NOT asking for the power set of a set. It is asking for all, sorted, unique combinations of the terms in the input. This caused me a great deal of grief. This problem\\'s description should be changed to remove the power set  wording."
                    },
                    {
                        "username": "charonme",
                        "content": "This is clearly wrong. When the array contains duplicates, the duplicate elements are either the same element or they are different elements. If they are the same, then [1, 2, 2] and [1, 2] are the same subset of an array given as [1, 2, 2]. But the problem solution expects both [1, 2] and [1, 2, 2], so clearly the first 2 and the second 2 must be different elements, in which case subsets [1, 2] (with the first 2) and [1, 2] (with the second 2) should be accepted too, but they are not."
                    },
                    {
                        "username": "piyushshah12327",
                        "content": "I went through some of the solutions to understand but why the need to sort?"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "You need to sort the array so, we can compare that previous element is same as current element or not. If you don\\'t sort the array, then it can\\'t find that element is same or different. ex,\\nint[] arr = {1,2,1};\\nhere you can see element at 0 index is equal to element at 2nd index.\\nIf you sort the array.  then it became \\nint[] arr = {1,1,2};\\nnow you can see that element at 0 index and 1 index are same and you can also easily write the code don\\'t run code from start. "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets-ii/solutions/2986411/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "coldz",
                        "content": "Find a way to adapt subset I solution to subsets II problem."
                    },
                    {
                        "username": "rahul_jain89",
                        "content": "I think description is not clear.\\n\\nI guess they want \"each subset should be sorted and unique\".\\n\\nThat\\'s why first we need to sort to input array, so that it will generate sorted subsets,\\nAnd then we can use a set to store the subsets, it will ensure that only unique subsets will be stored to result."
                    },
                    {
                        "username": "OmarNaru",
                        "content": "Idk why we need sorting here :\\nif the given input array is : [3,2,1]\\nthe output if we didn\\'t use sort will be :\\n1\\n2\\n2 1\\n3\\n3 1\\n3 2\\n3 2 1\\n_____________________\\nbut if we used sort it will be :\\n1\\n1 2\\n1 2 3\\n1 3\\n2\\n2 3\\n3\\n\\nit\\'s literally different output, how this even works !?\\nI guess I understood something wrong in the description\\ncan anyone explain ?"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "why sorting of input array is need here?"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "[@yadav_sahil](/yadav_sahil)  that\\'s not correct. It is because there are duplicate subsets [1,4] , [4,1] ,[4,4,1],[4,1,4] and [4,4,4,1],[4,4,1,4]. In the expected the total count of subarray is 10 while in output it is 13."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "Input:\\n[4,4,4,1,4]\\nOutput:\\n[[],[4],[1],[1,4],[4,4],[4,1],[4,1,4],[4,4,4],[4,4,1],[4,4,1,4],[4,4,4,4],[4,4,4,1],[4,4,4,1,4]]\\nExpected:\\n[[],[1],[1,4],[1,4,4],[1,4,4,4],[1,4,4,4,4],[4],[4,4],[4,4,4],[4,4,4,4]]\\nlook in this testcase expected output there is subset 1,4,4,4 which is not possible if 4,4,4,1,4 is not sorted as there is only one 4 after 1.\\n"
                    }
                ]
            },
            {
                "id": 1748905,
                "content": [
                    {
                        "username": "pengel1",
                        "content": "Where does the output should be in sorted order?  This may need further explination or refinement."
                    },
                    {
                        "username": "TerpsX",
                        "content": "Input:\\n[4,4,4,1,4]\\nOutput:\\n[[],[4],[1],[1,4],[4,4],[4,1],[4,1,4],[4,4,4],[4,4,1],[4,4,1,4],[4,4,4,4],[4,4,4,1],[4,4,4,1,4]]\\nExpected:\\n[[],[1],[1,4],[1,4,4],[1,4,4,4],[1,4,4,4,4],[4],[4,4],[4,4,4],[4,4,4,4]]\\n\\nHow come [1,4,4,4] a subset for [4,4,4,1,4]??"
                    },
                    {
                        "username": "2uringTested",
                        "content": "its a subset not a subsequence so [4,4,1,4] is same as [4,4,4,1], the order does not matter and so it should only be counted once."
                    },
                    {
                        "username": "goldenwind",
                        "content": "The subset of a set A is a set that contains some elements of A or all elements of A. If it is a set, the order does not matter. [1,4,4,4] is the same as [4,1,4,4] as a set."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "proper explanation of question is not given, nums needs to be sorted."
                    },
                    {
                        "username": "rakeshks7",
                        "content": "I think you\\'re confusing subset with sub-sequence"
                    },
                    {
                        "username": "lampuiho",
                        "content": "you have [4,4,1,4], and [4,4,4,1] in your output. I fixed my code when I sorted the numbers first so that all the duplicates are grouped together. This is because my recursion relies on a position tracking parameter for skipping the duplicates in subsequent loops."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "There, the catch is to sort the nums array first.\\nThank you."
                    },
                    {
                        "username": "ankitk742",
                        "content": "Thanks bro, helped me allot "
                    },
                    {
                        "username": "athravmehta06",
                        "content": "saved my day .. lol thanks"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "fuck yAAR!THANK HYOU IT WORKED\\n"
                    },
                    {
                        "username": "srapol",
                        "content": "bro how did you come up with it ?? whats the logic??\\nP.S: it worked"
                    },
                    {
                        "username": "mochiball",
                        "content": "Facts. I was running into errors until I sorted. The weird thing is Sets don\\'t seem to account for the unsorted  "
                    },
                    {
                        "username": "Ninjabdul",
                        "content": "thanks bro, stuff like this is why i read discussion post"
                    },
                    {
                        "username": "Oleas",
                        "content": "This problem is NOT asking for the power set of a set. It is asking for all, sorted, unique combinations of the terms in the input. This caused me a great deal of grief. This problem\\'s description should be changed to remove the power set  wording."
                    },
                    {
                        "username": "charonme",
                        "content": "This is clearly wrong. When the array contains duplicates, the duplicate elements are either the same element or they are different elements. If they are the same, then [1, 2, 2] and [1, 2] are the same subset of an array given as [1, 2, 2]. But the problem solution expects both [1, 2] and [1, 2, 2], so clearly the first 2 and the second 2 must be different elements, in which case subsets [1, 2] (with the first 2) and [1, 2] (with the second 2) should be accepted too, but they are not."
                    },
                    {
                        "username": "piyushshah12327",
                        "content": "I went through some of the solutions to understand but why the need to sort?"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "You need to sort the array so, we can compare that previous element is same as current element or not. If you don\\'t sort the array, then it can\\'t find that element is same or different. ex,\\nint[] arr = {1,2,1};\\nhere you can see element at 0 index is equal to element at 2nd index.\\nIf you sort the array.  then it became \\nint[] arr = {1,1,2};\\nnow you can see that element at 0 index and 1 index are same and you can also easily write the code don\\'t run code from start. "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets-ii/solutions/2986411/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "coldz",
                        "content": "Find a way to adapt subset I solution to subsets II problem."
                    },
                    {
                        "username": "rahul_jain89",
                        "content": "I think description is not clear.\\n\\nI guess they want \"each subset should be sorted and unique\".\\n\\nThat\\'s why first we need to sort to input array, so that it will generate sorted subsets,\\nAnd then we can use a set to store the subsets, it will ensure that only unique subsets will be stored to result."
                    },
                    {
                        "username": "OmarNaru",
                        "content": "Idk why we need sorting here :\\nif the given input array is : [3,2,1]\\nthe output if we didn\\'t use sort will be :\\n1\\n2\\n2 1\\n3\\n3 1\\n3 2\\n3 2 1\\n_____________________\\nbut if we used sort it will be :\\n1\\n1 2\\n1 2 3\\n1 3\\n2\\n2 3\\n3\\n\\nit\\'s literally different output, how this even works !?\\nI guess I understood something wrong in the description\\ncan anyone explain ?"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "why sorting of input array is need here?"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "[@yadav_sahil](/yadav_sahil)  that\\'s not correct. It is because there are duplicate subsets [1,4] , [4,1] ,[4,4,1],[4,1,4] and [4,4,4,1],[4,4,1,4]. In the expected the total count of subarray is 10 while in output it is 13."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "Input:\\n[4,4,4,1,4]\\nOutput:\\n[[],[4],[1],[1,4],[4,4],[4,1],[4,1,4],[4,4,4],[4,4,1],[4,4,1,4],[4,4,4,4],[4,4,4,1],[4,4,4,1,4]]\\nExpected:\\n[[],[1],[1,4],[1,4,4],[1,4,4,4],[1,4,4,4,4],[4],[4,4],[4,4,4],[4,4,4,4]]\\nlook in this testcase expected output there is subset 1,4,4,4 which is not possible if 4,4,4,1,4 is not sorted as there is only one 4 after 1.\\n"
                    }
                ]
            },
            {
                "id": 1781360,
                "content": [
                    {
                        "username": "pengel1",
                        "content": "Where does the output should be in sorted order?  This may need further explination or refinement."
                    },
                    {
                        "username": "TerpsX",
                        "content": "Input:\\n[4,4,4,1,4]\\nOutput:\\n[[],[4],[1],[1,4],[4,4],[4,1],[4,1,4],[4,4,4],[4,4,1],[4,4,1,4],[4,4,4,4],[4,4,4,1],[4,4,4,1,4]]\\nExpected:\\n[[],[1],[1,4],[1,4,4],[1,4,4,4],[1,4,4,4,4],[4],[4,4],[4,4,4],[4,4,4,4]]\\n\\nHow come [1,4,4,4] a subset for [4,4,4,1,4]??"
                    },
                    {
                        "username": "2uringTested",
                        "content": "its a subset not a subsequence so [4,4,1,4] is same as [4,4,4,1], the order does not matter and so it should only be counted once."
                    },
                    {
                        "username": "goldenwind",
                        "content": "The subset of a set A is a set that contains some elements of A or all elements of A. If it is a set, the order does not matter. [1,4,4,4] is the same as [4,1,4,4] as a set."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "proper explanation of question is not given, nums needs to be sorted."
                    },
                    {
                        "username": "rakeshks7",
                        "content": "I think you\\'re confusing subset with sub-sequence"
                    },
                    {
                        "username": "lampuiho",
                        "content": "you have [4,4,1,4], and [4,4,4,1] in your output. I fixed my code when I sorted the numbers first so that all the duplicates are grouped together. This is because my recursion relies on a position tracking parameter for skipping the duplicates in subsequent loops."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "There, the catch is to sort the nums array first.\\nThank you."
                    },
                    {
                        "username": "ankitk742",
                        "content": "Thanks bro, helped me allot "
                    },
                    {
                        "username": "athravmehta06",
                        "content": "saved my day .. lol thanks"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "fuck yAAR!THANK HYOU IT WORKED\\n"
                    },
                    {
                        "username": "srapol",
                        "content": "bro how did you come up with it ?? whats the logic??\\nP.S: it worked"
                    },
                    {
                        "username": "mochiball",
                        "content": "Facts. I was running into errors until I sorted. The weird thing is Sets don\\'t seem to account for the unsorted  "
                    },
                    {
                        "username": "Ninjabdul",
                        "content": "thanks bro, stuff like this is why i read discussion post"
                    },
                    {
                        "username": "Oleas",
                        "content": "This problem is NOT asking for the power set of a set. It is asking for all, sorted, unique combinations of the terms in the input. This caused me a great deal of grief. This problem\\'s description should be changed to remove the power set  wording."
                    },
                    {
                        "username": "charonme",
                        "content": "This is clearly wrong. When the array contains duplicates, the duplicate elements are either the same element or they are different elements. If they are the same, then [1, 2, 2] and [1, 2] are the same subset of an array given as [1, 2, 2]. But the problem solution expects both [1, 2] and [1, 2, 2], so clearly the first 2 and the second 2 must be different elements, in which case subsets [1, 2] (with the first 2) and [1, 2] (with the second 2) should be accepted too, but they are not."
                    },
                    {
                        "username": "piyushshah12327",
                        "content": "I went through some of the solutions to understand but why the need to sort?"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "You need to sort the array so, we can compare that previous element is same as current element or not. If you don\\'t sort the array, then it can\\'t find that element is same or different. ex,\\nint[] arr = {1,2,1};\\nhere you can see element at 0 index is equal to element at 2nd index.\\nIf you sort the array.  then it became \\nint[] arr = {1,1,2};\\nnow you can see that element at 0 index and 1 index are same and you can also easily write the code don\\'t run code from start. "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets-ii/solutions/2986411/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "coldz",
                        "content": "Find a way to adapt subset I solution to subsets II problem."
                    },
                    {
                        "username": "rahul_jain89",
                        "content": "I think description is not clear.\\n\\nI guess they want \"each subset should be sorted and unique\".\\n\\nThat\\'s why first we need to sort to input array, so that it will generate sorted subsets,\\nAnd then we can use a set to store the subsets, it will ensure that only unique subsets will be stored to result."
                    },
                    {
                        "username": "OmarNaru",
                        "content": "Idk why we need sorting here :\\nif the given input array is : [3,2,1]\\nthe output if we didn\\'t use sort will be :\\n1\\n2\\n2 1\\n3\\n3 1\\n3 2\\n3 2 1\\n_____________________\\nbut if we used sort it will be :\\n1\\n1 2\\n1 2 3\\n1 3\\n2\\n2 3\\n3\\n\\nit\\'s literally different output, how this even works !?\\nI guess I understood something wrong in the description\\ncan anyone explain ?"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "why sorting of input array is need here?"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "[@yadav_sahil](/yadav_sahil)  that\\'s not correct. It is because there are duplicate subsets [1,4] , [4,1] ,[4,4,1],[4,1,4] and [4,4,4,1],[4,4,1,4]. In the expected the total count of subarray is 10 while in output it is 13."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "Input:\\n[4,4,4,1,4]\\nOutput:\\n[[],[4],[1],[1,4],[4,4],[4,1],[4,1,4],[4,4,4],[4,4,1],[4,4,1,4],[4,4,4,4],[4,4,4,1],[4,4,4,1,4]]\\nExpected:\\n[[],[1],[1,4],[1,4,4],[1,4,4,4],[1,4,4,4,4],[4],[4,4],[4,4,4],[4,4,4,4]]\\nlook in this testcase expected output there is subset 1,4,4,4 which is not possible if 4,4,4,1,4 is not sorted as there is only one 4 after 1.\\n"
                    }
                ]
            },
            {
                "id": 1769485,
                "content": [
                    {
                        "username": "pengel1",
                        "content": "Where does the output should be in sorted order?  This may need further explination or refinement."
                    },
                    {
                        "username": "TerpsX",
                        "content": "Input:\\n[4,4,4,1,4]\\nOutput:\\n[[],[4],[1],[1,4],[4,4],[4,1],[4,1,4],[4,4,4],[4,4,1],[4,4,1,4],[4,4,4,4],[4,4,4,1],[4,4,4,1,4]]\\nExpected:\\n[[],[1],[1,4],[1,4,4],[1,4,4,4],[1,4,4,4,4],[4],[4,4],[4,4,4],[4,4,4,4]]\\n\\nHow come [1,4,4,4] a subset for [4,4,4,1,4]??"
                    },
                    {
                        "username": "2uringTested",
                        "content": "its a subset not a subsequence so [4,4,1,4] is same as [4,4,4,1], the order does not matter and so it should only be counted once."
                    },
                    {
                        "username": "goldenwind",
                        "content": "The subset of a set A is a set that contains some elements of A or all elements of A. If it is a set, the order does not matter. [1,4,4,4] is the same as [4,1,4,4] as a set."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "proper explanation of question is not given, nums needs to be sorted."
                    },
                    {
                        "username": "rakeshks7",
                        "content": "I think you\\'re confusing subset with sub-sequence"
                    },
                    {
                        "username": "lampuiho",
                        "content": "you have [4,4,1,4], and [4,4,4,1] in your output. I fixed my code when I sorted the numbers first so that all the duplicates are grouped together. This is because my recursion relies on a position tracking parameter for skipping the duplicates in subsequent loops."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "There, the catch is to sort the nums array first.\\nThank you."
                    },
                    {
                        "username": "ankitk742",
                        "content": "Thanks bro, helped me allot "
                    },
                    {
                        "username": "athravmehta06",
                        "content": "saved my day .. lol thanks"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "fuck yAAR!THANK HYOU IT WORKED\\n"
                    },
                    {
                        "username": "srapol",
                        "content": "bro how did you come up with it ?? whats the logic??\\nP.S: it worked"
                    },
                    {
                        "username": "mochiball",
                        "content": "Facts. I was running into errors until I sorted. The weird thing is Sets don\\'t seem to account for the unsorted  "
                    },
                    {
                        "username": "Ninjabdul",
                        "content": "thanks bro, stuff like this is why i read discussion post"
                    },
                    {
                        "username": "Oleas",
                        "content": "This problem is NOT asking for the power set of a set. It is asking for all, sorted, unique combinations of the terms in the input. This caused me a great deal of grief. This problem\\'s description should be changed to remove the power set  wording."
                    },
                    {
                        "username": "charonme",
                        "content": "This is clearly wrong. When the array contains duplicates, the duplicate elements are either the same element or they are different elements. If they are the same, then [1, 2, 2] and [1, 2] are the same subset of an array given as [1, 2, 2]. But the problem solution expects both [1, 2] and [1, 2, 2], so clearly the first 2 and the second 2 must be different elements, in which case subsets [1, 2] (with the first 2) and [1, 2] (with the second 2) should be accepted too, but they are not."
                    },
                    {
                        "username": "piyushshah12327",
                        "content": "I went through some of the solutions to understand but why the need to sort?"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "You need to sort the array so, we can compare that previous element is same as current element or not. If you don\\'t sort the array, then it can\\'t find that element is same or different. ex,\\nint[] arr = {1,2,1};\\nhere you can see element at 0 index is equal to element at 2nd index.\\nIf you sort the array.  then it became \\nint[] arr = {1,1,2};\\nnow you can see that element at 0 index and 1 index are same and you can also easily write the code don\\'t run code from start. "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets-ii/solutions/2986411/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "coldz",
                        "content": "Find a way to adapt subset I solution to subsets II problem."
                    },
                    {
                        "username": "rahul_jain89",
                        "content": "I think description is not clear.\\n\\nI guess they want \"each subset should be sorted and unique\".\\n\\nThat\\'s why first we need to sort to input array, so that it will generate sorted subsets,\\nAnd then we can use a set to store the subsets, it will ensure that only unique subsets will be stored to result."
                    },
                    {
                        "username": "OmarNaru",
                        "content": "Idk why we need sorting here :\\nif the given input array is : [3,2,1]\\nthe output if we didn\\'t use sort will be :\\n1\\n2\\n2 1\\n3\\n3 1\\n3 2\\n3 2 1\\n_____________________\\nbut if we used sort it will be :\\n1\\n1 2\\n1 2 3\\n1 3\\n2\\n2 3\\n3\\n\\nit\\'s literally different output, how this even works !?\\nI guess I understood something wrong in the description\\ncan anyone explain ?"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "why sorting of input array is need here?"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "[@yadav_sahil](/yadav_sahil)  that\\'s not correct. It is because there are duplicate subsets [1,4] , [4,1] ,[4,4,1],[4,1,4] and [4,4,4,1],[4,4,1,4]. In the expected the total count of subarray is 10 while in output it is 13."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "Input:\\n[4,4,4,1,4]\\nOutput:\\n[[],[4],[1],[1,4],[4,4],[4,1],[4,1,4],[4,4,4],[4,4,1],[4,4,1,4],[4,4,4,4],[4,4,4,1],[4,4,4,1,4]]\\nExpected:\\n[[],[1],[1,4],[1,4,4],[1,4,4,4],[1,4,4,4,4],[4],[4,4],[4,4,4],[4,4,4,4]]\\nlook in this testcase expected output there is subset 1,4,4,4 which is not possible if 4,4,4,1,4 is not sorted as there is only one 4 after 1.\\n"
                    }
                ]
            },
            {
                "id": 1573304,
                "content": [
                    {
                        "username": "pengel1",
                        "content": "Where does the output should be in sorted order?  This may need further explination or refinement."
                    },
                    {
                        "username": "TerpsX",
                        "content": "Input:\\n[4,4,4,1,4]\\nOutput:\\n[[],[4],[1],[1,4],[4,4],[4,1],[4,1,4],[4,4,4],[4,4,1],[4,4,1,4],[4,4,4,4],[4,4,4,1],[4,4,4,1,4]]\\nExpected:\\n[[],[1],[1,4],[1,4,4],[1,4,4,4],[1,4,4,4,4],[4],[4,4],[4,4,4],[4,4,4,4]]\\n\\nHow come [1,4,4,4] a subset for [4,4,4,1,4]??"
                    },
                    {
                        "username": "2uringTested",
                        "content": "its a subset not a subsequence so [4,4,1,4] is same as [4,4,4,1], the order does not matter and so it should only be counted once."
                    },
                    {
                        "username": "goldenwind",
                        "content": "The subset of a set A is a set that contains some elements of A or all elements of A. If it is a set, the order does not matter. [1,4,4,4] is the same as [4,1,4,4] as a set."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "proper explanation of question is not given, nums needs to be sorted."
                    },
                    {
                        "username": "rakeshks7",
                        "content": "I think you\\'re confusing subset with sub-sequence"
                    },
                    {
                        "username": "lampuiho",
                        "content": "you have [4,4,1,4], and [4,4,4,1] in your output. I fixed my code when I sorted the numbers first so that all the duplicates are grouped together. This is because my recursion relies on a position tracking parameter for skipping the duplicates in subsequent loops."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "There, the catch is to sort the nums array first.\\nThank you."
                    },
                    {
                        "username": "ankitk742",
                        "content": "Thanks bro, helped me allot "
                    },
                    {
                        "username": "athravmehta06",
                        "content": "saved my day .. lol thanks"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "fuck yAAR!THANK HYOU IT WORKED\\n"
                    },
                    {
                        "username": "srapol",
                        "content": "bro how did you come up with it ?? whats the logic??\\nP.S: it worked"
                    },
                    {
                        "username": "mochiball",
                        "content": "Facts. I was running into errors until I sorted. The weird thing is Sets don\\'t seem to account for the unsorted  "
                    },
                    {
                        "username": "Ninjabdul",
                        "content": "thanks bro, stuff like this is why i read discussion post"
                    },
                    {
                        "username": "Oleas",
                        "content": "This problem is NOT asking for the power set of a set. It is asking for all, sorted, unique combinations of the terms in the input. This caused me a great deal of grief. This problem\\'s description should be changed to remove the power set  wording."
                    },
                    {
                        "username": "charonme",
                        "content": "This is clearly wrong. When the array contains duplicates, the duplicate elements are either the same element or they are different elements. If they are the same, then [1, 2, 2] and [1, 2] are the same subset of an array given as [1, 2, 2]. But the problem solution expects both [1, 2] and [1, 2, 2], so clearly the first 2 and the second 2 must be different elements, in which case subsets [1, 2] (with the first 2) and [1, 2] (with the second 2) should be accepted too, but they are not."
                    },
                    {
                        "username": "piyushshah12327",
                        "content": "I went through some of the solutions to understand but why the need to sort?"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "You need to sort the array so, we can compare that previous element is same as current element or not. If you don\\'t sort the array, then it can\\'t find that element is same or different. ex,\\nint[] arr = {1,2,1};\\nhere you can see element at 0 index is equal to element at 2nd index.\\nIf you sort the array.  then it became \\nint[] arr = {1,1,2};\\nnow you can see that element at 0 index and 1 index are same and you can also easily write the code don\\'t run code from start. "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets-ii/solutions/2986411/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "coldz",
                        "content": "Find a way to adapt subset I solution to subsets II problem."
                    },
                    {
                        "username": "rahul_jain89",
                        "content": "I think description is not clear.\\n\\nI guess they want \"each subset should be sorted and unique\".\\n\\nThat\\'s why first we need to sort to input array, so that it will generate sorted subsets,\\nAnd then we can use a set to store the subsets, it will ensure that only unique subsets will be stored to result."
                    },
                    {
                        "username": "OmarNaru",
                        "content": "Idk why we need sorting here :\\nif the given input array is : [3,2,1]\\nthe output if we didn\\'t use sort will be :\\n1\\n2\\n2 1\\n3\\n3 1\\n3 2\\n3 2 1\\n_____________________\\nbut if we used sort it will be :\\n1\\n1 2\\n1 2 3\\n1 3\\n2\\n2 3\\n3\\n\\nit\\'s literally different output, how this even works !?\\nI guess I understood something wrong in the description\\ncan anyone explain ?"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "why sorting of input array is need here?"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "[@yadav_sahil](/yadav_sahil)  that\\'s not correct. It is because there are duplicate subsets [1,4] , [4,1] ,[4,4,1],[4,1,4] and [4,4,4,1],[4,4,1,4]. In the expected the total count of subarray is 10 while in output it is 13."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "Input:\\n[4,4,4,1,4]\\nOutput:\\n[[],[4],[1],[1,4],[4,4],[4,1],[4,1,4],[4,4,4],[4,4,1],[4,4,1,4],[4,4,4,4],[4,4,4,1],[4,4,4,1,4]]\\nExpected:\\n[[],[1],[1,4],[1,4,4],[1,4,4,4],[1,4,4,4,4],[4],[4,4],[4,4,4],[4,4,4,4]]\\nlook in this testcase expected output there is subset 1,4,4,4 which is not possible if 4,4,4,1,4 is not sorted as there is only one 4 after 1.\\n"
                    }
                ]
            },
            {
                "id": 1571200,
                "content": [
                    {
                        "username": "pengel1",
                        "content": "Where does the output should be in sorted order?  This may need further explination or refinement."
                    },
                    {
                        "username": "TerpsX",
                        "content": "Input:\\n[4,4,4,1,4]\\nOutput:\\n[[],[4],[1],[1,4],[4,4],[4,1],[4,1,4],[4,4,4],[4,4,1],[4,4,1,4],[4,4,4,4],[4,4,4,1],[4,4,4,1,4]]\\nExpected:\\n[[],[1],[1,4],[1,4,4],[1,4,4,4],[1,4,4,4,4],[4],[4,4],[4,4,4],[4,4,4,4]]\\n\\nHow come [1,4,4,4] a subset for [4,4,4,1,4]??"
                    },
                    {
                        "username": "2uringTested",
                        "content": "its a subset not a subsequence so [4,4,1,4] is same as [4,4,4,1], the order does not matter and so it should only be counted once."
                    },
                    {
                        "username": "goldenwind",
                        "content": "The subset of a set A is a set that contains some elements of A or all elements of A. If it is a set, the order does not matter. [1,4,4,4] is the same as [4,1,4,4] as a set."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "proper explanation of question is not given, nums needs to be sorted."
                    },
                    {
                        "username": "rakeshks7",
                        "content": "I think you\\'re confusing subset with sub-sequence"
                    },
                    {
                        "username": "lampuiho",
                        "content": "you have [4,4,1,4], and [4,4,4,1] in your output. I fixed my code when I sorted the numbers first so that all the duplicates are grouped together. This is because my recursion relies on a position tracking parameter for skipping the duplicates in subsequent loops."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "There, the catch is to sort the nums array first.\\nThank you."
                    },
                    {
                        "username": "ankitk742",
                        "content": "Thanks bro, helped me allot "
                    },
                    {
                        "username": "athravmehta06",
                        "content": "saved my day .. lol thanks"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "fuck yAAR!THANK HYOU IT WORKED\\n"
                    },
                    {
                        "username": "srapol",
                        "content": "bro how did you come up with it ?? whats the logic??\\nP.S: it worked"
                    },
                    {
                        "username": "mochiball",
                        "content": "Facts. I was running into errors until I sorted. The weird thing is Sets don\\'t seem to account for the unsorted  "
                    },
                    {
                        "username": "Ninjabdul",
                        "content": "thanks bro, stuff like this is why i read discussion post"
                    },
                    {
                        "username": "Oleas",
                        "content": "This problem is NOT asking for the power set of a set. It is asking for all, sorted, unique combinations of the terms in the input. This caused me a great deal of grief. This problem\\'s description should be changed to remove the power set  wording."
                    },
                    {
                        "username": "charonme",
                        "content": "This is clearly wrong. When the array contains duplicates, the duplicate elements are either the same element or they are different elements. If they are the same, then [1, 2, 2] and [1, 2] are the same subset of an array given as [1, 2, 2]. But the problem solution expects both [1, 2] and [1, 2, 2], so clearly the first 2 and the second 2 must be different elements, in which case subsets [1, 2] (with the first 2) and [1, 2] (with the second 2) should be accepted too, but they are not."
                    },
                    {
                        "username": "piyushshah12327",
                        "content": "I went through some of the solutions to understand but why the need to sort?"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "You need to sort the array so, we can compare that previous element is same as current element or not. If you don\\'t sort the array, then it can\\'t find that element is same or different. ex,\\nint[] arr = {1,2,1};\\nhere you can see element at 0 index is equal to element at 2nd index.\\nIf you sort the array.  then it became \\nint[] arr = {1,1,2};\\nnow you can see that element at 0 index and 1 index are same and you can also easily write the code don\\'t run code from start. "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets-ii/solutions/2986411/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "coldz",
                        "content": "Find a way to adapt subset I solution to subsets II problem."
                    },
                    {
                        "username": "rahul_jain89",
                        "content": "I think description is not clear.\\n\\nI guess they want \"each subset should be sorted and unique\".\\n\\nThat\\'s why first we need to sort to input array, so that it will generate sorted subsets,\\nAnd then we can use a set to store the subsets, it will ensure that only unique subsets will be stored to result."
                    },
                    {
                        "username": "OmarNaru",
                        "content": "Idk why we need sorting here :\\nif the given input array is : [3,2,1]\\nthe output if we didn\\'t use sort will be :\\n1\\n2\\n2 1\\n3\\n3 1\\n3 2\\n3 2 1\\n_____________________\\nbut if we used sort it will be :\\n1\\n1 2\\n1 2 3\\n1 3\\n2\\n2 3\\n3\\n\\nit\\'s literally different output, how this even works !?\\nI guess I understood something wrong in the description\\ncan anyone explain ?"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "why sorting of input array is need here?"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "[@yadav_sahil](/yadav_sahil)  that\\'s not correct. It is because there are duplicate subsets [1,4] , [4,1] ,[4,4,1],[4,1,4] and [4,4,4,1],[4,4,1,4]. In the expected the total count of subarray is 10 while in output it is 13."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "Input:\\n[4,4,4,1,4]\\nOutput:\\n[[],[4],[1],[1,4],[4,4],[4,1],[4,1,4],[4,4,4],[4,4,1],[4,4,1,4],[4,4,4,4],[4,4,4,1],[4,4,4,1,4]]\\nExpected:\\n[[],[1],[1,4],[1,4,4],[1,4,4,4],[1,4,4,4,4],[4],[4,4],[4,4,4],[4,4,4,4]]\\nlook in this testcase expected output there is subset 1,4,4,4 which is not possible if 4,4,4,1,4 is not sorted as there is only one 4 after 1.\\n"
                    }
                ]
            },
            {
                "id": 1976912,
                "content": [
                    {
                        "username": "pengel1",
                        "content": "Where does the output should be in sorted order?  This may need further explination or refinement."
                    },
                    {
                        "username": "TerpsX",
                        "content": "Input:\\n[4,4,4,1,4]\\nOutput:\\n[[],[4],[1],[1,4],[4,4],[4,1],[4,1,4],[4,4,4],[4,4,1],[4,4,1,4],[4,4,4,4],[4,4,4,1],[4,4,4,1,4]]\\nExpected:\\n[[],[1],[1,4],[1,4,4],[1,4,4,4],[1,4,4,4,4],[4],[4,4],[4,4,4],[4,4,4,4]]\\n\\nHow come [1,4,4,4] a subset for [4,4,4,1,4]??"
                    },
                    {
                        "username": "2uringTested",
                        "content": "its a subset not a subsequence so [4,4,1,4] is same as [4,4,4,1], the order does not matter and so it should only be counted once."
                    },
                    {
                        "username": "goldenwind",
                        "content": "The subset of a set A is a set that contains some elements of A or all elements of A. If it is a set, the order does not matter. [1,4,4,4] is the same as [4,1,4,4] as a set."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "proper explanation of question is not given, nums needs to be sorted."
                    },
                    {
                        "username": "rakeshks7",
                        "content": "I think you\\'re confusing subset with sub-sequence"
                    },
                    {
                        "username": "lampuiho",
                        "content": "you have [4,4,1,4], and [4,4,4,1] in your output. I fixed my code when I sorted the numbers first so that all the duplicates are grouped together. This is because my recursion relies on a position tracking parameter for skipping the duplicates in subsequent loops."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "There, the catch is to sort the nums array first.\\nThank you."
                    },
                    {
                        "username": "ankitk742",
                        "content": "Thanks bro, helped me allot "
                    },
                    {
                        "username": "athravmehta06",
                        "content": "saved my day .. lol thanks"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "fuck yAAR!THANK HYOU IT WORKED\\n"
                    },
                    {
                        "username": "srapol",
                        "content": "bro how did you come up with it ?? whats the logic??\\nP.S: it worked"
                    },
                    {
                        "username": "mochiball",
                        "content": "Facts. I was running into errors until I sorted. The weird thing is Sets don\\'t seem to account for the unsorted  "
                    },
                    {
                        "username": "Ninjabdul",
                        "content": "thanks bro, stuff like this is why i read discussion post"
                    },
                    {
                        "username": "Oleas",
                        "content": "This problem is NOT asking for the power set of a set. It is asking for all, sorted, unique combinations of the terms in the input. This caused me a great deal of grief. This problem\\'s description should be changed to remove the power set  wording."
                    },
                    {
                        "username": "charonme",
                        "content": "This is clearly wrong. When the array contains duplicates, the duplicate elements are either the same element or they are different elements. If they are the same, then [1, 2, 2] and [1, 2] are the same subset of an array given as [1, 2, 2]. But the problem solution expects both [1, 2] and [1, 2, 2], so clearly the first 2 and the second 2 must be different elements, in which case subsets [1, 2] (with the first 2) and [1, 2] (with the second 2) should be accepted too, but they are not."
                    },
                    {
                        "username": "piyushshah12327",
                        "content": "I went through some of the solutions to understand but why the need to sort?"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "You need to sort the array so, we can compare that previous element is same as current element or not. If you don\\'t sort the array, then it can\\'t find that element is same or different. ex,\\nint[] arr = {1,2,1};\\nhere you can see element at 0 index is equal to element at 2nd index.\\nIf you sort the array.  then it became \\nint[] arr = {1,1,2};\\nnow you can see that element at 0 index and 1 index are same and you can also easily write the code don\\'t run code from start. "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets-ii/solutions/2986411/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "coldz",
                        "content": "Find a way to adapt subset I solution to subsets II problem."
                    },
                    {
                        "username": "rahul_jain89",
                        "content": "I think description is not clear.\\n\\nI guess they want \"each subset should be sorted and unique\".\\n\\nThat\\'s why first we need to sort to input array, so that it will generate sorted subsets,\\nAnd then we can use a set to store the subsets, it will ensure that only unique subsets will be stored to result."
                    },
                    {
                        "username": "OmarNaru",
                        "content": "Idk why we need sorting here :\\nif the given input array is : [3,2,1]\\nthe output if we didn\\'t use sort will be :\\n1\\n2\\n2 1\\n3\\n3 1\\n3 2\\n3 2 1\\n_____________________\\nbut if we used sort it will be :\\n1\\n1 2\\n1 2 3\\n1 3\\n2\\n2 3\\n3\\n\\nit\\'s literally different output, how this even works !?\\nI guess I understood something wrong in the description\\ncan anyone explain ?"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "why sorting of input array is need here?"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "[@yadav_sahil](/yadav_sahil)  that\\'s not correct. It is because there are duplicate subsets [1,4] , [4,1] ,[4,4,1],[4,1,4] and [4,4,4,1],[4,4,1,4]. In the expected the total count of subarray is 10 while in output it is 13."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "Input:\\n[4,4,4,1,4]\\nOutput:\\n[[],[4],[1],[1,4],[4,4],[4,1],[4,1,4],[4,4,4],[4,4,1],[4,4,1,4],[4,4,4,4],[4,4,4,1],[4,4,4,1,4]]\\nExpected:\\n[[],[1],[1,4],[1,4,4],[1,4,4,4],[1,4,4,4,4],[4],[4,4],[4,4,4],[4,4,4,4]]\\nlook in this testcase expected output there is subset 1,4,4,4 which is not possible if 4,4,4,1,4 is not sorted as there is only one 4 after 1.\\n"
                    }
                ]
            },
            {
                "id": 2001079,
                "content": [
                    {
                        "username": "pengel1",
                        "content": "Where does the output should be in sorted order?  This may need further explination or refinement."
                    },
                    {
                        "username": "TerpsX",
                        "content": "Input:\\n[4,4,4,1,4]\\nOutput:\\n[[],[4],[1],[1,4],[4,4],[4,1],[4,1,4],[4,4,4],[4,4,1],[4,4,1,4],[4,4,4,4],[4,4,4,1],[4,4,4,1,4]]\\nExpected:\\n[[],[1],[1,4],[1,4,4],[1,4,4,4],[1,4,4,4,4],[4],[4,4],[4,4,4],[4,4,4,4]]\\n\\nHow come [1,4,4,4] a subset for [4,4,4,1,4]??"
                    },
                    {
                        "username": "2uringTested",
                        "content": "its a subset not a subsequence so [4,4,1,4] is same as [4,4,4,1], the order does not matter and so it should only be counted once."
                    },
                    {
                        "username": "goldenwind",
                        "content": "The subset of a set A is a set that contains some elements of A or all elements of A. If it is a set, the order does not matter. [1,4,4,4] is the same as [4,1,4,4] as a set."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "proper explanation of question is not given, nums needs to be sorted."
                    },
                    {
                        "username": "rakeshks7",
                        "content": "I think you\\'re confusing subset with sub-sequence"
                    },
                    {
                        "username": "lampuiho",
                        "content": "you have [4,4,1,4], and [4,4,4,1] in your output. I fixed my code when I sorted the numbers first so that all the duplicates are grouped together. This is because my recursion relies on a position tracking parameter for skipping the duplicates in subsequent loops."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "There, the catch is to sort the nums array first.\\nThank you."
                    },
                    {
                        "username": "ankitk742",
                        "content": "Thanks bro, helped me allot "
                    },
                    {
                        "username": "athravmehta06",
                        "content": "saved my day .. lol thanks"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "fuck yAAR!THANK HYOU IT WORKED\\n"
                    },
                    {
                        "username": "srapol",
                        "content": "bro how did you come up with it ?? whats the logic??\\nP.S: it worked"
                    },
                    {
                        "username": "mochiball",
                        "content": "Facts. I was running into errors until I sorted. The weird thing is Sets don\\'t seem to account for the unsorted  "
                    },
                    {
                        "username": "Ninjabdul",
                        "content": "thanks bro, stuff like this is why i read discussion post"
                    },
                    {
                        "username": "Oleas",
                        "content": "This problem is NOT asking for the power set of a set. It is asking for all, sorted, unique combinations of the terms in the input. This caused me a great deal of grief. This problem\\'s description should be changed to remove the power set  wording."
                    },
                    {
                        "username": "charonme",
                        "content": "This is clearly wrong. When the array contains duplicates, the duplicate elements are either the same element or they are different elements. If they are the same, then [1, 2, 2] and [1, 2] are the same subset of an array given as [1, 2, 2]. But the problem solution expects both [1, 2] and [1, 2, 2], so clearly the first 2 and the second 2 must be different elements, in which case subsets [1, 2] (with the first 2) and [1, 2] (with the second 2) should be accepted too, but they are not."
                    },
                    {
                        "username": "piyushshah12327",
                        "content": "I went through some of the solutions to understand but why the need to sort?"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "You need to sort the array so, we can compare that previous element is same as current element or not. If you don\\'t sort the array, then it can\\'t find that element is same or different. ex,\\nint[] arr = {1,2,1};\\nhere you can see element at 0 index is equal to element at 2nd index.\\nIf you sort the array.  then it became \\nint[] arr = {1,1,2};\\nnow you can see that element at 0 index and 1 index are same and you can also easily write the code don\\'t run code from start. "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets-ii/solutions/2986411/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "coldz",
                        "content": "Find a way to adapt subset I solution to subsets II problem."
                    },
                    {
                        "username": "rahul_jain89",
                        "content": "I think description is not clear.\\n\\nI guess they want \"each subset should be sorted and unique\".\\n\\nThat\\'s why first we need to sort to input array, so that it will generate sorted subsets,\\nAnd then we can use a set to store the subsets, it will ensure that only unique subsets will be stored to result."
                    },
                    {
                        "username": "OmarNaru",
                        "content": "Idk why we need sorting here :\\nif the given input array is : [3,2,1]\\nthe output if we didn\\'t use sort will be :\\n1\\n2\\n2 1\\n3\\n3 1\\n3 2\\n3 2 1\\n_____________________\\nbut if we used sort it will be :\\n1\\n1 2\\n1 2 3\\n1 3\\n2\\n2 3\\n3\\n\\nit\\'s literally different output, how this even works !?\\nI guess I understood something wrong in the description\\ncan anyone explain ?"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "why sorting of input array is need here?"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "[@yadav_sahil](/yadav_sahil)  that\\'s not correct. It is because there are duplicate subsets [1,4] , [4,1] ,[4,4,1],[4,1,4] and [4,4,4,1],[4,4,1,4]. In the expected the total count of subarray is 10 while in output it is 13."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "Input:\\n[4,4,4,1,4]\\nOutput:\\n[[],[4],[1],[1,4],[4,4],[4,1],[4,1,4],[4,4,4],[4,4,1],[4,4,1,4],[4,4,4,4],[4,4,4,1],[4,4,4,1,4]]\\nExpected:\\n[[],[1],[1,4],[1,4,4],[1,4,4,4],[1,4,4,4,4],[4],[4,4],[4,4,4],[4,4,4,4]]\\nlook in this testcase expected output there is subset 1,4,4,4 which is not possible if 4,4,4,1,4 is not sorted as there is only one 4 after 1.\\n"
                    }
                ]
            },
            {
                "id": 1760164,
                "content": [
                    {
                        "username": "pengel1",
                        "content": "Where does the output should be in sorted order?  This may need further explination or refinement."
                    },
                    {
                        "username": "TerpsX",
                        "content": "Input:\\n[4,4,4,1,4]\\nOutput:\\n[[],[4],[1],[1,4],[4,4],[4,1],[4,1,4],[4,4,4],[4,4,1],[4,4,1,4],[4,4,4,4],[4,4,4,1],[4,4,4,1,4]]\\nExpected:\\n[[],[1],[1,4],[1,4,4],[1,4,4,4],[1,4,4,4,4],[4],[4,4],[4,4,4],[4,4,4,4]]\\n\\nHow come [1,4,4,4] a subset for [4,4,4,1,4]??"
                    },
                    {
                        "username": "2uringTested",
                        "content": "its a subset not a subsequence so [4,4,1,4] is same as [4,4,4,1], the order does not matter and so it should only be counted once."
                    },
                    {
                        "username": "goldenwind",
                        "content": "The subset of a set A is a set that contains some elements of A or all elements of A. If it is a set, the order does not matter. [1,4,4,4] is the same as [4,1,4,4] as a set."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "proper explanation of question is not given, nums needs to be sorted."
                    },
                    {
                        "username": "rakeshks7",
                        "content": "I think you\\'re confusing subset with sub-sequence"
                    },
                    {
                        "username": "lampuiho",
                        "content": "you have [4,4,1,4], and [4,4,4,1] in your output. I fixed my code when I sorted the numbers first so that all the duplicates are grouped together. This is because my recursion relies on a position tracking parameter for skipping the duplicates in subsequent loops."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "There, the catch is to sort the nums array first.\\nThank you."
                    },
                    {
                        "username": "ankitk742",
                        "content": "Thanks bro, helped me allot "
                    },
                    {
                        "username": "athravmehta06",
                        "content": "saved my day .. lol thanks"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "fuck yAAR!THANK HYOU IT WORKED\\n"
                    },
                    {
                        "username": "srapol",
                        "content": "bro how did you come up with it ?? whats the logic??\\nP.S: it worked"
                    },
                    {
                        "username": "mochiball",
                        "content": "Facts. I was running into errors until I sorted. The weird thing is Sets don\\'t seem to account for the unsorted  "
                    },
                    {
                        "username": "Ninjabdul",
                        "content": "thanks bro, stuff like this is why i read discussion post"
                    },
                    {
                        "username": "Oleas",
                        "content": "This problem is NOT asking for the power set of a set. It is asking for all, sorted, unique combinations of the terms in the input. This caused me a great deal of grief. This problem\\'s description should be changed to remove the power set  wording."
                    },
                    {
                        "username": "charonme",
                        "content": "This is clearly wrong. When the array contains duplicates, the duplicate elements are either the same element or they are different elements. If they are the same, then [1, 2, 2] and [1, 2] are the same subset of an array given as [1, 2, 2]. But the problem solution expects both [1, 2] and [1, 2, 2], so clearly the first 2 and the second 2 must be different elements, in which case subsets [1, 2] (with the first 2) and [1, 2] (with the second 2) should be accepted too, but they are not."
                    },
                    {
                        "username": "piyushshah12327",
                        "content": "I went through some of the solutions to understand but why the need to sort?"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "You need to sort the array so, we can compare that previous element is same as current element or not. If you don\\'t sort the array, then it can\\'t find that element is same or different. ex,\\nint[] arr = {1,2,1};\\nhere you can see element at 0 index is equal to element at 2nd index.\\nIf you sort the array.  then it became \\nint[] arr = {1,1,2};\\nnow you can see that element at 0 index and 1 index are same and you can also easily write the code don\\'t run code from start. "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets-ii/solutions/2986411/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "coldz",
                        "content": "Find a way to adapt subset I solution to subsets II problem."
                    },
                    {
                        "username": "rahul_jain89",
                        "content": "I think description is not clear.\\n\\nI guess they want \"each subset should be sorted and unique\".\\n\\nThat\\'s why first we need to sort to input array, so that it will generate sorted subsets,\\nAnd then we can use a set to store the subsets, it will ensure that only unique subsets will be stored to result."
                    },
                    {
                        "username": "OmarNaru",
                        "content": "Idk why we need sorting here :\\nif the given input array is : [3,2,1]\\nthe output if we didn\\'t use sort will be :\\n1\\n2\\n2 1\\n3\\n3 1\\n3 2\\n3 2 1\\n_____________________\\nbut if we used sort it will be :\\n1\\n1 2\\n1 2 3\\n1 3\\n2\\n2 3\\n3\\n\\nit\\'s literally different output, how this even works !?\\nI guess I understood something wrong in the description\\ncan anyone explain ?"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "why sorting of input array is need here?"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "[@yadav_sahil](/yadav_sahil)  that\\'s not correct. It is because there are duplicate subsets [1,4] , [4,1] ,[4,4,1],[4,1,4] and [4,4,4,1],[4,4,1,4]. In the expected the total count of subarray is 10 while in output it is 13."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "Input:\\n[4,4,4,1,4]\\nOutput:\\n[[],[4],[1],[1,4],[4,4],[4,1],[4,1,4],[4,4,4],[4,4,1],[4,4,1,4],[4,4,4,4],[4,4,4,1],[4,4,4,1,4]]\\nExpected:\\n[[],[1],[1,4],[1,4,4],[1,4,4,4],[1,4,4,4,4],[4],[4,4],[4,4,4],[4,4,4,4]]\\nlook in this testcase expected output there is subset 1,4,4,4 which is not possible if 4,4,4,1,4 is not sorted as there is only one 4 after 1.\\n"
                    }
                ]
            },
            {
                "id": 1572369,
                "content": [
                    {
                        "username": "pengel1",
                        "content": "Where does the output should be in sorted order?  This may need further explination or refinement."
                    },
                    {
                        "username": "TerpsX",
                        "content": "Input:\\n[4,4,4,1,4]\\nOutput:\\n[[],[4],[1],[1,4],[4,4],[4,1],[4,1,4],[4,4,4],[4,4,1],[4,4,1,4],[4,4,4,4],[4,4,4,1],[4,4,4,1,4]]\\nExpected:\\n[[],[1],[1,4],[1,4,4],[1,4,4,4],[1,4,4,4,4],[4],[4,4],[4,4,4],[4,4,4,4]]\\n\\nHow come [1,4,4,4] a subset for [4,4,4,1,4]??"
                    },
                    {
                        "username": "2uringTested",
                        "content": "its a subset not a subsequence so [4,4,1,4] is same as [4,4,4,1], the order does not matter and so it should only be counted once."
                    },
                    {
                        "username": "goldenwind",
                        "content": "The subset of a set A is a set that contains some elements of A or all elements of A. If it is a set, the order does not matter. [1,4,4,4] is the same as [4,1,4,4] as a set."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "proper explanation of question is not given, nums needs to be sorted."
                    },
                    {
                        "username": "rakeshks7",
                        "content": "I think you\\'re confusing subset with sub-sequence"
                    },
                    {
                        "username": "lampuiho",
                        "content": "you have [4,4,1,4], and [4,4,4,1] in your output. I fixed my code when I sorted the numbers first so that all the duplicates are grouped together. This is because my recursion relies on a position tracking parameter for skipping the duplicates in subsequent loops."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "There, the catch is to sort the nums array first.\\nThank you."
                    },
                    {
                        "username": "ankitk742",
                        "content": "Thanks bro, helped me allot "
                    },
                    {
                        "username": "athravmehta06",
                        "content": "saved my day .. lol thanks"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "fuck yAAR!THANK HYOU IT WORKED\\n"
                    },
                    {
                        "username": "srapol",
                        "content": "bro how did you come up with it ?? whats the logic??\\nP.S: it worked"
                    },
                    {
                        "username": "mochiball",
                        "content": "Facts. I was running into errors until I sorted. The weird thing is Sets don\\'t seem to account for the unsorted  "
                    },
                    {
                        "username": "Ninjabdul",
                        "content": "thanks bro, stuff like this is why i read discussion post"
                    },
                    {
                        "username": "Oleas",
                        "content": "This problem is NOT asking for the power set of a set. It is asking for all, sorted, unique combinations of the terms in the input. This caused me a great deal of grief. This problem\\'s description should be changed to remove the power set  wording."
                    },
                    {
                        "username": "charonme",
                        "content": "This is clearly wrong. When the array contains duplicates, the duplicate elements are either the same element or they are different elements. If they are the same, then [1, 2, 2] and [1, 2] are the same subset of an array given as [1, 2, 2]. But the problem solution expects both [1, 2] and [1, 2, 2], so clearly the first 2 and the second 2 must be different elements, in which case subsets [1, 2] (with the first 2) and [1, 2] (with the second 2) should be accepted too, but they are not."
                    },
                    {
                        "username": "piyushshah12327",
                        "content": "I went through some of the solutions to understand but why the need to sort?"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "You need to sort the array so, we can compare that previous element is same as current element or not. If you don\\'t sort the array, then it can\\'t find that element is same or different. ex,\\nint[] arr = {1,2,1};\\nhere you can see element at 0 index is equal to element at 2nd index.\\nIf you sort the array.  then it became \\nint[] arr = {1,1,2};\\nnow you can see that element at 0 index and 1 index are same and you can also easily write the code don\\'t run code from start. "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets-ii/solutions/2986411/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "coldz",
                        "content": "Find a way to adapt subset I solution to subsets II problem."
                    },
                    {
                        "username": "rahul_jain89",
                        "content": "I think description is not clear.\\n\\nI guess they want \"each subset should be sorted and unique\".\\n\\nThat\\'s why first we need to sort to input array, so that it will generate sorted subsets,\\nAnd then we can use a set to store the subsets, it will ensure that only unique subsets will be stored to result."
                    },
                    {
                        "username": "OmarNaru",
                        "content": "Idk why we need sorting here :\\nif the given input array is : [3,2,1]\\nthe output if we didn\\'t use sort will be :\\n1\\n2\\n2 1\\n3\\n3 1\\n3 2\\n3 2 1\\n_____________________\\nbut if we used sort it will be :\\n1\\n1 2\\n1 2 3\\n1 3\\n2\\n2 3\\n3\\n\\nit\\'s literally different output, how this even works !?\\nI guess I understood something wrong in the description\\ncan anyone explain ?"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "why sorting of input array is need here?"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "[@yadav_sahil](/yadav_sahil)  that\\'s not correct. It is because there are duplicate subsets [1,4] , [4,1] ,[4,4,1],[4,1,4] and [4,4,4,1],[4,4,1,4]. In the expected the total count of subarray is 10 while in output it is 13."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "Input:\\n[4,4,4,1,4]\\nOutput:\\n[[],[4],[1],[1,4],[4,4],[4,1],[4,1,4],[4,4,4],[4,4,1],[4,4,1,4],[4,4,4,4],[4,4,4,1],[4,4,4,1,4]]\\nExpected:\\n[[],[1],[1,4],[1,4,4],[1,4,4,4],[1,4,4,4,4],[4],[4,4],[4,4,4],[4,4,4,4]]\\nlook in this testcase expected output there is subset 1,4,4,4 which is not possible if 4,4,4,1,4 is not sorted as there is only one 4 after 1.\\n"
                    }
                ]
            },
            {
                "id": 1571199,
                "content": [
                    {
                        "username": "pengel1",
                        "content": "Where does the output should be in sorted order?  This may need further explination or refinement."
                    },
                    {
                        "username": "TerpsX",
                        "content": "Input:\\n[4,4,4,1,4]\\nOutput:\\n[[],[4],[1],[1,4],[4,4],[4,1],[4,1,4],[4,4,4],[4,4,1],[4,4,1,4],[4,4,4,4],[4,4,4,1],[4,4,4,1,4]]\\nExpected:\\n[[],[1],[1,4],[1,4,4],[1,4,4,4],[1,4,4,4,4],[4],[4,4],[4,4,4],[4,4,4,4]]\\n\\nHow come [1,4,4,4] a subset for [4,4,4,1,4]??"
                    },
                    {
                        "username": "2uringTested",
                        "content": "its a subset not a subsequence so [4,4,1,4] is same as [4,4,4,1], the order does not matter and so it should only be counted once."
                    },
                    {
                        "username": "goldenwind",
                        "content": "The subset of a set A is a set that contains some elements of A or all elements of A. If it is a set, the order does not matter. [1,4,4,4] is the same as [4,1,4,4] as a set."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "proper explanation of question is not given, nums needs to be sorted."
                    },
                    {
                        "username": "rakeshks7",
                        "content": "I think you\\'re confusing subset with sub-sequence"
                    },
                    {
                        "username": "lampuiho",
                        "content": "you have [4,4,1,4], and [4,4,4,1] in your output. I fixed my code when I sorted the numbers first so that all the duplicates are grouped together. This is because my recursion relies on a position tracking parameter for skipping the duplicates in subsequent loops."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "There, the catch is to sort the nums array first.\\nThank you."
                    },
                    {
                        "username": "ankitk742",
                        "content": "Thanks bro, helped me allot "
                    },
                    {
                        "username": "athravmehta06",
                        "content": "saved my day .. lol thanks"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "fuck yAAR!THANK HYOU IT WORKED\\n"
                    },
                    {
                        "username": "srapol",
                        "content": "bro how did you come up with it ?? whats the logic??\\nP.S: it worked"
                    },
                    {
                        "username": "mochiball",
                        "content": "Facts. I was running into errors until I sorted. The weird thing is Sets don\\'t seem to account for the unsorted  "
                    },
                    {
                        "username": "Ninjabdul",
                        "content": "thanks bro, stuff like this is why i read discussion post"
                    },
                    {
                        "username": "Oleas",
                        "content": "This problem is NOT asking for the power set of a set. It is asking for all, sorted, unique combinations of the terms in the input. This caused me a great deal of grief. This problem\\'s description should be changed to remove the power set  wording."
                    },
                    {
                        "username": "charonme",
                        "content": "This is clearly wrong. When the array contains duplicates, the duplicate elements are either the same element or they are different elements. If they are the same, then [1, 2, 2] and [1, 2] are the same subset of an array given as [1, 2, 2]. But the problem solution expects both [1, 2] and [1, 2, 2], so clearly the first 2 and the second 2 must be different elements, in which case subsets [1, 2] (with the first 2) and [1, 2] (with the second 2) should be accepted too, but they are not."
                    },
                    {
                        "username": "piyushshah12327",
                        "content": "I went through some of the solutions to understand but why the need to sort?"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "You need to sort the array so, we can compare that previous element is same as current element or not. If you don\\'t sort the array, then it can\\'t find that element is same or different. ex,\\nint[] arr = {1,2,1};\\nhere you can see element at 0 index is equal to element at 2nd index.\\nIf you sort the array.  then it became \\nint[] arr = {1,1,2};\\nnow you can see that element at 0 index and 1 index are same and you can also easily write the code don\\'t run code from start. "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets-ii/solutions/2986411/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "coldz",
                        "content": "Find a way to adapt subset I solution to subsets II problem."
                    },
                    {
                        "username": "rahul_jain89",
                        "content": "I think description is not clear.\\n\\nI guess they want \"each subset should be sorted and unique\".\\n\\nThat\\'s why first we need to sort to input array, so that it will generate sorted subsets,\\nAnd then we can use a set to store the subsets, it will ensure that only unique subsets will be stored to result."
                    },
                    {
                        "username": "OmarNaru",
                        "content": "Idk why we need sorting here :\\nif the given input array is : [3,2,1]\\nthe output if we didn\\'t use sort will be :\\n1\\n2\\n2 1\\n3\\n3 1\\n3 2\\n3 2 1\\n_____________________\\nbut if we used sort it will be :\\n1\\n1 2\\n1 2 3\\n1 3\\n2\\n2 3\\n3\\n\\nit\\'s literally different output, how this even works !?\\nI guess I understood something wrong in the description\\ncan anyone explain ?"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "why sorting of input array is need here?"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "[@yadav_sahil](/yadav_sahil)  that\\'s not correct. It is because there are duplicate subsets [1,4] , [4,1] ,[4,4,1],[4,1,4] and [4,4,4,1],[4,4,1,4]. In the expected the total count of subarray is 10 while in output it is 13."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "Input:\\n[4,4,4,1,4]\\nOutput:\\n[[],[4],[1],[1,4],[4,4],[4,1],[4,1,4],[4,4,4],[4,4,1],[4,4,1,4],[4,4,4,4],[4,4,4,1],[4,4,4,1,4]]\\nExpected:\\n[[],[1],[1,4],[1,4,4],[1,4,4,4],[1,4,4,4,4],[4],[4,4],[4,4,4],[4,4,4,4]]\\nlook in this testcase expected output there is subset 1,4,4,4 which is not possible if 4,4,4,1,4 is not sorted as there is only one 4 after 1.\\n"
                    }
                ]
            },
            {
                "id": 1748905,
                "content": [
                    {
                        "username": "pengel1",
                        "content": "Where does the output should be in sorted order?  This may need further explination or refinement."
                    },
                    {
                        "username": "TerpsX",
                        "content": "Input:\\n[4,4,4,1,4]\\nOutput:\\n[[],[4],[1],[1,4],[4,4],[4,1],[4,1,4],[4,4,4],[4,4,1],[4,4,1,4],[4,4,4,4],[4,4,4,1],[4,4,4,1,4]]\\nExpected:\\n[[],[1],[1,4],[1,4,4],[1,4,4,4],[1,4,4,4,4],[4],[4,4],[4,4,4],[4,4,4,4]]\\n\\nHow come [1,4,4,4] a subset for [4,4,4,1,4]??"
                    },
                    {
                        "username": "2uringTested",
                        "content": "its a subset not a subsequence so [4,4,1,4] is same as [4,4,4,1], the order does not matter and so it should only be counted once."
                    },
                    {
                        "username": "goldenwind",
                        "content": "The subset of a set A is a set that contains some elements of A or all elements of A. If it is a set, the order does not matter. [1,4,4,4] is the same as [4,1,4,4] as a set."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "proper explanation of question is not given, nums needs to be sorted."
                    },
                    {
                        "username": "rakeshks7",
                        "content": "I think you\\'re confusing subset with sub-sequence"
                    },
                    {
                        "username": "lampuiho",
                        "content": "you have [4,4,1,4], and [4,4,4,1] in your output. I fixed my code when I sorted the numbers first so that all the duplicates are grouped together. This is because my recursion relies on a position tracking parameter for skipping the duplicates in subsequent loops."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "There, the catch is to sort the nums array first.\\nThank you."
                    },
                    {
                        "username": "ankitk742",
                        "content": "Thanks bro, helped me allot "
                    },
                    {
                        "username": "athravmehta06",
                        "content": "saved my day .. lol thanks"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "fuck yAAR!THANK HYOU IT WORKED\\n"
                    },
                    {
                        "username": "srapol",
                        "content": "bro how did you come up with it ?? whats the logic??\\nP.S: it worked"
                    },
                    {
                        "username": "mochiball",
                        "content": "Facts. I was running into errors until I sorted. The weird thing is Sets don\\'t seem to account for the unsorted  "
                    },
                    {
                        "username": "Ninjabdul",
                        "content": "thanks bro, stuff like this is why i read discussion post"
                    },
                    {
                        "username": "Oleas",
                        "content": "This problem is NOT asking for the power set of a set. It is asking for all, sorted, unique combinations of the terms in the input. This caused me a great deal of grief. This problem\\'s description should be changed to remove the power set  wording."
                    },
                    {
                        "username": "charonme",
                        "content": "This is clearly wrong. When the array contains duplicates, the duplicate elements are either the same element or they are different elements. If they are the same, then [1, 2, 2] and [1, 2] are the same subset of an array given as [1, 2, 2]. But the problem solution expects both [1, 2] and [1, 2, 2], so clearly the first 2 and the second 2 must be different elements, in which case subsets [1, 2] (with the first 2) and [1, 2] (with the second 2) should be accepted too, but they are not."
                    },
                    {
                        "username": "piyushshah12327",
                        "content": "I went through some of the solutions to understand but why the need to sort?"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "You need to sort the array so, we can compare that previous element is same as current element or not. If you don\\'t sort the array, then it can\\'t find that element is same or different. ex,\\nint[] arr = {1,2,1};\\nhere you can see element at 0 index is equal to element at 2nd index.\\nIf you sort the array.  then it became \\nint[] arr = {1,1,2};\\nnow you can see that element at 0 index and 1 index are same and you can also easily write the code don\\'t run code from start. "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets-ii/solutions/2986411/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "coldz",
                        "content": "Find a way to adapt subset I solution to subsets II problem."
                    },
                    {
                        "username": "rahul_jain89",
                        "content": "I think description is not clear.\\n\\nI guess they want \"each subset should be sorted and unique\".\\n\\nThat\\'s why first we need to sort to input array, so that it will generate sorted subsets,\\nAnd then we can use a set to store the subsets, it will ensure that only unique subsets will be stored to result."
                    },
                    {
                        "username": "OmarNaru",
                        "content": "Idk why we need sorting here :\\nif the given input array is : [3,2,1]\\nthe output if we didn\\'t use sort will be :\\n1\\n2\\n2 1\\n3\\n3 1\\n3 2\\n3 2 1\\n_____________________\\nbut if we used sort it will be :\\n1\\n1 2\\n1 2 3\\n1 3\\n2\\n2 3\\n3\\n\\nit\\'s literally different output, how this even works !?\\nI guess I understood something wrong in the description\\ncan anyone explain ?"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "why sorting of input array is need here?"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "[@yadav_sahil](/yadav_sahil)  that\\'s not correct. It is because there are duplicate subsets [1,4] , [4,1] ,[4,4,1],[4,1,4] and [4,4,4,1],[4,4,1,4]. In the expected the total count of subarray is 10 while in output it is 13."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "Input:\\n[4,4,4,1,4]\\nOutput:\\n[[],[4],[1],[1,4],[4,4],[4,1],[4,1,4],[4,4,4],[4,4,1],[4,4,1,4],[4,4,4,4],[4,4,4,1],[4,4,4,1,4]]\\nExpected:\\n[[],[1],[1,4],[1,4,4],[1,4,4,4],[1,4,4,4,4],[4],[4,4],[4,4,4],[4,4,4,4]]\\nlook in this testcase expected output there is subset 1,4,4,4 which is not possible if 4,4,4,1,4 is not sorted as there is only one 4 after 1.\\n"
                    }
                ]
            },
            {
                "id": 1781360,
                "content": [
                    {
                        "username": "pengel1",
                        "content": "Where does the output should be in sorted order?  This may need further explination or refinement."
                    },
                    {
                        "username": "TerpsX",
                        "content": "Input:\\n[4,4,4,1,4]\\nOutput:\\n[[],[4],[1],[1,4],[4,4],[4,1],[4,1,4],[4,4,4],[4,4,1],[4,4,1,4],[4,4,4,4],[4,4,4,1],[4,4,4,1,4]]\\nExpected:\\n[[],[1],[1,4],[1,4,4],[1,4,4,4],[1,4,4,4,4],[4],[4,4],[4,4,4],[4,4,4,4]]\\n\\nHow come [1,4,4,4] a subset for [4,4,4,1,4]??"
                    },
                    {
                        "username": "2uringTested",
                        "content": "its a subset not a subsequence so [4,4,1,4] is same as [4,4,4,1], the order does not matter and so it should only be counted once."
                    },
                    {
                        "username": "goldenwind",
                        "content": "The subset of a set A is a set that contains some elements of A or all elements of A. If it is a set, the order does not matter. [1,4,4,4] is the same as [4,1,4,4] as a set."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "proper explanation of question is not given, nums needs to be sorted."
                    },
                    {
                        "username": "rakeshks7",
                        "content": "I think you\\'re confusing subset with sub-sequence"
                    },
                    {
                        "username": "lampuiho",
                        "content": "you have [4,4,1,4], and [4,4,4,1] in your output. I fixed my code when I sorted the numbers first so that all the duplicates are grouped together. This is because my recursion relies on a position tracking parameter for skipping the duplicates in subsequent loops."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "There, the catch is to sort the nums array first.\\nThank you."
                    },
                    {
                        "username": "ankitk742",
                        "content": "Thanks bro, helped me allot "
                    },
                    {
                        "username": "athravmehta06",
                        "content": "saved my day .. lol thanks"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "fuck yAAR!THANK HYOU IT WORKED\\n"
                    },
                    {
                        "username": "srapol",
                        "content": "bro how did you come up with it ?? whats the logic??\\nP.S: it worked"
                    },
                    {
                        "username": "mochiball",
                        "content": "Facts. I was running into errors until I sorted. The weird thing is Sets don\\'t seem to account for the unsorted  "
                    },
                    {
                        "username": "Ninjabdul",
                        "content": "thanks bro, stuff like this is why i read discussion post"
                    },
                    {
                        "username": "Oleas",
                        "content": "This problem is NOT asking for the power set of a set. It is asking for all, sorted, unique combinations of the terms in the input. This caused me a great deal of grief. This problem\\'s description should be changed to remove the power set  wording."
                    },
                    {
                        "username": "charonme",
                        "content": "This is clearly wrong. When the array contains duplicates, the duplicate elements are either the same element or they are different elements. If they are the same, then [1, 2, 2] and [1, 2] are the same subset of an array given as [1, 2, 2]. But the problem solution expects both [1, 2] and [1, 2, 2], so clearly the first 2 and the second 2 must be different elements, in which case subsets [1, 2] (with the first 2) and [1, 2] (with the second 2) should be accepted too, but they are not."
                    },
                    {
                        "username": "piyushshah12327",
                        "content": "I went through some of the solutions to understand but why the need to sort?"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "You need to sort the array so, we can compare that previous element is same as current element or not. If you don\\'t sort the array, then it can\\'t find that element is same or different. ex,\\nint[] arr = {1,2,1};\\nhere you can see element at 0 index is equal to element at 2nd index.\\nIf you sort the array.  then it became \\nint[] arr = {1,1,2};\\nnow you can see that element at 0 index and 1 index are same and you can also easily write the code don\\'t run code from start. "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets-ii/solutions/2986411/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "coldz",
                        "content": "Find a way to adapt subset I solution to subsets II problem."
                    },
                    {
                        "username": "rahul_jain89",
                        "content": "I think description is not clear.\\n\\nI guess they want \"each subset should be sorted and unique\".\\n\\nThat\\'s why first we need to sort to input array, so that it will generate sorted subsets,\\nAnd then we can use a set to store the subsets, it will ensure that only unique subsets will be stored to result."
                    },
                    {
                        "username": "OmarNaru",
                        "content": "Idk why we need sorting here :\\nif the given input array is : [3,2,1]\\nthe output if we didn\\'t use sort will be :\\n1\\n2\\n2 1\\n3\\n3 1\\n3 2\\n3 2 1\\n_____________________\\nbut if we used sort it will be :\\n1\\n1 2\\n1 2 3\\n1 3\\n2\\n2 3\\n3\\n\\nit\\'s literally different output, how this even works !?\\nI guess I understood something wrong in the description\\ncan anyone explain ?"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "why sorting of input array is need here?"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "[@yadav_sahil](/yadav_sahil)  that\\'s not correct. It is because there are duplicate subsets [1,4] , [4,1] ,[4,4,1],[4,1,4] and [4,4,4,1],[4,4,1,4]. In the expected the total count of subarray is 10 while in output it is 13."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "Input:\\n[4,4,4,1,4]\\nOutput:\\n[[],[4],[1],[1,4],[4,4],[4,1],[4,1,4],[4,4,4],[4,4,1],[4,4,1,4],[4,4,4,4],[4,4,4,1],[4,4,4,1,4]]\\nExpected:\\n[[],[1],[1,4],[1,4,4],[1,4,4,4],[1,4,4,4,4],[4],[4,4],[4,4,4],[4,4,4,4]]\\nlook in this testcase expected output there is subset 1,4,4,4 which is not possible if 4,4,4,1,4 is not sorted as there is only one 4 after 1.\\n"
                    }
                ]
            },
            {
                "id": 1769485,
                "content": [
                    {
                        "username": "pengel1",
                        "content": "Where does the output should be in sorted order?  This may need further explination or refinement."
                    },
                    {
                        "username": "TerpsX",
                        "content": "Input:\\n[4,4,4,1,4]\\nOutput:\\n[[],[4],[1],[1,4],[4,4],[4,1],[4,1,4],[4,4,4],[4,4,1],[4,4,1,4],[4,4,4,4],[4,4,4,1],[4,4,4,1,4]]\\nExpected:\\n[[],[1],[1,4],[1,4,4],[1,4,4,4],[1,4,4,4,4],[4],[4,4],[4,4,4],[4,4,4,4]]\\n\\nHow come [1,4,4,4] a subset for [4,4,4,1,4]??"
                    },
                    {
                        "username": "2uringTested",
                        "content": "its a subset not a subsequence so [4,4,1,4] is same as [4,4,4,1], the order does not matter and so it should only be counted once."
                    },
                    {
                        "username": "goldenwind",
                        "content": "The subset of a set A is a set that contains some elements of A or all elements of A. If it is a set, the order does not matter. [1,4,4,4] is the same as [4,1,4,4] as a set."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "proper explanation of question is not given, nums needs to be sorted."
                    },
                    {
                        "username": "rakeshks7",
                        "content": "I think you\\'re confusing subset with sub-sequence"
                    },
                    {
                        "username": "lampuiho",
                        "content": "you have [4,4,1,4], and [4,4,4,1] in your output. I fixed my code when I sorted the numbers first so that all the duplicates are grouped together. This is because my recursion relies on a position tracking parameter for skipping the duplicates in subsequent loops."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "There, the catch is to sort the nums array first.\\nThank you."
                    },
                    {
                        "username": "ankitk742",
                        "content": "Thanks bro, helped me allot "
                    },
                    {
                        "username": "athravmehta06",
                        "content": "saved my day .. lol thanks"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "fuck yAAR!THANK HYOU IT WORKED\\n"
                    },
                    {
                        "username": "srapol",
                        "content": "bro how did you come up with it ?? whats the logic??\\nP.S: it worked"
                    },
                    {
                        "username": "mochiball",
                        "content": "Facts. I was running into errors until I sorted. The weird thing is Sets don\\'t seem to account for the unsorted  "
                    },
                    {
                        "username": "Ninjabdul",
                        "content": "thanks bro, stuff like this is why i read discussion post"
                    },
                    {
                        "username": "Oleas",
                        "content": "This problem is NOT asking for the power set of a set. It is asking for all, sorted, unique combinations of the terms in the input. This caused me a great deal of grief. This problem\\'s description should be changed to remove the power set  wording."
                    },
                    {
                        "username": "charonme",
                        "content": "This is clearly wrong. When the array contains duplicates, the duplicate elements are either the same element or they are different elements. If they are the same, then [1, 2, 2] and [1, 2] are the same subset of an array given as [1, 2, 2]. But the problem solution expects both [1, 2] and [1, 2, 2], so clearly the first 2 and the second 2 must be different elements, in which case subsets [1, 2] (with the first 2) and [1, 2] (with the second 2) should be accepted too, but they are not."
                    },
                    {
                        "username": "piyushshah12327",
                        "content": "I went through some of the solutions to understand but why the need to sort?"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "You need to sort the array so, we can compare that previous element is same as current element or not. If you don\\'t sort the array, then it can\\'t find that element is same or different. ex,\\nint[] arr = {1,2,1};\\nhere you can see element at 0 index is equal to element at 2nd index.\\nIf you sort the array.  then it became \\nint[] arr = {1,1,2};\\nnow you can see that element at 0 index and 1 index are same and you can also easily write the code don\\'t run code from start. "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets-ii/solutions/2986411/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "coldz",
                        "content": "Find a way to adapt subset I solution to subsets II problem."
                    },
                    {
                        "username": "rahul_jain89",
                        "content": "I think description is not clear.\\n\\nI guess they want \"each subset should be sorted and unique\".\\n\\nThat\\'s why first we need to sort to input array, so that it will generate sorted subsets,\\nAnd then we can use a set to store the subsets, it will ensure that only unique subsets will be stored to result."
                    },
                    {
                        "username": "OmarNaru",
                        "content": "Idk why we need sorting here :\\nif the given input array is : [3,2,1]\\nthe output if we didn\\'t use sort will be :\\n1\\n2\\n2 1\\n3\\n3 1\\n3 2\\n3 2 1\\n_____________________\\nbut if we used sort it will be :\\n1\\n1 2\\n1 2 3\\n1 3\\n2\\n2 3\\n3\\n\\nit\\'s literally different output, how this even works !?\\nI guess I understood something wrong in the description\\ncan anyone explain ?"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "why sorting of input array is need here?"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "[@yadav_sahil](/yadav_sahil)  that\\'s not correct. It is because there are duplicate subsets [1,4] , [4,1] ,[4,4,1],[4,1,4] and [4,4,4,1],[4,4,1,4]. In the expected the total count of subarray is 10 while in output it is 13."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "Input:\\n[4,4,4,1,4]\\nOutput:\\n[[],[4],[1],[1,4],[4,4],[4,1],[4,1,4],[4,4,4],[4,4,1],[4,4,1,4],[4,4,4,4],[4,4,4,1],[4,4,4,1,4]]\\nExpected:\\n[[],[1],[1,4],[1,4,4],[1,4,4,4],[1,4,4,4,4],[4],[4,4],[4,4,4],[4,4,4,4]]\\nlook in this testcase expected output there is subset 1,4,4,4 which is not possible if 4,4,4,1,4 is not sorted as there is only one 4 after 1.\\n"
                    }
                ]
            },
            {
                "id": 1573304,
                "content": [
                    {
                        "username": "pengel1",
                        "content": "Where does the output should be in sorted order?  This may need further explination or refinement."
                    },
                    {
                        "username": "TerpsX",
                        "content": "Input:\\n[4,4,4,1,4]\\nOutput:\\n[[],[4],[1],[1,4],[4,4],[4,1],[4,1,4],[4,4,4],[4,4,1],[4,4,1,4],[4,4,4,4],[4,4,4,1],[4,4,4,1,4]]\\nExpected:\\n[[],[1],[1,4],[1,4,4],[1,4,4,4],[1,4,4,4,4],[4],[4,4],[4,4,4],[4,4,4,4]]\\n\\nHow come [1,4,4,4] a subset for [4,4,4,1,4]??"
                    },
                    {
                        "username": "2uringTested",
                        "content": "its a subset not a subsequence so [4,4,1,4] is same as [4,4,4,1], the order does not matter and so it should only be counted once."
                    },
                    {
                        "username": "goldenwind",
                        "content": "The subset of a set A is a set that contains some elements of A or all elements of A. If it is a set, the order does not matter. [1,4,4,4] is the same as [4,1,4,4] as a set."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "proper explanation of question is not given, nums needs to be sorted."
                    },
                    {
                        "username": "rakeshks7",
                        "content": "I think you\\'re confusing subset with sub-sequence"
                    },
                    {
                        "username": "lampuiho",
                        "content": "you have [4,4,1,4], and [4,4,4,1] in your output. I fixed my code when I sorted the numbers first so that all the duplicates are grouped together. This is because my recursion relies on a position tracking parameter for skipping the duplicates in subsequent loops."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "There, the catch is to sort the nums array first.\\nThank you."
                    },
                    {
                        "username": "ankitk742",
                        "content": "Thanks bro, helped me allot "
                    },
                    {
                        "username": "athravmehta06",
                        "content": "saved my day .. lol thanks"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "fuck yAAR!THANK HYOU IT WORKED\\n"
                    },
                    {
                        "username": "srapol",
                        "content": "bro how did you come up with it ?? whats the logic??\\nP.S: it worked"
                    },
                    {
                        "username": "mochiball",
                        "content": "Facts. I was running into errors until I sorted. The weird thing is Sets don\\'t seem to account for the unsorted  "
                    },
                    {
                        "username": "Ninjabdul",
                        "content": "thanks bro, stuff like this is why i read discussion post"
                    },
                    {
                        "username": "Oleas",
                        "content": "This problem is NOT asking for the power set of a set. It is asking for all, sorted, unique combinations of the terms in the input. This caused me a great deal of grief. This problem\\'s description should be changed to remove the power set  wording."
                    },
                    {
                        "username": "charonme",
                        "content": "This is clearly wrong. When the array contains duplicates, the duplicate elements are either the same element or they are different elements. If they are the same, then [1, 2, 2] and [1, 2] are the same subset of an array given as [1, 2, 2]. But the problem solution expects both [1, 2] and [1, 2, 2], so clearly the first 2 and the second 2 must be different elements, in which case subsets [1, 2] (with the first 2) and [1, 2] (with the second 2) should be accepted too, but they are not."
                    },
                    {
                        "username": "piyushshah12327",
                        "content": "I went through some of the solutions to understand but why the need to sort?"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "You need to sort the array so, we can compare that previous element is same as current element or not. If you don\\'t sort the array, then it can\\'t find that element is same or different. ex,\\nint[] arr = {1,2,1};\\nhere you can see element at 0 index is equal to element at 2nd index.\\nIf you sort the array.  then it became \\nint[] arr = {1,1,2};\\nnow you can see that element at 0 index and 1 index are same and you can also easily write the code don\\'t run code from start. "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets-ii/solutions/2986411/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "coldz",
                        "content": "Find a way to adapt subset I solution to subsets II problem."
                    },
                    {
                        "username": "rahul_jain89",
                        "content": "I think description is not clear.\\n\\nI guess they want \"each subset should be sorted and unique\".\\n\\nThat\\'s why first we need to sort to input array, so that it will generate sorted subsets,\\nAnd then we can use a set to store the subsets, it will ensure that only unique subsets will be stored to result."
                    },
                    {
                        "username": "OmarNaru",
                        "content": "Idk why we need sorting here :\\nif the given input array is : [3,2,1]\\nthe output if we didn\\'t use sort will be :\\n1\\n2\\n2 1\\n3\\n3 1\\n3 2\\n3 2 1\\n_____________________\\nbut if we used sort it will be :\\n1\\n1 2\\n1 2 3\\n1 3\\n2\\n2 3\\n3\\n\\nit\\'s literally different output, how this even works !?\\nI guess I understood something wrong in the description\\ncan anyone explain ?"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "why sorting of input array is need here?"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "[@yadav_sahil](/yadav_sahil)  that\\'s not correct. It is because there are duplicate subsets [1,4] , [4,1] ,[4,4,1],[4,1,4] and [4,4,4,1],[4,4,1,4]. In the expected the total count of subarray is 10 while in output it is 13."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "Input:\\n[4,4,4,1,4]\\nOutput:\\n[[],[4],[1],[1,4],[4,4],[4,1],[4,1,4],[4,4,4],[4,4,1],[4,4,1,4],[4,4,4,4],[4,4,4,1],[4,4,4,1,4]]\\nExpected:\\n[[],[1],[1,4],[1,4,4],[1,4,4,4],[1,4,4,4,4],[4],[4,4],[4,4,4],[4,4,4,4]]\\nlook in this testcase expected output there is subset 1,4,4,4 which is not possible if 4,4,4,1,4 is not sorted as there is only one 4 after 1.\\n"
                    }
                ]
            },
            {
                "id": 1571200,
                "content": [
                    {
                        "username": "pengel1",
                        "content": "Where does the output should be in sorted order?  This may need further explination or refinement."
                    },
                    {
                        "username": "TerpsX",
                        "content": "Input:\\n[4,4,4,1,4]\\nOutput:\\n[[],[4],[1],[1,4],[4,4],[4,1],[4,1,4],[4,4,4],[4,4,1],[4,4,1,4],[4,4,4,4],[4,4,4,1],[4,4,4,1,4]]\\nExpected:\\n[[],[1],[1,4],[1,4,4],[1,4,4,4],[1,4,4,4,4],[4],[4,4],[4,4,4],[4,4,4,4]]\\n\\nHow come [1,4,4,4] a subset for [4,4,4,1,4]??"
                    },
                    {
                        "username": "2uringTested",
                        "content": "its a subset not a subsequence so [4,4,1,4] is same as [4,4,4,1], the order does not matter and so it should only be counted once."
                    },
                    {
                        "username": "goldenwind",
                        "content": "The subset of a set A is a set that contains some elements of A or all elements of A. If it is a set, the order does not matter. [1,4,4,4] is the same as [4,1,4,4] as a set."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "proper explanation of question is not given, nums needs to be sorted."
                    },
                    {
                        "username": "rakeshks7",
                        "content": "I think you\\'re confusing subset with sub-sequence"
                    },
                    {
                        "username": "lampuiho",
                        "content": "you have [4,4,1,4], and [4,4,4,1] in your output. I fixed my code when I sorted the numbers first so that all the duplicates are grouped together. This is because my recursion relies on a position tracking parameter for skipping the duplicates in subsequent loops."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "There, the catch is to sort the nums array first.\\nThank you."
                    },
                    {
                        "username": "ankitk742",
                        "content": "Thanks bro, helped me allot "
                    },
                    {
                        "username": "athravmehta06",
                        "content": "saved my day .. lol thanks"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "fuck yAAR!THANK HYOU IT WORKED\\n"
                    },
                    {
                        "username": "srapol",
                        "content": "bro how did you come up with it ?? whats the logic??\\nP.S: it worked"
                    },
                    {
                        "username": "mochiball",
                        "content": "Facts. I was running into errors until I sorted. The weird thing is Sets don\\'t seem to account for the unsorted  "
                    },
                    {
                        "username": "Ninjabdul",
                        "content": "thanks bro, stuff like this is why i read discussion post"
                    },
                    {
                        "username": "Oleas",
                        "content": "This problem is NOT asking for the power set of a set. It is asking for all, sorted, unique combinations of the terms in the input. This caused me a great deal of grief. This problem\\'s description should be changed to remove the power set  wording."
                    },
                    {
                        "username": "charonme",
                        "content": "This is clearly wrong. When the array contains duplicates, the duplicate elements are either the same element or they are different elements. If they are the same, then [1, 2, 2] and [1, 2] are the same subset of an array given as [1, 2, 2]. But the problem solution expects both [1, 2] and [1, 2, 2], so clearly the first 2 and the second 2 must be different elements, in which case subsets [1, 2] (with the first 2) and [1, 2] (with the second 2) should be accepted too, but they are not."
                    },
                    {
                        "username": "piyushshah12327",
                        "content": "I went through some of the solutions to understand but why the need to sort?"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "You need to sort the array so, we can compare that previous element is same as current element or not. If you don\\'t sort the array, then it can\\'t find that element is same or different. ex,\\nint[] arr = {1,2,1};\\nhere you can see element at 0 index is equal to element at 2nd index.\\nIf you sort the array.  then it became \\nint[] arr = {1,1,2};\\nnow you can see that element at 0 index and 1 index are same and you can also easily write the code don\\'t run code from start. "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets-ii/solutions/2986411/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "coldz",
                        "content": "Find a way to adapt subset I solution to subsets II problem."
                    },
                    {
                        "username": "rahul_jain89",
                        "content": "I think description is not clear.\\n\\nI guess they want \"each subset should be sorted and unique\".\\n\\nThat\\'s why first we need to sort to input array, so that it will generate sorted subsets,\\nAnd then we can use a set to store the subsets, it will ensure that only unique subsets will be stored to result."
                    },
                    {
                        "username": "OmarNaru",
                        "content": "Idk why we need sorting here :\\nif the given input array is : [3,2,1]\\nthe output if we didn\\'t use sort will be :\\n1\\n2\\n2 1\\n3\\n3 1\\n3 2\\n3 2 1\\n_____________________\\nbut if we used sort it will be :\\n1\\n1 2\\n1 2 3\\n1 3\\n2\\n2 3\\n3\\n\\nit\\'s literally different output, how this even works !?\\nI guess I understood something wrong in the description\\ncan anyone explain ?"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "why sorting of input array is need here?"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "[@yadav_sahil](/yadav_sahil)  that\\'s not correct. It is because there are duplicate subsets [1,4] , [4,1] ,[4,4,1],[4,1,4] and [4,4,4,1],[4,4,1,4]. In the expected the total count of subarray is 10 while in output it is 13."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "Input:\\n[4,4,4,1,4]\\nOutput:\\n[[],[4],[1],[1,4],[4,4],[4,1],[4,1,4],[4,4,4],[4,4,1],[4,4,1,4],[4,4,4,4],[4,4,4,1],[4,4,4,1,4]]\\nExpected:\\n[[],[1],[1,4],[1,4,4],[1,4,4,4],[1,4,4,4,4],[4],[4,4],[4,4,4],[4,4,4,4]]\\nlook in this testcase expected output there is subset 1,4,4,4 which is not possible if 4,4,4,1,4 is not sorted as there is only one 4 after 1.\\n"
                    }
                ]
            },
            {
                "id": 1976912,
                "content": [
                    {
                        "username": "pengel1",
                        "content": "Where does the output should be in sorted order?  This may need further explination or refinement."
                    },
                    {
                        "username": "TerpsX",
                        "content": "Input:\\n[4,4,4,1,4]\\nOutput:\\n[[],[4],[1],[1,4],[4,4],[4,1],[4,1,4],[4,4,4],[4,4,1],[4,4,1,4],[4,4,4,4],[4,4,4,1],[4,4,4,1,4]]\\nExpected:\\n[[],[1],[1,4],[1,4,4],[1,4,4,4],[1,4,4,4,4],[4],[4,4],[4,4,4],[4,4,4,4]]\\n\\nHow come [1,4,4,4] a subset for [4,4,4,1,4]??"
                    },
                    {
                        "username": "2uringTested",
                        "content": "its a subset not a subsequence so [4,4,1,4] is same as [4,4,4,1], the order does not matter and so it should only be counted once."
                    },
                    {
                        "username": "goldenwind",
                        "content": "The subset of a set A is a set that contains some elements of A or all elements of A. If it is a set, the order does not matter. [1,4,4,4] is the same as [4,1,4,4] as a set."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "proper explanation of question is not given, nums needs to be sorted."
                    },
                    {
                        "username": "rakeshks7",
                        "content": "I think you\\'re confusing subset with sub-sequence"
                    },
                    {
                        "username": "lampuiho",
                        "content": "you have [4,4,1,4], and [4,4,4,1] in your output. I fixed my code when I sorted the numbers first so that all the duplicates are grouped together. This is because my recursion relies on a position tracking parameter for skipping the duplicates in subsequent loops."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "There, the catch is to sort the nums array first.\\nThank you."
                    },
                    {
                        "username": "ankitk742",
                        "content": "Thanks bro, helped me allot "
                    },
                    {
                        "username": "athravmehta06",
                        "content": "saved my day .. lol thanks"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "fuck yAAR!THANK HYOU IT WORKED\\n"
                    },
                    {
                        "username": "srapol",
                        "content": "bro how did you come up with it ?? whats the logic??\\nP.S: it worked"
                    },
                    {
                        "username": "mochiball",
                        "content": "Facts. I was running into errors until I sorted. The weird thing is Sets don\\'t seem to account for the unsorted  "
                    },
                    {
                        "username": "Ninjabdul",
                        "content": "thanks bro, stuff like this is why i read discussion post"
                    },
                    {
                        "username": "Oleas",
                        "content": "This problem is NOT asking for the power set of a set. It is asking for all, sorted, unique combinations of the terms in the input. This caused me a great deal of grief. This problem\\'s description should be changed to remove the power set  wording."
                    },
                    {
                        "username": "charonme",
                        "content": "This is clearly wrong. When the array contains duplicates, the duplicate elements are either the same element or they are different elements. If they are the same, then [1, 2, 2] and [1, 2] are the same subset of an array given as [1, 2, 2]. But the problem solution expects both [1, 2] and [1, 2, 2], so clearly the first 2 and the second 2 must be different elements, in which case subsets [1, 2] (with the first 2) and [1, 2] (with the second 2) should be accepted too, but they are not."
                    },
                    {
                        "username": "piyushshah12327",
                        "content": "I went through some of the solutions to understand but why the need to sort?"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "You need to sort the array so, we can compare that previous element is same as current element or not. If you don\\'t sort the array, then it can\\'t find that element is same or different. ex,\\nint[] arr = {1,2,1};\\nhere you can see element at 0 index is equal to element at 2nd index.\\nIf you sort the array.  then it became \\nint[] arr = {1,1,2};\\nnow you can see that element at 0 index and 1 index are same and you can also easily write the code don\\'t run code from start. "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets-ii/solutions/2986411/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "coldz",
                        "content": "Find a way to adapt subset I solution to subsets II problem."
                    },
                    {
                        "username": "rahul_jain89",
                        "content": "I think description is not clear.\\n\\nI guess they want \"each subset should be sorted and unique\".\\n\\nThat\\'s why first we need to sort to input array, so that it will generate sorted subsets,\\nAnd then we can use a set to store the subsets, it will ensure that only unique subsets will be stored to result."
                    },
                    {
                        "username": "OmarNaru",
                        "content": "Idk why we need sorting here :\\nif the given input array is : [3,2,1]\\nthe output if we didn\\'t use sort will be :\\n1\\n2\\n2 1\\n3\\n3 1\\n3 2\\n3 2 1\\n_____________________\\nbut if we used sort it will be :\\n1\\n1 2\\n1 2 3\\n1 3\\n2\\n2 3\\n3\\n\\nit\\'s literally different output, how this even works !?\\nI guess I understood something wrong in the description\\ncan anyone explain ?"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "why sorting of input array is need here?"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "[@yadav_sahil](/yadav_sahil)  that\\'s not correct. It is because there are duplicate subsets [1,4] , [4,1] ,[4,4,1],[4,1,4] and [4,4,4,1],[4,4,1,4]. In the expected the total count of subarray is 10 while in output it is 13."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "Input:\\n[4,4,4,1,4]\\nOutput:\\n[[],[4],[1],[1,4],[4,4],[4,1],[4,1,4],[4,4,4],[4,4,1],[4,4,1,4],[4,4,4,4],[4,4,4,1],[4,4,4,1,4]]\\nExpected:\\n[[],[1],[1,4],[1,4,4],[1,4,4,4],[1,4,4,4,4],[4],[4,4],[4,4,4],[4,4,4,4]]\\nlook in this testcase expected output there is subset 1,4,4,4 which is not possible if 4,4,4,1,4 is not sorted as there is only one 4 after 1.\\n"
                    }
                ]
            },
            {
                "id": 2001079,
                "content": [
                    {
                        "username": "pengel1",
                        "content": "Where does the output should be in sorted order?  This may need further explination or refinement."
                    },
                    {
                        "username": "TerpsX",
                        "content": "Input:\\n[4,4,4,1,4]\\nOutput:\\n[[],[4],[1],[1,4],[4,4],[4,1],[4,1,4],[4,4,4],[4,4,1],[4,4,1,4],[4,4,4,4],[4,4,4,1],[4,4,4,1,4]]\\nExpected:\\n[[],[1],[1,4],[1,4,4],[1,4,4,4],[1,4,4,4,4],[4],[4,4],[4,4,4],[4,4,4,4]]\\n\\nHow come [1,4,4,4] a subset for [4,4,4,1,4]??"
                    },
                    {
                        "username": "2uringTested",
                        "content": "its a subset not a subsequence so [4,4,1,4] is same as [4,4,4,1], the order does not matter and so it should only be counted once."
                    },
                    {
                        "username": "goldenwind",
                        "content": "The subset of a set A is a set that contains some elements of A or all elements of A. If it is a set, the order does not matter. [1,4,4,4] is the same as [4,1,4,4] as a set."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "proper explanation of question is not given, nums needs to be sorted."
                    },
                    {
                        "username": "rakeshks7",
                        "content": "I think you\\'re confusing subset with sub-sequence"
                    },
                    {
                        "username": "lampuiho",
                        "content": "you have [4,4,1,4], and [4,4,4,1] in your output. I fixed my code when I sorted the numbers first so that all the duplicates are grouped together. This is because my recursion relies on a position tracking parameter for skipping the duplicates in subsequent loops."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "There, the catch is to sort the nums array first.\\nThank you."
                    },
                    {
                        "username": "ankitk742",
                        "content": "Thanks bro, helped me allot "
                    },
                    {
                        "username": "athravmehta06",
                        "content": "saved my day .. lol thanks"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "fuck yAAR!THANK HYOU IT WORKED\\n"
                    },
                    {
                        "username": "srapol",
                        "content": "bro how did you come up with it ?? whats the logic??\\nP.S: it worked"
                    },
                    {
                        "username": "mochiball",
                        "content": "Facts. I was running into errors until I sorted. The weird thing is Sets don\\'t seem to account for the unsorted  "
                    },
                    {
                        "username": "Ninjabdul",
                        "content": "thanks bro, stuff like this is why i read discussion post"
                    },
                    {
                        "username": "Oleas",
                        "content": "This problem is NOT asking for the power set of a set. It is asking for all, sorted, unique combinations of the terms in the input. This caused me a great deal of grief. This problem\\'s description should be changed to remove the power set  wording."
                    },
                    {
                        "username": "charonme",
                        "content": "This is clearly wrong. When the array contains duplicates, the duplicate elements are either the same element or they are different elements. If they are the same, then [1, 2, 2] and [1, 2] are the same subset of an array given as [1, 2, 2]. But the problem solution expects both [1, 2] and [1, 2, 2], so clearly the first 2 and the second 2 must be different elements, in which case subsets [1, 2] (with the first 2) and [1, 2] (with the second 2) should be accepted too, but they are not."
                    },
                    {
                        "username": "piyushshah12327",
                        "content": "I went through some of the solutions to understand but why the need to sort?"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "You need to sort the array so, we can compare that previous element is same as current element or not. If you don\\'t sort the array, then it can\\'t find that element is same or different. ex,\\nint[] arr = {1,2,1};\\nhere you can see element at 0 index is equal to element at 2nd index.\\nIf you sort the array.  then it became \\nint[] arr = {1,1,2};\\nnow you can see that element at 0 index and 1 index are same and you can also easily write the code don\\'t run code from start. "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets-ii/solutions/2986411/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "coldz",
                        "content": "Find a way to adapt subset I solution to subsets II problem."
                    },
                    {
                        "username": "rahul_jain89",
                        "content": "I think description is not clear.\\n\\nI guess they want \"each subset should be sorted and unique\".\\n\\nThat\\'s why first we need to sort to input array, so that it will generate sorted subsets,\\nAnd then we can use a set to store the subsets, it will ensure that only unique subsets will be stored to result."
                    },
                    {
                        "username": "OmarNaru",
                        "content": "Idk why we need sorting here :\\nif the given input array is : [3,2,1]\\nthe output if we didn\\'t use sort will be :\\n1\\n2\\n2 1\\n3\\n3 1\\n3 2\\n3 2 1\\n_____________________\\nbut if we used sort it will be :\\n1\\n1 2\\n1 2 3\\n1 3\\n2\\n2 3\\n3\\n\\nit\\'s literally different output, how this even works !?\\nI guess I understood something wrong in the description\\ncan anyone explain ?"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "why sorting of input array is need here?"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "[@yadav_sahil](/yadav_sahil)  that\\'s not correct. It is because there are duplicate subsets [1,4] , [4,1] ,[4,4,1],[4,1,4] and [4,4,4,1],[4,4,1,4]. In the expected the total count of subarray is 10 while in output it is 13."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "Input:\\n[4,4,4,1,4]\\nOutput:\\n[[],[4],[1],[1,4],[4,4],[4,1],[4,1,4],[4,4,4],[4,4,1],[4,4,1,4],[4,4,4,4],[4,4,4,1],[4,4,4,1,4]]\\nExpected:\\n[[],[1],[1,4],[1,4,4],[1,4,4,4],[1,4,4,4,4],[4],[4,4],[4,4,4],[4,4,4,4]]\\nlook in this testcase expected output there is subset 1,4,4,4 which is not possible if 4,4,4,1,4 is not sorted as there is only one 4 after 1.\\n"
                    }
                ]
            },
            {
                "id": 1760164,
                "content": [
                    {
                        "username": "pengel1",
                        "content": "Where does the output should be in sorted order?  This may need further explination or refinement."
                    },
                    {
                        "username": "TerpsX",
                        "content": "Input:\\n[4,4,4,1,4]\\nOutput:\\n[[],[4],[1],[1,4],[4,4],[4,1],[4,1,4],[4,4,4],[4,4,1],[4,4,1,4],[4,4,4,4],[4,4,4,1],[4,4,4,1,4]]\\nExpected:\\n[[],[1],[1,4],[1,4,4],[1,4,4,4],[1,4,4,4,4],[4],[4,4],[4,4,4],[4,4,4,4]]\\n\\nHow come [1,4,4,4] a subset for [4,4,4,1,4]??"
                    },
                    {
                        "username": "2uringTested",
                        "content": "its a subset not a subsequence so [4,4,1,4] is same as [4,4,4,1], the order does not matter and so it should only be counted once."
                    },
                    {
                        "username": "goldenwind",
                        "content": "The subset of a set A is a set that contains some elements of A or all elements of A. If it is a set, the order does not matter. [1,4,4,4] is the same as [4,1,4,4] as a set."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "proper explanation of question is not given, nums needs to be sorted."
                    },
                    {
                        "username": "rakeshks7",
                        "content": "I think you\\'re confusing subset with sub-sequence"
                    },
                    {
                        "username": "lampuiho",
                        "content": "you have [4,4,1,4], and [4,4,4,1] in your output. I fixed my code when I sorted the numbers first so that all the duplicates are grouped together. This is because my recursion relies on a position tracking parameter for skipping the duplicates in subsequent loops."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "There, the catch is to sort the nums array first.\\nThank you."
                    },
                    {
                        "username": "ankitk742",
                        "content": "Thanks bro, helped me allot "
                    },
                    {
                        "username": "athravmehta06",
                        "content": "saved my day .. lol thanks"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "fuck yAAR!THANK HYOU IT WORKED\\n"
                    },
                    {
                        "username": "srapol",
                        "content": "bro how did you come up with it ?? whats the logic??\\nP.S: it worked"
                    },
                    {
                        "username": "mochiball",
                        "content": "Facts. I was running into errors until I sorted. The weird thing is Sets don\\'t seem to account for the unsorted  "
                    },
                    {
                        "username": "Ninjabdul",
                        "content": "thanks bro, stuff like this is why i read discussion post"
                    },
                    {
                        "username": "Oleas",
                        "content": "This problem is NOT asking for the power set of a set. It is asking for all, sorted, unique combinations of the terms in the input. This caused me a great deal of grief. This problem\\'s description should be changed to remove the power set  wording."
                    },
                    {
                        "username": "charonme",
                        "content": "This is clearly wrong. When the array contains duplicates, the duplicate elements are either the same element or they are different elements. If they are the same, then [1, 2, 2] and [1, 2] are the same subset of an array given as [1, 2, 2]. But the problem solution expects both [1, 2] and [1, 2, 2], so clearly the first 2 and the second 2 must be different elements, in which case subsets [1, 2] (with the first 2) and [1, 2] (with the second 2) should be accepted too, but they are not."
                    },
                    {
                        "username": "piyushshah12327",
                        "content": "I went through some of the solutions to understand but why the need to sort?"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "You need to sort the array so, we can compare that previous element is same as current element or not. If you don\\'t sort the array, then it can\\'t find that element is same or different. ex,\\nint[] arr = {1,2,1};\\nhere you can see element at 0 index is equal to element at 2nd index.\\nIf you sort the array.  then it became \\nint[] arr = {1,1,2};\\nnow you can see that element at 0 index and 1 index are same and you can also easily write the code don\\'t run code from start. "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets-ii/solutions/2986411/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "coldz",
                        "content": "Find a way to adapt subset I solution to subsets II problem."
                    },
                    {
                        "username": "rahul_jain89",
                        "content": "I think description is not clear.\\n\\nI guess they want \"each subset should be sorted and unique\".\\n\\nThat\\'s why first we need to sort to input array, so that it will generate sorted subsets,\\nAnd then we can use a set to store the subsets, it will ensure that only unique subsets will be stored to result."
                    },
                    {
                        "username": "OmarNaru",
                        "content": "Idk why we need sorting here :\\nif the given input array is : [3,2,1]\\nthe output if we didn\\'t use sort will be :\\n1\\n2\\n2 1\\n3\\n3 1\\n3 2\\n3 2 1\\n_____________________\\nbut if we used sort it will be :\\n1\\n1 2\\n1 2 3\\n1 3\\n2\\n2 3\\n3\\n\\nit\\'s literally different output, how this even works !?\\nI guess I understood something wrong in the description\\ncan anyone explain ?"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "why sorting of input array is need here?"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "[@yadav_sahil](/yadav_sahil)  that\\'s not correct. It is because there are duplicate subsets [1,4] , [4,1] ,[4,4,1],[4,1,4] and [4,4,4,1],[4,4,1,4]. In the expected the total count of subarray is 10 while in output it is 13."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "Input:\\n[4,4,4,1,4]\\nOutput:\\n[[],[4],[1],[1,4],[4,4],[4,1],[4,1,4],[4,4,4],[4,4,1],[4,4,1,4],[4,4,4,4],[4,4,4,1],[4,4,4,1,4]]\\nExpected:\\n[[],[1],[1,4],[1,4,4],[1,4,4,4],[1,4,4,4,4],[4],[4,4],[4,4,4],[4,4,4,4]]\\nlook in this testcase expected output there is subset 1,4,4,4 which is not possible if 4,4,4,1,4 is not sorted as there is only one 4 after 1.\\n"
                    }
                ]
            },
            {
                "id": 1572090,
                "content": [
                    {
                        "username": "zhanghuimeng",
                        "content": "I think it is obvious that, for an empty set, its power set should be a set containing an empty set. (`P({}) = { {} }`) \\uFF08[What is the power set of the empty set](https://www.quora.com/What-is-the-power-set-of-the-empty-set-emptyset)\\uFF09Which means, if the input is `[]`, we need to return `[[]]`. Most implementations here follow this pattern, like [this](https://leetcode.com/problems/subsets-ii/discuss/30168/C++-solution-and-explanation) and [that](https://leetcode.com/problems/subsets-ii/discuss/30137/Simple-iterative-solution).\\n\\nBut in the run code section, the \"Expected Answer\" doesn\\'t think so.\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/zhanghuimeng1997/image_1534623169.png)\\n\\nThese codes above can pass, of course; when I make an special judgement for `[]` so that it outputs `[]`, I can still pass. So the OJ didn\\'t check for input `[]` at all. Also, I think there is a bug in the \"Expected Answer\" example program.\\n"
                    },
                    {
                        "username": "greatgrahambini",
                        "content": "A set is by definition, a collection of unique items."
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "A set is a collection of unordered items"
                    },
                    {
                        "username": "jaggz01",
                        "content": "Pre-requisite solve Permutation-I, Permutation-II, and Subset-I and this problem will be easy walk for you."
                    },
                    {
                        "username": "admiremeforever",
                        "content": "The problem description seems to be incorrect -"
                    },
                    {
                        "username": "ruchita1010",
                        "content": "Why is that a set results in wrong output? Given that in C++, set stores elements in sorted order! My code couldn\\'t pass from this test case - [4,4,4,1,4]. But after sorting the vector before passing it in the recursive function, it was accepted?!"
                    },
                    {
                        "username": "sk315425",
                        "content": "Input:\\n[4,4,4,1,4]\\nOutput:\\n[[],[4],[1],[1,4],[4,4],[4,1],[4,1,4],[4,4,4],[4,4,1],[4,4,1,4],[4,4,4,4],[4,4,4,1],[4,4,4,1,4]]\\nExpected:\\n[[],[1],[1,4],[1,4,4],[1,4,4,4],[1,4,4,4,4],[4],[4,4],[4,4,4],[4,4,4,4]]\\n\\narray need to be sorted for this ! \\n"
                    },
                    {
                        "username": "Tanya__",
                        "content": "provided description is incorrect\nExpected output =>return list  all sorted order and unique possible subsets"
                    },
                    {
                        "username": "birindersinghji",
                        "content": "Extremely poor question description. You need to constantly submit and find out what the question wants from the test cases instead of the description."
                    },
                    {
                        "username": "uma_gadde",
                        "content": "like seriouslyyy!!!\\nsorted ordered!! problem desc should be changed:("
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "Why the function name is subsetsWithDup , it should be without right  :)"
                    }
                ]
            },
            {
                "id": 1568913,
                "content": [
                    {
                        "username": "zhanghuimeng",
                        "content": "I think it is obvious that, for an empty set, its power set should be a set containing an empty set. (`P({}) = { {} }`) \\uFF08[What is the power set of the empty set](https://www.quora.com/What-is-the-power-set-of-the-empty-set-emptyset)\\uFF09Which means, if the input is `[]`, we need to return `[[]]`. Most implementations here follow this pattern, like [this](https://leetcode.com/problems/subsets-ii/discuss/30168/C++-solution-and-explanation) and [that](https://leetcode.com/problems/subsets-ii/discuss/30137/Simple-iterative-solution).\\n\\nBut in the run code section, the \"Expected Answer\" doesn\\'t think so.\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/zhanghuimeng1997/image_1534623169.png)\\n\\nThese codes above can pass, of course; when I make an special judgement for `[]` so that it outputs `[]`, I can still pass. So the OJ didn\\'t check for input `[]` at all. Also, I think there is a bug in the \"Expected Answer\" example program.\\n"
                    },
                    {
                        "username": "greatgrahambini",
                        "content": "A set is by definition, a collection of unique items."
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "A set is a collection of unordered items"
                    },
                    {
                        "username": "jaggz01",
                        "content": "Pre-requisite solve Permutation-I, Permutation-II, and Subset-I and this problem will be easy walk for you."
                    },
                    {
                        "username": "admiremeforever",
                        "content": "The problem description seems to be incorrect -"
                    },
                    {
                        "username": "ruchita1010",
                        "content": "Why is that a set results in wrong output? Given that in C++, set stores elements in sorted order! My code couldn\\'t pass from this test case - [4,4,4,1,4]. But after sorting the vector before passing it in the recursive function, it was accepted?!"
                    },
                    {
                        "username": "sk315425",
                        "content": "Input:\\n[4,4,4,1,4]\\nOutput:\\n[[],[4],[1],[1,4],[4,4],[4,1],[4,1,4],[4,4,4],[4,4,1],[4,4,1,4],[4,4,4,4],[4,4,4,1],[4,4,4,1,4]]\\nExpected:\\n[[],[1],[1,4],[1,4,4],[1,4,4,4],[1,4,4,4,4],[4],[4,4],[4,4,4],[4,4,4,4]]\\n\\narray need to be sorted for this ! \\n"
                    },
                    {
                        "username": "Tanya__",
                        "content": "provided description is incorrect\nExpected output =>return list  all sorted order and unique possible subsets"
                    },
                    {
                        "username": "birindersinghji",
                        "content": "Extremely poor question description. You need to constantly submit and find out what the question wants from the test cases instead of the description."
                    },
                    {
                        "username": "uma_gadde",
                        "content": "like seriouslyyy!!!\\nsorted ordered!! problem desc should be changed:("
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "Why the function name is subsetsWithDup , it should be without right  :)"
                    }
                ]
            },
            {
                "id": 2070774,
                "content": [
                    {
                        "username": "zhanghuimeng",
                        "content": "I think it is obvious that, for an empty set, its power set should be a set containing an empty set. (`P({}) = { {} }`) \\uFF08[What is the power set of the empty set](https://www.quora.com/What-is-the-power-set-of-the-empty-set-emptyset)\\uFF09Which means, if the input is `[]`, we need to return `[[]]`. Most implementations here follow this pattern, like [this](https://leetcode.com/problems/subsets-ii/discuss/30168/C++-solution-and-explanation) and [that](https://leetcode.com/problems/subsets-ii/discuss/30137/Simple-iterative-solution).\\n\\nBut in the run code section, the \"Expected Answer\" doesn\\'t think so.\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/zhanghuimeng1997/image_1534623169.png)\\n\\nThese codes above can pass, of course; when I make an special judgement for `[]` so that it outputs `[]`, I can still pass. So the OJ didn\\'t check for input `[]` at all. Also, I think there is a bug in the \"Expected Answer\" example program.\\n"
                    },
                    {
                        "username": "greatgrahambini",
                        "content": "A set is by definition, a collection of unique items."
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "A set is a collection of unordered items"
                    },
                    {
                        "username": "jaggz01",
                        "content": "Pre-requisite solve Permutation-I, Permutation-II, and Subset-I and this problem will be easy walk for you."
                    },
                    {
                        "username": "admiremeforever",
                        "content": "The problem description seems to be incorrect -"
                    },
                    {
                        "username": "ruchita1010",
                        "content": "Why is that a set results in wrong output? Given that in C++, set stores elements in sorted order! My code couldn\\'t pass from this test case - [4,4,4,1,4]. But after sorting the vector before passing it in the recursive function, it was accepted?!"
                    },
                    {
                        "username": "sk315425",
                        "content": "Input:\\n[4,4,4,1,4]\\nOutput:\\n[[],[4],[1],[1,4],[4,4],[4,1],[4,1,4],[4,4,4],[4,4,1],[4,4,1,4],[4,4,4,4],[4,4,4,1],[4,4,4,1,4]]\\nExpected:\\n[[],[1],[1,4],[1,4,4],[1,4,4,4],[1,4,4,4,4],[4],[4,4],[4,4,4],[4,4,4,4]]\\n\\narray need to be sorted for this ! \\n"
                    },
                    {
                        "username": "Tanya__",
                        "content": "provided description is incorrect\nExpected output =>return list  all sorted order and unique possible subsets"
                    },
                    {
                        "username": "birindersinghji",
                        "content": "Extremely poor question description. You need to constantly submit and find out what the question wants from the test cases instead of the description."
                    },
                    {
                        "username": "uma_gadde",
                        "content": "like seriouslyyy!!!\\nsorted ordered!! problem desc should be changed:("
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "Why the function name is subsetsWithDup , it should be without right  :)"
                    }
                ]
            },
            {
                "id": 2059050,
                "content": [
                    {
                        "username": "zhanghuimeng",
                        "content": "I think it is obvious that, for an empty set, its power set should be a set containing an empty set. (`P({}) = { {} }`) \\uFF08[What is the power set of the empty set](https://www.quora.com/What-is-the-power-set-of-the-empty-set-emptyset)\\uFF09Which means, if the input is `[]`, we need to return `[[]]`. Most implementations here follow this pattern, like [this](https://leetcode.com/problems/subsets-ii/discuss/30168/C++-solution-and-explanation) and [that](https://leetcode.com/problems/subsets-ii/discuss/30137/Simple-iterative-solution).\\n\\nBut in the run code section, the \"Expected Answer\" doesn\\'t think so.\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/zhanghuimeng1997/image_1534623169.png)\\n\\nThese codes above can pass, of course; when I make an special judgement for `[]` so that it outputs `[]`, I can still pass. So the OJ didn\\'t check for input `[]` at all. Also, I think there is a bug in the \"Expected Answer\" example program.\\n"
                    },
                    {
                        "username": "greatgrahambini",
                        "content": "A set is by definition, a collection of unique items."
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "A set is a collection of unordered items"
                    },
                    {
                        "username": "jaggz01",
                        "content": "Pre-requisite solve Permutation-I, Permutation-II, and Subset-I and this problem will be easy walk for you."
                    },
                    {
                        "username": "admiremeforever",
                        "content": "The problem description seems to be incorrect -"
                    },
                    {
                        "username": "ruchita1010",
                        "content": "Why is that a set results in wrong output? Given that in C++, set stores elements in sorted order! My code couldn\\'t pass from this test case - [4,4,4,1,4]. But after sorting the vector before passing it in the recursive function, it was accepted?!"
                    },
                    {
                        "username": "sk315425",
                        "content": "Input:\\n[4,4,4,1,4]\\nOutput:\\n[[],[4],[1],[1,4],[4,4],[4,1],[4,1,4],[4,4,4],[4,4,1],[4,4,1,4],[4,4,4,4],[4,4,4,1],[4,4,4,1,4]]\\nExpected:\\n[[],[1],[1,4],[1,4,4],[1,4,4,4],[1,4,4,4,4],[4],[4,4],[4,4,4],[4,4,4,4]]\\n\\narray need to be sorted for this ! \\n"
                    },
                    {
                        "username": "Tanya__",
                        "content": "provided description is incorrect\nExpected output =>return list  all sorted order and unique possible subsets"
                    },
                    {
                        "username": "birindersinghji",
                        "content": "Extremely poor question description. You need to constantly submit and find out what the question wants from the test cases instead of the description."
                    },
                    {
                        "username": "uma_gadde",
                        "content": "like seriouslyyy!!!\\nsorted ordered!! problem desc should be changed:("
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "Why the function name is subsetsWithDup , it should be without right  :)"
                    }
                ]
            },
            {
                "id": 2052359,
                "content": [
                    {
                        "username": "zhanghuimeng",
                        "content": "I think it is obvious that, for an empty set, its power set should be a set containing an empty set. (`P({}) = { {} }`) \\uFF08[What is the power set of the empty set](https://www.quora.com/What-is-the-power-set-of-the-empty-set-emptyset)\\uFF09Which means, if the input is `[]`, we need to return `[[]]`. Most implementations here follow this pattern, like [this](https://leetcode.com/problems/subsets-ii/discuss/30168/C++-solution-and-explanation) and [that](https://leetcode.com/problems/subsets-ii/discuss/30137/Simple-iterative-solution).\\n\\nBut in the run code section, the \"Expected Answer\" doesn\\'t think so.\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/zhanghuimeng1997/image_1534623169.png)\\n\\nThese codes above can pass, of course; when I make an special judgement for `[]` so that it outputs `[]`, I can still pass. So the OJ didn\\'t check for input `[]` at all. Also, I think there is a bug in the \"Expected Answer\" example program.\\n"
                    },
                    {
                        "username": "greatgrahambini",
                        "content": "A set is by definition, a collection of unique items."
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "A set is a collection of unordered items"
                    },
                    {
                        "username": "jaggz01",
                        "content": "Pre-requisite solve Permutation-I, Permutation-II, and Subset-I and this problem will be easy walk for you."
                    },
                    {
                        "username": "admiremeforever",
                        "content": "The problem description seems to be incorrect -"
                    },
                    {
                        "username": "ruchita1010",
                        "content": "Why is that a set results in wrong output? Given that in C++, set stores elements in sorted order! My code couldn\\'t pass from this test case - [4,4,4,1,4]. But after sorting the vector before passing it in the recursive function, it was accepted?!"
                    },
                    {
                        "username": "sk315425",
                        "content": "Input:\\n[4,4,4,1,4]\\nOutput:\\n[[],[4],[1],[1,4],[4,4],[4,1],[4,1,4],[4,4,4],[4,4,1],[4,4,1,4],[4,4,4,4],[4,4,4,1],[4,4,4,1,4]]\\nExpected:\\n[[],[1],[1,4],[1,4,4],[1,4,4,4],[1,4,4,4,4],[4],[4,4],[4,4,4],[4,4,4,4]]\\n\\narray need to be sorted for this ! \\n"
                    },
                    {
                        "username": "Tanya__",
                        "content": "provided description is incorrect\nExpected output =>return list  all sorted order and unique possible subsets"
                    },
                    {
                        "username": "birindersinghji",
                        "content": "Extremely poor question description. You need to constantly submit and find out what the question wants from the test cases instead of the description."
                    },
                    {
                        "username": "uma_gadde",
                        "content": "like seriouslyyy!!!\\nsorted ordered!! problem desc should be changed:("
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "Why the function name is subsetsWithDup , it should be without right  :)"
                    }
                ]
            },
            {
                "id": 2013448,
                "content": [
                    {
                        "username": "zhanghuimeng",
                        "content": "I think it is obvious that, for an empty set, its power set should be a set containing an empty set. (`P({}) = { {} }`) \\uFF08[What is the power set of the empty set](https://www.quora.com/What-is-the-power-set-of-the-empty-set-emptyset)\\uFF09Which means, if the input is `[]`, we need to return `[[]]`. Most implementations here follow this pattern, like [this](https://leetcode.com/problems/subsets-ii/discuss/30168/C++-solution-and-explanation) and [that](https://leetcode.com/problems/subsets-ii/discuss/30137/Simple-iterative-solution).\\n\\nBut in the run code section, the \"Expected Answer\" doesn\\'t think so.\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/zhanghuimeng1997/image_1534623169.png)\\n\\nThese codes above can pass, of course; when I make an special judgement for `[]` so that it outputs `[]`, I can still pass. So the OJ didn\\'t check for input `[]` at all. Also, I think there is a bug in the \"Expected Answer\" example program.\\n"
                    },
                    {
                        "username": "greatgrahambini",
                        "content": "A set is by definition, a collection of unique items."
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "A set is a collection of unordered items"
                    },
                    {
                        "username": "jaggz01",
                        "content": "Pre-requisite solve Permutation-I, Permutation-II, and Subset-I and this problem will be easy walk for you."
                    },
                    {
                        "username": "admiremeforever",
                        "content": "The problem description seems to be incorrect -"
                    },
                    {
                        "username": "ruchita1010",
                        "content": "Why is that a set results in wrong output? Given that in C++, set stores elements in sorted order! My code couldn\\'t pass from this test case - [4,4,4,1,4]. But after sorting the vector before passing it in the recursive function, it was accepted?!"
                    },
                    {
                        "username": "sk315425",
                        "content": "Input:\\n[4,4,4,1,4]\\nOutput:\\n[[],[4],[1],[1,4],[4,4],[4,1],[4,1,4],[4,4,4],[4,4,1],[4,4,1,4],[4,4,4,4],[4,4,4,1],[4,4,4,1,4]]\\nExpected:\\n[[],[1],[1,4],[1,4,4],[1,4,4,4],[1,4,4,4,4],[4],[4,4],[4,4,4],[4,4,4,4]]\\n\\narray need to be sorted for this ! \\n"
                    },
                    {
                        "username": "Tanya__",
                        "content": "provided description is incorrect\nExpected output =>return list  all sorted order and unique possible subsets"
                    },
                    {
                        "username": "birindersinghji",
                        "content": "Extremely poor question description. You need to constantly submit and find out what the question wants from the test cases instead of the description."
                    },
                    {
                        "username": "uma_gadde",
                        "content": "like seriouslyyy!!!\\nsorted ordered!! problem desc should be changed:("
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "Why the function name is subsetsWithDup , it should be without right  :)"
                    }
                ]
            },
            {
                "id": 2010742,
                "content": [
                    {
                        "username": "zhanghuimeng",
                        "content": "I think it is obvious that, for an empty set, its power set should be a set containing an empty set. (`P({}) = { {} }`) \\uFF08[What is the power set of the empty set](https://www.quora.com/What-is-the-power-set-of-the-empty-set-emptyset)\\uFF09Which means, if the input is `[]`, we need to return `[[]]`. Most implementations here follow this pattern, like [this](https://leetcode.com/problems/subsets-ii/discuss/30168/C++-solution-and-explanation) and [that](https://leetcode.com/problems/subsets-ii/discuss/30137/Simple-iterative-solution).\\n\\nBut in the run code section, the \"Expected Answer\" doesn\\'t think so.\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/zhanghuimeng1997/image_1534623169.png)\\n\\nThese codes above can pass, of course; when I make an special judgement for `[]` so that it outputs `[]`, I can still pass. So the OJ didn\\'t check for input `[]` at all. Also, I think there is a bug in the \"Expected Answer\" example program.\\n"
                    },
                    {
                        "username": "greatgrahambini",
                        "content": "A set is by definition, a collection of unique items."
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "A set is a collection of unordered items"
                    },
                    {
                        "username": "jaggz01",
                        "content": "Pre-requisite solve Permutation-I, Permutation-II, and Subset-I and this problem will be easy walk for you."
                    },
                    {
                        "username": "admiremeforever",
                        "content": "The problem description seems to be incorrect -"
                    },
                    {
                        "username": "ruchita1010",
                        "content": "Why is that a set results in wrong output? Given that in C++, set stores elements in sorted order! My code couldn\\'t pass from this test case - [4,4,4,1,4]. But after sorting the vector before passing it in the recursive function, it was accepted?!"
                    },
                    {
                        "username": "sk315425",
                        "content": "Input:\\n[4,4,4,1,4]\\nOutput:\\n[[],[4],[1],[1,4],[4,4],[4,1],[4,1,4],[4,4,4],[4,4,1],[4,4,1,4],[4,4,4,4],[4,4,4,1],[4,4,4,1,4]]\\nExpected:\\n[[],[1],[1,4],[1,4,4],[1,4,4,4],[1,4,4,4,4],[4],[4,4],[4,4,4],[4,4,4,4]]\\n\\narray need to be sorted for this ! \\n"
                    },
                    {
                        "username": "Tanya__",
                        "content": "provided description is incorrect\nExpected output =>return list  all sorted order and unique possible subsets"
                    },
                    {
                        "username": "birindersinghji",
                        "content": "Extremely poor question description. You need to constantly submit and find out what the question wants from the test cases instead of the description."
                    },
                    {
                        "username": "uma_gadde",
                        "content": "like seriouslyyy!!!\\nsorted ordered!! problem desc should be changed:("
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "Why the function name is subsetsWithDup , it should be without right  :)"
                    }
                ]
            },
            {
                "id": 2009435,
                "content": [
                    {
                        "username": "zhanghuimeng",
                        "content": "I think it is obvious that, for an empty set, its power set should be a set containing an empty set. (`P({}) = { {} }`) \\uFF08[What is the power set of the empty set](https://www.quora.com/What-is-the-power-set-of-the-empty-set-emptyset)\\uFF09Which means, if the input is `[]`, we need to return `[[]]`. Most implementations here follow this pattern, like [this](https://leetcode.com/problems/subsets-ii/discuss/30168/C++-solution-and-explanation) and [that](https://leetcode.com/problems/subsets-ii/discuss/30137/Simple-iterative-solution).\\n\\nBut in the run code section, the \"Expected Answer\" doesn\\'t think so.\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/zhanghuimeng1997/image_1534623169.png)\\n\\nThese codes above can pass, of course; when I make an special judgement for `[]` so that it outputs `[]`, I can still pass. So the OJ didn\\'t check for input `[]` at all. Also, I think there is a bug in the \"Expected Answer\" example program.\\n"
                    },
                    {
                        "username": "greatgrahambini",
                        "content": "A set is by definition, a collection of unique items."
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "A set is a collection of unordered items"
                    },
                    {
                        "username": "jaggz01",
                        "content": "Pre-requisite solve Permutation-I, Permutation-II, and Subset-I and this problem will be easy walk for you."
                    },
                    {
                        "username": "admiremeforever",
                        "content": "The problem description seems to be incorrect -"
                    },
                    {
                        "username": "ruchita1010",
                        "content": "Why is that a set results in wrong output? Given that in C++, set stores elements in sorted order! My code couldn\\'t pass from this test case - [4,4,4,1,4]. But after sorting the vector before passing it in the recursive function, it was accepted?!"
                    },
                    {
                        "username": "sk315425",
                        "content": "Input:\\n[4,4,4,1,4]\\nOutput:\\n[[],[4],[1],[1,4],[4,4],[4,1],[4,1,4],[4,4,4],[4,4,1],[4,4,1,4],[4,4,4,4],[4,4,4,1],[4,4,4,1,4]]\\nExpected:\\n[[],[1],[1,4],[1,4,4],[1,4,4,4],[1,4,4,4,4],[4],[4,4],[4,4,4],[4,4,4,4]]\\n\\narray need to be sorted for this ! \\n"
                    },
                    {
                        "username": "Tanya__",
                        "content": "provided description is incorrect\nExpected output =>return list  all sorted order and unique possible subsets"
                    },
                    {
                        "username": "birindersinghji",
                        "content": "Extremely poor question description. You need to constantly submit and find out what the question wants from the test cases instead of the description."
                    },
                    {
                        "username": "uma_gadde",
                        "content": "like seriouslyyy!!!\\nsorted ordered!! problem desc should be changed:("
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "Why the function name is subsetsWithDup , it should be without right  :)"
                    }
                ]
            },
            {
                "id": 1966724,
                "content": [
                    {
                        "username": "zhanghuimeng",
                        "content": "I think it is obvious that, for an empty set, its power set should be a set containing an empty set. (`P({}) = { {} }`) \\uFF08[What is the power set of the empty set](https://www.quora.com/What-is-the-power-set-of-the-empty-set-emptyset)\\uFF09Which means, if the input is `[]`, we need to return `[[]]`. Most implementations here follow this pattern, like [this](https://leetcode.com/problems/subsets-ii/discuss/30168/C++-solution-and-explanation) and [that](https://leetcode.com/problems/subsets-ii/discuss/30137/Simple-iterative-solution).\\n\\nBut in the run code section, the \"Expected Answer\" doesn\\'t think so.\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/zhanghuimeng1997/image_1534623169.png)\\n\\nThese codes above can pass, of course; when I make an special judgement for `[]` so that it outputs `[]`, I can still pass. So the OJ didn\\'t check for input `[]` at all. Also, I think there is a bug in the \"Expected Answer\" example program.\\n"
                    },
                    {
                        "username": "greatgrahambini",
                        "content": "A set is by definition, a collection of unique items."
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "A set is a collection of unordered items"
                    },
                    {
                        "username": "jaggz01",
                        "content": "Pre-requisite solve Permutation-I, Permutation-II, and Subset-I and this problem will be easy walk for you."
                    },
                    {
                        "username": "admiremeforever",
                        "content": "The problem description seems to be incorrect -"
                    },
                    {
                        "username": "ruchita1010",
                        "content": "Why is that a set results in wrong output? Given that in C++, set stores elements in sorted order! My code couldn\\'t pass from this test case - [4,4,4,1,4]. But after sorting the vector before passing it in the recursive function, it was accepted?!"
                    },
                    {
                        "username": "sk315425",
                        "content": "Input:\\n[4,4,4,1,4]\\nOutput:\\n[[],[4],[1],[1,4],[4,4],[4,1],[4,1,4],[4,4,4],[4,4,1],[4,4,1,4],[4,4,4,4],[4,4,4,1],[4,4,4,1,4]]\\nExpected:\\n[[],[1],[1,4],[1,4,4],[1,4,4,4],[1,4,4,4,4],[4],[4,4],[4,4,4],[4,4,4,4]]\\n\\narray need to be sorted for this ! \\n"
                    },
                    {
                        "username": "Tanya__",
                        "content": "provided description is incorrect\nExpected output =>return list  all sorted order and unique possible subsets"
                    },
                    {
                        "username": "birindersinghji",
                        "content": "Extremely poor question description. You need to constantly submit and find out what the question wants from the test cases instead of the description."
                    },
                    {
                        "username": "uma_gadde",
                        "content": "like seriouslyyy!!!\\nsorted ordered!! problem desc should be changed:("
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "Why the function name is subsetsWithDup , it should be without right  :)"
                    }
                ]
            },
            {
                "id": 1960953,
                "content": [
                    {
                        "username": "zhanghuimeng",
                        "content": "I think it is obvious that, for an empty set, its power set should be a set containing an empty set. (`P({}) = { {} }`) \\uFF08[What is the power set of the empty set](https://www.quora.com/What-is-the-power-set-of-the-empty-set-emptyset)\\uFF09Which means, if the input is `[]`, we need to return `[[]]`. Most implementations here follow this pattern, like [this](https://leetcode.com/problems/subsets-ii/discuss/30168/C++-solution-and-explanation) and [that](https://leetcode.com/problems/subsets-ii/discuss/30137/Simple-iterative-solution).\\n\\nBut in the run code section, the \"Expected Answer\" doesn\\'t think so.\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/zhanghuimeng1997/image_1534623169.png)\\n\\nThese codes above can pass, of course; when I make an special judgement for `[]` so that it outputs `[]`, I can still pass. So the OJ didn\\'t check for input `[]` at all. Also, I think there is a bug in the \"Expected Answer\" example program.\\n"
                    },
                    {
                        "username": "greatgrahambini",
                        "content": "A set is by definition, a collection of unique items."
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "A set is a collection of unordered items"
                    },
                    {
                        "username": "jaggz01",
                        "content": "Pre-requisite solve Permutation-I, Permutation-II, and Subset-I and this problem will be easy walk for you."
                    },
                    {
                        "username": "admiremeforever",
                        "content": "The problem description seems to be incorrect -"
                    },
                    {
                        "username": "ruchita1010",
                        "content": "Why is that a set results in wrong output? Given that in C++, set stores elements in sorted order! My code couldn\\'t pass from this test case - [4,4,4,1,4]. But after sorting the vector before passing it in the recursive function, it was accepted?!"
                    },
                    {
                        "username": "sk315425",
                        "content": "Input:\\n[4,4,4,1,4]\\nOutput:\\n[[],[4],[1],[1,4],[4,4],[4,1],[4,1,4],[4,4,4],[4,4,1],[4,4,1,4],[4,4,4,4],[4,4,4,1],[4,4,4,1,4]]\\nExpected:\\n[[],[1],[1,4],[1,4,4],[1,4,4,4],[1,4,4,4,4],[4],[4,4],[4,4,4],[4,4,4,4]]\\n\\narray need to be sorted for this ! \\n"
                    },
                    {
                        "username": "Tanya__",
                        "content": "provided description is incorrect\nExpected output =>return list  all sorted order and unique possible subsets"
                    },
                    {
                        "username": "birindersinghji",
                        "content": "Extremely poor question description. You need to constantly submit and find out what the question wants from the test cases instead of the description."
                    },
                    {
                        "username": "uma_gadde",
                        "content": "like seriouslyyy!!!\\nsorted ordered!! problem desc should be changed:("
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "Why the function name is subsetsWithDup , it should be without right  :)"
                    }
                ]
            },
            {
                "id": 1946014,
                "content": [
                    {
                        "username": "shivam2612002",
                        "content": "to find subsets, a simple approach is to use a pick-skip method.\\nbut when we do have to find unique subsets, do we have to use for loop?\\ni mean can we do it without loops? "
                    },
                    {
                        "username": "AshleyXM",
                        "content": "The description of this problem is sooooooo ambiguous. The number of examples is too small to clarify the problem."
                    },
                    {
                        "username": "vaibhav_oo7",
                        "content": "class Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        Set<List<Integer>> ans = new HashSet<>();\\n        List<Integer> a = new ArrayList<>();\\n        subsetsall(nums,0,ans,a);\\n        List<List<Integer>> d = new ArrayList<>(ans);\\n        return d;\\n\\n    }\\n    public void subsetsall (int nums[], int index, Set<List<Integer>> subsets , List<Integer> subset){\\n        if(index==nums.length){\\n            subsets.add(subset);\\n        }\\n        else{\\n            subset.add(nums[index]);\\n            subsetsall(nums,index+1,subsets,subset);\\n            subset.remove(subset.size()-1);\\n            subsetsall(nums,index+1,subsets,subset);\\n        }\\n    }\\n}\\n\\nwhy this gives empty list  why is this wrong??\\n"
                    },
                    {
                        "username": "hemanth0010",
                        "content": "//why this code is not working\\nclass Solution {\\n    public void solve(int[] nums, int i, List<Integer> ds, Set<List<Integer>> st) {\\n        if (i == nums.length) {\\n            Collections.sort(ds);\\n            st.add(ds);\\n            return;\\n        }\\n        ds.add(nums[i]);\\n        solve(nums, i + 1, ds, st);\\n        ds.remove(ds.size() - 1);\\n        solve(nums, i + 1, ds, st);\\n    }\\n\\n    public List<List<Integer>> subsetsWithDup(int nums[]) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        Set<List<Integer>> st = new HashSet<>();\\n        List<Integer> ds = new ArrayList<>();\\n        solve(nums, 0, ds, st);\\n        for (List<Integer> v : st) {\\n            ans.add(v);\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Ayush_Kumar-01",
                        "content": "class Solution {\\n    void findit(vector<vector<int>>& ans,int index)\\n    {\\n        vector<vector<int>>::iterator it=ans.begin()+index;\\n        if(index>=ans.size())\\n        {\\n            return;\\n        }\\n        for(int i=index;i<ans.size();i++)\\n        {\\n            if(ans[index]==ans[i])\\n            {\\n                \\n                ans.erase(it);\\n            }\\n        }\\n        findit(ans,index+1);\\n    }\\n\\n    void solve(vector<int> nums, vector<int> output, int index, vector<vector<int> >& ans) {\\n        //base case\\n        if(index >= nums.size()) {\\n            ans.push_back(output);\\n            return ;\\n        }\\n        \\n        //exclude\\n        solve(nums, output, index+1, ans);\\n        \\n        //include\\n        int element = nums[index];\\n        output.push_back(element);\\n        solve(nums, output, index+1, ans);\\n\\n\\n        \\n        \\n    }\\n    \\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        vector<vector<int> > ans;\\n        vector<int> output;\\n        int index = 0;\\n        solve(nums, output, index, ans);\\n        findit(ans,0);\\n        sort(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n\\nplease help me and find out where i am doing a mistake"
                    },
                    {
                        "username": "hucancode",
                        "content": "Input need to be sorted before generating subset. It was not mentioned in the problem description."
                    },
                    {
                        "username": "pratham2712",
                        "content": "the solution is similar to the subset1 just think about duplicates.\\n\\n\\n\\nhint : set,sort"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "Sorting Matters"
                    },
                    {
                        "username": "Loncey",
                        "content": "The question says \"the solution set must not contain duplicate subsets.\", but the answer expects duplicate subsets of limited nature.\nIn the first example for nums = [1, 2, 2], subsets [1,2] and [1, 2, 2] are equal so one of them shouldn't be included, but the solution expects us to include both. And if every number of the same value were to be treated as a different object, then correct answer for an array [1, 2, 2] should include all combinations [], [1], [2], [2], [1,2], [1,2], [2, 2], [1, 2, 2] which is not the case.\nThe expected answer to the given question is simply incorrect. Either the question needs to be rephrased or the expected solution has to be changed."
                    },
                    {
                        "username": "Sahil_Rana",
                        "content": "//can someone please find the problem in this code. It gives the following \\n//  output:\\n//  [[],[2],[2],[1]]\\n\\n\\nvector<vector<int>> ans;\\n\\n//ans.push_back({});\\n\\nvoid helper(vector<int>& nums, vector<int> v){\\n\\n    if(nums.size()==0){\\n        ans.push_back(v);\\n        return ;\\n    }\\n\\n    vector<int> v1=v;\\n    vector<int> v2=v;\\n     \\n     v2.push_back(nums[0]);\\n     nums.erase(nums.begin()+0);\\n\\n     helper(nums,v1);\\n     helper(nums,v2);\\n     return;\\n \\n}\\n\\n\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        \\n        vector<int> v;\\n        helper(nums,v);\\n\\n        return ans;\\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1938381,
                "content": [
                    {
                        "username": "shivam2612002",
                        "content": "to find subsets, a simple approach is to use a pick-skip method.\\nbut when we do have to find unique subsets, do we have to use for loop?\\ni mean can we do it without loops? "
                    },
                    {
                        "username": "AshleyXM",
                        "content": "The description of this problem is sooooooo ambiguous. The number of examples is too small to clarify the problem."
                    },
                    {
                        "username": "vaibhav_oo7",
                        "content": "class Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        Set<List<Integer>> ans = new HashSet<>();\\n        List<Integer> a = new ArrayList<>();\\n        subsetsall(nums,0,ans,a);\\n        List<List<Integer>> d = new ArrayList<>(ans);\\n        return d;\\n\\n    }\\n    public void subsetsall (int nums[], int index, Set<List<Integer>> subsets , List<Integer> subset){\\n        if(index==nums.length){\\n            subsets.add(subset);\\n        }\\n        else{\\n            subset.add(nums[index]);\\n            subsetsall(nums,index+1,subsets,subset);\\n            subset.remove(subset.size()-1);\\n            subsetsall(nums,index+1,subsets,subset);\\n        }\\n    }\\n}\\n\\nwhy this gives empty list  why is this wrong??\\n"
                    },
                    {
                        "username": "hemanth0010",
                        "content": "//why this code is not working\\nclass Solution {\\n    public void solve(int[] nums, int i, List<Integer> ds, Set<List<Integer>> st) {\\n        if (i == nums.length) {\\n            Collections.sort(ds);\\n            st.add(ds);\\n            return;\\n        }\\n        ds.add(nums[i]);\\n        solve(nums, i + 1, ds, st);\\n        ds.remove(ds.size() - 1);\\n        solve(nums, i + 1, ds, st);\\n    }\\n\\n    public List<List<Integer>> subsetsWithDup(int nums[]) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        Set<List<Integer>> st = new HashSet<>();\\n        List<Integer> ds = new ArrayList<>();\\n        solve(nums, 0, ds, st);\\n        for (List<Integer> v : st) {\\n            ans.add(v);\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Ayush_Kumar-01",
                        "content": "class Solution {\\n    void findit(vector<vector<int>>& ans,int index)\\n    {\\n        vector<vector<int>>::iterator it=ans.begin()+index;\\n        if(index>=ans.size())\\n        {\\n            return;\\n        }\\n        for(int i=index;i<ans.size();i++)\\n        {\\n            if(ans[index]==ans[i])\\n            {\\n                \\n                ans.erase(it);\\n            }\\n        }\\n        findit(ans,index+1);\\n    }\\n\\n    void solve(vector<int> nums, vector<int> output, int index, vector<vector<int> >& ans) {\\n        //base case\\n        if(index >= nums.size()) {\\n            ans.push_back(output);\\n            return ;\\n        }\\n        \\n        //exclude\\n        solve(nums, output, index+1, ans);\\n        \\n        //include\\n        int element = nums[index];\\n        output.push_back(element);\\n        solve(nums, output, index+1, ans);\\n\\n\\n        \\n        \\n    }\\n    \\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        vector<vector<int> > ans;\\n        vector<int> output;\\n        int index = 0;\\n        solve(nums, output, index, ans);\\n        findit(ans,0);\\n        sort(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n\\nplease help me and find out where i am doing a mistake"
                    },
                    {
                        "username": "hucancode",
                        "content": "Input need to be sorted before generating subset. It was not mentioned in the problem description."
                    },
                    {
                        "username": "pratham2712",
                        "content": "the solution is similar to the subset1 just think about duplicates.\\n\\n\\n\\nhint : set,sort"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "Sorting Matters"
                    },
                    {
                        "username": "Loncey",
                        "content": "The question says \"the solution set must not contain duplicate subsets.\", but the answer expects duplicate subsets of limited nature.\nIn the first example for nums = [1, 2, 2], subsets [1,2] and [1, 2, 2] are equal so one of them shouldn't be included, but the solution expects us to include both. And if every number of the same value were to be treated as a different object, then correct answer for an array [1, 2, 2] should include all combinations [], [1], [2], [2], [1,2], [1,2], [2, 2], [1, 2, 2] which is not the case.\nThe expected answer to the given question is simply incorrect. Either the question needs to be rephrased or the expected solution has to be changed."
                    },
                    {
                        "username": "Sahil_Rana",
                        "content": "//can someone please find the problem in this code. It gives the following \\n//  output:\\n//  [[],[2],[2],[1]]\\n\\n\\nvector<vector<int>> ans;\\n\\n//ans.push_back({});\\n\\nvoid helper(vector<int>& nums, vector<int> v){\\n\\n    if(nums.size()==0){\\n        ans.push_back(v);\\n        return ;\\n    }\\n\\n    vector<int> v1=v;\\n    vector<int> v2=v;\\n     \\n     v2.push_back(nums[0]);\\n     nums.erase(nums.begin()+0);\\n\\n     helper(nums,v1);\\n     helper(nums,v2);\\n     return;\\n \\n}\\n\\n\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        \\n        vector<int> v;\\n        helper(nums,v);\\n\\n        return ans;\\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1935888,
                "content": [
                    {
                        "username": "shivam2612002",
                        "content": "to find subsets, a simple approach is to use a pick-skip method.\\nbut when we do have to find unique subsets, do we have to use for loop?\\ni mean can we do it without loops? "
                    },
                    {
                        "username": "AshleyXM",
                        "content": "The description of this problem is sooooooo ambiguous. The number of examples is too small to clarify the problem."
                    },
                    {
                        "username": "vaibhav_oo7",
                        "content": "class Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        Set<List<Integer>> ans = new HashSet<>();\\n        List<Integer> a = new ArrayList<>();\\n        subsetsall(nums,0,ans,a);\\n        List<List<Integer>> d = new ArrayList<>(ans);\\n        return d;\\n\\n    }\\n    public void subsetsall (int nums[], int index, Set<List<Integer>> subsets , List<Integer> subset){\\n        if(index==nums.length){\\n            subsets.add(subset);\\n        }\\n        else{\\n            subset.add(nums[index]);\\n            subsetsall(nums,index+1,subsets,subset);\\n            subset.remove(subset.size()-1);\\n            subsetsall(nums,index+1,subsets,subset);\\n        }\\n    }\\n}\\n\\nwhy this gives empty list  why is this wrong??\\n"
                    },
                    {
                        "username": "hemanth0010",
                        "content": "//why this code is not working\\nclass Solution {\\n    public void solve(int[] nums, int i, List<Integer> ds, Set<List<Integer>> st) {\\n        if (i == nums.length) {\\n            Collections.sort(ds);\\n            st.add(ds);\\n            return;\\n        }\\n        ds.add(nums[i]);\\n        solve(nums, i + 1, ds, st);\\n        ds.remove(ds.size() - 1);\\n        solve(nums, i + 1, ds, st);\\n    }\\n\\n    public List<List<Integer>> subsetsWithDup(int nums[]) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        Set<List<Integer>> st = new HashSet<>();\\n        List<Integer> ds = new ArrayList<>();\\n        solve(nums, 0, ds, st);\\n        for (List<Integer> v : st) {\\n            ans.add(v);\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Ayush_Kumar-01",
                        "content": "class Solution {\\n    void findit(vector<vector<int>>& ans,int index)\\n    {\\n        vector<vector<int>>::iterator it=ans.begin()+index;\\n        if(index>=ans.size())\\n        {\\n            return;\\n        }\\n        for(int i=index;i<ans.size();i++)\\n        {\\n            if(ans[index]==ans[i])\\n            {\\n                \\n                ans.erase(it);\\n            }\\n        }\\n        findit(ans,index+1);\\n    }\\n\\n    void solve(vector<int> nums, vector<int> output, int index, vector<vector<int> >& ans) {\\n        //base case\\n        if(index >= nums.size()) {\\n            ans.push_back(output);\\n            return ;\\n        }\\n        \\n        //exclude\\n        solve(nums, output, index+1, ans);\\n        \\n        //include\\n        int element = nums[index];\\n        output.push_back(element);\\n        solve(nums, output, index+1, ans);\\n\\n\\n        \\n        \\n    }\\n    \\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        vector<vector<int> > ans;\\n        vector<int> output;\\n        int index = 0;\\n        solve(nums, output, index, ans);\\n        findit(ans,0);\\n        sort(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n\\nplease help me and find out where i am doing a mistake"
                    },
                    {
                        "username": "hucancode",
                        "content": "Input need to be sorted before generating subset. It was not mentioned in the problem description."
                    },
                    {
                        "username": "pratham2712",
                        "content": "the solution is similar to the subset1 just think about duplicates.\\n\\n\\n\\nhint : set,sort"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "Sorting Matters"
                    },
                    {
                        "username": "Loncey",
                        "content": "The question says \"the solution set must not contain duplicate subsets.\", but the answer expects duplicate subsets of limited nature.\nIn the first example for nums = [1, 2, 2], subsets [1,2] and [1, 2, 2] are equal so one of them shouldn't be included, but the solution expects us to include both. And if every number of the same value were to be treated as a different object, then correct answer for an array [1, 2, 2] should include all combinations [], [1], [2], [2], [1,2], [1,2], [2, 2], [1, 2, 2] which is not the case.\nThe expected answer to the given question is simply incorrect. Either the question needs to be rephrased or the expected solution has to be changed."
                    },
                    {
                        "username": "Sahil_Rana",
                        "content": "//can someone please find the problem in this code. It gives the following \\n//  output:\\n//  [[],[2],[2],[1]]\\n\\n\\nvector<vector<int>> ans;\\n\\n//ans.push_back({});\\n\\nvoid helper(vector<int>& nums, vector<int> v){\\n\\n    if(nums.size()==0){\\n        ans.push_back(v);\\n        return ;\\n    }\\n\\n    vector<int> v1=v;\\n    vector<int> v2=v;\\n     \\n     v2.push_back(nums[0]);\\n     nums.erase(nums.begin()+0);\\n\\n     helper(nums,v1);\\n     helper(nums,v2);\\n     return;\\n \\n}\\n\\n\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        \\n        vector<int> v;\\n        helper(nums,v);\\n\\n        return ans;\\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1928000,
                "content": [
                    {
                        "username": "shivam2612002",
                        "content": "to find subsets, a simple approach is to use a pick-skip method.\\nbut when we do have to find unique subsets, do we have to use for loop?\\ni mean can we do it without loops? "
                    },
                    {
                        "username": "AshleyXM",
                        "content": "The description of this problem is sooooooo ambiguous. The number of examples is too small to clarify the problem."
                    },
                    {
                        "username": "vaibhav_oo7",
                        "content": "class Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        Set<List<Integer>> ans = new HashSet<>();\\n        List<Integer> a = new ArrayList<>();\\n        subsetsall(nums,0,ans,a);\\n        List<List<Integer>> d = new ArrayList<>(ans);\\n        return d;\\n\\n    }\\n    public void subsetsall (int nums[], int index, Set<List<Integer>> subsets , List<Integer> subset){\\n        if(index==nums.length){\\n            subsets.add(subset);\\n        }\\n        else{\\n            subset.add(nums[index]);\\n            subsetsall(nums,index+1,subsets,subset);\\n            subset.remove(subset.size()-1);\\n            subsetsall(nums,index+1,subsets,subset);\\n        }\\n    }\\n}\\n\\nwhy this gives empty list  why is this wrong??\\n"
                    },
                    {
                        "username": "hemanth0010",
                        "content": "//why this code is not working\\nclass Solution {\\n    public void solve(int[] nums, int i, List<Integer> ds, Set<List<Integer>> st) {\\n        if (i == nums.length) {\\n            Collections.sort(ds);\\n            st.add(ds);\\n            return;\\n        }\\n        ds.add(nums[i]);\\n        solve(nums, i + 1, ds, st);\\n        ds.remove(ds.size() - 1);\\n        solve(nums, i + 1, ds, st);\\n    }\\n\\n    public List<List<Integer>> subsetsWithDup(int nums[]) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        Set<List<Integer>> st = new HashSet<>();\\n        List<Integer> ds = new ArrayList<>();\\n        solve(nums, 0, ds, st);\\n        for (List<Integer> v : st) {\\n            ans.add(v);\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Ayush_Kumar-01",
                        "content": "class Solution {\\n    void findit(vector<vector<int>>& ans,int index)\\n    {\\n        vector<vector<int>>::iterator it=ans.begin()+index;\\n        if(index>=ans.size())\\n        {\\n            return;\\n        }\\n        for(int i=index;i<ans.size();i++)\\n        {\\n            if(ans[index]==ans[i])\\n            {\\n                \\n                ans.erase(it);\\n            }\\n        }\\n        findit(ans,index+1);\\n    }\\n\\n    void solve(vector<int> nums, vector<int> output, int index, vector<vector<int> >& ans) {\\n        //base case\\n        if(index >= nums.size()) {\\n            ans.push_back(output);\\n            return ;\\n        }\\n        \\n        //exclude\\n        solve(nums, output, index+1, ans);\\n        \\n        //include\\n        int element = nums[index];\\n        output.push_back(element);\\n        solve(nums, output, index+1, ans);\\n\\n\\n        \\n        \\n    }\\n    \\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        vector<vector<int> > ans;\\n        vector<int> output;\\n        int index = 0;\\n        solve(nums, output, index, ans);\\n        findit(ans,0);\\n        sort(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n\\nplease help me and find out where i am doing a mistake"
                    },
                    {
                        "username": "hucancode",
                        "content": "Input need to be sorted before generating subset. It was not mentioned in the problem description."
                    },
                    {
                        "username": "pratham2712",
                        "content": "the solution is similar to the subset1 just think about duplicates.\\n\\n\\n\\nhint : set,sort"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "Sorting Matters"
                    },
                    {
                        "username": "Loncey",
                        "content": "The question says \"the solution set must not contain duplicate subsets.\", but the answer expects duplicate subsets of limited nature.\nIn the first example for nums = [1, 2, 2], subsets [1,2] and [1, 2, 2] are equal so one of them shouldn't be included, but the solution expects us to include both. And if every number of the same value were to be treated as a different object, then correct answer for an array [1, 2, 2] should include all combinations [], [1], [2], [2], [1,2], [1,2], [2, 2], [1, 2, 2] which is not the case.\nThe expected answer to the given question is simply incorrect. Either the question needs to be rephrased or the expected solution has to be changed."
                    },
                    {
                        "username": "Sahil_Rana",
                        "content": "//can someone please find the problem in this code. It gives the following \\n//  output:\\n//  [[],[2],[2],[1]]\\n\\n\\nvector<vector<int>> ans;\\n\\n//ans.push_back({});\\n\\nvoid helper(vector<int>& nums, vector<int> v){\\n\\n    if(nums.size()==0){\\n        ans.push_back(v);\\n        return ;\\n    }\\n\\n    vector<int> v1=v;\\n    vector<int> v2=v;\\n     \\n     v2.push_back(nums[0]);\\n     nums.erase(nums.begin()+0);\\n\\n     helper(nums,v1);\\n     helper(nums,v2);\\n     return;\\n \\n}\\n\\n\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        \\n        vector<int> v;\\n        helper(nums,v);\\n\\n        return ans;\\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1922658,
                "content": [
                    {
                        "username": "shivam2612002",
                        "content": "to find subsets, a simple approach is to use a pick-skip method.\\nbut when we do have to find unique subsets, do we have to use for loop?\\ni mean can we do it without loops? "
                    },
                    {
                        "username": "AshleyXM",
                        "content": "The description of this problem is sooooooo ambiguous. The number of examples is too small to clarify the problem."
                    },
                    {
                        "username": "vaibhav_oo7",
                        "content": "class Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        Set<List<Integer>> ans = new HashSet<>();\\n        List<Integer> a = new ArrayList<>();\\n        subsetsall(nums,0,ans,a);\\n        List<List<Integer>> d = new ArrayList<>(ans);\\n        return d;\\n\\n    }\\n    public void subsetsall (int nums[], int index, Set<List<Integer>> subsets , List<Integer> subset){\\n        if(index==nums.length){\\n            subsets.add(subset);\\n        }\\n        else{\\n            subset.add(nums[index]);\\n            subsetsall(nums,index+1,subsets,subset);\\n            subset.remove(subset.size()-1);\\n            subsetsall(nums,index+1,subsets,subset);\\n        }\\n    }\\n}\\n\\nwhy this gives empty list  why is this wrong??\\n"
                    },
                    {
                        "username": "hemanth0010",
                        "content": "//why this code is not working\\nclass Solution {\\n    public void solve(int[] nums, int i, List<Integer> ds, Set<List<Integer>> st) {\\n        if (i == nums.length) {\\n            Collections.sort(ds);\\n            st.add(ds);\\n            return;\\n        }\\n        ds.add(nums[i]);\\n        solve(nums, i + 1, ds, st);\\n        ds.remove(ds.size() - 1);\\n        solve(nums, i + 1, ds, st);\\n    }\\n\\n    public List<List<Integer>> subsetsWithDup(int nums[]) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        Set<List<Integer>> st = new HashSet<>();\\n        List<Integer> ds = new ArrayList<>();\\n        solve(nums, 0, ds, st);\\n        for (List<Integer> v : st) {\\n            ans.add(v);\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Ayush_Kumar-01",
                        "content": "class Solution {\\n    void findit(vector<vector<int>>& ans,int index)\\n    {\\n        vector<vector<int>>::iterator it=ans.begin()+index;\\n        if(index>=ans.size())\\n        {\\n            return;\\n        }\\n        for(int i=index;i<ans.size();i++)\\n        {\\n            if(ans[index]==ans[i])\\n            {\\n                \\n                ans.erase(it);\\n            }\\n        }\\n        findit(ans,index+1);\\n    }\\n\\n    void solve(vector<int> nums, vector<int> output, int index, vector<vector<int> >& ans) {\\n        //base case\\n        if(index >= nums.size()) {\\n            ans.push_back(output);\\n            return ;\\n        }\\n        \\n        //exclude\\n        solve(nums, output, index+1, ans);\\n        \\n        //include\\n        int element = nums[index];\\n        output.push_back(element);\\n        solve(nums, output, index+1, ans);\\n\\n\\n        \\n        \\n    }\\n    \\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        vector<vector<int> > ans;\\n        vector<int> output;\\n        int index = 0;\\n        solve(nums, output, index, ans);\\n        findit(ans,0);\\n        sort(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n\\nplease help me and find out where i am doing a mistake"
                    },
                    {
                        "username": "hucancode",
                        "content": "Input need to be sorted before generating subset. It was not mentioned in the problem description."
                    },
                    {
                        "username": "pratham2712",
                        "content": "the solution is similar to the subset1 just think about duplicates.\\n\\n\\n\\nhint : set,sort"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "Sorting Matters"
                    },
                    {
                        "username": "Loncey",
                        "content": "The question says \"the solution set must not contain duplicate subsets.\", but the answer expects duplicate subsets of limited nature.\nIn the first example for nums = [1, 2, 2], subsets [1,2] and [1, 2, 2] are equal so one of them shouldn't be included, but the solution expects us to include both. And if every number of the same value were to be treated as a different object, then correct answer for an array [1, 2, 2] should include all combinations [], [1], [2], [2], [1,2], [1,2], [2, 2], [1, 2, 2] which is not the case.\nThe expected answer to the given question is simply incorrect. Either the question needs to be rephrased or the expected solution has to be changed."
                    },
                    {
                        "username": "Sahil_Rana",
                        "content": "//can someone please find the problem in this code. It gives the following \\n//  output:\\n//  [[],[2],[2],[1]]\\n\\n\\nvector<vector<int>> ans;\\n\\n//ans.push_back({});\\n\\nvoid helper(vector<int>& nums, vector<int> v){\\n\\n    if(nums.size()==0){\\n        ans.push_back(v);\\n        return ;\\n    }\\n\\n    vector<int> v1=v;\\n    vector<int> v2=v;\\n     \\n     v2.push_back(nums[0]);\\n     nums.erase(nums.begin()+0);\\n\\n     helper(nums,v1);\\n     helper(nums,v2);\\n     return;\\n \\n}\\n\\n\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        \\n        vector<int> v;\\n        helper(nums,v);\\n\\n        return ans;\\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1890598,
                "content": [
                    {
                        "username": "shivam2612002",
                        "content": "to find subsets, a simple approach is to use a pick-skip method.\\nbut when we do have to find unique subsets, do we have to use for loop?\\ni mean can we do it without loops? "
                    },
                    {
                        "username": "AshleyXM",
                        "content": "The description of this problem is sooooooo ambiguous. The number of examples is too small to clarify the problem."
                    },
                    {
                        "username": "vaibhav_oo7",
                        "content": "class Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        Set<List<Integer>> ans = new HashSet<>();\\n        List<Integer> a = new ArrayList<>();\\n        subsetsall(nums,0,ans,a);\\n        List<List<Integer>> d = new ArrayList<>(ans);\\n        return d;\\n\\n    }\\n    public void subsetsall (int nums[], int index, Set<List<Integer>> subsets , List<Integer> subset){\\n        if(index==nums.length){\\n            subsets.add(subset);\\n        }\\n        else{\\n            subset.add(nums[index]);\\n            subsetsall(nums,index+1,subsets,subset);\\n            subset.remove(subset.size()-1);\\n            subsetsall(nums,index+1,subsets,subset);\\n        }\\n    }\\n}\\n\\nwhy this gives empty list  why is this wrong??\\n"
                    },
                    {
                        "username": "hemanth0010",
                        "content": "//why this code is not working\\nclass Solution {\\n    public void solve(int[] nums, int i, List<Integer> ds, Set<List<Integer>> st) {\\n        if (i == nums.length) {\\n            Collections.sort(ds);\\n            st.add(ds);\\n            return;\\n        }\\n        ds.add(nums[i]);\\n        solve(nums, i + 1, ds, st);\\n        ds.remove(ds.size() - 1);\\n        solve(nums, i + 1, ds, st);\\n    }\\n\\n    public List<List<Integer>> subsetsWithDup(int nums[]) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        Set<List<Integer>> st = new HashSet<>();\\n        List<Integer> ds = new ArrayList<>();\\n        solve(nums, 0, ds, st);\\n        for (List<Integer> v : st) {\\n            ans.add(v);\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Ayush_Kumar-01",
                        "content": "class Solution {\\n    void findit(vector<vector<int>>& ans,int index)\\n    {\\n        vector<vector<int>>::iterator it=ans.begin()+index;\\n        if(index>=ans.size())\\n        {\\n            return;\\n        }\\n        for(int i=index;i<ans.size();i++)\\n        {\\n            if(ans[index]==ans[i])\\n            {\\n                \\n                ans.erase(it);\\n            }\\n        }\\n        findit(ans,index+1);\\n    }\\n\\n    void solve(vector<int> nums, vector<int> output, int index, vector<vector<int> >& ans) {\\n        //base case\\n        if(index >= nums.size()) {\\n            ans.push_back(output);\\n            return ;\\n        }\\n        \\n        //exclude\\n        solve(nums, output, index+1, ans);\\n        \\n        //include\\n        int element = nums[index];\\n        output.push_back(element);\\n        solve(nums, output, index+1, ans);\\n\\n\\n        \\n        \\n    }\\n    \\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        vector<vector<int> > ans;\\n        vector<int> output;\\n        int index = 0;\\n        solve(nums, output, index, ans);\\n        findit(ans,0);\\n        sort(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n\\nplease help me and find out where i am doing a mistake"
                    },
                    {
                        "username": "hucancode",
                        "content": "Input need to be sorted before generating subset. It was not mentioned in the problem description."
                    },
                    {
                        "username": "pratham2712",
                        "content": "the solution is similar to the subset1 just think about duplicates.\\n\\n\\n\\nhint : set,sort"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "Sorting Matters"
                    },
                    {
                        "username": "Loncey",
                        "content": "The question says \"the solution set must not contain duplicate subsets.\", but the answer expects duplicate subsets of limited nature.\nIn the first example for nums = [1, 2, 2], subsets [1,2] and [1, 2, 2] are equal so one of them shouldn't be included, but the solution expects us to include both. And if every number of the same value were to be treated as a different object, then correct answer for an array [1, 2, 2] should include all combinations [], [1], [2], [2], [1,2], [1,2], [2, 2], [1, 2, 2] which is not the case.\nThe expected answer to the given question is simply incorrect. Either the question needs to be rephrased or the expected solution has to be changed."
                    },
                    {
                        "username": "Sahil_Rana",
                        "content": "//can someone please find the problem in this code. It gives the following \\n//  output:\\n//  [[],[2],[2],[1]]\\n\\n\\nvector<vector<int>> ans;\\n\\n//ans.push_back({});\\n\\nvoid helper(vector<int>& nums, vector<int> v){\\n\\n    if(nums.size()==0){\\n        ans.push_back(v);\\n        return ;\\n    }\\n\\n    vector<int> v1=v;\\n    vector<int> v2=v;\\n     \\n     v2.push_back(nums[0]);\\n     nums.erase(nums.begin()+0);\\n\\n     helper(nums,v1);\\n     helper(nums,v2);\\n     return;\\n \\n}\\n\\n\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        \\n        vector<int> v;\\n        helper(nums,v);\\n\\n        return ans;\\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1848069,
                "content": [
                    {
                        "username": "shivam2612002",
                        "content": "to find subsets, a simple approach is to use a pick-skip method.\\nbut when we do have to find unique subsets, do we have to use for loop?\\ni mean can we do it without loops? "
                    },
                    {
                        "username": "AshleyXM",
                        "content": "The description of this problem is sooooooo ambiguous. The number of examples is too small to clarify the problem."
                    },
                    {
                        "username": "vaibhav_oo7",
                        "content": "class Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        Set<List<Integer>> ans = new HashSet<>();\\n        List<Integer> a = new ArrayList<>();\\n        subsetsall(nums,0,ans,a);\\n        List<List<Integer>> d = new ArrayList<>(ans);\\n        return d;\\n\\n    }\\n    public void subsetsall (int nums[], int index, Set<List<Integer>> subsets , List<Integer> subset){\\n        if(index==nums.length){\\n            subsets.add(subset);\\n        }\\n        else{\\n            subset.add(nums[index]);\\n            subsetsall(nums,index+1,subsets,subset);\\n            subset.remove(subset.size()-1);\\n            subsetsall(nums,index+1,subsets,subset);\\n        }\\n    }\\n}\\n\\nwhy this gives empty list  why is this wrong??\\n"
                    },
                    {
                        "username": "hemanth0010",
                        "content": "//why this code is not working\\nclass Solution {\\n    public void solve(int[] nums, int i, List<Integer> ds, Set<List<Integer>> st) {\\n        if (i == nums.length) {\\n            Collections.sort(ds);\\n            st.add(ds);\\n            return;\\n        }\\n        ds.add(nums[i]);\\n        solve(nums, i + 1, ds, st);\\n        ds.remove(ds.size() - 1);\\n        solve(nums, i + 1, ds, st);\\n    }\\n\\n    public List<List<Integer>> subsetsWithDup(int nums[]) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        Set<List<Integer>> st = new HashSet<>();\\n        List<Integer> ds = new ArrayList<>();\\n        solve(nums, 0, ds, st);\\n        for (List<Integer> v : st) {\\n            ans.add(v);\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Ayush_Kumar-01",
                        "content": "class Solution {\\n    void findit(vector<vector<int>>& ans,int index)\\n    {\\n        vector<vector<int>>::iterator it=ans.begin()+index;\\n        if(index>=ans.size())\\n        {\\n            return;\\n        }\\n        for(int i=index;i<ans.size();i++)\\n        {\\n            if(ans[index]==ans[i])\\n            {\\n                \\n                ans.erase(it);\\n            }\\n        }\\n        findit(ans,index+1);\\n    }\\n\\n    void solve(vector<int> nums, vector<int> output, int index, vector<vector<int> >& ans) {\\n        //base case\\n        if(index >= nums.size()) {\\n            ans.push_back(output);\\n            return ;\\n        }\\n        \\n        //exclude\\n        solve(nums, output, index+1, ans);\\n        \\n        //include\\n        int element = nums[index];\\n        output.push_back(element);\\n        solve(nums, output, index+1, ans);\\n\\n\\n        \\n        \\n    }\\n    \\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        vector<vector<int> > ans;\\n        vector<int> output;\\n        int index = 0;\\n        solve(nums, output, index, ans);\\n        findit(ans,0);\\n        sort(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n\\nplease help me and find out where i am doing a mistake"
                    },
                    {
                        "username": "hucancode",
                        "content": "Input need to be sorted before generating subset. It was not mentioned in the problem description."
                    },
                    {
                        "username": "pratham2712",
                        "content": "the solution is similar to the subset1 just think about duplicates.\\n\\n\\n\\nhint : set,sort"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "Sorting Matters"
                    },
                    {
                        "username": "Loncey",
                        "content": "The question says \"the solution set must not contain duplicate subsets.\", but the answer expects duplicate subsets of limited nature.\nIn the first example for nums = [1, 2, 2], subsets [1,2] and [1, 2, 2] are equal so one of them shouldn't be included, but the solution expects us to include both. And if every number of the same value were to be treated as a different object, then correct answer for an array [1, 2, 2] should include all combinations [], [1], [2], [2], [1,2], [1,2], [2, 2], [1, 2, 2] which is not the case.\nThe expected answer to the given question is simply incorrect. Either the question needs to be rephrased or the expected solution has to be changed."
                    },
                    {
                        "username": "Sahil_Rana",
                        "content": "//can someone please find the problem in this code. It gives the following \\n//  output:\\n//  [[],[2],[2],[1]]\\n\\n\\nvector<vector<int>> ans;\\n\\n//ans.push_back({});\\n\\nvoid helper(vector<int>& nums, vector<int> v){\\n\\n    if(nums.size()==0){\\n        ans.push_back(v);\\n        return ;\\n    }\\n\\n    vector<int> v1=v;\\n    vector<int> v2=v;\\n     \\n     v2.push_back(nums[0]);\\n     nums.erase(nums.begin()+0);\\n\\n     helper(nums,v1);\\n     helper(nums,v2);\\n     return;\\n \\n}\\n\\n\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        \\n        vector<int> v;\\n        helper(nums,v);\\n\\n        return ans;\\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1833839,
                "content": [
                    {
                        "username": "shivam2612002",
                        "content": "to find subsets, a simple approach is to use a pick-skip method.\\nbut when we do have to find unique subsets, do we have to use for loop?\\ni mean can we do it without loops? "
                    },
                    {
                        "username": "AshleyXM",
                        "content": "The description of this problem is sooooooo ambiguous. The number of examples is too small to clarify the problem."
                    },
                    {
                        "username": "vaibhav_oo7",
                        "content": "class Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        Set<List<Integer>> ans = new HashSet<>();\\n        List<Integer> a = new ArrayList<>();\\n        subsetsall(nums,0,ans,a);\\n        List<List<Integer>> d = new ArrayList<>(ans);\\n        return d;\\n\\n    }\\n    public void subsetsall (int nums[], int index, Set<List<Integer>> subsets , List<Integer> subset){\\n        if(index==nums.length){\\n            subsets.add(subset);\\n        }\\n        else{\\n            subset.add(nums[index]);\\n            subsetsall(nums,index+1,subsets,subset);\\n            subset.remove(subset.size()-1);\\n            subsetsall(nums,index+1,subsets,subset);\\n        }\\n    }\\n}\\n\\nwhy this gives empty list  why is this wrong??\\n"
                    },
                    {
                        "username": "hemanth0010",
                        "content": "//why this code is not working\\nclass Solution {\\n    public void solve(int[] nums, int i, List<Integer> ds, Set<List<Integer>> st) {\\n        if (i == nums.length) {\\n            Collections.sort(ds);\\n            st.add(ds);\\n            return;\\n        }\\n        ds.add(nums[i]);\\n        solve(nums, i + 1, ds, st);\\n        ds.remove(ds.size() - 1);\\n        solve(nums, i + 1, ds, st);\\n    }\\n\\n    public List<List<Integer>> subsetsWithDup(int nums[]) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        Set<List<Integer>> st = new HashSet<>();\\n        List<Integer> ds = new ArrayList<>();\\n        solve(nums, 0, ds, st);\\n        for (List<Integer> v : st) {\\n            ans.add(v);\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Ayush_Kumar-01",
                        "content": "class Solution {\\n    void findit(vector<vector<int>>& ans,int index)\\n    {\\n        vector<vector<int>>::iterator it=ans.begin()+index;\\n        if(index>=ans.size())\\n        {\\n            return;\\n        }\\n        for(int i=index;i<ans.size();i++)\\n        {\\n            if(ans[index]==ans[i])\\n            {\\n                \\n                ans.erase(it);\\n            }\\n        }\\n        findit(ans,index+1);\\n    }\\n\\n    void solve(vector<int> nums, vector<int> output, int index, vector<vector<int> >& ans) {\\n        //base case\\n        if(index >= nums.size()) {\\n            ans.push_back(output);\\n            return ;\\n        }\\n        \\n        //exclude\\n        solve(nums, output, index+1, ans);\\n        \\n        //include\\n        int element = nums[index];\\n        output.push_back(element);\\n        solve(nums, output, index+1, ans);\\n\\n\\n        \\n        \\n    }\\n    \\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        vector<vector<int> > ans;\\n        vector<int> output;\\n        int index = 0;\\n        solve(nums, output, index, ans);\\n        findit(ans,0);\\n        sort(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n\\nplease help me and find out where i am doing a mistake"
                    },
                    {
                        "username": "hucancode",
                        "content": "Input need to be sorted before generating subset. It was not mentioned in the problem description."
                    },
                    {
                        "username": "pratham2712",
                        "content": "the solution is similar to the subset1 just think about duplicates.\\n\\n\\n\\nhint : set,sort"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "Sorting Matters"
                    },
                    {
                        "username": "Loncey",
                        "content": "The question says \"the solution set must not contain duplicate subsets.\", but the answer expects duplicate subsets of limited nature.\nIn the first example for nums = [1, 2, 2], subsets [1,2] and [1, 2, 2] are equal so one of them shouldn't be included, but the solution expects us to include both. And if every number of the same value were to be treated as a different object, then correct answer for an array [1, 2, 2] should include all combinations [], [1], [2], [2], [1,2], [1,2], [2, 2], [1, 2, 2] which is not the case.\nThe expected answer to the given question is simply incorrect. Either the question needs to be rephrased or the expected solution has to be changed."
                    },
                    {
                        "username": "Sahil_Rana",
                        "content": "//can someone please find the problem in this code. It gives the following \\n//  output:\\n//  [[],[2],[2],[1]]\\n\\n\\nvector<vector<int>> ans;\\n\\n//ans.push_back({});\\n\\nvoid helper(vector<int>& nums, vector<int> v){\\n\\n    if(nums.size()==0){\\n        ans.push_back(v);\\n        return ;\\n    }\\n\\n    vector<int> v1=v;\\n    vector<int> v2=v;\\n     \\n     v2.push_back(nums[0]);\\n     nums.erase(nums.begin()+0);\\n\\n     helper(nums,v1);\\n     helper(nums,v2);\\n     return;\\n \\n}\\n\\n\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        \\n        vector<int> v;\\n        helper(nums,v);\\n\\n        return ans;\\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1812431,
                "content": [
                    {
                        "username": "shivam2612002",
                        "content": "to find subsets, a simple approach is to use a pick-skip method.\\nbut when we do have to find unique subsets, do we have to use for loop?\\ni mean can we do it without loops? "
                    },
                    {
                        "username": "AshleyXM",
                        "content": "The description of this problem is sooooooo ambiguous. The number of examples is too small to clarify the problem."
                    },
                    {
                        "username": "vaibhav_oo7",
                        "content": "class Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        Set<List<Integer>> ans = new HashSet<>();\\n        List<Integer> a = new ArrayList<>();\\n        subsetsall(nums,0,ans,a);\\n        List<List<Integer>> d = new ArrayList<>(ans);\\n        return d;\\n\\n    }\\n    public void subsetsall (int nums[], int index, Set<List<Integer>> subsets , List<Integer> subset){\\n        if(index==nums.length){\\n            subsets.add(subset);\\n        }\\n        else{\\n            subset.add(nums[index]);\\n            subsetsall(nums,index+1,subsets,subset);\\n            subset.remove(subset.size()-1);\\n            subsetsall(nums,index+1,subsets,subset);\\n        }\\n    }\\n}\\n\\nwhy this gives empty list  why is this wrong??\\n"
                    },
                    {
                        "username": "hemanth0010",
                        "content": "//why this code is not working\\nclass Solution {\\n    public void solve(int[] nums, int i, List<Integer> ds, Set<List<Integer>> st) {\\n        if (i == nums.length) {\\n            Collections.sort(ds);\\n            st.add(ds);\\n            return;\\n        }\\n        ds.add(nums[i]);\\n        solve(nums, i + 1, ds, st);\\n        ds.remove(ds.size() - 1);\\n        solve(nums, i + 1, ds, st);\\n    }\\n\\n    public List<List<Integer>> subsetsWithDup(int nums[]) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        Set<List<Integer>> st = new HashSet<>();\\n        List<Integer> ds = new ArrayList<>();\\n        solve(nums, 0, ds, st);\\n        for (List<Integer> v : st) {\\n            ans.add(v);\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Ayush_Kumar-01",
                        "content": "class Solution {\\n    void findit(vector<vector<int>>& ans,int index)\\n    {\\n        vector<vector<int>>::iterator it=ans.begin()+index;\\n        if(index>=ans.size())\\n        {\\n            return;\\n        }\\n        for(int i=index;i<ans.size();i++)\\n        {\\n            if(ans[index]==ans[i])\\n            {\\n                \\n                ans.erase(it);\\n            }\\n        }\\n        findit(ans,index+1);\\n    }\\n\\n    void solve(vector<int> nums, vector<int> output, int index, vector<vector<int> >& ans) {\\n        //base case\\n        if(index >= nums.size()) {\\n            ans.push_back(output);\\n            return ;\\n        }\\n        \\n        //exclude\\n        solve(nums, output, index+1, ans);\\n        \\n        //include\\n        int element = nums[index];\\n        output.push_back(element);\\n        solve(nums, output, index+1, ans);\\n\\n\\n        \\n        \\n    }\\n    \\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        vector<vector<int> > ans;\\n        vector<int> output;\\n        int index = 0;\\n        solve(nums, output, index, ans);\\n        findit(ans,0);\\n        sort(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n\\nplease help me and find out where i am doing a mistake"
                    },
                    {
                        "username": "hucancode",
                        "content": "Input need to be sorted before generating subset. It was not mentioned in the problem description."
                    },
                    {
                        "username": "pratham2712",
                        "content": "the solution is similar to the subset1 just think about duplicates.\\n\\n\\n\\nhint : set,sort"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "Sorting Matters"
                    },
                    {
                        "username": "Loncey",
                        "content": "The question says \"the solution set must not contain duplicate subsets.\", but the answer expects duplicate subsets of limited nature.\nIn the first example for nums = [1, 2, 2], subsets [1,2] and [1, 2, 2] are equal so one of them shouldn't be included, but the solution expects us to include both. And if every number of the same value were to be treated as a different object, then correct answer for an array [1, 2, 2] should include all combinations [], [1], [2], [2], [1,2], [1,2], [2, 2], [1, 2, 2] which is not the case.\nThe expected answer to the given question is simply incorrect. Either the question needs to be rephrased or the expected solution has to be changed."
                    },
                    {
                        "username": "Sahil_Rana",
                        "content": "//can someone please find the problem in this code. It gives the following \\n//  output:\\n//  [[],[2],[2],[1]]\\n\\n\\nvector<vector<int>> ans;\\n\\n//ans.push_back({});\\n\\nvoid helper(vector<int>& nums, vector<int> v){\\n\\n    if(nums.size()==0){\\n        ans.push_back(v);\\n        return ;\\n    }\\n\\n    vector<int> v1=v;\\n    vector<int> v2=v;\\n     \\n     v2.push_back(nums[0]);\\n     nums.erase(nums.begin()+0);\\n\\n     helper(nums,v1);\\n     helper(nums,v2);\\n     return;\\n \\n}\\n\\n\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        \\n        vector<int> v;\\n        helper(nums,v);\\n\\n        return ans;\\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1789409,
                "content": [
                    {
                        "username": "shivam2612002",
                        "content": "to find subsets, a simple approach is to use a pick-skip method.\\nbut when we do have to find unique subsets, do we have to use for loop?\\ni mean can we do it without loops? "
                    },
                    {
                        "username": "AshleyXM",
                        "content": "The description of this problem is sooooooo ambiguous. The number of examples is too small to clarify the problem."
                    },
                    {
                        "username": "vaibhav_oo7",
                        "content": "class Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        Set<List<Integer>> ans = new HashSet<>();\\n        List<Integer> a = new ArrayList<>();\\n        subsetsall(nums,0,ans,a);\\n        List<List<Integer>> d = new ArrayList<>(ans);\\n        return d;\\n\\n    }\\n    public void subsetsall (int nums[], int index, Set<List<Integer>> subsets , List<Integer> subset){\\n        if(index==nums.length){\\n            subsets.add(subset);\\n        }\\n        else{\\n            subset.add(nums[index]);\\n            subsetsall(nums,index+1,subsets,subset);\\n            subset.remove(subset.size()-1);\\n            subsetsall(nums,index+1,subsets,subset);\\n        }\\n    }\\n}\\n\\nwhy this gives empty list  why is this wrong??\\n"
                    },
                    {
                        "username": "hemanth0010",
                        "content": "//why this code is not working\\nclass Solution {\\n    public void solve(int[] nums, int i, List<Integer> ds, Set<List<Integer>> st) {\\n        if (i == nums.length) {\\n            Collections.sort(ds);\\n            st.add(ds);\\n            return;\\n        }\\n        ds.add(nums[i]);\\n        solve(nums, i + 1, ds, st);\\n        ds.remove(ds.size() - 1);\\n        solve(nums, i + 1, ds, st);\\n    }\\n\\n    public List<List<Integer>> subsetsWithDup(int nums[]) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        Set<List<Integer>> st = new HashSet<>();\\n        List<Integer> ds = new ArrayList<>();\\n        solve(nums, 0, ds, st);\\n        for (List<Integer> v : st) {\\n            ans.add(v);\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Ayush_Kumar-01",
                        "content": "class Solution {\\n    void findit(vector<vector<int>>& ans,int index)\\n    {\\n        vector<vector<int>>::iterator it=ans.begin()+index;\\n        if(index>=ans.size())\\n        {\\n            return;\\n        }\\n        for(int i=index;i<ans.size();i++)\\n        {\\n            if(ans[index]==ans[i])\\n            {\\n                \\n                ans.erase(it);\\n            }\\n        }\\n        findit(ans,index+1);\\n    }\\n\\n    void solve(vector<int> nums, vector<int> output, int index, vector<vector<int> >& ans) {\\n        //base case\\n        if(index >= nums.size()) {\\n            ans.push_back(output);\\n            return ;\\n        }\\n        \\n        //exclude\\n        solve(nums, output, index+1, ans);\\n        \\n        //include\\n        int element = nums[index];\\n        output.push_back(element);\\n        solve(nums, output, index+1, ans);\\n\\n\\n        \\n        \\n    }\\n    \\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        vector<vector<int> > ans;\\n        vector<int> output;\\n        int index = 0;\\n        solve(nums, output, index, ans);\\n        findit(ans,0);\\n        sort(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n\\nplease help me and find out where i am doing a mistake"
                    },
                    {
                        "username": "hucancode",
                        "content": "Input need to be sorted before generating subset. It was not mentioned in the problem description."
                    },
                    {
                        "username": "pratham2712",
                        "content": "the solution is similar to the subset1 just think about duplicates.\\n\\n\\n\\nhint : set,sort"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "Sorting Matters"
                    },
                    {
                        "username": "Loncey",
                        "content": "The question says \"the solution set must not contain duplicate subsets.\", but the answer expects duplicate subsets of limited nature.\nIn the first example for nums = [1, 2, 2], subsets [1,2] and [1, 2, 2] are equal so one of them shouldn't be included, but the solution expects us to include both. And if every number of the same value were to be treated as a different object, then correct answer for an array [1, 2, 2] should include all combinations [], [1], [2], [2], [1,2], [1,2], [2, 2], [1, 2, 2] which is not the case.\nThe expected answer to the given question is simply incorrect. Either the question needs to be rephrased or the expected solution has to be changed."
                    },
                    {
                        "username": "Sahil_Rana",
                        "content": "//can someone please find the problem in this code. It gives the following \\n//  output:\\n//  [[],[2],[2],[1]]\\n\\n\\nvector<vector<int>> ans;\\n\\n//ans.push_back({});\\n\\nvoid helper(vector<int>& nums, vector<int> v){\\n\\n    if(nums.size()==0){\\n        ans.push_back(v);\\n        return ;\\n    }\\n\\n    vector<int> v1=v;\\n    vector<int> v2=v;\\n     \\n     v2.push_back(nums[0]);\\n     nums.erase(nums.begin()+0);\\n\\n     helper(nums,v1);\\n     helper(nums,v2);\\n     return;\\n \\n}\\n\\n\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        \\n        vector<int> v;\\n        helper(nums,v);\\n\\n        return ans;\\n        \\n    }\\n};"
                    }
                ]
            }
        ]
    },
    {
        "title": "Reverse Bits",
        "question_content": "<p>Reverse bits of a given 32 bits unsigned integer.</p>\n\n<p><strong>Note:</strong></p>\n\n<ul>\n\t<li>Note that in some languages, such as Java, there is no unsigned integer type. In this case, both input and output will be given as a signed integer type. They should not affect your implementation, as the integer&#39;s internal binary representation is the same, whether it is signed or unsigned.</li>\n\t<li>In Java, the compiler represents the signed integers using <a href=\"https://en.wikipedia.org/wiki/Two%27s_complement\" target=\"_blank\">2&#39;s complement notation</a>. Therefore, in <strong class=\"example\">Example 2</strong> above, the input represents the signed integer <code>-3</code> and the output represents the signed integer <code>-1073741825</code>.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 00000010100101000001111010011100\n<strong>Output:</strong>    964176192 (00111001011110000010100101000000)\n<strong>Explanation: </strong>The input binary string <strong>00000010100101000001111010011100</strong> represents the unsigned integer 43261596, so return 964176192 which its binary representation is <strong>00111001011110000010100101000000</strong>.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 11111111111111111111111111111101\n<strong>Output:</strong>   3221225471 (10111111111111111111111111111111)\n<strong>Explanation: </strong>The input binary string <strong>11111111111111111111111111111101</strong> represents the unsigned integer 4294967293, so return 3221225471 which its binary representation is <strong>10111111111111111111111111111111</strong>.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The input must be a <strong>binary string</strong> of length <code>32</code></li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong> If this function is called many times, how would you optimize it?</p>\n",
        "solutions": [
            {
                "id": 54738,
                "title": "sharing-my-2ms-java-solution-with-explanation",
                "content": "\\n\"\\nWe first intitialize result to 0. We then iterate from\\n0 to 31 (an integer has 32 bits).  In each iteration:  \\n  We first shift result to the left by 1 bit.\\n  Then, if the last digit of input n is 1, we add 1 to result. To\\n  find the last digit of n, we just do: (n & 1)\\n    Example, if n=5 (101), n&1 = 101 & 001 = 001 = 1;\\n    however, if n = 2 (10), n&1 = 10 & 01 = 00 = 0).\\n\\n  Finally, we update n by shifting it to the right by 1 (n >>= 1). This is because the last digit is already taken care of, so we need to drop it by shifting n to the right by 1.\\n\\nAt the end of the iteration, we return result.\\n\\nExample, if input n = 13 (represented in binary as\\n0000_0000_0000_0000_0000_0000_0000_1101, the \"_\" is for readability),\\ncalling reverseBits(13) should return:\\n1011_0000_0000_0000_0000_0000_0000_0000\\n\\nHere is how our algorithm would work for input n = 13:\\n\\nInitially, result = 0 = 0000_0000_0000_0000_0000_0000_0000_0000,\\nn = 13 = 0000_0000_0000_0000_0000_0000_0000_1101\\n\\nStarting for loop:\\n  i = 0:\\n    result = result << 1 = 0000_0000_0000_0000_0000_0000_0000_0000.\\n    n&1 = 0000_0000_0000_0000_0000_0000_0000_1101 \\n           & 0000_0000_0000_0000_0000_0000_0000_0001 \\n           = 0000_0000_0000_0000_0000_0000_0000_0001 = 1\\n          therefore result = result + 1 =\\n          0000_0000_0000_0000_0000_0000_0000_0000 \\n       + 0000_0000_0000_0000_0000_0000_0000_0001 \\n       = 0000_0000_0000_0000_0000_0000_0000_0001 = 1\\n    \\nNext, we right shift n by 1 (n >>= 1) (i.e. we drop the least significant bit) to get:\\n    n = 0000_0000_0000_0000_0000_0000_0000_0110.\\n    We then go to the next iteration.\\n\\n  i = 1:\\n    result = result << 1 = 0000_0000_0000_0000_0000_0000_0000_0010;\\n    n&1 = 0000_0000_0000_0000_0000_0000_0000_0110 &\\n          0000_0000_0000_0000_0000_0000_0000_0001\\n        = 0000_0000_0000_0000_0000_0000_0000_0000 = 0;\\n    therefore we don't increment result.\\n    We right shift n by 1 (n >>= 1) to get:\\n    n = 0000_0000_0000_0000_0000_0000_0000_0011.\\n    We then go to the next iteration.\\n\\n  i = 2:\\n    result = result << 1 = 0000_0000_0000_0000_0000_0000_0000_0100.\\n    n&1 = 0000_0000_0000_0000_0000_0000_0000_0011 &\\n          0000_0000_0000_0000_0000_0000_0000_0001 =\\n          0000_0000_0000_0000_0000_0000_0000_0001 = 1\\n          therefore result = result + 1 =\\n          0000_0000_0000_0000_0000_0000_0000_0100 +\\n          0000_0000_0000_0000_0000_0000_0000_0001 =\\n          result = 0000_0000_0000_0000_0000_0000_0000_0101\\n    We right shift n by 1 to get:\\n    n = 0000_0000_0000_0000_0000_0000_0000_0001.\\n    We then go to the next iteration.\\n\\n  i = 3:\\n    result = result << 1 = 0000_0000_0000_0000_0000_0000_0000_1010. \\n    n&1 = 0000_0000_0000_0000_0000_0000_0000_0001 &\\n              0000_0000_0000_0000_0000_0000_0000_0001 =\\n              0000_0000_0000_0000_0000_0000_0000_0001 = 1\\n          therefore result = result + 1 =\\n                           = 0000_0000_0000_0000_0000_0000_0000_1011\\n    We right shift n by 1 to get:\\n    n = 0000_0000_0000_0000_0000_0000_0000_0000 = 0.\\n\\n  Now, from here to the end of the iteration, n is 0, so (n&1)\\n  will always be 0 and and n >>=1 will not change n. The only change\\n  will be for result <<=1, i.e. shifting result to the left by 1 digit.\\n  Since there we have i=4 to i = 31 iterations left, this will result\\n  in padding 28 0's to the right of result. i.e at the end, we get\\n  result = 1011_0000_0000_0000_0000_0000_0000_0000\\n\\n  This is exactly what we expected to get\\n\"\\n\\n    \\n    public int reverseBits(int n) {\\n        if (n == 0) return 0;\\n        \\n        int result = 0;\\n        for (int i = 0; i < 32; i++) {\\n            result <<= 1;\\n            if ((n & 1) == 1) result++;\\n            n >>= 1;\\n        }\\n        return result;\\n    }",
                "solutionTags": [],
                "code": "\\n\"\\nWe first intitialize result to 0. We then iterate from\\n0 to 31 (an integer has 32 bits).  In each iteration:  \\n  We first shift result to the left by 1 bit.\\n  Then, if the last digit of input n is 1, we add 1 to result. To\\n  find the last digit of n, we just do: (n & 1)\\n    Example, if n=5 (101), n&1 = 101 & 001 = 001 = 1;\\n    however, if n = 2 (10), n&1 = 10 & 01 = 00 = 0).\\n\\n  Finally, we update n by shifting it to the right by 1 (n >>= 1). This is because the last digit is already taken care of, so we need to drop it by shifting n to the right by 1.\\n\\nAt the end of the iteration, we return result.\\n\\nExample, if input n = 13 (represented in binary as\\n0000_0000_0000_0000_0000_0000_0000_1101, the \"_\" is for readability),\\ncalling reverseBits(13) should return:\\n1011_0000_0000_0000_0000_0000_0000_0000\\n\\nHere is how our algorithm would work for input n = 13:\\n\\nInitially, result = 0 = 0000_0000_0000_0000_0000_0000_0000_0000,\\nn = 13 = 0000_0000_0000_0000_0000_0000_0000_1101\\n\\nStarting for loop:\\n  i = 0:\\n    result = result << 1 = 0000_0000_0000_0000_0000_0000_0000_0000.\\n    n&1 = 0000_0000_0000_0000_0000_0000_0000_1101 \\n           & 0000_0000_0000_0000_0000_0000_0000_0001 \\n           = 0000_0000_0000_0000_0000_0000_0000_0001 = 1\\n          therefore result = result + 1 =\\n          0000_0000_0000_0000_0000_0000_0000_0000 \\n       + 0000_0000_0000_0000_0000_0000_0000_0001 \\n       = 0000_0000_0000_0000_0000_0000_0000_0001 = 1\\n    \\nNext, we right shift n by 1 (n >>= 1) (i.e. we drop the least significant bit) to get:\\n    n = 0000_0000_0000_0000_0000_0000_0000_0110.\\n    We then go to the next iteration.\\n\\n  i = 1:\\n    result = result << 1 = 0000_0000_0000_0000_0000_0000_0000_0010;\\n    n&1 = 0000_0000_0000_0000_0000_0000_0000_0110 &\\n          0000_0000_0000_0000_0000_0000_0000_0001\\n        = 0000_0000_0000_0000_0000_0000_0000_0000 = 0;\\n    therefore we don't increment result.\\n    We right shift n by 1 (n >>= 1) to get:\\n    n = 0000_0000_0000_0000_0000_0000_0000_0011.\\n    We then go to the next iteration.\\n\\n  i = 2:\\n    result = result << 1 = 0000_0000_0000_0000_0000_0000_0000_0100.\\n    n&1 = 0000_0000_0000_0000_0000_0000_0000_0011 &\\n          0000_0000_0000_0000_0000_0000_0000_0001 =\\n          0000_0000_0000_0000_0000_0000_0000_0001 = 1\\n          therefore result = result + 1 =\\n          0000_0000_0000_0000_0000_0000_0000_0100 +\\n          0000_0000_0000_0000_0000_0000_0000_0001 =\\n          result = 0000_0000_0000_0000_0000_0000_0000_0101\\n    We right shift n by 1 to get:\\n    n = 0000_0000_0000_0000_0000_0000_0000_0001.\\n    We then go to the next iteration.\\n\\n  i = 3:\\n    result = result << 1 = 0000_0000_0000_0000_0000_0000_0000_1010. \\n    n&1 = 0000_0000_0000_0000_0000_0000_0000_0001 &\\n              0000_0000_0000_0000_0000_0000_0000_0001 =\\n              0000_0000_0000_0000_0000_0000_0000_0001 = 1\\n          therefore result = result + 1 =\\n                           = 0000_0000_0000_0000_0000_0000_0000_1011\\n    We right shift n by 1 to get:\\n    n = 0000_0000_0000_0000_0000_0000_0000_0000 = 0.\\n\\n  Now, from here to the end of the iteration, n is 0, so (n&1)\\n  will always be 0 and and n >>=1 will not change n. The only change\\n  will be for result <<=1, i.e. shifting result to the left by 1 digit.\\n  Since there we have i=4 to i = 31 iterations left, this will result\\n  in padding 28 0's to the right of result. i.e at the end, we get\\n  result = 1011_0000_0000_0000_0000_0000_0000_0000\\n\\n  This is exactly what we expected to get\\n\"\\n\\n    \\n    public int reverseBits(int n) {\\n        if (n == 0) return 0;\\n        \\n        int result = 0;\\n        for (int i = 0; i < 32; i++) {\\n            result <<= 1;\\n            if ((n & 1) == 1) result++;\\n            n >>= 1;\\n        }\\n        return result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 54741,
                "title": "o-1-bit-operation-c-solution-8ms",
                "content": "    class Solution {\\n    public:\\n        uint32_t reverseBits(uint32_t n) {\\n            n = (n >> 16) | (n << 16);\\n            n = ((n & 0xff00ff00) >> 8) | ((n & 0x00ff00ff) << 8);\\n            n = ((n & 0xf0f0f0f0) >> 4) | ((n & 0x0f0f0f0f) << 4);\\n            n = ((n & 0xcccccccc) >> 2) | ((n & 0x33333333) << 2);\\n            n = ((n & 0xaaaaaaaa) >> 1) | ((n & 0x55555555) << 1);\\n            return n;\\n        }\\n    };\\n\\nfor 8 bit binary number *abcdefgh*, the process is as follow:\\n\\n*abcdefgh -> efghabcd -> ghefcdab -> hgfedcba*",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        uint32_t reverseBits(uint32_t n) {\\n            n = (n >> 16) | (n << 16);\\n            n = ((n & 0xff00ff00) >> 8) | ((n & 0x00ff00ff) << 8);\\n            n = ((n & 0xf0f0f0f0) >> 4) | ((n & 0x0f0f0f0f) << 4);\\n            n = ((n & 0xcccccccc) >> 2) | ((n & 0x33333333) << 2);\\n            n = ((n & 0xaaaaaaaa) >> 1) | ((n & 0x55555555) << 1);\\n            return n;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1232842,
                "title": "java-c-0ms-o-1-time-complexity-in-place-detailed-explanation",
                "content": "<u>**COMPLEXITY**</u>\\n* **Time: O(1)**, constant time\\n* **Space: O(1)**, in-place\\n\\n\\n**BASIC IDEA**\\n\\tIn this implementation we have followed **\"Divide and Conquer\"** strategy where **Original problem is divided into sub problems**\\n\\n<iframe src=\"https://leetcode.com/playground/23MFqfwn/shared\" frameBorder=\"0\" width=\"100%\" height=\"300\"></iframe>\\n\\nLet\\'s understand in terms of decimal number to understand how the code is implemented\\n Suppose we have a number `12345678` and we have to reverse it to get `87654321` as desired output\\nThe process will be as follows:\\n\\t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`12345678` --> original number\\n1. \\t`56781234`\\n1. \\t`78563412`\\n1. \\t`87654321` --> desired number(reversed number)\\n\\nExplanation of above process is as follows:\\n\\t\\n* \\tDivide original number`(12345678)` into 2 parts(**4 - 4 each**)\\n    `1234|5678` and swap with each other i.e.\\n\\t&nbsp;&nbsp;&nbsp;&nbsp;|&#95;&#95;&#95;&#95;&#95;|\\n\\t\\n    `5678|1234`(it can also be said that we are **right shifting** the 1st part`(1234)` **to 4 places** from its original position and **left shifting** the 2nd part`(5678)` **to 4 places** from its original position)\\n\\n*   Divide this obtained number`(56781234)` into 4 parts(**2 - 2 each**)\\n    `56|78|12|34` and swap with each other i.e.\\n\\t&nbsp;&nbsp;&nbsp;|&#95;&#95;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&#95;&#95;|\\n\\t\\n    `78|56|34|12`(it can also be said that we are **right shifting** the 1st part`(56)` and 3rd part`(12)` **to 2 places** from their original positions and **left shifting** the 2nd part`(78)` and 4th part`(34)` **to 2 places** from their original positions)\\n\\n* Divide the obtained number`(78563412)` into 8 parts(**1 - 1 each**)\\n    `7|8|5|6|3|4|1|2` and swap with each other i.e.\\n\\t&nbsp;&nbsp;&nbsp;|&#95;|&nbsp;&nbsp;&nbsp;&nbsp;|&#95;|&nbsp;&nbsp;&nbsp;&nbsp;|&#95;|&nbsp;&nbsp;&nbsp;&nbsp;|&#95;|\\n\\t\\n    `8|7|6|5|4|3|2|1`(it can also be said that we are **right shifting** the 1st part`(7)`, 3rd part`(5)`, 5th part`(3)` and 7th part`(1)`  **to 1 place** from their original positions and **left shifting** the 2nd part`(8)`, 4th part`(6)`, 6th part`(4)` and 8th part`(2)`  **to 1 place** from their original positions)\\n\\t\\n    We got the desired output as `87654321`\\n\\t<hr>\\n\\t\\n\\t**Time to play with bits!!!!!!**\\n\\t\\n\\tTo get better understanding of how the 32 bits are reversed in binary, we will take 8 bits instead of 32.\\n\\t**If the number is of 8 bits**, **the bits will be reversed in 3 steps** as we are using **Divide and Conquer** approach which is nothing **dividing the original problem into sub problems** i.e. log(O(Number_Of_Bits)) i.e. log(O(8)) --> 3 and the same Idea applies **for 32 bits** where **the bits will be reversed in 5 steps** as log(O(32)) --> 5\\n\\t\\n\\tFirst let\\'s understand with 8 bits\\n\\tSuppose we have bits as 00010111 and we have to reverse it to get 11101000 as desired output\\n\\tThe Process will be as follows:\\n\\t00010111(8 bits)  --> Original Number\\n\\t\\n1. 01110001\\n1. 11010100\\n1. 11101000  --> Reversed Numer\\n\\nExplanation of above process is as follows:\\n\\n1. Divide original bits into 4 - 4 each (4 * 2 = 8 bits)\\n`0001|0111` and swap with each other i.e.\\n&nbsp;&nbsp;|&#95;&#95;&#95;&#95;&#95;|\\n`0111|0001` (It can also be said that we are **right shifting** 1st part(first 4 bits) **to 4 places** from their original positions and **left shifting** the 2nd part(last 4 bits) **to 4 places** from their original positions)<br>\\nFollowing is the process of doing it:\\na) **Preserve 1st part(first 4 bits)** and we know the property of bitwise and(&) opertor i.e. 0, 1 -> 0 and 1, 1 -> 1\\nFor this, we will take a mask in **hexadecimal form** and **apply bitwise and(&) to preserve the first 4 bits**\\n**mask = 0xf0** (which is nothing but `1111 0000` i.e. `1111`(15 == f) and 0000(0))\\n&nbsp;&nbsp;&nbsp;`0001 0111` --> num\\n&&nbsp;<u>`1111 0000`</u> --> 0xf0\\n&nbsp;&nbsp;&nbsp;`0001 0000`<br>\\nb) **Right shift** the obtained number from its original position **by 4 places** i.e. (num & 0xf0) >>> 4\\n&nbsp;&nbsp;&nbsp;&nbsp;`00000001`<br>\\nc) **Preserve the 2nd part(last 4 bits)**\\nFor this, will take a mask in **hexadecimal form** and **apply bitwise and(&) to preserve the last 4 bits**\\n**mask = 0x0f** (which is nothing but `0000 1111` i.e. `0000`(0) and `1111`(15 == f))\\n&nbsp;&nbsp;&nbsp;`0001 0111` --> num\\n&&nbsp;<u>`0000 1111`</u> --> 0x0f\\n&nbsp;&nbsp;&nbsp;`0000 0111`<br>\\nd) **Left shift** the obtained number from its original position **by 4 places** i.e. (num & 0x0f) << 4\\n &nbsp;&nbsp;&nbsp;`01110000`<br>\\n e) **Do the bitwise OR(|)** operation on both shifted numbers to **merge intermediate results** into a single number which is used as an input for the next step.\\n &nbsp;&nbsp;&nbsp;`0000 0001` --> number obtained by right shift at step b)\\n |&nbsp;&nbsp;<u>`0111 0000`</u> --> number obtained by left shift at step d)\\n &nbsp;&nbsp;&nbsp;`0111 0001`<br>\\nf) **Assign the result into num** after apply bitwise or into num again to proceed furthur\\n&nbsp;&nbsp;&nbsp;num = `01110001`\\n\\n**Till here, 1 of 3 steps of process has been completed. 2 More remaining!!!**\\n\\n2. Divide obtained bits(`01110001`) into 2 - 2 each (2 * 4 = 8 bits)\\n`01|11|00|01` and swap with each other i.e.\\n&nbsp;&nbsp;&nbsp;&nbsp;|&#95;&#95;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&#95;&#95;|\\n`11|01|01|00` (It can also be said that we are **right shifting** 1st part(01) and 3rd part(00) **to 2 places** from their original positions and **left shifting** the 2nd part(11) and 4th part(01) **to 2 places** from their original positions)<br>\\nFollowing is the process of doing it:\\na) **Preserve 1st part(01) and 3rd part(00)** and we know the property of bitwise and(&) opertor i.e. 0, 1 -> 0 and 1, 1 -> 1\\nFor this, we will take a mask in **hexadecimal form** and **apply bitwise and(&) to preserve 1st part(01) and 3rd part(00)**\\n**mask = 0xcc** (which is nothing but 1100 1100 i.e. (12 == c) and (12 == c))\\n&nbsp;&nbsp;&nbsp;`01 11 00 01` --> num\\n&&nbsp;<u>`11 00 11 00`</u> --> 0xcc\\n&nbsp;&nbsp;&nbsp;`01 00 00 00`<br>\\nb) **Right shift** the obtained number(`01 00 00 00`) from its original position **by 2 places** i.e. (num & 0xcc) >>> 2\\n&nbsp;&nbsp;&nbsp;&nbsp;`00 01 00 00`<br>\\nc) **Preserve the 2nd part(11) and 4th part(01)**\\nFor this, we will take a mask in **hexadecimal form** and **apply bitwise and(&) to preserve 2nd part(11) and 4th part(01)**\\n**mask = 0x33** (which is nothing but 0011 0011 i.e. 0011(3) and 0011(3))\\n&nbsp;&nbsp;&nbsp;`01 11 00 01` --> num\\n&&nbsp;<u>`00 11 00 11`</u> --> 0x33\\n&nbsp;&nbsp;&nbsp;`00 11 00 01`<br>\\nd) **Left shift** the obtained number(00 11 00 01) from its original position **by 2 places** i.e. (num & 0x33) << 2\\n &nbsp;&nbsp;&nbsp;`11 00 01 00`<br>\\n e) **Do the bitwise OR(|)** operation on both shifted numbers to **merge intermediate results** into a single number which is used as an input for the next step.\\n &nbsp;&nbsp;&nbsp;`00 01 00 00` --> number obtained by right shift at step b)\\n |&nbsp;&nbsp;<u>`11 00 01 00`</u> --> number obtained by left shift at step d)\\n &nbsp;&nbsp;&nbsp;`11 01 01 00`<br>\\nf) **Assign the result into num** after apply bitwise or into num again to proceed furthur\\n&nbsp;&nbsp;&nbsp;num = `11010100`\\n\\n**Till here, 2 of 3 steps of process has been completed. Only 1 more to go!!!!!!!!!**\\n\\n3. Divide obtained bits(`11010100`) into 1 - 1 each (1 * 8 = 8 bits)\\n1|1|0|1|0|1|0|0 and swap with each other i.e.\\n&nbsp;|&#95;|&nbsp;&nbsp;|&#95;|&nbsp;&nbsp;|&#95;|&nbsp;&nbsp;|&#95;|\\n1|1|1|0|1|0|0|0 (It can also be said that we are **right shifting** 1st(1), 3rd(0), 5th(0) and 7th(0) parts **to 1 place** from their original positions and **left shifting** the 2nd(1), 4th(1), 6th(1) and 8th(0) parts **to 1 place** from their original positions)<br>\\nFollowing is the process of doing it\\na) **Preserve 1st(1), 3rd(0), 5th(0) and 7th(0) parts** \\nWe know the property of bitwise and(&) opertor i.e. 0, 1 -> 0 and 1, 1 -> 1\\nFor this, we will take a mask in **hexadecimal form** and **apply bitwise and(&) to preserve 1st(1), 3rd(0), 5th(0) and 7th(0) parts**\\n**mask = 0xaa** (which is nothing but `1010 1010` i.e. (10 == a) and (10 == a))\\n&nbsp;&nbsp;&nbsp;`1 1 0 1 0 1 0 0` --> num\\n&&nbsp;<u>`1 0 1 0 1 0 1 0`</u> --> 0xaa\\n&nbsp;&nbsp;&nbsp;`1 0 0 0 0 0 0 0`<br>\\nb) **Right shift** the obtained number(`1 0 0 0 0 0 0 0`) from its original position **by 1 place** i.e. (num & 0xaa) >>> 1\\n&nbsp;&nbsp;&nbsp;&nbsp;`0 1 0 0 0 0 0 0`<br>\\nc) **Preserve the 2nd(1), 4th(1), 6th(1) and 8th(0) parts**\\nFor this, we will take a mask in **hexadecimal form** and **apply bitwise and(&) to preserve 2nd(1), 4th(1), 6th(1) and 8th(0) parts**\\n**mask = 0x55** (which is nothing but 0101 0101 i.e. 0101(5) and 0101(5))\\n&nbsp;&nbsp;&nbsp;`1 1 0 1 0 1 0 0` --> num\\n&&nbsp;<u>`0 1 0 1 0 1 0 1`</u> --> 0x55\\n&nbsp;&nbsp;&nbsp;`0 1 0 1 0 1 0 0`<br>\\nd) **Left shift** the obtained number(0 1 0 1 0 1 0 0) from its original position **by 1 place** i.e. (num & 0x55) << 1\\n &nbsp;&nbsp;&nbsp;`1 0 1 0 1 0 0 0`<br>\\n e) **Do the bitwise OR(|)** operation on both shifted numbers\\n &nbsp;&nbsp;&nbsp;`0 1 0 0 0 0 0 0` --> number obtained by right shift at step b)\\n |&nbsp;&nbsp;<u>`1 0 1 0 1 0 0 0`</u> --> number obtained by left shift at step d)\\n &nbsp;&nbsp;&nbsp;`1 1 1 0 1 0 0 0`<br>\\nf) **Assign the result into num** after apply bitwise or into num again\\n&nbsp;&nbsp;&nbsp;num = `11101000`\\n\\nNow, **return the num**.\\n\\n**We have finally reversed the original number i.e. `00010111` -> `11101000`**\\n<br>\\nSame idea goes for 32 bits \\neg: \\nbreak the 32 bits into half(16 - 16 each) and right shift 1st half part to 16 positions and left shift the 2nd half to 16 positions\\nbreak the 16 bits into half(8 - 8 each) and right shift to 8 positions and left shift to 8 positions\\nbreak the 8 bits into half(4 - 4 each) and right shift to 4 positions and left shift to 4 positions\\nbreak the 4 bits into half(2 - 2 each) and right shift to 2 positions and left shift to 2 positions\\nbreak the 2 bits into half(1 - 1 each) and right shift to 1 positions and left shift to 1 positions\\n\\n<u><strong>Refer to the following github repsitory for more leetcode solutions<strong></u>\\nhttps://github.com/Akshaya-Amar/LeetCodeSolutions\\n\\n# **Please UPVOTE if you find this post helpful :)**\\n",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "<u>**COMPLEXITY**</u>\\n* **Time: O(1)**, constant time\\n* **Space: O(1)**, in-place\\n\\n\\n**BASIC IDEA**\\n\\tIn this implementation we have followed **\"Divide and Conquer\"** strategy where **Original problem is divided into sub problems**\\n\\n<iframe src=\"https://leetcode.com/playground/23MFqfwn/shared\" frameBorder=\"0\" width=\"100%\" height=\"300\"></iframe>\\n\\nLet\\'s understand in terms of decimal number to understand how the code is implemented\\n Suppose we have a number `12345678` and we have to reverse it to get `87654321` as desired output\\nThe process will be as follows:\\n\\t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`12345678` --> original number\\n1. \\t`56781234`\\n1. \\t`78563412`\\n1. \\t`87654321` --> desired number(reversed number)\\n\\nExplanation of above process is as follows:\\n\\t\\n* \\tDivide original number`(12345678)` into 2 parts(**4 - 4 each**)\\n    `1234|5678` and swap with each other i.e.\\n\\t&nbsp;&nbsp;&nbsp;&nbsp;|&#95;&#95;&#95;&#95;&#95;|\\n\\t\\n    `5678|1234`(it can also be said that we are **right shifting** the 1st part`(1234)` **to 4 places** from its original position and **left shifting** the 2nd part`(5678)` **to 4 places** from its original position)\\n\\n*   Divide this obtained number`(56781234)` into 4 parts(**2 - 2 each**)\\n    `56|78|12|34` and swap with each other i.e.\\n\\t&nbsp;&nbsp;&nbsp;|&#95;&#95;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&#95;&#95;|\\n\\t\\n    `78|56|34|12`(it can also be said that we are **right shifting** the 1st part`(56)` and 3rd part`(12)` **to 2 places** from their original positions and **left shifting** the 2nd part`(78)` and 4th part`(34)` **to 2 places** from their original positions)\\n\\n* Divide the obtained number`(78563412)` into 8 parts(**1 - 1 each**)\\n    `7|8|5|6|3|4|1|2` and swap with each other i.e.\\n\\t&nbsp;&nbsp;&nbsp;|&#95;|&nbsp;&nbsp;&nbsp;&nbsp;|&#95;|&nbsp;&nbsp;&nbsp;&nbsp;|&#95;|&nbsp;&nbsp;&nbsp;&nbsp;|&#95;|\\n\\t\\n    `8|7|6|5|4|3|2|1`(it can also be said that we are **right shifting** the 1st part`(7)`, 3rd part`(5)`, 5th part`(3)` and 7th part`(1)`  **to 1 place** from their original positions and **left shifting** the 2nd part`(8)`, 4th part`(6)`, 6th part`(4)` and 8th part`(2)`  **to 1 place** from their original positions)\\n\\t\\n    We got the desired output as `87654321`\\n\\t<hr>\\n\\t\\n\\t**Time to play with bits!!!!!!**\\n\\t\\n\\tTo get better understanding of how the 32 bits are reversed in binary, we will take 8 bits instead of 32.\\n\\t**If the number is of 8 bits**, **the bits will be reversed in 3 steps** as we are using **Divide and Conquer** approach which is nothing **dividing the original problem into sub problems** i.e. log(O(Number_Of_Bits)) i.e. log(O(8)) --> 3 and the same Idea applies **for 32 bits** where **the bits will be reversed in 5 steps** as log(O(32)) --> 5\\n\\t\\n\\tFirst let\\'s understand with 8 bits\\n\\tSuppose we have bits as 00010111 and we have to reverse it to get 11101000 as desired output\\n\\tThe Process will be as follows:\\n\\t00010111(8 bits)  --> Original Number\\n\\t\\n1. 01110001\\n1. 11010100\\n1. 11101000  --> Reversed Numer\\n\\nExplanation of above process is as follows:\\n\\n1. Divide original bits into 4 - 4 each (4 * 2 = 8 bits)\\n`0001|0111` and swap with each other i.e.\\n&nbsp;&nbsp;|&#95;&#95;&#95;&#95;&#95;|\\n`0111|0001` (It can also be said that we are **right shifting** 1st part(first 4 bits) **to 4 places** from their original positions and **left shifting** the 2nd part(last 4 bits) **to 4 places** from their original positions)<br>\\nFollowing is the process of doing it:\\na) **Preserve 1st part(first 4 bits)** and we know the property of bitwise and(&) opertor i.e. 0, 1 -> 0 and 1, 1 -> 1\\nFor this, we will take a mask in **hexadecimal form** and **apply bitwise and(&) to preserve the first 4 bits**\\n**mask = 0xf0** (which is nothing but `1111 0000` i.e. `1111`(15 == f) and 0000(0))\\n&nbsp;&nbsp;&nbsp;`0001 0111` --> num\\n&&nbsp;<u>`1111 0000`</u> --> 0xf0\\n&nbsp;&nbsp;&nbsp;`0001 0000`<br>\\nb) **Right shift** the obtained number from its original position **by 4 places** i.e. (num & 0xf0) >>> 4\\n&nbsp;&nbsp;&nbsp;&nbsp;`00000001`<br>\\nc) **Preserve the 2nd part(last 4 bits)**\\nFor this, will take a mask in **hexadecimal form** and **apply bitwise and(&) to preserve the last 4 bits**\\n**mask = 0x0f** (which is nothing but `0000 1111` i.e. `0000`(0) and `1111`(15 == f))\\n&nbsp;&nbsp;&nbsp;`0001 0111` --> num\\n&&nbsp;<u>`0000 1111`</u> --> 0x0f\\n&nbsp;&nbsp;&nbsp;`0000 0111`<br>\\nd) **Left shift** the obtained number from its original position **by 4 places** i.e. (num & 0x0f) << 4\\n &nbsp;&nbsp;&nbsp;`01110000`<br>\\n e) **Do the bitwise OR(|)** operation on both shifted numbers to **merge intermediate results** into a single number which is used as an input for the next step.\\n &nbsp;&nbsp;&nbsp;`0000 0001` --> number obtained by right shift at step b)\\n |&nbsp;&nbsp;<u>`0111 0000`</u> --> number obtained by left shift at step d)\\n &nbsp;&nbsp;&nbsp;`0111 0001`<br>\\nf) **Assign the result into num** after apply bitwise or into num again to proceed furthur\\n&nbsp;&nbsp;&nbsp;num = `01110001`\\n\\n**Till here, 1 of 3 steps of process has been completed. 2 More remaining!!!**\\n\\n2. Divide obtained bits(`01110001`) into 2 - 2 each (2 * 4 = 8 bits)\\n`01|11|00|01` and swap with each other i.e.\\n&nbsp;&nbsp;&nbsp;&nbsp;|&#95;&#95;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&#95;&#95;|\\n`11|01|01|00` (It can also be said that we are **right shifting** 1st part(01) and 3rd part(00) **to 2 places** from their original positions and **left shifting** the 2nd part(11) and 4th part(01) **to 2 places** from their original positions)<br>\\nFollowing is the process of doing it:\\na) **Preserve 1st part(01) and 3rd part(00)** and we know the property of bitwise and(&) opertor i.e. 0, 1 -> 0 and 1, 1 -> 1\\nFor this, we will take a mask in **hexadecimal form** and **apply bitwise and(&) to preserve 1st part(01) and 3rd part(00)**\\n**mask = 0xcc** (which is nothing but 1100 1100 i.e. (12 == c) and (12 == c))\\n&nbsp;&nbsp;&nbsp;`01 11 00 01` --> num\\n&&nbsp;<u>`11 00 11 00`</u> --> 0xcc\\n&nbsp;&nbsp;&nbsp;`01 00 00 00`<br>\\nb) **Right shift** the obtained number(`01 00 00 00`) from its original position **by 2 places** i.e. (num & 0xcc) >>> 2\\n&nbsp;&nbsp;&nbsp;&nbsp;`00 01 00 00`<br>\\nc) **Preserve the 2nd part(11) and 4th part(01)**\\nFor this, we will take a mask in **hexadecimal form** and **apply bitwise and(&) to preserve 2nd part(11) and 4th part(01)**\\n**mask = 0x33** (which is nothing but 0011 0011 i.e. 0011(3) and 0011(3))\\n&nbsp;&nbsp;&nbsp;`01 11 00 01` --> num\\n&&nbsp;<u>`00 11 00 11`</u> --> 0x33\\n&nbsp;&nbsp;&nbsp;`00 11 00 01`<br>\\nd) **Left shift** the obtained number(00 11 00 01) from its original position **by 2 places** i.e. (num & 0x33) << 2\\n &nbsp;&nbsp;&nbsp;`11 00 01 00`<br>\\n e) **Do the bitwise OR(|)** operation on both shifted numbers to **merge intermediate results** into a single number which is used as an input for the next step.\\n &nbsp;&nbsp;&nbsp;`00 01 00 00` --> number obtained by right shift at step b)\\n |&nbsp;&nbsp;<u>`11 00 01 00`</u> --> number obtained by left shift at step d)\\n &nbsp;&nbsp;&nbsp;`11 01 01 00`<br>\\nf) **Assign the result into num** after apply bitwise or into num again to proceed furthur\\n&nbsp;&nbsp;&nbsp;num = `11010100`\\n\\n**Till here, 2 of 3 steps of process has been completed. Only 1 more to go!!!!!!!!!**\\n\\n3. Divide obtained bits(`11010100`) into 1 - 1 each (1 * 8 = 8 bits)\\n1|1|0|1|0|1|0|0 and swap with each other i.e.\\n&nbsp;|&#95;|&nbsp;&nbsp;|&#95;|&nbsp;&nbsp;|&#95;|&nbsp;&nbsp;|&#95;|\\n1|1|1|0|1|0|0|0 (It can also be said that we are **right shifting** 1st(1), 3rd(0), 5th(0) and 7th(0) parts **to 1 place** from their original positions and **left shifting** the 2nd(1), 4th(1), 6th(1) and 8th(0) parts **to 1 place** from their original positions)<br>\\nFollowing is the process of doing it\\na) **Preserve 1st(1), 3rd(0), 5th(0) and 7th(0) parts** \\nWe know the property of bitwise and(&) opertor i.e. 0, 1 -> 0 and 1, 1 -> 1\\nFor this, we will take a mask in **hexadecimal form** and **apply bitwise and(&) to preserve 1st(1), 3rd(0), 5th(0) and 7th(0) parts**\\n**mask = 0xaa** (which is nothing but `1010 1010` i.e. (10 == a) and (10 == a))\\n&nbsp;&nbsp;&nbsp;`1 1 0 1 0 1 0 0` --> num\\n&&nbsp;<u>`1 0 1 0 1 0 1 0`</u> --> 0xaa\\n&nbsp;&nbsp;&nbsp;`1 0 0 0 0 0 0 0`<br>\\nb) **Right shift** the obtained number(`1 0 0 0 0 0 0 0`) from its original position **by 1 place** i.e. (num & 0xaa) >>> 1\\n&nbsp;&nbsp;&nbsp;&nbsp;`0 1 0 0 0 0 0 0`<br>\\nc) **Preserve the 2nd(1), 4th(1), 6th(1) and 8th(0) parts**\\nFor this, we will take a mask in **hexadecimal form** and **apply bitwise and(&) to preserve 2nd(1), 4th(1), 6th(1) and 8th(0) parts**\\n**mask = 0x55** (which is nothing but 0101 0101 i.e. 0101(5) and 0101(5))\\n&nbsp;&nbsp;&nbsp;`1 1 0 1 0 1 0 0` --> num\\n&&nbsp;<u>`0 1 0 1 0 1 0 1`</u> --> 0x55\\n&nbsp;&nbsp;&nbsp;`0 1 0 1 0 1 0 0`<br>\\nd) **Left shift** the obtained number(0 1 0 1 0 1 0 0) from its original position **by 1 place** i.e. (num & 0x55) << 1\\n &nbsp;&nbsp;&nbsp;`1 0 1 0 1 0 0 0`<br>\\n e) **Do the bitwise OR(|)** operation on both shifted numbers\\n &nbsp;&nbsp;&nbsp;`0 1 0 0 0 0 0 0` --> number obtained by right shift at step b)\\n |&nbsp;&nbsp;<u>`1 0 1 0 1 0 0 0`</u> --> number obtained by left shift at step d)\\n &nbsp;&nbsp;&nbsp;`1 1 1 0 1 0 0 0`<br>\\nf) **Assign the result into num** after apply bitwise or into num again\\n&nbsp;&nbsp;&nbsp;num = `11101000`\\n\\nNow, **return the num**.\\n\\n**We have finally reversed the original number i.e. `00010111` -> `11101000`**\\n<br>\\nSame idea goes for 32 bits \\neg: \\nbreak the 32 bits into half(16 - 16 each) and right shift 1st half part to 16 positions and left shift the 2nd half to 16 positions\\nbreak the 16 bits into half(8 - 8 each) and right shift to 8 positions and left shift to 8 positions\\nbreak the 8 bits into half(4 - 4 each) and right shift to 4 positions and left shift to 4 positions\\nbreak the 4 bits into half(2 - 2 each) and right shift to 2 positions and left shift to 2 positions\\nbreak the 2 bits into half(1 - 1 each) and right shift to 1 positions and left shift to 1 positions\\n\\n<u><strong>Refer to the following github repsitory for more leetcode solutions<strong></u>\\nhttps://github.com/Akshaya-Amar/LeetCodeSolutions\\n\\n# **Please UPVOTE if you find this post helpful :)**\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 54746,
                "title": "java-solution-and-optimization",
                "content": "The Java solution is straightforward, just bitwise operation:\\n\\n    public int reverseBits(int n) {\\n        int result = 0;\\n        for (int i = 0; i < 32; i++) {\\n            result += n & 1;\\n            n >>>= 1;   // CATCH: must do unsigned shift\\n            if (i < 31) // CATCH: for last digit, don't shift!\\n                result <<= 1;\\n        }\\n        return result;\\n    }\\n\\nHow to optimize if this function is called multiple times? We can divide an int into 4 bytes, and reverse each byte then combine into an int. For each byte, we can use cache to improve performance.\\n\\n    // cache\\n    private final Map<Byte, Integer> cache = new HashMap<Byte, Integer>();\\n    public int reverseBits(int n) {\\n        byte[] bytes = new byte[4];\\n        for (int i = 0; i < 4; i++) // convert int into 4 bytes\\n            bytes[i] = (byte)((n >>> 8*i) & 0xFF);\\n        int result = 0;\\n        for (int i = 0; i < 4; i++) {\\n            result += reverseByte(bytes[i]); // reverse per byte\\n            if (i < 3)\\n                result <<= 8;\\n        }\\n        return result;\\n    }\\n    \\n    private int reverseByte(byte b) {\\n        Integer value = cache.get(b); // first look up from cache\\n        if (value != null)\\n            return value;\\n        value = 0;\\n        // reverse by bit\\n        for (int i = 0; i < 8; i++) {\\n            value += ((b >>> i) & 1);\\n            if (i < 7)\\n                value <<= 1;\\n        }\\n        cache.put(b, value);\\n        return value;\\n    }",
                "solutionTags": [],
                "code": "The Java solution is straightforward, just bitwise operation:\\n\\n    public int reverseBits(int n) {\\n        int result = 0;\\n        for (int i = 0; i < 32; i++) {\\n            result += n & 1;\\n            n >>>= 1;   // CATCH: must do unsigned shift\\n            if (i < 31) // CATCH: for last digit, don't shift!\\n                result <<= 1;\\n        }\\n        return result;\\n    }\\n\\nHow to optimize if this function is called multiple times? We can divide an int into 4 bytes, and reverse each byte then combine into an int. For each byte, we can use cache to improve performance.\\n\\n    // cache\\n    private final Map<Byte, Integer> cache = new HashMap<Byte, Integer>();\\n    public int reverseBits(int n) {\\n        byte[] bytes = new byte[4];\\n        for (int i = 0; i < 4; i++) // convert int into 4 bytes\\n            bytes[i] = (byte)((n >>> 8*i) & 0xFF);\\n        int result = 0;\\n        for (int i = 0; i < 4; i++) {\\n            result += reverseByte(bytes[i]); // reverse per byte\\n            if (i < 3)\\n                result <<= 8;\\n        }\\n        return result;\\n    }\\n    \\n    private int reverseByte(byte b) {\\n        Integer value = cache.get(b); // first look up from cache\\n        if (value != null)\\n            return value;\\n        value = 0;\\n        // reverse by bit\\n        for (int i = 0; i < 8; i++) {\\n            value += ((b >>> i) & 1);\\n            if (i < 7)\\n                value <<= 1;\\n        }\\n        cache.put(b, value);\\n        return value;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 54760,
                "title": "my-3ms-pure-c-solution",
                "content": "    uint32_t reverseBits(uint32_t n) {\\n        uint32_t m = 0;\\n        for (int i = 0; i < 32; i++, n >>= 1) {\\n            m <<= 1;\\n            m |= n & 1;\\n        }\\n        return m;\\n    }\\n\\nThe process is straightforward, just iterate over all bits.",
                "solutionTags": [],
                "code": "    uint32_t reverseBits(uint32_t n) {\\n        uint32_t m = 0;\\n        for (int i = 0; i < 32; i++, n >>= 1) {\\n            m <<= 1;\\n            m |= n & 1;\\n        }\\n        return m;\\n    }\\n\\nThe process is straightforward, just iterate over all bits.",
                "codeTag": "Unknown"
            },
            {
                "id": 54748,
                "title": "ac-python-44-ms-solution-bit-manipulation",
                "content": "    def reverseBits(self, n):\\n        ans = 0\\n        for i in xrange(32):\\n            ans = (ans << 1) + (n & 1)\\n            n >>= 1\\n        return ans\\n\\n\\n    # 600 / 600 test cases passed.\\n    # Status: Accepted\\n    # Runtime: 44 ms\\n    # 98.59%\\n\\n\\n\\nJust generate the answer bit by bit, do not use things like \"% 2\" or \"2 ** k\" or \"bin\". Bit manipulation is a lot faster. One small thing is the plus operator can be replaced by \"bitwise or\", aka \"|\". However i found plus is more readable and fast in python.",
                "solutionTags": [],
                "code": "    def reverseBits(self, n):\\n        ans = 0\\n        for i in xrange(32):\\n            ans = (ans << 1) + (n & 1)\\n            n >>= 1\\n        return ans\\n\\n\\n    # 600 / 600 test cases passed.\\n    # Status: Accepted\\n    # Runtime: 44 ms\\n    # 98.59%\\n\\n\\n\\nJust generate the answer bit by bit, do not use things like \"% 2\" or \"2 ** k\" or \"bin\". Bit manipulation is a lot faster. One small thing is the plus operator can be replaced by \"bitwise or\", aka \"|\". However i found plus is more readable and fast in python.",
                "codeTag": "Python3"
            },
            {
                "id": 54772,
                "title": "the-concise-c-solution-9ms",
                "content": "    class Solution {\\n    public:\\n        uint32_t  reverseBits(uint32_t n) {\\n            uint32_t result= 0;\\n            for(int i=0; i<32; i++)\\n                result = (result<<1) + (n>>i &1);\\n            \\n            return result;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        uint32_t  reverseBits(uint32_t n) {\\n            uint32_t result= 0;\\n            for(int i=0; i<32; i++)\\n                result = (result<<1) + (n>>i &1);\\n            \\n            return result;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 732138,
                "title": "python-o-32-simple-solution-explained",
                "content": "We are asked to reverse bits in our number. What is the most logical way to do it? Create number `out`, process original number bit by bit from end and add this bit to the end of our `out` number, and that is all! Why it is works? \\n1. `out = (out << 1)^(n & 1)` adds last bit of `n` to `out`\\n2. `n >>= 1` removes last bit from `n`.\\n\\nImagine number `n = 11011010`, and `out = 0`\\n1. `out = 0`, `n = 1101101`\\n2. `out = 01`, `n = 110110`\\n3. `out = 010`, `n = 11011`\\n4. `out = 0101`, `n = 1101`\\n5. `out = 01011`, `n = 110`\\n6. `out = 010110`, `n = 11`\\n7. `out = 0101101`, `n = 1`\\n8. `out = 01011011`, `n = 0` \\n\\n**Compexity**: time complexity is `O(32)`, space complexity is `O(1)`.\\n\\n**Follow up** There is `O(5)` smart solution which quite impressive, see the most voted post in discussion by @tworuler. We also can hash some `8`-bits parts, so we can inverse `4` parts on the fly, with time complexity `O(4)` and memory complexity `O(256)` (and preprocessing `O(256)` as well).\\n\\n\\n\\n```\\nclass Solution:\\n    def reverseBits(self, n):\\n        out = 0\\n        for i in range(32):\\n            out = (out << 1)^(n & 1)\\n            n >>= 1\\n        return out\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def reverseBits(self, n):\\n        out = 0\\n        for i in range(32):\\n            out = (out << 1)^(n & 1)\\n            n >>= 1\\n        return out\\n```",
                "codeTag": "Java"
            },
            {
                "id": 55011,
                "title": "javascript-solution",
                "content": "    var reverseBits = function(n) {\\n      var result = 0;\\n      var count = 32;\\n    \\n      while (count--) {\\n        result *= 2;\\n        result += n & 1;\\n        n = n >> 1;\\n      }\\n      return result;\\n    };",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "    var reverseBits = function(n) {\\n      var result = 0;\\n      var count = 32;\\n    \\n      while (count--) {\\n        result *= 2;\\n        result += n & 1;\\n        n = n >> 1;\\n      }\\n      return result;\\n    };",
                "codeTag": "Unknown"
            },
            {
                "id": 54740,
                "title": "python-ac-with-63ms-3lines",
                "content": "    class Solution:\\n        # @param n, an integer\\n        # @return an integer\\n        def reverseBits(self, n):\\n            oribin='{0:032b}'.format(n)\\n            reversebin=oribin[::-1]\\n            return int(reversebin,2)",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n        # @param n, an integer\\n        # @return an integer\\n        def reverseBits(self, n):\\n            oribin='{0:032b}",
                "codeTag": "Java"
            },
            {
                "id": 1334532,
                "title": "c-simple-and-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        uint32_t res = 0;\\n        \\n        for (int i = 0; i < 32; i++) {\\n            res <<= 1;\\n            res += n % 2;\\n            n >>= 1;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        uint32_t res = 0;\\n        \\n        for (int i = 0; i < 32; i++) {\\n            res <<= 1;\\n            res += n % 2;\\n            n >>= 1;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1791099,
                "title": "python-3-40ms-real-bit-manipulation-solution",
                "content": "```\\nclass Solution:\\n    def reverseBits(self, n: int) -> int:\\n        res = 0\\n        for _ in range(32):\\n            res = (res<<1) + (n&1)\\n            n>>=1\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def reverseBits(self, n: int) -> int:\\n        res = 0\\n        for _ in range(32):\\n            res = (res<<1) + (n&1)\\n            n>>=1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 54938,
                "title": "a-short-simple-java-solution",
                "content": "public int reverseBits(int n) {\\n\\n        int res=0;\\n        for(int i=0;i<32;i++){\\n        \\tres= ( res << 1 ) | ( n & 1 );         \\n        \\tn = n >> 1;                  \\n        }\\n        return res;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "public int reverseBits(int n) {\\n\\n        int res=0;\\n        for(int i=0;i<32;i++){\\n        \\tres= ( res << 1 ) | ( n & 1 );         \\n        \\tn = n >> 1;                  \\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 54950,
                "title": "concise-java-solution",
                "content": "     public int reverseBits(int n) {\\n\\t  int result = 0;\\n\\t  for (int i = 0; i < 32; ++i) {\\n\\t    result = result<<1  | (n & 1);\\n\\t    n >>>= 1;\\n\\t  }\\n\\treturn result;  }",
                "solutionTags": [],
                "code": "     public int reverseBits(int n) {\\n\\t  int result = 0;\\n\\t  for (int i = 0; i < 32; ++i) {\\n\\t    result = result<<1  | (n & 1);\\n\\t    n >>>= 1;\\n\\t  }\\n\\treturn result;  }",
                "codeTag": "Unknown"
            },
            {
                "id": 55042,
                "title": "8ms-c-code-some-ideas-about-optimization-spoiler",
                "content": "The key idea of the optimization is to look up a 4 bit chuck and find out what the reverse is. For example, reverse of 0001 is 1000 (in decimal reverse of 1 is 8). Another example, reverse of 1010 is 0101, meaning reverse of 10 is 5. \\n\\nBased on this idea we could create a look up table:\\n\\nvalue -> reverse\\n\\n0  ------>  0\\n\\n1  ------> 8\\n\\n... ------> ...\\n\\n15 ------> 15\\n\\nThis can be further optimized by using bytes lookup table of size 256 but I am too lazy to generate the table : ).  Note, place the table initialization outside the reverseBits() routine is necessary for performance.\\n\\n\\nIn theory, using look up table may improve the performance as we are dealing with 4 bits each time. Comparing to the method that iteratively swaps two bits each time, the method below should be faster.\\nGiven the 600 test cases, the performance difference is not dramatic though.\\n\\n\\n\\nDuring each iteration, shift the output 4 bits to the left, and discard the lowest 4 bits from the input. Make sure the reverse of current lowest 4 bits is saved to the current highest 4 bits in the output. \\n\\n\\n\\n    char tb[16] = {0,8,4,12,2,10,6,14,1,9,5,13,3,11,7,15};\\n\\n    uint32_t reverseBits(uint32_t n) {\\n            int curr = 0;\\n            uint32_t ret = 0;\\n            uint32_t msk = 0xF;\\n            for(int i = 0; i< 8; i++) {\\n                ret = ret << 4;\\n                curr = msk&n;\\n                ret |= tb[curr];\\n                n = n >> 4;\\n            }\\n            return ret;\\n    }",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "The key idea of the optimization is to look up a 4 bit chuck and find out what the reverse is. For example, reverse of 0001 is 1000 (in decimal reverse of 1 is 8). Another example, reverse of 1010 is 0101, meaning reverse of 10 is 5. \\n\\nBased on this idea we could create a look up table:\\n\\nvalue -> reverse\\n\\n0  ------>  0\\n\\n1  ------> 8\\n\\n... ------> ...\\n\\n15 ------> 15\\n\\nThis can be further optimized by using bytes lookup table of size 256 but I am too lazy to generate the table : ).  Note, place the table initialization outside the reverseBits() routine is necessary for performance.\\n\\n\\nIn theory, using look up table may improve the performance as we are dealing with 4 bits each time. Comparing to the method that iteratively swaps two bits each time, the method below should be faster.\\nGiven the 600 test cases, the performance difference is not dramatic though.\\n\\n\\n\\nDuring each iteration, shift the output 4 bits to the left, and discard the lowest 4 bits from the input. Make sure the reverse of current lowest 4 bits is saved to the current highest 4 bits in the output. \\n\\n\\n\\n    char tb[16] = {0,8,4,12,2,10,6,14,1,9,5,13,3,11,7,15};\\n\\n    uint32_t reverseBits(uint32_t n) {\\n            int curr = 0;\\n            uint32_t ret = 0;\\n            uint32_t msk = 0xF;\\n            for(int i = 0; i< 8; i++) {\\n                ret = ret << 4;\\n                curr = msk&n;\\n                ret |= tb[curr];\\n                n = n >> 4;\\n            }\\n            return ret;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 54765,
                "title": "one-line-solution-in-python",
                "content": "I love Python! It has such a lot of cool features with string manipulation, such as slicing.\\n\\n    def reverseBits(self, n):\\n        return int(bin(n)[2:].zfill(32)[::-1], 2)\\n\\nRuntime is 52ms. Slower than most solutions posted here though. I'm just trying to get my hands dirty on Python :)",
                "solutionTags": [],
                "code": "I love Python! It has such a lot of cool features with string manipulation, such as slicing.\\n\\n    def reverseBits(self, n):\\n        return int(bin(n)[2:].zfill(32)[::-1], 2)\\n\\nRuntime is 52ms. Slower than most solutions posted here though. I'm just trying to get my hands dirty on Python :)",
                "codeTag": "Python3"
            },
            {
                "id": 2680791,
                "title": "handwritten-solution",
                "content": "![image](https://assets.leetcode.com/users/images/0f627884-02ec-42ef-bffe-e79fe6b08cd4_1665309768.1695473.jpeg)\\n![image](https://assets.leetcode.com/users/images/30ef3d02-0e36-4dd2-976b-305e6be99d30_1665309849.1929986.jpeg)\\n![image](https://assets.leetcode.com/users/images/53f628b4-6a5f-49d9-a59e-40e47b069473_1665309881.6886282.jpeg)\\n**\\n//CODE-\\n\\npublic class Solution {\\n    // you need treat n as an unsigned value\\n    public int reverseBits(int n) {\\n\\t\\n       int ans = 0;\\n        for(int i=0;i<32;i++){\\n            int lsb = n & 1 ;\\n            int temp= lsb<<(31-i);\\n            ans = ans|temp;\\n            n = n>>1;\\n        }\\n        return ans;\\n    }\\n}\\n\\n",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "class Solution {\\n    // you need treat n as an unsigned value\\n    public int reverseBits(int n) {\\n\\t\\n       int ans = 0;\\n        for(int i=0;i<32;i++){\\n            int lsb = n & 1 ;\\n            int temp= lsb<<(31-i);\\n            ans = ans|temp;\\n            n = n>>1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2089559,
                "title": "python-fast-beginer-freendly",
                "content": "**UPVOTE IF HELPFuuL**\\n\\n**SOME PYTHON FUNCTIONS**\\n\\n* ```bin(n)``` -> Converts a decimal to binary, Result is returned as a string with ```0b``` as a prefix. \\n**EG**-> ```bin(7) -> \"0b111\"```\\n\\n* ```s=s[i:]``` ->String slicing -> It return the substring starting from index ```i```. \\n**EG**-> ```s=\"0b111\" -> s[2:] = \"111\"```\\n\\n* ```s=s[::-1]``` ->String slicing -> With no two initial arguments, it reverses the string. \\n**EG** -> ```s=\"0101\", s[::-1]=\"1010\"```\\n\\n* ```int(s,2)```->converts a binary string to a decimal number. \\n**EG**-> ```int(\"101\",2) = 5```\\n\\n\\n```\\nclass Solution:\\n    def reverseBits(self, n: int) -> int:\\n        s=bin(n)\\n        s=s[2:]\\n        s=s[::-1] + (\"0\"*(32-len(s)))\\n        return int(s,2)\\n\\t\\t\\n\\t\\t#  (\"0\"*(32-len(s))) is added to reversed string AS WE ARE TO ASSUME INITIAL NUMBER IS 32 bit, so all preceding zeroes will now be at end.\\n```\\n\\n![image](https://assets.leetcode.com/users/images/4049293b-de11-4b60-9320-cd56c5bbcf44_1657465280.5308366.jpeg)\\n\\n",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation"
                ],
                "code": "```bin(n)```\n```0b```\n```bin(7) -> \"0b111\"```\n```s=s[i:]```\n```i```\n```s=\"0b111\" -> s[2:] = \"111\"```\n```s=s[::-1]```\n```s=\"0101\", s[::-1]=\"1010\"```\n```int(s,2)```\n```int(\"101\",2) = 5```\n```\\nclass Solution:\\n    def reverseBits(self, n: int) -> int:\\n        s=bin(n)\\n        s=s[2:]\\n        s=s[::-1] + (\"0\"*(32-len(s)))\\n        return int(s,2)\\n\\t\\t\\n\\t\\t#  (\"0\"*(32-len(s))) is added to reversed string AS WE ARE TO ASSUME INITIAL NUMBER IS 32 bit, so all preceding zeroes will now be at end.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2795526,
                "title": "java-bit-manipulation-easy",
                "content": "### **Please Upvote** :D\\n```\\npublic class Solution {\\n    public int reverseBits(int n) {\\n        int rev = 0;\\n        for (int i = 0; i < 32; i++) {\\n            rev <<= 1;\\n            rev |= (n & 1);\\n            n >>= 1;\\n        }\\n        return rev;\\n    }\\n}\\n\\n// TC: O(1)\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\npublic class Solution {\\n    public int reverseBits(int n) {\\n        int rev = 0;\\n        for (int i = 0; i < 32; i++) {\\n            rev <<= 1;\\n            rev |= (n & 1);\\n            n >>= 1;\\n        }\\n        return rev;\\n    }\\n}\\n\\n// TC: O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3218837,
                "title": "190-solution-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nWe can reverse bits of a given number by iterating over all bits of the given number and adding the bits in the reverse order. To reverse the bits, we can use a variable and left shift it by 1 in each iteration. We can then add the last bit of the given number to the reversed number by performing an AND operation with the last bit of the given number. Once we add the last bit of the given number, we can right shift the given number by 1 to remove the last bit.\\n\\nAlgorithm:\\n\\n1. Initialize the reversed number to 0.\\n2. Iterate over all 32 bits of the given number.\\n3. In each iteration, left shift the reversed number by 1 and add the last bit of the given number to it.\\n4. To add the last bit of the given number to the reversed number, perform an AND operation with the given number and 1.\\n5. Right shift the given number by 1 to remove the last bit.\\n6. Repeat steps 3-5 for all 32 bits of the given number.\\n7. Return the reversed number.\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of the above algorithm is O(1) as we are iterating over all 32 bits of the given number.\\n73.76%\\n\\n- Space complexity:\\nThe space complexity of the above algorithm is O(1) as we are not using any extra data structures to store the intermediate results.\\n91.81%\\n\\n# Code\\n```\\nclass Solution:\\n    def reverseBits(self, n: int) -> int:\\n        # Initialize the reversed number to 0\\n        reversed_num = 0\\n        \\n        # Iterate over all 32 bits of the given number\\n        for i in range(32):\\n            # Left shift the reversed number by 1 and add the last bit of the given number to it\\n            reversed_num = (reversed_num << 1) | (n & 1)\\n            # To add the last bit of the given number to the reversed number, perform an AND operation with the given number and 1\\n            n >>= 1\\n        \\n        # Return the reversed number\\n        return reversed_num\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Divide and Conquer",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def reverseBits(self, n: int) -> int:\\n        # Initialize the reversed number to 0\\n        reversed_num = 0\\n        \\n        # Iterate over all 32 bits of the given number\\n        for i in range(32):\\n            # Left shift the reversed number by 1 and add the last bit of the given number to it\\n            reversed_num = (reversed_num << 1) | (n & 1)\\n            # To add the last bit of the given number to the reversed number, perform an AND operation with the given number and 1\\n            n >>= 1\\n        \\n        # Return the reversed number\\n        return reversed_num\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 54932,
                "title": "three-different-solutions-in-python",
                "content": "    class Solution(object):\\n        # Pythonic way, easy to understand.\\n        def reverseBits(self, n):\\n            bit_str = '{0:032b}'.format(n)\\n            reverse_str = bit_str[::-1]\\n            return int(reverse_str, 2)\\n    \\n        # General way, easy to understand.\\n        def reverseBits_1(self, n):\\n            reversed = 0\\n            for i in range(32):\\n                reversed = reversed << 1\\n                reversed |= (n >> i) & 0x1\\n            return reversed\\n    \\n        \"\"\"\\n        Divide and Conquer!  Someway like merge sort.\\n        For example, if there are 8 bit binary number abcdefgh,\\n        the process is as follow:\\n        abcdefgh -> efghabcd -> ghefcdab -> hgfedcba\\n        \"\"\"\\n        def reverseBits_2(self, n):\\n            # For python, there is no 32bit int, so we need to force it 32 bits.\\n            n = (n >> 16) | (n << 16) & 0xffffffff\\n            n = ((n & 0xff00ff00) >> 8) | ((n & 0x00ff00ff) << 8) & 0xffffffff\\n            n = ((n & 0xf0f0f0f0) >> 4) | ((n & 0x0f0f0f0f) << 4) & 0xffffffff\\n            n = ((n & 0xcccccccc) >> 2) | ((n & 0x33333333) << 2) & 0xffffffff\\n            n = ((n & 0xaaaaaaaa) >> 1) | ((n & 0x55555555) << 1) & 0xffffffff\\n            return n\\n\\n Refer to: https://leetcode.com/discuss/27405/o-1-bit-operation-c-solution-8ms",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation"
                ],
                "code": "class Solution(object):\\n        # Pythonic way, easy to understand.\\n        def reverseBits(self, n):\\n            bit_str = '{0:032b}",
                "codeTag": "Java"
            },
            {
                "id": 1555748,
                "title": "java-tc-o-1-sc-o-1-two-simple-approaches-using-bit-manipulation",
                "content": "**Use masks to select the desired bits and shift them to generate the result**\\n```java\\n/**\\n * Mask and Shift\\n *\\n * Time Complexity: O(1)\\n *\\n * Space Complexity: O(1)\\n */\\nclass Solution {\\n    // you need treat n as an unsigned value\\n    public int reverseBits(int n) {\\n        if (n == 0) {\\n            return 0;\\n        }\\n\\n        // Swap 16 bits <--> 16 bits\\n        n = (n >>> 16) | (n << 16);\\n\\t\\t\\n        // Swap 8 bits <--> 8 bits\\n        n = ((n & 0xff00ff00) >>> 8) | ((n & 0x00ff00ff) << 8);\\n        \\n\\t\\t// Swap 4 bits <--> 4 bits\\n        n = ((n & 0xf0f0f0f0) >>> 4) | ((n & 0x0f0f0f0f) << 4);\\n        \\n\\t\\t// Swap 2 bits <--> 2 bits\\n        n = ((n & 0xcccccccc) >>> 2) | ((n & 0x33333333) << 2);\\n        \\n\\t\\t// Swap 1 bits <--> 1 bits\\n        n = ((n & 0xaaaaaaaa) >>> 1) | ((n & 0x55555555) << 1);\\n\\n        return n;\\n    }\\n}\\n```\\n\\n---\\n**Reverse Bit by Bit. This solution can take maximum 32 iterations**\\n```java\\n/**\\n * Bit by Bit\\n *\\n * Time Complexity: O(32) = O(1)\\n *\\n * Space Complexity: O(1)\\n */\\nclass Solution {\\n    // you need treat n as an unsigned value\\n    public int reverseBits(int n) {\\n        if (n == 0) {\\n            return 0;\\n        }\\n\\n        int result = 0;\\n        int power = 31;\\n\\n        while (n != 0) {\\n            result |= (n & 1) << power;\\n            n >>>= 1;\\n            power--;\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```java\\n/**\\n * Mask and Shift\\n *\\n * Time Complexity: O(1)\\n *\\n * Space Complexity: O(1)\\n */\\nclass Solution {\\n    // you need treat n as an unsigned value\\n    public int reverseBits(int n) {\\n        if (n == 0) {\\n            return 0;\\n        }\\n\\n        // Swap 16 bits <--> 16 bits\\n        n = (n >>> 16) | (n << 16);\\n\\t\\t\\n        // Swap 8 bits <--> 8 bits\\n        n = ((n & 0xff00ff00) >>> 8) | ((n & 0x00ff00ff) << 8);\\n        \\n\\t\\t// Swap 4 bits <--> 4 bits\\n        n = ((n & 0xf0f0f0f0) >>> 4) | ((n & 0x0f0f0f0f) << 4);\\n        \\n\\t\\t// Swap 2 bits <--> 2 bits\\n        n = ((n & 0xcccccccc) >>> 2) | ((n & 0x33333333) << 2);\\n        \\n\\t\\t// Swap 1 bits <--> 1 bits\\n        n = ((n & 0xaaaaaaaa) >>> 1) | ((n & 0x55555555) << 1);\\n\\n        return n;\\n    }\\n}\\n```\n```java\\n/**\\n * Bit by Bit\\n *\\n * Time Complexity: O(32) = O(1)\\n *\\n * Space Complexity: O(1)\\n */\\nclass Solution {\\n    // you need treat n as an unsigned value\\n    public int reverseBits(int n) {\\n        if (n == 0) {\\n            return 0;\\n        }\\n\\n        int result = 0;\\n        int power = 31;\\n\\n        while (n != 0) {\\n            result |= (n & 1) << power;\\n            n >>>= 1;\\n            power--;\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 54873,
                "title": "java-two-methods-using-string-or-bit-operation-6ms-and-2ms-easy-understand",
                "content": "`method1 : using String, 6ms`\\n\\n    //\\u65b9\\u6cd51\\uff1a\\u4f7f\\u7528\\u5b57\\u7b26\\u4e32(\\u6ce8\\u610f-1\\uff1affffffff\\u6700\\u540e\\u4e00\\u6b65r=Inteter.MAX_VALUE+(1<<31)\\u662fMIN_VALUE,\\u7ed3\\u679c\\u521a\\u597d\\u8fd8\\u662f-1)\\n        public int reverseBits(int n) {\\n        \\tStringBuffer sb = new StringBuffer();\\n        \\tString s = Integer.toBinaryString(n);\\n        \\tfor(int i = 0; i < 32-s.length(); i++)\\n        \\t\\tsb.append('0');\\n        \\ts = sb.toString() + s;\\n            char[]  c = s.toCharArray();\\n            int r = 0;\\n            for(int i = 0; i < 32; i++){\\n            \\tif(c[i] == '1')\\n            \\t\\tr += (1 << i);\\n            }\\n            return r;\\n        }\\n`method2:using bit opeeation, 2ms`\\n\\n    //\\u65b9\\u6cd52\\uff1a\\u4f7f\\u7528\\u4f4d\\u64cd\\u4f5c\\n    \\tpublic int reverseBits2(int n){\\n    \\t\\tn = ((n & 0xAAAAAAAA ) >>> 1) | ((n & 0x55555555) << 1);\\n    \\t\\tn = ((n & 0xCCCCCCCC ) >>> 2) | ((n & 0x33333333) << 2);\\n    \\t\\tn = ((n & 0xf0f0f0f0 ) >>> 4) | ((n & 0x0f0f0f0f) << 4);\\n    \\t\\tn = ((n & 0xff00ff00 ) >>> 8) | ((n & 0x00ff00ff) << 8);\\n    \\t\\tn = ((n & 0xffff0000 ) >>> 16) | ((n & 0x0000ffff) << 16);\\n    \\t\\treturn n;\\n    \\t}\\n\\n         /*\\n    \\t * \\u5229\\u7528\\u9ad8\\u5730\\u4f4d\\u4ea4\\u6362\\u5b9e\\u73b0\\u9006\\u5e8f\\n    \\t * \\u4e24\\u4f4d\\u4e00\\u7ec4\\uff0c\\u9ad8\\u4f4e\\u4f4d\\u4e92\\u6362\\uff0c\\u65b9\\u6cd5\\u662f\\uff08\\u53d6\\u5947\\u6570\\u4f4d\\uff0c\\u5076\\u6570\\u4f4d\\u88650\\uff0c\\u53f3\\u79fb1\\u4f4d\\uff09| \\uff08\\u53d6\\u5076\\u6570\\u4e3a\\uff0c\\u5947\\u6570\\u4f4d\\u88650\\uff0c\\u5de6\\u79fb1\\u4f4d\\uff09\\n    \\t * \\u4f9d\\u6b21\\u56db\\u4f4d\\u4e00\\u7ec4\\uff0c\\u516b\\u4f4d\\u4e00\\u7ec4\\uff0c\\u5341\\u516d\\u4f4d\\u4e00\\u7ec4\\uff0c\\u4e09\\u5341\\u4e8c\\u4f4d\\u4e00\\u7ec4\\n    \\t * \\u7531\\u4e8e\\u662f\\u65e0\\u7b26\\u53f7\\u4f4d\\uff0c\\u6240\\u4ee5\\u6ce8\\u610f\\u5f97\\u662f\\u903b\\u8f91\\u53f3\\u79fb\\n    \\t */",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "`method1 : using String, 6ms`\\n\\n    //\\u65b9\\u6cd51\\uff1a\\u4f7f\\u7528\\u5b57\\u7b26\\u4e32(\\u6ce8\\u610f-1\\uff1affffffff\\u6700\\u540e\\u4e00\\u6b65r=Inteter.MAX_VALUE+(1<<31)\\u662fMIN_VALUE,\\u7ed3\\u679c\\u521a\\u597d\\u8fd8\\u662f-1)\\n        public int reverseBits(int n) {\\n        \\tStringBuffer sb = new StringBuffer();\\n        \\tString s = Integer.toBinaryString(n);\\n        \\tfor(int i = 0; i < 32-s.length(); i++)\\n        \\t\\tsb.append('0');\\n        \\ts = sb.toString() + s;\\n            char[]  c = s.toCharArray();\\n            int r = 0;\\n            for(int i = 0; i < 32; i++){\\n            \\tif(c[i] == '1')\\n            \\t\\tr += (1 << i);\\n            }\\n            return r;\\n        }\\n`method2:using bit opeeation, 2ms`\\n\\n    //\\u65b9\\u6cd52\\uff1a\\u4f7f\\u7528\\u4f4d\\u64cd\\u4f5c\\n    \\tpublic int reverseBits2(int n){\\n    \\t\\tn = ((n & 0xAAAAAAAA ) >>> 1) | ((n & 0x55555555) << 1);\\n    \\t\\tn = ((n & 0xCCCCCCCC ) >>> 2) | ((n & 0x33333333) << 2);\\n    \\t\\tn = ((n & 0xf0f0f0f0 ) >>> 4) | ((n & 0x0f0f0f0f) << 4);\\n    \\t\\tn = ((n & 0xff00ff00 ) >>> 8) | ((n & 0x00ff00ff) << 8);\\n    \\t\\tn = ((n & 0xffff0000 ) >>> 16) | ((n & 0x0000ffff) << 16);\\n    \\t\\treturn n;\\n    \\t}\\n\\n         /*\\n    \\t * \\u5229\\u7528\\u9ad8\\u5730\\u4f4d\\u4ea4\\u6362\\u5b9e\\u73b0\\u9006\\u5e8f\\n    \\t * \\u4e24\\u4f4d\\u4e00\\u7ec4\\uff0c\\u9ad8\\u4f4e\\u4f4d\\u4e92\\u6362\\uff0c\\u65b9\\u6cd5\\u662f\\uff08\\u53d6\\u5947\\u6570\\u4f4d\\uff0c\\u5076\\u6570\\u4f4d\\u88650\\uff0c\\u53f3\\u79fb1\\u4f4d\\uff09| \\uff08\\u53d6\\u5076\\u6570\\u4e3a\\uff0c\\u5947\\u6570\\u4f4d\\u88650\\uff0c\\u5de6\\u79fb1\\u4f4d\\uff09\\n    \\t * \\u4f9d\\u6b21\\u56db\\u4f4d\\u4e00\\u7ec4\\uff0c\\u516b\\u4f4d\\u4e00\\u7ec4\\uff0c\\u5341\\u516d\\u4f4d\\u4e00\\u7ec4\\uff0c\\u4e09\\u5341\\u4e8c\\u4f4d\\u4e00\\u7ec4\\n    \\t * \\u7531\\u4e8e\\u662f\\u65e0\\u7b26\\u53f7\\u4f4d\\uff0c\\u6240\\u4ee5\\u6ce8\\u610f\\u5f97\\u662f\\u903b\\u8f91\\u53f3\\u79fb\\n    \\t */",
                "codeTag": "Unknown"
            },
            {
                "id": 744794,
                "title": "easy-python-100-speed",
                "content": "**Easy Python | 100% Speed**\\n\\n**A) Bit Manipulation**\\n\\nIn this algorithm, we basically print each bit into its reversed counterpart. It looks a bit ugly, but it makes a lot of sense after a while :)\\n```\\nclass Solution:\\n    def reverseBits(self, n):\\n        res    = 0\\n        for i in range(32):\\n            if n&1:\\n                res += 1 << (31-i)\\n            n >>= 1\\n        return res\\n```\\n\\n**B) String Padding**\\nWe can take advantage of the Python\\'s \\'bin\\' function to obtain a string representation of the binary number, add padding zeros, and convert the reversed string back into a number:\\n\\n```\\nclass Solution:\\n    def reverseBits(self, n):\\n        n = bin(n)[2:]         # convert to binary, and remove the usual 0b prefix\\n        n = \\'%32s\\' % n         # print number into a pre-formatted string with space-padding\\n        n = n.replace(\\' \\',\\'0\\') # Convert the useful space-padding into zeros\\n        # Now we have a  proper binary representation, so we can make the final transformation\\n        return int(n[::-1],2)\\n```\\n\\n**C) One-Liner String Padding Conversion**\\n\\nSolution B in One-Liner format.\\n```\\nclass Solution:\\n    def reverseBits(self, n):\\n        return int( (\\'%32s\\' % bin(n)[2:]).replace(\\' \\',\\'0\\')[::-1] ,2)\\n```\\n\\n**D) High-Speed Code**\\n\\nI ran a benchmark in my laptop with 1 million random test cases, and this Solution proved to be faster than all previous versions:\\n\\n```\\nclass Solution:\\n    def reverseBits(self, n):\\n        n = bin(n)[2:]\\n        n = \\'0\\'*( 32-len(n) ) + n\\n        return int( n[::-1] ,2)\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def reverseBits(self, n):\\n        res    = 0\\n        for i in range(32):\\n            if n&1:\\n                res += 1 << (31-i)\\n            n >>= 1\\n        return res\\n```\n```\\nclass Solution:\\n    def reverseBits(self, n):\\n        n = bin(n)[2:]         # convert to binary, and remove the usual 0b prefix\\n        n = \\'%32s\\' % n         # print number into a pre-formatted string with space-padding\\n        n = n.replace(\\' \\',\\'0\\') # Convert the useful space-padding into zeros\\n        # Now we have a  proper binary representation, so we can make the final transformation\\n        return int(n[::-1],2)\\n```\n```\\nclass Solution:\\n    def reverseBits(self, n):\\n        return int( (\\'%32s\\' % bin(n)[2:]).replace(\\' \\',\\'0\\')[::-1] ,2)\\n```\n```\\nclass Solution:\\n    def reverseBits(self, n):\\n        n = bin(n)[2:]\\n        n = \\'0\\'*( 32-len(n) ) + n\\n        return int( n[::-1] ,2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 732028,
                "title": "c-bitwise-solution-explained-100-time-100-space",
                "content": "Basically we need to construct our accumulator variable `res` shaving off the leftmost digit at each iteration and adding it to the double (`<< 1` works like `* 2` in this case) to our previously computed `res`; similarly, at each iteration we remove the just used leftmost bit with a right shift: `>> 1`.\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        uint32_t res = 0;\\n        for (int i = 0; i < 31; i++) {\\n            res = (n % 2) + res << 1;\\n            n >>= 1;\\n        }\\n        return res + n % 2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        uint32_t res = 0;\\n        for (int i = 0; i < 31; i++) {\\n            res = (n % 2) + res << 1;\\n            n >>= 1;\\n        }\\n        return res + n % 2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 129802,
                "title": "javascript-one-liner",
                "content": "```\\n/**\\n *\\n * Reverse Bits\\n *\\n * @param {number} n - a positive integer\\n * @return {number} - a positive integer\\n */\\nfunction reverseBits(n) {\\n  return Number.parseInt(n.toString(2).split(\"\").reverse().join(\"\").padEnd(32, \"0\"), 2);\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n *\\n * Reverse Bits\\n *\\n * @param {number} n - a positive integer\\n * @return {number} - a positive integer\\n */\\nfunction reverseBits(n) {\\n  return Number.parseInt(n.toString(2).split(\"\").reverse().join(\"\").padEnd(32, \"0\"), 2);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2339454,
                "title": "easiest-way-to-do-bit-manipulation-java-code",
                "content": "public class Solution {\\n\\n    // you need treat n as an unsigned value\\n    public int reverseBits(int n) {\\n        int binaryNum = 0;\\n        \\n        for(int i=0;i<32;i++) {\\n            binaryNum = binaryNum<<1;                   //multiply by 2\\n            binaryNum = binaryNum + (n&1);              //add last digit to binaryNum \\n            n=n>>1;                                     //update n by removing last digit\\n        }\\n        \\n        return binaryNum ;\\n        \\n    }\\n}\\n\\n***Note: Kindly Upvote this article, if you found it helpful. Thanks For Reading!!***",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "class Solution {\\n\\n    // you need treat n as an unsigned value\\n    public int reverseBits(int n) {\\n        int binaryNum = 0;\\n        \\n        for(int i=0;i<32;i++) {\\n            binaryNum = binaryNum<<1;                   //multiply by 2\\n            binaryNum = binaryNum + (n&1);              //add last digit to binaryNum \\n            n=n>>1;                                     //update n by removing last digit\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3060703,
                "title": "c-solution-beats-100-faster",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    uint32_t k = 0;\\n    int l = 31;\\n    uint32_t reverseBits(uint32_t n) {\\n        if(n == 0)\\n        return 0;\\n\\n        if(n & 1)\\n        {\\n            k += 1 << l;\\n        }\\n        l--;\\n        reverseBits(n >> 1);\\n\\n        return k;\\n    }\\n};\\n```\\n\\nPlease upvote if you like it and also give suggestions.",
                "solutionTags": [
                    "C++",
                    "Divide and Conquer",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    uint32_t k = 0;\\n    int l = 31;\\n    uint32_t reverseBits(uint32_t n) {\\n        if(n == 0)\\n        return 0;\\n\\n        if(n & 1)\\n        {\\n            k += 1 << l;\\n        }\\n        l--;\\n        reverseBits(n >> 1);\\n\\n        return k;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2628641,
                "title": "python3-solution-one-line",
                "content": "```\\nclass Solution:\\n    def reverseBits(self, n: int) -> int:\\n        return int(((\\'{0:032b}\\'.format(n))[::-1]),2)\\n```\\n* (\\'{0:032b}\\'.format(n) Converts to a 32 bit representation of the number in binary. This is formatted as a string\\n* [::-1] Reverses the String\\n* int(...., 2) converts the number back to the appropriate base",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def reverseBits(self, n: int) -> int:\\n        return int(((\\'{0:032b}\\'.format(n))[::-1]),2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 426492,
                "title": "golang-100-super-simple",
                "content": "Simple solution using bit operations.\\n32 iterations, each time we:\\n1. Shift result left by 1 bit and append to it last bit from input number\\n2. Shift input number right by 1 bit\\n\\nYou can imagive it as two stacks, we pop items from one and push to another. Only your stacks have same length and always autofilled with 0s.\\n\\nHere is code:\\n```\\nfunc reverseBits(num uint32) uint32 {\\n    var res uint32\\n    for i := 0; i < 32; i++ {\\n        res = res << 1 + num & 1\\n        num >>= 1\\n    }\\n    return res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc reverseBits(num uint32) uint32 {\\n    var res uint32\\n    for i := 0; i < 32; i++ {\\n        res = res << 1 + num & 1\\n        num >>= 1\\n    }\\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 54997,
                "title": "simple-4ms-c-solution-with-updated-explanation",
                "content": "This does literally what the problem asks, it swaps each pair of bits from the outside in. The swap operation looks at the pair of bits to see if they're different, and if so, flips each bit. For each pair of indices *i* and *j*, we can select the *ith* bit and the *jth* bit with the expressions `((n >> i) & 1)` and  `(n >> j) & 1)`. We then compare the two bits. If they are equal, we don't need to do anything because swapping them would have no effect. If they're not equal, we flip each bit by XORing it with 1. This has the effect of \"swapping\" the bits even though we're really just flipping each one. So the pair (0, 1) would get changed to (1, 0) and (1, 0) would get changed to (0, 1). To XOR the *ith* and *jth* bits each with ones, we form a number with 1's in the *ith* and *jth* places using OR: `((1U << i) | (1U << j))`. Then we can just XOR this with our number to flip the bits in the *ith* and *jth* places.\\n\\nIf we needed to process lots of numbers, a faster way to do this would be to build up a table of preprocessed answers for numbers up to some bit count, and then reverse the overall number block by block.\\n\\n    class Solution {\\n    public:\\n        uint32_t reverseBits(uint32_t n) {\\n            int i = 0, j = 31;\\n            while (i < j) {\\n                if (((n >> i) & 1) != ((n >> j) & 1)) {\\n                    n ^= ((1U << i) | (1U << j));\\n                }\\n                i++, j--;\\n            }\\n            return n;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        uint32_t reverseBits(uint32_t n) {\\n            int i = 0, j = 31;\\n            while (i < j) {\\n                if (((n >> i) & 1) != ((n >> j) & 1)) {\\n                    n ^= ((1U << i) | (1U << j));\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2321365,
                "title": "faster-than-100-of-the-users",
                "content": "**we will traverse till 32 bits and find the last digit of n by using n&1 . After this we will add this value in ans ans then right shift the value of n and repeat till last item.   hope this helped you please upvote.**\\n```\\npublic class Solution {\\n    // you need treat n as an unsigned value\\n    public int reverseBits(int n) {\\n        int ans = 0;\\n        for( int i= 0; i < 32 ;i++){\\n            ans = (ans << 1) | (n&1);\\n            n = n >> 1;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "JavaScript",
                    "Bit Manipulation"
                ],
                "code": "```\\npublic class Solution {\\n    // you need treat n as an unsigned value\\n    public int reverseBits(int n) {\\n        int ans = 0;\\n        for( int i= 0; i < 32 ;i++){\\n            ans = (ans << 1) | (n&1);\\n            n = n >> 1;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 54806,
                "title": "2ms-java-solution",
                "content": "    public class Solution {\\n        // you need treat n as an unsigned value\\n        public int reverseBits(int n) {\\n            int answer = 0; // initializing answer\\n            for (int i = 0; i < 32; i++) { // 32 bit integers\\n                answer <<= 1; // shifts answer over 1 to open a space\\n                answer |= ((n >> i) & 1); // inserts bits from n\\n            }\\n            return answer;\\n        }\\n    }\\n\\nIf anyone has a faster solution, please comment below.",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        // you need treat n as an unsigned value\\n        public int reverseBits(int n) {\\n            int answer = 0; // initializing answer\\n            for (int i = 0; i < 32; i++) { // 32 bit integers\\n                answer <<= 1; // shifts answer over 1 to open a space\\n                answer |= ((n >> i) & 1); // inserts bits from n\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 54979,
                "title": "c-4-lines-4-ms",
                "content": "    uint32_t reverseBits(uint32_t n) {\\n        uint32_t m = 0;\\n        for (int i = 0; i< 32 ; i++,n/=2)\\n            m = (m<<1) + (n%2);\\n        return m;\\n    }",
                "solutionTags": [],
                "code": "    uint32_t reverseBits(uint32_t n) {\\n        uint32_t m = 0;\\n        for (int i = 0; i< 32 ; i++,n/=2)\\n            m = (m<<1) + (n%2);\\n        return m;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1941906,
                "title": "c-solution-with-explanation",
                "content": "The logic is to push 1 bit at a time from end of one register to another.\\n\\nConsider a 4 bit number n = 1101, result = 0000\\n1) First iteration: result = 0000 ( after left shift of 1), n & 1 = 0001 (since n is odd), result | n & 1 = 0001, n >> 1 right shifts n, now n = 0110. You can see last bit of n in now added to result.\\n2) Second iteration: result = 0010 (left shift of 1), n & 1 = 0000 (n is even), result | (n&1) = 0010, n >> 1 gives n = 0011\\n3) Third iteration: result = 0100, n & 1 = 0001, result | (n & 1) = 0101, n >> 1 = 0001\\n4) Fourth iteration: result = 1010, n & 1 = 0001, result | (n & 1) = 1011, n >> 1 = 0000\\n\\nIn this way, we remove element from right side of n and append it to result, then we push result to 1 bit left. \\n\\nPlease upvote if you like it.\\n\\n```\\nclass Solution {\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        uint32_t result = 0;\\n        \\n        for (int i = 0; i < 32; i++) {\\n            result <<= 1;\\n            result |= n & 1;\\n            n >>= 1;\\n        }\\n        return result;\\n            \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        uint32_t result = 0;\\n        \\n        for (int i = 0; i < 32; i++) {\\n            result <<= 1;\\n            result |= n & 1;\\n            n >>= 1;\\n        }\\n        return result;\\n            \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 55025,
                "title": "my-c-4ms-solution-with-two-line",
                "content": "    uint32_t reverseBits(uint32_t n){\\n       int i,bin=0;\\n         for (i = 0; i < 32; i++) \\n    \\t bin+=(n >> i & 1)<<(31-i);\\n        return bin;\\n    }",
                "solutionTags": [],
                "code": "    uint32_t reverseBits(uint32_t n){\\n       int i,bin=0;\\n         for (i = 0; i < 32; i++) \\n    \\t bin+=(n >> i & 1)<<(31-i);\\n        return bin;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 54751,
                "title": "c-solution-9ms-without-loop-without-calculation",
                "content": "    class Solution {\\n    public:\\n        uint32_t reverseBits(uint32_t n) {\\n            struct bs\\n            {\\n                unsigned int _00:1; unsigned int _01:1; unsigned int _02:1; unsigned int _03:1;\\n                unsigned int _04:1; unsigned int _05:1; unsigned int _06:1; unsigned int _07:1;\\n                unsigned int _08:1; unsigned int _09:1; unsigned int _10:1; unsigned int _11:1;\\n                unsigned int _12:1; unsigned int _13:1; unsigned int _14:1; unsigned int _15:1;\\n                unsigned int _16:1; unsigned int _17:1; unsigned int _18:1; unsigned int _19:1;\\n                unsigned int _20:1; unsigned int _21:1; unsigned int _22:1; unsigned int _23:1;\\n                unsigned int _24:1; unsigned int _25:1; unsigned int _26:1; unsigned int _27:1;\\n                unsigned int _28:1; unsigned int _29:1; unsigned int _30:1; unsigned int _31:1;\\n            } *b = (bs*)&n, \\n            c = \\n            {\\n                  b->_31, b->_30, b->_29, b->_28\\n                , b->_27, b->_26, b->_25, b->_24\\n                , b->_23, b->_22, b->_21, b->_20\\n                , b->_19, b->_18, b->_17, b->_16\\n                , b->_15, b->_14, b->_13, b->_12\\n                , b->_11, b->_10, b->_09, b->_08\\n                , b->_07, b->_06, b->_05, b->_04\\n                , b->_03, b->_02, b->_01, b->_00\\n            };\\n    \\n            return *(unsigned int *)&c;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        uint32_t reverseBits(uint32_t n) {\\n            struct bs\\n            {\\n                unsigned int _00:1; unsigned int _01:1; unsigned int _02:1; unsigned int _03:1;\\n                unsigned int _04:1; unsigned int _05:1; unsigned int _06:1; unsigned int _07:1;\\n                unsigned int _08:1; unsigned int _09:1; unsigned int _10:1; unsigned int _11:1;\\n                unsigned int _12:1; unsigned int _13:1; unsigned int _14:1; unsigned int _15:1;\\n                unsigned int _16:1; unsigned int _17:1; unsigned int _18:1; unsigned int _19:1;\\n                unsigned int _20:1; unsigned int _21:1; unsigned int _22:1; unsigned int _23:1;\\n                unsigned int _24:1; unsigned int _25:1; unsigned int _26:1; unsigned int _27:1;\\n                unsigned int _28:1; unsigned int _29:1; unsigned int _30:1; unsigned int _31:1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 55046,
                "title": "concise-java-solution-300ms",
                "content": "    public class Solution {\\n        // you need treat n as an unsigned value\\n        public int reverseBits(int n) {\\n            long sum=0;\\n            for(int i=0;i<32;i++){\\n               sum+=Math.pow(2,31-i)*(n&1);\\n                n=n>>1;\\n            }\\n           return (int)sum;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        // you need treat n as an unsigned value\\n        public int reverseBits(int n) {\\n            long sum=0;\\n            for(int i=0;i<32;i++){\\n               sum+=Math.pow(2,31-i)*(n&1);\\n                n=n>>1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1776103,
                "title": "c-bit-manipulation-100-faster-0-ms-easy-to-understand",
                "content": "\\uD83D\\uDCBB --  **Upvote , If found helpful**\\n\\n* **Approach** - find the ith bit and put it in ith bit from last in answer \\n\\n* **Explaination**\\n1. let n = 00000010100101000001111010011100\\n2. To find the 2nd bit in n , right shift by 2 (**n>>2**) and taking its and with 1\\nbecause anything and with 1 remains same \\n3. now make ith bit from last according to mask in new number (**which we have to return**) i.e (**31-i**). \\n\\n\\n\\n* **Code**\\n```\\nuint32_t reverseBits(uint32_t n) {\\n        int ans = 0;\\n        for(int i = 0 ; i < 32 ; i++){\\n            int mask = (n>>i)&1;\\n            ans = ans|(mask<<(31-i));\\n        }\\n        return ans;\\n    }\\n```\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nuint32_t reverseBits(uint32_t n) {\\n        int ans = 0;\\n        for(int i = 0 ; i < 32 ; i++){\\n            int mask = (n>>i)&1;\\n            ans = ans|(mask<<(31-i));\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1296934,
                "title": "easy-java-solution-1-line-of-code-using-in-built-class-1ms-beats-98",
                "content": "```\\npublic class Solution {\\n    public int reverseBits(int n) {\\n        return Integer.reverse(n);  \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic class Solution {\\n    public int reverseBits(int n) {\\n        return Integer.reverse(n);  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2491045,
                "title": "c-beginner-friendly-solution-explantion-fast-easy-3ms",
                "content": "**Given problem:** To reverse the binary representation of a number.\\nHere ```uint32_t``` is used to store the 32 bits.\\n\\n**Read this First**\\n1. If ```num = 1101``` then either of these are possible:\\n\\ta. ```num = num>>1``` will make ```num = 0110        //right shift``` .\\n\\tb.```num = num<<1``` will make ```num = 1010        //left shift```.\\n\\t\\n2. If ```num = 1101```, then ```&``` (AND) operation:\\n\\ta. ```a = num & 1``` will give ```a = 1``` which is the right most bit of num.\\n\\t\\n3. If ```num = 1010```, then ```|``` (OR) operation:\\n\\ta. ```a = num | 1``` will give ```a = 1011``` where 1 gets added to the right most bit of num.\\n<br></br>\\n\\n**Solution Steps:**\\n1. We create a new variable to store the answer i.e. the *reversed binary representation*.\\n\\n\\n2. Initially ```ans``` variable is ```0```. To store more bits we need to expand its space. \\nSo we perform ``` ans<<=1``` which can also be written as ```ans = ans << 1```.\\nThis **left shifts** ```ans``` variable **by 1 space towards its left**. So now ```ans``` is ```0 0```.\\n3. We read only the last bit of the given binary form ```n```, using ```&``` operation like ```n & 1```.\\n4. Then we add this last bit of ```n``` to ```ans```. If the last bit of n was ```1```, then ```ans``` is ```0 1``` now.\\nWe can add in 2 ways: ```ans = ans + (n&1)``` or ``` ans = ans | (n&1)```. \\nThe second ```OR``` operation is **much faster**.\\n5. As we have dealt with the current last bit, we remove it by right shifting ```n```; ```n = n>>1```.\\n6. We repeat all the above steps 2 to 5, for 32 times for each of the 32 bits.\\n\\n```\\nclass Solution {\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        uint32_t ans=0; int i=32;\\n        while(i--){\\n            ans<<=1;\\n            ans|=n&1;\\n            n>>=1;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n<br></br>\\n***Upvote** if this is helpful. Comment if there any mistake in explanation or any doubt.*",
                "solutionTags": [
                    "C"
                ],
                "code": "```uint32_t```\n```num = 1101```\n```num = num>>1```\n```num = 0110        //right shift```\n```num = num<<1```\n```num = 1010        //left shift```\n```num = 1101```\n```&```\n```a = num & 1```\n```a = 1```\n```num = 1010```\n```|```\n```a = num | 1```\n```a = 1011```\n```ans```\n```0```\n``` ans<<=1```\n```ans = ans << 1```\n```ans```\n```ans```\n```0 0```\n```n```\n```&```\n```n & 1```\n```n```\n```ans```\n```1```\n```ans```\n```0 1```\n```ans = ans + (n&1)```\n``` ans = ans | (n&1)```\n```OR```\n```n```\n```n = n>>1```\n```\\nclass Solution {\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        uint32_t ans=0; int i=32;\\n        while(i--){\\n            ans<<=1;\\n            ans|=n&1;\\n            n>>=1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2037664,
                "title": "python-pure-bit-manipulation-no-string-reversal-34-ms-beats-85",
                "content": "```\\nclass Solution:\\n    def reverseBits(self, n: int) -> int:\\n        if n == 0:\\n            return 0\\n\\n        out = 0  # Initialize output with \\'0000...{32 times}...000\\'\\n        for _ in range(31):\\n            bit = n & 1  # 1. Take the last bit of n \\n            out |= bit   # 2. Set the last bit of output to the last bit of n \\n            out <<= 1    # 3. Left shift output by 1 so that the last bit set is now one step to the left\\n            n >>= 1      # 4. Right shift n by 1 so that in the next iteration, we can extract the next bit\\n        \\n        # We set the 32nd bit outside of the loop because we don\\'t want to left shift output after this.\\n        out |= n  \\n        return out\\n```",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def reverseBits(self, n: int) -> int:\\n        if n == 0:\\n            return 0\\n\\n        out = 0  # Initialize output with \\'0000...{32 times}...000\\'\\n        for _ in range(31):\\n            bit = n & 1  # 1. Take the last bit of n \\n            out |= bit   # 2. Set the last bit of output to the last bit of n \\n            out <<= 1    # 3. Left shift output by 1 so that the last bit set is now one step to the left\\n            n >>= 1      # 4. Right shift n by 1 so that in the next iteration, we can extract the next bit\\n        \\n        # We set the 32nd bit outside of the loop because we don\\'t want to left shift output after this.\\n        out |= n  \\n        return out\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1294666,
                "title": "c-a-different-soln-using-bitset",
                "content": "```\\n// This is not the best way to do it, but it is defienlty differnt than most of the top rated solns\\n// so I thought it\\'s a good soln to give a glance\\n```\\n\\n```\\nclass Solution {\\npublic:\\n    uint32_t reverseBits(uint32_t n) \\n    {\\n        bitset<32> orig(n);\\n        bitset<32> num;\\n        for (int j = 31, i = 0; j >= 0; j--)\\n            num[i++] = orig[j];\\n        return num.to_ulong();\\n    }\\n};\\n```\\n\\n```\\nclass Solution {\\npublic:\\n    uint32_t reverseBits(uint32_t n) \\n    {\\n        string s = bitset<32>(n).to_string();\\n        reverse(s.begin(), s.end());\\n        bitset<32> num(s);\\n        return num.to_ulong();\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n// This is not the best way to do it, but it is defienlty differnt than most of the top rated solns\\n// so I thought it\\'s a good soln to give a glance\\n```\n```\\nclass Solution {\\npublic:\\n    uint32_t reverseBits(uint32_t n) \\n    {\\n        bitset<32> orig(n);\\n        bitset<32> num;\\n        for (int j = 31, i = 0; j >= 0; j--)\\n            num[i++] = orig[j];\\n        return num.to_ulong();\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    uint32_t reverseBits(uint32_t n) \\n    {\\n        string s = bitset<32>(n).to_string();\\n        reverse(s.begin(), s.end());\\n        bitset<32> num(s);\\n        return num.to_ulong();\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1243746,
                "title": "bit-by-bit-js-solution",
                "content": "```\\n/*\\nProcess the right-most bit for 32 times (at most)\\n*/\\nvar reverseBits = function(n) {\\n    let res = 0, pow = 31;\\n    while (n > 0) {\\n        let rightMost = n & 1;\\n        res = res + (rightMost << pow);\\n        pow--;\\n        n = n >>> 1;\\n    }\\n    // take negative into positive\\n    return res >>> 0;\\n    // T.C: O(1)\\n    // S.C: O(1)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/*\\nProcess the right-most bit for 32 times (at most)\\n*/\\nvar reverseBits = function(n) {\\n    let res = 0, pow = 31;\\n    while (n > 0) {\\n        let rightMost = n & 1;\\n        res = res + (rightMost << pow);\\n        pow--;\\n        n = n >>> 1;\\n    }\\n    // take negative into positive\\n    return res >>> 0;\\n    // T.C: O(1)\\n    // S.C: O(1)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 54957,
                "title": "my-simple-solution",
                "content": "    class Solution {\\n    public:\\n        uint32_t reverseBits( uint32_t n ) {\\n            uint32_t result = 0;\\n            for( int i = 0; i < 32; i++, n >>= 1 )\\n                if( n & 1 )\\n                    result |=  1 << ( 31 - i );\\n            \\n            return result;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        uint32_t reverseBits( uint32_t n ) {\\n            uint32_t result = 0;\\n            for( int i = 0; i < 32; i++, n >>= 1 )\\n                if( n & 1 )\\n                    result |=  1 << ( 31 - i );\\n            \\n            return result;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 54974,
                "title": "no-loop-bit-manipulation-but-many-inst",
                "content": "    \\n    uint32_t reverseBits(uint32_t n)\\n    {\\n       n = ((n<<16) | (n>>16));                         //swap [31:16]<=>[15:0]\\n       n = ((n&0x00ff00ff)<< 8 | (n&0xff00ff00)>> 8);   //swap [31:24]<=>[23:16] , [15:8]<=>[7:0]\\n       n = ((n&0x0f0f0f0f)<< 4 | (n&0xf0f0f0f0)>> 4);   //swap ...\\n       n = ((n&0x33333333)<< 2 | (n&0xcccccccc)>> 2);   //swap ...\\n       n = ((n&0x55555555)<< 1 | (n&0xaaaaaaaa)>> 1);   //swap ...\\n       return n;    \\n    }",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "    \\n    uint32_t reverseBits(uint32_t n)\\n    {\\n       n = ((n<<16) | (n>>16));                         //swap [31:16]<=>[15:0]\\n       n = ((n&0x00ff00ff)<< 8 | (n&0xff00ff00)>> 8);   //swap [31:24]<=>[23:16] , [15:8]<=>[7:0]\\n       n = ((n&0x0f0f0f0f)<< 4 | (n&0xf0f0f0f0)>> 4);   //swap ...\\n       n = ((n&0x33333333)<< 2 | (n&0xcccccccc)>> 2);   //swap ...\\n       n = ((n&0x55555555)<< 1 | (n&0xaaaaaaaa)>> 1);   //swap ...\\n       return n;    \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 54971,
                "title": "very-neat-c-solution",
                "content": "    class Solution {\\n    public:\\n        uint32_t reverseBits(uint32_t n) {\\n            for (int i = 0; i < 16; i++)\\n                // toggle bits when the 2 bits in a pair are different\\n                if ((n >> i & 1) ^ (n >> (31 - i) & 1))\\n                    n ^= (1 << i | 1 << (31 - i));\\n            return n;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        uint32_t reverseBits(uint32_t n) {\\n            for (int i = 0; i < 16; i++)\\n                // toggle bits when the 2 bits in a pair are different\\n                if ((n >> i & 1) ^ (n >> (31 - i) & 1))\\n                    n ^= (1 << i | 1 << (31 - i));\\n            return n;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 54754,
                "title": "javascript-bit-solution-139ms-matters-explained",
                "content": "> The << operator is defined as working on signed 32-bit integers (converted from the native Number storage of double-precision float). So 1<<31 must result in a negative number.\\n\\n-- source https://stackoverflow.com/a/1908655/2013580\\n\\n> The >> is arithmetic shift right, >>> is logical shift right.\\nIn an arithmetic shift, the sign bit is extended to preserve the signedness of the number.\\n\\n-- source https://stackoverflow.com/a/2811372/2013580\\n\\n```\\nvar reverseBits = function(n) {\\n    let ans = 0;\\n    for (let i = 0; i < 32; i += 1) {\\n        ans <<= 1;\\n        ans |= n & 1;\\n        n >>= 1;\\n    }\\n    return ans >>> 0;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar reverseBits = function(n) {\\n    let ans = 0;\\n    for (let i = 0; i < 32; i += 1) {\\n        ans <<= 1;\\n        ans |= n & 1;\\n        n >>= 1;\\n    }\\n    return ans >>> 0;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3032438,
                "title": "easy-to-understand-solution-bitwise-operation-c-solution",
                "content": "# Intuition\\nThe intuition is play on bits using bit manipulation.\\n\\n# Approach\\nSo, for a 32 bit integer, we got 32 bits as 01010100.....\\nNow, since we need to reverse the given number, we have to do 32 operations(changing/shifting the bit).\\n\\nSo, first of all, we can consider number \"1\" whose binary value would be -\"00000000000000000000000000000001\" (32 bits)\\nnow, since we need to reverse the given number n\\n\\nConsidering n\\'s binary representation from test case -\\n00000010100101000001111010011100\\nWe need to reverse it to ->\\n00111001011110000010100101000000\\n\\nSo, we need to start from least significant bit(lsb) and therefore to get the lsb, we perform bitwise And operation on n and 1 (n & 1)\\nthis gives us, 0 in this case. Now, we need to store it at first place. So we left shift the result by (31-i) bits where i is the i-th time we are operating on bits.\\n\\nnow, to save result, we can perform bitwise OR operation on result (initially 0) and lsb_reverse.\\n\\nNow, when we have stored lsb, we can now shift the n by 1 bit and operate for new lsb.\\n\\nThis we continue for 32 times and finally we get the number with reversed bits.  \\n\\nHope you liked the solution!! \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public uint reverseBits(uint n) {\\n        uint res=0;\\n        for(int i=0;i<32;i++)\\n        {\\n            uint lsb=n & 1;\\n            uint lsb_reverse=lsb<<(31-i);\\n            res= res | lsb_reverse;\\n            n=n>>1;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C#",
                    "Bit Manipulation"
                ],
                "code": "```\\npublic class Solution {\\n    public uint reverseBits(uint n) {\\n        uint res=0;\\n        for(int i=0;i<32;i++)\\n        {\\n            uint lsb=n & 1;\\n            uint lsb_reverse=lsb<<(31-i);\\n            res= res | lsb_reverse;\\n            n=n>>1;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1038308,
                "title": "java-integer-api-and-bit-by-bit-implementation",
                "content": "Bit-by-Bit\\n```\\npublic class Solution {\\n    public int reverseBits(int n) {\\n        var rev = 0;\\n        for (int i = 0; i < 32; i++) {\\n    \\t    rev = ( rev << 1 ) | ( n & 1 );         \\n    \\t    n = n >> 1;                  \\n        }\\n        return rev;\\n    }\\n}\\n```\\nInteger API\\n```\\npublic class Solution {\\n    public int reverseBits(int n) {\\n        return Integer.reverse(n);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic class Solution {\\n    public int reverseBits(int n) {\\n        var rev = 0;\\n        for (int i = 0; i < 32; i++) {\\n    \\t    rev = ( rev << 1 ) | ( n & 1 );         \\n    \\t    n = n >> 1;                  \\n        }\\n        return rev;\\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public int reverseBits(int n) {\\n        return Integer.reverse(n);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 936391,
                "title": "easy-solution-without-any-in-built-functions",
                "content": "```\\nclass Solution:\\n    def reverseBits(self, n: int) -> int:\\n        res=0\\n        for i in range(32): # since it is 32 bit integer\\n            res=res<<1   # left shift to check it till 32 bits\\n            res+=n%2  # checking if rightmost bit of n is 1 and adding to result\\n            n=n>>1     # checking all bits of n till n becomes 0\\n        return res",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def reverseBits(self, n: int) -> int:\\n        res=0\\n        for i in range(32): # since it is 32 bit integer\\n            res=res<<1   # left shift to check it till 32 bits\\n            res+=n%2  # checking if rightmost bit of n is 1 and adding to result\\n            n=n>>1     # checking all bits of n till n becomes 0\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 455724,
                "title": "python-3-solution-in-2-lines",
                "content": "```\\nclass Solution:\\n    def reverseBits(self, n: int) -> int:\\n        num = bin(n)[2:].zfill(32)\\n        return int(num[::-1], 2)\\n```\\n\\n\\n\\nExplanation:\\n\\n* `bin(n)` -> converts the integer no. to binary [e.g 5 to 101]. It will return a string in the format \\'0b101\\' which has a prefix 0b , which stands for binary representation. So, to remove 0b on the left side `[2:]` has been  done.\\n\\n* `zfill(32)` -> returns a copy of the string with \\u20180\\u2019 characters padded to the left side of the given string.\\n\\n* `num` -> now has a string of length 32 which is a binary no. \\n   e.g\\n\\t `num = bin(5)[2:].zfill(32)`\\n\\n     `num` is now equals to \\'00000000000000000000000000000101\\'\\n\\n* `int(num[::-1], 2)` -> returns reverse of string `num`. Second parameter (2) in the int() represent the base of the no.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def reverseBits(self, n: int) -> int:\\n        num = bin(n)[2:].zfill(32)\\n        return int(num[::-1], 2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 54954,
                "title": "simply-great-performance-java-solution",
                "content": "    public class Solution {\\n        // you need treat n as an unsigned value\\n        public int reverseBits(int n) {\\n            int res = 0;\\n            int count = 31;\\n            while (n != 0) {\\n                if ((n & 1) == 1) {\\n                    res = res + (1 << count);\\n                } \\n                n >>>= 1;\\n                count--;\\n            }\\n            \\n            return res;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        // you need treat n as an unsigned value\\n        public int reverseBits(int n) {\\n            int res = 0;\\n            int count = 31;\\n            while (n != 0) {\\n                if ((n & 1) == 1) {\\n                    res = res + (1 << count);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 55036,
                "title": "very-simple-non-iterate-solution",
                "content": "    class Solution:\\n        # @param n, an integer\\n        # @return an integer\\n        def reverseBits(self, n):\\n            n = ((n & 0x55555555) << 1) | ((n & 0xAAAAAAAA) >> 1)\\n            n = ((n & 0x33333333) << 2) | ((n & 0xCCCCCCCC) >> 2)\\n            n = ((n & 0x0F0F0F0F) << 4) | ((n & 0xF0F0F0F0) >> 4)\\n            n = ((n & 0x00FF00FF) << 8) | ((n & 0xFF00FF00) >> 8)\\n            n = ((n & 0x0000FFFF) << 16) | ((n & 0xFFFF0000) >> 16)\\n            return n\\n\\nLike merge sort, swap two bits, 4 bits, 8 bits, 16 bits and 32 bits, Then it reversed",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution:\\n        # @param n, an integer\\n        # @return an integer\\n        def reverseBits(self, n):\\n            n = ((n & 0x55555555) << 1) | ((n & 0xAAAAAAAA) >> 1)\\n            n = ((n & 0x33333333) << 2) | ((n & 0xCCCCCCCC) >> 2)\\n            n = ((n & 0x0F0F0F0F) << 4) | ((n & 0xF0F0F0F0) >> 4)\\n            n = ((n & 0x00FF00FF) << 8) | ((n & 0xFF00FF00) >> 8)\\n            n = ((n & 0x0000FFFF) << 16) | ((n & 0xFFFF0000) >> 16)\\n            return n\\n\\nLike merge sort, swap two bits, 4 bits, 8 bits, 16 bits and 32 bits, Then it reversed",
                "codeTag": "Java"
            },
            {
                "id": 3578130,
                "title": "simple-c-solution-beats-100",
                "content": "# Intuition\\nTO convert the bitstring  **to reversed **\\n# Approach\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        bitset<32> bi(n);\\n        string str= bi.to_string();\\n        reverse(str.begin(),str.end());\\n        bitset<32> b2(str);\\n        return b2.to_ullong();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        bitset<32> bi(n);\\n        string str= bi.to_string();\\n        reverse(str.begin(),str.end());\\n        bitset<32> b2(str);\\n        return b2.to_ullong();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3089314,
                "title": "java-easy-solution-2ms-easy-to-understand-for-begineer",
                "content": "\\n\\n# Code\\n```\\npublic class Solution {\\n    // you need treat n as an unsigned value\\n    public int reverseBits(int n) {\\n        int res =0;\\n        for(int i =0;i<32;i++) {\\n            //this is used to find least significant digit (lsb)\\n            // 00000010100101000001111010011100 & 1 = 00000010100101000001111010011100<- lsb =0\\n            int lsb = n & 1;\\n\\n            // soo, left shift of lsb lsb<<(31-i) so our 1st position zero will swaped with 31-i.so on...\\n            int revLsb = lsb<<(31-i);\\n           // store the revLsb in our result variable \\n            res = res|revLsb;\\n\\n            // right sift of n , one time ans soo on...\\n            n= n>>1;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic class Solution {\\n    // you need treat n as an unsigned value\\n    public int reverseBits(int n) {\\n        int res =0;\\n        for(int i =0;i<32;i++) {\\n            //this is used to find least significant digit (lsb)\\n            // 00000010100101000001111010011100 & 1 = 00000010100101000001111010011100<- lsb =0\\n            int lsb = n & 1;\\n\\n            // soo, left shift of lsb lsb<<(31-i) so our 1st position zero will swaped with 31-i.so on...\\n            int revLsb = lsb<<(31-i);\\n           // store the revLsb in our result variable \\n            res = res|revLsb;\\n\\n            // right sift of n , one time ans soo on...\\n            n= n>>1;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3005453,
                "title": "s5bit",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        uint32_t x = 0;\\n        int d = 0;\\n        while(n>0){\\n            x+=(n%2) << (31-d);\\n            n >>= 1;\\n            d++;\\n        }\\n        return x;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        uint32_t x = 0;\\n        int d = 0;\\n        while(n>0){\\n            x+=(n%2) << (31-d);\\n            n >>= 1;\\n            d++;\\n        }\\n        return x;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1761429,
                "title": "easy-explanation-with-comments-java",
                "content": "```\\npublic class Solution {\\n    // you need treat n as an unsigned value\\n    public int reverseBits(int n) {\\n        \\n        // return (int)Integer.reverse(n);\\n        \\n        int ans=0;\\n        int j=0;\\n        \\n        //iterate in bits and update ans\\n        \\n        for(int i=31;i>=0;i--){\\n            \\n            int mask=1<<i;\\n            \\n            //means at position i is off, skip\\n            if((n&mask)==0){\\n            }\\n            \\n            //bit is on so shift our pointer to jth position and add it to ans;\\n            else{\\n                ans+=(1<<j);\\n            }   \\n            \\n            j++;\\n        }\\n        \\n        return ans;\\n        \\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bitmask"
                ],
                "code": "```\\npublic class Solution {\\n    // you need treat n as an unsigned value\\n    public int reverseBits(int n) {\\n        \\n        // return (int)Integer.reverse(n);\\n        \\n        int ans=0;\\n        int j=0;\\n        \\n        //iterate in bits and update ans\\n        \\n        for(int i=31;i>=0;i--){\\n            \\n            int mask=1<<i;\\n            \\n            //means at position i is off, skip\\n            if((n&mask)==0){\\n            }\\n            \\n            //bit is on so shift our pointer to jth position and add it to ans;\\n            else{\\n                ans+=(1<<j);\\n            }   \\n            \\n            j++;\\n        }\\n        \\n        return ans;\\n        \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1685305,
                "title": "python-with-20ms-super-simple-clear-explanation",
                "content": "**1. Solution**\\n```    \\ndef reverseBits(self, n):\\n        num = 0              # contains the reversed number\\n        for i in range(32):\\n            num = num << 1   # (1) shift left to have space for a new bit  \\n            bit = n % 2      # (2) get the rightmost bit of the input\\n            num += bit       # (3) add this bit to the output number \\n\\t\\t\\t                 #     and it will be shifted leftwards later\\n            n = n >> 1       # (4) drop the rightmost bit of the input\\n        return num\\n          \\n\\n```\\n**2. Explanation**\\nThere\\'s mainly just 4 steps:\\n1) Get the rightmost bit of the input\\n2) Add the bit to the rightmost position of the output\\n3) Shift this bit leftwards in the output\\n4) Drop this (rightmost) bit at the input\\nRepeat these steps for all 32 bits, and you\\'re done.\\n\\n***Hope this post helps! Please upvote if you find it useful.\\nHave a good coding and have a good day!***",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Bit Manipulation"
                ],
                "code": "```    \\ndef reverseBits(self, n):\\n        num = 0              # contains the reversed number\\n        for i in range(32):\\n            num = num << 1   # (1) shift left to have space for a new bit  \\n            bit = n % 2      # (2) get the rightmost bit of the input\\n            num += bit       # (3) add this bit to the output number \\n\\t\\t\\t                 #     and it will be shifted leftwards later\\n            n = n >> 1       # (4) drop the rightmost bit of the input\\n        return num\\n          \\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1493349,
                "title": "bit-manipulation-c",
                "content": "```\\nclass Solution {\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        uint32_t ans = 0;\\n        for(int i=0; i < 32; i++){\\n            ans = ans << 1;\\n            if(n & 1 == 1) ans++;\\n            n = n >> 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        uint32_t ans = 0;\\n        for(int i=0; i < 32; i++){\\n            ans = ans << 1;\\n            if(n & 1 == 1) ans++;\\n            n = n >> 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 746561,
                "title": "divide-and-conquer-without-bit-masking",
                "content": "The following solution approaches the problem using bit shifting and divide and conquer. It divides the problem using `start` and `end` pointers, and uses those values to shift the input and account for the base case.\\n\\n```java\\npublic class Solution {\\n    // you need treat n as an unsigned value\\n    public int reverseBits(int n) {\\n        return reverse(n, 0, 31);\\n    }\\n    \\n    private int reverse(int n, int start, int end) {\\n        if (start == end) {            \\n            return (n >>> (31-start)) % 2;\\n        }\\n        \\n        int mid = (end-start)/2+start;\\n        \\n        int left = reverse(n, start, mid);\\n        int right = reverse(n, mid+1, end);\\n\\n        return (right << (end-mid)) + left;\\n    }\\n}\\n```\\n\\nBasically, it keeps dividing the problem by half, until it reaches the base case where the subproblem is of size 1. In the base case, it returns the bit at the current position.\\n\\nIn a non-base case, it gets the reversed bits in the left and right subproblems, and uses bit shifting to concatenate the right subsolution and the left subsolution.",
                "solutionTags": [
                    "Divide and Conquer"
                ],
                "code": "```java\\npublic class Solution {\\n    // you need treat n as an unsigned value\\n    public int reverseBits(int n) {\\n        return reverse(n, 0, 31);\\n    }\\n    \\n    private int reverse(int n, int start, int end) {\\n        if (start == end) {            \\n            return (n >>> (31-start)) % 2;\\n        }\\n        \\n        int mid = (end-start)/2+start;\\n        \\n        int left = reverse(n, start, mid);\\n        int right = reverse(n, mid+1, end);\\n\\n        return (right << (end-mid)) + left;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 54867,
                "title": "share-my-one-line-python-solution",
                "content": "- def reverseBits(self, n):\\n\\n        return int('{0:032b}'.format(n)[::-1],2)",
                "solutionTags": [
                    "Python"
                ],
                "code": "- def reverseBits(self, n):\\n\\n        return int('{0:032b}'.format(n)[::-1],2)",
                "codeTag": "Python3"
            },
            {
                "id": 54865,
                "title": "2ms-java-solution",
                "content": "    public class ReverseBits {\\n    \\t// you need treat n as an unsigned value\\n    \\tpublic int reverseBits(int n) {\\n    \\t\\tint reverse = 0;\\n    \\t\\tfor (int i = 0; i < 32; i++) {\\n    \\t\\t\\treverse |= ((n >>> i) & 1) << (31 - i);\\n    \\t\\t}\\n    \\t\\treturn reverse;\\n    \\t}\\n    }",
                "solutionTags": [],
                "code": "    public class ReverseBits {\\n    \\t// you need treat n as an unsigned value\\n    \\tpublic int reverseBits(int n) {\\n    \\t\\tint reverse = 0;\\n    \\t\\tfor (int i = 0; i < 32; i++) {\\n    \\t\\t\\treverse |= ((n >>> i) & 1) << (31 - i);\\n    \\t\\t}\\n    \\t\\treturn reverse;\\n    \\t}\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 54916,
                "title": "what-s-with-the-follow-up",
                "content": "OK, first off, here is the Hacker's Delight (figure 7-1) classics in Java:\\n\\n    public int reverseBits(int n) {\\n        // note: mutating formal parameter\\n        n = ((n & 0x5555_5555) << 1) | ((n >>> 1) & 0x5555_5555);\\n        n = ((n & 0x3333_3333) << 2) | ((n >>> 2) & 0x3333_3333);\\n        n = ((n & 0x0F0F_0F0F) << 4) | ((n >>> 4) & 0x0F0F_0F0F);\\n        return (n >>> 24) | ((n >>> 8) & 0xFF00) | ((n & 0xFF00) << 8) | (n << 24);\\n    }\\n\\nIt's quite obvious once you figure it out. Just reverse bits in pairs, then reverse pairs in quadruples, then reverse quadruples in \\u201coctuples\\u201d (well, bytes or octets), then just reverse bytes. It may seem computation-heavy, but considering that bitwise and shift operations are among the fastest and that it will probably all be done in registers (and the code even minimizes the number of constants involved!), it will be very fast. In fact, that's exactly what `Integer.reverse` does.\\n\\nNow, I see a lot of solutions using a cache. In fact, we can do even better. Suppose our function is called so many times that initialization time doesn't really matter. So it could look like this:\\n\\n    private static final int[] map = new int[65536];\\n    \\n    static {\\n        for (int i = 0; i <= 65535; ++i) {\\n            int n = i;\\n            n = ((n & 0x5555) << 1) | ((n >>> 1) & 0x5555);\\n            n = ((n & 0x3333) << 2) | ((n >>> 2) & 0x3333);\\n            n = ((n & 0x0F0F) << 4) | ((n >>> 4) & 0x0F0F);\\n            map[i] = ((n >>> 8) | (n << 8)) & 0xFFFF;\\n        }\\n    }\\n    \\n    // you need treat n as an unsigned value\\n    public int reverseBits(int n) {\\n        return (map[n & 0xFFFF] << 16) | map[n >>> 16];\\n    }\\n\\nNow class loading will be slow, but then the function will be amazingly fast, as there are only two shifts and one bitwise AND involved. Or will it? Now instead of a lot of arithmetics we have two table lookups. Not to mention this could be hard on cache, memory read operations are obviously much slower than in-register bitwise arithmetics. Maybe changing shorts to bytes can be easier on cache, but then combining the whole thing will look very much like the last [HD] line which is about half of the job. Plus *four* table lookups.\\n\\nThe solution above runs in 55 ms, by the way, while the first one runs in 2. But I don't know whether the OJ loads the class each time for every test case, and there's probably not enough test cases for the \\u201cimprovement\\u201d above to work (assuming it works at all).\\n\\nSo, my question is, isn't the follow-up basically asking to do a premature optimization that not only won't make things any better, but in fact could make it much worse? Or maybe that's exactly the point? Maybe we should answer that using a table is a bad idea and that we should concentrate on optimizing our math instead, referring to [HD] and `Integer.reverse`?",
                "solutionTags": [
                    "Java"
                ],
                "code": "OK, first off, here is the Hacker's Delight (figure 7-1) classics in Java:\\n\\n    public int reverseBits(int n) {\\n        // note: mutating formal parameter\\n        n = ((n & 0x5555_5555) << 1) | ((n >>> 1) & 0x5555_5555);\\n        n = ((n & 0x3333_3333) << 2) | ((n >>> 2) & 0x3333_3333);\\n        n = ((n & 0x0F0F_0F0F) << 4) | ((n >>> 4) & 0x0F0F_0F0F);\\n        return (n >>> 24) | ((n >>> 8) & 0xFF00) | ((n & 0xFF00) << 8) | (n << 24);\\n    }\\n\\nIt's quite obvious once you figure it out. Just reverse bits in pairs, then reverse pairs in quadruples, then reverse quadruples in \\u201coctuples\\u201d (well, bytes or octets), then just reverse bytes. It may seem computation-heavy, but considering that bitwise and shift operations are among the fastest and that it will probably all be done in registers (and the code even minimizes the number of constants involved!), it will be very fast. In fact, that's exactly what `Integer.reverse` does.\\n\\nNow, I see a lot of solutions using a cache. In fact, we can do even better. Suppose our function is called so many times that initialization time doesn't really matter. So it could look like this:\\n\\n    private static final int[] map = new int[65536];\\n    \\n    static {\\n        for (int i = 0; i <= 65535; ++i) {\\n            int n = i;\\n            n = ((n & 0x5555) << 1) | ((n >>> 1) & 0x5555);\\n            n = ((n & 0x3333) << 2) | ((n >>> 2) & 0x3333);\\n            n = ((n & 0x0F0F) << 4) | ((n >>> 4) & 0x0F0F);\\n            map[i] = ((n >>> 8) | (n << 8)) & 0xFFFF;\\n        }\\n    }\\n    \\n    // you need treat n as an unsigned value\\n    public int reverseBits(int n) {\\n        return (map[n & 0xFFFF] << 16) | map[n >>> 16];\\n    }\\n\\nNow class loading will be slow, but then the function will be amazingly fast, as there are only two shifts and one bitwise AND involved. Or will it? Now instead of a lot of arithmetics we have two table lookups. Not to mention this could be hard on cache, memory read operations are obviously much slower than in-register bitwise arithmetics. Maybe changing shorts to bytes can be easier on cache, but then combining the whole thing will look very much like the last [HD] line which is about half of the job. Plus *four* table lookups.\\n\\nThe solution above runs in 55 ms, by the way, while the first one runs in 2. But I don't know whether the OJ loads the class each time for every test case, and there's probably not enough test cases for the \\u201cimprovement\\u201d above to work (assuming it works at all).\\n\\nSo, my question is, isn't the follow-up basically asking to do a premature optimization that not only won't make things any better, but in fact could make it much worse? Or maybe that's exactly the point? Maybe we should answer that using a table is a bad idea and that we should concentrate on optimizing our math instead, referring to [HD] and `Integer.reverse`?",
                "codeTag": "Java"
            },
            {
                "id": 54943,
                "title": "c-3ms-solution-with-lookup-table",
                "content": "    const uint8_t lookup[] = {0, 128, 64, 192, 32, 160, 96, 224, 16, 144, 80, 208, 48, 176, 112, 240, 8, 136, 72, 200, 40, 168, 104, 232, 24, 152, 88, 216, 56, 184, 120, 248, 4, 132, 68, 196, 36, 164, 100, 228, 20, 148, 84, 212, 52, 180, 116, 244, 12, 140, 76, 204, 44, 172, 108, 236, 28, 156, 92, 220, 60, 188, 124, 252, 2, 130, 66, 194, 34, 162, 98, 226, 18, 146, 82, 210, 50, 178, 114, 242, 10, 138, 74, 202, 42, 170, 106, 234, 26, 154, 90, 218, 58, 186, 122, 250, 6, 134, 70, 198, 38, 166, 102, 230, 22, 150, 86, 214, 54, 182, 118, 246, 14, 142, 78, 206, 46, 174, 110, 238, 30, 158, 94, 222, 62, 190, 126, 254, 1, 129, 65, 193, 33, 161, 97, 225, 17, 145, 81, 209, 49, 177, 113, 241, 9, 137, 73, 201, 41, 169, 105, 233, 25, 153, 89, 217, 57, 185, 121, 249, 5, 133, 69, 197, 37, 165, 101, 229, 21, 149, 85, 213, 53, 181, 117, 245, 13, 141, 77, 205, 45, 173, 109, 237, 29, 157, 93, 221, 61, 189, 125, 253, 3, 131, 67, 195, 35, 163, 99, 227, 19, 147, 83, 211, 51, 179, 115, 243, 11, 139, 75, 203, 43, 171, 107, 235, 27, 155, 91, 219, 59, 187, 123, 251, 7, 135, 71, 199, 39, 167, 103, 231, 23, 151, 87, 215, 55, 183, 119, 247, 15, 143, 79, 207, 47, 175, 111, 239, 31, 159, 95, 223, 63, 191, 127, 255};\\n    \\n    uint32_t reverseBits(uint32_t n) {\\n        uint32_t ret;\\n        register uint8_t *p = (uint8_t *)&n, *q = (uint8_t *)&ret;\\n            \\n        q[0] = lookup[p[3]];\\n        q[1] = lookup[p[2]];\\n        q[2] = lookup[p[1]];\\n        q[3] = lookup[p[0]];\\n        \\n        return ret;\\n    }",
                "solutionTags": [],
                "code": "    const uint8_t lookup[] = {0, 128, 64, 192, 32, 160, 96, 224, 16, 144, 80, 208, 48, 176, 112, 240, 8, 136, 72, 200, 40, 168, 104, 232, 24, 152, 88, 216, 56, 184, 120, 248, 4, 132, 68, 196, 36, 164, 100, 228, 20, 148, 84, 212, 52, 180, 116, 244, 12, 140, 76, 204, 44, 172, 108, 236, 28, 156, 92, 220, 60, 188, 124, 252, 2, 130, 66, 194, 34, 162, 98, 226, 18, 146, 82, 210, 50, 178, 114, 242, 10, 138, 74, 202, 42, 170, 106, 234, 26, 154, 90, 218, 58, 186, 122, 250, 6, 134, 70, 198, 38, 166, 102, 230, 22, 150, 86, 214, 54, 182, 118, 246, 14, 142, 78, 206, 46, 174, 110, 238, 30, 158, 94, 222, 62, 190, 126, 254, 1, 129, 65, 193, 33, 161, 97, 225, 17, 145, 81, 209, 49, 177, 113, 241, 9, 137, 73, 201, 41, 169, 105, 233, 25, 153, 89, 217, 57, 185, 121, 249, 5, 133, 69, 197, 37, 165, 101, 229, 21, 149, 85, 213, 53, 181, 117, 245, 13, 141, 77, 205, 45, 173, 109, 237, 29, 157, 93, 221, 61, 189, 125, 253, 3, 131, 67, 195, 35, 163, 99, 227, 19, 147, 83, 211, 51, 179, 115, 243, 11, 139, 75, 203, 43, 171, 107, 235, 27, 155, 91, 219, 59, 187, 123, 251, 7, 135, 71, 199, 39, 167, 103, 231, 23, 151, 87, 215, 55, 183, 119, 247, 15, 143, 79, 207, 47, 175, 111, 239, 31, 159, 95, 223, 63, 191, 127, 255};\\n    \\n    uint32_t reverseBits(uint32_t n) {\\n        uint32_t ret;\\n        register uint8_t *p = (uint8_t *)&n, *q = (uint8_t *)&ret;\\n            \\n        q[0] = lookup[p[3]];\\n        q[1] = lookup[p[2]];\\n        q[2] = lookup[p[1]];\\n        q[3] = lookup[p[0]];\\n        \\n        return ret;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3287155,
                "title": "simple-java-code-with-explanation-with-less-time-complexity",
                "content": "The given Java code is an implementation of the \"Reverse Bits\" problem, which requires reversing the bits of a 32-bit unsigned integer.\\n\\nHere\\'s a detailed explanation of how the code works:\\n\\n```\\npublic class Solution {\\n    // you need treat n as an unsigned value\\n    public int reverseBits(int n) {\\n        int x=0;\\n        int i=31;\\n        while(i>=0){\\n            x |= ((n >> i) & 1) << (31 - i);\\n            i--;\\n        }\\n        return x;\\n    }\\n}\\n```\\nThe function reverseBits takes an integer n as input, which is to be treated as an unsigned 32-bit integer. The function returns the reversed version of n.\\n\\nThe variable x is initially set to zero. This variable will hold the reversed integer. The variable i is initialized to 31, which is the index of the most significant bit in a 32-bit unsigned integer.\\n\\nThe while loop iterates from i = 31 to i = 0. In each iteration, the i-th bit of n is extracted using the right shift operator >> and the bitwise AND operator &. Specifically, the expression (n >> i) & 1 extracts the i-th bit of n. The extracted bit is then shifted to the correct position in the reversed integer x using the left shift operator <<. Specifically, the expression ((n >> i) & 1) << (31 - i) shifts the extracted bit to the (31-i)th position in x. Finally, the shifted bit is OR-ed with the existing bits in x using the bitwise OR operator |. Specifically, the expression x |= ... sets the (31-i)th bit of x to the value of the i-th bit of n.\\n\\nAfter all 32 bits have been processed, the reversed integer x is returned as the output of the function.",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\npublic class Solution {\\n    // you need treat n as an unsigned value\\n    public int reverseBits(int n) {\\n        int x=0;\\n        int i=31;\\n        while(i>=0){\\n            x |= ((n >> i) & 1) << (31 - i);\\n            i--;\\n        }\\n        return x;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3081380,
                "title": "100-beat-easy-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        int arr[32]={0};\\n        // for(int i=0;i<32;i++){\\n        //     arr[i]=n%10;\\n        //     n=n/10;\\n        // }\\n        int i=0;\\n        while(n!=0){\\n            int rem=0;\\n            rem=n%2;\\n             arr[i]=rem;\\n              n=n/2;\\n              i++;\\n    }\\n\\n        long long ans=0;\\n        for(int i=0;i<32;i++){\\n            ans+=arr[i]*pow(2,32-1-i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        int arr[32]={0};\\n        // for(int i=0;i<32;i++){\\n        //     arr[i]=n%10;\\n        //     n=n/10;\\n        // }\\n        int i=0;\\n        while(n!=0){\\n            int rem=0;\\n            rem=n%2;\\n             arr[i]=rem;\\n              n=n/2;\\n              i++;\\n    }\\n\\n        long long ans=0;\\n        for(int i=0;i<32;i++){\\n            ans+=arr[i]*pow(2,32-1-i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2401921,
                "title": "c-simple-bit-manipulation-0ms-brief-explanation",
                "content": "In this approach , First you will initialize result(k) with 0. As we have 32 bits in 32 bit unsigned integer(n) so we can ran loop 32 times. In each iteration , we will left shift one bit of our current result and then we do `n&1` so that we can know that whether we have 0 or 1 as first (right most ) bit . Now we can update our result with the equation ` k=(k|(n&1))` and also we update our number(n) by right shifting of one bit of it . After 32 iteration we can find that we have result k as reversed bit of number n. \\n\\n```\\nclass Solution {\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        int i=32;\\n        uint32_t k=0;\\n    while(i--){\\n      k<<=1;\\n        k=(k|(n&1));\\n        n>>=1;\\n        }\\n        return k;\\n    }\\n};\\n```\\nPlease upvote if you like this solution !\\nAll the Best !!\\n\\n\\n\\n",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        int i=32;\\n        uint32_t k=0;\\n    while(i--){\\n      k<<=1;\\n        k=(k|(n&1));\\n        n>>=1;\\n        }\\n        return k;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1703007,
                "title": "simple-java-solution-with-comments-bitwise",
                "content": "think it like converting number to 10 base number. so we iterate big number diigit by digit and  do multiply each digit by 10 and then add last digit to it.\\nlike 123 can be written as 1 * 100 + 2 * 10 + 3 * 1 = 123\\nand for reverse -> \\n3 * 10 + 2 = 32\\n32 * 10 + 1 = 321\\n\\nin same way we will do conversion in 2 base. so loop from 0 to 31 digit and keep on preparing result. \\n```\\npublic int reverseBits(int n) {\\n        int res=0;\\n        for(int i=0;i<32;i++) {\\n\\t\\t   //multiply by 2\\n            res=res<<1;\\n\\t\\t\\t//add last digit to res\\n            res=res+(n&1);\\n\\t\\t\\t//update n by removing last digit\\n            n=n>>1;\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\npublic int reverseBits(int n) {\\n        int res=0;\\n        for(int i=0;i<32;i++) {\\n\\t\\t   //multiply by 2\\n            res=res<<1;\\n\\t\\t\\t//add last digit to res\\n            res=res+(n&1);\\n\\t\\t\\t//update n by removing last digit\\n            n=n>>1;\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1375685,
                "title": "0ms-c-solution-beginner-friendly",
                "content": "```\\n uint32_t reverseBits(uint32_t n) {\\n        uint32_t ans=0;\\n        for(int i=0;i<32;i++){\\n            ans=(ans<<1)+(n&1);\\n           n= n>>1;\\n        }\\n        return ans;\\n    }",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\n uint32_t reverseBits(uint32_t n) {\\n        uint32_t ans=0;\\n        for(int i=0;i<32;i++){\\n            ans=(ans<<1)+(n&1);\\n           n= n>>1;\\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1008703,
                "title": "rust-bit-operation-solution",
                "content": "Runtime: 0 ms, faster than 100.00% of Rust online submissions for Reverse Bits.\\nMemory Usage: 1.9 MB, less than 95.83% of Rust online submissions for Reverse Bits.\\n```\\nimpl Solution {\\n    pub fn reverse_bits(x: u32) -> u32 {\\n        let (mut res, mut x) = (0u32, x);\\n        for _ in 0..32 {\\n            res = (res << 1) | (x & 1);\\n            x >>= 1;\\n        }\\n        res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn reverse_bits(x: u32) -> u32 {\\n        let (mut res, mut x) = (0u32, x);\\n        for _ in 0..32 {\\n            res = (res << 1) | (x & 1);\\n            x >>= 1;\\n        }\\n        res\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 562090,
                "title": "swift-very-simple-solution",
                "content": "```\\nclass Solution {\\n    func reverseBits(_ n: Int) -> Int {\\n        let raw = String(n, radix: 2)\\n        let str = String(repeating: \"0\", count: 32 - raw.count) + raw\\n        return Int(String(str.reversed()), radix: 2) ?? -1\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func reverseBits(_ n: Int) -> Int {\\n        let raw = String(n, radix: 2)\\n        let str = String(repeating: \"0\", count: 32 - raw.count) + raw\\n        return Int(String(str.reversed()), radix: 2) ?? -1\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 474948,
                "title": "simple-java-solution-beats-100-with-explaination",
                "content": "<img src=\"https://assets.leetcode.com/users/magi003769/image_1578547693.png\" style=\"zoom:50%\" />\\n\\nIn each loop, use logical AND operation `n & 1` to get the least significant bit and add it to the `ans`. To reverse the bit, shift `n` and `ans` in opposite directions. What needs attention is that, after we add the last bit of `n`  to `ans` at the 32th loop, the following left shift of `ans` is no longer needed. The most significant bit of `n` has already at the right most position after previous 31 loops. \\n\\n```\\npublic class Solution {\\n    // you need treat n as an unsigned value\\n    public int reverseBits(int n) {\\n        int ans = 0;\\n        for(int i=0; i < 31; i++) {\\n            ans += (n & 1);    // add the new bit\\n            ans = ans << 1;   // left shift ans to mantain previous bits\\n            n = n >> 1;         // get the right most bit\\n        }\\n        ans += (n & 1);\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    // you need treat n as an unsigned value\\n    public int reverseBits(int n) {\\n        int ans = 0;\\n        for(int i=0; i < 31; i++) {\\n            ans += (n & 1);    // add the new bit\\n            ans = ans << 1;   // left shift ans to mantain previous bits\\n            n = n >> 1;         // get the right most bit\\n        }\\n        ans += (n & 1);\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 427104,
                "title": "javascript-solution",
                "content": "```\\n/**\\n * @param {number} n - a positive integer\\n * @return {number} - a positive integer\\n */\\nvar reverseBits = function(n) {\\n    let result = 0;\\n    \\n    for(let i = 0; i < 32; i++) {    \\n        result <<= 1;  \\n        result |= n & 1;  \\n        n >>= 1;\\n    }\\n    \\n    return result >>> 0;\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n - a positive integer\\n * @return {number} - a positive integer\\n */\\nvar reverseBits = function(n) {\\n    let result = 0;\\n    \\n    for(let i = 0; i < 32; i++) {    \\n        result <<= 1;  \\n        result |= n & 1;  \\n        n >>= 1;\\n    }\\n    \\n    return result >>> 0;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 245459,
                "title": "java-solutions",
                "content": "**Solution 1:**\\n\\nTime complexity: `O(k) = O(log n)` - where `k` is the number of bits in the integer.\\nSpace complexity: `O(1)`\\n\\n```\\nclass Solution\\n{\\n\\tpublic int reverseBits(int n)\\n\\t{\\n\\t\\tint result = 0;\\n\\t\\t\\n\\t\\tfor(int i = 0; i < 32; i++)\\n\\t\\t{\\n\\t\\t\\tresult <<= 1;\\n\\t\\t\\tresult += n & 1;\\n\\t\\t\\tn >>>= 1;\\n\\t\\t}\\n\\t\\treturn result;\\n    }\\n}\\n```\\n\\n**Solution 2:**\\n\\n- For 8 bit binary number `A B C D E F G H`, the process is like: `A B C D E F G H --> E F G H A B C D --> G H E F C D A B --> H G F E D C B A`\\n\\nTime complexity: `O(k) = O(log n)` - where `k` is the number of bits in the integer.\\nSpace complexity: `O(1)`\\n\\n```\\nclass Solution\\n{\\n\\tpublic int reverseBits(int n)\\n\\t{\\n\\t\\tn = (n >>> 16) | (n << 16);\\n        n = ((n & 0xFF00FF00) >>> 8) | ((n & 0x00FF00FF) << 8);\\n        n = ((n & 0xF0F0F0F0) >>> 4) | ((n & 0x0F0F0F0F) << 4);\\n        n = ((n & 0xCCCCCCCC) >>> 2) | ((n & 0x33333333) << 2);\\n        n = ((n & 0xAAAAAAAA) >>> 1) | ((n & 0x55555555) << 1);\\n        return n;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n{\\n\\tpublic int reverseBits(int n)\\n\\t{\\n\\t\\tint result = 0;\\n\\t\\t\\n\\t\\tfor(int i = 0; i < 32; i++)\\n\\t\\t{\\n\\t\\t\\tresult <<= 1;\\n\\t\\t\\tresult += n & 1;\\n\\t\\t\\tn >>>= 1;\\n\\t\\t}\\n\\t\\treturn result;\\n    }\\n}\\n```\n```\\nclass Solution\\n{\\n\\tpublic int reverseBits(int n)\\n\\t{\\n\\t\\tn = (n >>> 16) | (n << 16);\\n        n = ((n & 0xFF00FF00) >>> 8) | ((n & 0x00FF00FF) << 8);\\n        n = ((n & 0xF0F0F0F0) >>> 4) | ((n & 0x0F0F0F0F) << 4);\\n        n = ((n & 0xCCCCCCCC) >>> 2) | ((n & 0x33333333) << 2);\\n        n = ((n & 0xAAAAAAAA) >>> 1) | ((n & 0x55555555) << 1);\\n        return n;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 213951,
                "title": "javascript-commented-bitwise-solution-64ms-100-and-es8-string-wranglin-solution-72ms",
                "content": "**TLDR**: 100% solution is at the bottom\\n\\nMy initial solution converts n to a string, pads the start with the missing 0s, converts the str to an array, reverses it, and then converts it back to a string to parse as a base2 number. This attempt landed me at 76ms and a sad ~29.  I replaced [...str] with str.split(\\'\\') for a 4ms which seems small, but moved my solution from being faster than ~29% to 54%. No further optimizations were made on this solution and I moved to a \\'bitwiser\\' (lol) solution.\\n###### es8 string wranglin\\' solution (72ms, 54%)\\n```\\nconst reverseBits = n => {\\n    const str = n.toString(2).padStart(32, \\'0\\');\\n    return parseInt(str.split(\\'\\').reverse().join(\\'\\'), 2)      \\n};\\n```\\n\\nMy next attempt loops through each bit left shifting the result by 1, adding the value of n\\'s right most bit to result, and then right shifting n by 1. Finally we use `result >>> 0` to force javascript to treat it as unsigned.\\n\\n###### \\'bitwiser\\' solution (64ms, 100%)\\n```\\nconst reverseBits = n => {\\n    let result = 0;\\n    for ( let i = 0; i < 32; i++) {\\n        result <<= 1;\\n        result |= n & 1;\\n        n >>>= 1;\\n        // uncomment for help visualiziing\\n        // console.log(result.toString(2), \\'<<<\\', n.toString(2));\\n    }\\n    return result >>> 0;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nconst reverseBits = n => {\\n    const str = n.toString(2).padStart(32, \\'0\\');\\n    return parseInt(str.split(\\'\\').reverse().join(\\'\\'), 2)      \\n};\\n```\n```\\nconst reverseBits = n => {\\n    let result = 0;\\n    for ( let i = 0; i < 32; i++) {\\n        result <<= 1;\\n        result |= n & 1;\\n        n >>>= 1;\\n        // uncomment for help visualiziing\\n        // console.log(result.toString(2), \\'<<<\\', n.toString(2));\\n    }\\n    return result >>> 0;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 166657,
                "title": "python-with-bitwise-reversal",
                "content": "```\\n    def reverseBits(self, n):\\n        if n==0:\\n            return 0\\n        \\n        res = 0\\n        for i in range(32):\\n            res = res<<1\\n            res += n & 1 # last bit\\n            n = n >> 1\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\n    def reverseBits(self, n):\\n        if n==0:\\n            return 0\\n        \\n        res = 0\\n        for i in range(32):\\n            res = res<<1\\n            res += n & 1 # last bit\\n            n = n >> 1\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 54792,
                "title": "one-line-python-solution-with-brief-explanation",
                "content": "My basic idea is:\\n1.  Convert the given integer to an 32-bit binary string;\\n2.  Reverse the string;\\n3.  Convert it back to integer and return\\n\\nFor step 1: we can use '{0:032b}.format() to do it. The first '0' means that we will format the 0th(the first) argument; and the second '0' represents the padding symbol; '32' means total length of the output and 'b' represents binary.\\nAfter this, we can use slicing and built-in functions to finish.\\n\\nBy the way, I personally don't like the one-line code, because I think readability is very important while some people are kind of crazy about very short code; Another thing is that, although Python provides a lot powerful built-in functions, but don't rely too much on it. \\nHave fun. \\n```\\nclass Solution:\\n  def reverseBits(self, n):\\n    return int('{0:032b}'.format(n)[::-1], 2)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n  def reverseBits(self, n):\\n    return int('{0:032b}'.format(n)[::-1], 2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 54853,
                "title": "most-simple-c-solution",
                "content": "```\\npublic class Solution {\\n    public uint reverseBits(uint n)\\n    {\\n        uint num = 0;\\n        for(int i = 0; i < 32; ++i){\\n            num <<= 1;\\n            num += n % 2;\\n            n >>= 1;\\n        }\\n        return num;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public uint reverseBits(uint n)\\n    {\\n        uint num = 0;\\n        for(int i = 0; i < 32; ++i){\\n            num <<= 1;\\n            num += n % 2;\\n            n >>= 1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 54870,
                "title": "c-naive-and-optimized",
                "content": "    class Solution {\\n    public:\\n        // naive solution\\n        /*\\n        uint32_t reverseBits(uint32_t n) {\\n            uint32_t ans = 0;\\n            for(int i = 0, j = 31; i <= 31; ++i, --j){\\n                uint32_t tmp = n & (1 << i);\\n                if(tmp){\\n                    ans |= (1 << j);\\n                }\\n            }\\n            return ans;\\n        }\\n        */\\n        //look up a 4 bit chuck and find out what the reverse is\\n        char tb[16] = {0,8,4,12,2,10,6,14,1,9,5,13,3,11,7,15};\\n        uint32_t reverseBits(uint32_t n) {\\n            uint32_t cur = 0;\\n            uint32_t ans = 0;\\n            uint32_t msk = 0xf;\\n            for(int i = 0;i < 8; ++i){\\n                ans <<= 4;\\n                cur = n & msk;\\n                cur = tb[cur];\\n                ans = ans | cur;\\n                n >>= 4;\\n            }\\n            return ans;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        // naive solution\\n        /*\\n        uint32_t reverseBits(uint32_t n) {\\n            uint32_t ans = 0;\\n            for(int i = 0, j = 31; i <= 31; ++i, --j){\\n                uint32_t tmp = n & (1 << i);\\n                if(tmp){\\n                    ans |= (1 << j);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 54923,
                "title": "java-solution-using-java-functions",
                "content": "    public class Solution {\\n    // you need treat n as an unsigned value\\n    public int reverseBits(int n) {\\n        String op = String.format(\"%32s\", Integer.toBinaryString(n)).replace(' ', '0');\\n        op = new StringBuilder(op).reverse().toString();\\n        int num = Integer.parseUnsignedInt(op,2);\\n        return num;\\n    }}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    // you need treat n as an unsigned value\\n    public int reverseBits(int n) {\\n        String op = String.format(\"%32s\", Integer.toBinaryString(n)).replace(' ', '0');\\n        op = new StringBuilder(op).reverse().toString();\\n        int num = Integer.parseUnsignedInt(op,2);\\n        return num;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 55040,
                "title": "pure-c-solution-with-3ms",
                "content": "    uint32_t reverseBits(uint32_t n) {\\n    int i;\\n    uint32_t res = 0;\\n    for(i = 0; i < 32; i++) {\\n        res = (res << 1) ^ (n & 1);\\n        n >>= 1;\\n    }\\n    return res;\\n}",
                "solutionTags": [],
                "code": "    uint32_t reverseBits(uint32_t n) {\\n    int i;\\n    uint32_t res = 0;\\n    for(i = 0; i < 32; i++) {\\n        res = (res << 1) ^ (n & 1);\\n        n >>= 1;\\n    }\\n    return res;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 54958,
                "title": "one-of-most-concise-solutions-in-java",
                "content": "    public class Solution {\\n        // you need treat n as an unsigned value\\n        public int reverseBits(int n) {\\n            int reverse = 0;\\n            for (int i = 0; i < 32; ++i) {\\n                reverse = (reverse << 1) ^ (n & 0x1);\\n                n >>>= 1;\\n            }\\n            return reverse;\\n        }\\n    }\\n\\nAny suggestions? Thanks.",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        // you need treat n as an unsigned value\\n        public int reverseBits(int n) {\\n            int reverse = 0;\\n            for (int i = 0; i < 32; ++i) {\\n                reverse = (reverse << 1) ^ (n & 0x1);\\n                n >>>= 1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3945442,
                "title": "beats-100-easy-solution-explained-with-dry-run-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIntuition is to reverse the bits of an unsigned integer by iteratively extracting the least significant bit (LSB) of the input number n and building the reversed number bit by bit.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nwe create reversed variable, then we iterate over the bits of n here\\'s a dry run to understand better.\\n\\n    Initial values:\\n\\n    n = 110 (in binary: 0110110)\\n    reversed = 0 (in binary: 0)\\n\\n- Iteration 1:\\n    - Shift reversed left by 1: reversed = 0 (in binary: 00)\\n    - Get the LSB of n using n & 1, which is 0.\\n    - Add the least significant bit to reversed:\\n    `reversed = 0 (in binary: 00)`\\n    `Right shift n by 1: n = 55 (in binary: 0011011)`\\n\\n- Iteration 2:\\n    - Shift reversed left by 1: reversed = 0 (in binary: 000)\\n    - Get the LSB of n using n & 1, which is 1.\\n    - Add the least significant bit to reversed: \\n    `reversed = 1 (in binary: 0001)`\\n`    Right shift n by 1: n = 27 (in binary: 0001101)`\\n\\n- Iteration 3:\\n    - Shift reversed left by 1: reversed = 2 (in binary: 0010)\\n    - Get the LSB of n using n & 1, which is 1.\\n    - Add the least significant bit to reversed: \\n    `reversed = 3 (in binary: 0011)`\\n    `Right shift n by 1: n = 13 (in binary: 00001101)`\\n\\n- Iteration 4:\\n    - Shift reversed left by 1: reversed = 6 (in binary: 0110)\\n    - Get the LSB of n using n & 1, which is 1.\\n    - Add the least significant bit to reversed: \\n    `reversed = 7 (in binary: 0111)`\\n    `Right shift n by 1: n = 6 (in binary: 00000110)`\\n\\n- Iteration 5:\\n    - Shift reversed left by 1: reversed = 14 (in binary: 1110)\\n    - Get the LSB of n using n & 1, which is 0.\\n    - Add the least significant bit to reversed:\\n    `reversed = 14 (in binary: 1110)`\\n    `Right shift n by 1: n = 3 (in binary: 00000011)`\\n\\n- Iteration 6:\\n    - Shift reversed left by 1: reversed = 28 (in binary: 11100)\\n    - Get the LSB of n using n & 1, which is 1.\\n    - Add the least significant bit to reversed: \\n    `reversed = 29 (in binary: 11101)`\\n    `Right shift n by 1: n = 1 (in binary: 00000001)`\\n\\n- Iteration 7:\\n    - Shift reversed left by 1: reversed = 58 (in binary: 111010)\\n    - Get the LSB of n using n & 1, which is 1.\\n    - Add the least significant bit to reversed: \\n    `reversed = 59 (in binary: 111011)`\\n    `Right shift n by 1: n = 0 (in binary: 00000000)`\\n\\n# Complexity\\n- Time complexity:\\n$$O(1)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\npublic class Solution {\\n    public int reverseBits(int n) {\\n        int reversed = 0; \\n\\n        for (int i = 0; i < 32; i++) {\\n            \\n            // Left shift the reversed cause\\n            // we need to set new bit value and\\n            // don\\'t need to override the previous one\\n            reversed <<= 1; \\n\\n            // Add the least significant bit of n to reversed\\n            reversed += n & 1; \\n            \\n            // Right shift n to move to the next bit\\n            n >>= 1; \\n        }\\n\\n        return reversed;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic class Solution {\\n    public int reverseBits(int n) {\\n        int reversed = 0; \\n\\n        for (int i = 0; i < 32; i++) {\\n            \\n            // Left shift the reversed cause\\n            // we need to set new bit value and\\n            // don\\'t need to override the previous one\\n            reversed <<= 1; \\n\\n            // Add the least significant bit of n to reversed\\n            reversed += n & 1; \\n            \\n            // Right shift n to move to the next bit\\n            n >>= 1; \\n        }\\n\\n        return reversed;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3232945,
                "title": "powerful-logic-python3-java-golang",
                "content": "\\n# 1. Python3 Solution\\n```\\nclass Solution:\\n    def reverseBits(self, n: int) -> int:\\n        output=0\\n        for i in range(32):\\n            bits=n & 1\\n            output= output | bits << (31-i)\\n            n=n >> 1\\n        return output\\n\\n```\\n# 2. Golang Solution\\n```\\nfunc reverseBits(num uint32) uint32 {\\n    var answer uint32\\n    for i:=0;i<32;i++{\\n        answer=answer | (num&1)<<(31-i)\\n        num=num>>1\\n    }\\n    return answer \\n}\\n```\\n# 3. Java Solution\\n```\\npublic class Solution {\\n    // you need treat n as an unsigned value\\n    public int reverseBits(int n) {\\n        int answer=0;\\n        for (int i=0;i<32;i++){\\n            answer=answer | (n&1)<<(31-i);\\n            n=n>>1;\\n        }\\n        return answer;\\n        \\n    }\\n}\\n```\\n# please upvote me it would encourage me alot\\n",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "Go"
                ],
                "code": "```\\nclass Solution:\\n    def reverseBits(self, n: int) -> int:\\n        output=0\\n        for i in range(32):\\n            bits=n & 1\\n            output= output | bits << (31-i)\\n            n=n >> 1\\n        return output\\n\\n```\n```\\nfunc reverseBits(num uint32) uint32 {\\n    var answer uint32\\n    for i:=0;i<32;i++{\\n        answer=answer | (num&1)<<(31-i)\\n        num=num>>1\\n    }\\n    return answer \\n}\\n```\n```\\npublic class Solution {\\n    // you need treat n as an unsigned value\\n    public int reverseBits(int n) {\\n        int answer=0;\\n        for (int i=0;i<32;i++){\\n            answer=answer | (n&1)<<(31-i);\\n            n=n>>1;\\n        }\\n        return answer;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3005457,
                "title": "easy-c-5",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        uint32_t x = 0;\\n        int d = 0;\\n        while(n>0){\\n            x+=(n%2) << (31-d);\\n            n >>= 1;\\n            d++;\\n        }\\n        return x;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        uint32_t x = 0;\\n        int d = 0;\\n        while(n>0){\\n            x+=(n%2) << (31-d);\\n            n >>= 1;\\n            d++;\\n        }\\n        return x;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3005451,
                "title": "easyc-3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        uint32_t x = 0;\\n        int d = 0;\\n        while(n>0){\\n            x+=(n%2) << (31-d);\\n            n >>= 1;\\n            d++;\\n        }\\n        return x;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        uint32_t x = 0;\\n        int d = 0;\\n        while(n>0){\\n            x+=(n%2) << (31-d);\\n            n >>= 1;\\n            d++;\\n        }\\n        return x;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3005432,
                "title": "s1bit",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        uint32_t x = 0;\\n        int d = 0;\\n        while(n>0){\\n            x+=(n%2) << (31-d);\\n            n >>= 1;\\n            d++;\\n        }\\n        return x;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        uint32_t x = 0;\\n        int d = 0;\\n        while(n>0){\\n            x+=(n%2) << (31-d);\\n            n >>= 1;\\n            d++;\\n        }\\n        return x;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3005372,
                "title": "rb6c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        uint32_t x = 0;\\n        int d = 0;\\n        while(n>0){\\n            x+=(n%2) << (31-d);\\n            n >>= 1;\\n            d++;\\n        }\\n        return x;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        uint32_t x = 0;\\n        int d = 0;\\n        while(n>0){\\n            x+=(n%2) << (31-d);\\n            n >>= 1;\\n            d++;\\n        }\\n        return x;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3005370,
                "title": "rb4-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        uint32_t x = 0;\\n        int d = 0;\\n        while(n>0){\\n            x+=(n%2) << (31-d);\\n            n >>= 1;\\n            d++;\\n        }\\n        return x;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        uint32_t x = 0;\\n        int d = 0;\\n        while(n>0){\\n            x+=(n%2) << (31-d);\\n            n >>= 1;\\n            d++;\\n        }\\n        return x;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3005364,
                "title": "rb3-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        uint32_t x = 0;\\n        int d = 0;\\n        while(n>0){\\n            x+=(n%2) << (31-d);\\n            n >>= 1;\\n            d++;\\n        }\\n        return x;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        uint32_t x = 0;\\n        int d = 0;\\n        while(n>0){\\n            x+=(n%2) << (31-d);\\n            n >>= 1;\\n            d++;\\n        }\\n        return x;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3005362,
                "title": "rb1c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        uint32_t x = 0;\\n        int d = 0;\\n        while(n>0){\\n            x+=(n%2) << (31-d);\\n            n >>= 1;\\n            d++;\\n        }\\n        return x;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        uint32_t x = 0;\\n        int d = 0;\\n        while(n>0){\\n            x+=(n%2) << (31-d);\\n            n >>= 1;\\n            d++;\\n        }\\n        return x;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3005321,
                "title": "c-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        uint32_t x = 0;\\n        int d = 0;\\n        while(n>0){\\n            x+=(n%2) << (31-d);\\n            n >>= 1;\\n            d++;\\n        }\\n        return x;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        uint32_t x = 0;\\n        int d = 0;\\n        while(n>0){\\n            x+=(n%2) << (31-d);\\n            n >>= 1;\\n            d++;\\n        }\\n        return x;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2727766,
                "title": "my-brute-force-bit-manipulation-3ms-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        uint32_t a=0;\\n     for (int i=0;i<31;i++)\\n     {\\n        if(n&1)\\n         a+=1;\\n         a<<=1;\\n         n=n>>1;\\n     }\\n        if(n&1)a+=1;\\n        return a;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        uint32_t a=0;\\n     for (int i=0;i<31;i++)\\n     {\\n        if(n&1)\\n         a+=1;\\n         a<<=1;\\n         n=n>>1;\\n     }\\n        if(n&1)a+=1;\\n        return a;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2493907,
                "title": "simple-solution-in-python-directly-created-a-32-bit-representation-of-given-integer",
                "content": "def reverseBits(self, n: int) -> int:\\n        a = f\\'{n:032b}\\'\\n        a= a[::-1]\\n        return int(a,2)",
                "solutionTags": [
                    "Python"
                ],
                "code": "def reverseBits(self, n: int) -> int:\\n        a = f\\'{n:032b}\\'\\n        a= a[::-1]\\n        return int(a,2)",
                "codeTag": "Python3"
            },
            {
                "id": 2440929,
                "title": "c-python-optimized-o-n-solution",
                "content": "### C++\\nRuntime: 5 ms, faster than 32.53% of C++ online submissions for Reverse Bits.\\nMemory Usage: 5.9 MB, less than 51.91% of C++ online submissions for Reverse Bits.\\n```\\nclass Solution {\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        uint32_t res = 0;\\n        for (int i = 0; i<32; i++) {\\n            res <<= 1;\\n            res += n % 2;\\n            n >>= 1;\\n        }\\n        return res;\\n    }\\n};\\n```\\nTime Complexity: O(N)\\nSpace Complexity: O(1)\\n\\n### Python\\nRuntime: 59 ms, faster than 31.44% of Python3 online submissions for Reverse Bits.\\nMemory Usage: 13.8 MB, less than 49.77% of Python3 online submissions for Reverse Bits.\\n```\\nclass Solution:\\n    def reverseBits(self, n: int) -> int:\\n        res = 0\\n        for i in range(32):\\n            res = (res<<1) + (n&1)\\n            n>>=1\\n        return res\\n```\\nTime Complexity: O(N)\\nSpace Complexity: O(1)\\n\\n##### I hope that you\\'ve found this useful. If you like the solution and find it understandable, then do upvote it & Share it with others.\\n##### It only motivates me to write more such posts, If you found any error, any suggestions then do comment for any query\\n##### Thanks alot ! Cheers to your coding",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Python3",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        uint32_t res = 0;\\n        for (int i = 0; i<32; i++) {\\n            res <<= 1;\\n            res += n % 2;\\n            n >>= 1;\\n        }\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def reverseBits(self, n: int) -> int:\\n        res = 0\\n        for i in range(32):\\n            res = (res<<1) + (n&1)\\n            n>>=1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2076297,
                "title": "reverse-bits-in-3ms-using-basic-technique",
                "content": "class Solution {\\n    private:\\n     \\n    int digit(uint32_t n,int a){\\n        uint32_t num=n>>a;\\n        return num&1;\\n    }\\n    \\n    void push(uint32_t &n,int dig){\\n        n=n<<1;\\n        n=n | dig;\\n    }\\n       \\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        \\n        vector<int> v;\\n        for(int i=0;i<32;i++){\\n            v.push_back(digit(n,i));\\n        }\\n        \\n        uint32_t ans=00000000000000000000000000000000;\\n        for(int i=0;i<v.size();i++){\\n            push(ans,v[i]);\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "class Solution {\\n    private:\\n     \\n    int digit(uint32_t n,int a){\\n        uint32_t num=n>>a;\\n        return num&1;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1776019,
                "title": "1ms-approach-explained-with-comments",
                "content": "```\\npublic class Solution {\\n    // you need treat n as an unsigned value\\n    public int reverseBits(int n) {\\n        \\n        int res =0;   // initialize reverse res as zero (no bit is set)\\n        int j = 0;    // j pointing to MSB (most significant bit) of res\\n        \\n        // Traverse n which is of 32 bit from end and check if ith\\'s ith bit set or not\\n        for(int i = 31; i>=0 ;i--)\\n        {   \\n            // the mask is used to move 1 to left each time when i move to left\\n            int mask = 1<<i;\\n            \\n            // if n & mask results in non - zero number then it means bit is set at ith place hence set the bit in res at jth place also\\n            if((n & mask) != 0) // & operator is used to check if bit is 1 or 0 i.e set or unset\\n            {   \\n                // In order to set bit at jth place we need setmask which would have 1 (set bit) at jth position only\\n                int smask = 1<<j;\\n                res = res | smask;  // | (or) operator is used to set bit \\n                j++;  // don\\'t forget to move j pointer too, as it is helpful in setting res \\n            }\\n            // if n & mask results in  zero number then it means bit is unset at ith place hence no need to set the bit in res at jth place , just move j to next\\n            else\\n                j++;\\n            \\n        } return res;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "class Solution {\\n    // you need treat n as an unsigned value\\n    public int reverseBits(int n) {\\n        \\n        int res =0;   // initialize reverse res as zero (no bit is set)\\n        int j = 0;    // j pointing to MSB (most significant bit) of res\\n        \\n        // Traverse n which is of 32 bit from end and check if ith\\'s ith bit set or not\\n        for(int i = 31; i>=0 ;i--)\\n        {   \\n            // the mask is used to move 1 to left each time when i move to left\\n            int mask = 1<<i;\\n            \\n            // if n & mask results in non - zero number then it means bit is set at ith place hence set the bit in res at jth place also\\n            if((n & mask) != 0) // & operator is used to check if bit is 1 or 0 i.e set or unset\\n            {   \\n                // In order to set bit at jth place we need setmask which would have 1 (set bit) at jth position only\\n                int smask = 1<<j;\\n                res = res | smask;  // | (or) operator is used to set bit \\n                j++;  // don\\'t forget to move j pointer too, as it is helpful in setting res \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1750702,
                "title": "c-100-faster-easy-to-understand",
                "content": "class Solution {\\npublic:\\n\\n    uint32_t reverseBits(uint32_t n) {\\n        uint32_t y=0;\\n        for(int i=31; i>=0; i--) {\\n            int p=n & 1;\\n            if(p) {\\n            y+=(1<<i);\\n            }\\n            n=n>>1;\\n        }\\n     return y;\\n    }\\n};\\n\\n// if(find helpful) {\\ndo upvote(); // thanks\\n}",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "class Solution {\\npublic:\\n\\n    uint32_t reverseBits(uint32_t n) {\\n        uint32_t y=0;\\n        for(int i=31; i>=0; i--) {\\n            int p=n & 1;\\n            if(p) {\\n            y+=(1<<i);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1736337,
                "title": "typescript-javascript-bitwise-solution-why-the-correct-solution-won-t-work",
                "content": "I noticed almost no solutions actually successfully used bitwise operations at all. There are a several of pitfalls due to the fact that JavaScript has some surprising behavior. This covers  why the \"correct\" solution doesn\\'t actually work and several other common pitfalls.\\n\\nThe solution you would expect to work since it will work in languages with actual integer types.\\n```\\nfunction reverseBits(n: number): number {\\n  let ret: number = 0;\\n  let power: number = 31;\\n  while (n) {\\n    ret += (n & 1) << power;\\n    n = n >> 1;\\n    power -= 1;\\n  }\\n  return ret;\\n};\\n```\\nThere are at least two things wrong with this solution for JS. Before we get into it, realize that numbers in JS are actually double-precision 64-bit binary format IEEE 754 which means they are considered `doubles` in most other languages and are basically hacked together to make them feel like integers when we need them.\\n\\nFirstly, if the `n` is signed, using `>>` will cause the number to have some unexpected behavior. If you print `n` in the loop `console.debug(n, n.toString(2))` you\\'ll notice something strange happening. You\\'ll see the binary representation of the number change to `-1` over time and stay there which causes an infinite loop until **TLE**. This is the most common cause of **TLE** I see in the comments. To overcome this you have to use the Zero Fill Right Shift Operator `>>>`. This prevents the unsigned number from being interpreted as a signed integer and being ruined from a comparison standpoint. \\n\\nSecondly, at least in the V8 JavaScript engine, you can\\'t convert a signed integer into an unsigned integer via bitwise manipulation. What I mean literally is you can\\'t left shift 2^30 and expect to get 2^31. You have to inform the engine that you want whatever the number if to be considered a undesigned int.\\n\\n```\\nfunction reverseBits(n: number): number {\\n  let ret: number = 0;\\n  let power: number = 31;\\n  while (n) {\\n    ret += (n & 1) << power;\\n\\t// Zero Fill Right Shift Operator\\n    n = n >>> 1;\\n    power -= 1;\\n  }\\n  // Converts the number from a signed to an unsigned int\\n  return ret >>> 0;\\n};\\n```\\n\\nAll that being said, this is purely academic. It\\'s pretty slow because JS isn\\'t optimized for bitwise operations and very prone to pitfalls since it\\'s not really doing what it\\'s pretending to be doing since numbers are actually 64 bit doubles so don\\'t do this kind of garbage in production.",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "```\\nfunction reverseBits(n: number): number {\\n  let ret: number = 0;\\n  let power: number = 31;\\n  while (n) {\\n    ret += (n & 1) << power;\\n    n = n >> 1;\\n    power -= 1;\\n  }\\n  return ret;\\n};\\n```\n```\\nfunction reverseBits(n: number): number {\\n  let ret: number = 0;\\n  let power: number = 31;\\n  while (n) {\\n    ret += (n & 1) << power;\\n\\t// Zero Fill Right Shift Operator\\n    n = n >>> 1;\\n    power -= 1;\\n  }\\n  // Converts the number from a signed to an unsigned int\\n  return ret >>> 0;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1592120,
                "title": "weeb-does-python",
                "content": "\\n\\tclass Solution:\\n\\t\\tdef reverseBits(self, n: int) -> int:\\n\\t\\t\\tbinary = list(bin(n))[2:] # we don\\'t need 0b\\n\\t\\t\\tremainder = [\"0\"]\\n\\t\\t\\tzerosNeeded = 32 - len(binary)\\n\\t\\t\\tnewBinary = binary[::-1] + remainder * zerosNeeded # add the missing zeros\\n\\n\\t\\t\\treturn int(\"\".join(newBinary), 2)\\n\\t\\t\\t\\nIt ain\\'t bit manipulation, but it works\\nI\\'m just trynna take a different approach to solve the problem\\nAnyways, take a break fellow leetcoders, watch some anime instead\\nCheck out **\\u30AA\\u30FC\\u30D0\\u30FC\\u30ED\\u30FC\\u30C9 (Overlord)**\\n\\n\\n# Episodes: 39 (3 Seasons)\\n# Genres: Action, Adventure, Fantasy, Supernatural\\n# Theme: Game\\n\\nThere is also a series called **\\u30AA\\u30FC\\u30D0\\u30FC\\u30ED\\u30FC\\u30C9\\u3000\\u3077\\u308C\\u3077\\u308C\\u3077\\u308C\\u3042\\u3067\\u3059 (Overlord: Ple Ple Pleiades)** which is just some\\nparody shorts of the main series in the anime. These have no effect on the main storyline so you could choose to skip them.\\n\\nBy the way, season 4 of Overlord is confirmed!!! So if you happen to like this anime, there is more to come.",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "\\n\\tclass Solution:\\n\\t\\tdef reverseBits(self, n: int) -> int:\\n\\t\\t\\tbinary = list(bin(n))[2:] # we don\\'t need 0b\\n\\t\\t\\tremainder = [\"0\"]\\n\\t\\t\\tzerosNeeded = 32 - len(binary)\\n\\t\\t\\tnewBinary = binary[::-1] + remainder * zerosNeeded # add the missing zeros\\n\\n\\t\\t\\treturn int(\"\".join(newBinary), 2)\\n\\t\\t\\t\\nIt ain\\'t bit manipulation, but it works\\nI\\'m just trynna take a different approach to solve the problem\\nAnyways, take a break fellow leetcoders, watch some anime instead\\nCheck out **\\u30AA\\u30FC\\u30D0\\u30FC\\u30ED\\u30FC\\u30C9 (Overlord)**\\n\\n\\n# Episodes: 39 (3 Seasons)\\n# Genres: Action, Adventure, Fantasy, Supernatural\\n# Theme: Game\\n\\nThere is also a series called **\\u30AA\\u30FC\\u30D0\\u30FC\\u30ED\\u30FC\\u30C9\\u3000\\u3077\\u308C\\u3077\\u308C\\u3077\\u308C\\u3042\\u3067\\u3059 (Overlord: Ple Ple Pleiades)** which is just some\\nparody shorts of the main series in the anime. These have no effect on the main storyline so you could choose to skip them.\\n\\nBy the way, season 4 of Overlord is confirmed!!! So if you happen to like this anime, there is more to come.",
                "codeTag": "Java"
            },
            {
                "id": 1559893,
                "title": "simple-javascript-solution",
                "content": "Runtime: 84 ms, faster than 77.96% of JavaScript online submissions for Reverse Bits.\\nMemory Usage: 40.5 MB, less than 63.55% of JavaScript online submissions for Reverse Bits.\\n\\n\\n```\\nvar reverseBits = function(n) {\\n    let str = (n>>>0).toString(2).padStart(32, \\'0\\');\\n    let strReverse = str.split(\\'\\').reverse().join(\\'\\');\\n    let output = parseInt(strReverse, 2)\\n    return output;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Bit Manipulation"
                ],
                "code": "```\\nvar reverseBits = function(n) {\\n    let str = (n>>>0).toString(2).padStart(32, \\'0\\');\\n    let strReverse = str.split(\\'\\').reverse().join(\\'\\');\\n    let output = parseInt(strReverse, 2)\\n    return output;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1378710,
                "title": "approach-3-mask-and-shift-visual-explanation",
                "content": "Here is my code. I hope it will help you with a better understanding. If you realize a misspelling, please write a comment. Thanks.\\n\\n\\n        \\n\\t\\t#Mask -> using \"AND\" to separate n by 2 pieces\\n        #Shift -> using \">>\" or \"<<\"\\n        #Combine -> using \"OR\" or \"XOR\"\\n        \\n        # ..:: Step #0 ::..\\n        # n = abcdefgh\\n        # Note: \\'a\\', \\'b\\', \\'c\\', \\'d\\', \\'e\\', \\'f\\', \\'g\\', \\'h\\' are not hex representation.\\n        #       Those are just block names. Every letter represents a block with 4 bits.\\n\\t\\t\\n        n = (n >> 16) ^ (n << 16)\\n\\t\\t\\n        # ..:: Step #1 ::..\\n        # Mask -> not required because we have only two blocks\\n        #------------------\\n        # Shift -> (n >> 16) = 0000abcd\\n        #          (n << 16) = efgh0000\\n        #------------------\\n        # Combine -> 0000abcd\\n        #            efgh0000\\n        #         XOR--------\\n        #            efghabcd       \\n\\t\\t\\n        n = ( (n & 0xff00ff00) >> 8 ) ^ ( (n & 0x00ff00ff) << 8 )\\n\\t\\t\\n        # ..:: Step #2 ::..\\n        # Mask -> (n & 0xff00ff00) = ef00ab00\\n        #         (n & 0x00ff00ff) = 00gh00cd\\n        #------------------\\n        # Shift -> (n & 0xff00ff00) >> 8 = 00ef00ab\\n        #          (n & 0x00ff00ff) << 8 = gh00cd00\\n        #------------------\\n        # Combine -> 00ef00ab\\n        #            gh00cd00\\n        #         XOR--------\\n        #            ghefcdab    \\n\\t\\t\\n        n = ( (n & 0xf0f0f0f0) >> 4 ) ^ ( (n & 0x0f0f0f0f) << 4 )\\n\\t\\t\\n        # ..:: Step #3 ::..\\n        # Mask -> (n & 0xf0f0f0f0) = g0e0c0a0\\n        #         (n & 0x0f0f0f0f) = 0h0f0d0b\\n        #------------------\\n        # Shift -> (n & 0xf0f0f0f0) >> 4 = 0g0e0c0a\\n        #          (n & 0x0f0f0f0f) << 4 = h0f0d0b0\\n        #------------------\\n        # Combine -> 0g0e0c0a\\n        #            h0f0d0b0\\n        #         XOR--------\\n        #            hgfedcba    \\n\\t\\t\\n        n = ( (n & 0xcccccccc) >> 2 ) ^ ( (n & 0x33333333) << 2 )\\n\\t\\t\\n        # ..:: Step #4 ::..\\n        # Note: Before reading Step #4, please take a look at the note on Step #0.\\n        #       \\'a\\' = 1234\\n        #       \\'b\\' = 1234\\n        #       \\'c\\' = 1234\\n        #       \\'d\\' = 1234\\n        #       \\'e\\' = 1234\\n        #       \\'f\\' = 1234\\n        #       \\'g\\' = 1234\\n        #       \\'h\\' = 1234\\n        #       \\'.\\' = Seperate blocks for every 4 bits. This is added to improve readability of 32 bits.\\n        #       Please look above, every integer represents a block with 1 bits.\\n        #\\n        # Mask -> \\'c\\' represents \"1100\" in 4 bit.\\n        #         \\'3\\' represents \"0011\" in 4 bit.\\n        #         n = hgfedcba = 1234.1234.1234.1234.1234.1234.1234.1234\\n        #         (n & 0xcccccccc) = 1234.1234.1234.1234.1234.1234.1234.1234\\n        #                            1100.1100.1100.1100.1100.1100.1100.1100\\n        #                         AND---------------------------------------\\n        #                            1200.1200.1200.1200.1200.1200.1200.1200\\n        #     \\n        #         (n & 0x33333333) = 1234.1234.1234.1234.1234.1234.1234.1234\\n        #                            0011.0011.0011.0011.0011.0011.0011.0011\\n        #                         AND---------------------------------------\\n        #                            0034.0034.0034.0034.0034.0034.0034.0034\\n        #------------------\\n        # Shift -> (n & 0xcccccccc) >> 2 = 0012.0012.0012.0012.0012.0012.0012.0012\\n        #          (n & 0x33333333) << 2 = 3400.3400.3400.3400.3400.3400.3400.3400\\n        #------------------\\n        # Combine -> 0012.0012.0012.0012.0012.0012.0012.0012\\n        #            3400.3400.3400.3400.3400.3400.3400.3400\\n        #         XOR---------------------------------------\\n        #            3412.3412.3412.3412.3412.3412.3412.3412 \\n\\t\\t\\n        n = ( (n & 0xaaaaaaaa) >> 1 ) ^ ( (n & 0x55555555) << 1 )\\n\\t\\t\\n        # ..:: Step #5 ::..\\n        # Note: Before reading Step #5, please take a look at notes on Step #0 and Step#4.\\n        #\\n        # Mask -> \\'a\\' represents \"1010\" in 4 bit.\\n        #         \\'5\\' represents \"0101\" in 4 bit.\\n        #         n = 3412.3412.3412.3412.3412.3412.3412.3412\\n        #         (n & 0xaaaaaaaa) = 3412.3412.3412.3412.3412.3412.3412.3412\\n        #                            1010.1010.1010.1010.1010.1010.1010.1010\\n        #                         AND---------------------------------------\\n        #                            3010.3010.3010.3010.3010.3010.3010.3010\\n        #     \\n        #         (n & 0x55555555) = 3412.3412.3412.3412.3412.3412.3412.3412\\n        #                            0101.0101.0101.0101.0101.0101.0101.0101\\n        #                         AND---------------------------------------\\n        #                            0402.0402.0402.0402.0402.0402.0402.0402\\n        #------------------\\n        # Shift -> (n & 0xaaaaaaaa) >> 1 = 0301.0301.0301.0301.0301.0301.0301.0301\\n        #          (n & 0x55555555) << 1 = 4020.4020.4020.4020.4020.4020.4020.4020\\n        #------------------\\n        # Combine -> 0301.0301.0301.0301.0301.0301.0301.0301\\n        #            4020.4020.4020.4020.4020.4020.4020.4020\\n        #         XOR---------------------------------------\\n        #            4321.4321.4321.4321.4321.4321.4321.4321\\n\\t\\t\\n        return n\\n",
                "solutionTags": [],
                "code": "Here is my code. I hope it will help you with a better understanding. If you realize a misspelling, please write a comment. Thanks.\\n\\n\\n        \\n\\t\\t#Mask -> using \"AND\" to separate n by 2 pieces\\n        #Shift -> using \">>\" or \"<<\"\\n        #Combine -> using \"OR\" or \"XOR\"\\n        \\n        # ..:: Step #0 ::..\\n        # n = abcdefgh\\n        # Note: \\'a\\', \\'b\\', \\'c\\', \\'d\\', \\'e\\', \\'f\\', \\'g\\', \\'h\\' are not hex representation.\\n        #       Those are just block names. Every letter represents a block with 4 bits.\\n\\t\\t\\n        n = (n >> 16) ^ (n << 16)\\n\\t\\t\\n        # ..:: Step #1 ::..\\n        # Mask -> not required because we have only two blocks\\n        #------------------\\n        # Shift -> (n >> 16) = 0000abcd\\n        #          (n << 16) = efgh0000\\n        #------------------\\n        # Combine -> 0000abcd\\n        #            efgh0000\\n        #         XOR--------\\n        #            efghabcd       \\n\\t\\t\\n        n = ( (n & 0xff00ff00) >> 8 ) ^ ( (n & 0x00ff00ff) << 8 )\\n\\t\\t\\n        # ..:: Step #2 ::..\\n        # Mask -> (n & 0xff00ff00) = ef00ab00\\n        #         (n & 0x00ff00ff) = 00gh00cd\\n        #------------------\\n        # Shift -> (n & 0xff00ff00) >> 8 = 00ef00ab\\n        #          (n & 0x00ff00ff) << 8 = gh00cd00\\n        #------------------\\n        # Combine -> 00ef00ab\\n        #            gh00cd00\\n        #         XOR--------\\n        #            ghefcdab    \\n\\t\\t\\n        n = ( (n & 0xf0f0f0f0) >> 4 ) ^ ( (n & 0x0f0f0f0f) << 4 )\\n\\t\\t\\n        # ..:: Step #3 ::..\\n        # Mask -> (n & 0xf0f0f0f0) = g0e0c0a0\\n        #         (n & 0x0f0f0f0f) = 0h0f0d0b\\n        #------------------\\n        # Shift -> (n & 0xf0f0f0f0) >> 4 = 0g0e0c0a\\n        #          (n & 0x0f0f0f0f) << 4 = h0f0d0b0\\n        #------------------\\n        # Combine -> 0g0e0c0a\\n        #            h0f0d0b0\\n        #         XOR--------\\n        #            hgfedcba    \\n\\t\\t\\n        n = ( (n & 0xcccccccc) >> 2 ) ^ ( (n & 0x33333333) << 2 )\\n\\t\\t\\n        # ..:: Step #4 ::..\\n        # Note: Before reading Step #4, please take a look at the note on Step #0.\\n        #       \\'a\\' = 1234\\n        #       \\'b\\' = 1234\\n        #       \\'c\\' = 1234\\n        #       \\'d\\' = 1234\\n        #       \\'e\\' = 1234\\n        #       \\'f\\' = 1234\\n        #       \\'g\\' = 1234\\n        #       \\'h\\' = 1234\\n        #       \\'.\\' = Seperate blocks for every 4 bits. This is added to improve readability of 32 bits.\\n        #       Please look above, every integer represents a block with 1 bits.\\n        #\\n        # Mask -> \\'c\\' represents \"1100\" in 4 bit.\\n        #         \\'3\\' represents \"0011\" in 4 bit.\\n        #         n = hgfedcba = 1234.1234.1234.1234.1234.1234.1234.1234\\n        #         (n & 0xcccccccc) = 1234.1234.1234.1234.1234.1234.1234.1234\\n        #                            1100.1100.1100.1100.1100.1100.1100.1100\\n        #                         AND---------------------------------------\\n        #                            1200.1200.1200.1200.1200.1200.1200.1200\\n        #     \\n        #         (n & 0x33333333) = 1234.1234.1234.1234.1234.1234.1234.1234\\n        #                            0011.0011.0011.0011.0011.0011.0011.0011\\n        #                         AND---------------------------------------\\n        #                            0034.0034.0034.0034.0034.0034.0034.0034\\n        #------------------\\n        # Shift -> (n & 0xcccccccc) >> 2 = 0012.0012.0012.0012.0012.0012.0012.0012\\n        #          (n & 0x33333333) << 2 = 3400.3400.3400.3400.3400.3400.3400.3400\\n        #------------------\\n        # Combine -> 0012.0012.0012.0012.0012.0012.0012.0012\\n        #            3400.3400.3400.3400.3400.3400.3400.3400\\n        #         XOR---------------------------------------\\n        #            3412.3412.3412.3412.3412.3412.3412.3412 \\n\\t\\t\\n        n = ( (n & 0xaaaaaaaa) >> 1 ) ^ ( (n & 0x55555555) << 1 )\\n\\t\\t\\n        # ..:: Step #5 ::..\\n        # Note: Before reading Step #5, please take a look at notes on Step #0 and Step#4.\\n        #\\n        # Mask -> \\'a\\' represents \"1010\" in 4 bit.\\n        #         \\'5\\' represents \"0101\" in 4 bit.\\n        #         n = 3412.3412.3412.3412.3412.3412.3412.3412\\n        #         (n & 0xaaaaaaaa) = 3412.3412.3412.3412.3412.3412.3412.3412\\n        #                            1010.1010.1010.1010.1010.1010.1010.1010\\n        #                         AND---------------------------------------\\n        #                            3010.3010.3010.3010.3010.3010.3010.3010\\n        #     \\n        #         (n & 0x55555555) = 3412.3412.3412.3412.3412.3412.3412.3412\\n        #                            0101.0101.0101.0101.0101.0101.0101.0101\\n        #                         AND---------------------------------------\\n        #                            0402.0402.0402.0402.0402.0402.0402.0402\\n        #------------------\\n        # Shift -> (n & 0xaaaaaaaa) >> 1 = 0301.0301.0301.0301.0301.0301.0301.0301\\n        #          (n & 0x55555555) << 1 = 4020.4020.4020.4020.4020.4020.4020.4020\\n        #------------------\\n        # Combine -> 0301.0301.0301.0301.0301.0301.0301.0301\\n        #            4020.4020.4020.4020.4020.4020.4020.4020\\n        #         XOR---------------------------------------\\n        #            4321.4321.4321.4321.4321.4321.4321.4321\\n\\t\\t\\n        return n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 755158,
                "title": "simple-solution-in-js",
                "content": "If we take an input as 00110\\nResult will be a list of {0,1,1,0,0}, then we join and convert it into decimal number which is the same as output: 01100\\n![image](https://assets.leetcode.com/users/images/7e5b6285-52f3-4d67-a815-1b3f2a3002ca_1595702441.2824879.png)\\n\\nvar reverseBits = function(n) {\\n    var len = 32;\\n    var arr = new Array()\\n    while(len > 0){\\n        var t = n & 1;\\n        n = n >> 1;\\n        arr.push(t);\\n        len--;\\n    }\\n    var res = arr.join(\\'\\');\\n    return parseInt(res, 2);\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "If we take an input as 00110\\nResult will be a list of {0,1,1,0,0}, then we join and convert it into decimal number which is the same as output: 01100\\n![image](https://assets.leetcode.com/users/images/7e5b6285-52f3-4d67-a815-1b3f2a3002ca_1595702441.2824879.png)\\n\\nvar reverseBits = function(n) {\\n    var len = 32;\\n    var arr = new Array()\\n    while(len > 0){\\n        var t = n & 1;\\n        n = n >> 1;\\n        arr.push(t);\\n        len--;\\n    }\\n    var res = arr.join(\\'\\');\\n    return parseInt(res, 2);\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 733084,
                "title": "java-clean-code-easy-to-understand-1-ms-time-99-faster",
                "content": "```\\nclass Solution {\\n\\t\\n\\tpublic int reverseBits (int n) {\\n\\t\\t\\n\\t\\tint ans = 0;\\n \\n\\t\\tfor (int i = 0; i < 32; i++) {\\n\\t\\t\\tans += (n & 1);\\n\\t\\t\\tif (i == 31) {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\tans <<= 1;\\n\\t\\t\\tn >>= 1;\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn ans;\\n\\t}\\n}\\n```\\n\\nPlease help to **UPVOTE** if this post is useful for you.\\nIf you have any questions, feel free to comment below.\\n**HAPPY CODING :)\\nLOVE CODING :)**\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\t\\n\\tpublic int reverseBits (int n) {\\n\\t\\t\\n\\t\\tint ans = 0;\\n \\n\\t\\tfor (int i = 0; i < 32; i++) {\\n\\t\\t\\tans += (n & 1);\\n\\t\\t\\tif (i == 31) {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\tans <<= 1;\\n\\t\\t\\tn >>= 1;\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn ans;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 678194,
                "title": "java-solution-with-full-explanation",
                "content": "Java solution with full explanation\\n```\\npublic class Solution {\\n    // you need treat n as an unsigned value\\n    public int reverseBits(int n) {\\n        \\n        boolean isNegative = n < 0;\\n        \\n        int reverseNumber = 0;\\n        \\n        // counter to track the number of bits in the number\\n        int count = 31;\\n        \\n        while(count != 0){\\n            //getting the last bit from the number\\n\\t\\t\\t// Suppose number is 5, i.e. 0000 0101, then we perform AND operation with 0000 0001,\\n\\t\\t\\t// so we get 0000 0001 i.e. the last bit of the number 5\\n            int lastBit = n & 1;\\n            \\n            // add it to the reverseNumber variable using OR operation, initially reverse number is 0\\n\\t\\t\\t// 0000 0000 | 0000 0001 = 0000 0001(Based on the example of number 5)\\n            reverseNumber = reverseNumber | lastBit;\\n            \\n            // shift one position to the left\\n\\t\\t\\t// After left shift, current reverse number will become : 0000 0010\\n            reverseNumber = reverseNumber << 1;\\n            \\n            // now right shift the number one position\\n\\t\\t\\t// After right shift of 5, current input number : 0000 0010\\n            n = n >> 1;\\n            \\n            count--;\\n        }// Now we repeat the process\\n        \\n        \\n        return isNegative?reverseNumber+1:reverseNumber;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    // you need treat n as an unsigned value\\n    public int reverseBits(int n) {\\n        \\n        boolean isNegative = n < 0;\\n        \\n        int reverseNumber = 0;\\n        \\n        // counter to track the number of bits in the number\\n        int count = 31;\\n        \\n        while(count != 0){\\n            //getting the last bit from the number\\n\\t\\t\\t// Suppose number is 5, i.e. 0000 0101, then we perform AND operation with 0000 0001,\\n\\t\\t\\t// so we get 0000 0001 i.e. the last bit of the number 5\\n            int lastBit = n & 1;\\n            \\n            // add it to the reverseNumber variable using OR operation, initially reverse number is 0\\n\\t\\t\\t// 0000 0000 | 0000 0001 = 0000 0001(Based on the example of number 5)\\n            reverseNumber = reverseNumber | lastBit;\\n            \\n            // shift one position to the left\\n\\t\\t\\t// After left shift, current reverse number will become : 0000 0010\\n            reverseNumber = reverseNumber << 1;\\n            \\n            // now right shift the number one position\\n\\t\\t\\t// After right shift of 5, current input number : 0000 0010\\n            n = n >> 1;\\n            \\n            count--;\\n        }// Now we repeat the process\\n        \\n        \\n        return isNegative?reverseNumber+1:reverseNumber;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 661484,
                "title": "c-3-lines-with-bitset",
                "content": "```\\nclass Solution {\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        string str(bitset<32>(n).to_string());\\n        reverse(str.begin(), str.end());\\n        return bitset<32>(str).to_ulong();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        string str(bitset<32>(n).to_string());\\n        reverse(str.begin(), str.end());\\n        return bitset<32>(str).to_ulong();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 492436,
                "title": "python-one-liner",
                "content": "```\\nclass Solution:\\n    def reverseBits(self, n: int) -> int:\\n        return int((format(n,\\'#034b\\')[2:])[::-1], 2)\\n```\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def reverseBits(self, n: int) -> int:\\n        return int((format(n,\\'#034b\\')[2:])[::-1], 2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 54827,
                "title": "javascript-solution",
                "content": "    /**\\n     * @param {number} n - a positive integer\\n     * @return {number} - a positive integer\\n     */\\n    var reverseBits = function(n) {\\n        var res = 0;\\n        var i = 31;\\n        while(i > 0){\\n            res = res << 1;\\n            if(n & 1){\\n                res = res | 1;\\n            }\\n            n = n >> 1;\\n            i -= 1;\\n        }\\n        if(n & 1){\\n            return  res * 2 + 1;\\n        } else {\\n            return res * 2;\\n        }\\n    };",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "    /**\\n     * @param {number} n - a positive integer\\n     * @return {number} - a positive integer\\n     */\\n    var reverseBits = function(n) {\\n        var res = 0;\\n        var i = 31;\\n        while(i > 0){\\n            res = res << 1;\\n            if(n & 1){\\n                res = res | 1;\\n            }\\n            n = n >> 1;\\n            i -= 1;\\n        }\\n        if(n & 1){\\n            return  res * 2 + 1;\\n        } else {\\n            return res * 2;\\n        }\\n    };",
                "codeTag": "Unknown"
            },
            {
                "id": 54904,
                "title": "my-simple-javascript-solution",
                "content": "    var reverseBits = function(n) {\\n    \\n    var str=n.toString(2).split(\"\").reverse().join(\"\");\\n    while(str.length<32){\\n        str=str+'0';\\n    }\\n    console.log(str);\\n    return parseInt(str, 2);\\n    \\n};",
                "solutionTags": [],
                "code": "    var reverseBits = function(n) {\\n    \\n    var str=n.toString(2).split(\"\").reverse().join(\"\");\\n    while(str.length<32){\\n        str=str+'0';\\n    }\\n    console.log(str);\\n    return parseInt(str, 2);\\n    \\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 54930,
                "title": "share-my-solution-how-to-optimize-it-when-this-function-is-called-many-times",
                "content": "\\n    private int[] reverseHex = new int[] {0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15};\\n\\n    // you need treat n as an unsigned value\\n    public int reverseBits(int n) {\\n        int rev = 0;\\n        while (n != 0) {\\n            rev = (rev << 4) + reverseHex[n & 0xF];\\n            n >>>= 4;\\n        }\\n        return rev;\\n    }\\n\\n1. Create an array that contains the reverse number of 0-15.\\n2. Divide the number into 8 parts, each part has 4 bits which can represent number 0-15. Get the reverse number of each part using the array.",
                "solutionTags": [],
                "code": "\\n    private int[] reverseHex = new int[] {0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15};\\n\\n    // you need treat n as an unsigned value\\n    public int reverseBits(int n) {\\n        int rev = 0;\\n        while (n != 0) {\\n            rev = (rev << 4) + reverseHex[n & 0xF];\\n            n >>>= 4;\\n        }\\n        return rev;\\n    }\\n\\n1. Create an array that contains the reverse number of 0-15.\\n2. Divide the number into 8 parts, each part has 4 bits which can represent number 0-15. Get the reverse number of each part using the array.",
                "codeTag": "Unknown"
            },
            {
                "id": 54975,
                "title": "python-easy-to-understand-solutions",
                "content": "```\\nclass Solution:\\n    def reverseBits1(self, n):\\n        res = 0\\n        for _ in range(32):\\n            res = res*2 + (n & 1)\\n            n >>= 1\\n        return res\\n\\n    def reverseBits(self, n):\\n        res, i = 0, 31\\n        while n:\\n            res += (n & 1) << i\\n            n >>= 1\\n            i -= 1\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def reverseBits1(self, n):\\n        res = 0\\n        for _ in range(32):\\n            res = res*2 + (n & 1)\\n            n >>= 1\\n        return res\\n\\n    def reverseBits(self, n):\\n        res, i = 0, 31\\n        while n:\\n            res += (n & 1) << i\\n            n >>= 1\\n            i -= 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3686805,
                "title": "simplest-way",
                "content": "```\\nclass Solution {\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        uint32_t res = 0;\\n        // precomputed the 2^31 (1000...31times in bit form) value as we have to find reverse\\n        // otherwise it would have 2^0 (1 in bit form)\\n        uint32_t x = 1 << 31;\\n\\n        while (n) {\\n            // checks if the bit is set or not using (n&1)\\n            // if bit is set then add x to the res\\n            // here x = 2^(31-i)\\n            // where i will be the ith bit from right\\n            if (n&1) res += x;\\n\\n            // update the n i.e n = n/2\\n            n >>= 1;\\n            // update the x i.e x = x/2\\n            // since, we have to find reverse so instead of multiplying by 2 we have to divide by 2\\n            x >>= 1;\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        uint32_t res = 0;\\n        // precomputed the 2^31 (1000...31times in bit form) value as we have to find reverse\\n        // otherwise it would have 2^0 (1 in bit form)\\n        uint32_t x = 1 << 31;\\n\\n        while (n) {\\n            // checks if the bit is set or not using (n&1)\\n            // if bit is set then add x to the res\\n            // here x = 2^(31-i)\\n            // where i will be the ith bit from right\\n            if (n&1) res += x;\\n\\n            // update the n i.e n = n/2\\n            n >>= 1;\\n            // update the x i.e x = x/2\\n            // since, we have to find reverse so instead of multiplying by 2 we have to divide by 2\\n            x >>= 1;\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3612196,
                "title": "c-beats-100-most-easy-and-best-solution-ever",
                "content": "# Complexity\\n- Time complexity:$$O(1)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        uint32_t ans;\\n        for(int i = 0; i < 32; i++) {\\n            ans = ans << 1;\\n            bool bit = n & 1;\\n            ans = ans | bit;\\n            n = n >> 1;\\n            // cout << bit << \" \";\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        uint32_t ans;\\n        for(int i = 0; i < 32; i++) {\\n            ans = ans << 1;\\n            bool bit = n & 1;\\n            ans = ans | bit;\\n            n = n >> 1;\\n            // cout << bit << \" \";\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3394452,
                "title": "explained-beginner-friendly-one-liner-python3-fast-solution",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nInt -> Bin -> reverse -> Int\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n- Detailed \\n```\\nclass Solution:\\n    def reverseBits(self, n: int) -> int:\\n        bin_convert = bin(n) \\n        bin_convert_2 = bin_convert[2:]\\n        bin_fill_zero = bin_convert_2.zfill(32)\\n        reverse_bin = bin_fill_zero[::-1]\\n        answer = int(reverse_bin, 2)\\n        return answer\\n```\\n- One-Liner\\n```\\nclass Solution:\\n    def reverseBits(self, n: int) -> int:\\n        return (int((bin(n)[2:].zfill(32))[::-1], 2))\\n```",
                "solutionTags": [
                    "Python3",
                    "String",
                    "Divide and Conquer",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def reverseBits(self, n: int) -> int:\\n        bin_convert = bin(n) \\n        bin_convert_2 = bin_convert[2:]\\n        bin_fill_zero = bin_convert_2.zfill(32)\\n        reverse_bin = bin_fill_zero[::-1]\\n        answer = int(reverse_bin, 2)\\n        return answer\\n```\n```\\nclass Solution:\\n    def reverseBits(self, n: int) -> int:\\n        return (int((bin(n)[2:].zfill(32))[::-1], 2))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3005456,
                "title": "easyc-4",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        uint32_t x = 0;\\n        int d = 0;\\n        while(n>0){\\n            x+=(n%2) << (31-d);\\n            n >>= 1;\\n            d++;\\n        }\\n        return x;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        uint32_t x = 0;\\n        int d = 0;\\n        while(n>0){\\n            x+=(n%2) << (31-d);\\n            n >>= 1;\\n            d++;\\n        }\\n        return x;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3005360,
                "title": "rb2c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        uint32_t x = 0;\\n        int d = 0;\\n        while(n>0){\\n            x+=(n%2) << (31-d);\\n            n >>= 1;\\n            d++;\\n        }\\n        return x;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        uint32_t x = 0;\\n        int d = 0;\\n        while(n>0){\\n            x+=(n%2) << (31-d);\\n            n >>= 1;\\n            d++;\\n        }\\n        return x;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2942145,
                "title": "easiest-question-reversebits",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        uint32_t x = 0;\\n        int d = 0;\\n        while(n>0){\\n            x+=(n%2) << (31-d);\\n            n >>= 1;\\n            d++;\\n        }\\n        return x;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        uint32_t x = 0;\\n        int d = 0;\\n        while(n>0){\\n            x+=(n%2) << (31-d);\\n            n >>= 1;\\n            d++;\\n        }\\n        return x;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2789487,
                "title": "c-0ms-easy-to-understand",
                "content": "# Upvote if its helps\\n```\\nclass Solution {\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        uint32_t ans=0,count=32;\\n        //ans<<=1;\\n        //n>>=1;\\n        while(count){\\n            ans+=n&1;\\n            count--;\\n            n>>=1;\\n            if(count) ans<<=1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        uint32_t ans=0,count=32;\\n        //ans<<=1;\\n        //n>>=1;\\n        while(count){\\n            ans+=n&1;\\n            count--;\\n            n>>=1;\\n            if(count) ans<<=1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2770969,
                "title": "java-easy-solution",
                "content": "```\\npublic class Solution \\n{\\n    public int reverseBits(int n) \\n    {\\n        int i , reverse = 0 ;\\n        for( i = 0 ; i < 32 ; i++ )\\n        {\\n            reverse = reverse << 1 ;\\n            if( ( n & 1 ) == 1 )\\n            {\\n                reverse = reverse | 1 ;\\n            }\\n            n = n >> 1 ;\\n        }\\n        return reverse ;       \\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\npublic class Solution \\n{\\n    public int reverseBits(int n) \\n    {\\n        int i , reverse = 0 ;\\n        for( i = 0 ; i < 32 ; i++ )\\n        {\\n            reverse = reverse << 1 ;\\n            if( ( n & 1 ) == 1 )\\n            {\\n                reverse = reverse | 1 ;\\n            }\\n            n = n >> 1 ;\\n        }\\n        return reverse ;       \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2461453,
                "title": "javascript-bit-manipulation-watch-out-for-negative-numbers",
                "content": "```\\nfunction reverseBits(n) {\\n    let ans = 0;\\n    \\n    for (let i = 0; i < 32; i++) {\\n        ans = ans * 2 + n % 2;\\n        n >>>= 1;\\n    }\\n    \\n    return ans;\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Bit Manipulation"
                ],
                "code": "```\\nfunction reverseBits(n) {\\n    let ans = 0;\\n    \\n    for (let i = 0; i < 32; i++) {\\n        ans = ans * 2 + n % 2;\\n        n >>>= 1;\\n    }\\n    \\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2456553,
                "title": "javascript-simple-functional-approach",
                "content": "```\\nfunction reverseBits(bits) {\\n    return parseInt(bits.toString(2).split(\"\").reverse().join(\"\").padEnd(32, \"0\"), 2);\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfunction reverseBits(bits) {\\n    return parseInt(bits.toString(2).split(\"\").reverse().join(\"\").padEnd(32, \"0\"), 2);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2391999,
                "title": "javascript",
                "content": "```\\nvar reverseBits = function (n) {\\n  let res = 0;\\n  for (let i = 0; i < 32; i++) {\\n    res = (res << 1) | (n & 1);\\n    n >>= 1;\\n  }\\n  return res >>> 0;\\n};",
                "solutionTags": [],
                "code": "```\\nvar reverseBits = function (n) {\\n  let res = 0;\\n  for (let i = 0; i < 32; i++) {\\n    res = (res << 1) | (n & 1);\\n    n >>= 1;\\n  }\\n  return res >>> 0;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 2370464,
                "title": "faster-than-90-solutions-in-3-lines",
                "content": "```\\n/**\\n * @param {number} n - a positive integer\\n * @return {number} - a positive integer\\n */\\n\\n// remember the binary must always be of length 32 ;);\\nvar reverseBits = function(n) {\\n    const reversedBin = n.toString(2).split(\\'\\').reverse().join(\\'\\');\\n    const result =  reversedBin.padEnd(32,\\'0\\'); \\n    return parseInt(result, 2);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n - a positive integer\\n * @return {number} - a positive integer\\n */\\n\\n// remember the binary must always be of length 32 ;);\\nvar reverseBits = function(n) {\\n    const reversedBin = n.toString(2).split(\\'\\').reverse().join(\\'\\');\\n    const result =  reversedBin.padEnd(32,\\'0\\'); \\n    return parseInt(result, 2);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2192172,
                "title": "c-code-100-optimal-beginner-s-friendly",
                "content": "**Please Upvote the solution if it helped you because a single upvote motivate the creator\\'s like us to create more content...........**\\n\\nCode ->\\n```\\nclass Solution {\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        int res=0;\\n        for(int i=0 ;i<32;i++){\\n            int t=n&1;\\n            int ans=t<<(31-i);\\n            res=res|ans;\\n            n=n>>1;\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nHappy Coding :-)\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        int res=0;\\n        for(int i=0 ;i<32;i++){\\n            int t=n&1;\\n            int ans=t<<(31-i);\\n            res=res|ans;\\n            n=n>>1;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2118386,
                "title": "java-bitwise-simple-short-solution",
                "content": "This is quite simple to understand java solution. \\n\\nThe main idea is loop on each digit of the number (32 digits in total):\\n- take the least significant digit from the number and place it on the least significant digit of the new number\\n- shift the digits of the new number to the left to make them older\\n\\n```\\npublic class Solution {\\n    public int reverseBits(int n) {\\n        int reversed = 0, digit = -1;\\n\\n        while (++digit < 32) {\\n            reversed <<= 1;\\n            reversed |= n & 0b1;\\n            n >>= 1;\\n        }\\n\\n        return reversed;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\npublic class Solution {\\n    public int reverseBits(int n) {\\n        int reversed = 0, digit = -1;\\n\\n        while (++digit < 32) {\\n            reversed <<= 1;\\n            reversed |= n & 0b1;\\n            n >>= 1;\\n        }\\n\\n        return reversed;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2075869,
                "title": "mask-shift-c-solution",
                "content": "```\\nuint32_t reverseBits(uint32_t n) {\\n    uint32_t result = 0;\\n    for (int i = 0; i < 32; i++) {\\n        result = (result << 1) + (n & 1);\\n        n >>= 1;\\n    }\\n    return result;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nuint32_t reverseBits(uint32_t n) {\\n    uint32_t result = 0;\\n    for (int i = 0; i < 32; i++) {\\n        result = (result << 1) + (n & 1);\\n        n >>= 1;\\n    }\\n    return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2074789,
                "title": "reverse-bits-o-n-time-complexity-o-1-space-complexity-100-percent-faster-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        int i=0;\\n        uint32_t number=0;\\n        while(i<32){\\n            number = (number<<1)+(n&1);// Multiplication using left shift\\n            n=n>>1;// Division using right shift\\n            i++;\\n        }\\n        return number;\\n    }\\n};\\n```\\n**if(Helpful) {\\n\\tplease upvote;\\n}**\\n",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        int i=0;\\n        uint32_t number=0;\\n        while(i<32){\\n            number = (number<<1)+(n&1);// Multiplication using left shift\\n            n=n>>1;// Division using right shift\\n            i++;\\n        }\\n        return number;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2001398,
                "title": "bit-algorithm-explained",
                "content": "\\n\\n\\n\\n* As size is fixed of 32 bits \\n* Create a for loop for looping upto 32 times \\n* and store the last digit of n using n&1\\n* than add into res than left shift to i \\n* than store the res into ans by ans | res\\n* return ans \\n\\n\\n\\n```\\npublic class Solution {\\n    // you need treat n as an unsigned value\\n    public int reverseBits(int n) {\\n        int ans = 0;\\n        for(int i = 31;i>=0;i--)\\n        {\\n            int res = n&1;\\n            res = res<<i;\\n            ans = ans|res;\\n            n = n>>1;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\npublic class Solution {\\n    // you need treat n as an unsigned value\\n    public int reverseBits(int n) {\\n        int ans = 0;\\n        for(int i = 31;i>=0;i--)\\n        {\\n            int res = n&1;\\n            res = res<<i;\\n            ans = ans|res;\\n            n = n>>1;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1839116,
                "title": "c-100-faster-o-1-space-3-lines-code-bit-manipulation",
                "content": "\\'\\'\\'\\nclass Solution {\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        \\n        int sum = 0, ln=32;\\n        while(ln--){\\n            sum = 2LL*sum + n%2;\\n            n >>= 1;\\n        }\\n        \\n        return sum;\\n    }\\n};\\n\\'\\'\\'",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "class Solution {\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        \\n        int sum = 0, ln=32;\\n        while(ln--){\\n            sum = 2LL*sum + n%2;\\n            n >>= 1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1615371,
                "title": "c-explanation-for-absolute-beginners",
                "content": "**Solution Explanation**\\n\\nEach time we divide the number by 2, we actually get the right most bit from its binary representation\\nFor example;\\n110**1** = 13\\n1 is the right most bit\\n\\n13 % 2 = **1**\\n13 / 2 = 6\\n6 % 2 = **0**\\n6 / 2 = 3\\n3 % 2 = **1**\\n1 / 2 = 0\\n1 % 2 = **1**\\n\\nIn this way, we can get the bits in the binary representation starting form right to left. By using this division method, we can also get the real value(result integer value) of reversed number by multiplicating the digits by their correct 2 to the powers.\\n\\nOriginal Number\\n```\\n0       0       0       .....      1       1       0       1\\n2^31   2^30    2^29               2^3     2^2     2^1     2^0\\n```\\n\\nReversed Number\\n```\\n1       0       1      1      .....                0       0       0\\n2^31   2^30    2^29    2^28                       2^2     2^1     2^0\\n```\\n\\nAs you can see, once we get the right most bit, we can multiply it with 2^nth and add up onto result value, so that we will have the output.\\n\\n**C++ O(32) Time & O(1) Memory Solution**\\n```\\nclass Solution {\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        uint32_t result = 0;\\n        for (int k = 32, power = 31; k > 0; k--, power--) {\\n            int rem = n % 2;\\n            if (rem > 0) {\\n                result += pow(2, power);\\n            }\\n            n >>= 1;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n0       0       0       .....      1       1       0       1\\n2^31   2^30    2^29               2^3     2^2     2^1     2^0\\n```\n```\\n1       0       1      1      .....                0       0       0\\n2^31   2^30    2^29    2^28                       2^2     2^1     2^0\\n```\n```\\nclass Solution {\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        uint32_t result = 0;\\n        for (int k = 32, power = 31; k > 0; k--, power--) {\\n            int rem = n % 2;\\n            if (rem > 0) {\\n                result += pow(2, power);\\n            }\\n            n >>= 1;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1480288,
                "title": "c-simple-beginner-easy-to-understand",
                "content": "Idea : idea is simple we make res by finding current rightmost of n and then rightshift n!!!\\n```\\nclass Solution {\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        int res = 0;\\n        for(int i = 0 ; i < 32 ; ++i)\\n        {\\n            res = (res << 1) + (n & 1); // inserting 0 or 1 in res on the basis of last bit of n\\n            n = n >> 1; // righshifting n\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        int res = 0;\\n        for(int i = 0 ; i < 32 ; ++i)\\n        {\\n            res = (res << 1) + (n & 1); // inserting 0 or 1 in res on the basis of last bit of n\\n            n = n >> 1; // righshifting n\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1428971,
                "title": "easy-clean-c-solution",
                "content": "right shift n after every iteration, left shift the result after every iteration. iterate for 32 times.\\nwhat this basically translates to is that we keep getting the rightmost bit of the number ,store it in the result and then left shift the result whlie simultaneously removing the rightmost bit of n in every iteration.\\n```\\n uint32_t reverseBits(uint32_t n) {\\n        uint32_t result=0;\\n        for(int i=0;i<32;++i){\\n            result=result<<1;\\n            result|=(n&1);\\n            n=n>>1;\\n        }\\n        return result;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n uint32_t reverseBits(uint32_t n) {\\n        uint32_t result=0;\\n        for(int i=0;i<32;++i){\\n            result=result<<1;\\n            result|=(n&1);\\n            n=n>>1;\\n        }\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1352859,
                "title": "c-o-1-time-o-1-space-clean-concise-solution-with-detailed-explaination",
                "content": "* **Solution**\\nA 32 bits unsigned integer will have 32 bits with index from 0 to 31 from right to left. So to inverse 32 bits unsigned integer we will go through all the bits of n from 0 to 31 and add the the bit to our result. In order to do that we must know some knowledge about binary number :\\nn << 1 = n shift left 1 = move all the bits of n value to the left by 1 unit\\nexample: 0001 << 1 = 0010\\nn >> 1 = n shift right 1 = move all the bits of n value to right by 1 unit\\nexample: 1000 >> 1 = 0100\\nTherefore to solve this problem we get the rightmost bit ( by doing n mod 2 because we\\'re calculating in base 2 ) then add it to **result << 1**. To make sure the next bit is the rightmost bit we do **n>>1**, keep doing until we go through all 32 bits of n.\\n\\n\\n* **Time Complexity**\\nWe use a constant loop so the time complexity is O(32) which means **O(1)**.\\n\\n* **Space Complexity**\\nBecause we use constant number of variables so the space complexity is **O(1)**.\\n\\n* **Source Code**\\n```\\nclass Solution {\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        uint32_t res = 0;\\n        for (int i=0;i<32;++i) {\\n            res = (res<<1) + (n % 2);\\n            n = (n>>1);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        uint32_t res = 0;\\n        for (int i=0;i<32;++i) {\\n            res = (res<<1) + (n % 2);\\n            n = (n>>1);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1265259,
                "title": "100-c",
                "content": "This is a little non-intuitive at first, but here is the explaination:\\n* \\tMake a uint_32t variable res initalised to zero and power initialised to 31.\\n* \\tNow, while(n), pick the rightmost bit of n (n&1) and leftshift it by 31 places and store in res.\\n* \\tRightshift n (n>>1) and decrement power.\\n```\\nclass Solution {\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        uint32_t res=0,power=31;\\n        while(n){\\n            res+=(n&1)<<power;\\n            n=n>>1;\\n            power-=1;\\n        }\\n        return res;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        uint32_t res=0,power=31;\\n        while(n){\\n            res+=(n&1)<<power;\\n            n=n>>1;\\n            power-=1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1237141,
                "title": "2-liner-python",
                "content": "Approach:\\n* keep extracting bits from 1st to 32nd by periodically masking the input (shifting the mask bit right by one)\\n* if the extracted bit is 1 then add the corresponding power of 2 to the answer\\n\\n```\\n    def reverseBits(self, n: int) -> int:\\n        mask = 2**31\\n        return sum(2**i for i in range(32) if n&(mask>>i))\\n```\\n\\nLonger and more readable form:\\n```\\n    def reverseBits_1(self, n:int) -> int:\\n        mask = 2**31\\n        ans = 0\\n        for i in range(32):\\n            if n & mask : ans += 2**i\\n            mask >>= 1\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Bitmask"
                ],
                "code": "```\\n    def reverseBits(self, n: int) -> int:\\n        mask = 2**31\\n        return sum(2**i for i in range(32) if n&(mask>>i))\\n```\n```\\n    def reverseBits_1(self, n:int) -> int:\\n        mask = 2**31\\n        ans = 0\\n        for i in range(32):\\n            if n & mask : ans += 2**i\\n            mask >>= 1\\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1169541,
                "title": "simple-java-1ms-solution",
                "content": "\\tpublic int reverseBits(int n) { \\n\\n        int res = 0;\\n\\t\\t\\n        for(int i=0;i<32;i++){\\n\\t\\t\\n\\t\\t\\t//calculate least significant bit\\n            int lsb = n & 1;\\n\\t\\t\\t\\n\\t\\t\\t// left shift lsb bit by (31-i) times\\n            lsb = lsb << (31-i);\\n\\t\\t\\t\\n\\t\\t\\t// update result by performing OR between result and least significant bit\\n            res = res | lsb;\\n\\t\\t\\t\\n\\t\\t\\t// lsb is added to the result, so right shift the number by one\\n            n = n >> 1;\\n        }\\n        return res;\\n    }",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "\\tpublic int reverseBits(int n) { \\n\\n        int res = 0;\\n\\t\\t\\n        for(int i=0;i<32;i++){\\n\\t\\t\\n\\t\\t\\t//calculate least significant bit\\n            int lsb = n & 1;\\n\\t\\t\\t\\n\\t\\t\\t// left shift lsb bit by (31-i) times\\n            lsb = lsb << (31-i);\\n\\t\\t\\t\\n\\t\\t\\t// update result by performing OR between result and least significant bit\\n            res = res | lsb;\\n\\t\\t\\t\\n\\t\\t\\t// lsb is added to the result, so right shift the number by one\\n            n = n >> 1;\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1017982,
                "title": "scala",
                "content": "```\\ndef reverseBits(x: Int): Int = {\\nimport scala.annotation.tailrec\\n    @tailrec\\n    def reverse(in: Int, n: Int = 32, out: Int = 0): Int =\\n      if (n == 0) out\\n      else reverse(in >>> 1, n - 1, (out << 1) | (in & 1)) //magic\\n\\n    reverse(x)\\n  }\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\ndef reverseBits(x: Int): Int = {\\nimport scala.annotation.tailrec\\n    @tailrec\\n    def reverse(in: Int, n: Int = 32, out: Int = 0): Int =\\n      if (n == 0) out\\n      else reverse(in >>> 1, n - 1, (out << 1) | (in & 1)) //magic\\n\\n    reverse(x)\\n  }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 733451,
                "title": "javascript-clean-one-liner",
                "content": "```javascript\\nvar reverseBits = function(n) {\\n    const bits = n.toString(2).padStart(32, \\'0\\').split(\\'\\').reverse().join(\\'\\');\\n    return parseInt(bits, 2);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar reverseBits = function(n) {\\n    const bits = n.toString(2).padStart(32, \\'0\\').split(\\'\\').reverse().join(\\'\\');\\n    return parseInt(bits, 2);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 732071,
                "title": "c-two-solutions",
                "content": "### Solution 1 - Swapping the bits using bitset\\n```\\nclass Solution {\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        bitset<32>b = {n}; \\n        int right = 0,left=31; \\n        while(right < left){\\n\\t\\t\\tint t  = b[right];\\n            b[right++] = b[left];\\n            b[left--] = t;\\n        }\\n        return b.to_ulong();\\n\\n    }\\n};\\n```\\n\\n### Solution 2 - Set the 31-ith bit if ith bit is set\\n```\\nclass Solution {\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        uint32_t ans = 0;  // set ans as 0\\n\\t\\t//  if the ith bit of n is set then set 31-i th bit of ans  (similar to the swap)\\n        for (int i=0;i<=31;i++) ans += (n & (1<<i)) ? 1<<(31-i) : 0; \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        bitset<32>b = {n}; \\n        int right = 0,left=31; \\n        while(right < left){\\n\\t\\t\\tint t  = b[right];\\n            b[right++] = b[left];\\n            b[left--] = t;\\n        }\\n        return b.to_ulong();\\n\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        uint32_t ans = 0;  // set ans as 0\\n\\t\\t//  if the ith bit of n is set then set 31-i th bit of ans  (similar to the swap)\\n        for (int i=0;i<=31;i++) ans += (n & (1<<i)) ? 1<<(31-i) : 0; \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 535299,
                "title": "go",
                "content": "```\\nfunc reverseBits(num uint32) uint32 {\\n    var result uint32   \\n    for i := 0; i < 32; i++ {\\n        result += num >> i << 31 >> i\\n    }\\n    return result\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc reverseBits(num uint32) uint32 {\\n    var result uint32   \\n    for i := 0; i < 32; i++ {\\n        result += num >> i << 31 >> i\\n    }\\n    return result\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 411157,
                "title": "c-o-1-lookup-table-with-explanation",
                "content": "\\n```\\n    uint32_t reverseBits(uint32_t x) {\\n\\t\\n        uint32_t lookupTable[256]; // To achieve O(1) we need to do work beforehand, create a lookup table.\\n\\t\\t\\n        for (uint32_t i{}; i < 256; i++) { // 256 combinations in 8 bits (1 byte)\\n            lookupTable[i] = (i&1) * pow(2,7) + // If a bit exists at position 1, the reverse will have a bit at position 8.\\n                            ((i&2)>>1) * pow(2,6) + // As you can see, (i&2)>>1 is either 1 or 0. If it\\'s 1, \\n                            ((i&4)>>2) * pow(2,5) + // we add 2^6 (turn on a bit at position 7). \\n                            ((i&8)>>3) * pow(2,4) + // We continue this for every bit position for eight bits in a byte.\\n                            ((i&16)>>4) * pow(2,3) +\\n                            ((i&32)>>5) * pow(2,2) +\\n                            ((i&64)>>6) * pow(2,1) +\\n                            ((i&128)>>7) * pow(2,0);\\n        }\\n        \\n        uint32_t result = 0; // The new result starts at 0.\\n        result = (lookupTable[x & 0xff] << 24) + (lookupTable[x>>8 & 0xff] << 16) + (lookupTable[x>>16 & 0xff] << 8) \\n\\t\\t+ lookupTable[x>>24 & 0xff]; \\n\\t\\t\\n\\t\\t// This part is worth explaining. I explain below.\\n\\t\\t\\n        return result;\\n    }\\n```\\n\\t\\n\\tWe start by looking at the first 8 bits (x & 0xff). We look the number up in the table to find it\\'s reverse. \\n\\tWe then add 24 zeros in its binary representation such that this first block of 8 bits is now the last block \\n\\tof eight bits (it\\'s like a mirror image).\\n\\t\\n\\tFor example, if our first number was 0000\\'0001, we find the reverse via the lookup table and \\n\\tget: 1000\\'0000. We then push it over 24 times so it looks as follows. We repeat for the next three chunks of 8 bits \\n\\tsuch that we are left with these four  lookup results:\\n\\t\\n\\t1) 1000\\'0000\\'0000\\'0000\\'0000\\'0000\\'0000\\'0000\\n\\t2) ....\\'....\\'0101\\'0100\\'0000\\'0000\\'0000\\'0000// Note these numbers are random for display purposes\\n\\t3) ....\\'....\\'....\\'....\\'1011\\'0000\\'0000\\'0000\\n\\t4) ....\\'....\\'....\\'....\\'....\\'....\\'1011\\'0000\\n\\t\\n\\tWhen we add all these shifted over lookup values together to the result, which was initially 0, we get:\\n\\t1000\\'0000\\'0101\\'0100\\'1011\\'0000\\'1011\\'0000",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n    uint32_t reverseBits(uint32_t x) {\\n\\t\\n        uint32_t lookupTable[256]; // To achieve O(1) we need to do work beforehand, create a lookup table.\\n\\t\\t\\n        for (uint32_t i{}; i < 256; i++) { // 256 combinations in 8 bits (1 byte)\\n            lookupTable[i] = (i&1) * pow(2,7) + // If a bit exists at position 1, the reverse will have a bit at position 8.\\n                            ((i&2)>>1) * pow(2,6) + // As you can see, (i&2)>>1 is either 1 or 0. If it\\'s 1, \\n                            ((i&4)>>2) * pow(2,5) + // we add 2^6 (turn on a bit at position 7). \\n                            ((i&8)>>3) * pow(2,4) + // We continue this for every bit position for eight bits in a byte.\\n                            ((i&16)>>4) * pow(2,3) +\\n                            ((i&32)>>5) * pow(2,2) +\\n                            ((i&64)>>6) * pow(2,1) +\\n                            ((i&128)>>7) * pow(2,0);\\n        }\\n        \\n        uint32_t result = 0; // The new result starts at 0.\\n        result = (lookupTable[x & 0xff] << 24) + (lookupTable[x>>8 & 0xff] << 16) + (lookupTable[x>>16 & 0xff] << 8) \\n\\t\\t+ lookupTable[x>>24 & 0xff]; \\n\\t\\t\\n\\t\\t// This part is worth explaining. I explain below.\\n\\t\\t\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 387487,
                "title": "golang-solution-without-bit-ops",
                "content": "```\\nfunc reverseBits(num uint32) uint32 {\\n    var result uint32\\n    \\n    for i := 0; i < 32; i++ {\\n        result *= 2\\n        if num != 0 {\\n            result += num %2\\n            num /= 2\\n        }\\n    }\\n    \\n    return result\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc reverseBits(num uint32) uint32 {\\n    var result uint32\\n    \\n    for i := 0; i < 32; i++ {\\n        result *= 2\\n        if num != 0 {\\n            result += num %2\\n            num /= 2\\n        }\\n    }\\n    \\n    return result\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 54759,
                "title": "c-solution-with-explanation-3ms",
                "content": "````    \\nuint32_t reverseBits(uint32_t n) {\\n        uint32_t res = 0;\\n        for(int i = 0; i<32; i++){\\n            res = (res << 1 | n & 1);\\n            n = n>>1;\\n        }\\n        return res;\\n````\\n\\nEvery loop, we shift our result number to left by 1 digit. Then update result number. If the rightmost digit of n is 1 then update result number last digit be 1. If the rightmost digit of n is 0 then update result number last digit be 0. Then shift n to right by one for another update\\n\\n\\nI use 8 bit int as example to explain my idea:\\nFor example we want to reverse 01010101. \\n\\n````\\nloop     res                 n\\n0          0             01010101\\n1          1             0101010\\n2          10            10101\\n3          101           01010\\n4          1010          0101\\n5          10101         010\\n6          101010        10\\n7          1010101       0\\n8          10101010      0\\n````",
                "solutionTags": [],
                "code": "````    \\nuint32_t reverseBits(uint32_t n) {\\n        uint32_t res = 0;\\n        for(int i = 0; i<32; i++){\\n            res = (res << 1 | n & 1);\\n            n = n>>1;\\n        }\\n        return res;\\n```\n````\\nloop     res                 n\\n0          0             01010101\\n1          1             0101010\\n2          10            10101\\n3          101           01010\\n4          1010          0101\\n5          10101         010\\n6          101010        10\\n7          1010101       0\\n8          10101010      0\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 54769,
                "title": "swift-solution",
                "content": "```\\nclass Solution {\\n    func reverseBits(_ n: Int) -> Int {\\n        var n = n\\n        var result = 0\\n        \\n        for i in 0..<32 {\\n            result += (n & 1)\\n            n >>= 1\\n            if i < 31 {\\n                result <<= 1\\n            }\\n        }\\n        \\n        return result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    func reverseBits(_ n: Int) -> Int {\\n        var n = n\\n        var result = 0\\n        \\n        for i in 0..<32 {\\n            result += (n & 1)\\n            n >>= 1\\n            if i < 31 {\\n                result <<= 1\\n            }\\n        }\\n        \\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 54871,
                "title": "132-ms-solution-with-javascript",
                "content": "Hit 100% in performance with javascript submissions. Shift the results 1 bit leftwards; shift n 1 bit right wards, and bit AND with 1. Every time you will get the last bit as 0 or 1; if last bit is 1, add 1 to result. Get ready for next iteration. \\n\\nNote: in JS, you have to result>>>0 in order to get the result to be unsigned. \\n\\nvar reverseBits = function(n) {\\n    if (n === 0) return 0;\\n    \\n    var result = 0;\\n    for (var i = 0; i < 32; i ++) {\\n        result <<= 1;\\n        if (n & 1 === 1) {\\n            result += 1;\\n        }\\n        \\n        n >>= 1;\\n    }\\n    return result>>>0;\\n};",
                "solutionTags": [
                    "JavaScript",
                    "Bit Manipulation"
                ],
                "code": "Hit 100% in performance with javascript submissions. Shift the results 1 bit leftwards; shift n 1 bit right wards, and bit AND with 1. Every time you will get the last bit as 0 or 1; if last bit is 1, add 1 to result. Get ready for next iteration. \\n\\nNote: in JS, you have to result>>>0 in order to get the result to be unsigned. \\n\\nvar reverseBits = function(n) {\\n    if (n === 0) return 0;\\n    \\n    var result = 0;\\n    for (var i = 0; i < 32; i ++) {\\n        result <<= 1;\\n        if (n & 1 === 1) {\\n            result += 1;\\n        }\\n        \\n        n >>= 1;\\n    }\\n    return result>>>0;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 54895,
                "title": "one-line-of-python-code-that-beats-86-of-all-python-submissions",
                "content": "    class Solution(object):\\n        def reverseBits(self, n):\\n            \"\"\"\\n            :type n: int\\n            :rtype: int\\n            \"\"\"\\n            return int(bin(n).lstrip('0b').zfill(32)[::-1],2)",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution(object):\\n        def reverseBits(self, n):\\n            \"\"\"\\n            :type n: int\\n            :rtype: int\\n            \"\"\"\\n            return int(bin(n).lstrip('0b').zfill(32)[::-1],2)",
                "codeTag": "Java"
            },
            {
                "id": 54937,
                "title": "my-simple-solution-with-c",
                "content": "    class Solution {\\n    public:\\n        uint32_t reverseBits(uint32_t n) {\\n            uint32_t r = 0;\\n            for(int i = 0; i < 32; i++){\\n                r <<= 1;\\n                r += n & 1;\\n                n >>= 1;\\n            }\\n            return r;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        uint32_t reverseBits(uint32_t n) {\\n            uint32_t r = 0;\\n            for(int i = 0; i < 32; i++){\\n                r <<= 1;\\n                r += n & 1;\\n                n >>= 1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 54956,
                "title": "javascript-solution-using-prototype",
                "content": "    Number.prototype.bin = function () {\\n        var result = this.toString(2);\\n        while(result.length < 32) {\\n            result = \"0\" + result;\\n        }\\n        return result;\\n    };\\n    \\n    var reverseBits = function(n) {\\n        return parseInt(n.bin().split('').reverse().join(''), 2);\\n    };",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "    Number.prototype.bin = function () {\\n        var result = this.toString(2);\\n        while(result.length < 32) {\\n            result = \"0\" + result;\\n        }\\n        return result;\\n    };\\n    \\n    var reverseBits = function(n) {\\n        return parseInt(n.bin().split('').reverse().join(''), 2);\\n    };",
                "codeTag": "Unknown"
            },
            {
                "id": 54959,
                "title": "three-lines-c-solution",
                "content": "    class Solution {\\n    public:\\n        uint32_t reverseBits(uint32_t n) {\\n            decltype(n) res = 0;\\n            for (int i = 0; i < 32; i++, n >>= 1) res = (res << 1) | (n & 1);\\n            return res;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        uint32_t reverseBits(uint32_t n) {\\n            decltype(n) res = 0;\\n            for (int i = 0; i < 32; i++, n >>= 1) res = (res << 1) | (n & 1);\\n            return res;\\n        }",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1565743,
                "content": [
                    {
                        "username": "gen504240809",
                        "content": "int in java is 32-bit signed number ,the maximum signed number is 2147483647.when the last bit of the input number is '1' and we reverse bits,it will become negative number ,how can we return a positive int number and the number must be larger than 2147483647?"
                    },
                    {
                        "username": "shtian",
                        "content": "## Java ##\\n\\nUse [`>>>`\\\\*][1] instead of `>>`. `>>>`is unsigned right shift, and `>>` is signed.\\n\\nUse [`Integer.parseUnsignedInt`\\\\*][2] and [`Integer.toUnsignedString`\\\\*][3] if you want test your program locally.\\n\\n## JavaScript ##\\n\\nUse [`>>>`\\\\*][4] instead of `>>`. This is as same as Java.\\n\\nAfter `|`, `&`, `~`, `>>`, `<<`, the number was converted ToInt32. But you need return a positive value. So try `return result >>> 0;`. `>>>` will call [`ToUint32`\\\\*][5].\\n\\n\\n  [1]: http://docs.oracle.com/javase/tutorial/java/nutsandbolts/op3.html\\n  [2]: http://docs.oracle.com/javase/8/docs/api/java/lang/Integer.html#parseUnsignedInt-java.lang.String-\\n  [3]: http://docs.oracle.com/javase/8/docs/api/java/lang/Integer.html#toUnsignedString-int-int-\\n  [4]: http://www.ecma-international.org/ecma-262/5.1/#sec-11.7.2\\n  [5]: http://www.ecma-international.org/ecma-262/5.1/#sec-9.6"
                    },
                    {
                        "username": "quarkyy99",
                        "content": "What is wrong with the developer of the question....Theyre saying that input is binary string and the input theyre taking is an integer...\\n"
                    },
                    {
                        "username": "jimmyzzxhlh",
                        "content": "Since the function is forced to return an int, how is it possible to return 2147483648?\\n\\nI've tried to return -2147483648 and it doesn't work."
                    },
                    {
                        "username": "loveytx",
                        "content": "use long long int "
                    },
                    {
                        "username": "daynis",
                        "content": "I have a more of a Java language question. My program failed for 2147483648 as an input. How is Java able to represent 2147483648 as an unsigned int value when it doesn't have any unsigned integer types?In other words, how is the input sent as 2147483648 in an int variable given that the Java language itself doesn't let us hold 2147483648 in an int ?"
                    },
                    {
                        "username": "lordwerneo",
                        "content": "In case if you wonder, if it says that as input you get something like this: \\'00000000000000000000000000000100\\' it means that as input you just got int 4, and to get binary representation, you just need to format or f-string your input as f\\'{input:032b}\\' where input is your variable."
                    },
                    {
                        "username": "ThirteenBeans",
                        "content": "    def reverse_bits(n)\\n        sprintf(\"%.32b\", n).reverse.to_i(2)\\n    end"
                    },
                    {
                        "username": "ajitemk",
                        "content": "uint32_t reverseBits(uint32_t n) {\\n\\nThis below expression use to swap the bits.\\nLet an example, suppose num is 0100, after the above expression it will be 1000.\\n\\n    n = (((n & 0xaaaaaaaa) >> 1) | ((n & 0x55555555) << 1));\\n\\nbelow expression uses to swap the 2 bits of a nibble. Suppose num is 10 00, after the above expression, it will be 00 01.\\n\\nn = (((n & 0xcccccccc) >> 2) | ((n & 0x33333333) << 2));\\n\\nExpression use to swaps the nibbles. like if num is 0011 0010 then after the below expression it will be 0010 0011.\\n\\n\\tn = (((n & 0xf0f0f0f0) >> 4) | ((n & 0x0f0f0f0f) << 4));\\n\\t\\n\\tThis statement  uses to swap the bytes of an integer. Let num is 00001000 00001100, after the below expression, it will be 00001100 00001000.\\n\\t\\n\\tn = (((n & 0xff00ff00) >> 8) | ((n & 0x00ff00ff) << 8));\\n\\t\\nreturn((n >> 16) | (n << 16));\\nThe above expression uses to swap the half-word of an integer. Means that if the num is 0000000011001110 1000100100000110, after the above result number will be 1000100100000110 0000000011001110.\\n    \\n}"
                    },
                    {
                        "username": "Henton",
                        "content": "My solution show this.\\nRuntime: 2 ms, faster than 98.25% of Java online submissions for Reverse Bits."
                    },
                    {
                        "username": "vikas7",
                        "content": "In Q.190, The function prototype says return type is int (Java language). But for the input 1, the expected output is 2147483648, How can an int type can store that value?\\n\\nThank you"
                    }
                ]
            },
            {
                "id": 1565429,
                "content": [
                    {
                        "username": "gen504240809",
                        "content": "int in java is 32-bit signed number ,the maximum signed number is 2147483647.when the last bit of the input number is '1' and we reverse bits,it will become negative number ,how can we return a positive int number and the number must be larger than 2147483647?"
                    },
                    {
                        "username": "shtian",
                        "content": "## Java ##\\n\\nUse [`>>>`\\\\*][1] instead of `>>`. `>>>`is unsigned right shift, and `>>` is signed.\\n\\nUse [`Integer.parseUnsignedInt`\\\\*][2] and [`Integer.toUnsignedString`\\\\*][3] if you want test your program locally.\\n\\n## JavaScript ##\\n\\nUse [`>>>`\\\\*][4] instead of `>>`. This is as same as Java.\\n\\nAfter `|`, `&`, `~`, `>>`, `<<`, the number was converted ToInt32. But you need return a positive value. So try `return result >>> 0;`. `>>>` will call [`ToUint32`\\\\*][5].\\n\\n\\n  [1]: http://docs.oracle.com/javase/tutorial/java/nutsandbolts/op3.html\\n  [2]: http://docs.oracle.com/javase/8/docs/api/java/lang/Integer.html#parseUnsignedInt-java.lang.String-\\n  [3]: http://docs.oracle.com/javase/8/docs/api/java/lang/Integer.html#toUnsignedString-int-int-\\n  [4]: http://www.ecma-international.org/ecma-262/5.1/#sec-11.7.2\\n  [5]: http://www.ecma-international.org/ecma-262/5.1/#sec-9.6"
                    },
                    {
                        "username": "quarkyy99",
                        "content": "What is wrong with the developer of the question....Theyre saying that input is binary string and the input theyre taking is an integer...\\n"
                    },
                    {
                        "username": "jimmyzzxhlh",
                        "content": "Since the function is forced to return an int, how is it possible to return 2147483648?\\n\\nI've tried to return -2147483648 and it doesn't work."
                    },
                    {
                        "username": "loveytx",
                        "content": "use long long int "
                    },
                    {
                        "username": "daynis",
                        "content": "I have a more of a Java language question. My program failed for 2147483648 as an input. How is Java able to represent 2147483648 as an unsigned int value when it doesn't have any unsigned integer types?In other words, how is the input sent as 2147483648 in an int variable given that the Java language itself doesn't let us hold 2147483648 in an int ?"
                    },
                    {
                        "username": "lordwerneo",
                        "content": "In case if you wonder, if it says that as input you get something like this: \\'00000000000000000000000000000100\\' it means that as input you just got int 4, and to get binary representation, you just need to format or f-string your input as f\\'{input:032b}\\' where input is your variable."
                    },
                    {
                        "username": "ThirteenBeans",
                        "content": "    def reverse_bits(n)\\n        sprintf(\"%.32b\", n).reverse.to_i(2)\\n    end"
                    },
                    {
                        "username": "ajitemk",
                        "content": "uint32_t reverseBits(uint32_t n) {\\n\\nThis below expression use to swap the bits.\\nLet an example, suppose num is 0100, after the above expression it will be 1000.\\n\\n    n = (((n & 0xaaaaaaaa) >> 1) | ((n & 0x55555555) << 1));\\n\\nbelow expression uses to swap the 2 bits of a nibble. Suppose num is 10 00, after the above expression, it will be 00 01.\\n\\nn = (((n & 0xcccccccc) >> 2) | ((n & 0x33333333) << 2));\\n\\nExpression use to swaps the nibbles. like if num is 0011 0010 then after the below expression it will be 0010 0011.\\n\\n\\tn = (((n & 0xf0f0f0f0) >> 4) | ((n & 0x0f0f0f0f) << 4));\\n\\t\\n\\tThis statement  uses to swap the bytes of an integer. Let num is 00001000 00001100, after the below expression, it will be 00001100 00001000.\\n\\t\\n\\tn = (((n & 0xff00ff00) >> 8) | ((n & 0x00ff00ff) << 8));\\n\\t\\nreturn((n >> 16) | (n << 16));\\nThe above expression uses to swap the half-word of an integer. Means that if the num is 0000000011001110 1000100100000110, after the above result number will be 1000100100000110 0000000011001110.\\n    \\n}"
                    },
                    {
                        "username": "Henton",
                        "content": "My solution show this.\\nRuntime: 2 ms, faster than 98.25% of Java online submissions for Reverse Bits."
                    },
                    {
                        "username": "vikas7",
                        "content": "In Q.190, The function prototype says return type is int (Java language). But for the input 1, the expected output is 2147483648, How can an int type can store that value?\\n\\nThank you"
                    }
                ]
            },
            {
                "id": 1990124,
                "content": [
                    {
                        "username": "gen504240809",
                        "content": "int in java is 32-bit signed number ,the maximum signed number is 2147483647.when the last bit of the input number is '1' and we reverse bits,it will become negative number ,how can we return a positive int number and the number must be larger than 2147483647?"
                    },
                    {
                        "username": "shtian",
                        "content": "## Java ##\\n\\nUse [`>>>`\\\\*][1] instead of `>>`. `>>>`is unsigned right shift, and `>>` is signed.\\n\\nUse [`Integer.parseUnsignedInt`\\\\*][2] and [`Integer.toUnsignedString`\\\\*][3] if you want test your program locally.\\n\\n## JavaScript ##\\n\\nUse [`>>>`\\\\*][4] instead of `>>`. This is as same as Java.\\n\\nAfter `|`, `&`, `~`, `>>`, `<<`, the number was converted ToInt32. But you need return a positive value. So try `return result >>> 0;`. `>>>` will call [`ToUint32`\\\\*][5].\\n\\n\\n  [1]: http://docs.oracle.com/javase/tutorial/java/nutsandbolts/op3.html\\n  [2]: http://docs.oracle.com/javase/8/docs/api/java/lang/Integer.html#parseUnsignedInt-java.lang.String-\\n  [3]: http://docs.oracle.com/javase/8/docs/api/java/lang/Integer.html#toUnsignedString-int-int-\\n  [4]: http://www.ecma-international.org/ecma-262/5.1/#sec-11.7.2\\n  [5]: http://www.ecma-international.org/ecma-262/5.1/#sec-9.6"
                    },
                    {
                        "username": "quarkyy99",
                        "content": "What is wrong with the developer of the question....Theyre saying that input is binary string and the input theyre taking is an integer...\\n"
                    },
                    {
                        "username": "jimmyzzxhlh",
                        "content": "Since the function is forced to return an int, how is it possible to return 2147483648?\\n\\nI've tried to return -2147483648 and it doesn't work."
                    },
                    {
                        "username": "loveytx",
                        "content": "use long long int "
                    },
                    {
                        "username": "daynis",
                        "content": "I have a more of a Java language question. My program failed for 2147483648 as an input. How is Java able to represent 2147483648 as an unsigned int value when it doesn't have any unsigned integer types?In other words, how is the input sent as 2147483648 in an int variable given that the Java language itself doesn't let us hold 2147483648 in an int ?"
                    },
                    {
                        "username": "lordwerneo",
                        "content": "In case if you wonder, if it says that as input you get something like this: \\'00000000000000000000000000000100\\' it means that as input you just got int 4, and to get binary representation, you just need to format or f-string your input as f\\'{input:032b}\\' where input is your variable."
                    },
                    {
                        "username": "ThirteenBeans",
                        "content": "    def reverse_bits(n)\\n        sprintf(\"%.32b\", n).reverse.to_i(2)\\n    end"
                    },
                    {
                        "username": "ajitemk",
                        "content": "uint32_t reverseBits(uint32_t n) {\\n\\nThis below expression use to swap the bits.\\nLet an example, suppose num is 0100, after the above expression it will be 1000.\\n\\n    n = (((n & 0xaaaaaaaa) >> 1) | ((n & 0x55555555) << 1));\\n\\nbelow expression uses to swap the 2 bits of a nibble. Suppose num is 10 00, after the above expression, it will be 00 01.\\n\\nn = (((n & 0xcccccccc) >> 2) | ((n & 0x33333333) << 2));\\n\\nExpression use to swaps the nibbles. like if num is 0011 0010 then after the below expression it will be 0010 0011.\\n\\n\\tn = (((n & 0xf0f0f0f0) >> 4) | ((n & 0x0f0f0f0f) << 4));\\n\\t\\n\\tThis statement  uses to swap the bytes of an integer. Let num is 00001000 00001100, after the below expression, it will be 00001100 00001000.\\n\\t\\n\\tn = (((n & 0xff00ff00) >> 8) | ((n & 0x00ff00ff) << 8));\\n\\t\\nreturn((n >> 16) | (n << 16));\\nThe above expression uses to swap the half-word of an integer. Means that if the num is 0000000011001110 1000100100000110, after the above result number will be 1000100100000110 0000000011001110.\\n    \\n}"
                    },
                    {
                        "username": "Henton",
                        "content": "My solution show this.\\nRuntime: 2 ms, faster than 98.25% of Java online submissions for Reverse Bits."
                    },
                    {
                        "username": "vikas7",
                        "content": "In Q.190, The function prototype says return type is int (Java language). But for the input 1, the expected output is 2147483648, How can an int type can store that value?\\n\\nThank you"
                    }
                ]
            },
            {
                "id": 1565947,
                "content": [
                    {
                        "username": "gen504240809",
                        "content": "int in java is 32-bit signed number ,the maximum signed number is 2147483647.when the last bit of the input number is '1' and we reverse bits,it will become negative number ,how can we return a positive int number and the number must be larger than 2147483647?"
                    },
                    {
                        "username": "shtian",
                        "content": "## Java ##\\n\\nUse [`>>>`\\\\*][1] instead of `>>`. `>>>`is unsigned right shift, and `>>` is signed.\\n\\nUse [`Integer.parseUnsignedInt`\\\\*][2] and [`Integer.toUnsignedString`\\\\*][3] if you want test your program locally.\\n\\n## JavaScript ##\\n\\nUse [`>>>`\\\\*][4] instead of `>>`. This is as same as Java.\\n\\nAfter `|`, `&`, `~`, `>>`, `<<`, the number was converted ToInt32. But you need return a positive value. So try `return result >>> 0;`. `>>>` will call [`ToUint32`\\\\*][5].\\n\\n\\n  [1]: http://docs.oracle.com/javase/tutorial/java/nutsandbolts/op3.html\\n  [2]: http://docs.oracle.com/javase/8/docs/api/java/lang/Integer.html#parseUnsignedInt-java.lang.String-\\n  [3]: http://docs.oracle.com/javase/8/docs/api/java/lang/Integer.html#toUnsignedString-int-int-\\n  [4]: http://www.ecma-international.org/ecma-262/5.1/#sec-11.7.2\\n  [5]: http://www.ecma-international.org/ecma-262/5.1/#sec-9.6"
                    },
                    {
                        "username": "quarkyy99",
                        "content": "What is wrong with the developer of the question....Theyre saying that input is binary string and the input theyre taking is an integer...\\n"
                    },
                    {
                        "username": "jimmyzzxhlh",
                        "content": "Since the function is forced to return an int, how is it possible to return 2147483648?\\n\\nI've tried to return -2147483648 and it doesn't work."
                    },
                    {
                        "username": "loveytx",
                        "content": "use long long int "
                    },
                    {
                        "username": "daynis",
                        "content": "I have a more of a Java language question. My program failed for 2147483648 as an input. How is Java able to represent 2147483648 as an unsigned int value when it doesn't have any unsigned integer types?In other words, how is the input sent as 2147483648 in an int variable given that the Java language itself doesn't let us hold 2147483648 in an int ?"
                    },
                    {
                        "username": "lordwerneo",
                        "content": "In case if you wonder, if it says that as input you get something like this: \\'00000000000000000000000000000100\\' it means that as input you just got int 4, and to get binary representation, you just need to format or f-string your input as f\\'{input:032b}\\' where input is your variable."
                    },
                    {
                        "username": "ThirteenBeans",
                        "content": "    def reverse_bits(n)\\n        sprintf(\"%.32b\", n).reverse.to_i(2)\\n    end"
                    },
                    {
                        "username": "ajitemk",
                        "content": "uint32_t reverseBits(uint32_t n) {\\n\\nThis below expression use to swap the bits.\\nLet an example, suppose num is 0100, after the above expression it will be 1000.\\n\\n    n = (((n & 0xaaaaaaaa) >> 1) | ((n & 0x55555555) << 1));\\n\\nbelow expression uses to swap the 2 bits of a nibble. Suppose num is 10 00, after the above expression, it will be 00 01.\\n\\nn = (((n & 0xcccccccc) >> 2) | ((n & 0x33333333) << 2));\\n\\nExpression use to swaps the nibbles. like if num is 0011 0010 then after the below expression it will be 0010 0011.\\n\\n\\tn = (((n & 0xf0f0f0f0) >> 4) | ((n & 0x0f0f0f0f) << 4));\\n\\t\\n\\tThis statement  uses to swap the bytes of an integer. Let num is 00001000 00001100, after the below expression, it will be 00001100 00001000.\\n\\t\\n\\tn = (((n & 0xff00ff00) >> 8) | ((n & 0x00ff00ff) << 8));\\n\\t\\nreturn((n >> 16) | (n << 16));\\nThe above expression uses to swap the half-word of an integer. Means that if the num is 0000000011001110 1000100100000110, after the above result number will be 1000100100000110 0000000011001110.\\n    \\n}"
                    },
                    {
                        "username": "Henton",
                        "content": "My solution show this.\\nRuntime: 2 ms, faster than 98.25% of Java online submissions for Reverse Bits."
                    },
                    {
                        "username": "vikas7",
                        "content": "In Q.190, The function prototype says return type is int (Java language). But for the input 1, the expected output is 2147483648, How can an int type can store that value?\\n\\nThank you"
                    }
                ]
            },
            {
                "id": 1566836,
                "content": [
                    {
                        "username": "gen504240809",
                        "content": "int in java is 32-bit signed number ,the maximum signed number is 2147483647.when the last bit of the input number is '1' and we reverse bits,it will become negative number ,how can we return a positive int number and the number must be larger than 2147483647?"
                    },
                    {
                        "username": "shtian",
                        "content": "## Java ##\\n\\nUse [`>>>`\\\\*][1] instead of `>>`. `>>>`is unsigned right shift, and `>>` is signed.\\n\\nUse [`Integer.parseUnsignedInt`\\\\*][2] and [`Integer.toUnsignedString`\\\\*][3] if you want test your program locally.\\n\\n## JavaScript ##\\n\\nUse [`>>>`\\\\*][4] instead of `>>`. This is as same as Java.\\n\\nAfter `|`, `&`, `~`, `>>`, `<<`, the number was converted ToInt32. But you need return a positive value. So try `return result >>> 0;`. `>>>` will call [`ToUint32`\\\\*][5].\\n\\n\\n  [1]: http://docs.oracle.com/javase/tutorial/java/nutsandbolts/op3.html\\n  [2]: http://docs.oracle.com/javase/8/docs/api/java/lang/Integer.html#parseUnsignedInt-java.lang.String-\\n  [3]: http://docs.oracle.com/javase/8/docs/api/java/lang/Integer.html#toUnsignedString-int-int-\\n  [4]: http://www.ecma-international.org/ecma-262/5.1/#sec-11.7.2\\n  [5]: http://www.ecma-international.org/ecma-262/5.1/#sec-9.6"
                    },
                    {
                        "username": "quarkyy99",
                        "content": "What is wrong with the developer of the question....Theyre saying that input is binary string and the input theyre taking is an integer...\\n"
                    },
                    {
                        "username": "jimmyzzxhlh",
                        "content": "Since the function is forced to return an int, how is it possible to return 2147483648?\\n\\nI've tried to return -2147483648 and it doesn't work."
                    },
                    {
                        "username": "loveytx",
                        "content": "use long long int "
                    },
                    {
                        "username": "daynis",
                        "content": "I have a more of a Java language question. My program failed for 2147483648 as an input. How is Java able to represent 2147483648 as an unsigned int value when it doesn't have any unsigned integer types?In other words, how is the input sent as 2147483648 in an int variable given that the Java language itself doesn't let us hold 2147483648 in an int ?"
                    },
                    {
                        "username": "lordwerneo",
                        "content": "In case if you wonder, if it says that as input you get something like this: \\'00000000000000000000000000000100\\' it means that as input you just got int 4, and to get binary representation, you just need to format or f-string your input as f\\'{input:032b}\\' where input is your variable."
                    },
                    {
                        "username": "ThirteenBeans",
                        "content": "    def reverse_bits(n)\\n        sprintf(\"%.32b\", n).reverse.to_i(2)\\n    end"
                    },
                    {
                        "username": "ajitemk",
                        "content": "uint32_t reverseBits(uint32_t n) {\\n\\nThis below expression use to swap the bits.\\nLet an example, suppose num is 0100, after the above expression it will be 1000.\\n\\n    n = (((n & 0xaaaaaaaa) >> 1) | ((n & 0x55555555) << 1));\\n\\nbelow expression uses to swap the 2 bits of a nibble. Suppose num is 10 00, after the above expression, it will be 00 01.\\n\\nn = (((n & 0xcccccccc) >> 2) | ((n & 0x33333333) << 2));\\n\\nExpression use to swaps the nibbles. like if num is 0011 0010 then after the below expression it will be 0010 0011.\\n\\n\\tn = (((n & 0xf0f0f0f0) >> 4) | ((n & 0x0f0f0f0f) << 4));\\n\\t\\n\\tThis statement  uses to swap the bytes of an integer. Let num is 00001000 00001100, after the below expression, it will be 00001100 00001000.\\n\\t\\n\\tn = (((n & 0xff00ff00) >> 8) | ((n & 0x00ff00ff) << 8));\\n\\t\\nreturn((n >> 16) | (n << 16));\\nThe above expression uses to swap the half-word of an integer. Means that if the num is 0000000011001110 1000100100000110, after the above result number will be 1000100100000110 0000000011001110.\\n    \\n}"
                    },
                    {
                        "username": "Henton",
                        "content": "My solution show this.\\nRuntime: 2 ms, faster than 98.25% of Java online submissions for Reverse Bits."
                    },
                    {
                        "username": "vikas7",
                        "content": "In Q.190, The function prototype says return type is int (Java language). But for the input 1, the expected output is 2147483648, How can an int type can store that value?\\n\\nThank you"
                    }
                ]
            },
            {
                "id": 1576318,
                "content": [
                    {
                        "username": "gen504240809",
                        "content": "int in java is 32-bit signed number ,the maximum signed number is 2147483647.when the last bit of the input number is '1' and we reverse bits,it will become negative number ,how can we return a positive int number and the number must be larger than 2147483647?"
                    },
                    {
                        "username": "shtian",
                        "content": "## Java ##\\n\\nUse [`>>>`\\\\*][1] instead of `>>`. `>>>`is unsigned right shift, and `>>` is signed.\\n\\nUse [`Integer.parseUnsignedInt`\\\\*][2] and [`Integer.toUnsignedString`\\\\*][3] if you want test your program locally.\\n\\n## JavaScript ##\\n\\nUse [`>>>`\\\\*][4] instead of `>>`. This is as same as Java.\\n\\nAfter `|`, `&`, `~`, `>>`, `<<`, the number was converted ToInt32. But you need return a positive value. So try `return result >>> 0;`. `>>>` will call [`ToUint32`\\\\*][5].\\n\\n\\n  [1]: http://docs.oracle.com/javase/tutorial/java/nutsandbolts/op3.html\\n  [2]: http://docs.oracle.com/javase/8/docs/api/java/lang/Integer.html#parseUnsignedInt-java.lang.String-\\n  [3]: http://docs.oracle.com/javase/8/docs/api/java/lang/Integer.html#toUnsignedString-int-int-\\n  [4]: http://www.ecma-international.org/ecma-262/5.1/#sec-11.7.2\\n  [5]: http://www.ecma-international.org/ecma-262/5.1/#sec-9.6"
                    },
                    {
                        "username": "quarkyy99",
                        "content": "What is wrong with the developer of the question....Theyre saying that input is binary string and the input theyre taking is an integer...\\n"
                    },
                    {
                        "username": "jimmyzzxhlh",
                        "content": "Since the function is forced to return an int, how is it possible to return 2147483648?\\n\\nI've tried to return -2147483648 and it doesn't work."
                    },
                    {
                        "username": "loveytx",
                        "content": "use long long int "
                    },
                    {
                        "username": "daynis",
                        "content": "I have a more of a Java language question. My program failed for 2147483648 as an input. How is Java able to represent 2147483648 as an unsigned int value when it doesn't have any unsigned integer types?In other words, how is the input sent as 2147483648 in an int variable given that the Java language itself doesn't let us hold 2147483648 in an int ?"
                    },
                    {
                        "username": "lordwerneo",
                        "content": "In case if you wonder, if it says that as input you get something like this: \\'00000000000000000000000000000100\\' it means that as input you just got int 4, and to get binary representation, you just need to format or f-string your input as f\\'{input:032b}\\' where input is your variable."
                    },
                    {
                        "username": "ThirteenBeans",
                        "content": "    def reverse_bits(n)\\n        sprintf(\"%.32b\", n).reverse.to_i(2)\\n    end"
                    },
                    {
                        "username": "ajitemk",
                        "content": "uint32_t reverseBits(uint32_t n) {\\n\\nThis below expression use to swap the bits.\\nLet an example, suppose num is 0100, after the above expression it will be 1000.\\n\\n    n = (((n & 0xaaaaaaaa) >> 1) | ((n & 0x55555555) << 1));\\n\\nbelow expression uses to swap the 2 bits of a nibble. Suppose num is 10 00, after the above expression, it will be 00 01.\\n\\nn = (((n & 0xcccccccc) >> 2) | ((n & 0x33333333) << 2));\\n\\nExpression use to swaps the nibbles. like if num is 0011 0010 then after the below expression it will be 0010 0011.\\n\\n\\tn = (((n & 0xf0f0f0f0) >> 4) | ((n & 0x0f0f0f0f) << 4));\\n\\t\\n\\tThis statement  uses to swap the bytes of an integer. Let num is 00001000 00001100, after the below expression, it will be 00001100 00001000.\\n\\t\\n\\tn = (((n & 0xff00ff00) >> 8) | ((n & 0x00ff00ff) << 8));\\n\\t\\nreturn((n >> 16) | (n << 16));\\nThe above expression uses to swap the half-word of an integer. Means that if the num is 0000000011001110 1000100100000110, after the above result number will be 1000100100000110 0000000011001110.\\n    \\n}"
                    },
                    {
                        "username": "Henton",
                        "content": "My solution show this.\\nRuntime: 2 ms, faster than 98.25% of Java online submissions for Reverse Bits."
                    },
                    {
                        "username": "vikas7",
                        "content": "In Q.190, The function prototype says return type is int (Java language). But for the input 1, the expected output is 2147483648, How can an int type can store that value?\\n\\nThank you"
                    }
                ]
            },
            {
                "id": 1569006,
                "content": [
                    {
                        "username": "gen504240809",
                        "content": "int in java is 32-bit signed number ,the maximum signed number is 2147483647.when the last bit of the input number is '1' and we reverse bits,it will become negative number ,how can we return a positive int number and the number must be larger than 2147483647?"
                    },
                    {
                        "username": "shtian",
                        "content": "## Java ##\\n\\nUse [`>>>`\\\\*][1] instead of `>>`. `>>>`is unsigned right shift, and `>>` is signed.\\n\\nUse [`Integer.parseUnsignedInt`\\\\*][2] and [`Integer.toUnsignedString`\\\\*][3] if you want test your program locally.\\n\\n## JavaScript ##\\n\\nUse [`>>>`\\\\*][4] instead of `>>`. This is as same as Java.\\n\\nAfter `|`, `&`, `~`, `>>`, `<<`, the number was converted ToInt32. But you need return a positive value. So try `return result >>> 0;`. `>>>` will call [`ToUint32`\\\\*][5].\\n\\n\\n  [1]: http://docs.oracle.com/javase/tutorial/java/nutsandbolts/op3.html\\n  [2]: http://docs.oracle.com/javase/8/docs/api/java/lang/Integer.html#parseUnsignedInt-java.lang.String-\\n  [3]: http://docs.oracle.com/javase/8/docs/api/java/lang/Integer.html#toUnsignedString-int-int-\\n  [4]: http://www.ecma-international.org/ecma-262/5.1/#sec-11.7.2\\n  [5]: http://www.ecma-international.org/ecma-262/5.1/#sec-9.6"
                    },
                    {
                        "username": "quarkyy99",
                        "content": "What is wrong with the developer of the question....Theyre saying that input is binary string and the input theyre taking is an integer...\\n"
                    },
                    {
                        "username": "jimmyzzxhlh",
                        "content": "Since the function is forced to return an int, how is it possible to return 2147483648?\\n\\nI've tried to return -2147483648 and it doesn't work."
                    },
                    {
                        "username": "loveytx",
                        "content": "use long long int "
                    },
                    {
                        "username": "daynis",
                        "content": "I have a more of a Java language question. My program failed for 2147483648 as an input. How is Java able to represent 2147483648 as an unsigned int value when it doesn't have any unsigned integer types?In other words, how is the input sent as 2147483648 in an int variable given that the Java language itself doesn't let us hold 2147483648 in an int ?"
                    },
                    {
                        "username": "lordwerneo",
                        "content": "In case if you wonder, if it says that as input you get something like this: \\'00000000000000000000000000000100\\' it means that as input you just got int 4, and to get binary representation, you just need to format or f-string your input as f\\'{input:032b}\\' where input is your variable."
                    },
                    {
                        "username": "ThirteenBeans",
                        "content": "    def reverse_bits(n)\\n        sprintf(\"%.32b\", n).reverse.to_i(2)\\n    end"
                    },
                    {
                        "username": "ajitemk",
                        "content": "uint32_t reverseBits(uint32_t n) {\\n\\nThis below expression use to swap the bits.\\nLet an example, suppose num is 0100, after the above expression it will be 1000.\\n\\n    n = (((n & 0xaaaaaaaa) >> 1) | ((n & 0x55555555) << 1));\\n\\nbelow expression uses to swap the 2 bits of a nibble. Suppose num is 10 00, after the above expression, it will be 00 01.\\n\\nn = (((n & 0xcccccccc) >> 2) | ((n & 0x33333333) << 2));\\n\\nExpression use to swaps the nibbles. like if num is 0011 0010 then after the below expression it will be 0010 0011.\\n\\n\\tn = (((n & 0xf0f0f0f0) >> 4) | ((n & 0x0f0f0f0f) << 4));\\n\\t\\n\\tThis statement  uses to swap the bytes of an integer. Let num is 00001000 00001100, after the below expression, it will be 00001100 00001000.\\n\\t\\n\\tn = (((n & 0xff00ff00) >> 8) | ((n & 0x00ff00ff) << 8));\\n\\t\\nreturn((n >> 16) | (n << 16));\\nThe above expression uses to swap the half-word of an integer. Means that if the num is 0000000011001110 1000100100000110, after the above result number will be 1000100100000110 0000000011001110.\\n    \\n}"
                    },
                    {
                        "username": "Henton",
                        "content": "My solution show this.\\nRuntime: 2 ms, faster than 98.25% of Java online submissions for Reverse Bits."
                    },
                    {
                        "username": "vikas7",
                        "content": "In Q.190, The function prototype says return type is int (Java language). But for the input 1, the expected output is 2147483648, How can an int type can store that value?\\n\\nThank you"
                    }
                ]
            },
            {
                "id": 1570134,
                "content": [
                    {
                        "username": "gen504240809",
                        "content": "int in java is 32-bit signed number ,the maximum signed number is 2147483647.when the last bit of the input number is '1' and we reverse bits,it will become negative number ,how can we return a positive int number and the number must be larger than 2147483647?"
                    },
                    {
                        "username": "shtian",
                        "content": "## Java ##\\n\\nUse [`>>>`\\\\*][1] instead of `>>`. `>>>`is unsigned right shift, and `>>` is signed.\\n\\nUse [`Integer.parseUnsignedInt`\\\\*][2] and [`Integer.toUnsignedString`\\\\*][3] if you want test your program locally.\\n\\n## JavaScript ##\\n\\nUse [`>>>`\\\\*][4] instead of `>>`. This is as same as Java.\\n\\nAfter `|`, `&`, `~`, `>>`, `<<`, the number was converted ToInt32. But you need return a positive value. So try `return result >>> 0;`. `>>>` will call [`ToUint32`\\\\*][5].\\n\\n\\n  [1]: http://docs.oracle.com/javase/tutorial/java/nutsandbolts/op3.html\\n  [2]: http://docs.oracle.com/javase/8/docs/api/java/lang/Integer.html#parseUnsignedInt-java.lang.String-\\n  [3]: http://docs.oracle.com/javase/8/docs/api/java/lang/Integer.html#toUnsignedString-int-int-\\n  [4]: http://www.ecma-international.org/ecma-262/5.1/#sec-11.7.2\\n  [5]: http://www.ecma-international.org/ecma-262/5.1/#sec-9.6"
                    },
                    {
                        "username": "quarkyy99",
                        "content": "What is wrong with the developer of the question....Theyre saying that input is binary string and the input theyre taking is an integer...\\n"
                    },
                    {
                        "username": "jimmyzzxhlh",
                        "content": "Since the function is forced to return an int, how is it possible to return 2147483648?\\n\\nI've tried to return -2147483648 and it doesn't work."
                    },
                    {
                        "username": "loveytx",
                        "content": "use long long int "
                    },
                    {
                        "username": "daynis",
                        "content": "I have a more of a Java language question. My program failed for 2147483648 as an input. How is Java able to represent 2147483648 as an unsigned int value when it doesn't have any unsigned integer types?In other words, how is the input sent as 2147483648 in an int variable given that the Java language itself doesn't let us hold 2147483648 in an int ?"
                    },
                    {
                        "username": "lordwerneo",
                        "content": "In case if you wonder, if it says that as input you get something like this: \\'00000000000000000000000000000100\\' it means that as input you just got int 4, and to get binary representation, you just need to format or f-string your input as f\\'{input:032b}\\' where input is your variable."
                    },
                    {
                        "username": "ThirteenBeans",
                        "content": "    def reverse_bits(n)\\n        sprintf(\"%.32b\", n).reverse.to_i(2)\\n    end"
                    },
                    {
                        "username": "ajitemk",
                        "content": "uint32_t reverseBits(uint32_t n) {\\n\\nThis below expression use to swap the bits.\\nLet an example, suppose num is 0100, after the above expression it will be 1000.\\n\\n    n = (((n & 0xaaaaaaaa) >> 1) | ((n & 0x55555555) << 1));\\n\\nbelow expression uses to swap the 2 bits of a nibble. Suppose num is 10 00, after the above expression, it will be 00 01.\\n\\nn = (((n & 0xcccccccc) >> 2) | ((n & 0x33333333) << 2));\\n\\nExpression use to swaps the nibbles. like if num is 0011 0010 then after the below expression it will be 0010 0011.\\n\\n\\tn = (((n & 0xf0f0f0f0) >> 4) | ((n & 0x0f0f0f0f) << 4));\\n\\t\\n\\tThis statement  uses to swap the bytes of an integer. Let num is 00001000 00001100, after the below expression, it will be 00001100 00001000.\\n\\t\\n\\tn = (((n & 0xff00ff00) >> 8) | ((n & 0x00ff00ff) << 8));\\n\\t\\nreturn((n >> 16) | (n << 16));\\nThe above expression uses to swap the half-word of an integer. Means that if the num is 0000000011001110 1000100100000110, after the above result number will be 1000100100000110 0000000011001110.\\n    \\n}"
                    },
                    {
                        "username": "Henton",
                        "content": "My solution show this.\\nRuntime: 2 ms, faster than 98.25% of Java online submissions for Reverse Bits."
                    },
                    {
                        "username": "vikas7",
                        "content": "In Q.190, The function prototype says return type is int (Java language). But for the input 1, the expected output is 2147483648, How can an int type can store that value?\\n\\nThank you"
                    }
                ]
            },
            {
                "id": 1569405,
                "content": [
                    {
                        "username": "gen504240809",
                        "content": "int in java is 32-bit signed number ,the maximum signed number is 2147483647.when the last bit of the input number is '1' and we reverse bits,it will become negative number ,how can we return a positive int number and the number must be larger than 2147483647?"
                    },
                    {
                        "username": "shtian",
                        "content": "## Java ##\\n\\nUse [`>>>`\\\\*][1] instead of `>>`. `>>>`is unsigned right shift, and `>>` is signed.\\n\\nUse [`Integer.parseUnsignedInt`\\\\*][2] and [`Integer.toUnsignedString`\\\\*][3] if you want test your program locally.\\n\\n## JavaScript ##\\n\\nUse [`>>>`\\\\*][4] instead of `>>`. This is as same as Java.\\n\\nAfter `|`, `&`, `~`, `>>`, `<<`, the number was converted ToInt32. But you need return a positive value. So try `return result >>> 0;`. `>>>` will call [`ToUint32`\\\\*][5].\\n\\n\\n  [1]: http://docs.oracle.com/javase/tutorial/java/nutsandbolts/op3.html\\n  [2]: http://docs.oracle.com/javase/8/docs/api/java/lang/Integer.html#parseUnsignedInt-java.lang.String-\\n  [3]: http://docs.oracle.com/javase/8/docs/api/java/lang/Integer.html#toUnsignedString-int-int-\\n  [4]: http://www.ecma-international.org/ecma-262/5.1/#sec-11.7.2\\n  [5]: http://www.ecma-international.org/ecma-262/5.1/#sec-9.6"
                    },
                    {
                        "username": "quarkyy99",
                        "content": "What is wrong with the developer of the question....Theyre saying that input is binary string and the input theyre taking is an integer...\\n"
                    },
                    {
                        "username": "jimmyzzxhlh",
                        "content": "Since the function is forced to return an int, how is it possible to return 2147483648?\\n\\nI've tried to return -2147483648 and it doesn't work."
                    },
                    {
                        "username": "loveytx",
                        "content": "use long long int "
                    },
                    {
                        "username": "daynis",
                        "content": "I have a more of a Java language question. My program failed for 2147483648 as an input. How is Java able to represent 2147483648 as an unsigned int value when it doesn't have any unsigned integer types?In other words, how is the input sent as 2147483648 in an int variable given that the Java language itself doesn't let us hold 2147483648 in an int ?"
                    },
                    {
                        "username": "lordwerneo",
                        "content": "In case if you wonder, if it says that as input you get something like this: \\'00000000000000000000000000000100\\' it means that as input you just got int 4, and to get binary representation, you just need to format or f-string your input as f\\'{input:032b}\\' where input is your variable."
                    },
                    {
                        "username": "ThirteenBeans",
                        "content": "    def reverse_bits(n)\\n        sprintf(\"%.32b\", n).reverse.to_i(2)\\n    end"
                    },
                    {
                        "username": "ajitemk",
                        "content": "uint32_t reverseBits(uint32_t n) {\\n\\nThis below expression use to swap the bits.\\nLet an example, suppose num is 0100, after the above expression it will be 1000.\\n\\n    n = (((n & 0xaaaaaaaa) >> 1) | ((n & 0x55555555) << 1));\\n\\nbelow expression uses to swap the 2 bits of a nibble. Suppose num is 10 00, after the above expression, it will be 00 01.\\n\\nn = (((n & 0xcccccccc) >> 2) | ((n & 0x33333333) << 2));\\n\\nExpression use to swaps the nibbles. like if num is 0011 0010 then after the below expression it will be 0010 0011.\\n\\n\\tn = (((n & 0xf0f0f0f0) >> 4) | ((n & 0x0f0f0f0f) << 4));\\n\\t\\n\\tThis statement  uses to swap the bytes of an integer. Let num is 00001000 00001100, after the below expression, it will be 00001100 00001000.\\n\\t\\n\\tn = (((n & 0xff00ff00) >> 8) | ((n & 0x00ff00ff) << 8));\\n\\t\\nreturn((n >> 16) | (n << 16));\\nThe above expression uses to swap the half-word of an integer. Means that if the num is 0000000011001110 1000100100000110, after the above result number will be 1000100100000110 0000000011001110.\\n    \\n}"
                    },
                    {
                        "username": "Henton",
                        "content": "My solution show this.\\nRuntime: 2 ms, faster than 98.25% of Java online submissions for Reverse Bits."
                    },
                    {
                        "username": "vikas7",
                        "content": "In Q.190, The function prototype says return type is int (Java language). But for the input 1, the expected output is 2147483648, How can an int type can store that value?\\n\\nThank you"
                    }
                ]
            },
            {
                "id": 1569007,
                "content": [
                    {
                        "username": "gen504240809",
                        "content": "int in java is 32-bit signed number ,the maximum signed number is 2147483647.when the last bit of the input number is '1' and we reverse bits,it will become negative number ,how can we return a positive int number and the number must be larger than 2147483647?"
                    },
                    {
                        "username": "shtian",
                        "content": "## Java ##\\n\\nUse [`>>>`\\\\*][1] instead of `>>`. `>>>`is unsigned right shift, and `>>` is signed.\\n\\nUse [`Integer.parseUnsignedInt`\\\\*][2] and [`Integer.toUnsignedString`\\\\*][3] if you want test your program locally.\\n\\n## JavaScript ##\\n\\nUse [`>>>`\\\\*][4] instead of `>>`. This is as same as Java.\\n\\nAfter `|`, `&`, `~`, `>>`, `<<`, the number was converted ToInt32. But you need return a positive value. So try `return result >>> 0;`. `>>>` will call [`ToUint32`\\\\*][5].\\n\\n\\n  [1]: http://docs.oracle.com/javase/tutorial/java/nutsandbolts/op3.html\\n  [2]: http://docs.oracle.com/javase/8/docs/api/java/lang/Integer.html#parseUnsignedInt-java.lang.String-\\n  [3]: http://docs.oracle.com/javase/8/docs/api/java/lang/Integer.html#toUnsignedString-int-int-\\n  [4]: http://www.ecma-international.org/ecma-262/5.1/#sec-11.7.2\\n  [5]: http://www.ecma-international.org/ecma-262/5.1/#sec-9.6"
                    },
                    {
                        "username": "quarkyy99",
                        "content": "What is wrong with the developer of the question....Theyre saying that input is binary string and the input theyre taking is an integer...\\n"
                    },
                    {
                        "username": "jimmyzzxhlh",
                        "content": "Since the function is forced to return an int, how is it possible to return 2147483648?\\n\\nI've tried to return -2147483648 and it doesn't work."
                    },
                    {
                        "username": "loveytx",
                        "content": "use long long int "
                    },
                    {
                        "username": "daynis",
                        "content": "I have a more of a Java language question. My program failed for 2147483648 as an input. How is Java able to represent 2147483648 as an unsigned int value when it doesn't have any unsigned integer types?In other words, how is the input sent as 2147483648 in an int variable given that the Java language itself doesn't let us hold 2147483648 in an int ?"
                    },
                    {
                        "username": "lordwerneo",
                        "content": "In case if you wonder, if it says that as input you get something like this: \\'00000000000000000000000000000100\\' it means that as input you just got int 4, and to get binary representation, you just need to format or f-string your input as f\\'{input:032b}\\' where input is your variable."
                    },
                    {
                        "username": "ThirteenBeans",
                        "content": "    def reverse_bits(n)\\n        sprintf(\"%.32b\", n).reverse.to_i(2)\\n    end"
                    },
                    {
                        "username": "ajitemk",
                        "content": "uint32_t reverseBits(uint32_t n) {\\n\\nThis below expression use to swap the bits.\\nLet an example, suppose num is 0100, after the above expression it will be 1000.\\n\\n    n = (((n & 0xaaaaaaaa) >> 1) | ((n & 0x55555555) << 1));\\n\\nbelow expression uses to swap the 2 bits of a nibble. Suppose num is 10 00, after the above expression, it will be 00 01.\\n\\nn = (((n & 0xcccccccc) >> 2) | ((n & 0x33333333) << 2));\\n\\nExpression use to swaps the nibbles. like if num is 0011 0010 then after the below expression it will be 0010 0011.\\n\\n\\tn = (((n & 0xf0f0f0f0) >> 4) | ((n & 0x0f0f0f0f) << 4));\\n\\t\\n\\tThis statement  uses to swap the bytes of an integer. Let num is 00001000 00001100, after the below expression, it will be 00001100 00001000.\\n\\t\\n\\tn = (((n & 0xff00ff00) >> 8) | ((n & 0x00ff00ff) << 8));\\n\\t\\nreturn((n >> 16) | (n << 16));\\nThe above expression uses to swap the half-word of an integer. Means that if the num is 0000000011001110 1000100100000110, after the above result number will be 1000100100000110 0000000011001110.\\n    \\n}"
                    },
                    {
                        "username": "Henton",
                        "content": "My solution show this.\\nRuntime: 2 ms, faster than 98.25% of Java online submissions for Reverse Bits."
                    },
                    {
                        "username": "vikas7",
                        "content": "In Q.190, The function prototype says return type is int (Java language). But for the input 1, the expected output is 2147483648, How can an int type can store that value?\\n\\nThank you"
                    }
                ]
            },
            {
                "id": 1565743,
                "content": [
                    {
                        "username": "gen504240809",
                        "content": "int in java is 32-bit signed number ,the maximum signed number is 2147483647.when the last bit of the input number is '1' and we reverse bits,it will become negative number ,how can we return a positive int number and the number must be larger than 2147483647?"
                    },
                    {
                        "username": "shtian",
                        "content": "## Java ##\\n\\nUse [`>>>`\\\\*][1] instead of `>>`. `>>>`is unsigned right shift, and `>>` is signed.\\n\\nUse [`Integer.parseUnsignedInt`\\\\*][2] and [`Integer.toUnsignedString`\\\\*][3] if you want test your program locally.\\n\\n## JavaScript ##\\n\\nUse [`>>>`\\\\*][4] instead of `>>`. This is as same as Java.\\n\\nAfter `|`, `&`, `~`, `>>`, `<<`, the number was converted ToInt32. But you need return a positive value. So try `return result >>> 0;`. `>>>` will call [`ToUint32`\\\\*][5].\\n\\n\\n  [1]: http://docs.oracle.com/javase/tutorial/java/nutsandbolts/op3.html\\n  [2]: http://docs.oracle.com/javase/8/docs/api/java/lang/Integer.html#parseUnsignedInt-java.lang.String-\\n  [3]: http://docs.oracle.com/javase/8/docs/api/java/lang/Integer.html#toUnsignedString-int-int-\\n  [4]: http://www.ecma-international.org/ecma-262/5.1/#sec-11.7.2\\n  [5]: http://www.ecma-international.org/ecma-262/5.1/#sec-9.6"
                    },
                    {
                        "username": "quarkyy99",
                        "content": "What is wrong with the developer of the question....Theyre saying that input is binary string and the input theyre taking is an integer...\\n"
                    },
                    {
                        "username": "jimmyzzxhlh",
                        "content": "Since the function is forced to return an int, how is it possible to return 2147483648?\\n\\nI've tried to return -2147483648 and it doesn't work."
                    },
                    {
                        "username": "loveytx",
                        "content": "use long long int "
                    },
                    {
                        "username": "daynis",
                        "content": "I have a more of a Java language question. My program failed for 2147483648 as an input. How is Java able to represent 2147483648 as an unsigned int value when it doesn't have any unsigned integer types?In other words, how is the input sent as 2147483648 in an int variable given that the Java language itself doesn't let us hold 2147483648 in an int ?"
                    },
                    {
                        "username": "lordwerneo",
                        "content": "In case if you wonder, if it says that as input you get something like this: \\'00000000000000000000000000000100\\' it means that as input you just got int 4, and to get binary representation, you just need to format or f-string your input as f\\'{input:032b}\\' where input is your variable."
                    },
                    {
                        "username": "ThirteenBeans",
                        "content": "    def reverse_bits(n)\\n        sprintf(\"%.32b\", n).reverse.to_i(2)\\n    end"
                    },
                    {
                        "username": "ajitemk",
                        "content": "uint32_t reverseBits(uint32_t n) {\\n\\nThis below expression use to swap the bits.\\nLet an example, suppose num is 0100, after the above expression it will be 1000.\\n\\n    n = (((n & 0xaaaaaaaa) >> 1) | ((n & 0x55555555) << 1));\\n\\nbelow expression uses to swap the 2 bits of a nibble. Suppose num is 10 00, after the above expression, it will be 00 01.\\n\\nn = (((n & 0xcccccccc) >> 2) | ((n & 0x33333333) << 2));\\n\\nExpression use to swaps the nibbles. like if num is 0011 0010 then after the below expression it will be 0010 0011.\\n\\n\\tn = (((n & 0xf0f0f0f0) >> 4) | ((n & 0x0f0f0f0f) << 4));\\n\\t\\n\\tThis statement  uses to swap the bytes of an integer. Let num is 00001000 00001100, after the below expression, it will be 00001100 00001000.\\n\\t\\n\\tn = (((n & 0xff00ff00) >> 8) | ((n & 0x00ff00ff) << 8));\\n\\t\\nreturn((n >> 16) | (n << 16));\\nThe above expression uses to swap the half-word of an integer. Means that if the num is 0000000011001110 1000100100000110, after the above result number will be 1000100100000110 0000000011001110.\\n    \\n}"
                    },
                    {
                        "username": "Henton",
                        "content": "My solution show this.\\nRuntime: 2 ms, faster than 98.25% of Java online submissions for Reverse Bits."
                    },
                    {
                        "username": "vikas7",
                        "content": "In Q.190, The function prototype says return type is int (Java language). But for the input 1, the expected output is 2147483648, How can an int type can store that value?\\n\\nThank you"
                    }
                ]
            },
            {
                "id": 1565429,
                "content": [
                    {
                        "username": "gen504240809",
                        "content": "int in java is 32-bit signed number ,the maximum signed number is 2147483647.when the last bit of the input number is '1' and we reverse bits,it will become negative number ,how can we return a positive int number and the number must be larger than 2147483647?"
                    },
                    {
                        "username": "shtian",
                        "content": "## Java ##\\n\\nUse [`>>>`\\\\*][1] instead of `>>`. `>>>`is unsigned right shift, and `>>` is signed.\\n\\nUse [`Integer.parseUnsignedInt`\\\\*][2] and [`Integer.toUnsignedString`\\\\*][3] if you want test your program locally.\\n\\n## JavaScript ##\\n\\nUse [`>>>`\\\\*][4] instead of `>>`. This is as same as Java.\\n\\nAfter `|`, `&`, `~`, `>>`, `<<`, the number was converted ToInt32. But you need return a positive value. So try `return result >>> 0;`. `>>>` will call [`ToUint32`\\\\*][5].\\n\\n\\n  [1]: http://docs.oracle.com/javase/tutorial/java/nutsandbolts/op3.html\\n  [2]: http://docs.oracle.com/javase/8/docs/api/java/lang/Integer.html#parseUnsignedInt-java.lang.String-\\n  [3]: http://docs.oracle.com/javase/8/docs/api/java/lang/Integer.html#toUnsignedString-int-int-\\n  [4]: http://www.ecma-international.org/ecma-262/5.1/#sec-11.7.2\\n  [5]: http://www.ecma-international.org/ecma-262/5.1/#sec-9.6"
                    },
                    {
                        "username": "quarkyy99",
                        "content": "What is wrong with the developer of the question....Theyre saying that input is binary string and the input theyre taking is an integer...\\n"
                    },
                    {
                        "username": "jimmyzzxhlh",
                        "content": "Since the function is forced to return an int, how is it possible to return 2147483648?\\n\\nI've tried to return -2147483648 and it doesn't work."
                    },
                    {
                        "username": "loveytx",
                        "content": "use long long int "
                    },
                    {
                        "username": "daynis",
                        "content": "I have a more of a Java language question. My program failed for 2147483648 as an input. How is Java able to represent 2147483648 as an unsigned int value when it doesn't have any unsigned integer types?In other words, how is the input sent as 2147483648 in an int variable given that the Java language itself doesn't let us hold 2147483648 in an int ?"
                    },
                    {
                        "username": "lordwerneo",
                        "content": "In case if you wonder, if it says that as input you get something like this: \\'00000000000000000000000000000100\\' it means that as input you just got int 4, and to get binary representation, you just need to format or f-string your input as f\\'{input:032b}\\' where input is your variable."
                    },
                    {
                        "username": "ThirteenBeans",
                        "content": "    def reverse_bits(n)\\n        sprintf(\"%.32b\", n).reverse.to_i(2)\\n    end"
                    },
                    {
                        "username": "ajitemk",
                        "content": "uint32_t reverseBits(uint32_t n) {\\n\\nThis below expression use to swap the bits.\\nLet an example, suppose num is 0100, after the above expression it will be 1000.\\n\\n    n = (((n & 0xaaaaaaaa) >> 1) | ((n & 0x55555555) << 1));\\n\\nbelow expression uses to swap the 2 bits of a nibble. Suppose num is 10 00, after the above expression, it will be 00 01.\\n\\nn = (((n & 0xcccccccc) >> 2) | ((n & 0x33333333) << 2));\\n\\nExpression use to swaps the nibbles. like if num is 0011 0010 then after the below expression it will be 0010 0011.\\n\\n\\tn = (((n & 0xf0f0f0f0) >> 4) | ((n & 0x0f0f0f0f) << 4));\\n\\t\\n\\tThis statement  uses to swap the bytes of an integer. Let num is 00001000 00001100, after the below expression, it will be 00001100 00001000.\\n\\t\\n\\tn = (((n & 0xff00ff00) >> 8) | ((n & 0x00ff00ff) << 8));\\n\\t\\nreturn((n >> 16) | (n << 16));\\nThe above expression uses to swap the half-word of an integer. Means that if the num is 0000000011001110 1000100100000110, after the above result number will be 1000100100000110 0000000011001110.\\n    \\n}"
                    },
                    {
                        "username": "Henton",
                        "content": "My solution show this.\\nRuntime: 2 ms, faster than 98.25% of Java online submissions for Reverse Bits."
                    },
                    {
                        "username": "vikas7",
                        "content": "In Q.190, The function prototype says return type is int (Java language). But for the input 1, the expected output is 2147483648, How can an int type can store that value?\\n\\nThank you"
                    }
                ]
            },
            {
                "id": 1990124,
                "content": [
                    {
                        "username": "gen504240809",
                        "content": "int in java is 32-bit signed number ,the maximum signed number is 2147483647.when the last bit of the input number is '1' and we reverse bits,it will become negative number ,how can we return a positive int number and the number must be larger than 2147483647?"
                    },
                    {
                        "username": "shtian",
                        "content": "## Java ##\\n\\nUse [`>>>`\\\\*][1] instead of `>>`. `>>>`is unsigned right shift, and `>>` is signed.\\n\\nUse [`Integer.parseUnsignedInt`\\\\*][2] and [`Integer.toUnsignedString`\\\\*][3] if you want test your program locally.\\n\\n## JavaScript ##\\n\\nUse [`>>>`\\\\*][4] instead of `>>`. This is as same as Java.\\n\\nAfter `|`, `&`, `~`, `>>`, `<<`, the number was converted ToInt32. But you need return a positive value. So try `return result >>> 0;`. `>>>` will call [`ToUint32`\\\\*][5].\\n\\n\\n  [1]: http://docs.oracle.com/javase/tutorial/java/nutsandbolts/op3.html\\n  [2]: http://docs.oracle.com/javase/8/docs/api/java/lang/Integer.html#parseUnsignedInt-java.lang.String-\\n  [3]: http://docs.oracle.com/javase/8/docs/api/java/lang/Integer.html#toUnsignedString-int-int-\\n  [4]: http://www.ecma-international.org/ecma-262/5.1/#sec-11.7.2\\n  [5]: http://www.ecma-international.org/ecma-262/5.1/#sec-9.6"
                    },
                    {
                        "username": "quarkyy99",
                        "content": "What is wrong with the developer of the question....Theyre saying that input is binary string and the input theyre taking is an integer...\\n"
                    },
                    {
                        "username": "jimmyzzxhlh",
                        "content": "Since the function is forced to return an int, how is it possible to return 2147483648?\\n\\nI've tried to return -2147483648 and it doesn't work."
                    },
                    {
                        "username": "loveytx",
                        "content": "use long long int "
                    },
                    {
                        "username": "daynis",
                        "content": "I have a more of a Java language question. My program failed for 2147483648 as an input. How is Java able to represent 2147483648 as an unsigned int value when it doesn't have any unsigned integer types?In other words, how is the input sent as 2147483648 in an int variable given that the Java language itself doesn't let us hold 2147483648 in an int ?"
                    },
                    {
                        "username": "lordwerneo",
                        "content": "In case if you wonder, if it says that as input you get something like this: \\'00000000000000000000000000000100\\' it means that as input you just got int 4, and to get binary representation, you just need to format or f-string your input as f\\'{input:032b}\\' where input is your variable."
                    },
                    {
                        "username": "ThirteenBeans",
                        "content": "    def reverse_bits(n)\\n        sprintf(\"%.32b\", n).reverse.to_i(2)\\n    end"
                    },
                    {
                        "username": "ajitemk",
                        "content": "uint32_t reverseBits(uint32_t n) {\\n\\nThis below expression use to swap the bits.\\nLet an example, suppose num is 0100, after the above expression it will be 1000.\\n\\n    n = (((n & 0xaaaaaaaa) >> 1) | ((n & 0x55555555) << 1));\\n\\nbelow expression uses to swap the 2 bits of a nibble. Suppose num is 10 00, after the above expression, it will be 00 01.\\n\\nn = (((n & 0xcccccccc) >> 2) | ((n & 0x33333333) << 2));\\n\\nExpression use to swaps the nibbles. like if num is 0011 0010 then after the below expression it will be 0010 0011.\\n\\n\\tn = (((n & 0xf0f0f0f0) >> 4) | ((n & 0x0f0f0f0f) << 4));\\n\\t\\n\\tThis statement  uses to swap the bytes of an integer. Let num is 00001000 00001100, after the below expression, it will be 00001100 00001000.\\n\\t\\n\\tn = (((n & 0xff00ff00) >> 8) | ((n & 0x00ff00ff) << 8));\\n\\t\\nreturn((n >> 16) | (n << 16));\\nThe above expression uses to swap the half-word of an integer. Means that if the num is 0000000011001110 1000100100000110, after the above result number will be 1000100100000110 0000000011001110.\\n    \\n}"
                    },
                    {
                        "username": "Henton",
                        "content": "My solution show this.\\nRuntime: 2 ms, faster than 98.25% of Java online submissions for Reverse Bits."
                    },
                    {
                        "username": "vikas7",
                        "content": "In Q.190, The function prototype says return type is int (Java language). But for the input 1, the expected output is 2147483648, How can an int type can store that value?\\n\\nThank you"
                    }
                ]
            },
            {
                "id": 1565947,
                "content": [
                    {
                        "username": "gen504240809",
                        "content": "int in java is 32-bit signed number ,the maximum signed number is 2147483647.when the last bit of the input number is '1' and we reverse bits,it will become negative number ,how can we return a positive int number and the number must be larger than 2147483647?"
                    },
                    {
                        "username": "shtian",
                        "content": "## Java ##\\n\\nUse [`>>>`\\\\*][1] instead of `>>`. `>>>`is unsigned right shift, and `>>` is signed.\\n\\nUse [`Integer.parseUnsignedInt`\\\\*][2] and [`Integer.toUnsignedString`\\\\*][3] if you want test your program locally.\\n\\n## JavaScript ##\\n\\nUse [`>>>`\\\\*][4] instead of `>>`. This is as same as Java.\\n\\nAfter `|`, `&`, `~`, `>>`, `<<`, the number was converted ToInt32. But you need return a positive value. So try `return result >>> 0;`. `>>>` will call [`ToUint32`\\\\*][5].\\n\\n\\n  [1]: http://docs.oracle.com/javase/tutorial/java/nutsandbolts/op3.html\\n  [2]: http://docs.oracle.com/javase/8/docs/api/java/lang/Integer.html#parseUnsignedInt-java.lang.String-\\n  [3]: http://docs.oracle.com/javase/8/docs/api/java/lang/Integer.html#toUnsignedString-int-int-\\n  [4]: http://www.ecma-international.org/ecma-262/5.1/#sec-11.7.2\\n  [5]: http://www.ecma-international.org/ecma-262/5.1/#sec-9.6"
                    },
                    {
                        "username": "quarkyy99",
                        "content": "What is wrong with the developer of the question....Theyre saying that input is binary string and the input theyre taking is an integer...\\n"
                    },
                    {
                        "username": "jimmyzzxhlh",
                        "content": "Since the function is forced to return an int, how is it possible to return 2147483648?\\n\\nI've tried to return -2147483648 and it doesn't work."
                    },
                    {
                        "username": "loveytx",
                        "content": "use long long int "
                    },
                    {
                        "username": "daynis",
                        "content": "I have a more of a Java language question. My program failed for 2147483648 as an input. How is Java able to represent 2147483648 as an unsigned int value when it doesn't have any unsigned integer types?In other words, how is the input sent as 2147483648 in an int variable given that the Java language itself doesn't let us hold 2147483648 in an int ?"
                    },
                    {
                        "username": "lordwerneo",
                        "content": "In case if you wonder, if it says that as input you get something like this: \\'00000000000000000000000000000100\\' it means that as input you just got int 4, and to get binary representation, you just need to format or f-string your input as f\\'{input:032b}\\' where input is your variable."
                    },
                    {
                        "username": "ThirteenBeans",
                        "content": "    def reverse_bits(n)\\n        sprintf(\"%.32b\", n).reverse.to_i(2)\\n    end"
                    },
                    {
                        "username": "ajitemk",
                        "content": "uint32_t reverseBits(uint32_t n) {\\n\\nThis below expression use to swap the bits.\\nLet an example, suppose num is 0100, after the above expression it will be 1000.\\n\\n    n = (((n & 0xaaaaaaaa) >> 1) | ((n & 0x55555555) << 1));\\n\\nbelow expression uses to swap the 2 bits of a nibble. Suppose num is 10 00, after the above expression, it will be 00 01.\\n\\nn = (((n & 0xcccccccc) >> 2) | ((n & 0x33333333) << 2));\\n\\nExpression use to swaps the nibbles. like if num is 0011 0010 then after the below expression it will be 0010 0011.\\n\\n\\tn = (((n & 0xf0f0f0f0) >> 4) | ((n & 0x0f0f0f0f) << 4));\\n\\t\\n\\tThis statement  uses to swap the bytes of an integer. Let num is 00001000 00001100, after the below expression, it will be 00001100 00001000.\\n\\t\\n\\tn = (((n & 0xff00ff00) >> 8) | ((n & 0x00ff00ff) << 8));\\n\\t\\nreturn((n >> 16) | (n << 16));\\nThe above expression uses to swap the half-word of an integer. Means that if the num is 0000000011001110 1000100100000110, after the above result number will be 1000100100000110 0000000011001110.\\n    \\n}"
                    },
                    {
                        "username": "Henton",
                        "content": "My solution show this.\\nRuntime: 2 ms, faster than 98.25% of Java online submissions for Reverse Bits."
                    },
                    {
                        "username": "vikas7",
                        "content": "In Q.190, The function prototype says return type is int (Java language). But for the input 1, the expected output is 2147483648, How can an int type can store that value?\\n\\nThank you"
                    }
                ]
            },
            {
                "id": 1566836,
                "content": [
                    {
                        "username": "gen504240809",
                        "content": "int in java is 32-bit signed number ,the maximum signed number is 2147483647.when the last bit of the input number is '1' and we reverse bits,it will become negative number ,how can we return a positive int number and the number must be larger than 2147483647?"
                    },
                    {
                        "username": "shtian",
                        "content": "## Java ##\\n\\nUse [`>>>`\\\\*][1] instead of `>>`. `>>>`is unsigned right shift, and `>>` is signed.\\n\\nUse [`Integer.parseUnsignedInt`\\\\*][2] and [`Integer.toUnsignedString`\\\\*][3] if you want test your program locally.\\n\\n## JavaScript ##\\n\\nUse [`>>>`\\\\*][4] instead of `>>`. This is as same as Java.\\n\\nAfter `|`, `&`, `~`, `>>`, `<<`, the number was converted ToInt32. But you need return a positive value. So try `return result >>> 0;`. `>>>` will call [`ToUint32`\\\\*][5].\\n\\n\\n  [1]: http://docs.oracle.com/javase/tutorial/java/nutsandbolts/op3.html\\n  [2]: http://docs.oracle.com/javase/8/docs/api/java/lang/Integer.html#parseUnsignedInt-java.lang.String-\\n  [3]: http://docs.oracle.com/javase/8/docs/api/java/lang/Integer.html#toUnsignedString-int-int-\\n  [4]: http://www.ecma-international.org/ecma-262/5.1/#sec-11.7.2\\n  [5]: http://www.ecma-international.org/ecma-262/5.1/#sec-9.6"
                    },
                    {
                        "username": "quarkyy99",
                        "content": "What is wrong with the developer of the question....Theyre saying that input is binary string and the input theyre taking is an integer...\\n"
                    },
                    {
                        "username": "jimmyzzxhlh",
                        "content": "Since the function is forced to return an int, how is it possible to return 2147483648?\\n\\nI've tried to return -2147483648 and it doesn't work."
                    },
                    {
                        "username": "loveytx",
                        "content": "use long long int "
                    },
                    {
                        "username": "daynis",
                        "content": "I have a more of a Java language question. My program failed for 2147483648 as an input. How is Java able to represent 2147483648 as an unsigned int value when it doesn't have any unsigned integer types?In other words, how is the input sent as 2147483648 in an int variable given that the Java language itself doesn't let us hold 2147483648 in an int ?"
                    },
                    {
                        "username": "lordwerneo",
                        "content": "In case if you wonder, if it says that as input you get something like this: \\'00000000000000000000000000000100\\' it means that as input you just got int 4, and to get binary representation, you just need to format or f-string your input as f\\'{input:032b}\\' where input is your variable."
                    },
                    {
                        "username": "ThirteenBeans",
                        "content": "    def reverse_bits(n)\\n        sprintf(\"%.32b\", n).reverse.to_i(2)\\n    end"
                    },
                    {
                        "username": "ajitemk",
                        "content": "uint32_t reverseBits(uint32_t n) {\\n\\nThis below expression use to swap the bits.\\nLet an example, suppose num is 0100, after the above expression it will be 1000.\\n\\n    n = (((n & 0xaaaaaaaa) >> 1) | ((n & 0x55555555) << 1));\\n\\nbelow expression uses to swap the 2 bits of a nibble. Suppose num is 10 00, after the above expression, it will be 00 01.\\n\\nn = (((n & 0xcccccccc) >> 2) | ((n & 0x33333333) << 2));\\n\\nExpression use to swaps the nibbles. like if num is 0011 0010 then after the below expression it will be 0010 0011.\\n\\n\\tn = (((n & 0xf0f0f0f0) >> 4) | ((n & 0x0f0f0f0f) << 4));\\n\\t\\n\\tThis statement  uses to swap the bytes of an integer. Let num is 00001000 00001100, after the below expression, it will be 00001100 00001000.\\n\\t\\n\\tn = (((n & 0xff00ff00) >> 8) | ((n & 0x00ff00ff) << 8));\\n\\t\\nreturn((n >> 16) | (n << 16));\\nThe above expression uses to swap the half-word of an integer. Means that if the num is 0000000011001110 1000100100000110, after the above result number will be 1000100100000110 0000000011001110.\\n    \\n}"
                    },
                    {
                        "username": "Henton",
                        "content": "My solution show this.\\nRuntime: 2 ms, faster than 98.25% of Java online submissions for Reverse Bits."
                    },
                    {
                        "username": "vikas7",
                        "content": "In Q.190, The function prototype says return type is int (Java language). But for the input 1, the expected output is 2147483648, How can an int type can store that value?\\n\\nThank you"
                    }
                ]
            },
            {
                "id": 1576318,
                "content": [
                    {
                        "username": "gen504240809",
                        "content": "int in java is 32-bit signed number ,the maximum signed number is 2147483647.when the last bit of the input number is '1' and we reverse bits,it will become negative number ,how can we return a positive int number and the number must be larger than 2147483647?"
                    },
                    {
                        "username": "shtian",
                        "content": "## Java ##\\n\\nUse [`>>>`\\\\*][1] instead of `>>`. `>>>`is unsigned right shift, and `>>` is signed.\\n\\nUse [`Integer.parseUnsignedInt`\\\\*][2] and [`Integer.toUnsignedString`\\\\*][3] if you want test your program locally.\\n\\n## JavaScript ##\\n\\nUse [`>>>`\\\\*][4] instead of `>>`. This is as same as Java.\\n\\nAfter `|`, `&`, `~`, `>>`, `<<`, the number was converted ToInt32. But you need return a positive value. So try `return result >>> 0;`. `>>>` will call [`ToUint32`\\\\*][5].\\n\\n\\n  [1]: http://docs.oracle.com/javase/tutorial/java/nutsandbolts/op3.html\\n  [2]: http://docs.oracle.com/javase/8/docs/api/java/lang/Integer.html#parseUnsignedInt-java.lang.String-\\n  [3]: http://docs.oracle.com/javase/8/docs/api/java/lang/Integer.html#toUnsignedString-int-int-\\n  [4]: http://www.ecma-international.org/ecma-262/5.1/#sec-11.7.2\\n  [5]: http://www.ecma-international.org/ecma-262/5.1/#sec-9.6"
                    },
                    {
                        "username": "quarkyy99",
                        "content": "What is wrong with the developer of the question....Theyre saying that input is binary string and the input theyre taking is an integer...\\n"
                    },
                    {
                        "username": "jimmyzzxhlh",
                        "content": "Since the function is forced to return an int, how is it possible to return 2147483648?\\n\\nI've tried to return -2147483648 and it doesn't work."
                    },
                    {
                        "username": "loveytx",
                        "content": "use long long int "
                    },
                    {
                        "username": "daynis",
                        "content": "I have a more of a Java language question. My program failed for 2147483648 as an input. How is Java able to represent 2147483648 as an unsigned int value when it doesn't have any unsigned integer types?In other words, how is the input sent as 2147483648 in an int variable given that the Java language itself doesn't let us hold 2147483648 in an int ?"
                    },
                    {
                        "username": "lordwerneo",
                        "content": "In case if you wonder, if it says that as input you get something like this: \\'00000000000000000000000000000100\\' it means that as input you just got int 4, and to get binary representation, you just need to format or f-string your input as f\\'{input:032b}\\' where input is your variable."
                    },
                    {
                        "username": "ThirteenBeans",
                        "content": "    def reverse_bits(n)\\n        sprintf(\"%.32b\", n).reverse.to_i(2)\\n    end"
                    },
                    {
                        "username": "ajitemk",
                        "content": "uint32_t reverseBits(uint32_t n) {\\n\\nThis below expression use to swap the bits.\\nLet an example, suppose num is 0100, after the above expression it will be 1000.\\n\\n    n = (((n & 0xaaaaaaaa) >> 1) | ((n & 0x55555555) << 1));\\n\\nbelow expression uses to swap the 2 bits of a nibble. Suppose num is 10 00, after the above expression, it will be 00 01.\\n\\nn = (((n & 0xcccccccc) >> 2) | ((n & 0x33333333) << 2));\\n\\nExpression use to swaps the nibbles. like if num is 0011 0010 then after the below expression it will be 0010 0011.\\n\\n\\tn = (((n & 0xf0f0f0f0) >> 4) | ((n & 0x0f0f0f0f) << 4));\\n\\t\\n\\tThis statement  uses to swap the bytes of an integer. Let num is 00001000 00001100, after the below expression, it will be 00001100 00001000.\\n\\t\\n\\tn = (((n & 0xff00ff00) >> 8) | ((n & 0x00ff00ff) << 8));\\n\\t\\nreturn((n >> 16) | (n << 16));\\nThe above expression uses to swap the half-word of an integer. Means that if the num is 0000000011001110 1000100100000110, after the above result number will be 1000100100000110 0000000011001110.\\n    \\n}"
                    },
                    {
                        "username": "Henton",
                        "content": "My solution show this.\\nRuntime: 2 ms, faster than 98.25% of Java online submissions for Reverse Bits."
                    },
                    {
                        "username": "vikas7",
                        "content": "In Q.190, The function prototype says return type is int (Java language). But for the input 1, the expected output is 2147483648, How can an int type can store that value?\\n\\nThank you"
                    }
                ]
            },
            {
                "id": 1569006,
                "content": [
                    {
                        "username": "gen504240809",
                        "content": "int in java is 32-bit signed number ,the maximum signed number is 2147483647.when the last bit of the input number is '1' and we reverse bits,it will become negative number ,how can we return a positive int number and the number must be larger than 2147483647?"
                    },
                    {
                        "username": "shtian",
                        "content": "## Java ##\\n\\nUse [`>>>`\\\\*][1] instead of `>>`. `>>>`is unsigned right shift, and `>>` is signed.\\n\\nUse [`Integer.parseUnsignedInt`\\\\*][2] and [`Integer.toUnsignedString`\\\\*][3] if you want test your program locally.\\n\\n## JavaScript ##\\n\\nUse [`>>>`\\\\*][4] instead of `>>`. This is as same as Java.\\n\\nAfter `|`, `&`, `~`, `>>`, `<<`, the number was converted ToInt32. But you need return a positive value. So try `return result >>> 0;`. `>>>` will call [`ToUint32`\\\\*][5].\\n\\n\\n  [1]: http://docs.oracle.com/javase/tutorial/java/nutsandbolts/op3.html\\n  [2]: http://docs.oracle.com/javase/8/docs/api/java/lang/Integer.html#parseUnsignedInt-java.lang.String-\\n  [3]: http://docs.oracle.com/javase/8/docs/api/java/lang/Integer.html#toUnsignedString-int-int-\\n  [4]: http://www.ecma-international.org/ecma-262/5.1/#sec-11.7.2\\n  [5]: http://www.ecma-international.org/ecma-262/5.1/#sec-9.6"
                    },
                    {
                        "username": "quarkyy99",
                        "content": "What is wrong with the developer of the question....Theyre saying that input is binary string and the input theyre taking is an integer...\\n"
                    },
                    {
                        "username": "jimmyzzxhlh",
                        "content": "Since the function is forced to return an int, how is it possible to return 2147483648?\\n\\nI've tried to return -2147483648 and it doesn't work."
                    },
                    {
                        "username": "loveytx",
                        "content": "use long long int "
                    },
                    {
                        "username": "daynis",
                        "content": "I have a more of a Java language question. My program failed for 2147483648 as an input. How is Java able to represent 2147483648 as an unsigned int value when it doesn't have any unsigned integer types?In other words, how is the input sent as 2147483648 in an int variable given that the Java language itself doesn't let us hold 2147483648 in an int ?"
                    },
                    {
                        "username": "lordwerneo",
                        "content": "In case if you wonder, if it says that as input you get something like this: \\'00000000000000000000000000000100\\' it means that as input you just got int 4, and to get binary representation, you just need to format or f-string your input as f\\'{input:032b}\\' where input is your variable."
                    },
                    {
                        "username": "ThirteenBeans",
                        "content": "    def reverse_bits(n)\\n        sprintf(\"%.32b\", n).reverse.to_i(2)\\n    end"
                    },
                    {
                        "username": "ajitemk",
                        "content": "uint32_t reverseBits(uint32_t n) {\\n\\nThis below expression use to swap the bits.\\nLet an example, suppose num is 0100, after the above expression it will be 1000.\\n\\n    n = (((n & 0xaaaaaaaa) >> 1) | ((n & 0x55555555) << 1));\\n\\nbelow expression uses to swap the 2 bits of a nibble. Suppose num is 10 00, after the above expression, it will be 00 01.\\n\\nn = (((n & 0xcccccccc) >> 2) | ((n & 0x33333333) << 2));\\n\\nExpression use to swaps the nibbles. like if num is 0011 0010 then after the below expression it will be 0010 0011.\\n\\n\\tn = (((n & 0xf0f0f0f0) >> 4) | ((n & 0x0f0f0f0f) << 4));\\n\\t\\n\\tThis statement  uses to swap the bytes of an integer. Let num is 00001000 00001100, after the below expression, it will be 00001100 00001000.\\n\\t\\n\\tn = (((n & 0xff00ff00) >> 8) | ((n & 0x00ff00ff) << 8));\\n\\t\\nreturn((n >> 16) | (n << 16));\\nThe above expression uses to swap the half-word of an integer. Means that if the num is 0000000011001110 1000100100000110, after the above result number will be 1000100100000110 0000000011001110.\\n    \\n}"
                    },
                    {
                        "username": "Henton",
                        "content": "My solution show this.\\nRuntime: 2 ms, faster than 98.25% of Java online submissions for Reverse Bits."
                    },
                    {
                        "username": "vikas7",
                        "content": "In Q.190, The function prototype says return type is int (Java language). But for the input 1, the expected output is 2147483648, How can an int type can store that value?\\n\\nThank you"
                    }
                ]
            },
            {
                "id": 1570134,
                "content": [
                    {
                        "username": "gen504240809",
                        "content": "int in java is 32-bit signed number ,the maximum signed number is 2147483647.when the last bit of the input number is '1' and we reverse bits,it will become negative number ,how can we return a positive int number and the number must be larger than 2147483647?"
                    },
                    {
                        "username": "shtian",
                        "content": "## Java ##\\n\\nUse [`>>>`\\\\*][1] instead of `>>`. `>>>`is unsigned right shift, and `>>` is signed.\\n\\nUse [`Integer.parseUnsignedInt`\\\\*][2] and [`Integer.toUnsignedString`\\\\*][3] if you want test your program locally.\\n\\n## JavaScript ##\\n\\nUse [`>>>`\\\\*][4] instead of `>>`. This is as same as Java.\\n\\nAfter `|`, `&`, `~`, `>>`, `<<`, the number was converted ToInt32. But you need return a positive value. So try `return result >>> 0;`. `>>>` will call [`ToUint32`\\\\*][5].\\n\\n\\n  [1]: http://docs.oracle.com/javase/tutorial/java/nutsandbolts/op3.html\\n  [2]: http://docs.oracle.com/javase/8/docs/api/java/lang/Integer.html#parseUnsignedInt-java.lang.String-\\n  [3]: http://docs.oracle.com/javase/8/docs/api/java/lang/Integer.html#toUnsignedString-int-int-\\n  [4]: http://www.ecma-international.org/ecma-262/5.1/#sec-11.7.2\\n  [5]: http://www.ecma-international.org/ecma-262/5.1/#sec-9.6"
                    },
                    {
                        "username": "quarkyy99",
                        "content": "What is wrong with the developer of the question....Theyre saying that input is binary string and the input theyre taking is an integer...\\n"
                    },
                    {
                        "username": "jimmyzzxhlh",
                        "content": "Since the function is forced to return an int, how is it possible to return 2147483648?\\n\\nI've tried to return -2147483648 and it doesn't work."
                    },
                    {
                        "username": "loveytx",
                        "content": "use long long int "
                    },
                    {
                        "username": "daynis",
                        "content": "I have a more of a Java language question. My program failed for 2147483648 as an input. How is Java able to represent 2147483648 as an unsigned int value when it doesn't have any unsigned integer types?In other words, how is the input sent as 2147483648 in an int variable given that the Java language itself doesn't let us hold 2147483648 in an int ?"
                    },
                    {
                        "username": "lordwerneo",
                        "content": "In case if you wonder, if it says that as input you get something like this: \\'00000000000000000000000000000100\\' it means that as input you just got int 4, and to get binary representation, you just need to format or f-string your input as f\\'{input:032b}\\' where input is your variable."
                    },
                    {
                        "username": "ThirteenBeans",
                        "content": "    def reverse_bits(n)\\n        sprintf(\"%.32b\", n).reverse.to_i(2)\\n    end"
                    },
                    {
                        "username": "ajitemk",
                        "content": "uint32_t reverseBits(uint32_t n) {\\n\\nThis below expression use to swap the bits.\\nLet an example, suppose num is 0100, after the above expression it will be 1000.\\n\\n    n = (((n & 0xaaaaaaaa) >> 1) | ((n & 0x55555555) << 1));\\n\\nbelow expression uses to swap the 2 bits of a nibble. Suppose num is 10 00, after the above expression, it will be 00 01.\\n\\nn = (((n & 0xcccccccc) >> 2) | ((n & 0x33333333) << 2));\\n\\nExpression use to swaps the nibbles. like if num is 0011 0010 then after the below expression it will be 0010 0011.\\n\\n\\tn = (((n & 0xf0f0f0f0) >> 4) | ((n & 0x0f0f0f0f) << 4));\\n\\t\\n\\tThis statement  uses to swap the bytes of an integer. Let num is 00001000 00001100, after the below expression, it will be 00001100 00001000.\\n\\t\\n\\tn = (((n & 0xff00ff00) >> 8) | ((n & 0x00ff00ff) << 8));\\n\\t\\nreturn((n >> 16) | (n << 16));\\nThe above expression uses to swap the half-word of an integer. Means that if the num is 0000000011001110 1000100100000110, after the above result number will be 1000100100000110 0000000011001110.\\n    \\n}"
                    },
                    {
                        "username": "Henton",
                        "content": "My solution show this.\\nRuntime: 2 ms, faster than 98.25% of Java online submissions for Reverse Bits."
                    },
                    {
                        "username": "vikas7",
                        "content": "In Q.190, The function prototype says return type is int (Java language). But for the input 1, the expected output is 2147483648, How can an int type can store that value?\\n\\nThank you"
                    }
                ]
            },
            {
                "id": 1569405,
                "content": [
                    {
                        "username": "gen504240809",
                        "content": "int in java is 32-bit signed number ,the maximum signed number is 2147483647.when the last bit of the input number is '1' and we reverse bits,it will become negative number ,how can we return a positive int number and the number must be larger than 2147483647?"
                    },
                    {
                        "username": "shtian",
                        "content": "## Java ##\\n\\nUse [`>>>`\\\\*][1] instead of `>>`. `>>>`is unsigned right shift, and `>>` is signed.\\n\\nUse [`Integer.parseUnsignedInt`\\\\*][2] and [`Integer.toUnsignedString`\\\\*][3] if you want test your program locally.\\n\\n## JavaScript ##\\n\\nUse [`>>>`\\\\*][4] instead of `>>`. This is as same as Java.\\n\\nAfter `|`, `&`, `~`, `>>`, `<<`, the number was converted ToInt32. But you need return a positive value. So try `return result >>> 0;`. `>>>` will call [`ToUint32`\\\\*][5].\\n\\n\\n  [1]: http://docs.oracle.com/javase/tutorial/java/nutsandbolts/op3.html\\n  [2]: http://docs.oracle.com/javase/8/docs/api/java/lang/Integer.html#parseUnsignedInt-java.lang.String-\\n  [3]: http://docs.oracle.com/javase/8/docs/api/java/lang/Integer.html#toUnsignedString-int-int-\\n  [4]: http://www.ecma-international.org/ecma-262/5.1/#sec-11.7.2\\n  [5]: http://www.ecma-international.org/ecma-262/5.1/#sec-9.6"
                    },
                    {
                        "username": "quarkyy99",
                        "content": "What is wrong with the developer of the question....Theyre saying that input is binary string and the input theyre taking is an integer...\\n"
                    },
                    {
                        "username": "jimmyzzxhlh",
                        "content": "Since the function is forced to return an int, how is it possible to return 2147483648?\\n\\nI've tried to return -2147483648 and it doesn't work."
                    },
                    {
                        "username": "loveytx",
                        "content": "use long long int "
                    },
                    {
                        "username": "daynis",
                        "content": "I have a more of a Java language question. My program failed for 2147483648 as an input. How is Java able to represent 2147483648 as an unsigned int value when it doesn't have any unsigned integer types?In other words, how is the input sent as 2147483648 in an int variable given that the Java language itself doesn't let us hold 2147483648 in an int ?"
                    },
                    {
                        "username": "lordwerneo",
                        "content": "In case if you wonder, if it says that as input you get something like this: \\'00000000000000000000000000000100\\' it means that as input you just got int 4, and to get binary representation, you just need to format or f-string your input as f\\'{input:032b}\\' where input is your variable."
                    },
                    {
                        "username": "ThirteenBeans",
                        "content": "    def reverse_bits(n)\\n        sprintf(\"%.32b\", n).reverse.to_i(2)\\n    end"
                    },
                    {
                        "username": "ajitemk",
                        "content": "uint32_t reverseBits(uint32_t n) {\\n\\nThis below expression use to swap the bits.\\nLet an example, suppose num is 0100, after the above expression it will be 1000.\\n\\n    n = (((n & 0xaaaaaaaa) >> 1) | ((n & 0x55555555) << 1));\\n\\nbelow expression uses to swap the 2 bits of a nibble. Suppose num is 10 00, after the above expression, it will be 00 01.\\n\\nn = (((n & 0xcccccccc) >> 2) | ((n & 0x33333333) << 2));\\n\\nExpression use to swaps the nibbles. like if num is 0011 0010 then after the below expression it will be 0010 0011.\\n\\n\\tn = (((n & 0xf0f0f0f0) >> 4) | ((n & 0x0f0f0f0f) << 4));\\n\\t\\n\\tThis statement  uses to swap the bytes of an integer. Let num is 00001000 00001100, after the below expression, it will be 00001100 00001000.\\n\\t\\n\\tn = (((n & 0xff00ff00) >> 8) | ((n & 0x00ff00ff) << 8));\\n\\t\\nreturn((n >> 16) | (n << 16));\\nThe above expression uses to swap the half-word of an integer. Means that if the num is 0000000011001110 1000100100000110, after the above result number will be 1000100100000110 0000000011001110.\\n    \\n}"
                    },
                    {
                        "username": "Henton",
                        "content": "My solution show this.\\nRuntime: 2 ms, faster than 98.25% of Java online submissions for Reverse Bits."
                    },
                    {
                        "username": "vikas7",
                        "content": "In Q.190, The function prototype says return type is int (Java language). But for the input 1, the expected output is 2147483648, How can an int type can store that value?\\n\\nThank you"
                    }
                ]
            },
            {
                "id": 1569007,
                "content": [
                    {
                        "username": "gen504240809",
                        "content": "int in java is 32-bit signed number ,the maximum signed number is 2147483647.when the last bit of the input number is '1' and we reverse bits,it will become negative number ,how can we return a positive int number and the number must be larger than 2147483647?"
                    },
                    {
                        "username": "shtian",
                        "content": "## Java ##\\n\\nUse [`>>>`\\\\*][1] instead of `>>`. `>>>`is unsigned right shift, and `>>` is signed.\\n\\nUse [`Integer.parseUnsignedInt`\\\\*][2] and [`Integer.toUnsignedString`\\\\*][3] if you want test your program locally.\\n\\n## JavaScript ##\\n\\nUse [`>>>`\\\\*][4] instead of `>>`. This is as same as Java.\\n\\nAfter `|`, `&`, `~`, `>>`, `<<`, the number was converted ToInt32. But you need return a positive value. So try `return result >>> 0;`. `>>>` will call [`ToUint32`\\\\*][5].\\n\\n\\n  [1]: http://docs.oracle.com/javase/tutorial/java/nutsandbolts/op3.html\\n  [2]: http://docs.oracle.com/javase/8/docs/api/java/lang/Integer.html#parseUnsignedInt-java.lang.String-\\n  [3]: http://docs.oracle.com/javase/8/docs/api/java/lang/Integer.html#toUnsignedString-int-int-\\n  [4]: http://www.ecma-international.org/ecma-262/5.1/#sec-11.7.2\\n  [5]: http://www.ecma-international.org/ecma-262/5.1/#sec-9.6"
                    },
                    {
                        "username": "quarkyy99",
                        "content": "What is wrong with the developer of the question....Theyre saying that input is binary string and the input theyre taking is an integer...\\n"
                    },
                    {
                        "username": "jimmyzzxhlh",
                        "content": "Since the function is forced to return an int, how is it possible to return 2147483648?\\n\\nI've tried to return -2147483648 and it doesn't work."
                    },
                    {
                        "username": "loveytx",
                        "content": "use long long int "
                    },
                    {
                        "username": "daynis",
                        "content": "I have a more of a Java language question. My program failed for 2147483648 as an input. How is Java able to represent 2147483648 as an unsigned int value when it doesn't have any unsigned integer types?In other words, how is the input sent as 2147483648 in an int variable given that the Java language itself doesn't let us hold 2147483648 in an int ?"
                    },
                    {
                        "username": "lordwerneo",
                        "content": "In case if you wonder, if it says that as input you get something like this: \\'00000000000000000000000000000100\\' it means that as input you just got int 4, and to get binary representation, you just need to format or f-string your input as f\\'{input:032b}\\' where input is your variable."
                    },
                    {
                        "username": "ThirteenBeans",
                        "content": "    def reverse_bits(n)\\n        sprintf(\"%.32b\", n).reverse.to_i(2)\\n    end"
                    },
                    {
                        "username": "ajitemk",
                        "content": "uint32_t reverseBits(uint32_t n) {\\n\\nThis below expression use to swap the bits.\\nLet an example, suppose num is 0100, after the above expression it will be 1000.\\n\\n    n = (((n & 0xaaaaaaaa) >> 1) | ((n & 0x55555555) << 1));\\n\\nbelow expression uses to swap the 2 bits of a nibble. Suppose num is 10 00, after the above expression, it will be 00 01.\\n\\nn = (((n & 0xcccccccc) >> 2) | ((n & 0x33333333) << 2));\\n\\nExpression use to swaps the nibbles. like if num is 0011 0010 then after the below expression it will be 0010 0011.\\n\\n\\tn = (((n & 0xf0f0f0f0) >> 4) | ((n & 0x0f0f0f0f) << 4));\\n\\t\\n\\tThis statement  uses to swap the bytes of an integer. Let num is 00001000 00001100, after the below expression, it will be 00001100 00001000.\\n\\t\\n\\tn = (((n & 0xff00ff00) >> 8) | ((n & 0x00ff00ff) << 8));\\n\\t\\nreturn((n >> 16) | (n << 16));\\nThe above expression uses to swap the half-word of an integer. Means that if the num is 0000000011001110 1000100100000110, after the above result number will be 1000100100000110 0000000011001110.\\n    \\n}"
                    },
                    {
                        "username": "Henton",
                        "content": "My solution show this.\\nRuntime: 2 ms, faster than 98.25% of Java online submissions for Reverse Bits."
                    },
                    {
                        "username": "vikas7",
                        "content": "In Q.190, The function prototype says return type is int (Java language). But for the input 1, the expected output is 2147483648, How can an int type can store that value?\\n\\nThank you"
                    }
                ]
            },
            {
                "id": 1907553,
                "content": [
                    {
                        "username": "belyakovsergeyrus",
                        "content": "I did not immediately understand the task, so I will try to explain: in fact, the task is to return the \"revers\" of a given number"
                    },
                    {
                        "username": "user-online",
                        "content": "I\\'m not very familliar with bit operations. This is my first intuitive solution \\n`return int(bin(n)[::-1], 2)`.\\nI thought it should work but it failed actually with error\\n` ValueError: invalid literal for int() with base 2: \\'00111001011110000010100101b0\\'`\\nCan anyone help address my confusion? I really appreciate it."
                    },
                    {
                        "username": "pateldevarsh1206",
                        "content": "\\'b0\\' in ending is causing the problem. Try int(\\'0b\\' + bin(n)[2:][::-1], 2). \\n\\nHint : This is still not complete solution. You have to make string length 32"
                    },
                    {
                        "username": "pradyumnakr",
                        "content": "How to pass 32 bit unsigned integer to function in python?"
                    },
                    {
                        "username": "masterweb801",
                        "content": "My Issue is this error :-\\n`SyntaxError: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers`"
                    },
                    {
                        "username": "BrijeshSCareer",
                        "content": "Why (1<<31) is not working in C programming??\\n\\nI\\'m trying with unsigned int and signed int both.\\n\\nError is showing -  \"left shift of 1 by 31 places cannot be represented in type \\'int\\' \"."
                    },
                    {
                        "username": "hellenyue002",
                        "content": "If I use >>> it will pass, but if I use >>, it will time exceed. \\n\\nWhy the performance has so much difference?"
                    },
                    {
                        "username": "icyfox",
                        "content": "If you want to test  **2147483648 (10000000000000000000000000000000)**\\n\\n\\nBut eclipse tell you it is too large for **int**\\n\\n\\nuse **1 << 31** instead"
                    },
                    {
                        "username": "lq60607@yahoo.com",
                        "content": "Besides the discussion whether it's meaningful or not,\\nis there any programming room to \"optimize\" such a problem?\\n\\nCaching the result of last call of reverse(n) to prepare the same call of reverse(n) to be called again?\\n\\nForgive me if the question is dumb. But please detail the answer.\\n\\nThanks."
                    },
                    {
                        "username": "asgakashgupta",
                        "content": "![image](https://assets.leetcode.com/users/images/1605fec6-7bb3-4f5e-90b4-a54e3e038804_1599381784.601867.png)\\n"
                    },
                    {
                        "username": "akshatsoni64",
                        "content": "`return int(\"{:032b}\".format(n)[::-1],2)`"
                    }
                ]
            },
            {
                "id": 1576001,
                "content": [
                    {
                        "username": "belyakovsergeyrus",
                        "content": "I did not immediately understand the task, so I will try to explain: in fact, the task is to return the \"revers\" of a given number"
                    },
                    {
                        "username": "user-online",
                        "content": "I\\'m not very familliar with bit operations. This is my first intuitive solution \\n`return int(bin(n)[::-1], 2)`.\\nI thought it should work but it failed actually with error\\n` ValueError: invalid literal for int() with base 2: \\'00111001011110000010100101b0\\'`\\nCan anyone help address my confusion? I really appreciate it."
                    },
                    {
                        "username": "pateldevarsh1206",
                        "content": "\\'b0\\' in ending is causing the problem. Try int(\\'0b\\' + bin(n)[2:][::-1], 2). \\n\\nHint : This is still not complete solution. You have to make string length 32"
                    },
                    {
                        "username": "pradyumnakr",
                        "content": "How to pass 32 bit unsigned integer to function in python?"
                    },
                    {
                        "username": "masterweb801",
                        "content": "My Issue is this error :-\\n`SyntaxError: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers`"
                    },
                    {
                        "username": "BrijeshSCareer",
                        "content": "Why (1<<31) is not working in C programming??\\n\\nI\\'m trying with unsigned int and signed int both.\\n\\nError is showing -  \"left shift of 1 by 31 places cannot be represented in type \\'int\\' \"."
                    },
                    {
                        "username": "hellenyue002",
                        "content": "If I use >>> it will pass, but if I use >>, it will time exceed. \\n\\nWhy the performance has so much difference?"
                    },
                    {
                        "username": "icyfox",
                        "content": "If you want to test  **2147483648 (10000000000000000000000000000000)**\\n\\n\\nBut eclipse tell you it is too large for **int**\\n\\n\\nuse **1 << 31** instead"
                    },
                    {
                        "username": "lq60607@yahoo.com",
                        "content": "Besides the discussion whether it's meaningful or not,\\nis there any programming room to \"optimize\" such a problem?\\n\\nCaching the result of last call of reverse(n) to prepare the same call of reverse(n) to be called again?\\n\\nForgive me if the question is dumb. But please detail the answer.\\n\\nThanks."
                    },
                    {
                        "username": "asgakashgupta",
                        "content": "![image](https://assets.leetcode.com/users/images/1605fec6-7bb3-4f5e-90b4-a54e3e038804_1599381784.601867.png)\\n"
                    },
                    {
                        "username": "akshatsoni64",
                        "content": "`return int(\"{:032b}\".format(n)[::-1],2)`"
                    }
                ]
            },
            {
                "id": 1941582,
                "content": [
                    {
                        "username": "belyakovsergeyrus",
                        "content": "I did not immediately understand the task, so I will try to explain: in fact, the task is to return the \"revers\" of a given number"
                    },
                    {
                        "username": "user-online",
                        "content": "I\\'m not very familliar with bit operations. This is my first intuitive solution \\n`return int(bin(n)[::-1], 2)`.\\nI thought it should work but it failed actually with error\\n` ValueError: invalid literal for int() with base 2: \\'00111001011110000010100101b0\\'`\\nCan anyone help address my confusion? I really appreciate it."
                    },
                    {
                        "username": "pateldevarsh1206",
                        "content": "\\'b0\\' in ending is causing the problem. Try int(\\'0b\\' + bin(n)[2:][::-1], 2). \\n\\nHint : This is still not complete solution. You have to make string length 32"
                    },
                    {
                        "username": "pradyumnakr",
                        "content": "How to pass 32 bit unsigned integer to function in python?"
                    },
                    {
                        "username": "masterweb801",
                        "content": "My Issue is this error :-\\n`SyntaxError: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers`"
                    },
                    {
                        "username": "BrijeshSCareer",
                        "content": "Why (1<<31) is not working in C programming??\\n\\nI\\'m trying with unsigned int and signed int both.\\n\\nError is showing -  \"left shift of 1 by 31 places cannot be represented in type \\'int\\' \"."
                    },
                    {
                        "username": "hellenyue002",
                        "content": "If I use >>> it will pass, but if I use >>, it will time exceed. \\n\\nWhy the performance has so much difference?"
                    },
                    {
                        "username": "icyfox",
                        "content": "If you want to test  **2147483648 (10000000000000000000000000000000)**\\n\\n\\nBut eclipse tell you it is too large for **int**\\n\\n\\nuse **1 << 31** instead"
                    },
                    {
                        "username": "lq60607@yahoo.com",
                        "content": "Besides the discussion whether it's meaningful or not,\\nis there any programming room to \"optimize\" such a problem?\\n\\nCaching the result of last call of reverse(n) to prepare the same call of reverse(n) to be called again?\\n\\nForgive me if the question is dumb. But please detail the answer.\\n\\nThanks."
                    },
                    {
                        "username": "asgakashgupta",
                        "content": "![image](https://assets.leetcode.com/users/images/1605fec6-7bb3-4f5e-90b4-a54e3e038804_1599381784.601867.png)\\n"
                    },
                    {
                        "username": "akshatsoni64",
                        "content": "`return int(\"{:032b}\".format(n)[::-1],2)`"
                    }
                ]
            },
            {
                "id": 1940765,
                "content": [
                    {
                        "username": "belyakovsergeyrus",
                        "content": "I did not immediately understand the task, so I will try to explain: in fact, the task is to return the \"revers\" of a given number"
                    },
                    {
                        "username": "user-online",
                        "content": "I\\'m not very familliar with bit operations. This is my first intuitive solution \\n`return int(bin(n)[::-1], 2)`.\\nI thought it should work but it failed actually with error\\n` ValueError: invalid literal for int() with base 2: \\'00111001011110000010100101b0\\'`\\nCan anyone help address my confusion? I really appreciate it."
                    },
                    {
                        "username": "pateldevarsh1206",
                        "content": "\\'b0\\' in ending is causing the problem. Try int(\\'0b\\' + bin(n)[2:][::-1], 2). \\n\\nHint : This is still not complete solution. You have to make string length 32"
                    },
                    {
                        "username": "pradyumnakr",
                        "content": "How to pass 32 bit unsigned integer to function in python?"
                    },
                    {
                        "username": "masterweb801",
                        "content": "My Issue is this error :-\\n`SyntaxError: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers`"
                    },
                    {
                        "username": "BrijeshSCareer",
                        "content": "Why (1<<31) is not working in C programming??\\n\\nI\\'m trying with unsigned int and signed int both.\\n\\nError is showing -  \"left shift of 1 by 31 places cannot be represented in type \\'int\\' \"."
                    },
                    {
                        "username": "hellenyue002",
                        "content": "If I use >>> it will pass, but if I use >>, it will time exceed. \\n\\nWhy the performance has so much difference?"
                    },
                    {
                        "username": "icyfox",
                        "content": "If you want to test  **2147483648 (10000000000000000000000000000000)**\\n\\n\\nBut eclipse tell you it is too large for **int**\\n\\n\\nuse **1 << 31** instead"
                    },
                    {
                        "username": "lq60607@yahoo.com",
                        "content": "Besides the discussion whether it's meaningful or not,\\nis there any programming room to \"optimize\" such a problem?\\n\\nCaching the result of last call of reverse(n) to prepare the same call of reverse(n) to be called again?\\n\\nForgive me if the question is dumb. But please detail the answer.\\n\\nThanks."
                    },
                    {
                        "username": "asgakashgupta",
                        "content": "![image](https://assets.leetcode.com/users/images/1605fec6-7bb3-4f5e-90b4-a54e3e038804_1599381784.601867.png)\\n"
                    },
                    {
                        "username": "akshatsoni64",
                        "content": "`return int(\"{:032b}\".format(n)[::-1],2)`"
                    }
                ]
            },
            {
                "id": 1801569,
                "content": [
                    {
                        "username": "belyakovsergeyrus",
                        "content": "I did not immediately understand the task, so I will try to explain: in fact, the task is to return the \"revers\" of a given number"
                    },
                    {
                        "username": "user-online",
                        "content": "I\\'m not very familliar with bit operations. This is my first intuitive solution \\n`return int(bin(n)[::-1], 2)`.\\nI thought it should work but it failed actually with error\\n` ValueError: invalid literal for int() with base 2: \\'00111001011110000010100101b0\\'`\\nCan anyone help address my confusion? I really appreciate it."
                    },
                    {
                        "username": "pateldevarsh1206",
                        "content": "\\'b0\\' in ending is causing the problem. Try int(\\'0b\\' + bin(n)[2:][::-1], 2). \\n\\nHint : This is still not complete solution. You have to make string length 32"
                    },
                    {
                        "username": "pradyumnakr",
                        "content": "How to pass 32 bit unsigned integer to function in python?"
                    },
                    {
                        "username": "masterweb801",
                        "content": "My Issue is this error :-\\n`SyntaxError: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers`"
                    },
                    {
                        "username": "BrijeshSCareer",
                        "content": "Why (1<<31) is not working in C programming??\\n\\nI\\'m trying with unsigned int and signed int both.\\n\\nError is showing -  \"left shift of 1 by 31 places cannot be represented in type \\'int\\' \"."
                    },
                    {
                        "username": "hellenyue002",
                        "content": "If I use >>> it will pass, but if I use >>, it will time exceed. \\n\\nWhy the performance has so much difference?"
                    },
                    {
                        "username": "icyfox",
                        "content": "If you want to test  **2147483648 (10000000000000000000000000000000)**\\n\\n\\nBut eclipse tell you it is too large for **int**\\n\\n\\nuse **1 << 31** instead"
                    },
                    {
                        "username": "lq60607@yahoo.com",
                        "content": "Besides the discussion whether it's meaningful or not,\\nis there any programming room to \"optimize\" such a problem?\\n\\nCaching the result of last call of reverse(n) to prepare the same call of reverse(n) to be called again?\\n\\nForgive me if the question is dumb. But please detail the answer.\\n\\nThanks."
                    },
                    {
                        "username": "asgakashgupta",
                        "content": "![image](https://assets.leetcode.com/users/images/1605fec6-7bb3-4f5e-90b4-a54e3e038804_1599381784.601867.png)\\n"
                    },
                    {
                        "username": "akshatsoni64",
                        "content": "`return int(\"{:032b}\".format(n)[::-1],2)`"
                    }
                ]
            },
            {
                "id": 1571401,
                "content": [
                    {
                        "username": "belyakovsergeyrus",
                        "content": "I did not immediately understand the task, so I will try to explain: in fact, the task is to return the \"revers\" of a given number"
                    },
                    {
                        "username": "user-online",
                        "content": "I\\'m not very familliar with bit operations. This is my first intuitive solution \\n`return int(bin(n)[::-1], 2)`.\\nI thought it should work but it failed actually with error\\n` ValueError: invalid literal for int() with base 2: \\'00111001011110000010100101b0\\'`\\nCan anyone help address my confusion? I really appreciate it."
                    },
                    {
                        "username": "pateldevarsh1206",
                        "content": "\\'b0\\' in ending is causing the problem. Try int(\\'0b\\' + bin(n)[2:][::-1], 2). \\n\\nHint : This is still not complete solution. You have to make string length 32"
                    },
                    {
                        "username": "pradyumnakr",
                        "content": "How to pass 32 bit unsigned integer to function in python?"
                    },
                    {
                        "username": "masterweb801",
                        "content": "My Issue is this error :-\\n`SyntaxError: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers`"
                    },
                    {
                        "username": "BrijeshSCareer",
                        "content": "Why (1<<31) is not working in C programming??\\n\\nI\\'m trying with unsigned int and signed int both.\\n\\nError is showing -  \"left shift of 1 by 31 places cannot be represented in type \\'int\\' \"."
                    },
                    {
                        "username": "hellenyue002",
                        "content": "If I use >>> it will pass, but if I use >>, it will time exceed. \\n\\nWhy the performance has so much difference?"
                    },
                    {
                        "username": "icyfox",
                        "content": "If you want to test  **2147483648 (10000000000000000000000000000000)**\\n\\n\\nBut eclipse tell you it is too large for **int**\\n\\n\\nuse **1 << 31** instead"
                    },
                    {
                        "username": "lq60607@yahoo.com",
                        "content": "Besides the discussion whether it's meaningful or not,\\nis there any programming room to \"optimize\" such a problem?\\n\\nCaching the result of last call of reverse(n) to prepare the same call of reverse(n) to be called again?\\n\\nForgive me if the question is dumb. But please detail the answer.\\n\\nThanks."
                    },
                    {
                        "username": "asgakashgupta",
                        "content": "![image](https://assets.leetcode.com/users/images/1605fec6-7bb3-4f5e-90b4-a54e3e038804_1599381784.601867.png)\\n"
                    },
                    {
                        "username": "akshatsoni64",
                        "content": "`return int(\"{:032b}\".format(n)[::-1],2)`"
                    }
                ]
            },
            {
                "id": 1571403,
                "content": [
                    {
                        "username": "belyakovsergeyrus",
                        "content": "I did not immediately understand the task, so I will try to explain: in fact, the task is to return the \"revers\" of a given number"
                    },
                    {
                        "username": "user-online",
                        "content": "I\\'m not very familliar with bit operations. This is my first intuitive solution \\n`return int(bin(n)[::-1], 2)`.\\nI thought it should work but it failed actually with error\\n` ValueError: invalid literal for int() with base 2: \\'00111001011110000010100101b0\\'`\\nCan anyone help address my confusion? I really appreciate it."
                    },
                    {
                        "username": "pateldevarsh1206",
                        "content": "\\'b0\\' in ending is causing the problem. Try int(\\'0b\\' + bin(n)[2:][::-1], 2). \\n\\nHint : This is still not complete solution. You have to make string length 32"
                    },
                    {
                        "username": "pradyumnakr",
                        "content": "How to pass 32 bit unsigned integer to function in python?"
                    },
                    {
                        "username": "masterweb801",
                        "content": "My Issue is this error :-\\n`SyntaxError: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers`"
                    },
                    {
                        "username": "BrijeshSCareer",
                        "content": "Why (1<<31) is not working in C programming??\\n\\nI\\'m trying with unsigned int and signed int both.\\n\\nError is showing -  \"left shift of 1 by 31 places cannot be represented in type \\'int\\' \"."
                    },
                    {
                        "username": "hellenyue002",
                        "content": "If I use >>> it will pass, but if I use >>, it will time exceed. \\n\\nWhy the performance has so much difference?"
                    },
                    {
                        "username": "icyfox",
                        "content": "If you want to test  **2147483648 (10000000000000000000000000000000)**\\n\\n\\nBut eclipse tell you it is too large for **int**\\n\\n\\nuse **1 << 31** instead"
                    },
                    {
                        "username": "lq60607@yahoo.com",
                        "content": "Besides the discussion whether it's meaningful or not,\\nis there any programming room to \"optimize\" such a problem?\\n\\nCaching the result of last call of reverse(n) to prepare the same call of reverse(n) to be called again?\\n\\nForgive me if the question is dumb. But please detail the answer.\\n\\nThanks."
                    },
                    {
                        "username": "asgakashgupta",
                        "content": "![image](https://assets.leetcode.com/users/images/1605fec6-7bb3-4f5e-90b4-a54e3e038804_1599381784.601867.png)\\n"
                    },
                    {
                        "username": "akshatsoni64",
                        "content": "`return int(\"{:032b}\".format(n)[::-1],2)`"
                    }
                ]
            },
            {
                "id": 1571402,
                "content": [
                    {
                        "username": "belyakovsergeyrus",
                        "content": "I did not immediately understand the task, so I will try to explain: in fact, the task is to return the \"revers\" of a given number"
                    },
                    {
                        "username": "user-online",
                        "content": "I\\'m not very familliar with bit operations. This is my first intuitive solution \\n`return int(bin(n)[::-1], 2)`.\\nI thought it should work but it failed actually with error\\n` ValueError: invalid literal for int() with base 2: \\'00111001011110000010100101b0\\'`\\nCan anyone help address my confusion? I really appreciate it."
                    },
                    {
                        "username": "pateldevarsh1206",
                        "content": "\\'b0\\' in ending is causing the problem. Try int(\\'0b\\' + bin(n)[2:][::-1], 2). \\n\\nHint : This is still not complete solution. You have to make string length 32"
                    },
                    {
                        "username": "pradyumnakr",
                        "content": "How to pass 32 bit unsigned integer to function in python?"
                    },
                    {
                        "username": "masterweb801",
                        "content": "My Issue is this error :-\\n`SyntaxError: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers`"
                    },
                    {
                        "username": "BrijeshSCareer",
                        "content": "Why (1<<31) is not working in C programming??\\n\\nI\\'m trying with unsigned int and signed int both.\\n\\nError is showing -  \"left shift of 1 by 31 places cannot be represented in type \\'int\\' \"."
                    },
                    {
                        "username": "hellenyue002",
                        "content": "If I use >>> it will pass, but if I use >>, it will time exceed. \\n\\nWhy the performance has so much difference?"
                    },
                    {
                        "username": "icyfox",
                        "content": "If you want to test  **2147483648 (10000000000000000000000000000000)**\\n\\n\\nBut eclipse tell you it is too large for **int**\\n\\n\\nuse **1 << 31** instead"
                    },
                    {
                        "username": "lq60607@yahoo.com",
                        "content": "Besides the discussion whether it's meaningful or not,\\nis there any programming room to \"optimize\" such a problem?\\n\\nCaching the result of last call of reverse(n) to prepare the same call of reverse(n) to be called again?\\n\\nForgive me if the question is dumb. But please detail the answer.\\n\\nThanks."
                    },
                    {
                        "username": "asgakashgupta",
                        "content": "![image](https://assets.leetcode.com/users/images/1605fec6-7bb3-4f5e-90b4-a54e3e038804_1599381784.601867.png)\\n"
                    },
                    {
                        "username": "akshatsoni64",
                        "content": "`return int(\"{:032b}\".format(n)[::-1],2)`"
                    }
                ]
            },
            {
                "id": 1574336,
                "content": [
                    {
                        "username": "belyakovsergeyrus",
                        "content": "I did not immediately understand the task, so I will try to explain: in fact, the task is to return the \"revers\" of a given number"
                    },
                    {
                        "username": "user-online",
                        "content": "I\\'m not very familliar with bit operations. This is my first intuitive solution \\n`return int(bin(n)[::-1], 2)`.\\nI thought it should work but it failed actually with error\\n` ValueError: invalid literal for int() with base 2: \\'00111001011110000010100101b0\\'`\\nCan anyone help address my confusion? I really appreciate it."
                    },
                    {
                        "username": "pateldevarsh1206",
                        "content": "\\'b0\\' in ending is causing the problem. Try int(\\'0b\\' + bin(n)[2:][::-1], 2). \\n\\nHint : This is still not complete solution. You have to make string length 32"
                    },
                    {
                        "username": "pradyumnakr",
                        "content": "How to pass 32 bit unsigned integer to function in python?"
                    },
                    {
                        "username": "masterweb801",
                        "content": "My Issue is this error :-\\n`SyntaxError: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers`"
                    },
                    {
                        "username": "BrijeshSCareer",
                        "content": "Why (1<<31) is not working in C programming??\\n\\nI\\'m trying with unsigned int and signed int both.\\n\\nError is showing -  \"left shift of 1 by 31 places cannot be represented in type \\'int\\' \"."
                    },
                    {
                        "username": "hellenyue002",
                        "content": "If I use >>> it will pass, but if I use >>, it will time exceed. \\n\\nWhy the performance has so much difference?"
                    },
                    {
                        "username": "icyfox",
                        "content": "If you want to test  **2147483648 (10000000000000000000000000000000)**\\n\\n\\nBut eclipse tell you it is too large for **int**\\n\\n\\nuse **1 << 31** instead"
                    },
                    {
                        "username": "lq60607@yahoo.com",
                        "content": "Besides the discussion whether it's meaningful or not,\\nis there any programming room to \"optimize\" such a problem?\\n\\nCaching the result of last call of reverse(n) to prepare the same call of reverse(n) to be called again?\\n\\nForgive me if the question is dumb. But please detail the answer.\\n\\nThanks."
                    },
                    {
                        "username": "asgakashgupta",
                        "content": "![image](https://assets.leetcode.com/users/images/1605fec6-7bb3-4f5e-90b4-a54e3e038804_1599381784.601867.png)\\n"
                    },
                    {
                        "username": "akshatsoni64",
                        "content": "`return int(\"{:032b}\".format(n)[::-1],2)`"
                    }
                ]
            },
            {
                "id": 1576137,
                "content": [
                    {
                        "username": "belyakovsergeyrus",
                        "content": "I did not immediately understand the task, so I will try to explain: in fact, the task is to return the \"revers\" of a given number"
                    },
                    {
                        "username": "user-online",
                        "content": "I\\'m not very familliar with bit operations. This is my first intuitive solution \\n`return int(bin(n)[::-1], 2)`.\\nI thought it should work but it failed actually with error\\n` ValueError: invalid literal for int() with base 2: \\'00111001011110000010100101b0\\'`\\nCan anyone help address my confusion? I really appreciate it."
                    },
                    {
                        "username": "pateldevarsh1206",
                        "content": "\\'b0\\' in ending is causing the problem. Try int(\\'0b\\' + bin(n)[2:][::-1], 2). \\n\\nHint : This is still not complete solution. You have to make string length 32"
                    },
                    {
                        "username": "pradyumnakr",
                        "content": "How to pass 32 bit unsigned integer to function in python?"
                    },
                    {
                        "username": "masterweb801",
                        "content": "My Issue is this error :-\\n`SyntaxError: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers`"
                    },
                    {
                        "username": "BrijeshSCareer",
                        "content": "Why (1<<31) is not working in C programming??\\n\\nI\\'m trying with unsigned int and signed int both.\\n\\nError is showing -  \"left shift of 1 by 31 places cannot be represented in type \\'int\\' \"."
                    },
                    {
                        "username": "hellenyue002",
                        "content": "If I use >>> it will pass, but if I use >>, it will time exceed. \\n\\nWhy the performance has so much difference?"
                    },
                    {
                        "username": "icyfox",
                        "content": "If you want to test  **2147483648 (10000000000000000000000000000000)**\\n\\n\\nBut eclipse tell you it is too large for **int**\\n\\n\\nuse **1 << 31** instead"
                    },
                    {
                        "username": "lq60607@yahoo.com",
                        "content": "Besides the discussion whether it's meaningful or not,\\nis there any programming room to \"optimize\" such a problem?\\n\\nCaching the result of last call of reverse(n) to prepare the same call of reverse(n) to be called again?\\n\\nForgive me if the question is dumb. But please detail the answer.\\n\\nThanks."
                    },
                    {
                        "username": "asgakashgupta",
                        "content": "![image](https://assets.leetcode.com/users/images/1605fec6-7bb3-4f5e-90b4-a54e3e038804_1599381784.601867.png)\\n"
                    },
                    {
                        "username": "akshatsoni64",
                        "content": "`return int(\"{:032b}\".format(n)[::-1],2)`"
                    }
                ]
            },
            {
                "id": 1575918,
                "content": [
                    {
                        "username": "Alptekin",
                        "content": "return Integer.reverse(n);\\n"
                    },
                    {
                        "username": "LakshmanMalviya",
                        "content": "Solution is of single line \" return Integer.reverse(n); \"\\nBeats 100%"
                    },
                    {
                        "username": "the_timmer",
                        "content": "For Python3, the Testcase / Result section was misleading to me.  It kept showing the Input as a binary.  But when I started off with a print(n), it clearly printed a decimal, not a binary.  This is more consistent with n being defined as int.  So I needed to convert n to a binary before doing anything else, and then I could get a successful submittal."
                    },
                    {
                        "username": "Pr1yankar",
                        "content": "supper easy in c. Time complexity O(1)\\nuint32_t reverseBits(uint32_t n) {\\n    uint32_t i = 0 , bit = 0;\\n    for(int j = 0 ; j<32;j++) i=i<<1,bit = (1&n) ,i += bit , n = n>>1;\\n    return i;\\n}"
                    },
                    {
                        "username": "imamanwp",
                        "content": "This question should be medium level of difficulty as this question is complex and requires understanding of bits manipulation and divide and conquer."
                    },
                    {
                        "username": "SiegeSailor",
                        "content": "My Python solution works on my terminal but not here:\\n\\n```python\\nclass Solution:\\n    def reverseBits(self, n: int) -> int:\\n        output = list(bin(n)[2:])\\n        pointer_start, pointer_end = 0, len(output) - 1\\n        while pointer_start < pointer_end:\\n            output[pointer_start], output[pointer_end] = output[pointer_end], output[pointer_start]\\n            pointer_start += 1\\n            pointer_end -= 1\\n        return \"\".join(output)\\n```\\n\\nIt keeps complaining:\\n\\n> ValueError: Unknown format code \\'b\\' for object of type \\'str\\'\\n    out = \"%12d (%s)\" % (reversed_bits, \\'{:032b}\\'.format(reversed_bits))\\nLine 26 in _driver (Solution.py)\\n    _driver()\\nLine 35 in <module> (Solution.py)"
                    },
                    {
                        "username": "danek1313",
                        "content": "If I adapt Approach 1\\'s C++ option to Java, it fails with a Time Limit Exceeded. Why?"
                    },
                    {
                        "username": "ravikumarmanikyolla",
                        "content": "I have a more of a Java language question. My program failed for 2147483648 as an input. How is Java able to represent 2147483648 as an unsigned int value "
                    },
                    {
                        "username": "sethhu20",
                        "content": "I assume the follow up *If this function is called many times, how would you optimize it?* is just a \"interview\" style question without needing to necessarily code it out.\\n\\nBut I\\'m not quite sure what would be the idea for this question. It would be obvious to cache the results (as I saw some other answers), but that doesn\\'t sound like a convincing answer or if it is practical in real life, since if we assume the input is randomly distributed across the 32 bit unsigned integers range, then not only is the cache will rarely be useful, but also the space needed will grow to 32 bit size (a hashmap / array of 2^32 32 bit numbers takes up gigabytes of memory).\\n\\nWhat other optimization can be done in the event where these calls are randomly distributed along the 32 bit integer range?"
                    },
                    {
                        "username": "ankushmondal1y2t",
                        "content": "EASY 0ms BEATS 100% SOLUTION EASY TO UNDERSTAND\\n    uint32_t reverseBits(uint32_t n) {\\n        uint32_t r=0;\\n        for(int i=0;i<32;i++)\\n        {\\n            //n=n>>1;\\n            r<<=1;\\n            if((n&1)==1)\\n            {\\n                r++;\\n            }\\n            n>>=1;\\n        }\\n        return r;\\n    }"
                    }
                ]
            },
            {
                "id": 2075354,
                "content": [
                    {
                        "username": "Alptekin",
                        "content": "return Integer.reverse(n);\\n"
                    },
                    {
                        "username": "LakshmanMalviya",
                        "content": "Solution is of single line \" return Integer.reverse(n); \"\\nBeats 100%"
                    },
                    {
                        "username": "the_timmer",
                        "content": "For Python3, the Testcase / Result section was misleading to me.  It kept showing the Input as a binary.  But when I started off with a print(n), it clearly printed a decimal, not a binary.  This is more consistent with n being defined as int.  So I needed to convert n to a binary before doing anything else, and then I could get a successful submittal."
                    },
                    {
                        "username": "Pr1yankar",
                        "content": "supper easy in c. Time complexity O(1)\\nuint32_t reverseBits(uint32_t n) {\\n    uint32_t i = 0 , bit = 0;\\n    for(int j = 0 ; j<32;j++) i=i<<1,bit = (1&n) ,i += bit , n = n>>1;\\n    return i;\\n}"
                    },
                    {
                        "username": "imamanwp",
                        "content": "This question should be medium level of difficulty as this question is complex and requires understanding of bits manipulation and divide and conquer."
                    },
                    {
                        "username": "SiegeSailor",
                        "content": "My Python solution works on my terminal but not here:\\n\\n```python\\nclass Solution:\\n    def reverseBits(self, n: int) -> int:\\n        output = list(bin(n)[2:])\\n        pointer_start, pointer_end = 0, len(output) - 1\\n        while pointer_start < pointer_end:\\n            output[pointer_start], output[pointer_end] = output[pointer_end], output[pointer_start]\\n            pointer_start += 1\\n            pointer_end -= 1\\n        return \"\".join(output)\\n```\\n\\nIt keeps complaining:\\n\\n> ValueError: Unknown format code \\'b\\' for object of type \\'str\\'\\n    out = \"%12d (%s)\" % (reversed_bits, \\'{:032b}\\'.format(reversed_bits))\\nLine 26 in _driver (Solution.py)\\n    _driver()\\nLine 35 in <module> (Solution.py)"
                    },
                    {
                        "username": "danek1313",
                        "content": "If I adapt Approach 1\\'s C++ option to Java, it fails with a Time Limit Exceeded. Why?"
                    },
                    {
                        "username": "ravikumarmanikyolla",
                        "content": "I have a more of a Java language question. My program failed for 2147483648 as an input. How is Java able to represent 2147483648 as an unsigned int value "
                    },
                    {
                        "username": "sethhu20",
                        "content": "I assume the follow up *If this function is called many times, how would you optimize it?* is just a \"interview\" style question without needing to necessarily code it out.\\n\\nBut I\\'m not quite sure what would be the idea for this question. It would be obvious to cache the results (as I saw some other answers), but that doesn\\'t sound like a convincing answer or if it is practical in real life, since if we assume the input is randomly distributed across the 32 bit unsigned integers range, then not only is the cache will rarely be useful, but also the space needed will grow to 32 bit size (a hashmap / array of 2^32 32 bit numbers takes up gigabytes of memory).\\n\\nWhat other optimization can be done in the event where these calls are randomly distributed along the 32 bit integer range?"
                    },
                    {
                        "username": "ankushmondal1y2t",
                        "content": "EASY 0ms BEATS 100% SOLUTION EASY TO UNDERSTAND\\n    uint32_t reverseBits(uint32_t n) {\\n        uint32_t r=0;\\n        for(int i=0;i<32;i++)\\n        {\\n            //n=n>>1;\\n            r<<=1;\\n            if((n&1)==1)\\n            {\\n                r++;\\n            }\\n            n>>=1;\\n        }\\n        return r;\\n    }"
                    }
                ]
            },
            {
                "id": 2056572,
                "content": [
                    {
                        "username": "Alptekin",
                        "content": "return Integer.reverse(n);\\n"
                    },
                    {
                        "username": "LakshmanMalviya",
                        "content": "Solution is of single line \" return Integer.reverse(n); \"\\nBeats 100%"
                    },
                    {
                        "username": "the_timmer",
                        "content": "For Python3, the Testcase / Result section was misleading to me.  It kept showing the Input as a binary.  But when I started off with a print(n), it clearly printed a decimal, not a binary.  This is more consistent with n being defined as int.  So I needed to convert n to a binary before doing anything else, and then I could get a successful submittal."
                    },
                    {
                        "username": "Pr1yankar",
                        "content": "supper easy in c. Time complexity O(1)\\nuint32_t reverseBits(uint32_t n) {\\n    uint32_t i = 0 , bit = 0;\\n    for(int j = 0 ; j<32;j++) i=i<<1,bit = (1&n) ,i += bit , n = n>>1;\\n    return i;\\n}"
                    },
                    {
                        "username": "imamanwp",
                        "content": "This question should be medium level of difficulty as this question is complex and requires understanding of bits manipulation and divide and conquer."
                    },
                    {
                        "username": "SiegeSailor",
                        "content": "My Python solution works on my terminal but not here:\\n\\n```python\\nclass Solution:\\n    def reverseBits(self, n: int) -> int:\\n        output = list(bin(n)[2:])\\n        pointer_start, pointer_end = 0, len(output) - 1\\n        while pointer_start < pointer_end:\\n            output[pointer_start], output[pointer_end] = output[pointer_end], output[pointer_start]\\n            pointer_start += 1\\n            pointer_end -= 1\\n        return \"\".join(output)\\n```\\n\\nIt keeps complaining:\\n\\n> ValueError: Unknown format code \\'b\\' for object of type \\'str\\'\\n    out = \"%12d (%s)\" % (reversed_bits, \\'{:032b}\\'.format(reversed_bits))\\nLine 26 in _driver (Solution.py)\\n    _driver()\\nLine 35 in <module> (Solution.py)"
                    },
                    {
                        "username": "danek1313",
                        "content": "If I adapt Approach 1\\'s C++ option to Java, it fails with a Time Limit Exceeded. Why?"
                    },
                    {
                        "username": "ravikumarmanikyolla",
                        "content": "I have a more of a Java language question. My program failed for 2147483648 as an input. How is Java able to represent 2147483648 as an unsigned int value "
                    },
                    {
                        "username": "sethhu20",
                        "content": "I assume the follow up *If this function is called many times, how would you optimize it?* is just a \"interview\" style question without needing to necessarily code it out.\\n\\nBut I\\'m not quite sure what would be the idea for this question. It would be obvious to cache the results (as I saw some other answers), but that doesn\\'t sound like a convincing answer or if it is practical in real life, since if we assume the input is randomly distributed across the 32 bit unsigned integers range, then not only is the cache will rarely be useful, but also the space needed will grow to 32 bit size (a hashmap / array of 2^32 32 bit numbers takes up gigabytes of memory).\\n\\nWhat other optimization can be done in the event where these calls are randomly distributed along the 32 bit integer range?"
                    },
                    {
                        "username": "ankushmondal1y2t",
                        "content": "EASY 0ms BEATS 100% SOLUTION EASY TO UNDERSTAND\\n    uint32_t reverseBits(uint32_t n) {\\n        uint32_t r=0;\\n        for(int i=0;i<32;i++)\\n        {\\n            //n=n>>1;\\n            r<<=1;\\n            if((n&1)==1)\\n            {\\n                r++;\\n            }\\n            n>>=1;\\n        }\\n        return r;\\n    }"
                    }
                ]
            },
            {
                "id": 2034322,
                "content": [
                    {
                        "username": "Alptekin",
                        "content": "return Integer.reverse(n);\\n"
                    },
                    {
                        "username": "LakshmanMalviya",
                        "content": "Solution is of single line \" return Integer.reverse(n); \"\\nBeats 100%"
                    },
                    {
                        "username": "the_timmer",
                        "content": "For Python3, the Testcase / Result section was misleading to me.  It kept showing the Input as a binary.  But when I started off with a print(n), it clearly printed a decimal, not a binary.  This is more consistent with n being defined as int.  So I needed to convert n to a binary before doing anything else, and then I could get a successful submittal."
                    },
                    {
                        "username": "Pr1yankar",
                        "content": "supper easy in c. Time complexity O(1)\\nuint32_t reverseBits(uint32_t n) {\\n    uint32_t i = 0 , bit = 0;\\n    for(int j = 0 ; j<32;j++) i=i<<1,bit = (1&n) ,i += bit , n = n>>1;\\n    return i;\\n}"
                    },
                    {
                        "username": "imamanwp",
                        "content": "This question should be medium level of difficulty as this question is complex and requires understanding of bits manipulation and divide and conquer."
                    },
                    {
                        "username": "SiegeSailor",
                        "content": "My Python solution works on my terminal but not here:\\n\\n```python\\nclass Solution:\\n    def reverseBits(self, n: int) -> int:\\n        output = list(bin(n)[2:])\\n        pointer_start, pointer_end = 0, len(output) - 1\\n        while pointer_start < pointer_end:\\n            output[pointer_start], output[pointer_end] = output[pointer_end], output[pointer_start]\\n            pointer_start += 1\\n            pointer_end -= 1\\n        return \"\".join(output)\\n```\\n\\nIt keeps complaining:\\n\\n> ValueError: Unknown format code \\'b\\' for object of type \\'str\\'\\n    out = \"%12d (%s)\" % (reversed_bits, \\'{:032b}\\'.format(reversed_bits))\\nLine 26 in _driver (Solution.py)\\n    _driver()\\nLine 35 in <module> (Solution.py)"
                    },
                    {
                        "username": "danek1313",
                        "content": "If I adapt Approach 1\\'s C++ option to Java, it fails with a Time Limit Exceeded. Why?"
                    },
                    {
                        "username": "ravikumarmanikyolla",
                        "content": "I have a more of a Java language question. My program failed for 2147483648 as an input. How is Java able to represent 2147483648 as an unsigned int value "
                    },
                    {
                        "username": "sethhu20",
                        "content": "I assume the follow up *If this function is called many times, how would you optimize it?* is just a \"interview\" style question without needing to necessarily code it out.\\n\\nBut I\\'m not quite sure what would be the idea for this question. It would be obvious to cache the results (as I saw some other answers), but that doesn\\'t sound like a convincing answer or if it is practical in real life, since if we assume the input is randomly distributed across the 32 bit unsigned integers range, then not only is the cache will rarely be useful, but also the space needed will grow to 32 bit size (a hashmap / array of 2^32 32 bit numbers takes up gigabytes of memory).\\n\\nWhat other optimization can be done in the event where these calls are randomly distributed along the 32 bit integer range?"
                    },
                    {
                        "username": "ankushmondal1y2t",
                        "content": "EASY 0ms BEATS 100% SOLUTION EASY TO UNDERSTAND\\n    uint32_t reverseBits(uint32_t n) {\\n        uint32_t r=0;\\n        for(int i=0;i<32;i++)\\n        {\\n            //n=n>>1;\\n            r<<=1;\\n            if((n&1)==1)\\n            {\\n                r++;\\n            }\\n            n>>=1;\\n        }\\n        return r;\\n    }"
                    }
                ]
            },
            {
                "id": 2015527,
                "content": [
                    {
                        "username": "Alptekin",
                        "content": "return Integer.reverse(n);\\n"
                    },
                    {
                        "username": "LakshmanMalviya",
                        "content": "Solution is of single line \" return Integer.reverse(n); \"\\nBeats 100%"
                    },
                    {
                        "username": "the_timmer",
                        "content": "For Python3, the Testcase / Result section was misleading to me.  It kept showing the Input as a binary.  But when I started off with a print(n), it clearly printed a decimal, not a binary.  This is more consistent with n being defined as int.  So I needed to convert n to a binary before doing anything else, and then I could get a successful submittal."
                    },
                    {
                        "username": "Pr1yankar",
                        "content": "supper easy in c. Time complexity O(1)\\nuint32_t reverseBits(uint32_t n) {\\n    uint32_t i = 0 , bit = 0;\\n    for(int j = 0 ; j<32;j++) i=i<<1,bit = (1&n) ,i += bit , n = n>>1;\\n    return i;\\n}"
                    },
                    {
                        "username": "imamanwp",
                        "content": "This question should be medium level of difficulty as this question is complex and requires understanding of bits manipulation and divide and conquer."
                    },
                    {
                        "username": "SiegeSailor",
                        "content": "My Python solution works on my terminal but not here:\\n\\n```python\\nclass Solution:\\n    def reverseBits(self, n: int) -> int:\\n        output = list(bin(n)[2:])\\n        pointer_start, pointer_end = 0, len(output) - 1\\n        while pointer_start < pointer_end:\\n            output[pointer_start], output[pointer_end] = output[pointer_end], output[pointer_start]\\n            pointer_start += 1\\n            pointer_end -= 1\\n        return \"\".join(output)\\n```\\n\\nIt keeps complaining:\\n\\n> ValueError: Unknown format code \\'b\\' for object of type \\'str\\'\\n    out = \"%12d (%s)\" % (reversed_bits, \\'{:032b}\\'.format(reversed_bits))\\nLine 26 in _driver (Solution.py)\\n    _driver()\\nLine 35 in <module> (Solution.py)"
                    },
                    {
                        "username": "danek1313",
                        "content": "If I adapt Approach 1\\'s C++ option to Java, it fails with a Time Limit Exceeded. Why?"
                    },
                    {
                        "username": "ravikumarmanikyolla",
                        "content": "I have a more of a Java language question. My program failed for 2147483648 as an input. How is Java able to represent 2147483648 as an unsigned int value "
                    },
                    {
                        "username": "sethhu20",
                        "content": "I assume the follow up *If this function is called many times, how would you optimize it?* is just a \"interview\" style question without needing to necessarily code it out.\\n\\nBut I\\'m not quite sure what would be the idea for this question. It would be obvious to cache the results (as I saw some other answers), but that doesn\\'t sound like a convincing answer or if it is practical in real life, since if we assume the input is randomly distributed across the 32 bit unsigned integers range, then not only is the cache will rarely be useful, but also the space needed will grow to 32 bit size (a hashmap / array of 2^32 32 bit numbers takes up gigabytes of memory).\\n\\nWhat other optimization can be done in the event where these calls are randomly distributed along the 32 bit integer range?"
                    },
                    {
                        "username": "ankushmondal1y2t",
                        "content": "EASY 0ms BEATS 100% SOLUTION EASY TO UNDERSTAND\\n    uint32_t reverseBits(uint32_t n) {\\n        uint32_t r=0;\\n        for(int i=0;i<32;i++)\\n        {\\n            //n=n>>1;\\n            r<<=1;\\n            if((n&1)==1)\\n            {\\n                r++;\\n            }\\n            n>>=1;\\n        }\\n        return r;\\n    }"
                    }
                ]
            },
            {
                "id": 1976384,
                "content": [
                    {
                        "username": "Alptekin",
                        "content": "return Integer.reverse(n);\\n"
                    },
                    {
                        "username": "LakshmanMalviya",
                        "content": "Solution is of single line \" return Integer.reverse(n); \"\\nBeats 100%"
                    },
                    {
                        "username": "the_timmer",
                        "content": "For Python3, the Testcase / Result section was misleading to me.  It kept showing the Input as a binary.  But when I started off with a print(n), it clearly printed a decimal, not a binary.  This is more consistent with n being defined as int.  So I needed to convert n to a binary before doing anything else, and then I could get a successful submittal."
                    },
                    {
                        "username": "Pr1yankar",
                        "content": "supper easy in c. Time complexity O(1)\\nuint32_t reverseBits(uint32_t n) {\\n    uint32_t i = 0 , bit = 0;\\n    for(int j = 0 ; j<32;j++) i=i<<1,bit = (1&n) ,i += bit , n = n>>1;\\n    return i;\\n}"
                    },
                    {
                        "username": "imamanwp",
                        "content": "This question should be medium level of difficulty as this question is complex and requires understanding of bits manipulation and divide and conquer."
                    },
                    {
                        "username": "SiegeSailor",
                        "content": "My Python solution works on my terminal but not here:\\n\\n```python\\nclass Solution:\\n    def reverseBits(self, n: int) -> int:\\n        output = list(bin(n)[2:])\\n        pointer_start, pointer_end = 0, len(output) - 1\\n        while pointer_start < pointer_end:\\n            output[pointer_start], output[pointer_end] = output[pointer_end], output[pointer_start]\\n            pointer_start += 1\\n            pointer_end -= 1\\n        return \"\".join(output)\\n```\\n\\nIt keeps complaining:\\n\\n> ValueError: Unknown format code \\'b\\' for object of type \\'str\\'\\n    out = \"%12d (%s)\" % (reversed_bits, \\'{:032b}\\'.format(reversed_bits))\\nLine 26 in _driver (Solution.py)\\n    _driver()\\nLine 35 in <module> (Solution.py)"
                    },
                    {
                        "username": "danek1313",
                        "content": "If I adapt Approach 1\\'s C++ option to Java, it fails with a Time Limit Exceeded. Why?"
                    },
                    {
                        "username": "ravikumarmanikyolla",
                        "content": "I have a more of a Java language question. My program failed for 2147483648 as an input. How is Java able to represent 2147483648 as an unsigned int value "
                    },
                    {
                        "username": "sethhu20",
                        "content": "I assume the follow up *If this function is called many times, how would you optimize it?* is just a \"interview\" style question without needing to necessarily code it out.\\n\\nBut I\\'m not quite sure what would be the idea for this question. It would be obvious to cache the results (as I saw some other answers), but that doesn\\'t sound like a convincing answer or if it is practical in real life, since if we assume the input is randomly distributed across the 32 bit unsigned integers range, then not only is the cache will rarely be useful, but also the space needed will grow to 32 bit size (a hashmap / array of 2^32 32 bit numbers takes up gigabytes of memory).\\n\\nWhat other optimization can be done in the event where these calls are randomly distributed along the 32 bit integer range?"
                    },
                    {
                        "username": "ankushmondal1y2t",
                        "content": "EASY 0ms BEATS 100% SOLUTION EASY TO UNDERSTAND\\n    uint32_t reverseBits(uint32_t n) {\\n        uint32_t r=0;\\n        for(int i=0;i<32;i++)\\n        {\\n            //n=n>>1;\\n            r<<=1;\\n            if((n&1)==1)\\n            {\\n                r++;\\n            }\\n            n>>=1;\\n        }\\n        return r;\\n    }"
                    }
                ]
            },
            {
                "id": 1963653,
                "content": [
                    {
                        "username": "Alptekin",
                        "content": "return Integer.reverse(n);\\n"
                    },
                    {
                        "username": "LakshmanMalviya",
                        "content": "Solution is of single line \" return Integer.reverse(n); \"\\nBeats 100%"
                    },
                    {
                        "username": "the_timmer",
                        "content": "For Python3, the Testcase / Result section was misleading to me.  It kept showing the Input as a binary.  But when I started off with a print(n), it clearly printed a decimal, not a binary.  This is more consistent with n being defined as int.  So I needed to convert n to a binary before doing anything else, and then I could get a successful submittal."
                    },
                    {
                        "username": "Pr1yankar",
                        "content": "supper easy in c. Time complexity O(1)\\nuint32_t reverseBits(uint32_t n) {\\n    uint32_t i = 0 , bit = 0;\\n    for(int j = 0 ; j<32;j++) i=i<<1,bit = (1&n) ,i += bit , n = n>>1;\\n    return i;\\n}"
                    },
                    {
                        "username": "imamanwp",
                        "content": "This question should be medium level of difficulty as this question is complex and requires understanding of bits manipulation and divide and conquer."
                    },
                    {
                        "username": "SiegeSailor",
                        "content": "My Python solution works on my terminal but not here:\\n\\n```python\\nclass Solution:\\n    def reverseBits(self, n: int) -> int:\\n        output = list(bin(n)[2:])\\n        pointer_start, pointer_end = 0, len(output) - 1\\n        while pointer_start < pointer_end:\\n            output[pointer_start], output[pointer_end] = output[pointer_end], output[pointer_start]\\n            pointer_start += 1\\n            pointer_end -= 1\\n        return \"\".join(output)\\n```\\n\\nIt keeps complaining:\\n\\n> ValueError: Unknown format code \\'b\\' for object of type \\'str\\'\\n    out = \"%12d (%s)\" % (reversed_bits, \\'{:032b}\\'.format(reversed_bits))\\nLine 26 in _driver (Solution.py)\\n    _driver()\\nLine 35 in <module> (Solution.py)"
                    },
                    {
                        "username": "danek1313",
                        "content": "If I adapt Approach 1\\'s C++ option to Java, it fails with a Time Limit Exceeded. Why?"
                    },
                    {
                        "username": "ravikumarmanikyolla",
                        "content": "I have a more of a Java language question. My program failed for 2147483648 as an input. How is Java able to represent 2147483648 as an unsigned int value "
                    },
                    {
                        "username": "sethhu20",
                        "content": "I assume the follow up *If this function is called many times, how would you optimize it?* is just a \"interview\" style question without needing to necessarily code it out.\\n\\nBut I\\'m not quite sure what would be the idea for this question. It would be obvious to cache the results (as I saw some other answers), but that doesn\\'t sound like a convincing answer or if it is practical in real life, since if we assume the input is randomly distributed across the 32 bit unsigned integers range, then not only is the cache will rarely be useful, but also the space needed will grow to 32 bit size (a hashmap / array of 2^32 32 bit numbers takes up gigabytes of memory).\\n\\nWhat other optimization can be done in the event where these calls are randomly distributed along the 32 bit integer range?"
                    },
                    {
                        "username": "ankushmondal1y2t",
                        "content": "EASY 0ms BEATS 100% SOLUTION EASY TO UNDERSTAND\\n    uint32_t reverseBits(uint32_t n) {\\n        uint32_t r=0;\\n        for(int i=0;i<32;i++)\\n        {\\n            //n=n>>1;\\n            r<<=1;\\n            if((n&1)==1)\\n            {\\n                r++;\\n            }\\n            n>>=1;\\n        }\\n        return r;\\n    }"
                    }
                ]
            },
            {
                "id": 1931929,
                "content": [
                    {
                        "username": "Alptekin",
                        "content": "return Integer.reverse(n);\\n"
                    },
                    {
                        "username": "LakshmanMalviya",
                        "content": "Solution is of single line \" return Integer.reverse(n); \"\\nBeats 100%"
                    },
                    {
                        "username": "the_timmer",
                        "content": "For Python3, the Testcase / Result section was misleading to me.  It kept showing the Input as a binary.  But when I started off with a print(n), it clearly printed a decimal, not a binary.  This is more consistent with n being defined as int.  So I needed to convert n to a binary before doing anything else, and then I could get a successful submittal."
                    },
                    {
                        "username": "Pr1yankar",
                        "content": "supper easy in c. Time complexity O(1)\\nuint32_t reverseBits(uint32_t n) {\\n    uint32_t i = 0 , bit = 0;\\n    for(int j = 0 ; j<32;j++) i=i<<1,bit = (1&n) ,i += bit , n = n>>1;\\n    return i;\\n}"
                    },
                    {
                        "username": "imamanwp",
                        "content": "This question should be medium level of difficulty as this question is complex and requires understanding of bits manipulation and divide and conquer."
                    },
                    {
                        "username": "SiegeSailor",
                        "content": "My Python solution works on my terminal but not here:\\n\\n```python\\nclass Solution:\\n    def reverseBits(self, n: int) -> int:\\n        output = list(bin(n)[2:])\\n        pointer_start, pointer_end = 0, len(output) - 1\\n        while pointer_start < pointer_end:\\n            output[pointer_start], output[pointer_end] = output[pointer_end], output[pointer_start]\\n            pointer_start += 1\\n            pointer_end -= 1\\n        return \"\".join(output)\\n```\\n\\nIt keeps complaining:\\n\\n> ValueError: Unknown format code \\'b\\' for object of type \\'str\\'\\n    out = \"%12d (%s)\" % (reversed_bits, \\'{:032b}\\'.format(reversed_bits))\\nLine 26 in _driver (Solution.py)\\n    _driver()\\nLine 35 in <module> (Solution.py)"
                    },
                    {
                        "username": "danek1313",
                        "content": "If I adapt Approach 1\\'s C++ option to Java, it fails with a Time Limit Exceeded. Why?"
                    },
                    {
                        "username": "ravikumarmanikyolla",
                        "content": "I have a more of a Java language question. My program failed for 2147483648 as an input. How is Java able to represent 2147483648 as an unsigned int value "
                    },
                    {
                        "username": "sethhu20",
                        "content": "I assume the follow up *If this function is called many times, how would you optimize it?* is just a \"interview\" style question without needing to necessarily code it out.\\n\\nBut I\\'m not quite sure what would be the idea for this question. It would be obvious to cache the results (as I saw some other answers), but that doesn\\'t sound like a convincing answer or if it is practical in real life, since if we assume the input is randomly distributed across the 32 bit unsigned integers range, then not only is the cache will rarely be useful, but also the space needed will grow to 32 bit size (a hashmap / array of 2^32 32 bit numbers takes up gigabytes of memory).\\n\\nWhat other optimization can be done in the event where these calls are randomly distributed along the 32 bit integer range?"
                    },
                    {
                        "username": "ankushmondal1y2t",
                        "content": "EASY 0ms BEATS 100% SOLUTION EASY TO UNDERSTAND\\n    uint32_t reverseBits(uint32_t n) {\\n        uint32_t r=0;\\n        for(int i=0;i<32;i++)\\n        {\\n            //n=n>>1;\\n            r<<=1;\\n            if((n&1)==1)\\n            {\\n                r++;\\n            }\\n            n>>=1;\\n        }\\n        return r;\\n    }"
                    }
                ]
            },
            {
                "id": 1901966,
                "content": [
                    {
                        "username": "Alptekin",
                        "content": "return Integer.reverse(n);\\n"
                    },
                    {
                        "username": "LakshmanMalviya",
                        "content": "Solution is of single line \" return Integer.reverse(n); \"\\nBeats 100%"
                    },
                    {
                        "username": "the_timmer",
                        "content": "For Python3, the Testcase / Result section was misleading to me.  It kept showing the Input as a binary.  But when I started off with a print(n), it clearly printed a decimal, not a binary.  This is more consistent with n being defined as int.  So I needed to convert n to a binary before doing anything else, and then I could get a successful submittal."
                    },
                    {
                        "username": "Pr1yankar",
                        "content": "supper easy in c. Time complexity O(1)\\nuint32_t reverseBits(uint32_t n) {\\n    uint32_t i = 0 , bit = 0;\\n    for(int j = 0 ; j<32;j++) i=i<<1,bit = (1&n) ,i += bit , n = n>>1;\\n    return i;\\n}"
                    },
                    {
                        "username": "imamanwp",
                        "content": "This question should be medium level of difficulty as this question is complex and requires understanding of bits manipulation and divide and conquer."
                    },
                    {
                        "username": "SiegeSailor",
                        "content": "My Python solution works on my terminal but not here:\\n\\n```python\\nclass Solution:\\n    def reverseBits(self, n: int) -> int:\\n        output = list(bin(n)[2:])\\n        pointer_start, pointer_end = 0, len(output) - 1\\n        while pointer_start < pointer_end:\\n            output[pointer_start], output[pointer_end] = output[pointer_end], output[pointer_start]\\n            pointer_start += 1\\n            pointer_end -= 1\\n        return \"\".join(output)\\n```\\n\\nIt keeps complaining:\\n\\n> ValueError: Unknown format code \\'b\\' for object of type \\'str\\'\\n    out = \"%12d (%s)\" % (reversed_bits, \\'{:032b}\\'.format(reversed_bits))\\nLine 26 in _driver (Solution.py)\\n    _driver()\\nLine 35 in <module> (Solution.py)"
                    },
                    {
                        "username": "danek1313",
                        "content": "If I adapt Approach 1\\'s C++ option to Java, it fails with a Time Limit Exceeded. Why?"
                    },
                    {
                        "username": "ravikumarmanikyolla",
                        "content": "I have a more of a Java language question. My program failed for 2147483648 as an input. How is Java able to represent 2147483648 as an unsigned int value "
                    },
                    {
                        "username": "sethhu20",
                        "content": "I assume the follow up *If this function is called many times, how would you optimize it?* is just a \"interview\" style question without needing to necessarily code it out.\\n\\nBut I\\'m not quite sure what would be the idea for this question. It would be obvious to cache the results (as I saw some other answers), but that doesn\\'t sound like a convincing answer or if it is practical in real life, since if we assume the input is randomly distributed across the 32 bit unsigned integers range, then not only is the cache will rarely be useful, but also the space needed will grow to 32 bit size (a hashmap / array of 2^32 32 bit numbers takes up gigabytes of memory).\\n\\nWhat other optimization can be done in the event where these calls are randomly distributed along the 32 bit integer range?"
                    },
                    {
                        "username": "ankushmondal1y2t",
                        "content": "EASY 0ms BEATS 100% SOLUTION EASY TO UNDERSTAND\\n    uint32_t reverseBits(uint32_t n) {\\n        uint32_t r=0;\\n        for(int i=0;i<32;i++)\\n        {\\n            //n=n>>1;\\n            r<<=1;\\n            if((n&1)==1)\\n            {\\n                r++;\\n            }\\n            n>>=1;\\n        }\\n        return r;\\n    }"
                    }
                ]
            },
            {
                "id": 1881339,
                "content": [
                    {
                        "username": "Alptekin",
                        "content": "return Integer.reverse(n);\\n"
                    },
                    {
                        "username": "LakshmanMalviya",
                        "content": "Solution is of single line \" return Integer.reverse(n); \"\\nBeats 100%"
                    },
                    {
                        "username": "the_timmer",
                        "content": "For Python3, the Testcase / Result section was misleading to me.  It kept showing the Input as a binary.  But when I started off with a print(n), it clearly printed a decimal, not a binary.  This is more consistent with n being defined as int.  So I needed to convert n to a binary before doing anything else, and then I could get a successful submittal."
                    },
                    {
                        "username": "Pr1yankar",
                        "content": "supper easy in c. Time complexity O(1)\\nuint32_t reverseBits(uint32_t n) {\\n    uint32_t i = 0 , bit = 0;\\n    for(int j = 0 ; j<32;j++) i=i<<1,bit = (1&n) ,i += bit , n = n>>1;\\n    return i;\\n}"
                    },
                    {
                        "username": "imamanwp",
                        "content": "This question should be medium level of difficulty as this question is complex and requires understanding of bits manipulation and divide and conquer."
                    },
                    {
                        "username": "SiegeSailor",
                        "content": "My Python solution works on my terminal but not here:\\n\\n```python\\nclass Solution:\\n    def reverseBits(self, n: int) -> int:\\n        output = list(bin(n)[2:])\\n        pointer_start, pointer_end = 0, len(output) - 1\\n        while pointer_start < pointer_end:\\n            output[pointer_start], output[pointer_end] = output[pointer_end], output[pointer_start]\\n            pointer_start += 1\\n            pointer_end -= 1\\n        return \"\".join(output)\\n```\\n\\nIt keeps complaining:\\n\\n> ValueError: Unknown format code \\'b\\' for object of type \\'str\\'\\n    out = \"%12d (%s)\" % (reversed_bits, \\'{:032b}\\'.format(reversed_bits))\\nLine 26 in _driver (Solution.py)\\n    _driver()\\nLine 35 in <module> (Solution.py)"
                    },
                    {
                        "username": "danek1313",
                        "content": "If I adapt Approach 1\\'s C++ option to Java, it fails with a Time Limit Exceeded. Why?"
                    },
                    {
                        "username": "ravikumarmanikyolla",
                        "content": "I have a more of a Java language question. My program failed for 2147483648 as an input. How is Java able to represent 2147483648 as an unsigned int value "
                    },
                    {
                        "username": "sethhu20",
                        "content": "I assume the follow up *If this function is called many times, how would you optimize it?* is just a \"interview\" style question without needing to necessarily code it out.\\n\\nBut I\\'m not quite sure what would be the idea for this question. It would be obvious to cache the results (as I saw some other answers), but that doesn\\'t sound like a convincing answer or if it is practical in real life, since if we assume the input is randomly distributed across the 32 bit unsigned integers range, then not only is the cache will rarely be useful, but also the space needed will grow to 32 bit size (a hashmap / array of 2^32 32 bit numbers takes up gigabytes of memory).\\n\\nWhat other optimization can be done in the event where these calls are randomly distributed along the 32 bit integer range?"
                    },
                    {
                        "username": "ankushmondal1y2t",
                        "content": "EASY 0ms BEATS 100% SOLUTION EASY TO UNDERSTAND\\n    uint32_t reverseBits(uint32_t n) {\\n        uint32_t r=0;\\n        for(int i=0;i<32;i++)\\n        {\\n            //n=n>>1;\\n            r<<=1;\\n            if((n&1)==1)\\n            {\\n                r++;\\n            }\\n            n>>=1;\\n        }\\n        return r;\\n    }"
                    }
                ]
            },
            {
                "id": 1849699,
                "content": [
                    {
                        "username": "kingp",
                        "content": "This code is really hard to understand Please can anyone help me understand . Thanking you in Advance....\\n```\\nclass Solution {\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        n = (n >> 16) | (n << 16);\\n        n = ((n & 0xff00ff00) >> 8) | ((n & 0x00ff00ff) << 8);\\n        n = ((n & 0xf0f0f0f0) >> 4) | ((n & 0x0f0f0f0f) << 4);\\n        n = ((n & 0xcccccccc) >> 2) | ((n & 0x33333333) << 2);\\n        n = ((n & 0xaaaaaaaa) >> 1) | ((n & 0x55555555) << 1);\\n        return n;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "cheguvera",
                        "content": "Hi\\nKindly help me with the following\\nI am getting the following run time error.\\n\\nLine 17: Char 12: runtime error: shift exponent 32 is too large for 32-bit type \\'uint32_t\\' (aka \\'unsigned int\\') (solution.cpp)\\n\\nthe place corresponds to \\nb=b<<(32-cnt);\\nwhere cnt is bit length of number\\nIf i replace this by for loop to run till 32(bit size of uint32_t), i am not getting and also code is passed. \\nKindly help me why is this problem coming"
                    },
                    {
                        "username": "NIkhil_Rathi93",
                        "content": " public int reverseBits(int n) {\n        String num = Integer.toBinaryString(n);\n        String ans=\"\";\n        for(int i=num.length()-1;i>0;i--){\n            ans +=num.charAt(i);\n        } \n       int fn = Integer.parseInt(ans);  \n        return fn;\n    }\n\nWHAT AM I DOING WRONG HERE??"
                    },
                    {
                        "username": "codebothot",
                        "content": " `public class Solution {\\n\n    // you need treat n as an unsigned value\\n\n    public int reverseBits(int n) {\\n\n        int k = 32;\\n\n        int ans = 0;\n        while(k-- >= 0) {\n            ans += Math.pow(2,k) * (n %2);\n            n = n>>>1;\n        }\n        return ans;\n    }\n}`\n\nwhy does this Java code fail for I/P: 00000000000000000000000000000001\n\nexpected O/P: 2147483648\nO/P: 2147483647"
                    },
                    {
                        "username": "Frankie_Lee",
                        "content": "```cpp\\nclass Solution {\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        int pos = 31,reverse = 0;\\n        while(pos >= 0 && n){\\n            if(n & 1){\\n                reverse |= (1 << pos);\\n            }\\n            n >>= 1;\\n            pos--;\\n        }\\n        return reverse;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Just a normal question until you realize"
                    },
                    {
                        "username": "mobeenyaqub",
                        "content": "class Solution:\\n    def reverseBits(self, n: int) -> int:\\n        n = str(n)\\n        ans = 0\\n        for i in range(len(n)):\\n            if n[i] == \\'1\\':\\n                ans += 2 ** i\\n\\n        return ans\\n\\n\\nPycharm is giving correct answer, but leetcode is giving me totally wrong answer for the sample inputs."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/190_Reverse_Bits.cpp"
                    },
                    {
                        "username": "AdiechaHK",
                        "content": "here is the quick solution for python3\\n\\n```\\nclass Solution:\\n    def reverseBits(self, n: int) -> int:\\n        return int(\"{:032b}\".format(n)[::-1], 2)\\n```"
                    },
                    {
                        "username": "Ajantharajah",
                        "content": "Can anyone explain why it isn\\'t working\\n\\nuint32_t reverseBits(uint32_t n) {\\n        uint32_t ans = 0;\\n        for(int i=1; i<=32;i++) {\\n            ans = ans + (n&1)<<(32-i);\\n            n = n>>1;\\n        }\\n        return ans;\\n    } "
                    },
                    {
                        "username": "Ajantharajah",
                        "content": "got it. it should be or instead of +\\nans = ans | (n&1)<<(32-i);"
                    }
                ]
            },
            {
                "id": 1841375,
                "content": [
                    {
                        "username": "kingp",
                        "content": "This code is really hard to understand Please can anyone help me understand . Thanking you in Advance....\\n```\\nclass Solution {\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        n = (n >> 16) | (n << 16);\\n        n = ((n & 0xff00ff00) >> 8) | ((n & 0x00ff00ff) << 8);\\n        n = ((n & 0xf0f0f0f0) >> 4) | ((n & 0x0f0f0f0f) << 4);\\n        n = ((n & 0xcccccccc) >> 2) | ((n & 0x33333333) << 2);\\n        n = ((n & 0xaaaaaaaa) >> 1) | ((n & 0x55555555) << 1);\\n        return n;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "cheguvera",
                        "content": "Hi\\nKindly help me with the following\\nI am getting the following run time error.\\n\\nLine 17: Char 12: runtime error: shift exponent 32 is too large for 32-bit type \\'uint32_t\\' (aka \\'unsigned int\\') (solution.cpp)\\n\\nthe place corresponds to \\nb=b<<(32-cnt);\\nwhere cnt is bit length of number\\nIf i replace this by for loop to run till 32(bit size of uint32_t), i am not getting and also code is passed. \\nKindly help me why is this problem coming"
                    },
                    {
                        "username": "NIkhil_Rathi93",
                        "content": " public int reverseBits(int n) {\n        String num = Integer.toBinaryString(n);\n        String ans=\"\";\n        for(int i=num.length()-1;i>0;i--){\n            ans +=num.charAt(i);\n        } \n       int fn = Integer.parseInt(ans);  \n        return fn;\n    }\n\nWHAT AM I DOING WRONG HERE??"
                    },
                    {
                        "username": "codebothot",
                        "content": " `public class Solution {\\n\n    // you need treat n as an unsigned value\\n\n    public int reverseBits(int n) {\\n\n        int k = 32;\\n\n        int ans = 0;\n        while(k-- >= 0) {\n            ans += Math.pow(2,k) * (n %2);\n            n = n>>>1;\n        }\n        return ans;\n    }\n}`\n\nwhy does this Java code fail for I/P: 00000000000000000000000000000001\n\nexpected O/P: 2147483648\nO/P: 2147483647"
                    },
                    {
                        "username": "Frankie_Lee",
                        "content": "```cpp\\nclass Solution {\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        int pos = 31,reverse = 0;\\n        while(pos >= 0 && n){\\n            if(n & 1){\\n                reverse |= (1 << pos);\\n            }\\n            n >>= 1;\\n            pos--;\\n        }\\n        return reverse;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Just a normal question until you realize"
                    },
                    {
                        "username": "mobeenyaqub",
                        "content": "class Solution:\\n    def reverseBits(self, n: int) -> int:\\n        n = str(n)\\n        ans = 0\\n        for i in range(len(n)):\\n            if n[i] == \\'1\\':\\n                ans += 2 ** i\\n\\n        return ans\\n\\n\\nPycharm is giving correct answer, but leetcode is giving me totally wrong answer for the sample inputs."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/190_Reverse_Bits.cpp"
                    },
                    {
                        "username": "AdiechaHK",
                        "content": "here is the quick solution for python3\\n\\n```\\nclass Solution:\\n    def reverseBits(self, n: int) -> int:\\n        return int(\"{:032b}\".format(n)[::-1], 2)\\n```"
                    },
                    {
                        "username": "Ajantharajah",
                        "content": "Can anyone explain why it isn\\'t working\\n\\nuint32_t reverseBits(uint32_t n) {\\n        uint32_t ans = 0;\\n        for(int i=1; i<=32;i++) {\\n            ans = ans + (n&1)<<(32-i);\\n            n = n>>1;\\n        }\\n        return ans;\\n    } "
                    },
                    {
                        "username": "Ajantharajah",
                        "content": "got it. it should be or instead of +\\nans = ans | (n&1)<<(32-i);"
                    }
                ]
            },
            {
                "id": 1835764,
                "content": [
                    {
                        "username": "kingp",
                        "content": "This code is really hard to understand Please can anyone help me understand . Thanking you in Advance....\\n```\\nclass Solution {\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        n = (n >> 16) | (n << 16);\\n        n = ((n & 0xff00ff00) >> 8) | ((n & 0x00ff00ff) << 8);\\n        n = ((n & 0xf0f0f0f0) >> 4) | ((n & 0x0f0f0f0f) << 4);\\n        n = ((n & 0xcccccccc) >> 2) | ((n & 0x33333333) << 2);\\n        n = ((n & 0xaaaaaaaa) >> 1) | ((n & 0x55555555) << 1);\\n        return n;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "cheguvera",
                        "content": "Hi\\nKindly help me with the following\\nI am getting the following run time error.\\n\\nLine 17: Char 12: runtime error: shift exponent 32 is too large for 32-bit type \\'uint32_t\\' (aka \\'unsigned int\\') (solution.cpp)\\n\\nthe place corresponds to \\nb=b<<(32-cnt);\\nwhere cnt is bit length of number\\nIf i replace this by for loop to run till 32(bit size of uint32_t), i am not getting and also code is passed. \\nKindly help me why is this problem coming"
                    },
                    {
                        "username": "NIkhil_Rathi93",
                        "content": " public int reverseBits(int n) {\n        String num = Integer.toBinaryString(n);\n        String ans=\"\";\n        for(int i=num.length()-1;i>0;i--){\n            ans +=num.charAt(i);\n        } \n       int fn = Integer.parseInt(ans);  \n        return fn;\n    }\n\nWHAT AM I DOING WRONG HERE??"
                    },
                    {
                        "username": "codebothot",
                        "content": " `public class Solution {\\n\n    // you need treat n as an unsigned value\\n\n    public int reverseBits(int n) {\\n\n        int k = 32;\\n\n        int ans = 0;\n        while(k-- >= 0) {\n            ans += Math.pow(2,k) * (n %2);\n            n = n>>>1;\n        }\n        return ans;\n    }\n}`\n\nwhy does this Java code fail for I/P: 00000000000000000000000000000001\n\nexpected O/P: 2147483648\nO/P: 2147483647"
                    },
                    {
                        "username": "Frankie_Lee",
                        "content": "```cpp\\nclass Solution {\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        int pos = 31,reverse = 0;\\n        while(pos >= 0 && n){\\n            if(n & 1){\\n                reverse |= (1 << pos);\\n            }\\n            n >>= 1;\\n            pos--;\\n        }\\n        return reverse;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Just a normal question until you realize"
                    },
                    {
                        "username": "mobeenyaqub",
                        "content": "class Solution:\\n    def reverseBits(self, n: int) -> int:\\n        n = str(n)\\n        ans = 0\\n        for i in range(len(n)):\\n            if n[i] == \\'1\\':\\n                ans += 2 ** i\\n\\n        return ans\\n\\n\\nPycharm is giving correct answer, but leetcode is giving me totally wrong answer for the sample inputs."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/190_Reverse_Bits.cpp"
                    },
                    {
                        "username": "AdiechaHK",
                        "content": "here is the quick solution for python3\\n\\n```\\nclass Solution:\\n    def reverseBits(self, n: int) -> int:\\n        return int(\"{:032b}\".format(n)[::-1], 2)\\n```"
                    },
                    {
                        "username": "Ajantharajah",
                        "content": "Can anyone explain why it isn\\'t working\\n\\nuint32_t reverseBits(uint32_t n) {\\n        uint32_t ans = 0;\\n        for(int i=1; i<=32;i++) {\\n            ans = ans + (n&1)<<(32-i);\\n            n = n>>1;\\n        }\\n        return ans;\\n    } "
                    },
                    {
                        "username": "Ajantharajah",
                        "content": "got it. it should be or instead of +\\nans = ans | (n&1)<<(32-i);"
                    }
                ]
            },
            {
                "id": 1798129,
                "content": [
                    {
                        "username": "kingp",
                        "content": "This code is really hard to understand Please can anyone help me understand . Thanking you in Advance....\\n```\\nclass Solution {\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        n = (n >> 16) | (n << 16);\\n        n = ((n & 0xff00ff00) >> 8) | ((n & 0x00ff00ff) << 8);\\n        n = ((n & 0xf0f0f0f0) >> 4) | ((n & 0x0f0f0f0f) << 4);\\n        n = ((n & 0xcccccccc) >> 2) | ((n & 0x33333333) << 2);\\n        n = ((n & 0xaaaaaaaa) >> 1) | ((n & 0x55555555) << 1);\\n        return n;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "cheguvera",
                        "content": "Hi\\nKindly help me with the following\\nI am getting the following run time error.\\n\\nLine 17: Char 12: runtime error: shift exponent 32 is too large for 32-bit type \\'uint32_t\\' (aka \\'unsigned int\\') (solution.cpp)\\n\\nthe place corresponds to \\nb=b<<(32-cnt);\\nwhere cnt is bit length of number\\nIf i replace this by for loop to run till 32(bit size of uint32_t), i am not getting and also code is passed. \\nKindly help me why is this problem coming"
                    },
                    {
                        "username": "NIkhil_Rathi93",
                        "content": " public int reverseBits(int n) {\n        String num = Integer.toBinaryString(n);\n        String ans=\"\";\n        for(int i=num.length()-1;i>0;i--){\n            ans +=num.charAt(i);\n        } \n       int fn = Integer.parseInt(ans);  \n        return fn;\n    }\n\nWHAT AM I DOING WRONG HERE??"
                    },
                    {
                        "username": "codebothot",
                        "content": " `public class Solution {\\n\n    // you need treat n as an unsigned value\\n\n    public int reverseBits(int n) {\\n\n        int k = 32;\\n\n        int ans = 0;\n        while(k-- >= 0) {\n            ans += Math.pow(2,k) * (n %2);\n            n = n>>>1;\n        }\n        return ans;\n    }\n}`\n\nwhy does this Java code fail for I/P: 00000000000000000000000000000001\n\nexpected O/P: 2147483648\nO/P: 2147483647"
                    },
                    {
                        "username": "Frankie_Lee",
                        "content": "```cpp\\nclass Solution {\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        int pos = 31,reverse = 0;\\n        while(pos >= 0 && n){\\n            if(n & 1){\\n                reverse |= (1 << pos);\\n            }\\n            n >>= 1;\\n            pos--;\\n        }\\n        return reverse;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Just a normal question until you realize"
                    },
                    {
                        "username": "mobeenyaqub",
                        "content": "class Solution:\\n    def reverseBits(self, n: int) -> int:\\n        n = str(n)\\n        ans = 0\\n        for i in range(len(n)):\\n            if n[i] == \\'1\\':\\n                ans += 2 ** i\\n\\n        return ans\\n\\n\\nPycharm is giving correct answer, but leetcode is giving me totally wrong answer for the sample inputs."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/190_Reverse_Bits.cpp"
                    },
                    {
                        "username": "AdiechaHK",
                        "content": "here is the quick solution for python3\\n\\n```\\nclass Solution:\\n    def reverseBits(self, n: int) -> int:\\n        return int(\"{:032b}\".format(n)[::-1], 2)\\n```"
                    },
                    {
                        "username": "Ajantharajah",
                        "content": "Can anyone explain why it isn\\'t working\\n\\nuint32_t reverseBits(uint32_t n) {\\n        uint32_t ans = 0;\\n        for(int i=1; i<=32;i++) {\\n            ans = ans + (n&1)<<(32-i);\\n            n = n>>1;\\n        }\\n        return ans;\\n    } "
                    },
                    {
                        "username": "Ajantharajah",
                        "content": "got it. it should be or instead of +\\nans = ans | (n&1)<<(32-i);"
                    }
                ]
            },
            {
                "id": 1793181,
                "content": [
                    {
                        "username": "kingp",
                        "content": "This code is really hard to understand Please can anyone help me understand . Thanking you in Advance....\\n```\\nclass Solution {\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        n = (n >> 16) | (n << 16);\\n        n = ((n & 0xff00ff00) >> 8) | ((n & 0x00ff00ff) << 8);\\n        n = ((n & 0xf0f0f0f0) >> 4) | ((n & 0x0f0f0f0f) << 4);\\n        n = ((n & 0xcccccccc) >> 2) | ((n & 0x33333333) << 2);\\n        n = ((n & 0xaaaaaaaa) >> 1) | ((n & 0x55555555) << 1);\\n        return n;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "cheguvera",
                        "content": "Hi\\nKindly help me with the following\\nI am getting the following run time error.\\n\\nLine 17: Char 12: runtime error: shift exponent 32 is too large for 32-bit type \\'uint32_t\\' (aka \\'unsigned int\\') (solution.cpp)\\n\\nthe place corresponds to \\nb=b<<(32-cnt);\\nwhere cnt is bit length of number\\nIf i replace this by for loop to run till 32(bit size of uint32_t), i am not getting and also code is passed. \\nKindly help me why is this problem coming"
                    },
                    {
                        "username": "NIkhil_Rathi93",
                        "content": " public int reverseBits(int n) {\n        String num = Integer.toBinaryString(n);\n        String ans=\"\";\n        for(int i=num.length()-1;i>0;i--){\n            ans +=num.charAt(i);\n        } \n       int fn = Integer.parseInt(ans);  \n        return fn;\n    }\n\nWHAT AM I DOING WRONG HERE??"
                    },
                    {
                        "username": "codebothot",
                        "content": " `public class Solution {\\n\n    // you need treat n as an unsigned value\\n\n    public int reverseBits(int n) {\\n\n        int k = 32;\\n\n        int ans = 0;\n        while(k-- >= 0) {\n            ans += Math.pow(2,k) * (n %2);\n            n = n>>>1;\n        }\n        return ans;\n    }\n}`\n\nwhy does this Java code fail for I/P: 00000000000000000000000000000001\n\nexpected O/P: 2147483648\nO/P: 2147483647"
                    },
                    {
                        "username": "Frankie_Lee",
                        "content": "```cpp\\nclass Solution {\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        int pos = 31,reverse = 0;\\n        while(pos >= 0 && n){\\n            if(n & 1){\\n                reverse |= (1 << pos);\\n            }\\n            n >>= 1;\\n            pos--;\\n        }\\n        return reverse;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Just a normal question until you realize"
                    },
                    {
                        "username": "mobeenyaqub",
                        "content": "class Solution:\\n    def reverseBits(self, n: int) -> int:\\n        n = str(n)\\n        ans = 0\\n        for i in range(len(n)):\\n            if n[i] == \\'1\\':\\n                ans += 2 ** i\\n\\n        return ans\\n\\n\\nPycharm is giving correct answer, but leetcode is giving me totally wrong answer for the sample inputs."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/190_Reverse_Bits.cpp"
                    },
                    {
                        "username": "AdiechaHK",
                        "content": "here is the quick solution for python3\\n\\n```\\nclass Solution:\\n    def reverseBits(self, n: int) -> int:\\n        return int(\"{:032b}\".format(n)[::-1], 2)\\n```"
                    },
                    {
                        "username": "Ajantharajah",
                        "content": "Can anyone explain why it isn\\'t working\\n\\nuint32_t reverseBits(uint32_t n) {\\n        uint32_t ans = 0;\\n        for(int i=1; i<=32;i++) {\\n            ans = ans + (n&1)<<(32-i);\\n            n = n>>1;\\n        }\\n        return ans;\\n    } "
                    },
                    {
                        "username": "Ajantharajah",
                        "content": "got it. it should be or instead of +\\nans = ans | (n&1)<<(32-i);"
                    }
                ]
            },
            {
                "id": 1787179,
                "content": [
                    {
                        "username": "kingp",
                        "content": "This code is really hard to understand Please can anyone help me understand . Thanking you in Advance....\\n```\\nclass Solution {\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        n = (n >> 16) | (n << 16);\\n        n = ((n & 0xff00ff00) >> 8) | ((n & 0x00ff00ff) << 8);\\n        n = ((n & 0xf0f0f0f0) >> 4) | ((n & 0x0f0f0f0f) << 4);\\n        n = ((n & 0xcccccccc) >> 2) | ((n & 0x33333333) << 2);\\n        n = ((n & 0xaaaaaaaa) >> 1) | ((n & 0x55555555) << 1);\\n        return n;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "cheguvera",
                        "content": "Hi\\nKindly help me with the following\\nI am getting the following run time error.\\n\\nLine 17: Char 12: runtime error: shift exponent 32 is too large for 32-bit type \\'uint32_t\\' (aka \\'unsigned int\\') (solution.cpp)\\n\\nthe place corresponds to \\nb=b<<(32-cnt);\\nwhere cnt is bit length of number\\nIf i replace this by for loop to run till 32(bit size of uint32_t), i am not getting and also code is passed. \\nKindly help me why is this problem coming"
                    },
                    {
                        "username": "NIkhil_Rathi93",
                        "content": " public int reverseBits(int n) {\n        String num = Integer.toBinaryString(n);\n        String ans=\"\";\n        for(int i=num.length()-1;i>0;i--){\n            ans +=num.charAt(i);\n        } \n       int fn = Integer.parseInt(ans);  \n        return fn;\n    }\n\nWHAT AM I DOING WRONG HERE??"
                    },
                    {
                        "username": "codebothot",
                        "content": " `public class Solution {\\n\n    // you need treat n as an unsigned value\\n\n    public int reverseBits(int n) {\\n\n        int k = 32;\\n\n        int ans = 0;\n        while(k-- >= 0) {\n            ans += Math.pow(2,k) * (n %2);\n            n = n>>>1;\n        }\n        return ans;\n    }\n}`\n\nwhy does this Java code fail for I/P: 00000000000000000000000000000001\n\nexpected O/P: 2147483648\nO/P: 2147483647"
                    },
                    {
                        "username": "Frankie_Lee",
                        "content": "```cpp\\nclass Solution {\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        int pos = 31,reverse = 0;\\n        while(pos >= 0 && n){\\n            if(n & 1){\\n                reverse |= (1 << pos);\\n            }\\n            n >>= 1;\\n            pos--;\\n        }\\n        return reverse;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Just a normal question until you realize"
                    },
                    {
                        "username": "mobeenyaqub",
                        "content": "class Solution:\\n    def reverseBits(self, n: int) -> int:\\n        n = str(n)\\n        ans = 0\\n        for i in range(len(n)):\\n            if n[i] == \\'1\\':\\n                ans += 2 ** i\\n\\n        return ans\\n\\n\\nPycharm is giving correct answer, but leetcode is giving me totally wrong answer for the sample inputs."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/190_Reverse_Bits.cpp"
                    },
                    {
                        "username": "AdiechaHK",
                        "content": "here is the quick solution for python3\\n\\n```\\nclass Solution:\\n    def reverseBits(self, n: int) -> int:\\n        return int(\"{:032b}\".format(n)[::-1], 2)\\n```"
                    },
                    {
                        "username": "Ajantharajah",
                        "content": "Can anyone explain why it isn\\'t working\\n\\nuint32_t reverseBits(uint32_t n) {\\n        uint32_t ans = 0;\\n        for(int i=1; i<=32;i++) {\\n            ans = ans + (n&1)<<(32-i);\\n            n = n>>1;\\n        }\\n        return ans;\\n    } "
                    },
                    {
                        "username": "Ajantharajah",
                        "content": "got it. it should be or instead of +\\nans = ans | (n&1)<<(32-i);"
                    }
                ]
            },
            {
                "id": 1783590,
                "content": [
                    {
                        "username": "kingp",
                        "content": "This code is really hard to understand Please can anyone help me understand . Thanking you in Advance....\\n```\\nclass Solution {\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        n = (n >> 16) | (n << 16);\\n        n = ((n & 0xff00ff00) >> 8) | ((n & 0x00ff00ff) << 8);\\n        n = ((n & 0xf0f0f0f0) >> 4) | ((n & 0x0f0f0f0f) << 4);\\n        n = ((n & 0xcccccccc) >> 2) | ((n & 0x33333333) << 2);\\n        n = ((n & 0xaaaaaaaa) >> 1) | ((n & 0x55555555) << 1);\\n        return n;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "cheguvera",
                        "content": "Hi\\nKindly help me with the following\\nI am getting the following run time error.\\n\\nLine 17: Char 12: runtime error: shift exponent 32 is too large for 32-bit type \\'uint32_t\\' (aka \\'unsigned int\\') (solution.cpp)\\n\\nthe place corresponds to \\nb=b<<(32-cnt);\\nwhere cnt is bit length of number\\nIf i replace this by for loop to run till 32(bit size of uint32_t), i am not getting and also code is passed. \\nKindly help me why is this problem coming"
                    },
                    {
                        "username": "NIkhil_Rathi93",
                        "content": " public int reverseBits(int n) {\n        String num = Integer.toBinaryString(n);\n        String ans=\"\";\n        for(int i=num.length()-1;i>0;i--){\n            ans +=num.charAt(i);\n        } \n       int fn = Integer.parseInt(ans);  \n        return fn;\n    }\n\nWHAT AM I DOING WRONG HERE??"
                    },
                    {
                        "username": "codebothot",
                        "content": " `public class Solution {\\n\n    // you need treat n as an unsigned value\\n\n    public int reverseBits(int n) {\\n\n        int k = 32;\\n\n        int ans = 0;\n        while(k-- >= 0) {\n            ans += Math.pow(2,k) * (n %2);\n            n = n>>>1;\n        }\n        return ans;\n    }\n}`\n\nwhy does this Java code fail for I/P: 00000000000000000000000000000001\n\nexpected O/P: 2147483648\nO/P: 2147483647"
                    },
                    {
                        "username": "Frankie_Lee",
                        "content": "```cpp\\nclass Solution {\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        int pos = 31,reverse = 0;\\n        while(pos >= 0 && n){\\n            if(n & 1){\\n                reverse |= (1 << pos);\\n            }\\n            n >>= 1;\\n            pos--;\\n        }\\n        return reverse;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Just a normal question until you realize"
                    },
                    {
                        "username": "mobeenyaqub",
                        "content": "class Solution:\\n    def reverseBits(self, n: int) -> int:\\n        n = str(n)\\n        ans = 0\\n        for i in range(len(n)):\\n            if n[i] == \\'1\\':\\n                ans += 2 ** i\\n\\n        return ans\\n\\n\\nPycharm is giving correct answer, but leetcode is giving me totally wrong answer for the sample inputs."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/190_Reverse_Bits.cpp"
                    },
                    {
                        "username": "AdiechaHK",
                        "content": "here is the quick solution for python3\\n\\n```\\nclass Solution:\\n    def reverseBits(self, n: int) -> int:\\n        return int(\"{:032b}\".format(n)[::-1], 2)\\n```"
                    },
                    {
                        "username": "Ajantharajah",
                        "content": "Can anyone explain why it isn\\'t working\\n\\nuint32_t reverseBits(uint32_t n) {\\n        uint32_t ans = 0;\\n        for(int i=1; i<=32;i++) {\\n            ans = ans + (n&1)<<(32-i);\\n            n = n>>1;\\n        }\\n        return ans;\\n    } "
                    },
                    {
                        "username": "Ajantharajah",
                        "content": "got it. it should be or instead of +\\nans = ans | (n&1)<<(32-i);"
                    }
                ]
            },
            {
                "id": 1772313,
                "content": [
                    {
                        "username": "kingp",
                        "content": "This code is really hard to understand Please can anyone help me understand . Thanking you in Advance....\\n```\\nclass Solution {\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        n = (n >> 16) | (n << 16);\\n        n = ((n & 0xff00ff00) >> 8) | ((n & 0x00ff00ff) << 8);\\n        n = ((n & 0xf0f0f0f0) >> 4) | ((n & 0x0f0f0f0f) << 4);\\n        n = ((n & 0xcccccccc) >> 2) | ((n & 0x33333333) << 2);\\n        n = ((n & 0xaaaaaaaa) >> 1) | ((n & 0x55555555) << 1);\\n        return n;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "cheguvera",
                        "content": "Hi\\nKindly help me with the following\\nI am getting the following run time error.\\n\\nLine 17: Char 12: runtime error: shift exponent 32 is too large for 32-bit type \\'uint32_t\\' (aka \\'unsigned int\\') (solution.cpp)\\n\\nthe place corresponds to \\nb=b<<(32-cnt);\\nwhere cnt is bit length of number\\nIf i replace this by for loop to run till 32(bit size of uint32_t), i am not getting and also code is passed. \\nKindly help me why is this problem coming"
                    },
                    {
                        "username": "NIkhil_Rathi93",
                        "content": " public int reverseBits(int n) {\n        String num = Integer.toBinaryString(n);\n        String ans=\"\";\n        for(int i=num.length()-1;i>0;i--){\n            ans +=num.charAt(i);\n        } \n       int fn = Integer.parseInt(ans);  \n        return fn;\n    }\n\nWHAT AM I DOING WRONG HERE??"
                    },
                    {
                        "username": "codebothot",
                        "content": " `public class Solution {\\n\n    // you need treat n as an unsigned value\\n\n    public int reverseBits(int n) {\\n\n        int k = 32;\\n\n        int ans = 0;\n        while(k-- >= 0) {\n            ans += Math.pow(2,k) * (n %2);\n            n = n>>>1;\n        }\n        return ans;\n    }\n}`\n\nwhy does this Java code fail for I/P: 00000000000000000000000000000001\n\nexpected O/P: 2147483648\nO/P: 2147483647"
                    },
                    {
                        "username": "Frankie_Lee",
                        "content": "```cpp\\nclass Solution {\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        int pos = 31,reverse = 0;\\n        while(pos >= 0 && n){\\n            if(n & 1){\\n                reverse |= (1 << pos);\\n            }\\n            n >>= 1;\\n            pos--;\\n        }\\n        return reverse;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Just a normal question until you realize"
                    },
                    {
                        "username": "mobeenyaqub",
                        "content": "class Solution:\\n    def reverseBits(self, n: int) -> int:\\n        n = str(n)\\n        ans = 0\\n        for i in range(len(n)):\\n            if n[i] == \\'1\\':\\n                ans += 2 ** i\\n\\n        return ans\\n\\n\\nPycharm is giving correct answer, but leetcode is giving me totally wrong answer for the sample inputs."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/190_Reverse_Bits.cpp"
                    },
                    {
                        "username": "AdiechaHK",
                        "content": "here is the quick solution for python3\\n\\n```\\nclass Solution:\\n    def reverseBits(self, n: int) -> int:\\n        return int(\"{:032b}\".format(n)[::-1], 2)\\n```"
                    },
                    {
                        "username": "Ajantharajah",
                        "content": "Can anyone explain why it isn\\'t working\\n\\nuint32_t reverseBits(uint32_t n) {\\n        uint32_t ans = 0;\\n        for(int i=1; i<=32;i++) {\\n            ans = ans + (n&1)<<(32-i);\\n            n = n>>1;\\n        }\\n        return ans;\\n    } "
                    },
                    {
                        "username": "Ajantharajah",
                        "content": "got it. it should be or instead of +\\nans = ans | (n&1)<<(32-i);"
                    }
                ]
            },
            {
                "id": 1760330,
                "content": [
                    {
                        "username": "kingp",
                        "content": "This code is really hard to understand Please can anyone help me understand . Thanking you in Advance....\\n```\\nclass Solution {\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        n = (n >> 16) | (n << 16);\\n        n = ((n & 0xff00ff00) >> 8) | ((n & 0x00ff00ff) << 8);\\n        n = ((n & 0xf0f0f0f0) >> 4) | ((n & 0x0f0f0f0f) << 4);\\n        n = ((n & 0xcccccccc) >> 2) | ((n & 0x33333333) << 2);\\n        n = ((n & 0xaaaaaaaa) >> 1) | ((n & 0x55555555) << 1);\\n        return n;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "cheguvera",
                        "content": "Hi\\nKindly help me with the following\\nI am getting the following run time error.\\n\\nLine 17: Char 12: runtime error: shift exponent 32 is too large for 32-bit type \\'uint32_t\\' (aka \\'unsigned int\\') (solution.cpp)\\n\\nthe place corresponds to \\nb=b<<(32-cnt);\\nwhere cnt is bit length of number\\nIf i replace this by for loop to run till 32(bit size of uint32_t), i am not getting and also code is passed. \\nKindly help me why is this problem coming"
                    },
                    {
                        "username": "NIkhil_Rathi93",
                        "content": " public int reverseBits(int n) {\n        String num = Integer.toBinaryString(n);\n        String ans=\"\";\n        for(int i=num.length()-1;i>0;i--){\n            ans +=num.charAt(i);\n        } \n       int fn = Integer.parseInt(ans);  \n        return fn;\n    }\n\nWHAT AM I DOING WRONG HERE??"
                    },
                    {
                        "username": "codebothot",
                        "content": " `public class Solution {\\n\n    // you need treat n as an unsigned value\\n\n    public int reverseBits(int n) {\\n\n        int k = 32;\\n\n        int ans = 0;\n        while(k-- >= 0) {\n            ans += Math.pow(2,k) * (n %2);\n            n = n>>>1;\n        }\n        return ans;\n    }\n}`\n\nwhy does this Java code fail for I/P: 00000000000000000000000000000001\n\nexpected O/P: 2147483648\nO/P: 2147483647"
                    },
                    {
                        "username": "Frankie_Lee",
                        "content": "```cpp\\nclass Solution {\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        int pos = 31,reverse = 0;\\n        while(pos >= 0 && n){\\n            if(n & 1){\\n                reverse |= (1 << pos);\\n            }\\n            n >>= 1;\\n            pos--;\\n        }\\n        return reverse;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Just a normal question until you realize"
                    },
                    {
                        "username": "mobeenyaqub",
                        "content": "class Solution:\\n    def reverseBits(self, n: int) -> int:\\n        n = str(n)\\n        ans = 0\\n        for i in range(len(n)):\\n            if n[i] == \\'1\\':\\n                ans += 2 ** i\\n\\n        return ans\\n\\n\\nPycharm is giving correct answer, but leetcode is giving me totally wrong answer for the sample inputs."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/190_Reverse_Bits.cpp"
                    },
                    {
                        "username": "AdiechaHK",
                        "content": "here is the quick solution for python3\\n\\n```\\nclass Solution:\\n    def reverseBits(self, n: int) -> int:\\n        return int(\"{:032b}\".format(n)[::-1], 2)\\n```"
                    },
                    {
                        "username": "Ajantharajah",
                        "content": "Can anyone explain why it isn\\'t working\\n\\nuint32_t reverseBits(uint32_t n) {\\n        uint32_t ans = 0;\\n        for(int i=1; i<=32;i++) {\\n            ans = ans + (n&1)<<(32-i);\\n            n = n>>1;\\n        }\\n        return ans;\\n    } "
                    },
                    {
                        "username": "Ajantharajah",
                        "content": "got it. it should be or instead of +\\nans = ans | (n&1)<<(32-i);"
                    }
                ]
            },
            {
                "id": 1749872,
                "content": [
                    {
                        "username": "kingp",
                        "content": "This code is really hard to understand Please can anyone help me understand . Thanking you in Advance....\\n```\\nclass Solution {\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        n = (n >> 16) | (n << 16);\\n        n = ((n & 0xff00ff00) >> 8) | ((n & 0x00ff00ff) << 8);\\n        n = ((n & 0xf0f0f0f0) >> 4) | ((n & 0x0f0f0f0f) << 4);\\n        n = ((n & 0xcccccccc) >> 2) | ((n & 0x33333333) << 2);\\n        n = ((n & 0xaaaaaaaa) >> 1) | ((n & 0x55555555) << 1);\\n        return n;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "cheguvera",
                        "content": "Hi\\nKindly help me with the following\\nI am getting the following run time error.\\n\\nLine 17: Char 12: runtime error: shift exponent 32 is too large for 32-bit type \\'uint32_t\\' (aka \\'unsigned int\\') (solution.cpp)\\n\\nthe place corresponds to \\nb=b<<(32-cnt);\\nwhere cnt is bit length of number\\nIf i replace this by for loop to run till 32(bit size of uint32_t), i am not getting and also code is passed. \\nKindly help me why is this problem coming"
                    },
                    {
                        "username": "NIkhil_Rathi93",
                        "content": " public int reverseBits(int n) {\n        String num = Integer.toBinaryString(n);\n        String ans=\"\";\n        for(int i=num.length()-1;i>0;i--){\n            ans +=num.charAt(i);\n        } \n       int fn = Integer.parseInt(ans);  \n        return fn;\n    }\n\nWHAT AM I DOING WRONG HERE??"
                    },
                    {
                        "username": "codebothot",
                        "content": " `public class Solution {\\n\n    // you need treat n as an unsigned value\\n\n    public int reverseBits(int n) {\\n\n        int k = 32;\\n\n        int ans = 0;\n        while(k-- >= 0) {\n            ans += Math.pow(2,k) * (n %2);\n            n = n>>>1;\n        }\n        return ans;\n    }\n}`\n\nwhy does this Java code fail for I/P: 00000000000000000000000000000001\n\nexpected O/P: 2147483648\nO/P: 2147483647"
                    },
                    {
                        "username": "Frankie_Lee",
                        "content": "```cpp\\nclass Solution {\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        int pos = 31,reverse = 0;\\n        while(pos >= 0 && n){\\n            if(n & 1){\\n                reverse |= (1 << pos);\\n            }\\n            n >>= 1;\\n            pos--;\\n        }\\n        return reverse;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Just a normal question until you realize"
                    },
                    {
                        "username": "mobeenyaqub",
                        "content": "class Solution:\\n    def reverseBits(self, n: int) -> int:\\n        n = str(n)\\n        ans = 0\\n        for i in range(len(n)):\\n            if n[i] == \\'1\\':\\n                ans += 2 ** i\\n\\n        return ans\\n\\n\\nPycharm is giving correct answer, but leetcode is giving me totally wrong answer for the sample inputs."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/190_Reverse_Bits.cpp"
                    },
                    {
                        "username": "AdiechaHK",
                        "content": "here is the quick solution for python3\\n\\n```\\nclass Solution:\\n    def reverseBits(self, n: int) -> int:\\n        return int(\"{:032b}\".format(n)[::-1], 2)\\n```"
                    },
                    {
                        "username": "Ajantharajah",
                        "content": "Can anyone explain why it isn\\'t working\\n\\nuint32_t reverseBits(uint32_t n) {\\n        uint32_t ans = 0;\\n        for(int i=1; i<=32;i++) {\\n            ans = ans + (n&1)<<(32-i);\\n            n = n>>1;\\n        }\\n        return ans;\\n    } "
                    },
                    {
                        "username": "Ajantharajah",
                        "content": "got it. it should be or instead of +\\nans = ans | (n&1)<<(32-i);"
                    }
                ]
            }
        ]
    }
]