[
    {
        "title": "Spiral Matrix III",
        "question_content": "You start at the cell (rStart, cStart) of an rows x cols grid facing east. The northwest corner is at the first row and column in the grid, and the southeast corner is at the last row and column.\nYou will walk in a clockwise spiral shape to visit every position in this grid. Whenever you move outside the grid's boundary, we continue our walk outside the grid (but may return to the grid boundary later.). Eventually, we reach all rows * cols spaces of the grid.\nReturn an array of coordinates representing the positions of the grid in the order you visited them.\n&nbsp;\nExample 1:\n\nInput: rows = 1, cols = 4, rStart = 0, cStart = 0\nOutput: [[0,0],[0,1],[0,2],[0,3]]\n\nExample 2:\n\nInput: rows = 5, cols = 6, rStart = 1, cStart = 4\nOutput: [[1,4],[1,5],[2,5],[2,4],[2,3],[1,3],[0,3],[0,4],[0,5],[3,5],[3,4],[3,3],[3,2],[2,2],[1,2],[0,2],[4,5],[4,4],[4,3],[4,2],[4,1],[3,1],[2,1],[1,1],[0,1],[4,0],[3,0],[2,0],[1,0],[0,0]]\n\n&nbsp;\nConstraints:\n\n\t1 <= rows, cols <= 100\n\t0 <= rStart < rows\n\t0 <= cStart < cols",
        "solutions": [
            {
                "id": 158970,
                "title": "c-java-python-1-1-2-2-3-3-steps",
                "content": "## **Intuition**:\\nTake steps one by one.\\nIf the location is inside of grid, add it to `res`.\\nBut how to simulate the path?\\n\\nIt seems to be annoying, but if we observer the path:\\n\\nmove right `1` step, turn right\\nmove down `1` step, turn right\\nmove left `2` steps, turn right\\nmove top `2` steps, turn right,\\nmove right `3` steps, turn right\\nmove down `3` steps, turn right\\nmove left `4` steps, turn right\\nmove top `4` steps, turn right,\\n\\nwe can find the sequence of steps: 1,1,2,2,3,3,4,4,5,5....\\n\\nSo there are two thing to figure out:\\n1. how to generate sequence 1,1,2,2,3,3,4,4,5,5\\n2. how to turn right?\\n<br>\\n\\n## **Generate sequence 1,1,2,2,3,3,4,4,5,5**\\nLet `n` be index of this sequence.\\nThen `A0 = 1`, `A1 = 1`, `A2 = 2` ......\\nWe can find that `An = n / 2 + 1`\\n<br>\\n\\n## **How to turn right?**\\nBy cross product:\\nAssume current direction is (x, y) in plane, which is (x, y, 0) in space.\\nThen the direction after turn right (x, y, 0) \\xD7 (0, 0, 1) = (y, -x, 0)\\nTranslate to code: `tmp = x; x = y; y = -tmp;`\\n\\nBy arrays of arrays:\\nThe directions order is (0,1),(1,0),(0,-1),(-1,0), then repeat.\\nJust define a variable.\\n<br>\\n\\n## **Time Complexity**:\\nTime `O(max(R,C)^2)`\\nSpace `O(R*C)` for output\\n<br>\\n\\n**Java:**\\n```java\\n    public int[][] spiralMatrixIII(int R, int C, int x, int y) {\\n        int[][] res = new int[R * C][2];\\n        int dx = 0, dy = 1, n = 0, tmp;\\n        for (int j = 0; j < R * C; ++n) {\\n            for (int i = 0; i < n / 2 + 1; ++i) {\\n                if (0 <= x && x < R && 0 <= y && y < C)\\n                    res[j++] = new int[] {x, y};\\n                x += dx;\\n                y += dy;\\n            }\\n            tmp = dx;\\n            dx = dy;\\n            dy = -tmp;\\n        }\\n        return res;\\n    }\\n```\\n**C++:**\\n```cpp\\n    vector<vector<int>> spiralMatrixIII(int R, int C, int r, int c) {\\n        vector<vector<int>> res = {{r, c}};\\n        int dx = 0, dy = 1, tmp;\\n        for (int n = 0; res.size() < R * C; n++) {\\n            for (int i = 0; i < n / 2 + 1; i++) {\\n                r += dx, c += dy;\\n                if (0 <= r && r < R && 0 <= c && c < C)\\n                    res.push_back({r, c});\\n            }\\n            tmp = dx, dx = dy, dy = -tmp;\\n        }\\n        return res;\\n    }\\n```\\n**Python:**\\n```python\\n    def spiralMatrixIII(self, R, C, x, y):\\n        res = []\\n        dx, dy, n = 0, 1, 0\\n        while len(res) < R * C:\\n            for i in xrange(n / 2 + 1):\\n                if 0 <= x < R and 0 <= y < C:\\n                    res.append([x, y])\\n                x, y = x + dx, y + dy\\n            dx, dy, n = dy, -dx, n + 1\\n        return res\\n```\\n",
                "solutionTags": [],
                "code": "```java\\n    public int[][] spiralMatrixIII(int R, int C, int x, int y) {\\n        int[][] res = new int[R * C][2];\\n        int dx = 0, dy = 1, n = 0, tmp;\\n        for (int j = 0; j < R * C; ++n) {\\n            for (int i = 0; i < n / 2 + 1; ++i) {\\n                if (0 <= x && x < R && 0 <= y && y < C)\\n                    res[j++] = new int[] {x, y};\\n                x += dx;\\n                y += dy;\\n            }\\n            tmp = dx;\\n            dx = dy;\\n            dy = -tmp;\\n        }\\n        return res;\\n    }\\n```\n```cpp\\n    vector<vector<int>> spiralMatrixIII(int R, int C, int r, int c) {\\n        vector<vector<int>> res = {{r, c}};\\n        int dx = 0, dy = 1, tmp;\\n        for (int n = 0; res.size() < R * C; n++) {\\n            for (int i = 0; i < n / 2 + 1; i++) {\\n                r += dx, c += dy;\\n                if (0 <= r && r < R && 0 <= c && c < C)\\n                    res.push_back({r, c});\\n            }\\n            tmp = dx, dx = dy, dy = -tmp;\\n        }\\n        return res;\\n    }\\n```\n```python\\n    def spiralMatrixIII(self, R, C, x, y):\\n        res = []\\n        dx, dy, n = 0, 1, 0\\n        while len(res) < R * C:\\n            for i in xrange(n / 2 + 1):\\n                if 0 <= x < R and 0 <= y < C:\\n                    res.append([x, y])\\n                x, y = x + dx, y + dy\\n            dx, dy, n = dy, -dx, n + 1\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 158977,
                "title": "java-15-lines-concise-solution-with-comments",
                "content": "```Java\\n    public int[][] spiralMatrixIII(int R, int C, int r0, int c0) {\\n        int[][] dirt = new int[][]{{0, 1}, {1, 0}, {0, -1}, {-1, 0}}; // east, south, west, north\\n        List<int[]> res = new ArrayList<>();\\n        int len = 0, d = 0; // move <len> steps in the <d> direction\\n        res.add(new int[]{r0, c0});\\n        while (res.size() < R * C) {\\n            if (d == 0 || d == 2) len++; // when move east or west, the length of path need plus 1 \\n            for (int i = 0; i < len; i++) {\\n                r0 += dirt[d][0];\\n                c0 += dirt[d][1];\\n                if (r0 >= 0 && r0 < R && c0 >= 0 && c0 < C) // check valid\\n                    res.add(new int[]{r0, c0});\\n            }\\n            d = (d + 1) % 4; // turn to next direction\\n        }\\n        return res.toArray(new int[R * C][2]);\\n    }\\n```",
                "solutionTags": [],
                "code": "```Java\\n    public int[][] spiralMatrixIII(int R, int C, int r0, int c0) {\\n        int[][] dirt = new int[][]{{0, 1}, {1, 0}, {0, -1}, {-1, 0}}; // east, south, west, north\\n        List<int[]> res = new ArrayList<>();\\n        int len = 0, d = 0; // move <len> steps in the <d> direction\\n        res.add(new int[]{r0, c0});\\n        while (res.size() < R * C) {\\n            if (d == 0 || d == 2) len++; // when move east or west, the length of path need plus 1 \\n            for (int i = 0; i < len; i++) {\\n                r0 += dirt[d][0];\\n                c0 += dirt[d][1];\\n                if (r0 >= 0 && r0 < R && c0 >= 0 && c0 < C) // check valid\\n                    res.add(new int[]{r0, c0});\\n            }\\n            d = (d + 1) % 4; // turn to next direction\\n        }\\n        return res.toArray(new int[R * C][2]);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 362319,
                "title": "super-clean-code-python",
                "content": "The idea is that you keep a \"ghost\" point which keeps moving and whenever the ghost point takes a step you check if it\\'s valid. If valid, append to the return array. \\n\\n```\\nclass Solution(object):\\n    \\n    def spiralMatrixIII(self, R, C, r0, c0):\\n        ret = [(r0, c0)] \\n        is_valid = lambda row, col: row >= 0 and row < R and col >= 0 and col < C \\n        \\n        steps = 1 \\n        r, c = r0, c0 \\n        while len(ret) < R * C: \\n            # Go east 1\\n            for step in xrange(steps):\\n                r, c = r, c + 1 \\n                if is_valid(r, c): ret.append((r, c))\\n                    \\n            # Go down 1 \\n            for step in xrange(steps):\\n                r, c = r + 1, c \\n                if is_valid(r, c): ret.append((r, c))\\n                    \\n            steps += 1\\n                    \\n            # Go west 2 \\n            for step in xrange(steps):\\n                r, c = r, c - 1\\n                if is_valid(r, c): ret.append((r, c))           \\n            \\n            # Go north 2 \\n            for step in xrange(steps):\\n                r, c = r - 1, c \\n                if is_valid(r, c): ret.append((r, c))           \\n                    \\n            steps += 1\\n            \\n        return ret \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    \\n    def spiralMatrixIII(self, R, C, r0, c0):\\n        ret = [(r0, c0)] \\n        is_valid = lambda row, col: row >= 0 and row < R and col >= 0 and col < C \\n        \\n        steps = 1 \\n        r, c = r0, c0 \\n        while len(ret) < R * C: \\n            # Go east 1\\n            for step in xrange(steps):\\n                r, c = r, c + 1 \\n                if is_valid(r, c): ret.append((r, c))\\n                    \\n            # Go down 1 \\n            for step in xrange(steps):\\n                r, c = r + 1, c \\n                if is_valid(r, c): ret.append((r, c))\\n                    \\n            steps += 1\\n                    \\n            # Go west 2 \\n            for step in xrange(steps):\\n                r, c = r, c - 1\\n                if is_valid(r, c): ret.append((r, c))           \\n            \\n            # Go north 2 \\n            for step in xrange(steps):\\n                r, c = r - 1, c \\n                if is_valid(r, c): ret.append((r, c))           \\n                    \\n            steps += 1\\n            \\n        return ret \\n```",
                "codeTag": "Java"
            },
            {
                "id": 158971,
                "title": "python-sort-all-coordinates",
                "content": "Put all valid coordinates to a list `res`\\n\\nSort all coordinates by the following rule:\\n\\n0. Change coordinates to a relative coordinates to center.\\n\\n1. Sort ascending by the distance to the center `max(abs(x), abs(y))`\\nIf `max(abs(x), abs(y)) == 0`, it\\'s the center.\\nIf `max(abs(x), abs(y)) == 1`, it\\'s in the first layer around the center\\n\\n2. Sort descending by the angle to the center `max(abs(x), abs(y))`\\n\\n\\n**Python:**\\n```\\n    def spiralMatrixIII(self, R, C, r, c):\\n        def key((x, y)):\\n            x, y = x - r, y - c\\n            return (max(abs(x), abs(y)), -((math.atan2(-1, 1) - math.atan2(x, y)) % (math.pi * 2)))\\n        return sorted([(i, j) for i in xrange(R) for j in xrange(C)], key=key)\\n```\\n",
                "solutionTags": [],
                "code": "```\\n    def spiralMatrixIII(self, R, C, r, c):\\n        def key((x, y)):\\n            x, y = x - r, y - c\\n            return (max(abs(x), abs(y)), -((math.atan2(-1, 1) - math.atan2(x, y)) % (math.pi * 2)))\\n        return sorted([(i, j) for i in xrange(R) for j in xrange(C)], key=key)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 163370,
                "title": "simple-easy-to-understand-java-solution",
                "content": "The idea here is that once we start at (r=r0, c=c0), we walk along the east, then south, then west, and then north. \\n\\nWhen we go east, we do c++ (column increases), when we go west, we do c--, when we go south, we do r++ (row increases), and when we go north, we do r--.\\n\\nAfter starting at (r0,c0), we need to walk in spirals, where the length of the spiral increases after every two directions. For example 2, we start at (r0=1, c0=4), then we go east by one length, we go south by one length. Following that, we go west by 2 length and then, go north by 2 length. After that, we go in next directions by 3 lengths, and so on.\\n\\nThe trick here is that we continue to walk in spiral, whether the current (r,c) is valid or not. However, we add (r,c) to the result only if it is valid.\\n\\n```\\nclass Solution {\\n    int idx;\\n    int[][] ret;\\n    \\n    private void add (int r, int c, int R, int C) {\\n        if (r >= R || r < 0 || c >= C || c < 0) return;\\n        ret[idx][0] = r;\\n        ret[idx++][1] = c;\\n    }\\n    \\n    public int[][] spiralMatrixIII(int R, int C, int r0, int c0) {\\n        int r = r0, c = c0, len = 1;\\n        ret = new int[R * C][2];\\n        while (idx < (R * C )) {         \\n            for (int k = 0; k < len; k++) add(r, c++, R, C);          \\n            for (int k = 0; k < len; k++) add(r++, c, R, C);\\n            len++;\\n            for (int k = 0; k < len; k++) add(r, c--, R, C);\\n            for (int k = 0; k < len; k++) add(r--, c, R, C);\\n            len++;   \\n        }\\n        return ret;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int idx;\\n    int[][] ret;\\n    \\n    private void add (int r, int c, int R, int C) {\\n        if (r >= R || r < 0 || c >= C || c < 0) return;\\n        ret[idx][0] = r;\\n        ret[idx++][1] = c;\\n    }\\n    \\n    public int[][] spiralMatrixIII(int R, int C, int r0, int c0) {\\n        int r = r0, c = c0, len = 1;\\n        ret = new int[R * C][2];\\n        while (idx < (R * C )) {         \\n            for (int k = 0; k < len; k++) add(r, c++, R, C);          \\n            for (int k = 0; k < len; k++) add(r++, c, R, C);\\n            len++;\\n            for (int k = 0; k < len; k++) add(r, c--, R, C);\\n            for (int k = 0; k < len; k++) add(r--, c, R, C);\\n            len++;   \\n        }\\n        return ret;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1511489,
                "title": "java-tc-o-max-r-c-2-sc-o-1-simulating-a-spiral-walk",
                "content": "```java\\n/**\\n * Distance covered in each direction follows 1, 1, 2, 2, 3, 3, 4, 4... pattern.\\n *\\n * Order of directions: Right, Down, Left, Up. Whenever the direction becomes\\n * right or left, the distance travelled in that direction increases by 1.\\n *\\n * So the distance travelled is sum of 1, 1, 2, 2, ... 2*max(R,C), 2*max(R,C).\\n *\\n * Time Complexity: O(max(R, C)^2)\\n *\\n * Space Complexity: O(1) -> Excluding the result.\\n *\\n * R = Input number of rows. C = Input number of columns.\\n */\\nclass Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        if (rows < 0 || cols < 0 || rStart < 0 || rStart >= rows || cStart < 0 || cStart >= cols) {\\n            throw new IllegalArgumentException(\"Input is invalid\");\\n        }\\n\\n        int totalLen = rows * cols;\\n        int[][] result = new int[totalLen][2];\\n        result[0] = new int[] { rStart, cStart };\\n        if (totalLen == 1) {\\n            return result;\\n        }\\n\\n        int dist = 0;\\n        int row = rStart;\\n        int col = cStart;\\n        int[][] dirs = { { 0, 1 }, { 1, 0 }, { 0, -1 }, { -1, 0 } };\\n        int dirIdx = 0;\\n        int count = 1;\\n\\n        while (count < totalLen) {\\n            if (dirIdx == 0 || dirIdx == 2) {\\n                dist++;\\n            }\\n            for (int i = 1; i <= dist; i++) {\\n                row += dirs[dirIdx][0];\\n                col += dirs[dirIdx][1];\\n                if (row >= 0 && row < rows && col >= 0 && col < cols) {\\n                    result[count++] = new int[] { row, col };\\n                    if (count == totalLen) {\\n                        return result;\\n                    }\\n                }\\n            }\\n            dirIdx = (dirIdx + 1) % 4;\\n        }\\n\\n        return result;\\n    }\\n}\\n```\\n\\n---\\n\\nSolutions to other parts of Spiral Matrix question on LeetCode:\\n- [54. Spiral Matrix](https://leetcode.com/problems/spiral-matrix/discuss/1511476/Java-or-TC:-O(M*N)-or-SC:-O(1)-or-Optimized-solution-using-Switch-Case)\\n- [59. Spiral Matrix II](https://leetcode.com/problems/spiral-matrix-ii/discuss/1511479/Java-or-TC:-O(N2)-or-SC:-O(1)-or-Multiple-optimized-ways-to-solve-this-question)",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Matrix",
                    "Simulation"
                ],
                "code": "```java\\n/**\\n * Distance covered in each direction follows 1, 1, 2, 2, 3, 3, 4, 4... pattern.\\n *\\n * Order of directions: Right, Down, Left, Up. Whenever the direction becomes\\n * right or left, the distance travelled in that direction increases by 1.\\n *\\n * So the distance travelled is sum of 1, 1, 2, 2, ... 2*max(R,C), 2*max(R,C).\\n *\\n * Time Complexity: O(max(R, C)^2)\\n *\\n * Space Complexity: O(1) -> Excluding the result.\\n *\\n * R = Input number of rows. C = Input number of columns.\\n */\\nclass Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        if (rows < 0 || cols < 0 || rStart < 0 || rStart >= rows || cStart < 0 || cStart >= cols) {\\n            throw new IllegalArgumentException(\"Input is invalid\");\\n        }\\n\\n        int totalLen = rows * cols;\\n        int[][] result = new int[totalLen][2];\\n        result[0] = new int[] { rStart, cStart };\\n        if (totalLen == 1) {\\n            return result;\\n        }\\n\\n        int dist = 0;\\n        int row = rStart;\\n        int col = cStart;\\n        int[][] dirs = { { 0, 1 }, { 1, 0 }, { 0, -1 }, { -1, 0 } };\\n        int dirIdx = 0;\\n        int count = 1;\\n\\n        while (count < totalLen) {\\n            if (dirIdx == 0 || dirIdx == 2) {\\n                dist++;\\n            }\\n            for (int i = 1; i <= dist; i++) {\\n                row += dirs[dirIdx][0];\\n                col += dirs[dirIdx][1];\\n                if (row >= 0 && row < rows && col >= 0 && col < cols) {\\n                    result[count++] = new int[] { row, col };\\n                    if (count == totalLen) {\\n                        return result;\\n                    }\\n                }\\n            }\\n            dirIdx = (dirIdx + 1) % 4;\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 159128,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int R, int C, int x, int y) {\\n        \\n        vector<vector<int>>sol;\\n        int n = 0;\\n        int step=1;\\n\\twhile(n<R*C){\\n\\n\\t\\tfor (int i = 0; i < step; ++i)\\n\\t\\t{\\n\\t\\t\\tif(x>=0 and x<R and y>=0 and y<C)sol.push_back(vector<int>{x,y}),n++;\\n\\t\\t\\ty++;\\n\\t\\t}\\n\\t\\tfor (int i = 0; i < step; ++i)\\n\\t\\t{\\n\\t\\t\\tif(x>=0 and x<R and y>=0 and y<C)sol.push_back(vector<int>{x,y}),n++;\\n\\t\\t\\tx++;\\n\\t\\t}\\n\\t\\tstep++;\\n\\t\\tfor (int i = 0; i < step; ++i)\\n\\t\\t{\\n\\t\\t\\tif(x>=0 and x<R and y>=0 and y<C)sol.push_back(vector<int>{x,y}),n++;\\n\\t\\t\\ty--;\\n\\t\\t}\\n\\t\\tfor (int i = 0; i < step; ++i)\\n\\t\\t{\\n\\t\\t\\tif(x>=0 and x<R and y>=0 and y<C)sol.push_back(vector<int>{x,y}),n++;\\n\\t\\t\\tx--;\\n\\t\\t}\\n\\t\\tstep++;\\n\\n\\n\\n\\t}\\n        \\n        return sol;\\n        \\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int R, int C, int x, int y) {\\n        \\n        vector<vector<int>>sol;\\n        int n = 0;\\n        int step=1;\\n\\twhile(n<R*C){\\n\\n\\t\\tfor (int i = 0; i < step; ++i)\\n\\t\\t{\\n\\t\\t\\tif(x>=0 and x<R and y>=0 and y<C)sol.push_back(vector<int>{x,y}),n++;\\n\\t\\t\\ty++;\\n\\t\\t}\\n\\t\\tfor (int i = 0; i < step; ++i)\\n\\t\\t{\\n\\t\\t\\tif(x>=0 and x<R and y>=0 and y<C)sol.push_back(vector<int>{x,y}),n++;\\n\\t\\t\\tx++;\\n\\t\\t}\\n\\t\\tstep++;\\n\\t\\tfor (int i = 0; i < step; ++i)\\n\\t\\t{\\n\\t\\t\\tif(x>=0 and x<R and y>=0 and y<C)sol.push_back(vector<int>{x,y}),n++;\\n\\t\\t\\ty--;\\n\\t\\t}\\n\\t\\tfor (int i = 0; i < step; ++i)\\n\\t\\t{\\n\\t\\t\\tif(x>=0 and x<R and y>=0 and y<C)sol.push_back(vector<int>{x,y}),n++;\\n\\t\\t\\tx--;\\n\\t\\t}\\n\\t\\tstep++;\\n\\n\\n\\n\\t}\\n        \\n        return sol;\\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 184851,
                "title": "python-beats-100",
                "content": "```\nclass Solution(object):\n    def spiralMatrixIII(self, R, C, r0, c0):\n        \"\"\"\n        :type R: int\n        :type C: int\n        :type r0: int\n        :type c0: int\n        :rtype: List[List[int]]\n        \"\"\"\n        i = r0\n        j = c0\n        coordinates = [[r0, c0]]\n        step_size = 1\n        sign = 1\n        while len(coordinates) < R*C:\n            for _ in range(step_size):\n                j += sign\n                if i < R and j < C and i >= 0 and j >= 0:\n                    coordinates.append([i, j])\n            \n            for _ in range(step_size):\n                i += sign\n                if i < R and j < C and i >= 0 and j >= 0:\n                    coordinates.append([i, j])\n            \n            step_size += 1\n            sign *= -1\n        return coordinates\n```",
                "solutionTags": [],
                "code": "```\nclass Solution(object):\n    def spiralMatrixIII(self, R, C, r0, c0):\n        \"\"\"\n        :type R: int\n        :type C: int\n        :type r0: int\n        :type c0: int\n        :rtype: List[List[int]]\n        \"\"\"\n        i = r0\n        j = c0\n        coordinates = [[r0, c0]]\n        step_size = 1\n        sign = 1\n        while len(coordinates) < R*C:\n            for _ in range(step_size):\n                j += sign\n                if i < R and j < C and i >= 0 and j >= 0:\n                    coordinates.append([i, j])\n            \n            for _ in range(step_size):\n                i += sign\n                if i < R and j < C and i >= 0 and j >= 0:\n                    coordinates.append([i, j])\n            \n            step_size += 1\n            sign *= -1\n        return coordinates\n```",
                "codeTag": "Java"
            },
            {
                "id": 158954,
                "title": "java-simulation-17-lines-with-line-by-line-explanation",
                "content": "```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int R, int C, int r0, int c0) {\\n        int[][] res= new int[R*C][2];\\n        res[0]=new int[]{r0, c0};\\n        int len=0, idx=1, k=0;\\n        int[] d= new int[]{0,1,0,-1,0};\\n        while (idx<R*C){\\n            len++;\\n            for (int round=0; round<2; round++){\\n                for (int sz=len; sz>0; sz--){\\n                    r0+=d[k];\\n                    c0+=d[k+1];\\n                    if (r0<0 || r0>=R || c0<0 || c0>=C) continue;\\n                    res[idx++]=new int[]{r0, c0};\\n                }\\n                k=(k+1)%4;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/caraxin/image_1534044938.png)\\n\\nHappy Coding!\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int R, int C, int r0, int c0) {\\n        int[][] res= new int[R*C][2];\\n        res[0]=new int[]{r0, c0};\\n        int len=0, idx=1, k=0;\\n        int[] d= new int[]{0,1,0,-1,0};\\n        while (idx<R*C){\\n            len++;\\n            for (int round=0; round<2; round++){\\n                for (int sz=len; sz>0; sz--){\\n                    r0+=d[k];\\n                    c0+=d[k+1];\\n                    if (r0<0 || r0>=R || c0<0 || c0>=C) continue;\\n                    res[idx++]=new int[]{r0, c0};\\n                }\\n                k=(k+1)%4;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 483264,
                "title": "sort-coordinates-python",
                "content": "Sort by:\\n1) layer = max(&Delta;r, &Delta;c)\\n2) right-bottom half before left-top half\\n3) By r and c (increasing or decreasing depending on the half)\\n```\\ndef spiralMatrixIII(self, R, C, r0, c0):\\n    return sorted([[r, c] for r in range(R) for c in range(C)],\\n                  key=lambda (r, c): (max(abs(r - r0), abs(c - c0)),\\n                                      (0, r, -c) if r + c > r0 + c0 else (1, -r, c)))\\n```\\nWritten after seeing @lee215\\'s title \"[Sort All Coordinates](https://leetcode.com/problems/spiral-matrix-iii/discuss/158971/Python-Sort-All-Coordinates)\" but before looking at its code.",
                "solutionTags": [],
                "code": "```\\ndef spiralMatrixIII(self, R, C, r0, c0):\\n    return sorted([[r, c] for r in range(R) for c in range(C)],\\n                  key=lambda (r, c): (max(abs(r - r0), abs(c - c0)),\\n                                      (0, r, -c) if r + c > r0 + c0 else (1, -r, c)))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 482757,
                "title": "c-from-approach-to-implementation-explained",
                "content": "# Observation 1- How to traverse\\nIn this approach I have traversed the path of the spiral after making a few observations. If you refer \\nExample 2, R = 5, C = 6, r0 = 1, c0 = 4, you will notice the direction of the walk does not change\\nfrom 1 to 2, \\n2 to 3, \\n3 to 5,\\n5 to 7, ....\\nHere  2-1 = 3-2\\n5-3 = 7-5\\n![image](https://assets.leetcode.com/users/debipur/image_1579243848.png)\\nThis brings us to our first observation, the length of the line along which direction does not change\\nremains equal after the odd number of changes and after even direction changes the length \\nincreases by 1.\\n# Approach\\nSo, our approach here is we keep track of our current coordinates. Also have a array which stores the\\nchange required to move right, down, left and up respectively :- {{0, 1}, {1, 0}, {0, -1}, {-1, 0}}.\\nAccording to the no. of steps taken, position in current line and no. of direction changes we make \\nthe change to our current cordinate. At each coordinate we check whether it is a valid cell, if so we \\npush it to answer.\\n```\\ninline bool isvalid(vector<int> &cur, int R, int C){\\n\\tif(cur[0] >= 0 && cur[1] >= 0 && cur[0] < R && cur[1] < C)\\n\\t\\treturn true;\\n\\treturn false;\\n}\\n```\\n# Observation 2- How long to traverse\\nThe question is how long we need to move? If you draw(rather imagine) the spiral, for the following\\nboundary case it answers our question, R = 100, C = 1, r0 = 0, c0 = 0. You will find (2*max(R, C))^2 is\\nthe maximum number of steps you will need.\\n```\\nvector<vector<int>> spiralMatrixIII(int R, int C, int r0, int c0) {\\n        vector<vector<int>> ans;\\n        vector<int> cur = {r0, c0};\\n        ans.push_back(cur);\\n        vector<vector<int>> dir = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\\n        int totsteps = 2*max(R, C); totsteps*=totsteps;\\n\\t\\tint stepi = 0, d = 0;                    //tracks i th step and d th direction change\\n        int linelen = 1;\\n        while(stepi <= totsteps){\\n            for(int a = 1; a <=2; ++a){          // looping twice for same length\\n                int k = 1;                       //tracks steps taken in current line\\n                while(k <= linelen){\\n                    cur[0] += dir[d][0];\\n                    cur[1] += dir[d][1];\\n                    if(isvalid(cur, R, C)) ans.push_back(cur);\\n                    k++; stepi++;\\n                }\\n                d = (d+1)%4;\\n            }\\n            linelen++;\\n        }\\n        return ans;\\n    }\\n```\\nMy first post here in leetcode :)\\nLet me know if this helped or did I leave out details.",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\ninline bool isvalid(vector<int> &cur, int R, int C){\\n\\tif(cur[0] >= 0 && cur[1] >= 0 && cur[0] < R && cur[1] < C)\\n\\t\\treturn true;\\n\\treturn false;\\n}\\n```\n```\\nvector<vector<int>> spiralMatrixIII(int R, int C, int r0, int c0) {\\n        vector<vector<int>> ans;\\n        vector<int> cur = {r0, c0};\\n        ans.push_back(cur);\\n        vector<vector<int>> dir = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\\n        int totsteps = 2*max(R, C); totsteps*=totsteps;\\n\\t\\tint stepi = 0, d = 0;                    //tracks i th step and d th direction change\\n        int linelen = 1;\\n        while(stepi <= totsteps){\\n            for(int a = 1; a <=2; ++a){          // looping twice for same length\\n                int k = 1;                       //tracks steps taken in current line\\n                while(k <= linelen){\\n                    cur[0] += dir[d][0];\\n                    cur[1] += dir[d][1];\\n                    if(isvalid(cur, R, C)) ans.push_back(cur);\\n                    k++; stepi++;\\n                }\\n                d = (d+1)%4;\\n            }\\n            linelen++;\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2166570,
                "title": "c-easy-explanation-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        \\n        vector<vector<int>> ans;\\n        ans.push_back({rStart, cStart}); //Pushing the starting point in answer\\n        int topRow = rStart-1; //Row above starting point\\n        int bottomRow = rStart+1; //Row below starting point\\n        int leftCol = cStart-1; //Col left to starting point\\n        int rightCol = cStart+1; //Col right to starting point\\n        \\n        while(topRow != -1 || bottomRow != rows || leftCol != -1 || rightCol != cols){ //Untill all rows and columns are exhausted\\n            \\n            if(rightCol != cols){ //Checking if this col is exhausted\\n                for(int i = topRow+1; i < bottomRow;i++) ans.push_back({i, rightCol}); //Running loop from one bottom of top row till bottom row in right col\\n                rightCol++; //Incrementing the col forward\\n            }\\n            //Similar things are done below with different cols and rows\\n            if(bottomRow != rows){\\n                for(int j = rightCol-1; j > leftCol; j--) ans.push_back({bottomRow, j});\\n                bottomRow++;\\n            }\\n            \\n            if(leftCol != -1){\\n                for(int i = bottomRow-1; i > topRow; i--) ans.push_back({i, leftCol});\\n                leftCol--;\\n            }\\n            \\n            if(topRow != -1){\\n                for(int j = leftCol+1; j < rightCol; j++) ans.push_back({topRow, j});\\n                topRow--;\\n            }  \\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nIf you think this post was ***helpful***, I will be happy if you give a ***upvote***. Any questions or discussions are welcome! **Thanks a lot.** \\uD83D\\uDE04",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        \\n        vector<vector<int>> ans;\\n        ans.push_back({rStart, cStart}); //Pushing the starting point in answer\\n        int topRow = rStart-1; //Row above starting point\\n        int bottomRow = rStart+1; //Row below starting point\\n        int leftCol = cStart-1; //Col left to starting point\\n        int rightCol = cStart+1; //Col right to starting point\\n        \\n        while(topRow != -1 || bottomRow != rows || leftCol != -1 || rightCol != cols){ //Untill all rows and columns are exhausted\\n            \\n            if(rightCol != cols){ //Checking if this col is exhausted\\n                for(int i = topRow+1; i < bottomRow;i++) ans.push_back({i, rightCol}); //Running loop from one bottom of top row till bottom row in right col\\n                rightCol++; //Incrementing the col forward\\n            }\\n            //Similar things are done below with different cols and rows\\n            if(bottomRow != rows){\\n                for(int j = rightCol-1; j > leftCol; j--) ans.push_back({bottomRow, j});\\n                bottomRow++;\\n            }\\n            \\n            if(leftCol != -1){\\n                for(int i = bottomRow-1; i > topRow; i--) ans.push_back({i, leftCol});\\n                leftCol--;\\n            }\\n            \\n            if(topRow != -1){\\n                for(int j = leftCol+1; j < rightCol; j++) ans.push_back({topRow, j});\\n                topRow--;\\n            }  \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2351356,
                "title": "python-easy-simulation-iterative-approach-notes",
                "content": "```\\n/*\\ninitialize val to 1\\ninitialize answer set with starting index\\nAlgo\\nGo in infinite loop\\n   Go right val times, if the index is valid, add all those indexes to answer set\\n   Go Down val times, if the index is valid, add all those indexes to answer set\\n   Go Left val+1 times, if the index is valid, add all those indexes to answer set\\n   Go Up val + 1 times, if the index is valid, add all those indexes to answer set\\n   if the answer set has rows*cols entries, break out of loop and return the answer set\\n*/\\n```\\n```\\nclass Solution:\\n    def spiralMatrixIII(self, rows: int, cols: int, rStart: int, cStart: int) -> List[List[int]]:\\n        ans = [[rStart, cStart]]\\n        val = 1\\n        i, j = rStart, cStart\\n        def is_valid(i, j):\\n            if 0 <= i < rows and 0 <= j < cols:\\n                return True\\n            return False\\n        \\n        while True:\\n            if len(ans) == rows * cols:\\n                return ans\\n            \\n            # go right val times\\n            for _ in range(val):\\n                j+=1\\n                if is_valid(i,j):\\n                    ans.append([i,j])\\n            # go bottom val times\\n            for _ in range(val):\\n                i+=1\\n                if is_valid(i,j):\\n                    ans.append([i,j])\\n            # go left val+1 times\\n            for _ in range(val+1):\\n                j-=1\\n                if is_valid(i,j):\\n                    ans.append([i,j])\\n            # go up val+1 times\\n            for _ in range(val+1):\\n                i-=1\\n                if is_valid(i,j):\\n                    ans.append([i,j])\\n            val+=2\\n```",
                "solutionTags": [
                    "Python",
                    "Simulation"
                ],
                "code": "```\\n/*\\ninitialize val to 1\\ninitialize answer set with starting index\\nAlgo\\nGo in infinite loop\\n   Go right val times, if the index is valid, add all those indexes to answer set\\n   Go Down val times, if the index is valid, add all those indexes to answer set\\n   Go Left val+1 times, if the index is valid, add all those indexes to answer set\\n   Go Up val + 1 times, if the index is valid, add all those indexes to answer set\\n   if the answer set has rows*cols entries, break out of loop and return the answer set\\n*/\\n```\n```\\nclass Solution:\\n    def spiralMatrixIII(self, rows: int, cols: int, rStart: int, cStart: int) -> List[List[int]]:\\n        ans = [[rStart, cStart]]\\n        val = 1\\n        i, j = rStart, cStart\\n        def is_valid(i, j):\\n            if 0 <= i < rows and 0 <= j < cols:\\n                return True\\n            return False\\n        \\n        while True:\\n            if len(ans) == rows * cols:\\n                return ans\\n            \\n            # go right val times\\n            for _ in range(val):\\n                j+=1\\n                if is_valid(i,j):\\n                    ans.append([i,j])\\n            # go bottom val times\\n            for _ in range(val):\\n                i+=1\\n                if is_valid(i,j):\\n                    ans.append([i,j])\\n            # go left val+1 times\\n            for _ in range(val+1):\\n                j-=1\\n                if is_valid(i,j):\\n                    ans.append([i,j])\\n            # go up val+1 times\\n            for _ in range(val+1):\\n                i-=1\\n                if is_valid(i,j):\\n                    ans.append([i,j])\\n            val+=2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1633745,
                "title": "easy-c-solution",
                "content": "In the below algorithm, I have used direction parameters :\\n(0,1) for east\\n(1,0) for south\\n(0,-1) for west\\n(-1,0) for north\\n\\nEven there is a chance of getting out of the boundary, this algorithm works fine only because of this statement:\\n```\\nif(rStart>=0 && rStart<rows && cStart>=0 && cStart<cols){\\n                    result.push_back({rStart,cStart});\\n                }\\n```\\n\\n\\nComplete Code:-\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        \\n        vector<vector<int>> result = {{rStart,cStart}};\\n        \\n        vector<vector<int>> dir = {{0,1},{1,0},{0,-1},{-1,0}};\\n        \\n        int len = 0, d = 0;\\n        \\n        while(result.size()<rows*cols){\\n            \\n            if(d==0 || d==2) len++;\\n            \\n            for(int i=0;i<len;i++){\\n                rStart+=dir[d][0];\\n                cStart+=dir[d][1];\\n                if(rStart>=0 && rStart<rows && cStart>=0 && cStart<cols){\\n                    result.push_back({rStart,cStart});\\n                }\\n            }\\n            d = (d+1)%4;\\n        }\\n        return result;\\n    }\\n};\\n```\\nKindly upvote if you get any help here.\\nHappy coding!",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nif(rStart>=0 && rStart<rows && cStart>=0 && cStart<cols){\\n                    result.push_back({rStart,cStart});\\n                }\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        \\n        vector<vector<int>> result = {{rStart,cStart}};\\n        \\n        vector<vector<int>> dir = {{0,1},{1,0},{0,-1},{-1,0}};\\n        \\n        int len = 0, d = 0;\\n        \\n        while(result.size()<rows*cols){\\n            \\n            if(d==0 || d==2) len++;\\n            \\n            for(int i=0;i<len;i++){\\n                rStart+=dir[d][0];\\n                cStart+=dir[d][1];\\n                if(rStart>=0 && rStart<rows && cStart>=0 && cStart<cols){\\n                    result.push_back({rStart,cStart});\\n                }\\n            }\\n            d = (d+1)%4;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 440599,
                "title": "java-solution-using-simple-walking-simulation-97",
                "content": "```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int R, int C, int r0, int c0) {\\n        final int totalCellsToVisit = R * C;\\n        final int[][] cells = new int[totalCellsToVisit][2];\\n        int cellsVisited = 0;\\n        int stepLength = 1;\\n        int stepsTaken = 0;\\n        int direction = 0;\\n        int row = r0, column = c0;\\n        \\n        while (cellsVisited < totalCellsToVisit) {\\n            // If we are inside the matrix, record the position\\n            if (row >= 0 && row < R && column >= 0 && column < C) {\\n                cells[cellsVisited][0] = row;\\n                cells[cellsVisited][1] = column;\\n                cellsVisited++;\\n            }\\n            \\n            // Move a step to correct direction (0=E, 1=S, 2=W, 3=N)\\n            if (direction == 0) { column++; }\\n            else if (direction == 1) { row++; }\\n            else if (direction == 2) { column--; }\\n            else if (direction == 3) { row--; }\\n            stepsTaken++;\\n            \\n            // If we are taken the correct amount of steps to the current direction,\\n            // change direction\\n            if (stepsTaken == stepLength) {\\n                stepsTaken = 0;\\n                direction++;\\n                // When going east or west increase the steps we take for each direction\\n                if (direction == 2) {\\n                    stepLength++;\\n                    stepsTaken = 0;\\n                } else if (direction == 4) {\\n                    direction = 0;\\n                    stepLength++;\\n                    stepsTaken = 0;\\n                }\\n            }\\n        }\\n        return cells;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int R, int C, int r0, int c0) {\\n        final int totalCellsToVisit = R * C;\\n        final int[][] cells = new int[totalCellsToVisit][2];\\n        int cellsVisited = 0;\\n        int stepLength = 1;\\n        int stepsTaken = 0;\\n        int direction = 0;\\n        int row = r0, column = c0;\\n        \\n        while (cellsVisited < totalCellsToVisit) {\\n            // If we are inside the matrix, record the position\\n            if (row >= 0 && row < R && column >= 0 && column < C) {\\n                cells[cellsVisited][0] = row;\\n                cells[cellsVisited][1] = column;\\n                cellsVisited++;\\n            }\\n            \\n            // Move a step to correct direction (0=E, 1=S, 2=W, 3=N)\\n            if (direction == 0) { column++; }\\n            else if (direction == 1) { row++; }\\n            else if (direction == 2) { column--; }\\n            else if (direction == 3) { row--; }\\n            stepsTaken++;\\n            \\n            // If we are taken the correct amount of steps to the current direction,\\n            // change direction\\n            if (stepsTaken == stepLength) {\\n                stepsTaken = 0;\\n                direction++;\\n                // When going east or west increase the steps we take for each direction\\n                if (direction == 2) {\\n                    stepLength++;\\n                    stepsTaken = 0;\\n                } else if (direction == 4) {\\n                    direction = 0;\\n                    stepLength++;\\n                    stepsTaken = 0;\\n                }\\n            }\\n        }\\n        return cells;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1945963,
                "title": "c-easy-solution-0ms-intuitive-approach",
                "content": "class Solution {\\npublic:\\n    \\n    bool Valid(int i,int j,int n,int m){\\n        if(i<0 || j<0 || j>=m || i>=n) return false;\\n        return true;\\n    }\\n    vector<vector<int>> spiralMatrixIII(int n, int m, int x, int y) {\\n        vector<vector<int>> ans ;\\n        ans.push_back({x,y});   //initial point\\n        int len=1;\\n        while(ans.size()<n*m){              //Base Case --> once we get whole grid --> break\\n            for(int j=1;j<=len;j++){        //going right \\n                if(Valid(x,y+j,n,m)){       //Checking if this pos exists in Grid\\n                    ans.push_back({x,y+j});\\n                }\\n            }\\n            y+=len;                         //Updating the value of y coordinate \\n            for(int i=1;i<=len;i++){        //Going Down\\n                if(Valid(x+i,y,n,m)) ans.push_back({x+i,y});        //Checking if exists in Grid\\n            }\\n            x+=len;                         //Updating X coordinate \\n            len++;          //Increasing length of step in each direction \\n            for(int j=1;j<=len;j++){        //Going Left \\n                if(Valid(x,y-j,n,m)) ans.push_back({x,y-j});\\n            }\\n            y-=len;\\n            for(int i=1;i<=len;i++){        //Going Up\\n                if(Valid(x-i,y,n,m)) ans.push_back({x-i,y});\\n            }\\n            x-=len;\\n            len++;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    bool Valid(int i,int j,int n,int m){\\n        if(i<0 || j<0 || j>=m || i>=n) return false;\\n        return true;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1426785,
                "title": "python-3-simulation-explanation",
                "content": "### Explanation\\n- Starting with a step length of `1`, move one time to right, then turn; move one time to below\\n- Increase step length, `1 + 1 = 2`, move 2 times to left, then turn; move 2 times to above\\n- So, for each step length, we will move `step` for 2 directions, then increase `step` by one; and repeat\\n- To summarize:\\n\\t- `Step == 1, move*step, turn, move*step, turn`\\n\\t- `Step += 1, move*step, turn, move*step, turn`\\n\\t- `Step += 1, move*step, turn, move*step, turn`\\n\\t- `... ... repeat`\\n### Implementation\\n```\\nclass Solution:\\n    def spiralMatrixIII(self, rows: int, cols: int, rStart: int, cStart: int) -> List[List[int]]:\\n        total, cnt, step, i = rows * cols, 1, 1, 0\\n        ans = [[rStart, cStart]]\\n        direction = {0: (0, 1), 1: (1, 0), 2: (0, -1), 3: (-1, 0)} # setup direction movements\\n        while cnt < total:\\n            for k in range(step):\\n                rStart, cStart = rStart+direction[i][0], cStart + direction[i][1]\\n                if 0 <= rStart < rows and 0 <= cStart < cols:\\n                    ans.append([rStart, cStart])\\n                    cnt += 1       # count visited \\n            i = (i + 1) % 4        # changing direction\\n            step += not i % 2      # increase step every 2 directions\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Matrix",
                    "Simulation"
                ],
                "code": "```\\nclass Solution:\\n    def spiralMatrixIII(self, rows: int, cols: int, rStart: int, cStart: int) -> List[List[int]]:\\n        total, cnt, step, i = rows * cols, 1, 1, 0\\n        ans = [[rStart, cStart]]\\n        direction = {0: (0, 1), 1: (1, 0), 2: (0, -1), 3: (-1, 0)} # setup direction movements\\n        while cnt < total:\\n            for k in range(step):\\n                rStart, cStart = rStart+direction[i][0], cStart + direction[i][1]\\n                if 0 <= rStart < rows and 0 <= cStart < cols:\\n                    ans.append([rStart, cStart])\\n                    cnt += 1       # count visited \\n            i = (i + 1) % 4        # changing direction\\n            step += not i % 2      # increase step every 2 directions\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 897620,
                "title": "javascript-one-pass-solution",
                "content": "The idea in each spiral both row and col movements will have the same offset. but may have different limits (or boundaries). \\nSo compute `cLimit` for column and  `rLimit`  for row and update the offset to the next spiral length whenever both `i`  add `j` are equal to their respective limits\\n\\n```\\nvar spiralMatrixIII = function(R, C, r0, c0) {\\n    let offset = 1, cLimit = c0+offset, rLimit = r0+offset\\n    let i = r0, j = c0\\n    let res = []\\n    \\n    while(res.length < R*C){\\n\\t\\t//if i and j are within the boundaries of the matix and to res\\n        if(i>=0 && j>=0 && i<R && j<C){  \\n            res.push([i,j])\\n        }\\n        // if i and j are both equal to their respective limits upate offset to next spiral length and direction\\n        if(i == rLimit && cLimit == j){ \\n            offset = offset<0 ? offset-1 : offset+1\\n            offset *= -1\\n            cLimit = cLimit + offset\\n            rLimit = rLimit + offset\\n        }\\n        // each of the four possible movements through the matrix\\n        if(j<cLimit) j++\\n        else if(i<rLimit) i++\\n        else if(j>cLimit) j--\\n        else if(i>rLimit) i--\\n    }\\n    return res\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar spiralMatrixIII = function(R, C, r0, c0) {\\n    let offset = 1, cLimit = c0+offset, rLimit = r0+offset\\n    let i = r0, j = c0\\n    let res = []\\n    \\n    while(res.length < R*C){\\n\\t\\t//if i and j are within the boundaries of the matix and to res\\n        if(i>=0 && j>=0 && i<R && j<C){  \\n            res.push([i,j])\\n        }\\n        // if i and j are both equal to their respective limits upate offset to next spiral length and direction\\n        if(i == rLimit && cLimit == j){ \\n            offset = offset<0 ? offset-1 : offset+1\\n            offset *= -1\\n            cLimit = cLimit + offset\\n            rLimit = rLimit + offset\\n        }\\n        // each of the four possible movements through the matrix\\n        if(j<cLimit) j++\\n        else if(i<rLimit) i++\\n        else if(j>cLimit) j--\\n        else if(i>rLimit) i--\\n    }\\n    return res\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 347424,
                "title": "java-solution-just-like-clean-robot",
                "content": "Just like robot clean problem, use```curDirection```to record the curDirection and ```(curDirection + 1) % 4```to find the next direction.\\nWhen the direction is equals 0 or 2, ```len++```\\u3002\\n```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int R, int C, int r0, int c0) {\\n        int[] dx = new int[]{0, 1, 0, -1};\\n        int[] dy = new int[]{1, 0, -1, 0};\\n        List<int[]> list = new ArrayList<>();\\n        int curDirection = 0;\\n        list.add(new int[]{r0, c0});\\n        int len = 0;\\n        while (list.size() < R * C) {\\n            if (curDirection == 0 || curDirection == 2) len++;\\n            for (int i = 0; i < len; i++) {\\n                r0 += dx[curDirection];\\n                c0 += dy[curDirection];\\n                if (r0 < 0 || r0 >= R || c0 < 0 || c0 >= C) continue;\\n                list.add(new int[]{r0, c0});\\n            }\\n            curDirection = (curDirection + 1) % 4;\\n        }\\n        int[][] res = new int[list.size()][2];\\n        for (int i = 0; i < res.length; i++) {\\n            res[i] = list.get(i);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```curDirection```\n```(curDirection + 1) % 4```\n```len++```\n```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int R, int C, int r0, int c0) {\\n        int[] dx = new int[]{0, 1, 0, -1};\\n        int[] dy = new int[]{1, 0, -1, 0};\\n        List<int[]> list = new ArrayList<>();\\n        int curDirection = 0;\\n        list.add(new int[]{r0, c0});\\n        int len = 0;\\n        while (list.size() < R * C) {\\n            if (curDirection == 0 || curDirection == 2) len++;\\n            for (int i = 0; i < len; i++) {\\n                r0 += dx[curDirection];\\n                c0 += dy[curDirection];\\n                if (r0 < 0 || r0 >= R || c0 < 0 || c0 >= C) continue;\\n                list.add(new int[]{r0, c0});\\n            }\\n            curDirection = (curDirection + 1) % 4;\\n        }\\n        int[][] res = new int[list.size()][2];\\n        for (int i = 0; i < res.length; i++) {\\n            res[i] = list.get(i);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3292721,
                "title": "c-f-cing-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        \\n        vector<vector<int>> ans(rows* cols, vector<int>(2));\\n        int i=0;\\n        ans[i++]={rStart,cStart};\\n        int len=0;\\n        int d=0;\\n        int direction[]={0,1,0,-1,0};\\n        while(i<rows*cols){\\n            if(d==0 ||d==2){\\n                len++;\\n            }\\n            for(int k=0;k<len;k++){\\n                rStart+=direction[d];\\n                cStart+=direction[d+1];\\n               if(rStart<rows && rStart>=0&& cStart<cols && cStart>=0 ){\\n                    ans[i++]={rStart,cStart};\\n            \\n                } \\n            }\\n         d=++d%4;   \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        \\n        vector<vector<int>> ans(rows* cols, vector<int>(2));\\n        int i=0;\\n        ans[i++]={rStart,cStart};\\n        int len=0;\\n        int d=0;\\n        int direction[]={0,1,0,-1,0};\\n        while(i<rows*cols){\\n            if(d==0 ||d==2){\\n                len++;\\n            }\\n            for(int k=0;k<len;k++){\\n                rStart+=direction[d];\\n                cStart+=direction[d+1];\\n               if(rStart<rows && rStart>=0&& cStart<cols && cStart>=0 ){\\n                    ans[i++]={rStart,cStart};\\n            \\n                } \\n            }\\n         d=++d%4;   \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2837586,
                "title": "c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\npublic class Solution {\\n    public int[][] SpiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        List<int[]> result = new();\\n       int[,] directions = new int[,]{{0,1} ,{1,0},{0,-1},{-1,0}};\\n        int len =0;\\n        int d =0;\\n        result.Add(new int[]{rStart, cStart});\\n\\n        while(result.Count < rows * cols)\\n        {\\n            //directions right---> or left <---, increase len++\\n            if(d==0 || d==2)\\n            {\\n                len++;\\n            }\\n            for(int k=0; k<len; k++)\\n            {\\n                rStart += directions[d,0];\\n                cStart += directions[d,1];\\n                if(rStart < rows && rStart >=0 && cStart < cols && cStart >=0)\\n                {\\n                    result.Add(new int[]{rStart, cStart});\\n                }\\n            }\\n            d= (d+1) % 4;\\n        }\\n        return result.ToArray();\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int[][] SpiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        List<int[]> result = new();\\n       int[,] directions = new int[,]{{0,1} ,{1,0},{0,-1},{-1,0}};\\n        int len =0;\\n        int d =0;\\n        result.Add(new int[]{rStart, cStart});\\n\\n        while(result.Count < rows * cols)\\n        {\\n            //directions right---> or left <---, increase len++\\n            if(d==0 || d==2)\\n            {\\n                len++;\\n            }\\n            for(int k=0; k<len; k++)\\n            {\\n                rStart += directions[d,0];\\n                cStart += directions[d,1];\\n                if(rStart < rows && rStart >=0 && cStart < cols && cStart >=0)\\n                {\\n                    result.Add(new int[]{rStart, cStart});\\n                }\\n            }\\n            d= (d+1) % 4;\\n        }\\n        return result.ToArray();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2718364,
                "title": "easy-python-solution-based-on-spiral-matrix-i-and-ii",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAfter every iteration of a row or column we need to widen our range.\\nIf the first row we\\'re reading is length of two when we read if in reverse direction we need to add one more element to it.\\nEg. Lets read a row in to the left direction then when we eventually try to read in the reverse that is to the right direction. We include one more element. 1->2 then 5<-4<-3\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n*m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n*m)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def spiralMatrixIII(self, rows: int, cols: int, rStart: int, cStart: int) -> List[List[int]]:\\n        ans = []\\n        left, right = cStart, cStart+1\\n        top, bottom = rStart, rStart+1\\n        current = 1\\n        move = 0\\n        while current <= rows*cols:\\n            # fill top\\n            for i in range(left+move, right+1):\\n                if self.inbound(top, i, rows, cols):\\n                    ans.append([top, i])\\n                    current += 1\\n            left -= 1\\n            # fill right\\n            for i in range(top+1, bottom+1):\\n                if self.inbound(i, right, rows, cols):\\n                    ans.append([i, right])\\n                    current += 1\\n            top -= 1\\n            # fill bottom\\n            for i in range(right-1, left-1, -1):\\n                if self.inbound(bottom, i, rows, cols):\\n                    ans.append([bottom, i])\\n                    current += 1\\n            right += 1\\n            # fill left\\n            for i in range(bottom-1, top-1, -1):\\n                if self.inbound(i, left, rows, cols):\\n                    ans.append([i, left])\\n                    current += 1\\n            bottom += 1\\n            move = 1\\n        return ans\\n    def inbound(self, r, c, rows, cols):\\n        return 0<=r<rows and 0<=c<cols\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def spiralMatrixIII(self, rows: int, cols: int, rStart: int, cStart: int) -> List[List[int]]:\\n        ans = []\\n        left, right = cStart, cStart+1\\n        top, bottom = rStart, rStart+1\\n        current = 1\\n        move = 0\\n        while current <= rows*cols:\\n            # fill top\\n            for i in range(left+move, right+1):\\n                if self.inbound(top, i, rows, cols):\\n                    ans.append([top, i])\\n                    current += 1\\n            left -= 1\\n            # fill right\\n            for i in range(top+1, bottom+1):\\n                if self.inbound(i, right, rows, cols):\\n                    ans.append([i, right])\\n                    current += 1\\n            top -= 1\\n            # fill bottom\\n            for i in range(right-1, left-1, -1):\\n                if self.inbound(bottom, i, rows, cols):\\n                    ans.append([bottom, i])\\n                    current += 1\\n            right += 1\\n            # fill left\\n            for i in range(bottom-1, top-1, -1):\\n                if self.inbound(i, left, rows, cols):\\n                    ans.append([i, left])\\n                    current += 1\\n            bottom += 1\\n            move = 1\\n        return ans\\n    def inbound(self, r, c, rows, cols):\\n        return 0<=r<rows and 0<=c<cols\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2188144,
                "title": "java-spiral-matrix-iii",
                "content": "In this question first we need to observe ans understand that how the direction will change or I should say what is the condition when the iterator itr (which is traversing array(matrix)) will change its direction of iteration.\\n\\nBy observation we figured it out that iterator itr is traversing the array in a pattern or elements of array are arranged in a definite pattern \\n   itr moves 1 step in right\\n   itr then moves 1step down \\n   itr then moves 2 steps in left\\n   itr then moves 2 steps top\\n   itr then moves 3 steps in right\\n   itr then moves 3 steps down\\n   itr then moves 4 steps in left\\n   itr then moves 4 steps top\\n   itr then moves 5 step in right\\n   .\\n   .\\n   .\\n   .\\n   .\\n   .\\n   .\\n   .\\n   ans so on till the last element is reached\\n   \\n  ![image](https://assets.leetcode.com/users/images/cf928875-778b-49d7-9fc0-c5e08c1e17de_1656001345.1119683.png)\\n\\n\\n   \\n   here we can observe that itreator itr traverse the array in a pattern   1,1,2,2,3,3,4,4,5,5,6,6,.............\\n   \\n   so now we know the pattern, we have to derive the formula to get that pattern to traverse the array\\n   let  A(0)==1, A(1)==1, A(2)==2, A(3)==2, A(4)==3, A(5)==3, A(6)==4, . . . . . . . . . . . . . . and so on\\n   \\n   so, by this we can conclude\\n        A(n)= n/2 + 1;\\n\\t\\there n belong to (0, length of row of ans)\\n\\t\\t\\n\\t\\t\\n\\t\\t\\n   Now, we have one more challenge to change the direction of array in this we have four cases\\n  Case 1:-  When iterate from left to right\\n\\t\\t\\t\\t  here we need to increment the column index only \\n\\n  Case 2:- When iterate from top to bottom\\n\\t\\t\\t\\there we need to increment the row index only\\n\\n  Case 3:- When iterate from right to left\\n\\t\\t\\t\\there we need to decrement the column index only\\n\\n  Case 4:- When iterate from bottom to top \\n\\t\\t\\t\\there we need to decrement the row index only\\n\\t\\t\\t\\t\\t\\nTo handle or perform the above for cases we can do this by using simple technique\\ntake   int dx=0, dy=1, temp=0;\\nand    rStart==x, cStart=y\\n\\nnow just perfor this simple following code when the inner loop has done traversing in one direction or  you can say after  the completion of inner loop \\n\\ntemp=dx;\\ndx=dy;\\ndy= -tmp;\\n\\t\\t\\n\\t\\t\\n\\t\\t\\n\\t\\t\\n\\t\\t\\n\\t\\t```\\n\\t\\t\\n\\t\\tclass Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int x, int y) {\\n        \\n        int[][] ans=new int[rows*cols][2];\\n        int n=0;\\n        int dx=0;\\n        int dy=1;\\n        int temp=0;\\n        \\n        for(int j=0;j<rows*cols;++n){\\n            for(int i=0;i< n/2 + 1;++i){\\n                \\n                if(x>=0 && x<rows && y>=0 && y<cols){\\n                    // here we are assigning the new 1D array to row of 2D array (ans) \\n                    // it will remind you some basic concept of aray that every thing in java is an object\\n                    ans[j++]=new int[]{x,y};\\n                }\\n                \\n                x=x+dx;\\n                y=y+dy;\\n            }\\n            // by this code we will change the direction of array(ans) traversing\\n            // left to right\\n            // top to bottom\\n            // right to left\\n            // bottom to up\\n            temp=dx;\\n            dx=dy;\\n            dy= -temp;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n\\n```\\n\\t\\t\\n",
                "solutionTags": [
                    "Matrix"
                ],
                "code": "```\\n\\t\\t\\n\\t\\tclass Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int x, int y) {\\n        \\n        int[][] ans=new int[rows*cols][2];\\n        int n=0;\\n        int dx=0;\\n        int dy=1;\\n        int temp=0;\\n        \\n        for(int j=0;j<rows*cols;++n){\\n            for(int i=0;i< n/2 + 1;++i){\\n                \\n                if(x>=0 && x<rows && y>=0 && y<cols){\\n                    // here we are assigning the new 1D array to row of 2D array (ans) \\n                    // it will remind you some basic concept of aray that every thing in java is an object\\n                    ans[j++]=new int[]{x,y};\\n                }\\n                \\n                x=x+dx;\\n                y=y+dy;\\n            }\\n            // by this code we will change the direction of array(ans) traversing\\n            // left to right\\n            // top to bottom\\n            // right to left\\n            // bottom to up\\n            temp=dx;\\n            dx=dy;\\n            dy= -temp;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1941300,
                "title": "c-easy-understanding",
                "content": "intution :\\nin each iteration you are traversing a square \\n     ->  downwards -> leftwards ->upwards ->righwards\\nwhile traversing check if the cell is within the grid\\nif with in the grid assign the value of count and increment count value\\nafter each iteration update the value of l,r,t,b\\n\\nl = index of left most column\\nr = index of right most column\\nt = index of top  row\\nb = index of bottom row\\n```\\nclass Solution {\\npublic:\\n    int m1,n1;\\n    void solve(vector<vector<int>>&res,int r,int c,int &ct){\\n        if(r>=0 && r<m1 && c>=0 && c<n1){\\n            {res.push_back({r,c});ct++;}\\n        }\\n    }\\n    vector<vector<int>> spiralMatrixIII(int m, int n, int rs, int cs) {\\n        \\n        vector<vector<int>>res;\\n        res.push_back({rs,cs});\\n        int l=cs-1,r=cs+1,t=rs-1,b=rs+1,ct=2;\\n        m1=m;n1=n;\\n        while(ct<=m*n){\\n            for(int i=t+1;i<b;i++) solve(res,i,r,ct);\\n            for(int i=r;i>=l;i--)  solve(res,b,i,ct);\\n            for(int i=b-1;i>t;i--) solve(res,i,l,ct);\\n            for(int i=l;i<=r;i++)  solve(res,t,i,ct);\\n            r++;l--;t--;b++;\\n        }\\n        return res;\\n    }\\n};\\n```\\nplease upvote if you like .\\nHappy coding :)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int m1,n1;\\n    void solve(vector<vector<int>>&res,int r,int c,int &ct){\\n        if(r>=0 && r<m1 && c>=0 && c<n1){\\n            {res.push_back({r,c});ct++;}\\n        }\\n    }\\n    vector<vector<int>> spiralMatrixIII(int m, int n, int rs, int cs) {\\n        \\n        vector<vector<int>>res;\\n        res.push_back({rs,cs});\\n        int l=cs-1,r=cs+1,t=rs-1,b=rs+1,ct=2;\\n        m1=m;n1=n;\\n        while(ct<=m*n){\\n            for(int i=t+1;i<b;i++) solve(res,i,r,ct);\\n            for(int i=r;i>=l;i--)  solve(res,b,i,ct);\\n            for(int i=b-1;i>t;i--) solve(res,i,l,ct);\\n            for(int i=l;i<=r;i++)  solve(res,t,i,ct);\\n            r++;l--;t--;b++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1637681,
                "title": "python3-simple",
                "content": "```\\nclass Solution:\\n    def spiralMatrixIII(self, rows: int, cols: int, rStart: int, cStart: int) -> List[List[int]]:\\n        res=[]\\n        rowMin=rStart\\n        rowMax=rStart+1\\n        colMin=cStart\\n        colMax=cStart+1\\n        while len(res)!=rows*cols:\\n            \\n            for col in range(colMin,colMax):\\n                if 0<=col<cols and 0<=rowMin<rows: res.append([rowMin,col])\\n            \\n            for row in range(rowMin,rowMax):\\n                if 0<=colMax<cols and 0<=row<rows: res.append([row,colMax])\\n            \\n            colMin-=1\\n            \\n            for col in range(colMax,colMin,-1):\\n                if 0<=col<cols and 0<=rowMax<rows: res.append([rowMax,col])\\n            \\n            rowMin-=1\\n            \\n            for row in range(rowMax,rowMin,-1):\\n                if 0<=colMin<cols and 0<=row<rows: res.append([row,colMin])\\n            \\n            colMax+=1\\n            rowMax+=1\\n        \\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def spiralMatrixIII(self, rows: int, cols: int, rStart: int, cStart: int) -> List[List[int]]:\\n        res=[]\\n        rowMin=rStart\\n        rowMax=rStart+1\\n        colMin=cStart\\n        colMax=cStart+1\\n        while len(res)!=rows*cols:\\n            \\n            for col in range(colMin,colMax):\\n                if 0<=col<cols and 0<=rowMin<rows: res.append([rowMin,col])\\n            \\n            for row in range(rowMin,rowMax):\\n                if 0<=colMax<cols and 0<=row<rows: res.append([row,colMax])\\n            \\n            colMin-=1\\n            \\n            for col in range(colMax,colMin,-1):\\n                if 0<=col<cols and 0<=rowMax<rows: res.append([rowMax,col])\\n            \\n            rowMin-=1\\n            \\n            for row in range(rowMax,rowMin,-1):\\n                if 0<=colMin<cols and 0<=row<rows: res.append([row,colMin])\\n            \\n            colMax+=1\\n            rowMax+=1\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1607741,
                "title": "cpp-solution-faster-than-99-12",
                "content": "On observing we need to take take steps in each direction two times, like we start from left, then we take one step to left than we go down(directed to) and take one step there, after that we need to take 2 steps the same way to right and to up, the  solution is the sollowing the same rule> I know its a bit lengthy but ***TIME MATTERS*** most IMO.(99.12%)\\n```\\nvector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        vector<vector<int>> ans;\\n        vector<int>temp;\\n\\t\\t//base case\\n        if(rows==1 && cols==1){\\n            temp.push_back(0);\\n            temp.push_back(0);\\n            ans.push_back(temp);\\n            return ans;\\n        }\\n        int steps=1;\\n        int n=2;\\n        int size=0;\\n        int x=rStart,y=cStart;\\n\\t\\t\\n\\t\\t//variable for tracking the direction\\n        char dir=\\'r\\';\\n\\t\\t\\n\\t\\t//for first step\\n        temp.push_back(x);\\n        temp.push_back(y);\\n        ans.push_back(temp);\\n        size++;\\n        temp.clear();\\n        while(size<=cols*rows){\\n            for(int i=0;i<n;i++){\\n                for(int j=0;j<steps;j++){\\n                    if(dir==\\'r\\')y++;\\n                    else if(dir==\\'b\\')x++;\\n                    else if(dir==\\'l\\')y--;\\n                    else if(dir==\\'u\\')x--;\\n                    if(x>=0 && x<rows && y>=0 && y<cols){\\n                        temp.push_back(x);\\n                        temp.push_back(y);\\n                        ans.push_back(temp);\\n                        temp.clear();\\n                        size++;\\n                        if(size==cols*rows)return ans;\\n                    }\\n                }\\n                if(dir==\\'r\\')dir=\\'b\\';\\n                else if(dir==\\'b\\')dir=\\'l\\';\\n                else if(dir==\\'l\\')dir=\\'u\\';\\n                else if(dir==\\'u\\')dir=\\'r\\';\\n            }\\n\\t\\t\\t//after two iterations in 2 directions we need to change the number of steps\\n            steps++;\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nvector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        vector<vector<int>> ans;\\n        vector<int>temp;\\n\\t\\t//base case\\n        if(rows==1 && cols==1){\\n            temp.push_back(0);\\n            temp.push_back(0);\\n            ans.push_back(temp);\\n            return ans;\\n        }\\n        int steps=1;\\n        int n=2;\\n        int size=0;\\n        int x=rStart,y=cStart;\\n\\t\\t\\n\\t\\t//variable for tracking the direction\\n        char dir=\\'r\\';\\n\\t\\t\\n\\t\\t//for first step\\n        temp.push_back(x);\\n        temp.push_back(y);\\n        ans.push_back(temp);\\n        size++;\\n        temp.clear();\\n        while(size<=cols*rows){\\n            for(int i=0;i<n;i++){\\n                for(int j=0;j<steps;j++){\\n                    if(dir==\\'r\\')y++;\\n                    else if(dir==\\'b\\')x++;\\n                    else if(dir==\\'l\\')y--;\\n                    else if(dir==\\'u\\')x--;\\n                    if(x>=0 && x<rows && y>=0 && y<cols){\\n                        temp.push_back(x);\\n                        temp.push_back(y);\\n                        ans.push_back(temp);\\n                        temp.clear();\\n                        size++;\\n                        if(size==cols*rows)return ans;\\n                    }\\n                }\\n                if(dir==\\'r\\')dir=\\'b\\';\\n                else if(dir==\\'b\\')dir=\\'l\\';\\n                else if(dir==\\'l\\')dir=\\'u\\';\\n                else if(dir==\\'u\\')dir=\\'r\\';\\n            }\\n\\t\\t\\t//after two iterations in 2 directions we need to change the number of steps\\n            steps++;\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 600122,
                "title": "java-straightforward-solution",
                "content": "```\\n\\tpublic int[][] spiralMatrixIII(int R, int C, int r0, int c0) {\\n        int[][] ret = new int[R*C][2];\\n        int step = 1;\\n        int i = 0;\\n        int r = r0;\\n        int c = c0;\\n        int offset = 1;\\n        while (i < R*C) {\\n            for (int j = 0; j < step; j++) {\\n                if (r >= 0 && c >= 0 && r < R && c < C && i < R*C) {\\n                    ret[i][0] = r;\\n                    ret[i][1] = c;\\n                    i++;\\n                }\\n                c += offset;\\n            }\\n            for (int j = 0; j < step; j++) {\\n                if (r >= 0 && c >= 0 && r < R && c < C && i < R*C) {\\n                    ret[i][0] = r;\\n                    ret[i][1] = c;\\n                    i++;\\n                }\\n                r += offset;\\n            }\\n            step++;\\n            offset = -offset;\\n        }\\n        return ret;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\tpublic int[][] spiralMatrixIII(int R, int C, int r0, int c0) {\\n        int[][] ret = new int[R*C][2];\\n        int step = 1;\\n        int i = 0;\\n        int r = r0;\\n        int c = c0;\\n        int offset = 1;\\n        while (i < R*C) {\\n            for (int j = 0; j < step; j++) {\\n                if (r >= 0 && c >= 0 && r < R && c < C && i < R*C) {\\n                    ret[i][0] = r;\\n                    ret[i][1] = c;\\n                    i++;\\n                }\\n                c += offset;\\n            }\\n            for (int j = 0; j < step; j++) {\\n                if (r >= 0 && c >= 0 && r < R && c < C && i < R*C) {\\n                    ret[i][0] = r;\\n                    ret[i][1] = c;\\n                    i++;\\n                }\\n                r += offset;\\n            }\\n            step++;\\n            offset = -offset;\\n        }\\n        return ret;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 159178,
                "title": "javascript-solution-straightforward-with-graph",
                "content": "The key point is to traverse the elements in correct order.\\n### Steps:\\n* Find out how many times we should do the traversal (four lines one time, as shown in the graph);\\n* Each time, we traverse four lines, and we push every element we meet, no matter whether they belong to the matrix or not;\\n* We filter the result we got, and leave only elements that belong to the matrix.\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/lmiaoj/image_1534089926.png)\\n\\n```\\nvar spiralMatrixIII = function(R, C, r0, c0) {\\n    let n = Math.max(r0, c0, R-1-r0, C-1-c0);\\n    let res = [[r0,c0]];\\n    for(let i=1; i<=n; i++){\\n    \\tfor(let j=1-i; j<=i; j++) res.push([r0+j,c0+i]); //line 1\\n    \\tfor(let j=i-1; j>=-i; j--) res.push([r0+i,c0+j]); //line 2\\n    \\tfor(let j=i-1; j>=-i; j--) res.push([r0+j,c0-i]); //line 3\\n    \\tfor(let j=1-i; j<=i; j++) res.push([r0-i,c0+j]); //line 4\\n    }\\n    return res.filter(x=>x[0]>=0&&x[0]<R&&x[1]>=0&&x[1]<C);\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar spiralMatrixIII = function(R, C, r0, c0) {\\n    let n = Math.max(r0, c0, R-1-r0, C-1-c0);\\n    let res = [[r0,c0]];\\n    for(let i=1; i<=n; i++){\\n    \\tfor(let j=1-i; j<=i; j++) res.push([r0+j,c0+i]); //line 1\\n    \\tfor(let j=i-1; j>=-i; j--) res.push([r0+i,c0+j]); //line 2\\n    \\tfor(let j=i-1; j>=-i; j--) res.push([r0+j,c0-i]); //line 3\\n    \\tfor(let j=1-i; j<=i; j++) res.push([r0-i,c0+j]); //line 4\\n    }\\n    return res.filter(x=>x[0]>=0&&x[0]<R&&x[1]>=0&&x[1]<C);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3709692,
                "title": "c-simple-soln",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTraversing spirally and checking whether that element belong to matrix or not\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe are traversing the matrix spirally and for each element we are checking  whether it lies in matrix or not and if len of answer becomes equal to rows*cols, we return.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(rows*rows*cols*cols)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isvalid(int i,int j, int row, int col)\\n    {\\n        return (i>=0 && j>=0 && i<row && j<col);\\n    }\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        vector<vector<int>> ans;\\n        ans.push_back({rStart,cStart});\\n\\n        int step = 1;\\n        int i = rStart,j = cStart;\\n\\n        while(ans.size() < rows*cols)\\n        {\\n            if(ans.size()==rows*cols)\\n            return ans;\\n\\n            int k=0;\\n            while(k<step)\\n            {\\n                j++;\\n                if(isvalid(i,j,rows,cols))\\n                {\\n                    ans.push_back({i,j});\\n                    if(ans.size()==rows*cols)\\n                    return ans;\\n                }\\n                k++;\\n            }\\n\\n            k=0;\\n            while(k<step)\\n            {\\n                i++;\\n                if(isvalid(i,j,rows,cols))\\n                {\\n                    ans.push_back({i,j});\\n                    if(ans.size()==rows*cols)\\n                    return ans;\\n                }\\n                k++;\\n            }\\n\\n            step++;\\n\\n            k=0;\\n            while(k<step)\\n            {\\n                j--;\\n                if(isvalid(i,j,rows,cols))\\n                {\\n                    ans.push_back({i,j});\\n                    if(ans.size()==rows*cols)\\n                    return ans;\\n                }\\n                k++;\\n            }\\n\\n            k=0;\\n            while(k<step)\\n            {\\n                i--;\\n                if(isvalid(i,j,rows,cols))\\n                {\\n                    ans.push_back({i,j});\\n                    if(ans.size()==rows*cols)\\n                    return ans;\\n                }\\n                k++;\\n            }\\n\\n            step++;\\n\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isvalid(int i,int j, int row, int col)\\n    {\\n        return (i>=0 && j>=0 && i<row && j<col);\\n    }\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        vector<vector<int>> ans;\\n        ans.push_back({rStart,cStart});\\n\\n        int step = 1;\\n        int i = rStart,j = cStart;\\n\\n        while(ans.size() < rows*cols)\\n        {\\n            if(ans.size()==rows*cols)\\n            return ans;\\n\\n            int k=0;\\n            while(k<step)\\n            {\\n                j++;\\n                if(isvalid(i,j,rows,cols))\\n                {\\n                    ans.push_back({i,j});\\n                    if(ans.size()==rows*cols)\\n                    return ans;\\n                }\\n                k++;\\n            }\\n\\n            k=0;\\n            while(k<step)\\n            {\\n                i++;\\n                if(isvalid(i,j,rows,cols))\\n                {\\n                    ans.push_back({i,j});\\n                    if(ans.size()==rows*cols)\\n                    return ans;\\n                }\\n                k++;\\n            }\\n\\n            step++;\\n\\n            k=0;\\n            while(k<step)\\n            {\\n                j--;\\n                if(isvalid(i,j,rows,cols))\\n                {\\n                    ans.push_back({i,j});\\n                    if(ans.size()==rows*cols)\\n                    return ans;\\n                }\\n                k++;\\n            }\\n\\n            k=0;\\n            while(k<step)\\n            {\\n                i--;\\n                if(isvalid(i,j,rows,cols))\\n                {\\n                    ans.push_back({i,j});\\n                    if(ans.size()==rows*cols)\\n                    return ans;\\n                }\\n                k++;\\n            }\\n\\n            step++;\\n\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3508037,
                "title": "easy-to-understand-approach-commented",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool isValid(int nrow,int ncol,int n,int m){\\n        return nrow>=0 && nrow<n && ncol>=0 && ncol<m ;\\n    }\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        vector<vector<int>>spiral;\\n        spiral.push_back({rStart,cStart});\\n        //till now, 1 coordinate used \\n        int used=1,move=1; \\n        while(used<rows*cols){\\n \\n            //for right movement first [1,2,3...]\\n            int canMove=move;\\n            while(canMove--){\\n                //row remains same column changes\\n                cStart++;\\n                //if new position valid take it in spiral order \\n                if(isValid(rStart,cStart,rows,cols)){\\n                     spiral.push_back({rStart,cStart});\\n                     used++; //another coordinate used \\n                }\\n            }\\n\\n            //for down movement \\n              canMove=move;\\n            while(canMove--){\\n                //column remains same row changes\\n                rStart++;\\n                //if new position valid take it in spiral order \\n                if(isValid(rStart,cStart,rows,cols)){\\n                     spiral.push_back({rStart,cStart});\\n                     used++; //another coordinate used \\n                }\\n            }\\n            //AFTER ONE SET OF RIGHT-DOWN MOVEMENT MOVE INCREASES BY 1 \\n            move++;\\n            \\n\\n            //for left movement \\n              canMove=move;\\n            while(canMove--){\\n                //row remains same column changes\\n                cStart--;\\n                //if new position valid take it in spiral order \\n                if(isValid(rStart,cStart,rows,cols)){\\n                     spiral.push_back({rStart,cStart});\\n                     used++; //another coordinate used \\n                }\\n            }\\n            \\n            //for up movement \\n              canMove=move;\\n            while(canMove--){\\n                //column remains same row changes\\n                rStart--;\\n                //if new position valid take it in spiral order \\n                if(isValid(rStart,cStart,rows,cols)){\\n                     spiral.push_back({rStart,cStart});\\n                     used++; //another coordinate used \\n                }\\n            }\\n            //AFTER ONE SET OF LEFT-UP MOVEMENT MOVE INCREASES BY 1 \\n            move++;\\n        }\\n        return spiral;\\n    }\\n};\\n```\\n```\\nIf you find this solutions to be helpful do upvote..It keeps me motivated :)\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(int nrow,int ncol,int n,int m){\\n        return nrow>=0 && nrow<n && ncol>=0 && ncol<m ;\\n    }\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        vector<vector<int>>spiral;\\n        spiral.push_back({rStart,cStart});\\n        //till now, 1 coordinate used \\n        int used=1,move=1; \\n        while(used<rows*cols){\\n \\n            //for right movement first [1,2,3...]\\n            int canMove=move;\\n            while(canMove--){\\n                //row remains same column changes\\n                cStart++;\\n                //if new position valid take it in spiral order \\n                if(isValid(rStart,cStart,rows,cols)){\\n                     spiral.push_back({rStart,cStart});\\n                     used++; //another coordinate used \\n                }\\n            }\\n\\n            //for down movement \\n              canMove=move;\\n            while(canMove--){\\n                //column remains same row changes\\n                rStart++;\\n                //if new position valid take it in spiral order \\n                if(isValid(rStart,cStart,rows,cols)){\\n                     spiral.push_back({rStart,cStart});\\n                     used++; //another coordinate used \\n                }\\n            }\\n            //AFTER ONE SET OF RIGHT-DOWN MOVEMENT MOVE INCREASES BY 1 \\n            move++;\\n            \\n\\n            //for left movement \\n              canMove=move;\\n            while(canMove--){\\n                //row remains same column changes\\n                cStart--;\\n                //if new position valid take it in spiral order \\n                if(isValid(rStart,cStart,rows,cols)){\\n                     spiral.push_back({rStart,cStart});\\n                     used++; //another coordinate used \\n                }\\n            }\\n            \\n            //for up movement \\n              canMove=move;\\n            while(canMove--){\\n                //column remains same row changes\\n                rStart--;\\n                //if new position valid take it in spiral order \\n                if(isValid(rStart,cStart,rows,cols)){\\n                     spiral.push_back({rStart,cStart});\\n                     used++; //another coordinate used \\n                }\\n            }\\n            //AFTER ONE SET OF LEFT-UP MOVEMENT MOVE INCREASES BY 1 \\n            move++;\\n        }\\n        return spiral;\\n    }\\n};\\n```\n```\\nIf you find this solutions to be helpful do upvote..It keeps me motivated :)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3399551,
                "title": "java-beats-100-0ms-runtime-easy-to-understand",
                "content": "# Complexity\\n- Time complexity: O(rows * cols)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        int[][] matrix = new int[rows*cols][2];\\n        int k = 0;\\n        \\n        int rEnd = rStart + 1;\\n        int cEnd = cStart + 1;\\n\\n        while(true) {\\n            // right \\n            for(int i = cStart; i <= cEnd; i++) {\\n                if(i < cols && i >= 0 && rStart >= 0) {\\n                    matrix[k][0] = rStart;\\n                    matrix[k][1] = i;\\n                    k++;\\n                }\\n            }\\n            cStart--;\\n            cEnd++;\\n\\n            if(k == matrix.length) {\\n                break;\\n            }\\n\\n            // down \\n            for(int i = rStart + 1; i <= rEnd; i++) {\\n                if(i < rows && i >= 0 && cEnd - 1 < cols) {\\n                    matrix[k][0] = i;\\n                    matrix[k][1] = cEnd - 1;\\n                    k++;\\n                }\\n            }\\n            rStart--;\\n            rEnd++;\\n\\n            if(k == matrix.length) {\\n                break;\\n            }\\n\\n            // left\\n            for(int i = cEnd - 2; i >= cStart; i--) {\\n                if(i >= 0 && i < cols && rEnd - 1 < rows) {\\n                    matrix[k][0] = rEnd - 1;\\n                    matrix[k][1] = i;\\n                    k++;\\n                }\\n            }\\n        \\n            if(k == matrix.length) {\\n                break;\\n            }\\n\\n            // up\\n            for(int i = rEnd - 2; i > rStart; i--) {\\n                if(i >= 0 && i < rows && cStart >= 0) {\\n                    matrix[k][0] = i;\\n                    matrix[k][1] = cStart;\\n                    k++;\\n                }\\n            }\\n        \\n            if(k == matrix.length) {\\n                break;\\n            }\\n        }\\n        return matrix;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        int[][] matrix = new int[rows*cols][2];\\n        int k = 0;\\n        \\n        int rEnd = rStart + 1;\\n        int cEnd = cStart + 1;\\n\\n        while(true) {\\n            // right \\n            for(int i = cStart; i <= cEnd; i++) {\\n                if(i < cols && i >= 0 && rStart >= 0) {\\n                    matrix[k][0] = rStart;\\n                    matrix[k][1] = i;\\n                    k++;\\n                }\\n            }\\n            cStart--;\\n            cEnd++;\\n\\n            if(k == matrix.length) {\\n                break;\\n            }\\n\\n            // down \\n            for(int i = rStart + 1; i <= rEnd; i++) {\\n                if(i < rows && i >= 0 && cEnd - 1 < cols) {\\n                    matrix[k][0] = i;\\n                    matrix[k][1] = cEnd - 1;\\n                    k++;\\n                }\\n            }\\n            rStart--;\\n            rEnd++;\\n\\n            if(k == matrix.length) {\\n                break;\\n            }\\n\\n            // left\\n            for(int i = cEnd - 2; i >= cStart; i--) {\\n                if(i >= 0 && i < cols && rEnd - 1 < rows) {\\n                    matrix[k][0] = rEnd - 1;\\n                    matrix[k][1] = i;\\n                    k++;\\n                }\\n            }\\n        \\n            if(k == matrix.length) {\\n                break;\\n            }\\n\\n            // up\\n            for(int i = rEnd - 2; i > rStart; i--) {\\n                if(i >= 0 && i < rows && cStart >= 0) {\\n                    matrix[k][0] = i;\\n                    matrix[k][1] = cStart;\\n                    k++;\\n                }\\n            }\\n        \\n            if(k == matrix.length) {\\n                break;\\n            }\\n        }\\n        return matrix;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3152133,
                "title": "java-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    int idx;\\n    int[][] ret;\\n    \\n    private void add (int r, int c, int R, int C) {\\n        if (r >= R || r < 0 || c >= C || c < 0) return;\\n        ret[idx][0] = r;\\n        ret[idx++][1] = c;\\n    }\\n    \\n    public int[][] spiralMatrixIII(int R, int C, int r0, int c0) {\\n        int r = r0, c = c0, len = 1;\\n        ret = new int[R * C][2];\\n        while (idx < (R * C )) {         \\n            for (int k = 0; k < len; k++) add(r, c++, R, C);          \\n            for (int k = 0; k < len; k++) add(r++, c, R, C);\\n            len++;\\n            for (int k = 0; k < len; k++) add(r, c--, R, C);\\n            for (int k = 0; k < len; k++) add(r--, c, R, C);\\n            len++;   \\n        }\\n        return ret;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int idx;\\n    int[][] ret;\\n    \\n    private void add (int r, int c, int R, int C) {\\n        if (r >= R || r < 0 || c >= C || c < 0) return;\\n        ret[idx][0] = r;\\n        ret[idx++][1] = c;\\n    }\\n    \\n    public int[][] spiralMatrixIII(int R, int C, int r0, int c0) {\\n        int r = r0, c = c0, len = 1;\\n        ret = new int[R * C][2];\\n        while (idx < (R * C )) {         \\n            for (int k = 0; k < len; k++) add(r, c++, R, C);          \\n            for (int k = 0; k < len; k++) add(r++, c, R, C);\\n            len++;\\n            for (int k = 0; k < len; k++) add(r, c--, R, C);\\n            for (int k = 0; k < len; k++) add(r--, c, R, C);\\n            len++;   \\n        }\\n        return ret;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3010933,
                "title": "c-commented-solution",
                "content": "# Intuition\\nThe below code works like this:\\n\\n```\\nstartPos {Row, Col}\\nloop 1:\\nCol -> + 1, Row -> + 0\\nCol -> + 0, Row -> + 1\\n++ Counter\\nloop 2:\\nCol -> - 1, Row -> + 0\\nCol -> - 1, Row -> + 0\\nCol -> + 0, Row -> - 1\\nCol -> + 0, Row -> - 1\\n++ Counter\\n...\\n```\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        vector<vector<int>> result;\\n        vector<int> startPos {rStart, cStart};\\n        result.push_back(startPos);\\n\\n        // For each walk, firstly we move the column by \"\"counter\"\" steps,\\n        //                secondly we move the row by \"\"counter\"\" steps,\\n        // Note that the step direction will depend on the \"counter % 2 == 0\"\\n        int counter {1};\\n        while(result.size() != rows * cols) {\\n            for (int i = 1; i <= counter; ++ i) {\\n                startPos[1] = startPos[1] + (counter % 2 == 0 ? -1 : 1);\\n                if (startPos[1] >= 0 && startPos[0] >= 0 && startPos[1] < cols && startPos[0] < rows)\\n                    result.push_back(startPos);\\n            }\\n\\n            for (int i = 1; i <= counter; ++ i) {\\n                startPos[0] = startPos[0] + (counter % 2 == 0 ? -1 : 1);\\n                if (startPos[1] >= 0 && startPos[0] >= 0 && startPos[1] < cols && startPos[0] < rows)\\n                    result.push_back(startPos);\\n            }\\n            \\n            ++ counter;\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nstartPos {Row, Col}\\nloop 1:\\nCol -> + 1, Row -> + 0\\nCol -> + 0, Row -> + 1\\n++ Counter\\nloop 2:\\nCol -> - 1, Row -> + 0\\nCol -> - 1, Row -> + 0\\nCol -> + 0, Row -> - 1\\nCol -> + 0, Row -> - 1\\n++ Counter\\n...\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        vector<vector<int>> result;\\n        vector<int> startPos {rStart, cStart};\\n        result.push_back(startPos);\\n\\n        // For each walk, firstly we move the column by \"\"counter\"\" steps,\\n        //                secondly we move the row by \"\"counter\"\" steps,\\n        // Note that the step direction will depend on the \"counter % 2 == 0\"\\n        int counter {1};\\n        while(result.size() != rows * cols) {\\n            for (int i = 1; i <= counter; ++ i) {\\n                startPos[1] = startPos[1] + (counter % 2 == 0 ? -1 : 1);\\n                if (startPos[1] >= 0 && startPos[0] >= 0 && startPos[1] < cols && startPos[0] < rows)\\n                    result.push_back(startPos);\\n            }\\n\\n            for (int i = 1; i <= counter; ++ i) {\\n                startPos[0] = startPos[0] + (counter % 2 == 0 ? -1 : 1);\\n                if (startPos[1] >= 0 && startPos[0] >= 0 && startPos[1] < cols && startPos[0] < rows)\\n                    result.push_back(startPos);\\n            }\\n            \\n            ++ counter;\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2777454,
                "title": "c-solution-with-explanation-and-complexity",
                "content": "After solving a few examples by myself, I found some observations:\\n* The number of grids that we are traversing in one direction starts from 1 and after traversing two direction it increases. I have called it as **checker** in code\\n* For stoping the traversal, we have to count all rows * cols grids. So i created **counter**\\n* Before pushing the coordinates in the ans vector, we need to check if it belongs inside the matrix or not. For that \\n\\t\\t0 <= i <= rows\\n\\t\\t0 <= j <= cols\\nwhere i is the index for row and j is the index for column.\\n\\n\\n\\n![image](https://assets.leetcode.com/users/images/ea296c0e-0175-4170-816b-133d40d94c51_1667559130.6659496.jpeg)\\n\\n**Space Complexity**: O(rows * cols)\\n**Time Complexity:** O(6 + (n - 1)* 8), where n = max(rows, cols)\\n```\\nclass Solution {\\npublic:\\n\\n\\t//function to check if i and j belong to matrix or not\\n    bool valid_to_push(int i, int j, int rows, int cols){\\n        if(i>=0 && i<rows && j>=0 && j<cols)\\n            return true;\\n        return false;\\n    }\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        vector<vector<int>> ans;\\n        int counter, direction, checker;\\n        ans.push_back({rStart, cStart});\\n        counter = 1; \\n        direction = 0;\\n        checker = 1;\\n        \\n        int i = rStart, j = cStart;\\n\\t\\t\\n        while(counter != rows * cols){\\n\\t\\t\\t// for direction 0\\n            if(direction == 0){\\n\\t\\t\\t\\t// only traverse till checker\\n                for(int k = 1; k<= checker; k++){\\n                    j++;\\n                    if(valid_to_push(i,j,rows,cols)){\\n                        ans.push_back({i, j});\\n                        counter++;\\n                    }\\n                }\\n                direction = 1; //change direction\\n            }\\n\\t\\t\\t// for direction 1\\n            if(direction == 1){\\n                for(int k = 1; k<= checker; k++){\\n                    i++;\\n                    if(valid_to_push(i,j,rows,cols)){\\n                        ans.push_back({i, j});\\n                        counter++;\\n                    }\\n                }\\n                direction = 2; //change direction\\n            }\\n            checker++; // increase after traversing two direction\\n\\t\\t\\t\\n\\t\\t\\t// for direction 2\\n            if(direction == 2){\\n                for(int k = 1; k<= checker; k++){\\n                    j--;\\n                    if(valid_to_push(i,j,rows,cols)){\\n                        ans.push_back({i, j});\\n                        counter++;\\n                    }\\n                }\\n                direction = 3; //change direction\\n            }\\n\\t\\t\\t\\n\\t\\t\\t// for direction 3\\n            if(direction == 3){\\n                for(int k = 1; k<= checker; k++){\\n                    i--;\\n                    if(valid_to_push(i,j,rows,cols)){\\n                        ans.push_back({i, j});\\n                        counter++;\\n                    }\\n                }\\n                direction = 0; //change direction\\n            }\\n            checker++; // increase after traversing two direction\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n\\t//function to check if i and j belong to matrix or not\\n    bool valid_to_push(int i, int j, int rows, int cols){\\n        if(i>=0 && i<rows && j>=0 && j<cols)\\n            return true;\\n        return false;\\n    }\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        vector<vector<int>> ans;\\n        int counter, direction, checker;\\n        ans.push_back({rStart, cStart});\\n        counter = 1; \\n        direction = 0;\\n        checker = 1;\\n        \\n        int i = rStart, j = cStart;\\n\\t\\t\\n        while(counter != rows * cols){\\n\\t\\t\\t// for direction 0\\n            if(direction == 0){\\n\\t\\t\\t\\t// only traverse till checker\\n                for(int k = 1; k<= checker; k++){\\n                    j++;\\n                    if(valid_to_push(i,j,rows,cols)){\\n                        ans.push_back({i, j});\\n                        counter++;\\n                    }\\n                }\\n                direction = 1; //change direction\\n            }\\n\\t\\t\\t// for direction 1\\n            if(direction == 1){\\n                for(int k = 1; k<= checker; k++){\\n                    i++;\\n                    if(valid_to_push(i,j,rows,cols)){\\n                        ans.push_back({i, j});\\n                        counter++;\\n                    }\\n                }\\n                direction = 2; //change direction\\n            }\\n            checker++; // increase after traversing two direction\\n\\t\\t\\t\\n\\t\\t\\t// for direction 2\\n            if(direction == 2){\\n                for(int k = 1; k<= checker; k++){\\n                    j--;\\n                    if(valid_to_push(i,j,rows,cols)){\\n                        ans.push_back({i, j});\\n                        counter++;\\n                    }\\n                }\\n                direction = 3; //change direction\\n            }\\n\\t\\t\\t\\n\\t\\t\\t// for direction 3\\n            if(direction == 3){\\n                for(int k = 1; k<= checker; k++){\\n                    i--;\\n                    if(valid_to_push(i,j,rows,cols)){\\n                        ans.push_back({i, j});\\n                        counter++;\\n                    }\\n                }\\n                direction = 0; //change direction\\n            }\\n            checker++; // increase after traversing two direction\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2692625,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        int[][] res = new int[rows * cols][];\\n        int k = 0;\\n        res[k++] = new int[]{rStart, cStart};\\n        int[] direction = {0, 1, 0, -1, 0};\\n        int d = 0;\\n        int len = 0;\\n        while(k < rows * cols){\\n            if(d == 0 || d == 2){\\n                len++;\\n            }\\n            for(int i = 0; i < len; i++){\\n                rStart += direction[d];\\n                cStart += direction[d+1];\\n                \\n                if(rStart > -1 && rStart < rows && cStart > -1 && cStart < cols){\\n                    res[k++] = new int[]{rStart, cStart};\\n                }\\n            }\\n            d = ++d % 4;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        int[][] res = new int[rows * cols][];\\n        int k = 0;\\n        res[k++] = new int[]{rStart, cStart};\\n        int[] direction = {0, 1, 0, -1, 0};\\n        int d = 0;\\n        int len = 0;\\n        while(k < rows * cols){\\n            if(d == 0 || d == 2){\\n                len++;\\n            }\\n            for(int i = 0; i < len; i++){\\n                rStart += direction[d];\\n                cStart += direction[d+1];\\n                \\n                if(rStart > -1 && rStart < rows && cStart > -1 && cStart < cols){\\n                    res[k++] = new int[]{rStart, cStart};\\n                }\\n            }\\n            d = ++d % 4;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2131312,
                "title": "c",
                "content": "![image](https://assets.leetcode.com/users/images/689bb355-4bde-4d86-bac1-13b88f5cb601_1654783840.3640954.png)\\n```\\nint** spiralMatrixIII(int rows, int cols, int rStart, int cStart, int* returnSize, int** returnColumnSizes) {\\n    (*returnSize) = rows * cols;\\n    *returnColumnSizes = (int*) malloc((*returnSize) * sizeof(int));\\n    int** res = (int**) malloc((*returnSize) * sizeof(int*));\\n    for (int i = 0; i < (*returnSize); i++) {\\n        res[i] = (int*) calloc(2, sizeof(int));\\n        (*returnColumnSizes)[i] = 2;\\n    }\\n    res[0][0] = rStart; res[0][1] = cStart;\\n    int up = 1, right = 1, cntRL = 0, cntUD = 0, idx = 1;\\n    while (idx < (*returnSize)) {\\n        for (int shift = 1; shift <= right; shift++) {\\n            cStart = (cntRL % 2 == 0) ? cStart + 1 : cStart - 1;\\n            if (rStart < rows && cStart < cols && rStart > -1 && cStart > -1) {\\n                res[idx][0] = rStart;\\n                res[idx][1] = cStart;\\n                idx++;\\n            }\\n        }\\n        cntRL++;\\n        right++;\\n        for (int shift = 1; shift <= up; shift++) {\\n            rStart = (cntUD % 2 == 0) ? rStart + 1 : rStart - 1;\\n            if (rStart < rows && cStart < cols && rStart > -1 && cStart > -1) {\\n                res[idx][0] = rStart;\\n                res[idx][1] = cStart;\\n                idx++;\\n            }\\n        }\\n        cntUD++;\\n        up++;\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint** spiralMatrixIII(int rows, int cols, int rStart, int cStart, int* returnSize, int** returnColumnSizes) {\\n    (*returnSize) = rows * cols;\\n    *returnColumnSizes = (int*) malloc((*returnSize) * sizeof(int));\\n    int** res = (int**) malloc((*returnSize) * sizeof(int*));\\n    for (int i = 0; i < (*returnSize); i++) {\\n        res[i] = (int*) calloc(2, sizeof(int));\\n        (*returnColumnSizes)[i] = 2;\\n    }\\n    res[0][0] = rStart; res[0][1] = cStart;\\n    int up = 1, right = 1, cntRL = 0, cntUD = 0, idx = 1;\\n    while (idx < (*returnSize)) {\\n        for (int shift = 1; shift <= right; shift++) {\\n            cStart = (cntRL % 2 == 0) ? cStart + 1 : cStart - 1;\\n            if (rStart < rows && cStart < cols && rStart > -1 && cStart > -1) {\\n                res[idx][0] = rStart;\\n                res[idx][1] = cStart;\\n                idx++;\\n            }\\n        }\\n        cntRL++;\\n        right++;\\n        for (int shift = 1; shift <= up; shift++) {\\n            rStart = (cntUD % 2 == 0) ? rStart + 1 : rStart - 1;\\n            if (rStart < rows && cStart < cols && rStart > -1 && cStart > -1) {\\n                res[idx][0] = rStart;\\n                res[idx][1] = cStart;\\n                idx++;\\n            }\\n        }\\n        cntUD++;\\n        up++;\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1946605,
                "title": "easy-to-understand-java-solution",
                "content": "```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        // {0,1,0,-1,0}   directions  0-> col++, 1->row++, 2-> col-- 3->row--\\n        \\n        \\n        int directions[]={0,1,0,-1,0} ;\\n        \\n        int steps=0;\\n        int move=0;\\n        int count=0;\\n        int ans[][]=new int[rows*cols][2];\\n        ans[count][0]=rStart;\\n        ans[count][1]=cStart;\\n        count++;\\n        \\n        int row=rStart,col=cStart;\\n        \\n        while(count<rows*cols)\\n        {\\n            if(move==0 || move== 2)\\n                steps++;\\n            \\n            for(int i=0;i<steps;i++)\\n            {\\n                row+=directions[move];\\n                col+=directions[move+1];\\n               if(row<rows && row>=0 && col<cols && col>=0)\\n               {\\n                ans[count][0]=row;\\n                ans[count][1]=col;\\n                count++;\\n               }\\n                \\n            }\\n            if(move!=0)\\n            move=(move+1)%4;\\n            else \\n                move++;\\n        }\\n        \\n        \\n        return ans;\\n        \\n        \\n        \\n        \\n        \\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        // {0,1,0,-1,0}   directions  0-> col++, 1->row++, 2-> col-- 3->row--\\n        \\n        \\n        int directions[]={0,1,0,-1,0} ;\\n        \\n        int steps=0;\\n        int move=0;\\n        int count=0;\\n        int ans[][]=new int[rows*cols][2];\\n        ans[count][0]=rStart;\\n        ans[count][1]=cStart;\\n        count++;\\n        \\n        int row=rStart,col=cStart;\\n        \\n        while(count<rows*cols)\\n        {\\n            if(move==0 || move== 2)\\n                steps++;\\n            \\n            for(int i=0;i<steps;i++)\\n            {\\n                row+=directions[move];\\n                col+=directions[move+1];\\n               if(row<rows && row>=0 && col<cols && col>=0)\\n               {\\n                ans[count][0]=row;\\n                ans[count][1]=col;\\n                count++;\\n               }\\n                \\n            }\\n            if(move!=0)\\n            move=(move+1)%4;\\n            else \\n                move++;\\n        }\\n        \\n        \\n        return ans;\\n        \\n        \\n        \\n        \\n        \\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1943274,
                "title": "c-solution-intutive",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        int result=rows*cols;\\n        int limit=1;\\n        int dir[4][2]={{0,1},{1,0},{0,-1},{-1,0}};\\n        int d=0;\\n        vector<vector<int>>ans={{rStart,cStart}};\\n        int no=1;\\n        while(ans.size()!=result)\\n        {\\n            for(int i=0;i<limit;i++)\\n            {\\n                rStart+=dir[d][0];\\n                cStart+=dir[d][1];\\n                if(rStart>=0 && rStart<rows && cStart>=0 && cStart<cols)\\n                {\\n                    ans.push_back({rStart,cStart});\\n                }\\n            }\\n                \\n                \\n                d=(d+1)%4;\\n            if(no==2)\\n            {\\n                limit++;no=1;\\n            }\\n            else no++;\\n                \\n                \\n                \\n        }\\n        return ans;\\n        \\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        int result=rows*cols;\\n        int limit=1;\\n        int dir[4][2]={{0,1},{1,0},{0,-1},{-1,0}};\\n        int d=0;\\n        vector<vector<int>>ans={{rStart,cStart}};\\n        int no=1;\\n        while(ans.size()!=result)\\n        {\\n            for(int i=0;i<limit;i++)\\n            {\\n                rStart+=dir[d][0];\\n                cStart+=dir[d][1];\\n                if(rStart>=0 && rStart<rows && cStart>=0 && cStart<cols)\\n                {\\n                    ans.push_back({rStart,cStart});\\n                }\\n            }\\n                \\n                \\n                d=(d+1)%4;\\n            if(no==2)\\n            {\\n                limit++;no=1;\\n            }\\n            else no++;\\n                \\n                \\n                \\n        }\\n        return ans;\\n        \\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1739543,
                "title": "java-easy-to-understand-solution",
                "content": "```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        int[][] matrix=new int[rows*cols][2];\\n        int i=0;\\n        matrix[i++]=new int[]{rStart,cStart};  //adding the initial position\\n        int d=0;          // this will be used for direction there can be 4 direction only 0 1 2 3 \\n\\t\\tint len=0;          //this is to take the number of steps;\\n        int[] directions=new int[]{0,1,0,-1,0};   //\\n        while(i<rows*cols){\\n            if(d==0||d==2){   // 0 for east 1 for south 2 for west and 3 for south \\n                len++;              //because only when we are facing east  or facing west then we are moving 1 step more\\n            }\\n            for(int k=0;k<len;k++){    //this for loop is to give the position after each step\\n                rStart+=directions[d];     //when facing east the x coordinate will not be changing only y coordinate will be changing that\\'s why cStart is incremented\\n                cStart+=directions[d+1];\\n                if(rStart<rows&&rStart>=0&&cStart<cols&&cStart>=0){\\n                    matrix[i++]=new int[]{rStart,cStart};         //this condition is to ensure we are only adding the coordinates of position which are in the matrix \\n                }\\n            }\\n            d=++d%4;       //this is to ensure d values never exceed 3 because we only want 4 direction and d value will be changing many times \\n            \\n        }\\n        return matrix;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        int[][] matrix=new int[rows*cols][2];\\n        int i=0;\\n        matrix[i++]=new int[]{rStart,cStart};  //adding the initial position\\n        int d=0;          // this will be used for direction there can be 4 direction only 0 1 2 3 \\n\\t\\tint len=0;          //this is to take the number of steps;\\n        int[] directions=new int[]{0,1,0,-1,0};   //\\n        while(i<rows*cols){\\n            if(d==0||d==2){   // 0 for east 1 for south 2 for west and 3 for south \\n                len++;              //because only when we are facing east  or facing west then we are moving 1 step more\\n            }\\n            for(int k=0;k<len;k++){    //this for loop is to give the position after each step\\n                rStart+=directions[d];     //when facing east the x coordinate will not be changing only y coordinate will be changing that\\'s why cStart is incremented\\n                cStart+=directions[d+1];\\n                if(rStart<rows&&rStart>=0&&cStart<cols&&cStart>=0){\\n                    matrix[i++]=new int[]{rStart,cStart};         //this condition is to ensure we are only adding the coordinates of position which are in the matrix \\n                }\\n            }\\n            d=++d%4;       //this is to ensure d values never exceed 3 because we only want 4 direction and d value will be changing many times \\n            \\n        }\\n        return matrix;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1735206,
                "title": "java-solution-using-recursion-faster-than-99-43",
                "content": "class Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        int[][] ans = new int[rows*cols][2];\\n        int topr = rStart-1;\\n        int bottomr =rStart+1;\\n        int leftc = cStart-1;\\n        int rightc =cStart+1;\\n        ans[0][0] = rStart;\\n        ans[0][1]= cStart;\\n        \\n        \\n        return path(rows, cols, rStart, cStart, topr, bottomr, leftc, rightc, ans, 1);\\n    }\\n    int[][] path(int rows, int cols, int rStart, int cStart, int topr, int bottomr, int leftc, int rightc, int[][] mat, int x){\\n        \\n        if(topr<0 && bottomr>rows-1 && leftc<0 && rightc>cols-1){\\n            return mat;\\n        }\\n        \\n        for(int i = topr+1 ; i <= bottomr; i++){\\n            if(i<rows && i>=0 && rightc>=0 && rightc<cols){\\n                mat[x][0]=i;\\n                mat[x][1]=rightc;\\n                x +=1;\\n            }\\n        }\\n        for(int i =rightc-1; i>= leftc ; i--){\\n            if(i>=0 && i<cols && bottomr>=0 && bottomr < rows){\\n                mat[x][0]=bottomr;\\n                mat[x][1]=i;\\n                x +=1;\\n            }\\n        }\\n        for(int i =bottomr-1; i>=topr; i--){\\n            if(i<rows && i>=0 && leftc >= 0 && leftc<cols){\\n                mat[x][0]=i;\\n                mat[x][1]=leftc;\\n                x +=1;\\n            }\\n        }\\n        for(int i = leftc+1 ; i<= rightc; i++){\\n            if(i<cols && i>=0 && topr>=0 && topr<rows){\\n                mat[x][0]=topr;\\n                mat[x][1]=i;\\n                x +=1;\\n            }\\n        }\\n        return path(rows, cols, rStart+1, cStart, topr-1, bottomr+1, leftc-1, rightc+1, mat, x);\\n            \\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "class Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        int[][] ans = new int[rows*cols][2];\\n        int topr = rStart-1;\\n        int bottomr =rStart+1;\\n        int leftc = cStart-1;\\n        int rightc =cStart+1;\\n        ans[0][0] = rStart;\\n        ans[0][1]= cStart;\\n        \\n        \\n        return path(rows, cols, rStart, cStart, topr, bottomr, leftc, rightc, ans, 1);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1688165,
                "title": "javascript-commented-solution",
                "content": "\\n```\\n/**\\n * @param {number} rows\\n * @param {number} cols\\n * @param {number} rStart\\n * @param {number} cStart\\n * @return {number[][]}\\n */\\n var spiralMatrixIII = function(rows, cols, rStart, cStart) {\\n    let r = rStart, c = cStart, results = [];\\n    results.push([r,c]);\\n    // Draw a picture of an infinite grid, then highlight a smaller grid inside with ${rows} of rows and ${cols} of columns.\\n    // Draw a little man at the rStart row and the cStart column.\\n    // We will tell the man to walk a number of steps in a certain direction.\\n    // if the man is on a highlighted square, he will collect it.\\n    const walk = (steps,rStep,cStep) => {\\n        for (let i =0;i<steps;i++) {\\n            r +=rStep, c+=cStep;\\n            if ( r>=0 && c >=0 && r < rows && c<cols) results.push([r,c]);\\n        }\\n    }\\n    // we need to direct the little man how to walk\\n    // first he will walk a distance of one step.\\n    let distance = 1;  \\n    // think about how he will walk the spiral.\\n     \\n    // we will tell the man to walk right 1 unit.\\n    // after that he will walk down 1 unit.\\n    let rDirection = 0, cDirection = 1;\\n     \\n    // then he walks left 2 units, then he walks up 2 units \\n    // then he walks right 3 units, then walks down 3 units\\n     \\n    // do this pattern until he collects all the squares. \\n    while (results.length < rows*cols) {\\n        walk(distance,rDirection,cDirection);\\n        [rDirection,cDirection] = [cDirection,rDirection];\\n        walk(distance,rDirection,cDirection);\\n        [rDirection,cDirection] = [-1*cDirection,-1*rDirection];\\n        distance++;\\n    }\\n    return results;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} rows\\n * @param {number} cols\\n * @param {number} rStart\\n * @param {number} cStart\\n * @return {number[][]}\\n */\\n var spiralMatrixIII = function(rows, cols, rStart, cStart) {\\n    let r = rStart, c = cStart, results = [];\\n    results.push([r,c]);\\n    // Draw a picture of an infinite grid, then highlight a smaller grid inside with ${rows} of rows and ${cols} of columns.\\n    // Draw a little man at the rStart row and the cStart column.\\n    // We will tell the man to walk a number of steps in a certain direction.\\n    // if the man is on a highlighted square, he will collect it.\\n    const walk = (steps,rStep,cStep) => {\\n        for (let i =0;i<steps;i++) {\\n            r +=rStep, c+=cStep;\\n            if ( r>=0 && c >=0 && r < rows && c<cols) results.push([r,c]);\\n        }\\n    }\\n    // we need to direct the little man how to walk\\n    // first he will walk a distance of one step.\\n    let distance = 1;  \\n    // think about how he will walk the spiral.\\n     \\n    // we will tell the man to walk right 1 unit.\\n    // after that he will walk down 1 unit.\\n    let rDirection = 0, cDirection = 1;\\n     \\n    // then he walks left 2 units, then he walks up 2 units \\n    // then he walks right 3 units, then walks down 3 units\\n     \\n    // do this pattern until he collects all the squares. \\n    while (results.length < rows*cols) {\\n        walk(distance,rDirection,cDirection);\\n        [rDirection,cDirection] = [cDirection,rDirection];\\n        walk(distance,rDirection,cDirection);\\n        [rDirection,cDirection] = [-1*cDirection,-1*rDirection];\\n        distance++;\\n    }\\n    return results;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1283466,
                "title": "efficient-c-solution",
                "content": "class Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int i, int j) {\\n\\t\\n\\t   // vector where we will store our elements indices { i , j }\\n       vector<vector<int>> matrix(rows*cols,vector<int>(2)); \\n\\t\\tint x=2;            // value to be used and incremented step by step\\n        int k=rows*cols,n1=0;      // max value is rows*cols\\n        int steps=1,t;      //  number of steps to go in any direction, we will increase this time to time\\n        matrix[n1++]={i,j};       // initialized first indice\\n        while(x<=k){\\n            \\n\\t\\t\\t// now first we will traverse steps number of steps in right direction\\n\\t\\t\\t// at every step, we will check if its a valid matrix indice or not\\n\\t\\t\\tt=steps;\\n            while(t--){\\n                j++;\\n                if( j<cols && i<rows && j>=0 && i>=0) {\\n\\t\\t\\t\\t// for any valid indice, we will store that indice in matrix and increment x\\n                    matrix[n1++]={ i , j };\\n                    x++;\\n                }\\n            }\\n\\t\\t\\t\\n\\t\\t\\t// now we will traverse same number of steps vertically down \\n            t=steps;\\n            while(t--){\\n                i++;\\n                if( j<cols && i<rows && j>=0 && i>=0) {\\n                    matrix[n1++]={ i , j };\\n                    x++;\\n                }\\n            }\\n\\t\\t\\t// now we will traverse steps+1 number of steps in left direction\\n            steps++;\\n            t=steps;\\n            while(t--){\\n                j--;\\n                if( j<cols && i<rows && j>=0 && i>=0) {\\n                    matrix[n1++]={ i , j };\\n                    x++;\\n                }\\n            }\\n\\t\\t\\t\\n\\t\\t\\t// now we will traverse same number of steps vertically upward \\n            t=steps;\\n            while(t--){\\n                i--;\\n                if( j<cols && i<rows && j>=0 && i>=0) {\\n                    matrix[n1++]={ i , j };\\n                    x++;\\n                }\\n            }\\n\\t\\t\\t// now we again increase steps by 1 to maintain clockwise motion\\n            l++;\\n        }\\n        return matrix;  // our matrix is ready \\n    }\\n// NOTE:- To understand the code, have a look at the given sample examples and understand the motion.\\n// If understood the concept then please press the up arrow on the left of this solution.\\n};\\n\\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int i, int j) {\\n\\t\\n\\t   // vector where we will store our elements indices { i , j }",
                "codeTag": "Java"
            },
            {
                "id": 352599,
                "title": "c-clean-code-beat-96-with-explanation",
                "content": "**take a pen and paper, try to draw the path once by yourself, you will notice that**\\n```\\n\\t\\t\\t       i    wanted steps\\ngo right  by 1     0        1 = i/2+1\\ngo down   by 1     1        1 = i/2+1\\ngo left   by 2     2        2 = i/2+1\\ngo up     by 2     3        2 = i/2+1\\ngo right  by 3     4        3 = i/2+1\\ngo down   by 3     5        3 = i/2+1\\ngo left   by 4     6        4 = i/2+1\\ngo up     by 4     7        4 = i/2+1\\n...etc\\n```\\n**once we meet out of bound, don\\'t add it to the answer and just going forward.**\\n\\n```\\nclass Solution {\\npublic:\\n    int way[4][2] = {{0,1},{1,0},{0,-1},{-1,0}};\\n    vector<vector<int>> spiralMatrixIII(int R, int C, int r0, int c0) {\\n        vector<vector<int>> res;\\n        res.push_back({r0,c0}); //put the source first\\n        int direction = 0, end_cnt = 1;\\n        for(int i = 0 ; end_cnt < R*C ; i++){\\n            int cnt = i/2+1;\\n            while(cnt--){\\n                r0 += way[direction][0];\\n                c0 += way[direction][1];\\n                if(r0 >= 0 && r0 < R && c0 < C && c0 >= 0) // only when current node is a valid position, add vector to the answer. There is no duplicate node, don\\'t worry.\\n                    res.push_back({r0,c0}),end_cnt++;\\n            }\\n            direction = (direction+1)%4; //each i loop, change direction\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\t\\t\\t       i    wanted steps\\ngo right  by 1     0        1 = i/2+1\\ngo down   by 1     1        1 = i/2+1\\ngo left   by 2     2        2 = i/2+1\\ngo up     by 2     3        2 = i/2+1\\ngo right  by 3     4        3 = i/2+1\\ngo down   by 3     5        3 = i/2+1\\ngo left   by 4     6        4 = i/2+1\\ngo up     by 4     7        4 = i/2+1\\n...etc\\n```\n```\\nclass Solution {\\npublic:\\n    int way[4][2] = {{0,1},{1,0},{0,-1},{-1,0}};\\n    vector<vector<int>> spiralMatrixIII(int R, int C, int r0, int c0) {\\n        vector<vector<int>> res;\\n        res.push_back({r0,c0}); //put the source first\\n        int direction = 0, end_cnt = 1;\\n        for(int i = 0 ; end_cnt < R*C ; i++){\\n            int cnt = i/2+1;\\n            while(cnt--){\\n                r0 += way[direction][0];\\n                c0 += way[direction][1];\\n                if(r0 >= 0 && r0 < R && c0 < C && c0 >= 0) // only when current node is a valid position, add vector to the answer. There is no duplicate node, don\\'t worry.\\n                    res.push_back({r0,c0}),end_cnt++;\\n            }\\n            direction = (direction+1)%4; //each i loop, change direction\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 160624,
                "title": "python-version-with-counting-turn-times",
                "content": "```\\ndef  spiralMatrixIII(R, C, r0, c0):\\n        res = [[r0,c0]]\\n        count_turn = 0\\n        di = 0\\n        x, y = r0, c0\\n        dx = [0, 1, 0, -1]\\n        dy = [1, 0, -1, 0]\\n        while len(res) < R*C:\\n            steps = count_turn//2 + 1\\n            for step in range(steps):\\n                x += dx[di]\\n                y += dy[di]\\n                if 0<= x<= R-1 and 0 <= y <=C-1:\\n                    res.append([x, y])\\n            count_turn += 1\\n            di = (di+1)%4\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\ndef  spiralMatrixIII(R, C, r0, c0):\\n        res = [[r0,c0]]\\n        count_turn = 0\\n        di = 0\\n        x, y = r0, c0\\n        dx = [0, 1, 0, -1]\\n        dy = [1, 0, -1, 0]\\n        while len(res) < R*C:\\n            steps = count_turn//2 + 1\\n            for step in range(steps):\\n                x += dx[di]\\n                y += dy[di]\\n                if 0<= x<= R-1 and 0 <= y <=C-1:\\n                    res.append([x, y])\\n            count_turn += 1\\n            di = (di+1)%4\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 158995,
                "title": "python-infinite-generator-yield",
                "content": "* use a generator to generate the infinite sequence of spiral coordinates\\n* every time a coordinate is within bounds, add it to the solution\\n* based on the spiral pattern:\\n  * no coordinate is visited twice\\n  * every coordinate is visited\\n  * the total number of spiral coordinates generated will not exceed approximately 4 times the size of the grid (since the first RxCx4 spiral coordinates should cover all four cuadrants around the starting point)\\n* stop when RxC coordinates have been collected\\n```\\nclass Solution(object):\\n    def spiralMatrixIII(self, R, C, r0, c0):\\n        \"\"\"\\n        :type R: int\\n        :type C: int\\n        :type r0: int\\n        :type c0: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        \\n        def nxt(r,c):\\n            d=1\\n            yield (r,c)\\n            while True:\\n                for i in range(d):\\n                    c+=1\\n                    yield (r,c)\\n                for i in range(d):\\n                    r+=1\\n                    yield (r,c)\\n                for i in range(d+1):\\n                    c-=1\\n                    yield (r,c)\\n                for i in range(d+1):\\n                    r-=1\\n                    yield (r,c)\\n                d+=2\\n        \\n        ret=[]\\n        r,c=r0,c0\\n        for (r,c) in nxt(r0,c0):\\n            if 0<=r<R and 0<=c<C:\\n                ret.append([r,c])\\n            if len(ret)==R*C:\\n                break\\n            \\n        return ret\\n\\t\\t\\t\\t\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def spiralMatrixIII(self, R, C, r0, c0):\\n        \"\"\"\\n        :type R: int\\n        :type C: int\\n        :type r0: int\\n        :type c0: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        \\n        def nxt(r,c):\\n            d=1\\n            yield (r,c)\\n            while True:\\n                for i in range(d):\\n                    c+=1\\n                    yield (r,c)\\n                for i in range(d):\\n                    r+=1\\n                    yield (r,c)\\n                for i in range(d+1):\\n                    c-=1\\n                    yield (r,c)\\n                for i in range(d+1):\\n                    r-=1\\n                    yield (r,c)\\n                d+=2\\n        \\n        ret=[]\\n        r,c=r0,c0\\n        for (r,c) in nxt(r0,c0):\\n            if 0<=r<R and 0<=c<C:\\n                ret.append([r,c])\\n            if len(ret)==R*C:\\n                break\\n            \\n        return ret\\n\\t\\t\\t\\t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3750377,
                "title": "solution-made-easy",
                "content": "# Approach\\nSame as Spiral Matrix 1\\nJust keep in mind that we do not have to stop once we are out of the boundary. The stopping condition is that when we have visited all the cells i.e. $$ans.size() == m*n$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int m, int n, int x, int y) {\\n        vector<vector<int>> ans;\\n\\n        int len = 1;\\n        ans.push_back({x,y});\\n\\n        while(ans.size() < m*n) {\\n            for(int j=1 ; j<=len ; j++) {\\n                if(isValid(x,y+j,m,n)) {\\n                    ans.push_back({x,y+j});\\n                }\\n            }\\n            y += len;\\n            \\n            for(int i=1 ; i<=len ; i++) {\\n                if(isValid(x+i,y,m,n)) {\\n                    ans.push_back({x+i,y});\\n                }\\n            }\\n            x += len;\\n\\n            len++;\\n            for(int j=1 ; j<=len ; j++) {\\n                if(isValid(x,y-j,m,n)) {\\n                    ans.push_back({x,y-j});\\n                }\\n            }\\n            y -= len;\\n\\n            for(int i=1 ; i<=len ; i++) {\\n                if(isValid(x-i,y,m,n)) {\\n                    ans.push_back({x-i,y});\\n                }\\n            }\\n            x -= len;\\n            len++;\\n        }\\n        return ans;\\n    }\\n\\n    bool isValid(int i, int j, int m, int n) {\\n        return (i>=0 && j>=0 && i<m && j<n);\\n    }\\n};\\n```\\n\\nCheck all the Spiral Matrix Problems (1 to 4) here -\\nSpiral Matrix 1 - https://leetcode.com/problems/spiral-matrix/solutions/3747955/easy-traversal/\\nSpiral Matrix 2 - https://leetcode.com/problems/spiral-matrix-ii/solutions/3747970/same-as-spiral-matrix-i/\\nSpiral Matrix 3 - https://leetcode.com/problems/spiral-matrix-iii/solutions/3750377/solution-made-easy/\\nSpiral Matrix 4 - https://leetcode.com/problems/spiral-matrix-iv/solutions/2230030/simple-solution/\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int m, int n, int x, int y) {\\n        vector<vector<int>> ans;\\n\\n        int len = 1;\\n        ans.push_back({x,y});\\n\\n        while(ans.size() < m*n) {\\n            for(int j=1 ; j<=len ; j++) {\\n                if(isValid(x,y+j,m,n)) {\\n                    ans.push_back({x,y+j});\\n                }\\n            }\\n            y += len;\\n            \\n            for(int i=1 ; i<=len ; i++) {\\n                if(isValid(x+i,y,m,n)) {\\n                    ans.push_back({x+i,y});\\n                }\\n            }\\n            x += len;\\n\\n            len++;\\n            for(int j=1 ; j<=len ; j++) {\\n                if(isValid(x,y-j,m,n)) {\\n                    ans.push_back({x,y-j});\\n                }\\n            }\\n            y -= len;\\n\\n            for(int i=1 ; i<=len ; i++) {\\n                if(isValid(x-i,y,m,n)) {\\n                    ans.push_back({x-i,y});\\n                }\\n            }\\n            x -= len;\\n            len++;\\n        }\\n        return ans;\\n    }\\n\\n    bool isValid(int i, int j, int m, int n) {\\n        return (i>=0 && j>=0 && i<m && j<n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3507866,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        \\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        cout.tie(NULL);\\n\\n        vector<vector<int>> result;\\n        int total = 0;\\n\\n        int rowStart = rStart;\\n        int rowEnd = rStart;\\n\\n        int colStart = cStart;\\n        int colEnd = cStart;\\n\\n        while(true){\\n            for(int i=colStart; i<=colEnd; i++){\\n                if(i >= 0 && i < cols && rowStart >= 0){\\n                    result.push_back({rowStart, i});\\n                    total++;\\n                }\\n            }\\n            colEnd++;\\n            if(total == (rows * cols))\\n                break;\\n            for(int i=rowStart; i<=rowEnd; i++){\\n                if(i >= 0 && i < rows && colEnd < cols){\\n                    result.push_back({i, colEnd});\\n                    total++;\\n                }\\n            }\\n            rowEnd++;\\n            if(total == (rows * cols))\\n                break;\\n            for(int i=colEnd; i>=colStart; i--){\\n                if(i >= 0 && i < cols && rowEnd < rows){\\n                    result.push_back({rowEnd, i});\\n                    total++;\\n                }\\n            }\\n            colStart--;\\n            if(total == (rows * cols))\\n                break;\\n            for(int i=rowEnd; i>=rowStart; i--){\\n                if(i >= 0 && i < rows && colStart >= 0){\\n                    result.push_back({i, colStart});\\n                    total++;\\n                }\\n            }\\n            rowStart--;\\n            if(total == (rows * cols))\\n                break;\\n        }\\n        return result;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def spiralMatrixIII(self, rows: int, cols: int, rStart: int, cStart: int) -> List[List[int]]:\\n        visits = []\\n        top, bottom, left, right = rStart, rStart + 1, cStart, cStart + 1\\n\\n        self.incr = 1\\n        direction = 0\\n\\n        def place(row, col):\\n            visits.append([row, col])\\n            self.incr += 1\\n        \\n        while self.incr != (1 + rows * cols):\\n            if direction == 0:\\n                if top >= 0:\\n                    row = top\\n                    for col in range(max(left, 0), min(right, cols)):\\n                        place(row, col)\\n                right += 1\\n            if direction == 1:\\n                if right <= cols:\\n                    col = right - 1\\n                    for row in range(max(top, 0), min(bottom, rows)):\\n                        place(row, col)\\n                bottom += 1\\n            if direction == 2:\\n                if bottom <= rows:\\n                    row = bottom - 1\\n                    for col in range(min(right - 1, cols - 1), max(left - 1, -1), -1):\\n                        place(row, col)\\n                left -= 1\\n            if direction == 3:\\n                if left >= 0:\\n                    col = left\\n                    for row in range(min(bottom - 1, rows - 1), max(top - 1, -1), -1):\\n                        place(row, col)\\n                top -= 1\\n            direction = (direction + 1) % 4\\n        return visits\\n```\\n\\n```Java []\\nclass Solution {\\n    int index = 1;\\n    int row;\\n    int col;\\n    int rows;\\n    int cols;\\n\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        int[][] result = new int[rows * cols][2];\\n        int moves = 0;\\n        row = rStart;\\n        col = cStart;\\n        this.rows = rows;\\n        this.cols = cols;\\n        result[0] = new int[] { rStart, cStart };\\n        while (index < result.length) {\\n            ++moves;\\n            addToResult(result, moves, 1, 0);\\n            addToResult(result, moves, 0, 1);\\n            ++moves;\\n            addToResult(result, moves, -1, 0);\\n            addToResult(result, moves, 0, -1);\\n        }\\n        return result;\\n    }\\n    public void addToResult(int[][] result, int moves, int horizontal, int vertical) {\\n        for (int i = 0; i < moves; ++i) {\\n            row += vertical;\\n            col += horizontal;\\n            if (row < rows && row > -1 && col < cols && col > -1) {\\n                result[index] = new int[] { row, col };\\n                ++index;\\n            }\\n        }\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        \\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        cout.tie(NULL);\\n\\n        vector<vector<int>> result;\\n        int total = 0;\\n\\n        int rowStart = rStart;\\n        int rowEnd = rStart;\\n\\n        int colStart = cStart;\\n        int colEnd = cStart;\\n\\n        while(true){\\n            for(int i=colStart; i<=colEnd; i++){\\n                if(i >= 0 && i < cols && rowStart >= 0){\\n                    result.push_back({rowStart, i});\\n                    total++;\\n                }\\n            }\\n            colEnd++;\\n            if(total == (rows * cols))\\n                break;\\n            for(int i=rowStart; i<=rowEnd; i++){\\n                if(i >= 0 && i < rows && colEnd < cols){\\n                    result.push_back({i, colEnd});\\n                    total++;\\n                }\\n            }\\n            rowEnd++;\\n            if(total == (rows * cols))\\n                break;\\n            for(int i=colEnd; i>=colStart; i--){\\n                if(i >= 0 && i < cols && rowEnd < rows){\\n                    result.push_back({rowEnd, i});\\n                    total++;\\n                }\\n            }\\n            colStart--;\\n            if(total == (rows * cols))\\n                break;\\n            for(int i=rowEnd; i>=rowStart; i--){\\n                if(i >= 0 && i < rows && colStart >= 0){\\n                    result.push_back({i, colStart});\\n                    total++;\\n                }\\n            }\\n            rowStart--;\\n            if(total == (rows * cols))\\n                break;\\n        }\\n        return result;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def spiralMatrixIII(self, rows: int, cols: int, rStart: int, cStart: int) -> List[List[int]]:\\n        visits = []\\n        top, bottom, left, right = rStart, rStart + 1, cStart, cStart + 1\\n\\n        self.incr = 1\\n        direction = 0\\n\\n        def place(row, col):\\n            visits.append([row, col])\\n            self.incr += 1\\n        \\n        while self.incr != (1 + rows * cols):\\n            if direction == 0:\\n                if top >= 0:\\n                    row = top\\n                    for col in range(max(left, 0), min(right, cols)):\\n                        place(row, col)\\n                right += 1\\n            if direction == 1:\\n                if right <= cols:\\n                    col = right - 1\\n                    for row in range(max(top, 0), min(bottom, rows)):\\n                        place(row, col)\\n                bottom += 1\\n            if direction == 2:\\n                if bottom <= rows:\\n                    row = bottom - 1\\n                    for col in range(min(right - 1, cols - 1), max(left - 1, -1), -1):\\n                        place(row, col)\\n                left -= 1\\n            if direction == 3:\\n                if left >= 0:\\n                    col = left\\n                    for row in range(min(bottom - 1, rows - 1), max(top - 1, -1), -1):\\n                        place(row, col)\\n                top -= 1\\n            direction = (direction + 1) % 4\\n        return visits\\n```\n```Java []\\nclass Solution {\\n    int index = 1;\\n    int row;\\n    int col;\\n    int rows;\\n    int cols;\\n\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        int[][] result = new int[rows * cols][2];\\n        int moves = 0;\\n        row = rStart;\\n        col = cStart;\\n        this.rows = rows;\\n        this.cols = cols;\\n        result[0] = new int[] { rStart, cStart };\\n        while (index < result.length) {\\n            ++moves;\\n            addToResult(result, moves, 1, 0);\\n            addToResult(result, moves, 0, 1);\\n            ++moves;\\n            addToResult(result, moves, -1, 0);\\n            addToResult(result, moves, 0, -1);\\n        }\\n        return result;\\n    }\\n    public void addToResult(int[][] result, int moves, int horizontal, int vertical) {\\n        for (int i = 0; i < moves; ++i) {\\n            row += vertical;\\n            col += horizontal;\\n            if (row < rows && row > -1 && col < cols && col > -1) {\\n                result[index] = new int[] { row, col };\\n                ++index;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3507245,
                "title": "c-easy-solution",
                "content": "```\\nvector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        vector<vector<int>> ans;\\n        int top = rStart, down = rStart, left = cStart, right = cStart;\\n        ans.push_back({rStart, cStart});\\n        int count = 1;\\n        \\n        int dir = 0;\\n        //rows* cols => no of elements in the matrix\\n        while(count < rows*cols)\\n        {\\n            if(dir == 0)\\n            {\\n                for(int i=left+1; i<=right+1; i++)\\n                {\\n                    if(i>=0 && i<cols && top>=0 && top<rows)\\n                    {\\n                        ans.push_back({top, i});\\n                        count++;\\n                    }\\n                }\\n                right++;\\n            }\\n            else if(dir == 1)\\n            {\\n                for(int i=top+1; i<=down+1; i++)\\n                {\\n                    if(i>=0 && i<rows && right>=0 && right<cols)\\n                    {\\n                        ans.push_back({i, right});\\n                        count++;\\n                    }\\n                }\\n                down++;\\n            }\\n            else if(dir == 2)\\n            {\\n                for(int i=right-1; i>=left-1; i--)\\n                {\\n                    if(i>=0 && i<cols && down>=0 && down<rows)\\n                    {\\n                        ans.push_back({down, i});\\n                        count++;\\n                    }\\n                }\\n                left--;\\n            }\\n            else if(dir == 3)\\n            {\\n                for(int i=down-1; i>=top-1; i--)\\n                {\\n                    if(i>=0 && i<rows && left>=0 && left<cols)\\n                    {\\n                        ans.push_back({i, left});\\n                        count++;\\n                    }\\n                }\\n                top--;\\n            }\\n            dir = (dir+1)%4;\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Matrix"
                ],
                "code": "```\\nvector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        vector<vector<int>> ans;\\n        int top = rStart, down = rStart, left = cStart, right = cStart;\\n        ans.push_back({rStart, cStart});\\n        int count = 1;\\n        \\n        int dir = 0;\\n        //rows* cols => no of elements in the matrix\\n        while(count < rows*cols)\\n        {\\n            if(dir == 0)\\n            {\\n                for(int i=left+1; i<=right+1; i++)\\n                {\\n                    if(i>=0 && i<cols && top>=0 && top<rows)\\n                    {\\n                        ans.push_back({top, i});\\n                        count++;\\n                    }\\n                }\\n                right++;\\n            }\\n            else if(dir == 1)\\n            {\\n                for(int i=top+1; i<=down+1; i++)\\n                {\\n                    if(i>=0 && i<rows && right>=0 && right<cols)\\n                    {\\n                        ans.push_back({i, right});\\n                        count++;\\n                    }\\n                }\\n                down++;\\n            }\\n            else if(dir == 2)\\n            {\\n                for(int i=right-1; i>=left-1; i--)\\n                {\\n                    if(i>=0 && i<cols && down>=0 && down<rows)\\n                    {\\n                        ans.push_back({down, i});\\n                        count++;\\n                    }\\n                }\\n                left--;\\n            }\\n            else if(dir == 3)\\n            {\\n                for(int i=down-1; i>=top-1; i--)\\n                {\\n                    if(i>=0 && i<rows && left>=0 && left<cols)\\n                    {\\n                        ans.push_back({i, left});\\n                        count++;\\n                    }\\n                }\\n                top--;\\n            }\\n            dir = (dir+1)%4;\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3504467,
                "title": "simple-simulation-solution-python",
                "content": "# Intuition and Approach\\n* start the simulation from starting cell and insert position of cells in to ans which lie within the matrix\\n\\n# Complexity\\n- Time complexity: O(N^2)\\n\\n- Space complexity: O(N^2)\\n\\n# Code\\n```\\nclass Solution:\\n    def spiralMatrixIII(self, m: int, n: int, i: int, j: int) -> List[List[int]]:\\n        ans=[]\\n        lb,rb,tb,bb=j,j,i,i\\n        while(len(ans)<m*n):\\n            while(j<rb+1):\\n                if(i<m and j<n and i>=0 and j>=0):ans.append([i,j])\\n                j+=1\\n            rb+=1\\n            while(i<bb+1):\\n                if(i<m and j<n and i>=0 and j>=0):ans.append([i,j])\\n                i+=1\\n            bb+=1\\n            while(j>lb-1):\\n                if(i<m and j<n and i>=0 and j>=0):ans.append([i,j])\\n                j-=1\\n            lb-=1\\n            while(i>tb-1):\\n                if(i<m and j<n and i>=0 and j>=0):ans.append([i,j])\\n                i-=1\\n            tb-=1\\n        return ans\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "Array",
                    "Matrix",
                    "Combinatorics"
                ],
                "code": "```\\nclass Solution:\\n    def spiralMatrixIII(self, m: int, n: int, i: int, j: int) -> List[List[int]]:\\n        ans=[]\\n        lb,rb,tb,bb=j,j,i,i\\n        while(len(ans)<m*n):\\n            while(j<rb+1):\\n                if(i<m and j<n and i>=0 and j>=0):ans.append([i,j])\\n                j+=1\\n            rb+=1\\n            while(i<bb+1):\\n                if(i<m and j<n and i>=0 and j>=0):ans.append([i,j])\\n                i+=1\\n            bb+=1\\n            while(j>lb-1):\\n                if(i<m and j<n and i>=0 and j>=0):ans.append([i,j])\\n                j-=1\\n            lb-=1\\n            while(i>tb-1):\\n                if(i<m and j<n and i>=0 and j>=0):ans.append([i,j])\\n                i-=1\\n            tb-=1\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2812047,
                "title": "spiral-matrix-iii-adapted-dfs-solution",
                "content": "# Approach\\nWe keep track of 5 main variables:\\n1. x: colum number\\n2. y: row number\\n3. d: current direction\\n3. visited: Set of Pairs of visited col & row\\n4. result: List of ordered visited pairs\\n\\nEach time we check the direction and possible x & y values :\\n- if next position already visited: keep moving in the same current position.\\n- if next position is not visited: update x & y\\n\\n**Grid\\'s boundary**:\\nMoving outside of the grid\\'s boundary will not cause a problem if we ignore the positions in the final result. It is not needed to include the outer positions in the visited set. \\n\\n# Complexity\\n- Time complexity: **O(n*m)**\\n\\n- Space complexity: **O(n*m)**\\n\\nNote: *n=rows, m=columns*\\n\\n# Code\\n```\\nenum class Direction {\\n    RIGHT, DOWN, LEFT, UP\\n}\\n\\nclass Solution {\\n\\n    fun spiralMatrixIII(rows: Int, cols: Int, rStart: Int, cStart: Int): Array<IntArray> {\\n        val visited: MutableSet<Pair<Int, Int>> = mutableSetOf()\\n        val result: MutableList<IntArray> = mutableListOf()\\n        var y = rStart\\n        var x = cStart\\n        var d: Direction = Direction.UP\\n        fun dfs() {\\n            if (x in 0 until cols && y in 0 until rows) {\\n                visited.add(Pair(y, x))\\n                result.add(intArrayOf(y, x))\\n            }\\n            when (d) {\\n                Direction.RIGHT -> {\\n                    if (!visited.contains(Pair(y+1, x))) {y+=1; d=Direction.DOWN}\\n                    else {x+=1; d=Direction.RIGHT}\\n                }\\n                Direction.DOWN -> {\\n                    if (!visited.contains(Pair(y, x-1))) {x-=1; d=Direction.LEFT}\\n                    else {y+=1; d=Direction.DOWN}\\n                }\\n                Direction.LEFT -> {\\n                    if (!visited.contains(Pair(y-1, x))) {y-=1; d=Direction.UP}\\n                    else {x-=1; d=Direction.LEFT}\\n                }\\n                Direction.UP -> {\\n                    if (!visited.contains(Pair(y, x+1))) {x+=1; d=Direction.RIGHT}\\n                    else {y-=1; d=Direction.UP}\\n                }\\n            }\\n            if (visited.size == rows * cols){\\n                return\\n            } else { dfs() }\\n        }\\n        dfs()\\n        return result.toTypedArray()\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Depth-First Search",
                    "Graph",
                    "Matrix"
                ],
                "code": "```\\nenum class Direction {\\n    RIGHT, DOWN, LEFT, UP\\n}\\n\\nclass Solution {\\n\\n    fun spiralMatrixIII(rows: Int, cols: Int, rStart: Int, cStart: Int): Array<IntArray> {\\n        val visited: MutableSet<Pair<Int, Int>> = mutableSetOf()\\n        val result: MutableList<IntArray> = mutableListOf()\\n        var y = rStart\\n        var x = cStart\\n        var d: Direction = Direction.UP\\n        fun dfs() {\\n            if (x in 0 until cols && y in 0 until rows) {\\n                visited.add(Pair(y, x))\\n                result.add(intArrayOf(y, x))\\n            }\\n            when (d) {\\n                Direction.RIGHT -> {\\n                    if (!visited.contains(Pair(y+1, x))) {y+=1; d=Direction.DOWN}\\n                    else {x+=1; d=Direction.RIGHT}\\n                }\\n                Direction.DOWN -> {\\n                    if (!visited.contains(Pair(y, x-1))) {x-=1; d=Direction.LEFT}\\n                    else {y+=1; d=Direction.DOWN}\\n                }\\n                Direction.LEFT -> {\\n                    if (!visited.contains(Pair(y-1, x))) {y-=1; d=Direction.UP}\\n                    else {x-=1; d=Direction.LEFT}\\n                }\\n                Direction.UP -> {\\n                    if (!visited.contains(Pair(y, x+1))) {x+=1; d=Direction.RIGHT}\\n                    else {y-=1; d=Direction.UP}\\n                }\\n            }\\n            if (visited.size == rows * cols){\\n                return\\n            } else { dfs() }\\n        }\\n        dfs()\\n        return result.toTypedArray()\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2288908,
                "title": "c-easy-code-with-comments",
                "content": "![image](https://assets.leetcode.com/users/images/f1fe41ab-78f6-476e-9878-58beac74b5a6_1657953630.037121.jpeg)\\n\\n\\n\\n//  Key idea behind this approach is to spirally(clockwise) traverse matrix and expand traversal area( decrementing top and left, incrementing right and down) and keep checking boundary condition\\n\\n// T.C = O(rows*cols) , S.C = O(rows*cols)\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        \\n        \\n        vector<vector<int>> ans ;\\n        \\n        // keep track which cell is visited to avoid duplicate insertion in ans \\n        vector<vector<bool>> isvisited( rows, vector<bool>( cols, false ) ) ;\\n        \\n        int top = rStart , down = (rStart < (rows-1)) ? rStart+1 : rStart , left = cStart, right = (cStart < (cols-1)) ? cStart+1 : cStart ;\\n        \\n        int direction = 0 ;   // 0 == forward, 1 == downward , 2 == backward, 3 == upward\\n        \\n        \\n        ans.push_back({rStart, cStart}) ;\\n        \\n        isvisited[rStart][cStart] = true ;\\n        \\n        while( (int)ans.size() < (rows*cols) ){\\n            \\n           \\n            // forward move\\n            \\n            if( direction == 0 ){\\n                \\n                for( int i = left+1 ; i <= right ; ++i ){\\n                    \\n                    if(!isvisited[top][i]){\\n                        \\n                        ans.push_back({ top , i }) ;\\n                        \\n                        isvisited[top][i] = true ;\\n                    }\\n                }\\n            }\\n            \\n            // downward move\\n            \\n            else if( direction == 1 ){\\n                \\n                for( int i = top+1 ; i <= down ; ++i ){\\n                    \\n                    if( !isvisited[i][right] ){\\n                        \\n                        ans.push_back({ i , right }) ;\\n                        \\n                        isvisited[i][right] = true ;\\n                    }\\n                }\\n                // if we can expand area, expand it(boundary condtion)\\n               if( top > 0 ){\\n                \\ttop -= 1 ;\\n                }\\n                if( left > 0 ){\\n                \\tleft -= 1 ;\\n                }\\n            }\\n            \\n            // backward move\\n            \\n            else if( direction == 2 ){\\n                \\n                for( int i = right-1 ; i >= left ; --i ){\\n                    \\n                    if( !isvisited[down][i] ){\\n                        \\n                        ans.push_back({ down , i }) ;\\n                        \\n                        isvisited[down][i] = true ;\\n                    }\\n                }\\n                // if we can expand area, expand it(boundary condtion)\\n                if( right < (cols-1)){\\n                \\tright += 1 ;\\n                }\\n            }\\n            \\n            // upward move\\n            \\n            else if( direction == 3 ){\\n                \\n                for( int i = down-1 ; i >= top ; --i ){\\n                    \\n                    if( !isvisited[i][left] ){\\n                        \\n                        ans.push_back({ i, left }) ;\\n                        \\n                        isvisited[i][left] = true ;\\n                    }\\n                }\\n                // if we can expand area, expand it(boundary condtion)\\n                if( down < (rows-1)){\\n                \\tdown += 1;\\n                }\\n            }\\n            \\n            \\n            direction =  (direction+1)%4 ;\\n           \\n        } \\n        \\n        return ans ;\\n        \\n    }\\n};\\n",
                "solutionTags": [
                    "Matrix"
                ],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        \\n        \\n        vector<vector<int>> ans ;\\n        \\n        // keep track which cell is visited to avoid duplicate insertion in ans \\n        vector<vector<bool>> isvisited( rows, vector<bool>( cols, false ) ) ;\\n        \\n        int top = rStart , down = (rStart < (rows-1)) ? rStart+1 : rStart , left = cStart, right = (cStart < (cols-1)) ? cStart+1 : cStart ;\\n        \\n        int direction = 0 ;   // 0 == forward, 1 == downward , 2 == backward, 3 == upward\\n        \\n        \\n        ans.push_back({rStart, cStart}",
                "codeTag": "Java"
            },
            {
                "id": 2238692,
                "title": "c-simple-simulate-the-process-with-ease",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isvalid(int r,int c,int n,int m)\\n    {\\n        return r>=0&&r<n&&c>=0&&c<m;\\n    }\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        vector<vector<int>> ans;\\n        int c=0;\\n        int grids=rows*cols;\\n        int go=1;\\n        bool up,left,right,down;\\n        left=up=down=false;\\n        int z=0;\\n        right=true;\\n        while(true)\\n        {\\n            if(isvalid(rStart,cStart,rows,cols))\\n            {\\n                c++;\\n                // cout<<c<<endl;\\n                // cout<<rStart<<\" \"<<cStart<<endl;\\n                ans.push_back({rStart,cStart});\\n            }\\n            if(c==grids)\\n            {\\n                break;\\n            }\\n            if(right&&z!=go)\\n            {\\n                cStart++;\\n                z++;\\n                if(z==go)\\n                {\\n                    right=false;\\n                    down=true;\\n                    z=0;\\n                }\\n            }\\n            else if(down&&z!=go)\\n            {\\n                rStart++;\\n                z++;\\n                if(z==go)\\n                {\\n                    down=false;\\n                    left=true;\\n                    go++;\\n                    z=0;\\n                }\\n            }\\n            else if(left)\\n            {\\n                cStart--;\\n                z++;\\n                if(z==go)\\n                {\\n                    left=false;\\n                    up=true;\\n                    z=0;\\n                }\\n            }\\n            else if(up)\\n            {\\n                rStart--;\\n                z++;\\n                if(z==go)\\n                {\\n                    up=false;\\n                    right=true;\\n                    go++;\\n                    z=0;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Please upvote to motivate me in my quest of documenting all leetcode solutions. HAPPY CODING:)\\nAny suggestions and improvements are always welcome**\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isvalid(int r,int c,int n,int m)\\n    {\\n        return r>=0&&r<n&&c>=0&&c<m;\\n    }\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        vector<vector<int>> ans;\\n        int c=0;\\n        int grids=rows*cols;\\n        int go=1;\\n        bool up,left,right,down;\\n        left=up=down=false;\\n        int z=0;\\n        right=true;\\n        while(true)\\n        {\\n            if(isvalid(rStart,cStart,rows,cols))\\n            {\\n                c++;\\n                // cout<<c<<endl;\\n                // cout<<rStart<<\" \"<<cStart<<endl;\\n                ans.push_back({rStart,cStart});\\n            }\\n            if(c==grids)\\n            {\\n                break;\\n            }\\n            if(right&&z!=go)\\n            {\\n                cStart++;\\n                z++;\\n                if(z==go)\\n                {\\n                    right=false;\\n                    down=true;\\n                    z=0;\\n                }\\n            }\\n            else if(down&&z!=go)\\n            {\\n                rStart++;\\n                z++;\\n                if(z==go)\\n                {\\n                    down=false;\\n                    left=true;\\n                    go++;\\n                    z=0;\\n                }\\n            }\\n            else if(left)\\n            {\\n                cStart--;\\n                z++;\\n                if(z==go)\\n                {\\n                    left=false;\\n                    up=true;\\n                    z=0;\\n                }\\n            }\\n            else if(up)\\n            {\\n                rStart--;\\n                z++;\\n                if(z==go)\\n                {\\n                    up=false;\\n                    right=true;\\n                    go++;\\n                    z=0;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2091734,
                "title": "java-easy-to-understand-solution",
                "content": "```\\npublic static final int[][] dir = new int[][]{{0,1}, {1,0}, {0,-1}, {-1, 0}};\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        int[][] coords = new int[rows*cols][2];\\n        int ind = 0;\\n        int count = 0;\\n        int d = 0;\\n        int x = rStart, y = cStart;\\n        coords[ind++] = new int[]{rStart, cStart};\\n        while(ind < rows*cols) {\\n            if(d % 2 == 0)\\n                count++;\\n            for(int i = 0; i < count; i++) {\\n                x += dir[d][0];\\n                y += dir[d][1];\\n                if(isCoordValid(x, y, rows, cols))\\n                    coords[ind++] = new int[]{x, y};\\n            }\\n            d = (d+1)%4;\\n        }\\n        return coords;\\n    }\\n    \\n    private boolean isCoordValid(int x, int y, int rows, int cols) {\\n        return x >= 0 && y >= 0 && x < rows && y < cols;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic static final int[][] dir = new int[][]{{0,1}, {1,0}, {0,-1}, {-1, 0}};\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        int[][] coords = new int[rows*cols][2];\\n        int ind = 0;\\n        int count = 0;\\n        int d = 0;\\n        int x = rStart, y = cStart;\\n        coords[ind++] = new int[]{rStart, cStart};\\n        while(ind < rows*cols) {\\n            if(d % 2 == 0)\\n                count++;\\n            for(int i = 0; i < count; i++) {\\n                x += dir[d][0];\\n                y += dir[d][1];\\n                if(isCoordValid(x, y, rows, cols))\\n                    coords[ind++] = new int[]{x, y};\\n            }\\n            d = (d+1)%4;\\n        }\\n        return coords;\\n    }\\n    \\n    private boolean isCoordValid(int x, int y, int rows, int cols) {\\n        return x >= 0 && y >= 0 && x < rows && y < cols;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2038092,
                "title": "python-go-easy-to-understand-because-i-m-a-dummy-and-so-are-you",
                "content": "This is a dummy\\'s way to solve the problem so it might be a bit lengthy, but I figure this should be easy to understand.\\n\\nFirst look at the picture with the arrows in the question (Look at the second example, it\\'s easier to visualize).\\n\\nHere\\'s the steps we follow:\\n- First move 1 step to the right\\n- Then move 1 step down\\n- Then move 2 steps to the left\\n- Then move 2 steps up\\n- Then move 3 steps to the right\\n- This goes on...\\n\\nHow can we exploit this pattern? By making a step variable.\\n- If the step is odd, we move right then down\\n- If the step is even, we move left then up\\n\\nFor each movement, we check if the position is within the matrix boundary. If it is, we add it to the solution, if not we ignore.\\n\\nJust look at the code. It\\'s really simple.\\n\\nHere\\'s the code:\\n\\n**Python:**\\n```\\nclass Solution:\\n    def spiralMatrixIII(self, rows: int, cols: int, row: int, col: int) -> List[List[int]]:\\n        step = 1\\n        res = [[row, col]] # we always start with the given position\\n        while len(res) < rows * cols: # stop when we have enough elements\\n            if step % 2 == 1: # odd step\\n                stop = col + step\\n                while col < stop: # move left\\n                    col += 1\\n                    if self.is_valid(row, col, rows, cols):\\n                        res.append([row, col])\\n                \\n                stop = row + step\\n                while row < stop: # move down\\n                    row += 1\\n                    if self.is_valid(row, col, rows, cols):\\n                        res.append([row, col])\\n                \\n            else: # even step\\n                stop = col - step\\n                while col > stop: # move right\\n                    col -= 1\\n                    if self.is_valid(row, col, rows, cols):\\n                        res.append([row, col])\\n                \\n                stop = row - step\\n                while row > stop: # move up\\n                    row -= 1\\n                    if self.is_valid(row, col, rows, cols):\\n                        res.append([row, col])\\n                \\n            step += 1\\n            \\n        return res\\n    \\n    def is_valid(self, row, col, rows, cols):\\n        return row >= 0 and row < rows and col >= 0 and col < cols\\n```\\n\\n**Go:**\\n```\\nfunc spiralMatrixIII(rows int, cols int, row int, col int) [][]int {\\n    step := 1\\n    res := [][]int{[]int{row, col}}\\n    \\n    for len(res) < rows * cols {\\n        if step % 2 == 1 { // odd step\\n            stop := col + step\\n            for col < stop { // move left\\n                col++\\n                if is_valid(row, col, rows, cols) {\\n                    res = append(res, []int{row, col})\\n                }\\n            }\\n            \\n            stop = row + step\\n            for row < stop { // move down\\n                row++\\n                if is_valid(row, col, rows, cols) {\\n                    res = append(res, []int{row, col})\\n                }\\n            }\\n        } else { // even step\\n            stop := col - step\\n            for col > stop { // move right\\n                col--\\n                if is_valid(row, col, rows, cols) {\\n                    res = append(res, []int{row, col})\\n                }\\n            }\\n            \\n            stop = row - step\\n            for row > stop { // move up\\n                row--\\n                if is_valid(row, col, rows, cols) {\\n                    res = append(res, []int{row, col})\\n                }\\n            }\\n        }\\n        \\n        step++\\n    }\\n    \\n    return res\\n}\\n\\nfunc is_valid(row, col, rows, cols int) bool {\\n    return row >= 0 && row < rows && col >= 0 && col < cols\\n}\\n```",
                "solutionTags": [
                    "Python",
                    "Go",
                    "Matrix"
                ],
                "code": "```\\nclass Solution:\\n    def spiralMatrixIII(self, rows: int, cols: int, row: int, col: int) -> List[List[int]]:\\n        step = 1\\n        res = [[row, col]] # we always start with the given position\\n        while len(res) < rows * cols: # stop when we have enough elements\\n            if step % 2 == 1: # odd step\\n                stop = col + step\\n                while col < stop: # move left\\n                    col += 1\\n                    if self.is_valid(row, col, rows, cols):\\n                        res.append([row, col])\\n                \\n                stop = row + step\\n                while row < stop: # move down\\n                    row += 1\\n                    if self.is_valid(row, col, rows, cols):\\n                        res.append([row, col])\\n                \\n            else: # even step\\n                stop = col - step\\n                while col > stop: # move right\\n                    col -= 1\\n                    if self.is_valid(row, col, rows, cols):\\n                        res.append([row, col])\\n                \\n                stop = row - step\\n                while row > stop: # move up\\n                    row -= 1\\n                    if self.is_valid(row, col, rows, cols):\\n                        res.append([row, col])\\n                \\n            step += 1\\n            \\n        return res\\n    \\n    def is_valid(self, row, col, rows, cols):\\n        return row >= 0 and row < rows and col >= 0 and col < cols\\n```\n```\\nfunc spiralMatrixIII(rows int, cols int, row int, col int) [][]int {\\n    step := 1\\n    res := [][]int{[]int{row, col}}\\n    \\n    for len(res) < rows * cols {\\n        if step % 2 == 1 { // odd step\\n            stop := col + step\\n            for col < stop { // move left\\n                col++\\n                if is_valid(row, col, rows, cols) {\\n                    res = append(res, []int{row, col})\\n                }\\n            }\\n            \\n            stop = row + step\\n            for row < stop { // move down\\n                row++\\n                if is_valid(row, col, rows, cols) {\\n                    res = append(res, []int{row, col})\\n                }\\n            }\\n        } else { // even step\\n            stop := col - step\\n            for col > stop { // move right\\n                col--\\n                if is_valid(row, col, rows, cols) {\\n                    res = append(res, []int{row, col})\\n                }\\n            }\\n            \\n            stop = row - step\\n            for row > stop { // move up\\n                row--\\n                if is_valid(row, col, rows, cols) {\\n                    res = append(res, []int{row, col})\\n                }\\n            }\\n        }\\n        \\n        step++\\n    }\\n    \\n    return res\\n}\\n\\nfunc is_valid(row, col, rows, cols int) bool {\\n    return row >= 0 && row < rows && col >= 0 && col < cols\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1956245,
                "title": "java-solution",
                "content": "Solution - \\n```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        int[][] ans = new int[rows*cols][2];\\n        int i=0;\\n        ans[i++] = new int[]{rStart, cStart};\\n        \\n        int len=0;\\n        int d=0;\\n        int[] direction = new int[]{0, 1, 0, -1, 0};\\n        \\n        while(i < rows * cols){\\n            if(d == 0 || d == 2){\\n                len++;\\n            }\\n            for(int k=0; k<len; k++){\\n                rStart += direction[d];\\n                cStart += direction[d+1];\\n                \\n                if(rStart<rows && rStart>=0 && cStart<cols && cStart >= 0){\\n                    ans[i++] = new int[]{rStart, cStart};\\n                }\\n            }\\n            d = ++d % 4;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        int[][] ans = new int[rows*cols][2];\\n        int i=0;\\n        ans[i++] = new int[]{rStart, cStart};\\n        \\n        int len=0;\\n        int d=0;\\n        int[] direction = new int[]{0, 1, 0, -1, 0};\\n        \\n        while(i < rows * cols){\\n            if(d == 0 || d == 2){\\n                len++;\\n            }\\n            for(int k=0; k<len; k++){\\n                rStart += direction[d];\\n                cStart += direction[d+1];\\n                \\n                if(rStart<rows && rStart>=0 && cStart<cols && cStart >= 0){\\n                    ans[i++] = new int[]{rStart, cStart};\\n                }\\n            }\\n            d = ++d % 4;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1942233,
                "title": "c-with-issafe-function",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    int isSafe(int rows, int cols, int i, int j)\\n    {\\n\\n        if (i < 0 || j < 0 || j >= cols || i >= rows)\\n        {\\n            return false;\\n        }\\n        return true;\\n    } \\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart)\\n    {\\n        int num = 2;\\n        vector<vector<int>> ans;\\n        int move = 0;\\n        ans.push_back(vector<int>{rStart, cStart});\\n        while (num <= rows * cols)\\n        {\\n\\n            move++;\\n            // right\\n            int p = move;\\n            while (p--)\\n            {\\n                cStart++;\\n                if (isSafe(rows , cols, rStart, cStart))\\n                {\\n                    ans.push_back(vector<int>{rStart, cStart});\\n                    num++;\\n                }\\n            }\\n\\n            // down\\n            p = move;\\n            while (p--)\\n            {\\n                rStart++;\\n                if (isSafe(rows , cols , rStart, cStart))\\n                {\\n                    ans.push_back(vector<int>{rStart, cStart});\\n                    num++;\\n                }\\n            }\\n\\n            move++;\\n            // r -> l\\n            p = move;\\n            while (p--)\\n            {\\n                cStart--;\\n                if (isSafe(rows , cols , rStart, cStart))\\n                {\\n                    ans.push_back(vector<int>{rStart, cStart});\\n                    num++;\\n                }\\n            }\\n\\n            // d -> u\\n            p = move;\\n            while (p--)\\n            {\\n                rStart--;\\n                if (isSafe(rows , cols, rStart, cStart))\\n                {\\n                    ans.push_back(vector<int>{rStart, cStart});\\n                    num++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    int isSafe(int rows, int cols, int i, int j)\\n    {\\n\\n        if (i < 0 || j < 0 || j >= cols || i >= rows)\\n        {\\n            return false;\\n        }\\n        return true;\\n    } \\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart)\\n    {\\n        int num = 2;\\n        vector<vector<int>> ans;\\n        int move = 0;\\n        ans.push_back(vector<int>{rStart, cStart});\\n        while (num <= rows * cols)\\n        {\\n\\n            move++;\\n            // right\\n            int p = move;\\n            while (p--)\\n            {\\n                cStart++;\\n                if (isSafe(rows , cols, rStart, cStart))\\n                {\\n                    ans.push_back(vector<int>{rStart, cStart});\\n                    num++;\\n                }\\n            }\\n\\n            // down\\n            p = move;\\n            while (p--)\\n            {\\n                rStart++;\\n                if (isSafe(rows , cols , rStart, cStart))\\n                {\\n                    ans.push_back(vector<int>{rStart, cStart});\\n                    num++;\\n                }\\n            }\\n\\n            move++;\\n            // r -> l\\n            p = move;\\n            while (p--)\\n            {\\n                cStart--;\\n                if (isSafe(rows , cols , rStart, cStart))\\n                {\\n                    ans.push_back(vector<int>{rStart, cStart});\\n                    num++;\\n                }\\n            }\\n\\n            // d -> u\\n            p = move;\\n            while (p--)\\n            {\\n                rStart--;\\n                if (isSafe(rows , cols, rStart, cStart))\\n                {\\n                    ans.push_back(vector<int>{rStart, cStart});\\n                    num++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1942077,
                "title": "python",
                "content": "\\n    def spiralMatrixIII(self, rows, cols, rStart, cStart):\\n        i, j = rStart, cStart\\n        coordinates = [[rStart,cStart]]\\n        \\n        step, sign = 1, 1\\n        \\n        while len(coordinates) < rows*cols:\\n            for _ in range(step):\\n                j += sign\\n                if 0 <= i < rows and 0 <= j < cols:\\n                    coordinates.append([i,j])\\n                    \\n            for _ in range(step):\\n                i += sign\\n                if 0 <= i < rows and 0 <= j < cols:\\n                    coordinates.append([i,j])\\n                    \\n            step += 1\\n            sign *= -1\\n    \\n        return coordinates",
                "solutionTags": [],
                "code": "\\n    def spiralMatrixIII(self, rows, cols, rStart, cStart):\\n        i, j = rStart, cStart\\n        coordinates = [[rStart,cStart]]\\n        \\n        step, sign = 1, 1\\n        \\n        while len(coordinates) < rows*cols:\\n            for _ in range(step):\\n                j += sign\\n                if 0 <= i < rows and 0 <= j < cols:\\n                    coordinates.append([i,j])\\n                    \\n            for _ in range(step):\\n                i += sign\\n                if 0 <= i < rows and 0 <= j < cols:\\n                    coordinates.append([i,j])\\n                    \\n            step += 1\\n            sign *= -1\\n    \\n        return coordinates",
                "codeTag": "Python3"
            },
            {
                "id": 1760359,
                "title": "java-simple-code-faster-than-99-47",
                "content": "\\n\\n```\\nclass Solution {\\n      int size = 0;\\n      int[][] mat;\\n    \\n     public void add(int r, int c, int rows, int cols) {\\n            \\n            //Check out of bound condition , if it is out of bound , don\\'t do anything\\n            //just return it\\n            \\n            if(r>=rows || r<0 || c>=cols || c<0) {\\n                return;\\n            }\\n            \\n             mat[size][0] = r;\\n             mat[size++][1] = c;        //size is increaed for next trip or iteration\\n     }\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n\\t\\n /*     \\nThere are rows X cols elements in Matrix , and each of that element we have to\\ntraverse in clockwise spiral i.e Jalebi , and we need to print co-ordinates of each\\nelement , so we need rows = rows X cols and in each 1D Array , there are two indices\\nonly i.e (row , col) , so we need cols = 2\\n*/    \\n \\n        mat = new int[rows * cols][2];\\n        \\n        int len = 1;\\n        int r = rStart, c = cStart;\\n        \\n        while(size < rows * cols) {\\n            \\n            //Move Right or East , so cols will increase\\n            for(int i=0; i<len; i++) {\\n                add(r, c++,  rows , cols);\\n            }\\n            \\n            //Move Down or South , so rows will increase\\n            for(int i=0; i<len; i++) {\\n                add(r++, c, rows, cols);\\n            }\\n                    len++;  \\n            \\n            //Move Left or West , so cols will decrease\\n            for(int i=0; i<len; i++) {\\n                add(r, c--, rows, cols);\\n            }\\n                    \\n            //Move Up or North , so rows will decrease\\n            for(int i=0; i<len; i++) {\\n                add(r--, c, rows, cols);\\n            }\\n                    len++;\\n        }\\n                    return mat;\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n      int size = 0;\\n      int[][] mat;\\n    \\n     public void add(int r, int c, int rows, int cols) {\\n            \\n            //Check out of bound condition , if it is out of bound , don\\'t do anything\\n            //just return it\\n            \\n            if(r>=rows || r<0 || c>=cols || c<0) {\\n                return;\\n            }\\n            \\n             mat[size][0] = r;\\n             mat[size++][1] = c;        //size is increaed for next trip or iteration\\n     }\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n\\t\\n /*     \\nThere are rows X cols elements in Matrix , and each of that element we have to\\ntraverse in clockwise spiral i.e Jalebi , and we need to print co-ordinates of each\\nelement , so we need rows = rows X cols and in each 1D Array , there are two indices\\nonly i.e (row , col) , so we need cols = 2\\n*/    \\n \\n        mat = new int[rows * cols][2];\\n        \\n        int len = 1;\\n        int r = rStart, c = cStart;\\n        \\n        while(size < rows * cols) {\\n            \\n            //Move Right or East , so cols will increase\\n            for(int i=0; i<len; i++) {\\n                add(r, c++,  rows , cols);\\n            }\\n            \\n            //Move Down or South , so rows will increase\\n            for(int i=0; i<len; i++) {\\n                add(r++, c, rows, cols);\\n            }\\n                    len++;  \\n            \\n            //Move Left or West , so cols will decrease\\n            for(int i=0; i<len; i++) {\\n                add(r, c--, rows, cols);\\n            }\\n                    \\n            //Move Up or North , so rows will decrease\\n            for(int i=0; i<len; i++) {\\n                add(r--, c, rows, cols);\\n            }\\n                    len++;\\n        }\\n                    return mat;\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1731664,
                "title": "java-easy-solution-with-explaintation",
                "content": "\\n      class Solution{\\n      public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        \\n        //first we need an 2D array to store all the indices\\n        //of rows = r*c and columns = 2 .\\n        int[][] res = new int[rows*cols][2];\\n        \\n        //edge case\\n        int size = rows*cols ; \\n     \\n\\t   //since initial positions index is given \\n        res[0] = new int[]{ rStart , cStart};\\n        if(size == 1) { return res ; }\\n        \\n        //we need an another array which change row and col values\\n        //so that we can move in spiral order.\\n        int[][] dir = { {0,1} , {1,0} , {0,-1} , {-1,0} };\\n        //now why I took these specific values in my dir array\\n        //bcoz if you notice the given examples , You will see a\\n        //pattern.\\n        //First we go east column increases & row remains constant so {0,1}\\n        //Second we go south row increases & column remains constant so {1,0}\\n        //Third we go west column decreases & row remains constant so {0,-1}\\n        //Fourth we go north row decreases & column remains constant so{-1,0}\\n        \\n        //now since we are moving in 4 directions so after a complete\\n        //revolution we need do reset direction to east \\n        //or we can say reset dir arr to its begining.\\n        int d = 0 ; // this variable gonna help us in his task.\\n        int len = 0; // this will decide how much length to go in a direction\\n        \\n       \\n        int count = 1 ; // this will be our counter var to break the loop\\n        // we put 1 element in res thats why count = 1.\\n        \\n        //now a loop to get all other indices in spiral manner\\n        \\n        while(count<rows*cols)\\n        {\\n            if(d==0||d==2) { len++ ; } //1,1,2,2,3,3,4,4\\n            //Above condition will helps in achieving the repeating sequence\\n            \\n            for(int i=0;i<len;i++)\\n            {\\n                rStart = rStart + dir[d][0]; //increase or decrease row\\n                cStart = cStart + dir[d][1]; //increase or decrease column\\n                \\n                if(rStart>=0 && rStart<rows && cStart>=0 && cStart<cols)\\n                {\\n                    //Above condition will check if the row & col values\\n                    //are in the given matrix or not. If true then we will\\n                    //add them in our result array.\\n                    res[count++] = new int[]{ rStart , cStart };\\n                }\\n            }\\n            //we have to change values of d in order to change the diection\\n            \\n            d = ( d+1 ) % 4 ; // this will reset the value to 0 after a revolution.                                                           \\n        }\\n        \\n        return res;\\n        \\n        \\n    }\\n}",
                "solutionTags": [
                    "Matrix"
                ],
                "code": "class Solution{\\n      public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        \\n        //first we need an 2D array to store all the indices\\n        //of rows = r*c and columns = 2 .\\n        int[][] res = new int[rows*cols][2];\\n        \\n        //edge case\\n        int size = rows*cols ; \\n     \\n\\t   //since initial positions index is given \\n        res[0] = new int[]{ rStart , cStart}",
                "codeTag": "Java"
            },
            {
                "id": 1696940,
                "title": "java-solution-easy",
                "content": "```class Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        \\n        int[][] ans = new int[rows*cols][2];\\n        \\n        int t = rStart;\\n        int d = t+1;\\n        int l = cStart;\\n        int r = l+1;\\n        int i = 0;\\n        int j = 0;\\n        \\n        ans[i][j++] = rStart;\\n        ans[i++][j] = cStart;\\n        j = 0;\\n        \\n        while((i<(rows*cols)) && j<2){\\n            \\n            for(int a = l+1; a<=r && i<(rows*cols); a++){\\n                if(a<cols && t>=0 && a>=0){\\n                    ans[i][j++] = t;\\n                    ans[i++][j] = a;\\n                    j=0;\\n                }\\n            }\\n            l--;\\n            \\n            for(int a = t+1; a<=d && i<(rows*cols); a++){\\n                if(a<rows && r<cols && a>=0){\\n                    ans[i][j++] = a;\\n                    ans[i++][j] = r;\\n                    j=0;\\n                }\\n            }\\n            t--;\\n            \\n            for(int a = r-1; a>=l && i<(rows*cols); a--){\\n                if(a<cols && d<rows && a>=0){\\n                    ans[i][j++] = d;\\n                    ans[i++][j] = a;\\n                    j=0;\\n                }\\n            }\\n            r++;\\n            \\n            for(int a = d-1; a>=t && i<(rows*cols); a--){\\n                if(a<rows && l>=0 && a>=0){\\n                    ans[i][j++] = a;\\n                    ans[i++][j] = l;\\n                    j=0;\\n                }\\n            }\\n            d++;\\n        }\\n        return ans;\\n    }\\n}```\\n\\nThere are four for loops for 4 movements  and the if condition take care that ans contains correct numbers for rows and collumn",
                "solutionTags": [],
                "code": "```class Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        \\n        int[][] ans = new int[rows*cols][2];\\n        \\n        int t = rStart;\\n        int d = t+1;\\n        int l = cStart;\\n        int r = l+1;\\n        int i = 0;\\n        int j = 0;\\n        \\n        ans[i][j++] = rStart;\\n        ans[i++][j] = cStart;\\n        j = 0;\\n        \\n        while((i<(rows*cols)) && j<2){\\n            \\n            for(int a = l+1; a<=r && i<(rows*cols); a++){\\n                if(a<cols && t>=0 && a>=0){\\n                    ans[i][j++] = t;\\n                    ans[i++][j] = a;\\n                    j=0;\\n                }\\n            }\\n            l--;\\n            \\n            for(int a = t+1; a<=d && i<(rows*cols); a++){\\n                if(a<rows && r<cols && a>=0){\\n                    ans[i][j++] = a;\\n                    ans[i++][j] = r;\\n                    j=0;\\n                }\\n            }\\n            t--;\\n            \\n            for(int a = r-1; a>=l && i<(rows*cols); a--){\\n                if(a<cols && d<rows && a>=0){\\n                    ans[i][j++] = d;\\n                    ans[i++][j] = a;\\n                    j=0;\\n                }\\n            }\\n            r++;\\n            \\n            for(int a = d-1; a>=t && i<(rows*cols); a--){\\n                if(a<rows && l>=0 && a>=0){\\n                    ans[i][j++] = a;\\n                    ans[i++][j] = l;\\n                    j=0;\\n                }\\n            }\\n            d++;\\n        }\\n        return ans;\\n    }\\n}```",
                "codeTag": "Java"
            },
            {
                "id": 1594604,
                "title": "c-98-4-solution",
                "content": "```\\n/*\\nRuntime: 8 ms, faster than 98.40% of C++ online submissions for Spiral Matrix III.\\nMemory Usage: 12.2 MB, less than 62.57% of C++ online submissions for Spiral Matrix III.\\n*/\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(const int rows, \\n                                        const int cols, \\n                                        const int rStart, \\n                                        const int cStart) \\n    {        \\n        const int SIZE = rows * cols;\\n        \\n        if ( 0 == SIZE ) return {};\\n        if ( 1 == SIZE ) \\n        {\\n            return { {0, 0} };\\n        }\\n        \\n        vector<vector<int>> ans;\\n        \\n        int count = 1;\\n        int r = rStart;\\n        int c = cStart;\\n        int step = 2;\\n        ans.push_back( {r, c} );\\n        \\n        while (1)\\n        {\\n            for ( int i = c; i < c+step; i++ )\\n            {\\n                if (  0 <= i && i < cols \\n                   && 0 <= r && r < rows )\\n                {\\n                    if ( i==c ) continue;\\n                    else\\n                    {\\n                        ans.push_back( {r, i} );\\n                        count++;\\n                    }\\n                }\\n            }\\n            \\n            if ( count >= SIZE ) break;\\n            c += step-1;\\n            \\n            for ( int i = r; i < r+step; i++ )\\n            {\\n                if (  0 <= i && i < rows \\n                   && 0 <= c && c < cols )\\n                {\\n                    if ( i==r ) continue;\\n                    else\\n                    {\\n                        ans.push_back( {i, c} );\\n                        count++;\\n                    }\\n                }\\n            }\\n            \\n            if ( count >= SIZE ) break;\\n            r += step-1;\\n            step++;\\n            \\n            for ( int i = c; i > c-step; i-- )\\n            {\\n                if (  0 <= i && i < cols \\n                   && 0 <= r && r < rows )\\n                {\\n                    if ( i==c ) continue;\\n                    else\\n                    {\\n                        ans.push_back( {r, i} );\\n                        count++;\\n                    }\\n                }\\n            }\\n            \\n            if ( count >= SIZE ) break;\\n            c += 1-step;\\n            \\n            for ( int i = r; i > r-step; i-- )\\n            {\\n                if (  0 <= i && i < rows \\n                   && 0 <= c && c < cols )\\n                {\\n                    if ( i==r ) continue;\\n                    else\\n                    {\\n                        ans.push_back( {i, c} );\\n                        count++;\\n                    }\\n                }\\n            }\\n            \\n            if ( count >= SIZE ) break;\\n            r += 1-step;\\n            step++;\\n        }\\n                \\n        return ans;      \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\nRuntime: 8 ms, faster than 98.40% of C++ online submissions for Spiral Matrix III.\\nMemory Usage: 12.2 MB, less than 62.57% of C++ online submissions for Spiral Matrix III.\\n*/\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(const int rows, \\n                                        const int cols, \\n                                        const int rStart, \\n                                        const int cStart) \\n    {        \\n        const int SIZE = rows * cols;\\n        \\n        if ( 0 == SIZE ) return {};\\n        if ( 1 == SIZE ) \\n        {\\n            return { {0, 0} };\\n        }\\n        \\n        vector<vector<int>> ans;\\n        \\n        int count = 1;\\n        int r = rStart;\\n        int c = cStart;\\n        int step = 2;\\n        ans.push_back( {r, c} );\\n        \\n        while (1)\\n        {\\n            for ( int i = c; i < c+step; i++ )\\n            {\\n                if (  0 <= i && i < cols \\n                   && 0 <= r && r < rows )\\n                {\\n                    if ( i==c ) continue;\\n                    else\\n                    {\\n                        ans.push_back( {r, i} );\\n                        count++;\\n                    }\\n                }\\n            }\\n            \\n            if ( count >= SIZE ) break;\\n            c += step-1;\\n            \\n            for ( int i = r; i < r+step; i++ )\\n            {\\n                if (  0 <= i && i < rows \\n                   && 0 <= c && c < cols )\\n                {\\n                    if ( i==r ) continue;\\n                    else\\n                    {\\n                        ans.push_back( {i, c} );\\n                        count++;\\n                    }\\n                }\\n            }\\n            \\n            if ( count >= SIZE ) break;\\n            r += step-1;\\n            step++;\\n            \\n            for ( int i = c; i > c-step; i-- )\\n            {\\n                if (  0 <= i && i < cols \\n                   && 0 <= r && r < rows )\\n                {\\n                    if ( i==c ) continue;\\n                    else\\n                    {\\n                        ans.push_back( {r, i} );\\n                        count++;\\n                    }\\n                }\\n            }\\n            \\n            if ( count >= SIZE ) break;\\n            c += 1-step;\\n            \\n            for ( int i = r; i > r-step; i-- )\\n            {\\n                if (  0 <= i && i < rows \\n                   && 0 <= c && c < cols )\\n                {\\n                    if ( i==r ) continue;\\n                    else\\n                    {\\n                        ans.push_back( {i, c} );\\n                        count++;\\n                    }\\n                }\\n            }\\n            \\n            if ( count >= SIZE ) break;\\n            r += 1-step;\\n            step++;\\n        }\\n                \\n        return ans;      \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1365212,
                "title": "to-practice-the-recursion",
                "content": "\\tclass Solution {\\n\\t\\tpublic int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n\\t\\t\\t// int[][] arr = new int[rows][cols];\\n\\t\\t\\t// arr[rStart][cStart] = 1;\\n\\t\\t\\tint[][] ans = new int[rows * cols][2];\\n\\t\\t\\tif (rows == 1 && cols == 1) return ans;\\n        \\n\\t\\t\\tint[] writer = new int[1];\\n\\t\\t\\tans[0][0] = rStart;\\n\\t\\t\\tans[0][1] = cStart;        \\n\\t\\t\\twriter[0] = 2;\\n\\t\\t\\tspiralMatrixIII(ans, 3, 0, rows, cols, rStart, cStart, writer);\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n    \\n\\t\\tprivate void spiralMatrixIII(int[][] ans, int size, int offset, int rows, int cols, int rStart, int cStart, int[] writer) {\\n\\t\\t\\tif ((rStart + offset >= rows) && (rStart - offset < 0) && (cStart + offset >= cols) && (cStart - offset < 0)) {\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\t// right\\n\\t\\t\\tfor (int i = 0; i < size - 1; i++) {\\n\\t\\t\\t\\tif ((rStart - offset + i <= rows - 1) && (cStart + 1 + offset <= cols - 1) && (rStart - offset + i >= 0) && (cStart + 1 + offset >=0)){\\n\\t\\t\\t\\t\\t// arr[rStart - offset + i][cStart + 1 + offset] = writer[0];\\n\\t\\t\\t\\t\\twriter[0]++;\\n\\t\\t\\t\\t\\tans[writer[0] - 2][0] = rStart - offset + i;\\n\\t\\t\\t\\t\\tans[writer[0] - 2][1] = cStart + 1 + offset;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} \\n        \\n\\t\\t\\t// bottom\\n\\t\\t\\tfor (int i = 0; i < size - 1; i++) {\\n\\t\\t\\t\\tif ((rStart + 1 + offset <= rows - 1) && (cStart - i + offset <= cols - 1) && (rStart + 1 + offset >= 0) && (cStart - i + offset >= 0)){\\n\\t\\t\\t\\t\\t// arr[rStart + 1 + offset][cStart - i + offset] = writer[0];\\n\\t\\t\\t\\t\\twriter[0]++;\\n\\t\\t\\t\\t\\tans[writer[0] - 2][0] = rStart + 1 + offset;\\n\\t\\t\\t\\t\\tans[writer[0] - 2][1] = cStart - i + offset;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n        \\n\\t\\t\\t// left\\n\\t\\t\\tfor (int i = 0; i < size - 1; i ++) {\\n\\t\\t\\t\\tif ((rStart - i + offset <= rows - 1) && (cStart - 1 - offset <= cols - 1) && (rStart - i + offset >= 0) && (cStart - 1 - offset >= 0)){\\n\\t\\t\\t\\t\\t// arr[rStart - i + offset][cStart - 1 - offset] = writer[0];\\n\\t\\t\\t\\t\\twriter[0]++; \\n\\t\\t\\t\\t\\tans[writer[0] - 2][0] = rStart - i + offset;\\n\\t\\t\\t\\t\\tans[writer[0] - 2][1] = cStart - 1 - offset;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n        \\n\\t\\t\\t// top\\n\\t\\t\\tfor (int i = 0; i < size - 1; i++) {\\n\\t\\t\\t\\tif ((rStart - 1 - offset <= rows - 1) && (cStart + i - offset <= cols - 1) && (rStart - 1 - offset >= 0) && (cStart + i - offset >= 0)){\\n\\t\\t\\t\\t\\t// arr[rStart - 1 - offset][cStart + i - offset] = writer[0];\\n\\t\\t\\t\\t\\twriter[0]++;  \\n\\t\\t\\t\\t\\tans[writer[0] - 2][0] = rStart - 1 - offset;\\n\\t\\t\\t\\t\\tans[writer[0] - 2][1] = cStart + i - offset;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tspiralMatrixIII(ans, size + 2, offset + 1, rows, cols, rStart, cStart, writer);\\n\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n\\t\\t\\t// int[][] arr = new int[rows][cols];\\n\\t\\t\\t// arr[rStart][cStart] = 1;\\n\\t\\t\\tint[][] ans = new int[rows * cols][2];\\n\\t\\t\\tif (rows == 1 && cols == 1) return ans;\\n        \\n\\t\\t\\tint[] writer = new int[1];\\n\\t\\t\\tans[0][0] = rStart;\\n\\t\\t\\tans[0][1] = cStart;        \\n\\t\\t\\twriter[0] = 2;\\n\\t\\t\\tspiralMatrixIII(ans, 3, 0, rows, cols, rStart, cStart, writer);\\n\\t\\t\\treturn ans;\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1285754,
                "title": "python3-solution",
                "content": "```\\nclass Solution:\\n    def spiralMatrixIII(self, rows: int, cols: int, rStart: int, cStart: int) -> List[List[int]]:\\n        i ,j = rStart, cStart\\n        inc = 1\\n        ans = [[rStart, cStart]]\\n        while len(ans) < rows*cols:\\n            if inc % 2 == 0:\\n                c = inc * -1\\n            else:\\n                c = inc\\n            z = abs(c)\\n            while z > 0:\\n                if c < 0:\\n                    j -= 1\\n                else:\\n                    j += 1\\n                if i in range(0, rows) and j in range(0, cols):\\n                    ans.append([i, j])\\n                z -= 1\\n            z = abs(c)\\n            while z > 0:\\n                if c < 0:\\n                    i -= 1\\n                else:\\n                    i += 1\\n                if i in range(0, rows) and j in range(0, cols):\\n                    ans.append([i, j])\\n                z -= 1\\n            inc += 1\\n        return ans\\n```\\n**If you like this solution, please upvote for this**",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def spiralMatrixIII(self, rows: int, cols: int, rStart: int, cStart: int) -> List[List[int]]:\\n        i ,j = rStart, cStart\\n        inc = 1\\n        ans = [[rStart, cStart]]\\n        while len(ans) < rows*cols:\\n            if inc % 2 == 0:\\n                c = inc * -1\\n            else:\\n                c = inc\\n            z = abs(c)\\n            while z > 0:\\n                if c < 0:\\n                    j -= 1\\n                else:\\n                    j += 1\\n                if i in range(0, rows) and j in range(0, cols):\\n                    ans.append([i, j])\\n                z -= 1\\n            z = abs(c)\\n            while z > 0:\\n                if c < 0:\\n                    i -= 1\\n                else:\\n                    i += 1\\n                if i in range(0, rows) and j in range(0, cols):\\n                    ans.append([i, j])\\n                z -= 1\\n            inc += 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1218501,
                "title": "java-iterative-approach-clear-code",
                "content": "Here\\'s a clear iterative code in Java, keep expanding to higher square as done with up, down, then expand col then expand row.\\n\\n```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        int n = rows*cols;\\n        List<int[]> l = new ArrayList<>();\\n        int rowStart = rStart, rowEnd = rStart+1;\\n        int colStart = cStart, colEnd = cStart+1;\\n        while (l.size() != n) {\\n            for (int j = colStart; j <= colEnd; j++) {\\n                if (isValid(rowStart, j, rows, cols)) {\\n                    l.add(new int[]{rowStart, j});\\n                }\\n            }\\n            for (int i = rowStart+1; i <= rowEnd; i++) {\\n                if (isValid(i, colEnd, rows, cols)) {\\n                    l.add(new int[]{i, colEnd});\\n                }\\n            }\\n            for (int j = colEnd-1; j >= colStart-1; j--) {\\n                if (isValid(rowEnd, j, rows, cols)) {\\n                    l.add(new int[]{rowEnd, j});\\n                }\\n            }\\n            for (int i = rowEnd-1; i >= rowStart; i--) {\\n                if (isValid(i, colStart-1, rows, cols)) {\\n                    l.add(new int[]{i, colStart-1});\\n                }\\n            }\\n            rowStart--;\\n            colStart--;\\n            rowEnd++;\\n            colEnd++;\\n        }\\n        int[][] res = new int[l.size()][];\\n        for (int i = 0; i < l.size(); i++) {\\n            res[i] = l.get(i);\\n        }\\n        return res;\\n    }\\n    \\n    private boolean isValid(int i, int j, int rows, int cols) {\\n        return (i >= 0 && i < rows && j >= 0 && j < cols);\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        int n = rows*cols;\\n        List<int[]> l = new ArrayList<>();\\n        int rowStart = rStart, rowEnd = rStart+1;\\n        int colStart = cStart, colEnd = cStart+1;\\n        while (l.size() != n) {\\n            for (int j = colStart; j <= colEnd; j++) {\\n                if (isValid(rowStart, j, rows, cols)) {\\n                    l.add(new int[]{rowStart, j});\\n                }\\n            }\\n            for (int i = rowStart+1; i <= rowEnd; i++) {\\n                if (isValid(i, colEnd, rows, cols)) {\\n                    l.add(new int[]{i, colEnd});\\n                }\\n            }\\n            for (int j = colEnd-1; j >= colStart-1; j--) {\\n                if (isValid(rowEnd, j, rows, cols)) {\\n                    l.add(new int[]{rowEnd, j});\\n                }\\n            }\\n            for (int i = rowEnd-1; i >= rowStart; i--) {\\n                if (isValid(i, colStart-1, rows, cols)) {\\n                    l.add(new int[]{i, colStart-1});\\n                }\\n            }\\n            rowStart--;\\n            colStart--;\\n            rowEnd++;\\n            colEnd++;\\n        }\\n        int[][] res = new int[l.size()][];\\n        for (int i = 0; i < l.size(); i++) {\\n            res[i] = l.get(i);\\n        }\\n        return res;\\n    }\\n    \\n    private boolean isValid(int i, int j, int rows, int cols) {\\n        return (i >= 0 && i < rows && j >= 0 && j < cols);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 979712,
                "title": "python-solution-faster-than-96",
                "content": "```\\nclass Solution:\\n    def spiralMatrixIII(self, R: int, C: int, r0: int, c0: int) -> List[List[int]]:\\n        res = [[r0, c0]]\\n        c_r, c_c = r0, c0  # current row, current column\\n        s, d = 1, 1  # step, direction\\n\\n        while len(res) < R * C:\\n            for _ in range(s):\\n                c_c = c_c + 1 * d\\n                if 0 <= c_r < R and 0 <= c_c < C:\\n                    res.append([c_r, c_c])\\n\\n            for _ in range(s):\\n                c_r = c_r + 1 * d\\n                if 0 <= c_r < R and 0 <= c_c < C:\\n                    res.append([c_r, c_c])\\n\\n            s += 1\\n            d *= -1\\n\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def spiralMatrixIII(self, R: int, C: int, r0: int, c0: int) -> List[List[int]]:\\n        res = [[r0, c0]]\\n        c_r, c_c = r0, c0  # current row, current column\\n        s, d = 1, 1  # step, direction\\n\\n        while len(res) < R * C:\\n            for _ in range(s):\\n                c_c = c_c + 1 * d\\n                if 0 <= c_r < R and 0 <= c_c < C:\\n                    res.append([c_r, c_c])\\n\\n            for _ in range(s):\\n                c_r = c_r + 1 * d\\n                if 0 <= c_r < R and 0 <= c_c < C:\\n                    res.append([c_r, c_c])\\n\\n            s += 1\\n            d *= -1\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 866874,
                "title": "java-very-simple-concise-and-fast",
                "content": "```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int R, int C, int r0, int c0) {\\n        int[][] result = new int[R*C][2];\\n        \\n        int direction=0;//{0,1,2,3};\\n        int index=0;\\n        int r=r0, c=c0;\\n        int step=0, size=1;\\n        \\n        while(index < R*C){\\n            if(r>=0 && r<=R-1 && c>=0 && c<=C-1){\\n                result[index][0]=r;\\n                result[index][1]=c;\\n                index++;\\n            }\\n\\n            if(direction==0){\\n                c++;\\n            }else if(direction==1)\\n                r++;\\n            else if(direction==2){\\n                c--;\\n            }else if(direction==3)\\n                r--;\\n            \\n            step++; //steps taken on a same direction\\n            if(step == size){\\n                direction= (direction+1) %4;\\n                //only on east and west we increase size.\\n                if(direction==0 || direction ==2)\\n                    size++;\\n                step=0;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int R, int C, int r0, int c0) {\\n        int[][] result = new int[R*C][2];\\n        \\n        int direction=0;//{0,1,2,3};\\n        int index=0;\\n        int r=r0, c=c0;\\n        int step=0, size=1;\\n        \\n        while(index < R*C){\\n            if(r>=0 && r<=R-1 && c>=0 && c<=C-1){\\n                result[index][0]=r;\\n                result[index][1]=c;\\n                index++;\\n            }\\n\\n            if(direction==0){\\n                c++;\\n            }else if(direction==1)\\n                r++;\\n            else if(direction==2){\\n                c--;\\n            }else if(direction==3)\\n                r--;\\n            \\n            step++; //steps taken on a same direction\\n            if(step == size){\\n                direction= (direction+1) %4;\\n                //only on east and west we increase size.\\n                if(direction==0 || direction ==2)\\n                    size++;\\n                step=0;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 848527,
                "title": "95-runtime-50-space-c",
                "content": "\\'\\'\\'\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int R, int C, int r0, int c0) {\\n        \\n        int cnt = 2;\\n        int inc = 1;\\n        vector<vector<int>> fi;\\n        fi.push_back({r0, c0});\\n        while(cnt <= R*C){\\n            for(int i = c0+1; i <= c0 + inc && i < C && (r0 >= 0 && r0 < R); i++){\\n                if(i >= 0){\\n                    cnt++;\\n                    fi.push_back({r0, i});\\n                } \\n\\n            }\\n            c0 = c0+inc;\\n            if(cnt>R*C){\\n                break;\\n            }\\n            \\n            for(int i = r0+1; i <= r0+ inc && i < R && (c0 >= 0 && c0 < C); i++){\\n                if(i >= 0){\\n                    cnt++;\\n                    fi.push_back({i, c0});\\n                }\\n            }\\n            r0 = r0 + inc;\\n            if(cnt>R*C){\\n                break;\\n            }\\n            inc++;\\n            for(int i = c0-1; i >= c0 - inc && i>= 0 && (r0 >= 0 && r0 < R); i--){\\n                if(i < C){\\n                    cnt++;\\n                    fi.push_back({r0, i});\\n                }\\n            }\\n            c0 = c0-inc;\\n            if(cnt>R*C){\\n                break;\\n            }\\n            for(int i = r0-1; i >= r0 - inc && i >= 0 && (c0 >= 0 && c0 < C); i--){\\n                if(i < R) {\\n                    cnt++;\\n                    fi.push_back({i, c0});\\n                }     \\n            }\\n            r0 = r0-inc;\\n            if(cnt > R*C){\\n                break;\\n            }\\n            inc++;\\n        }\\n        return fi;\\n    }\\n};\\n\\'\\'\\'",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int R, int C, int r0, int c0) {\\n        \\n        int cnt = 2;\\n        int inc = 1;\\n        vector<vector<int>> fi;\\n        fi.push_back({r0, c0}",
                "codeTag": "Java"
            },
            {
                "id": 834247,
                "title": "a-python-concise-solution-for-generic-these-problem",
                "content": "`direction` is a generator for right, down, left, up loop. If the direction is horizontal, step + 1.\\n```python\\ndef spiralMatrixIII(self, R: int, C: int, r0: int, c0: int) -> List[List[int]]:\\n    direction = itertools.cycle([(0, 1), (1, 0), (0, -1), (-1, 0)])\\n    ans = [(r0, c0)]\\n    step = 0\\n    while len(ans) < R*C:\\n        di, dj = next(direction)        \\n        if di==0:\\n            step += 1\\n        for _ in range(step):\\n            r0 += di\\n            c0 += dj\\n            if 0<=r0<R and 0<=c0<C:\\n                ans.append((r0, c0))\\n    return ans\\n```",
                "solutionTags": [],
                "code": "```python\\ndef spiralMatrixIII(self, R: int, C: int, r0: int, c0: int) -> List[List[int]]:\\n    direction = itertools.cycle([(0, 1), (1, 0), (0, -1), (-1, 0)])\\n    ans = [(r0, c0)]\\n    step = 0\\n    while len(ans) < R*C:\\n        di, dj = next(direction)        \\n        if di==0:\\n            step += 1\\n        for _ in range(step):\\n            r0 += di\\n            c0 += dj\\n            if 0<=r0<R and 0<=c0<C:\\n                ans.append((r0, c0))\\n    return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 812777,
                "title": "python-easy-simple-solution-91-faster",
                "content": "```\\nclass Solution:\\n    def spiralMatrixIII(self, R: int, C: int, r0: int, c0: int) -> List[List[int]]:\\n        ans = []\\n        len_row, len_col = 0, 2\\n        start_row, start_col= r0, c0\\n        direction = 1\\n        cnt = 0\\n\\n        while cnt < R * C:\\n            curr_row, curr_col = start_row, start_col\\n            for c in range(len_col):\\n                curr_col = start_col + c * direction\\n                if 0 <= start_row < R and 0 <= curr_col < C:\\n                    ans.append([start_row, curr_col])\\n                    cnt += 1\\n\\t\\t\\t\\t\\t\\n            start_col = curr_col\\n            start_row += direction\\n\\n            for r in range(len_row):\\n                curr_row = start_row + r * direction\\n                if 0 <= curr_row < R and 0 <= start_col < C:\\n                    ans.append([curr_row, start_col])\\n                    cnt += 1\\n\\n            len_row += 1\\n            len_col += 1\\n            start_row = curr_row\\n            start_row += direction\\n            direction *= -1\\n        return ans\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def spiralMatrixIII(self, R: int, C: int, r0: int, c0: int) -> List[List[int]]:\\n        ans = []\\n        len_row, len_col = 0, 2\\n        start_row, start_col= r0, c0\\n        direction = 1\\n        cnt = 0\\n\\n        while cnt < R * C:\\n            curr_row, curr_col = start_row, start_col\\n            for c in range(len_col):\\n                curr_col = start_col + c * direction\\n                if 0 <= start_row < R and 0 <= curr_col < C:\\n                    ans.append([start_row, curr_col])\\n                    cnt += 1\\n\\t\\t\\t\\t\\t\\n            start_col = curr_col\\n            start_row += direction\\n\\n            for r in range(len_row):\\n                curr_row = start_row + r * direction\\n                if 0 <= curr_row < R and 0 <= start_col < C:\\n                    ans.append([curr_row, start_col])\\n                    cnt += 1\\n\\n            len_row += 1\\n            len_col += 1\\n            start_row = curr_row\\n            start_row += direction\\n            direction *= -1\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 812019,
                "title": "python-beats-100-simple-solution-with-explanation",
                "content": "**Explanation**\\nThe basic idea behind this question is to increment the number of cells traversed after every column and row operation. So if we can perform these two operations and increment the number of cells it needs to traverse next, we simply reach the solution. \\nIn this solution, I have checked if the number of steps required is odd or even. In case of odd, we need to increase the indices by 1 and decrease by 1 in case of even, i.e., go right or south in case of odd steps and west or north in case of even steps. \\n\\n**Hope this helps!**\\n```\\nclass Solution(object):\\n    def spiralMatrixIII(self, R, C, r0, c0):\\n        \"\"\"\\n        :type R: int\\n        :type C: int\\n        :type r0: int\\n        :type c0: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        out = [[r0,c0]]\\n        steps = 1\\n        \\n        while len(out) == R*C:\\n            rowS = colS = steps\\n            if rowS % 2 == 0:\\n                x = True\\n            else:\\n                x = False\\n                \\n            while colS != 0:\\n                if not x:\\n                    c0 += 1\\n                else:\\n                    c0 -= 1\\n                if 0 <= c0 < C and 0 <= r0 < R:\\n                    out.append([r0,c0])\\n                colS -= 1\\n                \\n            while rowS != 0:\\n                if not x:\\n                    r0 += 1\\n                else:\\n                    r0 -= 1\\n                if 0 <= c0 < C and 0 <= r0 < R:\\n                    out.append([r0,c0])\\n                rowS -= 1\\n            \\n            steps += 1\\n            \\n        return out\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def spiralMatrixIII(self, R, C, r0, c0):\\n        \"\"\"\\n        :type R: int\\n        :type C: int\\n        :type r0: int\\n        :type c0: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        out = [[r0,c0]]\\n        steps = 1\\n        \\n        while len(out) == R*C:\\n            rowS = colS = steps\\n            if rowS % 2 == 0:\\n                x = True\\n            else:\\n                x = False\\n                \\n            while colS != 0:\\n                if not x:\\n                    c0 += 1\\n                else:\\n                    c0 -= 1\\n                if 0 <= c0 < C and 0 <= r0 < R:\\n                    out.append([r0,c0])\\n                colS -= 1\\n                \\n            while rowS != 0:\\n                if not x:\\n                    r0 += 1\\n                else:\\n                    r0 -= 1\\n                if 0 <= c0 < C and 0 <= r0 < R:\\n                    out.append([r0,c0])\\n                rowS -= 1\\n            \\n            steps += 1\\n            \\n        return out\\n```",
                "codeTag": "Java"
            },
            {
                "id": 710300,
                "title": "simple-and-concise-c-solution",
                "content": "<iframe src=\"https://leetcode.com/playground/3psR9eMH/shared\" frameBorder=\"0\" width=\"600\" height=\"650\"></iframe>",
                "solutionTags": [],
                "code": "<iframe src=\"https://leetcode.com/playground/3psR9eMH/shared\" frameBorder=\"0\" width=\"600\" height=\"650\"></iframe>",
                "codeTag": "Unknown"
            },
            {
                "id": 633901,
                "title": "simpleish-js",
                "content": "```\\n\\nvar spiralMatrixIII = function(R, C, r0, c0) {\\n    var totalTile = R * C\\n    var amount    = 1\\n    var output    = [[ r0, c0 ]]\\n    var place     = [ r0, c0 ]\\n    var direction = directions[0]\\n    \\n    while ( output.length < totalTile ) {\\n        walk( place, amount | 0, direction, output, R, C )\\n        amount += .5\\n        direction = directions[ ( directions.indexOf( direction ) + 1 ) % 4 ]\\n    }\\n    \\n    return output\\n}\\n\\nconst directions = [\\n    [ 0, 1 ], // east\\n    [ 1, 0 ], // south\\n    [ 0, -1 ], // west\\n    [ -1, 0 ], // north\\n]\\n    \\nconst walk = ( place, amount, direction, output, R, C ) => {\\n    while ( amount ) {\\n        place[0] += direction[0]\\n        place[1] += direction[1]\\n\\n        if ( isInGrid( place[0], place[1], R, C ) )\\n            output.push([ place[0], place[1] ])\\n        \\n        amount--\\n    }\\n}\\n\\nconst isInGrid = ( r, c, R, C ) => 0 <= r && 0 <= c && r < R && c < C\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\nvar spiralMatrixIII = function(R, C, r0, c0) {\\n    var totalTile = R * C\\n    var amount    = 1\\n    var output    = [[ r0, c0 ]]\\n    var place     = [ r0, c0 ]\\n    var direction = directions[0]\\n    \\n    while ( output.length < totalTile ) {\\n        walk( place, amount | 0, direction, output, R, C )\\n        amount += .5\\n        direction = directions[ ( directions.indexOf( direction ) + 1 ) % 4 ]\\n    }\\n    \\n    return output\\n}\\n\\nconst directions = [\\n    [ 0, 1 ], // east\\n    [ 1, 0 ], // south\\n    [ 0, -1 ], // west\\n    [ -1, 0 ], // north\\n]\\n    \\nconst walk = ( place, amount, direction, output, R, C ) => {\\n    while ( amount ) {\\n        place[0] += direction[0]\\n        place[1] += direction[1]\\n\\n        if ( isInGrid( place[0], place[1], R, C ) )\\n            output.push([ place[0], place[1] ])\\n        \\n        amount--\\n    }\\n}\\n\\nconst isInGrid = ( r, c, R, C ) => 0 <= r && 0 <= c && r < R && c < C\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 584440,
                "title": "simple-python-solution",
                "content": "```\\nclass Solution:\\n    def spiralMatrixIII(self, R: int, C: int, r0: int, c0: int) -> List[List[int]]:\\n        res = []\\n        i = 0\\n        target = R * C\\n        \\n        def in_matrix():\\n            if r0 >= 0 and r0 < R and c0 >= 0 and c0 < C:\\n                return True \\n            return False\\n        while len(res) < target:\\n            i += 1\\n            #move right\\n            for _ in range(i):\\n                if in_matrix():\\n                    res.append([r0, c0])\\n                c0 += 1\\n            \\n            #move down\\n            for _ in range(i):\\n                if in_matrix():\\n                    res.append([r0, c0])\\n                r0 += 1\\n            \\n            i += 1\\n            \\n            #move Left\\n            for _ in range(i):\\n                if in_matrix():\\n                    res.append([r0, c0])\\n                c0 -= 1\\n                \\n            #move up\\n            for _ in range(i):\\n                if in_matrix():\\n                    res.append([r0, c0])\\n                r0 -= 1\\n        return res\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def spiralMatrixIII(self, R: int, C: int, r0: int, c0: int) -> List[List[int]]:\\n        res = []\\n        i = 0\\n        target = R * C\\n        \\n        def in_matrix():\\n            if r0 >= 0 and r0 < R and c0 >= 0 and c0 < C:\\n                return True \\n            return False\\n        while len(res) < target:\\n            i += 1\\n            #move right\\n            for _ in range(i):\\n                if in_matrix():\\n                    res.append([r0, c0])\\n                c0 += 1\\n            \\n            #move down\\n            for _ in range(i):\\n                if in_matrix():\\n                    res.append([r0, c0])\\n                r0 += 1\\n            \\n            i += 1\\n            \\n            #move Left\\n            for _ in range(i):\\n                if in_matrix():\\n                    res.append([r0, c0])\\n                c0 -= 1\\n                \\n            #move up\\n            for _ in range(i):\\n                if in_matrix():\\n                    res.append([r0, c0])\\n                r0 -= 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 513543,
                "title": "simple-java-solution",
                "content": "```java\\nclass Solution {\\n    \\n    int[] dr = new int[] { 0, 1, 0, -1 };\\n    int[] dc = new int[] { 1, 0, -1, 0 };\\n    \\n    public int[][] spiralMatrixIII(int R, int C, int r0, int c0) {\\n        \\n        int x = r0, y = c0;\\n        \\n        int[][] res = new int[R*C][2];\\n        res[0][0] = r0;\\n        res[0][1] = c0;\\n\\n        int count = 1;\\n        int size = 1;\\n        \\n        int dir = 0;\\n        \\n        while (count < R * C) {\\n            \\n            for (int i = 0; i < size; i++) {\\n                x = x + dr[dir];\\n                y = y + dc[dir];\\n\\n                if (0 <= x && x < R && 0 <= y && y < C) {\\n                    res[count][0] = x;\\n                    res[count][1] = y;\\n                    count++;\\n                }\\n            }\\n            \\n            dir = (dir + 1) % 4;;\\n            \\n            for (int i = 0; i < size; i++) {\\n                x = x + dr[dir];\\n                y = y + dc[dir];\\n\\n                if (0 <= x && x < R && 0 <= y && y < C) {\\n                    res[count][0] = x;\\n                    res[count][1] = y;\\n                    count++;\\n                }\\n            }\\n            \\n            dir = (dir + 1) % 4;\\n            size++;\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    \\n    int[] dr = new int[] { 0, 1, 0, -1 };\\n    int[] dc = new int[] { 1, 0, -1, 0 };\\n    \\n    public int[][] spiralMatrixIII(int R, int C, int r0, int c0) {\\n        \\n        int x = r0, y = c0;\\n        \\n        int[][] res = new int[R*C][2];\\n        res[0][0] = r0;\\n        res[0][1] = c0;\\n\\n        int count = 1;\\n        int size = 1;\\n        \\n        int dir = 0;\\n        \\n        while (count < R * C) {\\n            \\n            for (int i = 0; i < size; i++) {\\n                x = x + dr[dir];\\n                y = y + dc[dir];\\n\\n                if (0 <= x && x < R && 0 <= y && y < C) {\\n                    res[count][0] = x;\\n                    res[count][1] = y;\\n                    count++;\\n                }\\n            }\\n            \\n            dir = (dir + 1) % 4;;\\n            \\n            for (int i = 0; i < size; i++) {\\n                x = x + dr[dir];\\n                y = y + dc[dir];\\n\\n                if (0 <= x && x < R && 0 <= y && y < C) {\\n                    res[count][0] = x;\\n                    res[count][1] = y;\\n                    count++;\\n                }\\n            }\\n            \\n            dir = (dir + 1) % 4;\\n            size++;\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 501338,
                "title": "python-detailed-explanation-easy-to-understand",
                "content": "Let\\'s assume the board is infinite (then we don\\'t need to care about the case of moving out of boundary, we can add restrictions back later), if the current position is ```(i,j)```, the moves are:\\n```\\ni,j\\ni,j-1\\ni+1,j+1\\ni+1,j\\ni+1,j-1\\ni,j-1\\ni-1,j-1\\n------ (first round ends)\\ni-1,j\\ni-1,j+1\\ni-1,j+2\\ni,j+2\\ni-1,j+2\\n...\\n```\\nLet\\'s make a cut each time when we move to ```(i-k, j-k), k=1,2,3...``` and call it a round, then we\\'ll find the following pattern in each round(```R``` means ```move right```, ```L``` means ```move left```, ```U``` means ```move up```, ```D``` means ```move down```):\\n```\\nfirst round: RDLLUUR\\nsecond round: RRDDDLLLLUUUURR\\nthird round: RRRDDDDDLLLLLLUUUUUURRR\\n```\\nAs you can see:\\nthe number of R: 1 2 3......\\nthe number of D: 1 3 5......\\nthe number of L:  2 4 6......\\nthe number of U: 2 4 6......\\nthe number of R: 1 2 3......\\nThe pattern is quite clear now, from the above observation, we can use 5 counters to count RDLUR, and update positions in five for-loops, update rules:\\n```\\ncnt1+=1\\ncnt2+=2\\ncnt3+=2\\ncnt4+=2\\ncnt5+=1\\n```\\nbecause so far our board is infinite, now we also need to consider the restriction for a legal step, it\\'s simple:\\n```\\n0 <= cur_x < R and 0 <= cur_y < C\\n```\\nBased on the code above, we have the code below:\\n```\\nclass Solution(object):\\n    def spiralMatrixIII(self, R, C, r0, c0):\\n        def isGood(x, y):\\n            return 0 <= x < R and 0 <= y < C\\n        \\n        ans = [[r0, c0]]\\n        cnt1 = 1  # R\\n        cnt2 = 1  # D\\n        cnt3 = 2  # L\\n        cnt4 = 2  # U\\n        cnt5 = 1  # R\\n        nx, ny = r0, c0\\n        while len(ans) != R*C:\\n            for i in range(cnt1):\\n                nx, ny = nx, ny+1\\n                if isGood(nx, ny):\\n                    ans.append([nx, ny])\\n            for i in range(cnt2):\\n                nx, ny = nx+1, ny\\n                if isGood(nx, ny):\\n                    ans.append([nx, ny])\\n            for i in range(cnt3):\\n                nx, ny = nx, ny-1\\n                if isGood(nx, ny):\\n                    ans.append([nx, ny])\\n            for i in range(cnt4):\\n                nx, ny = nx-1, ny\\n                if isGood(nx, ny):\\n                    ans.append([nx, ny])\\n            for i in range(cnt5):\\n                nx, ny = nx, ny+1\\n                if isGood(nx, ny):\\n                    ans.append([nx, ny])\\n            cnt1+=1\\n            cnt2+=2\\n            cnt3+=2\\n            cnt4+=2\\n            cnt5+=1\\n            \\n        return ans\\n```\\nNot elegant, but easy enough to understand.",
                "solutionTags": [],
                "code": "```(i,j)```\n```\\ni,j\\ni,j-1\\ni+1,j+1\\ni+1,j\\ni+1,j-1\\ni,j-1\\ni-1,j-1\\n------ (first round ends)\\ni-1,j\\ni-1,j+1\\ni-1,j+2\\ni,j+2\\ni-1,j+2\\n...\\n```\n```(i-k, j-k), k=1,2,3...```\n```R```\n```move right```\n```L```\n```move left```\n```U```\n```move up```\n```D```\n```move down```\n```\\nfirst round: RDLLUUR\\nsecond round: RRDDDLLLLUUUURR\\nthird round: RRRDDDDDLLLLLLUUUUUURRR\\n```\n```\\ncnt1+=1\\ncnt2+=2\\ncnt3+=2\\ncnt4+=2\\ncnt5+=1\\n```\n```\\n0 <= cur_x < R and 0 <= cur_y < C\\n```\n```\\nclass Solution(object):\\n    def spiralMatrixIII(self, R, C, r0, c0):\\n        def isGood(x, y):\\n            return 0 <= x < R and 0 <= y < C\\n        \\n        ans = [[r0, c0]]\\n        cnt1 = 1  # R\\n        cnt2 = 1  # D\\n        cnt3 = 2  # L\\n        cnt4 = 2  # U\\n        cnt5 = 1  # R\\n        nx, ny = r0, c0\\n        while len(ans) != R*C:\\n            for i in range(cnt1):\\n                nx, ny = nx, ny+1\\n                if isGood(nx, ny):\\n                    ans.append([nx, ny])\\n            for i in range(cnt2):\\n                nx, ny = nx+1, ny\\n                if isGood(nx, ny):\\n                    ans.append([nx, ny])\\n            for i in range(cnt3):\\n                nx, ny = nx, ny-1\\n                if isGood(nx, ny):\\n                    ans.append([nx, ny])\\n            for i in range(cnt4):\\n                nx, ny = nx-1, ny\\n                if isGood(nx, ny):\\n                    ans.append([nx, ny])\\n            for i in range(cnt5):\\n                nx, ny = nx, ny+1\\n                if isGood(nx, ny):\\n                    ans.append([nx, ny])\\n            cnt1+=1\\n            cnt2+=2\\n            cnt3+=2\\n            cnt4+=2\\n            cnt5+=1\\n            \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 479084,
                "title": "python-concise-solution-beats-100-run-time-and-memory",
                "content": "```\\nclass Solution:\\n    def spiralMatrixIII(self, R: int, C: int, r0: int, c0: int) -> List[List[int]]:\\n        out=[[r0,c0]]\\n        rn,cn=r0,c0\\n        step=1\\n        while len(out)!=R*C:                \\n            direction = ((-1)**(step-1))\\n            if rn<R and rn>-1:             \\n                for c in range(step): \\n                    cn += direction \\n                    if cn<C and cn>-1:\\n                        out.append([rn,cn])\\n            else:                          \\n                cn+= direction*step\\n            if cn<C and cn>-1:              \\n                for c in range(step):\\n                    rn += direction\\n                    if rn<R and rn>-1:\\n                        out.append([rn,cn])\\n            else:                          \\n                rn += direction*step\\n            step+=1\\n        return out \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def spiralMatrixIII(self, R: int, C: int, r0: int, c0: int) -> List[List[int]]:\\n        out=[[r0,c0]]\\n        rn,cn=r0,c0\\n        step=1\\n        while len(out)!=R*C:                \\n            direction = ((-1)**(step-1))\\n            if rn<R and rn>-1:             \\n                for c in range(step): \\n                    cn += direction \\n                    if cn<C and cn>-1:\\n                        out.append([rn,cn])\\n            else:                          \\n                cn+= direction*step\\n            if cn<C and cn>-1:              \\n                for c in range(step):\\n                    rn += direction\\n                    if rn<R and rn>-1:\\n                        out.append([rn,cn])\\n            else:                          \\n                rn += direction*step\\n            step+=1\\n        return out \\n```",
                "codeTag": "Java"
            },
            {
                "id": 384657,
                "title": "java-clean-solution-step-by-step-with-explanation",
                "content": "```\\nclass Solution {\\n    /*  Time Complexity: the worse condition is when the starting point\\n        is in the south-east corner of the grid, which requires the function\\n        to traveal through (2max(R,C)) ^ 2 points thus the TM would be \\n        O((max(R, C)^2)). Space complexity would be O(R*C)*/\\n    \\n    public int[][] spiralMatrixIII(int R, int C, int r0, int c0) {\\n        // direction: right, down, left, up\\n        int[] dirRow = new int[]{0, 1, 0, -1};\\n        int[] dirCol = new int[]{1, 0, -1, 0};\\n        \\n        int[][] result = new int[R*C][2];\\n        result[0] = new int[]{r0, c0};\\n        // use count to keep track of number of nodes that have been found\\n        // use k to keep track of direction and steps\\n        int count = 1, k = 1;\\n        \\n        while (count != R*C) {\\n            // get direction\\n            int dir = (k - 1) % 4;\\n            // get number of steps\\n            int step = k % 2 == 0 ? k / 2 : (k + 1) / 2;\\n            \\n            // move in this direction\\n            for (int i = 0; i < step; i++) {\\n                r0 += dirRow[dir];\\n                c0 += dirCol[dir];\\n                // check for the bound, if within the bound\\n                // then add them into the result array\\n                if (r0 < R && c0 < C && r0 >= 0 && c0 >= 0) {\\n                    result[count] = new int[]{r0, c0};\\n                    count++;\\n                }\\n            }\\n            k++;\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    /*  Time Complexity: the worse condition is when the starting point\\n        is in the south-east corner of the grid, which requires the function\\n        to traveal through (2max(R,C)) ^ 2 points thus the TM would be \\n        O((max(R, C)^2)). Space complexity would be O(R*C)*/\\n    \\n    public int[][] spiralMatrixIII(int R, int C, int r0, int c0) {\\n        // direction: right, down, left, up\\n        int[] dirRow = new int[]{0, 1, 0, -1};\\n        int[] dirCol = new int[]{1, 0, -1, 0};\\n        \\n        int[][] result = new int[R*C][2];\\n        result[0] = new int[]{r0, c0};\\n        // use count to keep track of number of nodes that have been found\\n        // use k to keep track of direction and steps\\n        int count = 1, k = 1;\\n        \\n        while (count != R*C) {\\n            // get direction\\n            int dir = (k - 1) % 4;\\n            // get number of steps\\n            int step = k % 2 == 0 ? k / 2 : (k + 1) / 2;\\n            \\n            // move in this direction\\n            for (int i = 0; i < step; i++) {\\n                r0 += dirRow[dir];\\n                c0 += dirCol[dir];\\n                // check for the bound, if within the bound\\n                // then add them into the result array\\n                if (r0 < R && c0 < C && r0 >= 0 && c0 >= 0) {\\n                    result[count] = new int[]{r0, c0};\\n                    count++;\\n                }\\n            }\\n            k++;\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 383209,
                "title": "simple-java-solution",
                "content": "```\\n    //Steps : 1,1,2,2,3,3,4,4...(increase step by 1 when turn east or west)\\n    public int[][] spiralMatrixIII(int R, int C, int x, int y) {\\n        int[][] res = new int[R * C][2];\\n        int[][] dirs = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}}; //east, south, west, north\\n        int steps = 0, dir = 0, count = 0;\\n        res[0] = new int[]{x, y};\\n        count++;\\n        while (count < R * C) {\\n            if (dir == 0 || dir == 2)\\n                steps++;\\n            for (int i = 0; i < steps; i++) {\\n                x += dirs[dir][0];\\n                y += dirs[dir][1];\\n                if (x >= 0 && x < R && y >= 0 && y < C) {\\n                    res[count++] = new int[]{x, y};\\n                }\\n            }\\n            dir = (dir + 1) % 4;\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    //Steps : 1,1,2,2,3,3,4,4...(increase step by 1 when turn east or west)\\n    public int[][] spiralMatrixIII(int R, int C, int x, int y) {\\n        int[][] res = new int[R * C][2];\\n        int[][] dirs = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}}; //east, south, west, north\\n        int steps = 0, dir = 0, count = 0;\\n        res[0] = new int[]{x, y};\\n        count++;\\n        while (count < R * C) {\\n            if (dir == 0 || dir == 2)\\n                steps++;\\n            for (int i = 0; i < steps; i++) {\\n                x += dirs[dir][0];\\n                y += dirs[dir][1];\\n                if (x >= 0 && x < R && y >= 0 && y < C) {\\n                    res[count++] = new int[]{x, y};\\n                }\\n            }\\n            dir = (dir + 1) % 4;\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 267308,
                "title": "c",
                "content": "```\\npublic class Solution {\\n    public int[][] SpiralMatrixIII(int R, int C, int r0, int c0) {\\n        var res = new int[R * C][];\\n\\n        int cur = 0, len = 1;\\n\\n        while (cur < R * C)\\n        {\\n            for (var i = c0; i < c0 + len; i++) if (i >= 0 && i < C && r0 >= 0 && r0 < R) res[cur++] = new[] { r0, i };\\n\\n            c0 += len;\\n\\n            for (var i = r0; i < r0 + len; i++) if (c0 < C && c0 >= 0 && i >= 0 && i < R) res[cur++] = new[] { i, c0 };\\n\\n            r0 += len++;\\n\\n            for (var i = c0; i > c0 - len; i--) if (r0 < R && r0 >= 0 && i >= 0 && i < C) res[cur++] = new[] { r0, i };\\n\\n            c0 -= len;\\n\\n            for (var i = r0; i > r0 - len; i--) if (i >= 0 && i < R && c0 >= 0 && c0 < C) res[cur++] = new[] { i, c0 };\\n\\n            r0 -= len++;\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int[][] SpiralMatrixIII(int R, int C, int r0, int c0) {\\n        var res = new int[R * C][];\\n\\n        int cur = 0, len = 1;\\n\\n        while (cur < R * C)\\n        {\\n            for (var i = c0; i < c0 + len; i++) if (i >= 0 && i < C && r0 >= 0 && r0 < R) res[cur++] = new[] { r0, i };\\n\\n            c0 += len;\\n\\n            for (var i = r0; i < r0 + len; i++) if (c0 < C && c0 >= 0 && i >= 0 && i < R) res[cur++] = new[] { i, c0 };\\n\\n            r0 += len++;\\n\\n            for (var i = c0; i > c0 - len; i--) if (r0 < R && r0 >= 0 && i >= 0 && i < C) res[cur++] = new[] { r0, i };\\n\\n            c0 -= len;\\n\\n            for (var i = r0; i > r0 - len; i--) if (i >= 0 && i < R && c0 >= 0 && c0 < C) res[cur++] = new[] { i, c0 };\\n\\n            r0 -= len++;\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 260748,
                "title": "javascript-solution-with-comments-beats-100",
                "content": "```\\n/**\\n * @param {number} R\\n * @param {number} C\\n * @param {number} r0\\n * @param {number} c0\\n * @return {number[][]}\\n */\\nvar spiralMatrixIII = function(R, C, r0, c0) {\\n    // Set start space.\\n    let r = r0;\\n    let c = c0;\\n    let startSpace = [r, c];\\n    \\n    // Define possible diredctions, start from index = 0.\\n    const directions = [\\'+c\\', \\'+r\\', \\'-c\\', \\'-r\\'];\\n    let directionIndex = 0;\\n    \\n    // Add startSpace to the result array.\\n    const result = [startSpace];\\n    \\n    // Mark the start space as parsed and start from spiral shape with length = 2.\\n    let parsedSpaces = 1;\\n    let spiralLength = 2;\\n    \\n    // Define helper method for setting the next direction.\\n    const changeDirection = () => {\\n        directionIndex = directionIndex + 1 > 3 ? 0 : directionIndex + 1;\\n    }\\n    \\n    // Iterate until all R * C spaces of the grid are parsed.\\n    while (result.length < R * C) {\\n        // Calculate the amount of spaces in the next spiral shape.\\n        const areaOfSpiralShape = spiralLength ** 2;\\n        \\n        // Iterate until all spaces of the current spiral shape are parsed.\\n        while (parsedSpaces <= areaOfSpiralShape) {\\n            const isLastSpace = parsedSpaces === areaOfSpiralShape - 1;\\n            \\n            // 1. Go to the next space by incrementing/decrementing c/r according to direction.\\n            // 2. Check if a wall of the current spiral shape is reached.\\n            // 3. Change direction if the wall is reached.\\n            // 4. Exception: leave the current direction if the last space of spiral is reached.\\n            switch (directions[directionIndex]) {\\n                case \\'+c\\':\\n                    c++;\\n                    if (!isLastSpace && c + 1 >= startSpace[1] + spiralLength) {\\n                        changeDirection();\\n                    }\\n                    break;\\n                case \\'-c\\':\\n                    c--;\\n                    if (!isLastSpace && c - 1 <= startSpace[1] - spiralLength) {\\n                        changeDirection();\\n                    }\\n                    break;\\n                case \\'+r\\':\\n                    r++;\\n                    if (!isLastSpace && r + 1 >= startSpace[0] + spiralLength) {\\n                        changeDirection();\\n                    }\\n                    break;\\n                case \\'-r\\': \\n                    r--;\\n                    if (!isLastSpace && r - 1 <= startSpace[0] - spiralLength) {\\n                        changeDirection();\\n                    }\\n                    break;\\n            }\\n            \\n            // Add to result in case [r, c] is within R*C grid.\\n            if (c >= 0 && c < C && r >= 0 && r < R) {\\n                result.push([r, c]);\\n            }\\n            parsedSpaces++;\\n        }\\n        \\n        // Set the start space of the next spiral.\\n        startSpace = [r, c];\\n        spiralLength++;\\n    }\\n    \\n    return result;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number} R\\n * @param {number} C\\n * @param {number} r0\\n * @param {number} c0\\n * @return {number[][]}\\n */\\nvar spiralMatrixIII = function(R, C, r0, c0) {\\n    // Set start space.\\n    let r = r0;\\n    let c = c0;\\n    let startSpace = [r, c];\\n    \\n    // Define possible diredctions, start from index = 0.\\n    const directions = [\\'+c\\', \\'+r\\', \\'-c\\', \\'-r\\'];\\n    let directionIndex = 0;\\n    \\n    // Add startSpace to the result array.\\n    const result = [startSpace];\\n    \\n    // Mark the start space as parsed and start from spiral shape with length = 2.\\n    let parsedSpaces = 1;\\n    let spiralLength = 2;\\n    \\n    // Define helper method for setting the next direction.\\n    const changeDirection = () => {\\n        directionIndex = directionIndex + 1 > 3 ? 0 : directionIndex + 1;\\n    }\\n    \\n    // Iterate until all R * C spaces of the grid are parsed.\\n    while (result.length < R * C) {\\n        // Calculate the amount of spaces in the next spiral shape.\\n        const areaOfSpiralShape = spiralLength ** 2;\\n        \\n        // Iterate until all spaces of the current spiral shape are parsed.\\n        while (parsedSpaces <= areaOfSpiralShape) {\\n            const isLastSpace = parsedSpaces === areaOfSpiralShape - 1;\\n            \\n            // 1. Go to the next space by incrementing/decrementing c/r according to direction.\\n            // 2. Check if a wall of the current spiral shape is reached.\\n            // 3. Change direction if the wall is reached.\\n            // 4. Exception: leave the current direction if the last space of spiral is reached.\\n            switch (directions[directionIndex]) {\\n                case \\'+c\\':\\n                    c++;\\n                    if (!isLastSpace && c + 1 >= startSpace[1] + spiralLength) {\\n                        changeDirection();\\n                    }\\n                    break;\\n                case \\'-c\\':\\n                    c--;\\n                    if (!isLastSpace && c - 1 <= startSpace[1] - spiralLength) {\\n                        changeDirection();\\n                    }\\n                    break;\\n                case \\'+r\\':\\n                    r++;\\n                    if (!isLastSpace && r + 1 >= startSpace[0] + spiralLength) {\\n                        changeDirection();\\n                    }\\n                    break;\\n                case \\'-r\\': \\n                    r--;\\n                    if (!isLastSpace && r - 1 <= startSpace[0] - spiralLength) {\\n                        changeDirection();\\n                    }\\n                    break;\\n            }\\n            \\n            // Add to result in case [r, c] is within R*C grid.\\n            if (c >= 0 && c < C && r >= 0 && r < R) {\\n                result.push([r, c]);\\n            }\\n            parsedSpaces++;\\n        }\\n        \\n        // Set the start space of the next spiral.\\n        startSpace = [r, c];\\n        spiralLength++;\\n    }\\n    \\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 220530,
                "title": "python-real-o-r-c-solution-skipping-paths-outside-the-grid-beats-100",
                "content": "Here is the solution that skips rows and columns outside of the grid in O(1) instead of traversing them and checking if every cell is valid like most other solutions do (which yields them O(max(R,C)^2) time complexity which is apparent if you try a case like `1000 1 0 0`\\n\\nWhen I use `timeit` on my function with arguments `30000, 1, 0, 0` my algorithm takes less than 0.05 seconds on my machine, compared to admin provided solution which given exactly the same input takes around 238 seconds to complete (~4 minutes). And it grows really really fast after that, whereas my solution can process input `1000000, 1, 0, 0` in 1.5 seconds.\\n\\n```python \\nclass Solution:\\n    def spiralMatrixIII(self, R, C, r0, c0):\\n        \"\"\"\\n        :type R: int\\n        :type C: int\\n        :type r0: int\\n        :type c0: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        dirs = [[0, 1], [1, 0], [0, -1], [-1, 0]]\\n        d = 0\\n        steps = 0\\n        ans = [[r0, c0]]\\n        \\n        total = R*C\\n        while len(ans) < total:\\n            d = d % 4\\n            if d % 2 == 0:\\n                steps += 1\\n            steps_left = steps\\n            while steps_left:\\n                r0 = r0 + dirs[d][0]\\n                c0 = c0 + dirs[d][1]\\n                steps_left -= 1\\n                if r0 >= 0 and r0 < R and c0 >= 0 and c0 < C:\\n                    ans.append([r0, c0])\\n                elif steps_left:\\n                    if d == 0:\\n                        if c0 < 0 and r0 >= 0:\\n                            steps_left += c0 + 1\\n                            c0 = -1\\n                        else:\\n                            c0 += steps_left\\n                            steps_left = 0\\n                    elif d == 1:\\n                        if r0 < 0 and c0 < C:\\n                            steps_left += r0 + 1\\n                            r0 = -1\\n                        else:\\n                            r0 += steps_left\\n                            steps_left = 0\\n                    elif d == 2:\\n                        if c0 >= C and r0 < R:\\n                            steps_left -= c0 - C\\n                            c0 = C\\n                        else:\\n                            c0 -= steps_left\\n                            steps_left = 0\\n                    else:\\n                        if r0 >= R and c0 >= 0:\\n                            steps_left -= r0 - R\\n                            r0 = R\\n                        else:\\n                            r0 -= steps_left\\n                            steps_left = 0\\n            d += 1\\n        return ans",
                "solutionTags": [],
                "code": "Here is the solution that skips rows and columns outside of the grid in O(1) instead of traversing them and checking if every cell is valid like most other solutions do (which yields them O(max(R,C)^2) time complexity which is apparent if you try a case like `1000 1 0 0`\\n\\nWhen I use `timeit` on my function with arguments `30000, 1, 0, 0` my algorithm takes less than 0.05 seconds on my machine, compared to admin provided solution which given exactly the same input takes around 238 seconds to complete (~4 minutes). And it grows really really fast after that, whereas my solution can process input `1000000, 1, 0, 0` in 1.5 seconds.\\n\\n```python \\nclass Solution:\\n    def spiralMatrixIII(self, R, C, r0, c0):\\n        \"\"\"\\n        :type R: int\\n        :type C: int\\n        :type r0: int\\n        :type c0: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        dirs = [[0, 1], [1, 0], [0, -1], [-1, 0]]\\n        d = 0\\n        steps = 0\\n        ans = [[r0, c0]]\\n        \\n        total = R*C\\n        while len(ans) < total:\\n            d = d % 4\\n            if d % 2 == 0:\\n                steps += 1\\n            steps_left = steps\\n            while steps_left:\\n                r0 = r0 + dirs[d][0]\\n                c0 = c0 + dirs[d][1]\\n                steps_left -= 1\\n                if r0 >= 0 and r0 < R and c0 >= 0 and c0 < C:\\n                    ans.append([r0, c0])\\n                elif steps_left:\\n                    if d == 0:\\n                        if c0 < 0 and r0 >= 0:\\n                            steps_left += c0 + 1\\n                            c0 = -1\\n                        else:\\n                            c0 += steps_left\\n                            steps_left = 0\\n                    elif d == 1:\\n                        if r0 < 0 and c0 < C:\\n                            steps_left += r0 + 1\\n                            r0 = -1\\n                        else:\\n                            r0 += steps_left\\n                            steps_left = 0\\n                    elif d == 2:\\n                        if c0 >= C and r0 < R:\\n                            steps_left -= c0 - C\\n                            c0 = C\\n                        else:\\n                            c0 -= steps_left\\n                            steps_left = 0\\n                    else:\\n                        if r0 >= R and c0 >= 0:\\n                            steps_left -= r0 - R\\n                            r0 = R\\n                        else:\\n                            r0 -= steps_left\\n                            steps_left = 0\\n            d += 1\\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 219801,
                "title": "c-straightforward-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int R, int C, int r0, int c0) {\\n        int limit=R*C,size=1,direction=0,counter=1,num=2;\\n        vector<vector<int>> res={{r0,c0}};\\n        while(size<limit)\\n        {\\n            switch(direction)\\n            {   case 0:c0++;break;\\n                case 1:r0++;break;\\n                case 2:c0--;break;\\n                case 3:r0--;break;  }  \\n            if(r0>-1&&c0>-1&&r0<R&&c0<C) res.push_back({r0,c0}),size++;\\n            if((--counter)==0) counter=(++num)/2,direction=(direction+1)%4;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int R, int C, int r0, int c0) {\\n        int limit=R*C,size=1,direction=0,counter=1,num=2;\\n        vector<vector<int>> res={{r0,c0}};\\n        while(size<limit)\\n        {\\n            switch(direction)\\n            {   case 0:c0++;break;\\n                case 1:r0++;break;\\n                case 2:c0--;break;\\n                case 3:r0--;break;  }  \\n            if(r0>-1&&c0>-1&&r0<R&&c0<C) res.push_back({r0,c0}),size++;\\n            if((--counter)==0) counter=(++num)/2,direction=(direction+1)%4;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 159580,
                "title": "simple-python3-solution-with-video-explanation",
                "content": "Video Link: https://www.youtube.com/watch?v=zG05E85u1s0\\n\\n```\\nclass Solution:\\n  def spiralMatrixIII(self, R, C, r0, c0):\\n    \"\"\"\\n    :type R: int\\n    :type C: int\\n    :type r0: int\\n    :type c0: int\\n    :rtype: List[List[int]]\\n    \"\"\"\\n\\n    dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]\\n    dir_idx = 0\\n    total = R*C\\n    steps = 1\\n    increment = 1\\n    result = [[r0, c0]]\\n\\n    while len(result) < total:\\n      for i in range(increment):\\n        r0, c0 = r0 + dirs[dir_idx][0], c0 + dirs[dir_idx][1]\\n        if r0 >= 0 and r0 < R and c0 >= 0 and c0 < C:\\n          result.append([r0, c0])\\n      \\n      dir_idx = (dir_idx + 1) % 4\\n      if steps % 2 == 0:\\n        increment += 1\\n      steps += 1\\n    \\n    return result\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n  def spiralMatrixIII(self, R, C, r0, c0):\\n    \"\"\"\\n    :type R: int\\n    :type C: int\\n    :type r0: int\\n    :type c0: int\\n    :rtype: List[List[int]]\\n    \"\"\"\\n\\n    dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]\\n    dir_idx = 0\\n    total = R*C\\n    steps = 1\\n    increment = 1\\n    result = [[r0, c0]]\\n\\n    while len(result) < total:\\n      for i in range(increment):\\n        r0, c0 = r0 + dirs[dir_idx][0], c0 + dirs[dir_idx][1]\\n        if r0 >= 0 and r0 < R and c0 >= 0 and c0 < C:\\n          result.append([r0, c0])\\n      \\n      dir_idx = (dir_idx + 1) % 4\\n      if steps % 2 == 0:\\n        increment += 1\\n      steps += 1\\n    \\n    return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 159112,
                "title": "short-java-solution",
                "content": "```\\n    public int[][] spiralMatrixIII(int R, int C, int r0, int c0) {\\n        int[][] res = new int[R * C][2], dirs = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\\n        boolean[][] v = new boolean[R][C];\\n        int x = r0, y = c0, count = 0, dir = 0;\\n        \\n        while (count < R * C) {\\n            if(x >= 0 && x < R && y >=0 && y < C) {\\n                res[count][0] = x;\\n                res[count][1] = y;\\n                v[x][y] = true;\\n                count++;\\n            }\\n            x += dirs[dir][0];\\n            y += dirs[dir][1];\\n            \\n            dir = (dir + 1)%4;\\n            \\n            //one more step to check if we should change dir\\n            int xx = x + dirs[dir][0];\\n            int yy = y + dirs[dir][1];\\n            if(xx >= 0 && xx < R && yy >=0 && yy < C && v[xx][yy]) dir = (dir + 4 - 1)%4;\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int[][] spiralMatrixIII(int R, int C, int r0, int c0) {\\n        int[][] res = new int[R * C][2], dirs = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\\n        boolean[][] v = new boolean[R][C];\\n        int x = r0, y = c0, count = 0, dir = 0;\\n        \\n        while (count < R * C) {\\n            if(x >= 0 && x < R && y >=0 && y < C) {\\n                res[count][0] = x;\\n                res[count][1] = y;\\n                v[x][y] = true;\\n                count++;\\n            }\\n            x += dirs[dir][0];\\n            y += dirs[dir][1];\\n            \\n            dir = (dir + 1)%4;\\n            \\n            //one more step to check if we should change dir\\n            int xx = x + dirs[dir][0];\\n            int yy = y + dirs[dir][1];\\n            if(xx >= 0 && xx < R && yy >=0 && yy < C && v[xx][yy]) dir = (dir + 4 - 1)%4;\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 158983,
                "title": "python-iterative-solution",
                "content": "```\\nclass Solution:\\n    def spiralMatrixIII(self, R, C, r0, c0):\\n        direct, res, n, l, ind = [(-1, 0), (0, 1), (1, 0), (0, -1)], [[r0, c0]], R * C, 1, 1\\n        while len(res) < n:\\n            for __ in range(2):\\n                for _ in range(l):\\n                    r0 += direct[ind][0]\\n                    c0 += direct[ind][1]\\n                    if 0 <= r0 < R and 0 <= c0 < C:\\n                        res.append([r0, c0])\\n                ind = (ind + 1) % 4\\n            l += 1\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def spiralMatrixIII(self, R, C, r0, c0):\\n        direct, res, n, l, ind = [(-1, 0), (0, 1), (1, 0), (0, -1)], [[r0, c0]], R * C, 1, 1\\n        while len(res) < n:\\n            for __ in range(2):\\n                for _ in range(l):\\n                    r0 += direct[ind][0]\\n                    c0 += direct[ind][1]\\n                    if 0 <= r0 < R and 0 <= c0 < C:\\n                        res.append([r0, c0])\\n                ind = (ind + 1) % 4\\n            l += 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 158975,
                "title": "brute-force",
                "content": "high level idea is quite simple: we simulate the circle. If we change direction twice, we add 1 to our step.\\n\\n\\tclass Solution {\\n    public int[][] spiralMatrixIII(int R, int C, int r0, int c0) {\\n        int[][] result = new int[R * C][2];\\n        int direction = 0; //0\\n        int step = 1;\\n        int index = 1;\\n        int flag = 0;\\n        \\n        result[0][0] = r0;\\n        result[0][1] = c0;\\n        int x = r0;\\n        int y = c0;\\n        \\n        while(index < R * C) {\\n            for(int i = 0; i < step; i++) {\\n                switch(direction) {\\n                    case 0 :\\n                        y = y+ 1;\\n                        break;\\n                    case 1:\\n                        x = x + 1;\\n                        break;\\n                    case 2:\\n                        y = y- 1;\\n                        break;\\n                    case 3:\\n                        x = x - 1;\\n                        break;\\n                }\\n                \\n                if(isValid(R, C, x, y)) {\\n                    if(index >= R * C) {\\n                        return result;\\n                    }\\n                    \\n                    result[index][0] = x;\\n                    result[index++][1] = y;\\n                }\\n                \\n            }\\n            direction++;\\n            direction = direction % 4;\\n            \\n            if(flag == 1) {\\n                step++;\\n                \\n            }\\n            flag = (flag + 1) % 2;\\n            \\n        }\\n        return result;     \\n    }\\n    \\n    private boolean isValid(int R, int C, int x, int y) {\\n        return x >= 0 && x < R && y >= 0 && y < C;\\n    }}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[][] spiralMatrixIII(int R, int C, int r0, int c0) {\\n        int[][] result = new int[R * C][2];\\n        int direction = 0; //0\\n        int step = 1;\\n        int index = 1;\\n        int flag = 0;\\n        \\n        result[0][0] = r0;\\n        result[0][1] = c0;\\n        int x = r0;\\n        int y = c0;\\n        \\n        while(index < R * C) {\\n            for(int i = 0; i < step; i++) {\\n                switch(direction) {\\n                    case 0 :\\n                        y = y+ 1;\\n                        break;\\n                    case 1:\\n                        x = x + 1;\\n                        break;\\n                    case 2:\\n                        y = y- 1;\\n                        break;\\n                    case 3:\\n                        x = x - 1;\\n                        break;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 158968,
                "title": "concise-java-solution",
                "content": "```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int R, int C, int r0, int c0) {\\n        if (R == 0 || C == 0) return new int[0][0];\\n        int[][] res = new int[R * C][2];\\n        int[][] dirs = {{ 0, 1 }, {1, 0 }, {0, -1}, {-1, 0}};\\n        int p = 0; //current pointing direction: 0, 1, 2, 3\\n        int[] steps = {1, 1}; //steps to move along c and r direction\\n        int r = r0, c = c0;\\n        res[0] = new int[] {r0, c0};\\n        int i = 1;\\n        while (i < R * C) {\\n            for (int j = 0; j < steps[p % 2]; j++) {\\n                int[] dir = dirs[p];\\n                r += dir[0];\\n                c += dir[1];\\n                if (r >= 0 && r < R && c >= 0 && c < C) {\\n                    res[i++] = new int[] {r, c};\\n                }\\n            }\\n            steps[p % 2]++;\\n            p = (p + 1) % 4;\\n        }\\n        return res; \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[][] spiralMatrixIII(int R, int C, int r0, int c0) {\\n        if (R == 0 || C == 0) return new int[0][0];\\n        int[][] res = new int[R * C][2];\\n        int[][] dirs = {{ 0, 1 }",
                "codeTag": "Java"
            },
            {
                "id": 158962,
                "title": "concise-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int R, int C, int r0, int c0) {\\n        int total = R*C;\\n        int dx[4] = { 0 , 1, 0, -1};\\n        int dy[4] = { 1 , 0, -1, 0};\\n        int cnt = 0;\\n        vector<vector<int> > ans;\\n        ans.push_back({r0, c0});\\n        while(total > ans.size() ){\\n            int step = cnt/2+1;\\n            for( int i = 1; i<=step;i++){\\n                r0 += dx[cnt%4];\\n                c0 += dy[cnt%4];\\n                if( r0 >= 0 && c0 >= 0 && r0 < R && c0 <C )\\n                    ans.push_back({r0,c0});\\n            }\\n            cnt++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int R, int C, int r0, int c0) {\\n        int total = R*C;\\n        int dx[4] = { 0 , 1, 0, -1};\\n        int dy[4] = { 1 , 0, -1, 0};\\n        int cnt = 0;\\n        vector<vector<int> > ans;\\n        ans.push_back({r0, c0});\\n        while(total > ans.size() ){\\n            int step = cnt/2+1;\\n            for( int i = 1; i<=step;i++){\\n                r0 += dx[cnt%4];\\n                c0 += dy[cnt%4];\\n                if( r0 >= 0 && c0 >= 0 && r0 < R && c0 <C )\\n                    ans.push_back({r0,c0});\\n            }\\n            cnt++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4069939,
                "title": "java-solution",
                "content": "\\nclass Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n            int[][] ans = new int[rows*cols][2];\\n            int i=0;\\n            ans[i++]= new int[]{rStart,cStart};\\n\\n            int len = 0;\\n            int d = 0;\\n\\n            int[] directions = new int[]{0,1,0,-1,0};\\n\\n            while(i< rows*cols){\\n                if(d==0 || d==2){\\n                    len++;\\n                }\\n                for(int k=0;k<len;k++){\\n                    rStart += directions[d];\\n                    cStart += directions[d+1];\\n                    if(rStart<rows && rStart>=0 && cStart<cols && cStart>=0){\\n                        ans[i++]=new int[]{rStart,cStart};\\n                    }\\n                }\\n                d = ++d % 4;\\n            }\\n\\n            return ans;\\n   \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n            int[][] ans = new int[rows*cols][2];\\n            int i=0;\\n            ans[i++]= new int[]{rStart,cStart}",
                "codeTag": "Java"
            },
            {
                "id": 4066962,
                "title": "easiest-solution",
                "content": "\\n\\n# Code\\n```java []\\nclass Solution {\\n    public int[][] spiralMatrixIII(int R, int C, int r0, int c0) {\\n        int[][] result = new int[R * C][2];\\n        int[][] directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}}; // Right, Down, Left, Up\\n        int direction = 0; // Start with the right direction\\n        int steps = 1; // Number of steps to take in the current direction\\n        int count = 0; // Number of cells visited\\n        \\n        int x = r0;\\n        int y = c0;\\n        \\n        while (count < R * C) {\\n            for (int i = 0; i < steps; i++) {\\n                if (x >= 0 && x < R && y >= 0 && y < C) {\\n                    result[count][0] = x;\\n                    result[count][1] = y;\\n                    count++;\\n                }\\n                \\n                // Move in the current direction\\n                x += directions[direction][0];\\n                y += directions[direction][1];\\n            }\\n            \\n            // Change direction after every two steps\\n            direction = (direction + 1) % 4;\\n            \\n            // Increase steps after every two directions\\n            if (direction == 0 || direction == 2) {\\n                steps++;\\n            }\\n        }\\n        \\n        return result;\\n    }\\n}\\n```\\n```c++ []\\nclass Solution {\\npublic:\\nbool validcoordinate(int r,int m,int rows,int cols){\\n           return r>=0&&m>=0&&r<rows&&m<cols;\\n        }\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        int len=1;\\n        vector<vector<int>>ans;\\n        ans.push_back({rStart,cStart});\\n        int x=rStart,y=cStart;\\n    //jbtk ans ka size matrix ke size se kam ho tbtk loop chle kuki sare cell visit krne hai\\n        while(ans.size()<rows*cols){\\n            //toward right\\n            for(int i=1;i<=len;i++){\\n                if(validcoordinate(x,y+i,rows,cols))\\n                ans.push_back({x,y+i});\\n            }\\n            //goes out of boundary\\n            y+=len;\\n            //toward down\\n            for(int i=1;i<=len;i++){\\n                //check currently in valid cell or not\\n                if(validcoordinate(x+i,y,rows,cols)){\\n                    ans.push_back({x+i,y});\\n                }\\n            }\\n            x+=len;\\n            len++;\\n            //toward left\\n            for(int i=1;i<=len;i++){\\n                if(validcoordinate(x,y-i,rows,cols))\\n                ans.push_back({x,y-i});\\n            }\\n            y-=len;\\n            //toward up\\n            for(int i=1;i<=len;i++){\\n              if(validcoordinate(x-i,y,rows,cols))\\n              ans.push_back({x-i,y});\\n            }\\n            x-=len;\\n            len++;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n```python3 []\\nclass Solution:\\n    def doMove(self, rows, cols, current_pos, direction_index, distance):\\n        directions = [\\'e\\', \\'s\\', \\'w\\', \\'n\\']\\n        new_direction = directions[direction_index]\\n        spaces_moved = 1\\n        moves = []\\n        while(spaces_moved <= distance):\\n            if new_direction == \\'e\\':\\n                if current_pos[1] + 1 < cols and current_pos[0] >= 0 and current_pos[0] < rows and current_pos[1]+1 >=0:\\n                    moves.append([current_pos[0], current_pos[1]+1])\\n                current_pos = [current_pos[0], current_pos[1]+1]\\n                \\n            \\n            elif new_direction == \\'s\\':\\n                if current_pos[0]+1 < rows and current_pos[1] < cols and current_pos[1] >= 0 and current_pos[0]+1 >=0:\\n                    moves.append([current_pos[0]+1, current_pos[1]])\\n                current_pos = [current_pos[0]+1, current_pos[1]]\\n\\n            elif new_direction == \\'w\\':\\n                if current_pos[1] - 1 >= 0 and current_pos[0] >=0 and current_pos[0] < rows and current_pos[1]-1 < cols:\\n                    moves.append([current_pos[0], current_pos[1] - 1])\\n                current_pos = [current_pos[0], current_pos[1] - 1]\\n\\n            else:\\n                if current_pos[0] - 1 >= 0 and current_pos[1] < cols and current_pos[1] >= 0 and current_pos[0] - 1 < rows:\\n                    moves.append([current_pos[0]-1, current_pos[1]])\\n                current_pos = [current_pos[0]-1, current_pos[1]]\\n\\n            spaces_moved += 1\\n\\n        return moves, current_pos\\n\\n\\n\\n    def spiralMatrixIII(self, rows: int, cols: int, rStart: int, cStart: int) -> List[List[int]]:\\n        skip_add = True\\n        visited = []\\n        direction_index = 0\\n        distance = 1\\n        current_pos = [rStart, cStart]\\n        visited.append(current_pos)\\n\\n        while(len(visited) < (rows * cols)):\\n            latest_moves, current_pos = self.doMove(rows, cols, current_pos, direction_index, distance)\\n            visited.extend(latest_moves)\\n            direction_index += 1\\n            if direction_index > 3:\\n                direction_index = 0\\n            if not skip_add:\\n                skip_add = True\\n                distance += 1\\n            else:\\n                skip_add = False\\n\\n            \\n\\n        return visited\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```java []\\nclass Solution {\\n    public int[][] spiralMatrixIII(int R, int C, int r0, int c0) {\\n        int[][] result = new int[R * C][2];\\n        int[][] directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}}; // Right, Down, Left, Up\\n        int direction = 0; // Start with the right direction\\n        int steps = 1; // Number of steps to take in the current direction\\n        int count = 0; // Number of cells visited\\n        \\n        int x = r0;\\n        int y = c0;\\n        \\n        while (count < R * C) {\\n            for (int i = 0; i < steps; i++) {\\n                if (x >= 0 && x < R && y >= 0 && y < C) {\\n                    result[count][0] = x;\\n                    result[count][1] = y;\\n                    count++;\\n                }\\n                \\n                // Move in the current direction\\n                x += directions[direction][0];\\n                y += directions[direction][1];\\n            }\\n            \\n            // Change direction after every two steps\\n            direction = (direction + 1) % 4;\\n            \\n            // Increase steps after every two directions\\n            if (direction == 0 || direction == 2) {\\n                steps++;\\n            }\\n        }\\n        \\n        return result;\\n    }\\n}\\n```\n```c++ []\\nclass Solution {\\npublic:\\nbool validcoordinate(int r,int m,int rows,int cols){\\n           return r>=0&&m>=0&&r<rows&&m<cols;\\n        }\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        int len=1;\\n        vector<vector<int>>ans;\\n        ans.push_back({rStart,cStart});\\n        int x=rStart,y=cStart;\\n    //jbtk ans ka size matrix ke size se kam ho tbtk loop chle kuki sare cell visit krne hai\\n        while(ans.size()<rows*cols){\\n            //toward right\\n            for(int i=1;i<=len;i++){\\n                if(validcoordinate(x,y+i,rows,cols))\\n                ans.push_back({x,y+i});\\n            }\\n            //goes out of boundary\\n            y+=len;\\n            //toward down\\n            for(int i=1;i<=len;i++){\\n                //check currently in valid cell or not\\n                if(validcoordinate(x+i,y,rows,cols)){\\n                    ans.push_back({x+i,y});\\n                }\\n            }\\n            x+=len;\\n            len++;\\n            //toward left\\n            for(int i=1;i<=len;i++){\\n                if(validcoordinate(x,y-i,rows,cols))\\n                ans.push_back({x,y-i});\\n            }\\n            y-=len;\\n            //toward up\\n            for(int i=1;i<=len;i++){\\n              if(validcoordinate(x-i,y,rows,cols))\\n              ans.push_back({x-i,y});\\n            }\\n            x-=len;\\n            len++;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```python3 []\\nclass Solution:\\n    def doMove(self, rows, cols, current_pos, direction_index, distance):\\n        directions = [\\'e\\', \\'s\\', \\'w\\', \\'n\\']\\n        new_direction = directions[direction_index]\\n        spaces_moved = 1\\n        moves = []\\n        while(spaces_moved <= distance):\\n            if new_direction == \\'e\\':\\n                if current_pos[1] + 1 < cols and current_pos[0] >= 0 and current_pos[0] < rows and current_pos[1]+1 >=0:\\n                    moves.append([current_pos[0], current_pos[1]+1])\\n                current_pos = [current_pos[0], current_pos[1]+1]\\n                \\n            \\n            elif new_direction == \\'s\\':\\n                if current_pos[0]+1 < rows and current_pos[1] < cols and current_pos[1] >= 0 and current_pos[0]+1 >=0:\\n                    moves.append([current_pos[0]+1, current_pos[1]])\\n                current_pos = [current_pos[0]+1, current_pos[1]]\\n\\n            elif new_direction == \\'w\\':\\n                if current_pos[1] - 1 >= 0 and current_pos[0] >=0 and current_pos[0] < rows and current_pos[1]-1 < cols:\\n                    moves.append([current_pos[0], current_pos[1] - 1])\\n                current_pos = [current_pos[0], current_pos[1] - 1]\\n\\n            else:\\n                if current_pos[0] - 1 >= 0 and current_pos[1] < cols and current_pos[1] >= 0 and current_pos[0] - 1 < rows:\\n                    moves.append([current_pos[0]-1, current_pos[1]])\\n                current_pos = [current_pos[0]-1, current_pos[1]]\\n\\n            spaces_moved += 1\\n\\n        return moves, current_pos\\n\\n\\n\\n    def spiralMatrixIII(self, rows: int, cols: int, rStart: int, cStart: int) -> List[List[int]]:\\n        skip_add = True\\n        visited = []\\n        direction_index = 0\\n        distance = 1\\n        current_pos = [rStart, cStart]\\n        visited.append(current_pos)\\n\\n        while(len(visited) < (rows * cols)):\\n            latest_moves, current_pos = self.doMove(rows, cols, current_pos, direction_index, distance)\\n            visited.extend(latest_moves)\\n            direction_index += 1\\n            if direction_index > 3:\\n                direction_index = 0\\n            if not skip_add:\\n                skip_add = True\\n                distance += 1\\n            else:\\n                skip_add = False\\n\\n            \\n\\n        return visited\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4066023,
                "title": "spiral-matrix-iii",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAS we have done in spiral-I,spiral-II their was not given from where to start so we assume 4 pointers top,bottom,left,right but in this it is mentioned from where to start so in this traverse matrix till size of resultant array is less than size of matix (rows*cols);\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nInitialize len to 1 to represent the length of the current spiral.\\nCreate an empty 2D vector ans to store the coordinates in the spiral.\\nAdd the starting coordinate (rStart, cStart) to ans.\\nEnter a loop that continues until ans contains coordinates for all cells in the grid.\\nInside the loop:\\na. Move right by iterating i from 1 to len, adding valid coordinates to ans.\\nb. Update the y coordinate to the right boundary.\\nc. Move down by iterating i from 1 to len, adding valid coordinates to ans.\\nd. Update the x coordinate to the bottom boundary.\\ne. Increment len to increase the length of the spiral.\\nf. Move left by iterating i from 1 to len, adding valid coordinates to ans.\\ng. Update the y coordinate to the left boundary.\\nh. Move up by iterating i from 1 to len, adding valid coordinates to ans.\\ni. Update the x coordinate to the top boundary.\\nRepeat the above steps until ans contains coordinates for all cells in the grid.\\nReturn the ans vector containing the spiral coordinates.\\n# This code essentially follows a clockwise spiral pattern, extending the spiral by increasing len and updating the boundary coordinates in each direction (right, down, left, up) until all cells are covered.\\n\\n\\n# Complexity\\n- Time complexity:O(n*m)  ; n=rows,m=cols\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n*m) ; n=rows,m=cols\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nbool validcoordinate(int r,int m,int rows,int cols){\\n           return r>=0&&m>=0&&r<rows&&m<cols;\\n        }\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        int len=1;\\n        vector<vector<int>>ans;\\n        ans.push_back({rStart,cStart});\\n        int x=rStart,y=cStart;\\n    //jbtk ans ka size matrix ke size se kam ho tbtk loop chle kuki sare cell visit krne hai\\n        while(ans.size()<rows*cols){\\n            //toward right\\n            for(int i=1;i<=len;i++){\\n                if(validcoordinate(x,y+i,rows,cols))\\n                ans.push_back({x,y+i});\\n            }\\n            //goes out of boundary\\n            y+=len;\\n            //toward down\\n            for(int i=1;i<=len;i++){\\n                //check currently in valid cell or not\\n                if(validcoordinate(x+i,y,rows,cols)){\\n                    ans.push_back({x+i,y});\\n                }\\n            }\\n            x+=len;\\n            len++;\\n            //toward left\\n            for(int i=1;i<=len;i++){\\n                if(validcoordinate(x,y-i,rows,cols))\\n                ans.push_back({x,y-i});\\n            }\\n            y-=len;\\n            //toward up\\n            for(int i=1;i<=len;i++){\\n              if(validcoordinate(x-i,y,rows,cols))\\n              ans.push_back({x-i,y});\\n            }\\n            x-=len;\\n            len++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nbool validcoordinate(int r,int m,int rows,int cols){\\n           return r>=0&&m>=0&&r<rows&&m<cols;\\n        }\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        int len=1;\\n        vector<vector<int>>ans;\\n        ans.push_back({rStart,cStart});\\n        int x=rStart,y=cStart;\\n    //jbtk ans ka size matrix ke size se kam ho tbtk loop chle kuki sare cell visit krne hai\\n        while(ans.size()<rows*cols){\\n            //toward right\\n            for(int i=1;i<=len;i++){\\n                if(validcoordinate(x,y+i,rows,cols))\\n                ans.push_back({x,y+i});\\n            }\\n            //goes out of boundary\\n            y+=len;\\n            //toward down\\n            for(int i=1;i<=len;i++){\\n                //check currently in valid cell or not\\n                if(validcoordinate(x+i,y,rows,cols)){\\n                    ans.push_back({x+i,y});\\n                }\\n            }\\n            x+=len;\\n            len++;\\n            //toward left\\n            for(int i=1;i<=len;i++){\\n                if(validcoordinate(x,y-i,rows,cols))\\n                ans.push_back({x,y-i});\\n            }\\n            y-=len;\\n            //toward up\\n            for(int i=1;i<=len;i++){\\n              if(validcoordinate(x-i,y,rows,cols))\\n              ans.push_back({x-i,y});\\n            }\\n            x-=len;\\n            len++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4064400,
                "title": "r-50-m-70",
                "content": "# Complexity\\n- Time complexity: **O(max(m, n) ** 2)**\\nm - rows input value.\\nn - cols input value.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(m * n)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def spiralMatrixIII(self, rows: int, cols: int, rStart: int, cStart: int) -> List[List[int]]:\\n        # maximum size of row|column, inside the matrix.\\n        row_limit: int = rows\\n        col_limit: int = cols\\n        y: int = rStart\\n        x: int = cStart\\n        dx: int = 0\\n        dy: int = 0\\n        # All coordinates inside given matrix limits.\\n        insides: list[list[int]] = [[y, x]]\\n        # Maximum cells in given matrix.\\n        all_insides: int = rows * cols\\n        turn: int = 0\\n        # Standard steps we need to cover first ROW|COLUMN.\\n        y_steps: int = 1\\n        x_steps: int = 1\\n        # Essentially we\\'re just traversing matrix, and storing correct coordinates.\\n        # From some given point, we just travel ROW|COLUMN and expand it on turns.\\n        # Starting from sizes: ROW == 1, COLUMN == 1 and ending only when all coordinates added.\\n        while len(insides) != all_insides:\\n            if turn == 4:\\n                turn = 0\\n            if turn == 0:\\n                dx = 1\\n                dy = 0\\n            elif turn == 1:\\n                dx = 0\\n                dy = 1\\n            elif turn == 2:\\n                dx = -1\\n                dy = 0\\n            elif turn == 3:\\n                dx = 0\\n                dy = -1\\n            cur_steps: int = 0\\n            if turn == 0 or turn == 2:\\n                while cur_steps != x_steps:\\n                    y += dy\\n                    x += dx\\n                    cur_steps += 1\\n                    # Inside matrix.\\n                    if 0 <= y < row_limit and 0 <= x < col_limit:\\n                        insides.append([y, x])\\n                    # Out of bounds, no reasons to make steps.\\n                    # Just change coordinate to the last position we could have reach.\\n                    elif dx == 1 and x >= col_limit:\\n                        x += dx * (x_steps - cur_steps)\\n                        break\\n                    elif dx == -1 and x < 0:\\n                        x += dx * (x_steps - cur_steps)\\n                        break\\n                x_steps += 1\\n                turn += 1\\n            elif turn == 1 or turn == 3:\\n                while cur_steps != y_steps:\\n                    y += dy\\n                    x += dx\\n                    cur_steps += 1\\n                    if 0 <= y < row_limit and 0 <= x < col_limit:\\n                        insides.append([y, x])\\n                    elif dy == 1 and y >= row_limit:\\n                        y += dy * (y_steps - cur_steps)\\n                        break\\n                    elif dy == -1 and y < 0:\\n                        y += dy * (y_steps - cur_steps)\\n                        break\\n                y_steps += 1\\n                turn += 1\\n        return insides\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def spiralMatrixIII(self, rows: int, cols: int, rStart: int, cStart: int) -> List[List[int]]:\\n        # maximum size of row|column, inside the matrix.\\n        row_limit: int = rows\\n        col_limit: int = cols\\n        y: int = rStart\\n        x: int = cStart\\n        dx: int = 0\\n        dy: int = 0\\n        # All coordinates inside given matrix limits.\\n        insides: list[list[int]] = [[y, x]]\\n        # Maximum cells in given matrix.\\n        all_insides: int = rows * cols\\n        turn: int = 0\\n        # Standard steps we need to cover first ROW|COLUMN.\\n        y_steps: int = 1\\n        x_steps: int = 1\\n        # Essentially we\\'re just traversing matrix, and storing correct coordinates.\\n        # From some given point, we just travel ROW|COLUMN and expand it on turns.\\n        # Starting from sizes: ROW == 1, COLUMN == 1 and ending only when all coordinates added.\\n        while len(insides) != all_insides:\\n            if turn == 4:\\n                turn = 0\\n            if turn == 0:\\n                dx = 1\\n                dy = 0\\n            elif turn == 1:\\n                dx = 0\\n                dy = 1\\n            elif turn == 2:\\n                dx = -1\\n                dy = 0\\n            elif turn == 3:\\n                dx = 0\\n                dy = -1\\n            cur_steps: int = 0\\n            if turn == 0 or turn == 2:\\n                while cur_steps != x_steps:\\n                    y += dy\\n                    x += dx\\n                    cur_steps += 1\\n                    # Inside matrix.\\n                    if 0 <= y < row_limit and 0 <= x < col_limit:\\n                        insides.append([y, x])\\n                    # Out of bounds, no reasons to make steps.\\n                    # Just change coordinate to the last position we could have reach.\\n                    elif dx == 1 and x >= col_limit:\\n                        x += dx * (x_steps - cur_steps)\\n                        break\\n                    elif dx == -1 and x < 0:\\n                        x += dx * (x_steps - cur_steps)\\n                        break\\n                x_steps += 1\\n                turn += 1\\n            elif turn == 1 or turn == 3:\\n                while cur_steps != y_steps:\\n                    y += dy\\n                    x += dx\\n                    cur_steps += 1\\n                    if 0 <= y < row_limit and 0 <= x < col_limit:\\n                        insides.append([y, x])\\n                    elif dy == 1 and y >= row_limit:\\n                        y += dy * (y_steps - cur_steps)\\n                        break\\n                    elif dy == -1 and y < 0:\\n                        y += dy * (y_steps - cur_steps)\\n                        break\\n                y_steps += 1\\n                turn += 1\\n        return insides\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4031124,
                "title": "super-easy-java-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(R^2 * C^2) \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: 0(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int R, int C, int r0, int c0) {\\n        int[][] result = new int[R * C][2];\\n        int[][] directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}}; // Right, Down, Left, Up\\n        int direction = 0; // Start with the right direction\\n        int steps = 1; // Number of steps to take in the current direction\\n        int count = 0; // Number of cells visited\\n        \\n        int x = r0;\\n        int y = c0;\\n        \\n        while (count < R * C) {\\n            for (int i = 0; i < steps; i++) {\\n                if (x >= 0 && x < R && y >= 0 && y < C) {\\n                    result[count][0] = x;\\n                    result[count][1] = y;\\n                    count++;\\n                }\\n                \\n                // Move in the current direction\\n                x += directions[direction][0];\\n                y += directions[direction][1];\\n            }\\n            \\n            // Change direction after every two steps\\n            direction = (direction + 1) % 4;\\n            \\n            // Increase steps after every two directions\\n            if (direction == 0 || direction == 2) {\\n                steps++;\\n            }\\n        }\\n        \\n        return result;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int R, int C, int r0, int c0) {\\n        int[][] result = new int[R * C][2];\\n        int[][] directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}}; // Right, Down, Left, Up\\n        int direction = 0; // Start with the right direction\\n        int steps = 1; // Number of steps to take in the current direction\\n        int count = 0; // Number of cells visited\\n        \\n        int x = r0;\\n        int y = c0;\\n        \\n        while (count < R * C) {\\n            for (int i = 0; i < steps; i++) {\\n                if (x >= 0 && x < R && y >= 0 && y < C) {\\n                    result[count][0] = x;\\n                    result[count][1] = y;\\n                    count++;\\n                }\\n                \\n                // Move in the current direction\\n                x += directions[direction][0];\\n                y += directions[direction][1];\\n            }\\n            \\n            // Change direction after every two steps\\n            direction = (direction + 1) % 4;\\n            \\n            // Increase steps after every two directions\\n            if (direction == 0 || direction == 2) {\\n                steps++;\\n            }\\n        }\\n        \\n        return result;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4012986,
                "title": "java-esy-approach",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        int[][] res = new int[rows * cols][];\\n        int k = 0;\\n        res[k++] = new int[]{rStart, cStart};\\n        int[] direction = {0, 1, 0, -1, 0};\\n        int d = 0;\\n        int len = 0;\\n        while(k < rows * cols){\\n            if(d == 0 || d == 2){\\n                len++;\\n            }\\n            for(int i = 0; i < len; i++){\\n                rStart += direction[d];\\n                cStart += direction[d+1];\\n                \\n                if(rStart > -1 && rStart < rows && cStart > -1 && cStart < cols){\\n                    res[k++] = new int[]{rStart, cStart};\\n                }\\n            }\\n            d = ++d % 4;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        int[][] res = new int[rows * cols][];\\n        int k = 0;\\n        res[k++] = new int[]{rStart, cStart};\\n        int[] direction = {0, 1, 0, -1, 0};\\n        int d = 0;\\n        int len = 0;\\n        while(k < rows * cols){\\n            if(d == 0 || d == 2){\\n                len++;\\n            }\\n            for(int i = 0; i < len; i++){\\n                rStart += direction[d];\\n                cStart += direction[d+1];\\n                \\n                if(rStart > -1 && rStart < rows && cStart > -1 && cStart < cols){\\n                    res[k++] = new int[]{rStart, cStart};\\n                }\\n            }\\n            d = ++d % 4;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4012467,
                "title": "c-simple-brute-force-approach",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        static const struct { int dRow, dCol, dSteps; } dirs[] = {\\n            // right,   down,      left,        up\\n            {0, 1, 0}, {1, 0, 0}, {0, -1, 1}, {-1, 0, 1},\\n        };\\n\\n        vector<vector<int>> res;\\n        res.reserve(rows * cols);\\n\\n        int row = rStart, col = cStart;\\n        for (int nSteps = 1; res.size() < rows * cols; nSteps += 2) {\\n            for (const auto& dir : dirs) {\\n                for (int i = 0; i < nSteps + dir.dSteps; ++i) {\\n                    if (row >= 0 && row < rows && col >= 0 && col < cols)\\n                        res.emplace_back(vector<int>{row, col});\\n                    row += dir.dRow;\\n                    col += dir.dCol;\\n                }\\n            }\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        static const struct { int dRow, dCol, dSteps; } dirs[] = {\\n            // right,   down,      left,        up\\n            {0, 1, 0}, {1, 0, 0}, {0, -1, 1}, {-1, 0, 1},\\n        };\\n\\n        vector<vector<int>> res;\\n        res.reserve(rows * cols);\\n\\n        int row = rStart, col = cStart;\\n        for (int nSteps = 1; res.size() < rows * cols; nSteps += 2) {\\n            for (const auto& dir : dirs) {\\n                for (int i = 0; i < nSteps + dir.dSteps; ++i) {\\n                    if (row >= 0 && row < rows && col >= 0 && col < cols)\\n                        res.emplace_back(vector<int>{row, col});\\n                    row += dir.dRow;\\n                    col += dir.dCol;\\n                }\\n            }\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4003147,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        int totalCells = rows * cols;\\n        int[][] result = new int[totalCells][2];\\n\\n        result[0][0] = rStart;\\n        result[0][1] = cStart;\\n        if (totalCells == 1) return result;\\n\\n        // every left and every right up the steps;\\n        int totalSteps = 1;\\n        int steps = 0;\\n        String dir = \"right\";\\n        int[] currentCell = new int[]{rStart, cStart, 0};\\n        while (totalSteps < totalCells) {\\n            if (dir.equals(\"right\")) {\\n                steps++;\\n                totalSteps += addSteps(dir, steps, currentCell, result, rows, cols);\\n                dir = \"down\";\\n            }\\n            if (dir.equals(\"down\")) {\\n                totalSteps += addSteps(dir, steps, currentCell, result, rows, cols);\\n                dir = \"left\";\\n            }\\n            if (dir.equals(\"left\")) {\\n                steps++;\\n                totalSteps += addSteps(dir, steps, currentCell, result, rows, cols);\\n                dir = \"up\";\\n            }\\n            if (dir.equals(\"up\")) {\\n                totalSteps += addSteps(dir, steps, currentCell, result, rows, cols);\\n                dir = \"right\";\\n            }\\n        }\\n        return result;\\n    }\\n\\n    private int addSteps(String dir, int steps, int[] currentCell, int[][] result, int rows, int cols) {\\n        int addedSteps = 0;\\n        for (int i = 0; i < steps; i++) {\\n            if (dir.equals(\"right\")) {\\n                currentCell[1]++;\\n            } else if (dir.equals(\"down\")) {\\n                currentCell[0]++;\\n            } else if (dir.equals(\"left\")) {\\n                currentCell[1]--;\\n            } else  if (dir.equals(\"up\")) {\\n                currentCell[0]--;\\n            }\\n            if (currentCell[0] < 0 || currentCell[0] >= rows || currentCell[1] < 0 || currentCell[1] >= cols) continue;\\n            currentCell[2]++;\\n            result[currentCell[2]][0] = currentCell[0];\\n            result[currentCell[2]][1] = currentCell[1];\\n            addedSteps++;\\n        }\\n        return addedSteps;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        int totalCells = rows * cols;\\n        int[][] result = new int[totalCells][2];\\n\\n        result[0][0] = rStart;\\n        result[0][1] = cStart;\\n        if (totalCells == 1) return result;\\n\\n        // every left and every right up the steps;\\n        int totalSteps = 1;\\n        int steps = 0;\\n        String dir = \"right\";\\n        int[] currentCell = new int[]{rStart, cStart, 0};\\n        while (totalSteps < totalCells) {\\n            if (dir.equals(\"right\")) {\\n                steps++;\\n                totalSteps += addSteps(dir, steps, currentCell, result, rows, cols);\\n                dir = \"down\";\\n            }\\n            if (dir.equals(\"down\")) {\\n                totalSteps += addSteps(dir, steps, currentCell, result, rows, cols);\\n                dir = \"left\";\\n            }\\n            if (dir.equals(\"left\")) {\\n                steps++;\\n                totalSteps += addSteps(dir, steps, currentCell, result, rows, cols);\\n                dir = \"up\";\\n            }\\n            if (dir.equals(\"up\")) {\\n                totalSteps += addSteps(dir, steps, currentCell, result, rows, cols);\\n                dir = \"right\";\\n            }\\n        }\\n        return result;\\n    }\\n\\n    private int addSteps(String dir, int steps, int[] currentCell, int[][] result, int rows, int cols) {\\n        int addedSteps = 0;\\n        for (int i = 0; i < steps; i++) {\\n            if (dir.equals(\"right\")) {\\n                currentCell[1]++;\\n            } else if (dir.equals(\"down\")) {\\n                currentCell[0]++;\\n            } else if (dir.equals(\"left\")) {\\n                currentCell[1]--;\\n            } else  if (dir.equals(\"up\")) {\\n                currentCell[0]--;\\n            }\\n            if (currentCell[0] < 0 || currentCell[0] >= rows || currentCell[1] < 0 || currentCell[1] >= cols) continue;\\n            currentCell[2]++;\\n            result[currentCell[2]][0] = currentCell[0];\\n            result[currentCell[2]][1] = currentCell[1];\\n            addedSteps++;\\n        }\\n        return addedSteps;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3995487,
                "title": "beats-96-python-straightforward-solution",
                "content": "# Intuition\\nGenerates a spiral matrix of integers within a grid (rows x cols), starting at a specified point (rStart, cStart). It moves in four directions (right, down, left, up) while incrementing numbers until the entire grid is covered.\\n\\n# Complexity\\n- Time complexity: **O(rows * cols)**\\n- Space complexity: **O(rows * cols)**\\n![image.png](https://assets.leetcode.com/users/images/05db3c52-f603-4ca3-8d9a-808e088a982d_1693720178.937379.png)\\n\\n# Code\\n```py\\nclass Solution:\\n    def spiralMatrixIII(self, rows: int, cols: int, rStart: int, cStart: int):\\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\\n        curRow, curCol = rStart, cStart\\n        curNum = 1\\n        dirIdx = 0\\n        iterLen = 1\\n        res = [[rStart, cStart]]\\n        while curNum < rows * cols:\\n            dr, dc = directions[dirIdx]\\n            for c in range(iterLen):\\n                newR = curRow + dr\\n                newC = curCol + dc\\n\\n                if 0 <= newR < rows and 0 <= newC < cols:\\n                    curNum += 1\\n                    res.append([newR, newC])\\n                curRow = newR\\n                curCol = newC\\n\\n            dirIdx = (dirIdx + 1) % 4\\n            if dirIdx % 2 == 0:  # Increase iterLen every two directions\\n                iterLen += 1\\n\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```py\\nclass Solution:\\n    def spiralMatrixIII(self, rows: int, cols: int, rStart: int, cStart: int):\\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\\n        curRow, curCol = rStart, cStart\\n        curNum = 1\\n        dirIdx = 0\\n        iterLen = 1\\n        res = [[rStart, cStart]]\\n        while curNum < rows * cols:\\n            dr, dc = directions[dirIdx]\\n            for c in range(iterLen):\\n                newR = curRow + dr\\n                newC = curCol + dc\\n\\n                if 0 <= newR < rows and 0 <= newC < cols:\\n                    curNum += 1\\n                    res.append([newR, newC])\\n                curRow = newR\\n                curCol = newC\\n\\n            dirIdx = (dirIdx + 1) % 4\\n            if dirIdx % 2 == 0:  # Increase iterLen every two directions\\n                iterLen += 1\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3988426,
                "title": "optimal-solution-and-easy-code",
                "content": "```\\nclass Solution {\\npublic:\\n    bool is(int i , int j , int r , int c){\\n        return i>=0 && j>=0 && i<r && j<c;\\n    }\\n    vector<vector<int>> spiralMatrixIII(int r , int c , int x , int y){\\n        vector<vector<int>>v{{x,y}};\\n        int size = r*c , l=1;\\n        while(v.size()<size){\\n            for(int j=1; j<=l; j++){\\n                if(is(x , y+j , r , c)){\\n                    v.push_back({x,y+j});\\n                }\\n            }\\n            y+=l;\\n            for(int j=1; j<=l; j++){\\n                if(is(x+j , y , r , c)){\\n                    v.push_back({x+j,y});\\n                }\\n            }\\n            x+=l;\\n            l++;\\n            for(int j=1; j<=l; j++){\\n                if(is(x , y-j , r , c)){\\n                    v.push_back({x,y-j});\\n                }\\n            }\\n            y-=l;\\n            for(int j=1; j<=l; j++){\\n                if(is(x-j , y , r , c)){\\n                    v.push_back({x-j,y});\\n                }\\n            }\\n            x-=l;\\n            l++;\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool is(int i , int j , int r , int c){\\n        return i>=0 && j>=0 && i<r && j<c;\\n    }\\n    vector<vector<int>> spiralMatrixIII(int r , int c , int x , int y){\\n        vector<vector<int>>v{{x,y}};\\n        int size = r*c , l=1;\\n        while(v.size()<size){\\n            for(int j=1; j<=l; j++){\\n                if(is(x , y+j , r , c)){\\n                    v.push_back({x,y+j});\\n                }\\n            }\\n            y+=l;\\n            for(int j=1; j<=l; j++){\\n                if(is(x+j , y , r , c)){\\n                    v.push_back({x+j,y});\\n                }\\n            }\\n            x+=l;\\n            l++;\\n            for(int j=1; j<=l; j++){\\n                if(is(x , y-j , r , c)){\\n                    v.push_back({x,y-j});\\n                }\\n            }\\n            y-=l;\\n            for(int j=1; j<=l; j++){\\n                if(is(x-j , y , r , c)){\\n                    v.push_back({x-j,y});\\n                }\\n            }\\n            x-=l;\\n            l++;\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3988412,
                "title": "simplest-and-easiest-code",
                "content": "```\\nclass Solution {\\npublic:\\n    bool is(int i , int j , int r , int c){\\n        return i>=0 && j>=0 && i<r && j<c;\\n    }\\n    vector<vector<int>> spiralMatrixIII(int r , int c , int rS , int cS){\\n        vector<vector<int>>v{{rS,cS}};\\n        int size = r*c , l=1 , x=rS , y=cS;\\n        while(v.size()<size){\\n            for(int j=1; j<=l; j++){\\n                if(is(x , y+j , r , c)){\\n                    v.push_back({x,y+j});\\n                }\\n            }\\n            y+=l;\\n            for(int j=1; j<=l; j++){\\n                if(is(x+j , y , r , c)){\\n                    v.push_back({x+j,y});\\n                }\\n            }\\n            x+=l;\\n            l++;\\n            for(int j=1; j<=l; j++){\\n                if(is(x , y-j , r , c)){\\n                    v.push_back({x,y-j});\\n                }\\n            }\\n            y-=l;\\n            for(int j=1; j<=l; j++){\\n                if(is(x-j , y , r , c)){\\n                    v.push_back({x-j,y});\\n                }\\n            }\\n            x-=l;\\n            l++;\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool is(int i , int j , int r , int c){\\n        return i>=0 && j>=0 && i<r && j<c;\\n    }\\n    vector<vector<int>> spiralMatrixIII(int r , int c , int rS , int cS){\\n        vector<vector<int>>v{{rS,cS}};\\n        int size = r*c , l=1 , x=rS , y=cS;\\n        while(v.size()<size){\\n            for(int j=1; j<=l; j++){\\n                if(is(x , y+j , r , c)){\\n                    v.push_back({x,y+j});\\n                }\\n            }\\n            y+=l;\\n            for(int j=1; j<=l; j++){\\n                if(is(x+j , y , r , c)){\\n                    v.push_back({x+j,y});\\n                }\\n            }\\n            x+=l;\\n            l++;\\n            for(int j=1; j<=l; j++){\\n                if(is(x , y-j , r , c)){\\n                    v.push_back({x,y-j});\\n                }\\n            }\\n            y-=l;\\n            for(int j=1; j<=l; j++){\\n                if(is(x-j , y , r , c)){\\n                    v.push_back({x-j,y});\\n                }\\n            }\\n            x-=l;\\n            l++;\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3983475,
                "title": "java-straightforward",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        // lets make some boundaries and stick with it !\\n        int left = cStart -1 , right = cStart+1 , top = rStart-1 , btm = rStart+1 , cnt= 0;\\n        int [][] res = new int[rows*cols][2];\\n        while(cnt < rows * cols ){\\n            // move left to right\\n            for( ; cStart <= right ; cStart++){\\n                if( check(rStart , cStart , rows , cols)) res[cnt++] = new int[]{rStart ,cStart};\\n            }\\n            cStart = right ;\\n            rStart++;\\n\\n            // top to btm \\n            for( ; rStart <= btm ; rStart++){\\n                if( check(rStart , cStart , rows , cols)) res[cnt++] = new int[]{rStart ,cStart};\\n            }\\n            rStart = btm  ;\\n            cStart--;\\n\\n            //right to left\\n            for( ; cStart >= left ; cStart--){\\n                if( check(rStart , cStart , rows , cols)) res[cnt++] = new int[]{rStart ,cStart};\\n            }\\n            cStart = left;\\n            rStart--;\\n\\n            // btm to top\\n            for( ; rStart >= top ; rStart--){\\n                if( check(rStart , cStart , rows , cols))   res[cnt++] = new int[]{rStart ,cStart};\\n            }\\n            rStart = top ;\\n            cStart++;\\n\\n            top--;btm++;left--;right++;\\n            \\n        }\\n        return res;\\n    }\\n    public boolean check( int rStart , int cStart , int rows , int cols){\\n        if( rStart >= 0 && rStart <rows && cStart >= 0 && cStart < cols)  return true ;\\n        return false ;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        // lets make some boundaries and stick with it !\\n        int left = cStart -1 , right = cStart+1 , top = rStart-1 , btm = rStart+1 , cnt= 0;\\n        int [][] res = new int[rows*cols][2];\\n        while(cnt < rows * cols ){\\n            // move left to right\\n            for( ; cStart <= right ; cStart++){\\n                if( check(rStart , cStart , rows , cols)) res[cnt++] = new int[]{rStart ,cStart};\\n            }\\n            cStart = right ;\\n            rStart++;\\n\\n            // top to btm \\n            for( ; rStart <= btm ; rStart++){\\n                if( check(rStart , cStart , rows , cols)) res[cnt++] = new int[]{rStart ,cStart};\\n            }\\n            rStart = btm  ;\\n            cStart--;\\n\\n            //right to left\\n            for( ; cStart >= left ; cStart--){\\n                if( check(rStart , cStart , rows , cols)) res[cnt++] = new int[]{rStart ,cStart};\\n            }\\n            cStart = left;\\n            rStart--;\\n\\n            // btm to top\\n            for( ; rStart >= top ; rStart--){\\n                if( check(rStart , cStart , rows , cols))   res[cnt++] = new int[]{rStart ,cStart};\\n            }\\n            rStart = top ;\\n            cStart++;\\n\\n            top--;btm++;left--;right++;\\n            \\n        }\\n        return res;\\n    }\\n    public boolean check( int rStart , int cStart , int rows , int cols){\\n        if( rStart >= 0 && rStart <rows && cStart >= 0 && cStart < cols)  return true ;\\n        return false ;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3981258,
                "title": "c-matrix-traversal",
                "content": "\\n# Complexity\\n- Time complexity:\\nO(rows*cols)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    inline bool isValid(int cr,int cc,int rows, int cols){\\n        return cr>=0 && cc>=0 && cr<rows && cc <cols;\\n    }\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        vector<vector<int>> dirs {{0,1,0},{1,0,0},{0,-1,1},{-1,0,1}};\\n        int cellsToVisit = rows*cols-1,cl=1,cr=rStart,cc=cStart;\\n        vector<vector<int>> ans;\\n        ans.push_back({rStart,cStart});\\n        while (cellsToVisit>0){\\n            for (int i=0;i<4 && cellsToVisit>0;i++){\\n                for (int j=0;j<cl+dirs[i][2]&& cellsToVisit>0;j++){\\n                    cr += dirs[i][0];\\n                    cc += dirs[i][1];\\n                    //cout << cr << \"-\" << cc << endl;\\n                    if (isValid(cr,cc,rows,cols)) ans.push_back({cr,cc}),cellsToVisit--;\\n                }\\n            }\\n            cl+=2;\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    inline bool isValid(int cr,int cc,int rows, int cols){\\n        return cr>=0 && cc>=0 && cr<rows && cc <cols;\\n    }\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        vector<vector<int>> dirs {{0,1,0},{1,0,0},{0,-1,1},{-1,0,1}};\\n        int cellsToVisit = rows*cols-1,cl=1,cr=rStart,cc=cStart;\\n        vector<vector<int>> ans;\\n        ans.push_back({rStart,cStart});\\n        while (cellsToVisit>0){\\n            for (int i=0;i<4 && cellsToVisit>0;i++){\\n                for (int j=0;j<cl+dirs[i][2]&& cellsToVisit>0;j++){\\n                    cr += dirs[i][0];\\n                    cc += dirs[i][1];\\n                    //cout << cr << \"-\" << cc << endl;\\n                    if (isValid(cr,cc,rows,cols)) ans.push_back({cr,cc}),cellsToVisit--;\\n                }\\n            }\\n            cl+=2;\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3971173,
                "title": "easy-solution-cpp-fastest",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rstart, int cstart) {\\n        vector<vector<int>> ans;\\n        int total = rows * cols;\\n        int ec = cstart, sc = cstart;\\n        int sr = rstart , er = rstart;\\n            \\n        while(ans.size() < total){\\n            ec++;\\n            if(sr >= 0) \\n                for(int i = max(0,sc); i < min(cols,ec) ; i++) \\n                    ans.push_back({sr,i});\\n                  \\n            er++;\\n            if(ec < cols) \\n                for(int i = max(sr,0) ; i < min(er,rows); i++) \\n                    ans.push_back({i,ec});\\n\\n            sc--;\\n            if(er < rows) \\n                for(int i = min (ec, cols-1); i >max(-1, sc) ;i--) \\n                    ans.push_back({er,i});\\n                   \\n            sr--;\\n            if(sc >=0 )\\n                for(int i = min(er,rows-1) ;i > max(-1,sr) ; i--) \\n                    ans.push_back({i,sc}); \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rstart, int cstart) {\\n        vector<vector<int>> ans;\\n        int total = rows * cols;\\n        int ec = cstart, sc = cstart;\\n        int sr = rstart , er = rstart;\\n            \\n        while(ans.size() < total){\\n            ec++;\\n            if(sr >= 0) \\n                for(int i = max(0,sc); i < min(cols,ec) ; i++) \\n                    ans.push_back({sr,i});\\n                  \\n            er++;\\n            if(ec < cols) \\n                for(int i = max(sr,0) ; i < min(er,rows); i++) \\n                    ans.push_back({i,ec});\\n\\n            sc--;\\n            if(er < rows) \\n                for(int i = min (ec, cols-1); i >max(-1, sc) ;i--) \\n                    ans.push_back({er,i});\\n                   \\n            sr--;\\n            if(sc >=0 )\\n                for(int i = min(er,rows-1) ;i > max(-1,sr) ; i--) \\n                    ans.push_back({i,sc}); \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3956137,
                "title": "solution-same-with-spiral-matrix-i-and-ii",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        vector<vector<int>> sprial(rows, vector<int>(cols));\\n        int i = 0;\\n        int a = rStart;\\n        int b = cStart;\\n        int layer1 = max({a, rows-a, cols-b, b});\\n        sprial.erase(sprial.begin(), sprial.end());\\n        sprial.push_back({rStart, cStart});\\n        for (int layer = 0; layer <= layer1;){\\n            for(i = 0; i < (2 * layer + 1); i++){\\n                if((b - layer + i + 1) >= 0 && (b - layer + i + 1) < cols && (a - layer) >= 0) {\\n                    sprial.push_back({a - layer, b - layer + i + 1});\\n                    }\\n            }\\n            layer++;\\n            for(i = 0; i < 2 * layer - 1; i++){\\n                if((a - layer + i + 2) < rows && (a - layer + i + 2)>=0 && (b + layer) < cols) {\\n                    sprial.push_back({a - layer + 2 + i, b + layer});\\n                    }\\n            }\\n            for(i = 0; i < 2 * layer; i++){\\n                if((b + layer - i -1) < cols && (b + layer - i -1) >= 0 && (a + layer) < rows) {\\n                    sprial.push_back({a + layer, b + layer -i - 1});}\\n            }\\n            for(i = 0; i < 2 * layer; i++){\\n                if((a + layer - i -1) < rows && (a + layer - i -1) >= 0 && (b - layer) >= 0) {\\n                    sprial.push_back({a + layer - i -1, b - layer});}\\n            }\\n        }\\n        return sprial;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        vector<vector<int>> sprial(rows, vector<int>(cols));\\n        int i = 0;\\n        int a = rStart;\\n        int b = cStart;\\n        int layer1 = max({a, rows-a, cols-b, b});\\n        sprial.erase(sprial.begin(), sprial.end());\\n        sprial.push_back({rStart, cStart});\\n        for (int layer = 0; layer <= layer1;){\\n            for(i = 0; i < (2 * layer + 1); i++){\\n                if((b - layer + i + 1) >= 0 && (b - layer + i + 1) < cols && (a - layer) >= 0) {\\n                    sprial.push_back({a - layer, b - layer + i + 1});\\n                    }\\n            }\\n            layer++;\\n            for(i = 0; i < 2 * layer - 1; i++){\\n                if((a - layer + i + 2) < rows && (a - layer + i + 2)>=0 && (b + layer) < cols) {\\n                    sprial.push_back({a - layer + 2 + i, b + layer});\\n                    }\\n            }\\n            for(i = 0; i < 2 * layer; i++){\\n                if((b + layer - i -1) < cols && (b + layer - i -1) >= 0 && (a + layer) < rows) {\\n                    sprial.push_back({a + layer, b + layer -i - 1});}\\n            }\\n            for(i = 0; i < 2 * layer; i++){\\n                if((a + layer - i -1) < rows && (a + layer - i -1) >= 0 && (b - layer) >= 0) {\\n                    sprial.push_back({a + layer - i -1, b - layer});}\\n            }\\n        }\\n        return sprial;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3908272,
                "title": "easiest-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        int[][] mat = new int[rows * cols][2];\\n        int in = 0;\\n        int[][] directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\\n        int rs = rStart;\\n        int cs = cStart;\\n        int directionIndex = 0;\\n        int steps = 1;\\n        while (in < rows * cols) {\\n            for (int i = 0; i < steps; i++) {\\n                if (rs >= 0 && rs < rows && cs >= 0 && cs < cols) {\\n                    mat[in][0] = rs;\\n                    mat[in][1] = cs;\\n                    in++;\\n                }\\n                rs += directions[directionIndex][0];\\n                cs += directions[directionIndex][1];\\n            }\\n            if (directionIndex % 2 == 1) {\\n                steps++;\\n            }\\n            directionIndex = (directionIndex + 1) % 4;\\n        }\\n        return mat;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        int[][] mat = new int[rows * cols][2];\\n        int in = 0;\\n        int[][] directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\\n        int rs = rStart;\\n        int cs = cStart;\\n        int directionIndex = 0;\\n        int steps = 1;\\n        while (in < rows * cols) {\\n            for (int i = 0; i < steps; i++) {\\n                if (rs >= 0 && rs < rows && cs >= 0 && cs < cols) {\\n                    mat[in][0] = rs;\\n                    mat[in][1] = cs;\\n                    in++;\\n                }\\n                rs += directions[directionIndex][0];\\n                cs += directions[directionIndex][1];\\n            }\\n            if (directionIndex % 2 == 1) {\\n                steps++;\\n            }\\n            directionIndex = (directionIndex + 1) % 4;\\n        }\\n        return mat;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3861073,
                "title": "elegant-c-solution",
                "content": "\\n# Solution\\n\\nAdd start cell to the solution list. \\n\\nStart from given starting position and walk until result list contains all `R * C` cells.\\n\\n# Complexity\\n\\nWorst case scenario when $$R = 1$$, $$C > 1$$, and starting position $$(0, C-1)$$ corner. To reach $$(0, C-2)$$ we need to do spiral around, and trace $$3 *3$$ square before we reach starting position. To reach $$(0, C-3)$$ cell we must do $$5 * 5$$ moves. It is easy to see that the algorithm will require $$O(max(R, C)^2)$$ steps to walk all $$R*C$$ cells.\\n\\n# Code\\n\\n```\\n// define how to add pairs\\ntemplate<typename T, typename K>\\nvoid operator +=(pair<T,K> &lhs, const pair<T,K> &rhs) {\\n    lhs.first += rhs.first;\\n    lhs.second += rhs.second;\\n}\\n\\nclass Solution {\\n\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n\\n        pair<int, int> pos = { rStart, cStart};\\n    \\n        const vector<pair<int,int>> dirs = {\\n            {  0,  1 }, // E\\n            {  1,  0 }, // S\\n            {  0, -1 }, // W\\n            { -1,  0 }  // N\\n        };\\n\\n        vector<vector<int>> ans;\\n        ans.reserve(rows*cols); // from problem statement\\n        ans.push_back({pos.first, pos.second});\\n\\n        const int cnt = rows * cols;\\n\\n        int r = 1; // radius\\n        int s = 0; // steps\\n\\n        while (ans.size() < cnt) {\\n            const auto &move = dirs[s++ % dirs.size()];\\n\\n            for (int k = 0; k < r && ans.size() < cnt; ++k) {\\n                pos += move;\\n                \\n                if (pos.first == clamp(pos.first, 0, rows - 1) && \\n                    pos.second == clamp(pos.second, 0, cols - 1)) {\\n                    ans.push_back({pos.first, pos.second});\\n                }\\n            }\\n\\n            // every two steps increase radius\\n            if (s % 2 == 0) {\\n                r++;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n// define how to add pairs\\ntemplate<typename T, typename K>\\nvoid operator +=(pair<T,K> &lhs, const pair<T,K> &rhs) {\\n    lhs.first += rhs.first;\\n    lhs.second += rhs.second;\\n}\\n\\nclass Solution {\\n\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n\\n        pair<int, int> pos = { rStart, cStart};\\n    \\n        const vector<pair<int,int>> dirs = {\\n            {  0,  1 }, // E\\n            {  1,  0 }, // S\\n            {  0, -1 }, // W\\n            { -1,  0 }  // N\\n        };\\n\\n        vector<vector<int>> ans;\\n        ans.reserve(rows*cols); // from problem statement\\n        ans.push_back({pos.first, pos.second});\\n\\n        const int cnt = rows * cols;\\n\\n        int r = 1; // radius\\n        int s = 0; // steps\\n\\n        while (ans.size() < cnt) {\\n            const auto &move = dirs[s++ % dirs.size()];\\n\\n            for (int k = 0; k < r && ans.size() < cnt; ++k) {\\n                pos += move;\\n                \\n                if (pos.first == clamp(pos.first, 0, rows - 1) && \\n                    pos.second == clamp(pos.second, 0, cols - 1)) {\\n                    ans.push_back({pos.first, pos.second});\\n                }\\n            }\\n\\n            // every two steps increase radius\\n            if (s % 2 == 0) {\\n                r++;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3849650,
                "title": "clean-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe algorithm generates a spiral path by simulating movement starting from a given position. It traverses right, down, left, and up in a spiral pattern, increasing the step length to cover all cells.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUsing sets, the algorithm tracks already traversed and all possible coordinates. It ensures cell validity and avoids revisiting cells. By incrementally updating the step length, it efficiently covers all cells in the grid. The output grid is constructed with the visited cells in the order of traversal, forming a spiral pattern that represents the desired path. This approach ensures a complete and optimized traversal of the grid to solve the spiral matrix III problem.\\n# Complexity\\n- Time complexity: O(row^2 + column^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(row * column)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        // Create an unordered_set to store the coordinates of all cells in the grid\\n        unordered_set<string> coordinates;\\n        for (int r = 0; r < rows; r++) {\\n            for (int c = 0; c < cols; c++) {\\n                // Convert the row and column indices to a string and insert into the set\\n                coordinates.insert(to_string(r) + \"-\" + to_string(c));\\n            }\\n        }\\n\\n        // Create an unordered_set to store the already traversed coordinates\\n        unordered_set<string> AlreadyTraversed;\\n\\n        // Create a vector to store the final output grid\\n        vector<vector<int>> OutputGrid;\\n\\n        // Initialize the current row and column with the starting positions\\n        int curr_row = rStart;\\n        int curr_column = cStart;\\n\\n        // Push the starting cell into the output grid\\n        OutputGrid.push_back(vector<int>{curr_row, curr_column});\\n\\n        // Mark the starting cell as already traversed\\n        AlreadyTraversed.insert(to_string(curr_row) + \"-\" + to_string(curr_column));\\n\\n        // Initialize the current step length to 1\\n        int curr = 1;\\n\\n        // Continue traversing until all cells have been visited\\n        while (AlreadyTraversed.size() != coordinates.size()) {\\n            // Traverse to the right\\n            for (int i = 0; i < curr; i++) {\\n                // Move to the next right cell\\n                curr_column++;\\n\\n                // If the cell is within the grid and not already traversed\\n                if (coordinates.find(to_string(curr_row) + \"-\" + to_string(curr_column)) != coordinates.end()) {\\n                    // Push it to the output array\\n                    OutputGrid.push_back(vector<int>{curr_row, curr_column});\\n\\n                    // Mark it as already traversed\\n                    AlreadyTraversed.insert(to_string(curr_row) + \"-\" + to_string(curr_column));\\n                }\\n            }\\n\\n            // Traverse down\\n            for (int i = 0; i < curr; i++) {\\n                // Move down by 1\\n                curr_row++;\\n\\n                // If the cell is within the grid and not already traversed\\n                if (coordinates.find(to_string(curr_row) + \"-\" + to_string(curr_column)) != coordinates.end()) {\\n                    // Push it to the output array\\n                    OutputGrid.push_back(vector<int>{curr_row, curr_column});\\n\\n                    // Mark it as already traversed\\n                    AlreadyTraversed.insert(to_string(curr_row) + \"-\" + to_string(curr_column));\\n                }\\n            }\\n\\n            // Increment the current step length\\n            curr++;\\n\\n            // Traverse to the left\\n            for (int i = 0; i < curr; i++) {\\n                // Move left by one\\n                curr_column--;\\n\\n                // If the cell is within the grid and not already traversed\\n                if (coordinates.find(to_string(curr_row) + \"-\" + to_string(curr_column)) != coordinates.end()) {\\n                    // Push it to the output array\\n                    OutputGrid.push_back(vector<int>{curr_row, curr_column});\\n\\n                    // Mark it as already traversed\\n                    AlreadyTraversed.insert(to_string(curr_row) + \"-\" + to_string(curr_column));\\n                }\\n            }\\n\\n            // Traverse up\\n            for (int i = 0; i < curr; i++) {\\n                // Move up by 1\\n                curr_row--;\\n\\n                // If the cell is within the grid and not already traversed\\n                if (coordinates.find(to_string(curr_row) + \"-\" + to_string(curr_column)) != coordinates.end()) {\\n                    // Push it to the output array\\n                    OutputGrid.push_back(vector<int>{curr_row, curr_column});\\n\\n                    // Mark it as already traversed\\n                    AlreadyTraversed.insert(to_string(curr_row) + \"-\" + to_string(curr_column));\\n                }\\n            }\\n\\n            // Increment the current step length\\n            curr++;\\n        }\\n\\n        // Return the final output grid containing the spiral path\\n        return OutputGrid;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Matrix",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        // Create an unordered_set to store the coordinates of all cells in the grid\\n        unordered_set<string> coordinates;\\n        for (int r = 0; r < rows; r++) {\\n            for (int c = 0; c < cols; c++) {\\n                // Convert the row and column indices to a string and insert into the set\\n                coordinates.insert(to_string(r) + \"-\" + to_string(c));\\n            }\\n        }\\n\\n        // Create an unordered_set to store the already traversed coordinates\\n        unordered_set<string> AlreadyTraversed;\\n\\n        // Create a vector to store the final output grid\\n        vector<vector<int>> OutputGrid;\\n\\n        // Initialize the current row and column with the starting positions\\n        int curr_row = rStart;\\n        int curr_column = cStart;\\n\\n        // Push the starting cell into the output grid\\n        OutputGrid.push_back(vector<int>{curr_row, curr_column});\\n\\n        // Mark the starting cell as already traversed\\n        AlreadyTraversed.insert(to_string(curr_row) + \"-\" + to_string(curr_column));\\n\\n        // Initialize the current step length to 1\\n        int curr = 1;\\n\\n        // Continue traversing until all cells have been visited\\n        while (AlreadyTraversed.size() != coordinates.size()) {\\n            // Traverse to the right\\n            for (int i = 0; i < curr; i++) {\\n                // Move to the next right cell\\n                curr_column++;\\n\\n                // If the cell is within the grid and not already traversed\\n                if (coordinates.find(to_string(curr_row) + \"-\" + to_string(curr_column)) != coordinates.end()) {\\n                    // Push it to the output array\\n                    OutputGrid.push_back(vector<int>{curr_row, curr_column});\\n\\n                    // Mark it as already traversed\\n                    AlreadyTraversed.insert(to_string(curr_row) + \"-\" + to_string(curr_column));\\n                }\\n            }\\n\\n            // Traverse down\\n            for (int i = 0; i < curr; i++) {\\n                // Move down by 1\\n                curr_row++;\\n\\n                // If the cell is within the grid and not already traversed\\n                if (coordinates.find(to_string(curr_row) + \"-\" + to_string(curr_column)) != coordinates.end()) {\\n                    // Push it to the output array\\n                    OutputGrid.push_back(vector<int>{curr_row, curr_column});\\n\\n                    // Mark it as already traversed\\n                    AlreadyTraversed.insert(to_string(curr_row) + \"-\" + to_string(curr_column));\\n                }\\n            }\\n\\n            // Increment the current step length\\n            curr++;\\n\\n            // Traverse to the left\\n            for (int i = 0; i < curr; i++) {\\n                // Move left by one\\n                curr_column--;\\n\\n                // If the cell is within the grid and not already traversed\\n                if (coordinates.find(to_string(curr_row) + \"-\" + to_string(curr_column)) != coordinates.end()) {\\n                    // Push it to the output array\\n                    OutputGrid.push_back(vector<int>{curr_row, curr_column});\\n\\n                    // Mark it as already traversed\\n                    AlreadyTraversed.insert(to_string(curr_row) + \"-\" + to_string(curr_column));\\n                }\\n            }\\n\\n            // Traverse up\\n            for (int i = 0; i < curr; i++) {\\n                // Move up by 1\\n                curr_row--;\\n\\n                // If the cell is within the grid and not already traversed\\n                if (coordinates.find(to_string(curr_row) + \"-\" + to_string(curr_column)) != coordinates.end()) {\\n                    // Push it to the output array\\n                    OutputGrid.push_back(vector<int>{curr_row, curr_column});\\n\\n                    // Mark it as already traversed\\n                    AlreadyTraversed.insert(to_string(curr_row) + \"-\" + to_string(curr_column));\\n                }\\n            }\\n\\n            // Increment the current step length\\n            curr++;\\n        }\\n\\n        // Return the final output grid containing the spiral path\\n        return OutputGrid;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3828031,
                "title": "java-straightforward-simulation",
                "content": "The square we walk in grows its sides by **2** each iteration; i.e., **1 x 1**-> **3 x 3**-> **5 x 5**. The walk down needs to be one shorter than the others, and the walk right needs to be one longer.\\n\\n```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        int[][] res = new int[rows * cols][2];\\n        \\n        int x = rStart, y = cStart, idx = 0, spiralSize = 1;\\n        while (idx < res.length) {\\n            //walk down\\n            for (int i = 0; i < spiralSize - 2; i++) {\\n                if (x >= 0 && y >= 0 && x < rows && y < cols)\\n                    res[idx++] = new int[]{x, y};\\n                x++;\\n            }\\n            //walk left\\n            for (int i = 0; i < spiralSize - 1; i++) {\\n                if (x >= 0 && y >= 0 && x < rows && y < cols)\\n                    res[idx++] = new int[]{x, y};\\n                y--;\\n            }\\n            //walk up\\n            for (int i = 0; i < spiralSize - 1; i++) {\\n                if (x >= 0 && y >= 0 && x < rows && y < cols)\\n                    res[idx++] = new int[]{x, y};\\n                x--;\\n            }\\n            //walk right\\n            for (int i = 0; i < spiralSize; i++) {\\n                if (x >= 0 && y >= 0 && x < rows && y < cols)\\n                    res[idx++] = new int[]{x, y};\\n                y++;\\n            }\\n            spiralSize += 2;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        int[][] res = new int[rows * cols][2];\\n        \\n        int x = rStart, y = cStart, idx = 0, spiralSize = 1;\\n        while (idx < res.length) {\\n            //walk down\\n            for (int i = 0; i < spiralSize - 2; i++) {\\n                if (x >= 0 && y >= 0 && x < rows && y < cols)\\n                    res[idx++] = new int[]{x, y};\\n                x++;\\n            }\\n            //walk left\\n            for (int i = 0; i < spiralSize - 1; i++) {\\n                if (x >= 0 && y >= 0 && x < rows && y < cols)\\n                    res[idx++] = new int[]{x, y};\\n                y--;\\n            }\\n            //walk up\\n            for (int i = 0; i < spiralSize - 1; i++) {\\n                if (x >= 0 && y >= 0 && x < rows && y < cols)\\n                    res[idx++] = new int[]{x, y};\\n                x--;\\n            }\\n            //walk right\\n            for (int i = 0; i < spiralSize; i++) {\\n                if (x >= 0 && y >= 0 && x < rows && y < cols)\\n                    res[idx++] = new int[]{x, y};\\n                y++;\\n            }\\n            spiralSize += 2;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3815975,
                "title": "innovative-java-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        int max=rows*cols;\\n        int res[][]=new int[max][2];\\n        int i=1,minus=1,count=0;\\n        res[count++]=new int[]{rStart,cStart};\\n        while(count<max){\\n            for(int j=i;j>0;j--){\\n                cStart+=minus;\\n                if(rStart<rows && cStart<cols && rStart>=0 && cStart>=0){\\n                    res[count++]=new int[]{rStart,cStart};\\n                    if(count>=max) return res;\\n                }\\n            }\\n            for(int j=i;j>0;j--){\\n                rStart+=minus;\\n                if(rStart<rows && cStart<cols && rStart>=0 && cStart>=0){\\n                    res[count++]=new int[]{rStart,cStart};\\n                    if(count>=max) return res;\\n                }\\n            }\\n            minus*=-1;\\n            i++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        int max=rows*cols;\\n        int res[][]=new int[max][2];\\n        int i=1,minus=1,count=0;\\n        res[count++]=new int[]{rStart,cStart};\\n        while(count<max){\\n            for(int j=i;j>0;j--){\\n                cStart+=minus;\\n                if(rStart<rows && cStart<cols && rStart>=0 && cStart>=0){\\n                    res[count++]=new int[]{rStart,cStart};\\n                    if(count>=max) return res;\\n                }\\n            }\\n            for(int j=i;j>0;j--){\\n                rStart+=minus;\\n                if(rStart<rows && cStart<cols && rStart>=0 && cStart>=0){\\n                    res[count++]=new int[]{rStart,cStart};\\n                    if(count>=max) return res;\\n                }\\n            }\\n            minus*=-1;\\n            i++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3785773,
                "title": "python3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def spiralMatrixIII(self, rows: int, cols: int, rStart: int, cStart: int) -> List[List[int]]:\\n        directions = [(0 ,1), (1, 0), (0, -1), (-1, 0)]\\n        step = 0\\n        w = 2\\n        ret = [[rStart, cStart]]\\n        r, c = rStart, cStart\\n        while len(ret) < rows * cols:\\n            direction = directions[step % 4]\\n\\n            for i in range(1, w):\\n                r += direction[0]\\n                c += direction[1]\\n                if r >= 0 and r < rows and c >= 0 and c < cols:\\n                    ret.append([r, c])\\n\\n            step += 1\\n            if step % 2 == 0:\\n                w += 1\\n        return ret\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def spiralMatrixIII(self, rows: int, cols: int, rStart: int, cStart: int) -> List[List[int]]:\\n        directions = [(0 ,1), (1, 0), (0, -1), (-1, 0)]\\n        step = 0\\n        w = 2\\n        ret = [[rStart, cStart]]\\n        r, c = rStart, cStart\\n        while len(ret) < rows * cols:\\n            direction = directions[step % 4]\\n\\n            for i in range(1, w):\\n                r += direction[0]\\n                c += direction[1]\\n                if r >= 0 and r < rows and c >= 0 and c < cols:\\n                    ret.append([r, c])\\n\\n            step += 1\\n            if step % 2 == 0:\\n                w += 1\\n        return ret\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3773371,
                "title": "java-easy-understable-problem",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        int size = 1;\\n        int dir = 1;\\n        int result[][] = new int[rows * cols][2];\\n        result[0] = new int[]{rStart, cStart};\\n        \\n        while (size < rows * cols) {\\n            // for east\\n            int east = 1;\\n            while (east <= dir) {\\n                cStart++;\\n                if (check(rStart, cStart, rows, cols)) {\\n                    result[size] = new int[]{rStart, cStart};\\n                    size++;\\n                }\\n                east++;\\n            }\\n            \\n            // for south\\n            int south = 1;\\n            while (south <= dir) {\\n                rStart++;\\n                if (check(rStart, cStart, rows, cols)) {\\n                    result[size] = new int[]{rStart, cStart};\\n                    size++;\\n                }\\n                south++;\\n            }\\n            \\n            dir++;\\n            \\n            // for west\\n            int west = 1;\\n            while (west <= dir) {\\n                cStart--;\\n                if (check(rStart, cStart, rows, cols)) {\\n                    result[size] = new int[]{rStart, cStart};\\n                    size++;\\n                }\\n                west++;\\n            }\\n            \\n            // for north\\n            int north = 1;\\n            while (north <= dir) {\\n                rStart--;\\n                if (check(rStart, cStart, rows, cols)) {\\n                    result[size] = new int[]{rStart, cStart};\\n                    size++;\\n                }\\n                north++;\\n            }\\n            \\n            dir++;\\n        }\\n        \\n        return result;\\n    }\\n    \\n    public static boolean check(int row, int col, int rows, int cols) {\\n        return row >= 0 && row < rows && col >= 0 && col < cols;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        int size = 1;\\n        int dir = 1;\\n        int result[][] = new int[rows * cols][2];\\n        result[0] = new int[]{rStart, cStart};\\n        \\n        while (size < rows * cols) {\\n            // for east\\n            int east = 1;\\n            while (east <= dir) {\\n                cStart++;\\n                if (check(rStart, cStart, rows, cols)) {\\n                    result[size] = new int[]{rStart, cStart};\\n                    size++;\\n                }\\n                east++;\\n            }\\n            \\n            // for south\\n            int south = 1;\\n            while (south <= dir) {\\n                rStart++;\\n                if (check(rStart, cStart, rows, cols)) {\\n                    result[size] = new int[]{rStart, cStart};\\n                    size++;\\n                }\\n                south++;\\n            }\\n            \\n            dir++;\\n            \\n            // for west\\n            int west = 1;\\n            while (west <= dir) {\\n                cStart--;\\n                if (check(rStart, cStart, rows, cols)) {\\n                    result[size] = new int[]{rStart, cStart};\\n                    size++;\\n                }\\n                west++;\\n            }\\n            \\n            // for north\\n            int north = 1;\\n            while (north <= dir) {\\n                rStart--;\\n                if (check(rStart, cStart, rows, cols)) {\\n                    result[size] = new int[]{rStart, cStart};\\n                    size++;\\n                }\\n                north++;\\n            }\\n            \\n            dir++;\\n        }\\n        \\n        return result;\\n    }\\n    \\n    public static boolean check(int row, int col, int rows, int cols) {\\n        return row >= 0 && row < rows && col >= 0 && col < cols;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3741426,
                "title": "slow-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def spiralMatrixIII(self, rows: int, cols: int, rStart: int, cStart: int) -> List[List[int]]:\\n        matrix = []\\n        for i in range(rows):\\n            for j in range(cols):\\n                matrix.append([i,j])\\n        mypath = [[rStart, cStart]]\\n        mypoint = [rStart, cStart]\\n        offset = 1\\n        while len(mypath) < len(matrix):\\n            # right\\n            for i in range(1, offset+1):\\n                mypoint = [mypoint[0],mypoint[1]+1]\\n                if mypoint in matrix:\\n                    mypath.append(mypoint)\\n            # down\\n            for i in range(1, offset+1):\\n                mypoint = [mypoint[0]+1,mypoint[1]]\\n                if mypoint in matrix:\\n                    mypath.append(mypoint)\\n            offset += 1\\n            #left\\n            for i in range(1, offset+1):\\n                mypoint = [mypoint[0],mypoint[1]-1]\\n                if mypoint in matrix:\\n                    mypath.append(mypoint)\\n            # up\\n            for i in range(1, offset+1):\\n                mypoint = [mypoint[0]-1,mypoint[1]]\\n                if mypoint in matrix:\\n                    mypath.append(mypoint)\\n            offset += 1\\n            steps += 1\\n\\n\\n        return mypath\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def spiralMatrixIII(self, rows: int, cols: int, rStart: int, cStart: int) -> List[List[int]]:\\n        matrix = []\\n        for i in range(rows):\\n            for j in range(cols):\\n                matrix.append([i,j])\\n        mypath = [[rStart, cStart]]\\n        mypoint = [rStart, cStart]\\n        offset = 1\\n        while len(mypath) < len(matrix):\\n            # right\\n            for i in range(1, offset+1):\\n                mypoint = [mypoint[0],mypoint[1]+1]\\n                if mypoint in matrix:\\n                    mypath.append(mypoint)\\n            # down\\n            for i in range(1, offset+1):\\n                mypoint = [mypoint[0]+1,mypoint[1]]\\n                if mypoint in matrix:\\n                    mypath.append(mypoint)\\n            offset += 1\\n            #left\\n            for i in range(1, offset+1):\\n                mypoint = [mypoint[0],mypoint[1]-1]\\n                if mypoint in matrix:\\n                    mypath.append(mypoint)\\n            # up\\n            for i in range(1, offset+1):\\n                mypoint = [mypoint[0]-1,mypoint[1]]\\n                if mypoint in matrix:\\n                    mypath.append(mypoint)\\n            offset += 1\\n            steps += 1\\n\\n\\n        return mypath\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3734825,
                "title": "easiest-code-you-will-ever-find-beats-everyone",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def spiralMatrixIII(self, r: int, c: int, i: int, j: int) -> List[List[int]]:\\n\\n\\n        ans = []                                    \\n        rb, lb, ub, db = j, j, i, i                 \\n        while (len(ans) < r*c):                     \\n            while j < rb + 1:                       \\n                if(i<r and j<c and i>=0 and j>=0):  \\n                    ans.append([i, j])              \\n                j += 1                              \\n            rb += 1                                 \\n                                            \\n            while i < db + 1:                       \\n                if(i<r and j<c and i>=0 and j>=0):  \\n                    ans.append([i, j])              \\n                i += 1                              \\n            db += 1                                 \\n                                            \\n            while j > lb - 1:                       \\n                if(i<r and j<c and i>=0 and j>=0):  \\n                    ans.append([i, j])              \\n                j -= 1                              \\n            lb -= 1                                 \\n                                            \\n            while i > ub - 1:                       \\n                if(i<r and j<c and i>=0 and j>=0):  \\n                    ans.append([i, j])              \\n                i -= 1                              \\n            ub -= 1                                 \\n        return ans                                                      \\n                  \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def spiralMatrixIII(self, r: int, c: int, i: int, j: int) -> List[List[int]]:\\n\\n\\n        ans = []                                    \\n        rb, lb, ub, db = j, j, i, i                 \\n        while (len(ans) < r*c):                     \\n            while j < rb + 1:                       \\n                if(i<r and j<c and i>=0 and j>=0):  \\n                    ans.append([i, j])              \\n                j += 1                              \\n            rb += 1                                 \\n                                            \\n            while i < db + 1:                       \\n                if(i<r and j<c and i>=0 and j>=0):  \\n                    ans.append([i, j])              \\n                i += 1                              \\n            db += 1                                 \\n                                            \\n            while j > lb - 1:                       \\n                if(i<r and j<c and i>=0 and j>=0):  \\n                    ans.append([i, j])              \\n                j -= 1                              \\n            lb -= 1                                 \\n                                            \\n            while i > ub - 1:                       \\n                if(i<r and j<c and i>=0 and j>=0):  \\n                    ans.append([i, j])              \\n                i -= 1                              \\n            ub -= 1                                 \\n        return ans                                                      \\n                  \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3734049,
                "title": "c-termination-condition-one-loop-design-hard-problem-2023-july",
                "content": "July 7, 2023\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo be a good thinker, it takes a lot of practice. \\n\\nThe challenge part is to define termination condition for spiral matrix movement. With uncertain Spiral visit\\'s length, all nodes inside matrix should be able to be visited once. \\n\\nI also learn to write C# in short form, using int[,] instead of declaring two arrays. \\n\\n```\\n// clockwise, right, down, left, up\\nvar directions = new int[,] { { 0, 1 }, { 1, 0 }, { 0, -1 }, { -1, 0 } };\\n```\\n\\nBetter than the following\\n```\\n var directionRow = new int[] { 0, 1, 0, -1 };\\n var directionCol = new int[] { 1, 0, -1, 0 };\\n```\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAfter 6+ month break, I came back to warmup my C# coding skills to prepare Meta phone screen in 2 months. \\n\\nThe following are needed:\\n1. Work on basics of algorithm - start one algorithm a day, code one algorithm a day\\n2. Also challenge myself to solve more algorithms, really go through painful feelings to fail on some algorithms. \\n3. Get back on working on C# coding skills, one tip a time. \\n4. Trust myself to learn better, fail better.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nusing System;\\nusing System.Collections.Generic;\\nusing System.Diagnostics;\\nusing System.Linq;\\nusing System.Text;\\nusing System.Threading.Tasks;\\n\\nnamespace _885_spiral_matrix_III\\n{\\n    class Program\\n    {\\n        static void Main(string[] args)\\n        {\\n            var test = new Program();\\n\\n            var result = test.SpiralMatrixIII(1, 4, 0, 0);\\n            var sb = new StringBuilder();\\n            for (var i = 0; i < result.Length; i++)\\n            {\\n                sb.Append(string.Join(\"-\", result[i]));                \\n                sb.Append(\",\");\\n            }\\n            \\n            Debug.Assert(sb.ToString().CompareTo(\"0-0,0-1,0-2,0-3,\") == 0);\\n\\n            result = test.SpiralMatrixIII(5, 6, 1, 4);\\n        }\\n\\n        /// <summary>\\n        /// Spiral matrix \\n        /// study code\\n        /// https://leetcode.com/problems/spiral-matrix-iii/solutions/2837586/c/\\n        /// </summary>\\n        /// <param name=\"rows\"></param>\\n        /// <param name=\"cols\"></param>\\n        /// <param name=\"rStart\"></param>\\n        /// <param name=\"cStart\"></param>\\n        /// <returns></returns>\\n        public int[][] SpiralMatrixIII(int rows, int cols, int rStart, int cStart)\\n        {\\n            var result = new List<int[]>();\\n\\n            // clockwise, right, down, left, up\\n            var directions = new int[,] { { 0, 1 }, { 1, 0 }, { 0, -1 }, { -1, 0 } };\\n\\n            var steps = 0;\\n            var direction = 0;\\n\\n            result.Add(new int[] { rStart, cStart });\\n\\n            // based on two facts: All nodes will be visited in the matrix\\n            // step - 1, 1, 2, 2, 3, 3, ...\\n            // We do not care about nodes outside of matrix - just go through those nodes if needed\\n            // Think about more carefully - one loop - termination condition - ?\\n            while (result.Count < rows * cols)\\n            {\\n                //directions right---> or left <---, increase steps++\\n                if (direction == 0 || direction == 2)\\n                {\\n                    steps++;\\n                }\\n\\n                for (int index = 0; index < steps; index++)\\n                {\\n                    rStart += directions[direction, 0];\\n                    cStart += directions[direction, 1];\\n\\n                    // if it is in matrix range - out-of-range - just ignore\\n                    if (rStart < rows && rStart >= 0 && cStart < cols && cStart >= 0)\\n                    {\\n                        result.Add(new int[] { rStart, cStart });\\n                    }\\n                }\\n\\n                direction = (direction + 1) % 4;\\n            }\\n\\n            return result.ToArray();\\n        }\\n    }    \\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\n// clockwise, right, down, left, up\\nvar directions = new int[,] { { 0, 1 }, { 1, 0 }, { 0, -1 }, { -1, 0 } };\\n```\n```\\n var directionRow = new int[] { 0, 1, 0, -1 };\\n var directionCol = new int[] { 1, 0, -1, 0 };\\n```\n```\\nusing System;\\nusing System.Collections.Generic;\\nusing System.Diagnostics;\\nusing System.Linq;\\nusing System.Text;\\nusing System.Threading.Tasks;\\n\\nnamespace _885_spiral_matrix_III\\n{\\n    class Program\\n    {\\n        static void Main(string[] args)\\n        {\\n            var test = new Program();\\n\\n            var result = test.SpiralMatrixIII(1, 4, 0, 0);\\n            var sb = new StringBuilder();\\n            for (var i = 0; i < result.Length; i++)\\n            {\\n                sb.Append(string.Join(\"-\", result[i]));                \\n                sb.Append(\",\");\\n            }\\n            \\n            Debug.Assert(sb.ToString().CompareTo(\"0-0,0-1,0-2,0-3,\") == 0);\\n\\n            result = test.SpiralMatrixIII(5, 6, 1, 4);\\n        }\\n\\n        /// <summary>\\n        /// Spiral matrix \\n        /// study code\\n        /// https://leetcode.com/problems/spiral-matrix-iii/solutions/2837586/c/\\n        /// </summary>\\n        /// <param name=\"rows\"></param>\\n        /// <param name=\"cols\"></param>\\n        /// <param name=\"rStart\"></param>\\n        /// <param name=\"cStart\"></param>\\n        /// <returns></returns>\\n        public int[][] SpiralMatrixIII(int rows, int cols, int rStart, int cStart)\\n        {\\n            var result = new List<int[]>();\\n\\n            // clockwise, right, down, left, up\\n            var directions = new int[,] { { 0, 1 }, { 1, 0 }, { 0, -1 }, { -1, 0 } };\\n\\n            var steps = 0;\\n            var direction = 0;\\n\\n            result.Add(new int[] { rStart, cStart });\\n\\n            // based on two facts: All nodes will be visited in the matrix\\n            // step - 1, 1, 2, 2, 3, 3, ...\\n            // We do not care about nodes outside of matrix - just go through those nodes if needed\\n            // Think about more carefully - one loop - termination condition - ?\\n            while (result.Count < rows * cols)\\n            {\\n                //directions right---> or left <---, increase steps++\\n                if (direction == 0 || direction == 2)\\n                {\\n                    steps++;\\n                }\\n\\n                for (int index = 0; index < steps; index++)\\n                {\\n                    rStart += directions[direction, 0];\\n                    cStart += directions[direction, 1];\\n\\n                    // if it is in matrix range - out-of-range - just ignore\\n                    if (rStart < rows && rStart >= 0 && cStart < cols && cStart >= 0)\\n                    {\\n                        result.Add(new int[] { rStart, cStart });\\n                    }\\n                }\\n\\n                direction = (direction + 1) % 4;\\n            }\\n\\n            return result.ToArray();\\n        }\\n    }    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3723058,
                "title": "c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n class Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        vector<vector<int>> result;\\n        \\n        // Initialize the boundary variables\\n        int left = cStart - 1;\\n        int right = cStart + 1;\\n        int top = rStart - 1;\\n        int bottom = rStart + 1;\\n        \\n        // Add the initial position to the result\\n        result.push_back({rStart, cStart});\\n\\n        // Continue until all positions are covered\\n        while (left > -1 || right < cols || top > -1 || bottom < rows) {\\n            // Traverse right from top to bottom\\n            if (right < cols) {\\n                for (int i = top + 1; i < bottom; i++) {\\n                    result.push_back({i, right});\\n                }\\n                right++;\\n            }\\n            \\n            // Traverse down from right to left\\n            if (bottom < rows) {\\n                for (int i = right - 1; i > left; i--) {\\n                    result.push_back({bottom, i});\\n                }\\n                bottom++;\\n            }\\n            \\n            // Traverse left from bottom to top\\n            if (left > -1) {\\n                for (int i = bottom - 1; i > top; i--) {\\n                    result.push_back({i, left});\\n                }\\n                left--;\\n            }\\n            \\n            // Traverse up from left to right\\n            if (top > -1) {\\n                for (int i = left + 1; i < right; i++) {\\n                    result.push_back({top, i});\\n                }\\n                top--;\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n class Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        vector<vector<int>> result;\\n        \\n        // Initialize the boundary variables\\n        int left = cStart - 1;\\n        int right = cStart + 1;\\n        int top = rStart - 1;\\n        int bottom = rStart + 1;\\n        \\n        // Add the initial position to the result\\n        result.push_back({rStart, cStart});\\n\\n        // Continue until all positions are covered\\n        while (left > -1 || right < cols || top > -1 || bottom < rows) {\\n            // Traverse right from top to bottom\\n            if (right < cols) {\\n                for (int i = top + 1; i < bottom; i++) {\\n                    result.push_back({i, right});\\n                }\\n                right++;\\n            }\\n            \\n            // Traverse down from right to left\\n            if (bottom < rows) {\\n                for (int i = right - 1; i > left; i--) {\\n                    result.push_back({bottom, i});\\n                }\\n                bottom++;\\n            }\\n            \\n            // Traverse left from bottom to top\\n            if (left > -1) {\\n                for (int i = bottom - 1; i > top; i--) {\\n                    result.push_back({i, left});\\n                }\\n                left--;\\n            }\\n            \\n            // Traverse up from left to right\\n            if (top > -1) {\\n                for (int i = left + 1; i < right; i++) {\\n                    result.push_back({top, i});\\n                }\\n                top--;\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3705690,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        \\n        int[][] matrix = new int[rows*cols][2];\\n        int i=0;\\n        // 0th row is filled and i is incremented afterwards\\n        matrix[i++]=new int[]{rStart,cStart};\\n\\n        int d=0; // for direction moving\\n        //to move in all directions as per the need\\n        int[] directions = new int[]{0,1,0,-1,0}; \\n        int length =0;\\n\\n        while(i < rows*cols)\\n        {\\n            if(d==0 || d==2) // length need not to be incremnted in case of 3 or 4\\n            {\\n                length++;\\n            }\\n          //loop will run the length times\\n            for(int j=0; j<length; j++)\\n            {\\n                rStart += directions[d];\\n                cStart += directions[d+1];\\n                if(rStart>=0 && rStart<rows && cStart>=0 && cStart<cols)\\n                {\\n                    matrix[i++] = new int[]{rStart,cStart};\\n                }\\n            }\\n            d = ++d % 4;\\n        }\\n        return matrix;\\n    }\\n}\\n```\\n\\nUpvote please\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        \\n        int[][] matrix = new int[rows*cols][2];\\n        int i=0;\\n        // 0th row is filled and i is incremented afterwards\\n        matrix[i++]=new int[]{rStart,cStart};\\n\\n        int d=0; // for direction moving\\n        //to move in all directions as per the need\\n        int[] directions = new int[]{0,1,0,-1,0}; \\n        int length =0;\\n\\n        while(i < rows*cols)\\n        {\\n            if(d==0 || d==2) // length need not to be incremnted in case of 3 or 4\\n            {\\n                length++;\\n            }\\n          //loop will run the length times\\n            for(int j=0; j<length; j++)\\n            {\\n                rStart += directions[d];\\n                cStart += directions[d+1];\\n                if(rStart>=0 && rStart<rows && cStart>=0 && cStart<cols)\\n                {\\n                    matrix[i++] = new int[]{rStart,cStart};\\n                }\\n            }\\n            d = ++d % 4;\\n        }\\n        return matrix;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3684268,
                "title": "c-very-fast-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        vector<vector<int>> ans;\\n        ans.reserve(rows*cols);\\n\\n        enum directions {RIGHT, DOWN, LEFT, UP};\\n        int dir = RIGHT;\\n        int step = 1;\\n        int countAll = rows*cols;\\n\\n        int i = rStart;\\n        int j = cStart;\\n\\n        while(countAll > 0) {\\n            if (dir == RIGHT) {\\n                if (i >=0 && i < rows)\\n                for(int k = max(j, 0), maxK = min(j+step-1, cols-1); k <= maxK; k++) {\\n                    ans.push_back({i, k});\\n                    countAll--;\\n                }\\n                j += step;\\n                dir = DOWN;\\n            } else if (dir == DOWN) {\\n                if (j >=0 && j < cols)\\n                for(int k = max(i, 0), maxK = min(i+step-1, rows-1); k <= maxK; k++) {\\n                    ans.push_back({k, j});\\n                    countAll--;\\n                }\\n                i += step;\\n                step++;\\n                dir = LEFT;\\n            }if (dir == LEFT) {\\n                if (i >=0 && i < rows)\\n                for(int k = min(j, cols-1), minK = max(j-step+1, 0); k >= minK; k--) {\\n                    ans.push_back({i, k});\\n                    countAll--;\\n                }\\n                j -= step;\\n                dir = UP;\\n            } else if (dir == UP) {\\n                if (j >=0 && j < cols)\\n                for(int k = min(i, rows-1), minK = max(i-step+1, 0); k >= minK; k--) {\\n                    ans.push_back({k, j});\\n                    countAll--;\\n                }\\n                i -= step;\\n                step++;\\n                dir = RIGHT;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        vector<vector<int>> ans;\\n        ans.reserve(rows*cols);\\n\\n        enum directions {RIGHT, DOWN, LEFT, UP};\\n        int dir = RIGHT;\\n        int step = 1;\\n        int countAll = rows*cols;\\n\\n        int i = rStart;\\n        int j = cStart;\\n\\n        while(countAll > 0) {\\n            if (dir == RIGHT) {\\n                if (i >=0 && i < rows)\\n                for(int k = max(j, 0), maxK = min(j+step-1, cols-1); k <= maxK; k++) {\\n                    ans.push_back({i, k});\\n                    countAll--;\\n                }\\n                j += step;\\n                dir = DOWN;\\n            } else if (dir == DOWN) {\\n                if (j >=0 && j < cols)\\n                for(int k = max(i, 0), maxK = min(i+step-1, rows-1); k <= maxK; k++) {\\n                    ans.push_back({k, j});\\n                    countAll--;\\n                }\\n                i += step;\\n                step++;\\n                dir = LEFT;\\n            }if (dir == LEFT) {\\n                if (i >=0 && i < rows)\\n                for(int k = min(j, cols-1), minK = max(j-step+1, 0); k >= minK; k--) {\\n                    ans.push_back({i, k});\\n                    countAll--;\\n                }\\n                j -= step;\\n                dir = UP;\\n            } else if (dir == UP) {\\n                if (j >=0 && j < cols)\\n                for(int k = min(i, rows-1), minK = max(i-step+1, 0); k >= minK; k--) {\\n                    ans.push_back({k, j});\\n                    countAll--;\\n                }\\n                i -= step;\\n                step++;\\n                dir = RIGHT;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3657077,
                "title": "solution-with-comments-3",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        int[][] result = new int[rows * cols][2];\\n        int[][] directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\\n        int directionIndex = 0;\\n        int currentRow = rStart;\\n        int currentCol = cStart;\\n        int count = 0;\\n        int stepsInCurrentDirection = 1;\\n\\n        while (count < rows * cols) {\\n            for (int i = 0; i < 2; i++) {  // \\u041E\\u0431\\u0440\\u043E\\u0431\\u043A\\u0430 \\u0434\\u0432\\u043E\\u0445 \\u043A\\u0440\\u043E\\u043A\\u0456\\u0432 \\u0443 \\u043F\\u043E\\u0442\\u043E\\u0447\\u043D\\u043E\\u043C\\u0443 \\u043D\\u0430\\u043F\\u0440\\u044F\\u043C\\u043A\\u0443\\n                for (int j = 0; j < stepsInCurrentDirection; j++) {\\n                    if (currentRow >= 0 && currentRow < rows && currentCol >= 0 && currentCol < cols) {\\n                        result[count++] = new int[]{currentRow, currentCol};\\n                    }\\n                    currentRow += directions[directionIndex][0];\\n                    currentCol += directions[directionIndex][1];\\n                    if (count == rows * cols) {\\n                        return result;  // \\u0412\\u0441\\u0456 \\u043F\\u043E\\u0437\\u0438\\u0446\\u0456\\u0457 \\u0432\\u0456\\u0434\\u0432\\u0456\\u0434\\u0430\\u043D\\u0456, \\u043F\\u043E\\u0432\\u0435\\u0440\\u0442\\u0430\\u0454\\u043C\\u043E \\u0440\\u0435\\u0437\\u0443\\u043B\\u044C\\u0442\\u0430\\u0442\\n                    }\\n                }\\n                directionIndex = (directionIndex + 1) % 4;  // \\u0417\\u043C\\u0456\\u043D\\u0430 \\u043D\\u0430\\u043F\\u0440\\u044F\\u043C\\u043A\\u0443\\n            }\\n            stepsInCurrentDirection++;  // \\u0417\\u0431\\u0456\\u043B\\u044C\\u0448\\u0435\\u043D\\u043D\\u044F \\u043A\\u0456\\u043B\\u044C\\u043A\\u043E\\u0441\\u0442\\u0456 \\u043A\\u0440\\u043E\\u043A\\u0456\\u0432 \\u0443 \\u043D\\u0430\\u0441\\u0442\\u0443\\u043F\\u043D\\u043E\\u043C\\u0443 \\u043D\\u0430\\u043F\\u0440\\u044F\\u043C\\u043A\\u0443\\n        }\\n\\n        return result;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        int[][] result = new int[rows * cols][2];\\n        int[][] directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\\n        int directionIndex = 0;\\n        int currentRow = rStart;\\n        int currentCol = cStart;\\n        int count = 0;\\n        int stepsInCurrentDirection = 1;\\n\\n        while (count < rows * cols) {\\n            for (int i = 0; i < 2; i++) {  // \\u041E\\u0431\\u0440\\u043E\\u0431\\u043A\\u0430 \\u0434\\u0432\\u043E\\u0445 \\u043A\\u0440\\u043E\\u043A\\u0456\\u0432 \\u0443 \\u043F\\u043E\\u0442\\u043E\\u0447\\u043D\\u043E\\u043C\\u0443 \\u043D\\u0430\\u043F\\u0440\\u044F\\u043C\\u043A\\u0443\\n                for (int j = 0; j < stepsInCurrentDirection; j++) {\\n                    if (currentRow >= 0 && currentRow < rows && currentCol >= 0 && currentCol < cols) {\\n                        result[count++] = new int[]{currentRow, currentCol};\\n                    }\\n                    currentRow += directions[directionIndex][0];\\n                    currentCol += directions[directionIndex][1];\\n                    if (count == rows * cols) {\\n                        return result;  // \\u0412\\u0441\\u0456 \\u043F\\u043E\\u0437\\u0438\\u0446\\u0456\\u0457 \\u0432\\u0456\\u0434\\u0432\\u0456\\u0434\\u0430\\u043D\\u0456, \\u043F\\u043E\\u0432\\u0435\\u0440\\u0442\\u0430\\u0454\\u043C\\u043E \\u0440\\u0435\\u0437\\u0443\\u043B\\u044C\\u0442\\u0430\\u0442\\n                    }\\n                }\\n                directionIndex = (directionIndex + 1) % 4;  // \\u0417\\u043C\\u0456\\u043D\\u0430 \\u043D\\u0430\\u043F\\u0440\\u044F\\u043C\\u043A\\u0443\\n            }\\n            stepsInCurrentDirection++;  // \\u0417\\u0431\\u0456\\u043B\\u044C\\u0448\\u0435\\u043D\\u043D\\u044F \\u043A\\u0456\\u043B\\u044C\\u043A\\u043E\\u0441\\u0442\\u0456 \\u043A\\u0440\\u043E\\u043A\\u0456\\u0432 \\u0443 \\u043D\\u0430\\u0441\\u0442\\u0443\\u043F\\u043D\\u043E\\u043C\\u0443 \\u043D\\u0430\\u043F\\u0440\\u044F\\u043C\\u043A\\u0443\\n        }\\n\\n        return result;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3649528,
                "title": "python",
                "content": "\\n# Code\\n```\\nclass Solution:\\n\\n    def spiralMatrixIII(self, rows: int, cols: int, rStart: int, cStart: int) -> List[List[int]]:\\n        total = rows * cols\\n        if total == 1:\\n            return [[rStart, cStart]]\\n        c = 1\\n        step = 0\\n        jump = 1\\n        dirs = [(0,1), (1,0), (0,-1), (-1,0)]\\n        idx = 0\\n        d = dirs[idx]\\n\\n        i = rStart\\n        j = cStart\\n        matrix = [[0 for _ in range(cols)] for _ in range(rows)]\\n        matrix[rStart][cStart] = 1\\n        res = [[rStart, cStart]]\\n\\n        while c <= total:\\n\\n            inext = i + d[0] * jump\\n            jnext = j + d[1] * jump\\n            if idx < 2:\\n                ds = 1\\n                istart = i\\n                iend = inext+1\\n                jstart = j\\n                jend = jnext+1\\n            else:\\n                ds = -1\\n                istart = i\\n                iend = inext-1\\n                jstart = j\\n                jend = jnext-1\\n\\n            for ic in range(istart, iend, ds):\\n                for jc in range(jstart, jend, ds):\\n                    if 0 <= ic < rows and 0 <= jc < cols and matrix[ic][jc] == 0:\\n                        c += 1\\n                        res.append([ic, jc])\\n                        matrix[ic][jc] = 1\\n                        if c == total:\\n\\n                            return res\\n\\n            step += 1\\n            \\n            if idx == 3:\\n                idx = 0\\n            else:\\n                idx += 1\\n            d = dirs[idx]\\n            \\n            if step == 2:\\n                step = 0\\n                jump += 1\\n            \\n            i = inext\\n            j = jnext\\n\\n        return res\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n\\n    def spiralMatrixIII(self, rows: int, cols: int, rStart: int, cStart: int) -> List[List[int]]:\\n        total = rows * cols\\n        if total == 1:\\n            return [[rStart, cStart]]\\n        c = 1\\n        step = 0\\n        jump = 1\\n        dirs = [(0,1), (1,0), (0,-1), (-1,0)]\\n        idx = 0\\n        d = dirs[idx]\\n\\n        i = rStart\\n        j = cStart\\n        matrix = [[0 for _ in range(cols)] for _ in range(rows)]\\n        matrix[rStart][cStart] = 1\\n        res = [[rStart, cStart]]\\n\\n        while c <= total:\\n\\n            inext = i + d[0] * jump\\n            jnext = j + d[1] * jump\\n            if idx < 2:\\n                ds = 1\\n                istart = i\\n                iend = inext+1\\n                jstart = j\\n                jend = jnext+1\\n            else:\\n                ds = -1\\n                istart = i\\n                iend = inext-1\\n                jstart = j\\n                jend = jnext-1\\n\\n            for ic in range(istart, iend, ds):\\n                for jc in range(jstart, jend, ds):\\n                    if 0 <= ic < rows and 0 <= jc < cols and matrix[ic][jc] == 0:\\n                        c += 1\\n                        res.append([ic, jc])\\n                        matrix[ic][jc] = 1\\n                        if c == total:\\n\\n                            return res\\n\\n            step += 1\\n            \\n            if idx == 3:\\n                idx = 0\\n            else:\\n                idx += 1\\n            d = dirs[idx]\\n            \\n            if step == 2:\\n                step = 0\\n                jump += 1\\n            \\n            i = inext\\n            j = jnext\\n\\n        return res\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3620449,
                "title": "brute-force",
                "content": "# Approach\\nSimilar to I and II, store direction in a deque, and use a counter to determine floor((n+1)/2) steps to take, for all natural number n.\\n\\nIf the coordinate is in grid, at coordinate to grid (or increment a counter). Continue this process until all coordinate in grid is collected. \\n\\n# Complexity\\n- Time complexity: O((max(rows, cols))^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(rows * cols)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def spiralMatrixIII(self, rows: int, cols: int, rStart: int, cStart: int) -> List[List[int]]:\\n        ret = [[rStart, cStart]]\\n        direction = deque([(0, 1), (1, 0), (0, -1), (-1, 0)])\\n        count = 2\\n\\n        while True:\\n            dx, dy = direction[0]\\n\\n            for i in range(count//2):\\n                rStart += dx\\n                cStart += dy\\n                \\n                if 0 <= rStart < rows and 0 <= cStart < cols:\\n                    ret.append([rStart, cStart]) \\n            \\n            if len(ret) == rows * cols:\\n                return ret\\n            \\n            direction.rotate(-1)\\n            count += 1\\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def spiralMatrixIII(self, rows: int, cols: int, rStart: int, cStart: int) -> List[List[int]]:\\n        ret = [[rStart, cStart]]\\n        direction = deque([(0, 1), (1, 0), (0, -1), (-1, 0)])\\n        count = 2\\n\\n        while True:\\n            dx, dy = direction[0]\\n\\n            for i in range(count//2):\\n                rStart += dx\\n                cStart += dy\\n                \\n                if 0 <= rStart < rows and 0 <= cStart < cols:\\n                    ret.append([rStart, cStart]) \\n            \\n            if len(ret) == rows * cols:\\n                return ret\\n            \\n            direction.rotate(-1)\\n            count += 1\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3613845,
                "title": "simple-simulation",
                "content": "# Approach\\nWe simulate spiral traversal. When we are inside given boundaries we append to the result.\\n\\n# Complexity\\n- Time complexity: $$O(4*rows*cols)$$ ~ $$O(rows*cols)$$.\\n\\n- Space complexity: $$O(rows*cols)$$.\\n\\n# Code\\n```\\nclass Solution:\\n    def spiralMatrixIII(self, rows: int, cols: int, rStart: int, cStart: int) -> List[List[int]]:\\n        directions = ((0, 1), (1, 0), (0, -1), (-1, 0))\\n        curDir = 0\\n        result = []\\n        r, c = rStart, cStart\\n        steps = 1\\n        n = 0\\n        while n < rows*cols:\\n            for _ in range(2):\\n                for _ in range(steps):\\n                    if 0 <= r < rows and 0 <= c < cols:\\n                        result.append([r,c])\\n                        n += 1\\n\\n                    r += directions[curDir][0]\\n                    c += directions[curDir][1]\\n            \\n                curDir = (curDir + 1)%len(directions)\\n\\n            steps += 1\\n\\n        return result\\n```",
                "solutionTags": [
                    "Python3",
                    "Matrix",
                    "Simulation"
                ],
                "code": "```\\nclass Solution:\\n    def spiralMatrixIII(self, rows: int, cols: int, rStart: int, cStart: int) -> List[List[int]]:\\n        directions = ((0, 1), (1, 0), (0, -1), (-1, 0))\\n        curDir = 0\\n        result = []\\n        r, c = rStart, cStart\\n        steps = 1\\n        n = 0\\n        while n < rows*cols:\\n            for _ in range(2):\\n                for _ in range(steps):\\n                    if 0 <= r < rows and 0 <= c < cols:\\n                        result.append([r,c])\\n                        n += 1\\n\\n                    r += directions[curDir][0]\\n                    c += directions[curDir][1]\\n            \\n                curDir = (curDir + 1)%len(directions)\\n\\n            steps += 1\\n\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3605129,
                "title": "c-solution-with-explanation",
                "content": "# EXPLANATION\\nWe created 2-D vector **v** for our traversal.\\nStored the given coordinates in **i** and **j** respectively.\\nCreated a 2-D vector **ans** for our answer.\\n\\nLet\\'s see the idea:-\\nWe took bool\\na = for traversal left to right (if possible)\\nb = for traversal top to bottom (if possible)\\nc = for traversal right to left (if possible)\\nd = for traversal bottom to top (if possible)\\nThe idea is to keep track of 4 index to check if traversal is possible or not. The coordinates of 4-index are stored in vector **p**.\\nIn the first set of the conditions we we checked if the 4 point are going to lie in **v** or not.\\nInside big while loop\\nWe traversed in spiral form and on every inner loop, we checked if we are not out of vector and simultaneously added the coordinates in **ans**.\\nFinally returned the answer.\\nIT WILL BE BETTER IF THE CODE IS DRY RUN FOR JUST ONE SPIRAL MOVEMENT, FOR BETTER UNDERSTANDING.\\nIn this we need to check for condition of corner cases too.\\n# SOLUTION\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        vector<vector<int>> v(rows,vector<int>(cols,0));\\n        int i=rStart,j=cStart;\\n        vector<vector<int>> ans;\\n        bool a=true,b=true,c=true,d=true;\\n        vector<vector<int>> p={{i,j},{i,j+1},{i+1,j},{i,j-1}};\\n        if(p[1][1]>=cols)\\n            b=false;\\n        if(p[2][0]>=rows)\\n            c=false;\\n        else if(p[2][1]+1<cols)\\n            p[2][1]++;\\n        if(p[3][1]<0)\\n            d=false;\\n        else if(p[3][0]+1<rows)\\n            p[3][0]++;\\n        while(a || b || c || d){\\n            if(a){\\n                int x=p[0][0],y=p[0][1];\\n                while(y<cols && y!=p[1][1])\\n                    ans.push_back({x,y++});\\n                p[0][0]--;\\n                if(p[0][0]<0)\\n                    a=false;\\n                (p[0][1]-1<0)?:p[0][1]--;\\n            }\\n            if(b){\\n                int x=p[1][0],y=p[1][1];\\n                while(x<rows && x!=p[2][0])\\n                    ans.push_back({x++,y});\\n                p[1][1]++;\\n                if(p[1][1]>=cols)\\n                    b=false;\\n                (p[1][0]-1<0)?:p[1][0]--;\\n            }\\n            if(c){\\n                int x=p[2][0],y=p[2][1];\\n                while(y>=0 && y!=p[3][1])\\n                    ans.push_back({x,y--});\\n                p[2][0]++;\\n                if(p[2][0]>=rows)\\n                    c=false;\\n                (p[2][1]+1>=cols)?:p[2][1]++;\\n            }\\n            if(d){\\n                int x=p[3][0],y=p[3][1];\\n                while(x>=0 && x!=p[0][0])\\n                    ans.push_back({x--,y});\\n                p[3][1]--;\\n                if(p[3][1]<0)\\n                    d=false;\\n                (p[3][0]+1>=rows)?:p[3][0]++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Matrix",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        vector<vector<int>> v(rows,vector<int>(cols,0));\\n        int i=rStart,j=cStart;\\n        vector<vector<int>> ans;\\n        bool a=true,b=true,c=true,d=true;\\n        vector<vector<int>> p={{i,j},{i,j+1},{i+1,j},{i,j-1}};\\n        if(p[1][1]>=cols)\\n            b=false;\\n        if(p[2][0]>=rows)\\n            c=false;\\n        else if(p[2][1]+1<cols)\\n            p[2][1]++;\\n        if(p[3][1]<0)\\n            d=false;\\n        else if(p[3][0]+1<rows)\\n            p[3][0]++;\\n        while(a || b || c || d){\\n            if(a){\\n                int x=p[0][0],y=p[0][1];\\n                while(y<cols && y!=p[1][1])\\n                    ans.push_back({x,y++});\\n                p[0][0]--;\\n                if(p[0][0]<0)\\n                    a=false;\\n                (p[0][1]-1<0)?:p[0][1]--;\\n            }\\n            if(b){\\n                int x=p[1][0],y=p[1][1];\\n                while(x<rows && x!=p[2][0])\\n                    ans.push_back({x++,y});\\n                p[1][1]++;\\n                if(p[1][1]>=cols)\\n                    b=false;\\n                (p[1][0]-1<0)?:p[1][0]--;\\n            }\\n            if(c){\\n                int x=p[2][0],y=p[2][1];\\n                while(y>=0 && y!=p[3][1])\\n                    ans.push_back({x,y--});\\n                p[2][0]++;\\n                if(p[2][0]>=rows)\\n                    c=false;\\n                (p[2][1]+1>=cols)?:p[2][1]++;\\n            }\\n            if(d){\\n                int x=p[3][0],y=p[3][1];\\n                while(x>=0 && x!=p[0][0])\\n                    ans.push_back({x--,y});\\n                p[3][1]--;\\n                if(p[3][1]<0)\\n                    d=false;\\n                (p[3][0]+1>=rows)?:p[3][0]++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3602266,
                "title": "python-straightforward-and-logical",
                "content": "# Intuition\\n1. Notice that we must traverse the spiral walk regardless if we are inside or outside the grid boundaries.\\n2. We will need to continue spiral walking until visiting all cells.\\n3. The spiral walk follows a pattern:\\n4. Move forward `k` steps, turn right, move forward `k` steps, turn right, then increment `k += 1`. \\n5. Each time we move, we visit the cell by checking if we are within the boundaries, if so, then we append to output.\\n\\n# Code\\n```\\nclass Solution:\\n    def spiralMatrixIII(self, rows: int, cols: int, rStart: int, cStart: int) -> List[List[int]]:\\n        moves = [(0, 1), (1, 0), (0, -1), (-1, 0)]\\n        d = 0\\n        k = 1\\n        x, y = rStart, cStart\\n        output = []\\n        output.append([x, y])\\n        while len(output) < rows * cols:\\n            # move forward k steps\\n            dx, dy = moves[d]\\n            for _ in range(k):\\n                x += dx\\n                y += dy\\n                if 0 <= x < rows and 0 <= y < cols:\\n                    output.append([x, y])\\n            # turn right\\n            d = (d + 1) % 4\\n            # move forward k steps\\n            dx, dy = moves[d]\\n            for _ in range(k):\\n                x += dx\\n                y += dy\\n                if 0 <= x < rows and 0 <= y < cols:\\n                    output.append([x, y])\\n            # turn right\\n            d = (d + 1) % 4\\n            # increment k\\n            k += 1\\n        \\n        return output\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Simulation"
                ],
                "code": "```\\nclass Solution:\\n    def spiralMatrixIII(self, rows: int, cols: int, rStart: int, cStart: int) -> List[List[int]]:\\n        moves = [(0, 1), (1, 0), (0, -1), (-1, 0)]\\n        d = 0\\n        k = 1\\n        x, y = rStart, cStart\\n        output = []\\n        output.append([x, y])\\n        while len(output) < rows * cols:\\n            # move forward k steps\\n            dx, dy = moves[d]\\n            for _ in range(k):\\n                x += dx\\n                y += dy\\n                if 0 <= x < rows and 0 <= y < cols:\\n                    output.append([x, y])\\n            # turn right\\n            d = (d + 1) % 4\\n            # move forward k steps\\n            dx, dy = moves[d]\\n            for _ in range(k):\\n                x += dx\\n                y += dy\\n                if 0 <= x < rows and 0 <= y < cols:\\n                    output.append([x, y])\\n            # turn right\\n            d = (d + 1) % 4\\n            # increment k\\n            k += 1\\n        \\n        return output\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3590449,
                "title": "go-simple-solution",
                "content": "```\\nfunc spiralMatrixIII(rows int, cols int, rStart int, cStart int) [][]int {\\n\\n\\tres := make([][]int, 0, rows*cols)\\n\\tres = append(res, []int{rStart, cStart})\\n\\n\\tcount := 1\\n\\tlimit := 1\\n\\tdirections := [][]int{{0, 1}, {1, 0}, {0, -1}, {-1, 0}}\\n\\tcol, row := cStart, rStart\\n\\tfor count != rows*cols {\\n\\t\\tfor k, d := range directions {\\n\\t\\t\\tfor c := 0; c < limit; c++ {\\n\\t\\t\\t\\trow += d[0]\\n\\t\\t\\t\\tcol += d[1]\\n\\t\\t\\t\\tif col < cols && row < rows && row >= 0 && col >= 0 {\\n\\t\\t\\t\\t\\tres = append(res, []int{row, col})\\n\\t\\t\\t\\t\\tcount++\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif k == 1 || k == 3 {\\n\\t\\t\\t\\tlimit += 1\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc spiralMatrixIII(rows int, cols int, rStart int, cStart int) [][]int {\\n\\n\\tres := make([][]int, 0, rows*cols)\\n\\tres = append(res, []int{rStart, cStart})\\n\\n\\tcount := 1\\n\\tlimit := 1\\n\\tdirections := [][]int{{0, 1}, {1, 0}, {0, -1}, {-1, 0}}\\n\\tcol, row := cStart, rStart\\n\\tfor count != rows*cols {\\n\\t\\tfor k, d := range directions {\\n\\t\\t\\tfor c := 0; c < limit; c++ {\\n\\t\\t\\t\\trow += d[0]\\n\\t\\t\\t\\tcol += d[1]\\n\\t\\t\\t\\tif col < cols && row < rows && row >= 0 && col >= 0 {\\n\\t\\t\\t\\t\\tres = append(res, []int{row, col})\\n\\t\\t\\t\\t\\tcount++\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif k == 1 || k == 3 {\\n\\t\\t\\t\\tlimit += 1\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3562668,
                "title": "simple-rotating-loop",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. create bound for start/end of row and column\\n2. rotate increasing our bounds by 1 each time\\n3. if an index is within our grid bounds add it to the result set\\n\\n# Complexity\\n- Time complexity: O(N)\\n\\n- Space complexity: O(N)\\n\\n# Code\\n```\\nfunc spiralMatrixIII(rows int, cols int, rStart int, cStart int) [][]int {\\n    res := [][]int{}\\n\\n    rstart, rend := rStart, rStart + 1\\n    cstart, cend := cStart, cStart + 1\\n\\n    for len(res) < rows * cols {\\n        for i := cstart; i <= cend; i++ {\\n            res = add(res, rstart, i, rows, cols)\\n        }\\n\\n        cstart--\\n\\n        for i := rstart + 1; i <= rend; i++ {\\n            res = add(res, i, cend, rows, cols)\\n        }\\n\\n        rstart--\\n\\n        for i := cend - 1; i >= cstart; i-- {\\n            res = add(res, rend, i, rows, cols)\\n        }\\n\\n        cend++\\n\\n        for i := rend - 1; i > rstart; i-- {\\n            res = add(res, i, cstart, rows, cols)\\n        }\\n\\n        rend++\\n    }\\n\\n    return res\\n}\\n\\nfunc add(res [][]int, i int, j int, rows int, cols int) [][]int {\\n    if i < 0 || i > rows - 1 || j < 0 || j > cols - 1 {\\n        return res\\n    }\\n\\n    return append(res, []int{i, j})\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc spiralMatrixIII(rows int, cols int, rStart int, cStart int) [][]int {\\n    res := [][]int{}\\n\\n    rstart, rend := rStart, rStart + 1\\n    cstart, cend := cStart, cStart + 1\\n\\n    for len(res) < rows * cols {\\n        for i := cstart; i <= cend; i++ {\\n            res = add(res, rstart, i, rows, cols)\\n        }\\n\\n        cstart--\\n\\n        for i := rstart + 1; i <= rend; i++ {\\n            res = add(res, i, cend, rows, cols)\\n        }\\n\\n        rstart--\\n\\n        for i := cend - 1; i >= cstart; i-- {\\n            res = add(res, rend, i, rows, cols)\\n        }\\n\\n        cend++\\n\\n        for i := rend - 1; i > rstart; i-- {\\n            res = add(res, i, cstart, rows, cols)\\n        }\\n\\n        rend++\\n    }\\n\\n    return res\\n}\\n\\nfunc add(res [][]int, i int, j int, rows int, cols int) [][]int {\\n    if i < 0 || i > rows - 1 || j < 0 || j > cols - 1 {\\n        return res\\n    }\\n\\n    return append(res, []int{i, j})\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3539627,
                "title": "swift-clean-solution-explained",
                "content": "# Approach\\n###### Simulate the walk, ignoring whether we stay in the grid or not, and record positions of the grid in the order we encounter them.\\n###### Keep track of the count of steps needed in current direction. When it becomes zero, turn clockwise and reset the counter, incrementing it every second time.\\n###### Take the unit vector $$(0, 1)$$ pointing to the right as the start move direction. When it\\'s time to turn, use the force of science to get a new heading. As the math says, the orthogonals to vector $$(A, B)$$ are vectors $$(-B, A)$$ and $$(B, -A)$$, the former is original turned $$90^0$$ counter-clockwise and the latter is $$(A, B)$$ turned $$90^0$$ clockwise, which is what we need.\\n\\n# Complexity\\n- Time complexity: $$O(max(R, C)^2)$$. Potentially, our walk needs to spiral until we move $$R$$ in one direction, and $$C$$ in another direction, so as to reach every cell of the grid.\\n- Space complexity: $$O(R*C)$$, the space used by the answer.\\n\\n# Code\\n```\\nclass Solution\\n{\\n    struct Coord\\n    {\\n        var i, j: Int\\n        init(_ i: Int, _ j: Int) { self.i = i; self.j = j }\\n        static func += (lhs: inout Coord, rhs: Coord) { lhs.i += rhs.i; lhs.j += rhs.j }\\n    }\\n    \\n    func spiralMatrixIII(_ rows: Int, _ cols: Int, _ rStart: Int, _ cStart: Int) -> [[Int]]\\n    {\\n        var coord = Coord(rStart, cStart), direction = Coord(0, 1)\\n        func isInGrid() -> Bool {\\n            coord.i >= 0 && coord.i < rows && coord.j >= 0 && coord.j < cols\\n        }\\n\\n        let cellCount = rows * cols\\n        var visited: [[Int]] = [], steps = 1, maxSteps = 2\\n        while true\\n        {\\n            if isInGrid() {\\n                visited.append([coord.i, coord.j])\\n                if visited.count == cellCount { break }\\n            }\\n\\n            if steps == 0\\n            {   // turn clockwise\\n                (direction.i, direction.j) = (direction.j, -direction.i)\\n                // calculate amount of steps in new direction\\n                maxSteps += 1\\n                steps = maxSteps / 2\\n            }\\n            // advance in the current direction\\n            coord += direction\\n            steps -= 1\\n        }\\n        return visited\\n    }\\n}\\n\\n```\\n### The same, using SIMD2 vector type just for kicks\\n```\\n    func spiralMatrixIII(_ rows: Int, _ cols: Int, _ rStart: Int, _ cStart: Int) -> [[Int]]\\n    {\\n        // coord.x is rows from top to down, coord.y is columns from left to right\\n        var coord = SIMD2(rStart, cStart), direction = SIMD2(0, 1)\\n\\n        let origin = SIMD2(0, 0), corner = SIMD2(rows - 1, cols - 1)\\n        let SIMD2True = SIMDMask<SIMD2<Int>>(repeating: true)\\n        func isInGrid() -> Bool { \\n            ((coord .>= origin) == SIMD2True) && ((coord .<= corner) == SIMD2True)\\n        }\\n\\n        let cellCount = rows * cols\\n        var visited: [[Int]] = [], steps = 1, maxSteps = 2\\n        while true\\n        {\\n            if isInGrid() {\\n                visited.append([coord.x, coord.y])\\n                if visited.count == cellCount { break }\\n            }\\n\\n            if steps == 0\\n            {   // turn clockwise\\n                (direction.x, direction.y) = (direction.y, -direction.x)\\n                // calculate amount of steps in new direction\\n                maxSteps += 1\\n                steps = maxSteps / 2\\n            }\\n            // advance in the current direction\\n            coord &+= direction\\n            steps -= 1            \\n        }\\n        return visited\\n    }\\n```",
                "solutionTags": [
                    "Swift",
                    "Math",
                    "Matrix",
                    "Simulation"
                ],
                "code": "```\\nclass Solution\\n{\\n    struct Coord\\n    {\\n        var i, j: Int\\n        init(_ i: Int, _ j: Int) { self.i = i; self.j = j }\\n        static func += (lhs: inout Coord, rhs: Coord) { lhs.i += rhs.i; lhs.j += rhs.j }\\n    }\\n    \\n    func spiralMatrixIII(_ rows: Int, _ cols: Int, _ rStart: Int, _ cStart: Int) -> [[Int]]\\n    {\\n        var coord = Coord(rStart, cStart), direction = Coord(0, 1)\\n        func isInGrid() -> Bool {\\n            coord.i >= 0 && coord.i < rows && coord.j >= 0 && coord.j < cols\\n        }\\n\\n        let cellCount = rows * cols\\n        var visited: [[Int]] = [], steps = 1, maxSteps = 2\\n        while true\\n        {\\n            if isInGrid() {\\n                visited.append([coord.i, coord.j])\\n                if visited.count == cellCount { break }\\n            }\\n\\n            if steps == 0\\n            {   // turn clockwise\\n                (direction.i, direction.j) = (direction.j, -direction.i)\\n                // calculate amount of steps in new direction\\n                maxSteps += 1\\n                steps = maxSteps / 2\\n            }\\n            // advance in the current direction\\n            coord += direction\\n            steps -= 1\\n        }\\n        return visited\\n    }\\n}\\n\\n```\n```\\n    func spiralMatrixIII(_ rows: Int, _ cols: Int, _ rStart: Int, _ cStart: Int) -> [[Int]]\\n    {\\n        // coord.x is rows from top to down, coord.y is columns from left to right\\n        var coord = SIMD2(rStart, cStart), direction = SIMD2(0, 1)\\n\\n        let origin = SIMD2(0, 0), corner = SIMD2(rows - 1, cols - 1)\\n        let SIMD2True = SIMDMask<SIMD2<Int>>(repeating: true)\\n        func isInGrid() -> Bool { \\n            ((coord .>= origin) == SIMD2True) && ((coord .<= corner) == SIMD2True)\\n        }\\n\\n        let cellCount = rows * cols\\n        var visited: [[Int]] = [], steps = 1, maxSteps = 2\\n        while true\\n        {\\n            if isInGrid() {\\n                visited.append([coord.x, coord.y])\\n                if visited.count == cellCount { break }\\n            }\\n\\n            if steps == 0\\n            {   // turn clockwise\\n                (direction.x, direction.y) = (direction.y, -direction.x)\\n                // calculate amount of steps in new direction\\n                maxSteps += 1\\n                steps = maxSteps / 2\\n            }\\n            // advance in the current direction\\n            coord &+= direction\\n            steps -= 1            \\n        }\\n        return visited\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3519800,
                "title": "simple-c-code-with-o-n-4",
                "content": "# Complexity\\n- Time complexity:\\nO(ror*row*col*col)\\n\\n- Space complexity:\\nWe have not used any extra space bu to return the answer we have used a space of O(row*col)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        int n = rows*cols;\\n        int left=cStart, right=cStart+1, bottom=rStart+1,top=rStart;\\n        vector<vector<int>> ans;\\n        while(n){\\n            //right\\n            for(int i=left; i<=right; i++){\\n                if(i<=cols-1 && i>=0 && top>=0 && top<=rows-1){\\n                    ans.push_back({top, i});\\n                    n--;\\n                }\\n            }\\n            left--;\\n\\n            //bottom\\n            for(int i=top+1; i<=bottom; i++){\\n                if(right<=cols-1 && right>=0 && i>=0 && i<=rows-1){\\n                    ans.push_back({i, right});\\n                    n--;\\n                }\\n            }\\n            top--;\\n\\n            //left\\n            for(int i=right-1; i>=left; i--){\\n                if(i<=cols-1 && i>=0 && bottom>=0 && bottom<=rows-1){\\n                    ans.push_back({bottom, i});\\n                    n--;\\n                }\\n            }\\n            right++;\\n\\n            //top\\n            for(int i=bottom-1; i>top; i--){\\n                if(left<=cols-1 && left>=0 && i>=0 && i<=rows-1){\\n                    ans.push_back({i, left});\\n                    n--;\\n                }\\n            }\\n            bottom++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        int n = rows*cols;\\n        int left=cStart, right=cStart+1, bottom=rStart+1,top=rStart;\\n        vector<vector<int>> ans;\\n        while(n){\\n            //right\\n            for(int i=left; i<=right; i++){\\n                if(i<=cols-1 && i>=0 && top>=0 && top<=rows-1){\\n                    ans.push_back({top, i});\\n                    n--;\\n                }\\n            }\\n            left--;\\n\\n            //bottom\\n            for(int i=top+1; i<=bottom; i++){\\n                if(right<=cols-1 && right>=0 && i>=0 && i<=rows-1){\\n                    ans.push_back({i, right});\\n                    n--;\\n                }\\n            }\\n            top--;\\n\\n            //left\\n            for(int i=right-1; i>=left; i--){\\n                if(i<=cols-1 && i>=0 && bottom>=0 && bottom<=rows-1){\\n                    ans.push_back({bottom, i});\\n                    n--;\\n                }\\n            }\\n            right++;\\n\\n            //top\\n            for(int i=bottom-1; i>top; i--){\\n                if(left<=cols-1 && left>=0 && i>=0 && i<=rows-1){\\n                    ans.push_back({i, left});\\n                    n--;\\n                }\\n            }\\n            bottom++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3519783,
                "title": "simple-c-solution-with-o-n-4",
                "content": "# Complexity\\n- Time complexity: O(r * r * c * c)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(r*c)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int r, int c, int sr, int sc) {\\n        int n=r*c;\\n        vector<vector<int>>ans;\\n        int top=sr,right=sc+1;\\n        int bottom=sr+1,left=sc;\\n        while(n>0){\\n            for(int i=left;i<=right;++i){\\n                if(top>=0 && top<r && i>=0 && i<c){\\n                    ans.push_back({top,i});\\n                    n--;\\n                }\\n            }\\n            left--;\\n            for(int i=top+1;i<=bottom;++i){\\n                if(i>=0 && i<r && right>=0 && right<c){\\n                    ans.push_back({i,right});\\n                    n--;\\n                }\\n            }\\n            top--;\\n            for(int i=right-1;i>left;--i){\\n                if(bottom>=0 && bottom<r && i>=0 && i<c){\\n                    ans.push_back({bottom,i});\\n                    n--;\\n                }\\n            }\\n            right++;\\n            for(int i=bottom;i>top;--i){\\n                if(i>=0 && i<r && left>=0 && left<c){\\n                    ans.push_back({i,left});\\n                    n--;\\n                }\\n            }\\n            bottom++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int r, int c, int sr, int sc) {\\n        int n=r*c;\\n        vector<vector<int>>ans;\\n        int top=sr,right=sc+1;\\n        int bottom=sr+1,left=sc;\\n        while(n>0){\\n            for(int i=left;i<=right;++i){\\n                if(top>=0 && top<r && i>=0 && i<c){\\n                    ans.push_back({top,i});\\n                    n--;\\n                }\\n            }\\n            left--;\\n            for(int i=top+1;i<=bottom;++i){\\n                if(i>=0 && i<r && right>=0 && right<c){\\n                    ans.push_back({i,right});\\n                    n--;\\n                }\\n            }\\n            top--;\\n            for(int i=right-1;i>left;--i){\\n                if(bottom>=0 && bottom<r && i>=0 && i<c){\\n                    ans.push_back({bottom,i});\\n                    n--;\\n                }\\n            }\\n            right++;\\n            for(int i=bottom;i>top;--i){\\n                if(i>=0 && i<r && left>=0 && left<c){\\n                    ans.push_back({i,left});\\n                    n--;\\n                }\\n            }\\n            bottom++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3516395,
                "title": "spiral-matrix-iii-very-easy-solution-in-c-intuitive-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        vector<vector<int>> ans;\\n        int required_movements = rows * cols;\\n        int i = rStart, j = cStart;\\n        int steps = 0, steps_cpy = 0;\\n        ans.push_back({i, j});\\n        while(ans.size() < required_movements)\\n        {\\n            steps++;\\n            steps_cpy = steps;\\n            while(steps_cpy > 0)\\n            {\\n                if(steps % 2 != 0)\\n                {\\n                    j++;\\n                    if(i>=0 && i<rows && j>=0 && j<cols)\\n                    {\\n                        ans.push_back({i, j});\\n                    }\\n                    steps_cpy--;\\n                }\\n                else\\n                {\\n                    j--;\\n                    if(i>=0 && i<rows && j>=0 && j<cols)\\n                    {\\n                        ans.push_back({i, j});\\n                    }\\n                    steps_cpy--; \\n                }\\n            }\\n            if(ans.size() < required_movements)\\n            {\\n                steps_cpy = steps;\\n                while(steps_cpy > 0)\\n                {\\n                    if(steps % 2 != 0)\\n                    {\\n                        i++;\\n                        if(i>=0 && i<rows && j>=0 && j<cols)\\n                        {\\n                            ans.push_back({i, j});\\n                        }\\n                        steps_cpy--;\\n                    }\\n                    else\\n                    {\\n                        i--;\\n                        if(i>=0 && i<rows && j>=0 && j<cols)\\n                        {\\n                            ans.push_back({i, j});\\n                        }\\n                        steps_cpy--; \\n                    }\\n                }\\n            }\\n        }  \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        vector<vector<int>> ans;\\n        int required_movements = rows * cols;\\n        int i = rStart, j = cStart;\\n        int steps = 0, steps_cpy = 0;\\n        ans.push_back({i, j});\\n        while(ans.size() < required_movements)\\n        {\\n            steps++;\\n            steps_cpy = steps;\\n            while(steps_cpy > 0)\\n            {\\n                if(steps % 2 != 0)\\n                {\\n                    j++;\\n                    if(i>=0 && i<rows && j>=0 && j<cols)\\n                    {\\n                        ans.push_back({i, j});\\n                    }\\n                    steps_cpy--;\\n                }\\n                else\\n                {\\n                    j--;\\n                    if(i>=0 && i<rows && j>=0 && j<cols)\\n                    {\\n                        ans.push_back({i, j});\\n                    }\\n                    steps_cpy--; \\n                }\\n            }\\n            if(ans.size() < required_movements)\\n            {\\n                steps_cpy = steps;\\n                while(steps_cpy > 0)\\n                {\\n                    if(steps % 2 != 0)\\n                    {\\n                        i++;\\n                        if(i>=0 && i<rows && j>=0 && j<cols)\\n                        {\\n                            ans.push_back({i, j});\\n                        }\\n                        steps_cpy--;\\n                    }\\n                    else\\n                    {\\n                        i--;\\n                        if(i>=0 && i<rows && j>=0 && j<cols)\\n                        {\\n                            ans.push_back({i, j});\\n                        }\\n                        steps_cpy--; \\n                    }\\n                }\\n            }\\n        }  \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3512926,
                "title": "java-solution",
                "content": "# Time complexity:\\nO ( max ( rows, cols ) ^2 )\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        int len = rows*cols;\\n        int[][] ans = new int[len][2];\\n        int ai = 0;\\n        ans[ai][0] = rStart;\\n        ans[ai][1] = cStart++;\\n        ai++;\\n        int rEnd = rStart-1;\\n        int cEnd = cStart;\\n        while(ai<len){\\n            //go right\\n            for(int i=cStart; i<=cEnd && ai<len; i++){\\n                if(rStart<0 || i<0  || i>=cols) continue;\\n                ans[ai][0] = rStart;\\n                ans[ai][1] = i;\\n                ai++;\\n            }\\n            rStart++; //cuz starting row is covered now\\n            rEnd+=2;\\n\\n            //go down -> travel rows\\n            for(int i=rStart; i<=rEnd && ai<len; i++){\\n                if(i<0 || i>=rows || cEnd>=cols) continue;\\n                ans[ai][0] = i;\\n                ans[ai][1] = cEnd;\\n                ai++;\\n            }\\n            cEnd--; //cuz last column is finished now\\n            cStart-=2;\\n            \\n            //go left -> travel columns\\n            for(int i=cEnd; i>=cStart && ai<len; i--){\\n                if(rEnd>=rows || i<0 || i>=cols) continue;\\n                ans[ai][0] = rEnd;\\n                ans[ai][1] = i;\\n                ai++;\\n            }\\n            rEnd--; //cuz last row is now done\\n            rStart-=2;\\n            \\n            //go up -> travel rows\\n            for(int i=rEnd; i>=rStart && ai<len; i--){\\n                if(cStart<0 || i<0 || i>=rows) continue;\\n                ans[ai][0] = i;\\n                ans[ai][1] = cStart;\\n                ai++;\\n            }\\n            cStart++; //cuz starting col is now done\\n            cEnd+=2;\\n        }\\n        return ans;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        int len = rows*cols;\\n        int[][] ans = new int[len][2];\\n        int ai = 0;\\n        ans[ai][0] = rStart;\\n        ans[ai][1] = cStart++;\\n        ai++;\\n        int rEnd = rStart-1;\\n        int cEnd = cStart;\\n        while(ai<len){\\n            //go right\\n            for(int i=cStart; i<=cEnd && ai<len; i++){\\n                if(rStart<0 || i<0  || i>=cols) continue;\\n                ans[ai][0] = rStart;\\n                ans[ai][1] = i;\\n                ai++;\\n            }\\n            rStart++; //cuz starting row is covered now\\n            rEnd+=2;\\n\\n            //go down -> travel rows\\n            for(int i=rStart; i<=rEnd && ai<len; i++){\\n                if(i<0 || i>=rows || cEnd>=cols) continue;\\n                ans[ai][0] = i;\\n                ans[ai][1] = cEnd;\\n                ai++;\\n            }\\n            cEnd--; //cuz last column is finished now\\n            cStart-=2;\\n            \\n            //go left -> travel columns\\n            for(int i=cEnd; i>=cStart && ai<len; i--){\\n                if(rEnd>=rows || i<0 || i>=cols) continue;\\n                ans[ai][0] = rEnd;\\n                ans[ai][1] = i;\\n                ai++;\\n            }\\n            rEnd--; //cuz last row is now done\\n            rStart-=2;\\n            \\n            //go up -> travel rows\\n            for(int i=rEnd; i>=rStart && ai<len; i--){\\n                if(cStart<0 || i<0 || i>=rows) continue;\\n                ans[ai][0] = i;\\n                ans[ai][1] = cStart;\\n                ai++;\\n            }\\n            cStart++; //cuz starting col is now done\\n            cEnd+=2;\\n        }\\n        return ans;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3509778,
                "title": "python-solution-based-spiral-matrix-1-2-and-4-easy-understanding",
                "content": "\\n    def spiralMatrixIII(self, rows: int, cols: int, rStart: int, cStart: int) -> List[List[int]]:\\n        matrix = [[-1 for i in range(cols)] for j in range(rows)]\\n        if rows==0:\\n            return []\\n        t=rStart\\n        ans=[]\\n        b=t+1\\n        l=cStart\\n        r=l+1\\n        d=0\\n        ct=1\\n        while ct<=rows*cols:\\n            if l<=0:\\n                l=0\\n            if t<=0:\\n                t=0\\n            if r>=cols-1:\\n                r=cols-1\\n            if b>=rows-1:\\n                b=rows-1\\n            if(d==0):\\n                for i in range(l,r+1):\\n                    if matrix[t][i]==-1:\\n                        ans.append([t,i])\\n                        matrix[t][i]=0\\n                        ct+=1\\n                d=1\\n                l-=1\\n            elif(d==1):\\n                for i in range(t,b+1):\\n                    if matrix[i][r]==-1:\\n                        matrix[i][r]=0\\n                        ans.append([i,r])\\n                        ct+=1\\n                d=2\\n                t-=1\\n            elif(d==2):\\n                for i in reversed(range(l,r+1)):\\n                    if matrix[b][i]==-1:\\n                        ans.append([b,i])\\n                        matrix[b][i]=0\\n                        ct+=1\\n                r+=1\\n                d=3\\n            elif(d==3):\\n                for i in reversed(range(t,b+1)):\\n                    if matrix[i][l]==-1:\\n                        ans.append([i,l])\\n                        matrix[i][l]=0\\n                        ct+=1\\n                b+=1\\n                d=0\\n        return ans\\n",
                "solutionTags": [
                    "Python",
                    "Matrix"
                ],
                "code": "\\n    def spiralMatrixIII(self, rows: int, cols: int, rStart: int, cStart: int) -> List[List[int]]:\\n        matrix = [[-1 for i in range(cols)] for j in range(rows)]\\n        if rows==0:\\n            return []\\n        t=rStart\\n        ans=[]\\n        b=t+1\\n        l=cStart\\n        r=l+1\\n        d=0\\n        ct=1\\n        while ct<=rows*cols:\\n            if l<=0:\\n                l=0\\n            if t<=0:\\n                t=0\\n            if r>=cols-1:\\n                r=cols-1\\n            if b>=rows-1:\\n                b=rows-1\\n            if(d==0):\\n                for i in range(l,r+1):\\n                    if matrix[t][i]==-1:\\n                        ans.append([t,i])\\n                        matrix[t][i]=0\\n                        ct+=1\\n                d=1\\n                l-=1\\n            elif(d==1):\\n                for i in range(t,b+1):\\n                    if matrix[i][r]==-1:\\n                        matrix[i][r]=0\\n                        ans.append([i,r])\\n                        ct+=1\\n                d=2\\n                t-=1\\n            elif(d==2):\\n                for i in reversed(range(l,r+1)):\\n                    if matrix[b][i]==-1:\\n                        ans.append([b,i])\\n                        matrix[b][i]=0\\n                        ct+=1\\n                r+=1\\n                d=3\\n            elif(d==3):\\n                for i in reversed(range(t,b+1)):\\n                    if matrix[i][l]==-1:\\n                        ans.append([i,l])\\n                        matrix[i][l]=0\\n                        ct+=1\\n                b+=1\\n                d=0\\n        return ans\\n",
                "codeTag": "Python3"
            },
            {
                "id": 3509589,
                "title": "java-solution-with-approach",
                "content": "# Intuition\\nfor solving spiral matrix III you should be able to solve spiral matrix I and II \\ncheckout my solution link for spiral matrix I and II with the same approach I have solved spiral matrix III with little changes.\\n\\nspiral matrix I :-https://leetcode.com/problems/spiral-matrix/solutions/3506074/easy-beats-100-java-while-loop/?orderBy=most_votes\\n\\nspiral matrix II :-https://leetcode.com/problems/spiral-matrix-ii/solutions/3509420/easy-java-solution-with-explanation/?orderBy=most_votes\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n     int[] a1 = new int[rows*cols];\\n     int[] a2 = new int[rows*cols];\\n     int[][] arr = new int[rows*cols][2];\\n     int add=0;\\n     int i1=0;\\n     int index=0;\\n\\n\\n     while(add!=rows*cols){\\n     int c1=cStart+1; // in spiral matrix III loop conditions and \\n     int c2=cStart-1; //dependent on both i1 and these 4 variables\\n     int r1=rStart+1;\\n     int r2=rStart-1;\\n\\n\\n         int i=rStart-i1;\\n         int j=cStart-i1;\\n            if(i<rows&&i>=0&&j<cols&&j>=0){\\n                a1[index]=i;// add first element \\n                a2[index]=j;\\n                index++;\\n                add++;\\n            }    \\n         if(add==rows*cols){\\n             add(arr,a1,a2); // when this condition becomes true we \\n             return arr;     //got our answer \\n         }\\n         j++;\\n         c1=c1+i1;\\n\\n\\n         while(j<=c1){//first while loop going right\\n             if(i<rows&&i>=0&&j<cols&&j>=0){\\n            a1[index]=i;\\n            a2[index]=j;\\n            index++;\\n            add++;\\n             }\\n             if(add==rows*cols){ // check each time\\n             add(arr,a1,a2);     // you can write function for that\\n             return arr;\\n         }\\n             j++;\\n         }\\n         j--;\\n         i++;\\n         r1=r1+i1;\\n\\n\\n         while(i<=r1){//second while loop going down\\n             if(i<rows && i>=0 && j<cols && j>=0){\\n         a1[index]=i;\\n         a2[index]=j;\\n         index++;\\n         add++;\\n             }\\n          if(add==rows*cols){\\n             add(arr,a1,a2);\\n             return arr;\\n         }\\n         i++;             \\n         }\\n         i--;\\n         j--;\\n         c2=c2-i1;\\n\\n\\n         while(j>=c2){//third while loop going left\\n             if(i<rows&&i>=0&&j<cols&&j>=0){ \\n         a1[index]=i;\\n         a2[index]=j;\\n         index++;\\n         add++;\\n             }\\n          if(add==rows*cols){\\n             add(arr,a1,a2);\\n             return arr;\\n         }\\n         j--;            \\n         }  \\n         j++;\\n         i--;\\n         r2=r2-i1;\\n\\n\\n         while(i>r2){//fourth while  loop going up\\n             if(i<rows&&i>=0&&j<cols&&j>=0){\\n         a1[index]=i;\\n         a2[index]=j;\\n         index++;\\n         add++;\\n             }\\n          if(add==rows*cols){\\n             add(arr,a1,a2);\\n             return arr;\\n         }\\n         i--;        \\n         }\\n\\n\\n         i1++;     // i1 variable which is deciding all conditions\\n            // of the loop and increasing by one in each iteration\\n\\n     }\\n     return arr;\\n    }\\n    public static void add(int[][] arr ,int[] a1,int[] a2){\\n        for(int i=0;i<a1.length;i++){\\n            arr[i][0]=a1[i];\\n            arr[i][1]=a2[i];\\n        }\\n    }\\n\\n    public static boolean \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n     int[] a1 = new int[rows*cols];\\n     int[] a2 = new int[rows*cols];\\n     int[][] arr = new int[rows*cols][2];\\n     int add=0;\\n     int i1=0;\\n     int index=0;\\n\\n\\n     while(add!=rows*cols){\\n     int c1=cStart+1; // in spiral matrix III loop conditions and \\n     int c2=cStart-1; //dependent on both i1 and these 4 variables\\n     int r1=rStart+1;\\n     int r2=rStart-1;\\n\\n\\n         int i=rStart-i1;\\n         int j=cStart-i1;\\n            if(i<rows&&i>=0&&j<cols&&j>=0){\\n                a1[index]=i;// add first element \\n                a2[index]=j;\\n                index++;\\n                add++;\\n            }    \\n         if(add==rows*cols){\\n             add(arr,a1,a2); // when this condition becomes true we \\n             return arr;     //got our answer \\n         }\\n         j++;\\n         c1=c1+i1;\\n\\n\\n         while(j<=c1){//first while loop going right\\n             if(i<rows&&i>=0&&j<cols&&j>=0){\\n            a1[index]=i;\\n            a2[index]=j;\\n            index++;\\n            add++;\\n             }\\n             if(add==rows*cols){ // check each time\\n             add(arr,a1,a2);     // you can write function for that\\n             return arr;\\n         }\\n             j++;\\n         }\\n         j--;\\n         i++;\\n         r1=r1+i1;\\n\\n\\n         while(i<=r1){//second while loop going down\\n             if(i<rows && i>=0 && j<cols && j>=0){\\n         a1[index]=i;\\n         a2[index]=j;\\n         index++;\\n         add++;\\n             }\\n          if(add==rows*cols){\\n             add(arr,a1,a2);\\n             return arr;\\n         }\\n         i++;             \\n         }\\n         i--;\\n         j--;\\n         c2=c2-i1;\\n\\n\\n         while(j>=c2){//third while loop going left\\n             if(i<rows&&i>=0&&j<cols&&j>=0){ \\n         a1[index]=i;\\n         a2[index]=j;\\n         index++;\\n         add++;\\n             }\\n          if(add==rows*cols){\\n             add(arr,a1,a2);\\n             return arr;\\n         }\\n         j--;            \\n         }  \\n         j++;\\n         i--;\\n         r2=r2-i1;\\n\\n\\n         while(i>r2){//fourth while  loop going up\\n             if(i<rows&&i>=0&&j<cols&&j>=0){\\n         a1[index]=i;\\n         a2[index]=j;\\n         index++;\\n         add++;\\n             }\\n          if(add==rows*cols){\\n             add(arr,a1,a2);\\n             return arr;\\n         }\\n         i--;        \\n         }\\n\\n\\n         i1++;     // i1 variable which is deciding all conditions\\n            // of the loop and increasing by one in each iteration\\n\\n     }\\n     return arr;\\n    }\\n    public static void add(int[][] arr ,int[] a1,int[] a2){\\n        for(int i=0;i<a1.length;i++){\\n            arr[i][0]=a1[i];\\n            arr[i][1]=a2[i];\\n        }\\n    }\\n\\n    public static boolean \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3509429,
                "title": "clean-and-explanined-one-past-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(m * n) as it would just visit each of the item in the matrix for once.(I did vertify my thinking with Chat GPT)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1) as constant of the space was used\\n\\n# Code\\n```\\n/**\\n * @param {number} rows\\n * @param {number} cols\\n * @param {number} rStart\\n * @param {number} cStart\\n * @return {number[][]}\\n */\\nvar spiralMatrixIII = function(rows, cols, rStart, cStart) {\\n  //as mention in the editorial, we walk in 1,1,2,2,3,3 ... \\n  //and so on pattern, so the step is used to count \\n  //the step before turning\\n  let step = 1;\\n\\n  let curStep = 0;\\n  let turnCount = 0;\\n  //turnCount is used to indicate which direction is moving, \\n  //if it is 0, it means moving right as direction[turnCount] = [0,1]\\n  let ans = [[rStart, cStart]];\\n\\n  let sr = rStart, sc = cStart;\\n\\n  const direction = [[0,1],[1,0],[0,-1],[-1,0]];\\n\\n  while(ans.length < rows * cols){\\n    curStep = step;\\n    while(curStep){\\n      const [dx, dy] = direction[turnCount];\\n      sr += dx;\\n      sc += dy;\\n      if(sr >=0 && sr < rows && sc >= 0 && sc < cols){\\n        ans.push([sr, sc]);\\n      }\\n      curStep--;\\n    }\\n    turnCount = (turnCount + 1) % direction.length;\\n\\n    //the number of step is increased when the direction is moving left or right,\\n    //which means direction[2] || direction[0] on the direction array    \\n    if(turnCount === 2 || turnCount === 0){\\n      step++;\\n    }\\n  }\\n\\n  return ans;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} rows\\n * @param {number} cols\\n * @param {number} rStart\\n * @param {number} cStart\\n * @return {number[][]}\\n */\\nvar spiralMatrixIII = function(rows, cols, rStart, cStart) {\\n  //as mention in the editorial, we walk in 1,1,2,2,3,3 ... \\n  //and so on pattern, so the step is used to count \\n  //the step before turning\\n  let step = 1;\\n\\n  let curStep = 0;\\n  let turnCount = 0;\\n  //turnCount is used to indicate which direction is moving, \\n  //if it is 0, it means moving right as direction[turnCount] = [0,1]\\n  let ans = [[rStart, cStart]];\\n\\n  let sr = rStart, sc = cStart;\\n\\n  const direction = [[0,1],[1,0],[0,-1],[-1,0]];\\n\\n  while(ans.length < rows * cols){\\n    curStep = step;\\n    while(curStep){\\n      const [dx, dy] = direction[turnCount];\\n      sr += dx;\\n      sc += dy;\\n      if(sr >=0 && sr < rows && sc >= 0 && sc < cols){\\n        ans.push([sr, sc]);\\n      }\\n      curStep--;\\n    }\\n    turnCount = (turnCount + 1) % direction.length;\\n\\n    //the number of step is increased when the direction is moving left or right,\\n    //which means direction[2] || direction[0] on the direction array    \\n    if(turnCount === 2 || turnCount === 0){\\n      step++;\\n    }\\n  }\\n\\n  return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3509096,
                "title": "java-code-with-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe simple approach that comes to mind is traverse in spiral direction from the current position, if we are within matrix are we will add that to our ans otherwise ignore, this way we will cover all indexes.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nstart from current index and start traversing in spiral way,\\nComments are added in code for more clarity.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nif size of matrix is X then max we will iterate 4*X indexes.\\nO(4*X)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(X)\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        //set the size of matrix -1 because we already visited one position\\n        int size = rows*cols-1;\\n        //shift is the number of steps in one direction, we can also say one side of rectangle\\n        int shift = 1;\\n        //when to increase shift, we will increase shift after completing two sides\\n        boolean increaseShift = false;\\n        //op stands for operation, operations means the direction of traversal\\n        int op = 1;\\n        //start and end point\\n        int x=rStart;\\n        int y=cStart;\\n        //array to store ans\\n        int[][] ans = new int[size+1][2];\\n        //index of ans array\\n        int idx=0;\\n        //count of steps in one particular direction\\n        int currentCount=0;\\n        //we add the current position\\n        ans[idx][0]=rStart;\\n        ans[idx][1]=cStart;\\n        idx++;\\n        while(size>0){\\n            if(op==1){\\n                y++;\\n            }else if(op==2){\\n                x++;\\n            }else if(op==3){\\n                y--;\\n            }else if(op==4){\\n                x--;\\n            }\\n            //increase the count in this direction\\n            currentCount++;\\n            //if position is within our range then add to ans\\n            if(inRange(rows,cols,x,y)){\\n                    ans[idx][0]=x;\\n                    ans[idx][1]=y;\\n                    idx++;\\n                    size--;\\n            }\\n            //if current count is equal to max steps then...\\n            if(currentCount==shift){\\n                currentCount=0; //reset\\n                op++;   //change direction\\n                op=op%4;\\n                if(op==0){\\n                    op=4;\\n                }\\n                if(!increaseShift){ //logic to increase shift\\n                    increaseShift=true;\\n                }else{\\n                    increaseShift=false;\\n                    shift++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    boolean inRange(int rows, int cols, int x, int y){\\n        if(x<0 || x>=rows){\\n            return false;\\n        }\\n        if(y<0 || y>=cols){\\n            return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        //set the size of matrix -1 because we already visited one position\\n        int size = rows*cols-1;\\n        //shift is the number of steps in one direction, we can also say one side of rectangle\\n        int shift = 1;\\n        //when to increase shift, we will increase shift after completing two sides\\n        boolean increaseShift = false;\\n        //op stands for operation, operations means the direction of traversal\\n        int op = 1;\\n        //start and end point\\n        int x=rStart;\\n        int y=cStart;\\n        //array to store ans\\n        int[][] ans = new int[size+1][2];\\n        //index of ans array\\n        int idx=0;\\n        //count of steps in one particular direction\\n        int currentCount=0;\\n        //we add the current position\\n        ans[idx][0]=rStart;\\n        ans[idx][1]=cStart;\\n        idx++;\\n        while(size>0){\\n            if(op==1){\\n                y++;\\n            }else if(op==2){\\n                x++;\\n            }else if(op==3){\\n                y--;\\n            }else if(op==4){\\n                x--;\\n            }\\n            //increase the count in this direction\\n            currentCount++;\\n            //if position is within our range then add to ans\\n            if(inRange(rows,cols,x,y)){\\n                    ans[idx][0]=x;\\n                    ans[idx][1]=y;\\n                    idx++;\\n                    size--;\\n            }\\n            //if current count is equal to max steps then...\\n            if(currentCount==shift){\\n                currentCount=0; //reset\\n                op++;   //change direction\\n                op=op%4;\\n                if(op==0){\\n                    op=4;\\n                }\\n                if(!increaseShift){ //logic to increase shift\\n                    increaseShift=true;\\n                }else{\\n                    increaseShift=false;\\n                    shift++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    boolean inRange(int rows, int cols, int x, int y){\\n        if(x<0 || x>=rows){\\n            return false;\\n        }\\n        if(y<0 || y>=cols){\\n            return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3508974,
                "title": "50-long-typescript-click",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nlet go = ([r, c]: number[], direction: \"u\" | \"d\" | \"l\" | \"r\") => {\\n    switch (direction) {\\n        case \"u\":\\n            return [r-1, c]\\n        case \"d\":\\n            return [r+1, c]\\n        case \"l\":\\n            return [r, c-1]\\n        case \"r\":\\n            return [r, c+1]\\n        default:\\n            return [r, c]\\n    }\\n}\\n\\nlet convertToOrgCoords = ([r,c]: number[], [expandedXLength, expandedYLength]: number[]) => {\\n    return [r-expandedYLength, c-expandedXLength]\\n}\\n\\nlet isOutOfBound = ([r,c]: number[], rows: number, cols: number):boolean => {\\n    if(r < 0 || r >= rows) return true;\\n    if(c < 0 || c >= cols) return true;\\n    return false;\\n}\\n\\n\\nlet getExpandedCoords = (rows: number, cols: number, rStart: number, cStart: number): number[][] => {\\n    let leftLength = cStart;\\n    let rightLength = cols-cStart-1;\\n    let maxXAxis = Math.max(leftLength, rightLength);\\n    let topLength = rStart;\\n    let bottomLength = rows-rStart-1;\\n    let maxYAxis = Math.max(topLength, bottomLength);\\n    let maxLength = Math.max(maxXAxis, maxYAxis);\\n    let expandedXLength = maxLength-cStart;\\n    let expandedYLength = maxLength-rStart;\\n    // console.log(maxLength, maxXAxis, maxYAxis)\\n    return [[maxLength, maxLength], [expandedXLength, expandedYLength]];\\n}\\n\\nfunction spiralMatrixIII(rows: number, cols: number, rStart: number, cStart: number): number[][] {\\n    let res: number[][] = []\\n    let l = Math.max(cStart, rStart)*2+1;\\n    let [startCoords, expandedLength] = getExpandedCoords(rows, cols, rStart, cStart);\\n    // console.log(expandedLength)\\n    res.push(convertToOrgCoords(startCoords, expandedLength));\\n    let step = 1;\\n    let direction: (\"u\" | \"d\" | \"l\" | \"r\")[] = [\"r\", \"d\", \"l\", \"u\"];\\n    let t = rows*cols;\\n    if(res.length === t) return res;\\n    // let z = 0\\n    let coords = startCoords;\\n    while(true) {\\n    // while(z<2) {\\n        // z++;\\n        for(let i=0; i<4; i++) {\\n            for(let j=0; j<step; j++) {\\n                coords = go(coords, direction[i])\\n                let orgCoords = convertToOrgCoords(coords, expandedLength)\\n                if(isOutOfBound(orgCoords, rows, cols)) continue;\\n                res.push(orgCoords);\\n                if(res.length === t) return res;\\n                // console.log(orgCoords, coords)\\n            }\\n            if(i === 1) step++;\\n        }\\n        step++;\\n        // console.log(res)\\n        // break;\\n    }\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nlet go = ([r, c]: number[], direction: \"u\" | \"d\" | \"l\" | \"r\") => {\\n    switch (direction) {\\n        case \"u\":\\n            return [r-1, c]\\n        case \"d\":\\n            return [r+1, c]\\n        case \"l\":\\n            return [r, c-1]\\n        case \"r\":\\n            return [r, c+1]\\n        default:\\n            return [r, c]\\n    }\\n}\\n\\nlet convertToOrgCoords = ([r,c]: number[], [expandedXLength, expandedYLength]: number[]) => {\\n    return [r-expandedYLength, c-expandedXLength]\\n}\\n\\nlet isOutOfBound = ([r,c]: number[], rows: number, cols: number):boolean => {\\n    if(r < 0 || r >= rows) return true;\\n    if(c < 0 || c >= cols) return true;\\n    return false;\\n}\\n\\n\\nlet getExpandedCoords = (rows: number, cols: number, rStart: number, cStart: number): number[][] => {\\n    let leftLength = cStart;\\n    let rightLength = cols-cStart-1;\\n    let maxXAxis = Math.max(leftLength, rightLength);\\n    let topLength = rStart;\\n    let bottomLength = rows-rStart-1;\\n    let maxYAxis = Math.max(topLength, bottomLength);\\n    let maxLength = Math.max(maxXAxis, maxYAxis);\\n    let expandedXLength = maxLength-cStart;\\n    let expandedYLength = maxLength-rStart;\\n    // console.log(maxLength, maxXAxis, maxYAxis)\\n    return [[maxLength, maxLength], [expandedXLength, expandedYLength]];\\n}\\n\\nfunction spiralMatrixIII(rows: number, cols: number, rStart: number, cStart: number): number[][] {\\n    let res: number[][] = []\\n    let l = Math.max(cStart, rStart)*2+1;\\n    let [startCoords, expandedLength] = getExpandedCoords(rows, cols, rStart, cStart);\\n    // console.log(expandedLength)\\n    res.push(convertToOrgCoords(startCoords, expandedLength));\\n    let step = 1;\\n    let direction: (\"u\" | \"d\" | \"l\" | \"r\")[] = [\"r\", \"d\", \"l\", \"u\"];\\n    let t = rows*cols;\\n    if(res.length === t) return res;\\n    // let z = 0\\n    let coords = startCoords;\\n    while(true) {\\n    // while(z<2) {\\n        // z++;\\n        for(let i=0; i<4; i++) {\\n            for(let j=0; j<step; j++) {\\n                coords = go(coords, direction[i])\\n                let orgCoords = convertToOrgCoords(coords, expandedLength)\\n                if(isOutOfBound(orgCoords, rows, cols)) continue;\\n                res.push(orgCoords);\\n                if(res.length === t) return res;\\n                // console.log(orgCoords, coords)\\n            }\\n            if(i === 1) step++;\\n        }\\n        step++;\\n        // console.log(res)\\n        // break;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3508609,
                "title": "spiral-walking-using-point-direction-datatypes",
                "content": "# Approach\\nUses Direction and Point datatypes. Walk in a spiral by keeping track of `step_count` and `step_length`. When changing direction from Up or Down, the `step_length` increases by `1`. \\n\\nOnly push to the `output` array if the input is within the bounds.\\n\\nTerminate when the number of steps walked in a single direction is larger than `n`.\\n\\n# Code\\n```\\nimpl Solution {\\n    pub fn spiral_matrix_iii(rows: i32, cols: i32, r_start: i32, c_start: i32) -> Vec<Vec<i32>> {\\n        let n = i32::max(r_start + rows, c_start + cols) * 2;\\n\\n        let mut output: Vec<Vec<i32>> = vec![];\\n        let mut position = Point {\\n            x: c_start,\\n            y: r_start,\\n        };\\n        let mut direction = Direction::Right;\\n        let (mut step_length, mut step_count) = (1, 0);\\n\\n        loop {\\n            if position.x >= 0 && position.x < cols && position.y >= 0 && position.y < rows {\\n                output.push(vec![position.y, position.x]);\\n            }\\n            position = position.next_point(&direction);\\n            step_count += 1;\\n\\n            if step_count >= step_length {\\n                step_count = 0;\\n                if direction == Direction::Down || direction == Direction::Up {\\n                    step_length += 1;\\n                }\\n                direction = direction.next();\\n            }\\n            if step_count > n {\\n                break;\\n            }\\n        }\\n\\n        output\\n    }\\n}\\n\\n#[derive(PartialEq, Eq)]\\nenum Direction {\\n    Right,\\n    Down,\\n    Left,\\n    Up,\\n}\\n\\nimpl Direction {\\n    pub fn next(&self) -> Direction {\\n        match self {\\n            Direction::Right => Direction::Down,\\n            Direction::Down => Direction::Left,\\n            Direction::Left => Direction::Up,\\n            Direction::Up => Direction::Right,\\n        }\\n    }\\n}\\n\\nstruct Point {\\n    x: i32,\\n    y: i32,\\n}\\n\\nimpl Point {\\n    pub fn next_point(&self, direction: &Direction) -> Point {\\n        match direction {\\n            Direction::Right => Point {\\n                x: self.x + 1,\\n                y: self.y,\\n            },\\n            Direction::Down => Point {\\n                x: self.x,\\n                y: self.y + 1,\\n            },\\n            Direction::Left => Point {\\n                x: self.x - 1,\\n                y: self.y,\\n            },\\n            Direction::Up => Point {\\n                x: self.x,\\n                y: self.y - 1,\\n            },\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn spiral_matrix_iii(rows: i32, cols: i32, r_start: i32, c_start: i32) -> Vec<Vec<i32>> {\\n        let n = i32::max(r_start + rows, c_start + cols) * 2;\\n\\n        let mut output: Vec<Vec<i32>> = vec![];\\n        let mut position = Point {\\n            x: c_start,\\n            y: r_start,\\n        };\\n        let mut direction = Direction::Right;\\n        let (mut step_length, mut step_count) = (1, 0);\\n\\n        loop {\\n            if position.x >= 0 && position.x < cols && position.y >= 0 && position.y < rows {\\n                output.push(vec![position.y, position.x]);\\n            }\\n            position = position.next_point(&direction);\\n            step_count += 1;\\n\\n            if step_count >= step_length {\\n                step_count = 0;\\n                if direction == Direction::Down || direction == Direction::Up {\\n                    step_length += 1;\\n                }\\n                direction = direction.next();\\n            }\\n            if step_count > n {\\n                break;\\n            }\\n        }\\n\\n        output\\n    }\\n}\\n\\n#[derive(PartialEq, Eq)]\\nenum Direction {\\n    Right,\\n    Down,\\n    Left,\\n    Up,\\n}\\n\\nimpl Direction {\\n    pub fn next(&self) -> Direction {\\n        match self {\\n            Direction::Right => Direction::Down,\\n            Direction::Down => Direction::Left,\\n            Direction::Left => Direction::Up,\\n            Direction::Up => Direction::Right,\\n        }\\n    }\\n}\\n\\nstruct Point {\\n    x: i32,\\n    y: i32,\\n}\\n\\nimpl Point {\\n    pub fn next_point(&self, direction: &Direction) -> Point {\\n        match direction {\\n            Direction::Right => Point {\\n                x: self.x + 1,\\n                y: self.y,\\n            },\\n            Direction::Down => Point {\\n                x: self.x,\\n                y: self.y + 1,\\n            },\\n            Direction::Left => Point {\\n                x: self.x - 1,\\n                y: self.y,\\n            },\\n            Direction::Up => Point {\\n                x: self.x,\\n                y: self.y - 1,\\n            },\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3506810,
                "title": "easy-brute-force-with-explaination",
                "content": "# Intuition\\nIf we observer the path:\\n\\nmove right 1 step, turn right\\nmove down 1 step, turn right\\nmove left 2 steps, turn right\\nmove top 2 steps, turn right,\\nmove right 3 steps, turn right\\nmove down 3 steps, turn right\\nmove left 4 steps, turn right\\nmove top 4 steps, turn right,\\n\\nwe can find the sequence of steps: 1,1,2,2,3,3,4,4,5,5....\\n\\nThus, the length variable keeps changing after 2 steps, i.e, 1,1 then 2,2 then 3,3 and so on.\\n\\n# Code\\n```\\nclass Solution {\\n    int index;\\n    int[][] ans;\\n    \\n    private void add (int r, int c, int R, int C) {\\n        if (r >= R || r < 0 || c >= C || c < 0) return;\\n        ans[index][0] = r;\\n        ans[index][1] = c;\\n        index++;\\n    }\\n    \\n    public int[][] spiralMatrixIII(int R, int C, int r0, int c0) {\\n        int r = r0, c = c0, len = 1;\\n        ans= new int[R * C][2];\\n        while (index < (R * C )) {         \\n            for (int k = 0; k < len; k++) add(r, c++, R, C);          \\n            for (int k = 0; k < len; k++) add(r++, c, R, C);\\n            len++;\\n            for (int k = 0; k < len; k++) add(r, c--, R, C);\\n            for (int k = 0; k < len; k++) add(r--, c, R, C);\\n            len++;   \\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int index;\\n    int[][] ans;\\n    \\n    private void add (int r, int c, int R, int C) {\\n        if (r >= R || r < 0 || c >= C || c < 0) return;\\n        ans[index][0] = r;\\n        ans[index][1] = c;\\n        index++;\\n    }\\n    \\n    public int[][] spiralMatrixIII(int R, int C, int r0, int c0) {\\n        int r = r0, c = c0, len = 1;\\n        ans= new int[R * C][2];\\n        while (index < (R * C )) {         \\n            for (int k = 0; k < len; k++) add(r, c++, R, C);          \\n            for (int k = 0; k < len; k++) add(r++, c, R, C);\\n            len++;\\n            for (int k = 0; k < len; k++) add(r, c--, R, C);\\n            for (int k = 0; k < len; k++) add(r--, c, R, C);\\n            len++;   \\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3504838,
                "title": "javascript-easy-understanding-solution",
                "content": "# Intuition\\nUse 4 while loop to move from top left to top right, top right to bottom right, bottom right to bottom left and bottom left to top left. We will travel each edge in 1 while loop and then extend the bound until it reach the border.\\n\\n# Code\\n```\\n/**\\n * @param {number} rows\\n * @param {number} cols\\n * @param {number} rStart\\n * @param {number} cStart\\n * @return {number[][]}\\n */\\nvar spiralMatrixIII = function(rows, cols, rStart, cStart) {\\n    let res = [];\\n    let leftCol = cStart, rightCol = cStart;\\n    let topRow = rStart, bottomRow = rStart;\\n    let i = rStart, j = cStart;\\n    let visit = {};\\n    while (1) {\\n        rightCol = rightCol + 1 === cols ? rightCol : rightCol + 1;\\n        while (j <= rightCol){\\n            if (visit[[i, j]] === undefined) res.push([i, j]);\\n            visit[[i, j]] = true;\\n            j++;\\n        }\\n        j--;\\n        if (res.length === rows * cols) break;\\n        bottomRow = bottomRow + 1 === rows ? bottomRow : bottomRow + 1;\\n        while (i <= bottomRow){\\n            if (visit[[i, j]] === undefined) res.push([i, j]);\\n            visit[[i, j]] = true;\\n            i++;\\n        }\\n        i--;\\n        if (res.length === rows * cols) break;\\n        leftCol = leftCol === 0 ? 0 : leftCol - 1;\\n        while (j >= leftCol){\\n            if (visit[[i, j]] === undefined) res.push([i, j]);\\n            visit[[i, j]] = true;\\n            j--;\\n        }\\n        j++;\\n        if (res.length === rows * cols) break;\\n        topRow = topRow === 0 ? 0 : topRow - 1;\\n        while (i >= topRow){\\n            if (visit[[i, j]] === undefined) res.push([i, j]);\\n            visit[[i, j]] = true;\\n            i--;\\n        }\\n        i++;\\n        if (res.length === rows * cols) break;\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} rows\\n * @param {number} cols\\n * @param {number} rStart\\n * @param {number} cStart\\n * @return {number[][]}\\n */\\nvar spiralMatrixIII = function(rows, cols, rStart, cStart) {\\n    let res = [];\\n    let leftCol = cStart, rightCol = cStart;\\n    let topRow = rStart, bottomRow = rStart;\\n    let i = rStart, j = cStart;\\n    let visit = {};\\n    while (1) {\\n        rightCol = rightCol + 1 === cols ? rightCol : rightCol + 1;\\n        while (j <= rightCol){\\n            if (visit[[i, j]] === undefined) res.push([i, j]);\\n            visit[[i, j]] = true;\\n            j++;\\n        }\\n        j--;\\n        if (res.length === rows * cols) break;\\n        bottomRow = bottomRow + 1 === rows ? bottomRow : bottomRow + 1;\\n        while (i <= bottomRow){\\n            if (visit[[i, j]] === undefined) res.push([i, j]);\\n            visit[[i, j]] = true;\\n            i++;\\n        }\\n        i--;\\n        if (res.length === rows * cols) break;\\n        leftCol = leftCol === 0 ? 0 : leftCol - 1;\\n        while (j >= leftCol){\\n            if (visit[[i, j]] === undefined) res.push([i, j]);\\n            visit[[i, j]] = true;\\n            j--;\\n        }\\n        j++;\\n        if (res.length === rows * cols) break;\\n        topRow = topRow === 0 ? 0 : topRow - 1;\\n        while (i >= topRow){\\n            if (visit[[i, j]] === undefined) res.push([i, j]);\\n            visit[[i, j]] = true;\\n            i--;\\n        }\\n        i++;\\n        if (res.length === rows * cols) break;\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3503916,
                "title": "c-112233-sequence-observation-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nObservation of Sequence 11223344......\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n**Variables: i -> Row, j -> col, k -> sequence number**\\n1) put (r, c) in ans.\\n2) then observe that every time we take \"k\" number of row\\'s OR col\\'s elements either in right or left side(For Row) OR top or down side(For Col). \\n3) Upper codition manages to generate the spiral.\\n4) We take those indices only which are in the grid, For that we applied codition(ok(i, j)).\\n7) If size of \"ans\" becomes (n*m) means we took elements of grid then we break(Here, \"done\" Do that which is nothing but #define....).\\n8) Try to do Dry Run by yourself for \"k\" values upto 4 it will be more clear.\\n \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N * M)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N * M)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    #define done {if(ans.size() == n * m) break;}\\n    \\n    int N, M;\\n    bool ok(int i, int j)\\n    {\\n        return (i >= 0 && j >= 0 && i < N && j < M);\\n    }\\n    vector<vector<int>> spiralMatrixIII(int n, int m, int r, int c) {\\n        N = n, M = m;\\n        vector<vector<int>> ans;\\n        int i = r, j = c + 1, k = 1;\\n        ans.push_back({r, c});\\n        while(1)\\n        {\\n            done;\\n\\n            for(int l = 1; l <= k; l++)\\n            {\\n                if(ok(i, j)) ans.push_back({i, j});\\n                if(ans.size() == n * m) break;\\n                j++;\\n            }\\n            j--;\\n\\n            done;\\n\\n            i++;\\n            for(int l = 1; l <= k; l++)\\n            {\\n                if(ok(i, j)) ans.push_back({i, j});\\n                if(ans.size() == n * m) break;\\n                i++;\\n            }\\n            i--;\\n            \\n            done;\\n            k++;\\n\\n            j--;\\n            for(int l = 1; l <= k; l++)\\n            {\\n                if(ok(i, j)) ans.push_back({i, j});\\n                if(ans.size() == n * m) break;\\n                j--;\\n            }\\n            j++;\\n            \\n            done;\\n\\n            i--;\\n            for(int l = 1; l <= k; l++)\\n            {\\n                if(ok(i, j)) ans.push_back({i, j});\\n                if(ans.size() == n * m) break;\\n                i--;\\n            }\\n            i++;\\n\\n            done;\\n            k++;\\n\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Matrix",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define done {if(ans.size() == n * m) break;}\\n    \\n    int N, M;\\n    bool ok(int i, int j)\\n    {\\n        return (i >= 0 && j >= 0 && i < N && j < M);\\n    }\\n    vector<vector<int>> spiralMatrixIII(int n, int m, int r, int c) {\\n        N = n, M = m;\\n        vector<vector<int>> ans;\\n        int i = r, j = c + 1, k = 1;\\n        ans.push_back({r, c});\\n        while(1)\\n        {\\n            done;\\n\\n            for(int l = 1; l <= k; l++)\\n            {\\n                if(ok(i, j)) ans.push_back({i, j});\\n                if(ans.size() == n * m) break;\\n                j++;\\n            }\\n            j--;\\n\\n            done;\\n\\n            i++;\\n            for(int l = 1; l <= k; l++)\\n            {\\n                if(ok(i, j)) ans.push_back({i, j});\\n                if(ans.size() == n * m) break;\\n                i++;\\n            }\\n            i--;\\n            \\n            done;\\n            k++;\\n\\n            j--;\\n            for(int l = 1; l <= k; l++)\\n            {\\n                if(ok(i, j)) ans.push_back({i, j});\\n                if(ans.size() == n * m) break;\\n                j--;\\n            }\\n            j++;\\n            \\n            done;\\n\\n            i--;\\n            for(int l = 1; l <= k; l++)\\n            {\\n                if(ok(i, j)) ans.push_back({i, j});\\n                if(ans.size() == n * m) break;\\n                i--;\\n            }\\n            i++;\\n\\n            done;\\n            k++;\\n\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3503860,
                "title": "c-simple-and-understandable-solution-two-pointers",
                "content": "# Intuition\\nFirst of all, set the left and right pointer as cStart and up and down pointer as rStart.And initialize num as 0 to keep track of element we have visited.\\nThen do the following in the different blocks:\\n//Upper Block (dir=0)\\n    Traverse it from left to right keeping **\"up\"** pointer as constant and after it increment the **\"right\"** pointer by 1. \\n//Right Block (dir=1)\\n    Traverse it from up to down keeping **\"right\"** pointer as constant and after it increment the **\"down\"** pointer by 1. \\n//Lower Block (dir=2)\\n    Traverse it from right to left keeping **\"down\"** pointer as constant and after it decrement the **\"left\"** pointer by 1. \\n//Left Block (dir=3)\\n    Traverse it from down to up keeping **\"left\"** pointer as constant and after it decrement the **\"up\"** pointer by 1.\\n**Note :-** Before traversing any block, check whether it(left,right,up,down) lies in the matrix or not. \\n# Approach\\nTwo pointers.\\n\\n# Complexity\\n- Time complexity:\\n    O(rows*cols)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        vector<vector<int>> result(rows*cols,vector<int>(2,0));\\n        int left=cStart,right=cStart,up=rStart,down=rStart;\\n        int dir=0,num=0;\\n        while (num < rows*cols){\\n            //upper block\\n            if (dir==0){\\n                if (up>=0){\\n                    for (int i=max(left,0);i<=min(right,cols-1);i++){\\n                        result[num][0]=up;\\n                        result[num][1]=i;\\n                        num++;\\n                    }\\n                }\\n                right++;\\n            }\\n            //right block\\n            if (dir==1){\\n                if (right<cols){\\n                    for (int i=max(up,0);i<=min(down,rows-1);i++){\\n                        result[num][0]=i;\\n                        result[num][1]=right;\\n                        num++;\\n                    }\\n                }\\n                down++;\\n            }\\n            //lower block\\n            if (dir==2){\\n                if (down < rows){\\n                    for (int i=min(right,cols-1);i>=max(left,0);i--){\\n                        result[num][0]=down;\\n                        result[num][1]=i;\\n                        num++;\\n                    }\\n                }\\n                left--;\\n            }\\n            //left block\\n            if (dir==3){\\n                if (left>=0){\\n                    for (int i=min(down,rows-1);i>=max(up,0);i--){\\n                        result[num][0]=i;\\n                        result[num][1]=left;\\n                        num++;\\n                    }\\n                }\\n                up--;\\n            }\\n            dir++;\\n            if (dir==4)\\n                dir=0;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        vector<vector<int>> result(rows*cols,vector<int>(2,0));\\n        int left=cStart,right=cStart,up=rStart,down=rStart;\\n        int dir=0,num=0;\\n        while (num < rows*cols){\\n            //upper block\\n            if (dir==0){\\n                if (up>=0){\\n                    for (int i=max(left,0);i<=min(right,cols-1);i++){\\n                        result[num][0]=up;\\n                        result[num][1]=i;\\n                        num++;\\n                    }\\n                }\\n                right++;\\n            }\\n            //right block\\n            if (dir==1){\\n                if (right<cols){\\n                    for (int i=max(up,0);i<=min(down,rows-1);i++){\\n                        result[num][0]=i;\\n                        result[num][1]=right;\\n                        num++;\\n                    }\\n                }\\n                down++;\\n            }\\n            //lower block\\n            if (dir==2){\\n                if (down < rows){\\n                    for (int i=min(right,cols-1);i>=max(left,0);i--){\\n                        result[num][0]=down;\\n                        result[num][1]=i;\\n                        num++;\\n                    }\\n                }\\n                left--;\\n            }\\n            //left block\\n            if (dir==3){\\n                if (left>=0){\\n                    for (int i=min(down,rows-1);i>=max(up,0);i--){\\n                        result[num][0]=i;\\n                        result[num][1]=left;\\n                        num++;\\n                    }\\n                }\\n                up--;\\n            }\\n            dir++;\\n            if (dir==4)\\n                dir=0;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3476884,
                "title": "c-simply-traverse-as-directed",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFollow path as directed.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWhile following spiral path, if row and col falls on matrix, add to answer vector.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        vector<vector<int>> ans;\\n        int r = rStart, c = cStart;\\n        int step = 1, dir = 1;\\n        ans.push_back({r,c});\\n        while (ans.size() < rows*cols) {\\n            for (int i = 0; i < step; i++) {\\n                c += dir;\\n                if (r >= 0 and r < rows and c >= 0 and c < cols)\\n                    ans.push_back({r,c});\\n            }\\n            for (int i = 0; i < step; i++) {\\n                r += dir;\\n                if (r >= 0 and r < rows and c >= 0 and c < cols)\\n                    ans.push_back({r,c});\\n            }\\n            dir *= -1;\\n            step++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        vector<vector<int>> ans;\\n        int r = rStart, c = cStart;\\n        int step = 1, dir = 1;\\n        ans.push_back({r,c});\\n        while (ans.size() < rows*cols) {\\n            for (int i = 0; i < step; i++) {\\n                c += dir;\\n                if (r >= 0 and r < rows and c >= 0 and c < cols)\\n                    ans.push_back({r,c});\\n            }\\n            for (int i = 0; i < step; i++) {\\n                r += dir;\\n                if (r >= 0 and r < rows and c >= 0 and c < cols)\\n                    ans.push_back({r,c});\\n            }\\n            dir *= -1;\\n            step++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3456668,
                "title": "java-easy-solution-beats-100",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n       int[][] ans= new int[rows*cols][2];\\n       int rmax=rStart+1, cmax=cStart+1, j=0;\\n        while(j<ans.length){\\n            for(int i=cStart; i<cmax; i++){\\n                if(j>=ans.length || i>=cols || rStart<0){rStart=0; break;}\\n                ans[j][0]=rStart;\\n                ans[j][1]=i;\\n                j++;\\n            }\\n            cStart--;\\n            for(int i=rStart; i<rmax; i++){\\n                if(j>=ans.length || i>=rows || cmax>=cols){cmax=cols-1; break;}\\n                ans[j][0]=i;\\n                ans[j][1]=cmax;\\n                j++;\\n            }\\n            rStart--;\\n            for(int i=cmax; i>cStart; i--){\\n                if(j>=ans.length || i<0  || rmax>=rows){rmax=rows-1; break;}\\n                ans[j][0]=rmax;\\n                ans[j][1]=i;\\n                j++;\\n            }\\n            cmax++;\\n            for(int i=rmax; i>rStart; i--){\\n                if(j>=ans.length || i<0 || cStart<0){cStart=0; break;}\\n                ans[j][0]=i;\\n                ans[j][1]=cStart;\\n                j++;\\n            }\\n            rmax++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n       int[][] ans= new int[rows*cols][2];\\n       int rmax=rStart+1, cmax=cStart+1, j=0;\\n        while(j<ans.length){\\n            for(int i=cStart; i<cmax; i++){\\n                if(j>=ans.length || i>=cols || rStart<0){rStart=0; break;}\\n                ans[j][0]=rStart;\\n                ans[j][1]=i;\\n                j++;\\n            }\\n            cStart--;\\n            for(int i=rStart; i<rmax; i++){\\n                if(j>=ans.length || i>=rows || cmax>=cols){cmax=cols-1; break;}\\n                ans[j][0]=i;\\n                ans[j][1]=cmax;\\n                j++;\\n            }\\n            rStart--;\\n            for(int i=cmax; i>cStart; i--){\\n                if(j>=ans.length || i<0  || rmax>=rows){rmax=rows-1; break;}\\n                ans[j][0]=rmax;\\n                ans[j][1]=i;\\n                j++;\\n            }\\n            cmax++;\\n            for(int i=rmax; i>rStart; i--){\\n                if(j>=ans.length || i<0 || cStart<0){cStart=0; break;}\\n                ans[j][0]=i;\\n                ans[j][1]=cStart;\\n                j++;\\n            }\\n            rmax++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3454323,
                "title": "1-1-2-2-3-3-steps-firstly-right-down-n-then-left-up-simulation",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isValid(int m, int n, int i, int j)\\n    {\\n        if(i>=0 and i<m and j>=0 and j<n) return true;\\n        return false;\\n    }\\n    vector<vector<int>> spiralMatrixIII(int m, int n, int rStart, int cStart) {\\n        vector<vector<int>>mat;\\n        int cnt = 1;\\n        int movement = 1;\\n        int i = rStart, j = cStart;\\n        bool rd = true;\\n        while(cnt <= m*n)\\n        {\\n            int curr = 0;\\n            if(rd)\\n            {\\n                while(curr < movement)\\n                {\\n                    if(isValid(m, n, i, j))\\n                    {\\n                        mat.push_back({i, j});\\n                        cnt++;\\n                    }\\n                    j++;\\n                    curr++;\\n                }\\n                curr = 0;\\n                while(curr < movement)\\n                {\\n                    if(isValid(m, n, i, j))\\n                    {\\n                        mat.push_back({i, j});\\n                        cnt++;\\n                    }\\n                    i++;\\n                    curr++;\\n                }\\n                rd = false;\\n                movement++;\\n            }\\n            else\\n            {\\n                while(curr < movement)\\n                {\\n                    if(isValid(m, n, i, j))\\n                    {\\n                        mat.push_back({i, j});\\n                        cnt++;\\n                    }\\n                    j--;\\n                    curr++;\\n                }\\n                curr = 0;\\n                while(curr < movement)\\n                {\\n                    if(isValid(m, n, i, j))\\n                    {\\n                        mat.push_back({i, j});\\n                        cnt++;\\n                    }\\n                    i--;\\n                    curr++;\\n                }\\n                rd = true;\\n                movement++;\\n            }\\n        }\\n        return mat;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(int m, int n, int i, int j)\\n    {\\n        if(i>=0 and i<m and j>=0 and j<n) return true;\\n        return false;\\n    }\\n    vector<vector<int>> spiralMatrixIII(int m, int n, int rStart, int cStart) {\\n        vector<vector<int>>mat;\\n        int cnt = 1;\\n        int movement = 1;\\n        int i = rStart, j = cStart;\\n        bool rd = true;\\n        while(cnt <= m*n)\\n        {\\n            int curr = 0;\\n            if(rd)\\n            {\\n                while(curr < movement)\\n                {\\n                    if(isValid(m, n, i, j))\\n                    {\\n                        mat.push_back({i, j});\\n                        cnt++;\\n                    }\\n                    j++;\\n                    curr++;\\n                }\\n                curr = 0;\\n                while(curr < movement)\\n                {\\n                    if(isValid(m, n, i, j))\\n                    {\\n                        mat.push_back({i, j});\\n                        cnt++;\\n                    }\\n                    i++;\\n                    curr++;\\n                }\\n                rd = false;\\n                movement++;\\n            }\\n            else\\n            {\\n                while(curr < movement)\\n                {\\n                    if(isValid(m, n, i, j))\\n                    {\\n                        mat.push_back({i, j});\\n                        cnt++;\\n                    }\\n                    j--;\\n                    curr++;\\n                }\\n                curr = 0;\\n                while(curr < movement)\\n                {\\n                    if(isValid(m, n, i, j))\\n                    {\\n                        mat.push_back({i, j});\\n                        cnt++;\\n                    }\\n                    i--;\\n                    curr++;\\n                }\\n                rd = true;\\n                movement++;\\n            }\\n        }\\n        return mat;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3447270,
                "title": "easy-clean-java-solution-directions",
                "content": "If we look at the spiral, the noOfElements written in different direction looks like 1, 1, 2, 2, 3, 3 ...\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n\\n        int totalElement = rows * cols;\\n\\n        // Result Matrix having rows equal to the totalElements\\n        int[][] resMatrix = new int[totalElement][2];\\n\\n        int i = rStart, j = cStart;\\n        int count = 1;\\n\\n        // trackes the noOfElements to be written in a particular direction\\n        int length = 1;\\n\\n        // this loop will run until all the elements are written\\n        while(count <= totalElement) {\\n\\n            // Looping through each direction and writing the length noOfElements in that direction\\n            for(Direction dir : Direction.values()) {\\n                for(int rep = 0; rep < length; rep++) {\\n                    if(i < rows && j < cols && i >=0 && j >= 0) {\\n                        resMatrix[count - 1][0] = i;\\n                        resMatrix[count - 1][1] = j;\\n                        count++;\\n                    }\\n                    i = i + dir.rMove;\\n                    j = j + dir.cMove;\\n                }\\n\\n                // the length will change after every two direction\\n                if(dir.ordinal() % 2 != 0) {\\n                    length++;\\n                }\\n            }\\n        }\\n        return resMatrix;\\n    }\\n\\n    enum Direction {\\n        RIGHT(0,1), DOWN(1,0), LEFT(0,-1), UP(-1,0);\\n\\n        // rMove, cMove: value to be added to the indexes to move to the next positon in a given direction\\n        final int rMove;\\n        final int cMove;\\n\\n        Direction(int rMove, int cMove) {\\n            this.rMove = rMove;\\n            this.cMove = cMove;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n\\n        int totalElement = rows * cols;\\n\\n        // Result Matrix having rows equal to the totalElements\\n        int[][] resMatrix = new int[totalElement][2];\\n\\n        int i = rStart, j = cStart;\\n        int count = 1;\\n\\n        // trackes the noOfElements to be written in a particular direction\\n        int length = 1;\\n\\n        // this loop will run until all the elements are written\\n        while(count <= totalElement) {\\n\\n            // Looping through each direction and writing the length noOfElements in that direction\\n            for(Direction dir : Direction.values()) {\\n                for(int rep = 0; rep < length; rep++) {\\n                    if(i < rows && j < cols && i >=0 && j >= 0) {\\n                        resMatrix[count - 1][0] = i;\\n                        resMatrix[count - 1][1] = j;\\n                        count++;\\n                    }\\n                    i = i + dir.rMove;\\n                    j = j + dir.cMove;\\n                }\\n\\n                // the length will change after every two direction\\n                if(dir.ordinal() % 2 != 0) {\\n                    length++;\\n                }\\n            }\\n        }\\n        return resMatrix;\\n    }\\n\\n    enum Direction {\\n        RIGHT(0,1), DOWN(1,0), LEFT(0,-1), UP(-1,0);\\n\\n        // rMove, cMove: value to be added to the indexes to move to the next positon in a given direction\\n        final int rMove;\\n        final int cMove;\\n\\n        Direction(int rMove, int cMove) {\\n            this.rMove = rMove;\\n            this.cMove = cMove;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3438808,
                "title": "simpe-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        int arr[][] = new int[rows*cols][2];\\n        int row=rStart, col=cStart;\\n        int rowLast = row, collast = col;\\n        int c=0;\\n        while(c<rows*cols)\\n        {\\n            collast++;\\n            if(row>=0)\\n            {\\n                for(int i=col; i<collast; i++)\\n                    if(i>=0 && i<cols)\\n                    {\\n                        arr[c][0]=row;\\n                        arr[c++][1]=i;\\n                    }\\n            }\\n            rowLast++;\\n            if(collast<cols)\\n            {\\n                for(int i=row; i<rowLast; i++)\\n                    if(i>=0 && i<rows)\\n                    {\\n                        arr[c][0]=i;\\n                        arr[c++][1]=collast;\\n                    }\\n            }\\n            col--;\\n            if(rowLast<rows)\\n            {\\n                for(int i=collast; i>col; i--)\\n                    if(i>=0 && i<cols)\\n                    {\\n                        arr[c][0]=rowLast;\\n                        arr[c++][1]=i;\\n                    }\\n            }\\n            row--;\\n            if(col>=0)\\n            {\\n                for(int i=rowLast; i>row; i--)\\n                {\\n                    if(i>=0 && i<rows && c<rows*cols)\\n                    {\\n                        arr[c][0]=i;\\n                        arr[c++][1]=col;\\n                    }\\n                }\\n            }\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        int arr[][] = new int[rows*cols][2];\\n        int row=rStart, col=cStart;\\n        int rowLast = row, collast = col;\\n        int c=0;\\n        while(c<rows*cols)\\n        {\\n            collast++;\\n            if(row>=0)\\n            {\\n                for(int i=col; i<collast; i++)\\n                    if(i>=0 && i<cols)\\n                    {\\n                        arr[c][0]=row;\\n                        arr[c++][1]=i;\\n                    }\\n            }\\n            rowLast++;\\n            if(collast<cols)\\n            {\\n                for(int i=row; i<rowLast; i++)\\n                    if(i>=0 && i<rows)\\n                    {\\n                        arr[c][0]=i;\\n                        arr[c++][1]=collast;\\n                    }\\n            }\\n            col--;\\n            if(rowLast<rows)\\n            {\\n                for(int i=collast; i>col; i--)\\n                    if(i>=0 && i<cols)\\n                    {\\n                        arr[c][0]=rowLast;\\n                        arr[c++][1]=i;\\n                    }\\n            }\\n            row--;\\n            if(col>=0)\\n            {\\n                for(int i=rowLast; i>row; i--)\\n                {\\n                    if(i>=0 && i<rows && c<rows*cols)\\n                    {\\n                        arr[c][0]=i;\\n                        arr[c++][1]=col;\\n                    }\\n                }\\n            }\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421247,
                "title": "java-soln-simulation",
                "content": "```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        int[][] spiralMatrix = new int[rows * cols][2];\\n        \\n        int count = 1;\\n        int x = rStart;\\n        int y = cStart;\\n        int offset = Math.max(cStart, cols - cStart);\\n        int rightLimit = cStart + 2, downLimit = rStart + 2, leftLimit = cStart - 1, upLimit = rStart - 1;\\n        while(count <= rows * cols) {\\n            // right\\n            while(y < rightLimit) {\\n                if(x >= 0 && x < rows && y >= 0 && y < cols) {\\n                    spiralMatrix[count - 1][0] = x;\\n                    spiralMatrix[count - 1][1] = y;\\n                    count++;\\n                }\\n                if(y <= rightLimit - 1) y++;\\n            }\\n            y--;\\n            \\n            // down\\n            x++;\\n            while(x < downLimit) {\\n                if(x >= 0 && x < rows && y >= 0 && y < cols) {\\n                    spiralMatrix[count - 1][0] = x;\\n                    spiralMatrix[count - 1][1] = y;\\n                    count++;\\n                }\\n                if(x <= downLimit - 1) x++;\\n            }\\n            x--;\\n            \\n            // left\\n            y--;\\n            while(y >= leftLimit) {\\n                if(x >= 0 && x < rows && y >= 0 && y < cols) {\\n                    spiralMatrix[count - 1][0] = x;\\n                    spiralMatrix[count - 1][1] = y;\\n                    count++;\\n                }\\n                if(y >= leftLimit) y--;\\n            }\\n            y++;\\n            \\n            // up\\n            x--;\\n            while(x >= upLimit) {\\n                if(x >= 0 && x < rows && y >= 0 && y < cols) {\\n                    spiralMatrix[count - 1][0] = x;\\n                    spiralMatrix[count - 1][1] = y;\\n                    count++;\\n                }\\n                if(x >= upLimit) x--;\\n            }\\n            x++;\\n            \\n            y++;\\n            upLimit--;\\n            rightLimit++;\\n            downLimit++;\\n            leftLimit--;\\n        }\\n        \\n        return spiralMatrix;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        int[][] spiralMatrix = new int[rows * cols][2];\\n        \\n        int count = 1;\\n        int x = rStart;\\n        int y = cStart;\\n        int offset = Math.max(cStart, cols - cStart);\\n        int rightLimit = cStart + 2, downLimit = rStart + 2, leftLimit = cStart - 1, upLimit = rStart - 1;\\n        while(count <= rows * cols) {\\n            // right\\n            while(y < rightLimit) {\\n                if(x >= 0 && x < rows && y >= 0 && y < cols) {\\n                    spiralMatrix[count - 1][0] = x;\\n                    spiralMatrix[count - 1][1] = y;\\n                    count++;\\n                }\\n                if(y <= rightLimit - 1) y++;\\n            }\\n            y--;\\n            \\n            // down\\n            x++;\\n            while(x < downLimit) {\\n                if(x >= 0 && x < rows && y >= 0 && y < cols) {\\n                    spiralMatrix[count - 1][0] = x;\\n                    spiralMatrix[count - 1][1] = y;\\n                    count++;\\n                }\\n                if(x <= downLimit - 1) x++;\\n            }\\n            x--;\\n            \\n            // left\\n            y--;\\n            while(y >= leftLimit) {\\n                if(x >= 0 && x < rows && y >= 0 && y < cols) {\\n                    spiralMatrix[count - 1][0] = x;\\n                    spiralMatrix[count - 1][1] = y;\\n                    count++;\\n                }\\n                if(y >= leftLimit) y--;\\n            }\\n            y++;\\n            \\n            // up\\n            x--;\\n            while(x >= upLimit) {\\n                if(x >= 0 && x < rows && y >= 0 && y < cols) {\\n                    spiralMatrix[count - 1][0] = x;\\n                    spiralMatrix[count - 1][1] = y;\\n                    count++;\\n                }\\n                if(x >= upLimit) x--;\\n            }\\n            x++;\\n            \\n            y++;\\n            upLimit--;\\n            rightLimit++;\\n            downLimit++;\\n            leftLimit--;\\n        }\\n        \\n        return spiralMatrix;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3391541,
                "title": "imperative-approach-python3",
                "content": "# Code\\n```\\n\\n        UP, RIGHT, DOWN, LEFT = 0, 1, 2, 3\\n        \\n        def switch(d):\\n            return {\\n                UP:    RIGHT,\\n                RIGHT:  DOWN,\\n                DOWN:   LEFT,\\n                LEFT:     UP\\n            }[d]\\n            \\n        def move(i, j, d):\\n            return {\\n                UP:     (i - 1,     j),\\n                RIGHT:  (    i, j + 1),\\n                DOWN:   (i + 1,     j),\\n                LEFT:   (    i, j - 1)\\n            }[d]\\n\\n        def valid(i, j, m, n):\\n            return 0 <= i < m and 0 <= j < n\\n        \\n        res       = [(i, j)]\\n        d         = RIGHT\\n        num_movs  = 1\\n        it        = 0\\n\\n        while len(res) < rows * cols:\\n            for _ in range(num_movs):\\n                i, j = move(i, j, d)\\n                if valid(i, j, rows, cols):\\n                    res.append((i, j))\\n\\n            num_movs  += it & 1          # Increment every two iterations\\n            d          = switch(d)\\n            it        += 1\\n\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n\\n        UP, RIGHT, DOWN, LEFT = 0, 1, 2, 3\\n        \\n        def switch(d):\\n            return {\\n                UP:    RIGHT,\\n                RIGHT:  DOWN,\\n                DOWN:   LEFT,\\n                LEFT:     UP\\n            }[d]\\n            \\n        def move(i, j, d):\\n            return {\\n                UP:     (i - 1,     j),\\n                RIGHT:  (    i, j + 1),\\n                DOWN:   (i + 1,     j),\\n                LEFT:   (    i, j - 1)\\n            }[d]\\n\\n        def valid(i, j, m, n):\\n            return 0 <= i < m and 0 <= j < n\\n        \\n        res       = [(i, j)]\\n        d         = RIGHT\\n        num_movs  = 1\\n        it        = 0\\n\\n        while len(res) < rows * cols:\\n            for _ in range(num_movs):\\n                i, j = move(i, j, d)\\n                if valid(i, j, rows, cols):\\n                    res.append((i, j))\\n\\n            num_movs  += it & 1          # Increment every two iterations\\n            d          = switch(d)\\n            it        += 1\\n\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3356529,
                "title": "easy-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) \\n    {\\n        vector<vector<int>>ans;\\n        int r=rStart;\\n        int c=cStart;\\n        int cnt=0;\\n        int steps=2;\\n        bool even=1;\\n        cnt++;\\n        ans.push_back({rStart,cStart});\\n        while(cnt<rows*cols)\\n        {\\n             if (even)\\n             {\\n                for (int i=0;i<steps-1;i++)\\n                {\\n                    c++;\\n                    if (r>=0 && c>=0 &&r<rows && c<cols)\\n                    {\\n                        \\n                        ans.push_back({r,c});\\n                        cnt++;\\n                    }\\n                }\\n                for (int i=0;i<steps-1;i++)\\n                {\\n                    r++;\\n                     if (r>=0 && c>=0 &&r<rows && c<cols)\\n                    {\\n                        ans.push_back({r,c});\\n                        cnt++;\\n                    }\\n                }\\n             }\\n             else{\\n                 for (int i=0;i<steps-1;i++)\\n                 {\\n                     c--;\\n                      if ( r>=0 && c>=0 &&r<rows && c<cols)\\n                    {\\n                        ans.push_back({r,c});\\n                        cnt++;\\n                    }\\n                 }\\n                 for (int i=0;i<steps-1;i++)\\n                 {\\n                    r--;\\n                     if (r>=0 && c>=0 &&r<rows && c<cols)\\n                    {\\n                        ans.push_back({r,c});\\n                        cnt++;\\n                    }\\n                 }\\n             }\\n             steps++;\\n             even=1-even;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) \\n    {\\n        vector<vector<int>>ans;\\n        int r=rStart;\\n        int c=cStart;\\n        int cnt=0;\\n        int steps=2;\\n        bool even=1;\\n        cnt++;\\n        ans.push_back({rStart,cStart});\\n        while(cnt<rows*cols)\\n        {\\n             if (even)\\n             {\\n                for (int i=0;i<steps-1;i++)\\n                {\\n                    c++;\\n                    if (r>=0 && c>=0 &&r<rows && c<cols)\\n                    {\\n                        \\n                        ans.push_back({r,c});\\n                        cnt++;\\n                    }\\n                }\\n                for (int i=0;i<steps-1;i++)\\n                {\\n                    r++;\\n                     if (r>=0 && c>=0 &&r<rows && c<cols)\\n                    {\\n                        ans.push_back({r,c});\\n                        cnt++;\\n                    }\\n                }\\n             }\\n             else{\\n                 for (int i=0;i<steps-1;i++)\\n                 {\\n                     c--;\\n                      if ( r>=0 && c>=0 &&r<rows && c<cols)\\n                    {\\n                        ans.push_back({r,c});\\n                        cnt++;\\n                    }\\n                 }\\n                 for (int i=0;i<steps-1;i++)\\n                 {\\n                    r--;\\n                     if (r>=0 && c>=0 &&r<rows && c<cols)\\n                    {\\n                        ans.push_back({r,c});\\n                        cnt++;\\n                    }\\n                 }\\n             }\\n             steps++;\\n             even=1-even;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3356397,
                "title": "simple-c-solution",
                "content": "# Code\\n```\\nclass Solution \\n{\\npublic:\\n    bool liesInside(int r, int c, int rows, int cols)\\n    {\\n        return (r>=0 && r<rows && c>=0 && c<cols);\\n    }\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) \\n    {\\n        int cnt=1;\\n        vector<vector<int>> ans;\\n        vector<int> v={rStart,cStart};\\n        ans.push_back(v);\\n        int count=0, d=0, steps=1;\\n        int r=rStart, c=cStart;\\n        while(cnt!=(rows*cols))\\n        {\\n            for(int x=1; x<=steps; x++)\\n            {\\n                if(d==0)\\n                {\\n                    c++;\\n                    if(liesInside(r,c,rows,cols)) \\n                    {\\n                        vector<int> v={r,c};\\n                        ans.push_back(v);\\n                        cnt++;\\n                    }\\n                }\\n                else if(d==1)\\n                {\\n                    r++;\\n                    if(liesInside(r,c,rows,cols)) \\n                    {\\n                        vector<int> v={r,c};\\n                        ans.push_back(v);\\n                        cnt++;\\n                    }\\n                }\\n                else if(d==2)\\n                {\\n                    c--;\\n                    if(liesInside(r,c,rows,cols)) \\n                    {\\n                        vector<int> v={r,c};\\n                        ans.push_back(v);\\n                        cnt++;\\n                    } \\n                }\\n                else\\n                {\\n                    r--;\\n                    if(liesInside(r,c,rows,cols)) \\n                    {\\n                        vector<int> v={r,c};\\n                        ans.push_back(v);\\n                        cnt++;\\n                    } \\n                }\\n            }\\n            count++;\\n            d=(d+1)%4;\\n            if(count%2==0) steps++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    bool liesInside(int r, int c, int rows, int cols)\\n    {\\n        return (r>=0 && r<rows && c>=0 && c<cols);\\n    }\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) \\n    {\\n        int cnt=1;\\n        vector<vector<int>> ans;\\n        vector<int> v={rStart,cStart};\\n        ans.push_back(v);\\n        int count=0, d=0, steps=1;\\n        int r=rStart, c=cStart;\\n        while(cnt!=(rows*cols))\\n        {\\n            for(int x=1; x<=steps; x++)\\n            {\\n                if(d==0)\\n                {\\n                    c++;\\n                    if(liesInside(r,c,rows,cols)) \\n                    {\\n                        vector<int> v={r,c};\\n                        ans.push_back(v);\\n                        cnt++;\\n                    }\\n                }\\n                else if(d==1)\\n                {\\n                    r++;\\n                    if(liesInside(r,c,rows,cols)) \\n                    {\\n                        vector<int> v={r,c};\\n                        ans.push_back(v);\\n                        cnt++;\\n                    }\\n                }\\n                else if(d==2)\\n                {\\n                    c--;\\n                    if(liesInside(r,c,rows,cols)) \\n                    {\\n                        vector<int> v={r,c};\\n                        ans.push_back(v);\\n                        cnt++;\\n                    } \\n                }\\n                else\\n                {\\n                    r--;\\n                    if(liesInside(r,c,rows,cols)) \\n                    {\\n                        vector<int> v={r,c};\\n                        ans.push_back(v);\\n                        cnt++;\\n                    } \\n                }\\n            }\\n            count++;\\n            d=(d+1)%4;\\n            if(count%2==0) steps++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3351492,
                "title": "simple-java-solution-using-while-loop-and-if-conditions",
                "content": "```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        char ch=\\'s\\';\\n        int r=0;\\n        int[][] ans=new int[rows*cols][2];\\n        ans[r][0]=rStart;\\n        ans[r][1]=cStart;r++;\\n        cStart++;\\n        int times=0;\\n        int i=1;\\n        while(i<(rows*cols)){\\n           if(ch==\\'s\\'){\\n               times=times+1;\\n               ch=\\'r\\';\\n           }\\n            else if(ch==\\'r\\'){\\n                int temp=times;\\n                while(temp>0){\\n                    if(rStart>=0 && rStart<rows&&cStart>=0&&cStart<cols){\\n                        ans[r][0]=rStart;\\n                        ans[r][1]=cStart;\\n                    \\n                    r++;i++;\\n                    }\\n                    cStart++;\\n                    temp--;\\n                }\\n                ch=\\'d\\';\\n                rStart++;\\n                cStart--;\\n            }\\n            else if(ch==\\'d\\'){\\n                int temp=times;\\n                while(temp>0){\\n                    if(rStart>=0 && rStart<rows&&cStart>=0&&cStart<cols){\\n                    ans[r][0]=rStart;\\n                    ans[r][1]=cStart;\\n                    \\n                   r++;i++;}\\n                    rStart++;\\n                     temp--;\\n                }\\n                ch=\\'l\\';\\n                times=times+1;\\n                rStart--;\\n                cStart--;\\n            }\\n            else if(ch==\\'l\\'){\\n                int temp=times;\\n                while(temp>0){\\n                    if(rStart>=0 && rStart<rows&&cStart>=0&&cStart<cols){\\n                    ans[r][0]=rStart;\\n                    ans[r][1]=cStart;\\n                    \\n                    r++;i++;\\n                }\\n                    cStart--;\\n                    temp--;\\n                }\\n                ch=\\'u\\';\\n                cStart++;\\n                rStart--;\\n            }\\n            else{\\n                int temp=times;\\n                while(temp>0){\\n                    if(rStart>=0 && rStart<rows&&cStart>=0&&cStart<cols){\\n                    ans[r][0]=rStart;\\n                    ans[r][1]=cStart;\\n                    r++;i++;\\n                }\\n                    rStart--;\\n                temp--;\\n                }\\n                ch=\\'r\\';\\n                times=times+1;\\n                rStart++;\\n                cStart++;\\n            }\\n        }\\n        return ans;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        char ch=\\'s\\';\\n        int r=0;\\n        int[][] ans=new int[rows*cols][2];\\n        ans[r][0]=rStart;\\n        ans[r][1]=cStart;r++;\\n        cStart++;\\n        int times=0;\\n        int i=1;\\n        while(i<(rows*cols)){\\n           if(ch==\\'s\\'){\\n               times=times+1;\\n               ch=\\'r\\';\\n           }",
                "codeTag": "Java"
            },
            {
                "id": 3344671,
                "title": "crazy-code-will-blow-off-you-mind-c",
                "content": "# Intuition\\n<Moving in spiral and filling the value in v[t++] if ro and co lie in boundary>\\n\\n# Approach\\n<moving in a spiral ,.. with the help .of direction(d) and displacement(a)>\\n\\n# Complexity\\n- Time complexity:\\n<$$O(n^m)$$>\\n\\n- Space complexity:\\n<$$O(n*m)$$>\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nvector<vector<int>> spiralMatrixIII(int row, int col, int ro, int co) {\\n    int n=row*col;\\n    vector<vector<int>>v(n);\\n    int a=1;\\n    int t=0;\\n    int d=1;\\n    int c;\\n    while(t<n){\\n        c=a;\\n        while(c--){ // moving right \\n            if(-1<ro && ro<row && -1<co && co<col){v[t++]={ro,co};}\\n            co+=d;\\n        }\\n        c=a;\\n        while(c--){  /// moving downward\\n            if(-1<ro && ro<row && -1<co && co<col){v[t++]={ro,co};}\\n            ro+=d;\\n        }\\n        d*=(-1); /// and we will change the direction \\n        a++; /// we will increase the distane we will now cover ..\\n    }\\n    return v;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nvector<vector<int>> spiralMatrixIII(int row, int col, int ro, int co) {\\n    int n=row*col;\\n    vector<vector<int>>v(n);\\n    int a=1;\\n    int t=0;\\n    int d=1;\\n    int c;\\n    while(t<n){\\n        c=a;\\n        while(c--){ // moving right \\n            if(-1<ro && ro<row && -1<co && co<col){v[t++]={ro,co};}\\n            co+=d;\\n        }\\n        c=a;\\n        while(c--){  /// moving downward\\n            if(-1<ro && ro<row && -1<co && co<col){v[t++]={ro,co};}\\n            ro+=d;\\n        }\\n        d*=(-1); /// and we will change the direction \\n        a++; /// we will increase the distane we will now cover ..\\n    }\\n    return v;\\n}\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1565679,
                "content": [
                    {
                        "username": "wise",
                        "content": "Whenever we would move outside the boundary of the grid, we continue our walk outside the grid (but may return to the grid boundary later.) \\n\\nwhat the heck is this?"
                    },
                    {
                        "username": "yinlosky",
                        "content": "It means you keeps walking even if you are outside of the grid, but because you are walking clockwise, eventually you will return back to the grid, and you will start saving the cell that is in the gird into your result. If the cell is outside of the grid, you do not save the cell. \\nTake out a piece of paper, and draw a grid, and start at any cell and walk clockwise and you will understand. "
                    },
                    {
                        "username": "2uringTested",
                        "content": "where ever you are starting the spiral in this problem, consider it to be the end point of the spiral traversal we were doing in previous such problems like spiral matrix I and spiral Matrix II, if the (rStart,cStart) were exactly at the middle of the matrix then we wouldn\\'t be going out of the matrix at all, but since it is not exactly at the middle, it means its the spiral end to a even bigger matrix, of which, only a part of it is given to us.\\n\\nYou can also actually calculate the actual dimensions of the matrix this starting point would\\'ve been a spiral end to. and make a 2d matrix of that size, traverse it normally and push every coordinate which would be within this given rows and cols and ignore the ones which wouldnt be there in it and then reverse that order.\\n\\n"
                    },
                    {
                        "username": "bharat_gupta",
                        "content": "I can feel a spiral moving inside my head forcing me to break my pc."
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "\\uD83D\\uDE02"
                    },
                    {
                        "username": "papaggalos",
                        "content": "Exquisite problem, I\\'m on the brink of forgetting how LOOPS work!"
                    },
                    {
                        "username": "BREATHTAKER200",
                        "content": "Why??"
                    },
                    {
                        "username": "neil_paul",
                        "content": "\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "**Since I was walking outside the grid and by mistake I turned anti-clockwise now I am  in South Korea trying to figure out what went wrong**"
                    },
                    {
                        "username": "To-heeb",
                        "content": ",keep moving forward you will be in North Korea in a no time"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "This should have been marked as \\'Hard\\'"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Once you\\'ve done Spiral Matrix I this one isn\\'t particularly challenging. Just keep an eye on how many steps you take when going right, down, left, and up, and how those steps increase at a regular interval on each cycle."
                    },
                    {
                        "username": "sav20011962",
                        "content": "Hello, I can not understand - in the previous tasks of this series:\\n54.Spiral Matrix\\n59. Spiral Matrix II\\nthe matrix was bypassed in a twisting spiral, the bypass rules were obvious and unambiguous, but here the rules have changed and the principle of changing the direction of movement is generally incomprehensible. For example, in \"Example 1\" why suddenly after \"2\" do not continue to move to the right, why change direction to \"down\". Similarly, in \"Example 2\" after \"3\" - why does the direction change to \"left\" while the direction \"down\" is free?"
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@sav20011962](/sav20011962) it is mentioned that you are facing east, so it essentially means that the movement is left to right initially"
                    },
                    {
                        "username": "sav20011962",
                        "content": "[@2uringTested](/2uringTested) \\nnowhere is it indicated that the initial movement is \"left-to-right\", just \"clockwise\", then if the movement is \"top-down\" first, this matrix will turn out:\\n30 25 16 05 06 07\\n29 24 15 04 01 08\\n28 23 14 03 02 09\\n27 22 13 12 11 10\\n26 21 20 19 18 17"
                    },
                    {
                        "username": "2uringTested",
                        "content": "where ever you are starting the spiral in this problem, consider it to be the end point of the spiral traversal we were doing in previous such problems like spiral matrix I and spiral Matrix II, if the (rStart,cStart) were exactly at the middle of the matrix then we wouldn't be going out of the matrix at all, but since it is not exactly at the middle, it means its the spiral end to a even bigger matrix, of which, only a part of it is given to us.\n\nYou can also actually calculate the actual dimensions of the matrix this starting point would've been a spiral end to. and make a 2d matrix of that size, traverse it normally and push every coordinate which would be within this given rows and cols and ignore the ones which wouldnt be there in it and then reverse that order."
                    },
                    {
                        "username": "pulkit31997",
                        "content": "Examining the lengths of our walk in each direction, we find the following pattern: 1, 1, 2, 2, 3, 3, 4, 4, ...\\nshould be mentioned in description"
                    },
                    {
                        "username": "gaurav707026",
                        "content": "I am here after solving two similar problems i.e. matrix I and matrix II and thought this will be the similar problem, but travelling outside the matrix made me out of track."
                    }
                ]
            },
            {
                "id": 1899832,
                "content": [
                    {
                        "username": "wise",
                        "content": "Whenever we would move outside the boundary of the grid, we continue our walk outside the grid (but may return to the grid boundary later.) \\n\\nwhat the heck is this?"
                    },
                    {
                        "username": "yinlosky",
                        "content": "It means you keeps walking even if you are outside of the grid, but because you are walking clockwise, eventually you will return back to the grid, and you will start saving the cell that is in the gird into your result. If the cell is outside of the grid, you do not save the cell. \\nTake out a piece of paper, and draw a grid, and start at any cell and walk clockwise and you will understand. "
                    },
                    {
                        "username": "2uringTested",
                        "content": "where ever you are starting the spiral in this problem, consider it to be the end point of the spiral traversal we were doing in previous such problems like spiral matrix I and spiral Matrix II, if the (rStart,cStart) were exactly at the middle of the matrix then we wouldn\\'t be going out of the matrix at all, but since it is not exactly at the middle, it means its the spiral end to a even bigger matrix, of which, only a part of it is given to us.\\n\\nYou can also actually calculate the actual dimensions of the matrix this starting point would\\'ve been a spiral end to. and make a 2d matrix of that size, traverse it normally and push every coordinate which would be within this given rows and cols and ignore the ones which wouldnt be there in it and then reverse that order.\\n\\n"
                    },
                    {
                        "username": "bharat_gupta",
                        "content": "I can feel a spiral moving inside my head forcing me to break my pc."
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "\\uD83D\\uDE02"
                    },
                    {
                        "username": "papaggalos",
                        "content": "Exquisite problem, I\\'m on the brink of forgetting how LOOPS work!"
                    },
                    {
                        "username": "BREATHTAKER200",
                        "content": "Why??"
                    },
                    {
                        "username": "neil_paul",
                        "content": "\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "**Since I was walking outside the grid and by mistake I turned anti-clockwise now I am  in South Korea trying to figure out what went wrong**"
                    },
                    {
                        "username": "To-heeb",
                        "content": ",keep moving forward you will be in North Korea in a no time"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "This should have been marked as \\'Hard\\'"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Once you\\'ve done Spiral Matrix I this one isn\\'t particularly challenging. Just keep an eye on how many steps you take when going right, down, left, and up, and how those steps increase at a regular interval on each cycle."
                    },
                    {
                        "username": "sav20011962",
                        "content": "Hello, I can not understand - in the previous tasks of this series:\\n54.Spiral Matrix\\n59. Spiral Matrix II\\nthe matrix was bypassed in a twisting spiral, the bypass rules were obvious and unambiguous, but here the rules have changed and the principle of changing the direction of movement is generally incomprehensible. For example, in \"Example 1\" why suddenly after \"2\" do not continue to move to the right, why change direction to \"down\". Similarly, in \"Example 2\" after \"3\" - why does the direction change to \"left\" while the direction \"down\" is free?"
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@sav20011962](/sav20011962) it is mentioned that you are facing east, so it essentially means that the movement is left to right initially"
                    },
                    {
                        "username": "sav20011962",
                        "content": "[@2uringTested](/2uringTested) \\nnowhere is it indicated that the initial movement is \"left-to-right\", just \"clockwise\", then if the movement is \"top-down\" first, this matrix will turn out:\\n30 25 16 05 06 07\\n29 24 15 04 01 08\\n28 23 14 03 02 09\\n27 22 13 12 11 10\\n26 21 20 19 18 17"
                    },
                    {
                        "username": "2uringTested",
                        "content": "where ever you are starting the spiral in this problem, consider it to be the end point of the spiral traversal we were doing in previous such problems like spiral matrix I and spiral Matrix II, if the (rStart,cStart) were exactly at the middle of the matrix then we wouldn't be going out of the matrix at all, but since it is not exactly at the middle, it means its the spiral end to a even bigger matrix, of which, only a part of it is given to us.\n\nYou can also actually calculate the actual dimensions of the matrix this starting point would've been a spiral end to. and make a 2d matrix of that size, traverse it normally and push every coordinate which would be within this given rows and cols and ignore the ones which wouldnt be there in it and then reverse that order."
                    },
                    {
                        "username": "pulkit31997",
                        "content": "Examining the lengths of our walk in each direction, we find the following pattern: 1, 1, 2, 2, 3, 3, 4, 4, ...\\nshould be mentioned in description"
                    },
                    {
                        "username": "gaurav707026",
                        "content": "I am here after solving two similar problems i.e. matrix I and matrix II and thought this will be the similar problem, but travelling outside the matrix made me out of track."
                    }
                ]
            },
            {
                "id": 1804177,
                "content": [
                    {
                        "username": "wise",
                        "content": "Whenever we would move outside the boundary of the grid, we continue our walk outside the grid (but may return to the grid boundary later.) \\n\\nwhat the heck is this?"
                    },
                    {
                        "username": "yinlosky",
                        "content": "It means you keeps walking even if you are outside of the grid, but because you are walking clockwise, eventually you will return back to the grid, and you will start saving the cell that is in the gird into your result. If the cell is outside of the grid, you do not save the cell. \\nTake out a piece of paper, and draw a grid, and start at any cell and walk clockwise and you will understand. "
                    },
                    {
                        "username": "2uringTested",
                        "content": "where ever you are starting the spiral in this problem, consider it to be the end point of the spiral traversal we were doing in previous such problems like spiral matrix I and spiral Matrix II, if the (rStart,cStart) were exactly at the middle of the matrix then we wouldn\\'t be going out of the matrix at all, but since it is not exactly at the middle, it means its the spiral end to a even bigger matrix, of which, only a part of it is given to us.\\n\\nYou can also actually calculate the actual dimensions of the matrix this starting point would\\'ve been a spiral end to. and make a 2d matrix of that size, traverse it normally and push every coordinate which would be within this given rows and cols and ignore the ones which wouldnt be there in it and then reverse that order.\\n\\n"
                    },
                    {
                        "username": "bharat_gupta",
                        "content": "I can feel a spiral moving inside my head forcing me to break my pc."
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "\\uD83D\\uDE02"
                    },
                    {
                        "username": "papaggalos",
                        "content": "Exquisite problem, I\\'m on the brink of forgetting how LOOPS work!"
                    },
                    {
                        "username": "BREATHTAKER200",
                        "content": "Why??"
                    },
                    {
                        "username": "neil_paul",
                        "content": "\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "**Since I was walking outside the grid and by mistake I turned anti-clockwise now I am  in South Korea trying to figure out what went wrong**"
                    },
                    {
                        "username": "To-heeb",
                        "content": ",keep moving forward you will be in North Korea in a no time"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "This should have been marked as \\'Hard\\'"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Once you\\'ve done Spiral Matrix I this one isn\\'t particularly challenging. Just keep an eye on how many steps you take when going right, down, left, and up, and how those steps increase at a regular interval on each cycle."
                    },
                    {
                        "username": "sav20011962",
                        "content": "Hello, I can not understand - in the previous tasks of this series:\\n54.Spiral Matrix\\n59. Spiral Matrix II\\nthe matrix was bypassed in a twisting spiral, the bypass rules were obvious and unambiguous, but here the rules have changed and the principle of changing the direction of movement is generally incomprehensible. For example, in \"Example 1\" why suddenly after \"2\" do not continue to move to the right, why change direction to \"down\". Similarly, in \"Example 2\" after \"3\" - why does the direction change to \"left\" while the direction \"down\" is free?"
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@sav20011962](/sav20011962) it is mentioned that you are facing east, so it essentially means that the movement is left to right initially"
                    },
                    {
                        "username": "sav20011962",
                        "content": "[@2uringTested](/2uringTested) \\nnowhere is it indicated that the initial movement is \"left-to-right\", just \"clockwise\", then if the movement is \"top-down\" first, this matrix will turn out:\\n30 25 16 05 06 07\\n29 24 15 04 01 08\\n28 23 14 03 02 09\\n27 22 13 12 11 10\\n26 21 20 19 18 17"
                    },
                    {
                        "username": "2uringTested",
                        "content": "where ever you are starting the spiral in this problem, consider it to be the end point of the spiral traversal we were doing in previous such problems like spiral matrix I and spiral Matrix II, if the (rStart,cStart) were exactly at the middle of the matrix then we wouldn't be going out of the matrix at all, but since it is not exactly at the middle, it means its the spiral end to a even bigger matrix, of which, only a part of it is given to us.\n\nYou can also actually calculate the actual dimensions of the matrix this starting point would've been a spiral end to. and make a 2d matrix of that size, traverse it normally and push every coordinate which would be within this given rows and cols and ignore the ones which wouldnt be there in it and then reverse that order."
                    },
                    {
                        "username": "pulkit31997",
                        "content": "Examining the lengths of our walk in each direction, we find the following pattern: 1, 1, 2, 2, 3, 3, 4, 4, ...\\nshould be mentioned in description"
                    },
                    {
                        "username": "gaurav707026",
                        "content": "I am here after solving two similar problems i.e. matrix I and matrix II and thought this will be the similar problem, but travelling outside the matrix made me out of track."
                    }
                ]
            },
            {
                "id": 1782042,
                "content": [
                    {
                        "username": "wise",
                        "content": "Whenever we would move outside the boundary of the grid, we continue our walk outside the grid (but may return to the grid boundary later.) \\n\\nwhat the heck is this?"
                    },
                    {
                        "username": "yinlosky",
                        "content": "It means you keeps walking even if you are outside of the grid, but because you are walking clockwise, eventually you will return back to the grid, and you will start saving the cell that is in the gird into your result. If the cell is outside of the grid, you do not save the cell. \\nTake out a piece of paper, and draw a grid, and start at any cell and walk clockwise and you will understand. "
                    },
                    {
                        "username": "2uringTested",
                        "content": "where ever you are starting the spiral in this problem, consider it to be the end point of the spiral traversal we were doing in previous such problems like spiral matrix I and spiral Matrix II, if the (rStart,cStart) were exactly at the middle of the matrix then we wouldn\\'t be going out of the matrix at all, but since it is not exactly at the middle, it means its the spiral end to a even bigger matrix, of which, only a part of it is given to us.\\n\\nYou can also actually calculate the actual dimensions of the matrix this starting point would\\'ve been a spiral end to. and make a 2d matrix of that size, traverse it normally and push every coordinate which would be within this given rows and cols and ignore the ones which wouldnt be there in it and then reverse that order.\\n\\n"
                    },
                    {
                        "username": "bharat_gupta",
                        "content": "I can feel a spiral moving inside my head forcing me to break my pc."
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "\\uD83D\\uDE02"
                    },
                    {
                        "username": "papaggalos",
                        "content": "Exquisite problem, I\\'m on the brink of forgetting how LOOPS work!"
                    },
                    {
                        "username": "BREATHTAKER200",
                        "content": "Why??"
                    },
                    {
                        "username": "neil_paul",
                        "content": "\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "**Since I was walking outside the grid and by mistake I turned anti-clockwise now I am  in South Korea trying to figure out what went wrong**"
                    },
                    {
                        "username": "To-heeb",
                        "content": ",keep moving forward you will be in North Korea in a no time"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "This should have been marked as \\'Hard\\'"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Once you\\'ve done Spiral Matrix I this one isn\\'t particularly challenging. Just keep an eye on how many steps you take when going right, down, left, and up, and how those steps increase at a regular interval on each cycle."
                    },
                    {
                        "username": "sav20011962",
                        "content": "Hello, I can not understand - in the previous tasks of this series:\\n54.Spiral Matrix\\n59. Spiral Matrix II\\nthe matrix was bypassed in a twisting spiral, the bypass rules were obvious and unambiguous, but here the rules have changed and the principle of changing the direction of movement is generally incomprehensible. For example, in \"Example 1\" why suddenly after \"2\" do not continue to move to the right, why change direction to \"down\". Similarly, in \"Example 2\" after \"3\" - why does the direction change to \"left\" while the direction \"down\" is free?"
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@sav20011962](/sav20011962) it is mentioned that you are facing east, so it essentially means that the movement is left to right initially"
                    },
                    {
                        "username": "sav20011962",
                        "content": "[@2uringTested](/2uringTested) \\nnowhere is it indicated that the initial movement is \"left-to-right\", just \"clockwise\", then if the movement is \"top-down\" first, this matrix will turn out:\\n30 25 16 05 06 07\\n29 24 15 04 01 08\\n28 23 14 03 02 09\\n27 22 13 12 11 10\\n26 21 20 19 18 17"
                    },
                    {
                        "username": "2uringTested",
                        "content": "where ever you are starting the spiral in this problem, consider it to be the end point of the spiral traversal we were doing in previous such problems like spiral matrix I and spiral Matrix II, if the (rStart,cStart) were exactly at the middle of the matrix then we wouldn't be going out of the matrix at all, but since it is not exactly at the middle, it means its the spiral end to a even bigger matrix, of which, only a part of it is given to us.\n\nYou can also actually calculate the actual dimensions of the matrix this starting point would've been a spiral end to. and make a 2d matrix of that size, traverse it normally and push every coordinate which would be within this given rows and cols and ignore the ones which wouldnt be there in it and then reverse that order."
                    },
                    {
                        "username": "pulkit31997",
                        "content": "Examining the lengths of our walk in each direction, we find the following pattern: 1, 1, 2, 2, 3, 3, 4, 4, ...\\nshould be mentioned in description"
                    },
                    {
                        "username": "gaurav707026",
                        "content": "I am here after solving two similar problems i.e. matrix I and matrix II and thought this will be the similar problem, but travelling outside the matrix made me out of track."
                    }
                ]
            },
            {
                "id": 1965068,
                "content": [
                    {
                        "username": "wise",
                        "content": "Whenever we would move outside the boundary of the grid, we continue our walk outside the grid (but may return to the grid boundary later.) \\n\\nwhat the heck is this?"
                    },
                    {
                        "username": "yinlosky",
                        "content": "It means you keeps walking even if you are outside of the grid, but because you are walking clockwise, eventually you will return back to the grid, and you will start saving the cell that is in the gird into your result. If the cell is outside of the grid, you do not save the cell. \\nTake out a piece of paper, and draw a grid, and start at any cell and walk clockwise and you will understand. "
                    },
                    {
                        "username": "2uringTested",
                        "content": "where ever you are starting the spiral in this problem, consider it to be the end point of the spiral traversal we were doing in previous such problems like spiral matrix I and spiral Matrix II, if the (rStart,cStart) were exactly at the middle of the matrix then we wouldn\\'t be going out of the matrix at all, but since it is not exactly at the middle, it means its the spiral end to a even bigger matrix, of which, only a part of it is given to us.\\n\\nYou can also actually calculate the actual dimensions of the matrix this starting point would\\'ve been a spiral end to. and make a 2d matrix of that size, traverse it normally and push every coordinate which would be within this given rows and cols and ignore the ones which wouldnt be there in it and then reverse that order.\\n\\n"
                    },
                    {
                        "username": "bharat_gupta",
                        "content": "I can feel a spiral moving inside my head forcing me to break my pc."
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "\\uD83D\\uDE02"
                    },
                    {
                        "username": "papaggalos",
                        "content": "Exquisite problem, I\\'m on the brink of forgetting how LOOPS work!"
                    },
                    {
                        "username": "BREATHTAKER200",
                        "content": "Why??"
                    },
                    {
                        "username": "neil_paul",
                        "content": "\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "**Since I was walking outside the grid and by mistake I turned anti-clockwise now I am  in South Korea trying to figure out what went wrong**"
                    },
                    {
                        "username": "To-heeb",
                        "content": ",keep moving forward you will be in North Korea in a no time"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "This should have been marked as \\'Hard\\'"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Once you\\'ve done Spiral Matrix I this one isn\\'t particularly challenging. Just keep an eye on how many steps you take when going right, down, left, and up, and how those steps increase at a regular interval on each cycle."
                    },
                    {
                        "username": "sav20011962",
                        "content": "Hello, I can not understand - in the previous tasks of this series:\\n54.Spiral Matrix\\n59. Spiral Matrix II\\nthe matrix was bypassed in a twisting spiral, the bypass rules were obvious and unambiguous, but here the rules have changed and the principle of changing the direction of movement is generally incomprehensible. For example, in \"Example 1\" why suddenly after \"2\" do not continue to move to the right, why change direction to \"down\". Similarly, in \"Example 2\" after \"3\" - why does the direction change to \"left\" while the direction \"down\" is free?"
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@sav20011962](/sav20011962) it is mentioned that you are facing east, so it essentially means that the movement is left to right initially"
                    },
                    {
                        "username": "sav20011962",
                        "content": "[@2uringTested](/2uringTested) \\nnowhere is it indicated that the initial movement is \"left-to-right\", just \"clockwise\", then if the movement is \"top-down\" first, this matrix will turn out:\\n30 25 16 05 06 07\\n29 24 15 04 01 08\\n28 23 14 03 02 09\\n27 22 13 12 11 10\\n26 21 20 19 18 17"
                    },
                    {
                        "username": "2uringTested",
                        "content": "where ever you are starting the spiral in this problem, consider it to be the end point of the spiral traversal we were doing in previous such problems like spiral matrix I and spiral Matrix II, if the (rStart,cStart) were exactly at the middle of the matrix then we wouldn't be going out of the matrix at all, but since it is not exactly at the middle, it means its the spiral end to a even bigger matrix, of which, only a part of it is given to us.\n\nYou can also actually calculate the actual dimensions of the matrix this starting point would've been a spiral end to. and make a 2d matrix of that size, traverse it normally and push every coordinate which would be within this given rows and cols and ignore the ones which wouldnt be there in it and then reverse that order."
                    },
                    {
                        "username": "pulkit31997",
                        "content": "Examining the lengths of our walk in each direction, we find the following pattern: 1, 1, 2, 2, 3, 3, 4, 4, ...\\nshould be mentioned in description"
                    },
                    {
                        "username": "gaurav707026",
                        "content": "I am here after solving two similar problems i.e. matrix I and matrix II and thought this will be the similar problem, but travelling outside the matrix made me out of track."
                    }
                ]
            },
            {
                "id": 2037855,
                "content": [
                    {
                        "username": "wise",
                        "content": "Whenever we would move outside the boundary of the grid, we continue our walk outside the grid (but may return to the grid boundary later.) \\n\\nwhat the heck is this?"
                    },
                    {
                        "username": "yinlosky",
                        "content": "It means you keeps walking even if you are outside of the grid, but because you are walking clockwise, eventually you will return back to the grid, and you will start saving the cell that is in the gird into your result. If the cell is outside of the grid, you do not save the cell. \\nTake out a piece of paper, and draw a grid, and start at any cell and walk clockwise and you will understand. "
                    },
                    {
                        "username": "2uringTested",
                        "content": "where ever you are starting the spiral in this problem, consider it to be the end point of the spiral traversal we were doing in previous such problems like spiral matrix I and spiral Matrix II, if the (rStart,cStart) were exactly at the middle of the matrix then we wouldn\\'t be going out of the matrix at all, but since it is not exactly at the middle, it means its the spiral end to a even bigger matrix, of which, only a part of it is given to us.\\n\\nYou can also actually calculate the actual dimensions of the matrix this starting point would\\'ve been a spiral end to. and make a 2d matrix of that size, traverse it normally and push every coordinate which would be within this given rows and cols and ignore the ones which wouldnt be there in it and then reverse that order.\\n\\n"
                    },
                    {
                        "username": "bharat_gupta",
                        "content": "I can feel a spiral moving inside my head forcing me to break my pc."
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "\\uD83D\\uDE02"
                    },
                    {
                        "username": "papaggalos",
                        "content": "Exquisite problem, I\\'m on the brink of forgetting how LOOPS work!"
                    },
                    {
                        "username": "BREATHTAKER200",
                        "content": "Why??"
                    },
                    {
                        "username": "neil_paul",
                        "content": "\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "**Since I was walking outside the grid and by mistake I turned anti-clockwise now I am  in South Korea trying to figure out what went wrong**"
                    },
                    {
                        "username": "To-heeb",
                        "content": ",keep moving forward you will be in North Korea in a no time"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "This should have been marked as \\'Hard\\'"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Once you\\'ve done Spiral Matrix I this one isn\\'t particularly challenging. Just keep an eye on how many steps you take when going right, down, left, and up, and how those steps increase at a regular interval on each cycle."
                    },
                    {
                        "username": "sav20011962",
                        "content": "Hello, I can not understand - in the previous tasks of this series:\\n54.Spiral Matrix\\n59. Spiral Matrix II\\nthe matrix was bypassed in a twisting spiral, the bypass rules were obvious and unambiguous, but here the rules have changed and the principle of changing the direction of movement is generally incomprehensible. For example, in \"Example 1\" why suddenly after \"2\" do not continue to move to the right, why change direction to \"down\". Similarly, in \"Example 2\" after \"3\" - why does the direction change to \"left\" while the direction \"down\" is free?"
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@sav20011962](/sav20011962) it is mentioned that you are facing east, so it essentially means that the movement is left to right initially"
                    },
                    {
                        "username": "sav20011962",
                        "content": "[@2uringTested](/2uringTested) \\nnowhere is it indicated that the initial movement is \"left-to-right\", just \"clockwise\", then if the movement is \"top-down\" first, this matrix will turn out:\\n30 25 16 05 06 07\\n29 24 15 04 01 08\\n28 23 14 03 02 09\\n27 22 13 12 11 10\\n26 21 20 19 18 17"
                    },
                    {
                        "username": "2uringTested",
                        "content": "where ever you are starting the spiral in this problem, consider it to be the end point of the spiral traversal we were doing in previous such problems like spiral matrix I and spiral Matrix II, if the (rStart,cStart) were exactly at the middle of the matrix then we wouldn't be going out of the matrix at all, but since it is not exactly at the middle, it means its the spiral end to a even bigger matrix, of which, only a part of it is given to us.\n\nYou can also actually calculate the actual dimensions of the matrix this starting point would've been a spiral end to. and make a 2d matrix of that size, traverse it normally and push every coordinate which would be within this given rows and cols and ignore the ones which wouldnt be there in it and then reverse that order."
                    },
                    {
                        "username": "pulkit31997",
                        "content": "Examining the lengths of our walk in each direction, we find the following pattern: 1, 1, 2, 2, 3, 3, 4, 4, ...\\nshould be mentioned in description"
                    },
                    {
                        "username": "gaurav707026",
                        "content": "I am here after solving two similar problems i.e. matrix I and matrix II and thought this will be the similar problem, but travelling outside the matrix made me out of track."
                    }
                ]
            },
            {
                "id": 1970393,
                "content": [
                    {
                        "username": "wise",
                        "content": "Whenever we would move outside the boundary of the grid, we continue our walk outside the grid (but may return to the grid boundary later.) \\n\\nwhat the heck is this?"
                    },
                    {
                        "username": "yinlosky",
                        "content": "It means you keeps walking even if you are outside of the grid, but because you are walking clockwise, eventually you will return back to the grid, and you will start saving the cell that is in the gird into your result. If the cell is outside of the grid, you do not save the cell. \\nTake out a piece of paper, and draw a grid, and start at any cell and walk clockwise and you will understand. "
                    },
                    {
                        "username": "2uringTested",
                        "content": "where ever you are starting the spiral in this problem, consider it to be the end point of the spiral traversal we were doing in previous such problems like spiral matrix I and spiral Matrix II, if the (rStart,cStart) were exactly at the middle of the matrix then we wouldn\\'t be going out of the matrix at all, but since it is not exactly at the middle, it means its the spiral end to a even bigger matrix, of which, only a part of it is given to us.\\n\\nYou can also actually calculate the actual dimensions of the matrix this starting point would\\'ve been a spiral end to. and make a 2d matrix of that size, traverse it normally and push every coordinate which would be within this given rows and cols and ignore the ones which wouldnt be there in it and then reverse that order.\\n\\n"
                    },
                    {
                        "username": "bharat_gupta",
                        "content": "I can feel a spiral moving inside my head forcing me to break my pc."
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "\\uD83D\\uDE02"
                    },
                    {
                        "username": "papaggalos",
                        "content": "Exquisite problem, I\\'m on the brink of forgetting how LOOPS work!"
                    },
                    {
                        "username": "BREATHTAKER200",
                        "content": "Why??"
                    },
                    {
                        "username": "neil_paul",
                        "content": "\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "**Since I was walking outside the grid and by mistake I turned anti-clockwise now I am  in South Korea trying to figure out what went wrong**"
                    },
                    {
                        "username": "To-heeb",
                        "content": ",keep moving forward you will be in North Korea in a no time"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "This should have been marked as \\'Hard\\'"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Once you\\'ve done Spiral Matrix I this one isn\\'t particularly challenging. Just keep an eye on how many steps you take when going right, down, left, and up, and how those steps increase at a regular interval on each cycle."
                    },
                    {
                        "username": "sav20011962",
                        "content": "Hello, I can not understand - in the previous tasks of this series:\\n54.Spiral Matrix\\n59. Spiral Matrix II\\nthe matrix was bypassed in a twisting spiral, the bypass rules were obvious and unambiguous, but here the rules have changed and the principle of changing the direction of movement is generally incomprehensible. For example, in \"Example 1\" why suddenly after \"2\" do not continue to move to the right, why change direction to \"down\". Similarly, in \"Example 2\" after \"3\" - why does the direction change to \"left\" while the direction \"down\" is free?"
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@sav20011962](/sav20011962) it is mentioned that you are facing east, so it essentially means that the movement is left to right initially"
                    },
                    {
                        "username": "sav20011962",
                        "content": "[@2uringTested](/2uringTested) \\nnowhere is it indicated that the initial movement is \"left-to-right\", just \"clockwise\", then if the movement is \"top-down\" first, this matrix will turn out:\\n30 25 16 05 06 07\\n29 24 15 04 01 08\\n28 23 14 03 02 09\\n27 22 13 12 11 10\\n26 21 20 19 18 17"
                    },
                    {
                        "username": "2uringTested",
                        "content": "where ever you are starting the spiral in this problem, consider it to be the end point of the spiral traversal we were doing in previous such problems like spiral matrix I and spiral Matrix II, if the (rStart,cStart) were exactly at the middle of the matrix then we wouldn't be going out of the matrix at all, but since it is not exactly at the middle, it means its the spiral end to a even bigger matrix, of which, only a part of it is given to us.\n\nYou can also actually calculate the actual dimensions of the matrix this starting point would've been a spiral end to. and make a 2d matrix of that size, traverse it normally and push every coordinate which would be within this given rows and cols and ignore the ones which wouldnt be there in it and then reverse that order."
                    },
                    {
                        "username": "pulkit31997",
                        "content": "Examining the lengths of our walk in each direction, we find the following pattern: 1, 1, 2, 2, 3, 3, 4, 4, ...\\nshould be mentioned in description"
                    },
                    {
                        "username": "gaurav707026",
                        "content": "I am here after solving two similar problems i.e. matrix I and matrix II and thought this will be the similar problem, but travelling outside the matrix made me out of track."
                    }
                ]
            },
            {
                "id": 1888980,
                "content": [
                    {
                        "username": "wise",
                        "content": "Whenever we would move outside the boundary of the grid, we continue our walk outside the grid (but may return to the grid boundary later.) \\n\\nwhat the heck is this?"
                    },
                    {
                        "username": "yinlosky",
                        "content": "It means you keeps walking even if you are outside of the grid, but because you are walking clockwise, eventually you will return back to the grid, and you will start saving the cell that is in the gird into your result. If the cell is outside of the grid, you do not save the cell. \\nTake out a piece of paper, and draw a grid, and start at any cell and walk clockwise and you will understand. "
                    },
                    {
                        "username": "2uringTested",
                        "content": "where ever you are starting the spiral in this problem, consider it to be the end point of the spiral traversal we were doing in previous such problems like spiral matrix I and spiral Matrix II, if the (rStart,cStart) were exactly at the middle of the matrix then we wouldn\\'t be going out of the matrix at all, but since it is not exactly at the middle, it means its the spiral end to a even bigger matrix, of which, only a part of it is given to us.\\n\\nYou can also actually calculate the actual dimensions of the matrix this starting point would\\'ve been a spiral end to. and make a 2d matrix of that size, traverse it normally and push every coordinate which would be within this given rows and cols and ignore the ones which wouldnt be there in it and then reverse that order.\\n\\n"
                    },
                    {
                        "username": "bharat_gupta",
                        "content": "I can feel a spiral moving inside my head forcing me to break my pc."
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "\\uD83D\\uDE02"
                    },
                    {
                        "username": "papaggalos",
                        "content": "Exquisite problem, I\\'m on the brink of forgetting how LOOPS work!"
                    },
                    {
                        "username": "BREATHTAKER200",
                        "content": "Why??"
                    },
                    {
                        "username": "neil_paul",
                        "content": "\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "**Since I was walking outside the grid and by mistake I turned anti-clockwise now I am  in South Korea trying to figure out what went wrong**"
                    },
                    {
                        "username": "To-heeb",
                        "content": ",keep moving forward you will be in North Korea in a no time"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "This should have been marked as \\'Hard\\'"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Once you\\'ve done Spiral Matrix I this one isn\\'t particularly challenging. Just keep an eye on how many steps you take when going right, down, left, and up, and how those steps increase at a regular interval on each cycle."
                    },
                    {
                        "username": "sav20011962",
                        "content": "Hello, I can not understand - in the previous tasks of this series:\\n54.Spiral Matrix\\n59. Spiral Matrix II\\nthe matrix was bypassed in a twisting spiral, the bypass rules were obvious and unambiguous, but here the rules have changed and the principle of changing the direction of movement is generally incomprehensible. For example, in \"Example 1\" why suddenly after \"2\" do not continue to move to the right, why change direction to \"down\". Similarly, in \"Example 2\" after \"3\" - why does the direction change to \"left\" while the direction \"down\" is free?"
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@sav20011962](/sav20011962) it is mentioned that you are facing east, so it essentially means that the movement is left to right initially"
                    },
                    {
                        "username": "sav20011962",
                        "content": "[@2uringTested](/2uringTested) \\nnowhere is it indicated that the initial movement is \"left-to-right\", just \"clockwise\", then if the movement is \"top-down\" first, this matrix will turn out:\\n30 25 16 05 06 07\\n29 24 15 04 01 08\\n28 23 14 03 02 09\\n27 22 13 12 11 10\\n26 21 20 19 18 17"
                    },
                    {
                        "username": "2uringTested",
                        "content": "where ever you are starting the spiral in this problem, consider it to be the end point of the spiral traversal we were doing in previous such problems like spiral matrix I and spiral Matrix II, if the (rStart,cStart) were exactly at the middle of the matrix then we wouldn't be going out of the matrix at all, but since it is not exactly at the middle, it means its the spiral end to a even bigger matrix, of which, only a part of it is given to us.\n\nYou can also actually calculate the actual dimensions of the matrix this starting point would've been a spiral end to. and make a 2d matrix of that size, traverse it normally and push every coordinate which would be within this given rows and cols and ignore the ones which wouldnt be there in it and then reverse that order."
                    },
                    {
                        "username": "pulkit31997",
                        "content": "Examining the lengths of our walk in each direction, we find the following pattern: 1, 1, 2, 2, 3, 3, 4, 4, ...\\nshould be mentioned in description"
                    },
                    {
                        "username": "gaurav707026",
                        "content": "I am here after solving two similar problems i.e. matrix I and matrix II and thought this will be the similar problem, but travelling outside the matrix made me out of track."
                    }
                ]
            },
            {
                "id": 2052023,
                "content": [
                    {
                        "username": "wise",
                        "content": "Whenever we would move outside the boundary of the grid, we continue our walk outside the grid (but may return to the grid boundary later.) \\n\\nwhat the heck is this?"
                    },
                    {
                        "username": "yinlosky",
                        "content": "It means you keeps walking even if you are outside of the grid, but because you are walking clockwise, eventually you will return back to the grid, and you will start saving the cell that is in the gird into your result. If the cell is outside of the grid, you do not save the cell. \\nTake out a piece of paper, and draw a grid, and start at any cell and walk clockwise and you will understand. "
                    },
                    {
                        "username": "2uringTested",
                        "content": "where ever you are starting the spiral in this problem, consider it to be the end point of the spiral traversal we were doing in previous such problems like spiral matrix I and spiral Matrix II, if the (rStart,cStart) were exactly at the middle of the matrix then we wouldn\\'t be going out of the matrix at all, but since it is not exactly at the middle, it means its the spiral end to a even bigger matrix, of which, only a part of it is given to us.\\n\\nYou can also actually calculate the actual dimensions of the matrix this starting point would\\'ve been a spiral end to. and make a 2d matrix of that size, traverse it normally and push every coordinate which would be within this given rows and cols and ignore the ones which wouldnt be there in it and then reverse that order.\\n\\n"
                    },
                    {
                        "username": "bharat_gupta",
                        "content": "I can feel a spiral moving inside my head forcing me to break my pc."
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "\\uD83D\\uDE02"
                    },
                    {
                        "username": "papaggalos",
                        "content": "Exquisite problem, I\\'m on the brink of forgetting how LOOPS work!"
                    },
                    {
                        "username": "BREATHTAKER200",
                        "content": "Why??"
                    },
                    {
                        "username": "neil_paul",
                        "content": "\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "**Since I was walking outside the grid and by mistake I turned anti-clockwise now I am  in South Korea trying to figure out what went wrong**"
                    },
                    {
                        "username": "To-heeb",
                        "content": ",keep moving forward you will be in North Korea in a no time"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "This should have been marked as \\'Hard\\'"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Once you\\'ve done Spiral Matrix I this one isn\\'t particularly challenging. Just keep an eye on how many steps you take when going right, down, left, and up, and how those steps increase at a regular interval on each cycle."
                    },
                    {
                        "username": "sav20011962",
                        "content": "Hello, I can not understand - in the previous tasks of this series:\\n54.Spiral Matrix\\n59. Spiral Matrix II\\nthe matrix was bypassed in a twisting spiral, the bypass rules were obvious and unambiguous, but here the rules have changed and the principle of changing the direction of movement is generally incomprehensible. For example, in \"Example 1\" why suddenly after \"2\" do not continue to move to the right, why change direction to \"down\". Similarly, in \"Example 2\" after \"3\" - why does the direction change to \"left\" while the direction \"down\" is free?"
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@sav20011962](/sav20011962) it is mentioned that you are facing east, so it essentially means that the movement is left to right initially"
                    },
                    {
                        "username": "sav20011962",
                        "content": "[@2uringTested](/2uringTested) \\nnowhere is it indicated that the initial movement is \"left-to-right\", just \"clockwise\", then if the movement is \"top-down\" first, this matrix will turn out:\\n30 25 16 05 06 07\\n29 24 15 04 01 08\\n28 23 14 03 02 09\\n27 22 13 12 11 10\\n26 21 20 19 18 17"
                    },
                    {
                        "username": "2uringTested",
                        "content": "where ever you are starting the spiral in this problem, consider it to be the end point of the spiral traversal we were doing in previous such problems like spiral matrix I and spiral Matrix II, if the (rStart,cStart) were exactly at the middle of the matrix then we wouldn't be going out of the matrix at all, but since it is not exactly at the middle, it means its the spiral end to a even bigger matrix, of which, only a part of it is given to us.\n\nYou can also actually calculate the actual dimensions of the matrix this starting point would've been a spiral end to. and make a 2d matrix of that size, traverse it normally and push every coordinate which would be within this given rows and cols and ignore the ones which wouldnt be there in it and then reverse that order."
                    },
                    {
                        "username": "pulkit31997",
                        "content": "Examining the lengths of our walk in each direction, we find the following pattern: 1, 1, 2, 2, 3, 3, 4, 4, ...\\nshould be mentioned in description"
                    },
                    {
                        "username": "gaurav707026",
                        "content": "I am here after solving two similar problems i.e. matrix I and matrix II and thought this will be the similar problem, but travelling outside the matrix made me out of track."
                    }
                ]
            },
            {
                "id": 2020544,
                "content": [
                    {
                        "username": "wise",
                        "content": "Whenever we would move outside the boundary of the grid, we continue our walk outside the grid (but may return to the grid boundary later.) \\n\\nwhat the heck is this?"
                    },
                    {
                        "username": "yinlosky",
                        "content": "It means you keeps walking even if you are outside of the grid, but because you are walking clockwise, eventually you will return back to the grid, and you will start saving the cell that is in the gird into your result. If the cell is outside of the grid, you do not save the cell. \\nTake out a piece of paper, and draw a grid, and start at any cell and walk clockwise and you will understand. "
                    },
                    {
                        "username": "2uringTested",
                        "content": "where ever you are starting the spiral in this problem, consider it to be the end point of the spiral traversal we were doing in previous such problems like spiral matrix I and spiral Matrix II, if the (rStart,cStart) were exactly at the middle of the matrix then we wouldn\\'t be going out of the matrix at all, but since it is not exactly at the middle, it means its the spiral end to a even bigger matrix, of which, only a part of it is given to us.\\n\\nYou can also actually calculate the actual dimensions of the matrix this starting point would\\'ve been a spiral end to. and make a 2d matrix of that size, traverse it normally and push every coordinate which would be within this given rows and cols and ignore the ones which wouldnt be there in it and then reverse that order.\\n\\n"
                    },
                    {
                        "username": "bharat_gupta",
                        "content": "I can feel a spiral moving inside my head forcing me to break my pc."
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "\\uD83D\\uDE02"
                    },
                    {
                        "username": "papaggalos",
                        "content": "Exquisite problem, I\\'m on the brink of forgetting how LOOPS work!"
                    },
                    {
                        "username": "BREATHTAKER200",
                        "content": "Why??"
                    },
                    {
                        "username": "neil_paul",
                        "content": "\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "**Since I was walking outside the grid and by mistake I turned anti-clockwise now I am  in South Korea trying to figure out what went wrong**"
                    },
                    {
                        "username": "To-heeb",
                        "content": ",keep moving forward you will be in North Korea in a no time"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "This should have been marked as \\'Hard\\'"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Once you\\'ve done Spiral Matrix I this one isn\\'t particularly challenging. Just keep an eye on how many steps you take when going right, down, left, and up, and how those steps increase at a regular interval on each cycle."
                    },
                    {
                        "username": "sav20011962",
                        "content": "Hello, I can not understand - in the previous tasks of this series:\\n54.Spiral Matrix\\n59. Spiral Matrix II\\nthe matrix was bypassed in a twisting spiral, the bypass rules were obvious and unambiguous, but here the rules have changed and the principle of changing the direction of movement is generally incomprehensible. For example, in \"Example 1\" why suddenly after \"2\" do not continue to move to the right, why change direction to \"down\". Similarly, in \"Example 2\" after \"3\" - why does the direction change to \"left\" while the direction \"down\" is free?"
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@sav20011962](/sav20011962) it is mentioned that you are facing east, so it essentially means that the movement is left to right initially"
                    },
                    {
                        "username": "sav20011962",
                        "content": "[@2uringTested](/2uringTested) \\nnowhere is it indicated that the initial movement is \"left-to-right\", just \"clockwise\", then if the movement is \"top-down\" first, this matrix will turn out:\\n30 25 16 05 06 07\\n29 24 15 04 01 08\\n28 23 14 03 02 09\\n27 22 13 12 11 10\\n26 21 20 19 18 17"
                    },
                    {
                        "username": "2uringTested",
                        "content": "where ever you are starting the spiral in this problem, consider it to be the end point of the spiral traversal we were doing in previous such problems like spiral matrix I and spiral Matrix II, if the (rStart,cStart) were exactly at the middle of the matrix then we wouldn't be going out of the matrix at all, but since it is not exactly at the middle, it means its the spiral end to a even bigger matrix, of which, only a part of it is given to us.\n\nYou can also actually calculate the actual dimensions of the matrix this starting point would've been a spiral end to. and make a 2d matrix of that size, traverse it normally and push every coordinate which would be within this given rows and cols and ignore the ones which wouldnt be there in it and then reverse that order."
                    },
                    {
                        "username": "pulkit31997",
                        "content": "Examining the lengths of our walk in each direction, we find the following pattern: 1, 1, 2, 2, 3, 3, 4, 4, ...\\nshould be mentioned in description"
                    },
                    {
                        "username": "gaurav707026",
                        "content": "I am here after solving two similar problems i.e. matrix I and matrix II and thought this will be the similar problem, but travelling outside the matrix made me out of track."
                    }
                ]
            },
            {
                "id": 1565679,
                "content": [
                    {
                        "username": "wise",
                        "content": "Whenever we would move outside the boundary of the grid, we continue our walk outside the grid (but may return to the grid boundary later.) \\n\\nwhat the heck is this?"
                    },
                    {
                        "username": "yinlosky",
                        "content": "It means you keeps walking even if you are outside of the grid, but because you are walking clockwise, eventually you will return back to the grid, and you will start saving the cell that is in the gird into your result. If the cell is outside of the grid, you do not save the cell. \\nTake out a piece of paper, and draw a grid, and start at any cell and walk clockwise and you will understand. "
                    },
                    {
                        "username": "2uringTested",
                        "content": "where ever you are starting the spiral in this problem, consider it to be the end point of the spiral traversal we were doing in previous such problems like spiral matrix I and spiral Matrix II, if the (rStart,cStart) were exactly at the middle of the matrix then we wouldn\\'t be going out of the matrix at all, but since it is not exactly at the middle, it means its the spiral end to a even bigger matrix, of which, only a part of it is given to us.\\n\\nYou can also actually calculate the actual dimensions of the matrix this starting point would\\'ve been a spiral end to. and make a 2d matrix of that size, traverse it normally and push every coordinate which would be within this given rows and cols and ignore the ones which wouldnt be there in it and then reverse that order.\\n\\n"
                    },
                    {
                        "username": "bharat_gupta",
                        "content": "I can feel a spiral moving inside my head forcing me to break my pc."
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "\\uD83D\\uDE02"
                    },
                    {
                        "username": "papaggalos",
                        "content": "Exquisite problem, I\\'m on the brink of forgetting how LOOPS work!"
                    },
                    {
                        "username": "BREATHTAKER200",
                        "content": "Why??"
                    },
                    {
                        "username": "neil_paul",
                        "content": "\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "**Since I was walking outside the grid and by mistake I turned anti-clockwise now I am  in South Korea trying to figure out what went wrong**"
                    },
                    {
                        "username": "To-heeb",
                        "content": ",keep moving forward you will be in North Korea in a no time"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "This should have been marked as \\'Hard\\'"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Once you\\'ve done Spiral Matrix I this one isn\\'t particularly challenging. Just keep an eye on how many steps you take when going right, down, left, and up, and how those steps increase at a regular interval on each cycle."
                    },
                    {
                        "username": "sav20011962",
                        "content": "Hello, I can not understand - in the previous tasks of this series:\\n54.Spiral Matrix\\n59. Spiral Matrix II\\nthe matrix was bypassed in a twisting spiral, the bypass rules were obvious and unambiguous, but here the rules have changed and the principle of changing the direction of movement is generally incomprehensible. For example, in \"Example 1\" why suddenly after \"2\" do not continue to move to the right, why change direction to \"down\". Similarly, in \"Example 2\" after \"3\" - why does the direction change to \"left\" while the direction \"down\" is free?"
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@sav20011962](/sav20011962) it is mentioned that you are facing east, so it essentially means that the movement is left to right initially"
                    },
                    {
                        "username": "sav20011962",
                        "content": "[@2uringTested](/2uringTested) \\nnowhere is it indicated that the initial movement is \"left-to-right\", just \"clockwise\", then if the movement is \"top-down\" first, this matrix will turn out:\\n30 25 16 05 06 07\\n29 24 15 04 01 08\\n28 23 14 03 02 09\\n27 22 13 12 11 10\\n26 21 20 19 18 17"
                    },
                    {
                        "username": "2uringTested",
                        "content": "where ever you are starting the spiral in this problem, consider it to be the end point of the spiral traversal we were doing in previous such problems like spiral matrix I and spiral Matrix II, if the (rStart,cStart) were exactly at the middle of the matrix then we wouldn't be going out of the matrix at all, but since it is not exactly at the middle, it means its the spiral end to a even bigger matrix, of which, only a part of it is given to us.\n\nYou can also actually calculate the actual dimensions of the matrix this starting point would've been a spiral end to. and make a 2d matrix of that size, traverse it normally and push every coordinate which would be within this given rows and cols and ignore the ones which wouldnt be there in it and then reverse that order."
                    },
                    {
                        "username": "pulkit31997",
                        "content": "Examining the lengths of our walk in each direction, we find the following pattern: 1, 1, 2, 2, 3, 3, 4, 4, ...\\nshould be mentioned in description"
                    },
                    {
                        "username": "gaurav707026",
                        "content": "I am here after solving two similar problems i.e. matrix I and matrix II and thought this will be the similar problem, but travelling outside the matrix made me out of track."
                    }
                ]
            },
            {
                "id": 1899832,
                "content": [
                    {
                        "username": "wise",
                        "content": "Whenever we would move outside the boundary of the grid, we continue our walk outside the grid (but may return to the grid boundary later.) \\n\\nwhat the heck is this?"
                    },
                    {
                        "username": "yinlosky",
                        "content": "It means you keeps walking even if you are outside of the grid, but because you are walking clockwise, eventually you will return back to the grid, and you will start saving the cell that is in the gird into your result. If the cell is outside of the grid, you do not save the cell. \\nTake out a piece of paper, and draw a grid, and start at any cell and walk clockwise and you will understand. "
                    },
                    {
                        "username": "2uringTested",
                        "content": "where ever you are starting the spiral in this problem, consider it to be the end point of the spiral traversal we were doing in previous such problems like spiral matrix I and spiral Matrix II, if the (rStart,cStart) were exactly at the middle of the matrix then we wouldn\\'t be going out of the matrix at all, but since it is not exactly at the middle, it means its the spiral end to a even bigger matrix, of which, only a part of it is given to us.\\n\\nYou can also actually calculate the actual dimensions of the matrix this starting point would\\'ve been a spiral end to. and make a 2d matrix of that size, traverse it normally and push every coordinate which would be within this given rows and cols and ignore the ones which wouldnt be there in it and then reverse that order.\\n\\n"
                    },
                    {
                        "username": "bharat_gupta",
                        "content": "I can feel a spiral moving inside my head forcing me to break my pc."
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "\\uD83D\\uDE02"
                    },
                    {
                        "username": "papaggalos",
                        "content": "Exquisite problem, I\\'m on the brink of forgetting how LOOPS work!"
                    },
                    {
                        "username": "BREATHTAKER200",
                        "content": "Why??"
                    },
                    {
                        "username": "neil_paul",
                        "content": "\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "**Since I was walking outside the grid and by mistake I turned anti-clockwise now I am  in South Korea trying to figure out what went wrong**"
                    },
                    {
                        "username": "To-heeb",
                        "content": ",keep moving forward you will be in North Korea in a no time"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "This should have been marked as \\'Hard\\'"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Once you\\'ve done Spiral Matrix I this one isn\\'t particularly challenging. Just keep an eye on how many steps you take when going right, down, left, and up, and how those steps increase at a regular interval on each cycle."
                    },
                    {
                        "username": "sav20011962",
                        "content": "Hello, I can not understand - in the previous tasks of this series:\\n54.Spiral Matrix\\n59. Spiral Matrix II\\nthe matrix was bypassed in a twisting spiral, the bypass rules were obvious and unambiguous, but here the rules have changed and the principle of changing the direction of movement is generally incomprehensible. For example, in \"Example 1\" why suddenly after \"2\" do not continue to move to the right, why change direction to \"down\". Similarly, in \"Example 2\" after \"3\" - why does the direction change to \"left\" while the direction \"down\" is free?"
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@sav20011962](/sav20011962) it is mentioned that you are facing east, so it essentially means that the movement is left to right initially"
                    },
                    {
                        "username": "sav20011962",
                        "content": "[@2uringTested](/2uringTested) \\nnowhere is it indicated that the initial movement is \"left-to-right\", just \"clockwise\", then if the movement is \"top-down\" first, this matrix will turn out:\\n30 25 16 05 06 07\\n29 24 15 04 01 08\\n28 23 14 03 02 09\\n27 22 13 12 11 10\\n26 21 20 19 18 17"
                    },
                    {
                        "username": "2uringTested",
                        "content": "where ever you are starting the spiral in this problem, consider it to be the end point of the spiral traversal we were doing in previous such problems like spiral matrix I and spiral Matrix II, if the (rStart,cStart) were exactly at the middle of the matrix then we wouldn't be going out of the matrix at all, but since it is not exactly at the middle, it means its the spiral end to a even bigger matrix, of which, only a part of it is given to us.\n\nYou can also actually calculate the actual dimensions of the matrix this starting point would've been a spiral end to. and make a 2d matrix of that size, traverse it normally and push every coordinate which would be within this given rows and cols and ignore the ones which wouldnt be there in it and then reverse that order."
                    },
                    {
                        "username": "pulkit31997",
                        "content": "Examining the lengths of our walk in each direction, we find the following pattern: 1, 1, 2, 2, 3, 3, 4, 4, ...\\nshould be mentioned in description"
                    },
                    {
                        "username": "gaurav707026",
                        "content": "I am here after solving two similar problems i.e. matrix I and matrix II and thought this will be the similar problem, but travelling outside the matrix made me out of track."
                    }
                ]
            },
            {
                "id": 1804177,
                "content": [
                    {
                        "username": "wise",
                        "content": "Whenever we would move outside the boundary of the grid, we continue our walk outside the grid (but may return to the grid boundary later.) \\n\\nwhat the heck is this?"
                    },
                    {
                        "username": "yinlosky",
                        "content": "It means you keeps walking even if you are outside of the grid, but because you are walking clockwise, eventually you will return back to the grid, and you will start saving the cell that is in the gird into your result. If the cell is outside of the grid, you do not save the cell. \\nTake out a piece of paper, and draw a grid, and start at any cell and walk clockwise and you will understand. "
                    },
                    {
                        "username": "2uringTested",
                        "content": "where ever you are starting the spiral in this problem, consider it to be the end point of the spiral traversal we were doing in previous such problems like spiral matrix I and spiral Matrix II, if the (rStart,cStart) were exactly at the middle of the matrix then we wouldn\\'t be going out of the matrix at all, but since it is not exactly at the middle, it means its the spiral end to a even bigger matrix, of which, only a part of it is given to us.\\n\\nYou can also actually calculate the actual dimensions of the matrix this starting point would\\'ve been a spiral end to. and make a 2d matrix of that size, traverse it normally and push every coordinate which would be within this given rows and cols and ignore the ones which wouldnt be there in it and then reverse that order.\\n\\n"
                    },
                    {
                        "username": "bharat_gupta",
                        "content": "I can feel a spiral moving inside my head forcing me to break my pc."
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "\\uD83D\\uDE02"
                    },
                    {
                        "username": "papaggalos",
                        "content": "Exquisite problem, I\\'m on the brink of forgetting how LOOPS work!"
                    },
                    {
                        "username": "BREATHTAKER200",
                        "content": "Why??"
                    },
                    {
                        "username": "neil_paul",
                        "content": "\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "**Since I was walking outside the grid and by mistake I turned anti-clockwise now I am  in South Korea trying to figure out what went wrong**"
                    },
                    {
                        "username": "To-heeb",
                        "content": ",keep moving forward you will be in North Korea in a no time"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "This should have been marked as \\'Hard\\'"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Once you\\'ve done Spiral Matrix I this one isn\\'t particularly challenging. Just keep an eye on how many steps you take when going right, down, left, and up, and how those steps increase at a regular interval on each cycle."
                    },
                    {
                        "username": "sav20011962",
                        "content": "Hello, I can not understand - in the previous tasks of this series:\\n54.Spiral Matrix\\n59. Spiral Matrix II\\nthe matrix was bypassed in a twisting spiral, the bypass rules were obvious and unambiguous, but here the rules have changed and the principle of changing the direction of movement is generally incomprehensible. For example, in \"Example 1\" why suddenly after \"2\" do not continue to move to the right, why change direction to \"down\". Similarly, in \"Example 2\" after \"3\" - why does the direction change to \"left\" while the direction \"down\" is free?"
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@sav20011962](/sav20011962) it is mentioned that you are facing east, so it essentially means that the movement is left to right initially"
                    },
                    {
                        "username": "sav20011962",
                        "content": "[@2uringTested](/2uringTested) \\nnowhere is it indicated that the initial movement is \"left-to-right\", just \"clockwise\", then if the movement is \"top-down\" first, this matrix will turn out:\\n30 25 16 05 06 07\\n29 24 15 04 01 08\\n28 23 14 03 02 09\\n27 22 13 12 11 10\\n26 21 20 19 18 17"
                    },
                    {
                        "username": "2uringTested",
                        "content": "where ever you are starting the spiral in this problem, consider it to be the end point of the spiral traversal we were doing in previous such problems like spiral matrix I and spiral Matrix II, if the (rStart,cStart) were exactly at the middle of the matrix then we wouldn't be going out of the matrix at all, but since it is not exactly at the middle, it means its the spiral end to a even bigger matrix, of which, only a part of it is given to us.\n\nYou can also actually calculate the actual dimensions of the matrix this starting point would've been a spiral end to. and make a 2d matrix of that size, traverse it normally and push every coordinate which would be within this given rows and cols and ignore the ones which wouldnt be there in it and then reverse that order."
                    },
                    {
                        "username": "pulkit31997",
                        "content": "Examining the lengths of our walk in each direction, we find the following pattern: 1, 1, 2, 2, 3, 3, 4, 4, ...\\nshould be mentioned in description"
                    },
                    {
                        "username": "gaurav707026",
                        "content": "I am here after solving two similar problems i.e. matrix I and matrix II and thought this will be the similar problem, but travelling outside the matrix made me out of track."
                    }
                ]
            },
            {
                "id": 1782042,
                "content": [
                    {
                        "username": "wise",
                        "content": "Whenever we would move outside the boundary of the grid, we continue our walk outside the grid (but may return to the grid boundary later.) \\n\\nwhat the heck is this?"
                    },
                    {
                        "username": "yinlosky",
                        "content": "It means you keeps walking even if you are outside of the grid, but because you are walking clockwise, eventually you will return back to the grid, and you will start saving the cell that is in the gird into your result. If the cell is outside of the grid, you do not save the cell. \\nTake out a piece of paper, and draw a grid, and start at any cell and walk clockwise and you will understand. "
                    },
                    {
                        "username": "2uringTested",
                        "content": "where ever you are starting the spiral in this problem, consider it to be the end point of the spiral traversal we were doing in previous such problems like spiral matrix I and spiral Matrix II, if the (rStart,cStart) were exactly at the middle of the matrix then we wouldn\\'t be going out of the matrix at all, but since it is not exactly at the middle, it means its the spiral end to a even bigger matrix, of which, only a part of it is given to us.\\n\\nYou can also actually calculate the actual dimensions of the matrix this starting point would\\'ve been a spiral end to. and make a 2d matrix of that size, traverse it normally and push every coordinate which would be within this given rows and cols and ignore the ones which wouldnt be there in it and then reverse that order.\\n\\n"
                    },
                    {
                        "username": "bharat_gupta",
                        "content": "I can feel a spiral moving inside my head forcing me to break my pc."
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "\\uD83D\\uDE02"
                    },
                    {
                        "username": "papaggalos",
                        "content": "Exquisite problem, I\\'m on the brink of forgetting how LOOPS work!"
                    },
                    {
                        "username": "BREATHTAKER200",
                        "content": "Why??"
                    },
                    {
                        "username": "neil_paul",
                        "content": "\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "**Since I was walking outside the grid and by mistake I turned anti-clockwise now I am  in South Korea trying to figure out what went wrong**"
                    },
                    {
                        "username": "To-heeb",
                        "content": ",keep moving forward you will be in North Korea in a no time"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "This should have been marked as \\'Hard\\'"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Once you\\'ve done Spiral Matrix I this one isn\\'t particularly challenging. Just keep an eye on how many steps you take when going right, down, left, and up, and how those steps increase at a regular interval on each cycle."
                    },
                    {
                        "username": "sav20011962",
                        "content": "Hello, I can not understand - in the previous tasks of this series:\\n54.Spiral Matrix\\n59. Spiral Matrix II\\nthe matrix was bypassed in a twisting spiral, the bypass rules were obvious and unambiguous, but here the rules have changed and the principle of changing the direction of movement is generally incomprehensible. For example, in \"Example 1\" why suddenly after \"2\" do not continue to move to the right, why change direction to \"down\". Similarly, in \"Example 2\" after \"3\" - why does the direction change to \"left\" while the direction \"down\" is free?"
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@sav20011962](/sav20011962) it is mentioned that you are facing east, so it essentially means that the movement is left to right initially"
                    },
                    {
                        "username": "sav20011962",
                        "content": "[@2uringTested](/2uringTested) \\nnowhere is it indicated that the initial movement is \"left-to-right\", just \"clockwise\", then if the movement is \"top-down\" first, this matrix will turn out:\\n30 25 16 05 06 07\\n29 24 15 04 01 08\\n28 23 14 03 02 09\\n27 22 13 12 11 10\\n26 21 20 19 18 17"
                    },
                    {
                        "username": "2uringTested",
                        "content": "where ever you are starting the spiral in this problem, consider it to be the end point of the spiral traversal we were doing in previous such problems like spiral matrix I and spiral Matrix II, if the (rStart,cStart) were exactly at the middle of the matrix then we wouldn't be going out of the matrix at all, but since it is not exactly at the middle, it means its the spiral end to a even bigger matrix, of which, only a part of it is given to us.\n\nYou can also actually calculate the actual dimensions of the matrix this starting point would've been a spiral end to. and make a 2d matrix of that size, traverse it normally and push every coordinate which would be within this given rows and cols and ignore the ones which wouldnt be there in it and then reverse that order."
                    },
                    {
                        "username": "pulkit31997",
                        "content": "Examining the lengths of our walk in each direction, we find the following pattern: 1, 1, 2, 2, 3, 3, 4, 4, ...\\nshould be mentioned in description"
                    },
                    {
                        "username": "gaurav707026",
                        "content": "I am here after solving two similar problems i.e. matrix I and matrix II and thought this will be the similar problem, but travelling outside the matrix made me out of track."
                    }
                ]
            },
            {
                "id": 1965068,
                "content": [
                    {
                        "username": "wise",
                        "content": "Whenever we would move outside the boundary of the grid, we continue our walk outside the grid (but may return to the grid boundary later.) \\n\\nwhat the heck is this?"
                    },
                    {
                        "username": "yinlosky",
                        "content": "It means you keeps walking even if you are outside of the grid, but because you are walking clockwise, eventually you will return back to the grid, and you will start saving the cell that is in the gird into your result. If the cell is outside of the grid, you do not save the cell. \\nTake out a piece of paper, and draw a grid, and start at any cell and walk clockwise and you will understand. "
                    },
                    {
                        "username": "2uringTested",
                        "content": "where ever you are starting the spiral in this problem, consider it to be the end point of the spiral traversal we were doing in previous such problems like spiral matrix I and spiral Matrix II, if the (rStart,cStart) were exactly at the middle of the matrix then we wouldn\\'t be going out of the matrix at all, but since it is not exactly at the middle, it means its the spiral end to a even bigger matrix, of which, only a part of it is given to us.\\n\\nYou can also actually calculate the actual dimensions of the matrix this starting point would\\'ve been a spiral end to. and make a 2d matrix of that size, traverse it normally and push every coordinate which would be within this given rows and cols and ignore the ones which wouldnt be there in it and then reverse that order.\\n\\n"
                    },
                    {
                        "username": "bharat_gupta",
                        "content": "I can feel a spiral moving inside my head forcing me to break my pc."
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "\\uD83D\\uDE02"
                    },
                    {
                        "username": "papaggalos",
                        "content": "Exquisite problem, I\\'m on the brink of forgetting how LOOPS work!"
                    },
                    {
                        "username": "BREATHTAKER200",
                        "content": "Why??"
                    },
                    {
                        "username": "neil_paul",
                        "content": "\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "**Since I was walking outside the grid and by mistake I turned anti-clockwise now I am  in South Korea trying to figure out what went wrong**"
                    },
                    {
                        "username": "To-heeb",
                        "content": ",keep moving forward you will be in North Korea in a no time"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "This should have been marked as \\'Hard\\'"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Once you\\'ve done Spiral Matrix I this one isn\\'t particularly challenging. Just keep an eye on how many steps you take when going right, down, left, and up, and how those steps increase at a regular interval on each cycle."
                    },
                    {
                        "username": "sav20011962",
                        "content": "Hello, I can not understand - in the previous tasks of this series:\\n54.Spiral Matrix\\n59. Spiral Matrix II\\nthe matrix was bypassed in a twisting spiral, the bypass rules were obvious and unambiguous, but here the rules have changed and the principle of changing the direction of movement is generally incomprehensible. For example, in \"Example 1\" why suddenly after \"2\" do not continue to move to the right, why change direction to \"down\". Similarly, in \"Example 2\" after \"3\" - why does the direction change to \"left\" while the direction \"down\" is free?"
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@sav20011962](/sav20011962) it is mentioned that you are facing east, so it essentially means that the movement is left to right initially"
                    },
                    {
                        "username": "sav20011962",
                        "content": "[@2uringTested](/2uringTested) \\nnowhere is it indicated that the initial movement is \"left-to-right\", just \"clockwise\", then if the movement is \"top-down\" first, this matrix will turn out:\\n30 25 16 05 06 07\\n29 24 15 04 01 08\\n28 23 14 03 02 09\\n27 22 13 12 11 10\\n26 21 20 19 18 17"
                    },
                    {
                        "username": "2uringTested",
                        "content": "where ever you are starting the spiral in this problem, consider it to be the end point of the spiral traversal we were doing in previous such problems like spiral matrix I and spiral Matrix II, if the (rStart,cStart) were exactly at the middle of the matrix then we wouldn't be going out of the matrix at all, but since it is not exactly at the middle, it means its the spiral end to a even bigger matrix, of which, only a part of it is given to us.\n\nYou can also actually calculate the actual dimensions of the matrix this starting point would've been a spiral end to. and make a 2d matrix of that size, traverse it normally and push every coordinate which would be within this given rows and cols and ignore the ones which wouldnt be there in it and then reverse that order."
                    },
                    {
                        "username": "pulkit31997",
                        "content": "Examining the lengths of our walk in each direction, we find the following pattern: 1, 1, 2, 2, 3, 3, 4, 4, ...\\nshould be mentioned in description"
                    },
                    {
                        "username": "gaurav707026",
                        "content": "I am here after solving two similar problems i.e. matrix I and matrix II and thought this will be the similar problem, but travelling outside the matrix made me out of track."
                    }
                ]
            },
            {
                "id": 2037855,
                "content": [
                    {
                        "username": "wise",
                        "content": "Whenever we would move outside the boundary of the grid, we continue our walk outside the grid (but may return to the grid boundary later.) \\n\\nwhat the heck is this?"
                    },
                    {
                        "username": "yinlosky",
                        "content": "It means you keeps walking even if you are outside of the grid, but because you are walking clockwise, eventually you will return back to the grid, and you will start saving the cell that is in the gird into your result. If the cell is outside of the grid, you do not save the cell. \\nTake out a piece of paper, and draw a grid, and start at any cell and walk clockwise and you will understand. "
                    },
                    {
                        "username": "2uringTested",
                        "content": "where ever you are starting the spiral in this problem, consider it to be the end point of the spiral traversal we were doing in previous such problems like spiral matrix I and spiral Matrix II, if the (rStart,cStart) were exactly at the middle of the matrix then we wouldn\\'t be going out of the matrix at all, but since it is not exactly at the middle, it means its the spiral end to a even bigger matrix, of which, only a part of it is given to us.\\n\\nYou can also actually calculate the actual dimensions of the matrix this starting point would\\'ve been a spiral end to. and make a 2d matrix of that size, traverse it normally and push every coordinate which would be within this given rows and cols and ignore the ones which wouldnt be there in it and then reverse that order.\\n\\n"
                    },
                    {
                        "username": "bharat_gupta",
                        "content": "I can feel a spiral moving inside my head forcing me to break my pc."
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "\\uD83D\\uDE02"
                    },
                    {
                        "username": "papaggalos",
                        "content": "Exquisite problem, I\\'m on the brink of forgetting how LOOPS work!"
                    },
                    {
                        "username": "BREATHTAKER200",
                        "content": "Why??"
                    },
                    {
                        "username": "neil_paul",
                        "content": "\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "**Since I was walking outside the grid and by mistake I turned anti-clockwise now I am  in South Korea trying to figure out what went wrong**"
                    },
                    {
                        "username": "To-heeb",
                        "content": ",keep moving forward you will be in North Korea in a no time"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "This should have been marked as \\'Hard\\'"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Once you\\'ve done Spiral Matrix I this one isn\\'t particularly challenging. Just keep an eye on how many steps you take when going right, down, left, and up, and how those steps increase at a regular interval on each cycle."
                    },
                    {
                        "username": "sav20011962",
                        "content": "Hello, I can not understand - in the previous tasks of this series:\\n54.Spiral Matrix\\n59. Spiral Matrix II\\nthe matrix was bypassed in a twisting spiral, the bypass rules were obvious and unambiguous, but here the rules have changed and the principle of changing the direction of movement is generally incomprehensible. For example, in \"Example 1\" why suddenly after \"2\" do not continue to move to the right, why change direction to \"down\". Similarly, in \"Example 2\" after \"3\" - why does the direction change to \"left\" while the direction \"down\" is free?"
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@sav20011962](/sav20011962) it is mentioned that you are facing east, so it essentially means that the movement is left to right initially"
                    },
                    {
                        "username": "sav20011962",
                        "content": "[@2uringTested](/2uringTested) \\nnowhere is it indicated that the initial movement is \"left-to-right\", just \"clockwise\", then if the movement is \"top-down\" first, this matrix will turn out:\\n30 25 16 05 06 07\\n29 24 15 04 01 08\\n28 23 14 03 02 09\\n27 22 13 12 11 10\\n26 21 20 19 18 17"
                    },
                    {
                        "username": "2uringTested",
                        "content": "where ever you are starting the spiral in this problem, consider it to be the end point of the spiral traversal we were doing in previous such problems like spiral matrix I and spiral Matrix II, if the (rStart,cStart) were exactly at the middle of the matrix then we wouldn't be going out of the matrix at all, but since it is not exactly at the middle, it means its the spiral end to a even bigger matrix, of which, only a part of it is given to us.\n\nYou can also actually calculate the actual dimensions of the matrix this starting point would've been a spiral end to. and make a 2d matrix of that size, traverse it normally and push every coordinate which would be within this given rows and cols and ignore the ones which wouldnt be there in it and then reverse that order."
                    },
                    {
                        "username": "pulkit31997",
                        "content": "Examining the lengths of our walk in each direction, we find the following pattern: 1, 1, 2, 2, 3, 3, 4, 4, ...\\nshould be mentioned in description"
                    },
                    {
                        "username": "gaurav707026",
                        "content": "I am here after solving two similar problems i.e. matrix I and matrix II and thought this will be the similar problem, but travelling outside the matrix made me out of track."
                    }
                ]
            },
            {
                "id": 1970393,
                "content": [
                    {
                        "username": "wise",
                        "content": "Whenever we would move outside the boundary of the grid, we continue our walk outside the grid (but may return to the grid boundary later.) \\n\\nwhat the heck is this?"
                    },
                    {
                        "username": "yinlosky",
                        "content": "It means you keeps walking even if you are outside of the grid, but because you are walking clockwise, eventually you will return back to the grid, and you will start saving the cell that is in the gird into your result. If the cell is outside of the grid, you do not save the cell. \\nTake out a piece of paper, and draw a grid, and start at any cell and walk clockwise and you will understand. "
                    },
                    {
                        "username": "2uringTested",
                        "content": "where ever you are starting the spiral in this problem, consider it to be the end point of the spiral traversal we were doing in previous such problems like spiral matrix I and spiral Matrix II, if the (rStart,cStart) were exactly at the middle of the matrix then we wouldn\\'t be going out of the matrix at all, but since it is not exactly at the middle, it means its the spiral end to a even bigger matrix, of which, only a part of it is given to us.\\n\\nYou can also actually calculate the actual dimensions of the matrix this starting point would\\'ve been a spiral end to. and make a 2d matrix of that size, traverse it normally and push every coordinate which would be within this given rows and cols and ignore the ones which wouldnt be there in it and then reverse that order.\\n\\n"
                    },
                    {
                        "username": "bharat_gupta",
                        "content": "I can feel a spiral moving inside my head forcing me to break my pc."
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "\\uD83D\\uDE02"
                    },
                    {
                        "username": "papaggalos",
                        "content": "Exquisite problem, I\\'m on the brink of forgetting how LOOPS work!"
                    },
                    {
                        "username": "BREATHTAKER200",
                        "content": "Why??"
                    },
                    {
                        "username": "neil_paul",
                        "content": "\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "**Since I was walking outside the grid and by mistake I turned anti-clockwise now I am  in South Korea trying to figure out what went wrong**"
                    },
                    {
                        "username": "To-heeb",
                        "content": ",keep moving forward you will be in North Korea in a no time"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "This should have been marked as \\'Hard\\'"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Once you\\'ve done Spiral Matrix I this one isn\\'t particularly challenging. Just keep an eye on how many steps you take when going right, down, left, and up, and how those steps increase at a regular interval on each cycle."
                    },
                    {
                        "username": "sav20011962",
                        "content": "Hello, I can not understand - in the previous tasks of this series:\\n54.Spiral Matrix\\n59. Spiral Matrix II\\nthe matrix was bypassed in a twisting spiral, the bypass rules were obvious and unambiguous, but here the rules have changed and the principle of changing the direction of movement is generally incomprehensible. For example, in \"Example 1\" why suddenly after \"2\" do not continue to move to the right, why change direction to \"down\". Similarly, in \"Example 2\" after \"3\" - why does the direction change to \"left\" while the direction \"down\" is free?"
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@sav20011962](/sav20011962) it is mentioned that you are facing east, so it essentially means that the movement is left to right initially"
                    },
                    {
                        "username": "sav20011962",
                        "content": "[@2uringTested](/2uringTested) \\nnowhere is it indicated that the initial movement is \"left-to-right\", just \"clockwise\", then if the movement is \"top-down\" first, this matrix will turn out:\\n30 25 16 05 06 07\\n29 24 15 04 01 08\\n28 23 14 03 02 09\\n27 22 13 12 11 10\\n26 21 20 19 18 17"
                    },
                    {
                        "username": "2uringTested",
                        "content": "where ever you are starting the spiral in this problem, consider it to be the end point of the spiral traversal we were doing in previous such problems like spiral matrix I and spiral Matrix II, if the (rStart,cStart) were exactly at the middle of the matrix then we wouldn't be going out of the matrix at all, but since it is not exactly at the middle, it means its the spiral end to a even bigger matrix, of which, only a part of it is given to us.\n\nYou can also actually calculate the actual dimensions of the matrix this starting point would've been a spiral end to. and make a 2d matrix of that size, traverse it normally and push every coordinate which would be within this given rows and cols and ignore the ones which wouldnt be there in it and then reverse that order."
                    },
                    {
                        "username": "pulkit31997",
                        "content": "Examining the lengths of our walk in each direction, we find the following pattern: 1, 1, 2, 2, 3, 3, 4, 4, ...\\nshould be mentioned in description"
                    },
                    {
                        "username": "gaurav707026",
                        "content": "I am here after solving two similar problems i.e. matrix I and matrix II and thought this will be the similar problem, but travelling outside the matrix made me out of track."
                    }
                ]
            },
            {
                "id": 1888980,
                "content": [
                    {
                        "username": "wise",
                        "content": "Whenever we would move outside the boundary of the grid, we continue our walk outside the grid (but may return to the grid boundary later.) \\n\\nwhat the heck is this?"
                    },
                    {
                        "username": "yinlosky",
                        "content": "It means you keeps walking even if you are outside of the grid, but because you are walking clockwise, eventually you will return back to the grid, and you will start saving the cell that is in the gird into your result. If the cell is outside of the grid, you do not save the cell. \\nTake out a piece of paper, and draw a grid, and start at any cell and walk clockwise and you will understand. "
                    },
                    {
                        "username": "2uringTested",
                        "content": "where ever you are starting the spiral in this problem, consider it to be the end point of the spiral traversal we were doing in previous such problems like spiral matrix I and spiral Matrix II, if the (rStart,cStart) were exactly at the middle of the matrix then we wouldn\\'t be going out of the matrix at all, but since it is not exactly at the middle, it means its the spiral end to a even bigger matrix, of which, only a part of it is given to us.\\n\\nYou can also actually calculate the actual dimensions of the matrix this starting point would\\'ve been a spiral end to. and make a 2d matrix of that size, traverse it normally and push every coordinate which would be within this given rows and cols and ignore the ones which wouldnt be there in it and then reverse that order.\\n\\n"
                    },
                    {
                        "username": "bharat_gupta",
                        "content": "I can feel a spiral moving inside my head forcing me to break my pc."
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "\\uD83D\\uDE02"
                    },
                    {
                        "username": "papaggalos",
                        "content": "Exquisite problem, I\\'m on the brink of forgetting how LOOPS work!"
                    },
                    {
                        "username": "BREATHTAKER200",
                        "content": "Why??"
                    },
                    {
                        "username": "neil_paul",
                        "content": "\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "**Since I was walking outside the grid and by mistake I turned anti-clockwise now I am  in South Korea trying to figure out what went wrong**"
                    },
                    {
                        "username": "To-heeb",
                        "content": ",keep moving forward you will be in North Korea in a no time"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "This should have been marked as \\'Hard\\'"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Once you\\'ve done Spiral Matrix I this one isn\\'t particularly challenging. Just keep an eye on how many steps you take when going right, down, left, and up, and how those steps increase at a regular interval on each cycle."
                    },
                    {
                        "username": "sav20011962",
                        "content": "Hello, I can not understand - in the previous tasks of this series:\\n54.Spiral Matrix\\n59. Spiral Matrix II\\nthe matrix was bypassed in a twisting spiral, the bypass rules were obvious and unambiguous, but here the rules have changed and the principle of changing the direction of movement is generally incomprehensible. For example, in \"Example 1\" why suddenly after \"2\" do not continue to move to the right, why change direction to \"down\". Similarly, in \"Example 2\" after \"3\" - why does the direction change to \"left\" while the direction \"down\" is free?"
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@sav20011962](/sav20011962) it is mentioned that you are facing east, so it essentially means that the movement is left to right initially"
                    },
                    {
                        "username": "sav20011962",
                        "content": "[@2uringTested](/2uringTested) \\nnowhere is it indicated that the initial movement is \"left-to-right\", just \"clockwise\", then if the movement is \"top-down\" first, this matrix will turn out:\\n30 25 16 05 06 07\\n29 24 15 04 01 08\\n28 23 14 03 02 09\\n27 22 13 12 11 10\\n26 21 20 19 18 17"
                    },
                    {
                        "username": "2uringTested",
                        "content": "where ever you are starting the spiral in this problem, consider it to be the end point of the spiral traversal we were doing in previous such problems like spiral matrix I and spiral Matrix II, if the (rStart,cStart) were exactly at the middle of the matrix then we wouldn't be going out of the matrix at all, but since it is not exactly at the middle, it means its the spiral end to a even bigger matrix, of which, only a part of it is given to us.\n\nYou can also actually calculate the actual dimensions of the matrix this starting point would've been a spiral end to. and make a 2d matrix of that size, traverse it normally and push every coordinate which would be within this given rows and cols and ignore the ones which wouldnt be there in it and then reverse that order."
                    },
                    {
                        "username": "pulkit31997",
                        "content": "Examining the lengths of our walk in each direction, we find the following pattern: 1, 1, 2, 2, 3, 3, 4, 4, ...\\nshould be mentioned in description"
                    },
                    {
                        "username": "gaurav707026",
                        "content": "I am here after solving two similar problems i.e. matrix I and matrix II and thought this will be the similar problem, but travelling outside the matrix made me out of track."
                    }
                ]
            },
            {
                "id": 2052023,
                "content": [
                    {
                        "username": "wise",
                        "content": "Whenever we would move outside the boundary of the grid, we continue our walk outside the grid (but may return to the grid boundary later.) \\n\\nwhat the heck is this?"
                    },
                    {
                        "username": "yinlosky",
                        "content": "It means you keeps walking even if you are outside of the grid, but because you are walking clockwise, eventually you will return back to the grid, and you will start saving the cell that is in the gird into your result. If the cell is outside of the grid, you do not save the cell. \\nTake out a piece of paper, and draw a grid, and start at any cell and walk clockwise and you will understand. "
                    },
                    {
                        "username": "2uringTested",
                        "content": "where ever you are starting the spiral in this problem, consider it to be the end point of the spiral traversal we were doing in previous such problems like spiral matrix I and spiral Matrix II, if the (rStart,cStart) were exactly at the middle of the matrix then we wouldn\\'t be going out of the matrix at all, but since it is not exactly at the middle, it means its the spiral end to a even bigger matrix, of which, only a part of it is given to us.\\n\\nYou can also actually calculate the actual dimensions of the matrix this starting point would\\'ve been a spiral end to. and make a 2d matrix of that size, traverse it normally and push every coordinate which would be within this given rows and cols and ignore the ones which wouldnt be there in it and then reverse that order.\\n\\n"
                    },
                    {
                        "username": "bharat_gupta",
                        "content": "I can feel a spiral moving inside my head forcing me to break my pc."
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "\\uD83D\\uDE02"
                    },
                    {
                        "username": "papaggalos",
                        "content": "Exquisite problem, I\\'m on the brink of forgetting how LOOPS work!"
                    },
                    {
                        "username": "BREATHTAKER200",
                        "content": "Why??"
                    },
                    {
                        "username": "neil_paul",
                        "content": "\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "**Since I was walking outside the grid and by mistake I turned anti-clockwise now I am  in South Korea trying to figure out what went wrong**"
                    },
                    {
                        "username": "To-heeb",
                        "content": ",keep moving forward you will be in North Korea in a no time"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "This should have been marked as \\'Hard\\'"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Once you\\'ve done Spiral Matrix I this one isn\\'t particularly challenging. Just keep an eye on how many steps you take when going right, down, left, and up, and how those steps increase at a regular interval on each cycle."
                    },
                    {
                        "username": "sav20011962",
                        "content": "Hello, I can not understand - in the previous tasks of this series:\\n54.Spiral Matrix\\n59. Spiral Matrix II\\nthe matrix was bypassed in a twisting spiral, the bypass rules were obvious and unambiguous, but here the rules have changed and the principle of changing the direction of movement is generally incomprehensible. For example, in \"Example 1\" why suddenly after \"2\" do not continue to move to the right, why change direction to \"down\". Similarly, in \"Example 2\" after \"3\" - why does the direction change to \"left\" while the direction \"down\" is free?"
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@sav20011962](/sav20011962) it is mentioned that you are facing east, so it essentially means that the movement is left to right initially"
                    },
                    {
                        "username": "sav20011962",
                        "content": "[@2uringTested](/2uringTested) \\nnowhere is it indicated that the initial movement is \"left-to-right\", just \"clockwise\", then if the movement is \"top-down\" first, this matrix will turn out:\\n30 25 16 05 06 07\\n29 24 15 04 01 08\\n28 23 14 03 02 09\\n27 22 13 12 11 10\\n26 21 20 19 18 17"
                    },
                    {
                        "username": "2uringTested",
                        "content": "where ever you are starting the spiral in this problem, consider it to be the end point of the spiral traversal we were doing in previous such problems like spiral matrix I and spiral Matrix II, if the (rStart,cStart) were exactly at the middle of the matrix then we wouldn't be going out of the matrix at all, but since it is not exactly at the middle, it means its the spiral end to a even bigger matrix, of which, only a part of it is given to us.\n\nYou can also actually calculate the actual dimensions of the matrix this starting point would've been a spiral end to. and make a 2d matrix of that size, traverse it normally and push every coordinate which would be within this given rows and cols and ignore the ones which wouldnt be there in it and then reverse that order."
                    },
                    {
                        "username": "pulkit31997",
                        "content": "Examining the lengths of our walk in each direction, we find the following pattern: 1, 1, 2, 2, 3, 3, 4, 4, ...\\nshould be mentioned in description"
                    },
                    {
                        "username": "gaurav707026",
                        "content": "I am here after solving two similar problems i.e. matrix I and matrix II and thought this will be the similar problem, but travelling outside the matrix made me out of track."
                    }
                ]
            },
            {
                "id": 2020544,
                "content": [
                    {
                        "username": "wise",
                        "content": "Whenever we would move outside the boundary of the grid, we continue our walk outside the grid (but may return to the grid boundary later.) \\n\\nwhat the heck is this?"
                    },
                    {
                        "username": "yinlosky",
                        "content": "It means you keeps walking even if you are outside of the grid, but because you are walking clockwise, eventually you will return back to the grid, and you will start saving the cell that is in the gird into your result. If the cell is outside of the grid, you do not save the cell. \\nTake out a piece of paper, and draw a grid, and start at any cell and walk clockwise and you will understand. "
                    },
                    {
                        "username": "2uringTested",
                        "content": "where ever you are starting the spiral in this problem, consider it to be the end point of the spiral traversal we were doing in previous such problems like spiral matrix I and spiral Matrix II, if the (rStart,cStart) were exactly at the middle of the matrix then we wouldn\\'t be going out of the matrix at all, but since it is not exactly at the middle, it means its the spiral end to a even bigger matrix, of which, only a part of it is given to us.\\n\\nYou can also actually calculate the actual dimensions of the matrix this starting point would\\'ve been a spiral end to. and make a 2d matrix of that size, traverse it normally and push every coordinate which would be within this given rows and cols and ignore the ones which wouldnt be there in it and then reverse that order.\\n\\n"
                    },
                    {
                        "username": "bharat_gupta",
                        "content": "I can feel a spiral moving inside my head forcing me to break my pc."
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "\\uD83D\\uDE02"
                    },
                    {
                        "username": "papaggalos",
                        "content": "Exquisite problem, I\\'m on the brink of forgetting how LOOPS work!"
                    },
                    {
                        "username": "BREATHTAKER200",
                        "content": "Why??"
                    },
                    {
                        "username": "neil_paul",
                        "content": "\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "**Since I was walking outside the grid and by mistake I turned anti-clockwise now I am  in South Korea trying to figure out what went wrong**"
                    },
                    {
                        "username": "To-heeb",
                        "content": ",keep moving forward you will be in North Korea in a no time"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "This should have been marked as \\'Hard\\'"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Once you\\'ve done Spiral Matrix I this one isn\\'t particularly challenging. Just keep an eye on how many steps you take when going right, down, left, and up, and how those steps increase at a regular interval on each cycle."
                    },
                    {
                        "username": "sav20011962",
                        "content": "Hello, I can not understand - in the previous tasks of this series:\\n54.Spiral Matrix\\n59. Spiral Matrix II\\nthe matrix was bypassed in a twisting spiral, the bypass rules were obvious and unambiguous, but here the rules have changed and the principle of changing the direction of movement is generally incomprehensible. For example, in \"Example 1\" why suddenly after \"2\" do not continue to move to the right, why change direction to \"down\". Similarly, in \"Example 2\" after \"3\" - why does the direction change to \"left\" while the direction \"down\" is free?"
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@sav20011962](/sav20011962) it is mentioned that you are facing east, so it essentially means that the movement is left to right initially"
                    },
                    {
                        "username": "sav20011962",
                        "content": "[@2uringTested](/2uringTested) \\nnowhere is it indicated that the initial movement is \"left-to-right\", just \"clockwise\", then if the movement is \"top-down\" first, this matrix will turn out:\\n30 25 16 05 06 07\\n29 24 15 04 01 08\\n28 23 14 03 02 09\\n27 22 13 12 11 10\\n26 21 20 19 18 17"
                    },
                    {
                        "username": "2uringTested",
                        "content": "where ever you are starting the spiral in this problem, consider it to be the end point of the spiral traversal we were doing in previous such problems like spiral matrix I and spiral Matrix II, if the (rStart,cStart) were exactly at the middle of the matrix then we wouldn't be going out of the matrix at all, but since it is not exactly at the middle, it means its the spiral end to a even bigger matrix, of which, only a part of it is given to us.\n\nYou can also actually calculate the actual dimensions of the matrix this starting point would've been a spiral end to. and make a 2d matrix of that size, traverse it normally and push every coordinate which would be within this given rows and cols and ignore the ones which wouldnt be there in it and then reverse that order."
                    },
                    {
                        "username": "pulkit31997",
                        "content": "Examining the lengths of our walk in each direction, we find the following pattern: 1, 1, 2, 2, 3, 3, 4, 4, ...\\nshould be mentioned in description"
                    },
                    {
                        "username": "gaurav707026",
                        "content": "I am here after solving two similar problems i.e. matrix I and matrix II and thought this will be the similar problem, but travelling outside the matrix made me out of track."
                    }
                ]
            }
        ]
    },
    {
        "title": "Number of Burgers with No Waste of Ingredients",
        "question_content": "<p>Given two integers <code>tomatoSlices</code> and <code>cheeseSlices</code>. The ingredients of different burgers are as follows:</p>\n\n<ul>\n\t<li><strong>Jumbo Burger:</strong> <code>4</code> tomato slices and <code>1</code> cheese slice.</li>\n\t<li><strong>Small Burger:</strong> <code>2</code> Tomato slices and <code>1</code> cheese slice.</li>\n</ul>\n\n<p>Return <code>[total_jumbo, total_small]</code> so that the number of remaining <code>tomatoSlices</code> equal to <code>0</code> and the number of remaining <code>cheeseSlices</code> equal to <code>0</code>. If it is not possible to make the remaining <code>tomatoSlices</code> and <code>cheeseSlices</code> equal to <code>0</code> return <code>[]</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> tomatoSlices = 16, cheeseSlices = 7\n<strong>Output:</strong> [1,6]\n<strong>Explantion:</strong> To make one jumbo burger and 6 small burgers we need 4*1 + 2*6 = 16 tomato and 1 + 6 = 7 cheese.\nThere will be no remaining ingredients.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> tomatoSlices = 17, cheeseSlices = 4\n<strong>Output:</strong> []\n<strong>Explantion:</strong> There will be no way to use all ingredients to make small and jumbo burgers.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> tomatoSlices = 4, cheeseSlices = 17\n<strong>Output:</strong> []\n<strong>Explantion:</strong> Making 1 jumbo burger there will be 16 cheese remaining and making 2 small burgers there will be 15 cheese remaining.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= tomatoSlices, cheeseSlices &lt;= 10<sup>7</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 441321,
                "title": "java-c-python-chickens-and-rabbits",
                "content": "# **Intuition**\\nClassic problem, https://w.wiki/D2S\\nSorry that I don\\'t know the name in English.\\nMaybe  Chickens and Rabbits problem\\n<br>\\n\\n# **Explanation**\\ntomate number `t` should not be odd,\\nand it should valid that `c * 2 <= t && t <= c * 4`.\\n\\nFrom\\n`jumbo + small = cheese`\\n`jumbo * 2 + small = tomate / 2`\\n\\nWe can get that\\n`jumb0 = tomate / 2 - cheese`\\nSo that\\n`small = cheese * 2 - tomate / 2`\\n<br>\\n\\n# **Complexity**\\nTime `O(1)`\\nSpace `O(1)`\\n<br>\\n\\n**Java:**\\n```java\\n    public List<Integer> numOfBurgers(int t, int c) {\\n        return t % 2 == 0 && c * 2 <= t && t <= c * 4 ? Arrays.asList(t / 2 - c, c * 2 - t / 2) :  new ArrayList();\\n    }\\n```\\n\\n**C++:**\\n```cpp\\n    vector<int> numOfBurgers(int t, int c) {\\n        if (t % 2 == 0 && c * 2 <= t && t <= c * 4)\\n            return {t / 2 - c, c * 2 - t / 2};\\n        return {};\\n    }\\n```\\n\\n**Python:**\\n```python\\n    def numOfBurgers(self, t, c):\\n        return [t / 2 - c, c * 2 - t / 2] if t % 2 == 0 and c * 2 <= t <= c * 4 else []\\n```\\n",
                "solutionTags": [],
                "code": "```java\\n    public List<Integer> numOfBurgers(int t, int c) {\\n        return t % 2 == 0 && c * 2 <= t && t <= c * 4 ? Arrays.asList(t / 2 - c, c * 2 - t / 2) :  new ArrayList();\\n    }\\n```\n```cpp\\n    vector<int> numOfBurgers(int t, int c) {\\n        if (t % 2 == 0 && c * 2 <= t && t <= c * 4)\\n            return {t / 2 - c, c * 2 - t / 2};\\n        return {};\\n    }\\n```\n```python\\n    def numOfBurgers(self, t, c):\\n        return [t / 2 - c, c * 2 - t / 2] if t % 2 == 0 and c * 2 <= t <= c * 4 else []\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 441342,
                "title": "java-python-3-solve-a-linear-equations-group-w-brief-explanation-and-analysis",
                "content": "According the description of the problem, we have the following:\\n```\\nJumbo Burger: 4 tomato slices and 1 cheese slice.\\nSmall Burger: 2 Tomato slices and 1 cheese slice.\\n```\\nTherefore:\\n```\\n4 * Jumbo Burger + 2 * Small Burger = tomatoSlices\\nJumbo Burger + Small Burger = cheeseSlices\\n```\\nLet `x` and `y` indicate `jumbo` and `small` Burger, respectively, then\\n```\\n4x + 2y = tomatoSlices\\nx + y = cheeseSlices\\n```\\n=>\\n```\\n2x = tomatoSlices - 2 * cheeseSlices\\n```\\n=>\\n```\\nx = (tomatoSlices - 2 * cheeseSlices) / 2\\ny = cheeseSlices - x\\n```\\n\\n----\\n\\n```java\\n    public List<Integer> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        int twoX = tomatoSlices - 2 * cheeseSlices, x = twoX / 2, y = cheeseSlices - x;\\n        return twoX >= 0 && twoX % 2 == 0 && y >= 0 ? Arrays.asList(x, y) : Arrays.asList();        \\n    }\\n```\\n```python\\n    def numOfBurgers(self, tomatoSlices: int, cheeseSlices: int) -> List[int]:\\n        two_x = tomatoSlices - 2 * cheeseSlices\\n        x = two_x // 2\\n        y = cheeseSlices - x\\n        return [x, y] if two_x >= 0 and not two_x % 2 and y >= 0 else []\\n```\\n**Analysis**\\n\\nTime & space: O(1).",
                "solutionTags": [],
                "code": "```\\nJumbo Burger: 4 tomato slices and 1 cheese slice.\\nSmall Burger: 2 Tomato slices and 1 cheese slice.\\n```\n```\\n4 * Jumbo Burger + 2 * Small Burger = tomatoSlices\\nJumbo Burger + Small Burger = cheeseSlices\\n```\n```\\n4x + 2y = tomatoSlices\\nx + y = cheeseSlices\\n```\n```\\n2x = tomatoSlices - 2 * cheeseSlices\\n```\n```\\nx = (tomatoSlices - 2 * cheeseSlices) / 2\\ny = cheeseSlices - x\\n```\n```java\\n    public List<Integer> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        int twoX = tomatoSlices - 2 * cheeseSlices, x = twoX / 2, y = cheeseSlices - x;\\n        return twoX >= 0 && twoX % 2 == 0 && y >= 0 ? Arrays.asList(x, y) : Arrays.asList();        \\n    }\\n```\n```python\\n    def numOfBurgers(self, tomatoSlices: int, cheeseSlices: int) -> List[int]:\\n        two_x = tomatoSlices - 2 * cheeseSlices\\n        x = two_x // 2\\n        y = cheeseSlices - x\\n        return [x, y] if two_x >= 0 and not two_x % 2 and y >= 0 else []\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 441475,
                "title": "the-only-realistic-solution",
                "content": "I believe this is how you\\'d solve it after eating a lot of burgers.\\n```\\n    vector<int> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        int burgers = cheeseSlices;\\n        for (int jumbo = 0; jumbo <= burgers; jumbo++) {\\n            int small = burgers - jumbo;\\n            if (tomatoSlices == 4*jumbo + 2*small)\\n                return {jumbo, small};\\n        }\\n        return {};\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    vector<int> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        int burgers = cheeseSlices;\\n        for (int jumbo = 0; jumbo <= burgers; jumbo++) {\\n            int small = burgers - jumbo;\\n            if (tomatoSlices == 4*jumbo + 2*small)\\n                return {jumbo, small};\\n        }\\n        return {};\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 656213,
                "title": "o-1-solution-with-complete-analysis",
                "content": "Imagine, `x` number of jumbo burgers and `y` number of small burgers are made from the given `tomatoSlices` and `cheeseSlices`. \\n\\nSo, the equation would be, \\n`4x + 2y = tomatoSlices` which means, total number of tomatoSlices required for making `x` jumbo burgers and `y` small burgers should be EXACTLY `tomatoSlices` (if possible)\\n\\nSecond equation would be,\\n`x + y = cheeseSlices` which means, total number of cheeseSlices required for making `x` jumbo burgers and `y` small burgers should be EXACTLY `cheeseSlices` (if possible)\\n\\nThe way we solve this equation is,\\nmultiply `4` on both sides of equation 2.\\nSo, `4x + 4y = 4*cheeseSlices` <-- Equation 3\\n\\nSubtract equation 1 from equaiton 3\\n\\n```\\n    4x + 4y = 4*cheeseSlices (equation 3)\\n-   4x + 2y = tomatoSlices (equation 1)\\n\\t__________________________________________\\n         2y = 4*cheeseSlices - tomatoSlices <-- Equation 4\\n```\\n\\nNow, if the solution is impossible, we will not get a positive whole integer value for `y` from equation 4.\\nSo, let\\'s make a quick check for that. \\n`y = (4*cheeseSlices - tomatoSlices) / 2` (Based on equation 4)\\n\\nwhich means, for `y` to be a positive whole integer `4*cheeseSlices - tomatoSlices` must be positive and a multple of 2, otherwise we return empty list.\\n\\nafter getting y, use equation 2 to get x\\n`x = cheeseSlices - y`\\n\\nAgain check if x is a positive whole integer. (Because `x` could turn out negative based on value of `y`). So, if `x` is negative, return an empty list.\\n\\nIf all goes well, return list of `x` and `y` as result.\\n\\n```\\npublic List<Integer> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n\\tint jCount = 0, // x\\n\\t\\tsCount = 0; // y\\n\\n\\t// 4x + 2y = tomatoSlices\\n\\t// x + y = cheeseSlices\\n\\n\\tif ((4*cheeseSlices - tomatoSlices) < 0 || (4*cheeseSlices - tomatoSlices) % 2 != 0) {\\n\\t\\treturn Collections.emptyList();\\n\\t}\\n\\n\\tsCount = (4*cheeseSlices - tomatoSlices) / 2;\\n\\tjCount = cheeseSlices - sCount;\\n\\n\\treturn jCount >= 0\\n\\t\\t? Arrays.asList(jCount, sCount)\\n\\t\\t: Collections.emptyList();\\n}\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\n    4x + 4y = 4*cheeseSlices (equation 3)\\n-   4x + 2y = tomatoSlices (equation 1)\\n\\t__________________________________________\\n         2y = 4*cheeseSlices - tomatoSlices <-- Equation 4\\n```\n```\\npublic List<Integer> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n\\tint jCount = 0, // x\\n\\t\\tsCount = 0; // y\\n\\n\\t// 4x + 2y = tomatoSlices\\n\\t// x + y = cheeseSlices\\n\\n\\tif ((4*cheeseSlices - tomatoSlices) < 0 || (4*cheeseSlices - tomatoSlices) % 2 != 0) {\\n\\t\\treturn Collections.emptyList();\\n\\t}\\n\\n\\tsCount = (4*cheeseSlices - tomatoSlices) / 2;\\n\\tjCount = cheeseSlices - sCount;\\n\\n\\treturn jCount >= 0\\n\\t\\t? Arrays.asList(jCount, sCount)\\n\\t\\t: Collections.emptyList();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 444896,
                "title": "c-binary-search-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        int totalNumberBurgers = cheeseSlices;\\n        \\n        // Low & high represent boundaries of binary search for number of jumbo burgers\\n        int low = 0; int high = totalNumberBurgers;\\n        while (low <= high) {\\n            int mid = low + (high - low) / 2;\\n            \\n            int currSlices = mid*4 + (totalNumberBurgers - mid)*2;\\n            if (currSlices == tomatoSlices) {\\n                return {mid, totalNumberBurgers-mid};\\n            }\\n            \\n            if (currSlices < tomatoSlices) {\\n                low = mid+1;\\n            } else {\\n                high = mid-1;\\n            }\\n        }\\n        \\n        return {};\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        int totalNumberBurgers = cheeseSlices;\\n        \\n        // Low & high represent boundaries of binary search for number of jumbo burgers\\n        int low = 0; int high = totalNumberBurgers;\\n        while (low <= high) {\\n            int mid = low + (high - low) / 2;\\n            \\n            int currSlices = mid*4 + (totalNumberBurgers - mid)*2;\\n            if (currSlices == tomatoSlices) {\\n                return {mid, totalNumberBurgers-mid};\\n            }\\n            \\n            if (currSlices < tomatoSlices) {\\n                low = mid+1;\\n            } else {\\n                high = mid-1;\\n            }\\n        }\\n        \\n        return {};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 441434,
                "title": "easy-java-to-understand-beats-100",
                "content": "```\\nclass Solution {\\n    public List<Integer> numOfBurgers(int t, int c) {\\n        List<Integer> ret = new ArrayList<>();\\n        if(t%2!=0||((t/2)>2*c)||c>(t/2))return ret;\\n        ret.add((t/2-c));\\n        ret.add((2*c-t/2));\\n        return ret;\\n    }\\n}\\n```\\n![image](https://assets.leetcode.com/users/vshnlucky/image_1575176370.png)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> numOfBurgers(int t, int c) {\\n        List<Integer> ret = new ArrayList<>();\\n        if(t%2!=0||((t/2)>2*c)||c>(t/2))return ret;\\n        ret.add((t/2-c));\\n        ret.add((2*c-t/2));\\n        return ret;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 441323,
                "title": "java-simple-easy-solution-o-1-time-o-1-space",
                "content": "```\\nclass Solution {\\n    public List<Integer> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        \\n        List<Integer> ans = new ArrayList<>();\\n        \\n        // need to solve 2 equations\\n        // 4 * jumbo + 2 * small = tomatoSlices, jumbo + small = cheeseSlices\\n        \\n        if(tomatoSlices % 2 == 1) return ans;\\n        \\n        int jumbo = tomatoSlices - 2 * cheeseSlices;\\n        if(jumbo < 0 || jumbo % 2 == 1) return ans;\\n        \\n        jumbo /= 2;\\n        \\n        int small = cheeseSlices - jumbo;\\n        if(small < 0) return ans;\\n        \\n        ans.add(jumbo);\\n        ans.add(small);\\n        \\n        return ans;\\n        \\n    }\\n}",
                "solutionTags": [
                    "Math"
                ],
                "code": "class Solution {\\n    public List<Integer> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        \\n        List<Integer> ans = new ArrayList<>();\\n        \\n        // need to solve 2 equations\\n        // 4 * jumbo + 2 * small = tomatoSlices, jumbo + small = cheeseSlices\\n        \\n        if(tomatoSlices % 2 == 1) return ans;\\n        \\n        int jumbo = tomatoSlices - 2 * cheeseSlices;\\n        if(jumbo < 0 || jumbo % 2 == 1) return ans;\\n        \\n        jumbo /= 2;\\n        \\n        int small = cheeseSlices - jumbo;\\n        if(small < 0) return ans;\\n        \\n        ans.add(jumbo);\\n        ans.add(small);\\n        \\n        return ans;\\n        \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 441299,
                "title": "python-easy-solution-with-explanation-2-known-2-variables",
                "content": "treat it like two equations where you have 2 known 2 variable:\\n    \\nLet number of small burgers be y and number of jumbo burgers be x.\\ntotal tomatoslices used will be 4x +2y \\ntotal cheeseSlices used will be x+y\\n\\n4x +2y = tomatoSlices\\nx+y = cheeseSlices\\n\\nSolving for x and y , we get:\\n\\ny= ((4* cheeseSlices) - tomatoSlices)/2\\nx= cheeseSlices - y\\n```\\n\\nclass Solution(object):\\n    def numOfBurgers(self, t, c):\\n        small = ((4*c)-t)/2\\n        jumbo = c-small\\n        if small.is_integer() and small >= 0 and jumbo >= 0:\\n            return [int(jumbo), int(small)]\\n        else:\\n            return []\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution(object):\\n    def numOfBurgers(self, t, c):\\n        small = ((4*c)-t)/2\\n        jumbo = c-small\\n        if small.is_integer() and small >= 0 and jumbo >= 0:\\n            return [int(jumbo), int(small)]\\n        else:\\n            return []\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 889527,
                "title": "java-solution-two-solutions",
                "content": "**Checking all the possible solutions**\\nRuntime : **497ms**\\n```\\npublic List<Integer> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        boolean cond1 = (tomatoSlices == 0 && cheeseSlices !=0) || (tomatoSlices != 0 && cheeseSlices ==0);\\n        boolean cond2 = (tomatoSlices < cheeseSlices);\\n        boolean cond3 = (tomatoSlices%2 == 1);\\n        if(cond1 || cond2 ||  cond3){\\n            return new ArrayList<>();\\n        }\\n        int low = 0;\\n        int high = cheeseSlices;\\n        while(low <= cheeseSlices){\\n            int Jumbo_Burger = 4*low;\\n            int Small_Burger = 2*high;\\n            if(Jumbo_Burger + Small_Burger == tomatoSlices){\\n               return Arrays.asList(low,high);\\n            }\\n            low++;\\n            high--;\\n        }\\n        \\n        //if not above then there is no answer\\n        return new ArrayList<>();\\n    }\\n```\\n\\n**Simple Math**\\n**Run Time : 1ms**\\n```\\npublic List<Integer> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        //Jumbo Burger = (tomatoSlices/2) - cheeseSlices;\\n        //Jumbo Burger + Small Burger = cheeseSlices\\n        \\n        //check for even tomatoes\\n        if(tomatoSlices %2 == 1){\\n            return new ArrayList<>();\\n        }\\n        int Jumbo_Burger =  (tomatoSlices/2) - cheeseSlices;\\n        \\n        //check for Jumbo_Burger\\n        if(Jumbo_Burger <0 || Jumbo_Burger > cheeseSlices){\\n             return new ArrayList<>();\\n        }\\n        int Small_Burger = cheeseSlices - Jumbo_Burger;\\n        return Arrays.asList(Jumbo_Burger,Small_Burger);\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic List<Integer> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        boolean cond1 = (tomatoSlices == 0 && cheeseSlices !=0) || (tomatoSlices != 0 && cheeseSlices ==0);\\n        boolean cond2 = (tomatoSlices < cheeseSlices);\\n        boolean cond3 = (tomatoSlices%2 == 1);\\n        if(cond1 || cond2 ||  cond3){\\n            return new ArrayList<>();\\n        }\\n        int low = 0;\\n        int high = cheeseSlices;\\n        while(low <= cheeseSlices){\\n            int Jumbo_Burger = 4*low;\\n            int Small_Burger = 2*high;\\n            if(Jumbo_Burger + Small_Burger == tomatoSlices){\\n               return Arrays.asList(low,high);\\n            }\\n            low++;\\n            high--;\\n        }\\n        \\n        //if not above then there is no answer\\n        return new ArrayList<>();\\n    }\\n```\n```\\npublic List<Integer> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        //Jumbo Burger = (tomatoSlices/2) - cheeseSlices;\\n        //Jumbo Burger + Small Burger = cheeseSlices\\n        \\n        //check for even tomatoes\\n        if(tomatoSlices %2 == 1){\\n            return new ArrayList<>();\\n        }\\n        int Jumbo_Burger =  (tomatoSlices/2) - cheeseSlices;\\n        \\n        //check for Jumbo_Burger\\n        if(Jumbo_Burger <0 || Jumbo_Burger > cheeseSlices){\\n             return new ArrayList<>();\\n        }\\n        int Small_Burger = cheeseSlices - Jumbo_Burger;\\n        return Arrays.asList(Jumbo_Burger,Small_Burger);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2057564,
                "title": "java-python-3-solve-a-linear-equations-group-w-brief-explanation-and-analysis",
                "content": "According the description of the problem, we have the following:\\n\\n```\\nJumbo Burger: 4 tomato slices and 1 cheese slice.\\nSmall Burger: 2 Tomato slices and 1 cheese slice.\\n```\\n\\nTherefore:\\n\\n```\\n4 * Jumbo Burger + 2 * Small Burger = tomatoSlices\\nJumbo Burger + Small Burger = cheeseSlices\\nLet x and y indicate jumbo and small Burger, respectively, then\\n```\\n\\n```\\n4x + 2y = tomatoSlices\\nx + y = cheeseSlices\\n```\\n\\n**=>**\\n\\n```2x = tomatoSlices - 2 * cheeseSlices```\\n\\n**=>**\\n\\n```\\nx = (tomatoSlices - 2 * cheeseSlices) / 2\\ny = cheeseSlices - x\\n```\\n\\n\\n**JAVA**\\n```\\npublic List<Integer> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        int twoX = tomatoSlices - 2 * cheeseSlices, x = twoX / 2, y = cheeseSlices - x;\\n        return twoX >= 0 && twoX % 2 == 0 && y >= 0 ? Arrays.asList(x, y) : Arrays.asList();        \\n    }\\n```\\n\\n**PYTHON**\\n```\\ndef numOfBurgers(self, tomatoSlices: int, cheeseSlices: int) -> List[int]:\\n        two_x = tomatoSlices - 2 * cheeseSlices\\n        x = two_x // 2\\n        y = cheeseSlices - x\\n        return [x, y] if two_x >= 0 and not two_x % 2 and y >= 0 else []\\n```\\n\\n**Analysis**\\n\\n**Time & space: O(1).**",
                "solutionTags": [
                    "Java",
                    "Python"
                ],
                "code": "```\\nJumbo Burger: 4 tomato slices and 1 cheese slice.\\nSmall Burger: 2 Tomato slices and 1 cheese slice.\\n```\n```\\n4 * Jumbo Burger + 2 * Small Burger = tomatoSlices\\nJumbo Burger + Small Burger = cheeseSlices\\nLet x and y indicate jumbo and small Burger, respectively, then\\n```\n```\\n4x + 2y = tomatoSlices\\nx + y = cheeseSlices\\n```\n```2x = tomatoSlices - 2 * cheeseSlices```\n```\\nx = (tomatoSlices - 2 * cheeseSlices) / 2\\ny = cheeseSlices - x\\n```\n```\\npublic List<Integer> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        int twoX = tomatoSlices - 2 * cheeseSlices, x = twoX / 2, y = cheeseSlices - x;\\n        return twoX >= 0 && twoX % 2 == 0 && y >= 0 ? Arrays.asList(x, y) : Arrays.asList();        \\n    }\\n```\n```\\ndef numOfBurgers(self, tomatoSlices: int, cheeseSlices: int) -> List[int]:\\n        two_x = tomatoSlices - 2 * cheeseSlices\\n        x = two_x // 2\\n        y = cheeseSlices - x\\n        return [x, y] if two_x >= 0 and not two_x % 2 and y >= 0 else []\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1599441,
                "title": "python3-linear-equation-explained-beats-100",
                "content": "We notice that the number of burger limited by chees slices, i.e. number of burgers are going to be equal to number of chees slices. Thus,  if we denote number of small burgers as `x` and number of big burgers as `y`, we got an equation `x + y = cheesSlices`. This immediately suggest the use of linear equations. Since we have 2 unknowns, we need a second equation which is `x*2 + y*4 = tomatoSlices`. Then we simply express `y` through the `x`, substitute one into another and calculate `y` and `x`.\\n\\n```\\n\\tx + y = cheesSlices\\n\\t2*x + 4*y = tomatoSlices\\n\\t\\n\\tx = cheesSlices - y\\n\\t2*(cheesSlices - y) + y*4 = tomatoSlices\\n\\t\\n\\ty = tomatoSlices/2 - cheesSlices\\n```\\n\\nRuntime: 20 ms, faster than **100.00%** of Python3 online submissions for Number of Burgers with No Waste of Ingredients.\\nMemory Usage: 14.3 MB, less than **53.33%** of Python3 online submissions for Number of Burgers with No Waste of Ingredients.\\n\\n```\\nclass Solution:\\n    def numOfBurgers(self, ts: int, cs: int) -> List[int]:             \\n        x = ts/2 - cs\\n        y = cs - x\\n\\n        if x < 0 or x % 1 or y < 0 or y % 1:\\n            return []\\n\\n        return [int(x), int(y)]\\n```\\n",
                "solutionTags": [],
                "code": "```\\n\\tx + y = cheesSlices\\n\\t2*x + 4*y = tomatoSlices\\n\\t\\n\\tx = cheesSlices - y\\n\\t2*(cheesSlices - y) + y*4 = tomatoSlices\\n\\t\\n\\ty = tomatoSlices/2 - cheesSlices\\n```\n```\\nclass Solution:\\n    def numOfBurgers(self, ts: int, cs: int) -> List[int]:             \\n        x = ts/2 - cs\\n        y = cs - x\\n\\n        if x < 0 or x % 1 or y < 0 or y % 1:\\n            return []\\n\\n        return [int(x), int(y)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1348226,
                "title": "best-logical-solution-100-faster-o-1-time-o-1-space-no-dsa-required",
                "content": "\\tThis problem can be easily converted into a 2 equations, 2 variables maths problem.\\n\\t\\n\\tFor making a Jumbo burger we require: 4 tomato slices and 1 cheese slice.\\n\\tSimilarly for making a Small burger we require: 2 tomato slices and 1 cheese slice.\\n\\t\\n\\tLet the number of Jumbo burgers which can be made using the given slices be denoted by \\'x\\' and \\n\\tnumber of Small burgers which can be made using the given slices be denoted by \\'y\\'.\\n\\t\\n\\tNow since each jumbo burger (x) has 4 tomato slices and each small burger (y) has 2 tomato slices:\\n\\twe can note that the total number of tomato slices will be equal to: \\n\\tTomato slices (T) = 4*x + 2*y  - (i)\\n\\t\\n\\tSimilarly each jumbo burger (x) has 1 cheese slice and each small burger (y) has 1 cheese slice:\\n\\twe can note that the total number of cheese slices will be equal to: \\n\\tCheese slices (C) = x + y  - (ii)\\n\\t\\n\\tSolving equations (i) and (ii) we get:\\n\\tx = (T - 2*C) / 2\\n\\ty = (4*C - T) / 2\\n\\t\\n```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int T, int C) \\n    {\\n        if(T==0 && C==0)// if both the slices are zero\\n        {\\n            return {0,0};\\n        }\\n        if(T==0 || C==0)// if either one is zero, answer is not possible\\n        {\\n            return {};\\n        }\\n        int x = T-(2*C);\\n        if(x>0)\\n        {\\n            x = x/2;\\n        }\\n        int y = (4*C)-T;\\n        if(y>0)\\n        {\\n            y = y/2;\\n        }\\n        if(x+y==C && ((4*x)+(2*y))==T)\\n        {\\n            return {x,y};\\n        }\\n        return {};\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int T, int C) \\n    {\\n        if(T==0 && C==0)// if both the slices are zero\\n        {\\n            return {0,0};\\n        }\\n        if(T==0 || C==0)// if either one is zero, answer is not possible\\n        {\\n            return {};\\n        }\\n        int x = T-(2*C);\\n        if(x>0)\\n        {\\n            x = x/2;\\n        }\\n        int y = (4*C)-T;\\n        if(y>0)\\n        {\\n            y = y/2;\\n        }\\n        if(x+y==C && ((4*x)+(2*y))==T)\\n        {\\n            return {x,y};\\n        }\\n        return {};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 955083,
                "title": "python3-with-explanation",
                "content": "if cheese == 0, return [0, 0] only when tomato ==0.\\n\\nthe tomato/cheese ratio is determined by [2,4]\\n\\nno matter what the combination is, the number of tomato will always be even.\\n\\nThen, start with all burger 2, it will cost 2* cheese.\\nThe difference between tomato and 2* cheese will be compensated by burger 1. each additional burger 1 will offset 2 extra cheese.\\n\\n\\n```\\ndef numOfBurgers(self, tomatoSlices: int, cheeseSlices: int) -> List[int]:\\n        if cheeseSlices==0:\\n            return [0,0] if tomatoSlices==0 else []\\n        elif tomatoSlices/cheeseSlices<2 or tomatoSlices/cheeseSlices>4 or tomatoSlices%2==1:\\n            return []\\n        else:\\n            ans=(tomatoSlices-2*cheeseSlices)//2\\n            return [ans,cheeseSlices-ans]\\n```",
                "solutionTags": [],
                "code": "```\\ndef numOfBurgers(self, tomatoSlices: int, cheeseSlices: int) -> List[int]:\\n        if cheeseSlices==0:\\n            return [0,0] if tomatoSlices==0 else []\\n        elif tomatoSlices/cheeseSlices<2 or tomatoSlices/cheeseSlices>4 or tomatoSlices%2==1:\\n            return []\\n        else:\\n            ans=(tomatoSlices-2*cheeseSlices)//2\\n            return [ans,cheeseSlices-ans]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 551868,
                "title": "math-python-using-2-variables-linear-algebra-to-solve-the-problem",
                "content": "We are given here the number of tomato slices (T) and the number of cheese slices (C). Using them, we should make the burgers, jumbo and small. A jumbo burger requires 4 tomato slices and 1 cheese slice and a small burger requires 2 tomato slices and 1 cheese slices. Let J and S represent the number of jumbo burgers and small burgers. Also, \\n\\nSo, \\n*4J + 2S = T\\n  J +   S = C*\\n\\nGiven the values of T and C, we should find the values of J and S. That is solving the two variable linear equations. But wait! Are there any constraints?\\n\\nYes, there are. The number of burgers can\\'t be decimals or negatives.\\nSo, the constraints are:\\n*J \\u2208  {0, 1, 2, 3, ...}*\\n*S \\u2208  {0, 1, 2, 3, ...}*\\n\\nAs the matrix `[[4, 2], [1, 1]]` has non-zero determinant (i.e 2), there exists a unique solution. After finding the solution, we need to see if the solution satisfies the constraints. If it satisfies, return the list `[J, S]`, else return `[]`.\\n\\nTo find the inverse matrix, we divide the adjoint matrix by the determinant. So, the solution is:\\n*[[J], [S]] = 0.5 * [[0.5, -1], [0.5, 2]] x [[T], [C]]*\\n\\nNote that `x` represents matrix multiplication. So, we come up with the following solution.\\n\\nPython solution:\\n```\\nclass Solution:\\n    def numOfBurgers(self, tomatoSlices, cheeseSlices):\\n\\t\\t# on the basis of the matrix solution\\n        ans = [0.5 * tomatoSlices - cheeseSlices, -0.5 * tomatoSlices + 2 * cheeseSlices]\\n\\t\\t\\n\\t\\t# using the constraints to see if solution satisfies it\\n        if 0 <= int(ans[0]) == ans[0] and 0 <= int(ans[1]) == ans[1]:\\n            return [int(ans[0]), int(ans[1])]\\n        else:\\n            return []\\n```\\n\\nHave fun!",
                "solutionTags": [
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def numOfBurgers(self, tomatoSlices, cheeseSlices):\\n\\t\\t# on the basis of the matrix solution\\n        ans = [0.5 * tomatoSlices - cheeseSlices, -0.5 * tomatoSlices + 2 * cheeseSlices]\\n\\t\\t\\n\\t\\t# using the constraints to see if solution satisfies it\\n        if 0 <= int(ans[0]) == ans[0] and 0 <= int(ans[1]) == ans[1]:\\n            return [int(ans[0]), int(ans[1])]\\n        else:\\n            return []\\n```",
                "codeTag": "Java"
            },
            {
                "id": 441779,
                "title": "elegant-c-java-go-python-javascript-2-lines-o-1-time-space",
                "content": "This clearly should be \"Easy\" not \"Medium\".\\nCheck viability conditions first, then allocate greedily: jumbo = tomato/2 - cheese, small = cheese - jumbo.\\n\\nJava\\n``` \\nclass Solution {\\n    public List<Integer> numOfBurgers(int ts, int cs) {\\n        if (ts%2==1 || ts/2<cs || ts/4>cs) return Collections.emptyList();\\n        return Arrays.asList(ts/2-cs, 2*cs-ts/2);\\n    }\\n}\\n```\\nC++\\n```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int ts, int cs) {\\n        if (ts%2==1 || ts/2<cs || ts/4>cs) return {};\\n        return {ts/2-cs, 2*cs-ts/2};\\n    }\\n};\\n```\\nGo\\n```\\nfunc numOfBurgers(ts int, cs int) []int {\\n    if ts%2==1 || ts/2<cs || ts/4>cs {\\n        return []int{}\\n    } \\n    return []int{ts/2-cs, 2*cs-ts/2}\\n}\\n```\\nPython\\n```\\nclass Solution(object):\\n    def numOfBurgers(self, ts, cs):\\n        return [] if ts%2==1 or ts/2<cs or ts/4>cs else [ts/2-cs, 2*cs-ts/2]\\n```\\nJavaScript\\n```\\nfunction numOfBurgers(ts, cs) {\\n    return ts%2==1 || ts/2<cs || ts/4>cs ? [] : [ts/2-cs, 2*cs-ts/2];\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "JavaScript",
                    "Go"
                ],
                "code": "``` \\nclass Solution {\\n    public List<Integer> numOfBurgers(int ts, int cs) {\\n        if (ts%2==1 || ts/2<cs || ts/4>cs) return Collections.emptyList();\\n        return Arrays.asList(ts/2-cs, 2*cs-ts/2);\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int ts, int cs) {\\n        if (ts%2==1 || ts/2<cs || ts/4>cs) return {};\\n        return {ts/2-cs, 2*cs-ts/2};\\n    }\\n};\\n```\n```\\nfunc numOfBurgers(ts int, cs int) []int {\\n    if ts%2==1 || ts/2<cs || ts/4>cs {\\n        return []int{}\\n    } \\n    return []int{ts/2-cs, 2*cs-ts/2}\\n}\\n```\n```\\nclass Solution(object):\\n    def numOfBurgers(self, ts, cs):\\n        return [] if ts%2==1 or ts/2<cs or ts/4>cs else [ts/2-cs, 2*cs-ts/2]\\n```\n```\\nfunction numOfBurgers(ts, cs) {\\n    return ts%2==1 || ts/2<cs || ts/4>cs ? [] : [ts/2-cs, 2*cs-ts/2];\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3490817,
                "title": "simple-math",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        vector<int>ans;\\n        if(tomatoSlices%2==1) return ans;\\n        else\\n        {\\n            if(cheeseSlices>=ceil(1.0*tomatoSlices/4)&& cheeseSlices<=tomatoSlices/2)\\n            {\\n                int jumbo=((tomatoSlices/2) -cheeseSlices);\\n                int small=cheeseSlices-jumbo;\\n                ans.push_back(jumbo);\\n                ans.push_back(small);\\n            } \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        vector<int>ans;\\n        if(tomatoSlices%2==1) return ans;\\n        else\\n        {\\n            if(cheeseSlices>=ceil(1.0*tomatoSlices/4)&& cheeseSlices<=tomatoSlices/2)\\n            {\\n                int jumbo=((tomatoSlices/2) -cheeseSlices);\\n                int small=cheeseSlices-jumbo;\\n                ans.push_back(jumbo);\\n                ans.push_back(small);\\n            } \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3251518,
                "title": "beats-100-simplest-explanation",
                "content": "# Intuition\\nlet no be large and small \\n4*large  + 2*small = tomato .... eqn(i)\\nlarge + small = cheese ..... eqn(ii)\\nfrom both equation \\nlarge = (tomato)/2 - cheese \\nsmall = cheese - large \\n\\n.\\n.\\nPls upvote if you liked !!\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int tomato, int cheese) \\n    {\\n        \\n        if(tomato % 2!=0 || cheese*2> tomato || cheese >tomato)\\n        return { } ;\\n        int large  = tomato/2 - cheese ; \\n        int small = cheese - large ; \\n        if(large >=0 && small>=0)\\n        return {large,small};\\n        else return { };\\n\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int tomato, int cheese) \\n    {\\n        \\n        if(tomato % 2!=0 || cheese*2> tomato || cheese >tomato)\\n        return { } ;\\n        int large  = tomato/2 - cheese ; \\n        int small = cheese - large ; \\n        if(large >=0 && small>=0)\\n        return {large,small};\\n        else return { };\\n\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2607558,
                "title": "python-solution-basic-algebra",
                "content": "```\\nclass Solution:\\n    # Basic algebra\\n    # x, y = tomato, cheese\\n    # j, s = number of jumbo and small burgers made\\n    # 4*j + 2*s = x\\n    # j + s = y\\n    # 2*j + 2*s = 2y\\n    # 2*j = x - 2y\\n    # s = y - j = y - (x-2*y)/2 = 2*y - x/2\\n    def numOfBurgers(self, tomatoSlices: int, cheeseSlices: int) -> List[int]:\\n        x, y = tomatoSlices, cheeseSlices\\n        if x < 2*y or y < x/4 or (x-2*y)%2 != 0 or x%2 != 0:\\n            return []\\n        return [(x-2*y)//2, 2*y-x // 2]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    # Basic algebra\\n    # x, y = tomato, cheese\\n    # j, s = number of jumbo and small burgers made\\n    # 4*j + 2*s = x\\n    # j + s = y\\n    # 2*j + 2*s = 2y\\n    # 2*j = x - 2y\\n    # s = y - j = y - (x-2*y)/2 = 2*y - x/2\\n    def numOfBurgers(self, tomatoSlices: int, cheeseSlices: int) -> List[int]:\\n        x, y = tomatoSlices, cheeseSlices\\n        if x < 2*y or y < x/4 or (x-2*y)%2 != 0 or x%2 != 0:\\n            return []\\n        return [(x-2*y)//2, 2*y-x // 2]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2539048,
                "title": "o-1-well-commented-easy-understanding",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int tomato, int cheese) {\\n        \\n        if(tomato % 2 == 1) return {}; //if number of tomatoes are odd it\\'s not possible\\n        \\n        int l = tomato/4 + tomato%4; //setting a lower limit (i greedyly use as many jumbo as possible)\\n        \\n        if(tomato < 4)  l = 0; // if less than 4 tomatoes jumbo cant be used\\n        \\n        int h = tomato/2; //setting an upper limit (i greedyly use as many small as possible)\\n        \\n        if(cheese < l || cheese > h) return {}; //cheese should lie b/w the limits... why? simple logic cant produce more or less than that\\n        \\n        int small = h - (2*(h-cheese)); //number of small burgers (how this formula came check below)\\n        \\n        int big = cheese-small; // number of larger burgers\\n        \\n        return {big,small};\\n    }\\n};\\n\\n/*\\n\\n\\nlet tomatoes = 20 and cheese = 7\\n\\nlet\\'s find out if cheese lies within limits;\\nl = 5 h = 10\\nyes !!\\n\\nnow,\\n2 2 2 2 2 2 2 2 2 2 => i need 10 cheese for this but have 7 (need to remove 3 cheese)\\nin order to remove 3 cheese i will remove 6 2\\'s and replace with 3 4\\'s..\\nthat is,\\nnew small burgers = allFromSmall - (2*(allFromSmall - cheese));  ==> 10 - (2*(10-7)) ==>4\\nnew big ones = cheese - smalls ==> 7-4 = 3\\nans :: {3,4}\\n\\n\\n*/\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int tomato, int cheese) {\\n        \\n        if(tomato % 2 == 1) return {}; //if number of tomatoes are odd it\\'s not possible\\n        \\n        int l = tomato/4 + tomato%4; //setting a lower limit (i greedyly use as many jumbo as possible)\\n        \\n        if(tomato < 4)  l = 0; // if less than 4 tomatoes jumbo cant be used\\n        \\n        int h = tomato/2; //setting an upper limit (i greedyly use as many small as possible)\\n        \\n        if(cheese < l || cheese > h) return {}; //cheese should lie b/w the limits... why? simple logic cant produce more or less than that\\n        \\n        int small = h - (2*(h-cheese)); //number of small burgers (how this formula came check below)\\n        \\n        int big = cheese-small; // number of larger burgers\\n        \\n        return {big,small};\\n    }\\n};\\n\\n/*\\n\\n\\nlet tomatoes = 20 and cheese = 7\\n\\nlet\\'s find out if cheese lies within limits;\\nl = 5 h = 10\\nyes !!\\n\\nnow,\\n2 2 2 2 2 2 2 2 2 2 => i need 10 cheese for this but have 7 (need to remove 3 cheese)\\nin order to remove 3 cheese i will remove 6 2\\'s and replace with 3 4\\'s..\\nthat is,\\nnew small burgers = allFromSmall - (2*(allFromSmall - cheese));  ==> 10 - (2*(10-7)) ==>4\\nnew big ones = cheese - smalls ==> 7-4 = 3\\nans :: {3,4}\\n\\n\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1770237,
                "title": "100-faster-o-1-solution",
                "content": "** Overview- Make two equation from given constraint. Say we have J jumbo burger and S small burger\\n     then total tomato=4j+2s and total cheese =j+s and now just solve them.**\\n\\t \\n\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\t\\tvector<int> numOfBurgers(int t, int c) {\\n\\t\\t\\t\\tif(t==0 && c==0) return {0,0};\\n\\t\\t\\t\\tif(t==0 || t%2!=0 || c==0) return {};\\n\\t\\t\\t\\t vector<int> v;\\n\\t\\t\\t\\t int x1=ceil((t-2*c)/2);\\n\\t\\t\\t\\t int x2=floor((t-2*c)/2);\\n\\t\\t\\t\\t if(x1>=0 && x2>=0 && x1==x2 && c-x1>=0){\\n\\t\\t\\t\\t\\t  v.push_back(x1);\\n\\t\\t\\t\\t\\t  v.push_back(c-x1);\\n\\t\\t\\t\\t }\\n\\t\\t\\t\\t return v;\\n\\t\\t\\t}\\n\\t\\t};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\t\\tpublic:\\n\\t\\t\\tvector<int> numOfBurgers(int t, int c) {\\n\\t\\t\\t\\tif(t==0 && c==0) return {0,0}",
                "codeTag": "Java"
            },
            {
                "id": 1415148,
                "title": "c-o-1-faster-than-100-intuitive-solution-solve-linear-equations-explained-in-detail",
                "content": "# **Intuition and Maths Involved**\\nYou see, they ask us to use up all ingredients without wastage , if you just look a little carefully you will realize its more like a class 9th problem of **Pair Of Linear Equations in Two variables**, where all you need is to simply check if the 2 equations have \"whole number \" solutions .. \\n\\n\\nLet me explain :-\\nLet\\'s say we can create **x** jumbo burgers and **y** small ones ..\\n**Total cheeseslices Used  = x + y**  (all burgers use one cheeseslice so x + y burgers neeed x+ y slices , right?)\\ntomatoslices used in x Jumbo burgers = 4x (4 in each burger, means total 4x will be needed)\\nTomatoslices used in y small burgers = 2y (2 in each burger, means total 2x will be needed)\\n**Total tomatoeslices Used  = 4x + 2y**\\n\\nSo we are basically left with 2 equations at hand : -\\n**4x + 2y = tomatoslices       ----------(i)\\n\\tx + y = cheeseslices       ----------(ii)**\\n\\nIf we try to solve them we get x and y as \\n**x = (tomatoSlices - 2*cheeseSlices) / 2\\ny = cheeseSlices - x**\\nNow, all we need is to check if x and y we are getting, are whole numbers or not...\\nbecause you won\\'t be just making negative number of burgers or a fraction of them, will you? : -)\\n\\n# Implementation \\nIt could be one liner, but I prefer code to be more understandable than being very short : -)\\n```\\n\\nvector<int> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n            double x = 0, y = 0;\\n            x = (tomatoSlices - 2*cheeseSlices);\\n            x = x / 2;\\n            y = cheeseSlices - x;\\n            if(ceil(x) == x and ceil(y) == y and x >= 0 and y >= 0) // checks for whole number\\n               return {(int)x,(int)y};\\n            return {};\\n    }\\n```\\n# Complexity Analysis\\nTime Complexity - O(1)  // no iterations, just direct calculations \\nSpace Complecity - O(1) // No space needed except for 2 variable x and y : - ))\\nFaster than 100% \\n\\n**Please upvote if you find it useful !!**\\n",
                "solutionTags": [],
                "code": "```\\n\\nvector<int> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n            double x = 0, y = 0;\\n            x = (tomatoSlices - 2*cheeseSlices);\\n            x = x / 2;\\n            y = cheeseSlices - x;\\n            if(ceil(x) == x and ceil(y) == y and x >= 0 and y >= 0) // checks for whole number\\n               return {(int)x,(int)y};\\n            return {};\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1080107,
                "title": "linear-algebra-solution-with-explanation",
                "content": "This solution is not accepted by leetcode, but nonetheless I thought I would share. We can think of this problem as \\'Some amount of Jumbo Burgers + some amount of Small Burgers better = the amount of tomato and cheese slices I have. Let `J = Jumbor Burger`, let `S = Small Burger`, let `t = tomato slices I have`, let `c = cheese slices I have`. \\nThen,  `4*J + S*2 = t`,` J + S = c`. The first equation in words says, \\'For 1 Jumber Burger I need 4 slices of tomatoes and for 1 Small burger I need 2 slices of tomatoes. Now, I don\\'t know how many Jumbo Burgers and Small burgers I am going to make, but how ever many I end up making I better use all the tomatoe slices.\\' Similarly, the second equation in words says, \\'For 1 Jumber Burger I need 1 slice of cheese and for 1 Small burger I need 1 slice of cheese. Now, I don\\'t know how many Jumbo Burgers and Small burgers I am going to make, but how ever many I end up making I better use all the cheese slices.\\' Now we have a linear system of equations and we have tools to solve this problem. \\n\\n```\\nimport numpy as np\\nclass Solution:\\n    def numOfBurgers(self, tomatoSlices: int, cheeseSlices: int) -> List[int]:\\n        # Linear Algebra solution\\n        a = np.array([[4, 2], [1, 1]])\\n        b = np.array([tomatoSlices, cheeseSlices])\\n        x = np.linalg.solve(a, b)\\n        return x\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nimport numpy as np\\nclass Solution:\\n    def numOfBurgers(self, tomatoSlices: int, cheeseSlices: int) -> List[int]:\\n        # Linear Algebra solution\\n        a = np.array([[4, 2], [1, 1]])\\n        b = np.array([tomatoSlices, cheeseSlices])\\n        x = np.linalg.solve(a, b)\\n        return x\\n```",
                "codeTag": "Java"
            },
            {
                "id": 441667,
                "title": "python-3-one-line-beats-100-24-ms-with-explanation",
                "content": "_Explanation:_\\nLet x = number of jumbo burgers and y = number of small burgers. Then we can write the following system of equations: 4x + 2y = T  and  x + y = C. Using substitution, we can solve this linear system to get: x = T/2 - C  and  y = 2C - T/2. Note that although there is *always* a unique solution to this system (since the lines have different slopes), the solutions may not always make sense in the context of this problem. Specifically, x and y must be non-negative whole numbers. This requires three conditions to be met:\\n\\n1) T must be even (that is: T % 2 == 0)\\n2) x = T/2 - C \\u2265 0 (that is: T \\u2265 2C)\\n3) y = 2C - T/2 \\u2265 0 (that is: 4C \\u2265 T)\\n\\nThus we return [ ] if any of these conditions fail. Otherwise we return [x,y]. \\n```\\nclass Solution:\\n    def numOfBurgers(self, T: int, C: int) -> List[int]:\\n        return [[T//2 - C, 2*C - T//2],[]][T % 2 or T < 2*C or 4*C < T]\\n\\t\\t\\n\\t\\t\\n- Junaid Mansuri\\n- Chicago, IL",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "_Explanation:_\\nLet x = number of jumbo burgers and y = number of small burgers. Then we can write the following system of equations: 4x + 2y = T  and  x + y = C. Using substitution, we can solve this linear system to get: x = T/2 - C  and  y = 2C - T/2. Note that although there is *always* a unique solution to this system (since the lines have different slopes), the solutions may not always make sense in the context of this problem. Specifically, x and y must be non-negative whole numbers. This requires three conditions to be met:\\n\\n1) T must be even (that is: T % 2 == 0)\\n2) x = T/2 - C \\u2265 0 (that is: T \\u2265 2C)\\n3) y = 2C - T/2 \\u2265 0 (that is: 4C \\u2265 T)\\n\\nThus we return [ ] if any of these conditions fail. Otherwise we return [x,y]. \\n```\\nclass Solution:\\n    def numOfBurgers(self, T: int, C: int) -> List[int]:\\n        return [[T//2 - C, 2*C - T//2],[]][T % 2 or T < 2*C or 4*C < T]\\n\\t\\t\\n\\t\\t\\n- Junaid Mansuri\\n- Chicago, IL",
                "codeTag": "Java"
            },
            {
                "id": 441385,
                "title": "c-2-linear-equations-in-2-variables",
                "content": "Let the number of jumbo burgers and small burgers that will be our answer be x and y respectively. Now, the tomato slices and cheese slices used in each of our burgers will be:\\n\\n**Jumbo Burger**\\n\\tTomato Slices = 4*x\\n\\tCheese Slices = x\\n\\t\\n**Small Burger**\\n\\tTomato Slices = 2*y\\n\\tCheese Slices = y\\n\\t\\nNow, for no wastage of ingredients, the number of tomato slices and cheese slices used must be equal to the available number of tomato slices and cheese slices respectively. Therefore, the following 2 equations must hold:\\n\\n\\t4*x + 2*y = tomatoSlices\\n\\tx + y = cheeseSlices\\n\\t\\nSolving for x and y gives us:\\n\\n\\tx = tomatoSlices/2 - cheeseSlices\\n\\ty = 2*cheeseSlices - tomatoSlices/2\\n\\t\\nFor our answers to be valid, both x and y must not be negative as well as fractional. For integral answers, tomatoSlices/2 must be an integer, which is only possible when tomatoSlices is divisible by 2. For non-negative answers, we will compute x and y and check if they are both positive. If they are, we will return them as the answer.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        vector<int> result;\\n        if(tomatoSlices%2 == 0)\\n        {\\n            int x = tomatoSlices/2 - cheeseSlices;\\n            int y = 2*cheeseSlices - tomatoSlices/2;\\n            if(x>=0 && y>=0)\\n            {\\n                result.push_back(x);\\n                result.push_back(y);\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        vector<int> result;\\n        if(tomatoSlices%2 == 0)\\n        {\\n            int x = tomatoSlices/2 - cheeseSlices;\\n            int y = 2*cheeseSlices - tomatoSlices/2;\\n            if(x>=0 && y>=0)\\n            {\\n                result.push_back(x);\\n                result.push_back(y);\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4011164,
                "title": "fast-accepted-o-1-c-java-code-beats-100",
                "content": "# Complexity\\n- Time complexity : **O(1)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# JAVA\\n -- | Details | --\\n -- | -- | --:\\n**Runtime** | **1** *ms* | *Beats* **100%**\\n**Memory** | **40** *MB* | *Beats* **70%**\\n```\\nclass Solution {\\n    public List<Integer> numOfBurgers(int tSlices, int cSlices) {\\n        List<Integer> result = new ArrayList<Integer>();\\n        int x = tSlices - 2*cSlices;\\n        int y = cSlices - x/2;\\n        if(x<0 || x%2!=0 || y<1 )\\n            if(tSlices!=0 || cSlices!=0)\\n                return result;\\n        result.add(x/2); result.add(y);\\n        return result;\\n    }\\n}\\n```\\n# C\\n -- | Details | --\\n--- | --- | ---:\\n**Runtime** | **3** *ms* | *Beats* **100%**\\n**Memory** | **5** *MB* | *Beats* **100%**\\n```\\nint* numOfBurgers(int tSlices, int cSlices, int* returnSize){\\n    *returnSize = 0;\\n    int *result;\\n    int x = tSlices-2*cSlices;\\n    int y = cSlices-x/2;\\n    if(x<0 || x%2 || y<1 )\\n        if(tSlices || cSlices)\\n            return result;\\n    *returnSize = 2;\\n    result = (int *)malloc(sizeof(int)*2);\\n    result[0] = x/2; result[1] = y;\\n    return result;    \\n}\\n```\\n## Tom need a UPVOTE : |\\n![waiting-tom-and-jerry.gif](https://assets.leetcode.com/users/images/4f0cc754-71e1-4cfc-816b-36a94c20b17f_1678366238.9546802.gif)",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> numOfBurgers(int tSlices, int cSlices) {\\n        List<Integer> result = new ArrayList<Integer>();\\n        int x = tSlices - 2*cSlices;\\n        int y = cSlices - x/2;\\n        if(x<0 || x%2!=0 || y<1 )\\n            if(tSlices!=0 || cSlices!=0)\\n                return result;\\n        result.add(x/2); result.add(y);\\n        return result;\\n    }\\n}\\n```\n```\\nint* numOfBurgers(int tSlices, int cSlices, int* returnSize){\\n    *returnSize = 0;\\n    int *result;\\n    int x = tSlices-2*cSlices;\\n    int y = cSlices-x/2;\\n    if(x<0 || x%2 || y<1 )\\n        if(tSlices || cSlices)\\n            return result;\\n    *returnSize = 2;\\n    result = (int *)malloc(sizeof(int)*2);\\n    result[0] = x/2; result[1] = y;\\n    return result;    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3876200,
                "title": "easy-c-solution-in-one-line",
                "content": "\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n**```O(1)```**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n**```O(1)```**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\n// if it helps plzz upvote it \\uD83D\\uDE09\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        if(tomatoSlices % 2 == 0 && cheeseSlices <= tomatoSlices/2 && tomatoSlices <= cheeseSlices *4)\\n            return {(tomatoSlices/2)-cheeseSlices,(2*cheeseSlices) - (tomatoSlices/2)};\\n        return {};\\n    }\\n};\\n// if it helps plzz upvote it \\uD83D\\uDE09**Bold**\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```O(1)```\n```O(1)```\n```\\n// if it helps plzz upvote it \\uD83D\\uDE09\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        if(tomatoSlices % 2 == 0 && cheeseSlices <= tomatoSlices/2 && tomatoSlices <= cheeseSlices *4)\\n            return {(tomatoSlices/2)-cheeseSlices,(2*cheeseSlices) - (tomatoSlices/2)};\\n        return {};\\n    }\\n};\\n// if it helps plzz upvote it \\uD83D\\uDE09**Bold**\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3751409,
                "title": "o-1-simple-algebra-linear-equation-in-2-variables",
                "content": "\\t\\tclass Solution {\\n\\t\\tpublic:\\n\\n\\t\\t\\tvector<int> numOfBurgers(int t, int c) {\\n\\t\\t\\t\\t// Lets assume a is total number of tomato slices for jumbo burger and b is total number of tomato slices for small burger\\n\\t\\t\\t\\t// Now if provided data will give answer it must satisfy these two given equation \\n\\t\\t\\t   // Equation 1\\n\\t\\t\\t\\t// a/4 + b/2 = c    i.e. total tomato slices for jumbo burger / 4 + total slices for small burger / 2 should be equal to total cheese slices\\n\\t\\t\\t\\t// Equation 2\\n\\t\\t\\t\\t// a+b = t       also total tomato slices for jumbo burger + total slices for small burger  should be equal to total cheese tomato slice\\n\\t\\t\\t\\t// here t is total tomato slice and c is total cheese slice \\n\\t\\t\\t\\tint b = 4*c-t;\\n\\t\\t\\t\\tint a = t-b;\\n\\t\\t\\t\\tif( a<0 || b<0 || b%2!=0 || a%4 !=0) return {};\\n\\t\\t\\t\\tb/=2;\\n\\t\\t\\t\\ta/=4;\\n\\t\\t\\t\\treturn {a,b};\\n\\n\\n\\n\\t\\t\\t}\\n\\t\\t};",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "class Solution {\\n\\t\\tpublic:\\n\\n\\t\\t\\tvector<int> numOfBurgers(int t, int c) {\\n\\t\\t\\t\\t// Lets assume a is total number of tomato slices for jumbo burger and b is total number of tomato slices for small burger\\n\\t\\t\\t\\t// Now if provided data will give answer it must satisfy these two given equation \\n\\t\\t\\t   // Equation 1\\n\\t\\t\\t\\t// a/4 + b/2 = c    i.e. total tomato slices for jumbo burger / 4 + total slices for small burger / 2 should be equal to total cheese slices\\n\\t\\t\\t\\t// Equation 2\\n\\t\\t\\t\\t// a+b = t       also total tomato slices for jumbo burger + total slices for small burger  should be equal to total cheese tomato slice\\n\\t\\t\\t\\t// here t is total tomato slice and c is total cheese slice \\n\\t\\t\\t\\tint b = 4*c-t;\\n\\t\\t\\t\\tint a = t-b;\\n\\t\\t\\t\\tif( a<0 || b<0 || b%2!=0 || a%4 !=0) return {}",
                "codeTag": "Java"
            },
            {
                "id": 3570961,
                "title": "easy-to-understand-javascript-solution",
                "content": "```\\nvar numOfBurgers = function(tomatoSlices, cheeseSlices) {\\n    if (cheeseSlices * 2 > tomatoSlices) return [];\\n    if (tomatoSlices % 2 === 1) return [];\\n    if (tomatoSlices === 0 && cheeseSlices === 0) return [0, 0];\\n\\n    const maxSmallBurger = tomatoSlices / 2;\\n    const jumboBurger = maxSmallBurger - cheeseSlices;\\n    const smallBurger = maxSmallBurger - jumboBurger * 2;\\n\\n    return smallBurger >= 0 ? [jumboBurger, smallBurger] : [];\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar numOfBurgers = function(tomatoSlices, cheeseSlices) {\\n    if (cheeseSlices * 2 > tomatoSlices) return [];\\n    if (tomatoSlices % 2 === 1) return [];\\n    if (tomatoSlices === 0 && cheeseSlices === 0) return [0, 0];\\n\\n    const maxSmallBurger = tomatoSlices / 2;\\n    const jumboBurger = maxSmallBurger - cheeseSlices;\\n    const smallBurger = maxSmallBurger - jumboBurger * 2;\\n\\n    return smallBurger >= 0 ? [jumboBurger, smallBurger] : [];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3430090,
                "title": "alternative-solution-binary-search-explained",
                "content": "# Intuition\\nWell you can do this problem in many linear way but i tried to do this in binary search for a better understanding of binary Search algorithm.\\nSo what are the left and right limits? Its the 0 and the max Jumbo burger we can create from given tomatoes(t).\\nFind the remaining tomatoes left for making small burgers after making jumbo burgers, if it is equal to number of cheese(c) given return it as ans.\\nNow suppose the total no of Jumbo + small burger < required Burger\\n-> We are making more Jumbo than required shift right pointer\\nelse:\\nshift left pointer\\n# Code\\n```\\nclass Solution:\\n    def numOfBurgers(self, t: int, c: int) -> List[int]:\\n        if t % 2 != 0: # its odd then 1 tomato will always be remaining\\n          return []\\n        totalJumbo = t // 4\\n        left = 0\\n        right = totalJumbo\\n        while left < right:\\n            mid = (left + right) // 2\\n            remaining = t - (4 * mid)\\n            totalSmall = remaining / 2\\n            burgerPossible = mid + totalSmall\\n            if burgerPossible == c:\\n                return [mid, int(totalSmall)]\\n            elif (burgerPossible) < c: # we are making more jumbo reduce it \\n                right = mid\\n            else:\\n                left = mid + 1\\n        remaining = t - (4 * left)\\n        Small = remaining / 2\\n        if left + Small == c:\\n            return [left, int(Small)]\\n        return []\\n```",
                "solutionTags": [
                    "Python3",
                    "Math",
                    "Binary Search",
                    "Sort"
                ],
                "code": "```\\nclass Solution:\\n    def numOfBurgers(self, t: int, c: int) -> List[int]:\\n        if t % 2 != 0: # its odd then 1 tomato will always be remaining\\n          return []\\n        totalJumbo = t // 4\\n        left = 0\\n        right = totalJumbo\\n        while left < right:\\n            mid = (left + right) // 2\\n            remaining = t - (4 * mid)\\n            totalSmall = remaining / 2\\n            burgerPossible = mid + totalSmall\\n            if burgerPossible == c:\\n                return [mid, int(totalSmall)]\\n            elif (burgerPossible) < c: # we are making more jumbo reduce it \\n                right = mid\\n            else:\\n                left = mid + 1\\n        remaining = t - (4 * left)\\n        Small = remaining / 2\\n        if left + Small == c:\\n            return [left, int(Small)]\\n        return []\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2845361,
                "title": "no-math-intuitive-greedy-solution",
                "content": "Split tomatoSlices to count of 4s as maximum as possible. For Example if tomatoSlices are 18 then count of 4s should be 4 and count of 2s should be 2. Silimarly for 16, count of 4 is 4 and count of 2 is 0.  Then we break down the count of 4s and count of 2s such that it equals to cheeseSlices.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n    \\n        if(cheeseSlices == 0 && tomatoSlices == 0){\\n            return {0, 0} ;\\n        }\\n        if(cheeseSlices >= tomatoSlices || tomatoSlices %2 != 0){\\n            return {} ;\\n        }\\n        int cnt4s = 0 ;\\n        int cnt2s = 0 ;\\n        if(tomatoSlices %4 == 0){\\n            cnt4s += tomatoSlices /4 ;\\n        }else{\\n            cnt4s += tomatoSlices /4 ;\\n            cnt2s++ ;\\n        }\\n        \\n        while(cheeseSlices > (cnt4s + cnt2s)){\\n            if(cnt4s < 0){\\n                return {};\\n            }\\n            cnt4s-- ;\\n            cnt2s += 2 ;\\n        }\\n        \\n        if(cheeseSlices == (cnt4s + cnt2s)){\\n            return {cnt4s, cnt2s} ;\\n        }\\n        return {} ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n    \\n        if(cheeseSlices == 0 && tomatoSlices == 0){\\n            return {0, 0} ;\\n        }\\n        if(cheeseSlices >= tomatoSlices || tomatoSlices %2 != 0){\\n            return {} ;\\n        }\\n        int cnt4s = 0 ;\\n        int cnt2s = 0 ;\\n        if(tomatoSlices %4 == 0){\\n            cnt4s += tomatoSlices /4 ;\\n        }else{\\n            cnt4s += tomatoSlices /4 ;\\n            cnt2s++ ;\\n        }\\n        \\n        while(cheeseSlices > (cnt4s + cnt2s)){\\n            if(cnt4s < 0){\\n                return {};\\n            }\\n            cnt4s-- ;\\n            cnt2s += 2 ;\\n        }\\n        \\n        if(cheeseSlices == (cnt4s + cnt2s)){\\n            return {cnt4s, cnt2s} ;\\n        }\\n        return {} ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2843901,
                "title": "c-easy-fast",
                "content": "\\n# Code\\n```\\n//from lee 215\\nclass Solution {\\npublic:\\n        vector<int> numOfBurgers(int t, int c) {\\n        if (t % 2 == 0 && c * 2 <= t && t <= c * 4)\\n            return {t / 2 - c, c * 2 - t / 2};\\n        return {};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n//from lee 215\\nclass Solution {\\npublic:\\n        vector<int> numOfBurgers(int t, int c) {\\n        if (t % 2 == 0 && c * 2 <= t && t <= c * 4)\\n            return {t / 2 - c, c * 2 - t / 2};\\n        return {};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2609231,
                "title": "c-easy-solution-explained-with-comments-tc-o-1-oc-o-1",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        vector<int> ans;\\n        int a = tomatoSlices;\\n        int b = cheeseSlices;\\n        \\n        // Let the number of Jumbo and Small Burger be x and y\\n        double x,y;\\n        \\n        // Solve the simultaneous equation for x and y\\n        x = (double)(a-2*b)/(double)2;\\n        y = (double)(4*b-a)/(double)2;\\n        \\n        // Check if they can be actual values of number of burgers\\n        if(x==(int)x && y==(int)y && x>=0 && y>=0){\\n            ans.push_back(x);\\n            ans.push_back(y);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        vector<int> ans;\\n        int a = tomatoSlices;\\n        int b = cheeseSlices;\\n        \\n        // Let the number of Jumbo and Small Burger be x and y\\n        double x,y;\\n        \\n        // Solve the simultaneous equation for x and y\\n        x = (double)(a-2*b)/(double)2;\\n        y = (double)(4*b-a)/(double)2;\\n        \\n        // Check if they can be actual values of number of burgers\\n        if(x==(int)x && y==(int)y && x>=0 && y>=0){\\n            ans.push_back(x);\\n            ans.push_back(y);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2520545,
                "title": "obviously-range-is-between-0-cheezeslice-cheezeslice-0-check-all-cases-matching-to-tomato-one",
                "content": "```\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int t, int c) {\\n        if(c>t/2 || t%2 || t/4 > c)\\n            return {};\\n        \\n        for(int i=0;i<=c;i++)\\n        {\\n            if(i*4 + (c-i)*2 == t)\\n                return {i,c-i};\\n        }\\n        \\n        return {};\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int t, int c) {\\n        if(c>t/2 || t%2 || t/4 > c)\\n            return {};\\n        \\n        for(int i=0;i<=c;i++)\\n        {\\n            if(i*4 + (c-i)*2 == t)\\n                return {i,c-i};\\n        }\\n        \\n        return {};\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2351357,
                "title": "python-o-1-tc-o-1-sc",
                "content": "\\'\\'\\'\\n\\n\\tclass Solution:\\n\\t\\tdef numOfBurgers(self, tomatoSlices: int, cheeseSlices: int) -> List[int]:\\n\\n\\t\\t\\t# total_jumbo + total_small = cheeseSlices\\n\\t\\t\\t# (4 * total_jumbo) + (2 * total_small) = tomatoSlices ie..., (2 * total_jumbo) + total_small = tomatoSlices / 2\\n\\n\\t\\t\\t# solve above two eq for total_jumbo and total_small;\\n\\t\\t\\t# total_jumbo = tomatoSlices/2 - cheeseSlices\\n\\t\\t\\t# total_small = 2*cheeseSlices - tomatoSlices/2\\n\\n\\t\\t\\tif 2 * cheeseSlices <= tomatoSlices <= 4 * cheeseSlices and  not tomatoSlices % 2:\\n\\t\\t\\t\\treturn [tomatoSlices // 2 - cheeseSlices, 2 * cheeseSlices - tomatoSlices // 2]\\n\\t\\t\\telse: return []\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "\\'\\'\\'\\n\\n\\tclass Solution:\\n\\t\\tdef numOfBurgers(self, tomatoSlices: int, cheeseSlices: int) -> List[int]:\\n\\n\\t\\t\\t# total_jumbo + total_small = cheeseSlices\\n\\t\\t\\t# (4 * total_jumbo) + (2 * total_small) = tomatoSlices ie..., (2 * total_jumbo) + total_small = tomatoSlices / 2\\n\\n\\t\\t\\t# solve above two eq for total_jumbo and total_small;\\n\\t\\t\\t# total_jumbo = tomatoSlices/2 - cheeseSlices\\n\\t\\t\\t# total_small = 2*cheeseSlices - tomatoSlices/2\\n\\n\\t\\t\\tif 2 * cheeseSlices <= tomatoSlices <= 4 * cheeseSlices and  not tomatoSlices % 2:\\n\\t\\t\\t\\treturn [tomatoSlices // 2 - cheeseSlices, 2 * cheeseSlices - tomatoSlices // 2]\\n\\t\\t\\telse: return []\\n\\'\\'\\'",
                "codeTag": "Java"
            },
            {
                "id": 1941373,
                "title": "binary-search-on-tomatoes-assuming-atleast-one-answer-exists",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        int ans = cheeseSlices;\\n        int low = 0, high = ans;\\n        while(low <= high)\\n        {\\n            int mid = (low + high) / 2;\\n            if((mid * 4) + ((ans - mid) * 2) == tomatoSlices)\\n                return {mid, ans - mid};\\n           if((mid * 4) + ((ans - mid) * 2) < tomatoSlices)\\n               low = mid +1;\\n            else\\n                high = mid - 1;\\n        }\\n        return {};\\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        int ans = cheeseSlices;\\n        int low = 0, high = ans;\\n        while(low <= high)\\n        {\\n            int mid = (low + high) / 2;\\n            if((mid * 4) + ((ans - mid) * 2) == tomatoSlices)\\n                return {mid, ans - mid};\\n           if((mid * 4) + ((ans - mid) * 2) < tomatoSlices)\\n               low = mid +1;\\n            else\\n                high = mid - 1;\\n        }\\n        return {};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1783836,
                "title": "c-2-line-code",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int tomato, int cheese) {\\n        if(tomato>cheese*4 or tomato<2*cheese or tomato%2!=0) return {};\\n        return {tomato/2-cheese, cheese*2-tomato/2};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int tomato, int cheese) {\\n        if(tomato>cheese*4 or tomato<2*cheese or tomato%2!=0) return {};\\n        return {tomato/2-cheese, cheese*2-tomato/2};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1773626,
                "title": "time-o-1-and-space-o-1-explore-the-unexplored",
                "content": "```\\nclass Solution:\\n    def numOfBurgers(self, tomatoSlices: int, cheeseSlices: int) -> List[int]:\\n        if tomatoSlices == 0 and cheeseSlices == 0:\\n            return [0,0]\\n        elif tomatoSlices % 2 != 0 or cheeseSlices * 4 < tomatoSlices or tomatoSlices < cheeseSlices * 2 or cheeseSlices == 0 or tomatoSlices == 0:\\n            return []\\n        \\n        remaining = tomatoSlices - (cheeseSlices * 2)\\n        \\n        if 4 * (remaining // 2) + (2 * (cheeseSlices - (remaining // 2))) == tomatoSlices:\\n            return [remaining // 2, cheeseSlices - (remaining // 2)]\\n\\n        return []\\n```",
                "solutionTags": [
                    "Python",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def numOfBurgers(self, tomatoSlices: int, cheeseSlices: int) -> List[int]:\\n        if tomatoSlices == 0 and cheeseSlices == 0:\\n            return [0,0]\\n        elif tomatoSlices % 2 != 0 or cheeseSlices * 4 < tomatoSlices or tomatoSlices < cheeseSlices * 2 or cheeseSlices == 0 or tomatoSlices == 0:\\n            return []\\n        \\n        remaining = tomatoSlices - (cheeseSlices * 2)\\n        \\n        if 4 * (remaining // 2) + (2 * (cheeseSlices - (remaining // 2))) == tomatoSlices:\\n            return [remaining // 2, cheeseSlices - (remaining // 2)]\\n\\n        return []\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1630421,
                "title": "fast-python-sol-o-1",
                "content": "```\\nclass Solution:\\n    def numOfBurgers(self, tomatoSlices: int, cheeseSlices: int) -> List[int]:\\n        x = tomatoSlices - 2 * cheeseSlices\\n        if x >= 0 and x % 2 == 0 and cheeseSlices - x // 2 >= 0:\\n            return [x // 2, cheeseSlices - x // 2]\\n        return []",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numOfBurgers(self, tomatoSlices: int, cheeseSlices: int) -> List[int]:\\n        x = tomatoSlices - 2 * cheeseSlices\\n        if x >= 0 and x % 2 == 0 and cheeseSlices - x // 2 >= 0:\\n            return [x // 2, cheeseSlices - x // 2]\\n        return []",
                "codeTag": "Java"
            },
            {
                "id": 1485768,
                "title": "c-simple-maths",
                "content": "\\n    // jumbo{4t,1c}\\n    // small{2t,1c}\\n    vector<int> numOfBurgers(int tom, int che) {\\n        int j,s;\\n        // 4*j + 2*s=tom\\n        // j+s=che \\n        \\n        if(int((tom-2*che)/2)==(double)(tom-2*che)/2)\\n        {\\n            j=(tom-2*che)/2;\\n            s=che-j;\\n            if(j>=0 && s>=0)\\n            return vector<int>{j,s};\\n        }\\n        \\n        return vector<int>();\\n    }\\n",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "\\n    // jumbo{4t,1c}\\n    // small{2t,1c}\\n    vector<int> numOfBurgers(int tom, int che) {\\n        int j,s;\\n        // 4*j + 2*s=tom\\n        // j+s=che \\n        \\n        if(int((tom-2*che)/2)==(double)(tom-2*che)/2)\\n        {\\n            j=(tom-2*che)/2;\\n            s=che-j;\\n            if(j>=0 && s>=0)\\n            return vector<int>{j,s};\\n        }\\n        \\n        return vector<int>();\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1293382,
                "title": "c-math-solution",
                "content": "Solution:\\nLet T = # of tomato slices, C = # of cheese slices, x = # of jumbo burgers, y = # of small burgers => x + y = C, 4x + 2y = T\\nSolving the system of equations we get x = (T - 2C) / 2, y = C - (T - 2C) / 2 = (4C - T) / 2\\n\\n```\\nclass Solution {\\npublic:\\n    /// 4 ms, faster than 68.27% of C++\\n    /// 7.1 MB, less than 97.21% of C++\\n    vector<int> numOfBurgers(int tomatoSlices, int cheeseSlices)\\n    {\\n        if (tomatoSlices % 2)\\n            return vector<int>();\\n        int jb = (tomatoSlices - 2*cheeseSlices) / 2;\\n        int sb = cheeseSlices - jb;\\n        if (jb < 0 || sb < 0)\\n            return vector<int>();\\n        return {jb,sb};\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    /// 4 ms, faster than 68.27% of C++\\n    /// 7.1 MB, less than 97.21% of C++\\n    vector<int> numOfBurgers(int tomatoSlices, int cheeseSlices)\\n    {\\n        if (tomatoSlices % 2)\\n            return vector<int>();\\n        int jb = (tomatoSlices - 2*cheeseSlices) / 2;\\n        int sb = cheeseSlices - jb;\\n        if (jb < 0 || sb < 0)\\n            return vector<int>();\\n        return {jb,sb}",
                "codeTag": "Java"
            },
            {
                "id": 1289712,
                "title": "simple-linear-eqn-solving-faster-than-100-java",
                "content": "```\\nclass Solution {\\n    public List<Integer> numOfBurgers(int vt, int vc) {\\n        int x=0,y=0;\\n        List<Integer> al=new ArrayList<>();\\n// 4x+2y=vt and x+y=vc =>2x=vt-2*vc=> x=vt-2*vc/2 only if x and y are pos integer its valid\\n\\n        if(vt>=2*vc&&(vt-2*vc)%2==0){\\n           x=(vt-2*vc)/2;\\n            y=vc-x; \\n            if(y>=0){\\n                al.add(x);\\n            al.add(y);\\n            }\\n        }\\n        return al;\\n        \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public List<Integer> numOfBurgers(int vt, int vc) {\\n        int x=0,y=0;\\n        List<Integer> al=new ArrayList<>();\\n// 4x+2y=vt and x+y=vc =>2x=vt-2*vc=> x=vt-2*vc/2 only if x and y are pos integer its valid\\n\\n        if(vt>=2*vc&&(vt-2*vc)%2==0){\\n           x=(vt-2*vc)/2;\\n            y=vc-x; \\n            if(y>=0){\\n                al.add(x);\\n            al.add(y);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1226554,
                "title": "java-intuitive-o-1-o-1-choose-1-type-convert",
                "content": "The idea is simple... start with all small (based on number of cheese slices), then see how many we need to convert to large to satisfy the target. If the number of conversions we need to do is negative or greater than the number of smalls we have, it cannot be done.\\n```\\nclass Solution {\\n    public List<Integer> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        if (tomatoSlices % 2 == 1) return List.of();\\n        \\n        int nSmall = cheeseSlices; // assume all small\\n        \\n        int nTomatoSlicesLeft = tomatoSlices - nSmall * 2;\\n        int nLarge = nTomatoSlicesLeft / 2;\\n        \\n        if (nLarge < 0) return List.of(); // smalls alone used more than available tomato slices\\n        if (nLarge > nSmall) return List.of(); // not enough to convert\\n        \\n        nSmall -= nLarge;\\n        \\n        return List.of(nLarge, nSmall);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        if (tomatoSlices % 2 == 1) return List.of();\\n        \\n        int nSmall = cheeseSlices; // assume all small\\n        \\n        int nTomatoSlicesLeft = tomatoSlices - nSmall * 2;\\n        int nLarge = nTomatoSlicesLeft / 2;\\n        \\n        if (nLarge < 0) return List.of(); // smalls alone used more than available tomato slices\\n        if (nLarge > nSmall) return List.of(); // not enough to convert\\n        \\n        nSmall -= nLarge;\\n        \\n        return List.of(nLarge, nSmall);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1221140,
                "title": "solving-using-linear-equation",
                "content": "```\\nclass Solution(object):\\n    def numOfBurgers(self, tomatoSlices, cheeseSlices):\\n        y = (4*cheeseSlices - tomatoSlices)\\n        if y%2==0 and y>=0:\\n            y/=2\\n            if(cheeseSlices-y>=0):\\n                return [cheeseSlices-y, y]\\n        return []\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def numOfBurgers(self, tomatoSlices, cheeseSlices):\\n        y = (4*cheeseSlices - tomatoSlices)\\n        if y%2==0 and y>=0:\\n            y/=2\\n            if(cheeseSlices-y>=0):\\n                return [cheeseSlices-y, y]\\n        return []\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1194577,
                "title": "java-0-1-time-and-o-1-space",
                "content": "Let x be the jumbo and y be the small burgers two linear equations formed will be\\n4x+2y=No.of tomato\\nx+y=No.of cheese\\nRest can be done by using simple maths\\nPlease upvote if you like the approach\\n\\n```\\n public List<Integer> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        \\n        if((tomatoSlices-2*cheeseSlices)%2!=0){\\n            return new ArrayList<>();\\n        }\\n        \\n        int jumbo=(tomatoSlices-2*cheeseSlices)/2;\\n        int small=(cheeseSlices-jumbo);\\n        \\n      \\n        \\n        List<Integer> result=new ArrayList<>();\\n        if(jumbo>=0 && small>=0){\\n        result.add(jumbo);\\n        result.add(small);\\n        return result;\\n        }\\n        else{\\n          return result;\\n        }\\n       \\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "Let x be the jumbo and y be the small burgers two linear equations formed will be\\n4x+2y=No.of tomato\\nx+y=No.of cheese\\nRest can be done by using simple maths\\nPlease upvote if you like the approach\\n\\n```\\n public List<Integer> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        \\n        if((tomatoSlices-2*cheeseSlices)%2!=0){\\n            return new ArrayList<>();\\n        }\\n        \\n        int jumbo=(tomatoSlices-2*cheeseSlices)/2;\\n        int small=(cheeseSlices-jumbo);\\n        \\n      \\n        \\n        List<Integer> result=new ArrayList<>();\\n        if(jumbo>=0 && small>=0){\\n        result.add(jumbo);\\n        result.add(small);\\n        return result;\\n        }\\n        else{\\n          return result;\\n        }\\n       \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1188000,
                "title": "easy-python-solution",
                "content": "```\\nclass Solution:\\n    def numOfBurgers(self, tomatoSlices: int, cheeseSlices: int) -> List[int]:\\n        total_jumbo = 0\\n        total_small = 0\\n        if tomatoSlices%2 != 0 or tomatoSlices < 2*cheeseSlices or tomatoSlices > 4*cheeseSlices :\\n\\t\\t\\t#checking for invalid values\\n            return []\\n        else:\\n            if tomatoSlices > 0 and cheeseSlices > 0:\\n                k = tomatoSlices % (2*cheeseSlices) #number of tomatoslices remained after making all small\\n                total_small += cheeseSlices \\n                if k > 0:\\n\\t\\t\\t\\t    #sending slices from small to jumbo\\n                    total_jumbo  = k // 2\\n                    total_small -= total_jumbo  \\n        return [total_jumbo,total_small]\\n    \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numOfBurgers(self, tomatoSlices: int, cheeseSlices: int) -> List[int]:\\n        total_jumbo = 0\\n        total_small = 0\\n        if tomatoSlices%2 != 0 or tomatoSlices < 2*cheeseSlices or tomatoSlices > 4*cheeseSlices :\\n\\t\\t\\t#checking for invalid values\\n            return []\\n        else:\\n            if tomatoSlices > 0 and cheeseSlices > 0:\\n                k = tomatoSlices % (2*cheeseSlices) #number of tomatoslices remained after making all small\\n                total_small += cheeseSlices \\n                if k > 0:\\n\\t\\t\\t\\t    #sending slices from small to jumbo\\n                    total_jumbo  = k // 2\\n                    total_small -= total_jumbo  \\n        return [total_jumbo,total_small]\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1166666,
                "title": "very-easy-greedy-approach-in-c",
                "content": "class Solution {\\npublic:\\n    vector<int> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        if(tomatoSlices%2!=0)\\n            return {};\\n        else \\n        {\\n            int k=(tomatoSlices/2-cheeseSlices);\\n                if(k<0)\\n                    return {};\\n            int p=(cheeseSlices-k);\\n                if(p<0)\\n                    return {};\\n            return {k,p};\\n        }\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        if(tomatoSlices%2!=0)\\n            return {}",
                "codeTag": "Java"
            },
            {
                "id": 1114739,
                "title": "c-binary-search-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        // Binary search: we know for sure the # of small burgers will be >= 0 && <= cheeseSlices.\\n        // So we use binary search to find out the ultimate # of small burgers.\\n        //\\n        // The condition is:\\n        // 1) if the left tomato slices and cheese slices can make exact N # of jumbos, return the result.\\n        // 2) if the left tomato slices is not enough to make exact # of jumbos, we need to make more small\\n        //    burgers and less jumbo burgers, hence search from mid + 1 to right.\\n        // 3) if left cheese slices is not enough to make exact # of jumbos, we need to make less small burgers\\n        //    and more jumbo burgers, hence search from left to mid - 1.\\n        return numOfBurgers(tomatoSlices, cheeseSlices, 0, cheeseSlices);\\n    }\\n    \\nprivate:\\n    vector<int> numOfBurgers(int tomatoSlices, int cheeseSlices, int left, int right)\\n    {\\n        if (left > right)\\n        {\\n            return {};\\n        }\\n        \\n        int mid = left + (right - left) / 2; \\n        int leftTomatoes = tomatoSlices - mid * 2;\\n        int leftCheeses = cheeseSlices - mid;\\n        \\n        if (leftCheeses * 4 == leftTomatoes)\\n        {\\n            return {leftCheeses, mid};\\n        }\\n        \\n        if (leftCheeses * 4 < leftTomatoes)\\n        {\\n            return numOfBurgers(tomatoSlices, cheeseSlices, left, mid - 1);\\n        }\\n        \\n        return numOfBurgers(tomatoSlices, cheeseSlices, mid + 1, right);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        // Binary search: we know for sure the # of small burgers will be >= 0 && <= cheeseSlices.\\n        // So we use binary search to find out the ultimate # of small burgers.\\n        //\\n        // The condition is:\\n        // 1) if the left tomato slices and cheese slices can make exact N # of jumbos, return the result.\\n        // 2) if the left tomato slices is not enough to make exact # of jumbos, we need to make more small\\n        //    burgers and less jumbo burgers, hence search from mid + 1 to right.\\n        // 3) if left cheese slices is not enough to make exact # of jumbos, we need to make less small burgers\\n        //    and more jumbo burgers, hence search from left to mid - 1.\\n        return numOfBurgers(tomatoSlices, cheeseSlices, 0, cheeseSlices);\\n    }\\n    \\nprivate:\\n    vector<int> numOfBurgers(int tomatoSlices, int cheeseSlices, int left, int right)\\n    {\\n        if (left > right)\\n        {\\n            return {};\\n        }\\n        \\n        int mid = left + (right - left) / 2; \\n        int leftTomatoes = tomatoSlices - mid * 2;\\n        int leftCheeses = cheeseSlices - mid;\\n        \\n        if (leftCheeses * 4 == leftTomatoes)\\n        {\\n            return {leftCheeses, mid};\\n        }\\n        \\n        if (leftCheeses * 4 < leftTomatoes)\\n        {\\n            return numOfBurgers(tomatoSlices, cheeseSlices, left, mid - 1);\\n        }\\n        \\n        return numOfBurgers(tomatoSlices, cheeseSlices, mid + 1, right);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1039997,
                "title": "easy-c-with-comments-linear-equations",
                "content": "Jumbo Burgers: 4 Tomatoes + 1 CheeseSlice\\nSmall Burgers: 2 Tomatoes + 1 CheeseSlice\\n\\nb = Jumbo Burgers, s = Small burgers\\n\\nThe two equations are\\n4*b + 2*s = Total no. of TomatoSlices\\nb + s = Total no. of CheeseSlices\\n\\n**if no. TomatoSlices is odd then no solution possible**\\n\\nsolving them we get-\\n\\n**Jumbo Burgers = TomatoSlices/2 - cheeseSlices\\nSmall Burgers = 2*CheeseSlices - TomatoSlices/2**\\n\\n```\\nvector<int> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        if(tomatoSlices%2 != 0) // base case\\n            return {};\\n        \\n        tomatoSlices /=2;\\n        int b=tomatoSlices - cheeseSlices, s= 2*cheeseSlices - tomatoSlices;\\n        \\n        if(b < 0 || s < 0) // if b or s comes out to be negative\\n            return {};\\n        \\n        return {b, s};\\n    }\\n",
                "solutionTags": [],
                "code": "Jumbo Burgers: 4 Tomatoes + 1 CheeseSlice\\nSmall Burgers: 2 Tomatoes + 1 CheeseSlice\\n\\nb = Jumbo Burgers, s = Small burgers\\n\\nThe two equations are\\n4*b + 2*s = Total no. of TomatoSlices\\nb + s = Total no. of CheeseSlices\\n\\n**if no. TomatoSlices is odd then no solution possible**\\n\\nsolving them we get-\\n\\n**Jumbo Burgers = TomatoSlices/2 - cheeseSlices\\nSmall Burgers = 2*CheeseSlices - TomatoSlices/2**\\n\\n```\\nvector<int> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        if(tomatoSlices%2 != 0) // base case\\n            return {};\\n        \\n        tomatoSlices /=2;\\n        int b=tomatoSlices - cheeseSlices, s= 2*cheeseSlices - tomatoSlices;\\n        \\n        if(b < 0 || s < 0) // if b or s comes out to be negative\\n            return {};\\n        \\n        return {b, s};\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1029915,
                "title": "simple-linear-equation-solution",
                "content": "Lets say we take x jumbo and y small burgers so we can say that:\\n```\\n\\tx + y = cheese_slices\\n\\t\\n\\t4x + y = tomato_slices\\n\\t\\n```\\n\\nOn solving the 2 linear equation we only want +ve solutions\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int ts, int cs){\\n        if(ts%2)\\n            return {};\\n        if(ts/2 < cs || 2*cs < ts/2)\\n            return {};      \\n        int jmb = (ts - 2*cs)/2;\\n        int sml = (2*cs - ts/2);\\n        return {jmb, sml};\\n    }\\n};\\n```\\n\\t\\t\\n\\t\\t",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n\\tx + y = cheese_slices\\n\\t\\n\\t4x + y = tomato_slices\\n\\t\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int ts, int cs){\\n        if(ts%2)\\n            return {};\\n        if(ts/2 < cs || 2*cs < ts/2)\\n            return {};      \\n        int jmb = (ts - 2*cs)/2;\\n        int sml = (2*cs - ts/2);\\n        return {jmb, sml};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 909355,
                "title": "c-o-1-solution",
                "content": "class Solution {\\npublic:\\n    vector<int> numOfBurgers(int t, int c) {\\n        vector<int> v;\\n        if(4*c<t) return v;\\n        if((4*c-t)%2!=0) return v;\\n        \\n        int x = (4*c-t)/2;\\n        if(c-x<0) return v;\\n        v.push_back(c-x);\\n        v.push_back(x);\\n        return v;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> numOfBurgers(int t, int c) {\\n        vector<int> v;\\n        if(4*c<t) return v;\\n        if((4*c-t)%2!=0) return v;\\n        \\n        int x = (4*c-t)/2;\\n        if(c-x<0) return v;\\n        v.push_back(c-x);\\n        v.push_back(x);\\n        return v;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 903002,
                "title": "c-simple-maths-explanation-0ms",
                "content": "Solving Equations:\\nLet no of big burgers be X,\\nLet no of small burgers be Y,\\nthen,\\n4X + 2Y=T             (i)\\nX + Y=C         (ii)\\nfrom (ii),          Y=C-X\\n4X + 2 (C-X) =T\\n4X + 2C - 2X=T\\n2X + 2C=T\\nX=(T - 2C) / 2        : where T= tomatoslices and C= cheeseslices which is given.\\n& Y= C-X\\nhence {X,Y} is the answer.\\t\\t   \\n```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        if(tomatoSlices%2!=0)\\n            return {};\\n        if(cheeseSlices<tomatoSlices/4)\\n            return {};\\n        if(cheeseSlices>tomatoSlices/2)\\n            return {};\\n        int x=(tomatoSlices-(2*cheeseSlices))/2;\\n        int y=cheeseSlices-x;\\n        return {x,y};\\n    }\\n};\\n```\\nPlease Upvote if you like!!!",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        if(tomatoSlices%2!=0)\\n            return {};\\n        if(cheeseSlices<tomatoSlices/4)\\n            return {};\\n        if(cheeseSlices>tomatoSlices/2)\\n            return {};\\n        int x=(tomatoSlices-(2*cheeseSlices))/2;\\n        int y=cheeseSlices-x;\\n        return {x,y};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 849216,
                "title": "python3-gaussian-elimination",
                "content": "```\\ndef gaussianElimination(m):\\n    r, c = len(m), len(m[0])\\n    for i in range(r):\\n        # if m[i][i] is 0, find j that m[j][i] != 0 and exchange rows i and j.\\n        for j in range(i, r):\\n            if m[j][i] != 0:\\n                m[i], m[j] = m[j], m[i]\\n                break\\n        # no solution.\\n        if m[i][i] == 0:\\n            return []\\n        # do row reduction for every row, so we don\\'t need back substitution.\\n        for j in range(r):\\n            if j == i: continue\\n            diff = - m[j][i] / m[i][i]\\n            for k in range(c):\\n                m[j][k] += diff * m[i][k]\\n    return [m[i][-1] / m[i][i] for i in range(r)]\\n\\ndef normalize(res):\\n    r = [int(x) for x in res if x >= 0 and abs(x - int(x)) < 0.000001]\\n    if len(r) != len(res):\\n        return []\\n    return r\\n\\nclass Solution:\\n    def numOfBurgers(self, t: int, c: int) -> List[int]:\\n        res = gaussianElimination([[4, 2, t], [1, 1, c]])\\n        return normalize(res)\\n```",
                "solutionTags": [
                    "Matrix"
                ],
                "code": "```\\ndef gaussianElimination(m):\\n    r, c = len(m), len(m[0])\\n    for i in range(r):\\n        # if m[i][i] is 0, find j that m[j][i] != 0 and exchange rows i and j.\\n        for j in range(i, r):\\n            if m[j][i] != 0:\\n                m[i], m[j] = m[j], m[i]\\n                break\\n        # no solution.\\n        if m[i][i] == 0:\\n            return []\\n        # do row reduction for every row, so we don\\'t need back substitution.\\n        for j in range(r):\\n            if j == i: continue\\n            diff = - m[j][i] / m[i][i]\\n            for k in range(c):\\n                m[j][k] += diff * m[i][k]\\n    return [m[i][-1] / m[i][i] for i in range(r)]\\n\\ndef normalize(res):\\n    r = [int(x) for x in res if x >= 0 and abs(x - int(x)) < 0.000001]\\n    if len(r) != len(res):\\n        return []\\n    return r\\n\\nclass Solution:\\n    def numOfBurgers(self, t: int, c: int) -> List[int]:\\n        res = gaussianElimination([[4, 2, t], [1, 1, c]])\\n        return normalize(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 844915,
                "title": "simple-math",
                "content": "```java\\n/*\\n* 4x + 2y = tomato\\n* 1*x + 1*y = cheese\\n*/\\nclass Solution {\\n    public List<Integer> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        int jumbo = tomatoSlices/2-cheeseSlices;\\n        int small = cheeseSlices - jumbo;\\n        if (jumbo < 0 || small < 0 || tomatoSlices%2 == 1) {\\n            return Collections.emptyList();\\n        }\\n        return Arrays.asList(jumbo, small);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\n/*\\n* 4x + 2y = tomato\\n* 1*x + 1*y = cheese\\n*/\\nclass Solution {\\n    public List<Integer> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        int jumbo = tomatoSlices/2-cheeseSlices;\\n        int small = cheeseSlices - jumbo;\\n        if (jumbo < 0 || small < 0 || tomatoSlices%2 == 1) {\\n            return Collections.emptyList();\\n        }\\n        return Arrays.asList(jumbo, small);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 733966,
                "title": "c-simple-5-line-sol",
                "content": "**Explanation** : Let\\'s assume \\n`x` be the *number of Jumbo Burgers* \\n`y` be the *number of Small Burger*. \\nSo total tomatoSlices used will be given by equation (ts) : \\n`ts` : ***4x+2y***\\nTotal CheeseSlices used (cs) : \\n`cs` : ***x + y***\\n\\nSolving the following would give us x = `ts-2*cs/2`\\nIf any of x and y is negative then it\\'s not possible to make `ts and cs` as 0.\\nand if total ts obtained after using x and y is <0 or >0 then also the answer won\\'t exist.\\nReturn `{}` in those cases else return `{x,y}`\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int ts, int cs) {\\n        int x = (ts- 2*cs)/2;\\n        int y = cs- x;\\n        if(x <0 || y<0) return {};\\n        if(4*x + 2*y < ts || 4*x + 2*y > ts) return {};  \\n        return {x,y};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int ts, int cs) {\\n        int x = (ts- 2*cs)/2;\\n        int y = cs- x;\\n        if(x <0 || y<0) return {};\\n        if(4*x + 2*y < ts || 4*x + 2*y > ts) return {};  \\n        return {x,y};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 733241,
                "title": "python-math-solution",
                "content": "X: Big burger Y: small burger\\n\\n4X + 2Y = T \\nX+Y = C\\n\\n=> X = T/2-C, Y = 2C-T/2 , both X and Y need > 0 , so \\n```\\nif tomatoSlices < 2*cheeseSlices or tomatoSlices > 4*cheeseSlices:\\n            return []\\n```\\n\\nSource \\n\\n```\\nclass Solution(object):\\n    def numOfBurgers(self, tomatoSlices, cheeseSlices):\\n        \"\"\"\\n        :type tomatoSlices: int\\n        :type cheeseSlices: int\\n        :rtype: List[int]\\n        \"\"\"\\n        if tomatoSlices%2 == 1:\\n            return []\\n        \\n        if tomatoSlices < 2*cheeseSlices or tomatoSlices > 4*cheeseSlices:\\n            return []\\n        \\n        return [tomatoSlices/2-cheeseSlices, 2*cheeseSlices-tomatoSlices/2]\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nif tomatoSlices < 2*cheeseSlices or tomatoSlices > 4*cheeseSlices:\\n            return []\\n```\n```\\nclass Solution(object):\\n    def numOfBurgers(self, tomatoSlices, cheeseSlices):\\n        \"\"\"\\n        :type tomatoSlices: int\\n        :type cheeseSlices: int\\n        :rtype: List[int]\\n        \"\"\"\\n        if tomatoSlices%2 == 1:\\n            return []\\n        \\n        if tomatoSlices < 2*cheeseSlices or tomatoSlices > 4*cheeseSlices:\\n            return []\\n        \\n        return [tomatoSlices/2-cheeseSlices, 2*cheeseSlices-tomatoSlices/2]\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 534759,
                "title": "java-this-question-should-be-under-easy",
                "content": "```\\nclass Solution {\\n    public List<Integer> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        List<Integer> res = new ArrayList<>();\\n        if(tomatoSlices % 2 == 1){\\n            return res;\\n        }\\n\\n        int smallCount = cheeseSlices*2;\\n        int extra = tomatoSlices - smallCount;\\n        if(extra >= 0) {\\n            int jumboCount = extra / 2;\\n\\n            if(cheeseSlices >= jumboCount) {\\n                res.add(jumboCount);\\n                res.add(cheeseSlices - jumboCount);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        List<Integer> res = new ArrayList<>();\\n        if(tomatoSlices % 2 == 1){\\n            return res;\\n        }\\n\\n        int smallCount = cheeseSlices*2;\\n        int extra = tomatoSlices - smallCount;\\n        if(extra >= 0) {\\n            int jumboCount = extra / 2;\\n\\n            if(cheeseSlices >= jumboCount) {\\n                res.add(jumboCount);\\n                res.add(cheeseSlices - jumboCount);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 488609,
                "title": "rust-4ms-and-1-9mb-100",
                "content": "Solve it use math directly\\n\\n```rust\\n// [tomato_slices /2 - cheese_slices, 2 * cheese_slices - tomato_slices / 2]  tomato_slices should be even\\npub fn num_of_burgers(tomato_slices: i32, cheese_slices: i32) -> Vec<i32> {\\n    if tomato_slices % 2 != 0 { return Vec::<i32>::new(); }\\n    let x = tomato_slices / 2 - cheese_slices;\\n    let y = 2 * cheese_slices - tomato_slices / 2;\\n    if x < 0 || y < 0 { return Vec::<i32>::new(); };\\n    vec![x, y]\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```rust\\n// [tomato_slices /2 - cheese_slices, 2 * cheese_slices - tomato_slices / 2]  tomato_slices should be even\\npub fn num_of_burgers(tomato_slices: i32, cheese_slices: i32) -> Vec<i32> {\\n    if tomato_slices % 2 != 0 { return Vec::<i32>::new(); }\\n    let x = tomato_slices / 2 - cheese_slices;\\n    let y = 2 * cheese_slices - tomato_slices / 2;\\n    if x < 0 || y < 0 { return Vec::<i32>::new(); };\\n    vec![x, y]\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 444801,
                "title": "i-psyched-myself-out-so-i-came-up-with-a-python-binary-search-solution-88-faster",
                "content": "Is this overkill?\\n\\n```\\ndef numOfBurgers(self, tomatoSlices: int, cheeseSlices: int) -> List[int]:\\n\\tif tomatoSlices % 2 == 1:\\n\\t\\treturn []\\n\\n\\tst = 0\\n\\ten = cheeseSlices\\n\\n\\twhile(st < en):\\n\\t\\thalf = st + math.floor((en - st) / 2)\\n\\n\\t\\tsm = (half * 4) + ((cheeseSlices-half)*2)\\n\\t\\tif sm == tomatoSlices:\\n\\t\\t\\treturn [half, cheeseSlices-half]\\n\\n\\t\\tif sm < tomatoSlices:\\n\\t\\t\\tst = half+1\\n\\t\\telse:\\n\\t\\t\\ten = half\\n\\n\\tif cheeseSlices * 4 == tomatoSlices:\\n\\t\\treturn [cheeseSlices, 0]\\n\\n\\treturn []\\n```",
                "solutionTags": [],
                "code": "```\\ndef numOfBurgers(self, tomatoSlices: int, cheeseSlices: int) -> List[int]:\\n\\tif tomatoSlices % 2 == 1:\\n\\t\\treturn []\\n\\n\\tst = 0\\n\\ten = cheeseSlices\\n\\n\\twhile(st < en):\\n\\t\\thalf = st + math.floor((en - st) / 2)\\n\\n\\t\\tsm = (half * 4) + ((cheeseSlices-half)*2)\\n\\t\\tif sm == tomatoSlices:\\n\\t\\t\\treturn [half, cheeseSlices-half]\\n\\n\\t\\tif sm < tomatoSlices:\\n\\t\\t\\tst = half+1\\n\\t\\telse:\\n\\t\\t\\ten = half\\n\\n\\tif cheeseSlices * 4 == tomatoSlices:\\n\\t\\treturn [cheeseSlices, 0]\\n\\n\\treturn []\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 441479,
                "title": "python-time-o-1-100-0-space-o-1-100-0-full-explain",
                "content": "For explain, please see comments.\\nI just want to say... who will buy a jumbo burger that only have more tomato? Seriousely?\\n\\n\\n```\\n# Dev: Chumicat\\n# Date: 2019/12/1\\n# Submission: https://leetcode.com/submissions/detail/282876212/\\n# (Time, Space) Complexity : O(1), O(1)\\n\\nclass Solution:\\n    def numOfBurgers(self, tomatoSlices: int, cheeseSlices: int) -> List[int]:\\n        \"\"\"\\n        :type tomatoSlices: int\\n        :type cheeseSlices: int\\n        :rtype: List[int]\\n        \"\"\"\\n        # Its a simple binary simultaneous equations\\n        # We have:\\n        #   f1: 4x+2y = tomatoSlices\\n        #   f2: x+y = cheeseSlices\\n        # Get x (total_jumbo):\\n        #   2x = (4x+2y) - (2x+2y)\\n        #      = f1 - 2*f2\\n        #      = tomatoSlices - 2*cheeseSlices\\n        #    x = 0.5*tomatoSlices - cheeseSlices\\n        # Get y (total_small):\\n        #    y = f1 - x\\n        #      = cheeseSlices - x \\n        #      = cheeseSlices - (0.5*tomatoSlices - cheeseSlices)\\n        #    y = -0.5*tomatoSlices + 2*cheeseSlices\\n        # Note:\\n        #   We solve the function, but its answer might not fit in this case\\n        #   1. We can\\'t sell half burger\\n        #   2. We can\\'t sell negative burger\\n        #   3. According to (1) and (2), x and y must be natural number (0 included)\\n        #   4. We didn\\'t need to worry about error in float, because it just divide by 2,\\n        #      which means there will no error occur in this situation\\n        x =  0.5*tomatoSlices -   cheeseSlices\\n        y = -0.5*tomatoSlices + 2*cheeseSlices\\n        \\n        if not x.is_integer() or not y.is_integer() or x < 0 or y < 0:\\n            return []\\n        else:\\n            return[int(x), int(y)]\\n```\\n\\nIf you really didn\\'t want to use float, well by add a check, we can use only integer\\nAnd if your are crazy, so you decide not to use any divide or multiply, well, use shift\\nBut this way will let code not let clean since we seperate the return place\\n```python\\n# Dev: Chumicat\\n# Date: 2019/12/1\\n# Submission: https://leetcode.com/submissions/detail/282877921/\\n# (Time, Space) Complexity : O(1), O(1)\\n\\nclass Solution:\\n    def numOfBurgers(self, tomatoSlices: int, cheeseSlices: int) -> List[int]:\\n        \"\"\"\\n        :type tomatoSlices: int\\n        :type cheeseSlices: int\\n        :rtype: List[int]\\n        \"\"\"\\n        # Only tomatoSlices need to be divide\\n        # You can also check this first\\n        if tomatoSlices & 1: return []\\n        \\n        x =  (tomatoSlices>>1) - (cheeseSlices)\\n        y = -(tomatoSlices>>1) + (cheeseSlices<<1)\\n        \\n        if x < 0 or y < 0:\\n            return []\\n        else:\\n            return [x, y]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n# Dev: Chumicat\\n# Date: 2019/12/1\\n# Submission: https://leetcode.com/submissions/detail/282876212/\\n# (Time, Space) Complexity : O(1), O(1)\\n\\nclass Solution:\\n    def numOfBurgers(self, tomatoSlices: int, cheeseSlices: int) -> List[int]:\\n        \"\"\"\\n        :type tomatoSlices: int\\n        :type cheeseSlices: int\\n        :rtype: List[int]\\n        \"\"\"\\n        # Its a simple binary simultaneous equations\\n        # We have:\\n        #   f1: 4x+2y = tomatoSlices\\n        #   f2: x+y = cheeseSlices\\n        # Get x (total_jumbo):\\n        #   2x = (4x+2y) - (2x+2y)\\n        #      = f1 - 2*f2\\n        #      = tomatoSlices - 2*cheeseSlices\\n        #    x = 0.5*tomatoSlices - cheeseSlices\\n        # Get y (total_small):\\n        #    y = f1 - x\\n        #      = cheeseSlices - x \\n        #      = cheeseSlices - (0.5*tomatoSlices - cheeseSlices)\\n        #    y = -0.5*tomatoSlices + 2*cheeseSlices\\n        # Note:\\n        #   We solve the function, but its answer might not fit in this case\\n        #   1. We can\\'t sell half burger\\n        #   2. We can\\'t sell negative burger\\n        #   3. According to (1) and (2), x and y must be natural number (0 included)\\n        #   4. We didn\\'t need to worry about error in float, because it just divide by 2,\\n        #      which means there will no error occur in this situation\\n        x =  0.5*tomatoSlices -   cheeseSlices\\n        y = -0.5*tomatoSlices + 2*cheeseSlices\\n        \\n        if not x.is_integer() or not y.is_integer() or x < 0 or y < 0:\\n            return []\\n        else:\\n            return[int(x), int(y)]\\n```\n```python\\n# Dev: Chumicat\\n# Date: 2019/12/1\\n# Submission: https://leetcode.com/submissions/detail/282877921/\\n# (Time, Space) Complexity : O(1), O(1)\\n\\nclass Solution:\\n    def numOfBurgers(self, tomatoSlices: int, cheeseSlices: int) -> List[int]:\\n        \"\"\"\\n        :type tomatoSlices: int\\n        :type cheeseSlices: int\\n        :rtype: List[int]\\n        \"\"\"\\n        # Only tomatoSlices need to be divide\\n        # You can also check this first\\n        if tomatoSlices & 1: return []\\n        \\n        x =  (tomatoSlices>>1) - (cheeseSlices)\\n        y = -(tomatoSlices>>1) + (cheeseSlices<<1)\\n        \\n        if x < 0 or y < 0:\\n            return []\\n        else:\\n            return [x, y]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 441458,
                "title": "javascript-solution-math",
                "content": "Since both kinds of burgers require 1 cheese slice, in total there has to be ```cheeseSlices``` number of burgers.\\n```\\n4jumbo + 2small = tomatoSlices (1)\\njumbo + small = cheeseSlices\\nOR \\n2jumbo + 2small = 2cheeseSlices (2)\\n\\nSubtracting (2) from (1) we have:\\n2jumbo = tomatoSlices - 2cheeseSlices\\n\\njumbo = (tomatoSlices - 2cheeseSlices) / 2\\nsmall = cheeseSlices - jumbo\\n```\\nAnd of course both of them have to be integers >= 0\\n```\\nvar numOfBurgers = function(tomatoSlices, cheeseSlices) {\\n  let jumbo = (tomatoSlices - 2 * cheeseSlices) / 2;\\n  let small = cheeseSlices - jumbo;\\n  return jumbo >= 0 && small >= 0 && jumbo % 1 == 0 ? [jumbo, small] : [];\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript",
                    "Math"
                ],
                "code": "```cheeseSlices```\n```\\n4jumbo + 2small = tomatoSlices (1)\\njumbo + small = cheeseSlices\\nOR \\n2jumbo + 2small = 2cheeseSlices (2)\\n\\nSubtracting (2) from (1) we have:\\n2jumbo = tomatoSlices - 2cheeseSlices\\n\\njumbo = (tomatoSlices - 2cheeseSlices) / 2\\nsmall = cheeseSlices - jumbo\\n```\n```\\nvar numOfBurgers = function(tomatoSlices, cheeseSlices) {\\n  let jumbo = (tomatoSlices - 2 * cheeseSlices) / 2;\\n  let small = cheeseSlices - jumbo;\\n  return jumbo >= 0 && small >= 0 && jumbo % 1 == 0 ? [jumbo, small] : [];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 441304,
                "title": "straightforward-math-solution-detailed",
                "content": "Since we are given the total number of cheese and tomato slices along with the cost for creating a jumbo and small burger we can setup a system of equations quite easily by noting that:\\n```\\ncheeseSlices = numJumboBurgers * (cheeseSlice/JumboBurger) + numSmallBurgers * (cheeseSlice/SmallBurger)\\ntomatoSlices = numJumboBurgers * (tomatoSlice/JumboBurger) + numSmallBurgers * (tomatoSlice/SmallBurger)\\n```\\n\\nNow we are given that cheeseSlice/JumboBurger = 1, cheeseSlice/SmallBurger = 1, tomatoSlice/JumboBurger = 4, tomatoSlice/SmallBurger = 2. \\n\\nFor simplicity let X = numJumboBurgers and Y = numSmallBurgers, then our system of equations becomes:\\n\\n```\\ncheeseSlices = X * 1 + Y * 1 => Y = cheeseSlices - X\\ntomatoSlices = X * 4 + Y * 2 => tomatoSlices = 4X + 2 * (cheeseSlices - X) = 2X + 2 * cheeseSlices\\n```\\n\\nTherefore, ```X = (tomatoSlices - 2 * cheeseSlices) / 2``` and this can be substituted into\\n```Y = cheeseSlices - X``` to find Y.\\n\\nNow to ensure the solution is valid we must enforce that X and Y are positive integers. This leads to the constraints: X >= 0, Y >= 0, and X * 4 + Y * 2 == tomatoSlices (Last equality verifies that there was no remainder during the divisions)\\n\\nCode:\\n```Java\\npublic List<Integer> numOfBurgers(int tomatoSlices, int cheeseSlices) \\n{\\n\\tList<Integer> ans = new ArrayList<Integer>();\\n\\n\\tint X = (tomatoSlices - 2 * cheeseSlices) / 2;\\n\\tint Y = cheeseSlices - X;\\n\\n\\tif (X * 4 + Y * 2 == tomatoSlices && X >= 0 && Y >= 0)\\n\\t{\\n\\t\\tans.add(X);\\n\\t\\tans.add(Y);\\n\\t}\\n\\n\\treturn ans;\\n}\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\ncheeseSlices = numJumboBurgers * (cheeseSlice/JumboBurger) + numSmallBurgers * (cheeseSlice/SmallBurger)\\ntomatoSlices = numJumboBurgers * (tomatoSlice/JumboBurger) + numSmallBurgers * (tomatoSlice/SmallBurger)\\n```\n```\\ncheeseSlices = X * 1 + Y * 1 => Y = cheeseSlices - X\\ntomatoSlices = X * 4 + Y * 2 => tomatoSlices = 4X + 2 * (cheeseSlices - X) = 2X + 2 * cheeseSlices\\n```\n```X = (tomatoSlices - 2 * cheeseSlices) / 2```\n```Y = cheeseSlices - X```\n```Java\\npublic List<Integer> numOfBurgers(int tomatoSlices, int cheeseSlices) \\n{\\n\\tList<Integer> ans = new ArrayList<Integer>();\\n\\n\\tint X = (tomatoSlices - 2 * cheeseSlices) / 2;\\n\\tint Y = cheeseSlices - X;\\n\\n\\tif (X * 4 + Y * 2 == tomatoSlices && X >= 0 && Y >= 0)\\n\\t{\\n\\t\\tans.add(X);\\n\\t\\tans.add(Y);\\n\\t}\\n\\n\\treturn ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4083615,
                "title": "linear-equation-basic-mathematics-o-1-method",
                "content": "# Intuition\\n   BY USING BASIC QUADRATIC MATHEMATICS\\n\\n# Approach\\n    Let the number of jumbo burgers be x and no of small burgers be y\\n    So according to the question:\\n         4*(x)+2*(y)=TomatoSlices\\n         x+y = CheeseSlices\\n    On solving the values for x,y for the given 2 equations:\\n    x = (tomatoSlices/2-cheeseSlices)\\n    y = (2*(cheeseSlices)-TomatoSlices//2)\\n    By looking at the above two equations,we can infer that:\\n       tomatoSlices must be a even number \\n       and Both x,y must be zero\\n\\n# Complexity\\n- Time complexity:O(1)\\n      \\n\\n- Space complexity: O(1)\\n      \\n\\n# Code\\n```\\nclass Solution(object):\\n    def numOfBurgers(self, tomatoSlices, cheeseSlices):\\n       if tomatoSlices<cheeseSlices:\\n           return []\\n       if tomatoSlices%2!=0:\\n           return []\\n       if (2*(cheeseSlices)-(tomatoSlices)//2)<0 or (tomatoSlices//2-cheeseSlices)<0:\\n           return []\\n       return [(tomatoSlices//2-cheeseSlices),(2*(cheeseSlices)-(tomatoSlices)//2)]\\n       \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def numOfBurgers(self, tomatoSlices, cheeseSlices):\\n       if tomatoSlices<cheeseSlices:\\n           return []\\n       if tomatoSlices%2!=0:\\n           return []\\n       if (2*(cheeseSlices)-(tomatoSlices)//2)<0 or (tomatoSlices//2-cheeseSlices)<0:\\n           return []\\n       return [(tomatoSlices//2-cheeseSlices),(2*(cheeseSlices)-(tomatoSlices)//2)]\\n       \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4027157,
                "title": "0-ms-100-solution-o-1-time-and-space",
                "content": "# Intuition\\n\\nThe problem can be turned into **pair of linear equations** with two variables, whose solution always exists(fortunately).\\n\\n# Approach\\nJust check if the solution of the equations are whole numbers(no of burgers cant be negative or fraction...0 is allowed tho).\\n\\nLets assume we can make \\'x\\' jumbo and \\'y\\' small burgers.\\nFor perfect case(where no slices are left off):\\n\\n## 1. 4*x+2*y=a    //a is total tomato slices given\\n## 2. x+y=b        //b is total cheese slices given\\n\\nMultiply (2) by 2 and then subtract it from 1.\\n\\nYou can the following results for x,y in terms of a and b:\\n## x=(a-2*b)/2;\\n## y=(4*b-a)/2;\\n\\nNow you know...\\n\\n# Complexity\\n- Time complexity:\\nO(1).\\n\\n- Space complexity:\\nO(1)   //Size 2(constant) array to return the output,\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        int a=tomatoSlices;\\n        int b=cheeseSlices;\\n        int x=a-2*b;    //x being no of twice of jumbo burgers that can be made\\n        int y=4*b-a;    //y being no of twice of small burgers that can be made\\n        if(x>=0&&y>=0&&(x%2==0)&&(y%2==0))  //check whether x and y are whole nubers\\n        {\\n            return {x/2,y/2};\\n        }\\n        return {};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        int a=tomatoSlices;\\n        int b=cheeseSlices;\\n        int x=a-2*b;    //x being no of twice of jumbo burgers that can be made\\n        int y=4*b-a;    //y being no of twice of small burgers that can be made\\n        if(x>=0&&y>=0&&(x%2==0)&&(y%2==0))  //check whether x and y are whole nubers\\n        {\\n            return {x/2,y/2};\\n        }\\n        return {};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4027057,
                "title": "matrix-mathematics",
                "content": "# Intuition\\nAfter reading through the hints, the solution is apparent with a bit of matrix mathematics. To start, we can see that we have a system with two equations and two unknowns, so we know we have a singular satisfiable answer. To work from this, we then can approach in the following manner. \\n\\n1) Set up you system of equations for jumbo and small burgers \\n    a. Jumbo as J, Tomato as T, CheeseSlices as C, then \\n    b. J = 4 * T + 1 * C \\n    c. S = 2 * T + 1 * C \\n2) We need the dual form of the above, so we conduct a shift to a system based on T and C instead of J and S by using the columns \\n    a. T = 4J + 2S \\n    b. C = 1J + 1S \\n3) From here, we conduct row matrix reductions to do the following \\n    a. Note that twice of 2b from 2a yields 2J = T - 2C \\n    b. Reduce this to J = T/2 - C \\n    c. Use 3b to find S = 2C - T/2 \\n4) Consider extrema points that will violate this; these are odd tomato slices, areas where C is greater than 2 * C and any instances of negative J or S (can\\'t make negative burgers). Code these in as boolean offshoots of the main process. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWith the intuition thus laid out, we can solve as follows \\n- Handle your extrema cases outside of calculations first (too much cheese, odd tomato slices) \\n- calculate J (if negative, return []) \\n- calculate S (if negative, return []) \\n- otherwise return [J, S]\\n\\n# Complexity\\n- Time complexity : 10 operations\\nOur time complexity is bounded very nicely by doing the math by hand before starting. Otherwise, we would have on the order of n^2 for row reduction matrix mathematics at best. As a nice system, we have in total \\n    - 2 multiplication, 2 subtractions, 1 division, 1 modulo and 4 comparisons = 10 operations. \\n\\n- Space complexity : O(1) \\n    - 3 variables are used which falls to O(1)  \\n\\n# Code\\n```\\nclass Solution:\\n    def numOfBurgers(self, tomatoSlices: int, cheeseSlices: int) -> List[int]:\\n        if cheeseSlices > 2 * tomatoSlices : \\n            return [] \\n        elif tomatoSlices % 2 : \\n            return [] \\n        else : \\n            T2 = tomatoSlices//2 \\n            J = T2 - cheeseSlices \\n            if J < 0 : \\n                return [] \\n            S = 2 * cheeseSlices - T2\\n            return [] if S < 0 else [J, S]\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numOfBurgers(self, tomatoSlices: int, cheeseSlices: int) -> List[int]:\\n        if cheeseSlices > 2 * tomatoSlices : \\n            return [] \\n        elif tomatoSlices % 2 : \\n            return [] \\n        else : \\n            T2 = tomatoSlices//2 \\n            J = T2 - cheeseSlices \\n            if J < 0 : \\n                return [] \\n            S = 2 * cheeseSlices - T2\\n            return [] if S < 0 else [J, S]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3985771,
                "title": "beats-100-very-clean-solution-explained",
                "content": "# Complexity\\n- Time complexity: $$O(1)$$\\n\\n- Space complexity: $$O(1)$$ \\n\\n```\\nLet there be x JUMBO burgers and \\'y\\' SMALL burgers\\nJumbo Burger => 4*x tomato slices and 1*x cheese slice.\\nSmall Burger => 2*y tomato slices and 1*y cheese slice.\\n\\n4*x + 2*y = tomatoSlices  \\n1*x + 1*y = cheeseSlices\\n\\n4*x + 2*y = t \\n1*x + 1*y = c\\n _         _ _    _     _   _\\n|  4    2  ||  x  |  = |  t  |\\n|_ 1    1 _||_ y _|    |_ c _|\\n\\n_     _     _      _ -1 _   _\\n|  x  |  = |  4  2  |  |  t  |\\n|_ y _|    |_ 1  1 _|  |_ c _|\\n\\n_     _      1    _      _  _   _\\n|  x  |  =  ---  |  1  -2  ||  t  |\\n|_ y _|     |d|  |_-1   4 _||_ c _|\\n\\n_     _      1    _      _  _   _\\n|  x  |  =  ---  |  1  -2  ||  t  |\\n|_ y _|     |2|  |_-1   4 _||_ c _|\\n\\n_     _       _            _\\n|  x  |  =   | ( t - 2c)/2  |\\n|_ y _|      |_(-t + 4c)/2 _|\\n\\nfor valid cases, both x and y should be positive and integers\\n\\n```\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        int t = tomatoSlices, c = cheeseSlices;\\n\\n         double ans1 = (t-2*c)/2.0, ans2 = (4*c - t)/2.0;\\n        if(ans1 >= 0 && ans2 >= 0 && ans1 == int(ans1) && ans2 == int(ans2))\\n          return {int(ans1),int(ans2)};\\n\\n    return {};\\n    }\\n};         \\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nLet there be x JUMBO burgers and \\'y\\' SMALL burgers\\nJumbo Burger => 4*x tomato slices and 1*x cheese slice.\\nSmall Burger => 2*y tomato slices and 1*y cheese slice.\\n\\n4*x + 2*y = tomatoSlices  \\n1*x + 1*y = cheeseSlices\\n\\n4*x + 2*y = t \\n1*x + 1*y = c\\n _         _ _    _     _   _\\n|  4    2  ||  x  |  = |  t  |\\n|_ 1    1 _||_ y _|    |_ c _|\\n\\n_     _     _      _ -1 _   _\\n|  x  |  = |  4  2  |  |  t  |\\n|_ y _|    |_ 1  1 _|  |_ c _|\\n\\n_     _      1    _      _  _   _\\n|  x  |  =  ---  |  1  -2  ||  t  |\\n|_ y _|     |d|  |_-1   4 _||_ c _|\\n\\n_     _      1    _      _  _   _\\n|  x  |  =  ---  |  1  -2  ||  t  |\\n|_ y _|     |2|  |_-1   4 _||_ c _|\\n\\n_     _       _            _\\n|  x  |  =   | ( t - 2c)/2  |\\n|_ y _|      |_(-t + 4c)/2 _|\\n\\nfor valid cases, both x and y should be positive and integers\\n\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        int t = tomatoSlices, c = cheeseSlices;\\n\\n         double ans1 = (t-2*c)/2.0, ans2 = (4*c - t)/2.0;\\n        if(ans1 >= 0 && ans2 >= 0 && ans1 == int(ans1) && ans2 == int(ans2))\\n          return {int(ans1),int(ans2)};\\n\\n    return {};\\n    }\\n};         \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3939384,
                "title": "cpp-solution-in-o-1-time-complexity",
                "content": "# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        \\n        if(tomatoSlices == 0 && cheeseSlices == 0)\\n            return {0, 0};\\n\\n        if(tomatoSlices == 0 || cheeseSlices == 0)\\n            return {};\\n\\n        // since 4x + 2y = tomatoSlices && x + y = cheeseSlices\\n        int jumbo = tomatoSlices/2 - cheeseSlices;\\n        int small = cheeseSlices - jumbo;\\n\\n        if(jumbo < 0 || small < 0)\\n            return {};\\n\\n        if( ((4*jumbo) + (2*small) == tomatoSlices) && (jumbo + small == cheeseSlices))\\n            return {jumbo, small};\\n\\n\\n\\n        return {};\\n\\n    }\\n};\\n```\\nHope you understand the code.",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        \\n        if(tomatoSlices == 0 && cheeseSlices == 0)\\n            return {0, 0};\\n\\n        if(tomatoSlices == 0 || cheeseSlices == 0)\\n            return {};\\n\\n        // since 4x + 2y = tomatoSlices && x + y = cheeseSlices\\n        int jumbo = tomatoSlices/2 - cheeseSlices;\\n        int small = cheeseSlices - jumbo;\\n\\n        if(jumbo < 0 || small < 0)\\n            return {};\\n\\n        if( ((4*jumbo) + (2*small) == tomatoSlices) && (jumbo + small == cheeseSlices))\\n            return {jumbo, small};\\n\\n\\n\\n        return {};\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3930851,
                "title": "1-liner",
                "content": "```ruby\\ndef num_of_burgers t, c\\n    t.even? && (c..c * 2) === (t /= 2) ? [j = t - c, c - j] : []\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby\\ndef num_of_burgers t, c\\n    t.even? && (c..c * 2) === (t /= 2) ? [j = t - c, c - j] : []\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3910844,
                "title": "ruby-o-1-solution-with-explanation-100-100",
                "content": "# Approach\\n1. It\\'s impossible to use all ingredients if there\\'s an odd number of tomato slices, of if the number is too high/low.\\n2. Since we always use two or four tomato slices, it\\'s easier to think of them in units of two.  Divide by two.\\n3. If tomato and cheese slices were equal, we would make only small burgers.  For every extra tomato slice (or pair of slices), we turn one small burger into a jumbo.  The number of jumbo burgers is just the difference, and the number of small is the rest of the cheese slices.\\n4. Return jumbo and small.\\n\\n# Complexity\\n- Time complexity:\\n$$O(1)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\ndef num_of_burgers(tomato, cheese)\\n    return [] if tomato % 2 == 1\\n    return [] if tomato > cheese * 4 || tomato < cheese * 2\\n\\n    tomato /= 2\\n    jumbo = tomato - cheese\\n    small = cheese - jumbo\\n    \\n    [jumbo,small]\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\ndef num_of_burgers(tomato, cheese)\\n    return [] if tomato % 2 == 1\\n    return [] if tomato > cheese * 4 || tomato < cheese * 2\\n\\n    tomato /= 2\\n    jumbo = tomato - cheese\\n    small = cheese - jumbo\\n    \\n    [jumbo,small]\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3907245,
                "title": "just-if-else-ladder-needed-totally-conditional-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        vector<int> ans;\\n    \\n    \\n    if(tomatoSlices == cheeseSlices*2){\\n        ans.push_back(0);\\n        ans.push_back(cheeseSlices);\\n        return ans;\\n    }\\n    \\n    int count1 = 0;\\n    while(tomatoSlices != cheeseSlices*2){\\n        tomatoSlices -= 4;\\n        cheeseSlices --;\\n        count1 ++;\\n\\n        if(tomatoSlices < 0){\\n            return {};\\n        }\\n    }\\n    ans.push_back(count1);\\n\\n    if(tomatoSlices == cheeseSlices*2){\\n        ans.push_back(cheeseSlices);\\n    }\\n    return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        vector<int> ans;\\n    \\n    \\n    if(tomatoSlices == cheeseSlices*2){\\n        ans.push_back(0);\\n        ans.push_back(cheeseSlices);\\n        return ans;\\n    }\\n    \\n    int count1 = 0;\\n    while(tomatoSlices != cheeseSlices*2){\\n        tomatoSlices -= 4;\\n        cheeseSlices --;\\n        count1 ++;\\n\\n        if(tomatoSlices < 0){\\n            return {};\\n        }\\n    }\\n    ans.push_back(count1);\\n\\n    if(tomatoSlices == cheeseSlices*2){\\n        ans.push_back(cheeseSlices);\\n    }\\n    return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3896859,
                "title": "python-3-solution-one-liner",
                "content": "# Code\\n```\\nclass Solution:\\n    def numOfBurgers(self, tomatoSlices: int, cheeseSlices: int) -> List[int]:\\n\\n        return [tomatoSlices//2 - cheeseSlices, 2*cheeseSlices - tomatoSlices//2] if (tomatoSlices - 2*cheeseSlices)%2 == 0 and (tomatoSlices - 2*cheeseSlices) >= 0 and (2*cheeseSlices - tomatoSlices//2) >= 0 else []\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numOfBurgers(self, tomatoSlices: int, cheeseSlices: int) -> List[int]:\\n\\n        return [tomatoSlices//2 - cheeseSlices, 2*cheeseSlices - tomatoSlices//2] if (tomatoSlices - 2*cheeseSlices)%2 == 0 and (tomatoSlices - 2*cheeseSlices) >= 0 and (2*cheeseSlices - tomatoSlices//2) >= 0 else []\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3887249,
                "title": "cpp-easy-implementation-5-line-code",
                "content": "\\n# Complexity\\n- Time complexity:O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int tom, int chee) {\\n        if(tom%2!=0)return {};\\n        if(tom<chee)return {};tom/=2;\\n        int x=tom-chee,y=2*chee-tom;\\n        if(x<0 || y<0)return {};\\n        return {x,y};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int tom, int chee) {\\n        if(tom%2!=0)return {};\\n        if(tom<chee)return {};tom/=2;\\n        int x=tom-chee,y=2*chee-tom;\\n        if(x<0 || y<0)return {};\\n        return {x,y};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3844528,
                "title": "python-exercise-in-solving-linear-equations",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nLetting T = ```tomatoSlices``` and C = ```cheeseSlices```, we have the equations:\\n        T = tomatoSlices; C = cheeseSlices\\n        T - ( 4*J + 2*S ) = 0\\n        C - ( 1*J + 1*S ) = 0\\n        T = 4*J + 2*S\\n        C = 1*J + 1*S\\n        T - 2*C = 2*J\\n        T - 4*C = -2*S\\n        T / 2 - C = J\\n        - T / 2 + 2 * C = S\\nWe also need two validity checks:  First, T must be even because it\\'s divided by two, and Second, both S and J must be non-negative\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nImplement the last two equations and add logic for the validity checks.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$ because there is no dependence in the size of the input (a pair of scalars )\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$ because the only temporary variables are scalars.\\n# Code\\n```\\nclass Solution:\\n    def numOfBurgers(self, tomatoSlices: int, cheeseSlices: int) -> List[int]:\\n        T = tomatoSlices; C = cheeseSlices\\n        # T - ( 4*J + 2*S ) = 0\\n        # C - ( 1*J + 1*S ) = 0\\n        # T = 4*J + 2*S\\n        # C = 1*J + 1*S\\n        # T - 2*C = 2*J\\n        # T - 4*C = -2*S\\n        if T % 2 == 1:\\n            return []\\n        else:\\n            J = ( T - 2 * C ) // 2\\n            S = - ( T - 4 * C ) // 2\\n            if J >= 0 and S >= 0:\\n                return [ J, S ]\\n            else:\\n                return []\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```tomatoSlices```\n```cheeseSlices```\n```\\nclass Solution:\\n    def numOfBurgers(self, tomatoSlices: int, cheeseSlices: int) -> List[int]:\\n        T = tomatoSlices; C = cheeseSlices\\n        # T - ( 4*J + 2*S ) = 0\\n        # C - ( 1*J + 1*S ) = 0\\n        # T = 4*J + 2*S\\n        # C = 1*J + 1*S\\n        # T - 2*C = 2*J\\n        # T - 4*C = -2*S\\n        if T % 2 == 1:\\n            return []\\n        else:\\n            J = ( T - 2 * C ) // 2\\n            S = - ( T - 4 * C ) // 2\\n            if J >= 0 and S >= 0:\\n                return [ J, S ]\\n            else:\\n                return []\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3822362,
                "title": "c-100-faster-math-eqns",
                "content": "**Intuition :** Intuition is simple , it just like we r given 2 linear equation with 2 variables  and we have to solve them for finding value of variables.\\n\\nLet , no of tomato slices be t , no of cheese slices be c.\\nIn one big burger 4 tomato slice and one cheese needed.\\nwhile for small one 2 tomato slice and one cheese needed.\\n\\nlet , no of big burgers =x.\\nno of small burgers =y.\\n\\nthen , 4x+2y = t.  or 2x+y=t/2. ---Eq(1).\\nand , x+y=c.  --Eq(2).\\n\\n**Important observation :** there is no values exist for x and y when t==odd . from Eq 1.\\n\\nnow , tym for code.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int t, int c) {\\n        vector<int>ans;\\n        if(t%2!=0)return ans;\\n        int a=0,b=0;\\n        a= t/2- c;\\n        b= c-a;\\n        if(a<0||b<0)return ans;\\n        ans.push_back(a);\\n        ans.push_back(b);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int t, int c) {\\n        vector<int>ans;\\n        if(t%2!=0)return ans;\\n        int a=0,b=0;\\n        a= t/2- c;\\n        b= c-a;\\n        if(a<0||b<0)return ans;\\n        ans.push_back(a);\\n        ans.push_back(b);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3819191,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> numOfBurgers(int tom, int chese) {\\n\\n        List<Integer> ans = new ArrayList<>();\\n        \\n        double t = (double)tom;\\n        double c = (double)chese;\\n        double x = (t-2*c)/2;\\n        double y = c-x;\\n\\n        if(x<0 || y<0 || x-(int)x !=0) return ans;\\n        else{\\n            ans.add((int)x);\\n            ans.add((int)y);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> numOfBurgers(int tom, int chese) {\\n\\n        List<Integer> ans = new ArrayList<>();\\n        \\n        double t = (double)tom;\\n        double c = (double)chese;\\n        double x = (t-2*c)/2;\\n        double y = c-x;\\n\\n        if(x<0 || y<0 || x-(int)x !=0) return ans;\\n        else{\\n            ans.add((int)x);\\n            ans.add((int)y);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3808691,
                "title": "java-o-1-space-and-time-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        // Jumbo Burger: 4 tomato slices and 1 cheese slice.\\n        // Small Burger: 2 Tomato slices and 1 cheese slice.\\n\\n        // 4 * x + 2 * y = tomatoSlices\\n        // 2*x + 2*y = 2* cheeseSlices\\n\\n        int jumbo = (tomatoSlices - 2 * cheeseSlices) / 2 ;\\n        int small = cheeseSlices - jumbo ;\\n\\n        if(jumbo >=0 && \\n           small>=0 &&\\n             4 * jumbo + 2* small == tomatoSlices\\n             && jumbo + small == cheeseSlices ){\\n           return List.of(jumbo, small);\\n\\n        }\\n        return new ArrayList();\\n\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        // Jumbo Burger: 4 tomato slices and 1 cheese slice.\\n        // Small Burger: 2 Tomato slices and 1 cheese slice.\\n\\n        // 4 * x + 2 * y = tomatoSlices\\n        // 2*x + 2*y = 2* cheeseSlices\\n\\n        int jumbo = (tomatoSlices - 2 * cheeseSlices) / 2 ;\\n        int small = cheeseSlices - jumbo ;\\n\\n        if(jumbo >=0 && \\n           small>=0 &&\\n             4 * jumbo + 2* small == tomatoSlices\\n             && jumbo + small == cheeseSlices ){\\n           return List.of(jumbo, small);\\n\\n        }\\n        return new ArrayList();\\n\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3773118,
                "title": "c-3-liner-code",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int t, int c) {\\n        if(t%2!=0) return {};\\n        if((t-2*c)%2!=0 || (t-2*c<0) || c-(t-2*c)/2<0) return {};\\n        return {(t-2*c)/2,c-(t-2*c)/2};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int t, int c) {\\n        if(t%2!=0) return {};\\n        if((t-2*c)%2!=0 || (t-2*c<0) || c-(t-2*c)/2<0) return {};\\n        return {(t-2*c)/2,c-(t-2*c)/2};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3724441,
                "title": "python-simple-math",
                "content": "```\\nclass Solution:\\n    def numOfBurgers(self, t: int, c: int) -> List[int]:\\n        \"\"\"\\n        [4t + 1c, 2t + 1c], where t = c = 0, else []\\n\\n        16t  7c\\n        4t: 16t-1x4t=12t  7c-1x1c=6c -> 1\\n        2t: 12t-6x2t=0t   6c-6x1c=0c -> 6\\n        0t == 0c\\n            \\n        j + s = c # total burgers that could be made = total cheese slices needed for the burgers\\n        4j + 2s = t # j jumbo + s small require t tomato slices\\n        \\n        s = 2c - t/2\\n        j = c - s\\n        \"\"\"\\n        return [] if t % 2 or (s := 2 * c - t // 2) < 0 or (j := c - s) < 0 else [j, s]\\n```",
                "solutionTags": [
                    "Python",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def numOfBurgers(self, t: int, c: int) -> List[int]:\\n        \"\"\"\\n        [4t + 1c, 2t + 1c], where t = c = 0, else []\\n\\n        16t  7c\\n        4t: 16t-1x4t=12t  7c-1x1c=6c -> 1\\n        2t: 12t-6x2t=0t   6c-6x1c=0c -> 6\\n        0t == 0c\\n            \\n        j + s = c # total burgers that could be made = total cheese slices needed for the burgers\\n        4j + 2s = t # j jumbo + s small require t tomato slices\\n        \\n        s = 2c - t/2\\n        j = c - s\\n        \"\"\"\\n        return [] if t % 2 or (s := 2 * c - t // 2) < 0 or (j := c - s) < 0 else [j, s]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3712249,
                "title": "simple-solution",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {number} tomatoSlices\\n * @param {number} cheeseSlices\\n * @return {number[]}\\n */\\nvar numOfBurgers = function(tomatoSlices, cheeseSlices) {\\n    if (tomatoSlices % 2 === 1) return []\\n    if (tomatoSlices / cheeseSlices < 2) return []\\n    if (tomatoSlices / cheeseSlices > 4) return []\\n    let jumbo =  (tomatoSlices - (cheeseSlices * 2)) / 2\\n    return [jumbo, cheeseSlices - jumbo]\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} tomatoSlices\\n * @param {number} cheeseSlices\\n * @return {number[]}\\n */\\nvar numOfBurgers = function(tomatoSlices, cheeseSlices) {\\n    if (tomatoSlices % 2 === 1) return []\\n    if (tomatoSlices / cheeseSlices < 2) return []\\n    if (tomatoSlices / cheeseSlices > 4) return []\\n    let jumbo =  (tomatoSlices - (cheeseSlices * 2)) / 2\\n    return [jumbo, cheeseSlices - jumbo]\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3687892,
                "title": "java",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        // x= jumbo , y = small :\\n        // 1. x*4 + y*2 = tomatoSlices\\n        // 2. x + y =  cheeseSlices\\n        // x = (tomatoSlices - 2 * cheeseSlices)/2 , y = cheeseSlices - x      \\n        int jumbo = (tomatoSlices - 2 * cheeseSlices)/2 , small = cheeseSlices - jumbo;\\n        return (jumbo < 0 || tomatoSlices % 2 ==1|| small <0) ? new ArrayList(): Arrays.asList(jumbo,small);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        // x= jumbo , y = small :\\n        // 1. x*4 + y*2 = tomatoSlices\\n        // 2. x + y =  cheeseSlices\\n        // x = (tomatoSlices - 2 * cheeseSlices)/2 , y = cheeseSlices - x      \\n        int jumbo = (tomatoSlices - 2 * cheeseSlices)/2 , small = cheeseSlices - jumbo;\\n        return (jumbo < 0 || tomatoSlices % 2 ==1|| small <0) ? new ArrayList(): Arrays.asList(jumbo,small);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3657898,
                "title": "c-beats-100-simple-1-line-solution",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n$$2x+4y=t ,x+y=c$$\\nSo $$x=2c-t/2, y=t/2-c$$\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(1)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int tomatoSlices, int cheeseSlices)\\n    {\\n        if(tomatoSlices%2==1 || tomatoSlices<2*cheeseSlices || tomatoSlices>4*cheeseSlices){return {};}\\n        return {tomatoSlices/2-cheeseSlices, 2*cheeseSlices-tomatoSlices/2};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int tomatoSlices, int cheeseSlices)\\n    {\\n        if(tomatoSlices%2==1 || tomatoSlices<2*cheeseSlices || tomatoSlices>4*cheeseSlices){return {};}\\n        return {tomatoSlices/2-cheeseSlices, 2*cheeseSlices-tomatoSlices/2};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3649368,
                "title": "2-lines-solution-simple-but-people-fail-to-understand",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    vector<int> numOfBurgers(int t, int c) {\\n        int c4=0;\\n        while(c4<c && (c+c4)*2<t) c4++;\\n        if((c+c4)*2==t)\\n        {\\n            ans.push_back(c4);\\n            ans.push_back(c-c4);\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    vector<int> numOfBurgers(int t, int c) {\\n        int c4=0;\\n        while(c4<c && (c+c4)*2<t) c4++;\\n        if((c+c4)*2==t)\\n        {\\n            ans.push_back(c4);\\n            ans.push_back(c-c4);\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3627445,
                "title": "o-1-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        vector<int>v;\\n        if(tomatoSlices%2!=0)return v;\\n        \\n        if(cheeseSlices>tomatoSlices/2)return v;\\n        \\n        int jumbo=(tomatoSlices)/2-cheeseSlices;\\n        \\n        int small=cheeseSlices-jumbo;\\n        \\n        if(small<0 || jumbo<0)return v;\\n        \\n        v.push_back(jumbo);\\n        v.push_back(small);\\n        \\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        vector<int>v;\\n        if(tomatoSlices%2!=0)return v;\\n        \\n        if(cheeseSlices>tomatoSlices/2)return v;\\n        \\n        int jumbo=(tomatoSlices)/2-cheeseSlices;\\n        \\n        int small=cheeseSlices-jumbo;\\n        \\n        if(small<0 || jumbo<0)return v;\\n        \\n        v.push_back(jumbo);\\n        v.push_back(small);\\n        \\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3599986,
                "title": "c-solution-using-simple-maths",
                "content": "# Intuition\\nSolved the question using simple maths. \\ncreate 2 equations :\\n4*jb + 2*sb = tomatoSlices;\\n1*jb + 1*sb = cheeseSlices;\\n\\n\\n# Approach\\nsolving the 2 linear equations we get \\nsb= (4*cheeseSlices- tomatoSlices)/2\\njb= (tomatoSlices- 2*cheeseSlices)/2\\n\\napplying edge cases of non negativity and checking if no decimals come we can solve this question.\\n\\n\\n# Complexity\\n- Time complexity:\\no(1) as we are not using any loop.\\n\\n- Space complexity:\\nlinear space complexity of vector used.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        vector<int> ans;\\n        if (cheeseSlices > tomatoSlices) return ans;\\n\\n        float jb= (tomatoSlices- 2*cheeseSlices)/2.0;\\n        if (jb == ceil(jb) && jb>=0){\\n            ans.push_back(int(jb));\\n        }\\n        else {\\n            return {};\\n        }\\n\\n        float sb= (4*cheeseSlices - tomatoSlices)/2.0;\\n        if (sb == ceil(sb) && sb>=0 ){\\n            ans.push_back(int(sb));\\n            return ans;\\n        }\\n        else {\\n            return {};\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        vector<int> ans;\\n        if (cheeseSlices > tomatoSlices) return ans;\\n\\n        float jb= (tomatoSlices- 2*cheeseSlices)/2.0;\\n        if (jb == ceil(jb) && jb>=0){\\n            ans.push_back(int(jb));\\n        }\\n        else {\\n            return {};\\n        }\\n\\n        float sb= (4*cheeseSlices - tomatoSlices)/2.0;\\n        if (sb == ceil(sb) && sb>=0 ){\\n            ans.push_back(int(sb));\\n            return ans;\\n        }\\n        else {\\n            return {};\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3598426,
                "title": "algebra-time-o-1-space-o-1",
                "content": "class Solution(object):\\n    def numOfBurgers(self, tomatoSlices, cheeseSlices):\\n        \"\"\"\\n        :type tomatoSlices: int\\n        :type cheeseSlices: int\\n        :rtype: List[int]\\n        \"\"\"\\n        \\n        if tomatoSlices & 1:\\n            return []\\n        \\n        \\n        if (tomatoSlices - 2*cheeseSlices) < 0 or (tomatoSlices - 2*cheeseSlices) & 1:\\n            return []\\n        \\n        jumbo = (tomatoSlices - 2*cheeseSlices) >> 1\\n        \\n        small = cheeseSlices - jumbo\\n        \\n        if small < 0:\\n            return []\\n        \\n        return [jumbo, small]\\n",
                "solutionTags": [],
                "code": "class Solution(object):\\n    def numOfBurgers(self, tomatoSlices, cheeseSlices):\\n        \"\"\"\\n        :type tomatoSlices: int\\n        :type cheeseSlices: int\\n        :rtype: List[int]\\n        \"\"\"\\n        \\n        if tomatoSlices & 1:\\n            return []\\n        \\n        \\n        if (tomatoSlices - 2*cheeseSlices) < 0 or (tomatoSlices - 2*cheeseSlices) & 1:\\n            return []\\n        \\n        jumbo = (tomatoSlices - 2*cheeseSlices) >> 1\\n        \\n        small = cheeseSlices - jumbo\\n        \\n        if small < 0:\\n            return []\\n        \\n        return [jumbo, small]\\n",
                "codeTag": "Java"
            },
            {
                "id": 3591459,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        if(tomatoSlices%2!=0 || 2*cheeseSlices>tomatoSlices || 4*cheeseSlices<tomatoSlices) return {};\\n        if((tomatoSlices-(2*cheeseSlices))%2==1) return {};\\n        int jumbo=(tomatoSlices-(2*cheeseSlices))/2;\\n        return {jumbo,cheeseSlices-jumbo};\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def numOfBurgers(self, tomatoSlices: int, cheeseSlices: int) -> List[int]:\\n        j = (tomatoSlices - 2*cheeseSlices)/2\\n        if int(j) != j or j<0 or cheeseSlices-j<0: \\n            return []\\n        else:\\n            return [int(j), int(cheeseSlices-j)]\\n```\\n\\n```Java []\\nclass Solution {\\n    public List<Integer> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        List<Integer> output = new ArrayList();\\n        int x = 0; int y = 0;\\n\\n        if (tomatoSlices % 2 != 0 || cheeseSlices > tomatoSlices)\\n            return output;\\n\\n        x = -cheeseSlices + (tomatoSlices / 2);\\n        y = (2 * cheeseSlices) - (tomatoSlices / 2);\\n        if (x < 0 || y < 0) \\n            return output;\\n\\n        output.add(x); output.add(y);\\n        return output;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        if(tomatoSlices%2!=0 || 2*cheeseSlices>tomatoSlices || 4*cheeseSlices<tomatoSlices) return {};\\n        if((tomatoSlices-(2*cheeseSlices))%2==1) return {};\\n        int jumbo=(tomatoSlices-(2*cheeseSlices))/2;\\n        return {jumbo,cheeseSlices-jumbo};\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def numOfBurgers(self, tomatoSlices: int, cheeseSlices: int) -> List[int]:\\n        j = (tomatoSlices - 2*cheeseSlices)/2\\n        if int(j) != j or j<0 or cheeseSlices-j<0: \\n            return []\\n        else:\\n            return [int(j), int(cheeseSlices-j)]\\n```\n```Java []\\nclass Solution {\\n    public List<Integer> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        List<Integer> output = new ArrayList();\\n        int x = 0; int y = 0;\\n\\n        if (tomatoSlices % 2 != 0 || cheeseSlices > tomatoSlices)\\n            return output;\\n\\n        x = -cheeseSlices + (tomatoSlices / 2);\\n        y = (2 * cheeseSlices) - (tomatoSlices / 2);\\n        if (x < 0 || y < 0) \\n            return output;\\n\\n        output.add(x); output.add(y);\\n        return output;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3569443,
                "title": "simple-java-beats-100-runtime-beats-99-memory",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        List<Integer> res = new ArrayList<>();\\n        if (tomatoSlices%2 != 0) return res;\\n\\n        if (cheeseSlices*2 > tomatoSlices) return res;\\n\\n        int rem = tomatoSlices - cheeseSlices*2;\\n        int jumbos = rem/2;\\n        int smalls = cheeseSlices - jumbos;\\n\\n        if (smalls < 0) return res;\\n        res.add(jumbos);\\n        res.add(smalls);\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        List<Integer> res = new ArrayList<>();\\n        if (tomatoSlices%2 != 0) return res;\\n\\n        if (cheeseSlices*2 > tomatoSlices) return res;\\n\\n        int rem = tomatoSlices - cheeseSlices*2;\\n        int jumbos = rem/2;\\n        int smalls = cheeseSlices - jumbos;\\n\\n        if (smalls < 0) return res;\\n        res.add(jumbos);\\n        res.add(smalls);\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3561856,
                "title": "java-linear-equations-group",
                "content": "```\\nclass Solution {\\n    public List<Integer> numOfBurgers(int ts, int cs) {\\n        int sb = (int)(2*cs-0.5*ts);\\n        int jb = cs-sb;\\n        return ts%2==1||sb<0||jb<0 ? List.of():List.of(jb,sb);\\n    }\\n    \\n    //linear equations system\\n    //4*jb+2*sb = ts;\\n    //sb+jb     = cs\\n    \\n    //express jb via cs and sb\\n    // jb=cs-sb;\\n    \\n    //rewrite the first equation using new jb definition:\\n    //4*(cs-sb)+2*sb = ts;\\n    \\n    //then, find sb from it\\n    //4*cs - 4*sb+2sb = ts; <=>\\n    //4cs-2sb=ts; <=>\\n    //2sb=4cs-ts <=>\\n    //sb=2cs-0.5ts\\n    \\n    //and afterwards, let\\'s find jb from it:\\n    //sb+jb=cs <=>\\n    //jb=cs-sb\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> numOfBurgers(int ts, int cs) {\\n        int sb = (int)(2*cs-0.5*ts);\\n        int jb = cs-sb;\\n        return ts%2==1||sb<0||jb<0 ? List.of():List.of(jb,sb);\\n    }\\n    \\n    //linear equations system\\n    //4*jb+2*sb = ts;\\n    //sb+jb     = cs\\n    \\n    //express jb via cs and sb\\n    // jb=cs-sb;\\n    \\n    //rewrite the first equation using new jb definition:\\n    //4*(cs-sb)+2*sb = ts;\\n    \\n    //then, find sb from it\\n    //4*cs - 4*sb+2sb = ts; <=>\\n    //4cs-2sb=ts; <=>\\n    //2sb=4cs-ts <=>\\n    //sb=2cs-0.5ts\\n    \\n    //and afterwards, let\\'s find jb from it:\\n    //sb+jb=cs <=>\\n    //jb=cs-sb\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3481628,
                "title": "simple-concise-1-liner-python-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def numOfBurgers(self, T: int, C: int) -> List[int]:\\n        return [[T//2 - C, 2*C - T//2],[]][T % 2 or T < 2*C or 4*C < T]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numOfBurgers(self, T: int, C: int) -> List[int]:\\n        return [[T//2 - C, 2*C - T//2],[]][T % 2 or T < 2*C or 4*C < T]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3434080,
                "title": "java-beats-100-o-1-easy-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public List<Integer> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        List<Integer>ans = new ArrayList<>();\\n\\n        if(tomatoSlices %2 == 1)\\n            return ans;\\n        int x = tomatoSlices/2 - cheeseSlices;\\n        int y = cheeseSlices - x;\\n        if(x < 0 || y < 0){\\n            return ans;\\n        }\\n        ans.add(x);\\n        ans.add(y);\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        List<Integer>ans = new ArrayList<>();\\n\\n        if(tomatoSlices %2 == 1)\\n            return ans;\\n        int x = tomatoSlices/2 - cheeseSlices;\\n        int y = cheeseSlices - x;\\n        if(x < 0 || y < 0){\\n            return ans;\\n        }\\n        ans.add(x);\\n        ans.add(y);\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3385844,
                "title": "c-o-1-with-thought-process-explained",
                "content": "The range of tomatoes must be within 4 * cheese slices and 2 * cheese slices and must be even to be valid. Lets say we wanted to start with making every burger with 2 tomato 1 cheese, we would be left over with total tomato slices - 2 * (slices of cheese). For the left over slices we would need to pair 2 at a time and convert a 2 tomato burger to a 4 tomato burger. So left over slices / 2 would be the amount of big burgers to make, and the amount of cheese needed for them. Then subtract that amount of cheese from the total cheese to find the remaining cheese to be used 1 slice at a time for a smaller burger.\\n```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int t, int c) {\\n        if (t > c * 4 || t < c * 2 || t % 2 == 1) return {};\\n        vector<int> ans(2);\\n        int minDif = c * 2;\\n        int extra = t - minDif;\\n        ans[0] = extra / 2;\\n        ans[1] = c - ans[0];\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int t, int c) {\\n        if (t > c * 4 || t < c * 2 || t % 2 == 1) return {};\\n        vector<int> ans(2);\\n        int minDif = c * 2;\\n        int extra = t - minDif;\\n        ans[0] = extra / 2;\\n        ans[1] = c - ans[0];\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3376851,
                "title": "java-o-1-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> numOfBurgers(int t, int c) {\\n        // j+s=c\\n        // 4*j+2*s=t\\n\\n        // 2s=4*c-t --> s=2c-t/2\\n        // -2j=2c-t --> j=t/2-c\\n\\n        return(2*c>=t/2 && t/2>=c && t%2==0)?new ArrayList<Integer>(Arrays.asList(t/2-c,2*c-t/2)):new ArrayList<Integer>();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> numOfBurgers(int t, int c) {\\n        // j+s=c\\n        // 4*j+2*s=t\\n\\n        // 2s=4*c-t --> s=2c-t/2\\n        // -2j=2c-t --> j=t/2-c\\n\\n        return(2*c>=t/2 && t/2>=c && t%2==0)?new ArrayList<Integer>(Arrays.asList(t/2-c,2*c-t/2)):new ArrayList<Integer>();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3341590,
                "title": "simple-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        List<Integer> l = new ArrayList<>();\\n        if (tomatoSlices % 2 == 1) return l;\\n        if (tomatoSlices / 2 < cheeseSlices) return l;\\n        if (cheeseSlices * 2 < tomatoSlices / 2) return l;\\n        l.add(tomatoSlices / 2 - cheeseSlices);\\n        l.add(cheeseSlices * 2 - tomatoSlices / 2);\\n        return l;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        List<Integer> l = new ArrayList<>();\\n        if (tomatoSlices % 2 == 1) return l;\\n        if (tomatoSlices / 2 < cheeseSlices) return l;\\n        if (cheeseSlices * 2 < tomatoSlices / 2) return l;\\n        l.add(tomatoSlices / 2 - cheeseSlices);\\n        l.add(cheeseSlices * 2 - tomatoSlices / 2);\\n        return l;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3328215,
                "title": "c",
                "content": "```\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nint* numOfBurgers(int tomatoSlices, int cheeseSlices, int* returnSize){\\n    \\n    int Jumbo_2 =  tomatoSlices - 2*cheeseSlices ;\\n    printf(\"%d \", Jumbo_2 ) ;\\n    if( Jumbo_2 < 0 || Jumbo_2 % 2 != 0 ||  (cheeseSlices - Jumbo_2/2) < 0){\\n        *returnSize = 0 ;\\n        return NULL ;\\n    }\\n    int* ans = malloc( 2 * sizeof(int) ) ;\\n    *returnSize = 2 ;\\n    ans[0] = Jumbo_2/2 ;\\n    ans[1] = cheeseSlices - ans[0] ;\\n    return ans ;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nint* numOfBurgers(int tomatoSlices, int cheeseSlices, int* returnSize){\\n    \\n    int Jumbo_2 =  tomatoSlices - 2*cheeseSlices ;\\n    printf(\"%d \", Jumbo_2 ) ;\\n    if( Jumbo_2 < 0 || Jumbo_2 % 2 != 0 ||  (cheeseSlices - Jumbo_2/2) < 0){\\n        *returnSize = 0 ;\\n        return NULL ;\\n    }\\n    int* ans = malloc( 2 * sizeof(int) ) ;\\n    *returnSize = 2 ;\\n    ans[0] = Jumbo_2/2 ;\\n    ans[1] = cheeseSlices - ans[0] ;\\n    return ans ;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3327100,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def numOfBurgers(self, tomatoSlices: int, cheeseSlices: int) -> List[int]:\\n        if tomatoSlices%2==0 and cheeseSlices*2<=tomatoSlices<=cheeseSlices*4:\\n            return [tomatoSlices//2-cheeseSlices,2*cheeseSlices-tomatoSlices//2]\\n\\n        else:\\n            return []    \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numOfBurgers(self, tomatoSlices: int, cheeseSlices: int) -> List[int]:\\n        if tomatoSlices%2==0 and cheeseSlices*2<=tomatoSlices<=cheeseSlices*4:\\n            return [tomatoSlices//2-cheeseSlices,2*cheeseSlices-tomatoSlices//2]\\n\\n        else:\\n            return []    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3320456,
                "title": "easy-solution-intutive-maths-c",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        int ch=cheeseSlices;\\n        int to=tomatoSlices;\\n        if(ch>to || ch*4<to) return {};\\n\\n        long long int x=to/2-ch;\\n        long long int y=ch-x;\\n        if(x<0 || y<0) return {};\\n         \\n         if(x+y==ch && ((x*4+y*2)==to)) return {(int)x,(int)y};\\n         return {};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        int ch=cheeseSlices;\\n        int to=tomatoSlices;\\n        if(ch>to || ch*4<to) return {};\\n\\n        long long int x=to/2-ch;\\n        long long int y=ch-x;\\n        if(x<0 || y<0) return {};\\n         \\n         if(x+y==ch && ((x*4+y*2)==to)) return {(int)x,(int)y};\\n         return {};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3290550,
                "title": "java-solution",
                "content": "# Intuition\\nThe number of chees slices determine the total number of burgers that would be made\\n\\n# Approach\\n As each of the burgers need the number of cheese slices as one then the noumber of chesse slices will determint the total number of burgers jumbo and small that will be made now we would form a equation as 4i+2(b-i) which statr with the value of i as 0 it will loop through all the conditon of diffrent number of jumbo and small burgers made untile it find the right number\\n\\n# Complexity\\n- Time complexity: O(cheeseSlices)\\n- Space complexity: Constant\\n<!-- space complexity is costant -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        List<Integer> ans=new ArrayList<Integer>();\\n        int b=cheeseSlices;\\n        int used=0;\\n        if(tomatoSlices==0&&cheeseSlices==0){\\n            ans.add(0);\\n            ans.add(0);\\n\\n            return ans;\\n        }\\n\\n        for(int i=0;i<b;i++){\\n            used=4*i+2*b-2*i;\\n            if(tomatoSlices==used){\\n                ans.add(i);\\n                ans.add(b-i);\\n                break;\\n                \\n            }\\n        }\\n\\n    return ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        List<Integer> ans=new ArrayList<Integer>();\\n        int b=cheeseSlices;\\n        int used=0;\\n        if(tomatoSlices==0&&cheeseSlices==0){\\n            ans.add(0);\\n            ans.add(0);\\n\\n            return ans;\\n        }\\n\\n        for(int i=0;i<b;i++){\\n            used=4*i+2*b-2*i;\\n            if(tomatoSlices==used){\\n                ans.add(i);\\n                ans.add(b-i);\\n                break;\\n                \\n            }\\n        }\\n\\n    return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3288686,
                "title": "simple-and-short-o-1-1ms-faster-than-100-math-java-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        List<Integer> ans=new ArrayList<>();\\n        int val=tomatoSlices-2*cheeseSlices;\\n        if(val>=0 && (val&1)==0 && cheeseSlices-val/2>=0){\\n            ans.add(val/2);\\n            ans.add(cheeseSlices-val/2);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        List<Integer> ans=new ArrayList<>();\\n        int val=tomatoSlices-2*cheeseSlices;\\n        if(val>=0 && (val&1)==0 && cheeseSlices-val/2>=0){\\n            ans.add(val/2);\\n            ans.add(cheeseSlices-val/2);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3285098,
                "title": "easy-javascript-solution-number-of-burgers-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nNumber of cheeseSlices is the variable that determine how many JumboBurger and SmallBurger will be made with zero remaining for both slices\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    First if odd number of tomatoSlices is given return [] b/c it is not possible to divide evenly.For number of cheeseSlices iterate in for loop and try every combination of i and n-i. \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n), where n is number of cheeseSlices given.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n# Code\\n```\\n/**\\n * @param {number} tomatoSlices\\n * @param {number} cheeseSlices\\n * @return {number[]}\\n */\\nvar numOfBurgers = function(tomatoSlices, cheeseSlices) {\\n    if(tomatoSlices %2 != 0) return []\\n\\n    const JB=4,SB=2;\\n    for(let i=0; i<=cheeseSlices; i++){\\n        if(JB*i + SB*(cheeseSlices-i) == tomatoSlices){\\n            return [i,cheeseSlices-i]\\n        }\\n    }\\n\\n    return []\\n\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} tomatoSlices\\n * @param {number} cheeseSlices\\n * @return {number[]}\\n */\\nvar numOfBurgers = function(tomatoSlices, cheeseSlices) {\\n    if(tomatoSlices %2 != 0) return []\\n\\n    const JB=4,SB=2;\\n    for(let i=0; i<=cheeseSlices; i++){\\n        if(JB*i + SB*(cheeseSlices-i) == tomatoSlices){\\n            return [i,cheeseSlices-i]\\n        }\\n    }\\n\\n    return []\\n\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3277238,
                "title": "just-a-simple-high-school-question-math-c-o-1-sc-o-1-tc",
                "content": "```\\nvector<int> numOfBurgers(int t, int c) {\\n        if(t<2*c or t>4*c) return {};\\n        if((t-2*c)/2.0!=(t-2*c)/2) return {};\\n        return {(t-2*c)/2,c-((t-2*c)/2)};\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\nvector<int> numOfBurgers(int t, int c) {\\n        if(t<2*c or t>4*c) return {};\\n        if((t-2*c)/2.0!=(t-2*c)/2) return {};\\n        return {(t-2*c)/2,c-((t-2*c)/2)};\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3268251,
                "title": "easy-solution-0ms-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        vector<int> burg;\\n        double x=(tomatoSlices-2*cheeseSlices)/2.0;\\n        double y=cheeseSlices-x;\\n        if(x-int(x) == 0 && x>=0 && y>=0)\\n        {\\n            burg.push_back(x);\\n            burg.push_back(y);\\n        }\\n\\n    return burg;}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        vector<int> burg;\\n        double x=(tomatoSlices-2*cheeseSlices)/2.0;\\n        double y=cheeseSlices-x;\\n        if(x-int(x) == 0 && x>=0 && y>=0)\\n        {\\n            burg.push_back(x);\\n            burg.push_back(y);\\n        }\\n\\n    return burg;}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3207917,
                "title": "java-fastest-100-no-loops-nothing-but-a-math-problem",
                "content": "# Intuition\\nRather than use loop to simulate problem. For you guys this is (\"NOTHING BUT\") a math problem and it should not be a medium difficulty.\\n\\n# Approach\\nFirst check that there is enough tomatos 2*cheese <= tomat0 <= 4*cheese and even number of slices. Otherwise return empty list.\\nNow start will makes small burgers 2 * cheese. There remaining are use for the burgers. \\n\\n# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> numOfBurgers(int toma, int cheese) {\\n        List<Integer> res = new ArrayList<>();\\n\\n        int small_cheese = cheese * 2;  /// use up all the cheese to make small burgers\\n        int total_big = 0;\\n        int total_small = 0;\\n        if (toma >= cheese * 2 && toma <= 4 * cheese && toma % 2 == 0) {\\n // we divide by 2 instead of 4 because 2 cheese are accounted for in the \\'small\\' burger\\n            total_big = (toma - small_cheese) /2;  \\n            total_small = cheese - total_big;\\n        }\\n        else \\n            return new ArrayList<>();\\n        res.add(total_big);  res.add(total_small);\\n        return res;\\n    }\\n\\n  \\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> numOfBurgers(int toma, int cheese) {\\n        List<Integer> res = new ArrayList<>();\\n\\n        int small_cheese = cheese * 2;  /// use up all the cheese to make small burgers\\n        int total_big = 0;\\n        int total_small = 0;\\n        if (toma >= cheese * 2 && toma <= 4 * cheese && toma % 2 == 0) {\\n // we divide by 2 instead of 4 because 2 cheese are accounted for in the \\'small\\' burger\\n            total_big = (toma - small_cheese) /2;  \\n            total_small = cheese - total_big;\\n        }\\n        else \\n            return new ArrayList<>();\\n        res.add(total_big);  res.add(total_small);\\n        return res;\\n    }\\n\\n  \\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3197583,
                "title": "2-lines-c-o-1",
                "content": "***million lines from a Pen may reach the globe,Even so some dozen lines of Codes rule all over it***\\n```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        if(tomatoSlices%2||cheeseSlices*4<tomatoSlices||cheeseSlices*2>tomatoSlices)return {};\\n        int n=(tomatoSlices-(2*cheeseSlices))/2;return {n,cheeseSlices-n};\\n    }\\n};\\n```\\n**logik**\\n1.if tomato slices are odd , they can\\'t be used in any way as we can take 2 or 4 at a time so by stating the obvious **Sum of two even numbers is even** \\n2.If there are more cheese slices than half of tomato slices then too there will be always some cheese remaining , similarly if they are less than one fourth then there will be tomato slices remaining\\n3. consider we make m large burgers and n small ones so total tomato slices=2n+4m\\n4.total cheeze slices=m+n\\n5.solving equation 3 and 4 we get**n=(tomatoSlices-(2xcheeseSlices))/2**  and **m=cheeseSlices-n**",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        if(tomatoSlices%2||cheeseSlices*4<tomatoSlices||cheeseSlices*2>tomatoSlices)return {};\\n        int n=(tomatoSlices-(2*cheeseSlices))/2;return {n,cheeseSlices-n};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3132315,
                "title": "java-o-1-1-ms-100",
                "content": "PLEASE UPVOTE IF HELPFUL\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        \\n        List<Integer> res = new ArrayList<Integer>();\\n\\n        if(2 * cheeseSlices > tomatoSlices) { return res; }\\n\\n        if(tomatoSlices > 4 * cheeseSlices) { return res; }\\n\\n        if((tomatoSlices & 1) == 1) { return res; }\\n\\n        res.add(tomatoSlices / 2 - cheeseSlices);\\n        res.add(cheeseSlices - res.get(0));\\n\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        \\n        List<Integer> res = new ArrayList<Integer>();\\n\\n        if(2 * cheeseSlices > tomatoSlices) { return res; }\\n\\n        if(tomatoSlices > 4 * cheeseSlices) { return res; }\\n\\n        if((tomatoSlices & 1) == 1) { return res; }\\n\\n        res.add(tomatoSlices / 2 - cheeseSlices);\\n        res.add(cheeseSlices - res.get(0));\\n\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3107889,
                "title": "c-10-lines-code",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(float a, float b) {\\n        int x=(a/2)-b;\\n        int y=b-x;\\n        cout<<x<<\" \"<<y<<endl;\\n        vector<int>v;\\n        if(x<0 || y<0) return v;\\n        if((2*x)+y!=(a/2)) return v;\\n        if(x+y!=b) return v;\\n        v.push_back(x);\\n        v.push_back(y);\\n        return v;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(float a, float b) {\\n        int x=(a/2)-b;\\n        int y=b-x;\\n        cout<<x<<\" \"<<y<<endl;\\n        vector<int>v;\\n        if(x<0 || y<0) return v;\\n        if((2*x)+y!=(a/2)) return v;\\n        if(x+y!=b) return v;\\n        v.push_back(x);\\n        v.push_back(y);\\n        return v;\\n\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3089819,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn num_of_burgers(tomato_slices: i32, cheese_slices: i32) -> Vec<i32> {\\n        let (tomato_slices, cheese_slices) = (tomato_slices as i64, cheese_slices as i64);\\n        let (a, b) = (tomato_slices - 2 * cheese_slices, 4 * cheese_slices - tomato_slices);\\n        if a < 0 || b < 0 || a % 2 != 0 || b % 2 != 0 {\\n            return vec![];\\n        }\\n        vec![(a / 2) as i32, (b / 2) as i32]\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn num_of_burgers(tomato_slices: i32, cheese_slices: i32) -> Vec<i32> {\\n        let (tomato_slices, cheese_slices) = (tomato_slices as i64, cheese_slices as i64);\\n        let (a, b) = (tomato_slices - 2 * cheese_slices, 4 * cheese_slices - tomato_slices);\\n        if a < 0 || b < 0 || a % 2 != 0 || b % 2 != 0 {\\n            return vec![];\\n        }\\n        vec![(a / 2) as i32, (b / 2) as i32]\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3024796,
                "title": "c-fast-and-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCan be solved by forming mathematical equations.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSince, we are capable of forming two equations and we need to find out values of two variables. Hence, we can find out the values of these variables by solving both the equations.\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        vector<int> ans;\\n        if(tomatoSlices%2==0 && tomatoSlices/2>=cheeseSlices && 2*cheeseSlices>=tomatoSlices/2)\\n        {\\n            ans.push_back(tomatoSlices/2-cheeseSlices);\\n            ans.push_back(2*cheeseSlices-tomatoSlices/2);\\n            return ans;\\n        }\\n\\n        else\\n        {\\n            return ans;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        vector<int> ans;\\n        if(tomatoSlices%2==0 && tomatoSlices/2>=cheeseSlices && 2*cheeseSlices>=tomatoSlices/2)\\n        {\\n            ans.push_back(tomatoSlices/2-cheeseSlices);\\n            ans.push_back(2*cheeseSlices-tomatoSlices/2);\\n            return ans;\\n        }\\n\\n        else\\n        {\\n            return ans;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2963783,
                "title": "simple-approach-with-cpp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can directly solve the approach using simple math technique.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nFirst, we must determine whether the tomato slices are odd or even. There is no chance that the burger can be made if the tomato slices are not even, as both burgers require even tomato slices. Therefore, if tomato slices are even, we can proceed with the mathematical method. Further steps are given in code as a comment.\\n\\nLet\\'s say there are \\'j\\' jumbo burgers possible and \\'s\\' small burgers possible.\\n\\n=> Total tomato slices needed for them = 4*j + 2*s = ts\\nand Total cheese slices needed for them is = j + s = cs\\n\\nAfter finding j and s we can find the final answer.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int ts, int cs) {\\n        \\n        vector<int> ans;\\n\\n        /*\\n        4j + 2s = ts\\n        j + s = cs\\n        => 2j + 2s = 2cs\\n\\n        => 2j = ts - 2cs\\n        => j = ts - 2cs / 2\\n\\n        => s = 2cs - (ts/2)\\n        */\\n\\n        if (ts%2==0)\\n        {\\n            int j = (ts - 2*cs)/2;\\n            int s = 2*cs - (ts/2);\\n            if (j >= 0 &&  s>= 0)\\n            {\\n                ans.push_back(j);\\n                ans.push_back(s);\\n            }\\n        }\\n\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int ts, int cs) {\\n        \\n        vector<int> ans;\\n\\n        /*\\n        4j + 2s = ts\\n        j + s = cs\\n        => 2j + 2s = 2cs\\n\\n        => 2j = ts - 2cs\\n        => j = ts - 2cs / 2\\n\\n        => s = 2cs - (ts/2)\\n        */\\n\\n        if (ts%2==0)\\n        {\\n            int j = (ts - 2*cs)/2;\\n            int s = 2*cs - (ts/2);\\n            if (j >= 0 &&  s>= 0)\\n            {\\n                ans.push_back(j);\\n                ans.push_back(s);\\n            }\\n        }\\n\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2929661,
                "title": "python-simple-maths",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def numOfBurgers(self, tomatoSlices, cheeseSlices):\\n        val = (tomatoSlices - 2*cheeseSlices)\\n\\n        if val >= 0 and val%2 == 0 and cheeseSlices-val//2 >= 0:\\n            return [val//2,cheeseSlices-val//2]\\n\\n        return []\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numOfBurgers(self, tomatoSlices, cheeseSlices):\\n        val = (tomatoSlices - 2*cheeseSlices)\\n\\n        if val >= 0 and val%2 == 0 and cheeseSlices-val//2 >= 0:\\n            return [val//2,cheeseSlices-val//2]\\n\\n        return []\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2842765,
                "title": "python-math-system-of-equations-step-by-step",
                "content": "The important fact here is that one of the main conditions for the quantities of Tomatoes (t) and Cheese slices (c) to be valid, they must follow this relationship:\\nThe total number of tomatoes (t) is 4 times the number of cheese slices of each jumbo burger (c1), plus 2 times the number of cheese slices in each small burger (c2). If that\\'s not satisfied, then we cannot make use of all the ingredients.\\nAnd the total number of cheese slices (c) equals the sum of the slices of each type of burger (c1 + c2)\\nCommon sense dictates that c1 >= 0 and c2 >= 0.\\nThat yields:\\n```\\nt = 4 * c1 + 2 * c2\\nc = c1 + c2\\n```\\nWith constraints `c1 >= 0, c2 >= 0, and they are both integers`\\n\\nWhich can be solved step by step:\\nReplacing `c1` by `c - c2`\\n`t` = `4 * (c - c2) + 2 * c2` = `4 * c - 2 * c2`\\nIt follows that\\n`c2` = `(4 * c - t) / 2` = `2 * c - t / 2` the latter expression being so as to keep the numbers low\\nand \\n`c1` = `c - c2`\\n\\nThen we just have to check that:\\n* `c2 is actually an integer`\\n* `c2 < c`\\n* `c2 >= 0`\\n\\nAnd that\\'s pretty much it.\\n**Constant time and space complexity.**\\n\\n```\\nclass Solution:\\n    def numOfBurgers(self, t: int, c: int) -> List[int]:\\n        cSmall = 2 * c - t / 2\\n        if (int(cSmall) != cSmall or int(cSmall) > c or cSmall < 0): return []\\n        \\n        return [c - int(cSmall), int(cSmall)]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nt = 4 * c1 + 2 * c2\\nc = c1 + c2\\n```\n```\\nclass Solution:\\n    def numOfBurgers(self, t: int, c: int) -> List[int]:\\n        cSmall = 2 * c - t / 2\\n        if (int(cSmall) != cSmall or int(cSmall) > c or cSmall < 0): return []\\n        \\n        return [c - int(cSmall), int(cSmall)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2839395,
                "title": "python-simple-formula",
                "content": "```\\nclass Solution:\\n    def numOfBurgers(self, tomatoSlices: int, cheeseSlices: int) -> List[int]:\\n        #x, cheeseSlices-x   be [jumbo,small]\\n        #4x,2(cheese-x)=tomato\\n        #2x=tomato-2cheese\\n        #Let 2x be n\\n        n=tomatoSlices-2*cheeseSlices\\n        if n%2==0:\\n            if n//2>=0 and n//2<=cheeseSlices:return [n//2,cheeseSlices-n//2]\\n        return []\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numOfBurgers(self, tomatoSlices: int, cheeseSlices: int) -> List[int]:\\n        #x, cheeseSlices-x   be [jumbo,small]\\n        #4x,2(cheese-x)=tomato\\n        #2x=tomato-2cheese\\n        #Let 2x be n\\n        n=tomatoSlices-2*cheeseSlices\\n        if n%2==0:\\n            if n//2>=0 and n//2<=cheeseSlices:return [n//2,cheeseSlices-n//2]\\n        return []\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2815396,
                "title": "math-with-styeps",
                "content": "vector<int> numOfBurgers(int ts, int cs) {\\n        vector<int> ans;\\n        /*\\n        x*4 + y*2 = ts    (1)\\n        x*1 + y*1 = cs    (2)\\n            \\n        2(x*2 + y) = ts\\n        x*1 + y*1 = cs\\n        \\n        divide (1) by 2  \\n        x*2 +y = ts/2   (3)\\n        x + y = cs\\n            \\n\\t\\t(3)-(2) yields\\n        x = ts/2 -cs\\n\\t\\t\\n        subsitute into (2) and derive for y\\n        y =cs -x\\n        */\\n        \\n\\t\\t//if ts is odd then there is not solution, from (1)\\n        if(ts%2)return ans;\\n        \\n        int x= ts/2-cs;\\n        int y = cs-x;\\n        \\n\\t\\t//x and y can not be zero in this context\\n        if(x<0 || y<0)return ans;\\n        \\n        ans.push_back(x);\\n        ans.push_back(y);\\n        \\n        return ans;\\n    }",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "vector<int> numOfBurgers(int ts, int cs) {\\n        vector<int> ans;\\n        /*\\n        x*4 + y*2 = ts    (1)\\n        x*1 + y*1 = cs    (2)\\n            \\n        2(x*2 + y) = ts\\n        x*1 + y*1 = cs\\n        \\n        divide (1) by 2  \\n        x*2 +y = ts/2   (3)\\n        x + y = cs\\n            \\n\\t\\t(3)-(2) yields\\n        x = ts/2 -cs\\n\\t\\t\\n        subsitute into (2) and derive for y\\n        y =cs -x\\n        */\\n        \\n\\t\\t//if ts is odd then there is not solution, from (1)\\n        if(ts%2)return ans;\\n        \\n        int x= ts/2-cs;\\n        int y = cs-x;\\n        \\n\\t\\t//x and y can not be zero in this context\\n        if(x<0 || y<0)return ans;\\n        \\n        ans.push_back(x);\\n        ans.push_back(y);\\n        \\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2784394,
                "title": "python-linear-equation",
                "content": "```\\nclass Solution:\\n    def numOfBurgers(self, tomatoSlices: int, cheeseSlices: int) -> List[int]:\\n        T, C = tomatoSlices, cheeseSlices\\n        if T < 2*C or (T - 2*C)%2 != 0: return []\\n        if 4*C < T or (4*C - T)%2 != 0: return []\\n        return [(T - 2*C)//2, (4*C - T)//2]",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def numOfBurgers(self, tomatoSlices: int, cheeseSlices: int) -> List[int]:\\n        T, C = tomatoSlices, cheeseSlices\\n        if T < 2*C or (T - 2*C)%2 != 0: return []\\n        if 4*C < T or (4*C - T)%2 != 0: return []\\n        return [(T - 2*C)//2, (4*C - T)//2]",
                "codeTag": "Java"
            },
            {
                "id": 2752266,
                "title": "go-linear-equation",
                "content": "Let us define number of jumbo burgers as X and number of small burgers as Y We have to find an x and y in this equation:\\n1. 4X + 2Y = tomato\\n2. X + Y = cheese\\n\\n```\\nfunc numOfBurgers(tomatoSlices int, cheeseSlices int) []int {\\n    reminder := (4*cheeseSlices - tomatoSlices) % 2\\n    if reminder != 0 {\\n        return nil\\n    }\\n    \\n    small := (4*cheeseSlices - tomatoSlices) / 2\\n    jumbo := cheeseSlices - small\\n    \\n    if small < 0 || jumbo < 0 {\\n        return nil\\n    }\\n    return []int{jumbo, small}\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc numOfBurgers(tomatoSlices int, cheeseSlices int) []int {\\n    reminder := (4*cheeseSlices - tomatoSlices) % 2\\n    if reminder != 0 {\\n        return nil\\n    }\\n    \\n    small := (4*cheeseSlices - tomatoSlices) / 2\\n    jumbo := cheeseSlices - small\\n    \\n    if small < 0 || jumbo < 0 {\\n        return nil\\n    }\\n    return []int{jumbo, small}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2705724,
                "title": "java-solution",
                "content": "# I had a python solution initially but it was leading to TLE so I had to write it in java. Here it is.\\n\\n\\n```\\nclass Solution {\\n    public List<Integer> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        List<Integer> list = new ArrayList<Integer>();\\n        if(tomatoSlices==0 && cheeseSlices==0)\\n        {\\n            \\n            list.add(0);\\n            list.add(0);\\n        }\\n        else\\n        {\\n            for(int x=0;x<cheeseSlices;x++)\\n            {\\n                if(4*x + 2*(cheeseSlices-x)==tomatoSlices)\\n                {\\n                    list.add(x);\\n                    list.add(cheeseSlices-x);\\n                    return list;\\n                }\\n            }\\n            \\n            return list;\\n        }\\n        \\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        List<Integer> list = new ArrayList<Integer>();\\n        if(tomatoSlices==0 && cheeseSlices==0)\\n        {\\n            \\n            list.add(0);\\n            list.add(0);\\n        }\\n        else\\n        {\\n            for(int x=0;x<cheeseSlices;x++)\\n            {\\n                if(4*x + 2*(cheeseSlices-x)==tomatoSlices)\\n                {\\n                    list.add(x);\\n                    list.add(cheeseSlices-x);\\n                    return list;\\n                }\\n            }\\n            \\n            return list;\\n        }\\n        \\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2699238,
                "title": "easy-to-understand-java-solution-beats-100-of-the-submissions",
                "content": "```\\npublic List<Integer> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        List<Integer> ans = new ArrayList<>();\\n        if (tomatoSlices%2!=0){\\n            return ans;\\n        }else if(tomatoSlices == 0 && cheeseSlices == 0){\\n            ans.add(0);\\n            ans.add(0);\\n            return ans;\\n        }\\n        double x = 0, y = 0;\\n        x = tomatoSlices/2 - cheeseSlices;\\n        y = 2*cheeseSlices-tomatoSlices/2;\\n        if ((int)x == x && (int)y == y && x>=0 && y>=0){\\n            ans.add((int) x);\\n            ans.add((int) y);\\n        }\\n        return ans;\\n    }\\n\\t```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\npublic List<Integer> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        List<Integer> ans = new ArrayList<>();\\n        if (tomatoSlices%2!=0){\\n            return ans;\\n        }else if(tomatoSlices == 0 && cheeseSlices == 0){\\n            ans.add(0);\\n            ans.add(0);\\n            return ans;\\n        }\\n        double x = 0, y = 0;\\n        x = tomatoSlices/2 - cheeseSlices;\\n        y = 2*cheeseSlices-tomatoSlices/2;\\n        if ((int)x == x && (int)y == y && x>=0 && y>=0){\\n            ans.add((int) x);\\n            ans.add((int) y);\\n        }\\n        return ans;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 2641779,
                "title": "easy-c-code-to-understand",
                "content": "class Solution {\\npublic:\\n    vector<int> numOfBurgers(int t, int c) {\\n        vector<int>ans;\\n        if((t-2*c)<0 or (t-2*c)%2!=0 or 4*c-t<0 or (4*c-t)%2!=0){\\n            return ans;\\n        }\\n        ans.push_back((t-2*c)/2);\\n        ans.push_back((4*c-t)/2);\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> numOfBurgers(int t, int c) {\\n        vector<int>ans;\\n        if((t-2*c)<0 or (t-2*c)%2!=0 or 4*c-t<0 or (4*c-t)%2!=0){\\n            return ans;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2585752,
                "title": "python-simple-math-solution",
                "content": "```\\nIt is easy to have the following equations:\\n4*x+2*y=to\\nx+y=ch\\n\\nSolving the previous equations lead x, y = (to-2*ch)//2, (4*ch-to)//2\\nWe also need to see whether the solution re-create the original inputs of to and ch\\n```\\n\\n```\\ndef numOfBurgers(self, to: int, ch: int) -> List[int]:\\n\\tx, y = (to-2*ch)//2, (4*ch-to)//2\\n\\treturn [x, y] if x>=0 and y>=0 and 4*x+2*y==to and x+y==ch else []\\n```",
                "solutionTags": [],
                "code": "```\\nIt is easy to have the following equations:\\n4*x+2*y=to\\nx+y=ch\\n\\nSolving the previous equations lead x, y = (to-2*ch)//2, (4*ch-to)//2\\nWe also need to see whether the solution re-create the original inputs of to and ch\\n```\n```\\ndef numOfBurgers(self, to: int, ch: int) -> List[int]:\\n\\tx, y = (to-2*ch)//2, (4*ch-to)//2\\n\\treturn [x, y] if x>=0 and y>=0 and 4*x+2*y==to and x+y==ch else []\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2576261,
                "title": "simple-maths-equation-in-python",
                "content": "b= big\\n\\ns= small\\n4b+2s= tomatoslices\\nb+s= cheeseslices\\n\\n```\\n    def numOfBurgers(self, tomatoSlices: int, cheeseSlices: int) -> List[int]:\\n        b= (tomatoSlices - 2* cheeseSlices)/2\\n        s= (4*cheeseSlices - tomatoSlices)/2\\n\\n        if b== int(b) and s== int(s) and (b>=0 and s>=0):\\n            return [int(b),int(s)]\\n        elif tomatoSlices==0 and cheeseSlices==0:\\n            return [0,0]\\n        else:\\n            return []\\n```",
                "solutionTags": [],
                "code": "```\\n    def numOfBurgers(self, tomatoSlices: int, cheeseSlices: int) -> List[int]:\\n        b= (tomatoSlices - 2* cheeseSlices)/2\\n        s= (4*cheeseSlices - tomatoSlices)/2\\n\\n        if b== int(b) and s== int(s) and (b>=0 and s>=0):\\n            return [int(b),int(s)]\\n        elif tomatoSlices==0 and cheeseSlices==0:\\n            return [0,0]\\n        else:\\n            return []\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2575749,
                "title": "python-easy-log-n-solution",
                "content": "\\tdef numOfBurgers(self, tomatoSlices: int, cheeseSlices: int) -> List[int]:\\n        if(tomatoSlices % 2 !=0):\\n            return []\\n        if(tomatoSlices < cheeseSlices * 2):\\n            return []\\n        if(tomatoSlices > cheeseSlices * 4):\\n            return []\\n        \\n        \\n        diff = int(cheeseSlices / 2)\\n        jumbo = diff\\n        small = cheeseSlices - jumbo\\n        total = 4 * jumbo + 2 * small\\n        \\n        while( total != tomatoSlices ):\\n            diff = int(diff / 2) or 1\\n            \\n            if(total > tomatoSlices):\\n                jumbo = jumbo - diff\\n                small = cheeseSlices - jumbo \\n                \\n            else:\\n                jumbo = jumbo + diff\\n                small = cheeseSlices - jumbo \\n        \\n            total = 4 * jumbo + 2 * small\\n            \\n        return [jumbo, small]",
                "solutionTags": [],
                "code": "\\tdef numOfBurgers(self, tomatoSlices: int, cheeseSlices: int) -> List[int]:\\n        if(tomatoSlices % 2 !=0):\\n            return []\\n        if(tomatoSlices < cheeseSlices * 2):\\n            return []\\n        if(tomatoSlices > cheeseSlices * 4):\\n            return []\\n        \\n        \\n        diff = int(cheeseSlices / 2)\\n        jumbo = diff\\n        small = cheeseSlices - jumbo\\n        total = 4 * jumbo + 2 * small\\n        \\n        while( total != tomatoSlices ):\\n            diff = int(diff / 2) or 1\\n            \\n            if(total > tomatoSlices):\\n                jumbo = jumbo - diff\\n                small = cheeseSlices - jumbo \\n                \\n            else:\\n                jumbo = jumbo + diff\\n                small = cheeseSlices - jumbo \\n        \\n            total = 4 * jumbo + 2 * small\\n            \\n        return [jumbo, small]",
                "codeTag": "Python3"
            },
            {
                "id": 2571150,
                "title": "c-o-1-solution-no-need-to-loop-math-equations-math",
                "content": "# Explanation\\n* **4x + 2y = Tomatos**\\n* **x+y = Cheese**\\n* X is No. Larger burger\\n* Y is No. smaller Burger\\nby solving these two equation together to evaluate each X and Y \\nwe get **y = cheese - x** And **x = (Tomatos - 2 * Cheese) /2**\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int T, int C) {\\n        vector<int>res;\\n        if (T % 2 == 0 && T >= C){\\n            int x = (T - 2*C)/2;\\n            int y = C - x;\\n            if (x < 0 || y < 0)return res; // count can\\'t be negatives\\n            res.push_back(x);\\n            res.push_back(y);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int T, int C) {\\n        vector<int>res;\\n        if (T % 2 == 0 && T >= C){\\n            int x = (T - 2*C)/2;\\n            int y = C - x;\\n            if (x < 0 || y < 0)return res; // count can\\'t be negatives\\n            res.push_back(x);\\n            res.push_back(y);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2570891,
                "title": "easy-c-solution",
                "content": "We will consider the small Burger =sm and Jumbo Burger=la;\\nThen we will apply some simple math to get the answer.\\n\\n```\\n\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int to, int ch) {\\n        int x=4*ch-to;\\n        if(x%2!=0) return {};\\n        else{\\n            int sm=x/2;\\n            int la=ch-sm;\\n            if(sm>=0 and la>=0){\\n            return {la,sm};\\n            }\\n            else\\n            {\\n                return {};\\n            }\\n        }\\n        return {};\\n        \\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int to, int ch) {\\n        int x=4*ch-to;\\n        if(x%2!=0) return {};\\n        else{\\n            int sm=x/2;\\n            int la=ch-sm;\\n            if(sm>=0 and la>=0){\\n            return {la,sm};\\n            }\\n            else\\n            {\\n                return {};\\n            }\\n        }\\n        return {};\\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2564607,
                "title": "python-o-1-one-statement",
                "content": "```\\nclass Solution:\\n    from typing import List\\n    def numOfBurgers(self, tomatoSlices: int, cheeseSlices: int) -> List[int]:\\n        return [] if (tomatoSlices - 2 * cheeseSlices) < 0 or (cheeseSlices * 4 - tomatoSlices) < 0 or tomatoSlices % 2 else [tomatoSlices //2 - cheeseSlices, cheeseSlices * 2 -tomatoSlices // 2]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    from typing import List\\n    def numOfBurgers(self, tomatoSlices: int, cheeseSlices: int) -> List[int]:\\n        return [] if (tomatoSlices - 2 * cheeseSlices) < 0 or (cheeseSlices * 4 - tomatoSlices) < 0 or tomatoSlices % 2 else [tomatoSlices //2 - cheeseSlices, cheeseSlices * 2 -tomatoSlices // 2]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2561957,
                "title": "c-simplest-solution-math",
                "content": "\\n\\t vector<int> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        \\n        // invalid case \\n        if(tomatoSlices &1 ){\\n            return {};\\n        }\\n        \\n        int y = (tomatoSlices/2) - cheeseSlices;\\n        int x = cheeseSlices -  y;\\n        \\n        // check not valid ans \\n        if(x <0 || y <0){\\n            return {};\\n        }\\n        \\n        return {y,x};\\n                                                                                             \\n        \\n    }",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "\\n\\t vector<int> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        \\n        // invalid case \\n        if(tomatoSlices &1 ){\\n            return {};\\n        }\\n        \\n        int y = (tomatoSlices/2) - cheeseSlices;\\n        int x = cheeseSlices -  y;\\n        \\n        // check not valid ans \\n        if(x <0 || y <0){\\n            return {};\\n        }\\n        \\n        return {y,x};\\n                                                                                             \\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2540689,
                "title": "java-100-fast",
                "content": "```\\nclass Solution {\\n    public List<Integer> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        List<Integer> l = new ArrayList<>();\\n        if(cheeseSlices*2 == tomatoSlices)\\n        {\\n            l.add(0);\\n            l.add(cheeseSlices);\\n        }\\n        else if(cheeseSlices*4 == tomatoSlices)\\n        {\\n            l.add(cheeseSlices);\\n            l.add(0);\\n        }\\n        else if(tomatoSlices - cheeseSlices*2 == 2)\\n        {\\n            l.add(1);\\n            l.add(cheeseSlices-1);\\n        }\\n        else if(tomatoSlices - cheeseSlices*2 > 2 && (tomatoSlices - cheeseSlices*2)%2==0)\\n        {\\n            int diff = 0;\\n            int a = (tomatoSlices - cheeseSlices*2)/4;\\n            if(((tomatoSlices - cheeseSlices*2)%4)==2)\\n            {\\n                diff = 1;\\n            }\\n            if(a*2+diff > cheeseSlices)\\n            {\\n                return l;\\n            }\\n            l.add(a*2+diff);\\n            l.add(cheeseSlices-(a*2+diff));\\n        }\\n        return l;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        List<Integer> l = new ArrayList<>();\\n        if(cheeseSlices*2 == tomatoSlices)\\n        {\\n            l.add(0);\\n            l.add(cheeseSlices);\\n        }\\n        else if(cheeseSlices*4 == tomatoSlices)\\n        {\\n            l.add(cheeseSlices);\\n            l.add(0);\\n        }\\n        else if(tomatoSlices - cheeseSlices*2 == 2)\\n        {\\n            l.add(1);\\n            l.add(cheeseSlices-1);\\n        }\\n        else if(tomatoSlices - cheeseSlices*2 > 2 && (tomatoSlices - cheeseSlices*2)%2==0)\\n        {\\n            int diff = 0;\\n            int a = (tomatoSlices - cheeseSlices*2)/4;\\n            if(((tomatoSlices - cheeseSlices*2)%4)==2)\\n            {\\n                diff = 1;\\n            }\\n            if(a*2+diff > cheeseSlices)\\n            {\\n                return l;\\n            }\\n            l.add(a*2+diff);\\n            l.add(cheeseSlices-(a*2+diff));\\n        }\\n        return l;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2529833,
                "title": "solve-a-linear-system-only-c-python",
                "content": "**C++**\\n```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        vector<int> v;\\n        int t = (tomatoSlices-2*cheeseSlices);\\n        int c = (4*cheeseSlices-tomatoSlices);\\n        if(t>=0 && c>=0){\\n            if(t%2==0 && c%2==0){\\n                v.push_back(t/2);\\n                v.push_back(c/2);\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```\\n**Python3**\\n```\\nclass Solution:\\n    def numOfBurgers(self, tomatoSlices: int, cheeseSlices: int) -> List[int]:\\n        v = []\\n        t = (tomatoSlices-2*cheeseSlices)\\n        c = (4*cheeseSlices-tomatoSlices)\\n        if(t>=0 and c>=0):\\n            if(t%2==0 and c%2==0):\\n                v.append(t//2)\\n                v.append(c//2)\\n        return v\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        vector<int> v;\\n        int t = (tomatoSlices-2*cheeseSlices);\\n        int c = (4*cheeseSlices-tomatoSlices);\\n        if(t>=0 && c>=0){\\n            if(t%2==0 && c%2==0){\\n                v.push_back(t/2);\\n                v.push_back(c/2);\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def numOfBurgers(self, tomatoSlices: int, cheeseSlices: int) -> List[int]:\\n        v = []\\n        t = (tomatoSlices-2*cheeseSlices)\\n        c = (4*cheeseSlices-tomatoSlices)\\n        if(t>=0 and c>=0):\\n            if(t%2==0 and c%2==0):\\n                v.append(t//2)\\n                v.append(c//2)\\n        return v\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2498928,
                "title": "cpp-tc-o-1-sc-o-1",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<int> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n\\t\\t\\t//below are the possible  conditions  to make burgers\\n\\t\\t\\t//tomatoSlices must be even \\n\\t\\t\\t//tomatoSlices/2 >= cheeseSlices && tomatoSlices/4<=cheeseSlices\\n\\n\\t\\t\\t//base case\\n\\t\\t\\tif((tomatoSlices&1) || (tomatoSlices/2 <cheeseSlices) || (tomatoSlices/4>cheeseSlices)){\\n\\t\\t\\t\\treturn {};\\n\\t\\t\\t}\\n\\n\\t\\t\\tint jumboBurgers=0,smallBurgers=0;\\n\\n\\t\\t\\t//total burgers can be made is equal to total cheeseSlices available\\n\\t\\t\\tsmallBurgers=(tomatoSlices/2);  \\n\\t\\t\\tjumboBurgers=smallBurgers-cheeseSlices;\\n\\t\\t\\tsmallBurgers=cheeseSlices-jumboBurgers;\\n\\n\\t\\t\\treturn {jumboBurgers,smallBurgers};\\n\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvector<int> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n\\t\\t\\t//below are the possible  conditions  to make burgers\\n\\t\\t\\t//tomatoSlices must be even \\n\\t\\t\\t//tomatoSlices/2 >= cheeseSlices && tomatoSlices/4<=cheeseSlices\\n\\n\\t\\t\\t//base case\\n\\t\\t\\tif((tomatoSlices&1) || (tomatoSlices/2 <cheeseSlices) || (tomatoSlices/4>cheeseSlices)){\\n\\t\\t\\t\\treturn {}",
                "codeTag": "Java"
            },
            {
                "id": 2489068,
                "title": "c-0ms-simple-logic",
                "content": "**Please do upvote if you liked my efforts :)**\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int t, int c) \\n    {\\n        int a, b;\\n        \\n        if(t%2 != 0 or t<2*c) return {};\\n        \\n        a = t/2-c, b = 2*c-t/2;\\n        if(a<0 or b<0 or 4*a + 2*b != t or a+b != c) return {};\\n        \\n        return {a, b};\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int t, int c) \\n    {\\n        int a, b;\\n        \\n        if(t%2 != 0 or t<2*c) return {};\\n        \\n        a = t/2-c, b = 2*c-t/2;\\n        if(a<0 or b<0 or 4*a + 2*b != t or a+b != c) return {};\\n        \\n        return {a, b};\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2460355,
                "title": "crisp-n-clear-o-n-javascript-memory-94-72-meaningful-vars",
                "content": "Runtime: 99 ms, faster than 82.35% of JavaScript online submissions for Number of Burgers with No Waste of Ingredients.\\nMemory Usage: 43.4 MB, less than 94.12% of JavaScript online submissions for Number of Burgers with No Waste of Ingredients.\\n```\\nvar numOfBurgers = function (tomatoSlices, cheeseSlices) {\\n  if (!(cheeseSlices * 2 <= tomatoSlices)) {\\n    return [];\\n  }\\n  if (tomatoSlices % 2 !== 0) {\\n    return [];\\n  }\\n  let halfTomatoSlices = tomatoSlices / 2;\\n  let jumbo = halfTomatoSlices - cheeseSlices;\\n  if (jumbo > cheeseSlices) {\\n    return [];\\n  }\\n  return [jumbo, cheeseSlices - jumbo];\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar numOfBurgers = function (tomatoSlices, cheeseSlices) {\\n  if (!(cheeseSlices * 2 <= tomatoSlices)) {\\n    return [];\\n  }\\n  if (tomatoSlices % 2 !== 0) {\\n    return [];\\n  }\\n  let halfTomatoSlices = tomatoSlices / 2;\\n  let jumbo = halfTomatoSlices - cheeseSlices;\\n  if (jumbo > cheeseSlices) {\\n    return [];\\n  }\\n  return [jumbo, cheeseSlices - jumbo];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2416647,
                "title": "math",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int ts, int cs) {\\n          if(ts&1) return {};\\n        \\n          int lb=(ts/4)+((ts%4)?1:0);\\n          int ub=(ts/2);\\n        \\n          if(cs<lb or cs>ub) return {};\\n          \\n          int fm=(ts/4); \\n        \\n          int ftke=0;\\n        \\n          while(ftke <= fm)\\n          {\\n              int bachelo=(ts - (ftke*4));\\n              int takenbytwo=(bachelo/2);\\n              \\n              if((ftke+takenbytwo) == cs){\\n                  return {ftke,takenbytwo};\\n              }\\n              \\n              ftke++; \\n          }\\n          \\n         return {};\\n          \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int ts, int cs) {\\n          if(ts&1) return {};\\n        \\n          int lb=(ts/4)+((ts%4)?1:0);\\n          int ub=(ts/2);\\n        \\n          if(cs<lb or cs>ub) return {};\\n          \\n          int fm=(ts/4); \\n        \\n          int ftke=0;\\n        \\n          while(ftke <= fm)\\n          {\\n              int bachelo=(ts - (ftke*4));\\n              int takenbytwo=(bachelo/2);\\n              \\n              if((ftke+takenbytwo) == cs){\\n                  return {ftke,takenbytwo};\\n              }\\n              \\n              ftke++; \\n          }\\n          \\n         return {};\\n          \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2416053,
                "title": "c-0ms-100-faster-math",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    vector<int> numOfBurgers(int tomatoSlices, int cheeseSlices)\\n    {\\n\\n        if (tomatoSlices == 0 and cheeseSlices == 0)\\n            return {0, 0};\\n        if (tomatoSlices % 2 != 0)\\n            return {};\\n\\n        if (tomatoSlices <= cheeseSlices)\\n            return {};\\n        if ((tomatoSlices - (2 * cheeseSlices)) % 2 != 0)\\n            return {};\\n\\n        int x = (tomatoSlices - (2 * cheeseSlices)) / 2;\\n        if (x < 0)\\n            return {};\\n\\n        int y = cheeseSlices - x;\\n        if (y < 0)\\n            return {};\\n\\n        return {x, y};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    vector<int> numOfBurgers(int tomatoSlices, int cheeseSlices)\\n    {\\n\\n        if (tomatoSlices == 0 and cheeseSlices == 0)\\n            return {0, 0};\\n        if (tomatoSlices % 2 != 0)\\n            return {};\\n\\n        if (tomatoSlices <= cheeseSlices)\\n            return {};\\n        if ((tomatoSlices - (2 * cheeseSlices)) % 2 != 0)\\n            return {};\\n\\n        int x = (tomatoSlices - (2 * cheeseSlices)) / 2;\\n        if (x < 0)\\n            return {};\\n\\n        int y = cheeseSlices - x;\\n        if (y < 0)\\n            return {};\\n\\n        return {x, y};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2414438,
                "title": "python-maths-formula",
                "content": "```\\nclass Solution:\\n    def numOfBurgers(self, tomatoSlices: int, cheeseSlices: int) -> List[int]:\\n        \\n        Jumbo = (tomatoSlices - 2*cheeseSlices) / 2\\n        \\n        Small = cheeseSlices - Jumbo\\n        \\n        if int(Jumbo) == Jumbo >= 0 and int(Small) == Small >= 0:\\n            return [int(Jumbo), int(Small)]\\n        \\n        return []\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numOfBurgers(self, tomatoSlices: int, cheeseSlices: int) -> List[int]:\\n        \\n        Jumbo = (tomatoSlices - 2*cheeseSlices) / 2\\n        \\n        Small = cheeseSlices - Jumbo\\n        \\n        if int(Jumbo) == Jumbo >= 0 and int(Small) == Small >= 0:\\n            return [int(Jumbo), int(Small)]\\n        \\n        return []\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2405898,
                "title": "easy-math-c",
                "content": "```\\n vector<int> numOfBurgers(int t, int c) {\\n        //4-1,2-1\\n        vector<int> v;\\n        t-=c*2;\\n        if(t%2!=0 || t<0)\\n            return v;\\n        int temp=t/2;\\n        v.push_back(temp);\\n        if((c-temp)<0)\\n            return {};\\n        v.push_back((c-temp));\\n        return v;\\n    }",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\n vector<int> numOfBurgers(int t, int c) {\\n        //4-1,2-1\\n        vector<int> v;\\n        t-=c*2;\\n        if(t%2!=0 || t<0)\\n            return v;\\n        int temp=t/2;\\n        v.push_back(temp);\\n        if((c-temp)<0)\\n            return {};\\n        v.push_back((c-temp));\\n        return v;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2368872,
                "title": "binary-search-c-clean-code-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        // Observation\\n        // Total Number of Burgers is Equal to Number of cheeseSlices\\n        // Try to make 1 --> cheeseSlices Amount of Jumbo Burgers and \\n        // remaining will be Small Burger\\n        vector <int> ans;\\n        if(tomatoSlices == 0 and cheeseSlices == 0) {\\n            ans.push_back(0), ans.push_back(0);\\n            return ans;\\n        }\\n        // Do Binary Search to Get Ideal Division.\\n        int low = 0, high = cheeseSlices;\\n        while(low < high) {\\n            int mid = (low + high) / 2;\\n            int jumbo = mid, small = cheeseSlices - mid;\\n            // Jumbo needs 4 tomatoes per burger\\n            // Small needs 2 tomatoes per burger\\n            int needJumboTom = jumbo * 4;\\n            int needSmallTom = small * 2;\\n            // Should Add Upto tomatoSlices\\n            if(needJumboTom + needSmallTom == tomatoSlices) {\\n                ans.push_back(jumbo), ans.push_back(small);\\n                break;\\n            } else if(needJumboTom + needSmallTom < tomatoSlices) {\\n                low = mid + 1;\\n            } else {\\n                high = mid;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\nHope You Like It :)",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        // Observation\\n        // Total Number of Burgers is Equal to Number of cheeseSlices\\n        // Try to make 1 --> cheeseSlices Amount of Jumbo Burgers and \\n        // remaining will be Small Burger\\n        vector <int> ans;\\n        if(tomatoSlices == 0 and cheeseSlices == 0) {\\n            ans.push_back(0), ans.push_back(0);\\n            return ans;\\n        }\\n        // Do Binary Search to Get Ideal Division.\\n        int low = 0, high = cheeseSlices;\\n        while(low < high) {\\n            int mid = (low + high) / 2;\\n            int jumbo = mid, small = cheeseSlices - mid;\\n            // Jumbo needs 4 tomatoes per burger\\n            // Small needs 2 tomatoes per burger\\n            int needJumboTom = jumbo * 4;\\n            int needSmallTom = small * 2;\\n            // Should Add Upto tomatoSlices\\n            if(needJumboTom + needSmallTom == tomatoSlices) {\\n                ans.push_back(jumbo), ans.push_back(small);\\n                break;\\n            } else if(needJumboTom + needSmallTom < tomatoSlices) {\\n                low = mid + 1;\\n            } else {\\n                high = mid;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2365094,
                "title": "o-1-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        vector<int> ans;\\n        int x=cheeseSlices-((4*cheeseSlices-tomatoSlices)/2);\\n        int y=(4*cheeseSlices-tomatoSlices)/2;\\n        if((4*cheeseSlices-tomatoSlices)%2==0 && x>=0 && y>=0)\\n        {\\n            ans.push_back(x);\\n            ans.push_back(y);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        vector<int> ans;\\n        int x=cheeseSlices-((4*cheeseSlices-tomatoSlices)/2);\\n        int y=(4*cheeseSlices-tomatoSlices)/2;\\n        if((4*cheeseSlices-tomatoSlices)%2==0 && x>=0 && y>=0)\\n        {\\n            ans.push_back(x);\\n            ans.push_back(y);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2355809,
                "title": "intuitive-just-math-nothing-relevant-to-programming",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        // 4 * x + 2 * y == tomato\\n        // 1 * x + 1 * y == cheese\\n        // => 2 * x == tomato - 2 * cheese\\n        \\n        int jumbo = tomatoSlices - 2 * cheeseSlices;\\n        if (jumbo % 2 or jumbo < 0 or cheeseSlices - jumbo / 2 < 0) return {};\\n        \\n        return {jumbo / 2, cheeseSlices - jumbo / 2};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        // 4 * x + 2 * y == tomato\\n        // 1 * x + 1 * y == cheese\\n        // => 2 * x == tomato - 2 * cheese\\n        \\n        int jumbo = tomatoSlices - 2 * cheeseSlices;\\n        if (jumbo % 2 or jumbo < 0 or cheeseSlices - jumbo / 2 < 0) return {};\\n        \\n        return {jumbo / 2, cheeseSlices - jumbo / 2};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2349343,
                "title": "c-simple-maths-solution-explained",
                "content": "Let the number of **jumbo burgers** be **m** and the number of **small burgers** be **n**.\\n\\nAccording to the problem, \\n--> for every jumbo burger, 4 tomatoSlices and 1 cheeseSlice are used\\n--> for every small burger, 1 tomatoSlice and 1 cheeseSlice is used.\\n\\nSimply create two linear equations for the above cases and solve :).\\nIf either **m** or **n** comes out to be negative means that we cannot create burgers with no waste of ingredients, therefore return {}.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        if(tomatoSlices%2 != 0) // if tomatoSlices are odd, tomato ingredient will be wasted for sure since both type of burgers use even number of tomato slices\\n            return {};\\n        \\n        int m, n;\\n        \\n        //4m + 2n = tomatoSlices;\\n        //m + n = cheeseSlices;\\n        \\n        m = (tomatoSlices-2*cheeseSlices)/2;\\n        n = (4*cheeseSlices-tomatoSlices)/2;\\n        \\n        if(m < 0 || n < 0)\\n            return {};\\n        \\n        vector<int> ans;\\n        ans.push_back(m);\\n        ans.push_back(n);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        if(tomatoSlices%2 != 0) // if tomatoSlices are odd, tomato ingredient will be wasted for sure since both type of burgers use even number of tomato slices\\n            return {};\\n        \\n        int m, n;\\n        \\n        //4m + 2n = tomatoSlices;\\n        //m + n = cheeseSlices;\\n        \\n        m = (tomatoSlices-2*cheeseSlices)/2;\\n        n = (4*cheeseSlices-tomatoSlices)/2;\\n        \\n        if(m < 0 || n < 0)\\n            return {};\\n        \\n        vector<int> ans;\\n        ans.push_back(m);\\n        ans.push_back(n);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2337371,
                "title": "java-easy-to-understand",
                "content": "\\'\\'\\'\\nclass Solution {\\n\\n    public List<Integer> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        \\n        List<Integer> l=new ArrayList<>();\\n        \\n        if(tomatoSlices%2!=0)\\n            return l;\\n        \\n        int x=tomatoSlices/2-cheeseSlices;\\n        \\n        if(x<0 || cheeseSlices-x<0)\\n            return l;\\n        \\n        l.add(x);\\n        l.add(cheeseSlices-x);\\n        \\n        return l;\\n    }\\n}\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "class Solution {\\n\\n    public List<Integer> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        \\n        List<Integer> l=new ArrayList<>();\\n        \\n        if(tomatoSlices%2!=0)\\n            return l;\\n        \\n        int x=tomatoSlices/2-cheeseSlices;\\n        \\n        if(x<0 || cheeseSlices-x<0)\\n            return l;\\n        \\n        l.add(x);\\n        l.add(cheeseSlices-x);\\n        \\n        return l;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2326286,
                "title": "python-easy-understanding-beats-100",
                "content": "```\\nclass Solution(object):\\n    def numOfBurgers(self, t, c):\\n        \\n        if t==c==0:\\n            return [0,0]\\n        four=(t-2*c)//2  # no of jumbo burgers by solving 4x+2y=t and x+y=c\\n        two=c-four #number of small burgers\\n        if c>=t or (t-2*c)%2==1 or four<0 or two<0: #if cheese is less than tomatoes or if number of jumbo burgers is a decimal or number of burgers are negtive we return empty list\\n            return []\\n        \\n        return [four,two]\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def numOfBurgers(self, t, c):\\n        \\n        if t==c==0:\\n            return [0,0]\\n        four=(t-2*c)//2  # no of jumbo burgers by solving 4x+2y=t and x+y=c\\n        two=c-four #number of small burgers\\n        if c>=t or (t-2*c)%2==1 or four<0 or two<0: #if cheese is less than tomatoes or if number of jumbo burgers is a decimal or number of burgers are negtive we return empty list\\n            return []\\n        \\n        return [four,two]\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2314394,
                "title": "java-simple-mathematical-solution-2-approaches-1ms-3ms",
                "content": "**Inefficient solution | O(n)**\\n```\\npublic List<Integer> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        if((tomatoSlices&1)==1)\\n            return new ArrayList<Integer>();\\n        if(cheeseSlices > tomatoSlices/2)\\n            return new ArrayList<Integer>();\\n        int jBurgers = 0;\\n        while(tomatoSlices>2*cheeseSlices && tomatoSlices>0 && cheeseSlices>0){\\n            tomatoSlices -= 4;\\n            cheeseSlices--;\\n            jBurgers++;\\n        }\\n        if(tomatoSlices==2*cheeseSlices)\\n            return Arrays.asList(jBurgers, cheeseSlices);\\n        return new ArrayList<Integer>();\\n    }\\n```\\n\\n**Efficient solution (1ms-3ms) | O(1)**\\n```\\n   public List<Integer> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        List<Integer> ans = new ArrayList<>();\\n        if((tomatoSlices&1)==1)\\n            return ans;\\n        if(cheeseSlices > tomatoSlices/2 || tomatoSlices > 4*cheeseSlices)\\n            return ans;\\n        int jumbo = (tomatoSlices-cheeseSlices*2)/2;\\n        ans.add(jumbo);\\n        ans.add(cheeseSlices-jumbo);\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\npublic List<Integer> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        if((tomatoSlices&1)==1)\\n            return new ArrayList<Integer>();\\n        if(cheeseSlices > tomatoSlices/2)\\n            return new ArrayList<Integer>();\\n        int jBurgers = 0;\\n        while(tomatoSlices>2*cheeseSlices && tomatoSlices>0 && cheeseSlices>0){\\n            tomatoSlices -= 4;\\n            cheeseSlices--;\\n            jBurgers++;\\n        }\\n        if(tomatoSlices==2*cheeseSlices)\\n            return Arrays.asList(jBurgers, cheeseSlices);\\n        return new ArrayList<Integer>();\\n    }\\n```\n```\\n   public List<Integer> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        List<Integer> ans = new ArrayList<>();\\n        if((tomatoSlices&1)==1)\\n            return ans;\\n        if(cheeseSlices > tomatoSlices/2 || tomatoSlices > 4*cheeseSlices)\\n            return ans;\\n        int jumbo = (tomatoSlices-cheeseSlices*2)/2;\\n        ans.add(jumbo);\\n        ans.add(cheeseSlices-jumbo);\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2297276,
                "title": "two-equations-in-two-unknowns-python",
                "content": "```\\ndef numOfBurgers(self, tomatoSlices: int, cheeseSlices: int) -> List[int]:\\n        ns = (4*cheeseSlices - tomatoSlices)/2\\n        nj = cheeseSlices- ns                \\n        \\n        if nj < 0 or ns < 0 or (4*int(nj)+ 2*int(ns)) != tomatoSlices or (int(nj) + int(ns)) != cheeseSlices :\\n            return []\\n        else:\\n            return[int(nj), int(ns)]",
                "solutionTags": [],
                "code": "```\\ndef numOfBurgers(self, tomatoSlices: int, cheeseSlices: int) -> List[int]:\\n        ns = (4*cheeseSlices - tomatoSlices)/2\\n        nj = cheeseSlices- ns                \\n        \\n        if nj < 0 or ns < 0 or (4*int(nj)+ 2*int(ns)) != tomatoSlices or (int(nj) + int(ns)) != cheeseSlices :\\n            return []\\n        else:\\n            return[int(nj), int(ns)]",
                "codeTag": "Python3"
            },
            {
                "id": 2263824,
                "title": "python-pure-math-explained",
                "content": "```\\ndef numOfBurgers(self, tomatoSlices: int, cheeseSlices: int) -> List[int]:\\n\\t\"\"\"\\n\\t\\tj: jumbo , s: small,  so we can get :\\n\\t\\t4j + 2s = t\\n\\t\\tj + s = c\\n\\t\\t==>\\n\\t\\t2j = t-2c  => j = (t-2c)/2\\n\\t\\t2s = 4c-t  => s = 2c-t/2\\n\\t\\t\\n\\t\\tSo , now the objective is to get non-negative answer for j and s\\n\\t\"\"\"\\n\\tt, c = tomatoSlices, cheeseSlices\\n\\tj = (t-2*c)/2 \\n\\tif int(j) != j or j < 0:\\n\\t\\treturn []\\n\\ts = 2*c - t/2\\n\\n\\tif int(s) != s or s < 0:\\n\\t\\treturn []\\n\\treturn [int(j), int(s)]\\n```",
                "solutionTags": [],
                "code": "```\\ndef numOfBurgers(self, tomatoSlices: int, cheeseSlices: int) -> List[int]:\\n\\t\"\"\"\\n\\t\\tj: jumbo , s: small,  so we can get :\\n\\t\\t4j + 2s = t\\n\\t\\tj + s = c\\n\\t\\t==>\\n\\t\\t2j = t-2c  => j = (t-2c)/2\\n\\t\\t2s = 4c-t  => s = 2c-t/2\\n\\t\\t\\n\\t\\tSo , now the objective is to get non-negative answer for j and s\\n\\t\"\"\"\\n\\tt, c = tomatoSlices, cheeseSlices\\n\\tj = (t-2*c)/2 \\n\\tif int(j) != j or j < 0:\\n\\t\\treturn []\\n\\ts = 2*c - t/2\\n\\n\\tif int(s) != s or s < 0:\\n\\t\\treturn []\\n\\treturn [int(j), int(s)]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2208887,
                "title": "equations-in-my-programming-seriously-upd",
                "content": "```\\nclass Solution:\\n    def numOfBurgers(self, tomatoSlices: int, cheeseSlices: int) -> List[int]:\\n\\t\\tif (tomatoSlices % 2 == 1): #UPD that improve speed almost twice\\n\\t\\t\\treturn []\\n        \"\"\"\\n        a system of two equations:\\n            4x+2y = tomatoSlices\\n            x+y = cheeseSlices\\n        \"\"\"\\n        x = tomatoSlices/2 - cheeseSlices\\n        y =  (cheeseSlices-x)\\n        if (0<=x==int(x))*(0<=y==int(y)):\\n            return [int(x),int(y)]\\n        return []",
                "solutionTags": [
                    "Python",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def numOfBurgers(self, tomatoSlices: int, cheeseSlices: int) -> List[int]:\\n\\t\\tif (tomatoSlices % 2 == 1): #UPD that improve speed almost twice\\n\\t\\t\\treturn []\\n        \"\"\"\\n        a system of two equations:\\n            4x+2y = tomatoSlices\\n            x+y = cheeseSlices\\n        \"\"\"\\n        x = tomatoSlices/2 - cheeseSlices\\n        y =  (cheeseSlices-x)\\n        if (0<=x==int(x))*(0<=y==int(y)):\\n            return [int(x),int(y)]\\n        return []",
                "codeTag": "Java"
            },
            {
                "id": 2172522,
                "title": "c-solution-based-on-math",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int t, int c) {\\n\\n        int delta_a = (t - 2 * c);\\n        int delta_b = (-t + 4 * c);\\n        if (delta_a % 2 == 1 || delta_b % 2 == 1){\\n            return {};\\n        }\\n        int j = delta_a / 2;\\n        int s = delta_b / 2;\\n        if (j < 0 || s < 0){\\n            return {};\\n        }\\n        return {j, s}; \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int t, int c) {\\n\\n        int delta_a = (t - 2 * c);\\n        int delta_b = (-t + 4 * c);\\n        if (delta_a % 2 == 1 || delta_b % 2 == 1){\\n            return {};\\n        }\\n        int j = delta_a / 2;\\n        int s = delta_b / 2;\\n        if (j < 0 || s < 0){\\n            return {};\\n        }\\n        return {j, s}; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2166808,
                "title": "linear-equation-problem-using-python3",
                "content": "4x + 2y = tomatoSlices = t\\nx + y = cheese slices = c\\nwhere 4x+y => Jumbo Burger\\nand 2x+y => Small Burger\\n, after solving the equations we get,\\n\\nx = (t - 2*c)/2\\ny = (4*c-t)/2\\n\\n```\\ndef numOfBurgers(self, tomatoSlices: int, cheeseSlices: int) -> List[int]:\\n        x = (tomatoSlices - 2*cheeseSlices)/2\\n        y = (4*cheeseSlices - tomatoSlices)/2\\n        if x<0 or y<0 or int(x)!=x or int(y)!=y:\\n            return []\\n        else:\\n            return [int(x),int(y)]\\n``\\n",
                "solutionTags": [
                    "Python",
                    "Math"
                ],
                "code": "4x + 2y = tomatoSlices = t\\nx + y = cheese slices = c\\nwhere 4x+y => Jumbo Burger\\nand 2x+y => Small Burger\\n, after solving the equations we get,\\n\\nx = (t - 2*c)/2\\ny = (4*c-t)/2\\n\\n```\\ndef numOfBurgers(self, tomatoSlices: int, cheeseSlices: int) -> List[int]:\\n        x = (tomatoSlices - 2*cheeseSlices)/2\\n        y = (4*cheeseSlices - tomatoSlices)/2\\n        if x<0 or y<0 or int(x)!=x or int(y)!=y:\\n            return []\\n        else:\\n            return [int(x),int(y)]\\n``\\n",
                "codeTag": "Python3"
            },
            {
                "id": 2125510,
                "title": "c-simple-mathematics",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int tomato, int cheese) {\\n        if(tomato%2) return {};\\n        int j=tomato/2-cheese;\\n        int s=cheese-j;\\n        if(s<0 or j<0){\\n            return {};\\n        }\\n        return {j,s};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int tomato, int cheese) {\\n        if(tomato%2) return {};\\n        int j=tomato/2-cheese;\\n        int s=cheese-j;\\n        if(s<0 or j<0){\\n            return {};\\n        }\\n        return {j,s};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2120256,
                "title": "python-3-simple-o-1-math-solution",
                "content": "```\\nclass Solution:\\n    def numOfBurgers(self, tomatoSlices: int, cheeseSlices: int) -> List[int]:\\n        if tomatoSlices % 2:\\n            return []\\n        jumbo = tomatoSlices // 2 - cheeseSlices\\n        if jumbo < 0 or cheeseSlices < jumbo:\\n            return []\\n        return [jumbo, cheeseSlices - jumbo]",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def numOfBurgers(self, tomatoSlices: int, cheeseSlices: int) -> List[int]:\\n        if tomatoSlices % 2:\\n            return []\\n        jumbo = tomatoSlices // 2 - cheeseSlices\\n        if jumbo < 0 or cheeseSlices < jumbo:\\n            return []\\n        return [jumbo, cheeseSlices - jumbo]",
                "codeTag": "Java"
            },
            {
                "id": 2101555,
                "title": "simple-javascript-solution",
                "content": "```\\nfunction numOfBurgers(a, b, s = 0) {\\n    while (a > 0 && b > 0 && a !== 2 * b) a -= 4, --b, ++s\\n    return a === 2 * b ? [s, b] : []\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfunction numOfBurgers(a, b, s = 0) {\\n    while (a > 0 && b > 0 && a !== 2 * b) a -= 4, --b, ++s\\n    return a === 2 * b ? [s, b] : []\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2089539,
                "title": "easy-java-solution-beginner-friendly",
                "content": "**Please Upvote if You Liked The Solution.**\\n```\\nclass Solution {\\n    public List<Integer> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        List<Integer>list=new ArrayList<>();\\n        int ts=tomatoSlices;\\n        int cs=cheeseSlices;\\n        if (ts<cs*2 || ts>cs*4 || ts%2!=0 || (ts==0 && cs>0) || (cs==0 && ts>0))\\n        {\\n            return list;\\n        }\\n        int cnt=0;\\n        while(ts>0 && cs>0 && ts!=cs*2)\\n        {\\n            ts-=4;\\n            cnt++;\\n            cs--;\\n        }\\n        list.add(cnt);\\n        list.add(cs);\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        List<Integer>list=new ArrayList<>();\\n        int ts=tomatoSlices;\\n        int cs=cheeseSlices;\\n        if (ts<cs*2 || ts>cs*4 || ts%2!=0 || (ts==0 && cs>0) || (cs==0 && ts>0))\\n        {\\n            return list;\\n        }\\n        int cnt=0;\\n        while(ts>0 && cs>0 && ts!=cs*2)\\n        {\\n            ts-=4;\\n            cnt++;\\n            cs--;\\n        }\\n        list.add(cnt);\\n        list.add(cs);\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2080150,
                "title": "python-simple-algebra",
                "content": "We first simply tomatoSlices as t, cheeseSlices as c.\\nLet\\'s assume there are x jumbo and y small. We will have the following euqations:\\n* 4x + 2y = t\\n* 2x + y = c\\n\\nSolving the above equations, we need to make sure that both x and y will be non-negative integers. \\n```\\ndef numOfBurgers(self, t: int, c: int) -> List[int]:\\n\\tif (t - 2 * c) % 2 or (t - 2 * c) < 0: return []\\n\\tif c < (t - 2 * c) // 2: return []\\n\\treturn [ (t - 2 * c) // 2, c - (t - 2 * c) // 2 ]\\n```",
                "solutionTags": [
                    "Python",
                    "Math"
                ],
                "code": "```\\ndef numOfBurgers(self, t: int, c: int) -> List[int]:\\n\\tif (t - 2 * c) % 2 or (t - 2 * c) < 0: return []\\n\\tif c < (t - 2 * c) // 2: return []\\n\\treturn [ (t - 2 * c) // 2, c - (t - 2 * c) // 2 ]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2073954,
                "title": "java-linear-algebra-based-solution",
                "content": "This is similar to solving a linear algebra question. The result of S and J can\\'t be negative and can\\'t be a fraction.\\n\\nLet J be the number of Jumbo Burgers, S be the number of Small Burgers.\\n\\n4J + 2S = tomatoSlices\\nJ+S = cheeseSlices\\n     \\nJ = cheeseSlices - S;\\n4J + 2S = tomatoSlices\\n4 * (cheeseSlices - S) + 2S = tomatoSlices;\\n4 * cheeseSlices - 4S + 2S = tomatoSlices;\\n4 * cheeseSlices - 2S = tomatoSlices;\\ntomatoSlices - 4 * cheeseSlices = - 2S;\\n0-(tomatoSlices - 4 * cheeseSlices) = 2S;\\nAnd we can substitute S back into the J + S = Cheese to find J.\\n\\nIf either is negative or not an integer, then we return an empty list.\\n```\\nclass Solution {\\n    public List<Integer> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        if(tomatoSlices % 2 == 1) return new ArrayList();\\n        \\n        \\n        // Both can\\'t be negative!\\n        int twiceNumS = -tomatoSlices + 4 * cheeseSlices;\\n        if(twiceNumS >= 0 && twiceNumS % 2 == 0){\\n            int numS = twiceNumS / 2;\\n            int numJ = cheeseSlices - numS;\\n            if(numJ >= 0){\\n                ArrayList<Integer> ans = new ArrayList();\\n                ans.add(numJ);\\n                ans.add(numS);\\n                return ans;\\n            }\\n        }\\n        return new ArrayList();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        if(tomatoSlices % 2 == 1) return new ArrayList();\\n        \\n        \\n        // Both can\\'t be negative!\\n        int twiceNumS = -tomatoSlices + 4 * cheeseSlices;\\n        if(twiceNumS >= 0 && twiceNumS % 2 == 0){\\n            int numS = twiceNumS / 2;\\n            int numJ = cheeseSlices - numS;\\n            if(numJ >= 0){\\n                ArrayList<Integer> ans = new ArrayList();\\n                ans.add(numJ);\\n                ans.add(numS);\\n                return ans;\\n            }\\n        }\\n        return new ArrayList();\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1968114,
                "content": [
                    {
                        "username": "prometheus101112",
                        "content": "Simple 2 equations and 2 variables problem. Any other ways of solving it ? Do tell"
                    }
                ]
            }
        ]
    }
]