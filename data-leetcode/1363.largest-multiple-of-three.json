[
    {
        "title": "Minimum Falling Path Sum",
        "question_content": "Given an n x n array of integers matrix, return the minimum sum of any falling path through matrix.\nA falling path starts at any element in the first row and chooses the element in the next row that is either directly below or diagonally left/right. Specifically, the next element from position (row, col) will be (row + 1, col - 1), (row + 1, col), or (row + 1, col + 1).\n&nbsp;\nExample 1:\n\nInput: matrix = [[2,1,3],[6,5,4],[7,8,9]]\nOutput: 13\nExplanation: There are two falling paths with a minimum sum as shown.\n\nExample 2:\n\nInput: matrix = [[-19,57],[-40,-5]]\nOutput: -59\nExplanation: The falling path with a minimum sum is shown.\n\n&nbsp;\nConstraints:\n\n\tn == matrix.length == matrix[i].length\n\t1 <= n <= 100\n\t-100 <= matrix[i][j] <= 100",
        "solutions": [
            {
                "id": 186666,
                "title": "c-java-4-lines-dp",
                "content": "The minimum path to get to element ```A[i][j]``` is the minimum of ```A[i - 1][j - 1]```, ```A[i - 1][j]``` and ```A[i - 1][j + 1]```. \\nStarting from row 1, we add the minumum path to each element. The smallest number in the last row is the miminum path sum.\\nExample:\\n[1, 2, 3]\\n[4, 5, 6] => [5, 6, 8]\\n[7, 8, 9] => [7, 8, 9] => [12, 13, 15]\\n\\n**C++**\\n```cpp\\nint minFallingPathSum(vector<vector<int>>& A) {\\n  for (auto i = 1; i < A.size(); ++i)\\n    for (auto j = 0; j < A.size(); ++j)\\n      A[i][j] += min({ A[i-1][j], A[i-1][max(0,j-1)], A[i-1][min((int)A.size()-1,j+1)] });\\n  return *min_element(begin(A[A.size() - 1]), end(A[A.size() - 1]));\\n}\\n```\\n\\n**Java**\\n```java\\npublic int minFallingPathSum(int[][] A) {\\n  for (int i = 1; i < A.length; ++i)\\n    for (int j = 0; j < A.length; ++j)\\n      A[i][j] += Math.min(A[i - 1][j], Math.min(A[i - 1][Math.max(0, j - 1)], A[i - 1][Math.min(A.length - 1, j + 1)]));\\n  return Arrays.stream(A[A.length - 1]).min().getAsInt();\\n}        \\n```",
                "solutionTags": [],
                "code": "```A[i][j]```\n```A[i - 1][j - 1]```\n```A[i - 1][j]```\n```A[i - 1][j + 1]```\n```cpp\\nint minFallingPathSum(vector<vector<int>>& A) {\\n  for (auto i = 1; i < A.size(); ++i)\\n    for (auto j = 0; j < A.size(); ++j)\\n      A[i][j] += min({ A[i-1][j], A[i-1][max(0,j-1)], A[i-1][min((int)A.size()-1,j+1)] });\\n  return *min_element(begin(A[A.size() - 1]), end(A[A.size() - 1]));\\n}\\n```\n```java\\npublic int minFallingPathSum(int[][] A) {\\n  for (int i = 1; i < A.length; ++i)\\n    for (int j = 0; j < A.length; ++j)\\n      A[i][j] += Math.min(A[i - 1][j], Math.min(A[i - 1][Math.max(0, j - 1)], A[i - 1][Math.min(A.length - 1, j + 1)]));\\n  return Arrays.stream(A[A.length - 1]).min().getAsInt();\\n}        \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 186689,
                "title": "java-dp-solution-with-graph-illustrated-explanations",
                "content": "The solution is definitely not optimal, nor is the code as \"elegant\", but the idea is straght forward, hope it helps :)\n\nGiven matrix like the left part in the graph below, we first initialize a 2D DP matrix, and then iterate the original matrix row by row. For each element in DP matrix, we sum up the **corresponding element from original matrix** with the **minimum neighbors from previous row in DP matrix**. \nIn order to save the future hassles dealing with index boundries while iterating the matrix, I added the **two extra columns** and assigned them as `Integer.MAX_VALUE`.\n\nThe idea is illustrated as following:\n![image](https://assets.leetcode.com/users/yfgu0618/image_1540698728.png)\n\nFollowing is the code:\n```java\npublic static int minFallingPathSum(int[][] A) {\n  int rows = A.length;\n  int cols = A[0].length;\n  // DP matrix has 2 extra columns\n  int[][] dp = new int[rows][cols + 2];\n  // Fill the first row of DP matrix\n  for (int i = 1; i <= cols; i++) {\n    dp[0][i] = A[0][i - 1];\n  }\n  // Fill Integer.MAX_VALUE into first and last column of DP matrix\n  for (int i = 0; i < rows; i++) {\n    dp[i][0] = Integer.MAX_VALUE;\n    dp[i][cols + 1] = Integer.MAX_VALUE;\n  }\n  // Building the DP matrix\n  for (int i = 1; i < rows; i++) {\n    for (int j = 1; j <= cols; j++) {\n      // Find the minimum neighbor from previous row in DP matrix\n      int minNeighbor = Math.min(dp[i - 1][j - 1], dp[i - 1][j]);\n      minNeighbor = Math.min(minNeighbor, dp[i - 1][j + 1]);\n      dp[i][j] = A[i][j - 1] + minNeighbor;\n    }\n  }\n  // The minimum path sum is minimum of the last row in DP matrix\n  int min = Integer.MAX_VALUE;\n  for (int i = 1; i <= cols; i++) {\n    min = Math.min(min, dp[rows - 1][i]);\n  }\n  return min;\n}\n```\n",
                "solutionTags": [],
                "code": "```java\npublic static int minFallingPathSum(int[][] A) {\n  int rows = A.length;\n  int cols = A[0].length;\n  // DP matrix has 2 extra columns\n  int[][] dp = new int[rows][cols + 2];\n  // Fill the first row of DP matrix\n  for (int i = 1; i <= cols; i++) {\n    dp[0][i] = A[0][i - 1];\n  }\n  // Fill Integer.MAX_VALUE into first and last column of DP matrix\n  for (int i = 0; i < rows; i++) {\n    dp[i][0] = Integer.MAX_VALUE;\n    dp[i][cols + 1] = Integer.MAX_VALUE;\n  }\n  // Building the DP matrix\n  for (int i = 1; i < rows; i++) {\n    for (int j = 1; j <= cols; j++) {\n      // Find the minimum neighbor from previous row in DP matrix\n      int minNeighbor = Math.min(dp[i - 1][j - 1], dp[i - 1][j]);\n      minNeighbor = Math.min(minNeighbor, dp[i - 1][j + 1]);\n      dp[i][j] = A[i][j - 1] + minNeighbor;\n    }\n  }\n  // The minimum path sum is minimum of the last row in DP matrix\n  int min = Integer.MAX_VALUE;\n  for (int i = 1; i <= cols; i++) {\n    min = Math.min(min, dp[rows - 1][i]);\n  }\n  return min;\n}\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 381898,
                "title": "python-not-shortest-but-easiest-to-understand-with-explanation",
                "content": "\\nTried to give a decent explanation of how to look at problem. Let me know if there is anything that is hard to understand.\\n    \\n    #this problem will use DP \\n    #by taking the minimum value from itself plus one of the 3 values right above it\\n\\n    #EX: \\n    # 1  2  3   \\n    # 4  5  6  \\n    # 7  8  9 \\n\\n    # new value for number at A[1][1] will be  min(5 + 1, 5 + 2, 5 + 3)\\n    # therefore it will be 5 + 1 = 6, and 6 will then replace the value at A[1][1]\\n\\n    #new value for number at A[1][0] will be  min(4 + 1, 4 + 2) = 5\\n    #it will only have two values to compare since there is no upper left value\\n\\n    #new value for number at A[1][2] will be  min(6 + 2, 6 + 3) = 8\\n    #it will only have two values to compare since there is no upper right value\\n    \\n    def minFallingPathSum(self, A: List[List[int]]) -> int:\\n        for i in range(1,len(A)):\\n            for j in range(len(A[0])):\\n\\t\\t\\t\\n                #edge cases are first column and last column which only have two paths from above\\n                if j == 0:\\n                    A[i][j]  = min((A[i][j] + A[i - 1][j]), (A[i][j] + A[i - 1][j + 1]) )\\n\\t\\t\\t\\t\\t\\n                elif (j == len(A[0]) - 1):\\n                    A[i][j]  = min((A[i][j] + A[i - 1][j]), (A[i][j] + A[i - 1][j - 1]) )\\n\\t\\t\\t\\t\\t\\n                #every other column will have three paths coming from above\\n                else:\\n                    A[i][j] = min(A[i][j] + A[i - 1][j],A[i][j] + A[i - 1][j + 1], A[i][j] + A[i - 1][j - 1])\\n            \\n\\t\\t# Now that minimum falling sums for each value at the bottom row have been computer\\n\\t\\t# We can just take the min of the bottow row to get the smallest overall path sum \\n        return min(A[len(A) - 1])\\n",
                "solutionTags": [],
                "code": "\\nTried to give a decent explanation of how to look at problem. Let me know if there is anything that is hard to understand.\\n    \\n    #this problem will use DP \\n    #by taking the minimum value from itself plus one of the 3 values right above it\\n\\n    #EX: \\n    # 1  2  3   \\n    # 4  5  6  \\n    # 7  8  9 \\n\\n    # new value for number at A[1][1] will be  min(5 + 1, 5 + 2, 5 + 3)\\n    # therefore it will be 5 + 1 = 6, and 6 will then replace the value at A[1][1]\\n\\n    #new value for number at A[1][0] will be  min(4 + 1, 4 + 2) = 5\\n    #it will only have two values to compare since there is no upper left value\\n\\n    #new value for number at A[1][2] will be  min(6 + 2, 6 + 3) = 8\\n    #it will only have two values to compare since there is no upper right value\\n    \\n    def minFallingPathSum(self, A: List[List[int]]) -> int:\\n        for i in range(1,len(A)):\\n            for j in range(len(A[0])):\\n\\t\\t\\t\\n                #edge cases are first column and last column which only have two paths from above\\n                if j == 0:\\n                    A[i][j]  = min((A[i][j] + A[i - 1][j]), (A[i][j] + A[i - 1][j + 1]) )\\n\\t\\t\\t\\t\\t\\n                elif (j == len(A[0]) - 1):\\n                    A[i][j]  = min((A[i][j] + A[i - 1][j]), (A[i][j] + A[i - 1][j - 1]) )\\n\\t\\t\\t\\t\\t\\n                #every other column will have three paths coming from above\\n                else:\\n                    A[i][j] = min(A[i][j] + A[i - 1][j],A[i][j] + A[i - 1][j + 1], A[i][j] + A[i - 1][j - 1])\\n            \\n\\t\\t# Now that minimum falling sums for each value at the bottom row have been computer\\n\\t\\t# We can just take the min of the bottow row to get the smallest overall path sum \\n        return min(A[len(A) - 1])\\n",
                "codeTag": "Python3"
            },
            {
                "id": 1191340,
                "title": "c-4-solutions-from-bruteforce-to-dp-with-explainations",
                "content": "Let\\'s start from the brute force, a good way is to think is a recursive fashion which helps to understand the base cases and how to implement the iterative one.\\n\\nIf we start from the row 1 in the matrix we need to pick for every position of the matrix the min value between:\\n- Matrix[r-1][c-1] + matrix[r][c] which means we have reach pos [r][c] from left\\n- Matrix[r-1][c+1] + matrix[r][c] which means we have reach pos [r][c] from right\\n- Matrix[r-1][c] + matrix[r][c] which means we have reach pos [r][c] from the middle\\n\\nBetween these we need to pick the minimum, paying attention to the matrix indexes (Don\\'t get out of boundaries) which reppresent a base case for the recursive calls.\\nThe other base case is when we reach the end so r = 0 in the case of the brute force.\\n\\nAfter having calculate the minimum value that lead to all the positions matrix[rows-1][c] we can just iterate through those values and take the max.\\n\\nHere is the brute force using recursion.\\n```\\n//Brute force TLE\\nclass Solution {\\npublic:\\n        int minFallingPathSumHelper(vector<vector<int>>& matrix, int r, int c){\\n        if(r == 0 and c < matrix[0].size() and c >= 0) return matrix[r][c]; \\n        if(c >= matrix[0].size() or c < 0) return INT_MAX;\\n        \\n        return matrix[r][c] + min(min(minFallingPathSumHelper(matrix, r-1, c+1), minFallingPathSumHelper(matrix, r-1, c)), minFallingPathSumHelper(matrix, r-1, c-1));\\n        \\n    }\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int rows = matrix.size(), cols = matrix[0].size();\\n        int ans = INT_MAX;\\n        for(int c=0; c < cols; c++){\\n            ans = min(ans, minFallingPathSumHelper(matrix, rows-1, c));\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nSomething you can note is that we are reapeting a bunch of calls, we can optimize using a memo that keeps the values for the position which are already calculated. We just need to initialize the memo with a value, INT_MAX since we can have also negative numbers. And if we haven\\'t calculated the value yet we do recursion as in the bruteforce otherwise we hit the cache.\\n\\n```\\n//Top-down Recursive with memo\\nclass Solution {\\npublic:\\n    int minFallingPathSumHelper(vector<vector<int>>& matrix, int r, int c, vector<vector<int>>& dp){\\n        if(r == 0 and c < matrix[0].size() and c >= 0) return matrix[r][c]; \\n        if(c >= matrix[0].size() or c < 0) return INT_MAX;\\n        \\n        if(dp[r][c] != INT_MAX) return dp[r][c];\\n        return dp[r][c] = matrix[r][c] + min(min(minFallingPathSumHelper(matrix, r-1, c+1, dp), minFallingPathSumHelper(matrix, r-1, c, dp)), minFallingPathSumHelper(matrix, r-1, c-1, dp));\\n        \\n    }\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int rows = matrix.size(), cols = matrix[0].size();\\n        vector<vector<int>> dp(rows+1, vector<int>(cols+1, INT_MAX));\\n        int ans = INT_MAX;\\n        for(int c=0; c < cols; c++){\\n            ans = min(ans, minFallingPathSumHelper(matrix, rows-1, c, dp));\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nAs I was saying before you can rethink the logic in the opposite way in a bottom-up fashion:\\n```\\n //Bottom-up Recursive with memo\\nclass Solution {\\npublic:\\n    int minFallingPathSumHelper(vector<vector<int>>& matrix, int r, int c, vector<vector<int>>& dp){\\n        if(r == matrix.size()-1 and c < matrix[0].size() and c >= 0) return matrix[r][c]; \\n        if(c >= matrix[0].size() or c < 0) return INT_MAX;\\n        \\n        if(dp[r][c] != INT_MAX) return dp[r][c];\\n        return dp[r][c] = matrix[r][c] + min(min(minFallingPathSumHelper(matrix, r+1, c-1, dp), minFallingPathSumHelper(matrix, r+1, c, dp)), minFallingPathSumHelper(matrix, r+1, c+1, dp));\\n        \\n    }\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int rows = matrix.size(), cols = matrix[0].size();\\n        vector<vector<int>> dp(rows+1, vector<int>(cols+1, INT_MAX));\\n        int ans = INT_MAX;\\n        for(int c=0; c < cols; c++){\\n            ans = min(ans, minFallingPathSumHelper(matrix, 0, c, dp));\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nThe last two solutions make use of a memo called dp which store preview calculation + occupies space with the recursive calls. So we can say that it takes O(mn) time and O(mn) extra space.\\n\\n\\nAnother approach could be (in the case you\\'re allowed to modify the input to store directly the calculation of the minimum path until that position directly in the matrix. This would need O(mn) time and O(1) extra space.\\nThe following solution can be adapted using a copy of the matrix to not modify the input using O(mn) space.\\n\\n```\\n//Iterative bottom-up solution\\nclass Solution {\\npublic:\\n    int customMin(int a, int b, int c){\\n        return min(a,min(b,c));\\n    }\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int rows = matrix.size(), cols = matrix[0].size();\\n        int ans = INT_MAX;\\n        \\n        for(int r=1; r < rows; r++){\\n            for(int c=0; c < cols; c++){\\n                int leftD, middle, rightD;               \\n                if(c == 0){\\n                    rightD = matrix[r-1][c+1];\\n                    middle = matrix[r-1][c];\\n                    matrix[r][c] += min(rightD, middle);\\n                }else if(c == cols-1){\\n                    leftD = matrix[r-1][c-1];\\n                    middle = matrix[r-1][c];\\n                    matrix[r][c] += min(leftD, middle);\\n                }else{\\n                    leftD = matrix[r-1][c+1];\\n                    middle = matrix[r-1][c];\\n                    rightD = matrix[r-1][c-1];\\n                    matrix[r][c] += customMin(leftD, rightD, middle);\\n                } \\n            }\\n        }\\n        for(int c=0; c < cols; c++){\\n            ans = min(ans, matrix[rows-1][c]);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nIn general iterative is harder to think but it\\'s almost always better.\\n\\nUpvote if you found this useful and check out my twitch channel.\\n\\n\\n    \\n",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization",
                    "Iterator"
                ],
                "code": "```\\n//Brute force TLE\\nclass Solution {\\npublic:\\n        int minFallingPathSumHelper(vector<vector<int>>& matrix, int r, int c){\\n        if(r == 0 and c < matrix[0].size() and c >= 0) return matrix[r][c]; \\n        if(c >= matrix[0].size() or c < 0) return INT_MAX;\\n        \\n        return matrix[r][c] + min(min(minFallingPathSumHelper(matrix, r-1, c+1), minFallingPathSumHelper(matrix, r-1, c)), minFallingPathSumHelper(matrix, r-1, c-1));\\n        \\n    }\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int rows = matrix.size(), cols = matrix[0].size();\\n        int ans = INT_MAX;\\n        for(int c=0; c < cols; c++){\\n            ans = min(ans, minFallingPathSumHelper(matrix, rows-1, c));\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\n//Top-down Recursive with memo\\nclass Solution {\\npublic:\\n    int minFallingPathSumHelper(vector<vector<int>>& matrix, int r, int c, vector<vector<int>>& dp){\\n        if(r == 0 and c < matrix[0].size() and c >= 0) return matrix[r][c]; \\n        if(c >= matrix[0].size() or c < 0) return INT_MAX;\\n        \\n        if(dp[r][c] != INT_MAX) return dp[r][c];\\n        return dp[r][c] = matrix[r][c] + min(min(minFallingPathSumHelper(matrix, r-1, c+1, dp), minFallingPathSumHelper(matrix, r-1, c, dp)), minFallingPathSumHelper(matrix, r-1, c-1, dp));\\n        \\n    }\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int rows = matrix.size(), cols = matrix[0].size();\\n        vector<vector<int>> dp(rows+1, vector<int>(cols+1, INT_MAX));\\n        int ans = INT_MAX;\\n        for(int c=0; c < cols; c++){\\n            ans = min(ans, minFallingPathSumHelper(matrix, rows-1, c, dp));\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\n //Bottom-up Recursive with memo\\nclass Solution {\\npublic:\\n    int minFallingPathSumHelper(vector<vector<int>>& matrix, int r, int c, vector<vector<int>>& dp){\\n        if(r == matrix.size()-1 and c < matrix[0].size() and c >= 0) return matrix[r][c]; \\n        if(c >= matrix[0].size() or c < 0) return INT_MAX;\\n        \\n        if(dp[r][c] != INT_MAX) return dp[r][c];\\n        return dp[r][c] = matrix[r][c] + min(min(minFallingPathSumHelper(matrix, r+1, c-1, dp), minFallingPathSumHelper(matrix, r+1, c, dp)), minFallingPathSumHelper(matrix, r+1, c+1, dp));\\n        \\n    }\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int rows = matrix.size(), cols = matrix[0].size();\\n        vector<vector<int>> dp(rows+1, vector<int>(cols+1, INT_MAX));\\n        int ans = INT_MAX;\\n        for(int c=0; c < cols; c++){\\n            ans = min(ans, minFallingPathSumHelper(matrix, 0, c, dp));\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\n//Iterative bottom-up solution\\nclass Solution {\\npublic:\\n    int customMin(int a, int b, int c){\\n        return min(a,min(b,c));\\n    }\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int rows = matrix.size(), cols = matrix[0].size();\\n        int ans = INT_MAX;\\n        \\n        for(int r=1; r < rows; r++){\\n            for(int c=0; c < cols; c++){\\n                int leftD, middle, rightD;               \\n                if(c == 0){\\n                    rightD = matrix[r-1][c+1];\\n                    middle = matrix[r-1][c];\\n                    matrix[r][c] += min(rightD, middle);\\n                }else if(c == cols-1){\\n                    leftD = matrix[r-1][c-1];\\n                    middle = matrix[r-1][c];\\n                    matrix[r][c] += min(leftD, middle);\\n                }else{\\n                    leftD = matrix[r-1][c+1];\\n                    middle = matrix[r-1][c];\\n                    rightD = matrix[r-1][c-1];\\n                    matrix[r][c] += customMin(leftD, rightD, middle);\\n                } \\n            }\\n        }\\n        for(int c=0; c < cols; c++){\\n            ans = min(ans, matrix[rows-1][c]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 776004,
                "title": "easy-java-solution-using-dp",
                "content": "```\\nclass Solution {\\n    public int minFallingPathSum(int[][] A) {\\n        int dp[][] = new int[A.length][A.length];\\n        int min = Integer.MAX_VALUE;\\n        for(int i = 0; i < A.length; i++)\\n        {\\n            dp[0][i] = A[0][i];\\n        }\\n        for(int i = 1; i < A.length; i++)\\n        {\\n            for(int j = 0; j < A.length; j++)\\n            {\\n                if(j == 0)\\n                {\\n                    dp[i][j] = A[i][j] + Math.min(dp[i-1][j], dp[i-1][j+1]);\\n                }\\n                else if(j == A.length - 1)\\n                {\\n                    dp[i][j] = A[i][j] + Math.min(dp[i-1][j-1], dp[i-1][j]);\\n                }\\n                else\\n                {\\n                    dp[i][j] = A[i][j] + Math.min(Math.min(dp[i-1][j-1], dp[i-1][j]), dp[i-1][j+1]);\\n                }\\n            }\\n        }\\n        for(int i = 0; i < A.length; i++)\\n        {\\n            if(dp[A.length-1][i] < min)  min = dp[A.length-1][i];\\n        }\\n        return min;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n    public int minFallingPathSum(int[][] A) {\\n        int dp[][] = new int[A.length][A.length];\\n        int min = Integer.MAX_VALUE;\\n        for(int i = 0; i < A.length; i++)\\n        {\\n            dp[0][i] = A[0][i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1369046,
                "title": "python-explanation-visuals-5-approaches-dp-dfs-w-memo-dfs-iterative",
                "content": "**Idea:**\\n- The problem is very simialr to **64. Minimum Path Sum** with minor tweaks:\\n\\t- multipe (starting nodes/ roots) instead of a single root\\n\\t- multiple (targets/ leaves) instead of just one\\n\\t- The allowed movement are : \\n\\t\\t- down and to the right\\n\\t\\t- down and to the left\\n\\t\\t- down\\n\\n- This problem fits the min/max pattern which can be solved via these methods:\\n\\n**1. Dfs**\\n\\t\\t- recursive with global memo\\n\\t\\t- recursive with local memo\\n\\t\\t- iterative \\n\\n**2. Dynamic programming**\\n\\n\\n\\n\\n----------------------------------------------------\\n[1] - Bottom up - DP | 120 ms, faster than 63.67% of Python3\\n----------------------------------------------------\\n----------------------------------------------------\\n![image](https://assets.leetcode.com/users/images/54836d22-edf2-42f6-bf34-0c264bf911d0_1627501376.4721816.jpeg)\\n\\n```\\ndef minFallingPathSum(self, matrix: List[List[int]]) -> int:\\n\\tgrid = matrix\\n\\tfor i in range(1, len(grid)):\\n\\t\\tfor j in range(len(grid[i])):\\n\\n\\t\\t\\t# [1] up-left\\n\\t\\t\\tif i-1 >= 0 and j-1 >= 0:\\n\\t\\t\\t\\tp1 = grid[i-1][j-1]\\n\\t\\t\\telse:\\n\\t\\t\\t\\tp1 = float(\\'inf\\')\\n\\n\\t\\t\\t# [2] up-same\\n\\t\\t\\tif i-1 >= 0:\\n\\t\\t\\t\\tp2 = grid[i-1][j]\\n\\t\\t\\telse:\\n\\t\\t\\t\\tp2 = float(\\'inf\\')\\n\\n\\t\\t\\t# [3] up-right\\n\\t\\t\\tif i-1 >= 0 and j+1 <= len(grid[0])-1:\\n\\t\\t\\t\\tp3 = grid[i-1][j+1]\\n\\t\\t\\telse:\\n\\t\\t\\t\\tp3 = float(\\'inf\\')\\n\\n\\t\\t\\tgrid[i][j] += min(p1,p2,p3)\\n\\n\\treturn min(grid[len(grid)-1])\\n```\\n----------------------------------------------------\\n[2] Brute force DFS iterative - with no visited set | SLOW | TLE 38 / 48 test cases passed.\\n----------------------------------------------------\\n----------------------------------------------------\\n\\n- For the DFS solution, we have to invoke it multiple times (once for each root/DAG separately)\\n\\n```\\ndef minFallingPathSum(self, matrix: List[List[int]]) -> int:\\n\\t# helper\\n\\tdef dfs(x,y):\\n\\t\\tstack = [((x,y), grid[x][y])]\\n\\t\\tdirs = [(1,0), (1,1), (1,-1)]\\n\\t\\tm, n = len(grid)-1, len(grid[0])-1\\n\\t\\tlocalMinSum = float(\\'inf\\')\\n\\t\\twhile stack:\\n\\t\\t\\t(x,y), pathSum = stack.pop()\\n\\t\\t\\t# print((x,y), pathSum)\\n\\t\\t\\tif x == m:\\n\\t\\t\\t\\tlocalMinSum = min(localMinSum, pathSum)\\n\\t\\t\\tfor dir in dirs:\\n\\t\\t\\t\\tnewX, newY = x+dir[0], y+dir[1]\\n\\t\\t\\t\\tif newX >= 0 and newX <= m and newY >= 0 and newY <= n:\\n\\t\\t\\t\\t\\tstack.append(((newX, newY), pathSum+grid[newX][newY]))\\n\\t\\treturn localMinSum\\n\\n\\n\\t# main\\n\\tgrid = matrix\\n\\troots = grid[0]\\n\\tminPath = float(\\'inf\\')\\n\\tfor i in range(len(roots)):\\n\\t\\tminPath = min(dfs(0,i), minPath)\\n\\treturn minPath\\n```\\n----------------------------------------------------\\n[3] - Recursive DFS with memo\\n\\t- with local memo for each DAG separate | 4908 ms faster than 5.22% of Python3\\n----------------------------------------------------\\n----------------------------------------------------\\n\\n- For the DFS solution, we have to invoke it multiple times (once for each root/DAG separately)\\n![image](https://assets.leetcode.com/users/images/f1ee79d7-ddfe-4085-8f1e-2ec318261a20_1627502368.368746.jpeg)\\n\\n- Initially, I though I should also use a separate memo dict to memoize each root/DAG separately as you can see below. See **approach [4]** for more details.\\n\\n```        \\ndef minFallingPathSum(self, matrix: List[List[int]]) -> int:\\n\\t# helper\\n\\tdef recurse(i,j, memo):\\n\\n\\t\\tif i < 0 or j < 0 or i > m-1 or j > n-1:\\n\\t\\t\\treturn float(\\'inf\\')\\n\\t\\tif i == m-1: # last row reached - does not make sense to memoize here\\n\\t\\t\\treturn grid[i][j]\\n\\t\\tif (i,j) in memo:\\n\\t\\t\\treturn memo[(i,j)]\\n\\t\\tresult = grid[i][j] + min(recurse(i+1, j, memo), recurse(i+1, j+1, memo), recurse(i+1, j-1, memo)) # - NOTE [1]\\n\\t\\tmemo[(i,j)] = result\\n\\t\\treturn result\\n\\n\\t# main\\n\\tgrid = matrix\\n\\tm, n = len(grid), len(grid[0])\\n\\tminFallPath = float(\\'inf\\')\\n\\tfor i in range(len(grid[0])):\\n\\t\\tminFallPath = min(minFallPath, recurse(0, i, {}))\\n\\treturn minFallPath\\n\\n\\t# - NOTE [1]\\n\\t# ----------\\n\\t# Treat every node in the zeroth row as a separate root/DAG with its own memoization\\n\\t# Memoization is possible when we have a single starting point that branches out\\n\\n\\t# Behavior of memo for each DAG separately for the ex: matrix = [[2,1,3],[6,5,4],[7,8,9]]\\n\\t# ------ new DAG -----\\n\\t# memo =  {(1, 0): 13}\\n\\t# memo =  {(1, 0): 13, (1, 1): 12}\\n\\t# memo =  {(1, 0): 13, (1, 1): 12, (0, 0): 14}\\n\\t#  ------ new DAG -----\\n\\t# memo =  {(1, 1): 12}\\n\\t# memo =  {(1, 1): 12, (1, 2): 12}\\n\\t# memo =  {(1, 1): 12, (1, 2): 12, (1, 0): 13}\\n\\t# memo =  {(1, 1): 12, (1, 2): 12, (1, 0): 13, (0, 1): 13}\\n\\t#  ------ new DAG -----\\n\\t# memo =  {(1, 2): 12}\\n\\t# memo =  {(1, 2): 12, (1, 1): 12}\\n\\t# memo =  {(1, 2): 12, (1, 1): 12, (0, 2): 15}\\n```\\n        \\n----------------------------------------------------\\n\\n[4] - Recursive DFS with memo\\n\\t- with global memo for the entire grid | 160 ms faster than 27.15% Python3\\n----------------------------------------------------\\n----------------------------------------------------\\n- Here, I am using a global memo for the entire grid\\n- This obviosuly reduces the runtime significalty\\n- **Why shoud we use global memoization?**\\n\\t- ![image](https://assets.leetcode.com/users/images/29702449-9697-4236-9890-784b62088ad3_1627502479.2262669.jpeg)\\n\\n\\t- It makes sense to use a global memo, because once memoized, a node (or a key) in the memo dict does not change its value. That is because the memoized value is determined based on the children of that node/key, and that is never going to change.\\n\\n\\t- So when the same node is viisted again via a different root (starting point), its value has already been memoized and we don\\'t have to go down the rabbit hole once again (don\\'t have to recurse to the bottom of the grid again)\\n \\n\\n```\\ndef minFallingPathSum(self, matrix: List[List[int]]) -> int:\\n\\t# helper\\n\\tdef recurse(i,j):\\n\\n\\t\\tif i < 0 or j < 0 or i > m-1 or j > n-1:\\n\\t\\t\\treturn float(\\'inf\\')\\n\\t\\tif i == m-1: # last row reached - does not make sense to memoize here\\n\\t\\t\\treturn grid[i][j]\\n\\t\\tif (i,j) in memo:\\n\\t\\t\\treturn memo[(i,j)]\\n\\t\\tresult = grid[i][j] + min(recurse(i+1, j), recurse(i+1, j+1), recurse(i+1, j-1)) # - NOTE [1]\\n\\t\\tmemo[(i,j)] = result\\n\\t\\tprint(\\'memo = \\', memo)\\n\\t\\treturn result\\n\\n\\t# main\\n\\tgrid = matrix\\n\\tm, n = len(grid), len(grid[0])\\n\\tminFallPath = float(\\'inf\\')\\n\\tmemo = {}\\n\\tfor i in range(len(grid[0])):\\n\\t\\tprint(\\' ------ new DAG -----\\')\\n\\t\\tminFallPath = min(minFallPath, recurse(0, i))\\n\\treturn minFallPath\\n ```   \\n----------------------------------------------------\\n[5] - Recursive DFS with memo\\n\\t- without memo | TLE 38 / 48 test cases passed.\\n----------------------------------------------------\\n----------------------------------------------------\\n```        \\ndef minFallingPathSum(self, matrix: List[List[int]]) -> int:\\n\\t# helper\\n\\tdef recurse(i,j):\\n\\t\\tif i < 0 or j < 0 or i > m-1 or j > n-1:\\n\\t\\t\\treturn float(\\'inf\\')\\n\\t\\tif i == m-1: # last row reached\\n\\t\\t\\treturn grid[i][j]\\n\\t\\tresult = grid[i][j] + min(recurse(i+1, j), recurse(i+1, j+1), recurse(i+1, j-1))\\n\\t\\t# memo[(i,j)] = result\\n\\t\\treturn result\\n\\n\\t# main\\n\\tgrid = matrix\\n\\tm, n = len(grid), len(grid[0])\\n\\tminFallPath = float(\\'inf\\')\\n\\tfor i in range(len(grid[0])):\\n\\t\\tminFallPath = min(minFallPath, recurse(0, i))\\n\\treturn minFallPath\\n```        \\n        \\n        \\n        \\n    \\n        \\n",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Recursion",
                    "Memoization",
                    "Iterator"
                ],
                "code": "```\\ndef minFallingPathSum(self, matrix: List[List[int]]) -> int:\\n\\tgrid = matrix\\n\\tfor i in range(1, len(grid)):\\n\\t\\tfor j in range(len(grid[i])):\\n\\n\\t\\t\\t# [1] up-left\\n\\t\\t\\tif i-1 >= 0 and j-1 >= 0:\\n\\t\\t\\t\\tp1 = grid[i-1][j-1]\\n\\t\\t\\telse:\\n\\t\\t\\t\\tp1 = float(\\'inf\\')\\n\\n\\t\\t\\t# [2] up-same\\n\\t\\t\\tif i-1 >= 0:\\n\\t\\t\\t\\tp2 = grid[i-1][j]\\n\\t\\t\\telse:\\n\\t\\t\\t\\tp2 = float(\\'inf\\')\\n\\n\\t\\t\\t# [3] up-right\\n\\t\\t\\tif i-1 >= 0 and j+1 <= len(grid[0])-1:\\n\\t\\t\\t\\tp3 = grid[i-1][j+1]\\n\\t\\t\\telse:\\n\\t\\t\\t\\tp3 = float(\\'inf\\')\\n\\n\\t\\t\\tgrid[i][j] += min(p1,p2,p3)\\n\\n\\treturn min(grid[len(grid)-1])\\n```\n```\\ndef minFallingPathSum(self, matrix: List[List[int]]) -> int:\\n\\t# helper\\n\\tdef dfs(x,y):\\n\\t\\tstack = [((x,y), grid[x][y])]\\n\\t\\tdirs = [(1,0), (1,1), (1,-1)]\\n\\t\\tm, n = len(grid)-1, len(grid[0])-1\\n\\t\\tlocalMinSum = float(\\'inf\\')\\n\\t\\twhile stack:\\n\\t\\t\\t(x,y), pathSum = stack.pop()\\n\\t\\t\\t# print((x,y), pathSum)\\n\\t\\t\\tif x == m:\\n\\t\\t\\t\\tlocalMinSum = min(localMinSum, pathSum)\\n\\t\\t\\tfor dir in dirs:\\n\\t\\t\\t\\tnewX, newY = x+dir[0], y+dir[1]\\n\\t\\t\\t\\tif newX >= 0 and newX <= m and newY >= 0 and newY <= n:\\n\\t\\t\\t\\t\\tstack.append(((newX, newY), pathSum+grid[newX][newY]))\\n\\t\\treturn localMinSum\\n\\n\\n\\t# main\\n\\tgrid = matrix\\n\\troots = grid[0]\\n\\tminPath = float(\\'inf\\')\\n\\tfor i in range(len(roots)):\\n\\t\\tminPath = min(dfs(0,i), minPath)\\n\\treturn minPath\\n```\n```        \\ndef minFallingPathSum(self, matrix: List[List[int]]) -> int:\\n\\t# helper\\n\\tdef recurse(i,j, memo):\\n\\n\\t\\tif i < 0 or j < 0 or i > m-1 or j > n-1:\\n\\t\\t\\treturn float(\\'inf\\')\\n\\t\\tif i == m-1: # last row reached - does not make sense to memoize here\\n\\t\\t\\treturn grid[i][j]\\n\\t\\tif (i,j) in memo:\\n\\t\\t\\treturn memo[(i,j)]\\n\\t\\tresult = grid[i][j] + min(recurse(i+1, j, memo), recurse(i+1, j+1, memo), recurse(i+1, j-1, memo)) # - NOTE [1]\\n\\t\\tmemo[(i,j)] = result\\n\\t\\treturn result\\n\\n\\t# main\\n\\tgrid = matrix\\n\\tm, n = len(grid), len(grid[0])\\n\\tminFallPath = float(\\'inf\\')\\n\\tfor i in range(len(grid[0])):\\n\\t\\tminFallPath = min(minFallPath, recurse(0, i, {}))\\n\\treturn minFallPath\\n\\n\\t# - NOTE [1]\\n\\t# ----------\\n\\t# Treat every node in the zeroth row as a separate root/DAG with its own memoization\\n\\t# Memoization is possible when we have a single starting point that branches out\\n\\n\\t# Behavior of memo for each DAG separately for the ex: matrix = [[2,1,3],[6,5,4],[7,8,9]]\\n\\t# ------ new DAG -----\\n\\t# memo =  {(1, 0): 13}\\n\\t# memo =  {(1, 0): 13, (1, 1): 12}\\n\\t# memo =  {(1, 0): 13, (1, 1): 12, (0, 0): 14}\\n\\t#  ------ new DAG -----\\n\\t# memo =  {(1, 1): 12}\\n\\t# memo =  {(1, 1): 12, (1, 2): 12}\\n\\t# memo =  {(1, 1): 12, (1, 2): 12, (1, 0): 13}\\n\\t# memo =  {(1, 1): 12, (1, 2): 12, (1, 0): 13, (0, 1): 13}\\n\\t#  ------ new DAG -----\\n\\t# memo =  {(1, 2): 12}\\n\\t# memo =  {(1, 2): 12, (1, 1): 12}\\n\\t# memo =  {(1, 2): 12, (1, 1): 12, (0, 2): 15}\\n```\n```\\ndef minFallingPathSum(self, matrix: List[List[int]]) -> int:\\n\\t# helper\\n\\tdef recurse(i,j):\\n\\n\\t\\tif i < 0 or j < 0 or i > m-1 or j > n-1:\\n\\t\\t\\treturn float(\\'inf\\')\\n\\t\\tif i == m-1: # last row reached - does not make sense to memoize here\\n\\t\\t\\treturn grid[i][j]\\n\\t\\tif (i,j) in memo:\\n\\t\\t\\treturn memo[(i,j)]\\n\\t\\tresult = grid[i][j] + min(recurse(i+1, j), recurse(i+1, j+1), recurse(i+1, j-1)) # - NOTE [1]\\n\\t\\tmemo[(i,j)] = result\\n\\t\\tprint(\\'memo = \\', memo)\\n\\t\\treturn result\\n\\n\\t# main\\n\\tgrid = matrix\\n\\tm, n = len(grid), len(grid[0])\\n\\tminFallPath = float(\\'inf\\')\\n\\tmemo = {}\\n\\tfor i in range(len(grid[0])):\\n\\t\\tprint(\\' ------ new DAG -----\\')\\n\\t\\tminFallPath = min(minFallPath, recurse(0, i))\\n\\treturn minFallPath\\n ```\n```        \\ndef minFallingPathSum(self, matrix: List[List[int]]) -> int:\\n\\t# helper\\n\\tdef recurse(i,j):\\n\\t\\tif i < 0 or j < 0 or i > m-1 or j > n-1:\\n\\t\\t\\treturn float(\\'inf\\')\\n\\t\\tif i == m-1: # last row reached\\n\\t\\t\\treturn grid[i][j]\\n\\t\\tresult = grid[i][j] + min(recurse(i+1, j), recurse(i+1, j+1), recurse(i+1, j-1))\\n\\t\\t# memo[(i,j)] = result\\n\\t\\treturn result\\n\\n\\t# main\\n\\tgrid = matrix\\n\\tm, n = len(grid), len(grid[0])\\n\\tminFallPath = float(\\'inf\\')\\n\\tfor i in range(len(grid[0])):\\n\\t\\tminFallPath = min(minFallPath, recurse(0, i))\\n\\treturn minFallPath\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1466824,
                "title": "recursion-memoization-iterative-dp",
                "content": "![image](https://assets.leetcode.com/users/images/6bda003d-d02b-421f-a84f-70a9a4ae9c20_1631794522.257455.jpeg)\\n\\n**Recursion TLE** \\n\\n```\\nint solve(int i,int j,int m,int n,vector<vector<int>>& matrix)\\n    {\\n        if(i<0 || j<0 || i>m || j>n) return INT_MAX;\\n        if(i == m) return matrix[i][j];\\n        \\n       return matrix[i][j] + min(solve(i+1,j-1,m,n,matrix),\\n           min(solve(i+1,j,m,n,matrix), solve(i+1,j+1,m,n,matrix)));\\n    }\\n    \\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n        int ans = INT_MAX;\\n        \\n        for(int j=0;j<n;j++)\\n        {\\n           ans = min(ans,solve(0,j,m-1,n-1,matrix));    \\n        }\\n        return ans;\\n    }\\n\\t\\n```\\n\\n**Memoization**\\n\\n```\\nint solve(int i,int j,int m,int n,vector<vector<int>>& matrix,\\n             vector<vector<int>> &dp)\\n    {\\n        if(i<0 || j<0 || i>m || j>n) return INT_MAX;\\n        if(i == m) return matrix[i][j];\\n        \\n        if(dp[i][j] != -1) return dp[i][j];\\n       \\n        return dp[i][j] = matrix[i][j] + min(solve(i+1,j-1,m,n,matrix,dp),\\n           min(solve(i+1,j,m,n,matrix,dp), solve(i+1,j+1,m,n,matrix,dp)));\\n    }\\n    \\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n        int ans = INT_MAX;\\n        \\n        vector<vector<int>> dp(m,vector<int>(n,-1));\\n        for(int j=0;j<n;j++)\\n        {\\n           ans = min(ans,solve(0,j,m-1,n-1,matrix,dp));    \\n        }\\n        return ans;\\n    }\\n```\\n\\n**Iterative DP**\\n\\n```\\nint minFallingPathSum(vector<vector<int>>& matrix) {\\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n        \\n        vector<vector<int>> dp(m,vector<int>(n,-1));\\n        for(int j=0;j<n;j++)\\n        {\\n            dp[0][j] = matrix[0][j];\\n        }\\n        \\n        for(int i=1;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                // for oth col we dont have col-1\\n                if(j == 0)\\n                    dp[i][j] = matrix[i][j] + min(dp[i-1][j],dp[i-1][j+1]);\\n                \\n                else if(j == n-1)\\n                    dp[i][j] = matrix[i][j] + min(dp[i-1][j-1],dp[i-1][j]);\\n                \\n                else\\n                {\\n                    dp[i][j] = matrix[i][j] + min(dp[i-1][j-1],\\n                                                min(dp[i-1][j],dp[i-1][j+1]));\\n                }\\n            }\\n        }\\n        \\n        int ans = 1e9;\\n        // find min among last row\\n        for(int j=0;j<n;j++)\\n        {\\n            ans = min(ans,dp[m-1][j]);\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint solve(int i,int j,int m,int n,vector<vector<int>>& matrix)\\n    {\\n        if(i<0 || j<0 || i>m || j>n) return INT_MAX;\\n        if(i == m) return matrix[i][j];\\n        \\n       return matrix[i][j] + min(solve(i+1,j-1,m,n,matrix),\\n           min(solve(i+1,j,m,n,matrix), solve(i+1,j+1,m,n,matrix)));\\n    }\\n    \\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n        int ans = INT_MAX;\\n        \\n        for(int j=0;j<n;j++)\\n        {\\n           ans = min(ans,solve(0,j,m-1,n-1,matrix));    \\n        }\\n        return ans;\\n    }\\n\\t\\n```\n```\\nint solve(int i,int j,int m,int n,vector<vector<int>>& matrix,\\n             vector<vector<int>> &dp)\\n    {\\n        if(i<0 || j<0 || i>m || j>n) return INT_MAX;\\n        if(i == m) return matrix[i][j];\\n        \\n        if(dp[i][j] != -1) return dp[i][j];\\n       \\n        return dp[i][j] = matrix[i][j] + min(solve(i+1,j-1,m,n,matrix,dp),\\n           min(solve(i+1,j,m,n,matrix,dp), solve(i+1,j+1,m,n,matrix,dp)));\\n    }\\n    \\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n        int ans = INT_MAX;\\n        \\n        vector<vector<int>> dp(m,vector<int>(n,-1));\\n        for(int j=0;j<n;j++)\\n        {\\n           ans = min(ans,solve(0,j,m-1,n-1,matrix,dp));    \\n        }\\n        return ans;\\n    }\\n```\n```\\nint minFallingPathSum(vector<vector<int>>& matrix) {\\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n        \\n        vector<vector<int>> dp(m,vector<int>(n,-1));\\n        for(int j=0;j<n;j++)\\n        {\\n            dp[0][j] = matrix[0][j];\\n        }\\n        \\n        for(int i=1;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                // for oth col we dont have col-1\\n                if(j == 0)\\n                    dp[i][j] = matrix[i][j] + min(dp[i-1][j],dp[i-1][j+1]);\\n                \\n                else if(j == n-1)\\n                    dp[i][j] = matrix[i][j] + min(dp[i-1][j-1],dp[i-1][j]);\\n                \\n                else\\n                {\\n                    dp[i][j] = matrix[i][j] + min(dp[i-1][j-1],\\n                                                min(dp[i-1][j],dp[i-1][j+1]));\\n                }\\n            }\\n        }\\n        \\n        int ans = 1e9;\\n        // find min among last row\\n        for(int j=0;j<n;j++)\\n        {\\n            ans = min(ans,dp[m-1][j]);\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 186646,
                "title": "the-art-of-dynamic-programming",
                "content": "[\\uD83C\\uDFA8 The ART of Dynamic Programming](https://leetcode.com/discuss/general-discussion/712010/The-ART-of-Dynamic-Programming-An-Intuitive-Approach%3A-from-Apprentice-to-Master)\\n\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n\\nThere are 3 path sum choices to consider for each cell `i`,`j` denoted as `a`,`b`,`c` to denote above/left, above, above/right correspondingly.\\n\\n---\\n\\n**Kotlin Solutions:**\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n```\\nclass Solution {\\n    fun minFallingPathSum(A: Array<IntArray>, INF: Int = (1e9 + 7).toInt()): Int {\\n        var (M, N) = listOf(A.size, A[0].size)\\n        fun go(i: Int, j: Int): Int {\\n            if (j < 0 || j == N)\\n                return INF\\n            if (i == 0)\\n                return A[i][j]\\n            var a = go(i - 1, j - 1)\\n            var b = go(i - 1, j)\\n            var c = go(i - 1, j + 1)\\n            return A[i][j] + listOf(a, b, c).min()!!\\n        }\\n        var best = INF\\n        for (j in 0 until N)\\n            best = Math.min(best, go(M - 1, j))\\n        return best\\n    }\\n}\\n```\\n\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n```\\nclass Solution {\\n    fun minFallingPathSum(A: Array<IntArray>, INF: Int = (1e9 + 7).toInt()): Int {\\n        var m = mutableMapOf<String, Int>()\\n        var (M, N) = listOf(A.size, A[0].size)\\n        fun go(i: Int, j: Int): Int {\\n            if (j < 0 || j == N)\\n                return INF\\n            if (i == 0)\\n                return A[i][j]\\n            var k = \"$i,$j\"\\n            if (!m.contains(k)) {\\n                var a = go(i - 1, j - 1)\\n                var b = go(i - 1, j)\\n                var c = go(i - 1, j + 1)\\n                m[k] = A[i][j] + listOf(a, b, c).min()!!\\n            }\\n            return m[k]!!\\n        }\\n        var best = INF\\n        for (j in 0 until N)\\n            best = Math.min(best, go(M - 1, j))\\n        return best\\n    }\\n}\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\nclass Solution {\\n    fun minFallingPathSum(A: Array<IntArray>, INF: Int = (1e9 + 7).toInt()): Int {\\n        var (M, N) = listOf(A.size, A[0].size)\\n        for (i in 1 until M) {\\n            for (j in 0 until N) {\\n                var a = if (0 <= j - 1) A[i - 1][j - 1] else INF\\n                var b = A[i - 1][j]\\n                var c = if (j + 1 < N) A[i - 1][j + 1] else INF\\n                A[i][j] += listOf(a, b, c).min()!!\\n            }\\n        }\\n        return A[M - 1].min()!!\\n    }\\n}\\n```\\n\\n---\\n\\n**Javascript Solutions:**\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n```\\nlet minFallingPathSum = A => {\\n    let [M, N] = [A.length, A[0].length];\\n    let go = (i, j) => {\\n        if (j < 0 || j == N)\\n            return Infinity;\\n        if (!i)\\n            return A[i][j];\\n        let a = go(i - 1, j - 1),\\n            b = go(i - 1, j),\\n            c = go(i - 1, j + 1);\\n        return A[i][j] + Math.min(a, b, c);\\n    };\\n    let best = Infinity;\\n    for (let j = 0; j < N; ++j)\\n        best = Math.min(best, go(M - 1, j));\\n    return best;\\n};\\n```\\n\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n```\\nlet minFallingPathSum = (A, m = new Map()) => {\\n    let [M, N] = [A.length, A[0].length];\\n    let go = (i, j) => {\\n        if (j < 0 || j == N)\\n            return Infinity;\\n        if (!i)\\n            return A[i][j];\\n        let k = `${i},${j}`;\\n        if (!m.has(k)) {\\n            let a = go(i - 1, j - 1),\\n                b = go(i - 1, j),\\n                c = go(i - 1, j + 1);\\n            m.set(k, A[i][j] + Math.min(a, b, c));\\n        }\\n        return m.get(k);\\n    };\\n    let best = Infinity;\\n    for (let j = 0; j < N; ++j)\\n        best = Math.min(best, go(M - 1, j));\\n    return best;\\n};\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\nlet minFallingPathSum = (A, m = new Map()) => {\\n    let [M, N] = [A.length, A[0].length];\\n    for (let i = 1; i < M; ++i) {\\n        for (let j = 0; j < N; ++j) {\\n            let a = 0 <= j - 1 ? A[i - 1][j - 1] : Infinity,\\n                b = A[i - 1][j],\\n                c = j + 1 < N ? A[i - 1][j + 1] : Infinity;\\n            A[i][j] += Math.min(a, b, c);\\n        }\\n    }\\n    return Math.min(...A[M - 1]);\\n};\\n```\\n\\n---\\n\\n**Python3 Solutions:**\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n```\\nclass Solution:\\n    def minFallingPathSum(self, A: List[List[int]]) -> int:\\n        M, N = len(A), len(A[0])\\n        def go(i, j):\\n            if j < 0 or j == N:\\n                return float(\\'inf\\')\\n            if not i:\\n                return A[i][j]\\n            a = go(i - 1, j - 1)\\n            b = go(i - 1, j)\\n            c = go(i - 1, j + 1)\\n            return A[i][j] + min(a, b, c)\\n        best = float(\\'inf\\')\\n        for j in range(N):\\n            best = min(best, go(M - 1, j))\\n        return best\\n```\\n\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n```\\nclass Solution:\\n    def minFallingPathSum(self, A: List[List[int]]) -> int:\\n        M, N = len(A), len(A[0])\\n        @cache\\n        def go(i, j):\\n            if j < 0 or j == N:\\n                return float(\\'inf\\')\\n            if not i:\\n                return A[i][j]\\n            a = go(i - 1, j - 1)\\n            b = go(i - 1, j)\\n            c = go(i - 1, j + 1)\\n            return A[i][j] + min(a, b, c)\\n        best = float(\\'inf\\')\\n        for j in range(N):\\n            best = min(best, go(M - 1, j))\\n        return best\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\nclass Solution:\\n    def minFallingPathSum(self, A: List[List[int]]) -> int:\\n        M, N = len(A), len(A[0])\\n        for i in range(1, M):\\n            for j in range(N):\\n                a = A[i - 1][j - 1] if 0 <= j - 1 else float(\\'inf\\')\\n                b = A[i - 1][j]\\n                c = A[i - 1][j + 1] if j + 1 < N else float(\\'inf\\')\\n                A[i][j] += min(a, b, c)\\n        return min(A[M - 1])\\n```\\n\\n---\\n\\n**C++ Solutions:**\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    using fun = function<int(int, int)>;\\n    int minFallingPathSum(VVI& A, int INF = 1e9 + 7) {\\n        int M = A.size(),\\n            N = A[0].size();\\n        fun go = [&](auto i, auto j) {\\n            if (j < 0 || j == N)\\n                return INF;\\n            if (!i)\\n                return A[i][j];\\n            auto a = go(i - 1, j -1),\\n                 b = go(i - 1, j),\\n                 c = go(i - 1, j + 1);\\n            return A[i][j] + min({ a, b, c });\\n        };\\n        auto best = INF;\\n        for (auto j{ 0 }; j < N; ++j)\\n            best = min(best, go(M - 1, j));\\n        return best;\\n    }\\n};\\n```\\n\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    using fun = function<int(int, int)>;\\n    using Map = unordered_map<string, int>;\\n    int minFallingPathSum(VVI& A, Map m = {}, int INF = 1e9 + 7) {\\n        int M = A.size(),\\n            N = A[0].size();\\n        auto key = [](auto i, auto j) {\\n            stringstream ss; ss << i << \",\" << j;\\n            return ss.str();\\n        };\\n        fun go = [&](auto i, auto j) {\\n            if (j < 0 || j == N)\\n                return INF;\\n            if (!i)\\n                return A[i][j];\\n            auto k = key(i, j);\\n            if (m.find(k) == m.end()) {\\n                auto a = go(i - 1, j -1),\\n                     b = go(i - 1, j),\\n                     c = go(i - 1, j + 1);\\n                m[k] = A[i][j] + min({ a, b, c });\\n            }\\n            return m[k];\\n        };\\n        auto best = INF;\\n        for (auto j{ 0 }; j < N; ++j)\\n            best = min(best, go(M - 1, j));\\n        return best;\\n    }\\n};\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    using fun = function<int(int, int)>;\\n    using Map = unordered_map<string, int>;\\n    int minFallingPathSum(VVI& A, Map m = {}, int INF = 1e9 + 7) {\\n        int M = A.size(),\\n            N = A[0].size();\\n        for (auto i{ 1 }; i < M; ++i) {\\n            for (auto j{ 0 }; j < N; ++j) {\\n                auto a = 0 <= j - 1 ? A[i - 1][j - 1] : INF,\\n                     b = A[i - 1][j],\\n                     c = j + 1 < N ? A[i - 1][j + 1] : INF;\\n                A[i][j] += min({ a, b, c });\\n            }\\n        }\\n        return *min_element(A[M - 1].begin(), A[M - 1].end());\\n    }\\n};\\n```\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun minFallingPathSum(A: Array<IntArray>, INF: Int = (1e9 + 7).toInt()): Int {\\n        var (M, N) = listOf(A.size, A[0].size)\\n        fun go(i: Int, j: Int): Int {\\n            if (j < 0 || j == N)\\n                return INF\\n            if (i == 0)\\n                return A[i][j]\\n            var a = go(i - 1, j - 1)\\n            var b = go(i - 1, j)\\n            var c = go(i - 1, j + 1)\\n            return A[i][j] + listOf(a, b, c).min()!!\\n        }\\n        var best = INF\\n        for (j in 0 until N)\\n            best = Math.min(best, go(M - 1, j))\\n        return best\\n    }\\n}\\n```\n```\\nclass Solution {\\n    fun minFallingPathSum(A: Array<IntArray>, INF: Int = (1e9 + 7).toInt()): Int {\\n        var m = mutableMapOf<String, Int>()\\n        var (M, N) = listOf(A.size, A[0].size)\\n        fun go(i: Int, j: Int): Int {\\n            if (j < 0 || j == N)\\n                return INF\\n            if (i == 0)\\n                return A[i][j]\\n            var k = \"$i,$j\"\\n            if (!m.contains(k)) {\\n                var a = go(i - 1, j - 1)\\n                var b = go(i - 1, j)\\n                var c = go(i - 1, j + 1)\\n                m[k] = A[i][j] + listOf(a, b, c).min()!!\\n            }\\n            return m[k]!!\\n        }\\n        var best = INF\\n        for (j in 0 until N)\\n            best = Math.min(best, go(M - 1, j))\\n        return best\\n    }\\n}\\n```\n```\\nclass Solution {\\n    fun minFallingPathSum(A: Array<IntArray>, INF: Int = (1e9 + 7).toInt()): Int {\\n        var (M, N) = listOf(A.size, A[0].size)\\n        for (i in 1 until M) {\\n            for (j in 0 until N) {\\n                var a = if (0 <= j - 1) A[i - 1][j - 1] else INF\\n                var b = A[i - 1][j]\\n                var c = if (j + 1 < N) A[i - 1][j + 1] else INF\\n                A[i][j] += listOf(a, b, c).min()!!\\n            }\\n        }\\n        return A[M - 1].min()!!\\n    }\\n}\\n```\n```\\nlet minFallingPathSum = A => {\\n    let [M, N] = [A.length, A[0].length];\\n    let go = (i, j) => {\\n        if (j < 0 || j == N)\\n            return Infinity;\\n        if (!i)\\n            return A[i][j];\\n        let a = go(i - 1, j - 1),\\n            b = go(i - 1, j),\\n            c = go(i - 1, j + 1);\\n        return A[i][j] + Math.min(a, b, c);\\n    };\\n    let best = Infinity;\\n    for (let j = 0; j < N; ++j)\\n        best = Math.min(best, go(M - 1, j));\\n    return best;\\n};\\n```\n```\\nlet minFallingPathSum = (A, m = new Map()) => {\\n    let [M, N] = [A.length, A[0].length];\\n    let go = (i, j) => {\\n        if (j < 0 || j == N)\\n            return Infinity;\\n        if (!i)\\n            return A[i][j];\\n        let k = `${i},${j}`;\\n        if (!m.has(k)) {\\n            let a = go(i - 1, j - 1),\\n                b = go(i - 1, j),\\n                c = go(i - 1, j + 1);\\n            m.set(k, A[i][j] + Math.min(a, b, c));\\n        }\\n        return m.get(k);\\n    };\\n    let best = Infinity;\\n    for (let j = 0; j < N; ++j)\\n        best = Math.min(best, go(M - 1, j));\\n    return best;\\n};\\n```\n```\\nlet minFallingPathSum = (A, m = new Map()) => {\\n    let [M, N] = [A.length, A[0].length];\\n    for (let i = 1; i < M; ++i) {\\n        for (let j = 0; j < N; ++j) {\\n            let a = 0 <= j - 1 ? A[i - 1][j - 1] : Infinity,\\n                b = A[i - 1][j],\\n                c = j + 1 < N ? A[i - 1][j + 1] : Infinity;\\n            A[i][j] += Math.min(a, b, c);\\n        }\\n    }\\n    return Math.min(...A[M - 1]);\\n};\\n```\n```\\nclass Solution:\\n    def minFallingPathSum(self, A: List[List[int]]) -> int:\\n        M, N = len(A), len(A[0])\\n        def go(i, j):\\n            if j < 0 or j == N:\\n                return float(\\'inf\\')\\n            if not i:\\n                return A[i][j]\\n            a = go(i - 1, j - 1)\\n            b = go(i - 1, j)\\n            c = go(i - 1, j + 1)\\n            return A[i][j] + min(a, b, c)\\n        best = float(\\'inf\\')\\n        for j in range(N):\\n            best = min(best, go(M - 1, j))\\n        return best\\n```\n```\\nclass Solution:\\n    def minFallingPathSum(self, A: List[List[int]]) -> int:\\n        M, N = len(A), len(A[0])\\n        @cache\\n        def go(i, j):\\n            if j < 0 or j == N:\\n                return float(\\'inf\\')\\n            if not i:\\n                return A[i][j]\\n            a = go(i - 1, j - 1)\\n            b = go(i - 1, j)\\n            c = go(i - 1, j + 1)\\n            return A[i][j] + min(a, b, c)\\n        best = float(\\'inf\\')\\n        for j in range(N):\\n            best = min(best, go(M - 1, j))\\n        return best\\n```\n```\\nclass Solution:\\n    def minFallingPathSum(self, A: List[List[int]]) -> int:\\n        M, N = len(A), len(A[0])\\n        for i in range(1, M):\\n            for j in range(N):\\n                a = A[i - 1][j - 1] if 0 <= j - 1 else float(\\'inf\\')\\n                b = A[i - 1][j]\\n                c = A[i - 1][j + 1] if j + 1 < N else float(\\'inf\\')\\n                A[i][j] += min(a, b, c)\\n        return min(A[M - 1])\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    using fun = function<int(int, int)>;\\n    int minFallingPathSum(VVI& A, int INF = 1e9 + 7) {\\n        int M = A.size(),\\n            N = A[0].size();\\n        fun go = [&](auto i, auto j) {\\n            if (j < 0 || j == N)\\n                return INF;\\n            if (!i)\\n                return A[i][j];\\n            auto a = go(i - 1, j -1),\\n                 b = go(i - 1, j),\\n                 c = go(i - 1, j + 1);\\n            return A[i][j] + min({ a, b, c });\\n        };\\n        auto best = INF;\\n        for (auto j{ 0 }; j < N; ++j)\\n            best = min(best, go(M - 1, j));\\n        return best;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    using fun = function<int(int, int)>;\\n    using Map = unordered_map<string, int>;\\n    int minFallingPathSum(VVI& A, Map m = {}, int INF = 1e9 + 7) {\\n        int M = A.size(),\\n            N = A[0].size();\\n        auto key = [](auto i, auto j) {\\n            stringstream ss; ss << i << \",\" << j;\\n            return ss.str();\\n        };\\n        fun go = [&](auto i, auto j) {\\n            if (j < 0 || j == N)\\n                return INF;\\n            if (!i)\\n                return A[i][j];\\n            auto k = key(i, j);\\n            if (m.find(k) == m.end()) {\\n                auto a = go(i - 1, j -1),\\n                     b = go(i - 1, j),\\n                     c = go(i - 1, j + 1);\\n                m[k] = A[i][j] + min({ a, b, c });\\n            }\\n            return m[k];\\n        };\\n        auto best = INF;\\n        for (auto j{ 0 }; j < N; ++j)\\n            best = min(best, go(M - 1, j));\\n        return best;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    using fun = function<int(int, int)>;\\n    using Map = unordered_map<string, int>;\\n    int minFallingPathSum(VVI& A, Map m = {}, int INF = 1e9 + 7) {\\n        int M = A.size(),\\n            N = A[0].size();\\n        for (auto i{ 1 }; i < M; ++i) {\\n            for (auto j{ 0 }; j < N; ++j) {\\n                auto a = 0 <= j - 1 ? A[i - 1][j - 1] : INF,\\n                     b = A[i - 1][j],\\n                     c = j + 1 < N ? A[i - 1][j + 1] : INF;\\n                A[i][j] += min({ a, b, c });\\n            }\\n        }\\n        return *min_element(A[M - 1].begin(), A[M - 1].end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 645283,
                "title": "c-simple-easy-solution-using-dp-beginners-friendly",
                "content": "Pls upvote if you find this helpful  :)\\n\\nBasic idea is to divide this problem into subproblems i.e get minimum value corresponding to each grid cell.For the first row the value remains unchanged,while from second row onwards we need to add minimum of the three elements from the previous row.Deal with corner cases separately .Once all this is done we scan the last row and get the minimum.\\n```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& A) {\\n        int row=A.size();\\n        int column=A[0].size();\\n        for(int i=1;i<row;i++){\\n            for(int j=0;j<column;j++){\\n                if(j==0)                                                    //Leftmost or first column\\n                A[i][j]+=min(A[i-1][j],A[i-1][j+1]);\\n                else if(j==column-1)A[i][j]+=min(A[i-1][j],A[i-1][j-1]);     //Rightmost or last column\\n                else A[i][j]+=std::min({A[i-1][j],A[i-1][j+1],A[i-1][j-1]}); //Remaining cases\\n            }\\n        }\\n        int sum=INT_MAX;\\n        for(int i=0;i<column;i++){\\n            sum=min(sum,A[row-1][i]);                                      //Last row scan\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& A) {\\n        int row=A.size();\\n        int column=A[0].size();\\n        for(int i=1;i<row;i++){\\n            for(int j=0;j<column;j++){\\n                if(j==0)                                                    //Leftmost or first column\\n                A[i][j]+=min(A[i-1][j],A[i-1][j+1]);\\n                else if(j==column-1)A[i][j]+=min(A[i-1][j],A[i-1][j-1]);     //Rightmost or last column\\n                else A[i][j]+=std::min({A[i-1][j],A[i-1][j+1],A[i-1][j-1]}); //Remaining cases\\n            }\\n        }\\n        int sum=INT_MAX;\\n        for(int i=0;i<column;i++){\\n            sum=min(sum,A[row-1][i]);                                      //Last row scan\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 206902,
                "title": "python-dp-solution-in-4-lines",
                "content": "\\n    def minFallingPathSum(self, A):\\n        \"\"\"\\n        :type A: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        dp = A[0]\\n        for row in A[1:]:\\n            dp = [value + min([dp[c], dp[max(c - 1, 0)], dp[min(len(A) - 1, c + 1)]]) for c, value in enumerate(row)]\\n        return min(dp)\\n\\t\\t\\n\\t\\t\\nin-place solution:\\n\\n    def minFallingPathSum(self, matrix: List[List[int]]) -> int:\\n        for i in range(1, len(matrix)):\\n            for j in range(len(matrix[0])):\\n                matrix[i][j] += min(matrix[i - 1][max(0, j - 1):j + 2])\\n        return min(matrix[-1])",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "\\n    def minFallingPathSum(self, A):\\n        \"\"\"\\n        :type A: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        dp = A[0]\\n        for row in A[1:]:\\n            dp = [value + min([dp[c], dp[max(c - 1, 0)], dp[min(len(A) - 1, c + 1)]]) for c, value in enumerate(row)]\\n        return min(dp)\\n\\t\\t\\n\\t\\t\\nin-place solution:\\n\\n    def minFallingPathSum(self, matrix: List[List[int]]) -> int:\\n        for i in range(1, len(matrix)):\\n            for j in range(len(matrix[0])):\\n                matrix[i][j] += min(matrix[i - 1][max(0, j - 1):j + 2])\\n        return min(matrix[-1])",
                "codeTag": "Python3"
            },
            {
                "id": 400592,
                "title": "python-beats-100-concise-code",
                "content": "\\tclass Solution(object):\\n\\t\\tdef minFallingPathSum(self, arr):\\n\\t\\t\\tfor i in range(1,len(arr)):\\n\\t\\t\\t\\tfor j in range(len(arr[0])):\\n\\t\\t\\t\\t\\tif j==0:\\n\\t\\t\\t\\t\\t\\tarr[i][j] += min([arr[i-1][j+1], arr[i-1][j]])\\n\\t\\t\\t\\t\\telif j==len(arr[0])-1:\\n\\t\\t\\t\\t\\t\\tarr[i][j] += min([arr[i-1][j-1], arr[i-1][j]])\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tarr[i][j] += min([arr[i-1][j-1], arr[i-1][j], arr[i-1][j+1]])\\n\\t\\t\\treturn min(arr[-1])",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "\\tclass Solution(object):\\n\\t\\tdef minFallingPathSum(self, arr):\\n\\t\\t\\tfor i in range(1,len(arr)):\\n\\t\\t\\t\\tfor j in range(len(arr[0])):\\n\\t\\t\\t\\t\\tif j==0:\\n\\t\\t\\t\\t\\t\\tarr[i][j] += min([arr[i-1][j+1], arr[i-1][j]])\\n\\t\\t\\t\\t\\telif j==len(arr[0])-1:\\n\\t\\t\\t\\t\\t\\tarr[i][j] += min([arr[i-1][j-1], arr[i-1][j]])\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tarr[i][j] += min([arr[i-1][j-1], arr[i-1][j], arr[i-1][j+1]])\\n\\t\\t\\treturn min(arr[-1])",
                "codeTag": "Java"
            },
            {
                "id": 241307,
                "title": "cpp-dp-easy-to-understand",
                "content": "```\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& A) {\\n    vector<vector<int>> dp(A.size(),vector<int>(A.size(),INT_MAX));\\n    for(int i=0;i<A.size();i++){\\n        dp[0][i] = A[0][i];\\n    }\\n    for(int i=1;i<A.size();i++){\\n        for(int j=0;j<A.size();j++){\\n            if(j>0 and j<A.size()-1){\\n                dp[i][j] = min(dp[i-1][j-1]+A[i][j],dp[i-1][j]+A[i][j]);\\n                dp[i][j] = min(dp[i-1][j+1]+A[i][j],dp[i][j]);\\n            }\\n            else if(j==0){\\n                dp[i][j] = min(dp[i-1][j+1]+A[i][j],dp[i-1][j]+A[i][j]);\\n            }\\n            else if(j == A.size()-1){\\n                dp[i][j] = min(dp[i-1][j-1]+A[i][j],dp[i-1][j]+A[i][j]);\\n            }\\n        }\\n    }\\n    \\n    int ans = INT_MAX;\\n    for(auto& x:dp[dp.size()-1]){\\n            ans = min(ans,x);\\n    }\\n    return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& A) {\\n    vector<vector<int>> dp(A.size(),vector<int>(A.size(),INT_MAX));\\n    for(int i=0;i<A.size();i++){\\n        dp[0][i] = A[0][i];\\n    }\\n    for(int i=1;i<A.size();i++){\\n        for(int j=0;j<A.size();j++){\\n            if(j>0 and j<A.size()-1){\\n                dp[i][j] = min(dp[i-1][j-1]+A[i][j],dp[i-1][j]+A[i][j]);\\n                dp[i][j] = min(dp[i-1][j+1]+A[i][j],dp[i][j]);\\n            }\\n            else if(j==0){\\n                dp[i][j] = min(dp[i-1][j+1]+A[i][j],dp[i-1][j]+A[i][j]);\\n            }\\n            else if(j == A.size()-1){\\n                dp[i][j] = min(dp[i-1][j-1]+A[i][j],dp[i-1][j]+A[i][j]);\\n            }\\n        }\\n    }\\n    \\n    int ans = INT_MAX;\\n    for(auto& x:dp[dp.size()-1]){\\n            ans = min(ans,x);\\n    }\\n    return ans;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 201812,
                "title": "recursive-with-memoization-3ms-beats-100",
                "content": "This solution sacrifices memory for speed. Things to keep in mind, minimal error checking, we know that A.length is bigger than 0 so we don\\'t have to check those cases. \\n\\nAlso there is one case that that might be a problem but I leave that as homework for you.\\n```\\nclass Solution {\\n    int[][] memo;\\n    public int minFallingPathSum(int[][] A) {\\n        int minPath = Integer.MAX_VALUE;\\n        memo = new int[A.length][A.length];\\n        for (int i = 0; i < A.length; i++){\\n            minPath = Math.min(minPath, findMinPath(A, 0, i));\\n        }\\n        return minPath;    \\n    }\\n    \\n    private int findMinPath(int[][] A, int row, int column){\\n        if (row == A.length - 1){\\n            return A[row][column];\\n        } \\n        if (memo[row][column] != 0) {return memo[row][column];}\\n        int minPath = Integer.MAX_VALUE; \\n        int value = A[row][column];\\n        if (column-1 >= 0)\\n            minPath = Math.min(minPath, findMinPath(A, row + 1, column - 1) + value);\\n        if (column+1 < A.length)\\n            minPath = Math.min(minPath, findMinPath(A, row + 1, column + 1) + value);\\n        minPath = Math.min(minPath, findMinPath(A, row + 1, column) + value);\\n        memo[row][column] = minPath;\\n        \\n        return minPath;\\n            \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int[][] memo;\\n    public int minFallingPathSum(int[][] A) {\\n        int minPath = Integer.MAX_VALUE;\\n        memo = new int[A.length][A.length];\\n        for (int i = 0; i < A.length; i++){\\n            minPath = Math.min(minPath, findMinPath(A, 0, i));\\n        }\\n        return minPath;    \\n    }\\n    \\n    private int findMinPath(int[][] A, int row, int column){\\n        if (row == A.length - 1){\\n            return A[row][column];\\n        } \\n        if (memo[row][column] != 0) {return memo[row][column];}\\n        int minPath = Integer.MAX_VALUE; \\n        int value = A[row][column];\\n        if (column-1 >= 0)\\n            minPath = Math.min(minPath, findMinPath(A, row + 1, column - 1) + value);\\n        if (column+1 < A.length)\\n            minPath = Math.min(minPath, findMinPath(A, row + 1, column + 1) + value);\\n        minPath = Math.min(minPath, findMinPath(A, row + 1, column) + value);\\n        memo[row][column] = minPath;\\n        \\n        return minPath;\\n            \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1738722,
                "title": "easy-dp-recurion-memoization-tabulation-space-optimization",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    \\n    \\n    //BASIC RECURSION \\n    \\n    \\n    \\n    int f(int i,int j,int n,int m,vector<vector<int>>& a)\\n    {\\n        if(j<0 || j>m-1)\\n            return 1e9;\\n        \\n        if(i==0)\\n            return a[i][j];\\n        \\n        int up = a[i][j] + f(i-1,j,n,m,a);\\n        \\n        int ld = a[i][j] + f(i-1,j-1,n,m,a);\\n        \\n        int rd = a[i][j] + f(i-1,j+1,n,m,a);\\n        \\n        \\n        return min(up,min(ld,rd));\\n        \\n    }\\n    \\n    \\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        \\n        int ans=INT_MAX;\\n        \\n        int n=matrix.size();\\n        \\n        int m=matrix[0].size();\\n        \\n        for(int j=0;j<m;j++)\\n        {\\n            ans=min(ans,f(n-1,j,n,m,matrix));\\n        }\\n        \\n        return ans;\\n        \\n    }\\n    \\n    \\n    \\n     \\n    //MEMOIZATION\\n    \\n    \\n    \\n    \\n    int f(int i,int j,int n,int m,vector<vector<int>>& a,vector<vector<int>>&dp)\\n    {\\n        if(j<0 || j>m-1)\\n            return 1e9;\\n        \\n        if(i==0)\\n            return a[i][j];\\n        \\n        if(dp[i][j]!=-1)\\n            return dp[i][j];\\n        \\n        int up = a[i][j] + f(i-1,j,n,m,a,dp);\\n        \\n        int ld = a[i][j] + f(i-1,j-1,n,m,a,dp);\\n        \\n        int rd = a[i][j] + f(i-1,j+1,n,m,a,dp);\\n        \\n        \\n        return dp[i][j]=min(up,min(ld,rd));\\n        \\n    }\\n    \\n    \\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        \\n        int ans=INT_MAX;\\n        \\n        int n=matrix.size();\\n        \\n        int m=matrix[0].size();\\n        \\n        vector<vector<int>>dp(n,vector<int>(m,-1));\\n        \\n        for(int j=0;j<m;j++)\\n        {\\n            ans=min(ans,f(n-1,j,n,m,matrix,dp));\\n        }\\n        \\n        return ans;\\n        \\n    }\\n    \\n    \\n    \\n    \\n    \\n    //TABULATION\\n    \\n    \\n    \\n    \\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        \\n        \\n        \\n        int n=matrix.size();\\n        \\n        int m=matrix[0].size();\\n        \\n        vector<vector<int>>dp(n,vector<int>(m,0));\\n        \\n        \\n        for(int j=0;j<m;j++)\\n        {\\n            dp[0][j]=matrix[0][j];\\n            \\n        }\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                int ld=1e9,rd=1e9;\\n                \\n                \\n                int up=matrix[i][j] + dp[i-1][j];\\n                \\n                if(j-1>=0)\\n                    ld=matrix[i][j] + dp[i-1][j-1];\\n                if(j+1<m)\\n                    rd=matrix[i][j] + dp[i-1][j+1];\\n                \\n                dp[i][j] = min(up,min(ld,rd));\\n                \\n                \\n                \\n            }\\n        }\\n        \\n        int mini=dp[n-1][0];\\n        \\n        for(int j=1;j<m;j++)\\n        {\\n            \\n            mini=min(mini,dp[n-1][j]);\\n            \\n        }\\n        return mini;\\n        \\n    }\\n    \\n    \\n    \\n    \\n    // space optimization \\n    \\n    \\n    \\n    \\n    \\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        \\n        \\n        \\n        int n=matrix.size();\\n        \\n        int m=matrix[0].size();\\n        \\n        vector<int>cur(m,0);\\n        vector<int>prev(m,0);\\n        \\n        for(int j=0;j<m;j++)\\n        {\\n            prev[j]=matrix[0][j]; \\n        }\\n        \\n        \\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                int ld=1e9,rd=1e9;\\n                \\n                \\n                int up=matrix[i][j] + prev[j];\\n                \\n                if(j-1>=0)\\n                    ld=matrix[i][j] + prev[j-1];\\n                if(j+1<m)\\n                    rd=matrix[i][j] + prev[j+1];\\n                \\n                cur[j] = min(up,min(ld,rd));\\n                \\n                \\n                \\n            }\\n            prev=cur;\\n        }\\n        \\n        int mini=prev[0];\\n        \\n        for(int j=1;j<m;j++)\\n        {\\n            \\n            mini=min(mini,prev[j]);\\n            \\n        }\\n        return mini;\\n        \\n    }\\n    \\n    \\n    \\n    \\n    \\n    \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    \\n    \\n    //BASIC RECURSION \\n    \\n    \\n    \\n    int f(int i,int j,int n,int m,vector<vector<int>>& a)\\n    {\\n        if(j<0 || j>m-1)\\n            return 1e9;\\n        \\n        if(i==0)\\n            return a[i][j];\\n        \\n        int up = a[i][j] + f(i-1,j,n,m,a);\\n        \\n        int ld = a[i][j] + f(i-1,j-1,n,m,a);\\n        \\n        int rd = a[i][j] + f(i-1,j+1,n,m,a);\\n        \\n        \\n        return min(up,min(ld,rd));\\n        \\n    }\\n    \\n    \\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        \\n        int ans=INT_MAX;\\n        \\n        int n=matrix.size();\\n        \\n        int m=matrix[0].size();\\n        \\n        for(int j=0;j<m;j++)\\n        {\\n            ans=min(ans,f(n-1,j,n,m,matrix));\\n        }\\n        \\n        return ans;\\n        \\n    }\\n    \\n    \\n    \\n     \\n    //MEMOIZATION\\n    \\n    \\n    \\n    \\n    int f(int i,int j,int n,int m,vector<vector<int>>& a,vector<vector<int>>&dp)\\n    {\\n        if(j<0 || j>m-1)\\n            return 1e9;\\n        \\n        if(i==0)\\n            return a[i][j];\\n        \\n        if(dp[i][j]!=-1)\\n            return dp[i][j];\\n        \\n        int up = a[i][j] + f(i-1,j,n,m,a,dp);\\n        \\n        int ld = a[i][j] + f(i-1,j-1,n,m,a,dp);\\n        \\n        int rd = a[i][j] + f(i-1,j+1,n,m,a,dp);\\n        \\n        \\n        return dp[i][j]=min(up,min(ld,rd));\\n        \\n    }\\n    \\n    \\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        \\n        int ans=INT_MAX;\\n        \\n        int n=matrix.size();\\n        \\n        int m=matrix[0].size();\\n        \\n        vector<vector<int>>dp(n,vector<int>(m,-1));\\n        \\n        for(int j=0;j<m;j++)\\n        {\\n            ans=min(ans,f(n-1,j,n,m,matrix,dp));\\n        }\\n        \\n        return ans;\\n        \\n    }\\n    \\n    \\n    \\n    \\n    \\n    //TABULATION\\n    \\n    \\n    \\n    \\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        \\n        \\n        \\n        int n=matrix.size();\\n        \\n        int m=matrix[0].size();\\n        \\n        vector<vector<int>>dp(n,vector<int>(m,0));\\n        \\n        \\n        for(int j=0;j<m;j++)\\n        {\\n            dp[0][j]=matrix[0][j];\\n            \\n        }\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                int ld=1e9,rd=1e9;\\n                \\n                \\n                int up=matrix[i][j] + dp[i-1][j];\\n                \\n                if(j-1>=0)\\n                    ld=matrix[i][j] + dp[i-1][j-1];\\n                if(j+1<m)\\n                    rd=matrix[i][j] + dp[i-1][j+1];\\n                \\n                dp[i][j] = min(up,min(ld,rd));\\n                \\n                \\n                \\n            }\\n        }\\n        \\n        int mini=dp[n-1][0];\\n        \\n        for(int j=1;j<m;j++)\\n        {\\n            \\n            mini=min(mini,dp[n-1][j]);\\n            \\n        }\\n        return mini;\\n        \\n    }\\n    \\n    \\n    \\n    \\n    // space optimization \\n    \\n    \\n    \\n    \\n    \\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        \\n        \\n        \\n        int n=matrix.size();\\n        \\n        int m=matrix[0].size();\\n        \\n        vector<int>cur(m,0);\\n        vector<int>prev(m,0);\\n        \\n        for(int j=0;j<m;j++)\\n        {\\n            prev[j]=matrix[0][j]; \\n        }\\n        \\n        \\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                int ld=1e9,rd=1e9;\\n                \\n                \\n                int up=matrix[i][j] + prev[j];\\n                \\n                if(j-1>=0)\\n                    ld=matrix[i][j] + prev[j-1];\\n                if(j+1<m)\\n                    rd=matrix[i][j] + prev[j+1];\\n                \\n                cur[j] = min(up,min(ld,rd));\\n                \\n                \\n                \\n            }\\n            prev=cur;\\n        }\\n        \\n        int mini=prev[0];\\n        \\n        for(int j=1;j<m;j++)\\n        {\\n            \\n            mini=min(mini,prev[j]);\\n            \\n        }\\n        return mini;\\n        \\n    }\\n    \\n    \\n    \\n    \\n    \\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1087173,
                "title": "python-dp-easy-to-understand",
                "content": "Guys im emotional because this is the first medium dp tabulation problem ive solved on my own in <10 minutes. Thanks to anyone who reads this.\\n```\\nimport math\\nclass Solution:\\n    def minFallingPathSum(self, matrix: List[List[int]]) -> int:\\n        for row in range(1, len(matrix)):\\n            for col in range(len(matrix)):\\n\\t\\t\\t\\t# Update current element with the min of its upper 3 elements. \\n\\t\\t\\t\\t# If any of those do not exist then just use math.inf as placeholder\\n                matrix[row][col] = matrix[row][col] + \\\\\\n\\t\\t\\t\\tmin(matrix[row-1][col], \\n\\t\\t\\t\\tmatrix[row-1][col-1] if col - 1 >= 0 else math.inf, \\n\\t\\t\\t\\tmatrix[row-1][col+1] if col + 1 < len(matrix) else math.inf)\\n\\t\\t# The minimum item on the last row is the result because it is the \"smallest path sum\"\\n        return min(matrix[-1])\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nimport math\\nclass Solution:\\n    def minFallingPathSum(self, matrix: List[List[int]]) -> int:\\n        for row in range(1, len(matrix)):\\n            for col in range(len(matrix)):\\n\\t\\t\\t\\t# Update current element with the min of its upper 3 elements. \\n\\t\\t\\t\\t# If any of those do not exist then just use math.inf as placeholder\\n                matrix[row][col] = matrix[row][col] + \\\\\\n\\t\\t\\t\\tmin(matrix[row-1][col], \\n\\t\\t\\t\\tmatrix[row-1][col-1] if col - 1 >= 0 else math.inf, \\n\\t\\t\\t\\tmatrix[row-1][col+1] if col + 1 < len(matrix) else math.inf)\\n\\t\\t# The minimum item on the last row is the result because it is the \"smallest path sum\"\\n        return min(matrix[-1])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2906833,
                "title": "python-c-dp-dfs",
                "content": "**\\u2705 IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n****\\nThis solution employs a *Dynamic Programming* approach to explore all possible paths. Time complexity is quadratic: **O(N\\\\*N)**. Space complexity is quadratic: **O(N\\\\*N)**.\\n****\\n\\n**Comment.** Path with the minimal sum is defined recursively, i.e., the path starting from some element in the current row is continued by the element in the next row (that is either directly below or diagonally left/right) which itself is a start of a minimal-sum path.\\n\\n**Python.** Recursive DFS. \\n```\\nclass Solution:\\n    def minFallingPathSum(self, mat: List[List[int]]) -> int:\\n        \\n        n = len(mat)\\n        \\n        @cache\\n        def dfs(i,j):\\n            if i == n          : return 0                                   # the bottom is reached\\n            if j < 0 or j == n : return float(\\'inf\\')                        # a boundary is reached\\n            return mat[i][j] + min(dfs(i+1,j-1), dfs(i+1,j), dfs(i+1,j+1))  # recursive condition\\n        \\n        return min(dfs(0,j) for j in range(n))                              # try all starting elements\\n```\\n\\n**C++.** Iterative DP.\\n```\\nclass Solution\\n{\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& m)\\n    {\\n        int n = m.size();\\n        \\n        for (int i = n-2; i >= 0; --i)\\n            for (int j = n-1; j >= 0; --j)\\n                m[i][j] += min({ m[i+1][max(j-1,0)], \\n                                 m[i+1][j], \\n                                 m[i+1][min(j+1,n-1)] });\\n        \\n        return *min_element(m[0].begin(), m[0].end());\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minFallingPathSum(self, mat: List[List[int]]) -> int:\\n        \\n        n = len(mat)\\n        \\n        @cache\\n        def dfs(i,j):\\n            if i == n          : return 0                                   # the bottom is reached\\n            if j < 0 or j == n : return float(\\'inf\\')                        # a boundary is reached\\n            return mat[i][j] + min(dfs(i+1,j-1), dfs(i+1,j), dfs(i+1,j+1))  # recursive condition\\n        \\n        return min(dfs(0,j) for j in range(n))                              # try all starting elements\\n```\n```\\nclass Solution\\n{\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& m)\\n    {\\n        int n = m.size();\\n        \\n        for (int i = n-2; i >= 0; --i)\\n            for (int j = n-1; j >= 0; --j)\\n                m[i][j] += min({ m[i+1][max(j-1,0)], \\n                                 m[i+1][j], \\n                                 m[i+1][min(j+1,n-1)] });\\n        \\n        return *min_element(m[0].begin(), m[0].end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 470229,
                "title": "easy-soution-by-3-ways-recursion-dp-bottom-up-and-dp-top-down",
                "content": "##### By simple recursion: \\n```\\n\\tconst int inf=1e8;\\n    int start(int x,int y,vector<vector<int>> &a)\\n    {\\n        if(x==a.size()) return 0;\\n        if(y==-1 || y==a[0].size()) return inf;\\n\\n\\n         int ans=INT_MAX;\\n        ans = min(ans,a[x][y] + start(x+1,y-1,a));\\n        ans = min(ans,a[x][y] + start(x+1,y,a));\\n        ans = min(ans,a[x][y] + start(x+1,y+1,a));\\n\\n         return ans;\\n    }\\n\\n     int minFallingPathSum(vector<vector<int>>& a) {\\n        int row = a.size();\\n        int col = a[0].size();\\n\\n         int ans = INT_MAX;\\n        for(int i=0;i<col;i++)\\n        {\\n            ans  = min(ans,start(0,i,a));\\n        }\\n        return ans;\\n    }\\n```\\n#### By Dynamic Programming : \\n\\n**1. Top-down** : \\n```\\n\\tconst int inf=1e8;\\n    vector<vector<int>> dp,visit;\\n    int start(int x,int y,vector<vector<int>> &a)\\n    {\\n        if(x==a.size()) return 0;\\n        if(y==-1 || y==a[0].size()) return inf;\\n            \\n        if(visit[x][y]) return dp[x][y];\\n        \\n        int ans=INT_MAX;\\n        ans = min(ans,a[x][y] + start(x+1,y-1,a));\\n        ans = min(ans,a[x][y] + start(x+1,y,a));\\n        ans = min(ans,a[x][y] + start(x+1,y+1,a));\\n        visit[x][y] = 1;\\n        return dp[x][y] = ans;\\n    }\\n    \\n    int minFallingPathSum(vector<vector<int>>& a) {\\n        int row = a.size();\\n        int col = a[0].size();\\n        \\n        dp.resize(row, vector<int>(col));\\n        visit.resize(row, vector<int>(col,0));\\n\\n        int ans = INT_MAX;\\n        for(int i=0;i<col;i++)\\n        {\\n            ans  = min(ans,start(0,i,a));\\n        }\\n        return ans;\\n    }\\n```\\n**2. Bottom-up**\\n```\\n\\tint n = a.size();\\n\\tvector<vector<int>> dp(n+1,vector<int>(n+2));\\n\\n\\tfor(int i=0;i<n+1;i++)\\n\\t{\\n\\t\\tdp[i][0] = dp[i][n+1] = INT_MAX;\\n\\t\\tdp[n][i] = 0;\\n\\t}\\n\\n\\tfor(int i=n-1;i>=0;i--)\\n\\t\\tfor(int j=n-1;j>=0;j--)\\n\\t\\t\\tdp[i][j+1] = a[i][j] + min(dp[i+1][j],min(dp[i+1][j+1], dp[i+1][j+2]) );\\n\\n\\tint ans=INT_MAX;\\n\\tfor(int i=1;i<=n;i++)\\n\\t\\tans = min(ans,dp[0][i]);\\n\\treturn ans;\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\n\\tconst int inf=1e8;\\n    int start(int x,int y,vector<vector<int>> &a)\\n    {\\n        if(x==a.size()) return 0;\\n        if(y==-1 || y==a[0].size()) return inf;\\n\\n\\n         int ans=INT_MAX;\\n        ans = min(ans,a[x][y] + start(x+1,y-1,a));\\n        ans = min(ans,a[x][y] + start(x+1,y,a));\\n        ans = min(ans,a[x][y] + start(x+1,y+1,a));\\n\\n         return ans;\\n    }\\n\\n     int minFallingPathSum(vector<vector<int>>& a) {\\n        int row = a.size();\\n        int col = a[0].size();\\n\\n         int ans = INT_MAX;\\n        for(int i=0;i<col;i++)\\n        {\\n            ans  = min(ans,start(0,i,a));\\n        }\\n        return ans;\\n    }\\n```\n```\\n\\tconst int inf=1e8;\\n    vector<vector<int>> dp,visit;\\n    int start(int x,int y,vector<vector<int>> &a)\\n    {\\n        if(x==a.size()) return 0;\\n        if(y==-1 || y==a[0].size()) return inf;\\n            \\n        if(visit[x][y]) return dp[x][y];\\n        \\n        int ans=INT_MAX;\\n        ans = min(ans,a[x][y] + start(x+1,y-1,a));\\n        ans = min(ans,a[x][y] + start(x+1,y,a));\\n        ans = min(ans,a[x][y] + start(x+1,y+1,a));\\n        visit[x][y] = 1;\\n        return dp[x][y] = ans;\\n    }\\n    \\n    int minFallingPathSum(vector<vector<int>>& a) {\\n        int row = a.size();\\n        int col = a[0].size();\\n        \\n        dp.resize(row, vector<int>(col));\\n        visit.resize(row, vector<int>(col,0));\\n\\n        int ans = INT_MAX;\\n        for(int i=0;i<col;i++)\\n        {\\n            ans  = min(ans,start(0,i,a));\\n        }\\n        return ans;\\n    }\\n```\n```\\n\\tint n = a.size();\\n\\tvector<vector<int>> dp(n+1,vector<int>(n+2));\\n\\n\\tfor(int i=0;i<n+1;i++)\\n\\t{\\n\\t\\tdp[i][0] = dp[i][n+1] = INT_MAX;\\n\\t\\tdp[n][i] = 0;\\n\\t}\\n\\n\\tfor(int i=n-1;i>=0;i--)\\n\\t\\tfor(int j=n-1;j>=0;j--)\\n\\t\\t\\tdp[i][j+1] = a[i][j] + min(dp[i+1][j],min(dp[i+1][j+1], dp[i+1][j+2]) );\\n\\n\\tint ans=INT_MAX;\\n\\tfor(int i=1;i<=n;i++)\\n\\t\\tans = min(ans,dp[0][i]);\\n\\treturn ans;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2905878,
                "title": "python-3-6-lines-w-explanation-t-m-99-91",
                "content": "Here\\'s the plan:\\n- We start on the bottom row, sliding a three-element window from left to right. \\n- For each window,  we select the minimum value and add it to the element directly above the middle element of the window. \\n- We continue this process on each row moving upward.\\n- When we complete the top row, we select the minimum value as the answer.\\n```\\nclass Solution:\\n    def minFallingPathSum(self, matrix: list[list[int]]) -> int:\\n\\n        m = len(matrix)\\n\\n        matrix = [[inf]+x+[inf] for x in matrix]            # <\\u2013\\u2013 apply some rails to the matrix, whichpreclude  \\n                                                            #     the need for checking if we are off the board\\n        for i in range(m-2,-1,-1):\\n            for j in (range(1,m+1)):\\n                matrix[i][j]+= min(matrix[i+1][j-1:j+2])    # <\\u2013\\u2013 sliding window\\n                \\n        return min(matrix[0])\\n\\n```\\n[https://leetcode.com/problems/minimum-falling-path-sum/submissions/858891502/](http://)\\n\\nI could be wrong, but I think that time is *O*(*N*^2) and space is *O*(*N*).",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minFallingPathSum(self, matrix: list[list[int]]) -> int:\\n\\n        m = len(matrix)\\n\\n        matrix = [[inf]+x+[inf] for x in matrix]            # <\\u2013\\u2013 apply some rails to the matrix, whichpreclude  \\n                                                            #     the need for checking if we are off the board\\n        for i in range(m-2,-1,-1):\\n            for j in (range(1,m+1)):\\n                matrix[i][j]+= min(matrix[i+1][j-1:j+2])    # <\\u2013\\u2013 sliding window\\n                \\n        return min(matrix[0])\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 848477,
                "title": "c-simple-and-clean-solution-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& A) {\\n        int n = A.size();\\n\\t\\t// Creating a dp matrix. This is the STL way to do it.\\n        vector<vector<int>> dp(n, vector<int>(n, 0));\\n        \\n\\t\\t// Populate the DP matrix for the first row.\\n        for(int i=0;i<dp.size();i++){\\n            dp[0][i] = A[0][i];\\n        }\\n        \\n\\t\\t// Loop for the rest of the DP matrix.\\n        for(int i=1; i<n;i++){\\n            for(int j=0;j<n;j++){\\n\\t\\t\\t\\t// INT_MAX is chosen because then that variable won\\'t be taken into consideration at the time of **main step.**\\n                int prevCol = (j>=1) ? dp[i-1][j-1] + A[i][j]: INT_MAX;\\n                int nextCol = (j<n-1) ? dp[i-1][j+1] + A[i][j]: INT_MAX;\\n                int sameCol = dp[i-1][j] + A[i][j];\\n                dp[i][j] = min(prevCol, min(nextCol, sameCol));    // MAIN STEP\\n            }\\n        }\\n        \\n\\t\\t// Calucating the minimum value for the last row becuase that is what we want.\\n        int ans = INT_MAX;\\n        for(int j=0;i<n;j++){\\n            ans = min(ans, dp[n-1][j]);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\nFeel free to ask any doubts in the **comment** section.\\nIf you like this solution, do **UPVOTE**.\\nHappy Coding :)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& A) {\\n        int n = A.size();\\n\\t\\t// Creating a dp matrix. This is the STL way to do it.\\n        vector<vector<int>> dp(n, vector<int>(n, 0));\\n        \\n\\t\\t// Populate the DP matrix for the first row.\\n        for(int i=0;i<dp.size();i++){\\n            dp[0][i] = A[0][i];\\n        }\\n        \\n\\t\\t// Loop for the rest of the DP matrix.\\n        for(int i=1; i<n;i++){\\n            for(int j=0;j<n;j++){\\n\\t\\t\\t\\t// INT_MAX is chosen because then that variable won\\'t be taken into consideration at the time of **main step.**\\n                int prevCol = (j>=1) ? dp[i-1][j-1] + A[i][j]: INT_MAX;\\n                int nextCol = (j<n-1) ? dp[i-1][j+1] + A[i][j]: INT_MAX;\\n                int sameCol = dp[i-1][j] + A[i][j];\\n                dp[i][j] = min(prevCol, min(nextCol, sameCol));    // MAIN STEP\\n            }\\n        }\\n        \\n\\t\\t// Calucating the minimum value for the last row becuase that is what we want.\\n        int ans = INT_MAX;\\n        for(int j=0;i<n;j++){\\n            ans = min(ans, dp[n-1][j]);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 186843,
                "title": "python-easy-4-liner",
                "content": "* Idea is simple.\\n* Starting from row 1, for each number in the current row (A[i][j]), cumulate minimum previous sum from (A[i - 1][j - 1], A[i - 1][j], A[i - 1][j + 1]).\\n* Return minimum cumulated sum in the last row\\n```\\nclass Solution:\\n    def minFallingPathSum(self, A):\\n        for i in range(1, len(A)):\\n            for j in range(len(A)):\\n                A[i][j] += min(A[i - 1][j and j - 1:j + 2])\\n        return min(A[-1])\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minFallingPathSum(self, A):\\n        for i in range(1, len(A)):\\n            for j in range(len(A)):\\n                A[i][j] += min(A[i - 1][j and j - 1:j + 2])\\n        return min(A[-1])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 186650,
                "title": "java-top-down-dynamic-programming",
                "content": "```\\nclass Solution {\\n    public int minFallingPathSum(int[][] A) {\\n        int m = A.length;\\n        int n = A[0].length;\\n        \\n\\n        if (m == 1 || n == 1) return A[0][0];\\n        \\n        Integer[][] dp = new Integer[m][n];\\n        int ans = Integer.MAX_VALUE;\\n        for (int i = 0; i < A.length; i++){\\n            ans = Math.min(ans, minFallingPathSum(A, 0, i, dp));\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    int minFallingPathSum(int[][] A, int row, int col, Integer[][]dp){\\n        int m = A.length;\\n        int n = A[0].length;\\n        \\n        if (dp[row][col] != null) return dp[row][col];\\n        \\n        if (row == n-1) //If we are on the last row then we are done for this path\\n            return dp[row][col] = A[row][col];\\n        \\n        int left = Integer.MAX_VALUE, right = Integer.MAX_VALUE;\\n        if (col > 0)\\n         left = minFallingPathSum(A, row +1, col-1, dp);\\n        \\n        int straight = minFallingPathSum(A, row+1, col, dp);\\n        \\n        if (col < n-1)\\n         right = minFallingPathSum(A, row+1, col+1, dp);\\n            \\n        dp[row][col] = Math.min(left, Math.min(straight, right)) + A[row][col];\\n        \\n        return dp[row][col];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minFallingPathSum(int[][] A) {\\n        int m = A.length;\\n        int n = A[0].length;\\n        \\n\\n        if (m == 1 || n == 1) return A[0][0];\\n        \\n        Integer[][] dp = new Integer[m][n];\\n        int ans = Integer.MAX_VALUE;\\n        for (int i = 0; i < A.length; i++){\\n            ans = Math.min(ans, minFallingPathSum(A, 0, i, dp));\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    int minFallingPathSum(int[][] A, int row, int col, Integer[][]dp){\\n        int m = A.length;\\n        int n = A[0].length;\\n        \\n        if (dp[row][col] != null) return dp[row][col];\\n        \\n        if (row == n-1) //If we are on the last row then we are done for this path\\n            return dp[row][col] = A[row][col];\\n        \\n        int left = Integer.MAX_VALUE, right = Integer.MAX_VALUE;\\n        if (col > 0)\\n         left = minFallingPathSum(A, row +1, col-1, dp);\\n        \\n        int straight = minFallingPathSum(A, row+1, col, dp);\\n        \\n        if (col < n-1)\\n         right = minFallingPathSum(A, row+1, col+1, dp);\\n            \\n        dp[row][col] = Math.min(left, Math.min(straight, right)) + A[row][col];\\n        \\n        return dp[row][col];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2723332,
                "title": "java-dp-solution-2-approaches-and-complexity-analysis-with-full-explanation",
                "content": "I will show `2 approaches` using Dynamic Programming to solve this question.\\n\\nIn this question, ***3 important things need to be highlighted***: \\n1. **starts at any element in the first row** - this means that, we need to compute answer by taking into consideration each element of `first row`  \\n2. allowed positions are **(row + 1, col - 1), (row + 1, col), or (row + 1, col + 1)**\\n3. question just demands you to reach the **last row** and `not last row\\'s last element `(as in few other path sum problems)\\n\\nSo basically, \\n- we need to find answer by considering each element of first row as starting element of path\\n- for that starting element, we\\'ll find answers considering 3 allowed moves as stated in point 2\\n- find the minimun of those (as we need to return the minimum path sum)\\n\\n## Approach 1 - DP (recursive)\\nWe shall consider variable `i` is for `rows` and `j` for columns and `n` as size of grid(matrix)\\nWe will follow the general approach that is followed for other path sum problems weherin we store value returned recursively by making recursive calls for each path.\\n\\n**Base case senarios**\\n1. if `j >= n`: i.e; we have crossed the bounds of that row and hence we shall return some **large** **positive** number, say (10^7). We are returning large and positive number because it should not be counted when we taken into account when finding the minimum sum as that number doesnot exist in the array.\\n\\t> We are not returning Integer.MAX_VALUE because in future variable recieves that value, it is added to grid[i][j] and when we add a number to MAX_VALUE it results in negative number to avoid overflow.\\n2. if `i == n - 1`: as i stated in 3rd point in the \"points to be highlighted\" - when we reach last row (where index of last row is n - 1) we need to simply stop the operations and return value - `grid[i][j]`\\n\\n**Code**\\n``` java\\npublic int minFallingPathSum(int[][] grid) {\\n        Integer[][] dp = new Integer[grid.length + 1][grid[0].length];\\n        int ans = Integer.MAX_VALUE;\\n        for (int i = 0; i < grid.length; i++)\\n            ans = Math.min(ans, (helperRecursiveDP(grid, dp, 0, i, grid.length)));\\n\\t\\t\\t// finding answers for each column of first row seperatly and storing the minimum value in variable ans \\n        return ans;\\n    }\\n\\t\\n// helper function which computes the result for each column in row 1\\nprivate int helperRecursiveDP(int[][] grid, Integer[][] dp, int i, int j, int n) {\\n        if (j >= n || j < 0) // base-case 1\\n            return (int) Math.pow(10, 7);\\n\\n        if (i == n - 1)\\n            return grid[i][j]; // base-case 2\\n\\n        if (dp[i][j] != null)\\n            return dp[i][j]; // avoiding repetitive steps by returning previously calculated ans\\n\\t\\t\\n\\t\\t// Traversing path according to the question\\n        int x = grid[i][j] + helperRecursiveDP(grid, dp, i + 1, j, n);\\n        int y = grid[i][j] + helperRecursiveDP(grid, dp, i + 1, j + 1, n);\\n        int z = grid[i][j] + helperRecursiveDP(grid, dp, i + 1, j - 1, n);\\n\\n        int ans = Math.min(x, Math.min(y, z)); // finding min of values returned by three traversed paths\\n        dp[i][j] = ans;\\n\\n        return ans;\\n    }\\n```\\n- Time complexity - O(N^2) because at max there will be `N*N` calls for every new problem\\n- Space complexity - O(N ^ 2) + O(N) because we are using O(N) recursive stack space\\n---\\n\\n(\\uD83C\\uDF1FPlease upvote\\u2B06 if it helps. Thank you\\uD83E\\uDD17)\\n\\n---\\n\\n## Approach 2 - Iterative DP (tabulation)\\n\\n**Note**\\n > - One thing to note here is that, dp array will have 2 extra colums on each side (like ***cusion***) so that `ArrayIndexOutOfBounds exception` will be avoided without requiring extra if-else statements. \\n > - We are doing so because we are looping through arrays with column values as (col - 1) (col) (col + 1) for (row + 1) and if we don\\'t add 1 extra columns at each end then at col == 0 and col == n - 1, we will get exceptions.\\n >  - i -> rows, j-> columns, n -> no. of rows\\n\\nTo convert recursive dp to iterative dp, we will do followings steps:\\n1. Pre-store values as per base cases. Therefore\\n\\t- in dp array, we will fill column == 0 and column == n + 1 (cusion columns of dp array)  `10 ^7` (some large +ve number) \\n\\t- we will fill elements of last row of dp array (apart from cusion elements) with values same as those of grid\\'s last row\\n2. Loop through whole dp matrix and storing respective values as explained in code\\n3. return minimum value in dp array\\'s top row \\n\\n**Code**\\n```\\npublic int minFallingPathSum(int[][] grid) {\\n        return table(grid, new int[grid.length][grid[0].length + 2], grid.length);\\n\\t}\\n\\t\\n// helper function to compute result\\nprivate static int table(int[][] grid, int[][] dp, int n) {\\n        if (grid.length == 1)\\n            return grid[0][0]; // base-case\\n\\t\\t\\t\\n\\t\\t// filling cusion columns with (10^7)\\n        for (int i = 0; i < n; i++) {\\n            dp[i][0] = (int) Math.pow(10, 7);\\n        }\\n        for (int i = 0; i < n; i++) {\\n            dp[i][n + 1] = (int) Math.pow(10, 7);\\n        }\\n\\t\\t\\n        int ans = 0;\\n\\t\\t\\n        for (int i = n - 1; i >= 0; i--) {\\n            int min = Integer.MAX_VALUE;\\n            for (int j = 1; j <= n; j++) {\\n                if (i == n - 1) {\\n                    dp[i][j] = grid[i][j - 1]; // filling elements of last row of dp array (apart from cusion elements) with values same as those of grid\\'s last row\\n                } else {\\n\\t\\t\\t\\t\\n                    int x = grid[i][j - 1] + dp[i + 1][j]; // similar to traversing (row + 1)(col) path\\n                    int y = grid[i][j - 1] + dp[i + 1][j - 1]; // similar to traversing (row + 1)(col - 1) path\\n                    int z = grid[i][j - 1] + dp[i + 1][j + 1]; // similar to traversing (row + 1)(col + 1) path\\n\\n                    dp[i][j] = Math.min(z, Math.min(y, x)); // storing min value of 3 \"paths\"\\n                    min = Math.min(min, dp[i][j]); // finding minimum value of that row. Can be ignored here but then has to be done at the end \"to find minimun value of top row\"\\n                }\\n            }\\n            ans = min;\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\nNote:\\nTo optimize this appraoch a bit, instead of calculating `min` ans in each row, you can calculate it for only the top row of dp array. Anyways, it won\\'t affect the actual time complexity, just the solution will run a bit faster.\\n\\n- Time complexity - O(N^2) because at max there will be `N*N` calls for every new problem\\n- Space complexity - O(N ^ 2) as no recurive stack space involved\\n\\nThankyou for reading.\\n\\n---\\n\\n(\\uD83C\\uDF1FPlease upvote\\u2B06 if it helps. Thank you\\uD83E\\uDD17)\\nIf you have any doubts/suggestions, feel free to comment them down below.\\n\\n---\\n",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "``` java\\npublic int minFallingPathSum(int[][] grid) {\\n        Integer[][] dp = new Integer[grid.length + 1][grid[0].length];\\n        int ans = Integer.MAX_VALUE;\\n        for (int i = 0; i < grid.length; i++)\\n            ans = Math.min(ans, (helperRecursiveDP(grid, dp, 0, i, grid.length)));\\n\\t\\t\\t// finding answers for each column of first row seperatly and storing the minimum value in variable ans \\n        return ans;\\n    }\\n\\t\\n// helper function which computes the result for each column in row 1\\nprivate int helperRecursiveDP(int[][] grid, Integer[][] dp, int i, int j, int n) {\\n        if (j >= n || j < 0) // base-case 1\\n            return (int) Math.pow(10, 7);\\n\\n        if (i == n - 1)\\n            return grid[i][j]; // base-case 2\\n\\n        if (dp[i][j] != null)\\n            return dp[i][j]; // avoiding repetitive steps by returning previously calculated ans\\n\\t\\t\\n\\t\\t// Traversing path according to the question\\n        int x = grid[i][j] + helperRecursiveDP(grid, dp, i + 1, j, n);\\n        int y = grid[i][j] + helperRecursiveDP(grid, dp, i + 1, j + 1, n);\\n        int z = grid[i][j] + helperRecursiveDP(grid, dp, i + 1, j - 1, n);\\n\\n        int ans = Math.min(x, Math.min(y, z)); // finding min of values returned by three traversed paths\\n        dp[i][j] = ans;\\n\\n        return ans;\\n    }\\n```\n```\\npublic int minFallingPathSum(int[][] grid) {\\n        return table(grid, new int[grid.length][grid[0].length + 2], grid.length);\\n\\t}\\n\\t\\n// helper function to compute result\\nprivate static int table(int[][] grid, int[][] dp, int n) {\\n        if (grid.length == 1)\\n            return grid[0][0]; // base-case\\n\\t\\t\\t\\n\\t\\t// filling cusion columns with (10^7)\\n        for (int i = 0; i < n; i++) {\\n            dp[i][0] = (int) Math.pow(10, 7);\\n        }\\n        for (int i = 0; i < n; i++) {\\n            dp[i][n + 1] = (int) Math.pow(10, 7);\\n        }\\n\\t\\t\\n        int ans = 0;\\n\\t\\t\\n        for (int i = n - 1; i >= 0; i--) {\\n            int min = Integer.MAX_VALUE;\\n            for (int j = 1; j <= n; j++) {\\n                if (i == n - 1) {\\n                    dp[i][j] = grid[i][j - 1]; // filling elements of last row of dp array (apart from cusion elements) with values same as those of grid\\'s last row\\n                } else {\\n\\t\\t\\t\\t\\n                    int x = grid[i][j - 1] + dp[i + 1][j]; // similar to traversing (row + 1)(col) path\\n                    int y = grid[i][j - 1] + dp[i + 1][j - 1]; // similar to traversing (row + 1)(col - 1) path\\n                    int z = grid[i][j - 1] + dp[i + 1][j + 1]; // similar to traversing (row + 1)(col + 1) path\\n\\n                    dp[i][j] = Math.min(z, Math.min(y, x)); // storing min value of 3 \"paths\"\\n                    min = Math.min(min, dp[i][j]); // finding minimum value of that row. Can be ignored here but then has to be done at the end \"to find minimun value of top row\"\\n                }\\n            }\\n            ans = min;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2906026,
                "title": "c-easy-understanding-fastest",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int rows = matrix.size();\\n        int cols = matrix.size();\\n        for(int i = 1; i < rows; i++){\\n            for(int j = 0; j < cols; j++){\\n                int rowUp = matrix[i-1][j];\\n                int leftUp = j>0?matrix[i-1][j-1]:INT_MAX;\\n                int rightUp = j<cols-1?matrix[i-1][j+1]:INT_MAX;\\n                matrix[i][j] += min(rowUp, min(leftUp, rightUp));\\n            }\\n        }\\n        int answer = INT_MAX;\\n        for(int j=0;j < cols; j++){\\n            answer = min(answer, matrix[rows-1][j]);\\n        }\\n        return answer;\\n    }\\n};\\n```\\n**Please upvote if you found the solution is useful**\\n\\n\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int rows = matrix.size();\\n        int cols = matrix.size();\\n        for(int i = 1; i < rows; i++){\\n            for(int j = 0; j < cols; j++){\\n                int rowUp = matrix[i-1][j];\\n                int leftUp = j>0?matrix[i-1][j-1]:INT_MAX;\\n                int rightUp = j<cols-1?matrix[i-1][j+1]:INT_MAX;\\n                matrix[i][j] += min(rowUp, min(leftUp, rightUp));\\n            }\\n        }\\n        int answer = INT_MAX;\\n        for(int j=0;j < cols; j++){\\n            answer = min(answer, matrix[rows-1][j]);\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2905987,
                "title": "memoized-bottomup-sc-o-n-n-sc-o-n-sc-o-1",
                "content": "**Memoized**\\n```\\nclass Solution {\\npublic:\\n    int dp[105][105];\\n    int rec(int i,int j, vector<vector<int>>&a){\\n        if(i==a.size()) return 0;\\n        if(dp[i][j]!=INT_MAX){\\n            return dp[i][j];\\n        }\\n        int op1 = INT_MAX , op2= INT_MAX , op3 = INT_MAX;\\n        if(j-1>=0){\\n            op1 = min(op1 , a[i][j] + rec(i+1,j-1,a));\\n        }\\n        \\n        if(j+1<a[0].size()){\\n            op2 = min(op2, a[i][j] + rec(i+1,j+1,a));\\n        }\\n        op3 = min(op3, a[i][j] + rec(i+1,j,a));\\n        return dp[i][j] = min({op1, op2, op3});\\n    }\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        for(int i=0;i<matrix.size()+1;i++){\\n            for(int j=0;j<=matrix[0].size();j++){\\n                dp[i][j] = INT_MAX;\\n            }\\n        }\\n        int ans = INT_MAX;\\n        for(int i=1;i<=18;i++){\\n            cout<<dp[i][0]<<endl;\\n        }\\n        for(int j=0;j<matrix[0].size();j++){\\n            ans = min(ans , rec(0,j,matrix));\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**Bottom up O(N * N) space**\\n\\n```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& a) {\\n        int n = a.size();\\n        int m = n;\\n        vector<vector<int>> dp(n, vector<int>(m));\\n        for(int j=0;j<m;j++){\\n            dp[0][j] = a[0][j];\\n        }\\n        for(int i=1;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(j==0 and j+1<m){\\n                    dp[i][j] = a[i][j] + min({dp[i-1][j+1], dp[i-1][j]});\\n                }\\n                \\n                if(j==m-1 and j-1>=0){\\n                    dp[i][j] = a[i][j] + min({dp[i-1][j-1], dp[i-1][j] });\\n                }\\n                \\n                if(j-1>=0 and j+1<m){\\n                    dp[i][j] = a[i][j] + min({dp[i-1][j-1], dp[i-1][j] , dp[i-1][j+1]});\\n                }\\n            }\\n        }\\n        return *min_element(begin(dp[n-1]), end(dp[n-1]));\\n    }\\n};\\n```\\n\\n**Bottom up O(N) space**\\n```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& a) {\\n        int n = a.size();\\n        int m = n;\\n        vector<int> curr(m, -1);\\n        vector<int> prev(m);\\n        for(int j=0;j<m;j++){\\n            prev[j] = a[0][j];\\n        }\\n        for(int i=1;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(j==0 and j+1<m){\\n                    curr[j] = a[i][j] + min(prev[j] , prev[j+1]);\\n                }\\n                else if(j==m-1 and j-1>=0){\\n                    curr[j] = a[i][j] + min(prev[j] , prev[j-1]);\\n                }\\n                else{\\n                    curr[j] = a[i][j] + min({prev[j] , prev[j-1], prev[j+1]});\\n                }\\n            }\\n            prev = curr;\\n        }\\n        return *min_element(begin(prev), end(prev));\\n    }\\n};\\n```\\n\\n**Bottom Up O(1) space**\\n```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& a) {\\n        int mx = INT_MAX;\\n        int n = a.size();\\n        int m = n;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(j==0 and j+1<m and i){\\n                    a[i][j] = a[i][j] + min({a[i-1][j+1], a[i-1][j]});\\n                }\\n                if(j==m-1 and j-1>=0 and i){\\n                    a[i][j] = a[i][j] + min({a[i-1][j-1], a[i-1][j] });\\n                }\\n                \\n                if(j-1>=0 and j+1<m and i){\\n                    a[i][j] = a[i][j] + min({a[i-1][j-1], a[i-1][j] , a[i-1][j+1]});\\n                }\\n                if(i==n-1){\\n                    mx = min(mx, a[i][j]);\\n                }\\n            }\\n        }\\n        return mx;\\n    }\\n};\\n```\\n**All above solutions have TC O(N * N)**\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[105][105];\\n    int rec(int i,int j, vector<vector<int>>&a){\\n        if(i==a.size()) return 0;\\n        if(dp[i][j]!=INT_MAX){\\n            return dp[i][j];\\n        }\\n        int op1 = INT_MAX , op2= INT_MAX , op3 = INT_MAX;\\n        if(j-1>=0){\\n            op1 = min(op1 , a[i][j] + rec(i+1,j-1,a));\\n        }\\n        \\n        if(j+1<a[0].size()){\\n            op2 = min(op2, a[i][j] + rec(i+1,j+1,a));\\n        }\\n        op3 = min(op3, a[i][j] + rec(i+1,j,a));\\n        return dp[i][j] = min({op1, op2, op3});\\n    }\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        for(int i=0;i<matrix.size()+1;i++){\\n            for(int j=0;j<=matrix[0].size();j++){\\n                dp[i][j] = INT_MAX;\\n            }\\n        }\\n        int ans = INT_MAX;\\n        for(int i=1;i<=18;i++){\\n            cout<<dp[i][0]<<endl;\\n        }\\n        for(int j=0;j<matrix[0].size();j++){\\n            ans = min(ans , rec(0,j,matrix));\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& a) {\\n        int n = a.size();\\n        int m = n;\\n        vector<vector<int>> dp(n, vector<int>(m));\\n        for(int j=0;j<m;j++){\\n            dp[0][j] = a[0][j];\\n        }\\n        for(int i=1;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(j==0 and j+1<m){\\n                    dp[i][j] = a[i][j] + min({dp[i-1][j+1], dp[i-1][j]});\\n                }\\n                \\n                if(j==m-1 and j-1>=0){\\n                    dp[i][j] = a[i][j] + min({dp[i-1][j-1], dp[i-1][j] });\\n                }\\n                \\n                if(j-1>=0 and j+1<m){\\n                    dp[i][j] = a[i][j] + min({dp[i-1][j-1], dp[i-1][j] , dp[i-1][j+1]});\\n                }\\n            }\\n        }\\n        return *min_element(begin(dp[n-1]), end(dp[n-1]));\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& a) {\\n        int n = a.size();\\n        int m = n;\\n        vector<int> curr(m, -1);\\n        vector<int> prev(m);\\n        for(int j=0;j<m;j++){\\n            prev[j] = a[0][j];\\n        }\\n        for(int i=1;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(j==0 and j+1<m){\\n                    curr[j] = a[i][j] + min(prev[j] , prev[j+1]);\\n                }\\n                else if(j==m-1 and j-1>=0){\\n                    curr[j] = a[i][j] + min(prev[j] , prev[j-1]);\\n                }\\n                else{\\n                    curr[j] = a[i][j] + min({prev[j] , prev[j-1], prev[j+1]});\\n                }\\n            }\\n            prev = curr;\\n        }\\n        return *min_element(begin(prev), end(prev));\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& a) {\\n        int mx = INT_MAX;\\n        int n = a.size();\\n        int m = n;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(j==0 and j+1<m and i){\\n                    a[i][j] = a[i][j] + min({a[i-1][j+1], a[i-1][j]});\\n                }\\n                if(j==m-1 and j-1>=0 and i){\\n                    a[i][j] = a[i][j] + min({a[i-1][j-1], a[i-1][j] });\\n                }\\n                \\n                if(j-1>=0 and j+1<m and i){\\n                    a[i][j] = a[i][j] + min({a[i-1][j-1], a[i-1][j] , a[i-1][j+1]});\\n                }\\n                if(i==n-1){\\n                    mx = min(mx, a[i][j]);\\n                }\\n            }\\n        }\\n        return mx;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 221123,
                "title": "very-easy-to-understand-python-6-line-dp-with-no-extra-space-beats-90",
                "content": "```\\nclass Solution:\\n    def minFallingPathSum(self, A):\\n        \"\"\"\\n        :type A: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        for i in range(1, len(A)):\\n            for j in range(len(A[0])):\\n                topleft = A[i-1][j-1] if j-1>=0 else float(\\'inf\\')\\n                topright = A[i-1][j+1] if j+1<len(A[0]) else float(\\'inf\\')\\n                A[i][j] += min(topleft, topright, A[i-1][j])\\n           \\n        return min(A[-1])\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minFallingPathSum(self, A):\\n        \"\"\"\\n        :type A: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        for i in range(1, len(A)):\\n            for j in range(len(A[0])):\\n                topleft = A[i-1][j-1] if j-1>=0 else float(\\'inf\\')\\n                topright = A[i-1][j+1] if j+1<len(A[0]) else float(\\'inf\\')\\n                A[i][j] += min(topleft, topright, A[i-1][j])\\n           \\n        return min(A[-1])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2905841,
                "title": "94-fastest-javascript-very-easy-to-understand-solution",
                "content": "Visit my youtube! Thank you!\\nhttps://www.youtube.com/channel/UCkhEaNAOO8tig5NHqqxXIeg\\n\\n# Code\\n```\\n/**\\n * @param {number[][]} matrix\\n * @return {number}\\n */\\nvar minFallingPathSum = function(matrix) {\\n    let arr = Array.from(Array(matrix.length),()=>new Array(matrix[0].length).fill(0))\\n    for(let i =0; i<matrix[0].length;i++){\\n        arr[0][i] = matrix[0][i]\\n    }\\n    for(let i =1;i<matrix.length;i++){\\n        for(let j =0;j<matrix[0].length;j++){\\n            if(j==0) arr[i][j] = Math.min(arr[i-1][j],arr[i-1][j+1])\\n            else if(j ==matrix[0].length-1) arr[i][j] = Math.min(arr[i-1][j-1],arr[i-1][j])\\n            else arr[i][j] = Math.min(arr[i-1][j-1],arr[i-1][j],arr[i-1][j+1])\\n            arr[i][j] += matrix[i][j]\\n        }\\n    }\\n    return Math.min(...arr[arr.length-1])\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} matrix\\n * @return {number}\\n */\\nvar minFallingPathSum = function(matrix) {\\n    let arr = Array.from(Array(matrix.length),()=>new Array(matrix[0].length).fill(0))\\n    for(let i =0; i<matrix[0].length;i++){\\n        arr[0][i] = matrix[0][i]\\n    }\\n    for(let i =1;i<matrix.length;i++){\\n        for(let j =0;j<matrix[0].length;j++){\\n            if(j==0) arr[i][j] = Math.min(arr[i-1][j],arr[i-1][j+1])\\n            else if(j ==matrix[0].length-1) arr[i][j] = Math.min(arr[i-1][j-1],arr[i-1][j])\\n            else arr[i][j] = Math.min(arr[i-1][j-1],arr[i-1][j],arr[i-1][j+1])\\n            arr[i][j] += matrix[i][j]\\n        }\\n    }\\n    return Math.min(...arr[arr.length-1])\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2554137,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Using Bottom Up DP***\\n\\n* ***Time Complexity :- O(N * M)***\\n\\n* ***Space Complexity :- O(1)***\\n\\n```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        \\n        int n = matrix.size();\\n        \\n        int m = matrix[0].size();\\n        \\n        // matrix[i][j] will store the minimum sum from 1st row to {i, j}\\n        \\n        for(int i = 1; i < n; i++)\\n        {\\n            for(int j = 0; j < m; j++)\\n            {\\n                // find min. of {up, diagonally left, diagonally right}\\n                \\n                // initialize with up\\n                \\n                int mini = matrix[i - 1][j];\\n                \\n                // diagonally left\\n                \\n                if(j - 1 >= 0)\\n                {\\n                    mini = min(mini, matrix[i - 1][j - 1]);\\n                }\\n                \\n                // diagonally right\\n                \\n                if(j + 1 < m)\\n                {\\n                    mini = min(mini, matrix[i - 1][j + 1]);\\n                }\\n                \\n                // update matrix[i][j]\\n                \\n                matrix[i][j] += mini;\\n            }\\n        }\\n        \\n        return *min_element(matrix[n - 1].begin(), matrix[n - 1].end());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        \\n        int n = matrix.size();\\n        \\n        int m = matrix[0].size();\\n        \\n        // matrix[i][j] will store the minimum sum from 1st row to {i, j}\\n        \\n        for(int i = 1; i < n; i++)\\n        {\\n            for(int j = 0; j < m; j++)\\n            {\\n                // find min. of {up, diagonally left, diagonally right}\\n                \\n                // initialize with up\\n                \\n                int mini = matrix[i - 1][j];\\n                \\n                // diagonally left\\n                \\n                if(j - 1 >= 0)\\n                {\\n                    mini = min(mini, matrix[i - 1][j - 1]);\\n                }\\n                \\n                // diagonally right\\n                \\n                if(j + 1 < m)\\n                {\\n                    mini = min(mini, matrix[i - 1][j + 1]);\\n                }\\n                \\n                // update matrix[i][j]\\n                \\n                matrix[i][j] += mini;\\n            }\\n        }\\n        \\n        return *min_element(matrix[n - 1].begin(), matrix[n - 1].end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 792368,
                "title": "simple-solution-with-explaination-with-comments",
                "content": "Idea : at each step we will choose **minimum** from **(column-1,column,column+1)** of **previous** row.\\n\\n```\\nclass Solution:\\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\\n        m,n = len(arr),len(arr[0])\\n        if m==0 or n==0:return 0\\n        dp = [[None]*n for r in range(m)]\\n        \\n        for i in range(m):\\n            for j in range(n):\\n\\t\\t\\t\\t#base case\\n                if i==0:dp[i][j] = arr[i][j]\\n\\t\\t\\t\\t#when there is only one column\\n                elif j==0 and j==n-1:dp[i][j] = arr[i][j]+dp[i-1][j]\\n\\t\\t\\t\\t#when it is first column, (column-1) will out of bound\\n                elif j==0:dp[i][j] = min(dp[i-1][j],dp[i-1][j+1])+arr[i][j]\\n\\t\\t\\t\\t#when it is last column, (column+1) will out of bound\\n                elif j==n-1:dp[i][j] = min(dp[i-1][j],dp[i-1][j-1])+arr[i][j]\\n\\t\\t\\t\\t#choose min from all of three\\n                else:dp[i][j] = min(dp[i-1][j-1],dp[i-1][j],dp[i-1][j+1])+arr[i][j]\\n\\t\\t#atlast return minimum from last row\\n        return min(dp[-1])\\n        \\n\\t\\t#if you understood this then please appreciate it",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Matrix"
                ],
                "code": "Idea : at each step we will choose **minimum** from **(column-1,column,column+1)** of **previous** row.\\n\\n```\\nclass Solution:\\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\\n        m,n = len(arr),len(arr[0])\\n        if m==0 or n==0:return 0\\n        dp = [[None]*n for r in range(m)]\\n        \\n        for i in range(m):\\n            for j in range(n):\\n\\t\\t\\t\\t#base case\\n                if i==0:dp[i][j] = arr[i][j]\\n\\t\\t\\t\\t#when there is only one column\\n                elif j==0 and j==n-1:dp[i][j] = arr[i][j]+dp[i-1][j]\\n\\t\\t\\t\\t#when it is first column, (column-1) will out of bound\\n                elif j==0:dp[i][j] = min(dp[i-1][j],dp[i-1][j+1])+arr[i][j]\\n\\t\\t\\t\\t#when it is last column, (column+1) will out of bound\\n                elif j==n-1:dp[i][j] = min(dp[i-1][j],dp[i-1][j-1])+arr[i][j]\\n\\t\\t\\t\\t#choose min from all of three\\n                else:dp[i][j] = min(dp[i-1][j-1],dp[i-1][j],dp[i-1][j+1])+arr[i][j]\\n\\t\\t#atlast return minimum from last row\\n        return min(dp[-1])\\n        \\n\\t\\t#if you understood this then please appreciate it",
                "codeTag": "Java"
            },
            {
                "id": 504544,
                "title": "java-top-down-with-memo-faster-than-100-with-comments",
                "content": "```\\nclass Solution {\\n    public int minFallingPathSum(int[][] A) {\\n        Integer[][] dp = new Integer[A.length][A.length];\\n        int min = Integer.MAX_VALUE;\\n        //loop through the first row\\n        for(int i= 0; i < A[0].length; i++) {\\n            //for each element in the first row find the minimum path possible from that element\\n            int curr = minPath(A, 0, i, dp);\\n            min = Math.min(curr, min);\\n        }\\n        return min;\\n    }\\n    private int minPath(int[][] A, int i, int j, Integer[][] dp) {\\n        //if row or col crosses boundaries return Max value since there\\'s no path possible\\n        if(i < 0 || j < 0 || i >= A.length || j >= A[i].length) {\\n            return Integer.MAX_VALUE;\\n        }\\n        //when you reach the end of the path, return the element at the end\\n        if(i == A.length-1) {\\n            return A[i][j];\\n        }\\n        //if you\\'ve already seen the path return the stored result\\n        if(dp[i][j] != null) {\\n            return dp[i][j];\\n        }\\n        //find the best possible path going left\\n        int left = minPath(A, i+1, j-1, dp);\\n        if(left != Integer.MAX_VALUE){\\n            left += A[i][j];\\n        }\\n        //find the best possible path going down\\n        int mid = minPath(A, i+1, j, dp);\\n        if(mid != Integer.MAX_VALUE){\\n            mid += A[i][j];\\n        }\\n        //find the best possible path going right\\n        int right = minPath(A, i+1, j+1, dp);\\n        if(right != Integer.MAX_VALUE){\\n            right += A[i][j];\\n        }\\n        int lm_best = Math.min(left, mid);\\n        //store and the best result found\\n        dp[i][j]= Math.min(lm_best, right);\\n        return dp[i][j];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minFallingPathSum(int[][] A) {\\n        Integer[][] dp = new Integer[A.length][A.length];\\n        int min = Integer.MAX_VALUE;\\n        //loop through the first row\\n        for(int i= 0; i < A[0].length; i++) {\\n            //for each element in the first row find the minimum path possible from that element\\n            int curr = minPath(A, 0, i, dp);\\n            min = Math.min(curr, min);\\n        }\\n        return min;\\n    }\\n    private int minPath(int[][] A, int i, int j, Integer[][] dp) {\\n        //if row or col crosses boundaries return Max value since there\\'s no path possible\\n        if(i < 0 || j < 0 || i >= A.length || j >= A[i].length) {\\n            return Integer.MAX_VALUE;\\n        }\\n        //when you reach the end of the path, return the element at the end\\n        if(i == A.length-1) {\\n            return A[i][j];\\n        }\\n        //if you\\'ve already seen the path return the stored result\\n        if(dp[i][j] != null) {\\n            return dp[i][j];\\n        }\\n        //find the best possible path going left\\n        int left = minPath(A, i+1, j-1, dp);\\n        if(left != Integer.MAX_VALUE){\\n            left += A[i][j];\\n        }\\n        //find the best possible path going down\\n        int mid = minPath(A, i+1, j, dp);\\n        if(mid != Integer.MAX_VALUE){\\n            mid += A[i][j];\\n        }\\n        //find the best possible path going right\\n        int right = minPath(A, i+1, j+1, dp);\\n        if(right != Integer.MAX_VALUE){\\n            right += A[i][j];\\n        }\\n        int lm_best = Math.min(left, mid);\\n        //store and the best result found\\n        dp[i][j]= Math.min(lm_best, right);\\n        return dp[i][j];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 186664,
                "title": "python-dynamic-programming-solution",
                "content": "```python\nclass Solution:\n    def minFallingPathSum(self, A):\n        \"\"\"\n        :type A: List[List[int]]\n        :rtype: int\n        \"\"\"\n        if not A: return 0\n        if len(A) == 1: return A[0][0]\n        length = len(A)\n        for i in range(1, length):\n            for j in range(0, length):\n                if j == 0:\n                    A[i][j] += min(A[i - 1][j], A[i - 1][j + 1])\n                elif j == length - 1:\n                    A[i][j] += min(A[i - 1][j - 1], A[i - 1][j])\n                else:\n                    A[i][j] += min(A[i - 1][j - 1], A[i - 1][j], A[i - 1][j + 1])\n\n        return min(A[-1])\n\n```",
                "solutionTags": [],
                "code": "```python\nclass Solution:\n    def minFallingPathSum(self, A):\n        \"\"\"\n        :type A: List[List[int]]\n        :rtype: int\n        \"\"\"\n        if not A: return 0\n        if len(A) == 1: return A[0][0]\n        length = len(A)\n        for i in range(1, length):\n            for j in range(0, length):\n                if j == 0:\n                    A[i][j] += min(A[i - 1][j], A[i - 1][j + 1])\n                elif j == length - 1:\n                    A[i][j] += min(A[i - 1][j - 1], A[i - 1][j])\n                else:\n                    A[i][j] += min(A[i - 1][j - 1], A[i - 1][j], A[i - 1][j + 1])\n\n        return min(A[-1])\n\n```",
                "codeTag": "Java"
            },
            {
                "id": 3693057,
                "title": "c-solution-dp-memorization-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minFallingPathSumUtil(int row, int col, vector<vector<int>>& matrix, int n, vector<vector<int>>& dp) {\\n\\n    if(row == n-1) return matrix[row][col];\\n\\n    if(dp[row][col] != INT_MIN) return dp[row][col];\\n\\n    return (dp[row][col] = matrix[row][col] + min({\\n       minFallingPathSumUtil(row+1, max(0, col-1), matrix, n, dp),\\n       minFallingPathSumUtil(row+1, col, matrix, n, dp),\\n       minFallingPathSumUtil(row+1, min(n-1, col+1), matrix, n, dp)\\n    }));\\n\\n}\\nint minFallingPathSum(vector<vector<int>>& matrix) {\\n\\n    int n = matrix.size();\\n\\n    vector<vector<int>> dp(n, vector<int>(n, INT_MIN));\\n        int mini = INT_MAX;\\n        for(int i = 0; i < n; i++) { \\n\\n            mini = min(mini, minFallingPathSumUtil(0, i, matrix, n, dp));\\n        }\\n\\n        return mini;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minFallingPathSumUtil(int row, int col, vector<vector<int>>& matrix, int n, vector<vector<int>>& dp) {\\n\\n    if(row == n-1) return matrix[row][col];\\n\\n    if(dp[row][col] != INT_MIN) return dp[row][col];\\n\\n    return (dp[row][col] = matrix[row][col] + min({\\n       minFallingPathSumUtil(row+1, max(0, col-1), matrix, n, dp),\\n       minFallingPathSumUtil(row+1, col, matrix, n, dp),\\n       minFallingPathSumUtil(row+1, min(n-1, col+1), matrix, n, dp)\\n    }));\\n\\n}\\nint minFallingPathSum(vector<vector<int>>& matrix) {\\n\\n    int n = matrix.size();\\n\\n    vector<vector<int>> dp(n, vector<int>(n, INT_MIN));\\n        int mini = INT_MAX;\\n        for(int i = 0; i < n; i++) { \\n\\n            mini = min(mini, minFallingPathSumUtil(0, i, matrix, n, dp));\\n        }\\n\\n        return mini;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3640333,
                "title": "very-simple-java-dp-tabulation-solution-everything-explained",
                "content": "\\n# Approach\\n1. Make a dp array and store the first row of matrix as it is in the array as that will the the minimum falling sum if we land on that element.\\n2. Now just iterate through the array by choosing the minimum falling sum from the above rows as per the given conditions. Check for boundary elements. The if/else checks are for them. Now we have filled up the DP array.\\n3. Now the dp array in the last row consists of n values out to which we have to select the minimum one.\\n\\n# Complexity\\n- Time complexity:\\nO(N X N)\\n\\n- Space complexity:\\nO(N X N)\\n\\n# Code\\n```\\nclass Solution {\\n    public int minFallingPathSum(int[][] matrix) {\\n        int n = matrix.length;\\n        int [][] dp = new int [n][n]; \\n        dp[0][0] = matrix[0][0];  \\n        for(int i=1;i<n;i++){\\n            dp[0][i] = matrix[0][i]; # 1\\n        }\\n        for(int i =0;i<n;i++){\\n            for(int j=0;j<n;j++){ #2\\n                if(i==0) continue;\\n                else if(j==0){\\n                    dp[i][j] = matrix[i][j] + Math.min(dp[i-1][j+1],dp[i-1][j]);\\n                }\\n                else if(j==n-1){\\n                    dp[i][j] = matrix[i][j] + Math.min(dp[i-1][j-1],dp[i-1][j]);\\n                }\\n                else{\\n                    dp[i][j] = matrix[i][j] + Math.min(dp[i-1][j+1],Math.min(dp[i-1][j-1],dp[i-1][j]));\\n                }\\n            }\\n        }\\n        int min = Integer.MAX_VALUE;\\n        for(int i=0;i<n;i++){\\n            min = Math.min(dp[n-1][i],min); #3\\n        }\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int minFallingPathSum(int[][] matrix) {\\n        int n = matrix.length;\\n        int [][] dp = new int [n][n]; \\n        dp[0][0] = matrix[0][0];  \\n        for(int i=1;i<n;i++){\\n            dp[0][i] = matrix[0][i]; # 1\\n        }\\n        for(int i =0;i<n;i++){\\n            for(int j=0;j<n;j++){ #2\\n                if(i==0) continue;\\n                else if(j==0){\\n                    dp[i][j] = matrix[i][j] + Math.min(dp[i-1][j+1],dp[i-1][j]);\\n                }\\n                else if(j==n-1){\\n                    dp[i][j] = matrix[i][j] + Math.min(dp[i-1][j-1],dp[i-1][j]);\\n                }\\n                else{\\n                    dp[i][j] = matrix[i][j] + Math.min(dp[i-1][j+1],Math.min(dp[i-1][j-1],dp[i-1][j]));\\n                }\\n            }\\n        }\\n        int min = Integer.MAX_VALUE;\\n        for(int i=0;i<n;i++){\\n            min = Math.min(dp[n-1][i],min); #3\\n        }\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2906365,
                "title": "c-3-approaches-memoization-tabulation-space-optimization",
                "content": "# Intuition\\nSince we have to find all possible ways to get minimum path sum, we use recursion and dp.\\n\\n# Approach\\nWe start from every column of last row (we can also start from first row) and move in all three mentioned directions upward (i-1, j-1), (i-1, j), and (i-1, j+1). If we go out of the matrix boundary we return max value. When we reach any column of the first row, we return that cell value and at last we calculate minimum path sum among all path sums and return it.\\n\\n# Memoization : (Top-Down Approach)\\n    \\n```\\nint f(int i, int j, vector<vector<int>> &mat, vector<vector<int>> &dp)\\n{\\n    if(j<0 || j>=mat[0].size()) return 1e8;\\n    if(i==0) return mat[0][j];\\n    if(dp[i][j] != -1) return dp[i][j];\\n\\n    int u=mat[i][j] + f(i-1, j, mat, dp);\\n    int ld=mat[i][j] + f(i-1, j-1, mat, dp);\\n    int rd=mat[i][j] + f(i-1, j+1, mat, dp);\\n\\n    return dp[i][j] = min(u, min(ld, rd));\\n}\\n\\nint minFallingPathSum(vector<vector<int>> &mat)\\n{\\n    int m=mat.size(), n=mat[0].size();\\n    vector<vector<int>> dp(m, vector<int> (n, -1));\\n    int mini=1e8;\\n    for(int j=0; j<n; j++)\\n        mini = min(mini, f(m-1, j, mat, dp));\\n    return mini;\\n}\\n```\\n### Complexity\\n**Time Complexity: O(mxn)** (recursion) + **O(m)** (loop)\\n**Space Complexity: O(mxn)** (dp) + **O(mxn)** (recursion auxiliary space)\\n    \\n# Tabulation : (Bottom-Up Approach)\\n\\n```\\nint minFallingPathSum(vector<vector<int>> &mat)\\n{\\n    int m=mat.size(), n=mat[0].size();\\n    vector<vector<int>> dp(m, vector<int> (n, 0));\\n\\n    for(int j=0; j<n; j++) dp[0][j] = mat[0][j];\\n\\n    for(int i=1; i<m; i++)\\n    {\\n        for(int j=0; j<n; j++)\\n        {\\n            int u = mat[i][j] + dp[i-1][j];\\n            int ld = mat[i][j], rd = mat[i][j];\\n\\n            if(j-1>=0) ld += dp[i-1][j-1];\\n            else ld += 1e8;\\n\\n            if(j+1<n) rd += dp[i-1][j+1];\\n            else rd += 1e8;\\n\\n            dp[i][j] = min(u, min(ld, rd));\\n        }\\n    }\\n\\n    int mini=1e8;\\n    for(int j=0; j<n; j++)\\n        mini = min(mini, dp[m-1][j]);\\n    return mini;\\n}\\n\\n```\\n### Complexity\\n**Time Complexity: O(mxn)** (nested for loop) + **O(m)** (base case loop)\\n**Space Complexity: O(mxn)** (dp)\\n# Space Optimization   \\n```\\nint minFallingPathSum(vector<vector<int>>& mat) \\n{\\n    int r=mat.size(), c=mat[0].size();\\n    vector<int> pre(c, 0), cur(c, 0);\\n    \\n    for(int j=0; j<c; j++) pre[j] = mat[0][j];\\n    \\n    for(int i=1; i<r; i++)\\n    {\\n        for(int j=0; j<c; j++)\\n        {\\n            int u = mat[i][j] + pre[j];\\n            \\n            int ld=mat[i][j], rd=mat[i][j];\\n            \\n            if(j-1>=0) ld += pre[j-1];\\n            else ld += 1e8;\\n            \\n            if(j+1<c) rd += pre[j+1];\\n            else rd += 1e8;\\n                \\n            cur[j] = min(u, min(ld, rd));\\n        }\\n        pre = cur;\\n    }\\n    \\n    int mini = 1e8;\\n    for(int j=0; j<c; j++)\\n        mini = min(mini, pre[j]);\\n    \\n    return mini;    \\n}\\n```\\n### Complexity\\n**Time Complexity: O(mxn)** (nested for loop) + **O(m)** (base case loop)\\n**Space Complexity: O(m)** (pre/cur vector)\\n\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Memoization",
                    "Matrix"
                ],
                "code": "```\\nint f(int i, int j, vector<vector<int>> &mat, vector<vector<int>> &dp)\\n{\\n    if(j<0 || j>=mat[0].size()) return 1e8;\\n    if(i==0) return mat[0][j];\\n    if(dp[i][j] != -1) return dp[i][j];\\n\\n    int u=mat[i][j] + f(i-1, j, mat, dp);\\n    int ld=mat[i][j] + f(i-1, j-1, mat, dp);\\n    int rd=mat[i][j] + f(i-1, j+1, mat, dp);\\n\\n    return dp[i][j] = min(u, min(ld, rd));\\n}\\n\\nint minFallingPathSum(vector<vector<int>> &mat)\\n{\\n    int m=mat.size(), n=mat[0].size();\\n    vector<vector<int>> dp(m, vector<int> (n, -1));\\n    int mini=1e8;\\n    for(int j=0; j<n; j++)\\n        mini = min(mini, f(m-1, j, mat, dp));\\n    return mini;\\n}\\n```\n```\\nint minFallingPathSum(vector<vector<int>> &mat)\\n{\\n    int m=mat.size(), n=mat[0].size();\\n    vector<vector<int>> dp(m, vector<int> (n, 0));\\n\\n    for(int j=0; j<n; j++) dp[0][j] = mat[0][j];\\n\\n    for(int i=1; i<m; i++)\\n    {\\n        for(int j=0; j<n; j++)\\n        {\\n            int u = mat[i][j] + dp[i-1][j];\\n            int ld = mat[i][j], rd = mat[i][j];\\n\\n            if(j-1>=0) ld += dp[i-1][j-1];\\n            else ld += 1e8;\\n\\n            if(j+1<n) rd += dp[i-1][j+1];\\n            else rd += 1e8;\\n\\n            dp[i][j] = min(u, min(ld, rd));\\n        }\\n    }\\n\\n    int mini=1e8;\\n    for(int j=0; j<n; j++)\\n        mini = min(mini, dp[m-1][j]);\\n    return mini;\\n}\\n\\n```\n```\\nint minFallingPathSum(vector<vector<int>>& mat) \\n{\\n    int r=mat.size(), c=mat[0].size();\\n    vector<int> pre(c, 0), cur(c, 0);\\n    \\n    for(int j=0; j<c; j++) pre[j] = mat[0][j];\\n    \\n    for(int i=1; i<r; i++)\\n    {\\n        for(int j=0; j<c; j++)\\n        {\\n            int u = mat[i][j] + pre[j];\\n            \\n            int ld=mat[i][j], rd=mat[i][j];\\n            \\n            if(j-1>=0) ld += pre[j-1];\\n            else ld += 1e8;\\n            \\n            if(j+1<c) rd += pre[j+1];\\n            else rd += 1e8;\\n                \\n            cur[j] = min(u, min(ld, rd));\\n        }\\n        pre = cur;\\n    }\\n    \\n    int mini = 1e8;\\n    for(int j=0; j<c; j++)\\n        mini = min(mini, pre[j]);\\n    \\n    return mini;    \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2906111,
                "title": "c-memoization-space-optimization-explained",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int rec( int i, int j, vector<vector<int>> &mat, vector<vector<int>> &dp ){\\n\\n        // Base Case \\n        if( j<0 || j>=mat.size() ) return 1e5;\\n        if( i == 0 ) return mat[0][j];\\n\\n        // memoization\\n        if( dp[i][j] != -1 ) return dp[i][j] ;\\n\\n        // Explore all the paths \\n        int up = mat[i][j] + rec( i-1, j, mat, dp );\\n        int leftDiag = mat[i][j] + rec( i-1, j-1, mat, dp );\\n        int rightDiag = mat[i][j] + rec( i-1, j+1, mat, dp );\\n\\n        // take the minimum \\n        return dp[i][j] = min( up, min(leftDiag, rightDiag) );\\n    } \\n    \\n    // Top Down Memoization \\n    // T.C -> O(n^3) Exponential, S.C -> O(n) Recursive Stack Space  \\n    int memoization( vector<vector<int>>& mat ) {\\n        \\n        int n = mat.size() ;\\n        vector<vector<int>> dp(n, vector<int>(n,0) );\\n\\n        int mini = 1e5 ;\\n        for( int j=0 ; j<n ; j++ ){\\n\\n            mini = min( mini, rec( n-1, j, mat, dp ) );\\n        }\\n        return mini ;\\n    }\\n    \\n    // Bottom Up Tabulation \\n    // T.C -> O(n*m), S.C -> O(n*m) DP vector \\n    int tabulation( vector<vector<int>>& mat ) {\\n        \\n        int n = mat.size() ;\\n        int mini = 1e5 ;\\n        vector<vector<int>> dp(n, vector<int>(n,0) );\\n        \\n        // Initialize the first row \\n        for( int j=0 ; j<n ; j++ ){\\n            dp[0][j] = mat[0][j] ;\\n        }\\n\\n        for( int i=1 ; i<n ; i++ ){\\n            for( int j=0 ; j<n ; j++ ){\\n\\n                int up = mat[i][j] + dp[i-1][j] ;\\n\\n                int ld = mat[i][j] ;\\n                if( j-1>=0 ) ld += dp[i-1][j-1] ;\\n                else ld = 1e5 ;\\n\\n                int rd = mat[i][j] ;\\n                if( j+1<n ) rd += dp[i-1][j+1] ;\\n                else rd = 1e5 ;\\n\\n                dp[i][j] = min( up, min(ld,rd) );\\n            }\\n        }\\n\\n        // calculate the max \\n        for( int j=0 ; j<n ; j++ ){\\n            mini = min( mini, dp[n-1][j] );\\n        }\\n\\n        return mini ;\\n    }\\n    \\n    // Space Optimization \\n    // T.C -> O(n*m), S.C -> O(2n) Just 2 linear vectors \\n    int minFallingPathSum( vector<vector<int>>& mat ) {\\n\\n        if( mat.size() == 1 && (mat[0][0]<0 || mat[0][0]>=0) ) return mat[0][0] ;\\n        \\n        int n = mat.size() ;\\n        int mini = 1e5 ;\\n        vector<int> curr(n,0), prev(n,0);\\n        \\n        // Initialize the first row \\n        for( int j=0 ; j<n ; j++ ){\\n            prev[j] = mat[0][j] ;\\n        }\\n\\n        for( int i=1 ; i<n ; i++ ){\\n            for( int j=0 ; j<n ; j++ ){\\n\\n                int up = mat[i][j] + prev[j] ;\\n\\n                int ld = mat[i][j] ;\\n                if( j-1>=0 ) ld += prev[j-1] ;\\n                else ld = 1e5 ;\\n\\n                int rd = mat[i][j] ;\\n                if( j+1<n ) rd += prev[j+1] ;\\n                else rd = 1e5 ;\\n\\n                curr[j] = min( up, min(ld,rd) );\\n            }\\n\\n            prev = curr ;\\n        }\\n\\n        // calculate the max \\n        for( int j=0 ; j<n ; j++ ){\\n            mini = min( mini, curr[j] );\\n        }\\n\\n        return mini ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int rec( int i, int j, vector<vector<int>> &mat, vector<vector<int>> &dp ){\\n\\n        // Base Case \\n        if( j<0 || j>=mat.size() ) return 1e5;\\n        if( i == 0 ) return mat[0][j];\\n\\n        // memoization\\n        if( dp[i][j] != -1 ) return dp[i][j] ;\\n\\n        // Explore all the paths \\n        int up = mat[i][j] + rec( i-1, j, mat, dp );\\n        int leftDiag = mat[i][j] + rec( i-1, j-1, mat, dp );\\n        int rightDiag = mat[i][j] + rec( i-1, j+1, mat, dp );\\n\\n        // take the minimum \\n        return dp[i][j] = min( up, min(leftDiag, rightDiag) );\\n    } \\n    \\n    // Top Down Memoization \\n    // T.C -> O(n^3) Exponential, S.C -> O(n) Recursive Stack Space  \\n    int memoization( vector<vector<int>>& mat ) {\\n        \\n        int n = mat.size() ;\\n        vector<vector<int>> dp(n, vector<int>(n,0) );\\n\\n        int mini = 1e5 ;\\n        for( int j=0 ; j<n ; j++ ){\\n\\n            mini = min( mini, rec( n-1, j, mat, dp ) );\\n        }\\n        return mini ;\\n    }\\n    \\n    // Bottom Up Tabulation \\n    // T.C -> O(n*m), S.C -> O(n*m) DP vector \\n    int tabulation( vector<vector<int>>& mat ) {\\n        \\n        int n = mat.size() ;\\n        int mini = 1e5 ;\\n        vector<vector<int>> dp(n, vector<int>(n,0) );\\n        \\n        // Initialize the first row \\n        for( int j=0 ; j<n ; j++ ){\\n            dp[0][j] = mat[0][j] ;\\n        }\\n\\n        for( int i=1 ; i<n ; i++ ){\\n            for( int j=0 ; j<n ; j++ ){\\n\\n                int up = mat[i][j] + dp[i-1][j] ;\\n\\n                int ld = mat[i][j] ;\\n                if( j-1>=0 ) ld += dp[i-1][j-1] ;\\n                else ld = 1e5 ;\\n\\n                int rd = mat[i][j] ;\\n                if( j+1<n ) rd += dp[i-1][j+1] ;\\n                else rd = 1e5 ;\\n\\n                dp[i][j] = min( up, min(ld,rd) );\\n            }\\n        }\\n\\n        // calculate the max \\n        for( int j=0 ; j<n ; j++ ){\\n            mini = min( mini, dp[n-1][j] );\\n        }\\n\\n        return mini ;\\n    }\\n    \\n    // Space Optimization \\n    // T.C -> O(n*m), S.C -> O(2n) Just 2 linear vectors \\n    int minFallingPathSum( vector<vector<int>>& mat ) {\\n\\n        if( mat.size() == 1 && (mat[0][0]<0 || mat[0][0]>=0) ) return mat[0][0] ;\\n        \\n        int n = mat.size() ;\\n        int mini = 1e5 ;\\n        vector<int> curr(n,0), prev(n,0);\\n        \\n        // Initialize the first row \\n        for( int j=0 ; j<n ; j++ ){\\n            prev[j] = mat[0][j] ;\\n        }\\n\\n        for( int i=1 ; i<n ; i++ ){\\n            for( int j=0 ; j<n ; j++ ){\\n\\n                int up = mat[i][j] + prev[j] ;\\n\\n                int ld = mat[i][j] ;\\n                if( j-1>=0 ) ld += prev[j-1] ;\\n                else ld = 1e5 ;\\n\\n                int rd = mat[i][j] ;\\n                if( j+1<n ) rd += prev[j+1] ;\\n                else rd = 1e5 ;\\n\\n                curr[j] = min( up, min(ld,rd) );\\n            }\\n\\n            prev = curr ;\\n        }\\n\\n        // calculate the max \\n        for( int j=0 ; j<n ; j++ ){\\n            mini = min( mini, curr[j] );\\n        }\\n\\n        return mini ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1724482,
                "title": "optimise-optimise-optimise",
                "content": "# Recursion\\nT.C - O(3^N) \\nS.C - O(N)\\n```\\nvar minFallingPathSum = function(matrix) {\\n    let n = matrix.length;\\n    let m = matrix[0].length;\\n    let min = Infinity;\\n    \\n    // base case - when i will be 0, dp[0][j] will be matrix[0][j]\\n    for(let j = 0; j < m; j++) matrix[0][j] = matrix[0][j]\\n    \\n    for(let j = 0 ; j < m; j++) {\\n        min = Math.min(min, compute(n - 1, j, matrix));  \\n    }\\n    return min;\\n};\\n\\nfunction compute(i, j, matrix) {\\n    if(j < 0 || j >= matrix.length) return 10000; // big enough number\\n    \\n    if(i === 0) return matrix[0][j];\\n    \\n    let up = matrix[i][j] + compute(i - 1, j, matrix);\\n    let upLeft = matrix[i][j] + compute(i - 1, j - 1, matrix);\\n    let upRight = matrix[i][j] + compute(i - 1, j + 1, matrix);\\n    \\n    return Math.min(up, upLeft, upRight);\\n}\\n```\\n\\n# Recursion + Dynamic Programming\\nT.C - O(N * M) * M \\nS.C - O(N * M) * M\\n```\\nvar minFallingPathSum = function(matrix) {\\n    let n = matrix.length;\\n    let m = matrix[0].length;\\n    let min = Infinity;\\n    let dp = new Array(n).fill(-1).map(() => new Array(m).fill(-1));\\n    \\n    // base case - when i will be 0, dp[0][j] will be matrix[0][j]\\n    for(let j = 0; j < m; j++) matrix[0][j] = matrix[0][j]\\n    \\n    for(let j = 0 ; j < m; j++) {\\n        min = Math.min(min, compute(n - 1, j, matrix, dp));  \\n    }\\n    \\n    return min;\\n};\\n\\nfunction compute(i, j, matrix, dp) {\\n    if(j < 0 || j >= matrix.length) return 10000; // big enough number\\n    \\n    if(i === 0) return matrix[0][j];\\n    \\n    if(dp[i][j] !== -1) return dp[i][j];\\n    \\n    let up = matrix[i][j] + compute(i - 1, j, matrix, dp);\\n    let upLeft = matrix[i][j] + compute(i - 1, j - 1, matrix, dp);\\n    let upRight = matrix[i][j] + compute(i - 1, j + 1, matrix, dp);\\n    \\n    return dp[i][j] = Math.min(up, upLeft, upRight);\\n}\\n```\\n\\n# Dynamic Programming + Tabulation\\nT.C - O(N * M)\\nS.C - O(N * M)\\n```\\nvar minFallingPathSum = function(matrix) {\\n    let n = matrix.length;\\n    let m = matrix[0].length;\\n    let dp = new Array(n).fill(0).map(() => new Array(m).fill(0));\\n    \\n    // tabulation // bottom-up approach\\n    \\n    // base case - when i will be 0, dp[0][j] will be matrix[0][j]\\n    for(let j = 0; j < m; j++) dp[0][j] = matrix[0][j]\\n    \\n    for(let i = 1; i < n; i++) {\\n        for(let j = 0 ; j < m; j++) {\\n            let up = matrix[i][j] + dp[i - 1][j];\\n            \\n            let upLeft = matrix[i][j];\\n            if((j - 1) >= 0) upLeft += dp[i - 1][j - 1]; // if not out of bound\\n            else upLeft += 10000; // big enough number\\n            \\n            let upRight = matrix[i][j];\\n            if((j + 1) < m) upRight += dp[i - 1][j + 1]; // if not out of bound\\n            else upRight += 10000; // big enough number\\n            \\n            dp[i][j] = Math.min(up, upLeft, upRight);\\n        }\\n    }\\n    return Math.min(...dp[n - 1]);\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/7d4a3179-f9af-4a70-b2ef-3ab241a391e3_1643376563.8287063.png)\\nThis runtime is of above solution\\n\\n\\n# Dynamic Programming + Tabulation (Space optimised)\\n How it is space optimised ?\\n     In this our upleft, upRight and up value only depends on the previous row\\n     Notice we reach next row after previous row right ?\\n     So why not just use previous row to compute next value instead of creating a 2D dpArray\\n```\\nvar minFallingPathSum = function(matrix) {\\n    let n = matrix.length;\\n    let m = matrix[0].length;\\n    let prev = new Array(m).fill(0);\\n    let curr = new Array(m).fill(0);\\n    \\n    // tabulation // bottom-up approach\\n    \\n    // base case - when i will be 0, dp[0][j] will be matrix[0][j]\\n    for(let j = 0; j < m; j++) prev[j] = matrix[0][j]; \\n    \\n    for(let i = 1; i < n; i++) {\\n        for(let j = 0 ; j < m; j++) {\\n            let up = matrix[i][j] + prev[j];\\n            \\n            let upLeft = matrix[i][j];\\n            if((j - 1) >= 0) upLeft += prev[j - 1]; if not out of bound\\n            else upLeft += 10000; // big enough number\\n            \\n            let upRight = matrix[i][j];\\n            if((j + 1) < m) upRight += prev[j + 1]; // if not out of bound\\n            else upRight += 10000; // big enough number\\n            \\n            curr[j] = Math.min(up, upLeft, upRight);\\n        }\\n        prev = curr;\\n    }\\n    return Math.min(...prev);\\n};\\n```\\n\\n# Tabulation\\nT.C - O(N * M)\\nS.C - O(1)\\n```\\nconst minFallingPathSum = function(matrix) {\\n    let m = matrix.length;\\n    let n = matrix[0].length;\\n    \\n    for (let i = 1; i < m; i++) {\\n        for (let j = 0; j < n; j++) {\\n            matrix[i][j] = matrix[i][j] + Math.min(matrix[i - 1][j], matrix[i - 1][j - 1] || 10000, matrix[i - 1][j + 1] || 10000);\\n        }\\n    }\\n    return Math.min(...matrix[m - 1]);\\n};\\n```\\n\\n",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nvar minFallingPathSum = function(matrix) {\\n    let n = matrix.length;\\n    let m = matrix[0].length;\\n    let min = Infinity;\\n    \\n    // base case - when i will be 0, dp[0][j] will be matrix[0][j]\\n    for(let j = 0; j < m; j++) matrix[0][j] = matrix[0][j]\\n    \\n    for(let j = 0 ; j < m; j++) {\\n        min = Math.min(min, compute(n - 1, j, matrix));  \\n    }\\n    return min;\\n};\\n\\nfunction compute(i, j, matrix) {\\n    if(j < 0 || j >= matrix.length) return 10000; // big enough number\\n    \\n    if(i === 0) return matrix[0][j];\\n    \\n    let up = matrix[i][j] + compute(i - 1, j, matrix);\\n    let upLeft = matrix[i][j] + compute(i - 1, j - 1, matrix);\\n    let upRight = matrix[i][j] + compute(i - 1, j + 1, matrix);\\n    \\n    return Math.min(up, upLeft, upRight);\\n}\\n```\n```\\nvar minFallingPathSum = function(matrix) {\\n    let n = matrix.length;\\n    let m = matrix[0].length;\\n    let min = Infinity;\\n    let dp = new Array(n).fill(-1).map(() => new Array(m).fill(-1));\\n    \\n    // base case - when i will be 0, dp[0][j] will be matrix[0][j]\\n    for(let j = 0; j < m; j++) matrix[0][j] = matrix[0][j]\\n    \\n    for(let j = 0 ; j < m; j++) {\\n        min = Math.min(min, compute(n - 1, j, matrix, dp));  \\n    }\\n    \\n    return min;\\n};\\n\\nfunction compute(i, j, matrix, dp) {\\n    if(j < 0 || j >= matrix.length) return 10000; // big enough number\\n    \\n    if(i === 0) return matrix[0][j];\\n    \\n    if(dp[i][j] !== -1) return dp[i][j];\\n    \\n    let up = matrix[i][j] + compute(i - 1, j, matrix, dp);\\n    let upLeft = matrix[i][j] + compute(i - 1, j - 1, matrix, dp);\\n    let upRight = matrix[i][j] + compute(i - 1, j + 1, matrix, dp);\\n    \\n    return dp[i][j] = Math.min(up, upLeft, upRight);\\n}\\n```\n```\\nvar minFallingPathSum = function(matrix) {\\n    let n = matrix.length;\\n    let m = matrix[0].length;\\n    let dp = new Array(n).fill(0).map(() => new Array(m).fill(0));\\n    \\n    // tabulation // bottom-up approach\\n    \\n    // base case - when i will be 0, dp[0][j] will be matrix[0][j]\\n    for(let j = 0; j < m; j++) dp[0][j] = matrix[0][j]\\n    \\n    for(let i = 1; i < n; i++) {\\n        for(let j = 0 ; j < m; j++) {\\n            let up = matrix[i][j] + dp[i - 1][j];\\n            \\n            let upLeft = matrix[i][j];\\n            if((j - 1) >= 0) upLeft += dp[i - 1][j - 1]; // if not out of bound\\n            else upLeft += 10000; // big enough number\\n            \\n            let upRight = matrix[i][j];\\n            if((j + 1) < m) upRight += dp[i - 1][j + 1]; // if not out of bound\\n            else upRight += 10000; // big enough number\\n            \\n            dp[i][j] = Math.min(up, upLeft, upRight);\\n        }\\n    }\\n    return Math.min(...dp[n - 1]);\\n};\\n```\n```\\nvar minFallingPathSum = function(matrix) {\\n    let n = matrix.length;\\n    let m = matrix[0].length;\\n    let prev = new Array(m).fill(0);\\n    let curr = new Array(m).fill(0);\\n    \\n    // tabulation // bottom-up approach\\n    \\n    // base case - when i will be 0, dp[0][j] will be matrix[0][j]\\n    for(let j = 0; j < m; j++) prev[j] = matrix[0][j]; \\n    \\n    for(let i = 1; i < n; i++) {\\n        for(let j = 0 ; j < m; j++) {\\n            let up = matrix[i][j] + prev[j];\\n            \\n            let upLeft = matrix[i][j];\\n            if((j - 1) >= 0) upLeft += prev[j - 1]; if not out of bound\\n            else upLeft += 10000; // big enough number\\n            \\n            let upRight = matrix[i][j];\\n            if((j + 1) < m) upRight += prev[j + 1]; // if not out of bound\\n            else upRight += 10000; // big enough number\\n            \\n            curr[j] = Math.min(up, upLeft, upRight);\\n        }\\n        prev = curr;\\n    }\\n    return Math.min(...prev);\\n};\\n```\n```\\nconst minFallingPathSum = function(matrix) {\\n    let m = matrix.length;\\n    let n = matrix[0].length;\\n    \\n    for (let i = 1; i < m; i++) {\\n        for (let j = 0; j < n; j++) {\\n            matrix[i][j] = matrix[i][j] + Math.min(matrix[i - 1][j], matrix[i - 1][j - 1] || 10000, matrix[i - 1][j + 1] || 10000);\\n        }\\n    }\\n    return Math.min(...matrix[m - 1]);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3376335,
                "title": "c-easy-solution-dfs-and-dp",
                "content": "# Intuition\\nFrom one cell we can move to three cells. We can use DFS to traverse the successors of a cell. But here we do have some repetations. We need to avoid repetation using DP.\\n\\n# Approach\\nWe need to apply DFS and store the value in a dp table. Calculate for every column in row 1 and return the minimum.\\n\\nThe terminating cases are:\\n\\nrow>=n returns 0 as it is end.\\ncol>=n || col<0 returns INT_MAX as we cannot go outside the matrix.\\n\\nDFS:\\n\\nFor each cell calculate minimum sum path ({row+1,col-1},{row+1,col},{row+1,col+1}) and add the current cell value.\\n\\n# Complexity\\n- Time complexity:\\nO(N^2)\\n\\n- Space complexity:\\nO(N^2)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint dfs(vector<vector<int>>&matrix,int row,int col,vector<vector<int>>&dp,int n){\\n    if(row>=n){\\n        return 0;\\n    }\\n    if(col>=n || col<0){\\n        return INT_MAX;\\n    }\\n    if(dp[row][col] != -1){\\n        return dp[row][col];\\n    }\\n    return dp[row][col] = matrix[row][col]+min({dfs(matrix,row+1,col-1,dp,n),dfs(matrix,row+1,col,dp,n),dfs(matrix,row+1,col+1,dp,n)});\\n}\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        int ans = INT_MAX;\\n        vector<vector<int>>dp(n,vector<int>(n,-1));\\n        for(int i = 0;i<n;i++){\\n            ans = min(ans,dfs(matrix,0,i,dp,n));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint dfs(vector<vector<int>>&matrix,int row,int col,vector<vector<int>>&dp,int n){\\n    if(row>=n){\\n        return 0;\\n    }\\n    if(col>=n || col<0){\\n        return INT_MAX;\\n    }\\n    if(dp[row][col] != -1){\\n        return dp[row][col];\\n    }\\n    return dp[row][col] = matrix[row][col]+min({dfs(matrix,row+1,col-1,dp,n),dfs(matrix,row+1,col,dp,n),dfs(matrix,row+1,col+1,dp,n)});\\n}\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        int ans = INT_MAX;\\n        vector<vector<int>>dp(n,vector<int>(n,-1));\\n        for(int i = 0;i<n;i++){\\n            ans = min(ans,dfs(matrix,0,i,dp,n));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2908134,
                "title": "c-just-do-as-question-says",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nJust did what was asked in the question and return the minimum of all the possibilites, that is, *minimum of all the path sum obtained after considering every element in first row*\\n# Complexity\\n- Time complexity: $$O(r*c*c)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(r*c)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int helper (vector<vector<int>>&matrix, int i, int j, vector<vector<int>>&dp){\\n        if (j < 0 || j >= matrix[0].size ())\\n            return INT_MAX;\\n        \\n        if (i == matrix.size()-1)\\n            \\n            return matrix[i][j];\\n        \\n        if (dp[i][j] != -1)\\n            return dp[i][j];\\n        \\n        int ans1 = helper (matrix,i+1,j,dp);\\n        int ans2 = helper (matrix,i+1,j+1,dp);\\n        int ans3 = helper (matrix,i+1,j-1,dp);\\n        \\n        return dp[i][j] = matrix[i][j] + min (ans1,min(ans2,ans3));\\n    }\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int res = INT_MAX;\\n        vector<vector<int>> dp (matrix.size(), vector<int>(matrix[0].size(),-1));\\n        \\n        for (int i = 0; i < matrix[0].size(); i++){\\n            res= min (res,helper (matrix,0,i,dp));\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int helper (vector<vector<int>>&matrix, int i, int j, vector<vector<int>>&dp){\\n        if (j < 0 || j >= matrix[0].size ())\\n            return INT_MAX;\\n        \\n        if (i == matrix.size()-1)\\n            \\n            return matrix[i][j];\\n        \\n        if (dp[i][j] != -1)\\n            return dp[i][j];\\n        \\n        int ans1 = helper (matrix,i+1,j,dp);\\n        int ans2 = helper (matrix,i+1,j+1,dp);\\n        int ans3 = helper (matrix,i+1,j-1,dp);\\n        \\n        return dp[i][j] = matrix[i][j] + min (ans1,min(ans2,ans3));\\n    }\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int res = INT_MAX;\\n        vector<vector<int>> dp (matrix.size(), vector<int>(matrix[0].size(),-1));\\n        \\n        for (int i = 0; i < matrix[0].size(); i++){\\n            res= min (res,helper (matrix,0,i,dp));\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2907009,
                "title": "dp-with-memoization",
                "content": "I am not proud of this code, but it works. DP with Memoization:\\n```csharp\\npublic class Solution\\n{\\n    public int MinFallingPathSum(int[][] m)\\n    {\\n        Dictionary<(int, int), int> memo = new();\\n        return m[0].Select((x, i) => dp(0, i)).Min();\\n\\n        int dp(int i, int j, int sum = 0) =>\\n            memo.ContainsKey((i, j)) ? memo[(i, j)]\\n            : i == m.Length ? sum\\n            : j < 0 || j == m[0].Length ? 1_000_000\\n            : memo[(i, j)] = m[i][j]\\n                + Math.Min(\\n                    dp(i + 1, j, sum),\\n                    Math.Min(\\n                        dp(i + 1, j - 1, sum),\\n                        dp(i + 1, j + 1, sum)\\n                    )\\n                );\\n    } \\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Memoization"
                ],
                "code": "```csharp\\npublic class Solution\\n{\\n    public int MinFallingPathSum(int[][] m)\\n    {\\n        Dictionary<(int, int), int> memo = new();\\n        return m[0].Select((x, i) => dp(0, i)).Min();\\n\\n        int dp(int i, int j, int sum = 0) =>\\n            memo.ContainsKey((i, j)) ? memo[(i, j)]\\n            : i == m.Length ? sum\\n            : j < 0 || j == m[0].Length ? 1_000_000\\n            : memo[(i, j)] = m[i][j]\\n                + Math.Min(\\n                    dp(i + 1, j, sum),\\n                    Math.Min(\\n                        dp(i + 1, j - 1, sum),\\n                        dp(i + 1, j + 1, sum)\\n                    )\\n                );\\n    } \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2905875,
                "title": "python-dp-solution-6-lines",
                "content": "### Code\\n```\\nclass Solution:\\n    def minFallingPathSum(self, A: List[List[int]]) -> int:\\n        for i in range(1,len(A)):\\n            for j in range(1,len(A[0])-1):\\n                A[i][j] = A[i][j] + min(A[i-1][j-1], A[i-1][j], A[i-1][j+1])\\n            \\n            A[i][0] = A[i][0] + min(A[i-1][0], A[i-1][1])\\n            A[i][-1] = A[i][-1] + min(A[i-1][-2], A[i-1][-1])\\n            \\n        return min(A[-1])\\n\\n```\\n\\n### Explanation\\nIterate from 2nd row to the end of the matrix.\\nFor each element add the minimum adjacent element in the row above it.\\nSeperate the edge cases when we are at the start of the row (since we can\\'t have an element above diagonally left) and end of the row (since we can\\'t have an element diagonally above and to the right)\\n\\n![931.gif](https://assets.leetcode.com/users/images/631bc451-b3e6-4a45-bb9e-fc662ff11466_1670899992.149613.gif){:style=\\'width:200px\\'}\\n\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minFallingPathSum(self, A: List[List[int]]) -> int:\\n        for i in range(1,len(A)):\\n            for j in range(1,len(A[0])-1):\\n                A[i][j] = A[i][j] + min(A[i-1][j-1], A[i-1][j], A[i-1][j+1])\\n            \\n            A[i][0] = A[i][0] + min(A[i-1][0], A[i-1][1])\\n            A[i][-1] = A[i][-1] + min(A[i-1][-2], A[i-1][-1])\\n            \\n        return min(A[-1])\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2403722,
                "title": "c-recursion-memoization-tabulation-space-optimization",
                "content": "The problem states that the starting point can be any cell from the first row and the ending point can be any cell in the last row. So, first let\\'s try out all the possible paths using recursion.\\n##### ***Recursive solution:***\\n***Step 1: Define the function and write Base cases.***\\n* We can define the function with two parameters i and j, where i and j represent the row and column of the matrix. `f(i, j)` -> Minimum path sum from any cell in the first row to the `cell[i][j]`.\\n* We will be doing a top-down recursion as there are multiple start points and multiple end points. So, lets start our recursion from the last row towards the first row. For the last row,` (i == N - 1)` there are multiple start points so we try out all the starting points i.e., `f(N-1,0), f(N-1,1) \\u2026\\u2026. f(N-1, M-1)`. and go upwards to the first `(i == 0)`.\\n**Base Case :**\\n* When `(i == 0)`, it means we are at the first row, we `return mat[0][j]`.\\n* At every cell we have three options (we are writing recursion from the last row to the first row): to the top cell (\\u2191), to the top-right cell(\\u2197), or to the top-left cell(\\u2196). When we go up we `return mat[i][j`] when `(i == 0)`. When we top-left cell(\\u2196)  and if we go out of the bound i.e., `j < 0` we `return 1e9` or when we go top-right cell(\\u2197) and if we go out of the bound i.e., `j > m-1` we return `1e9`.\\n\\n***Step 2: Try out all possible choices at a given index.***\\n* `top = cell[i][j] + f(cell[i-1][j])` when we move to the top cell (\\u2191).\\n* `top_left = cell[i][j] + f(cell[i-1][j-1]`) when we move to the top-left cell(\\u2196).\\n* `top_right = cell[i][j] + f(cell[i-1][j+1])` when we move to the top-right cell(\\u2197).\\n\\n***Step 3:  Take the minimum of all choices***\\n* we will return the minimum of all the choices (top, top_left, Top_right) \\n\\n***\\u274C CODE for Recursive function : | T.C \\u2013 O(3^N) | S.C \\u2013 O(N) Stack Space***\\n```\\nclass Solution {\\npublic:\\n    int solve(vector<vector<int>> &mat, int i, int j, int n) {\\n        if (j < 0 || j >= n) return 1e9; // Base Case 1: out of bound\\n        if (i == 0) return mat[i][j]; // Base Case 2: end point - 0th row\\n        int top = mat[i][j] + solve(mat, i - 1, j, n);\\n        int top_left = mat[i][j] + solve(mat, i - 1, j - 1, n);\\n        int top_right = mat[i][j] + solve(mat, i - 1, j + 1, n);\\n        return min(top, min(top_left, top_right));\\n    }\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        int min_path_sum = 1e9;\\n        for (int j = 0; j < n; j++) {\\n            min_path_sum = min(min_path_sum, solve(matrix, n - 1, j, n));\\n        }\\n        return min_path_sum;\\n    }\\n};\\n```\\n**It will give TLE. So, we will Optimize it further. As we can see there are multiple overlapping sub-problems so we will store the answer of current state in an array and use it to prevent same computation everytime.**\\n\\n##### ***Memoization***\\n* Create a dp array of size [N][N] an initialize it with -1.\\n\\u2022\\t`if(dp[i][j]!=-1) return dp[i][j]` else use the recursive relation as usual but before returning from the function, we will set dp[i][j] to the solution we get.\\n\\n***\\u2705 CODE: | T.C \\u2013 O(N^2) | S.C \\u2013 O(N^2) + O(N)-Stack Space***\\n```\\nclass Solution {\\npublic:\\n    int solve(vector<vector<int>> &mat, int i, int j, int m, vector<vector<int>> &dp) {\\n        if (j < 0 || j >= m) return 1e9; // out of bound\\n        if (i == 0) return mat[i][j]; // end point - 0th row\\n        if (dp[i][j] != -1) return dp[i][j]; // Memoization\\n        int top = mat[i][j] + solve(mat, i - 1, j, m, dp);\\n        int top_left = mat[i][j] + solve(mat, i - 1, j - 1, m, dp);\\n        int top_right = mat[i][j] + solve(mat, i - 1, j + 1, m, dp);\\n        return dp[i][j] = min(top, min(top_left, top_right));\\n    }\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        vector<vector<int>> dp(n, vector<int>(m, -1));\\n        int min_path_sum = 1e9;\\n        for (int j = 0; j < m; j++) {\\n            min_path_sum = min(min_path_sum, solve(matrix, n - 1, j, m, dp));\\n        }\\n        return min_path_sum;\\n    }\\n};\\n```\\n\\n##### ***Converting Memoization to Tabulation:***\\n* Declare a dp[] array of size [N][M]. And write the base condition values, i.e., the first row of the dp[][] to the first row of the input matrix.\\n* We want to move from the first row to the last row. if we see the memoized code, values required for `dp[i][j]` are: `dp[i-1][j], dp[i-1][j-1]` and `dp[i-1][j+1]`. So, we only need the values from the \\u2018i-1\\u2019 row. As we have already filled the first row (i=0), if we start from row \\u20181\\u2019 and move downwards we will find the values correctly.\\n* We can use two nested loops to have this traversal and at last we need to return the maximum among the last row of dp array as our answer.\\n\\n***\\u2705 CODE  | T.C \\u2013 O(N^2) | S.C \\u2013 O(N^2)***\\n```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& mat) {\\n        int n = mat.size(); // rows\\n        vector<vector<int>> dp(n, vector<int>(n, 0));\\n        int min_path_sum = 1e9;\\n        for (int j = 0; j < n; j++) // Base Case : (i == 0) precompute 1st row\\n            dp[0][j] = mat[0][j];\\n\\n        for (int i = 1; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                int down = mat[i][j] +  dp[i - 1][j];\\n                int right_diagonal = 1e9, left_diagonal = 1e9;\\n                // Check for Base condition : out of bounds\\n                if (j - 1 >= 0) left_diagonal = mat[i][j] + dp[i - 1][j - 1];\\n                if (j + 1 < n) right_diagonal = mat[i][j] +  dp[i - 1][j + 1];\\n                dp[i][j] = min(down, min(left_diagonal, right_diagonal));\\n            }\\n        }\\n        // Our answer will be the minimum of all path sum in last row\\n        for (int j = 0; j < n; j++) min_path_sum = min(min_path_sum, dp[n - 1][j]);\\n        return min_path_sum;\\n    }\\n};\\n```\\n\\n##### ***Space Optimization -->  (Best Solution)***\\n* if we closely look the relation, `dp[i][j] = matrix[i][j] + max(dp[i-1][j],dp[i-1][j-1], dp[i-1][j+1]`)). Which means we only need the previous row, to calculate `dp[i][j]`. so, we can space optimize it.\\n* Initially we can take a dummy array (say `prev`). We initialize this to the matrix first row (as done in tabulation).\\n* Now the current row only needs the `prev` row\\u2019s value in order to calculate `dp[i][j]`. we can store current row path sum in same input Matrix to optimize space.\\n* At last, we return the maximum value among all the values of the `prev` to get our answer.\\n\\n***\\u2705 CODE | T.C - O(N^2) | S.C - O(N)***\\n```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& mat) {\\n        int n = mat.size(); // rows & cols\\n        vector<int>prev;\\n        int min_path_sum = 1e9;\\n        for (int j = 0; j < n; j++) //  (i == 0) precompute 1st row\\n            prev.push_back(mat[0][j]);\\n\\n        for (int i = 1; i < n; i++) { // Now, start from 2nd row\\n            for (int j = 0; j < n; j++) {\\n                int down = mat[i][j] +  prev[j]; // go down\\n                int right_diagonal = 1e9, left_diagonal = 1e9;\\n                if (j - 1 >= 0) left_diagonal = mat[i][j] + prev[j - 1];\\n                if (j + 1 < n) right_diagonal = mat[i][j] +  prev[j + 1];\\n                // Here we can store curr row path sum in matrix itself\\n                mat[i][j] = min(down, min(left_diagonal, right_diagonal));\\n            }\\n            prev = mat[i];\\n        }\\n        // Our answer will be the minimum of all path sum in last row\\n        for (int j = 0; j < n; j++) min_path_sum = min(min_path_sum, prev[j]);\\n        return min_path_sum;\\n    }\\n};\\n```\\n**Runtime: 17 ms, faster than 80.44% of C++ online submissions for Minimum Falling Path Sum.\\nMemory Usage: 9.9 MB, less than 83.83% of C++ online submissions for Minimum Falling Path Sum.**\\n\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(vector<vector<int>> &mat, int i, int j, int n) {\\n        if (j < 0 || j >= n) return 1e9; // Base Case 1: out of bound\\n        if (i == 0) return mat[i][j]; // Base Case 2: end point - 0th row\\n        int top = mat[i][j] + solve(mat, i - 1, j, n);\\n        int top_left = mat[i][j] + solve(mat, i - 1, j - 1, n);\\n        int top_right = mat[i][j] + solve(mat, i - 1, j + 1, n);\\n        return min(top, min(top_left, top_right));\\n    }\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        int min_path_sum = 1e9;\\n        for (int j = 0; j < n; j++) {\\n            min_path_sum = min(min_path_sum, solve(matrix, n - 1, j, n));\\n        }\\n        return min_path_sum;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int solve(vector<vector<int>> &mat, int i, int j, int m, vector<vector<int>> &dp) {\\n        if (j < 0 || j >= m) return 1e9; // out of bound\\n        if (i == 0) return mat[i][j]; // end point - 0th row\\n        if (dp[i][j] != -1) return dp[i][j]; // Memoization\\n        int top = mat[i][j] + solve(mat, i - 1, j, m, dp);\\n        int top_left = mat[i][j] + solve(mat, i - 1, j - 1, m, dp);\\n        int top_right = mat[i][j] + solve(mat, i - 1, j + 1, m, dp);\\n        return dp[i][j] = min(top, min(top_left, top_right));\\n    }\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        vector<vector<int>> dp(n, vector<int>(m, -1));\\n        int min_path_sum = 1e9;\\n        for (int j = 0; j < m; j++) {\\n            min_path_sum = min(min_path_sum, solve(matrix, n - 1, j, m, dp));\\n        }\\n        return min_path_sum;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& mat) {\\n        int n = mat.size(); // rows\\n        vector<vector<int>> dp(n, vector<int>(n, 0));\\n        int min_path_sum = 1e9;\\n        for (int j = 0; j < n; j++) // Base Case : (i == 0) precompute 1st row\\n            dp[0][j] = mat[0][j];\\n\\n        for (int i = 1; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                int down = mat[i][j] +  dp[i - 1][j];\\n                int right_diagonal = 1e9, left_diagonal = 1e9;\\n                // Check for Base condition : out of bounds\\n                if (j - 1 >= 0) left_diagonal = mat[i][j] + dp[i - 1][j - 1];\\n                if (j + 1 < n) right_diagonal = mat[i][j] +  dp[i - 1][j + 1];\\n                dp[i][j] = min(down, min(left_diagonal, right_diagonal));\\n            }\\n        }\\n        // Our answer will be the minimum of all path sum in last row\\n        for (int j = 0; j < n; j++) min_path_sum = min(min_path_sum, dp[n - 1][j]);\\n        return min_path_sum;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& mat) {\\n        int n = mat.size(); // rows & cols\\n        vector<int>prev;\\n        int min_path_sum = 1e9;\\n        for (int j = 0; j < n; j++) //  (i == 0) precompute 1st row\\n            prev.push_back(mat[0][j]);\\n\\n        for (int i = 1; i < n; i++) { // Now, start from 2nd row\\n            for (int j = 0; j < n; j++) {\\n                int down = mat[i][j] +  prev[j]; // go down\\n                int right_diagonal = 1e9, left_diagonal = 1e9;\\n                if (j - 1 >= 0) left_diagonal = mat[i][j] + prev[j - 1];\\n                if (j + 1 < n) right_diagonal = mat[i][j] +  prev[j + 1];\\n                // Here we can store curr row path sum in matrix itself\\n                mat[i][j] = min(down, min(left_diagonal, right_diagonal));\\n            }\\n            prev = mat[i];\\n        }\\n        // Our answer will be the minimum of all path sum in last row\\n        for (int j = 0; j < n; j++) min_path_sum = min(min_path_sum, prev[j]);\\n        return min_path_sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2005104,
                "title": "java-4-solutions-simple-easy-clean-code",
                "content": "```\\nBELOW ARE THE  POSSIBLE SOLUTIONS\\n```\\n_Comment if anything is wrong!_\\n\\n-------------------------------------\\n__1. NAIVE SOLUTION__\\n```\\n`NAIVE SOLUTION WITH WORST TIME COMPLEXITY[EXPONENTIAL]`\\nclass Solution {\\n    public int minFallingPathSum(int[][] matrix) {\\n        \\n        int m = matrix.length, n = matrix[0].length;\\n        int result = Integer.MAX_VALUE;\\n        \\n        for(int i = 0; i < n; i++)\\n            result = Math.min(result, solve(m - 1, i, matrix, dp));\\n        \\n        return result;\\n    }\\n    \\n    private int solve(int m, int n, int[][] matrix, int[][] dp){\\n        \\n        if(n < 0 || n >= matrix[m].length) return Integer.MAX_VALUE;\\n        \\n        if(m == 0) return matrix[0][n];\\n    \\n        int up = solve(m - 1, n, matrix, dp);\\n        int left = solve(m - 1, n - 1, matrix, dp);\\n        int right = solve(m - 1, n + 1, matrix, dp);\\n        \\n        return Math.min(Math.min(left, right), up) + matrix[m][n];\\n        \\n    }   \\n}\\n```\\n__2. MEMOIZED SOLUTION__\\n```\\nclass Solution {\\n    public int minFallingPathSum(int[][] matrix) {\\n        \\n        int m = matrix.length, n = matrix[0].length;\\n        int result = Integer.MAX_VALUE;\\n        \\n        int[][] dp = new int[m][n];\\n        for(int[] row : dp) Arrays.fill(row, Integer.MAX_VALUE);\\n        \\n        for(int i = 0; i < n; i++)\\n            result = Math.min(result, solve(m - 1, i, matrix, dp));\\n        \\n        return result;\\n    }\\n    \\n    private int solve(int m, int n, int[][] matrix, int[][] dp){\\n        \\n        if(n < 0 || n >= matrix[m].length) return Integer.MAX_VALUE;\\n        \\n        if(m == 0) return dp[m][n] = matrix[0][n];\\n        \\n        if(dp[m][n] != Integer.MAX_VALUE) return dp[m][n];\\n        \\n        int up = solve(m - 1, n, matrix, dp);\\n        int left = solve(m - 1, n - 1, matrix, dp);\\n        int right = solve(m - 1, n + 1, matrix, dp);\\n        \\n        return dp[m][n] = Math.min(Math.min(left, right), up) + matrix[m][n];\\n        \\n    }\\n}\\n```\\n__3.TABULATION__\\n```\\nclass Solution {\\n    public int minFallingPathSum(int[][] matrix) {\\n        int m = matrix.length, n = matrix[0].length;\\n        int result = Integer.MAX_VALUE;\\n        \\n        int[][] dp = new int[m][n];\\n        \\n        //BASE CASE\\n        for(int i = 0; i < n; i++) dp[0][i] = matrix[0][i];\\n        \\n        for(int i = 1; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                int up = matrix[i][j] + dp[i - 1][j], left = matrix[i][j], right = matrix[i][j];\\n                \\n                if(j> 0) left += dp[i - 1][j - 1];\\n                else left = (int)Math.pow(10,9);\\n                \\n                if(j < n - 1) right += dp[i - 1][j + 1];\\n                else right = (int)Math.pow(10,9);\\n                \\n                dp[i][j] = Math.min(up, Math.min(left, right));\\n                \\n                // result = Math.min(result, dp[i][j]);\\n            }\\n        }\\n        \\n        for(int i = 0; i < n; i++)\\n            result = Math.min(result, dp[m - 1][i]);\\n        \\n        return result;\\n    }\\n}\\n```\\n__4. SPACE OPTIMIZED TABULATION__\\n```\\nclass Solution {\\n    public int minFallingPathSum(int[][] matrix) {\\n        int m = matrix.length, n = matrix[0].length;\\n        int result = Integer.MAX_VALUE;\\n        \\n        int[] dp = new int[n];\\n        \\n        //BASE CASE\\n        for(int i = 0; i < n; i++) dp[i] = matrix[0][i];\\n        \\n        \\n        for(int i = 1; i < m; i++){\\n            int[] temp = new int[n];\\n            for(int j = 0; j < n; j++){\\n                int up = matrix[i][j] + dp[j], left = matrix[i][j], right = matrix[i][j];\\n                \\n                if(j > 0) left += dp[j - 1];\\n                else left = (int)Math.pow(10,9);\\n                \\n                if(j < n - 1) right += dp[j + 1];\\n                else right = (int)Math.pow(10,9);\\n                \\n                temp[j] = Math.min(up, Math.min(left, right));\\n                \\n            }\\n            dp = temp;\\n        }\\n        \\n        for(int i = 0; i < n; i++)\\n            result = Math.min(result, dp[i]);\\n        \\n        return result;\\n    }\\n}\\n```\\n\\n__UPVOTE WOULBE APPRECIATED \\uD83D\\uDE4F\\uD83C\\uDFFB \\uD83D\\uDD25__\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nBELOW ARE THE  POSSIBLE SOLUTIONS\\n```\n```\\n`NAIVE SOLUTION WITH WORST TIME COMPLEXITY[EXPONENTIAL]`\\nclass Solution {\\n    public int minFallingPathSum(int[][] matrix) {\\n        \\n        int m = matrix.length, n = matrix[0].length;\\n        int result = Integer.MAX_VALUE;\\n        \\n        for(int i = 0; i < n; i++)\\n            result = Math.min(result, solve(m - 1, i, matrix, dp));\\n        \\n        return result;\\n    }\\n    \\n    private int solve(int m, int n, int[][] matrix, int[][] dp){\\n        \\n        if(n < 0 || n >= matrix[m].length) return Integer.MAX_VALUE;\\n        \\n        if(m == 0) return matrix[0][n];\\n    \\n        int up = solve(m - 1, n, matrix, dp);\\n        int left = solve(m - 1, n - 1, matrix, dp);\\n        int right = solve(m - 1, n + 1, matrix, dp);\\n        \\n        return Math.min(Math.min(left, right), up) + matrix[m][n];\\n        \\n    }   \\n}\\n```\n```\\nclass Solution {\\n    public int minFallingPathSum(int[][] matrix) {\\n        \\n        int m = matrix.length, n = matrix[0].length;\\n        int result = Integer.MAX_VALUE;\\n        \\n        int[][] dp = new int[m][n];\\n        for(int[] row : dp) Arrays.fill(row, Integer.MAX_VALUE);\\n        \\n        for(int i = 0; i < n; i++)\\n            result = Math.min(result, solve(m - 1, i, matrix, dp));\\n        \\n        return result;\\n    }\\n    \\n    private int solve(int m, int n, int[][] matrix, int[][] dp){\\n        \\n        if(n < 0 || n >= matrix[m].length) return Integer.MAX_VALUE;\\n        \\n        if(m == 0) return dp[m][n] = matrix[0][n];\\n        \\n        if(dp[m][n] != Integer.MAX_VALUE) return dp[m][n];\\n        \\n        int up = solve(m - 1, n, matrix, dp);\\n        int left = solve(m - 1, n - 1, matrix, dp);\\n        int right = solve(m - 1, n + 1, matrix, dp);\\n        \\n        return dp[m][n] = Math.min(Math.min(left, right), up) + matrix[m][n];\\n        \\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minFallingPathSum(int[][] matrix) {\\n        int m = matrix.length, n = matrix[0].length;\\n        int result = Integer.MAX_VALUE;\\n        \\n        int[][] dp = new int[m][n];\\n        \\n        //BASE CASE\\n        for(int i = 0; i < n; i++) dp[0][i] = matrix[0][i];\\n        \\n        for(int i = 1; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                int up = matrix[i][j] + dp[i - 1][j], left = matrix[i][j], right = matrix[i][j];\\n                \\n                if(j> 0) left += dp[i - 1][j - 1];\\n                else left = (int)Math.pow(10,9);\\n                \\n                if(j < n - 1) right += dp[i - 1][j + 1];\\n                else right = (int)Math.pow(10,9);\\n                \\n                dp[i][j] = Math.min(up, Math.min(left, right));\\n                \\n                // result = Math.min(result, dp[i][j]);\\n            }\\n        }\\n        \\n        for(int i = 0; i < n; i++)\\n            result = Math.min(result, dp[m - 1][i]);\\n        \\n        return result;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minFallingPathSum(int[][] matrix) {\\n        int m = matrix.length, n = matrix[0].length;\\n        int result = Integer.MAX_VALUE;\\n        \\n        int[] dp = new int[n];\\n        \\n        //BASE CASE\\n        for(int i = 0; i < n; i++) dp[i] = matrix[0][i];\\n        \\n        \\n        for(int i = 1; i < m; i++){\\n            int[] temp = new int[n];\\n            for(int j = 0; j < n; j++){\\n                int up = matrix[i][j] + dp[j], left = matrix[i][j], right = matrix[i][j];\\n                \\n                if(j > 0) left += dp[j - 1];\\n                else left = (int)Math.pow(10,9);\\n                \\n                if(j < n - 1) right += dp[j + 1];\\n                else right = (int)Math.pow(10,9);\\n                \\n                temp[j] = Math.min(up, Math.min(left, right));\\n                \\n            }\\n            dp = temp;\\n        }\\n        \\n        for(int i = 0; i < n; i++)\\n            result = Math.min(result, dp[i]);\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1931580,
                "title": "recursion-memoization-tabulation-optimization",
                "content": "**Recursion:**\\nTC: O(3^M) where M is no. of rows\\nSC: O(M) where M is no. of rows\\n\\n```\\nclass Solution {\\n    public int minFallingPathSum(int[][] a) {\\n        int min = Integer.MAX_VALUE;\\n        int m = a.length;\\n        int n = a[0].length;\\n        \\n        for(int j = 0; j<n; j++){\\n            int temp = help(m-1,j,a);\\n            min = Math.min(min,temp);\\n        }\\n        return min;\\n    }\\n    public int help(int i, int j, int[][] a){\\n        \\n        if(i<0 || j<0 || j>a[0].length-1) return (int)Math.pow(10,9);\\n        if(i==0) return a[i][j];\\n        \\n        int left = a[i][j] + help(i-1,j-1,a);\\n        int up = a[i][j] + help(i-1,j,a);\\n        int right = a[i][j] + help(i-1,j+1,a);\\n        \\n        return Math.min(left,Math.min(up,right));\\n    }\\n}\\n```\\n\\n\\n\\n**Memoization:**\\nTC: O(M x N) \\nSC: O(M) + O(M xN) \\n\\n```\\nclass Solution {\\n    public int minFallingPathSum(int[][] a) {\\n        int min = Integer.MAX_VALUE;\\n        int m = a.length;\\n        int n = a[0].length;\\n        int[][] dp=new int[m][n];\\n        for(int[] row: dp) Arrays.fill(row,-1);\\n        for(int j = 0; j<n; j++){\\n            int temp = help(m-1,j,a,dp);\\n            min = Math.min(min,temp);\\n        }\\n        return min;\\n    }\\n    public int help(int i, int j, int[][] a,int[][] dp){\\n        \\n        if(i<0 || j<0 || j>a[0].length-1) return (int)Math.pow(10,9);\\n        if(i==0) return a[i][j];\\n        if(dp[i][j] != -1) return dp[i][j];\\n        int left = a[i][j] + help(i-1,j-1,a,dp);\\n        int up = a[i][j] + help(i-1,j,a,dp);\\n        int right = a[i][j] + help(i-1,j+1,a,dp);\\n        \\n        return dp[i][j] = Math.min(left,Math.min(up,right));\\n    }\\n}\\n```\\n\\n\\n**Tabulation:**\\nTC: O(M x N) \\nSC: O(M x N) \\n\\n```\\nclass Solution {\\n    public int minFallingPathSum(int[][] a) {\\n        int min = Integer.MAX_VALUE;\\n        int m = a.length;\\n        int n = a[0].length;\\n        \\n        int[][] dp=new int[m][n];\\n        for(int[] row: dp) Arrays.fill(row,-1);\\n        for(int j = 0; j<n; j++) dp[0][j] = a[0][j];\\n        \\n        for(int i = 1; i<m; i++){\\n            for(int j =0; j<n; j++){\\n                \\n                int left = a[i][j];\\n                if(j>0) left += dp[i-1][j-1];\\n                else left += (int)Math.pow(10,9);\\n                \\n                int up = a[i][j] + dp[i-1][j];\\n                \\n                int right = a[i][j];\\n                if(j<a[0].length-1) right += dp[i-1][j+1];\\n                else right = (int)Math.pow(10,9);\\n                \\n                dp[i][j] = Math.min(left,Math.min(up,right));\\n            }\\n        }\\n        \\n        for(int j = 0; j<n; j++){\\n            min = Math.min(min,dp[n-1][j]);\\n        }\\n        return min;\\n    }\\n}\\n```\\n\\n\\n**Space Optimization:**\\nTC: O(M X N)\\nSC: O(M) Where M is no. of rows\\n\\n```\\nclass Solution {\\n    public int minFallingPathSum(int[][] a) {\\n        int min = Integer.MAX_VALUE;\\n        int m = a.length;\\n        int n = a[0].length;\\n        \\n        int[] dp=new int[n];\\n        Arrays.fill(dp,-1);\\n        for(int j = 0; j<n; j++) dp[j] = a[0][j];\\n        \\n        for(int i = 1; i<m; i++){\\n            int[] curr=new int[n];\\n            for(int j =0; j<n; j++){\\n                \\n                int left = a[i][j];\\n                if(j>0) left += dp[j-1];\\n                else left += (int)Math.pow(10,9);\\n                \\n                int up = a[i][j] + dp[j];\\n                \\n                int right = a[i][j];\\n                if(j<a[0].length-1) right += dp[j+1];\\n                else right = (int)Math.pow(10,9);\\n                \\n                curr[j] = Math.min(left,Math.min(up,right));\\n            }\\n            dp=curr;\\n        }\\n        \\n        for(int j = 0; j<n; j++){\\n            min = Math.min(min,dp[j]);\\n        }\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public int minFallingPathSum(int[][] a) {\\n        int min = Integer.MAX_VALUE;\\n        int m = a.length;\\n        int n = a[0].length;\\n        \\n        for(int j = 0; j<n; j++){\\n            int temp = help(m-1,j,a);\\n            min = Math.min(min,temp);\\n        }\\n        return min;\\n    }\\n    public int help(int i, int j, int[][] a){\\n        \\n        if(i<0 || j<0 || j>a[0].length-1) return (int)Math.pow(10,9);\\n        if(i==0) return a[i][j];\\n        \\n        int left = a[i][j] + help(i-1,j-1,a);\\n        int up = a[i][j] + help(i-1,j,a);\\n        int right = a[i][j] + help(i-1,j+1,a);\\n        \\n        return Math.min(left,Math.min(up,right));\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minFallingPathSum(int[][] a) {\\n        int min = Integer.MAX_VALUE;\\n        int m = a.length;\\n        int n = a[0].length;\\n        int[][] dp=new int[m][n];\\n        for(int[] row: dp) Arrays.fill(row,-1);\\n        for(int j = 0; j<n; j++){\\n            int temp = help(m-1,j,a,dp);\\n            min = Math.min(min,temp);\\n        }\\n        return min;\\n    }\\n    public int help(int i, int j, int[][] a,int[][] dp){\\n        \\n        if(i<0 || j<0 || j>a[0].length-1) return (int)Math.pow(10,9);\\n        if(i==0) return a[i][j];\\n        if(dp[i][j] != -1) return dp[i][j];\\n        int left = a[i][j] + help(i-1,j-1,a,dp);\\n        int up = a[i][j] + help(i-1,j,a,dp);\\n        int right = a[i][j] + help(i-1,j+1,a,dp);\\n        \\n        return dp[i][j] = Math.min(left,Math.min(up,right));\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minFallingPathSum(int[][] a) {\\n        int min = Integer.MAX_VALUE;\\n        int m = a.length;\\n        int n = a[0].length;\\n        \\n        int[][] dp=new int[m][n];\\n        for(int[] row: dp) Arrays.fill(row,-1);\\n        for(int j = 0; j<n; j++) dp[0][j] = a[0][j];\\n        \\n        for(int i = 1; i<m; i++){\\n            for(int j =0; j<n; j++){\\n                \\n                int left = a[i][j];\\n                if(j>0) left += dp[i-1][j-1];\\n                else left += (int)Math.pow(10,9);\\n                \\n                int up = a[i][j] + dp[i-1][j];\\n                \\n                int right = a[i][j];\\n                if(j<a[0].length-1) right += dp[i-1][j+1];\\n                else right = (int)Math.pow(10,9);\\n                \\n                dp[i][j] = Math.min(left,Math.min(up,right));\\n            }\\n        }\\n        \\n        for(int j = 0; j<n; j++){\\n            min = Math.min(min,dp[n-1][j]);\\n        }\\n        return min;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minFallingPathSum(int[][] a) {\\n        int min = Integer.MAX_VALUE;\\n        int m = a.length;\\n        int n = a[0].length;\\n        \\n        int[] dp=new int[n];\\n        Arrays.fill(dp,-1);\\n        for(int j = 0; j<n; j++) dp[j] = a[0][j];\\n        \\n        for(int i = 1; i<m; i++){\\n            int[] curr=new int[n];\\n            for(int j =0; j<n; j++){\\n                \\n                int left = a[i][j];\\n                if(j>0) left += dp[j-1];\\n                else left += (int)Math.pow(10,9);\\n                \\n                int up = a[i][j] + dp[j];\\n                \\n                int right = a[i][j];\\n                if(j<a[0].length-1) right += dp[j+1];\\n                else right = (int)Math.pow(10,9);\\n                \\n                curr[j] = Math.min(left,Math.min(up,right));\\n            }\\n            dp=curr;\\n        }\\n        \\n        for(int j = 0; j<n; j++){\\n            min = Math.min(min,dp[j]);\\n        }\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935121,
                "title": "java-recursion-with-memorization",
                "content": "```\\nclass Solution {\\n    public int minFallingPathSum(int[][] A) {\\n        int[][] memo = new int[A.length][A[0].length];\\n        \\n        // In the first row, we can start at any element\\n        // Find the min path\\n        int ans = Integer.MAX_VALUE;\\n        for(int j = 0; j < A[0].length; j++) {\\n            ans = Math.min(ans, dp(A, 0, j, memo));    \\n        }\\n        \\n        return ans;\\n    }\\n    \\n    // Defination: Falling from the first row, find the shortest path to reach the last row\\n    private int dp(int[][] A, int i, int j, int[][] memo) {\\n        // Base case\\n        // 1. No more row to falling\\n        if(i >= A.length) return 0;\\n        // 2. Invalid column index\\n        if(j < 0 || j >= A[0].length) return Integer.MAX_VALUE;\\n        // 3. If we are already solved it, return the result\\n        if(memo[i][j] != 0) return memo[i][j];\\n        \\n        // Make choice\\n\\t\\t// We have three choices to falling whitch is from the left(j - 1), center(j) or right(j + 1)\\n        return memo[i][j] = A[i][j] + min(dp(A, i + 1, j - 1, memo),\\n                                       dp(A, i + 1, j + 1, memo),\\n                                       dp(A, i + 1, j, memo));\\n    }\\n    \\n    private int min(int a, int b, int c) {\\n        return Math.min(Math.min(a, b), c);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int minFallingPathSum(int[][] A) {\\n        int[][] memo = new int[A.length][A[0].length];\\n        \\n        // In the first row, we can start at any element\\n        // Find the min path\\n        int ans = Integer.MAX_VALUE;\\n        for(int j = 0; j < A[0].length; j++) {\\n            ans = Math.min(ans, dp(A, 0, j, memo));    \\n        }\\n        \\n        return ans;\\n    }\\n    \\n    // Defination: Falling from the first row, find the shortest path to reach the last row\\n    private int dp(int[][] A, int i, int j, int[][] memo) {\\n        // Base case\\n        // 1. No more row to falling\\n        if(i >= A.length) return 0;\\n        // 2. Invalid column index\\n        if(j < 0 || j >= A[0].length) return Integer.MAX_VALUE;\\n        // 3. If we are already solved it, return the result\\n        if(memo[i][j] != 0) return memo[i][j];\\n        \\n        // Make choice\\n\\t\\t// We have three choices to falling whitch is from the left(j - 1), center(j) or right(j + 1)\\n        return memo[i][j] = A[i][j] + min(dp(A, i + 1, j - 1, memo),\\n                                       dp(A, i + 1, j + 1, memo),\\n                                       dp(A, i + 1, j, memo));\\n    }\\n    \\n    private int min(int a, int b, int c) {\\n        return Math.min(Math.min(a, b), c);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 695035,
                "title": "workings-how-i-solved-the-problem",
                "content": "**Orientation:**\\n- ***read the problem***:\\n\\t- square of integers (array of array)\\n\\t- find min sum path with constraints on choice\\n- ***hypothesis***: a 2d array A with size n*n where ??? < |A| < ???\\n- ***conclusion***:  the minimum sum subarray (given the constraints)\\n- ***categorize***:\\n\\t- combinatorial\\n- ***search space***:\\n\\t- exponential? I think this is factorial because it is n choose k.  Either way, brute force is not polynomial which leads me to believe a DP or Greedy solution may apply if we can prove optimal substructure\\n- ***brainstorm***:\\n\\t- start with visualizing and stepping through an example to find brute force algorithm:\\n\\t\\t- make the problem easier while you step through\\n\\t\\t\\t- what if there were no negative numbers?\\n\\t\\t\\t- what if you just chose a single column and returned the sum?\\n\\t\\t\\t- what if you didn\\'t care about the min sum?\\n\\t\\t- look at extreme examples\\n\\t\\t\\t- what is the smallest valid input?\\n\\t\\t\\t- what if all numbers are equal?\\n\\t\\t\\t- what if all min numbers form a diagonal\\n\\t\\t- look at the problem backwards\\n\\t\\t\\t- go from a complete set to the starting point\\n\\t- evaluate DP and Greedy criteria\\n\\t- if not possible, come back to orientation...\\n\\n**Visualize and Step Through Example:**\\n- input: A[[1,2,3],[4,5,6],[7,8,9]]\\n- output: [1,4,7]\\n\\n| i \\tj|  0 \\t| 1  \\t| 2  \\t|  \\n|---\\t|---\\t|---\\t|---\\t|\\n|   **0**\\t|   1\\t|  2 \\t|  3 \\t|   \\t\\n|   **1**\\t|   4\\t|  5 \\t|  6 \\t|   \\t\\n|   **2**\\t|   7\\t|  8 \\t| 9  \\t|   \\t\\n\\n**Make it easy - find the smallest sum column:**\\nSpecialize the problem and constrain it to make it easier and generalize from there.\\n```\\nAlgorithm(A):\\n\\tminSum = Integer.MAX_VALUE\\n\\tfor int i = 0 to i < A.length\\n\\t\\tcurSum = 0\\n\\t\\tfor int j = 0 to j < A.length\\n\\t\\t\\tcurCum += A[i][j]\\n\\t\\tminSum = Math.min(minSum, curSum)\\n\\treturn minSum\\n```\\n\\n**Make it easy - recast the problem slightly:**\\nInstead of finding the min sum of an entire column, reframe the problem as: ***find the min sum of a column ending at position (i,j) in the grid A***.\\n\\n**Look for optimal substructure:**\\nMin sum ending at (0,0) is 1 + 4 + 7\\nMin sum ending at (1,0) is 4 + 7\\nMin sum ending at (2,0) is 7\\n\\n**Add implied empty sets to make the recurrence more obvious:**\\nMin sum ending at (0,0) is 1 + 4 + 7 + {}\\nMin sum ending at (1,0) is 4 + 7 + {}\\nMin sum ending at (2,0) is 7 + {}\\nMin sum ending at (3,0) is {}\\n\\n*Notice that when i > A.length, we return an empty set.*\\n\\n**Define min sum ending at position (i,j) recursively:**\\nMin sum ending at (i,j) is: \\n- i > A.length, return empty\\n- else return A[i][j] + minSumEndingAt(A, i+1, j)\\n\\n```\\nminSumEndingAt(A, i, j)\\n\\tif (i > A.length) return 0;\\n\\treturn A[i][j] + minSumEndingAt(A, i+1, j);\\n```\\n\\n**Generalize - add the choice requirement into the problem:**\\nFind the min sum ending at i,j given the choice of an element in a column to the diagonal side of or below i,j.\\n\\nWe know that when the choice is constrained to just the cell directly below i,j then the min sum ending at i,j is the value at i,j plus the min sum of i+1,j. Therefore with the new requirement we can say that the min sum ending at i,j is the min of the min sum ending at all of the available choice cells:\\n\\nmin sum at i,j = **A[i][j] + Math.min(minSEA(A,i+1,j-1), minSEA(A,i+1,j), minSEA(A,i+1,j+1))** \\nalso notice that when j < 0 or j > A.length we return a nil set\\n\\n**Visualize as a tree:**\\nSometimes helps me later on if I visualize the recursion tree, abreviate min sum ending at as *minSEA*:\\n\\n```\\n\\n\\t\\t\\t\\t _____________minSEA(0,0)____________\\n\\t\\t\\t\\t/                  |                 \\\\\\n\\t\\t\\t   /                   |                  \\\\\\n\\tminSEA(1,-1)                  minSEA(1,0)         minSEA(1,1)\\n```\\n*tree continues like this for all cells. Leaves are outside the bounds of the grid and return a nil set.*\\n\\n**Define recursive brute force algorithm:**\\n```\\nminSumEndingAt(A, i, j)\\n\\tif (i > A.length || j < 0 || j > A.length) return nil\\n\\treturn A[i][j] + Math.min(minSumEndingAt(A,i+1,j-1), minSumEndingAt(A,i+1,j), minSumEndingAt(A,i+1,j))\\n```\\n\\n**Analyze:**\\n- **time**: we know the search space is non-polynomial, I think it\\'s factorial **O(n!)** because it looks like n choose k\\n- we do a few extra recursions to make the recursive function easier to write but I\\'m not too worried about this\\n\\n**Check DP / Greedy criteria to see if we can optimize:**\\n- does the problem have optimal substructure? yes, the optimal solution for the min sum ending at (i,j) contains the optimal solution to the min sum ending at one of the three cells below (i,j)\\n- have we defined the problem recursively? yes, above\\n- is there symmetry in the search space that we can exploit? yes, solutions to problems depend on the same solutions to sub problems which we can double check by looking at a table of optimal solutions:\\n\\n|  **min ending at cell:** \\t|   **min subset:**\\t|   **resursive solution:**\\t|   \\t   \\t\\n|---\\t|---\\t|---\\t\\n|  (2,0) \\t|   [7]\\t|   \\t|   \\t   \\t\\n|  (1,0) \\t|   [**4,7**]\\t|   4 + min (minSEA(2,0),minSEA(2,1)\\t|   \\t   \\t\\n|  (0,0)\\t|   [1,**4,7**]\\t|  1 + min (minSEA(1,0),minSEA(0,1) \\t|   \\t \\t\\n|  (2,1) \\t|   [8]\\t|   \\t|   \\t \\t\\n|  (1,1) \\t|   [5,7]\\t|   5 + min (minSEA(2,0), minSEA(2,1), minSEA(2,2))\\t|   \\t \\t\\n|  (0,1) \\t|   [2,**4,7**]\\t|   2 + min (minSEA(1,0), minSEA(1,1), minSEA(1,2))\\t|   \\t \\t\\n|  (2,2)\\t|   [9]\\t|   \\t|   \\t \\t\\n|  (1,2) \\t|   [6,8]\\t|   6 + min (minSEA(2,1), minSEA(2,2))\\t|   \\t \\t\\n|  (0,2) \\t|   [3,5,7]\\t|   3 + min (minSEA(1,1), minSEA(1,2))\\t|   \\t \\t\\n\\n**Looks like DP applies, add memoization to optimize the recursive algorithm:**\\nBasically the same as our algorithm but use a hash to store the computed min sum ending at i,j:\\n\\n```\\nhash[][]\\nminSumEndingAt(A,i,j)\\n\\tif (i > A.length || j < 0 || j > A.length) return nil\\n\\tif (hash[i][j] != nil) return hash[i][j]\\n\\n\\thash[i][j] = A[i][j] + Math.min(minSumEndingAt(A,i+1,j-1), minSumEndingAt(A,i+1,j), minSumEndingAt(A,i+1,j))\\n\\treturn hash[i][j]\\n```\\n\\n**Analyze:**\\n- **time**: we now only compute the value of a sub problem once and so the number of computations is now linear with regards to the number of cells. **O(n)**\\n- **space**: we need space for the hash proportional to the number of cells in the input and we need space for the recursion tree proportional to the height of the tree which is A.length or just **O(n)**\\n\\n**Transpose into Java:**\\nbreak out some smaller problems that I need to solve as I transpose:\\n- how to define the base case where i or j is out of bounds? easiest way I can think of is to use Integer.MAX_VALUE as we\\'re calculating min sums, will need to assume that the sum will be less than that so that I can test if a sub problem yields MAX_VALUE, and count it as 0 in my sum calculation.\\n- how to initialize the hash? easiest way I can think of is to assume the min sum will always be greater than 0\\n\\nmake assumptions to make the code easier to write:\\n- 0 < minSumEndingAt(i,j) < Integer.MAX_VALUE\\n\\n```\\nclass Solution {\\n    int[][] hash;\\n    \\n    public int minFallingPathSum(int[][] A) {\\n        int min = Integer.MAX_VALUE;\\n        hash = new int[A.length][A.length];\\n        for (int j = 0; j < A.length; j++) {\\n            min = Math.min(min, minSumEndingHere(A, 0, j));\\n        }\\n        return min;\\n    }\\n    \\n    private int minSumEndingHere(int[][] A, int i, int j) {\\n        if      (j < 0 || j > A.length - 1 || i > A.length - 1) return Integer.MAX_VALUE;\\n        else if (hash[i][j] != 0)                               return hash[i][j];\\n        \\n        int left    = minSumEndingHere(A, i+1, j-1);\\n        int mid     = minSumEndingHere(A, i+1, j);\\n        int right   = minSumEndingHere(A, i+1, j+1);\\n        \\n        int res = min(left, mid, right);\\n        \\n        hash[i][j] = A[i][j] + (res == Integer.MAX_VALUE ? 0 : res);\\n        return hash[i][j];\\n    }\\n    \\n    private int min(int a, int b, int c) {\\n        return Math.min(Math.min(a, b), c);\\n    }\\n}\\n```\\n\\n**I really struggled with time / space complexity analysis - anyone out there who can tell me what the actual time / space is and why?**",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nAlgorithm(A):\\n\\tminSum = Integer.MAX_VALUE\\n\\tfor int i = 0 to i < A.length\\n\\t\\tcurSum = 0\\n\\t\\tfor int j = 0 to j < A.length\\n\\t\\t\\tcurCum += A[i][j]\\n\\t\\tminSum = Math.min(minSum, curSum)\\n\\treturn minSum\\n```\n```\\nminSumEndingAt(A, i, j)\\n\\tif (i > A.length) return 0;\\n\\treturn A[i][j] + minSumEndingAt(A, i+1, j);\\n```\n```\\n\\n\\t\\t\\t\\t _____________minSEA(0,0)____________\\n\\t\\t\\t\\t/                  |                 \\\\\\n\\t\\t\\t   /                   |                  \\\\\\n\\tminSEA(1,-1)                  minSEA(1,0)         minSEA(1,1)\\n```\n```\\nminSumEndingAt(A, i, j)\\n\\tif (i > A.length || j < 0 || j > A.length) return nil\\n\\treturn A[i][j] + Math.min(minSumEndingAt(A,i+1,j-1), minSumEndingAt(A,i+1,j), minSumEndingAt(A,i+1,j))\\n```\n```\\nhash[][]\\nminSumEndingAt(A,i,j)\\n\\tif (i > A.length || j < 0 || j > A.length) return nil\\n\\tif (hash[i][j] != nil) return hash[i][j]\\n\\n\\thash[i][j] = A[i][j] + Math.min(minSumEndingAt(A,i+1,j-1), minSumEndingAt(A,i+1,j), minSumEndingAt(A,i+1,j))\\n\\treturn hash[i][j]\\n```\n```\\nclass Solution {\\n    int[][] hash;\\n    \\n    public int minFallingPathSum(int[][] A) {\\n        int min = Integer.MAX_VALUE;\\n        hash = new int[A.length][A.length];\\n        for (int j = 0; j < A.length; j++) {\\n            min = Math.min(min, minSumEndingHere(A, 0, j));\\n        }\\n        return min;\\n    }\\n    \\n    private int minSumEndingHere(int[][] A, int i, int j) {\\n        if      (j < 0 || j > A.length - 1 || i > A.length - 1) return Integer.MAX_VALUE;\\n        else if (hash[i][j] != 0)                               return hash[i][j];\\n        \\n        int left    = minSumEndingHere(A, i+1, j-1);\\n        int mid     = minSumEndingHere(A, i+1, j);\\n        int right   = minSumEndingHere(A, i+1, j+1);\\n        \\n        int res = min(left, mid, right);\\n        \\n        hash[i][j] = A[i][j] + (res == Integer.MAX_VALUE ? 0 : res);\\n        return hash[i][j];\\n    }\\n    \\n    private int min(int a, int b, int c) {\\n        return Math.min(Math.min(a, b), c);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 388723,
                "title": "python3-super-easy-understanding-with-dp",
                "content": "\\tclass Solution:\\n\\t\\tdef minFallingPathSum(self, A: List[List[int]]) -> int:\\n\\t\\t\\tr=len(A)\\n\\t\\t\\tc=len(A[0])\\n\\t\\t\\tfor i in range(1,r):\\n\\t\\t\\t\\tfor j in range(c):\\n\\t\\t\\t\\t\\tif j==0:\\n\\t\\t\\t\\t\\t\\tA[i][j]+=min(A[i-1][j+1],A[i-1][j])\\n\\t\\t\\t\\t\\telif j==c-1:\\n\\t\\t\\t\\t\\t\\tA[i][j]+=min(A[i-1][j-1],A[i-1][j])\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tA[i][j]+=min(A[i-1][j-1],A[i-1][j],A[i-1][j+1])\\n\\t\\t\\treturn min(A[-1])",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef minFallingPathSum(self, A: List[List[int]]) -> int:\\n\\t\\t\\tr=len(A)\\n\\t\\t\\tc=len(A[0])\\n\\t\\t\\tfor i in range(1,r):\\n\\t\\t\\t\\tfor j in range(c):\\n\\t\\t\\t\\t\\tif j==0:\\n\\t\\t\\t\\t\\t\\tA[i][j]+=min(A[i-1][j+1],A[i-1][j])\\n\\t\\t\\t\\t\\telif j==c-1:\\n\\t\\t\\t\\t\\t\\tA[i][j]+=min(A[i-1][j-1],A[i-1][j])\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tA[i][j]+=min(A[i-1][j-1],A[i-1][j],A[i-1][j+1])\\n\\t\\t\\treturn min(A[-1])",
                "codeTag": "Java"
            },
            {
                "id": 196646,
                "title": "c-4ms-dp-solution-with-explanation",
                "content": "# Brute Force / Recursive Solution\\nThe problem can be solved with recursion by generating all possible paths and picking the one with the smallest path sum; this can be done in *O(3^array_length)* time and *O(array_length)* space on the call stack (for a very large square array, each possible starting point in the first row has roughly 3 possible next values, and each of those has three possible next values, leading to roughly 3^array_length possible paths to consider).\\n\\n# Dynamic Programming\\nWe can solve this faster with dynamic programming in *O(array_length^2)* time and *O(array_length^2)* space. Suppose we have the array:\\n```\\n1   2   3\\n4   5   6\\n7   8   9\\n```\\n\\nWhat is the minimum falling path sum (mFPS) starting at array[0][1]? It is the minimum of the mFPS\\'s starting at array[1][0], array[1][1], and array[1][2], plus the value of array[0][1]. Similarly, the mFPS starting at array[1][1] is the minimum of the mFPS\\'s starting at array[2][0], array[2][1], and array[2][2], plus the value of array[1][1]. We can generalize this into an equation:\\n\\n**mFPSThrough(r, c) = min(mFPSThrough(r+1, c-1),    mFPSThrough(r+1, c),    mFPSThrough(r+1, c+1)) + array[r][c]**\\n\\nThere are a few edge cases to keep track of.\\n* The mFPS of elements in the last row is the values of the elements themselves since they\\'re at the end of any path (i.e. mFPSThrough(i+1, ...) = 0 for i >= r).\\n* The mFPS of elements in the first and last columns should only consider two possible paths, not three; the falling path sum can\\'t go outside the bounds of the array.\\n\\nWith this in mind, we can create a DP solution using a two-dimensional array with the elements in the bottom row initialized to their values in the array. We then iterate upwards, row by row, and for each element in that row we set it to the minimum of the two or three elements directly below it, plus its value in the array. At the end, we iterate through the top row and find the smallest value, which represents the minimum falling path sum.\\n\\n```\\nint minFallingPathSum(int** A, int ARowSize, int *AColSizes) {\\n    \\n\\t// Allocate the DP matrix\\n    int* mFPSThrough = (int*) malloc(ARowSize*ARowSize*sizeof(int));\\n    \\n\\t// Initialize the bottom row base case for our DP matrix\\n    int r, c;\\n    for(c = 0; c < ARowSize; ++c) {\\n        mFPSThrough[((ARowSize-1)*ARowSize) + c] = A[ARowSize-1][c]; \\n    }\\n    \\n\\t// Iterate upwards starting from the 2nd to last row\\n    for (r = ARowSize - 2; r >= 0; r--) {\\n        for (c = 0; c < ARowSize; ++c) {\\n            int index = (r*ARowSize) + c;\\n            \\n            // All paths can take the same column for the next row, so we start with this as the mFPS value through this column\\n            int cellMin = mFPSThrough[((r + 1)*ARowSize) + c];\\n            \\n            // If not leftmost col, check path through [r+1][c-1]\\n            if (c > 0) {\\n                int leftNext = mFPSThrough[((r + 1)*ARowSize) + (c - 1)];\\n                cellMin = (cellMin < leftNext) ? cellMin : leftNext;\\n            }\\n            \\n            // If not rightmost col, check path through [r+1][c+1]\\n            if (c < (ARowSize - 1)) {\\n                int rightNext = mFPSThrough[((r + 1)*ARowSize) + (c + 1)];\\n                cellMin = (cellMin < rightNext) ? cellMin : rightNext;\\n            }\\n\\n            // Need to include current cell\\'s value for sum of path through cell\\n            mFPSThrough[index] = cellMin + A[r][c];\\n        }\\n    }\\n    \\n\\t// Now find the smallest mFPS\\n\\tint minFPSum = INT_MAX;\\n    for (c = 0; c < ARowSize; ++c) {\\n        minFPSum = (mFPSThrough[c] < minFPSum) ? mFPSThrough[c] : minFPSum;\\n    }\\n    \\n    return minFPSum;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n1   2   3\\n4   5   6\\n7   8   9\\n```\n```\\nint minFallingPathSum(int** A, int ARowSize, int *AColSizes) {\\n    \\n\\t// Allocate the DP matrix\\n    int* mFPSThrough = (int*) malloc(ARowSize*ARowSize*sizeof(int));\\n    \\n\\t// Initialize the bottom row base case for our DP matrix\\n    int r, c;\\n    for(c = 0; c < ARowSize; ++c) {\\n        mFPSThrough[((ARowSize-1)*ARowSize) + c] = A[ARowSize-1][c]; \\n    }\\n    \\n\\t// Iterate upwards starting from the 2nd to last row\\n    for (r = ARowSize - 2; r >= 0; r--) {\\n        for (c = 0; c < ARowSize; ++c) {\\n            int index = (r*ARowSize) + c;\\n            \\n            // All paths can take the same column for the next row, so we start with this as the mFPS value through this column\\n            int cellMin = mFPSThrough[((r + 1)*ARowSize) + c];\\n            \\n            // If not leftmost col, check path through [r+1][c-1]\\n            if (c > 0) {\\n                int leftNext = mFPSThrough[((r + 1)*ARowSize) + (c - 1)];\\n                cellMin = (cellMin < leftNext) ? cellMin : leftNext;\\n            }\\n            \\n            // If not rightmost col, check path through [r+1][c+1]\\n            if (c < (ARowSize - 1)) {\\n                int rightNext = mFPSThrough[((r + 1)*ARowSize) + (c + 1)];\\n                cellMin = (cellMin < rightNext) ? cellMin : rightNext;\\n            }\\n\\n            // Need to include current cell\\'s value for sum of path through cell\\n            mFPSThrough[index] = cellMin + A[r][c];\\n        }\\n    }\\n    \\n\\t// Now find the smallest mFPS\\n\\tint minFPSum = INT_MAX;\\n    for (c = 0; c < ARowSize; ++c) {\\n        minFPSum = (mFPSThrough[c] < minFPSum) ? mFPSThrough[c] : minFPSum;\\n    }\\n    \\n    return minFPSum;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 186656,
                "title": "c-using-dynamic-programming",
                "content": "    int minFallingPathSum(vector<vector<int>>& A) {\n        int rows = A.size(), cols = rows ? A[0].size() : 0, i, j, k;\n        int res = INT_MAX;\n        \n        if(0 == rows || 0 == cols)\n            return 0;\n \n        for(i = 1; i < rows; i++) {\n            for(j = 0; j < cols; j++) {\n                int mn = A[i - 1][j];\n                if(j > 0)\n                    mn = min(mn, A[i - 1][j - 1]);\n                if(j < cols - 1)\n                    mn = min(mn, A[i - 1][j + 1]);\n                A[i][j] += mn;\n            }\n        }\n        for(j = 0; j < cols; j++)\n            res = min(res, A[rows - 1][j]);\n        \n        return res;\n    }",
                "solutionTags": [],
                "code": "    int minFallingPathSum(vector<vector<int>>& A) {\n        int rows = A.size(), cols = rows ? A[0].size() : 0, i, j, k;\n        int res = INT_MAX;\n        if(0 == rows || 0 == cols)\n            return 0;\n        for(i = 1; i < rows; i++) {\n            for(j = 0; j < cols; j++) {\n                int mn = A[i - 1][j];\n                if(j > 0)\n                    mn = min(mn, A[i - 1][j - 1]);\n                if(j < cols - 1)\n                    mn = min(mn, A[i - 1][j + 1]);\n                A[i][j] += mn;\n            }\n        }\n        for(j = 0; j < cols; j++)\n            res = min(res, A[rows - 1][j]);\n        return res;\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 4048436,
                "title": "easy-to-understand-c",
                "content": "# Problem: Minimum Falling Path Sum\\n\\n## Intuition\\nThe goal of this problem is to find the minimum falling path sum in a given matrix. Each cell in the matrix is the sum of the current cell and the minimum of its upper adjacent cells.\\n\\n## Approach\\nWe can solve this problem using dynamic programming. We start from the second row of the matrix and, for each cell in the current row, calculate the minimum falling path sum by considering the values of the upper adjacent cells. We update each cell with the sum of its current value and the minimum of the upper adjacent cells.\\n\\nHere\\'s the step-by-step approach:\\n1. Initialize a variable `n` to represent the number of rows in the matrix.\\n2. Iterate through the rows starting from the second row (index 1) to the last row (index n-1).\\n   - For each cell in the current row, calculate the minimum falling path sum by considering the values of the upper adjacent cells.\\n   - Handle the special cases for cells at the leftmost and rightmost edges of the matrix.\\n3. After completing the iteration, the minimum falling path sum can be found in the last row of the matrix.\\n4. Return the minimum value in the last row as the result.\\n\\n## Complexity\\n- Time Complexity: O($N^2$) where N is the number of rows in the matrix, as we iterate through each cell once.\\n- Space Complexity: O(1) as we are modifying the input matrix in-place.\\n\\n## Code\\n```cpp\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n      int n = matrix.size();\\n      for(int i=1; i<n; i++) {\\n        for(int j=0; j<n; j++) {\\n          if(j==0)\\n            matrix[i][j] += min(matrix[i-1][j], matrix[i-1][j+1]);\\n          else if(j==n-1)\\n            matrix[i][j] += min(matrix[i-1][j], matrix[i-1][j-1]);\\n          else \\n            matrix[i][j] += min(matrix[i-1][j], min(matrix[i-1][j-1], matrix[i-1][j+1]));\\n        }\\n      }\\n      int ans = *min_element(matrix[n-1].begin(), matrix[n-1].end()); \\n      return ans;\\n    }\\n};\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Matrix"
                ],
                "code": "class Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n      int n = matrix.size();\\n      for(int i=1; i<n; i++) {\\n        for(int j=0; j<n; j++) {\\n          if(j==0)\\n            matrix[i][j] += min(matrix[i-1][j], matrix[i-1][j+1]);\\n          else if(j==n-1)\\n            matrix[i][j] += min(matrix[i-1][j], matrix[i-1][j-1]);\\n          else \\n            matrix[i][j] += min(matrix[i-1][j], min(matrix[i-1][j-1], matrix[i-1][j+1]));\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3339256,
                "title": "best-o-n-n-solution",
                "content": "# Approach 1\\nRecursion (TLE)\\n\\n# Complexity\\n- Time complexity:\\n$$O(3^n)$$ \\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    int solve(int i, int j, vector<vector<int>>& matrix, int n) {\\n        if (j < 0 || j >= n)\\n            return 1e9;\\n        if (i == 0)\\n            return matrix[i][j];\\n        int up = matrix[i][j] + solve(i-1, j, matrix, n);  \\n        int leftDiagonal = matrix[i][j] + solve(i-1, j-1, matrix, n);  \\n        int rightDiagonal = matrix[i][j] + solve(i-1, j+1, matrix, n); \\n        return min (up, min (leftDiagonal, rightDiagonal));   \\n    }\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        int minSum = INT_MAX;\\n        for (int j = 0; j < n; j++) \\n            minSum = min (minSum, solve(n-1, j, matrix, n));\\n        return minSum;\\n    }\\n};\\n```\\n\\n# Approach 2\\nDP (Top Down Approach)\\n\\n# Complexity\\n- Time complexity:\\n$$O(n * n)$$\\n\\n- Space complexity:\\n$$O(n * n)$$\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    int solve(int i, int j, vector<vector<int>>& matrix, vector<vector<int>>& dp, int n) {\\n        if (j < 0 || j >= n)\\n            return 1e9;\\n        if (i == 0)\\n            return matrix[i][j];\\n        if (dp[i][j] != -1)\\n            return dp[i][j];    \\n        int up = matrix[i][j] + solve(i-1, j, matrix, dp, n);  \\n        int leftDiagonal = matrix[i][j] + solve(i-1, j-1, matrix, dp, n);  \\n        int rightDiagonal = matrix[i][j] + solve(i-1, j+1, matrix, dp, n); \\n        return dp[i][j] = min (up, min (leftDiagonal, rightDiagonal));   \\n    }\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        vector<vector<int>> dp(n, vector<int>(n, -1));\\n        int minSum = INT_MAX;\\n        for (int j = 0; j < n; j++) \\n            minSum = min (minSum, solve(n-1, j, matrix, dp, n));\\n        return minSum;\\n    }\\n};\\n```\\n\\n# Approach 3\\nDP (Bottom Up Approach)\\n\\n# Complexity\\n- Time complexity:\\n$$O(n * n)$$\\n\\n- Space complexity:\\n$$O(n * n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        vector<vector<int>> dp(n, vector<int>(n, 0));\\n        for (int j = 0; j < n; j++) \\n            dp[0][j] = matrix[0][j];\\n        for (int i = 1; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                int up = matrix[i][j] + dp[i-1][j];  \\n                int leftDiagonal = matrix[i][j]; \\n                if (j-1 >= 0)\\n                    leftDiagonal += dp[i-1][j-1]; \\n                else\\n                    leftDiagonal += 1e9;    \\n                int rightDiagonal = matrix[i][j]; \\n                if (j+1 < n)\\n                    rightDiagonal += dp[i-1][j+1]; \\n                else\\n                    rightDiagonal += 1e9;\\n                dp[i][j] = min (up, min (leftDiagonal, rightDiagonal));   \\n            }\\n        }    \\n        int minSum = INT_MAX;\\n        for (int j = 0; j < n; j++)\\n            minSum = min (minSum, dp[n-1][j]);\\n        return minSum;\\n    }\\n};\\n```\\n\\n# Approach 4\\nDP (Bottom Up Approach) + Space Optimization\\n\\n# Complexity\\n- Time complexity:\\n$$O(n * n)$$ \\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        vector <int> prev(n, 0), cur(n, 0);\\n        for (int j = 0; j < n; j++) \\n           prev[j] = matrix[0][j];\\n        for (int i = 1; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                int up = matrix[i][j] + prev[j];  \\n                int leftDiagonal = matrix[i][j]; \\n                if (j-1 >= 0)\\n                    leftDiagonal += prev[j-1]; \\n                else\\n                    leftDiagonal += 1e9;    \\n                int rightDiagonal = matrix[i][j]; \\n                if (j+1 < n)\\n                    rightDiagonal += prev[j+1]; \\n                else\\n                    rightDiagonal += 1e9;\\n                cur[j] = min (up, min (leftDiagonal, rightDiagonal));   \\n            }\\n            prev = cur;\\n        }    \\n        int minSum = INT_MAX;\\n        for (int j = 0; j < n; j++)\\n            minSum = min (minSum, prev[j]);\\n        return minSum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int solve(int i, int j, vector<vector<int>>& matrix, int n) {\\n        if (j < 0 || j >= n)\\n            return 1e9;\\n        if (i == 0)\\n            return matrix[i][j];\\n        int up = matrix[i][j] + solve(i-1, j, matrix, n);  \\n        int leftDiagonal = matrix[i][j] + solve(i-1, j-1, matrix, n);  \\n        int rightDiagonal = matrix[i][j] + solve(i-1, j+1, matrix, n); \\n        return min (up, min (leftDiagonal, rightDiagonal));   \\n    }\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        int minSum = INT_MAX;\\n        for (int j = 0; j < n; j++) \\n            minSum = min (minSum, solve(n-1, j, matrix, n));\\n        return minSum;\\n    }\\n};\\n```\n```\\nclass Solution {\\nprivate:\\n    int solve(int i, int j, vector<vector<int>>& matrix, vector<vector<int>>& dp, int n) {\\n        if (j < 0 || j >= n)\\n            return 1e9;\\n        if (i == 0)\\n            return matrix[i][j];\\n        if (dp[i][j] != -1)\\n            return dp[i][j];    \\n        int up = matrix[i][j] + solve(i-1, j, matrix, dp, n);  \\n        int leftDiagonal = matrix[i][j] + solve(i-1, j-1, matrix, dp, n);  \\n        int rightDiagonal = matrix[i][j] + solve(i-1, j+1, matrix, dp, n); \\n        return dp[i][j] = min (up, min (leftDiagonal, rightDiagonal));   \\n    }\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        vector<vector<int>> dp(n, vector<int>(n, -1));\\n        int minSum = INT_MAX;\\n        for (int j = 0; j < n; j++) \\n            minSum = min (minSum, solve(n-1, j, matrix, dp, n));\\n        return minSum;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        vector<vector<int>> dp(n, vector<int>(n, 0));\\n        for (int j = 0; j < n; j++) \\n            dp[0][j] = matrix[0][j];\\n        for (int i = 1; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                int up = matrix[i][j] + dp[i-1][j];  \\n                int leftDiagonal = matrix[i][j]; \\n                if (j-1 >= 0)\\n                    leftDiagonal += dp[i-1][j-1]; \\n                else\\n                    leftDiagonal += 1e9;    \\n                int rightDiagonal = matrix[i][j]; \\n                if (j+1 < n)\\n                    rightDiagonal += dp[i-1][j+1]; \\n                else\\n                    rightDiagonal += 1e9;\\n                dp[i][j] = min (up, min (leftDiagonal, rightDiagonal));   \\n            }\\n        }    \\n        int minSum = INT_MAX;\\n        for (int j = 0; j < n; j++)\\n            minSum = min (minSum, dp[n-1][j]);\\n        return minSum;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        vector <int> prev(n, 0), cur(n, 0);\\n        for (int j = 0; j < n; j++) \\n           prev[j] = matrix[0][j];\\n        for (int i = 1; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                int up = matrix[i][j] + prev[j];  \\n                int leftDiagonal = matrix[i][j]; \\n                if (j-1 >= 0)\\n                    leftDiagonal += prev[j-1]; \\n                else\\n                    leftDiagonal += 1e9;    \\n                int rightDiagonal = matrix[i][j]; \\n                if (j+1 < n)\\n                    rightDiagonal += prev[j+1]; \\n                else\\n                    rightDiagonal += 1e9;\\n                cur[j] = min (up, min (leftDiagonal, rightDiagonal));   \\n            }\\n            prev = cur;\\n        }    \\n        int minSum = INT_MAX;\\n        for (int j = 0; j < n; j++)\\n            minSum = min (minSum, prev[j]);\\n        return minSum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3058953,
                "title": "beats-100-most-efficient-solution-c",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& v) {\\n        int N = v.size();\\n         vector<int> curr(N,0) , prev(N,0);\\n        int maxi = INT_MIN;\\n        for(int j=0;j<N;j++){\\n            prev[j] = v[0][j];      \\n        }\\n        for(int i=1;i<N;i++){\\n            for(int j=0;j<N;j++){\\n                int top    = v[i][j] + prev[j];\\n                int topleft = v[i][j]; \\n                if(j>0){\\n                    topleft += prev[j-1];\\n                }\\n                else{\\n                    topleft += 1e9;\\n                }\\n                int topright = v[i][j];\\n                if(j<N-1){\\n                    topright += prev[j+1]; \\n                }\\n                else{\\n                    topright += 1e9; \\n                }\\n                curr[j] = min(top , min(topleft,topright));\\n            }\\n            prev = curr;\\n        }\\n        \\n        \\n         maxi = INT_MAX;\\n        for(int j=0;j<N;j++){\\n            maxi = min(maxi,prev[j]);\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& v) {\\n        int N = v.size();\\n         vector<int> curr(N,0) , prev(N,0);\\n        int maxi = INT_MIN;\\n        for(int j=0;j<N;j++){\\n            prev[j] = v[0][j];      \\n        }\\n        for(int i=1;i<N;i++){\\n            for(int j=0;j<N;j++){\\n                int top    = v[i][j] + prev[j];\\n                int topleft = v[i][j]; \\n                if(j>0){\\n                    topleft += prev[j-1];\\n                }\\n                else{\\n                    topleft += 1e9;\\n                }\\n                int topright = v[i][j];\\n                if(j<N-1){\\n                    topright += prev[j+1]; \\n                }\\n                else{\\n                    topright += 1e9; \\n                }\\n                curr[j] = min(top , min(topleft,topright));\\n            }\\n            prev = curr;\\n        }\\n        \\n        \\n         maxi = INT_MAX;\\n        for(int j=0;j<N;j++){\\n            maxi = min(maxi,prev[j]);\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2907855,
                "title": "simple-and-easy-java-video-explanation",
                "content": "--It is not the Fastest Solution but easy to understand and implement\\n--For understanding approach refer to my page and one youtube video link is also there\\n\\n# Code\\n```\\n// Kindly upvote my solution if it helps you because it gives me motivation to explain more\\nclass Solution {\\n    public int minFallingPathSum(int[][] matrix) {\\n        int n = matrix.length;\\n        int[][] mat = new int[n][n];\\n\\n        // Copying 1st row of given matrix to new matriz\\n        for(int i=0; i<n; i++){\\n            mat[0][i] = matrix[0][i];\\n        }\\n\\n        // Now in second row comparing the each element\\'s sum to the element on top of it top left and top right\\n        for(int row=1; row<n; row++){\\n            for(int col=0; col<n; col++){\\n                int min = Integer.MAX_VALUE;    // i took 1000 because in constraints they have mentioned max value is 100\\n\\n                // Now taking sum of this element and it\\'s upper element and comparing with previous\\n                min = Math.min(min , matrix[row][col] + mat[row-1][col]);\\n\\n                // checking if left element of upper element in new matrix exist then doing sum of it\\n                if(col-1 >= 0)    min = Math.min(min , matrix[row][col] + mat[row-1][col-1]);\\n\\n                // Now checking if top right element in new matrix exist and comparing the same\\n                if(col+1 <= n-1)    min = Math.min(min, matrix[row][col] + mat[row-1][col+1]);\\n\\n                // Now we have got the minimum value so we will add that value to the spot\\n                mat[row][col] = min;\\n            }\\n        }\\n        // Now we just need to select the minimum value from the last row of our new matrix\\n        int answer = Integer.MAX_VALUE;\\n        for(int i=0; i<n; i++){\\n            answer = Math.min(answer , mat[n-1][i]);\\n        }\\n        return answer;\\n    }\\n}\\n```\\n[https://www.youtube.com/watch?v=oJ5leqo6vjg]()",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// Kindly upvote my solution if it helps you because it gives me motivation to explain more\\nclass Solution {\\n    public int minFallingPathSum(int[][] matrix) {\\n        int n = matrix.length;\\n        int[][] mat = new int[n][n];\\n\\n        // Copying 1st row of given matrix to new matriz\\n        for(int i=0; i<n; i++){\\n            mat[0][i] = matrix[0][i];\\n        }\\n\\n        // Now in second row comparing the each element\\'s sum to the element on top of it top left and top right\\n        for(int row=1; row<n; row++){\\n            for(int col=0; col<n; col++){\\n                int min = Integer.MAX_VALUE;    // i took 1000 because in constraints they have mentioned max value is 100\\n\\n                // Now taking sum of this element and it\\'s upper element and comparing with previous\\n                min = Math.min(min , matrix[row][col] + mat[row-1][col]);\\n\\n                // checking if left element of upper element in new matrix exist then doing sum of it\\n                if(col-1 >= 0)    min = Math.min(min , matrix[row][col] + mat[row-1][col-1]);\\n\\n                // Now checking if top right element in new matrix exist and comparing the same\\n                if(col+1 <= n-1)    min = Math.min(min, matrix[row][col] + mat[row-1][col+1]);\\n\\n                // Now we have got the minimum value so we will add that value to the spot\\n                mat[row][col] = min;\\n            }\\n        }\\n        // Now we just need to select the minimum value from the last row of our new matrix\\n        int answer = Integer.MAX_VALUE;\\n        for(int i=0; i<n; i++){\\n            answer = Math.min(answer , mat[n-1][i]);\\n        }\\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2906678,
                "title": "simple-3-cases-solution-easy-to-understand-recursive-memoization-commented",
                "content": "# upvote if helpful.\\n# some knowledge:  \\nIn recursion we have two types of calls one is making the clever recursive calls and putting base case random and other is making random calls and putting base case cleverly, here i have shown how to make clever calls, where by making the below calls one can never go out of the index bound.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>>dp; //our programs brain; currently empty \\n    int util(vector<vector<int>>& arr, int i, int j){\\n        if(i>=arr.size()){\\n            return 0;\\n        }//base case when we go out of the matrix\\n        if(dp[i][j]!= 100000)return dp[i][j]; //if we already found our answer and stored in our brain then return that answer no need to make further recursive calls.\\n        int ans=INT_MAX;\\n        if(j==0){// if j==0 =>that we can go to j, j+1th element of next row\\n            int a= arr[i][j]+util(arr, i+1, j);\\n            int b= INT_MAX;\\n            //although there can be case where we have only 1 col\\n            //edge case\\n            if(j+1<arr[0].size()) b=arr[i][j]+ util(arr, i+1, j+1);\\n            ans= min({a, b, ans});\\n        }\\n        else if(j==arr[0].size()-1){//if j==arr[0].size()=> we are at last column and\\n        //we can make only call to j, j-1th element in next row\\n            int a= arr[i][j]+util(arr, i+1, j);\\n            int b= INT_MAX;\\n            //edge case when we have only one col in matrix\\n            if(j-1>=0)b= arr[i][j]+util(arr, i+1, j-1);\\n            ans=min({a, b, ans});\\n        }else{//this case is when we not the first col, last col we are in the cols between them \\n        //so we have 3 cases as mentioned in the problem\\n            //three cases are as follows:\\n            //1) add me and go to next ele below me.\\n            //2) add me and go to diagonally left ele below me.\\n            //3) add me and go to diagonally right ele below me.\\n            int a= arr[i][j]+util(arr, i+1, j);\\n            int b= arr[i][j]+util(arr, i+1, j-1);\\n            int c= arr[i][j]+util(arr, i+1, j+1);\\n            ans= min({a, b, c, ans});\\n        }\\n        return dp[i][j]= ans;// store calculated result into the brain\\n        //so that i can easilly return calculated result without doing calculations repeatatively.\\n\\n    }\\n\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int ans=INT_MAX;\\n        dp.resize(matrix.size()+1, vector<int>(matrix[0].size()+1, 100000));//defining our brain size.\\n        //for the first row only we have any choice to choose our\\n        //starting point.\\n        //but ater that we have at max 3 choices only \\n        for(int j=0; j<matrix[0].size(); j++){\\n            int curr= util(matrix, 0, j);\\n            ans= min(ans, curr);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>dp; //our programs brain; currently empty \\n    int util(vector<vector<int>>& arr, int i, int j){\\n        if(i>=arr.size()){\\n            return 0;\\n        }//base case when we go out of the matrix\\n        if(dp[i][j]!= 100000)return dp[i][j]; //if we already found our answer and stored in our brain then return that answer no need to make further recursive calls.\\n        int ans=INT_MAX;\\n        if(j==0){// if j==0 =>that we can go to j, j+1th element of next row\\n            int a= arr[i][j]+util(arr, i+1, j);\\n            int b= INT_MAX;\\n            //although there can be case where we have only 1 col\\n            //edge case\\n            if(j+1<arr[0].size()) b=arr[i][j]+ util(arr, i+1, j+1);\\n            ans= min({a, b, ans});\\n        }\\n        else if(j==arr[0].size()-1){//if j==arr[0].size()=> we are at last column and\\n        //we can make only call to j, j-1th element in next row\\n            int a= arr[i][j]+util(arr, i+1, j);\\n            int b= INT_MAX;\\n            //edge case when we have only one col in matrix\\n            if(j-1>=0)b= arr[i][j]+util(arr, i+1, j-1);\\n            ans=min({a, b, ans});\\n        }else{//this case is when we not the first col, last col we are in the cols between them \\n        //so we have 3 cases as mentioned in the problem\\n            //three cases are as follows:\\n            //1) add me and go to next ele below me.\\n            //2) add me and go to diagonally left ele below me.\\n            //3) add me and go to diagonally right ele below me.\\n            int a= arr[i][j]+util(arr, i+1, j);\\n            int b= arr[i][j]+util(arr, i+1, j-1);\\n            int c= arr[i][j]+util(arr, i+1, j+1);\\n            ans= min({a, b, c, ans});\\n        }\\n        return dp[i][j]= ans;// store calculated result into the brain\\n        //so that i can easilly return calculated result without doing calculations repeatatively.\\n\\n    }\\n\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int ans=INT_MAX;\\n        dp.resize(matrix.size()+1, vector<int>(matrix[0].size()+1, 100000));//defining our brain size.\\n        //for the first row only we have any choice to choose our\\n        //starting point.\\n        //but ater that we have at max 3 choices only \\n        for(int j=0; j<matrix[0].size(); j++){\\n            int curr= util(matrix, 0, j);\\n            ans= min(ans, curr);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1727944,
                "title": "c-dynamic-programming-easy-solution",
                "content": "```\\nclass Solution {\\n    int dp[102][102];\\npublic:\\n    int solve(vector<vector<int>>& matrix, int i, int j, int n, int m){\\n        if (j>=m || j<0) return INT_MAX;\\n        if (i==n-1) return matrix[i][j];\\n        if (dp[i][j]!=-1) return dp[i][j];\\n\\t\\t// now we will traverse below, diagonally_left and diagonally_right.\\n        return dp[i][j]=matrix[i][j]+min(solve(matrix,i+1,j,n,m),min(solve(matrix,i+1,j-1,n,m),solve(matrix,i+1,j+1,n,m)));\\n    }\\n    \\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n        int m=matrix[0].size();\\n        int min_val=INT_MAX;\\n        memset(dp,-1,sizeof(dp));\\n\\t\\t// this loop is for all elements of first row\\n        for (int i=0;i<m;i++){\\n            min_val=min(min_val,solve(matrix,0,i,n,m));\\n        }\\n        return min_val;\\n    }\\n};\\n```\\n\\nPS: do \"UPVOTE\" if you liked this solution :)",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int dp[102][102];\\npublic:\\n    int solve(vector<vector<int>>& matrix, int i, int j, int n, int m){\\n        if (j>=m || j<0) return INT_MAX;\\n        if (i==n-1) return matrix[i][j];\\n        if (dp[i][j]!=-1) return dp[i][j];\\n\\t\\t// now we will traverse below, diagonally_left and diagonally_right.\\n        return dp[i][j]=matrix[i][j]+min(solve(matrix,i+1,j,n,m),min(solve(matrix,i+1,j-1,n,m),solve(matrix,i+1,j+1,n,m)));\\n    }\\n    \\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n        int m=matrix[0].size();\\n        int min_val=INT_MAX;\\n        memset(dp,-1,sizeof(dp));\\n\\t\\t// this loop is for all elements of first row\\n        for (int i=0;i<m;i++){\\n            min_val=min(min_val,solve(matrix,0,i,n,m));\\n        }\\n        return min_val;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 948936,
                "title": "python-3-detailed-explanation-that-is-possible-to-follow",
                "content": "**Idea**:\\nCreate a ```dp``` matrix that is originally has 0 everywhere\\nThe first row will be equal to the row in the original list; we cannot do anything with it\\nThen we start filling out ```dp``` from the second row using two loops:\\n- if we are in the leftmost column, then we take the value from the original list that sits in the same position and will add to it the minimum of elements one row above: one element is just above our element, another is one step to the right\\n- if we are in the rightmost column, then we take the value from the original list that sits in the same position and will add to it the minimum of elements one row above: one element is just above our element, another is one step to the left\\n- in all other cases we take the value from the original list that sits in the same position and will add the minimum of three elements one row above: one element is just above our element, another element is one step to the left, another is one step to the right\\nThe answer is the minimum value in the last row of ```dp```\\n\\n```\\ndef minFallingPathSum(arr):\\n    dp = [[0] * len(arr[0]) for i in range(len(arr))]  # dp with zeroes\\n    for col in range(len(arr[0])):  # filling out the first row with original numbers\\n        dp[0][col] = arr[0][col]\\n    for row in range(1, len(arr)):  # two loops to fill out the rest of dp\\n        for col in range(len(arr[0])):\\n            if col == 0:  # filling out the first column starting from the second row\\n                dp[row][col] = arr[row][col] + min(dp[row - 1][col], dp[row - 1][col + 1])\\n            elif col == len(arr[0]) - 1:   # filling out the rightmost column from the second row\\n                dp[row][col] = arr[row][col] + min(dp[row - 1][col], dp[row - 1][col - 1])\\n            else:  # everything in between\\n                dp[row][col] = arr[row][col] + min(dp[row - 1][col - 1], dp[row - 1][col], dp[row - 1][col + 1])\\n    return min(dp[-1])  # return the smallest number in the last row\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Matrix"
                ],
                "code": "```dp```\n```dp```\n```dp```\n```\\ndef minFallingPathSum(arr):\\n    dp = [[0] * len(arr[0]) for i in range(len(arr))]  # dp with zeroes\\n    for col in range(len(arr[0])):  # filling out the first row with original numbers\\n        dp[0][col] = arr[0][col]\\n    for row in range(1, len(arr)):  # two loops to fill out the rest of dp\\n        for col in range(len(arr[0])):\\n            if col == 0:  # filling out the first column starting from the second row\\n                dp[row][col] = arr[row][col] + min(dp[row - 1][col], dp[row - 1][col + 1])\\n            elif col == len(arr[0]) - 1:   # filling out the rightmost column from the second row\\n                dp[row][col] = arr[row][col] + min(dp[row - 1][col], dp[row - 1][col - 1])\\n            else:  # everything in between\\n                dp[row][col] = arr[row][col] + min(dp[row - 1][col - 1], dp[row - 1][col], dp[row - 1][col + 1])\\n    return min(dp[-1])  # return the smallest number in the last row\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 572100,
                "title": "python-o-n-2-sol-with-in-place-dp-75-w-visualization",
                "content": "Python O(n^2) sol with in-place update by dynamic programming. \\n\\n---\\n\\nAbstract model and diagram:\\n\\nGeneral case:\\n\\n![image](https://assets.leetcode.com/users/brianchiang_tw/image_1586523920.png)\\n\\n--\\n\\nSpecial case:\\n\\n![image](https://assets.leetcode.com/users/brianchiang_tw/image_1586523934.png)\\n\\n---\\n\\n![image](https://assets.leetcode.com/users/brianchiang_tw/image_1586523730.png)\\n\\n---\\n\\n```\\nclass Solution:\\n    def minFallingPathSum(self, A: List[List[int]]) -> int:\\n        \\n        size = len(A)\\n        \\n        if size == 1:\\n            # Quick response for single row\\n            return A[0][0]\\n        \\n\\n        # Update A[y][x] from second row to last row\\n        for y in range( 1, size):\\n\\t\\t\\n\\t\\t\\t# sacn each column from 0 to size-1\\n            for x in range( size ):\\n                \\n\\t\\t\\t\\t# find falling path of minimal cost with optimal substructure\\n                min_prev = A[y-1][x] \\n                \\n                if x > 0:\\n                    min_prev = min( min_prev, A[y-1][x-1] )\\n                \\n                if x < size-1:\\n                    min_prev = min( min_prev, A[y-1][x+1] )\\n                \\n                # update the cost of falling path, destination is [y][x], with optimal substructure\\n                A[y][x] = A[y][x] + min_prev\\n                \\n        \\n        # the cost of minimum falling path is the minimum value of last row\\n        return min( A[size-1] )\\n        \\n        \\n```\\n\\n---\\n\\nShare another implementation by top-down DP:\\n\\n```\\nclass Solution:\\n    def minFallingPathSum(self, matrix: List[List[int]]) -> int:\\n        \\n        h, w = len(matrix), len(matrix[0])\\n        INF = sys.maxsize\\n        \\n        @cache\\n        def dp(row, col):\\n            \\n            ## Base case: top row\\n            if row == 0 and 0 <= col < w:\\n                return matrix[0][col]\\n            \\n            ## Base case: out-of boundary\\n            if col < 0 or col >= w:\\n                return INF\\n            \\n            ## General case: current cost + minimal cost of neighbor on previous row\\n            return matrix[row][col] + min( dp(row-1,col+offset) for offset in (-1, 0, 1) )\\n        \\n        # ------------------------------------------------\\n        return min( dp(h-1, col) for col in range(w) )\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def minFallingPathSum(self, A: List[List[int]]) -> int:\\n        \\n        size = len(A)\\n        \\n        if size == 1:\\n            # Quick response for single row\\n            return A[0][0]\\n        \\n\\n        # Update A[y][x] from second row to last row\\n        for y in range( 1, size):\\n\\t\\t\\n\\t\\t\\t# sacn each column from 0 to size-1\\n            for x in range( size ):\\n                \\n\\t\\t\\t\\t# find falling path of minimal cost with optimal substructure\\n                min_prev = A[y-1][x] \\n                \\n                if x > 0:\\n                    min_prev = min( min_prev, A[y-1][x-1] )\\n                \\n                if x < size-1:\\n                    min_prev = min( min_prev, A[y-1][x+1] )\\n                \\n                # update the cost of falling path, destination is [y][x], with optimal substructure\\n                A[y][x] = A[y][x] + min_prev\\n                \\n        \\n        # the cost of minimum falling path is the minimum value of last row\\n        return min( A[size-1] )\\n        \\n        \\n```\n```\\nclass Solution:\\n    def minFallingPathSum(self, matrix: List[List[int]]) -> int:\\n        \\n        h, w = len(matrix), len(matrix[0])\\n        INF = sys.maxsize\\n        \\n        @cache\\n        def dp(row, col):\\n            \\n            ## Base case: top row\\n            if row == 0 and 0 <= col < w:\\n                return matrix[0][col]\\n            \\n            ## Base case: out-of boundary\\n            if col < 0 or col >= w:\\n                return INF\\n            \\n            ## General case: current cost + minimal cost of neighbor on previous row\\n            return matrix[row][col] + min( dp(row-1,col+offset) for offset in (-1, 0, 1) )\\n        \\n        # ------------------------------------------------\\n        return min( dp(h-1, col) for col in range(w) )\\n```",
                "codeTag": "Java"
            },
            {
                "id": 212061,
                "title": "python-topdown-and-bottomup-with-detailed-explanation-and-algorithms",
                "content": "# https://leetcode.com/problems/minimum-falling-path-sum/description/\\n# Medium\\nimport sys\\n\\n# Input:\\nA = [[1,2,3],[4,5,6],[7,8,9]]\\nA = [[17,82],[1,-44]]\\n\\n# Algorithm: Iterative DP O(n) time and O(len(A)) space\\n 1. We create a Pad of infinity on left and right of the row, i,e including two cols to left and right\\n 2. We start from 1st index and for each A[i][j] we calc min from previous rows reachable cols i,e (j - 1), j, (j + 1)\\n 3. The technique lies in adding the min value to each cell from its reachable columns\\n 4. We update the values till the last row, then we return the min value of the last row\\n```\\nfrom collections import Counter\\nfrom copy import deepcopy\\n\\ndef minFallingPathSumIterativeDP(array):\\n    for i in range(len(array)):\\n        array[i] = [sys.maxsize] + array[i] + [sys.maxsize] # Pad infinity to left and right of array\\n\\n    for i in range(1, len(array)): # For rows 1->n, add reachable min value from prev row\\n        for j in range(1, len(array[0]) - 1): # Gracefully handle js indices\\n            array[i][j] += min(array[i - 1][j - 1],\\n                               array[i - 1][j],\\n                               array[i - 1][j + 1])\\n    return min(array[-1])\\n\\narray = deepcopy(A) # Creates a copy without reference\\nprint(minFallingPathSumIterativeDP(array))\\n```\\n# Algorithm: Recursive DP O(n * m) time\\n 0. Since the value depends on i and j, dp is 2D, we use it to store intermediate to avoid recomputations\\n 1. If reached the end of the array (in either the row or col) then, return 0\\n 2. Add the current value with minValue in next row\\n 3. Return the value as the result\\n```\\nfrom collections import Counter\\n\\ndef minFallingPathSumDP(A):\\n    def findFallingPathSum(A, i, j):\\n        if i == len(A): return 0 # If reached end of matrix, return 0\\n\\n        if (i, j) in dp: return dp[(i, j)] # If we have the value computed before return the value\\n        elif (0 <= j < len(A[0])): # If j is in range of columns and we haven\\'t computed before\\n            dp[(i, j)] = A[i][j] + min(findFallingPathSum(A, i + 1, j - 1), # Left element of j in next row\\n                                       findFallingPathSum(A, i + 1, j), # Same element as j in next row\\n                                       findFallingPathSum(A, i + 1, j + 1)) # Right element of j in next row\\n            return dp[(i, j)] # Return the computed value\\n        else: return sys.maxsize  j is out of range, so return infinity\\n\\n    dp = Counter()  DP is a lookup table\\n    return min([findFallingPathSum(A, 0, j) for j in range(len(A[0]))])\\n\\nprint(minFallingPathSumDP(A))\\n```\\n# Algorithm: Basic Recursive Solution O(3^n) time and O(n) stack space\\n 1. If reached the end of the array (in either the row or col) then, return 0\\n 2. Add the current value with minValue in next row\\n 3. Return the value as the result\\n```\\ndef minFallingPathSum(A):\\n    def findFallingPathSum(A, i, j):\\n        if i == len(A): return 0 # If reached end of matrix, return 0\\n\\n        if (0 <= j < len(A[0])): # If j is in range of columns\\n            return A[i][j] + min(findFallingPathSum(A, i + 1, j - 1), # Left element of j in next row\\n                                 findFallingPathSum(A, i + 1, j), # Same element as j in next row\\n                                 findFallingPathSum(A, i + 1, j + 1)) # Right element of j in next row\\n        else: return sys.maxsize\\n\\n    return min(findFallingPathSum(A, 0, j) for j in range(len(A[0])))\\n\\nprint(minFallingPathSum(A))\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import Counter\\nfrom copy import deepcopy\\n\\ndef minFallingPathSumIterativeDP(array):\\n    for i in range(len(array)):\\n        array[i] = [sys.maxsize] + array[i] + [sys.maxsize] # Pad infinity to left and right of array\\n\\n    for i in range(1, len(array)): # For rows 1->n, add reachable min value from prev row\\n        for j in range(1, len(array[0]) - 1): # Gracefully handle js indices\\n            array[i][j] += min(array[i - 1][j - 1],\\n                               array[i - 1][j],\\n                               array[i - 1][j + 1])\\n    return min(array[-1])\\n\\narray = deepcopy(A) # Creates a copy without reference\\nprint(minFallingPathSumIterativeDP(array))\\n```\n```\\nfrom collections import Counter\\n\\ndef minFallingPathSumDP(A):\\n    def findFallingPathSum(A, i, j):\\n        if i == len(A): return 0 # If reached end of matrix, return 0\\n\\n        if (i, j) in dp: return dp[(i, j)] # If we have the value computed before return the value\\n        elif (0 <= j < len(A[0])): # If j is in range of columns and we haven\\'t computed before\\n            dp[(i, j)] = A[i][j] + min(findFallingPathSum(A, i + 1, j - 1), # Left element of j in next row\\n                                       findFallingPathSum(A, i + 1, j), # Same element as j in next row\\n                                       findFallingPathSum(A, i + 1, j + 1)) # Right element of j in next row\\n            return dp[(i, j)] # Return the computed value\\n        else: return sys.maxsize  j is out of range, so return infinity\\n\\n    dp = Counter()  DP is a lookup table\\n    return min([findFallingPathSum(A, 0, j) for j in range(len(A[0]))])\\n\\nprint(minFallingPathSumDP(A))\\n```\n```\\ndef minFallingPathSum(A):\\n    def findFallingPathSum(A, i, j):\\n        if i == len(A): return 0 # If reached end of matrix, return 0\\n\\n        if (0 <= j < len(A[0])): # If j is in range of columns\\n            return A[i][j] + min(findFallingPathSum(A, i + 1, j - 1), # Left element of j in next row\\n                                 findFallingPathSum(A, i + 1, j), # Same element as j in next row\\n                                 findFallingPathSum(A, i + 1, j + 1)) # Right element of j in next row\\n        else: return sys.maxsize\\n\\n    return min(findFallingPathSum(A, 0, j) for j in range(len(A[0])))\\n\\nprint(minFallingPathSum(A))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 186677,
                "title": "java-simple-dp",
                "content": "```\\nclass Solution {\\n    public int mini(int[][] A, int i, int j){\\n        int a = (j > 0 ) ? A[i-1][j-1] : Integer.MAX_VALUE; \\n        int b = A[i-1][j]; \\n        int c = (j < A.length-1) ? A[i-1][j+1] : Integer.MAX_VALUE; \\n        return Math.min(a, Math.min(b,c)); \\n    }\\n    public int minFallingPathSum(int[][] A) {\\n        int n = A.length; \\n        int[][] dp = new int[n][n]; \\n        for(int i = 0; i < n; ++i ) dp[0][i] = A[0][i]; \\n        for(int i = 1; i < n; ++i){\\n            for(int j = 0; j < n; ++j){\\n                dp[i][j] = A[i][j] + mini(dp, i, j);\\n            }\\n        }\\n        int min = Integer.MAX_VALUE; \\n        for(int i = 0; i < n ; ++i) min = Math.min(min, dp[n-1][i]);\\n        return min; \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int mini(int[][] A, int i, int j){\\n        int a = (j > 0 ) ? A[i-1][j-1] : Integer.MAX_VALUE; \\n        int b = A[i-1][j]; \\n        int c = (j < A.length-1) ? A[i-1][j+1] : Integer.MAX_VALUE; \\n        return Math.min(a, Math.min(b,c)); \\n    }\\n    public int minFallingPathSum(int[][] A) {\\n        int n = A.length; \\n        int[][] dp = new int[n][n]; \\n        for(int i = 0; i < n; ++i ) dp[0][i] = A[0][i]; \\n        for(int i = 1; i < n; ++i){\\n            for(int j = 0; j < n; ++j){\\n                dp[i][j] = A[i][j] + mini(dp, i, j);\\n            }\\n        }\\n        int min = Integer.MAX_VALUE; \\n        for(int i = 0; i < n ; ++i) min = Math.min(min, dp[n-1][i]);\\n        return min; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3751797,
                "title": "three-approaches-memoization-tabulation-space-optimization-complexity-analysis",
                "content": "This problem is a typical Dynamic Programming Problem. Although most of the DP problems can be solved using Memoization, but this problem has updated an edge case, which gives TLE when using memoization, therefore we need to further optimize it. \\n\\nHere\\'s the code for your reference:\\n```\\nclass Solution {\\npublic:\\n    \\n//         int helper(int i, int j, vector<vector<int>>& matrix, vector<vector<int>>& dp){\\n//             if(i<0 || j<0 || i>=matrix.size() || j>=matrix[0].size()) return 1e9;\\n//             if(i==0) return matrix[i][j];\\n//             if(dp[i][j]!=-1) return dp[i][j];\\n//             return dp[i][j] = matrix[i][j] + min( helper(i-1, j, matrix, dp),\\n//                 min(helper(i-1, j-1, matrix, dp), helper(i-1, j+1, matrix, dp)));\\n\\n//         }\\n    \\n    /*\\n    // Memoization - TLE\\n    // T.C.: O(n x m)\\n    // S.C.: O(n x m) + O(n x m) - stack + dp\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        vector<vector<int>>dp(n, vector<int>(m, -1));\\n        int res = 1e9;\\n        for(int col = 0; col<m; col++){\\n            res = min( helper(n-1, col, matrix, dp), res);\\n        }\\n        return res;\\n    }\\n    */\\n    \\n    /*\\n    // Tabulation\\n    // T.C.: O(n x m)\\n    // S.C.: O(n x m) - dp\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        vector<vector<int>>dp(n, vector<int>(m, -1));\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(i==0){\\n                    dp[i][j] = matrix[i][j];\\n                    continue;\\n                }\\n                int top = INT_MAX, leftd = INT_MAX, rightd = INT_MAX;\\n                if(i-1 >= 0) top = dp[i-1][j];\\n                if(i-1 >= 0 && j-1>=0) leftd = dp[i-1][j-1];\\n                if(i-1 >= 0 && j+1<m) rightd = dp[i-1][j+1];\\n                dp[i][j] = matrix[i][j] + min(top, min(leftd, rightd));\\n                \\n            }\\n        }\\n        int res = INT_MAX;\\n        for(int col = 0; col<m; col++){\\n            res = min( dp[n-1][col], res);\\n        }\\n        return res;\\n    }\\n    */\\n    \\n    \\n    // Space Optimization\\n    // T.C.: O(n x m)\\n    // S.C.: O(m + m) == O(m) - prev + curr\\n    \\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        vector<int> prev(m, 0);\\n        \\n        for(int i=0;i<n;i++){\\n            vector<int> curr(m, 0);\\n            for(int j=0;j<m;j++){\\n                if(i==0){\\n                    curr[j] = matrix[i][j];\\n                    continue;\\n                }\\n                int top = INT_MAX, leftd = INT_MAX, rightd = INT_MAX;\\n                if(i-1 >= 0) top = prev[j];\\n                if(i-1 >= 0 && j-1>=0) leftd = prev[j-1];\\n                if(i-1 >= 0 && j+1<m) rightd = prev[j+1];\\n                curr[j] = matrix[i][j] + min(top, min(leftd, rightd));\\n                \\n            }\\n            prev = curr;\\n        }\\n        int res = INT_MAX;\\n        for(auto x: prev){\\n            res = min(x, res);\\n        }\\n        \\n        return res;\\n        \\n    }    \\n    \\n};\\n```\\n\\n**P.S: Do give it an upvote if this helped :)\\nIn case of any queries or suggestions, feel free to comment below!**",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n//         int helper(int i, int j, vector<vector<int>>& matrix, vector<vector<int>>& dp){\\n//             if(i<0 || j<0 || i>=matrix.size() || j>=matrix[0].size()) return 1e9;\\n//             if(i==0) return matrix[i][j];\\n//             if(dp[i][j]!=-1) return dp[i][j];\\n//             return dp[i][j] = matrix[i][j] + min( helper(i-1, j, matrix, dp),\\n//                 min(helper(i-1, j-1, matrix, dp), helper(i-1, j+1, matrix, dp)));\\n\\n//         }\\n    \\n    /*\\n    // Memoization - TLE\\n    // T.C.: O(n x m)\\n    // S.C.: O(n x m) + O(n x m) - stack + dp\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        vector<vector<int>>dp(n, vector<int>(m, -1));\\n        int res = 1e9;\\n        for(int col = 0; col<m; col++){\\n            res = min( helper(n-1, col, matrix, dp), res);\\n        }\\n        return res;\\n    }\\n    */\\n    \\n    /*\\n    // Tabulation\\n    // T.C.: O(n x m)\\n    // S.C.: O(n x m) - dp\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        vector<vector<int>>dp(n, vector<int>(m, -1));\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(i==0){\\n                    dp[i][j] = matrix[i][j];\\n                    continue;\\n                }\\n                int top = INT_MAX, leftd = INT_MAX, rightd = INT_MAX;\\n                if(i-1 >= 0) top = dp[i-1][j];\\n                if(i-1 >= 0 && j-1>=0) leftd = dp[i-1][j-1];\\n                if(i-1 >= 0 && j+1<m) rightd = dp[i-1][j+1];\\n                dp[i][j] = matrix[i][j] + min(top, min(leftd, rightd));\\n                \\n            }\\n        }\\n        int res = INT_MAX;\\n        for(int col = 0; col<m; col++){\\n            res = min( dp[n-1][col], res);\\n        }\\n        return res;\\n    }\\n    */\\n    \\n    \\n    // Space Optimization\\n    // T.C.: O(n x m)\\n    // S.C.: O(m + m) == O(m) - prev + curr\\n    \\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        vector<int> prev(m, 0);\\n        \\n        for(int i=0;i<n;i++){\\n            vector<int> curr(m, 0);\\n            for(int j=0;j<m;j++){\\n                if(i==0){\\n                    curr[j] = matrix[i][j];\\n                    continue;\\n                }\\n                int top = INT_MAX, leftd = INT_MAX, rightd = INT_MAX;\\n                if(i-1 >= 0) top = prev[j];\\n                if(i-1 >= 0 && j-1>=0) leftd = prev[j-1];\\n                if(i-1 >= 0 && j+1<m) rightd = prev[j+1];\\n                curr[j] = matrix[i][j] + min(top, min(leftd, rightd));\\n                \\n            }\\n            prev = curr;\\n        }\\n        int res = INT_MAX;\\n        for(auto x: prev){\\n            res = min(x, res);\\n        }\\n        \\n        return res;\\n        \\n    }    \\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3567378,
                "title": "memoization-striver-s-approach",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int memo(int i,int j,vector<vector<int>> &matrix,vector<vector<int>> &dp){\\n        if(j<0 || j>(matrix.size()-1))return 1e9;\\n        if(i==0) return matrix[i][j];\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int up=memo(i-1,j,matrix,dp);\\n        int ld=memo(i-1,j-1,matrix,dp);\\n        int rd=memo(i-1,j+1,matrix,dp);\\n        return dp[i][j]=matrix[i][j]+min(up,min(ld,rd));\\n    }\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n        int mini=INT_MAX;\\n        for(int i=0;i<n;i++){\\n            vector<vector<int>> dp(n,vector<int>(n,-1));\\n            int sum=memo(n-1,i,matrix,dp);\\n            mini=min(mini,sum);\\n        }\\n        return mini;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int memo(int i,int j,vector<vector<int>> &matrix,vector<vector<int>> &dp){\\n        if(j<0 || j>(matrix.size()-1))return 1e9;\\n        if(i==0) return matrix[i][j];\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int up=memo(i-1,j,matrix,dp);\\n        int ld=memo(i-1,j-1,matrix,dp);\\n        int rd=memo(i-1,j+1,matrix,dp);\\n        return dp[i][j]=matrix[i][j]+min(up,min(ld,rd));\\n    }\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n        int mini=INT_MAX;\\n        for(int i=0;i<n;i++){\\n            vector<vector<int>> dp(n,vector<int>(n,-1));\\n            int sum=memo(n-1,i,matrix,dp);\\n            mini=min(mini,sum);\\n        }\\n        return mini;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2908550,
                "title": "java-easy-dp-solution",
                "content": "# Intuition\\nWhy DP? because we can arrive at cell `A[r][c]` in multiple ways. Whenever we arrive at cell `A[r][c]` we need to calculate the minimum path from that cell onwards.\\n\\nTherefore, we have a recurring subproblem.\\n\\nWe need to know the solutions from the bottom-up so we iterate from the matrix bottom to top. The column order doesn\\'t matter.\\n\\n# Code\\n```\\n    class Solution {\\n        public int minFallingPathSum(int[][] matrix) {\\n            int n = matrix.length;\\n            int[][] dp = new int[n + 1][n + 2];\\n\\n            // The DP walls should be out-of-scope hence Integer.MAX_VALUE; They are used for code ease\\n            for (int r = 0; r < dp.length; r++) {\\n                dp[r][0] = Integer.MAX_VALUE;\\n                dp[r][dp[0].length - 1] = Integer.MAX_VALUE;\\n            }\\n\\n            for (int r = n - 1; r >= 0; r--) {\\n                for (int c = 0; c < n; c++) {\\n                    int[] moves = new int[]{dp[r + 1][c], dp[r + 1][c + 1], dp[r + 1][c + 2]};\\n                    dp[r][c + 1] = matrix[r][c] + Arrays.stream(moves).min().getAsInt();\\n                }\\n            }\\n            \\n            return Arrays.stream(dp[0]).min().getAsInt();\\n\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    class Solution {\\n        public int minFallingPathSum(int[][] matrix) {\\n            int n = matrix.length;\\n            int[][] dp = new int[n + 1][n + 2];\\n\\n            // The DP walls should be out-of-scope hence Integer.MAX_VALUE; They are used for code ease\\n            for (int r = 0; r < dp.length; r++) {\\n                dp[r][0] = Integer.MAX_VALUE;\\n                dp[r][dp[0].length - 1] = Integer.MAX_VALUE;\\n            }\\n\\n            for (int r = n - 1; r >= 0; r--) {\\n                for (int c = 0; c < n; c++) {\\n                    int[] moves = new int[]{dp[r + 1][c], dp[r + 1][c + 1], dp[r + 1][c + 2]};\\n                    dp[r][c + 1] = matrix[r][c] + Arrays.stream(moves).min().getAsInt();\\n                }\\n            }\\n            \\n            return Arrays.stream(dp[0]).min().getAsInt();\\n\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2908285,
                "title": "fastest-python-solution-beats-100",
                "content": "# Approach\\ngo from bottom to top and summarizing. then return min value of first row.\\n\\n# Complexity\\n- Time complexity:   $$O(n^2)$$\\n\\n- Space complexity:   $$O(n)$$\\n\\n# Code\\n```\\nclass Solution(object):\\n    def minFallingPathSum(self, m):\\n        m = [[100000]+x+[100000] for x in m]\\n        l = len(m)\\n        for i in range(l-1, 0, -1):\\n            for j in range(1, l+1):\\n                m[i-1][j] = m[i-1][j] + min(m[i][j], m[i][j-1], m[i][j+1])\\n        return min(m[0])\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def minFallingPathSum(self, m):\\n        m = [[100000]+x+[100000] for x in m]\\n        l = len(m)\\n        for i in range(l-1, 0, -1):\\n            for j in range(1, l+1):\\n                m[i-1][j] = m[i-1][j] + min(m[i][j], m[i][j-1], m[i][j+1])\\n        return min(m[0])\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2908090,
                "title": "python-2-solutions-video-solution",
                "content": "I have explained both the approaches in this [video](https://youtu.be/mzeDdbAABpE).\\n\\nIf this is helpful, please upvote, like the video and subscribe to the channel for more such content.\\n\\nCheers\\n\\n# Memoization\\n\\n**Time**: `O(n^2)`\\n**Space**: `O(n^2)`\\n\\n```\\nclass Solution:\\n    def minFallingPathSum(self, matrix: List[List[int]]) -> int:\\n        \\n        n = len(matrix)\\n        dp = {}\\n        \\n        def dfs(i, j):\\n            if j<0 or j>=n:\\n                return inf\\n            \\n            if i==n-1:\\n                return matrix[i][j]\\n            \\n            if (i,j) in dp:\\n                return dp[(i, j)]\\n            \\n            cur = matrix[i][j]\\n            \\n            dp[(i, j)] = cur + min( dfs(i+1, j), dfs(i+1, j-1), dfs(i+1, j+1))\\n            return dp[(i, j)]\\n        \\n        ans = math.inf\\n        for j in range(n):\\n            ans = min(ans, dfs(0,j))\\n            \\n        return ans\\n```\\n\\n# Dynamic Programming\\n\\n**Time**: `O(n^2)`\\n**Space**: `O(1)`\\n\\n```\\nclass Solution:\\n    def minFallingPathSum(self, matrix: List[List[int]]) -> int:\\n        \\n        n = len(matrix)\\n        \\n        for i in reversed(range(n-1)):\\n            for j in range(n):\\n                left = inf if j==0 else matrix[i+1][j-1]\\n                right = inf if j==n-1 else matrix[i+1][j+1]\\n                down = matrix[i+1][j]\\n                \\n                matrix[i][j] += min(left, down, right)\\n                \\n        return min(matrix[0])\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minFallingPathSum(self, matrix: List[List[int]]) -> int:\\n        \\n        n = len(matrix)\\n        dp = {}\\n        \\n        def dfs(i, j):\\n            if j<0 or j>=n:\\n                return inf\\n            \\n            if i==n-1:\\n                return matrix[i][j]\\n            \\n            if (i,j) in dp:\\n                return dp[(i, j)]\\n            \\n            cur = matrix[i][j]\\n            \\n            dp[(i, j)] = cur + min( dfs(i+1, j), dfs(i+1, j-1), dfs(i+1, j+1))\\n            return dp[(i, j)]\\n        \\n        ans = math.inf\\n        for j in range(n):\\n            ans = min(ans, dfs(0,j))\\n            \\n        return ans\\n```\n```\\nclass Solution:\\n    def minFallingPathSum(self, matrix: List[List[int]]) -> int:\\n        \\n        n = len(matrix)\\n        \\n        for i in reversed(range(n-1)):\\n            for j in range(n):\\n                left = inf if j==0 else matrix[i+1][j-1]\\n                right = inf if j==n-1 else matrix[i+1][j+1]\\n                down = matrix[i+1][j]\\n                \\n                matrix[i][j] += min(left, down, right)\\n                \\n        return min(matrix[0])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2906977,
                "title": "easy-java-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int minFallingPathSum(int[][] matrix) {\\n        int n = matrix.length;\\n\\n        if(n==1) return matrix[0][0];\\n        int[][] arr = new int[n+1][n+2];\\n\\n        for (int i = 0; i < n; i++) {\\n            arr[i][0] = Integer.MAX_VALUE;\\n            arr[i][n + 1] = Integer.MAX_VALUE;\\n        }\\n        for(int i=n-1;i>=0;i--){\\n            for(int j =1;j<=n;j++){\\n                int curr = matrix[i][j-1];\\n                int min = Integer.MIN_VALUE;\\n                min = Math.min(arr[i+1][j], Math.min(arr[i+1][j+1], arr[i+1][j-1]));\\n                arr[i][j]= curr+min;\\n            }\\n        }\\n        int minSum = Integer.MAX_VALUE;\\n        for(int i=1;i<=n;i++){\\n            minSum = Math.min(minSum,arr[0][i]);\\n        }\\n        return minSum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int minFallingPathSum(int[][] matrix) {\\n        int n = matrix.length;\\n\\n        if(n==1) return matrix[0][0];\\n        int[][] arr = new int[n+1][n+2];\\n\\n        for (int i = 0; i < n; i++) {\\n            arr[i][0] = Integer.MAX_VALUE;\\n            arr[i][n + 1] = Integer.MAX_VALUE;\\n        }\\n        for(int i=n-1;i>=0;i--){\\n            for(int j =1;j<=n;j++){\\n                int curr = matrix[i][j-1];\\n                int min = Integer.MIN_VALUE;\\n                min = Math.min(arr[i+1][j], Math.min(arr[i+1][j+1], arr[i+1][j-1]));\\n                arr[i][j]= curr+min;\\n            }\\n        }\\n        int minSum = Integer.MAX_VALUE;\\n        for(int i=1;i<=n;i++){\\n            minSum = Math.min(minSum,arr[0][i]);\\n        }\\n        return minSum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2906757,
                "title": "c-dp-3-approaches-easy-and-fast",
                "content": "```\\nIf you learn/found something new please upvote \\uD83D\\uDC4D\\n```\\n---\\n# Approach1 - Memoization Method\\n\\n### Complexity\\n- Time complexity: $$O(n*m)$$\\n\\n- Space complexity: $$O(n*m)$$\\n\\n```\\nclass Solution {\\n    vector<vector<int>> dp;\\n\\n    int dfs(int row, int col, vector<vector<int>>& matrix){\\n        if(row == matrix.size()-1)\\n            return matrix[row][col];\\n        \\n        if(dp[row][col] != -1)\\n            return dp[row][col];\\n\\n        int ans = dfs(row+1, col, matrix);\\n        if(col > 0)\\n            ans = min(ans, dfs(row+1, col-1, matrix));\\n        if(col < matrix[0].size()-1)\\n            ans = min(ans, dfs(row+1, col+1, matrix));\\n\\n        dp[row][col] = ans + matrix[row][col];\\n        return dp[row][col];\\n    }\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int minSum = INT_MAX;\\n\\n        int n = matrix.size(), m = matrix[0].size();\\n        dp = vector<vector<int>>(n, vector<int>(m, -1));\\n\\n        for(int i = 0; i<m; i++){\\n            minSum = min(minSum, dfs(0, i, matrix));\\n        }\\n\\n        return minSum;\\n    }\\n};\\n```\\n\\n---\\n\\n# Approach2 - Tabulation Method\\n\\n### Approach\\nStarted from bottom most row and found the minimum sum for each element. Then progressively done the same thing for each upper row. And searched for minimum sum that will be our answer.\\n\\n### Complexity\\n- Time complexity: $$O(n*m)$$\\n\\n- Space complexity: $$O(n*m)$$ ----- [Specific: $$O(3*n*m)$$]\\n\\n```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int minSum = INT_MAX;\\n\\n        int n = matrix.size(), m = matrix[0].size();\\n        vector<vector<int>> dp(n, vector<int>(m, INT_MAX));\\n\\n        for(int j = 0; j<m; j++)\\n            dp[n-1][j] = matrix[n-1][j];\\n\\n        for(int i = n-2; i>=0; i--){\\n            for(int j = 0; j<m; j++){\\n\\n                for(int y = -1; y<=1; y++){\\n                    if(j+y >= 0 && j+y < m)\\n                        dp[i][j] = min(dp[i][j], dp[i+1][j+y]);\\n                }\\n\\n                dp[i][j] += matrix[i][j];\\n            }\\n        }\\n\\n        for(int j = 0; j<m; j++)\\n            minSum = min(minSum, dp[0][j]);\\n\\n        return minSum;\\n    }\\n};\\n```\\n---\\n\\n# Approach3 - Space Optimised Tabulation Method\\n\\n### Approach\\nStarted from bottom most row and found the minimum sum for each element. Then progressively done the same thing for each upper row. And searched for minimum sum that will be our answer.\\n[Same as Approach 2 - Only replaced 2-D dp matrix with 1D dp array]\\n\\n### Complexity\\n- Time complexity: $$O(n*m)$$\\n\\n- Space complexity: $$O(n)$$ ----- [Specific: $$O(2*n)$$]\\n\\n```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        \\n        vector<int> prev(n, 0), curr(n, 0);\\n\\n        int sum = INT_MAX;\\n        for(int i = 0; i<n; i++){\\n            for(int j = 0; j<n; j++){\\n                curr[j] = matrix[i][j];\\n                if(i != 0){\\n                    int prevSum = prev[j];\\n                    if(j > 0)\\n                        prevSum = min(prevSum, prev[j-1]);\\n                    if(j < n-1)\\n                        prevSum = min(prevSum, prev[j+1]);\\n\\n                    curr[j] += prevSum;\\n                }\\n                \\n                if(i == n-1)\\n                    sum = min(sum, curr[j]);\\n            }\\n            prev = curr;\\n        }\\n\\n        return sum;\\n    }\\n};\\n```\\n---\\n\\n```\\nIf you learn/found something new please upvote \\uD83D\\uDC4D\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization",
                    "Matrix"
                ],
                "code": "```\\nIf you learn/found something new please upvote \\uD83D\\uDC4D\\n```\n```\\nclass Solution {\\n    vector<vector<int>> dp;\\n\\n    int dfs(int row, int col, vector<vector<int>>& matrix){\\n        if(row == matrix.size()-1)\\n            return matrix[row][col];\\n        \\n        if(dp[row][col] != -1)\\n            return dp[row][col];\\n\\n        int ans = dfs(row+1, col, matrix);\\n        if(col > 0)\\n            ans = min(ans, dfs(row+1, col-1, matrix));\\n        if(col < matrix[0].size()-1)\\n            ans = min(ans, dfs(row+1, col+1, matrix));\\n\\n        dp[row][col] = ans + matrix[row][col];\\n        return dp[row][col];\\n    }\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int minSum = INT_MAX;\\n\\n        int n = matrix.size(), m = matrix[0].size();\\n        dp = vector<vector<int>>(n, vector<int>(m, -1));\\n\\n        for(int i = 0; i<m; i++){\\n            minSum = min(minSum, dfs(0, i, matrix));\\n        }\\n\\n        return minSum;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int minSum = INT_MAX;\\n\\n        int n = matrix.size(), m = matrix[0].size();\\n        vector<vector<int>> dp(n, vector<int>(m, INT_MAX));\\n\\n        for(int j = 0; j<m; j++)\\n            dp[n-1][j] = matrix[n-1][j];\\n\\n        for(int i = n-2; i>=0; i--){\\n            for(int j = 0; j<m; j++){\\n\\n                for(int y = -1; y<=1; y++){\\n                    if(j+y >= 0 && j+y < m)\\n                        dp[i][j] = min(dp[i][j], dp[i+1][j+y]);\\n                }\\n\\n                dp[i][j] += matrix[i][j];\\n            }\\n        }\\n\\n        for(int j = 0; j<m; j++)\\n            minSum = min(minSum, dp[0][j]);\\n\\n        return minSum;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        \\n        vector<int> prev(n, 0), curr(n, 0);\\n\\n        int sum = INT_MAX;\\n        for(int i = 0; i<n; i++){\\n            for(int j = 0; j<n; j++){\\n                curr[j] = matrix[i][j];\\n                if(i != 0){\\n                    int prevSum = prev[j];\\n                    if(j > 0)\\n                        prevSum = min(prevSum, prev[j-1]);\\n                    if(j < n-1)\\n                        prevSum = min(prevSum, prev[j+1]);\\n\\n                    curr[j] += prevSum;\\n                }\\n                \\n                if(i == n-1)\\n                    sum = min(sum, curr[j]);\\n            }\\n            prev = curr;\\n        }\\n\\n        return sum;\\n    }\\n};\\n```\n```\\nIf you learn/found something new please upvote \\uD83D\\uDC4D\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2906597,
                "title": "java-easiest-dp",
                "content": "\\n```\\nclass Solution {\\n    public int minFallingPathSum(int[][] matrix) {\\n        int n = matrix.length;\\n        int minSum = Integer.MAX_VALUE;\\n\\n        if(n == 1) {\\n            return matrix[0][0];\\n        }\\n\\n        for(int i = 1; i<n; i++) {\\n            for(int j = 0; j<n; j++) {\\n                int minTop = matrix[i-1][j];\\n                if(j>0) {\\n                    minTop = Math.min(minTop, matrix[i-1][j-1]);\\n                } if(j<n-1) {\\n                    minTop = Math.min(minTop, matrix[i-1][j+1]);\\n                }\\n                \\n                matrix[i][j] += minTop;\\n                if(i == n-1) {\\n                    minSum = Math.min(minSum, matrix[i][j]);\\n                }\\n            }\\n        }\\n\\n        return minSum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minFallingPathSum(int[][] matrix) {\\n        int n = matrix.length;\\n        int minSum = Integer.MAX_VALUE;\\n\\n        if(n == 1) {\\n            return matrix[0][0];\\n        }\\n\\n        for(int i = 1; i<n; i++) {\\n            for(int j = 0; j<n; j++) {\\n                int minTop = matrix[i-1][j];\\n                if(j>0) {\\n                    minTop = Math.min(minTop, matrix[i-1][j-1]);\\n                } if(j<n-1) {\\n                    minTop = Math.min(minTop, matrix[i-1][j+1]);\\n                }\\n                \\n                matrix[i][j] += minTop;\\n                if(i == n-1) {\\n                    minSum = Math.min(minSum, matrix[i][j]);\\n                }\\n            }\\n        }\\n\\n        return minSum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2906418,
                "title": "minfallingpathsum-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(n*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(n*n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        // int ans=0;\\n        int n= matrix.size();\\n        int m= matrix[0].size();\\n         vector<vector<int>> dp(n,vector<int>(m,0));\\n         for(int i=0;i<m;i++){\\n           dp[0][i]=matrix[0][i];\\n         }\\n        for(int i=0;i<m;i++){\\n           cout<<dp[0][i]<<\" \";\\n         }\\n         for(int i=1;i<n;i++){\\n             for(int j=0;j<m;j++){\\n                 if(j==0){\\n                     dp[i][j]=matrix[i][j] + min(dp[i-1][j],dp[i-1][j+1]);\\n                 }\\n                 else if(j==m-1){\\n                     dp[i][j]=matrix[i][j] + min(dp[i-1][j],dp[i-1][j-1]);\\n                 }\\n                 else{\\n                     dp[i][j]=matrix[i][j] + min(dp[i-1][j-1],min(dp[i-1][j],dp[i-1][j+1]));\\n                 }\\n             }\\n              for(int k=0;k<m;k++){\\n           cout<<dp[i][k]<<\" \";\\n         }\\n         }\\n\\n         vector<int> v;\\n         for(int i=0;i<m;i++){\\n           v.push_back(dp[n-1][i]);\\n         }\\n         sort(v.begin(),v.end());\\n        return v[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        // int ans=0;\\n        int n= matrix.size();\\n        int m= matrix[0].size();\\n         vector<vector<int>> dp(n,vector<int>(m,0));\\n         for(int i=0;i<m;i++){\\n           dp[0][i]=matrix[0][i];\\n         }\\n        for(int i=0;i<m;i++){\\n           cout<<dp[0][i]<<\" \";\\n         }\\n         for(int i=1;i<n;i++){\\n             for(int j=0;j<m;j++){\\n                 if(j==0){\\n                     dp[i][j]=matrix[i][j] + min(dp[i-1][j],dp[i-1][j+1]);\\n                 }\\n                 else if(j==m-1){\\n                     dp[i][j]=matrix[i][j] + min(dp[i-1][j],dp[i-1][j-1]);\\n                 }\\n                 else{\\n                     dp[i][j]=matrix[i][j] + min(dp[i-1][j-1],min(dp[i-1][j],dp[i-1][j+1]));\\n                 }\\n             }\\n              for(int k=0;k<m;k++){\\n           cout<<dp[i][k]<<\" \";\\n         }\\n         }\\n\\n         vector<int> v;\\n         for(int i=0;i<m;i++){\\n           v.push_back(dp[n-1][i]);\\n         }\\n         sort(v.begin(),v.end());\\n        return v[0];\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2906392,
                "title": "4-dp-solutions-recursion-memoization-2d-dp-1d-dp",
                "content": "# Recursion(TLE)\\n```\\nclass Solution {\\npublic:\\n    int f(int x, int y, vector<vector<int>>& mat) {\\n        if(!x) return mat[x][y];\\n        int minSum = 1e6;\\n        int currSum = mat[x][y];\\n        minSum = min(minSum, f(x - 1, y, mat));\\n        if(y - 1 >= 0) minSum = min(minSum, f(x - 1, y - 1, mat));\\n        if(y + 1 < mat.size()) minSum = min(minSum, f(x - 1, y + 1, mat));\\n        return currSum + minSum;\\n    }\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int minFallPathSum = 1e6;\\n        int n = matrix.size();\\n        for(int j = n - 1; j >= 0; j--) {\\n            minFallPathSum = min(minFallPathSum, f(n - 1, j, matrix));\\n        }\\n        return minFallPathSum;\\n    }\\n};\\n```\\n# Memoization\\n```\\nclass Solution {\\npublic:\\n    int f(int x, int y, vector<vector<int>>& mat, vector<vector<int>>& dp) {\\n        if(!x) return mat[x][y];\\n        if(dp[x][y] != 1e6) return dp[x][y];\\n        int minSum = 1e6;\\n        int currSum = mat[x][y];\\n        minSum = min(minSum, f(x - 1, y, mat, dp));\\n        if(y - 1 >= 0) minSum = min(minSum, f(x - 1, y - 1, mat, dp));\\n        if(y + 1 < mat.size()) minSum = min(minSum, f(x - 1, y + 1, mat, dp));\\n        return dp[x][y] = currSum + minSum;\\n    }\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int minFallPathSum = 1e6;\\n        int n = matrix.size();\\n        vector<vector<int>> dp(n, vector<int>(n, 1e6));\\n        for(int j = n - 1; j >= 0; j--) {\\n            minFallPathSum = min(minFallPathSum, f(n - 1, j, matrix, dp));\\n        }\\n        return minFallPathSum;\\n    }\\n};\\n```\\n# 2D DP\\n```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        vector<vector<int>> dp(n, vector<int>(n, 1e6));\\n        for(int j = 0; j < n; j++) {\\n            dp[n - 1][j] = matrix[n - 1][j];\\n        }\\n        for(int i = n - 2; i >= 0; i--) {\\n            for(int j = 0; j < n; j++) {\\n                int minSum = dp[i + 1][j];\\n                if(j - 1 >= 0) minSum = min(minSum, dp[i + 1][j - 1]);\\n                if(j + 1 < n) minSum = min(minSum, dp[i + 1][j + 1]);\\n                dp[i][j] = matrix[i][j] + minSum;\\n            }\\n        }\\n        return *min_element(dp[0].begin(), dp[0].end());\\n    }\\n};\\n```\\n# 1D DP\\n```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        vector<int> prev(n, 0), curr(n, 0);\\n        for(int j = 0; j < n; j++) {\\n            prev[j] = matrix[n - 1][j];\\n        }\\n        for(int i = n - 2; i >= 0; i--) {\\n            for(int j = 0; j < n; j++) {\\n                int minSum = prev[j];\\n                if(j - 1 >= 0) minSum = min(minSum, prev[j - 1]);\\n                if(j + 1 < n) minSum = min(minSum, prev[j + 1]);\\n                curr[j] = matrix[i][j] + minSum;\\n            }\\n            prev = curr;\\n        }\\n        return *min_element(prev.begin(), prev.end());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int f(int x, int y, vector<vector<int>>& mat) {\\n        if(!x) return mat[x][y];\\n        int minSum = 1e6;\\n        int currSum = mat[x][y];\\n        minSum = min(minSum, f(x - 1, y, mat));\\n        if(y - 1 >= 0) minSum = min(minSum, f(x - 1, y - 1, mat));\\n        if(y + 1 < mat.size()) minSum = min(minSum, f(x - 1, y + 1, mat));\\n        return currSum + minSum;\\n    }\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int minFallPathSum = 1e6;\\n        int n = matrix.size();\\n        for(int j = n - 1; j >= 0; j--) {\\n            minFallPathSum = min(minFallPathSum, f(n - 1, j, matrix));\\n        }\\n        return minFallPathSum;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int f(int x, int y, vector<vector<int>>& mat, vector<vector<int>>& dp) {\\n        if(!x) return mat[x][y];\\n        if(dp[x][y] != 1e6) return dp[x][y];\\n        int minSum = 1e6;\\n        int currSum = mat[x][y];\\n        minSum = min(minSum, f(x - 1, y, mat, dp));\\n        if(y - 1 >= 0) minSum = min(minSum, f(x - 1, y - 1, mat, dp));\\n        if(y + 1 < mat.size()) minSum = min(minSum, f(x - 1, y + 1, mat, dp));\\n        return dp[x][y] = currSum + minSum;\\n    }\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int minFallPathSum = 1e6;\\n        int n = matrix.size();\\n        vector<vector<int>> dp(n, vector<int>(n, 1e6));\\n        for(int j = n - 1; j >= 0; j--) {\\n            minFallPathSum = min(minFallPathSum, f(n - 1, j, matrix, dp));\\n        }\\n        return minFallPathSum;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        vector<vector<int>> dp(n, vector<int>(n, 1e6));\\n        for(int j = 0; j < n; j++) {\\n            dp[n - 1][j] = matrix[n - 1][j];\\n        }\\n        for(int i = n - 2; i >= 0; i--) {\\n            for(int j = 0; j < n; j++) {\\n                int minSum = dp[i + 1][j];\\n                if(j - 1 >= 0) minSum = min(minSum, dp[i + 1][j - 1]);\\n                if(j + 1 < n) minSum = min(minSum, dp[i + 1][j + 1]);\\n                dp[i][j] = matrix[i][j] + minSum;\\n            }\\n        }\\n        return *min_element(dp[0].begin(), dp[0].end());\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        vector<int> prev(n, 0), curr(n, 0);\\n        for(int j = 0; j < n; j++) {\\n            prev[j] = matrix[n - 1][j];\\n        }\\n        for(int i = n - 2; i >= 0; i--) {\\n            for(int j = 0; j < n; j++) {\\n                int minSum = prev[j];\\n                if(j - 1 >= 0) minSum = min(minSum, prev[j - 1]);\\n                if(j + 1 < n) minSum = min(minSum, prev[j + 1]);\\n                curr[j] = matrix[i][j] + minSum;\\n            }\\n            prev = curr;\\n        }\\n        return *min_element(prev.begin(), prev.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2906214,
                "title": "c-begineerfriendly-easy-understanding-dp-video-solution",
                "content": "# Intuition and Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**C++ Clear Explaination ,Please support if you find it usefull. Can give me feedback in comment for improvement.,will be very thankfull.**\\nhttps://www.youtube.com/watch?v=GdbbIeLKwZM/\\n\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n int minFallingPathSum(vector<vector<int>>& matrix) {\\n int n = matrix.size();\\n        int m = matrix[0].size();\\n// If only one row. return minimum ..\\n        if(n == 1) return *min_element(matrix[0].begin(),matrix[0].end());\\n\\n// Otherwise traverse the entire matrix and update it.\\n        for(int i=1;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                    if(j == 0){\\n                        matrix[i][j] = matrix[i][j]+min(matrix[i-1][j],matrix[i-1][j+1]);\\n\\n                    }else if(j == m-1){\\n                        matrix[i][j] = matrix[i][j]+min(matrix[i-1][j],matrix[i-1][j-1]);\\n                    }else{\\n                        matrix[i][j] = matrix[i][j]+min(matrix[i-1][j],min(matrix[i-1][j+1],matrix[i-1][j-1]));\\n                    }\\n                }\\n            }\\n\\n// Return the minimum out of last elements.\\n        return *min_element(matrix[n-1].begin(),matrix[n-1].end());\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Backtracking",
                    "Greedy",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n int minFallingPathSum(vector<vector<int>>& matrix) {\\n int n = matrix.size();\\n        int m = matrix[0].size();\\n// If only one row. return minimum ..\\n        if(n == 1) return *min_element(matrix[0].begin(),matrix[0].end());\\n\\n// Otherwise traverse the entire matrix and update it.\\n        for(int i=1;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                    if(j == 0){\\n                        matrix[i][j] = matrix[i][j]+min(matrix[i-1][j],matrix[i-1][j+1]);\\n\\n                    }else if(j == m-1){\\n                        matrix[i][j] = matrix[i][j]+min(matrix[i-1][j],matrix[i-1][j-1]);\\n                    }else{\\n                        matrix[i][j] = matrix[i][j]+min(matrix[i-1][j],min(matrix[i-1][j+1],matrix[i-1][j-1]));\\n                    }\\n                }\\n            }\\n\\n// Return the minimum out of last elements.\\n        return *min_element(matrix[n-1].begin(),matrix[n-1].end());\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2830529,
                "title": "rust-iterators-100",
                "content": "# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nimpl Solution {\\n    pub fn min_falling_path_sum(matrix: Vec<Vec<i32>>) -> i32 {\\n        let len = matrix[0].len();\\n        *matrix\\n            .into_iter()\\n            .rev()\\n            .reduce(|acc, mut row| {\\n                for (i, x) in row.iter_mut().enumerate() {\\n                    *x += acc[i].min(acc[(len - 1).min(i + 1)].min(acc[i.min(i - 1)]));\\n                }\\n                row\\n            })\\n            .unwrap()\\n            .iter()\\n            .min()\\n            .unwrap()\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn min_falling_path_sum(matrix: Vec<Vec<i32>>) -> i32 {\\n        let len = matrix[0].len();\\n        *matrix\\n            .into_iter()\\n            .rev()\\n            .reduce(|acc, mut row| {\\n                for (i, x) in row.iter_mut().enumerate() {\\n                    *x += acc[i].min(acc[(len - 1).min(i + 1)].min(acc[i.min(i - 1)]));\\n                }\\n                row\\n            })\\n            .unwrap()\\n            .iter()\\n            .min()\\n            .unwrap()\\n    }\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2764325,
                "title": "c-easy-bottom-up-o-n-2",
                "content": "\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach -> Bottom up\\n<!-- Describe your approach to solving the problem. -->\\n\\n- Time complexity: O(m*m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int m = matrix.size();\\n        for(int i=1; i<m; i++){\\n            for(int j=0; j<m; j++){\\n                if(j==0)\\n                    matrix[i][j] += min(matrix[i-1][j], matrix[i-1][j+1]);\\n                else if(j==m-1)\\n                    matrix[i][j] += min(matrix[i-1][j-1], matrix[i-1][j]);\\n                else if(0<j<m-1)\\n                    matrix[i][j] += min(matrix[i-1][j-1], min(matrix[i-1][j], matrix[i-1][j+1]));\\n            }\\n        }\\n        return *min_element(matrix[m-1].begin(), matrix[m-1].end());\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int m = matrix.size();\\n        for(int i=1; i<m; i++){\\n            for(int j=0; j<m; j++){\\n                if(j==0)\\n                    matrix[i][j] += min(matrix[i-1][j], matrix[i-1][j+1]);\\n                else if(j==m-1)\\n                    matrix[i][j] += min(matrix[i-1][j-1], matrix[i-1][j]);\\n                else if(0<j<m-1)\\n                    matrix[i][j] += min(matrix[i-1][j-1], min(matrix[i-1][j], matrix[i-1][j+1]));\\n            }\\n        }\\n        return *min_element(matrix[m-1].begin(), matrix[m-1].end());\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2686717,
                "title": "python-dp-solution-memoization-tabulation-spaceoptimization",
                "content": "```\\n# Memoization Solution -->>>>>\\nclass Solution:\\n    def minFallingPathSum(self, matrix: List[List[int]]) -> int:\\n        def dfs(arr,i,j,dp):\\n\\n\\n            if j<0 or j>=len(arr[0]):\\n                return 1e9\\n            if i==0:\\n                return arr[0][j]\\n            if dp[i][j] != -1:\\n                return dp[i][j]\\n            up=dfs(arr,i-1,j,dp)+arr[i][j]\\n\\n            left=dfs(arr,i-1,j-1,dp)+arr[i][j]\\n\\n            right=dfs(arr,i-1,j+1,dp)+arr[i][j]\\n\\n            dp[i][j]=min(up,left,right)\\n            return dp[i][j]\\n\\n\\n        dp=[[-1]*len(matrix[0]) for i in range(len(matrix))]\\n        mini=999999\\n        for i in range(len(matrix[0])):\\n            mini=min(mini,dfs(matrix,len(matrix)-1,i,dp))\\n        return mini\\n        \\n```\\n```\\n# Tabulation Solution -->>>>>>>\\nclass Solution:\\n    def minFallingPathSum(self, matrix: List[List[int]]) -> int:\\n        dp=[[-1]*len(matrix[0]) for i in range(len(matrix))]\\n        n=len(matrix)\\n        m=len(matrix[0])\\n        for i in range(m):\\n            dp[0][i]=matrix[0][i]\\n        for i in range(1,n):\\n            for j in range(m):\\n                up=dp[i-1][j]+matrix[i][j]\\n                if j-1>=0:\\n                    left=dp[i-1][j-1]+matrix[i][j]\\n                else:\\n                    left=1e9+matrix[i][j]\\n\\n                if j+1<m:\\n                    right=dp[i-1][j+1]+matrix[i][j]\\n                else:\\n                    right=1e9+matrix[i][j]\\n                dp[i][j]=min(up,left,right)\\n        return min(dp[n-1])\\n```\\n```\\n# SpaceOptimization -->>>>>>>>\\nclass Solution:\\n    def minFallingPathSum(self, matrix: List[List[int]]) -> int:\\n        n=len(matrix)\\n        m=len(matrix[0])\\n        prev=[0]*m\\n        for i in range(m):\\n            prev[i]=matrix[0][i]\\n        for i in range(1,n):\\n            curr=[0]*m\\n            for j in range(m):\\n                up=prev[j]+matrix[i][j]\\n                if j-1>=0:\\n                    left=prev[j-1]+matrix[i][j]\\n                else:\\n                    left=1e9+matrix[i][j]\\n\\n                if j+1<m:\\n                    right=prev[j+1]+matrix[i][j]\\n                else:\\n                    right=1e9+matrix[i][j]\\n                curr[j]=min(up,left,right)\\n            prev=curr\\n        return min(prev)\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\n# Memoization Solution -->>>>>\\nclass Solution:\\n    def minFallingPathSum(self, matrix: List[List[int]]) -> int:\\n        def dfs(arr,i,j,dp):\\n\\n\\n            if j<0 or j>=len(arr[0]):\\n                return 1e9\\n            if i==0:\\n                return arr[0][j]\\n            if dp[i][j] != -1:\\n                return dp[i][j]\\n            up=dfs(arr,i-1,j,dp)+arr[i][j]\\n\\n            left=dfs(arr,i-1,j-1,dp)+arr[i][j]\\n\\n            right=dfs(arr,i-1,j+1,dp)+arr[i][j]\\n\\n            dp[i][j]=min(up,left,right)\\n            return dp[i][j]\\n\\n\\n        dp=[[-1]*len(matrix[0]) for i in range(len(matrix))]\\n        mini=999999\\n        for i in range(len(matrix[0])):\\n            mini=min(mini,dfs(matrix,len(matrix)-1,i,dp))\\n        return mini\\n        \\n```\n```\\n# Tabulation Solution -->>>>>>>\\nclass Solution:\\n    def minFallingPathSum(self, matrix: List[List[int]]) -> int:\\n        dp=[[-1]*len(matrix[0]) for i in range(len(matrix))]\\n        n=len(matrix)\\n        m=len(matrix[0])\\n        for i in range(m):\\n            dp[0][i]=matrix[0][i]\\n        for i in range(1,n):\\n            for j in range(m):\\n                up=dp[i-1][j]+matrix[i][j]\\n                if j-1>=0:\\n                    left=dp[i-1][j-1]+matrix[i][j]\\n                else:\\n                    left=1e9+matrix[i][j]\\n\\n                if j+1<m:\\n                    right=dp[i-1][j+1]+matrix[i][j]\\n                else:\\n                    right=1e9+matrix[i][j]\\n                dp[i][j]=min(up,left,right)\\n        return min(dp[n-1])\\n```\n```\\n# SpaceOptimization -->>>>>>>>\\nclass Solution:\\n    def minFallingPathSum(self, matrix: List[List[int]]) -> int:\\n        n=len(matrix)\\n        m=len(matrix[0])\\n        prev=[0]*m\\n        for i in range(m):\\n            prev[i]=matrix[0][i]\\n        for i in range(1,n):\\n            curr=[0]*m\\n            for j in range(m):\\n                up=prev[j]+matrix[i][j]\\n                if j-1>=0:\\n                    left=prev[j-1]+matrix[i][j]\\n                else:\\n                    left=1e9+matrix[i][j]\\n\\n                if j+1<m:\\n                    right=prev[j+1]+matrix[i][j]\\n                else:\\n                    right=1e9+matrix[i][j]\\n                curr[j]=min(up,left,right)\\n            prev=curr\\n        return min(prev)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2584949,
                "title": "java-recursion-memo-tabulation-dp-solution",
                "content": "Please UPVOTE the Solution\\n```\\nclass Solution {\\n    \\n    // Dp with Tabulation\\n    public int minFallingPathSum(int[][] matrix) {\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n        int dp[][] = new int[m][n];\\n        for(int j = 0; j < n; j++) {\\n            dp[0][j] = matrix[0][j];\\n        }\\n        for(int i = 1; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                if(j == 0) {\\n                    dp[i][j] = matrix[i][j] + Math.min(dp[i-1][j], dp[i-1][j+1]);\\n                }\\n                else if(j == n-1) {\\n                    dp[i][j] = matrix[i][j] + Math.min(dp[i-1][j], dp[i-1][j-1]);\\n                }\\n                else {\\n                    dp[i][j] = matrix[i][j] + Math.min(dp[i-1][j], Math.min(dp[i-1][j-1], dp[i-1][j+1]));\\n                }\\n            }\\n        }\\n        int res = Integer.MAX_VALUE;\\n        for(int j = 0; j < n; j++) {\\n            res = Math.min(dp[m-1][j], res);\\n        }\\n        return res;\\n    }\\n    \\n\\t\\t// Recursion with Memoization DP\\n\\t\\t// int dp[][];\\n\\t\\t// public int minFallingPathSum(int[][] matrix) {\\n\\t\\t// int res = Integer.MAX_VALUE;\\n\\t\\t// int m = matrix.length;\\n\\t\\t// int n = matrix[0].length;\\n\\t\\t// dp = new int[m][n];\\n\\t\\t// for(int row[]: dp) \\n\\t\\t// Arrays.fill(row, -200);\\n\\t\\t// for(int j = 0; j < n; j++) {\\n\\t\\t// int temp = helper(matrix.length-1, j, matrix);\\n\\t\\t// res = Math.min(res, temp);\\n\\t\\t// }\\n\\t\\t// return res;\\n\\t\\t// }\\n\\t\\t// private int helper(int i, int j, int[][] mat) {\\n\\t\\t// if(j < 0 || j >= mat.length) {\\n\\t\\t// return (int)1e9;\\n\\t\\t// }\\n\\t\\t// if(i == 0) {\\n\\t\\t// return mat[0][j];\\n\\t\\t// }\\n\\t\\t// if(dp[i][j] != -200) {\\n\\t\\t// return dp[i][j];\\n\\t\\t// }\\n\\t\\t// int up = mat[i][j] + helper(i-1, j, mat);\\n\\t\\t// int rdgu = mat[i][j] + helper(i-1, j+1, mat);\\n\\t\\t// int ldgu = mat[i][j] + helper(i-1, j-1, mat);\\n\\t\\t// return dp[i][j] = Math.min(up, Math.min(ldgu, rdgu));\\n\\t\\t// }\\n}\\n```\\nPlease UPVOTE the solution",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    \\n    // Dp with Tabulation\\n    public int minFallingPathSum(int[][] matrix) {\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n        int dp[][] = new int[m][n];\\n        for(int j = 0; j < n; j++) {\\n            dp[0][j] = matrix[0][j];\\n        }\\n        for(int i = 1; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                if(j == 0) {\\n                    dp[i][j] = matrix[i][j] + Math.min(dp[i-1][j], dp[i-1][j+1]);\\n                }\\n                else if(j == n-1) {\\n                    dp[i][j] = matrix[i][j] + Math.min(dp[i-1][j], dp[i-1][j-1]);\\n                }\\n                else {\\n                    dp[i][j] = matrix[i][j] + Math.min(dp[i-1][j], Math.min(dp[i-1][j-1], dp[i-1][j+1]));\\n                }\\n            }\\n        }\\n        int res = Integer.MAX_VALUE;\\n        for(int j = 0; j < n; j++) {\\n            res = Math.min(dp[m-1][j], res);\\n        }\\n        return res;\\n    }\\n    \\n\\t\\t// Recursion with Memoization DP\\n\\t\\t// int dp[][];\\n\\t\\t// public int minFallingPathSum(int[][] matrix) {\\n\\t\\t// int res = Integer.MAX_VALUE;\\n\\t\\t// int m = matrix.length;\\n\\t\\t// int n = matrix[0].length;\\n\\t\\t// dp = new int[m][n];\\n\\t\\t// for(int row[]: dp) \\n\\t\\t// Arrays.fill(row, -200);\\n\\t\\t// for(int j = 0; j < n; j++) {\\n\\t\\t// int temp = helper(matrix.length-1, j, matrix);\\n\\t\\t// res = Math.min(res, temp);\\n\\t\\t// }\\n\\t\\t// return res;\\n\\t\\t// }\\n\\t\\t// private int helper(int i, int j, int[][] mat) {\\n\\t\\t// if(j < 0 || j >= mat.length) {\\n\\t\\t// return (int)1e9;\\n\\t\\t// }\\n\\t\\t// if(i == 0) {\\n\\t\\t// return mat[0][j];\\n\\t\\t// }\\n\\t\\t// if(dp[i][j] != -200) {\\n\\t\\t// return dp[i][j];\\n\\t\\t// }\\n\\t\\t// int up = mat[i][j] + helper(i-1, j, mat);\\n\\t\\t// int rdgu = mat[i][j] + helper(i-1, j+1, mat);\\n\\t\\t// int ldgu = mat[i][j] + helper(i-1, j-1, mat);\\n\\t\\t// return dp[i][j] = Math.min(up, Math.min(ldgu, rdgu));\\n\\t\\t// }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2526559,
                "title": "cpp-98-99-faster-solution-space-optimized",
                "content": "\\n```\\n  int n=matrix.size();\\n        int m=matrix[0].size();\\n        int mini=1e8;\\n        vector<int>prev(m,0),cur(m,0);\\n       \\n       for(int j=0;j<m;j++)prev[j]=matrix[0][j];\\n       for(int i=1;i<n;i++){\\n           for(int j=0;j<m;j++){\\n               int  ld = matrix[i][j] ;\\n               if(j-1>=0) ld+= prev[j-1];\\n               else ld+=1e8;\\n               int  u = matrix[i][j] + prev[j];     \\n               int  rd = matrix[i][j] ;\\n               if(j+1<m) rd+= prev[j+1];\\n               else rd+=1e8;\\n               cur[j]=min(u ,min(ld,rd));\\n           }\\n           prev=cur;\\n       }\\n    \\n        for(int j=0;j<m;j++){\\n            mini= min(mini,prev[j]);\\n        }\\n        return mini;\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\n  int n=matrix.size();\\n        int m=matrix[0].size();\\n        int mini=1e8;\\n        vector<int>prev(m,0),cur(m,0);\\n       \\n       for(int j=0;j<m;j++)prev[j]=matrix[0][j];\\n       for(int i=1;i<n;i++){\\n           for(int j=0;j<m;j++){\\n               int  ld = matrix[i][j] ;\\n               if(j-1>=0) ld+= prev[j-1];\\n               else ld+=1e8;\\n               int  u = matrix[i][j] + prev[j];     \\n               int  rd = matrix[i][j] ;\\n               if(j+1<m) rd+= prev[j+1];\\n               else rd+=1e8;\\n               cur[j]=min(u ,min(ld,rd));\\n           }\\n           prev=cur;\\n       }\\n    \\n        for(int j=0;j<m;j++){\\n            mini= min(mini,prev[j]);\\n        }\\n        return mini;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2399423,
                "title": "memoization-tabulation-space-optimization-striver-s-dp",
                "content": "**upvote please it took a lot of effort**\\n\\n##### Memoization\\n```\\nint solve(int i, int j, vector<vector < int>> &matrix, vector< vector< int>> &dp)\\n        {\\n            if (j < 0 || j >= matrix[0].size())\\n            {\\n                return 1e9;\\n            }\\n            if (i == 0)\\n            {\\n                return matrix[i][j];\\n            }\\n            if (dp[i][j] != -1)\\n            {\\n                return dp[i][j];\\n            }\\n            int up = matrix[i][j] + solve(i - 1, j, matrix, dp);\\n            int leftdg = matrix[i][j] + solve(i - 1, j - 1, matrix, dp);\\n            int rightdg = matrix[i][j] + solve(i - 1, j + 1, matrix, dp);\\n            return dp[i][j] = min(up, min(leftdg, rightdg));\\n        }\\n    int minFallingPathSum(vector<vector < int>> &matrix)\\n    {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        vector<vector < int>> dp(n, vector<int> (m, -1));\\n        int mini = 1e9;\\n        for (int i = 0; i < m; i++)\\n        {\\n            mini = min(mini, solve(n - 1, i, matrix, dp));\\n        }\\n        return mini;\\n    }\\n```\\n##### Tabulation\\n```\\nint minFallingPathSum(vector<vector < int>> &matrix)\\n        {\\n\\n            int n = matrix.size();\\n            int m = matrix[0].size();\\n            vector<int> prev(m, 0), cur(m, 0);\\n            for (int i = 0; i < m; i++)\\n            {\\n                prev[i] = matrix[0][i];\\n            }\\n            for (int i = 1; i < n; i++)\\n            {\\n                for (int j = 0; j < m; j++)\\n                {\\n                    int up = matrix[i][j] + prev[j];\\n                    int ldg = 1e9, rdg = 1e9;\\n                    if (j > 0)\\n                    {\\n                        ldg = matrix[i][j] + prev[j - 1];\\n                    }\\n                    if (j < m - 1)\\n                    {\\n                        rdg = matrix[i][j] + prev[j + 1];\\n                    }\\n                    cur[j] = min(up, min(ldg, rdg));\\n                }\\n                prev = cur;\\n            }\\n            int mini = 1e9;\\n            for (int i = 0; i < m; i++)\\n            {\\n                mini = min(mini, prev[i]);\\n            }\\n            return mini;\\n        }\\n```\\n##### Space optimized\\n```\\nint minFallingPathSum(vector<vector < int>> &matrix)\\n        {\\n\\n            int n = matrix.size();\\n            int m = matrix[0].size();\\n            vector<int> prev(m, 0), cur(m, 0);\\n            for (int i = 0; i < m; i++)\\n            {\\n                prev[i] = matrix[0][i];\\n            }\\n            for (int i = 1; i < n; i++)\\n            {\\n                for (int j = 0; j < m; j++)\\n                {\\n                    int up = matrix[i][j] + prev[j];\\n                    int ldg = 1e9, rdg = 1e9;\\n                    if (j > 0)\\n                    {\\n                        ldg = matrix[i][j] + prev[j - 1];\\n                    }\\n                    if (j < m - 1)\\n                    {\\n                        rdg = matrix[i][j] + prev[j + 1];\\n                    }\\n                    cur[j] = min(up, min(ldg, rdg));\\n                }\\n                prev = cur;\\n            }\\n            int mini = 1e9;\\n            for (int i = 0; i < m; i++)\\n            {\\n                mini = min(mini, prev[i]);\\n            }\\n            return mini;\\n        }\\n```\\n\\n### if you like it then please don\\'t forget to upvote",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nint solve(int i, int j, vector<vector < int>> &matrix, vector< vector< int>> &dp)\\n        {\\n            if (j < 0 || j >= matrix[0].size())\\n            {\\n                return 1e9;\\n            }\\n            if (i == 0)\\n            {\\n                return matrix[i][j];\\n            }\\n            if (dp[i][j] != -1)\\n            {\\n                return dp[i][j];\\n            }\\n            int up = matrix[i][j] + solve(i - 1, j, matrix, dp);\\n            int leftdg = matrix[i][j] + solve(i - 1, j - 1, matrix, dp);\\n            int rightdg = matrix[i][j] + solve(i - 1, j + 1, matrix, dp);\\n            return dp[i][j] = min(up, min(leftdg, rightdg));\\n        }\\n    int minFallingPathSum(vector<vector < int>> &matrix)\\n    {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        vector<vector < int>> dp(n, vector<int> (m, -1));\\n        int mini = 1e9;\\n        for (int i = 0; i < m; i++)\\n        {\\n            mini = min(mini, solve(n - 1, i, matrix, dp));\\n        }\\n        return mini;\\n    }\\n```\n```\\nint minFallingPathSum(vector<vector < int>> &matrix)\\n        {\\n\\n            int n = matrix.size();\\n            int m = matrix[0].size();\\n            vector<int> prev(m, 0), cur(m, 0);\\n            for (int i = 0; i < m; i++)\\n            {\\n                prev[i] = matrix[0][i];\\n            }\\n            for (int i = 1; i < n; i++)\\n            {\\n                for (int j = 0; j < m; j++)\\n                {\\n                    int up = matrix[i][j] + prev[j];\\n                    int ldg = 1e9, rdg = 1e9;\\n                    if (j > 0)\\n                    {\\n                        ldg = matrix[i][j] + prev[j - 1];\\n                    }\\n                    if (j < m - 1)\\n                    {\\n                        rdg = matrix[i][j] + prev[j + 1];\\n                    }\\n                    cur[j] = min(up, min(ldg, rdg));\\n                }\\n                prev = cur;\\n            }\\n            int mini = 1e9;\\n            for (int i = 0; i < m; i++)\\n            {\\n                mini = min(mini, prev[i]);\\n            }\\n            return mini;\\n        }\\n```\n```\\nint minFallingPathSum(vector<vector < int>> &matrix)\\n        {\\n\\n            int n = matrix.size();\\n            int m = matrix[0].size();\\n            vector<int> prev(m, 0), cur(m, 0);\\n            for (int i = 0; i < m; i++)\\n            {\\n                prev[i] = matrix[0][i];\\n            }\\n            for (int i = 1; i < n; i++)\\n            {\\n                for (int j = 0; j < m; j++)\\n                {\\n                    int up = matrix[i][j] + prev[j];\\n                    int ldg = 1e9, rdg = 1e9;\\n                    if (j > 0)\\n                    {\\n                        ldg = matrix[i][j] + prev[j - 1];\\n                    }\\n                    if (j < m - 1)\\n                    {\\n                        rdg = matrix[i][j] + prev[j + 1];\\n                    }\\n                    cur[j] = min(up, min(ldg, rdg));\\n                }\\n                prev = cur;\\n            }\\n            int mini = 1e9;\\n            for (int i = 0; i < m; i++)\\n            {\\n                mini = min(mini, prev[i]);\\n            }\\n            return mini;\\n        }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1967536,
                "title": "java-consise-easy-tabulation",
                "content": "```\\nclass Solution {\\n    public int minFallingPathSum(int[][] matrix){\\n        int n = matrix.length,res = Integer.MAX_VALUE;\\n        int[][] dp = new int[n][n];\\n        for(int i=n-1;i>=0;i--)\\n            for(int j=0;j<n;j++){\\n                if(i == n-1) dp[i][j] = matrix[i][j];\\n                else if(j==0) dp[i][j] = matrix[i][j] + Math.min(dp[i+1][j],dp[i+1][j+1]);\\n                else if(j==matrix[0].length-1) dp[i][j] = matrix[i][j] + Math.min(dp[i+1][j],dp[i+1][j-1]);\\n                else dp[i][j] = matrix[i][j] + Math.min(dp[i+1][j],Math.min(dp[i+1][j+1],dp[i+1][j-1]));\\n                if(i==0) res = Math.min(res,dp[i][j]);\\n            }\\n        return res;\\n     }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minFallingPathSum(int[][] matrix){\\n        int n = matrix.length,res = Integer.MAX_VALUE;\\n        int[][] dp = new int[n][n];\\n        for(int i=n-1;i>=0;i--)\\n            for(int j=0;j<n;j++){\\n                if(i == n-1) dp[i][j] = matrix[i][j];\\n                else if(j==0) dp[i][j] = matrix[i][j] + Math.min(dp[i+1][j],dp[i+1][j+1]);\\n                else if(j==matrix[0].length-1) dp[i][j] = matrix[i][j] + Math.min(dp[i+1][j],dp[i+1][j-1]);\\n                else dp[i][j] = matrix[i][j] + Math.min(dp[i+1][j],Math.min(dp[i+1][j+1],dp[i+1][j-1]));\\n                if(i==0) res = Math.min(res,dp[i][j]);\\n            }\\n        return res;\\n     }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1871019,
                "title": "go-dp-o-n-m-time-in-place-o-1-space-clear-solution",
                "content": "O(n*m) Time, O(1) Space (In-place, using input matrix)\\n```\\nfunc minFallingPathSum(matrix [][]int) int {\\n    m, n := len(matrix), len(matrix[0])\\n    for r := 1; r < m; r++ {\\n        for c := 0; c < n; c++ {\\n            switch c {\\n                case 0:     matrix[r][c] += Min(matrix[r-1][c], matrix[r-1][c+1])\\n                case n-1:   matrix[r][c] += Min(matrix[r-1][c-1], matrix[r-1][c])\\n                default:    matrix[r][c] += Min(matrix[r-1][c-1], Min(matrix[r-1][c], matrix[r-1][c+1]))\\n            }\\n        }\\n    }\\n    min := math.MaxInt\\n    for c := 0; c < n; c++ { min = Min(min, matrix[m-1][c]) }\\n    return min\\n}\\n\\nfunc Min(a, b int) int {\\n    if a < b { return a }\\n    return b\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Dynamic Programming"
                ],
                "code": "```\\nfunc minFallingPathSum(matrix [][]int) int {\\n    m, n := len(matrix), len(matrix[0])\\n    for r := 1; r < m; r++ {\\n        for c := 0; c < n; c++ {\\n            switch c {\\n                case 0:     matrix[r][c] += Min(matrix[r-1][c], matrix[r-1][c+1])\\n                case n-1:   matrix[r][c] += Min(matrix[r-1][c-1], matrix[r-1][c])\\n                default:    matrix[r][c] += Min(matrix[r-1][c-1], Min(matrix[r-1][c], matrix[r-1][c+1]))\\n            }\\n        }\\n    }\\n    min := math.MaxInt\\n    for c := 0; c < n; c++ { min = Min(min, matrix[m-1][c]) }\\n    return min\\n}\\n\\nfunc Min(a, b int) int {\\n    if a < b { return a }\\n    return b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1807460,
                "title": "easy-dp-solution-in-java",
                "content": "```\\nclass Solution {\\n    public int minFallingPathSum(int[][] mat) {\\n        int m=mat.length;\\n        int dp[][]=new int[m][m];\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(i==0)                   //no need to calc sum in first row\\n                    dp[i][j]=mat[i][j];\\n\\t\\t\\t\\telse if(j==0)              //when in first column find the minimum number on top or top-right diagonal\\n                    dp[i][j]=mat[i][j]+Math.min(dp[i-1][j],dp[i-1][j+1]);\\n                else if(j==m-1)            //when in last column find the minimum number on top or top-left diagonal\\n                    dp[i][j]=mat[i][j]+Math.min(dp[i-1][j],dp[i-1][j-1]);\\n                else                       //find the minimum number on top or top-left diagonal or top-right diagonal\\n                    dp[i][j]=mat[i][j]+Math.min(Math.min(dp[i-1][j],dp[i-1][j-1]),dp[i-1][j+1]);\\n            }\\n        }\\n        int min=Integer.MAX_VALUE;\\n\\t\\tfor(int j=0;j<m;j++)               //find the minimum in last row\\n            min=Math.min(dp[m-1][j],min);\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int minFallingPathSum(int[][] mat) {\\n        int m=mat.length;\\n        int dp[][]=new int[m][m];\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(i==0)                   //no need to calc sum in first row\\n                    dp[i][j]=mat[i][j];\\n\\t\\t\\t\\telse if(j==0)              //when in first column find the minimum number on top or top-right diagonal\\n                    dp[i][j]=mat[i][j]+Math.min(dp[i-1][j],dp[i-1][j+1]);\\n                else if(j==m-1)            //when in last column find the minimum number on top or top-left diagonal\\n                    dp[i][j]=mat[i][j]+Math.min(dp[i-1][j],dp[i-1][j-1]);\\n                else                       //find the minimum number on top or top-left diagonal or top-right diagonal\\n                    dp[i][j]=mat[i][j]+Math.min(Math.min(dp[i-1][j],dp[i-1][j-1]),dp[i-1][j+1]);\\n            }\\n        }\\n        int min=Integer.MAX_VALUE;\\n\\t\\tfor(int j=0;j<m;j++)               //find the minimum in last row\\n            min=Math.min(dp[m-1][j],min);\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1674573,
                "title": "solution-swift-minimum-falling-path-sum-test-cases",
                "content": "```swift\\nclass Solution {\\n    func minFallingPathSum(_ matrix: [[Int]]) -> Int {\\n        let len = matrix.count, n = matrix[0].count\\n        if len <= 1 { return len == 0 ? 0 : matrix[0].min()! }\\n        var mat: [[Int]] = matrix\\n        for i in 1..<len {\\n            for j in 0..<n {\\n                var tmp = mat[i-1][j]\\n                if j + 1 < n { tmp = min(tmp, mat[i-1][j+1]) }\\n                if j - 1 >= 0 { tmp = min(tmp, mat[i-1][j-1]) }\\n                mat[i][j] += tmp\\n            }\\n        }\\n        return mat.last!.min()!\\n    }\\n}\\n```\\n\\n---\\n\\n<p>\\n<details>\\n<summary>\\n<img src=\"https://git.io/JDblm\" height=\"24\">\\n<b>TEST CASES</b>\\n</summary>\\n\\n<p><pre>\\n<b>Result:</b> Executed 2 tests, with 0 failures (0 unexpected) in 0.009 (0.011) seconds\\n</pre></p>\\n\\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    /// There are two falling paths with a minimum sum as shown.\\n    func test0() {\\n        let value = solution.minFallingPathSum([[2,1,3],[6,5,4],[7,8,9]])\\n        XCTAssertEqual(value, 13)\\n    }\\n    \\n    /// The falling path with a minimum sum is shown.\\n    func test1() {\\n        let value = solution.minFallingPathSum([[-19,57],[-40,-5]])\\n        XCTAssertEqual(value, -59)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n\\n</details>\\n</p>",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func minFallingPathSum(_ matrix: [[Int]]) -> Int {\\n        let len = matrix.count, n = matrix[0].count\\n        if len <= 1 { return len == 0 ? 0 : matrix[0].min()! }\\n        var mat: [[Int]] = matrix\\n        for i in 1..<len {\\n            for j in 0..<n {\\n                var tmp = mat[i-1][j]\\n                if j + 1 < n { tmp = min(tmp, mat[i-1][j+1]) }\\n                if j - 1 >= 0 { tmp = min(tmp, mat[i-1][j-1]) }\\n                mat[i][j] += tmp\\n            }\\n        }\\n        return mat.last!.min()!\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    /// There are two falling paths with a minimum sum as shown.\\n    func test0() {\\n        let value = solution.minFallingPathSum([[2,1,3],[6,5,4],[7,8,9]])\\n        XCTAssertEqual(value, 13)\\n    }\\n    \\n    /// The falling path with a minimum sum is shown.\\n    func test1() {\\n        let value = solution.minFallingPathSum([[-19,57],[-40,-5]])\\n        XCTAssertEqual(value, -59)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1592660,
                "title": "easy-to-understand-in-c-amazing-bottom-to-up",
                "content": "class Solution {\\npublic:\\n\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n        for(int i=n-2;i>=0;i--){\\n            for(int j=0;j<n;j++){\\n                int low=matrix[i+1][j];\\n                if(j-1>=0){\\n                    low=min(low,matrix[i+1][j-1]);\\n                }\\n                if(j+1<n){\\n                    low=min(low,matrix[i+1][j+1]);\\n                }\\n                matrix[i][j]+=low;\\n            }\\n        }\\n        int ans=matrix[0][0];\\n        for(int i=0;i<n;i++){\\n            ans=min(ans,matrix[0][i]);\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n        for(int i=n-2;i>=0;i--){\\n            for(int j=0;j<n;j++){\\n                int low=matrix[i+1][j];\\n                if(j-1>=0){\\n                    low=min(low,matrix[i+1][j-1]);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1354472,
                "title": "java-recursion-memoization-bottom-up-1ms-beats-99-62-t-c-o-n-2-s-c-o-n-2",
                "content": "\\n\\t// Recursion\\n\\t// O(n*3^n) O(n)\\n\\tpublic int minFallingPathSumRec(int[][] matrix) {\\n\\n\\t\\tint n = matrix.length, min = Integer.MAX_VALUE;\\n\\t\\tfor (int i = 0; i < n; i++)\\n\\t\\t\\tmin = Math.min(min, minFallingPathSumRecHelper(matrix, 0, i, n));\\n\\t\\treturn min;\\n\\t}\\n\\n\\t// Recursion\\n\\t// O(n*3^n) O(n)\\n\\tpublic int minFallingPathSumRecHelper(int[][] matrix, int row, int col, int n) {\\n\\n\\t\\tif (row == n)\\n\\t\\t\\treturn 0;\\n\\n\\t\\tint min = Integer.MAX_VALUE;\\n\\t\\tif (col - 1 >= 0)\\n\\t\\t\\tmin = Math.min(min, minFallingPathSumRecHelper(matrix, row + 1, col - 1, n) + matrix[row][col]);\\n\\n\\t\\tmin = Math.min(min, minFallingPathSumRecHelper(matrix, row + 1, col, n) + matrix[row][col]);\\n\\n\\t\\tif (col + 1 < n)\\n\\t\\t\\tmin = Math.min(min, minFallingPathSumRecHelper(matrix, row + 1, col + 1, n) + matrix[row][col]);\\n\\n\\t\\treturn min;\\n\\t}\\n\\n\\t// Memoization\\n\\t// O(n^2) O(n^2)\\n\\tpublic int minFallingPathSumMemo(int[][] matrix) {\\n\\n\\t\\tint n = matrix.length, min = Integer.MAX_VALUE;\\n\\t\\tInteger[][] memo = new Integer[n][n];\\n\\t\\tfor (int i = 0; i < n; i++)\\n\\t\\t\\tmin = Math.min(min, minFallingPathSumMemoHelper(matrix, 0, i, n, memo));\\n\\t\\treturn min;\\n\\t}\\n\\n\\t// Memoization\\n\\t// O(n^2) O(n^2)\\n\\tpublic int minFallingPathSumMemoHelper(int[][] matrix, int row, int col, int n, Integer[][] memo) {\\n\\n\\t\\tif (row == n)\\n\\t\\t\\treturn 0;\\n\\n\\t\\tif (memo[row][col] != null)\\n\\t\\t\\treturn memo[row][col];\\n\\n\\t\\tint min = Integer.MAX_VALUE;\\n\\t\\tif (col - 1 >= 0)\\n\\t\\t\\tmin = Math.min(min, minFallingPathSumMemoHelper(matrix, row + 1, col - 1, n, memo) + matrix[row][col]);\\n\\n\\t\\tmin = Math.min(min, minFallingPathSumMemoHelper(matrix, row + 1, col, n, memo) + matrix[row][col]);\\n\\n\\t\\tif (col + 1 < n)\\n\\t\\t\\tmin = Math.min(min, minFallingPathSumMemoHelper(matrix, row + 1, col + 1, n, memo) + matrix[row][col]);\\n\\n\\t\\tmemo[row][col] = min;\\n\\t\\treturn min;\\n\\t}\\n\\n\\t// Bottom Up\\n\\t// O(n^2) O(n^2)\\n\\tpublic int minFallingPathSumBU(int[][] matrix) {\\n\\n\\t\\tint n = matrix.length, ans = Integer.MAX_VALUE;\\n\\t\\tint[][] dp = new int[n + 1][n];\\n\\n\\t\\tfor (int i = n - 1; i >= 0; i--) {\\n\\t\\t\\tfor (int j = 0; j < n; j++) {\\n\\t\\t\\t\\tint min = Integer.MAX_VALUE;\\n\\t\\t\\t\\tif (j - 1 >= 0)\\n\\t\\t\\t\\t\\tmin = Math.min(min, dp[i + 1][j - 1]);\\n\\t\\t\\t\\tmin = Math.min(min, dp[i + 1][j]);\\n\\t\\t\\t\\tif (j + 1 < n)\\n\\t\\t\\t\\t\\tmin = Math.min(min, dp[i + 1][j + 1]);\\n\\t\\t\\t\\tdp[i][j] = min + matrix[i][j];\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tfor (int i = 0; i < n; i++)\\n\\t\\t\\tans = Math.min(ans, dp[0][i]);\\n\\n\\t\\treturn ans;\\n\\t}",
                "solutionTags": [],
                "code": "\\n\\t// Recursion\\n\\t// O(n*3^n) O(n)\\n\\tpublic int minFallingPathSumRec(int[][] matrix) {\\n\\n\\t\\tint n = matrix.length, min = Integer.MAX_VALUE;\\n\\t\\tfor (int i = 0; i < n; i++)\\n\\t\\t\\tmin = Math.min(min, minFallingPathSumRecHelper(matrix, 0, i, n));\\n\\t\\treturn min;\\n\\t}\\n\\n\\t// Recursion\\n\\t// O(n*3^n) O(n)\\n\\tpublic int minFallingPathSumRecHelper(int[][] matrix, int row, int col, int n) {\\n\\n\\t\\tif (row == n)\\n\\t\\t\\treturn 0;\\n\\n\\t\\tint min = Integer.MAX_VALUE;\\n\\t\\tif (col - 1 >= 0)\\n\\t\\t\\tmin = Math.min(min, minFallingPathSumRecHelper(matrix, row + 1, col - 1, n) + matrix[row][col]);\\n\\n\\t\\tmin = Math.min(min, minFallingPathSumRecHelper(matrix, row + 1, col, n) + matrix[row][col]);\\n\\n\\t\\tif (col + 1 < n)\\n\\t\\t\\tmin = Math.min(min, minFallingPathSumRecHelper(matrix, row + 1, col + 1, n) + matrix[row][col]);\\n\\n\\t\\treturn min;\\n\\t}\\n\\n\\t// Memoization\\n\\t// O(n^2) O(n^2)\\n\\tpublic int minFallingPathSumMemo(int[][] matrix) {\\n\\n\\t\\tint n = matrix.length, min = Integer.MAX_VALUE;\\n\\t\\tInteger[][] memo = new Integer[n][n];\\n\\t\\tfor (int i = 0; i < n; i++)\\n\\t\\t\\tmin = Math.min(min, minFallingPathSumMemoHelper(matrix, 0, i, n, memo));\\n\\t\\treturn min;\\n\\t}\\n\\n\\t// Memoization\\n\\t// O(n^2) O(n^2)\\n\\tpublic int minFallingPathSumMemoHelper(int[][] matrix, int row, int col, int n, Integer[][] memo) {\\n\\n\\t\\tif (row == n)\\n\\t\\t\\treturn 0;\\n\\n\\t\\tif (memo[row][col] != null)\\n\\t\\t\\treturn memo[row][col];\\n\\n\\t\\tint min = Integer.MAX_VALUE;\\n\\t\\tif (col - 1 >= 0)\\n\\t\\t\\tmin = Math.min(min, minFallingPathSumMemoHelper(matrix, row + 1, col - 1, n, memo) + matrix[row][col]);\\n\\n\\t\\tmin = Math.min(min, minFallingPathSumMemoHelper(matrix, row + 1, col, n, memo) + matrix[row][col]);\\n\\n\\t\\tif (col + 1 < n)\\n\\t\\t\\tmin = Math.min(min, minFallingPathSumMemoHelper(matrix, row + 1, col + 1, n, memo) + matrix[row][col]);\\n\\n\\t\\tmemo[row][col] = min;\\n\\t\\treturn min;\\n\\t}\\n\\n\\t// Bottom Up\\n\\t// O(n^2) O(n^2)\\n\\tpublic int minFallingPathSumBU(int[][] matrix) {\\n\\n\\t\\tint n = matrix.length, ans = Integer.MAX_VALUE;\\n\\t\\tint[][] dp = new int[n + 1][n];\\n\\n\\t\\tfor (int i = n - 1; i >= 0; i--) {\\n\\t\\t\\tfor (int j = 0; j < n; j++) {\\n\\t\\t\\t\\tint min = Integer.MAX_VALUE;\\n\\t\\t\\t\\tif (j - 1 >= 0)\\n\\t\\t\\t\\t\\tmin = Math.min(min, dp[i + 1][j - 1]);\\n\\t\\t\\t\\tmin = Math.min(min, dp[i + 1][j]);\\n\\t\\t\\t\\tif (j + 1 < n)\\n\\t\\t\\t\\t\\tmin = Math.min(min, dp[i + 1][j + 1]);\\n\\t\\t\\t\\tdp[i][j] = min + matrix[i][j];\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tfor (int i = 0; i < n; i++)\\n\\t\\t\\tans = Math.min(ans, dp[0][i]);\\n\\n\\t\\treturn ans;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 785637,
                "title": "python3-faster-than-99-33-dp",
                "content": "```\\nclass Solution:\\n    def minFallingPathSum(self, A: List[List[int]]) -> int:\\n        n = len(A)\\n        path = [[0 for x in range(n)] for y in range(n)]\\n        \\n        # initial state\\n        path[0] = A[0]\\n        \\n        for i in range(1, n):\\n            for j in range(n):\\n                if 0 < j < n -1:\\n                    path[i][j] = min(path[i-1][j-1], path[i-1][j], path[i-1][j+1]) + A[i][j]\\n                elif j == 0:\\n                    path[i][j] = min(path[i-1][j], path[i-1][j+1]) + A[i][j]\\n                else:\\n                    path[i][j] = min(path[i-1][j-1], path[i-1][j]) + A[i][j]\\n                    \\n        return min(path[-1])\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def minFallingPathSum(self, A: List[List[int]]) -> int:\\n        n = len(A)\\n        path = [[0 for x in range(n)] for y in range(n)]\\n        \\n        # initial state\\n        path[0] = A[0]\\n        \\n        for i in range(1, n):\\n            for j in range(n):\\n                if 0 < j < n -1:\\n                    path[i][j] = min(path[i-1][j-1], path[i-1][j], path[i-1][j+1]) + A[i][j]\\n                elif j == 0:\\n                    path[i][j] = min(path[i-1][j], path[i-1][j+1]) + A[i][j]\\n                else:\\n                    path[i][j] = min(path[i-1][j-1], path[i-1][j]) + A[i][j]\\n                    \\n        return min(path[-1])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 657787,
                "title": "simple-cpp-solution-with-detailed-explanation-o-n-x-m-tc",
                "content": "```\\n    int minFallingPathSum(vector<vector<int>>& A) {\\n        int rowSize = A.size(), colSize = A[0].size(), res = INT_MAX;\\n        //DP vector. Initialize all elements to 0\\n        vector<vector<int>> dp(rowSize, vector<int>(colSize, 0));\\n        \\n        //Copy first row\\n        for(int i = 0; i < colSize; i++)\\n            dp[0][i] = A[0][i];        \\n        \\n        //Traverse from second row and first col\\n        for(int i = 1; i < rowSize; i++)\\n        {\\n            for(int j = 0; j < colSize; j++)\\n            {\\n                int temp;\\n                //If it is first column, then take only first two columns in previous row for dp\\n                if(j == 0)\\n                    temp = min(dp[i-1][j], dp[i-1][j+1]);\\n                //If it is last column then take only last two columns in previous row for dp\\n                else if(j == (colSize - 1) )\\n                    temp = min(dp[i-1][j], dp[i-1][j-1]);\\n                //Else take current, preceeding and suceeding columns in previous row for dp\\n                else\\n                    temp = min(dp[i-1][j], min(dp[i-1][j-1], dp[i-1][j+1]));\\n                \\n                dp[i][j] = A[i][j] + temp;\\n            }\\n        }\\n        //Iterate through last row of Dp and take min sum\\n        for(int i = 0; i < colSize; i++)\\n            res = min(res, dp[rowSize-1][i]);\\n        \\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    int minFallingPathSum(vector<vector<int>>& A) {\\n        int rowSize = A.size(), colSize = A[0].size(), res = INT_MAX;\\n        //DP vector. Initialize all elements to 0\\n        vector<vector<int>> dp(rowSize, vector<int>(colSize, 0));\\n        \\n        //Copy first row\\n        for(int i = 0; i < colSize; i++)\\n            dp[0][i] = A[0][i];        \\n        \\n        //Traverse from second row and first col\\n        for(int i = 1; i < rowSize; i++)\\n        {\\n            for(int j = 0; j < colSize; j++)\\n            {\\n                int temp;\\n                //If it is first column, then take only first two columns in previous row for dp\\n                if(j == 0)\\n                    temp = min(dp[i-1][j], dp[i-1][j+1]);\\n                //If it is last column then take only last two columns in previous row for dp\\n                else if(j == (colSize - 1) )\\n                    temp = min(dp[i-1][j], dp[i-1][j-1]);\\n                //Else take current, preceeding and suceeding columns in previous row for dp\\n                else\\n                    temp = min(dp[i-1][j], min(dp[i-1][j-1], dp[i-1][j+1]));\\n                \\n                dp[i][j] = A[i][j] + temp;\\n            }\\n        }\\n        //Iterate through last row of Dp and take min sum\\n        for(int i = 0; i < colSize; i++)\\n            res = min(res, dp[rowSize-1][i]);\\n        \\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 455701,
                "title": "how-the-memory-usage-in-leetcode-is-calculated",
                "content": "If I use extra `2-dim dp[][]` array, the memory usage is 13.3MB.\\nBut if I don\\'t use any extra variables, the memory usage increased to 13.8MB.\\nCould someone explain me where is wrong? Thanks~\\n\\n- 2-dim dp[][] array code as follows, whose memory usage is 13.3MB:\\n```\\nclass Solution:\\n    def minFallingPathSum(self, A: List[List[int]]) -> int:\\n        # dp[i][j] the minimum sum in ith row jth column\\n        dp = []\\n        [dp.append([0] * len(A)) for i in range(len(A))]\\n\\n        for i in range(len(A)):\\n            dp[0][i] = A[0][i]\\n\\t\\t\\t\\n        for i in range(1, len(A)):\\n            for j in range(len(A)):\\n                if j == 0:\\n                    dp[i][j] = min(dp[i-1][j], dp[i-1][j+1]) + A[i][j]\\n                elif j == len(A) - 1:\\n                    dp[i][j] = min(dp[i-1][j-1], dp[i-1][j]) + A[i][j]\\n                else:\\n                    dp[i][j] = min(dp[i-1][j-1], dp[i-1][j], dp[i-1][j+1]) + A[i][j]\\n\\n        return min(dp[i])\\n```\\n\\n- No extra variables code is bellow, whose memory usage is 13.8MB:\\n```\\nclass Solution:\\n    def minFallingPathSum(self, A: List[List[int]]) -> int:\\n\\n        for i in range(1, len(A)):\\n            for j in range(len(A)):\\n                if j == 0:\\n                    A[i][j] = min(A[i-1][j], A[i-1][j+1]) + A[i][j]\\n                elif j == len(A) - 1:\\n                    A[i][j] = min(A[i-1][j-1], A[i-1][j]) + A[i][j]\\n                else:\\n                    A[i][j] = min(A[i-1][j-1], A[i-1][j], A[i-1][j+1]) + A[i][j]\\n        return min(A[-1])\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minFallingPathSum(self, A: List[List[int]]) -> int:\\n        # dp[i][j] the minimum sum in ith row jth column\\n        dp = []\\n        [dp.append([0] * len(A)) for i in range(len(A))]\\n\\n        for i in range(len(A)):\\n            dp[0][i] = A[0][i]\\n\\t\\t\\t\\n        for i in range(1, len(A)):\\n            for j in range(len(A)):\\n                if j == 0:\\n                    dp[i][j] = min(dp[i-1][j], dp[i-1][j+1]) + A[i][j]\\n                elif j == len(A) - 1:\\n                    dp[i][j] = min(dp[i-1][j-1], dp[i-1][j]) + A[i][j]\\n                else:\\n                    dp[i][j] = min(dp[i-1][j-1], dp[i-1][j], dp[i-1][j+1]) + A[i][j]\\n\\n        return min(dp[i])\\n```\n```\\nclass Solution:\\n    def minFallingPathSum(self, A: List[List[int]]) -> int:\\n\\n        for i in range(1, len(A)):\\n            for j in range(len(A)):\\n                if j == 0:\\n                    A[i][j] = min(A[i-1][j], A[i-1][j+1]) + A[i][j]\\n                elif j == len(A) - 1:\\n                    A[i][j] = min(A[i-1][j-1], A[i-1][j]) + A[i][j]\\n                else:\\n                    A[i][j] = min(A[i-1][j-1], A[i-1][j], A[i-1][j+1]) + A[i][j]\\n        return min(A[-1])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 411948,
                "title": "easy-to-understand-dfs-memo-python-with-dp-recipe",
                "content": "1) Determine if it\\'s DP Problem\\n2) Think about states and thing that change from state. -> position (i,j) change and min () from state to state\\n3) Think about the equation -> F(i,j)=A[i][j] +min(F(i+1,j),F(i+1,j+1),F(i+1,j-1))\\n4)  Think about the recursive solution and how to handle edge cases (this one tricky, you need to handle being off the board some how while maintaing the at most 1 over rule) I used min and max to determine the the rule for going left and right -> `left = max(0,j-1)` and `right = min(len(A)-1,j+1)`\\n```\\ndef dfs(self,A,i,j,memo):\\n        if i >= len(A):\\n            return 0\\n        return A[i][j] + min(self.dfs(A,i+1,j,memo),self.dfs(A,i+1,max(0,j-1),memo), self.dfs(A,i+1,min(len(A)-1,j+1),memo))\\n```\\n5)  memozation to help with TLE and your done with a good enough N^2 time N^2 space solution\\n\\nNote: Can def be optimize but this should be good enough to get you through that round of interviewing =D\\n```\\ndef minFallingPathSum(self, A):\\n        \"\"\"\\n        :type A: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        n = len(A[0])\\n        memo = [[None for _ in range(n)] for _ in range(n)] \\n        min_count = float(\\'inf\\')\\n        for j in range(n):\\n            min_count=min(min_count,self.dfs(A,0,j,memo))\\n        return min_count\\n\\n    def dfs(self,A,i,j,memo):\\n        if i >= len(A):\\n            return 0\\n        if memo[i][j]:\\n            return memo[i][j]\\n        memo[i][j]=A[i][j] + min(self.dfs(A,i+1,j,memo),self.dfs(A,i+1,max(0,j-1),memo), self.dfs(A,i+1,min(len(A)-1,j+1),memo))\\n        return memo[i][j]\\n\\t\\t```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\ndef dfs(self,A,i,j,memo):\\n        if i >= len(A):\\n            return 0\\n        return A[i][j] + min(self.dfs(A,i+1,j,memo),self.dfs(A,i+1,max(0,j-1),memo), self.dfs(A,i+1,min(len(A)-1,j+1),memo))\\n```\n```\\ndef minFallingPathSum(self, A):\\n        \"\"\"\\n        :type A: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        n = len(A[0])\\n        memo = [[None for _ in range(n)] for _ in range(n)] \\n        min_count = float(\\'inf\\')\\n        for j in range(n):\\n            min_count=min(min_count,self.dfs(A,0,j,memo))\\n        return min_count\\n\\n    def dfs(self,A,i,j,memo):\\n        if i >= len(A):\\n            return 0\\n        if memo[i][j]:\\n            return memo[i][j]\\n        memo[i][j]=A[i][j] + min(self.dfs(A,i+1,j,memo),self.dfs(A,i+1,max(0,j-1),memo), self.dfs(A,i+1,min(len(A)-1,j+1),memo))\\n        return memo[i][j]\\n\\t\\t```",
                "codeTag": "Python3"
            },
            {
                "id": 186671,
                "title": "java-dp-clean-code",
                "content": "```\\nclass Solution {\\n        int n=A.length;\\n        int[][] dp=new int[n][n];\\n        for (int[] line:dp){\\n            Arrays.fill(line,Integer.MAX_VALUE); \\n        }\\n        for (int i=0;i<n;i++){\\n            for (int j=0;j<n;j++){\\n                if(i==0) dp[i][j]=A[i][j];\\n                else{\\n                    dp[i][j]=dp[i-1][j];\\n                    if(j-1>=0) dp[i][j]=Math.min(dp[i][j],dp[i-1][j-1]);\\n                    if(j+1<n) dp[i][j]=Math.min(dp[i][j],dp[i-1][j+1]);\\n                    dp[i][j]+=A[i][j];  \\n                }\\n            }\\n        }\\n        int min=Integer.MAX_VALUE;\\n        for (int sum:dp[n-1]){\\n            min=Math.min(min,sum);\\n        }\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n        int n=A.length;\\n        int[][] dp=new int[n][n];\\n        for (int[] line:dp){\\n            Arrays.fill(line,Integer.MAX_VALUE); \\n        }\\n        for (int i=0;i<n;i++){\\n            for (int j=0;j<n;j++){\\n                if(i==0) dp[i][j]=A[i][j];\\n                else{\\n                    dp[i][j]=dp[i-1][j];\\n                    if(j-1>=0) dp[i][j]=Math.min(dp[i][j],dp[i-1][j-1]);\\n                    if(j+1<n) dp[i][j]=Math.min(dp[i][j],dp[i-1][j+1]);\\n                    dp[i][j]+=A[i][j];  \\n                }\\n            }\\n        }\\n        int min=Integer.MAX_VALUE;\\n        for (int sum:dp[n-1]){\\n            min=Math.min(min,sum);\\n        }\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 186651,
                "title": "java-two-clean-dp-codes-input-modified-and-not-time-o-n-2-space-o-1-o-n",
                "content": "\\nMethod 1: input **modified**.\\nTime: ```O(n ^ 2)```, space: ```O(1)```\\n\\n1. Starting from 2nd row, for each element, choose to add the minimum of the above 3 (or 2 if at either end of the row);\\n2. Repeat till the last row;\\n3. Find the minimum out of the last row.\\n\\n\\n```\\n    public int minFallingPathSum(int[][] A) {\\n        int n = A.length;\\n        for (int i = 1; i < n; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                int minOfAbove3 = A[i - 1][j];\\n                if (j > 0 && A[i - 1][j - 1] < minOfAbove3) { minOfAbove3 = A[i - 1][j - 1]; }\\n                if (j + 1 < n && A[i - 1][j + 1] < minOfAbove3) { minOfAbove3 = A[i - 1][j + 1]; }\\n                A[i][j] += minOfAbove3;            \\n            }\\n        }\\n        return  Arrays.stream(A[n - 1]).min().getAsInt();\\n    }\\n```\\n\\nMethod 2: Input **NOT modified**.\\nTime: ```O(n ^ 2)```, space: ```O(n)```\\n\\n1. Use a two-row array to store previous and current path value;\\n2. Use ```^= 1``` to switch between the two rows.\\n\\n```\\n    public int minFallingPathSum(int[][] A) {\\n        int n = A.length;\\n        int[][] paths = new int[2][n];\\n        for (int i = 0, k = 0; i < n; ++i, k ^= 1) {\\n            for (int j = 0; j < n; ++j) {\\n                int minOfAbove3 = paths[k][j]; // paths[k] - previous path value.\\n                if (j > 0 && paths[k][j - 1] < minOfAbove3) { minOfAbove3 = paths[k][j - 1]; }\\n                if (j + 1 < n && paths[k][j + 1] < minOfAbove3) { minOfAbove3 = paths[k][j + 1]; }\\n                paths[k ^ 1][j] = minOfAbove3 + A[i][j]; // paths[k ^ 1] - current path value.\\n            }\\n        }\\n        return Arrays.stream(paths[n % 2]).min().getAsInt();\\n    }\\n```",
                "solutionTags": [],
                "code": "```O(n ^ 2)```\n```O(1)```\n```\\n    public int minFallingPathSum(int[][] A) {\\n        int n = A.length;\\n        for (int i = 1; i < n; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                int minOfAbove3 = A[i - 1][j];\\n                if (j > 0 && A[i - 1][j - 1] < minOfAbove3) { minOfAbove3 = A[i - 1][j - 1]; }\\n                if (j + 1 < n && A[i - 1][j + 1] < minOfAbove3) { minOfAbove3 = A[i - 1][j + 1]; }\\n                A[i][j] += minOfAbove3;            \\n            }\\n        }\\n        return  Arrays.stream(A[n - 1]).min().getAsInt();\\n    }\\n```\n```O(n ^ 2)```\n```O(n)```\n```^= 1```\n```\\n    public int minFallingPathSum(int[][] A) {\\n        int n = A.length;\\n        int[][] paths = new int[2][n];\\n        for (int i = 0, k = 0; i < n; ++i, k ^= 1) {\\n            for (int j = 0; j < n; ++j) {\\n                int minOfAbove3 = paths[k][j]; // paths[k] - previous path value.\\n                if (j > 0 && paths[k][j - 1] < minOfAbove3) { minOfAbove3 = paths[k][j - 1]; }\\n                if (j + 1 < n && paths[k][j + 1] < minOfAbove3) { minOfAbove3 = paths[k][j + 1]; }\\n                paths[k ^ 1][j] = minOfAbove3 + A[i][j]; // paths[k ^ 1] - current path value.\\n            }\\n        }\\n        return Arrays.stream(paths[n % 2]).min().getAsInt();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3894169,
                "title": "python-92-56-faster-dp-memoization-tabulation",
                "content": "```\\n#Recursion \\n#Time Complexity: O(3^n)\\n#Space Complexity: O(n)\\nclass Solution1:\\n    def minFallingPathSum(self, matrix: List[List[int]]) -> int:\\n        def solve(i,j):\\n            if j>=n or j<0:\\n                return float(\\'inf\\')\\n            if i==0:\\n                return matrix[i][j]\\n            up=matrix[i][j]+solve(i-1,j)\\n            left=matrix[i][j]+solve(i-1,j-1)\\n            right=matrix[i][j]+solve(i-1,j+1)\\n            return min(up,left,right)\\n        n=len(matrix)\\n        m=float(\\'inf\\')\\n        for j in range(n):\\n            m=min(m,solve(n-1,j))\\n        return m\\n    \\n#Memoization (Top-Down)\\n#Time Complexity: O(n^2)\\n#Space Complexity: O(n) + O(n^2)\\nclass Solution2:\\n    def minFallingPathSum(self, matrix: List[List[int]]) -> int:\\n        def solve(i,j):\\n            if j>=n or j<0:\\n                return float(\\'inf\\')\\n            if i==0:\\n                return matrix[i][j]\\n            if dp[i][j]!=-1:\\n                return dp[i][j]\\n            up=matrix[i][j]+solve(i-1,j)\\n            left=matrix[i][j]+solve(i-1,j-1)\\n            right=matrix[i][j]+solve(i-1,j+1)\\n            return min(up,left,right)\\n        n=len(matrix)\\n        m=float(\\'inf\\')\\n        dp=[[-1 for j in range(n)] for i in range(n)]\\n        for j in range(n):\\n            m=min(m,solve(n-1,j))\\n        return m\\n\\n\\n#Tabulation (Bottom-Up)\\n#Time Complexity: O(n^2)\\n#Space Complexity: O(n^2)\\nclass Solution3:\\n    def minFallingPathSum(self, matrix: List[List[int]]) -> int:\\n        n=len(matrix)\\n        dp=[[0 for j in range(n)] for i in range(n)]\\n        for i in range(n):\\n            for j in range(n):\\n                if i==0:\\n                    dp[i][j]=matrix[i][j]\\n                    continue\\n                up=matrix[i][j]+dp[i-1][j]\\n                left=right=float(\\'inf\\')\\n                if j>0:\\n                    left=matrix[i][j]+dp[i-1][j-1]\\n                if j<n-1:\\n                    right=matrix[i][j]+dp[i-1][j+1]\\n                dp[i][j]=min(up,left,right)\\n        m=float(\\'inf\\')\\n        print(dp)\\n        for j in range(n):\\n            m=min(m,dp[n-1][j])\\n        return m\\n    \\n#Space Optimization\\n#Time Complexity: O(n^2)\\n#Space Complexity: O(n)\\nclass Solution:\\n    def minFallingPathSum(self, matrix: List[List[int]]) -> int:\\n        n=len(matrix)\\n        prev=[0]*n\\n        for i in range(n):\\n            curr=[0]*n\\n            for j in range(n):\\n                if i==0:\\n                    curr[j]=matrix[i][j]\\n                    continue\\n                up=matrix[i][j]+prev[j]\\n                left=right=float(\\'inf\\')\\n                if j>0:\\n                    left=matrix[i][j]+prev[j-1]\\n                if j<n-1:\\n                    right=matrix[i][j]+prev[j+1]\\n                curr[j]=min(up,left,right)\\n            prev=curr[:]\\n        m=float(\\'inf\\')\\n        for j in range(n):\\n            m=min(m,prev[j])\\n        return m\\n```\\n**An upvote will be encouraging**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Recursion",
                    "Matrix"
                ],
                "code": "```\\n#Recursion \\n#Time Complexity: O(3^n)\\n#Space Complexity: O(n)\\nclass Solution1:\\n    def minFallingPathSum(self, matrix: List[List[int]]) -> int:\\n        def solve(i,j):\\n            if j>=n or j<0:\\n                return float(\\'inf\\')\\n            if i==0:\\n                return matrix[i][j]\\n            up=matrix[i][j]+solve(i-1,j)\\n            left=matrix[i][j]+solve(i-1,j-1)\\n            right=matrix[i][j]+solve(i-1,j+1)\\n            return min(up,left,right)\\n        n=len(matrix)\\n        m=float(\\'inf\\')\\n        for j in range(n):\\n            m=min(m,solve(n-1,j))\\n        return m\\n    \\n#Memoization (Top-Down)\\n#Time Complexity: O(n^2)\\n#Space Complexity: O(n) + O(n^2)\\nclass Solution2:\\n    def minFallingPathSum(self, matrix: List[List[int]]) -> int:\\n        def solve(i,j):\\n            if j>=n or j<0:\\n                return float(\\'inf\\')\\n            if i==0:\\n                return matrix[i][j]\\n            if dp[i][j]!=-1:\\n                return dp[i][j]\\n            up=matrix[i][j]+solve(i-1,j)\\n            left=matrix[i][j]+solve(i-1,j-1)\\n            right=matrix[i][j]+solve(i-1,j+1)\\n            return min(up,left,right)\\n        n=len(matrix)\\n        m=float(\\'inf\\')\\n        dp=[[-1 for j in range(n)] for i in range(n)]\\n        for j in range(n):\\n            m=min(m,solve(n-1,j))\\n        return m\\n\\n\\n#Tabulation (Bottom-Up)\\n#Time Complexity: O(n^2)\\n#Space Complexity: O(n^2)\\nclass Solution3:\\n    def minFallingPathSum(self, matrix: List[List[int]]) -> int:\\n        n=len(matrix)\\n        dp=[[0 for j in range(n)] for i in range(n)]\\n        for i in range(n):\\n            for j in range(n):\\n                if i==0:\\n                    dp[i][j]=matrix[i][j]\\n                    continue\\n                up=matrix[i][j]+dp[i-1][j]\\n                left=right=float(\\'inf\\')\\n                if j>0:\\n                    left=matrix[i][j]+dp[i-1][j-1]\\n                if j<n-1:\\n                    right=matrix[i][j]+dp[i-1][j+1]\\n                dp[i][j]=min(up,left,right)\\n        m=float(\\'inf\\')\\n        print(dp)\\n        for j in range(n):\\n            m=min(m,dp[n-1][j])\\n        return m\\n    \\n#Space Optimization\\n#Time Complexity: O(n^2)\\n#Space Complexity: O(n)\\nclass Solution:\\n    def minFallingPathSum(self, matrix: List[List[int]]) -> int:\\n        n=len(matrix)\\n        prev=[0]*n\\n        for i in range(n):\\n            curr=[0]*n\\n            for j in range(n):\\n                if i==0:\\n                    curr[j]=matrix[i][j]\\n                    continue\\n                up=matrix[i][j]+prev[j]\\n                left=right=float(\\'inf\\')\\n                if j>0:\\n                    left=matrix[i][j]+prev[j-1]\\n                if j<n-1:\\n                    right=matrix[i][j]+prev[j+1]\\n                curr[j]=min(up,left,right)\\n            prev=curr[:]\\n        m=float(\\'inf\\')\\n        for j in range(n):\\n            m=min(m,prev[j])\\n        return m\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3861955,
                "title": "memoization-updated-striver-s-approach-tle-solved",
                "content": "# Intuition\\nYou might be getting tle in memoisation if you are initialising the dp with with -1 like this-\\n```\\nWrong:\\nvector<vector<int>> dp(n,vector<int> (n,-1));\\nRight:\\nvector<vector<int>> dp(n,vector<int> (n,INT_MIN));\\nAlso update, \\nif(dp[i][j]!=INT_MIN) return dp[i][j];\\n```\\nThis is happening because -1 can also be considered in taking the min sum so its deviating the answer hence we\\'d taken INT_MIN to initialise the dp.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n      int f(int i,int j,int n,vector<vector<int>>& matrix,vector<vector<int>>&dp){\\n\\n        if(j<0 || j>=n)return 1e9;\\n        if(i==0 )return matrix[i][j];\\n\\n        if(dp[i][j]!=INT_MIN) return dp[i][j];\\n        int str= matrix[i][j] + f(i-1,j,n,matrix,dp);\\n        int rd= matrix[i][j] + f(i-1,j+1,n,matrix,dp);\\n        int ld= matrix[i][j] + f(i-1,j-1,n,matrix,dp);\\n        return dp[i][j]= min(str, min(rd,ld));\\n    }\\n\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n        int ans=INT_MAX;\\n        vector<vector<int>> dp(n,vector<int> (n,INT_MIN));\\n        for(int j=0; j<n; j++){\\n          ans=min(ans,f(n-1,j,n,matrix,dp));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nWrong:\\nvector<vector<int>> dp(n,vector<int> (n,-1));\\nRight:\\nvector<vector<int>> dp(n,vector<int> (n,INT_MIN));\\nAlso update, \\nif(dp[i][j]!=INT_MIN) return dp[i][j];\\n```\n```\\nclass Solution {\\npublic:\\n      int f(int i,int j,int n,vector<vector<int>>& matrix,vector<vector<int>>&dp){\\n\\n        if(j<0 || j>=n)return 1e9;\\n        if(i==0 )return matrix[i][j];\\n\\n        if(dp[i][j]!=INT_MIN) return dp[i][j];\\n        int str= matrix[i][j] + f(i-1,j,n,matrix,dp);\\n        int rd= matrix[i][j] + f(i-1,j+1,n,matrix,dp);\\n        int ld= matrix[i][j] + f(i-1,j-1,n,matrix,dp);\\n        return dp[i][j]= min(str, min(rd,ld));\\n    }\\n\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n        int ans=INT_MAX;\\n        vector<vector<int>> dp(n,vector<int> (n,INT_MIN));\\n        for(int j=0; j<n; j++){\\n          ans=min(ans,f(n-1,j,n,matrix,dp));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3855287,
                "title": "check-if-you-struck-with-one-test-case-spoiler-alert",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nif you are storing the initial values of dp array as -1.\\nyou will get time limit exceeding because, there is a test designed especially for that.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int helperFunction(vector<vector<int>>& matrix, int i, int j, vector<vector<int>> &dp){\\n\\n        if(i >= matrix.size() || j < 0 || j >= matrix[0].size()){\\n            return 0;\\n        }\\n\\n        if(dp[i][j] != 1000000){\\n            return dp[i][j];\\n        }\\n\\n        int colSize = matrix[0].size();\\n        int first = INT_MAX;\\n        int second = INT_MAX;\\n        // int third = INT_MAX - 1;\\n        if(j + 1 < colSize)\\n            first = matrix[i][j + 1] + helperFunction(matrix, i + 1, j + 1, dp);\\n        if(j - 1 >= 0)\\n            second = matrix[i][j - 1] + helperFunction(matrix, i + 1, j - 1, dp);\\n        int third = matrix[i][j] + helperFunction(matrix, i + 1, j, dp);\\n\\n        int min = INT_MAX;\\n        if(first > second){\\n            min = second;\\n        }else{\\n            min = first;\\n        }\\n\\n        if(min > third){\\n            min = third;\\n        }\\n        // cout << min << \" \";\\n        return dp[i][j] = min;\\n    }\\n\\n\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int min = INT_MAX;\\n        // int col = 0;\\n        // vector<int> solution;\\n        for(int i=0; i < matrix[0].size(); i++){\\n            vector<vector<int>> dp(matrix.size(), vector<int>(matrix[0].size(), 1000000));\\n            int k = helperFunction(matrix, 0, i, dp);\\n            if(min > k){\\n                min = k;\\n            }\\n        }\\n        return min;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int helperFunction(vector<vector<int>>& matrix, int i, int j, vector<vector<int>> &dp){\\n\\n        if(i >= matrix.size() || j < 0 || j >= matrix[0].size()){\\n            return 0;\\n        }\\n\\n        if(dp[i][j] != 1000000){\\n            return dp[i][j];\\n        }\\n\\n        int colSize = matrix[0].size();\\n        int first = INT_MAX;\\n        int second = INT_MAX;\\n        // int third = INT_MAX - 1;\\n        if(j + 1 < colSize)\\n            first = matrix[i][j + 1] + helperFunction(matrix, i + 1, j + 1, dp);\\n        if(j - 1 >= 0)\\n            second = matrix[i][j - 1] + helperFunction(matrix, i + 1, j - 1, dp);\\n        int third = matrix[i][j] + helperFunction(matrix, i + 1, j, dp);\\n\\n        int min = INT_MAX;\\n        if(first > second){\\n            min = second;\\n        }else{\\n            min = first;\\n        }\\n\\n        if(min > third){\\n            min = third;\\n        }\\n        // cout << min << \" \";\\n        return dp[i][j] = min;\\n    }\\n\\n\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int min = INT_MAX;\\n        // int col = 0;\\n        // vector<int> solution;\\n        for(int i=0; i < matrix[0].size(); i++){\\n            vector<vector<int>> dp(matrix.size(), vector<int>(matrix[0].size(), 1000000));\\n            int k = helperFunction(matrix, 0, i, dp);\\n            if(min > k){\\n                min = k;\\n            }\\n        }\\n        return min;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3811790,
                "title": "java-top-down-and-bottom-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Added comments in code explaination\\n- Upvote if you Understand the asolution\\n\\n\\n# Code\\n```\\n/*\\nRecurion Appraoch that gives TLE\\nclass Solution {\\n    public int solve(int dp[][],int i,int j,int [][] matrix)\\n    {\\n        if(i<0 || j<0 || i>=matrix.length || j>=matrix[0].length)\\n        {\\n            return (int)Math.pow(10,9);\\n        }\\n        if(i==matrix.length-1)\\n        return matrix[i][j];\\n\\n        if(dp[i][j]!=-1) return dp[i][j];\\n\\n        int right=matrix[i][j]+solve(dp,i+1,j,matrix);\\n        int down=matrix[i][j]+solve(dp,i+1,j-1,matrix);\\n        int diag=matrix[i][j]+solve(dp,i+1,j+1,matrix);\\n\\n         dp[i][j] = Math.min(right, Math.min(down, diag));\\n        return dp[i][j];\\n\\n    }\\n    public int minFallingPathSum(int[][] matrix) {\\n        int n=matrix.length;\\n        int m=matrix[0].length;\\n\\n        int dp[][]= new int[n][m];\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                dp[i][j]=-1;\\n            }\\n        }\\n       \\n\\n        int minSum = Integer.MAX_VALUE;\\n        for (int j = 0; j < m; j++) {\\n            minSum = Math.min(minSum, solve(dp, 0, j, matrix));\\n        }\\n        return minSum;\\n\\n\\n    }\\n}\\n*/\\nBottom Up Dp Approach\\nclass Solution {\\n    public int minFallingPathSum(int[][] matrix) {\\n        int n = matrix.length;\\n        int m = matrix[0].length;\\n\\n        int[][] dp = new int[n][m];\\n        // Initialize the bottom row of dp with the values from the original matrix\\n        for (int j = 0; j < m; j++) {\\n            dp[n - 1][j] = matrix[n - 1][j];\\n        }\\n\\n        for (int i = n - 2; i >= 0; i--) {\\n            for (int j = 0; j < m; j++) {\\n                int right = dp[i + 1][j];\\n                int down = (j - 1 >= 0) ? dp[i + 1][j - 1] : Integer.MAX_VALUE;\\n                int diag = (j + 1 < m) ? dp[i + 1][j + 1] : Integer.MAX_VALUE;\\n                dp[i][j] = matrix[i][j] + Math.min(right, Math.min(down, diag));\\n            }\\n        }\\n\\n        // Find the minimum value in the first row, which represents the minimum falling path sum\\n        int minSum = Integer.MAX_VALUE;\\n        for (int j = 0; j < m; j++) {\\n            minSum = Math.min(minSum, dp[0][j]);\\n        }\\n\\n        return minSum;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/*\\nRecurion Appraoch that gives TLE\\nclass Solution {\\n    public int solve(int dp[][],int i,int j,int [][] matrix)\\n    {\\n        if(i<0 || j<0 || i>=matrix.length || j>=matrix[0].length)\\n        {\\n            return (int)Math.pow(10,9);\\n        }\\n        if(i==matrix.length-1)\\n        return matrix[i][j];\\n\\n        if(dp[i][j]!=-1) return dp[i][j];\\n\\n        int right=matrix[i][j]+solve(dp,i+1,j,matrix);\\n        int down=matrix[i][j]+solve(dp,i+1,j-1,matrix);\\n        int diag=matrix[i][j]+solve(dp,i+1,j+1,matrix);\\n\\n         dp[i][j] = Math.min(right, Math.min(down, diag));\\n        return dp[i][j];\\n\\n    }\\n    public int minFallingPathSum(int[][] matrix) {\\n        int n=matrix.length;\\n        int m=matrix[0].length;\\n\\n        int dp[][]= new int[n][m];\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                dp[i][j]=-1;\\n            }\\n        }\\n       \\n\\n        int minSum = Integer.MAX_VALUE;\\n        for (int j = 0; j < m; j++) {\\n            minSum = Math.min(minSum, solve(dp, 0, j, matrix));\\n        }\\n        return minSum;\\n\\n\\n    }\\n}\\n*/\\nBottom Up Dp Approach\\nclass Solution {\\n    public int minFallingPathSum(int[][] matrix) {\\n        int n = matrix.length;\\n        int m = matrix[0].length;\\n\\n        int[][] dp = new int[n][m];\\n        // Initialize the bottom row of dp with the values from the original matrix\\n        for (int j = 0; j < m; j++) {\\n            dp[n - 1][j] = matrix[n - 1][j];\\n        }\\n\\n        for (int i = n - 2; i >= 0; i--) {\\n            for (int j = 0; j < m; j++) {\\n                int right = dp[i + 1][j];\\n                int down = (j - 1 >= 0) ? dp[i + 1][j - 1] : Integer.MAX_VALUE;\\n                int diag = (j + 1 < m) ? dp[i + 1][j + 1] : Integer.MAX_VALUE;\\n                dp[i][j] = matrix[i][j] + Math.min(right, Math.min(down, diag));\\n            }\\n        }\\n\\n        // Find the minimum value in the first row, which represents the minimum falling path sum\\n        int minSum = Integer.MAX_VALUE;\\n        for (int j = 0; j < m; j++) {\\n            minSum = Math.min(minSum, dp[0][j]);\\n        }\\n\\n        return minSum;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3789438,
                "title": "simple-short-easy-solution-beats-90-using-recursion-memoization",
                "content": "# Intuition \\u2733\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n   The intuition behind the dynamic programming approach is to compute the minimum falling path sum for each cell by considering three possible moves from the current cell in the next row: moving down to the left, straight down, or moving down to the right. The minimum falling path sum at any cell is the sum of the value of the current cell and the minimum falling path sum of the three possible moves in the next row.\\nTo avoid redundant calculations, the function solve() uses memoization by storing the computed values in the dp array. If the function is called with the same row and column indices again, it returns the precomputed result directly.\\n\\n# Approach \\u2733\\n<!-- Describe your approach to solving the problem. -->The code uses a recursive dynamic programming approach to find the minimum falling path sum. It defines a recursive function solve() that calculates the minimum falling path sum starting from each element in the top row and recursively exploring all possible paths to reach the bottom row. The function stores previously computed results in the 2D array dp to avoid redundant calculations.\\nThe main function minFallingPathSum() initializes the dp array with INT_MAX, representing an uninitialized state. Then, it iterates over each element in the top row of the matrix and calls the solve() function for each starting position, keeping track of the minimum falling path sum encountered.\\n\\n# Complexity \\uD83D\\uDCAF\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> \\n    O(m*m);\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(m*m)\\n\\n# Code\\n  PLEASE UPVOTE IF YOU LIKE THIS SOLUTION HELPFUL \\uD83D\\uDE0A\\uD83D\\uDE0A\\n  THANKS .............\\n```\\nclass Solution {\\npublic:\\n    int dp[102][102];\\n    int solve(vector<vector<int>>&arr,int m,int i,int j)\\n    {   \\n        if(i>m)\\n          return 0;\\n        if(j>m || j<0)\\n          return INT_MAX;\\n        if(dp[i][j]!=INT_MAX)\\n          return dp[i][j];\\n        return dp[i][j]=arr[i][j]+min(solve(arr,m,i+1,j-1),min(solve(arr,m,i+1,j),solve(arr,m,i+1,j+1)));\\n\\n    }\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n       int ans=INT_MAX;\\n       int m=matrix.size()-1; \\n  \\n       for(int i=0;i<=m;i++)\\n        for(int j=0;j<=m;j++)\\n            dp[i][j]=INT_MAX;\\n\\n // start traversing from all elements in first row and find minium sum \\n\\n       for(int i=0;i<=m;i++)\\n       {\\n          ans=min(ans,solve(matrix,m,0,i));\\n       }\\n       return ans;\\n    }\\n};\\n```\\n![upvote.png](https://assets.leetcode.com/users/images/aadc9d52-4cfd-4b4f-8215-4a430d12f515_1689794728.8447285.png)",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[102][102];\\n    int solve(vector<vector<int>>&arr,int m,int i,int j)\\n    {   \\n        if(i>m)\\n          return 0;\\n        if(j>m || j<0)\\n          return INT_MAX;\\n        if(dp[i][j]!=INT_MAX)\\n          return dp[i][j];\\n        return dp[i][j]=arr[i][j]+min(solve(arr,m,i+1,j-1),min(solve(arr,m,i+1,j),solve(arr,m,i+1,j+1)));\\n\\n    }\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n       int ans=INT_MAX;\\n       int m=matrix.size()-1; \\n  \\n       for(int i=0;i<=m;i++)\\n        for(int j=0;j<=m;j++)\\n            dp[i][j]=INT_MAX;\\n\\n // start traversing from all elements in first row and find minium sum \\n\\n       for(int i=0;i<=m;i++)\\n       {\\n          ans=min(ans,solve(matrix,m,0,i));\\n       }\\n       return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3746636,
                "title": "space-optimized-solution-dynamic-programming-c",
                "content": "# Code\\n```cpp []\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int n = matrix.size(), m = matrix[0].size();\\n        vector<int> back(m, 0), curr(m, 0);\\n        for(int i=0; i<m; i++) back[i] = matrix[0][i];\\n\\n        for(int i=1; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                int left_d = INT_MAX, up = INT_MAX, right_d = INT_MAX;\\n                if(j>0) left_d = matrix[i][j] + back[j-1];\\n                up = matrix[i][j] + back[j];\\n                if(j<m-1) right_d = matrix[i][j] + back[j+1];\\n                curr[j] = min(left_d, min(up, right_d));\\n            }\\n            back = curr;\\n        }\\n        int ans = INT_MAX;\\n        for(int i=0; i<m; i++){\\n            ans = min(ans, back[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```cpp []\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int n = matrix.size(), m = matrix[0].size();\\n        vector<int> back(m, 0), curr(m, 0);\\n        for(int i=0; i<m; i++) back[i] = matrix[0][i];\\n\\n        for(int i=1; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                int left_d = INT_MAX, up = INT_MAX, right_d = INT_MAX;\\n                if(j>0) left_d = matrix[i][j] + back[j-1];\\n                up = matrix[i][j] + back[j];\\n                if(j<m-1) right_d = matrix[i][j] + back[j+1];\\n                curr[j] = min(left_d, min(up, right_d));\\n            }\\n            back = curr;\\n        }\\n        int ans = INT_MAX;\\n        for(int i=0; i<m; i++){\\n            ans = min(ans, back[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3603853,
                "title": "brute-force-memoization-tabulation-optimization-c",
                "content": "# Approach :\\nAt each point, we have 3 choices to make. Move in all the directions and consider the minimum cost path to reach the last row.\\n\\n# Brute Force (TLE)\\n```\\nint solve(vector<vector<int>> &grid, int i, int j, int m, int n)\\n{\\n    // base case\\n    // moving out of grid\\n    if(j >= n) return 999999;\\n    if(j < 0) return 99999;\\n    // reaching last row would be base case\\n    if(i == m-1) return grid[i][j];\\n\\n    \\n    // rec cases\\n    // it can move down, left diagonal, right diagonal\\n\\n    int down = 99999, leftD = 99999, rightD = 999999;\\n\\n    down = grid[i][j] +  solve(grid, i+1, j, m, n);\\n    if(j>0)  leftD = grid[i][j] + solve(grid, i+1, j-1, m, n);\\n    if(j+1<n) rightD = grid[i][j] + solve(grid, i+1, j+1, m, n);\\n\\n\\n    return min(down, min(leftD, rightD));\\n}\\n\\n\\nint minFallingPathSum(vector<vector<int>>& matrix) {\\n\\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n        int ans = 999999;\\n\\n        // we need to check  min cost from all the element of first row\\n\\n        for(int j = 0; j<n; j++)\\n        {\\n            ans = min(ans, solve(matrix, 0,j,m,n));\\n        }\\n\\n\\n        return ans;\\n        \\n    }\\n```\\n\\n\\nThis method costs approx O(3^M) * N Time and Space : Stack space\\n\\n\\n# Memoization (TLE) : \\n\\n```\\nint solve(vector<vector<int>> &grid, int i, int j, int m, int n,vectoe<vector<int>> &dp)\\n{\\n    // base case\\n    // moving out of grid\\n    if(j >= n) return 999999;\\n    if(j < 0) return 99999;\\n    // reaching last row would be base case\\n    if(i == m-1) return grid[i][j];\\n    if(dp[i][j] != -1) return dp[i][j];\\n\\n\\n    \\n    // rec cases\\n    // it can move down, left diagonal, right diagonal\\n\\n    int down = 99999, leftD = 99999, rightD = 999999;\\n\\n    down = grid[i][j] +  solve(grid, i+1, j, m, n, dp);\\n    if(j>0)  leftD = grid[i][j] + solve(grid, i+1, j-1, m, n, dp);\\n    if(j+1<n) rightD = grid[i][j] + solve(grid, i+1, j+1, m, n, dp);\\n\\n\\n    return dp[i][j] =  min(down, min(leftD, rightD));\\n}\\n\\n\\nint minFallingPathSum(vector<vector<int>>& matrix) {\\n\\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n        int ans = 999999;\\n\\n        vector<vector<int>> dp(m, vector<int>(n, -1));\\n\\n        for(int j = 0; j<n; j++)\\n        {\\n            ans = min(ans, solve(matrix, 0,j,m,n, dp));\\n        }\\n\\n\\n        return ans;\\n        \\n    }\\n```\\n\\nMemoization costs $$O(m*n)$$ time and space : $$O(m*n)$$ + $$Stack   Space$$\\n\\n\\n\\n# Tabulation (Accepted)\\n\\n```\\nint solve(vector<vector<int>> &grid,int m, int n)\\n{\\n\\n    vector<vector<int>> dp(m, vector<int>(n, -1));\\n    // base\\n    // copy first row of grid to dp\\n    for(int j = 0; j<n; j++)\\n    {\\n        dp[0][j] = grid[0][j];\\n    }\\n\\n\\n    for(int i = 1; i<m; i++)\\n    {\\n        for(int j = 0; j<n; j++)\\n        {\\n            int down = 999999, leftD = 999999, rightD = 999999;\\n            down = grid[i][j] + dp[i-1][j];\\n            if(j>0) leftD = grid[i][j] + dp[i-1][j-1];\\n            if(j+1<n) rightD = grid[i][j] + dp[i-1][j+1];\\n\\n            dp[i][j] = min(down, min(leftD, rightD));\\n        }\\n    }\\n\\n    // ans would be min of the last row\\n\\n    int ans = 9999;\\n    for(int j = 0; j<n; j++)\\n    {\\n        ans = min(ans, dp[m-1][j]);\\n    }\\n\\n    return ans;\\n    \\n}\\n\\nint minFallingPathSum(vector<vector<int>>& matrix) {\\n\\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n\\n        return solve(matrix, m, n);\\n        \\n    }\\n```\\n\\n\\nTabulation costs $$O(m * n)$$ time ans $$O(m * n)$$ space\\n\\n**But if we notice, each time we only need previous row as dp[i-1].\\nSo further space can be optimized to $$O(n)$$ if we only use that row** \\n\\n# Optimized (Accepted) :\\n\\n\\n```\\nclass Solution {\\npublic:\\nint solve(vector<vector<int>> &grid,int m, int n)\\n{\\n\\n    vector<int> prev = grid[0];\\n   \\n    for(int i = 1; i<m; i++)\\n    {\\n        vector<int> curr(n, -1);\\n        for(int j = 0; j<n; j++)\\n        {\\n            int down = 999999, leftD = 999999, rightD = 999999;\\n            down = grid[i][j] + prev[j];\\n            if(j>0) leftD = grid[i][j] + prev[j-1];\\n            if(j+1<n) rightD = grid[i][j] + prev[j+1];\\n\\n            curr[j] = min(down, min(leftD, rightD));\\n        }\\n        prev = curr;\\n    }\\n\\n    \\n\\n    int ans = 999999;\\n    for(int j = 0; j<n; j++)\\n    {\\n        ans = min(ans, prev[j]);\\n    }\\n\\n    return ans;\\n    \\n}\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n\\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n\\n        return solve(matrix, m, n);\\n        \\n    }\\n};\\n```\\n\\nHence Time it takes is $$O(m*n)$$ and space $$O(n)$$.\\n\\n# Hope it helps!",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nint solve(vector<vector<int>> &grid, int i, int j, int m, int n)\\n{\\n    // base case\\n    // moving out of grid\\n    if(j >= n) return 999999;\\n    if(j < 0) return 99999;\\n    // reaching last row would be base case\\n    if(i == m-1) return grid[i][j];\\n\\n    \\n    // rec cases\\n    // it can move down, left diagonal, right diagonal\\n\\n    int down = 99999, leftD = 99999, rightD = 999999;\\n\\n    down = grid[i][j] +  solve(grid, i+1, j, m, n);\\n    if(j>0)  leftD = grid[i][j] + solve(grid, i+1, j-1, m, n);\\n    if(j+1<n) rightD = grid[i][j] + solve(grid, i+1, j+1, m, n);\\n\\n\\n    return min(down, min(leftD, rightD));\\n}\\n\\n\\nint minFallingPathSum(vector<vector<int>>& matrix) {\\n\\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n        int ans = 999999;\\n\\n        // we need to check  min cost from all the element of first row\\n\\n        for(int j = 0; j<n; j++)\\n        {\\n            ans = min(ans, solve(matrix, 0,j,m,n));\\n        }\\n\\n\\n        return ans;\\n        \\n    }\\n```\n```\\nint solve(vector<vector<int>> &grid, int i, int j, int m, int n,vectoe<vector<int>> &dp)\\n{\\n    // base case\\n    // moving out of grid\\n    if(j >= n) return 999999;\\n    if(j < 0) return 99999;\\n    // reaching last row would be base case\\n    if(i == m-1) return grid[i][j];\\n    if(dp[i][j] != -1) return dp[i][j];\\n\\n\\n    \\n    // rec cases\\n    // it can move down, left diagonal, right diagonal\\n\\n    int down = 99999, leftD = 99999, rightD = 999999;\\n\\n    down = grid[i][j] +  solve(grid, i+1, j, m, n, dp);\\n    if(j>0)  leftD = grid[i][j] + solve(grid, i+1, j-1, m, n, dp);\\n    if(j+1<n) rightD = grid[i][j] + solve(grid, i+1, j+1, m, n, dp);\\n\\n\\n    return dp[i][j] =  min(down, min(leftD, rightD));\\n}\\n\\n\\nint minFallingPathSum(vector<vector<int>>& matrix) {\\n\\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n        int ans = 999999;\\n\\n        vector<vector<int>> dp(m, vector<int>(n, -1));\\n\\n        for(int j = 0; j<n; j++)\\n        {\\n            ans = min(ans, solve(matrix, 0,j,m,n, dp));\\n        }\\n\\n\\n        return ans;\\n        \\n    }\\n```\n```\\nint solve(vector<vector<int>> &grid,int m, int n)\\n{\\n\\n    vector<vector<int>> dp(m, vector<int>(n, -1));\\n    // base\\n    // copy first row of grid to dp\\n    for(int j = 0; j<n; j++)\\n    {\\n        dp[0][j] = grid[0][j];\\n    }\\n\\n\\n    for(int i = 1; i<m; i++)\\n    {\\n        for(int j = 0; j<n; j++)\\n        {\\n            int down = 999999, leftD = 999999, rightD = 999999;\\n            down = grid[i][j] + dp[i-1][j];\\n            if(j>0) leftD = grid[i][j] + dp[i-1][j-1];\\n            if(j+1<n) rightD = grid[i][j] + dp[i-1][j+1];\\n\\n            dp[i][j] = min(down, min(leftD, rightD));\\n        }\\n    }\\n\\n    // ans would be min of the last row\\n\\n    int ans = 9999;\\n    for(int j = 0; j<n; j++)\\n    {\\n        ans = min(ans, dp[m-1][j]);\\n    }\\n\\n    return ans;\\n    \\n}\\n\\nint minFallingPathSum(vector<vector<int>>& matrix) {\\n\\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n\\n        return solve(matrix, m, n);\\n        \\n    }\\n```\n```\\nclass Solution {\\npublic:\\nint solve(vector<vector<int>> &grid,int m, int n)\\n{\\n\\n    vector<int> prev = grid[0];\\n   \\n    for(int i = 1; i<m; i++)\\n    {\\n        vector<int> curr(n, -1);\\n        for(int j = 0; j<n; j++)\\n        {\\n            int down = 999999, leftD = 999999, rightD = 999999;\\n            down = grid[i][j] + prev[j];\\n            if(j>0) leftD = grid[i][j] + prev[j-1];\\n            if(j+1<n) rightD = grid[i][j] + prev[j+1];\\n\\n            curr[j] = min(down, min(leftD, rightD));\\n        }\\n        prev = curr;\\n    }\\n\\n    \\n\\n    int ans = 999999;\\n    for(int j = 0; j<n; j++)\\n    {\\n        ans = min(ans, prev[j]);\\n    }\\n\\n    return ans;\\n    \\n}\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n\\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n\\n        return solve(matrix, m, n);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3460607,
                "title": "clean-code-easy-dp-interview-approach-striver-you-will-understand",
                "content": "# Please UpVote \\n\\n# Code\\n```\\nclass Solution {\\n    public int minFallingPathSum(int[][] matrix) {\\n        int n = matrix.length; int m = matrix[0].length;\\n        int dp[][] = new int [n][m];\\n        for(int i=0 ; i< n; i++)\\n            for(int j =0 ;j < m ;j++)\\n                dp[i][j]=-1;\\n        \\n        int min= (int)1e9;\\n        for(int j =0  ; j< n ; j++){\\n            min= Math.min( min, f( 0 ,j ,n-1,matrix , dp ));\\n        }\\n        return min;\\n    }\\n    public int f ( int i , int j , int n ,int [][] matrix, int [][] dp){\\n        if( j>n || j<0) return (int)1e9;\\n        if( i==n) return matrix[i][j];\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int d= matrix[i][j] + f( i+1, j, n, matrix, dp);\\n        int dr= matrix[i][j] + f(i+1, j+1, n, matrix, dp);\\n        int dl= matrix[i][j] + f( i+1, j-1, n, matrix, dp);\\n        return dp[i][j]= Math.min(d, Math.min(dr, dl));\\n    }\\n}\\n```\\n![Screenshot 2023-04-21 140036.png](https://assets.leetcode.com/users/images/b84967d8-2b40-4861-984e-ef6714c6ee8f_1682598490.8409297.png)\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int minFallingPathSum(int[][] matrix) {\\n        int n = matrix.length; int m = matrix[0].length;\\n        int dp[][] = new int [n][m];\\n        for(int i=0 ; i< n; i++)\\n            for(int j =0 ;j < m ;j++)\\n                dp[i][j]=-1;\\n        \\n        int min= (int)1e9;\\n        for(int j =0  ; j< n ; j++){\\n            min= Math.min( min, f( 0 ,j ,n-1,matrix , dp ));\\n        }\\n        return min;\\n    }\\n    public int f ( int i , int j , int n ,int [][] matrix, int [][] dp){\\n        if( j>n || j<0) return (int)1e9;\\n        if( i==n) return matrix[i][j];\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int d= matrix[i][j] + f( i+1, j, n, matrix, dp);\\n        int dr= matrix[i][j] + f(i+1, j+1, n, matrix, dp);\\n        int dl= matrix[i][j] + f( i+1, j-1, n, matrix, dp);\\n        return dp[i][j]= Math.min(d, Math.min(dr, dl));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3438483,
                "title": "top-down-simple-dp-solution-easy-and-intuitive",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSince we want to find the minimum path sum at the bottom of the matrix, we can use dynamic programming to find the minimum path sum for each row of the matrix and work our way through the matrix to find the final result. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTop down dynamic programming\\n\\nFor each position i in row j, we want to find the minimum path sum to get to that position from row j-1. Since we are allowed to move either diagonally or downwards, we take the minimum of tiles i-1, i and i+1 in row j-1 to calculate the \"previous path sum\" which is to be added to the current value stored in grid[i][j]. \\n\\nWe do this to each and every row starting from the 2nd row (the first row will just contain values from the first row in the matrix), and once we reach the last row we find the minimum of that row to be our answer.\\n\\nThings to consider:\\nSince at index 0 and matrix.length-1 there is no diagonally upper left or right value, we can only consider 2 previous values to calculate the previous path sum to be used.\\n\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$ - traversing through n * n matrix\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$ - can be O(1) if done in place\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minFallingPathSum(int[][] matrix) {\\n        int n = matrix.length;\\n        int[][] dp = new int[n][n];\\n\\n        for(int i=0; i<n; i++){\\n            dp[0][i] = matrix[0][i];\\n        }\\n\\n        for(int i=1; i<n; i++){\\n            for(int j=0; j<n; j++){\\n                //no top left\\n                if(j == 0){\\n                    dp[i][j] = Math.min(dp[i-1][j], dp[i-1][j+1]) + matrix[i][j];\\n                }\\n                //no top right\\n                else if(j == n-1){\\n                    dp[i][j] = Math.min(dp[i-1][j], dp[i-1][j-1]) + matrix[i][j];\\n                }\\n                //comparing top left, middle, and right\\n                else{\\n                    dp[i][j] = Math.min(Math.min(dp[i-1][j], dp[i-1][j-1]), dp[i-1][j+1]) + matrix[i][j];\\n                }\\n            }\\n        }\\n        int out = Integer.MAX_VALUE;\\n        //finding the minimum of the last row\\n        for(int i=0; i<n; i++){\\n            out = Math.min(out, dp[n-1][i]);\\n        }\\n\\n        return out;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int minFallingPathSum(int[][] matrix) {\\n        int n = matrix.length;\\n        int[][] dp = new int[n][n];\\n\\n        for(int i=0; i<n; i++){\\n            dp[0][i] = matrix[0][i];\\n        }\\n\\n        for(int i=1; i<n; i++){\\n            for(int j=0; j<n; j++){\\n                //no top left\\n                if(j == 0){\\n                    dp[i][j] = Math.min(dp[i-1][j], dp[i-1][j+1]) + matrix[i][j];\\n                }\\n                //no top right\\n                else if(j == n-1){\\n                    dp[i][j] = Math.min(dp[i-1][j], dp[i-1][j-1]) + matrix[i][j];\\n                }\\n                //comparing top left, middle, and right\\n                else{\\n                    dp[i][j] = Math.min(Math.min(dp[i-1][j], dp[i-1][j-1]), dp[i-1][j+1]) + matrix[i][j];\\n                }\\n            }\\n        }\\n        int out = Integer.MAX_VALUE;\\n        //finding the minimum of the last row\\n        for(int i=0; i<n; i++){\\n            out = Math.min(out, dp[n-1][i]);\\n        }\\n\\n        return out;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3397491,
                "title": "super-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->We will first form the recursive solution by the three points mentioned in Dynamic Programming Introduction. \\n\\nStep 1: Express the problem in terms of indexes.\\n\\nWe are given an \\u2018N*M\\u2019 matrix. We can define the function with two parameters i and j, where i and j represent the row and column of the matrix.\\n\\nNow our ultimate aim is to reach the last row. We can define f(i,j) such that it gives us the maximum path sum from any cell in the first row to the cell[i][j].\\n\\n\\nIf we see the figure given below:\\n\\n\\nWe have a top row and a bottom row, we will be writing a recursion in the direction of the last row to the first row. For the last row, i=N-1 therefore we need to find four different answers:\\n\\nf(N-1,0), f(N-1,1), f(N-1,2), f(N-1,3)\\n\\nThese recursive calls will give the maximum path sum from a cell in the first row to the respective four cells for which the recursion calls are made. We need to return the maximum value among these as the final answer.\\n\\nBase Case:\\n\\nThere will be the following base cases:\\n\\nWhen i == 0, it means we are at the first row, so the min path from that cell to the first will be the value of that cell itself, hence we return mat[0][j].\\nAt every cell we have three options (we are writing recursion from the last row to the first row): to the top cell (\\u2191), to the top-right cell(\\u2197), or to the top-left cell(\\u2196).\\n\\nAs we are moving to the top cell (\\u2191), at max we will reach the first row, from where we return, so we will never go out of the bounding index.\\n\\nTo move to the top-left cell(\\u2196) or to the top-right cell(\\u2197), it can happen that we may go out of bound as shown in the figure(below). So we need to handle it, we can return -1e9, whenever we go out of bound, in this way this path will not be selected by the calling function as we have to return the maximum path.\\n\\n\\nIf j<0 or j>=M , then we return -1e9 \\nThe pseudocode till this step will be:\\n\\n\\nStep 2: Try out all possible choices at a given index.\\n\\nAt every cell we have three options (we are writing recursion from the last row to the first row): to the top cell (\\u2191), to the top-right cell(\\u2197), or to the top-left cell(\\u2196).\\n\\nTo go to the top, we will decrease i by 1, and to move towards top-left, we will decrease both i and j by 1 whereas to move to top-right, we will decrease i by 1 and increase j by 1.\\n\\nNow when we get our answer for the recursive call (f(i-1,j), f(i-1,j-1) or f(i-1,j+1)), we need to also add the current cell value to it as we have to include it too for the current path sum.\\n\\n\\nStep 3:  Take the maximum of all choices\\n\\nAs we have to find the maximum path sum of all the possible unique paths, we will return the maximum of all the choices(up, leftDiagonal, right diagonal) \\n\\nThe final pseudocode after steps 1, 2, and 3:\\n\\n\\nSteps to memoize a recursive solution:\\n\\nIf we draw the recursion tree, we will see that there are overlapping subproblems. In order to convert a recursive solution the following steps will be taken:\\n\\nCreate a dp array of size [N][M]\\nWhenever we want to find the answer of a particular row and column (say f(i,j)), we first check whether the answer is already calculated using the dp array(i.e dp[i][j]!= -1 ). If yes, simply return the value from the dp array.\\nIf not, then we are finding the answer for the given values for the first time, we will use the recursive relation as usual but before returning from the function, we will set dp[i][j] to the solution we get.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(M*N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\nint getminUtil(int i, int j, int m, vector<vector<int>> &matrix, \\nvector<vector<int> > &dp){\\n    \\n    // Base Conditions\\n    if(j<0 || j>=m)\\n        return 1e9;\\n    if(i==0)\\n        return matrix[0][j];\\n    \\n    if(dp[i][j]!=-1) return dp[i][j];\\n    \\n    int up = matrix[i][j] + getminUtil(i-1,j,m,matrix,dp);\\n    int leftDiagonal = matrix[i][j] + getminUtil(i-1,j-1,m,matrix,dp);\\n    int rightDiagonal = matrix[i][j] + getminUtil(i-1,j+1,m,matrix,dp);\\n    \\n    return dp[i][j]= min(up,min(leftDiagonal,rightDiagonal));\\n    \\n}\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n          \\n    int n = matrix.size();\\n    int m = matrix[0].size();\\n    \\n    vector<vector<int>> dp(n,vector<int>(m,-1));\\n    \\n    int mini = INT_MAX;\\n    \\n    for(int j=0; j<m;j++){\\n        int ans = getminUtil(n-1,j,m,matrix,dp);\\n        mini = min(mini,ans);\\n    }\\n    \\n    return mini;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\nint getminUtil(int i, int j, int m, vector<vector<int>> &matrix, \\nvector<vector<int> > &dp){\\n    \\n    // Base Conditions\\n    if(j<0 || j>=m)\\n        return 1e9;\\n    if(i==0)\\n        return matrix[0][j];\\n    \\n    if(dp[i][j]!=-1) return dp[i][j];\\n    \\n    int up = matrix[i][j] + getminUtil(i-1,j,m,matrix,dp);\\n    int leftDiagonal = matrix[i][j] + getminUtil(i-1,j-1,m,matrix,dp);\\n    int rightDiagonal = matrix[i][j] + getminUtil(i-1,j+1,m,matrix,dp);\\n    \\n    return dp[i][j]= min(up,min(leftDiagonal,rightDiagonal));\\n    \\n}\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n          \\n    int n = matrix.size();\\n    int m = matrix[0].size();\\n    \\n    vector<vector<int>> dp(n,vector<int>(m,-1));\\n    \\n    int mini = INT_MAX;\\n    \\n    for(int j=0; j<m;j++){\\n        int ans = getminUtil(n-1,j,m,matrix,dp);\\n        mini = min(mini,ans);\\n    }\\n    \\n    return mini;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3330093,
                "title": "minimum-falling-path-sum",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int minsum(vector<vector<int>>& matrix, int n, int row, int col,  vector<vector<int>>& dp){\\n        \\n        if(row >=n || col >=n || row <0 || col <0)\\n            return 10000001;\\n        \\n        if(row == n-1)\\n            return matrix[row][col];\\n        \\n        if(dp[row][col] != -1)\\n            return dp[row][col];\\n        \\n            int below = matrix[row][col] + minsum(matrix,n,row+1,col,dp); \\n            int left  = matrix[row][col] + minsum(matrix,n,row+1,col-1,dp);\\n            int right = matrix[row][col] + minsum(matrix,n,row+1,col+1,dp);\\n        \\n        dp[row][col] = min(below,min(left,right));\\n        return dp[row][col];\\n    }\\n        \\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        \\n        int n = matrix.size();\\n        int ans = 10000000;\\n        vector<vector<int>>dp(101,vector<int>(101,-1));\\n        for(int i = 0; i<n; i++){\\n            int temp_ans = minsum(matrix,n,0,i,dp);\\n            ans = min(ans,temp_ans);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int minsum(vector<vector<int>>& matrix, int n, int row, int col,  vector<vector<int>>& dp){\\n        \\n        if(row >=n || col >=n || row <0 || col <0)\\n            return 10000001;\\n        \\n        if(row == n-1)\\n            return matrix[row][col];\\n        \\n        if(dp[row][col] != -1)\\n            return dp[row][col];\\n        \\n            int below = matrix[row][col] + minsum(matrix,n,row+1,col,dp); \\n            int left  = matrix[row][col] + minsum(matrix,n,row+1,col-1,dp);\\n            int right = matrix[row][col] + minsum(matrix,n,row+1,col+1,dp);\\n        \\n        dp[row][col] = min(below,min(left,right));\\n        return dp[row][col];\\n    }\\n        \\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        \\n        int n = matrix.size();\\n        int ans = 10000000;\\n        vector<vector<int>>dp(101,vector<int>(101,-1));\\n        for(int i = 0; i<n; i++){\\n            int temp_ans = minsum(matrix,n,0,i,dp);\\n            ans = min(ans,temp_ans);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3293147,
                "title": "c-two-approaches-memoization-space-optimized",
                "content": "# Memoization :\\n\\n- Time complexity: O(N*N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N*N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(int i, int j, int n, vector<vector<int>>& mat, vector<vector<int>>& t) {\\n        if(i == n-1 && j >= 0 && j < n) return mat[i][j];\\n        if(j < 0 || j >= n) return INT_MAX;\\n        if(t[i][j] != -1) return t[i][j];\\n        int a = solve(i+1, j-1, n, mat, t);\\n        int b = solve(i+1, j, n, mat, t);\\n        int c = solve(i+1, j+1, n, mat, t);\\n        return t[i][j] = mat[i][j] + min(a, min(b, c));\\n    }\\n    int minFallingPathSum(vector<vector<int>>& mat) {\\n        int n = mat.size(), ans = INT_MAX;\\n        vector<vector<int>> t(n, vector<int> (n, -1));\\n        for(int k=0; k<n; k++) {\\n            int res = solve(0, k, n, mat, t);\\n            ans = min(ans, res);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n# Tabulation(Space Optimized) :\\n- Time complexity: O(N*N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& mat) {\\n        int n = mat.size();\\n        for(int i=1; i<n; i++) {\\n            for(int j=0; j<n; j++) {\\n                int s = mat[i-1][j];\\n                if(j-1 >= 0) s = min(s, mat[i-1][j-1]);\\n                if(j+1 < n) s = min(s, mat[i-1][j+1]);\\n                mat[i][j] += s;\\n            }\\n        }\\n        int ans = INT_MAX;\\n        for(int i=0; i<n; i++) ans = min(ans, mat[n-1][i]);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int i, int j, int n, vector<vector<int>>& mat, vector<vector<int>>& t) {\\n        if(i == n-1 && j >= 0 && j < n) return mat[i][j];\\n        if(j < 0 || j >= n) return INT_MAX;\\n        if(t[i][j] != -1) return t[i][j];\\n        int a = solve(i+1, j-1, n, mat, t);\\n        int b = solve(i+1, j, n, mat, t);\\n        int c = solve(i+1, j+1, n, mat, t);\\n        return t[i][j] = mat[i][j] + min(a, min(b, c));\\n    }\\n    int minFallingPathSum(vector<vector<int>>& mat) {\\n        int n = mat.size(), ans = INT_MAX;\\n        vector<vector<int>> t(n, vector<int> (n, -1));\\n        for(int k=0; k<n; k++) {\\n            int res = solve(0, k, n, mat, t);\\n            ans = min(ans, res);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& mat) {\\n        int n = mat.size();\\n        for(int i=1; i<n; i++) {\\n            for(int j=0; j<n; j++) {\\n                int s = mat[i-1][j];\\n                if(j-1 >= 0) s = min(s, mat[i-1][j-1]);\\n                if(j+1 < n) s = min(s, mat[i-1][j+1]);\\n                mat[i][j] += s;\\n            }\\n        }\\n        int ans = INT_MAX;\\n        for(int i=0; i<n; i++) ans = min(ans, mat[n-1][i]);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3069452,
                "title": "easily-explained-optimized-solution-recursive-d-p-tabulation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe are allowed to move in 3 directions and find out Minimum path sum among them.\\n\\nSo, we need to find all possible path sum and then take out minimum one. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Simple Recursive Approach:\\n    Steps to write a recursive function:\\n    ```\\n    (a) Identify Base Case\\n    (b) Do all stuff on particular index \\n    (c) Return whatever asked in question\\n    ```\\n\\n    ```\\n    class Solution {\\n        public static int fun(int row, int col, int[][] ar, int n) {\\n            if (col < 0 || col > n - 1)\\n                return (int)Math.pow(10, 9);\\n\\n            if (row == n - 1)\\n                return ar[n - 1][col];\\n            \\n            int down = ar[row][col] + fun(row + 1, col, ar, n);\\n            int left = ar[row][col] + fun(row + 1, col - 1, ar, n);\\n            int right = ar[row][col] + fun(row + 1, col + 1, ar, n);\\n\\n            return Math.min(down, Math.min(left, right));\\n        }\\n        public int minFallingPathSum(int[][] arr) {\\n            int n = arr.length;\\n            int ans = Integer.MAX_VALUE;\\n            for (int i = 0; i < n; i++) {\\n                ans = Math.min(ans, fun(0, i, arr, n));\\n            }\\n            return ans;\\n        }        \\n    }\\n\\n    ```\\n    - Time Complexity: ``` O(2^(N*N)) ```\\n    - Space Complexity:``` O(N) ```\\n    \\n2. DP Approach:\\n    Properties of a problem to be solved by DP are:\\n    1. We must be able to write recursive approach to code.\\n    2. Should include overlapping subproblems.\\n    \\n    We have overlapping subproblem in recursive solution so we will store it in 2-D array and use its solution in another subproblems which will save our time.\\n    ```\\n    class Solution {\\n        public static int fun(int row, int col, int[][] ar, int n, int[][] memo) {\\n            if (col < 0 || col > n - 1)\\n                return (int)Math.pow(10, 9);\\n\\n            if (row == n - 1)\\n                return ar[n - 1][col];\\n            \\n            if (memo[row][col] != 0)\\n                return memo[row][col];\\n            int down = ar[row][col] + fun(row + 1, col, ar, n, memo);\\n            int left = ar[row][col] + fun(row + 1, col - 1, ar, n, memo);\\n            int right = ar[row][col] + fun(row + 1, col + 1, ar, n, memo);\\n\\n            return memo[row][col] =  Math.min(down, Math.min(left, right));\\n        }\\n        public int minFallingPathSum(int[][] arr) {\\n            int n = arr.length;\\n            int ans = Integer.MAX_VALUE;\\n            int[][] dp = new int[n][n];\\n            \\n            for (int i = 0; i < n; i++) {\\n                \\n                ans = Math.min(ans, fun(0, i, arr, n, dp));\\n            }\\n            return ans;\\n        }        \\n    }\\n    ```\\n    - Time Complexity: O(N*N)\\n    - Space Complexity: O(N) + O(N*N)\\n    \\n\\n3. Tabulation Approach: \\n    Tabulation is Space Optimized approach which will remove the stack space.\\n\\n    ```\\n    class Solution {\\n        public int minFallingPathSum(int[][] A) {\\n            int n = A.length;\\n            int ans = Integer.MAX_VALUE;\\n            int[][] dp = new int[n][n];\\n            \\n            for (int i = 0; i < n; i++) {\\n                dp[0][i] = A[0][i];\\n            }\\n            \\n            int down = Integer.MAX_VALUE, left = Integer.MAX_VALUE, right = Integer.MAX_VALUE;\\n            for(int row = 1; row < n; row++) {\\n                for(int col = 0; col < n; col++) {\\n                    down = dp[row - 1][col];\\n                    if(col == 0) {\\n                        right = dp[row - 1][col + 1];\\n                        dp[row][col] = A[row][col] + Math.min(down, right);\\n                    }\\n                    else if (col == n - 1) {\\n                        left = dp[row - 1][col - 1];\\n                        dp[row][col] = A[row][col] + Math.min(down, left);\\n                    }\\n                    else {\\n                        left = dp[row - 1][col - 1];\\n                        right = dp[row - 1][col + 1];\\n                        dp[row][col] = A[row][col] + Math.min(down, Math.min(left, right));\\n                    }\\n                }\\n            }\\n\\n            for(int col = 0; col < n; col++)\\n                ans = Math.min(ans, dp[n - 1][col]);\\n            \\n            return ans;\\n        }        \\n    }\\n    ```\\n    - Time Complexity: O(N*N)\\n    - Space Complexity: O(N*N)\\n",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\n    (a) Identify Base Case\\n    (b) Do all stuff on particular index \\n    (c) Return whatever asked in question\\n    ```\n```\\n    class Solution {\\n        public static int fun(int row, int col, int[][] ar, int n) {\\n            if (col < 0 || col > n - 1)\\n                return (int)Math.pow(10, 9);\\n\\n            if (row == n - 1)\\n                return ar[n - 1][col];\\n            \\n            int down = ar[row][col] + fun(row + 1, col, ar, n);\\n            int left = ar[row][col] + fun(row + 1, col - 1, ar, n);\\n            int right = ar[row][col] + fun(row + 1, col + 1, ar, n);\\n\\n            return Math.min(down, Math.min(left, right));\\n        }\\n        public int minFallingPathSum(int[][] arr) {\\n            int n = arr.length;\\n            int ans = Integer.MAX_VALUE;\\n            for (int i = 0; i < n; i++) {\\n                ans = Math.min(ans, fun(0, i, arr, n));\\n            }\\n            return ans;\\n        }        \\n    }\\n\\n    ```\n``` O(2^(N*N)) ```\n``` O(N) ```\n```\\n    class Solution {\\n        public static int fun(int row, int col, int[][] ar, int n, int[][] memo) {\\n            if (col < 0 || col > n - 1)\\n                return (int)Math.pow(10, 9);\\n\\n            if (row == n - 1)\\n                return ar[n - 1][col];\\n            \\n            if (memo[row][col] != 0)\\n                return memo[row][col];\\n            int down = ar[row][col] + fun(row + 1, col, ar, n, memo);\\n            int left = ar[row][col] + fun(row + 1, col - 1, ar, n, memo);\\n            int right = ar[row][col] + fun(row + 1, col + 1, ar, n, memo);\\n\\n            return memo[row][col] =  Math.min(down, Math.min(left, right));\\n        }\\n        public int minFallingPathSum(int[][] arr) {\\n            int n = arr.length;\\n            int ans = Integer.MAX_VALUE;\\n            int[][] dp = new int[n][n];\\n            \\n            for (int i = 0; i < n; i++) {\\n                \\n                ans = Math.min(ans, fun(0, i, arr, n, dp));\\n            }\\n            return ans;\\n        }        \\n    }\\n    ```\n```\\n    class Solution {\\n        public int minFallingPathSum(int[][] A) {\\n            int n = A.length;\\n            int ans = Integer.MAX_VALUE;\\n            int[][] dp = new int[n][n];\\n            \\n            for (int i = 0; i < n; i++) {\\n                dp[0][i] = A[0][i];\\n            }\\n            \\n            int down = Integer.MAX_VALUE, left = Integer.MAX_VALUE, right = Integer.MAX_VALUE;\\n            for(int row = 1; row < n; row++) {\\n                for(int col = 0; col < n; col++) {\\n                    down = dp[row - 1][col];\\n                    if(col == 0) {\\n                        right = dp[row - 1][col + 1];\\n                        dp[row][col] = A[row][col] + Math.min(down, right);\\n                    }\\n                    else if (col == n - 1) {\\n                        left = dp[row - 1][col - 1];\\n                        dp[row][col] = A[row][col] + Math.min(down, left);\\n                    }\\n                    else {\\n                        left = dp[row - 1][col - 1];\\n                        right = dp[row - 1][col + 1];\\n                        dp[row][col] = A[row][col] + Math.min(down, Math.min(left, right));\\n                    }\\n                }\\n            }\\n\\n            for(int col = 0; col < n; col++)\\n                ans = Math.min(ans, dp[n - 1][col]);\\n            \\n            return ans;\\n        }        \\n    }\\n    ```",
                "codeTag": "Java"
            },
            {
                "id": 2972189,
                "title": "memoization-tabulation-space-optimization-c",
                "content": "# Memoization\\n```\\nclass Solution {\\n    int dfs(int i, int j, int n, vector<vector<int>> &matrix, vector<vector<int>> &dp) {\\n        if(j < 0 || j == n) return INT_MAX;\\n        if(i == n - 1) return matrix[i][j];\\n        if(dp[i][j] != -1) return dp[i][j];\\n\\n        int l = dfs(i + 1, j - 1, n, matrix, dp);\\n        int b = dfs(i + 1, j, n, matrix, dp);\\n        int r = dfs(i + 1, j + 1, n, matrix, dp);\\n\\n        return dp[i][j] = matrix[i][j] + min(l, min(b, r));\\n    }\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int ans = INT_MAX, n = matrix.size();\\n        vector<vector<int>> dp(n, vector<int>(n, -1));\\n        for(int i=0; i<n; i++) {\\n            ans = min(ans, dfs(0, i, n, matrix, dp));\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n# Tabulation\\n```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int ans = INT_MAX, n = matrix.size();\\n        vector<vector<int>> dp(n, vector<int>(n, -1));\\n        \\n        dp[0] = matrix[0];\\n        for(int i=1; i<n; i++) {\\n            for(int j=0; j<n; j++) {\\n                int l = 1e9, a = 1e9, r = 1e9;\\n                if(j > 0) l = dp[i - 1][j - 1];\\n                a = dp[i - 1][j];\\n                if(j + 1 < n) r = dp[i - 1][j + 1];\\n                dp[i][j] = matrix[i][j] + min(l, min(a, r));\\n            }\\n        }\\n\\n        for(int i=0; i<n; i++) ans = min(ans, dp[n - 1][i]);\\n        return ans;\\n    }\\n};\\n```\\n\\n# Space Optimization\\n```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int ans = INT_MAX, n = matrix.size();\\n        vector<int> dp = matrix[0];\\n        \\n        for(int i=1; i<n; i++) {\\n            vector<int> temp(n);\\n            for(int j=0; j<n; j++) {\\n                int l = 1e9, a = 1e9, r = 1e9;\\n                if(j > 0) l = dp[j - 1];\\n                a = dp[j];\\n                if(j + 1 < n) r = dp[j + 1];\\n                temp[j] = matrix[i][j] + min(l, min(a, r));\\n            }\\n            dp = temp;\\n        }\\n\\n        for(int i=0; i<n; i++) ans = min(ans, dp[i]);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int dfs(int i, int j, int n, vector<vector<int>> &matrix, vector<vector<int>> &dp) {\\n        if(j < 0 || j == n) return INT_MAX;\\n        if(i == n - 1) return matrix[i][j];\\n        if(dp[i][j] != -1) return dp[i][j];\\n\\n        int l = dfs(i + 1, j - 1, n, matrix, dp);\\n        int b = dfs(i + 1, j, n, matrix, dp);\\n        int r = dfs(i + 1, j + 1, n, matrix, dp);\\n\\n        return dp[i][j] = matrix[i][j] + min(l, min(b, r));\\n    }\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int ans = INT_MAX, n = matrix.size();\\n        vector<vector<int>> dp(n, vector<int>(n, -1));\\n        for(int i=0; i<n; i++) {\\n            ans = min(ans, dfs(0, i, n, matrix, dp));\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int ans = INT_MAX, n = matrix.size();\\n        vector<vector<int>> dp(n, vector<int>(n, -1));\\n        \\n        dp[0] = matrix[0];\\n        for(int i=1; i<n; i++) {\\n            for(int j=0; j<n; j++) {\\n                int l = 1e9, a = 1e9, r = 1e9;\\n                if(j > 0) l = dp[i - 1][j - 1];\\n                a = dp[i - 1][j];\\n                if(j + 1 < n) r = dp[i - 1][j + 1];\\n                dp[i][j] = matrix[i][j] + min(l, min(a, r));\\n            }\\n        }\\n\\n        for(int i=0; i<n; i++) ans = min(ans, dp[n - 1][i]);\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int ans = INT_MAX, n = matrix.size();\\n        vector<int> dp = matrix[0];\\n        \\n        for(int i=1; i<n; i++) {\\n            vector<int> temp(n);\\n            for(int j=0; j<n; j++) {\\n                int l = 1e9, a = 1e9, r = 1e9;\\n                if(j > 0) l = dp[j - 1];\\n                a = dp[j];\\n                if(j + 1 < n) r = dp[j + 1];\\n                temp[j] = matrix[i][j] + min(l, min(a, r));\\n            }\\n            dp = temp;\\n        }\\n\\n        for(int i=0; i<n; i++) ans = min(ans, dp[i]);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2930241,
                "title": "simple-python-solution-with-memoization",
                "content": "# Intuition\\nFirst thing that comes to mind is Depth First Search but you can quickly realiza that DFS will lead to Time Limit Exceeded. Becasue we are solving a summation problem at each level again and again that leads to memoization, we can save the computation by only calculating once the minimum sum possible if we select a specific `x, y` in matrix at level `i`.  \\n\\n# Approach\\nSince we need to know minimum on the next level, we start with bottom-up approach. Calculate the `memo` array from bottom and then perform simple `min` operation going up.\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$\\n\\n- Space complexity: $$O(n^2)$$\\n\\n---\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def minFallingPathSum(self, matrix: List[List[int]]) -> int:\\n        m, n = len(matrix), len(matrix[0])\\n        memo = [[0]*n for _ in range(m)]\\n        memo[m-1] = matrix[m-1]\\n        \\n\\n        for i in range(m-2, -1, -1):\\n            for j in range(n):\\n                x, y, z = memo[i+1][j], float(\\'inf\\'), float(\\'inf\\')\\n                if j != 0:\\n                    y = memo[i+1][j-1]\\n\\n                if j != n-1:\\n                   z = memo[i+1][j+1] \\n\\n                memo[i][j] = min(x, y, z) + matrix[i][j]\\n        return min(memo[0])\\n\\n            \\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def minFallingPathSum(self, matrix: List[List[int]]) -> int:\\n        m, n = len(matrix), len(matrix[0])\\n        memo = [[0]*n for _ in range(m)]\\n        memo[m-1] = matrix[m-1]\\n        \\n\\n        for i in range(m-2, -1, -1):\\n            for j in range(n):\\n                x, y, z = memo[i+1][j], float(\\'inf\\'), float(\\'inf\\')\\n                if j != 0:\\n                    y = memo[i+1][j-1]\\n\\n                if j != n-1:\\n                   z = memo[i+1][j+1] \\n\\n                memo[i][j] = min(x, y, z) + matrix[i][j]\\n        return min(memo[0])\\n\\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2910404,
                "title": "c-dp-on-grids-memoized-code-bottom-up-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe need to explore all possible paths here and then will find the minimum sum. Here source and destination both are variables. I am using bottom up approach. Starting from bottom row and then going to first row, finding all possible sum and storing mininum.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Time complexity for recursive solution will be O(3^n) means exponential, so we need to do either memoization or tabulation to handle overlapping subproblems.\\n2. Create one dp matrix and storing the result.\\n\\n# Complexity\\n- Time complexity: O(NxM)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(NxM) (not including recursion stack space)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(int row, int col, vector<vector<int>> &matrix,vector<vector<int>> &dp)\\n    {\\n        if(col<0 || col>matrix[0].size()-1) return 1E9;\\n        if(row==0) return matrix[row][col];\\n        if(dp[row][col] != -1) return dp[row][col];\\n        int up = matrix[row][col] + solve(row-1,col,matrix,dp);\\n        int leftDiagonal = matrix[row][col] + solve(row-1,col-1,matrix,dp);\\n        int rightDiagonal = matrix[row][col] + solve(row-1,col+1,matrix,dp);\\n        return dp[row][col] = min(up,min(leftDiagonal,rightDiagonal));\\n    }\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int ans = INT_MAX;\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        vector<vector<int>> dp(n,vector<int>(m,-1));\\n        for(int i=0;i<m;i++)\\n        {\\n            ans = min(ans,solve(n-1,i,matrix,dp));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int row, int col, vector<vector<int>> &matrix,vector<vector<int>> &dp)\\n    {\\n        if(col<0 || col>matrix[0].size()-1) return 1E9;\\n        if(row==0) return matrix[row][col];\\n        if(dp[row][col] != -1) return dp[row][col];\\n        int up = matrix[row][col] + solve(row-1,col,matrix,dp);\\n        int leftDiagonal = matrix[row][col] + solve(row-1,col-1,matrix,dp);\\n        int rightDiagonal = matrix[row][col] + solve(row-1,col+1,matrix,dp);\\n        return dp[row][col] = min(up,min(leftDiagonal,rightDiagonal));\\n    }\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int ans = INT_MAX;\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        vector<vector<int>> dp(n,vector<int>(m,-1));\\n        for(int i=0;i<m;i++)\\n        {\\n            ans = min(ans,solve(n-1,i,matrix,dp));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2907956,
                "title": "python-code-beats-96-easy-for-begginers",
                "content": "# Code\\n```\\nclass Solution:\\n    def minFallingPathSum(self, matrix: List[List[int]]) -> int:\\n        for i in range(1,len(matrix)):\\n            for j in range(len(matrix[i])):\\n                if j != 0 and j!=len(matrix[i])-1:\\n                    matrix[i][j] = min(matrix[i][j] + matrix[i-1][j], matrix[i][j] + matrix[i-1][j-1], matrix[i][j] + matrix[i-1][j+1])\\n                elif j == 0:\\n                    matrix[i][j] = min(matrix[i][j] + matrix[i-1][j], matrix[i][j] + matrix[i-1][j+1])\\n                else:\\n                    matrix[i][j] = min(matrix[i][j] + matrix[i-1][j], matrix[i][j] + matrix[i-1][j-1])\\n        return min(matrix[-1])\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minFallingPathSum(self, matrix: List[List[int]]) -> int:\\n        for i in range(1,len(matrix)):\\n            for j in range(len(matrix[i])):\\n                if j != 0 and j!=len(matrix[i])-1:\\n                    matrix[i][j] = min(matrix[i][j] + matrix[i-1][j], matrix[i][j] + matrix[i-1][j-1], matrix[i][j] + matrix[i-1][j+1])\\n                elif j == 0:\\n                    matrix[i][j] = min(matrix[i][j] + matrix[i-1][j], matrix[i][j] + matrix[i-1][j+1])\\n                else:\\n                    matrix[i][j] = min(matrix[i][j] + matrix[i-1][j], matrix[i][j] + matrix[i-1][j-1])\\n        return min(matrix[-1])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2907554,
                "title": "c-solution",
                "content": "# Code\\n```\\n#define inf 1000000000\\n#define maxn 105\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int n = matrix.size(), dp[maxn][maxn] = {};\\n        for(int i=1; i<maxn; i++) for(int j=0; j<maxn; j++) dp[i][j] = inf;\\n        for(int i=1; i<=n; i++) {\\n            for(int j=1; j<=n; j++) {\\n                dp[i][j] = matrix[i-1][j-1] + min({dp[i-1][j-1], dp[i-1][j], dp[i-1][j+1]});\\n            }\\n        }\\n        int ans = inf;\\n        for(int i=1; i<=n; i++) ans = min(ans, dp[n][i]);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define inf 1000000000\\n#define maxn 105\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int n = matrix.size(), dp[maxn][maxn] = {};\\n        for(int i=1; i<maxn; i++) for(int j=0; j<maxn; j++) dp[i][j] = inf;\\n        for(int i=1; i<=n; i++) {\\n            for(int j=1; j<=n; j++) {\\n                dp[i][j] = matrix[i-1][j-1] + min({dp[i-1][j-1], dp[i-1][j], dp[i-1][j+1]});\\n            }\\n        }\\n        int ans = inf;\\n        for(int i=1; i<=n; i++) ans = min(ans, dp[n][i]);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2907236,
                "title": "python-simple-solutions-o-n-2-time-and-o-1-space",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def minFallingPathSum(self, matrix):\\n        matLen = len(matrix)\\n        for i in range(matLen-2,-1,-1):\\n            for j in range (matLen):\\n                left = matrix[i][j]+matrix[i+1][j-1] if j > 0 else 999999999\\n                mid = matrix[i][j]+matrix[i+1][j] \\n                right = matrix[i][j]+matrix[i+1][j+1] if j < matLen-1 else 999999999\\n                matrix[i][j] = min(left,mid,right)\\n        return min(matrix[0])\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Matrix"
                ],
                "code": "```\\nclass Solution(object):\\n    def minFallingPathSum(self, matrix):\\n        matLen = len(matrix)\\n        for i in range(matLen-2,-1,-1):\\n            for j in range (matLen):\\n                left = matrix[i][j]+matrix[i+1][j-1] if j > 0 else 999999999\\n                mid = matrix[i][j]+matrix[i+1][j] \\n                right = matrix[i][j]+matrix[i+1][j+1] if j < matLen-1 else 999999999\\n                matrix[i][j] = min(left,mid,right)\\n        return min(matrix[0])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2907130,
                "title": "java-easy-to-understand-dp-using-tabulation",
                "content": "https://github.com/Freeze777/SDE-Interviewer-Notes/blob/main/LeetCodeJava/src/main/java/leetcode/medium/dp/MinFallingPathSum.java",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 2906518,
                "title": "c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        //here we are manipulating the input matrix. We are storing the minimum sum upto that position from the first row.\\n        for(int i=1;i<=matrix.size()-1;++i)\\n            for(int j=0;j<=matrix.size()-1;++j)\\n                matrix[i][j]+=min({matrix[i-1][j],matrix[i-1][max(0,j-1)],matrix[i-1][min((int)matrix.size()-1,j+1)]});\\n                // Now we are returning the minimum sum stored from the last row.\\n        return *min_element((begin(matrix[matrix.size()-1])),end(matrix[matrix.size()-1]));\\n        \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        //here we are manipulating the input matrix. We are storing the minimum sum upto that position from the first row.\\n        for(int i=1;i<=matrix.size()-1;++i)\\n            for(int j=0;j<=matrix.size()-1;++j)\\n                matrix[i][j]+=min({matrix[i-1][j],matrix[i-1][max(0,j-1)],matrix[i-1][min((int)matrix.size()-1,j+1)]});\\n                // Now we are returning the minimum sum stored from the last row.\\n        return *min_element((begin(matrix[matrix.size()-1])),end(matrix[matrix.size()-1]));\\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2906130,
                "title": "javascript-iteration-recursion-dynamic-programming-memoization",
                "content": "\\uD835\\uDDE3\\uD835\\uDDF9\\uD835\\uDDF2\\uD835\\uDDEE\\uD835\\uDE00\\uD835\\uDDF2 \\uD835\\uDDF1\\uD835\\uDDFF\\uD835\\uDDFC\\uD835\\uDDFD \\uD835\\uDDF0\\uD835\\uDDFC\\uD835\\uDDFA\\uD835\\uDDFA\\uD835\\uDDF2\\uD835\\uDDFB\\uD835\\uDE01\\uD835\\uDE00 \\uD835\\uDDEE\\uD835\\uDDFB\\uD835\\uDDF1 \\uD835\\uDDF3\\uD835\\uDDF2\\uD835\\uDDF2\\uD835\\uDDF1\\uD835\\uDDEF\\uD835\\uDDEE\\uD835\\uDDF0\\uD835\\uDDF8 \\uD835\\uDDF3\\uD835\\uDDFC\\uD835\\uDDFF \\uD835\\uDDF6\\uD835\\uDDFA\\uD835\\uDDFD\\uD835\\uDDFF\\uD835\\uDDFC\\uD835\\uDE03\\uD835\\uDDF2\\uD835\\uDDFA\\uD835\\uDDF2\\uD835\\uDDFB\\uD835\\uDE01\\nhttps://youtu.be/OPwU0D0z1r4\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n*n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n*n)\\n# Code\\n```\\n/**\\n *Iteration\\n */\\nvar minFallingPathSum = function(matrix) {\\n    let n = matrix.length;\\n\\n    let dp = new Array(n);\\n    for (let i = 0; i < n; i++) {\\n        dp[i] = [...matrix[i]]\\n    }\\n\\n    let minSum = Infinity;\\n    for (let i = n - 2; i >= 0; i--) {\\n        minSum = Infinity;\\n        for (let j = 0; j < n; j++) {\\n            dp[i][j] += dp[i+1][j];\\n            if (j > 0) dp[i][j] = Math.min(dp[i][j], matrix[i][j] + dp[i+1][j-1]);\\n            if (j < n-1) dp[i][j] = Math.min(dp[i][j], matrix[i][j] + dp[i+1][j+1]);\\n            minSum = Math.min(minSum, dp[i][j])\\n        }\\n    }\\n    return matrix.length > 1 ? minSum : matrix[0][0];\\n};\\n```\\n\\n\\n```\\n\\\\\\\\recursion\\nvar minFallingPathSum = function(matrix) {\\n    let minSum = Infinity;\\n    let n = matrix.length;\\n    let dp = new Array(n);\\n    for (let i = 0; i < n; i++) {\\n        dp[i] = [...matrix[i]];\\n    }\\n    let helper = function(i,j) {\\n        if (i == n || j == n || i < 0 || j < 0) return Infinity;\\n        if (i == n-1) return matrix[i][j];\\n        if (dp[i][j] != matrix[i][j]) return dp[i][j];\\n\\n        dp[i][j] += Math.min(helper(i+1, j-1), Math.min(helper(i+1, j), helper(i+1, j+1)))\\n        return dp[i][j];\\n    }\\n    for (let i = 0; i < matrix.length; i++) {\\n        helper(0,i);\\n        minSum = Math.min(minSum, dp[0][i])\\n    }\\n    return minSum;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization",
                    "Iterator"
                ],
                "code": "```\\n/**\\n *Iteration\\n */\\nvar minFallingPathSum = function(matrix) {\\n    let n = matrix.length;\\n\\n    let dp = new Array(n);\\n    for (let i = 0; i < n; i++) {\\n        dp[i] = [...matrix[i]]\\n    }\\n\\n    let minSum = Infinity;\\n    for (let i = n - 2; i >= 0; i--) {\\n        minSum = Infinity;\\n        for (let j = 0; j < n; j++) {\\n            dp[i][j] += dp[i+1][j];\\n            if (j > 0) dp[i][j] = Math.min(dp[i][j], matrix[i][j] + dp[i+1][j-1]);\\n            if (j < n-1) dp[i][j] = Math.min(dp[i][j], matrix[i][j] + dp[i+1][j+1]);\\n            minSum = Math.min(minSum, dp[i][j])\\n        }\\n    }\\n    return matrix.length > 1 ? minSum : matrix[0][0];\\n};\\n```\n```\\n\\\\\\\\recursion\\nvar minFallingPathSum = function(matrix) {\\n    let minSum = Infinity;\\n    let n = matrix.length;\\n    let dp = new Array(n);\\n    for (let i = 0; i < n; i++) {\\n        dp[i] = [...matrix[i]];\\n    }\\n    let helper = function(i,j) {\\n        if (i == n || j == n || i < 0 || j < 0) return Infinity;\\n        if (i == n-1) return matrix[i][j];\\n        if (dp[i][j] != matrix[i][j]) return dp[i][j];\\n\\n        dp[i][j] += Math.min(helper(i+1, j-1), Math.min(helper(i+1, j), helper(i+1, j+1)))\\n        return dp[i][j];\\n    }\\n    for (let i = 0; i < matrix.length; i++) {\\n        helper(0,i);\\n        minSum = Math.min(minSum, dp[0][i])\\n    }\\n    return minSum;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2906085,
                "title": "java-solution-dp",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int minFallingPathSum(int[][] matrix) {\\n       int dp[][] = new int[matrix.length][matrix.length];\\n        int min = Integer.MAX_VALUE;\\n        for(int i=0;i<matrix.length;i++){\\n            dp[0][i]=matrix[0][i];\\n        }\\n\\n        for(int i=1;i<matrix.length;i++){\\n            for(int j=0;j<matrix.length;j++){\\n                if(j==0){\\n                    dp[i][j]=matrix[i][j]+Math.min(dp[i-1][j],dp[i-1][j+1]);\\n                }\\n                else if(j==matrix.length-1){\\n                    dp[i][j]=matrix[i][j]+Math.min(dp[i-1][j],dp[i-1][j-1]);\\n                }\\n                else{\\n                    dp[i][j]=matrix[i][j]+ Math.min(Math.min(dp[i-1][j-1], dp[i-1][j]), dp[i-1][j+1]);\\n                }\\n\\n            }\\n        }\\n        for(int i=0;i<matrix.length;i++){\\n            if(dp[matrix.length-1][i]<min) min=dp[matrix.length-1][i];\\n        }\\n     return min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minFallingPathSum(int[][] matrix) {\\n       int dp[][] = new int[matrix.length][matrix.length];\\n        int min = Integer.MAX_VALUE;\\n        for(int i=0;i<matrix.length;i++){\\n            dp[0][i]=matrix[0][i];\\n        }\\n\\n        for(int i=1;i<matrix.length;i++){\\n            for(int j=0;j<matrix.length;j++){\\n                if(j==0){\\n                    dp[i][j]=matrix[i][j]+Math.min(dp[i-1][j],dp[i-1][j+1]);\\n                }\\n                else if(j==matrix.length-1){\\n                    dp[i][j]=matrix[i][j]+Math.min(dp[i-1][j],dp[i-1][j-1]);\\n                }\\n                else{\\n                    dp[i][j]=matrix[i][j]+ Math.min(Math.min(dp[i-1][j-1], dp[i-1][j]), dp[i-1][j+1]);\\n                }\\n\\n            }\\n        }\\n        for(int i=0;i<matrix.length;i++){\\n            if(dp[matrix.length-1][i]<min) min=dp[matrix.length-1][i];\\n        }\\n     return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2905834,
                "title": "swift-one-liner",
                "content": "**One-Liner, terse (accepted answer)**\\n```\\nclass Solution {\\n    func minFallingPathSum(_ m: [[Int]]) -> Int {\\n        (1..<m.count).reduce(into: m) { m,i in m.indices.forEach { j in m[i][j]+=m[i-1][max(0,j-1)...min(m.count-1,j+1)].min()!}}.last!.min()!\\n    }\\n}\\n```\\n**NOTE:** Technically a one-liner, since `return` keyword was omitted.\\n\\n---\\n**One-Liner, expanded (accepted answer)**\\n```\\nclass Solution {\\n    func minFallingPathSum(_ m: [[Int]]) -> Int {\\n        (1..<m.count).reduce(into: m) { m,i in\\n            m.indices.forEach { j in\\n                m[i][j] += m[i-1][max(0,j-1)...min(m.count-1,j+1)].min()!\\n            }\\n        }.last!.min()!\\n    }\\n}\\n```\\n---\\n\\n**One-Liner, expanded and annotated (accepted answer)**\\n```\\nclass Solution {\\n    func minFallingPathSum(_ matrix: [[Int]]) -> Int {\\n        // compute dp in-place \\n        // the reduce result initialized to a copy of `matrix` value\\n        (1..<matrix.count).reduce(into: matrix) { m,i in\\n            matrix.indices.forEach { j in\\n                // update `m[i][j]` by adding to it min. of \\n                // (up to) three adjacent cells under it.  \\n                m[i][j] += m[i-1][max(0,j-1)...min(m.count-1,j+1)].min()!\\n            }\\n        }.last!.min()! // the minimum elem. of the last row is the result.\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func minFallingPathSum(_ m: [[Int]]) -> Int {\\n        (1..<m.count).reduce(into: m) { m,i in m.indices.forEach { j in m[i][j]+=m[i-1][max(0,j-1)...min(m.count-1,j+1)].min()!}}.last!.min()!\\n    }\\n}\\n```\n```\\nclass Solution {\\n    func minFallingPathSum(_ m: [[Int]]) -> Int {\\n        (1..<m.count).reduce(into: m) { m,i in\\n            m.indices.forEach { j in\\n                m[i][j] += m[i-1][max(0,j-1)...min(m.count-1,j+1)].min()!\\n            }\\n        }.last!.min()!\\n    }\\n}\\n```\n```\\nclass Solution {\\n    func minFallingPathSum(_ matrix: [[Int]]) -> Int {\\n        // compute dp in-place \\n        // the reduce result initialized to a copy of `matrix` value\\n        (1..<matrix.count).reduce(into: matrix) { m,i in\\n            matrix.indices.forEach { j in\\n                // update `m[i][j]` by adding to it min. of \\n                // (up to) three adjacent cells under it.  \\n                m[i][j] += m[i-1][max(0,j-1)...min(m.count-1,j+1)].min()!\\n            }\\n        }.last!.min()! // the minimum elem. of the last row is the result.\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2905656,
                "title": "daily-leetcoding-challenge-december-day-13",
                "content": "This problem is the Daily LeetCoding Challenge for December, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/minimum-falling-path-sum/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force Using Depth First Search\n\n  \n**Approach 2:** Top Down Dynamic Programming\n\n  \n**Approach 3:** Bottom-Up Dynamic Programming (Tabulation)\n\n  \n**Approach 4:** Space Optimized, Bottom-Up Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/minimum-falling-path-sum/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n**Approach 3:** Bottom-Up Dynamic Programming (Tabulation)\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 2877607,
                "title": "golang-clean-and-efficient-dp-solution",
                "content": "```\\nfunc minFallingPathSum(matrix [][]int) int {\\n    dp := make([][]int, len(matrix))\\n    for i := range dp {\\n        dp[i] = make([]int, len(matrix[0]))\\n    }\\n    copy(dp[0], matrix[0])\\n\\n    for i := 1; i < len(dp); i++ {\\n        for j := 0; j < len(dp[0]); j++ {\\n            var minPathAbove int\\n\\n            switch j {\\n            case 0:\\n                minPathAbove = min([]int{dp[i-1][j], dp[i-1][j+1]})\\n            case len(dp[0])-1:\\n                minPathAbove = min([]int{dp[i-1][j-1], dp[i-1][j]})\\n            default:\\n                minPathAbove = min([]int{dp[i-1][j-1], dp[i-1][j], dp[i-1][j+1]})\\n            }\\n            \\n            dp[i][j] = minPathAbove + matrix[i][j]\\n        }\\n    }\\n\\n    return min(dp[len(dp)-1])\\n}\\n\\nfunc min(a []int) int {\\n    curMin := a[0]\\n    for _, elem := range a {\\n        if elem < curMin {\\n            curMin = elem\\n        }\\n    }\\n    return curMin\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Array",
                    "Dynamic Programming",
                    "Matrix"
                ],
                "code": "```\\nfunc minFallingPathSum(matrix [][]int) int {\\n    dp := make([][]int, len(matrix))\\n    for i := range dp {\\n        dp[i] = make([]int, len(matrix[0]))\\n    }\\n    copy(dp[0], matrix[0])\\n\\n    for i := 1; i < len(dp); i++ {\\n        for j := 0; j < len(dp[0]); j++ {\\n            var minPathAbove int\\n\\n            switch j {\\n            case 0:\\n                minPathAbove = min([]int{dp[i-1][j], dp[i-1][j+1]})\\n            case len(dp[0])-1:\\n                minPathAbove = min([]int{dp[i-1][j-1], dp[i-1][j]})\\n            default:\\n                minPathAbove = min([]int{dp[i-1][j-1], dp[i-1][j], dp[i-1][j+1]})\\n            }\\n            \\n            dp[i][j] = minPathAbove + matrix[i][j]\\n        }\\n    }\\n\\n    return min(dp[len(dp)-1])\\n}\\n\\nfunc min(a []int) int {\\n    curMin := a[0]\\n    for _, elem := range a {\\n        if elem < curMin {\\n            curMin = elem\\n        }\\n    }\\n    return curMin\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2847369,
                "title": "python-dp",
                "content": "class Solution:\\n    def minFallingPathSum(self, matrix: List[List[int]]) -> int:\\n        m=len(matrix)\\n        n=len(matrix[0])\\n        dp=[[0 for i in range(n)] for j in range(m)]\\n        for i in range(0,m):\\n            for j in range(0,n):\\n                if(i>0):\\n                    if(j-1>=0 and j+1<n):\\n                        dp[i][j]=matrix[i][j]+min(dp[i-1][j-1],dp[i-1][j],dp[i-1][j+1])\\n                    elif(j==0):\\n                        dp[i][j]=matrix[i][j]+min(dp[i-1][j],dp[i-1][j+1])\\n                    else:\\n                        dp[i][j]=matrix[i][j]+min(dp[i-1][j],dp[i-1][j-1])\\n                else:\\n                    dp[i][j]=matrix[i][j]\\n        return min(dp[-1])\\n",
                "solutionTags": [],
                "code": "class Solution:\\n    def minFallingPathSum(self, matrix: List[List[int]]) -> int:\\n        m=len(matrix)\\n        n=len(matrix[0])\\n        dp=[[0 for i in range(n)] for j in range(m)]\\n        for i in range(0,m):\\n            for j in range(0,n):\\n                if(i>0):\\n                    if(j-1>=0 and j+1<n):\\n                        dp[i][j]=matrix[i][j]+min(dp[i-1][j-1],dp[i-1][j],dp[i-1][j+1])\\n                    elif(j==0):\\n                        dp[i][j]=matrix[i][j]+min(dp[i-1][j],dp[i-1][j+1])\\n                    else:\\n                        dp[i][j]=matrix[i][j]+min(dp[i-1][j],dp[i-1][j-1])\\n                else:\\n                    dp[i][j]=matrix[i][j]\\n        return min(dp[-1])\\n",
                "codeTag": "Java"
            },
            {
                "id": 2617250,
                "title": "what-s-wrong-in-the-memoization-code-runtime-error",
                "content": "Here\\'s my code: \\n```\\nclass Solution {\\npublic:\\n    int solve(int i, int j, vector<vector<int>>& mat, vector<vector<int>> &dp){\\n        if(i == 0) return mat[0][j];\\n        if(j < 0 || j >= mat[0].size()) return 1e9;\\n        \\n        if(dp[i][j] != -1) return dp[i][j];\\n        int up = mat[i][j] + solve(i-1,j,mat,dp);\\n        int upl = mat[i][j] + solve(i-1,j-1,mat,dp);\\n        int upr = mat[i][j] + solve(i-1,j+1,mat,dp);\\n        \\n        return dp[i][j] = min(up,min(upl,upr));\\n    }\\n    \\n    int minFallingPathSum(vector<vector<int>>& mat) {\\n        int m = mat.size();\\n        int n = mat[0].size();\\n        vector<vector<int>> dp(m,vector<int>(n,-1));\\n        int mini = 1e9;\\n        for(int i=0;i<n;i++){\\n            mini = min(mini,solve(n-1,i,mat,dp));\\n        }\\n        return mini;\\n    }\\n};\\n```\\nError:\\n```\\nLine 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000090 overflowed to 0x60200000008c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34\\n```\\n",
                "solutionTags": [
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int i, int j, vector<vector<int>>& mat, vector<vector<int>> &dp){\\n        if(i == 0) return mat[0][j];\\n        if(j < 0 || j >= mat[0].size()) return 1e9;\\n        \\n        if(dp[i][j] != -1) return dp[i][j];\\n        int up = mat[i][j] + solve(i-1,j,mat,dp);\\n        int upl = mat[i][j] + solve(i-1,j-1,mat,dp);\\n        int upr = mat[i][j] + solve(i-1,j+1,mat,dp);\\n        \\n        return dp[i][j] = min(up,min(upl,upr));\\n    }\\n    \\n    int minFallingPathSum(vector<vector<int>>& mat) {\\n        int m = mat.size();\\n        int n = mat[0].size();\\n        vector<vector<int>> dp(m,vector<int>(n,-1));\\n        int mini = 1e9;\\n        for(int i=0;i<n;i++){\\n            mini = min(mini,solve(n-1,i,mat,dp));\\n        }\\n        return mini;\\n    }\\n};\\n```\n```\\nLine 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000090 overflowed to 0x60200000008c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2540020,
                "title": "faster-than-99-71-14-6-mb-less-than-89-60",
                "content": "```\\nclass Solution:\\n    def minFallingPathSum(self, matrix: List[List[int]]) -> int:\\n        n=len(matrix)\\n        dp=[[-1]*n for i in range(n)]\\n        for i in range(n):\\n            (dp[n-1])[i]=(matrix[n-1])[i]\\n\\n        for i in range(n-2,-1,-1):\\n            for j in range(n):\\n                leftd=99999\\n                rightd=99999\\n                down=(dp[i+1])[j]\\n                if j==0:\\n                    rightd=(dp[i+1])[j+1]\\n                elif j==n-1:\\n                    leftd=(dp[i+1])[j-1]\\n                else:  \\n                    rightd=(dp[i+1])[j+1]\\n                    leftd=(dp[i+1])[j-1]\\n\\n                (dp[i])[j]=((matrix[i])[j]+min(rightd,leftd,down))\\n\\n        return min(dp[0])\\n\\t\\t\\n\\t\\t\\n\\t\\t\\nMemoization \\n\\n```\\n```\\nclass Solution:\\n    def minFallingPathSum(self, matrix: List[List[int]]) -> int:\\n        def fun(i,j,Arry,n,dp):\\n            if i==n-1:\\n                (dp[i])[j]=(Arry[i])[j]\\n                return (dp[i])[j]\\n\\n            if (dp[i])[j]!=-1:\\n                return (dp[i])[j]\\n\\n            leftd=99999\\n            rightd=99999\\n            down=fun(i+1,j,Arry,n,dp)\\n            if j==0:\\n                rightd=fun(i+1,j+1,Arry,n,dp)\\n            elif j==n-1:\\n                leftd=fun(i+1,j-1,Arry,n,dp)\\n            else:  \\n                rightd=fun(i+1,j+1,Arry,n,dp)\\n                leftd=fun(i+1,j-1,Arry,n,dp)\\n\\n            (dp[i])[j]=((Arry[i])[j]+min(rightd,leftd,down))\\n            return (dp[i])[j]\\n\\n        \\n        \\n        \\n       \\n        n=len(matrix)\\n        dp=[[-1]*n for i in range(n)]\\n        \\n        mini=99999\\n        for x in range(n):\\n            mini=min(mini,fun(0,x,matrix,n,dp))\\n\\n        return(mini)\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minFallingPathSum(self, matrix: List[List[int]]) -> int:\\n        n=len(matrix)\\n        dp=[[-1]*n for i in range(n)]\\n        for i in range(n):\\n            (dp[n-1])[i]=(matrix[n-1])[i]\\n\\n        for i in range(n-2,-1,-1):\\n            for j in range(n):\\n                leftd=99999\\n                rightd=99999\\n                down=(dp[i+1])[j]\\n                if j==0:\\n                    rightd=(dp[i+1])[j+1]\\n                elif j==n-1:\\n                    leftd=(dp[i+1])[j-1]\\n                else:  \\n                    rightd=(dp[i+1])[j+1]\\n                    leftd=(dp[i+1])[j-1]\\n\\n                (dp[i])[j]=((matrix[i])[j]+min(rightd,leftd,down))\\n\\n        return min(dp[0])\\n\\t\\t\\n\\t\\t\\n\\t\\t\\nMemoization \\n\\n```\n```\\nclass Solution:\\n    def minFallingPathSum(self, matrix: List[List[int]]) -> int:\\n        def fun(i,j,Arry,n,dp):\\n            if i==n-1:\\n                (dp[i])[j]=(Arry[i])[j]\\n                return (dp[i])[j]\\n\\n            if (dp[i])[j]!=-1:\\n                return (dp[i])[j]\\n\\n            leftd=99999\\n            rightd=99999\\n            down=fun(i+1,j,Arry,n,dp)\\n            if j==0:\\n                rightd=fun(i+1,j+1,Arry,n,dp)\\n            elif j==n-1:\\n                leftd=fun(i+1,j-1,Arry,n,dp)\\n            else:  \\n                rightd=fun(i+1,j+1,Arry,n,dp)\\n                leftd=fun(i+1,j-1,Arry,n,dp)\\n\\n            (dp[i])[j]=((Arry[i])[j]+min(rightd,leftd,down))\\n            return (dp[i])[j]\\n\\n        \\n        \\n        \\n       \\n        n=len(matrix)\\n        dp=[[-1]*n for i in range(n)]\\n        \\n        mini=99999\\n        for x in range(n):\\n            mini=min(mini,fun(0,x,matrix,n,dp))\\n\\n        return(mini)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2472309,
                "title": "simple-java-solution",
                "content": "Solution - 1  (dp table memorization)\\n```\\nclass Solution {\\n    public int minFallingPathSum(int[][] m) {\\n        int k=m.length;\\n        int n=Integer.MAX_VALUE;\\n        int dp[][] = new int[k][k];\\n        for(int a[]:dp)\\n        {\\n            Arrays.fill(a,-1);\\n        }\\n        for(int i=0;i<k;i++)\\n        {\\n            n=Math.min(n,task(k,i,k-1,m,dp));\\n        }\\n        return n;\\n    }\\n    public int task(int n, int j, int i, int m[][], int dp[][])\\n    {\\n        if(j<0||j>=n)\\n            return Integer.MAX_VALUE;\\n        if(i==0)\\n            return m[0][j];\\n        if(dp[i][j] != -1)\\n            return dp[i][j];\\n        else\\n            return dp[i][j] = m[i][j]+Math.min(task(n,j-1,i-1,m,dp),Math.min(task(n,j,i-1,m,dp),task(n,j+1,i-1,m,dp)));\\n    }\\n}\\n```\\n\\nSolution - 2 (dp table iterative with space optimized)\\n```\\nclass Solution {\\n    public int minFallingPathSum(int[][] m) {\\n        int k=m.length;\\n        int n=Integer.MAX_VALUE;\\n        int dp[] = new int[k];\\n        for(int i=0;i<k;i++)\\n        {\\n            dp[i]=m[0][i];\\n        }\\n        for(int i=1;i<k;i++)\\n        {\\n            int a[] = new int[k];\\n            for(int j=0;j<k;j++)\\n            {\\n                if(j==0)\\n                {\\n                    a[j]=m[i][j]+Math.min(dp[j],dp[j+1]);\\n                }\\n                else if(j==k-1)\\n                {\\n                    a[j]=m[i][j]+Math.min(dp[j],dp[j-1]);\\n                }\\n                else\\n                {\\n                    a[j]=m[i][j]+Math.min(dp[j],Math.min(dp[j+1],dp[j-1]));\\n                }\\n            }\\n            dp=a;\\n        }\\n        int f=Integer.MAX_VALUE;\\n        for(int i=0;i<k;i++)\\n        {\\n            f=Math.min(f,dp[i]);\\n        }\\n        return f;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public int minFallingPathSum(int[][] m) {\\n        int k=m.length;\\n        int n=Integer.MAX_VALUE;\\n        int dp[][] = new int[k][k];\\n        for(int a[]:dp)\\n        {\\n            Arrays.fill(a,-1);\\n        }\\n        for(int i=0;i<k;i++)\\n        {\\n            n=Math.min(n,task(k,i,k-1,m,dp));\\n        }\\n        return n;\\n    }\\n    public int task(int n, int j, int i, int m[][], int dp[][])\\n    {\\n        if(j<0||j>=n)\\n            return Integer.MAX_VALUE;\\n        if(i==0)\\n            return m[0][j];\\n        if(dp[i][j] != -1)\\n            return dp[i][j];\\n        else\\n            return dp[i][j] = m[i][j]+Math.min(task(n,j-1,i-1,m,dp),Math.min(task(n,j,i-1,m,dp),task(n,j+1,i-1,m,dp)));\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minFallingPathSum(int[][] m) {\\n        int k=m.length;\\n        int n=Integer.MAX_VALUE;\\n        int dp[] = new int[k];\\n        for(int i=0;i<k;i++)\\n        {\\n            dp[i]=m[0][i];\\n        }\\n        for(int i=1;i<k;i++)\\n        {\\n            int a[] = new int[k];\\n            for(int j=0;j<k;j++)\\n            {\\n                if(j==0)\\n                {\\n                    a[j]=m[i][j]+Math.min(dp[j],dp[j+1]);\\n                }\\n                else if(j==k-1)\\n                {\\n                    a[j]=m[i][j]+Math.min(dp[j],dp[j-1]);\\n                }\\n                else\\n                {\\n                    a[j]=m[i][j]+Math.min(dp[j],Math.min(dp[j+1],dp[j-1]));\\n                }\\n            }\\n            dp=a;\\n        }\\n        int f=Integer.MAX_VALUE;\\n        for(int i=0;i<k;i++)\\n        {\\n            f=Math.min(f,dp[i]);\\n        }\\n        return f;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2418850,
                "title": "c-rec-mem-tab-so-so-inplace-99-faster",
                "content": "\\tint solveRec(vector<vector<int>>& matrix, int i, int j, int n, int m)\\n    {\\n        if(j<0||j>=m) return INT_MAX;\\n        if(i==n-1) return matrix[i][j];\\n        int lDiag=solveRec(matrix,i+1,j-1,n,m);\\n        int bottom=solveRec(matrix,i+1,j,n,m);\\n        int rDiag=solveRec(matrix,i+1,j+1,n,m);\\n        return matrix[i][j]+min(lDiag,min(bottom,rDiag));\\n    }\\n    \\n    int solveMem(vector<vector<int>>& matrix, int i, int j, int n, int m, vector<vector<int>> &dp)\\n    {\\n        if(j<0||j>=m) return INT_MAX;\\n        if(i==n-1) return matrix[i][j];\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int lDiag=solveMem(matrix,i+1,j-1,n,m,dp);\\n        int bottom=solveMem(matrix,i+1,j,n,m,dp);\\n        int rDiag=solveMem(matrix,i+1,j+1,n,m,dp);\\n        return dp[i][j]=matrix[i][j]+min(lDiag,min(bottom,rDiag));\\n    }\\n    \\n    int solveTab(vector<vector<int>>& matrix, int n, int m)\\n    {\\n        vector<vector<int>> dp(n,vector<int>(m));\\n        //Fill up the last row as it is\\n        for(int j=0;j<m;j++)  dp[n-1][j]=matrix[n-1][j];\\n        \\n        for(int i=n-2;i>=0;i--)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                int lDiag=INT_MAX; //only fill it when it is inside our range \\n                int rDiag=INT_MAX;\\n                if(j-1>=0)  lDiag=dp[i+1][j-1];\\n                int bottom=dp[i+1][j]; //this will always be inside the matrix\\n                if(j+1<m)   rDiag=dp[i+1][j+1];\\n                \\n                dp[i][j]=matrix[i][j]+min(lDiag,min(bottom,rDiag));\\n            }\\n        }\\n        int ans=INT_MAX;\\n        \\n        //Grab the least among the first row and return it\\n        for(int j=0;j<m;j++) ans=min(ans,dp[0][j]);\\n        return ans;\\n        \\n    }\\n    \\n    int solveSO(vector<vector<int>>& matrix, int n, int m)\\n    {\\n        vector<int>next(m);\\n        for(int j=0;j<m;j++)  next[j]=matrix[n-1][j];\\n        \\n        for(int i=n-2;i>=0;i--)\\n        {\\n            vector<int>cur(m);\\n            for(int j=0;j<m;j++)\\n            {\\n                int lDiag=INT_MAX;\\n                int rDiag=INT_MAX;\\n                if(j-1>=0)  lDiag=next[j-1];\\n                int bottom=next[j]; \\n                if(j+1<m)   rDiag=next[j+1];\\n                \\n                cur[j]=matrix[i][j]+min(lDiag,min(bottom,rDiag));\\n            }\\n            next=cur;\\n        }\\n        int ans=INT_MAX;\\n        \\n        for(int j=0;j<m;j++) ans=min(ans,next[j]);\\n        return ans;\\n        \\n    }\\n    \\n    int solveSOMore(vector<vector<int>>& matrix, int n, int m)\\n    {        \\n        for(int i=n-2;i>=0;i--)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                int lDiag=INT_MAX;\\n                int rDiag=INT_MAX;\\n                if(j-1>=0)  lDiag=matrix[i+1][j-1];\\n                int bottom=matrix[i+1][j]; \\n                if(j+1<m)   rDiag=matrix[i+1][j+1];\\n                \\n                matrix[i][j]=matrix[i][j]+min(lDiag,min(bottom,rDiag));\\n            }\\n        }\\n        \\n        int ans=INT_MAX;\\n        for(int j=0;j<m;j++) ans=min(ans,matrix[0][j]);\\n        return ans;\\n    }\\n    \\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int n=matrix.size(); int m=matrix[0].size();\\n        // vector<vector<int>> dp(n+1,vector<int>(m+1,-1));\\n        int ans=INT_MAX;\\n        // for(int j=0;j<m;j++)\\n        // {\\n        //     ans=min(ans,solveRec(matrix,0,j,n,m,dp));\\n        //     ans=min(ans,solveMem(matrix,0,j,n,m,dp));\\n        // }\\n        // ans=solveTab(matrix,n,m);\\n        // ans=solveSO(matrix,n,m);\\n        ans=solveSOMore(matrix,n,m);\\n        return ans;\\n    }",
                "solutionTags": [],
                "code": "\\tint solveRec(vector<vector<int>>& matrix, int i, int j, int n, int m)\\n    {\\n        if(j<0||j>=m) return INT_MAX;\\n        if(i==n-1) return matrix[i][j];\\n        int lDiag=solveRec(matrix,i+1,j-1,n,m);\\n        int bottom=solveRec(matrix,i+1,j,n,m);\\n        int rDiag=solveRec(matrix,i+1,j+1,n,m);\\n        return matrix[i][j]+min(lDiag,min(bottom,rDiag));\\n    }\\n    \\n    int solveMem(vector<vector<int>>& matrix, int i, int j, int n, int m, vector<vector<int>> &dp)\\n    {\\n        if(j<0||j>=m) return INT_MAX;\\n        if(i==n-1) return matrix[i][j];\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int lDiag=solveMem(matrix,i+1,j-1,n,m,dp);\\n        int bottom=solveMem(matrix,i+1,j,n,m,dp);\\n        int rDiag=solveMem(matrix,i+1,j+1,n,m,dp);\\n        return dp[i][j]=matrix[i][j]+min(lDiag,min(bottom,rDiag));\\n    }\\n    \\n    int solveTab(vector<vector<int>>& matrix, int n, int m)\\n    {\\n        vector<vector<int>> dp(n,vector<int>(m));\\n        //Fill up the last row as it is\\n        for(int j=0;j<m;j++)  dp[n-1][j]=matrix[n-1][j];\\n        \\n        for(int i=n-2;i>=0;i--)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                int lDiag=INT_MAX; //only fill it when it is inside our range \\n                int rDiag=INT_MAX;\\n                if(j-1>=0)  lDiag=dp[i+1][j-1];\\n                int bottom=dp[i+1][j]; //this will always be inside the matrix\\n                if(j+1<m)   rDiag=dp[i+1][j+1];\\n                \\n                dp[i][j]=matrix[i][j]+min(lDiag,min(bottom,rDiag));\\n            }\\n        }\\n        int ans=INT_MAX;\\n        \\n        //Grab the least among the first row and return it\\n        for(int j=0;j<m;j++) ans=min(ans,dp[0][j]);\\n        return ans;\\n        \\n    }\\n    \\n    int solveSO(vector<vector<int>>& matrix, int n, int m)\\n    {\\n        vector<int>next(m);\\n        for(int j=0;j<m;j++)  next[j]=matrix[n-1][j];\\n        \\n        for(int i=n-2;i>=0;i--)\\n        {\\n            vector<int>cur(m);\\n            for(int j=0;j<m;j++)\\n            {\\n                int lDiag=INT_MAX;\\n                int rDiag=INT_MAX;\\n                if(j-1>=0)  lDiag=next[j-1];\\n                int bottom=next[j]; \\n                if(j+1<m)   rDiag=next[j+1];\\n                \\n                cur[j]=matrix[i][j]+min(lDiag,min(bottom,rDiag));\\n            }\\n            next=cur;\\n        }\\n        int ans=INT_MAX;\\n        \\n        for(int j=0;j<m;j++) ans=min(ans,next[j]);\\n        return ans;\\n        \\n    }\\n    \\n    int solveSOMore(vector<vector<int>>& matrix, int n, int m)\\n    {        \\n        for(int i=n-2;i>=0;i--)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                int lDiag=INT_MAX;\\n                int rDiag=INT_MAX;\\n                if(j-1>=0)  lDiag=matrix[i+1][j-1];\\n                int bottom=matrix[i+1][j]; \\n                if(j+1<m)   rDiag=matrix[i+1][j+1];\\n                \\n                matrix[i][j]=matrix[i][j]+min(lDiag,min(bottom,rDiag));\\n            }\\n        }\\n        \\n        int ans=INT_MAX;\\n        for(int j=0;j<m;j++) ans=min(ans,matrix[0][j]);\\n        return ans;\\n    }\\n    \\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int n=matrix.size(); int m=matrix[0].size();\\n        // vector<vector<int>> dp(n+1,vector<int>(m+1,-1));\\n        int ans=INT_MAX;\\n        // for(int j=0;j<m;j++)\\n        // {\\n        //     ans=min(ans,solveRec(matrix,0,j,n,m,dp));\\n        //     ans=min(ans,solveMem(matrix,0,j,n,m,dp));\\n        // }\\n        // ans=solveTab(matrix,n,m);\\n        // ans=solveSO(matrix,n,m);\\n        ans=solveSOMore(matrix,n,m);\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2406783,
                "title": "dynamic-programming-3-approaches",
                "content": "Approach 1 - Recursion only ( TLE Appraoch)\\n```\\n\\tint rec(vector<vector<int>>& mat, int c, int r, int n) {\\n        if(r == n-1) return mat[r][c];\\n        \\n        int left = INT_MAX, right;\\n        if(c>0) left = rec(mat, c-1, r+1, n);\\n        int down = rec(mat, c  , r+1, n);\\n        if(c<n-1) right = rec(mat, c+1, r+1, n);\\n        \\n        int mn = min(down, min(left, right));\\n        return (mat[r][c] + mn);\\n    }\\n    \\n    int minFallingPathSum(vector<vector<int>>& mat) {\\n        int n = mat.size();\\n        \\n        int ans = INT_MAX;\\n        for(int i=0;i<n;i++) {\\n            ans = min(ans, rec(mat, i, 0, n));\\n        }\\n        \\n        return ans;\\n    }\\n```\\n\\nApproach 2 - Recursion + Memoization\\n```\\n\\tint rec(vector<vector<int>>& mat, vector<vector<int>>& dp, int c, int r, int n) {\\n        if(r == n-1) return mat[r][c];\\n        if(dp[r][c] != -1) return dp[r][c];\\n        \\n        int left = INT_MAX, right;\\n        if(c>0) left = rec(mat, dp, c-1, r+1, n);\\n        int down = rec(mat, dp, c  , r+1, n);\\n        if(c<n-1) right = rec(mat, dp, c+1, r+1, n);\\n        \\n        int mn = min(down, min(left, right));\\n        return dp[r][c] = (mat[r][c] + mn);\\n    }\\n    int minFallingPathSum(vector<vector<int>>& mat) {\\n        int n = mat.size();\\n        \\n        vector<vector<int>> dp(n, vector<int> (n, -1));\\n        int ans = INT_MAX;\\n        \\n        for(int i=0;i<n;i++) {\\n            ans = min(ans, rec(mat, dp, i, 0, n));\\n        }\\n        \\n        return ans;\\n    }\\n```\\n\\nApproach 3 - Tabulation\\n```\\n\\tint minFallingPathSum(vector<vector<int>>& mat) {\\n        int n = mat.size();\\n        \\n        vector<vector<int>> dp(n, vector<int> (n, -1));\\n        int ans = INT_MAX;\\n        \\n        for(int i=0;i<n;i++) {\\n            for(int j=0;j<n;j++) {\\n                if(i==0) dp[i][j] = mat[i][j];\\n                else {\\n                    int u = dp[i-1][j];\\n                    int l = INT_MAX, r = INT_MAX;\\n                    if(j>0) l = dp[i-1][j-1];\\n                    if(j<n-1) r=dp[i-1][j+1];\\n                    \\n                    dp[i][j] = min(u, min(l, r)) + mat[i][j];\\n                }\\n                \\n                if(i==n-1) ans = min(ans, dp[i][j]);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n```\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n\\tint rec(vector<vector<int>>& mat, int c, int r, int n) {\\n        if(r == n-1) return mat[r][c];\\n        \\n        int left = INT_MAX, right;\\n        if(c>0) left = rec(mat, c-1, r+1, n);\\n        int down = rec(mat, c  , r+1, n);\\n        if(c<n-1) right = rec(mat, c+1, r+1, n);\\n        \\n        int mn = min(down, min(left, right));\\n        return (mat[r][c] + mn);\\n    }\\n    \\n    int minFallingPathSum(vector<vector<int>>& mat) {\\n        int n = mat.size();\\n        \\n        int ans = INT_MAX;\\n        for(int i=0;i<n;i++) {\\n            ans = min(ans, rec(mat, i, 0, n));\\n        }\\n        \\n        return ans;\\n    }\\n```\n```\\n\\tint rec(vector<vector<int>>& mat, vector<vector<int>>& dp, int c, int r, int n) {\\n        if(r == n-1) return mat[r][c];\\n        if(dp[r][c] != -1) return dp[r][c];\\n        \\n        int left = INT_MAX, right;\\n        if(c>0) left = rec(mat, dp, c-1, r+1, n);\\n        int down = rec(mat, dp, c  , r+1, n);\\n        if(c<n-1) right = rec(mat, dp, c+1, r+1, n);\\n        \\n        int mn = min(down, min(left, right));\\n        return dp[r][c] = (mat[r][c] + mn);\\n    }\\n    int minFallingPathSum(vector<vector<int>>& mat) {\\n        int n = mat.size();\\n        \\n        vector<vector<int>> dp(n, vector<int> (n, -1));\\n        int ans = INT_MAX;\\n        \\n        for(int i=0;i<n;i++) {\\n            ans = min(ans, rec(mat, dp, i, 0, n));\\n        }\\n        \\n        return ans;\\n    }\\n```\n```\\n\\tint minFallingPathSum(vector<vector<int>>& mat) {\\n        int n = mat.size();\\n        \\n        vector<vector<int>> dp(n, vector<int> (n, -1));\\n        int ans = INT_MAX;\\n        \\n        for(int i=0;i<n;i++) {\\n            for(int j=0;j<n;j++) {\\n                if(i==0) dp[i][j] = mat[i][j];\\n                else {\\n                    int u = dp[i-1][j];\\n                    int l = INT_MAX, r = INT_MAX;\\n                    if(j>0) l = dp[i-1][j-1];\\n                    if(j<n-1) r=dp[i-1][j+1];\\n                    \\n                    dp[i][j] = min(u, min(l, r)) + mat[i][j];\\n                }\\n                \\n                if(i==n-1) ans = min(ans, dp[i][j]);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2406284,
                "title": "c-recursion-memoization-tabulation-spaceoptimization",
                "content": "# Method - 1 [Recursion - Bruteforce]\\n![image](https://assets.leetcode.com/users/images/ccff0257-08ed-4483-a58f-0be8fff59853_1660126376.7057586.png)\\n\\n**T->O(3^(n)) && S->O(n) [Recursion Stack Space]**\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint f(int i,int j,vector<vector<int>>& mat){\\n\\t\\t\\tif(j<0 || j>=mat.size()) return 1e6;\\n\\t\\t\\tif(i==mat.size()-1) return mat[i][j];\\n\\t\\t\\tint left = mat[i][j] + f(i+1,j-1,mat); \\n\\t\\t\\tint down = mat[i][j] + f(i+1,j,mat);\\n\\t\\t\\tint right = mat[i][j] + f(i+1,j+1,mat);\\n\\t\\t\\treturn min(down,min(left,right)); \\n\\t\\t}\\n\\n\\t\\tint minFallingPathSum(vector<vector<int>>& mat) {\\n\\t\\t\\tint n=mat.size();\\n\\t\\t\\tint ans=INT_MAX;\\n\\t\\t\\tfor(int j=0;j<n;j++) ans=min(ans,f(0,j,mat));\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};\\n\\n\\n# Method - 2 [Memoization]\\n![image](https://assets.leetcode.com/users/images/3cbc847f-13ca-4122-a0ce-dadae9bb70ee_1660126484.8591104.png)\\n\\n**T->O(n * n) && S->O(n) [Recursion Stack Space] + O(n * n) [Space for dp Matrix]**\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint f(int i,int j,vector<vector<int>>& mat,vector<vector<int>>& dp){\\n\\t\\t\\tif(j<0 || j>=mat.size()) return 1e6;\\n\\t\\t\\tif(i==mat.size()-1) return mat[i][j];\\n\\t\\t\\tif(dp[i][j]!=-1) return dp[i][j];\\n\\t\\t\\tint left = mat[i][j] + f(i+1,j-1,mat,dp); \\n\\t\\t\\tint down = mat[i][j] + f(i+1,j,mat,dp);\\n\\t\\t\\tint right = mat[i][j] + f(i+1,j+1,mat,dp);\\n\\t\\t\\treturn dp[i][j] = min(down,min(left,right)); \\n\\t\\t}\\n\\n\\t\\tint minFallingPathSum(vector<vector<int>>& mat) {\\n\\t\\t\\tint n=mat.size();\\n\\t\\t\\tint ans=INT_MAX;\\n\\t\\t\\tvector<vector<int>>dp(n,vector<int>(n,-1));\\n\\t\\t\\tfor(int j=0;j<n;j++) ans=min(ans,f(0,j,mat,dp));\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};\\n\\n\\n# Method - 3 [Tabulation]\\n\\n![image](https://assets.leetcode.com/users/images/6dc28f26-0411-4ee7-9b53-0365d4e7b77d_1660126223.16893.png)\\n\\n**T->O(n * n) && S->O(n * n) [Space for dp matrix]**\\n\\n\\tclass Solution {\\n\\tpublic:    \\n\\t\\tint minFallingPathSum(vector<vector<int>>& mat) {\\n\\t\\t\\tint n=mat.size();\\n\\t\\t\\tvector<vector<int>>dp(n,vector<int>(n,0));\\n\\t\\t\\tfor(int j=0;j<n;j++) dp[n-1][j]=mat[n-1][j];\\n\\t\\t\\tfor(int i=n-2;i>=0;i--){\\n\\t\\t\\t\\tfor(int j=0;j<n;j++){\\n\\t\\t\\t\\t\\tint left=INT_MAX,right=INT_MAX;\\n\\t\\t\\t\\t\\tif(j>0) left = mat[i][j] + dp[i+1][j-1]; \\n\\t\\t\\t\\t\\tint down = mat[i][j] + dp[i+1][j];\\n\\t\\t\\t\\t\\tif(j<n-1) right = mat[i][j] + dp[i+1][j+1];\\n\\t\\t\\t\\t\\tdp[i][j] = min(down,min(left,right));\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn *min_element(dp[0].begin(),dp[0].end());\\n\\t\\t}\\n\\t};\\n\\t\\n# Method-4 [Space Optimization]\\t\\n![image](https://assets.leetcode.com/users/images/9f07bd0e-894e-456c-aa08-72f937436b6d_1660127095.6840546.png)\\n\\n**T->O(n * n) && S->O(n) [Space for Prevrow vector]**\\n\\n\\tclass Solution {\\n\\tpublic:    \\n\\t\\tint minFallingPathSum(vector<vector<int>>& mat) {\\n\\t\\t\\tint n=mat.size();\\n\\t\\t\\tvector<int> prevrow(n);\\n\\t\\t\\tfor(int j=0;j<n;j++) prevrow[j]=mat[n-1][j];\\n\\t\\t\\tfor(int i=n-2;i>=0;i--){\\n\\t\\t\\t\\tvector<int> currrow(n);\\n\\t\\t\\t\\tfor(int j=0;j<n;j++){\\n\\t\\t\\t\\t\\tint left=INT_MAX,right=INT_MAX;\\n\\t\\t\\t\\t\\tif(j>0) left = mat[i][j] + prevrow[j-1]; \\n\\t\\t\\t\\t\\tint down = mat[i][j] + prevrow[j];\\n\\t\\t\\t\\t\\tif(j<n-1) right = mat[i][j] + prevrow[j+1];\\n\\t\\t\\t\\t\\tcurrrow[j] = min(down,min(left,right));\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tprevrow=currrow;\\n\\t\\t\\t}\\n\\t\\t\\treturn *min_element(prevrow.begin(),prevrow.end());\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint f(int i,int j,vector<vector<int>>& mat){\\n\\t\\t\\tif(j<0 || j>=mat.size()) return 1e6;\\n\\t\\t\\tif(i==mat.size()-1) return mat[i][j];\\n\\t\\t\\tint left = mat[i][j] + f(i+1,j-1,mat); \\n\\t\\t\\tint down = mat[i][j] + f(i+1,j,mat);\\n\\t\\t\\tint right = mat[i][j] + f(i+1,j+1,mat);\\n\\t\\t\\treturn min(down,min(left,right)); \\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2401168,
                "title": "python-recursion-dp-optimization",
                "content": "\\n**This is a  recursive approach (TLE)**\\n```  \\n\\nclass Solution(object):\\n    def minFallingPathSum(self, matrix):\\n        \"\"\"\\n        :type matrix: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        \\n        n=len(matrix)\\n\\n        \\n        def A(row,col):\\n\\t\\t\\t#handling edge cases\\n            if col<0 or col>n-1:return float(\\'inf\\')\\n            # if we reach last row \\n            if row==n-1:\\n                return matrix[row][col]\\n            \\n\\t\\t\\t#find the minimum path from curr(row,col)\\n            a=matrix[row][col]+A(row+1,col+1)\\n            b=matrix[row][col]+A(row+1,col)\\n            c=matrix[row][col]+A(row+1,col-1)\\n            \\n\\t\\t\\t#store the minimum path \\n            ans=min(a,b,c)\\n            \\n            \\n            return ans\\n        \\n        m=float(\\'inf\\')\\n        for x in range(n):\\n            m=min(m,A(0,x))\\n        return m\\n             ```\\n\\t\\t\\t \\n\\nThis is optimization of recursive approach  using DP (Above approach is Recursive )(Accepted)\\n\\n\\nclass Solution(object):\\n    def minFallingPathSum(self, matrix):\\n        \"\"\"\\n        :type matrix: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        \\n        n=len(matrix)\\n        \\n        dp=[[-1 for y in range(n)] for x in range(n)]\\n\\n        \\n        def A(row,col):\\n            if col<0 or col>n-1:return float(\\'inf\\')\\n            \\n            if row==n-1:\\n                dp[row][col]=matrix[row][col]\\n                return matrix[row][col]\\n            \\n            if dp[row][col]!=-1:\\n                return dp[row][col]\\n            \\n            \\n            \\n            a=matrix[row][col]+A(row+1,col+1)\\n            b=matrix[row][col]+A(row+1,col)\\n            c=matrix[row][col]+A(row+1,col-1)\\n            \\n            dp[row][col]=min(a,b,c)\\n            \\n            return dp[row][col]\\n            \\n        \\n        \\n        m=float(\\'inf\\')\\n        for x in range(n):\\n            A(0,x)\\n        return min(dp[0])\\n        \\n            \\n            \\n            \\n                ```\\n",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```  \\n\\nclass Solution(object):\\n    def minFallingPathSum(self, matrix):\\n        \"\"\"\\n        :type matrix: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        \\n        n=len(matrix)\\n\\n        \\n        def A(row,col):\\n\\t\\t\\t#handling edge cases\\n            if col<0 or col>n-1:return float(\\'inf\\')\\n            # if we reach last row \\n            if row==n-1:\\n                return matrix[row][col]\\n            \\n\\t\\t\\t#find the minimum path from curr(row,col)\\n            a=matrix[row][col]+A(row+1,col+1)\\n            b=matrix[row][col]+A(row+1,col)\\n            c=matrix[row][col]+A(row+1,col-1)\\n            \\n\\t\\t\\t#store the minimum path \\n            ans=min(a,b,c)\\n            \\n            \\n            return ans\\n        \\n        m=float(\\'inf\\')\\n        for x in range(n):\\n            m=min(m,A(0,x))\\n        return m\\n             ```",
                "codeTag": "Java"
            },
            {
                "id": 2373582,
                "title": "from-memoization-to-space-optimized",
                "content": "```\\nclass Solution {\\n    // public int helper(int i,int j,int n,int [][]matrix,int dp[][])\\n    // {//memo\\n    //     if(j<0 || j>=n) return (int)Math.pow(10,9);//for  preventing out of bound \\n    //     if(i==0)return matrix[i][j];// once we reach the 1st row we will return element\\\\\\n    //     if(dp[i][j]!=-1) return dp[i][j];\\n    //     int up=matrix[i][j]+helper(i-1,j,n,matrix,dp);\\n    //     int upleft=matrix[i][j]+helper(i-1,j-1,n,matrix,dp);\\n    //     int upright=matrix[i][j]+helper(i-1,j+1,n,matrix,dp);\\n    //     return dp[i][j]=Math.min(up,Math.min(upleft,upright));\\n    // }\\n    \\n    \\n//     public int minFallingPathSum(int[][] matrix) {\\n//      int  n=matrix.length;//tabulation\\n//         int m=matrix[0].length;\\n//         int dp[][]=new int[n][m];\\n        \\n//   for(int j=0;j<m;j++)\\n//   {\\n      \\n//       dp[0][j]=matrix[0][j];\\n//   }\\n//         for(int i=1;i<n;i++)\\n//         {\\n//             for(int j=0;j<m;j++)\\n//             {\\n//                 int up=0,left=0,right=0;\\n//                  up=matrix[i][j]+dp[i-1][j];\\n//              if(j-1>=0)    left=matrix[i][j]+dp[i-1][j-1];\\n//                 else left= matrix[i][j]+(int)Math.pow(10,9);\\n\\n//                 if(j+1<m)  right=matrix[i][j]+dp[i-1][j+1];\\n//                 else right=matrix[i][j]+(int)Math.pow(10,9);\\n//                  dp[i][j]=Math.min(up,Math.min(left,right));\\n//                 }\\n           \\n//         }\\n        \\n//         int mini=Integer.MAX_VALUE;\\n//         for(int j=0;j<m;j++)\\n//         {\\n//             mini=Math.min(mini,dp[n-1][j]);\\n//         }\\n//         return mini;\\n//     }\\n// }\\n\\n\\n\\n    public int minFallingPathSum(int[][] matrix) {\\n     int  n=matrix.length;\\n        int m=matrix[0].length;\\n    \\n        int prev[]=new int[m];\\n       \\n        \\n  for(int j=0;j<m;j++)\\n  {\\n      \\n      prev[j]=matrix[0][j];\\n  }\\n        for(int i=1;i<n;i++)\\n        {\\n             int curr[]=new int[m];\\n            for(int j=0;j<m;j++)\\n            {\\n                int up=0,left=0,right=0;\\n                 up=matrix[i][j]+prev[j];\\n             if(j-1>=0)    left=matrix[i][j]+prev[j-1];\\n                else left= matrix[i][j]+(int)Math.pow(10,9);\\n\\n                if(j+1<m)  right=matrix[i][j]+prev[j+1];\\n                else right=matrix[i][j]+(int)Math.pow(10,9);\\n                 curr[j]=Math.min(up,Math.min(left,right));\\n                }\\n            prev=curr;\\n           \\n        }\\n        \\n        int mini=Integer.MAX_VALUE;\\n        for(int j=0;j<m;j++)\\n        { int temp=prev[j];\\n            mini=Math.min(mini,temp);\\n        }\\n        return mini;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    // public int helper(int i,int j,int n,int [][]matrix,int dp[][])\\n    // {//memo\\n    //     if(j<0 || j>=n) return (int)Math.pow(10,9);//for  preventing out of bound \\n    //     if(i==0)return matrix[i][j];// once we reach the 1st row we will return element\\\\\\n    //     if(dp[i][j]!=-1) return dp[i][j];\\n    //     int up=matrix[i][j]+helper(i-1,j,n,matrix,dp);\\n    //     int upleft=matrix[i][j]+helper(i-1,j-1,n,matrix,dp);\\n    //     int upright=matrix[i][j]+helper(i-1,j+1,n,matrix,dp);\\n    //     return dp[i][j]=Math.min(up,Math.min(upleft,upright));\\n    // }\\n    \\n    \\n//     public int minFallingPathSum(int[][] matrix) {\\n//      int  n=matrix.length;//tabulation\\n//         int m=matrix[0].length;\\n//         int dp[][]=new int[n][m];\\n        \\n//   for(int j=0;j<m;j++)\\n//   {\\n      \\n//       dp[0][j]=matrix[0][j];\\n//   }\\n//         for(int i=1;i<n;i++)\\n//         {\\n//             for(int j=0;j<m;j++)\\n//             {\\n//                 int up=0,left=0,right=0;\\n//                  up=matrix[i][j]+dp[i-1][j];\\n//              if(j-1>=0)    left=matrix[i][j]+dp[i-1][j-1];\\n//                 else left= matrix[i][j]+(int)Math.pow(10,9);\\n\\n//                 if(j+1<m)  right=matrix[i][j]+dp[i-1][j+1];\\n//                 else right=matrix[i][j]+(int)Math.pow(10,9);\\n//                  dp[i][j]=Math.min(up,Math.min(left,right));\\n//                 }\\n           \\n//         }\\n        \\n//         int mini=Integer.MAX_VALUE;\\n//         for(int j=0;j<m;j++)\\n//         {\\n//             mini=Math.min(mini,dp[n-1][j]);\\n//         }\\n//         return mini;\\n//     }\\n// }\\n\\n\\n\\n    public int minFallingPathSum(int[][] matrix) {\\n     int  n=matrix.length;\\n        int m=matrix[0].length;\\n    \\n        int prev[]=new int[m];\\n       \\n        \\n  for(int j=0;j<m;j++)\\n  {\\n      \\n      prev[j]=matrix[0][j];\\n  }\\n        for(int i=1;i<n;i++)\\n        {\\n             int curr[]=new int[m];\\n            for(int j=0;j<m;j++)\\n            {\\n                int up=0,left=0,right=0;\\n                 up=matrix[i][j]+prev[j];\\n             if(j-1>=0)    left=matrix[i][j]+prev[j-1];\\n                else left= matrix[i][j]+(int)Math.pow(10,9);\\n\\n                if(j+1<m)  right=matrix[i][j]+prev[j+1];\\n                else right=matrix[i][j]+(int)Math.pow(10,9);\\n                 curr[j]=Math.min(up,Math.min(left,right));\\n                }\\n            prev=curr;\\n           \\n        }\\n        \\n        int mini=Integer.MAX_VALUE;\\n        for(int j=0;j<m;j++)\\n        { int temp=prev[j];\\n            mini=Math.min(mini,temp);\\n        }\\n        return mini;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2355966,
                "title": "c-recursive-memo-easy-small-code",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>dp;\\n    int solve(int m,int n,vector<vector<int>> &grid){\\n        if(m<0){\\n            return INT_MAX;\\n        }\\n        if(n<0){\\n            return INT_MAX;\\n        }\\n        if( n >= grid[m].size()){\\n            return INT_MAX;\\n        }\\n    \\n        if(dp[m][n] != -1)\\n            return dp[m][n];\\n        \\n        if(m == 0)\\n            return  grid[m][n];\\n        \\n        return  dp[m][n] = grid[m][n] + min({solve(m-1,n,grid),solve(m-1,n-1,grid),solve(m-1,n+1,grid)});\\n    }\\n    int minFallingPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        dp = vector<vector<int>>(m,vector<int>(n,-1));\\n        int ans = INT_MAX;\\n        for(int i = 0 ; i <n;i++){\\n            ans = min(ans,solve(m-1,i,grid));\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>dp;\\n    int solve(int m,int n,vector<vector<int>> &grid){\\n        if(m<0){\\n            return INT_MAX;\\n        }\\n        if(n<0){\\n            return INT_MAX;\\n        }\\n        if( n >= grid[m].size()){\\n            return INT_MAX;\\n        }\\n    \\n        if(dp[m][n] != -1)\\n            return dp[m][n];\\n        \\n        if(m == 0)\\n            return  grid[m][n];\\n        \\n        return  dp[m][n] = grid[m][n] + min({solve(m-1,n,grid),solve(m-1,n-1,grid),solve(m-1,n+1,grid)});\\n    }\\n    int minFallingPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        dp = vector<vector<int>>(m,vector<int>(n,-1));\\n        int ans = INT_MAX;\\n        for(int i = 0 ; i <n;i++){\\n            ans = min(ans,solve(m-1,i,grid));\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2354399,
                "title": "c-recursive-memoized-code-dp",
                "content": "1. Firstly we will see the basic brute force recursive solution\\n\\n```\\n    int f(int i, int j, vector<vector<int>> &matrix){\\n        \\n\\t\\t//base case\\n        if(i==0) return matrix[0][j];\\n\\t\\t\\n        //to handle edge cases if the j index is less than 0 or greater than size of the array.\\n        if(i<0 or i>=matrix.size[0]) return 1e8;\\n        \\n        int up = matrix[i][j] + f(i, j-1, matrix);\\n        \\n        int l = matrix[i][j] +  f(i-1, j-1, matrix);\\n        \\n        int r = matrix[i][j] +  f(i+1, j-1, matrix);\\n        \\n        return min(up, min(l, r));\\n        \\n\\t\\t}\\n```\\n\\n2. we can apply DP for the same recursive code and memoize it. Here is how it looks like after memoization.\\n```\\nclass Solution {\\npublic:\\n    \\n    int f(int i, int j, vector<vector<int>> &matrix, vector<vector<int>> &dp){\\n        \\n\\t\\t//to handle edge cases if the j index is less than 0 or greater than size of the array.\\n        if(j<0 or j>=matrix[0].size()) return 1e8;\\n\\t\\t\\n\\t\\t//base case\\n        if(i==0) return dp[0][j] = matrix[0][j];\\n        \\n        if(dp[i][j]!=-1) return dp[i][j];\\n        \\n        int up = matrix[i][j] + f(i-1, j, matrix, dp);\\n        \\n        int l = matrix[i][j] + f(i-1, j-1, matrix, dp);\\n        \\n        int r = matrix[i][j] + f(i-1, j+1, matrix, dp);\\n        \\n        return dp[i][j] = min(up, min(l, r));\\n        \\n    }\\n    \\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        \\n        int mini = INT_MAX;\\n        int n = matrix.size();\\n        \\n        vector<vector<int>> dp(n, vector<int>(n,-1));\\n        \\n        for(int j=0;j<n;j++){\\n            \\n            mini = min(mini, f(n-1, j, matrix, dp));\\n            \\n        }\\n        \\n        return mini;\\n        \\n    }\\n};\\n```\\n\\n\\t\\t\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n    int f(int i, int j, vector<vector<int>> &matrix){\\n        \\n\\t\\t//base case\\n        if(i==0) return matrix[0][j];\\n\\t\\t\\n        //to handle edge cases if the j index is less than 0 or greater than size of the array.\\n        if(i<0 or i>=matrix.size[0]) return 1e8;\\n        \\n        int up = matrix[i][j] + f(i, j-1, matrix);\\n        \\n        int l = matrix[i][j] +  f(i-1, j-1, matrix);\\n        \\n        int r = matrix[i][j] +  f(i+1, j-1, matrix);\\n        \\n        return min(up, min(l, r));\\n        \\n\\t\\t}\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    int f(int i, int j, vector<vector<int>> &matrix, vector<vector<int>> &dp){\\n        \\n\\t\\t//to handle edge cases if the j index is less than 0 or greater than size of the array.\\n        if(j<0 or j>=matrix[0].size()) return 1e8;\\n\\t\\t\\n\\t\\t//base case\\n        if(i==0) return dp[0][j] = matrix[0][j];\\n        \\n        if(dp[i][j]!=-1) return dp[i][j];\\n        \\n        int up = matrix[i][j] + f(i-1, j, matrix, dp);\\n        \\n        int l = matrix[i][j] + f(i-1, j-1, matrix, dp);\\n        \\n        int r = matrix[i][j] + f(i-1, j+1, matrix, dp);\\n        \\n        return dp[i][j] = min(up, min(l, r));\\n        \\n    }\\n    \\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        \\n        int mini = INT_MAX;\\n        int n = matrix.size();\\n        \\n        vector<vector<int>> dp(n, vector<int>(n,-1));\\n        \\n        for(int j=0;j<n;j++){\\n            \\n            mini = min(mini, f(n-1, j, matrix, dp));\\n            \\n        }\\n        \\n        return mini;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2342268,
                "title": "doubt-regarding-the-need-to-fetch-the-column-size",
                "content": "**As given the matrix is nxn i had only fetch the row size to make all the necessary conditions but it was giving runtime error but when i had written the second code i just used column size and it was running fine so it is necessary to fetch column size??????**\\n```\\nint helper(int i , int j , int n , vector<vector<int>>&m , vector<vector<int>>&dp)\\n   {\\n      if(i == n)\\n      {\\n        return m[i][j];\\n      }\\n      if(dp[i][j]!=-1)\\n      {\\n        return dp[i][j];\\n      }\\n      if(j>n || j<0)\\n      {\\n        return 1e9;\\n      }\\n    //down\\n     int down = m[i][j]+ helper(i+1 , j , n , m, dp);\\n      //lef dig\\n      int left = m[i][j] + helper(i+1 , j-1 , n , m ,dp);\\n      //right dig\\n      int right = m[i][j] + helper(i+1,j+1 , n , m ,dp);\\n\\n      return dp[i][j] = min(down, min( left , right));\\n   }\\n \\n int minFallingPathSum(vector<vector<int>>& matrix) {\\n    int n = matrix.size();\\n    int mini = 1e9;\\n   vector<vector<int>>dp(n+1 , vector<int>(n+1 , -1));\\n    for(int i = 0 ; i < n ; i++)\\n    {\\n        mini = min(mini , helper(0 , i ,n, matrix , dp));\\n    }\\n     \\n    return mini;\\n    }\\n```\\n**Plzz reply me where i am wrong**\\n```\\nclass Solution {\\npublic:\\n    int helper(int i , int j , int n ,int x, vector<vector<int>>&m , vector<vector<int>>&dp)\\n   {\\n      \\n      if(j>n-1 || j<0)\\n      {\\n        return 1e9;\\n      }\\n        \\n        if(dp[i][j]!=-1)\\n      {\\n        return dp[i][j];\\n      }\\n        \\n      if(i == n-1)\\n      {\\n        return m[i][j];\\n      }\\n    //down\\n     int down = m[i][j]+ helper(i+1 , j , n ,x, m, dp);\\n      //lef dig\\n      int left = m[i][j] + helper(i+1 , j-1 , n,x , m ,dp);\\n      //right dig\\n      int right = m[i][j] + helper(i+1,j+1 , n,x , m ,dp);\\n\\n      return dp[i][j] = min(down, min(left , right));\\n   }\\n \\n int minFallingPathSum(vector<vector<int>>& matrix) {\\n    int n = matrix.size();\\n     int m = matrix[0].size();\\n    int mini = 1e9;\\n   vector<vector<int>>dp(n+1 , vector<int>(m+1 , -1));\\n    for(int i = 0 ; i < m ; i++)\\n    {\\n        mini = min(mini , helper(0 , i ,n,m ,  matrix , dp));\\n    }\\n     \\n     return mini;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nint helper(int i , int j , int n , vector<vector<int>>&m , vector<vector<int>>&dp)\\n   {\\n      if(i == n)\\n      {\\n        return m[i][j];\\n      }\\n      if(dp[i][j]!=-1)\\n      {\\n        return dp[i][j];\\n      }\\n      if(j>n || j<0)\\n      {\\n        return 1e9;\\n      }\\n    //down\\n     int down = m[i][j]+ helper(i+1 , j , n , m, dp);\\n      //lef dig\\n      int left = m[i][j] + helper(i+1 , j-1 , n , m ,dp);\\n      //right dig\\n      int right = m[i][j] + helper(i+1,j+1 , n , m ,dp);\\n\\n      return dp[i][j] = min(down, min( left , right));\\n   }\\n \\n int minFallingPathSum(vector<vector<int>>& matrix) {\\n    int n = matrix.size();\\n    int mini = 1e9;\\n   vector<vector<int>>dp(n+1 , vector<int>(n+1 , -1));\\n    for(int i = 0 ; i < n ; i++)\\n    {\\n        mini = min(mini , helper(0 , i ,n, matrix , dp));\\n    }\\n     \\n    return mini;\\n    }\\n```\n```\\nclass Solution {\\npublic:\\n    int helper(int i , int j , int n ,int x, vector<vector<int>>&m , vector<vector<int>>&dp)\\n   {\\n      \\n      if(j>n-1 || j<0)\\n      {\\n        return 1e9;\\n      }\\n        \\n        if(dp[i][j]!=-1)\\n      {\\n        return dp[i][j];\\n      }\\n        \\n      if(i == n-1)\\n      {\\n        return m[i][j];\\n      }\\n    //down\\n     int down = m[i][j]+ helper(i+1 , j , n ,x, m, dp);\\n      //lef dig\\n      int left = m[i][j] + helper(i+1 , j-1 , n,x , m ,dp);\\n      //right dig\\n      int right = m[i][j] + helper(i+1,j+1 , n,x , m ,dp);\\n\\n      return dp[i][j] = min(down, min(left , right));\\n   }\\n \\n int minFallingPathSum(vector<vector<int>>& matrix) {\\n    int n = matrix.size();\\n     int m = matrix[0].size();\\n    int mini = 1e9;\\n   vector<vector<int>>dp(n+1 , vector<int>(m+1 , -1));\\n    for(int i = 0 ; i < m ; i++)\\n    {\\n        mini = min(mini , helper(0 , i ,n,m ,  matrix , dp));\\n    }\\n     \\n     return mini;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2330904,
                "title": "c-dp-memorization-easy-code",
                "content": "Please Upvote :)\\n\\n```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        vector<vector<int>> dp(matrix.size(),vector<int>(matrix.size(),INT_MAX));\\n        for(int i=0;i<matrix.size();i++)\\n        {\\n            fun(matrix,dp,0,i);\\n        }\\n        int res=INT_MAX;\\n        for(int i=0;i<matrix.size();i++)\\n        {\\n            res=min(res,dp[0][i]);\\n        }\\n        return res;\\n    }\\n    int fun(vector<vector<int>>& v,vector<vector<int>>& dp,int i,int j)\\n    {\\n        if(i<0 || j<0 || i>=v.size() || j>=v.size())\\n            return INT_MAX;\\n        \\n        if(i==v.size()-1)\\n            return dp[i][j]=v[i][j];\\n        \\n        if(dp[i][j]!=INT_MAX)\\n            return dp[i][j];\\n        \\n        int t=INT_MAX;\\n        t=min(t,fun(v,dp,i+1,j-1));\\n        t=min(t,fun(v,dp,i+1,j));\\n        t=min(t,fun(v,dp,i+1,j+1));\\n        \\n        return dp[i][j]=t+v[i][j];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        vector<vector<int>> dp(matrix.size(),vector<int>(matrix.size(),INT_MAX));\\n        for(int i=0;i<matrix.size();i++)\\n        {\\n            fun(matrix,dp,0,i);\\n        }\\n        int res=INT_MAX;\\n        for(int i=0;i<matrix.size();i++)\\n        {\\n            res=min(res,dp[0][i]);\\n        }\\n        return res;\\n    }\\n    int fun(vector<vector<int>>& v,vector<vector<int>>& dp,int i,int j)\\n    {\\n        if(i<0 || j<0 || i>=v.size() || j>=v.size())\\n            return INT_MAX;\\n        \\n        if(i==v.size()-1)\\n            return dp[i][j]=v[i][j];\\n        \\n        if(dp[i][j]!=INT_MAX)\\n            return dp[i][j];\\n        \\n        int t=INT_MAX;\\n        t=min(t,fun(v,dp,i+1,j-1));\\n        t=min(t,fun(v,dp,i+1,j));\\n        t=min(t,fun(v,dp,i+1,j+1));\\n        \\n        return dp[i][j]=t+v[i][j];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2326483,
                "title": "java-recursion-space-optimized-dp",
                "content": "```\\npublic int minFallingPathSum(int[][] matrix) {\\n\\t\\treturn spaceOptimization(matrix);\\n\\t}\\n\\n\\t// n = matrix.length -1; i = matrix.length-1; j = 0..matrix.length-1;\\n\\tprivate int recursion(int[][] arr, int i, int j, int n) {\\n\\t\\tif (i == 0)\\n\\t\\t\\treturn arr[i][j];\\n\\n\\t\\tint left = Integer.MAX_VALUE, right = Integer.MAX_VALUE;\\n\\t\\tif (j > 0) {\\n\\t\\t\\tleft = recursion(arr, i - 1, j - 1, n);\\n\\t\\t}\\n\\t\\tint curr = recursion(arr, i - 1, j, n);\\n\\t\\tif (j < n) {\\n\\t\\t\\tright = recursion(arr, i - 1, j + 1, n);\\n\\t\\t}\\n\\n\\t\\tint min = Math.min(left, Math.min(curr, right));\\n\\t\\treturn arr[i][j] + min;\\n\\t}\\n\\n\\t// dp = new int[n+1][n+1] where dp[i][j] = Integer.MIN_VALUE;\\n\\tprivate int memoization(int[][] arr, int i, int j, int n, int[][] dp) {\\n\\t\\tif (i == 0)\\n\\t\\t\\treturn arr[i][j];\\n\\n\\t\\tif (dp[i][j] != Integer.MIN_VALUE)\\n\\t\\t\\treturn dp[i][j];\\n\\n\\t\\tint left = Integer.MAX_VALUE, right = Integer.MAX_VALUE;\\n\\t\\tif (j > 0) {\\n\\t\\t\\tleft = memoization(arr, i - 1, j - 1, n, dp);\\n\\t\\t}\\n\\t\\tint curr = memoization(arr, i - 1, j, n, dp);\\n\\t\\tif (j < n) {\\n\\t\\t\\tright = memoization(arr, i - 1, j + 1, n, dp);\\n\\t\\t}\\n\\n\\t\\tint min = Math.min(left, Math.min(curr, right));\\n\\t\\treturn dp[i][j] = arr[i][j] + min;\\n\\t}\\n\\n\\tprivate int tabulation(int[][] arr) {\\n\\t\\tint n = arr.length;\\n\\t\\tint[][] dp = new int[n][n];\\n\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tdp[0][i] = arr[0][i];\\n\\t\\t}\\n\\n\\t\\tfor (int i = 1; i < n; i++) {\\n\\t\\t\\tfor (int j = 0; j < n; j++) {\\n\\t\\t\\t\\tint left = Integer.MAX_VALUE, right = Integer.MAX_VALUE;\\n\\t\\t\\t\\tif (j > 0)\\n\\t\\t\\t\\t\\tleft = dp[i - 1][j - 1];\\n\\t\\t\\t\\tif (j < n - 1)\\n\\t\\t\\t\\t\\tright = dp[i - 1][j + 1];\\n\\t\\t\\t\\tint curr = dp[i - 1][j];\\n\\t\\t\\t\\tint min = Math.min(Math.min(left, right), curr);\\n\\t\\t\\t\\tdp[i][j] = arr[i][j] + min;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tint min = Integer.MAX_VALUE;\\n\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tint temp = dp[n - 1][i];\\n\\t\\t\\tmin = Math.min(min, temp);\\n\\t\\t}\\n\\n\\t\\treturn min;\\n\\t}\\n\\n\\tprivate int spaceOptimization(int[][] arr) {\\n\\t\\tint n = arr.length;\\n\\t\\tint[] so = new int[n];\\n\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tso[i] = arr[0][i];\\n\\t\\t}\\n\\n\\t\\tfor (int i = 1; i < n; i++) {\\n\\t\\t\\tint[] temp = new int[n];\\n\\t\\t\\tfor (int j = 0; j < n; j++) {\\n\\t\\t\\t\\tint left = Integer.MAX_VALUE, right = Integer.MAX_VALUE;\\n\\t\\t\\t\\tif (j > 0)\\n\\t\\t\\t\\t\\tleft = so[j - 1];\\n\\t\\t\\t\\tif (j < n - 1)\\n\\t\\t\\t\\t\\tright = so[j + 1];\\n\\t\\t\\t\\tint curr = so[j];\\n\\t\\t\\t\\tint min = Math.min(Math.min(left, right), curr);\\n\\t\\t\\t\\ttemp[j] = arr[i][j] + min;\\n\\t\\t\\t}\\n\\t\\t\\tso = temp;\\n\\t\\t}\\n\\t\\tint min = Integer.MAX_VALUE;\\n\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tint temp = so[i];\\n\\t\\t\\tmin = Math.min(min, temp);\\n\\t\\t}\\n\\n\\t\\treturn min;\\n\\t}\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\npublic int minFallingPathSum(int[][] matrix) {\\n\\t\\treturn spaceOptimization(matrix);\\n\\t}\\n\\n\\t// n = matrix.length -1; i = matrix.length-1; j = 0..matrix.length-1;\\n\\tprivate int recursion(int[][] arr, int i, int j, int n) {\\n\\t\\tif (i == 0)\\n\\t\\t\\treturn arr[i][j];\\n\\n\\t\\tint left = Integer.MAX_VALUE, right = Integer.MAX_VALUE;\\n\\t\\tif (j > 0) {\\n\\t\\t\\tleft = recursion(arr, i - 1, j - 1, n);\\n\\t\\t}\\n\\t\\tint curr = recursion(arr, i - 1, j, n);\\n\\t\\tif (j < n) {\\n\\t\\t\\tright = recursion(arr, i - 1, j + 1, n);\\n\\t\\t}\\n\\n\\t\\tint min = Math.min(left, Math.min(curr, right));\\n\\t\\treturn arr[i][j] + min;\\n\\t}\\n\\n\\t// dp = new int[n+1][n+1] where dp[i][j] = Integer.MIN_VALUE;\\n\\tprivate int memoization(int[][] arr, int i, int j, int n, int[][] dp) {\\n\\t\\tif (i == 0)\\n\\t\\t\\treturn arr[i][j];\\n\\n\\t\\tif (dp[i][j] != Integer.MIN_VALUE)\\n\\t\\t\\treturn dp[i][j];\\n\\n\\t\\tint left = Integer.MAX_VALUE, right = Integer.MAX_VALUE;\\n\\t\\tif (j > 0) {\\n\\t\\t\\tleft = memoization(arr, i - 1, j - 1, n, dp);\\n\\t\\t}\\n\\t\\tint curr = memoization(arr, i - 1, j, n, dp);\\n\\t\\tif (j < n) {\\n\\t\\t\\tright = memoization(arr, i - 1, j + 1, n, dp);\\n\\t\\t}\\n\\n\\t\\tint min = Math.min(left, Math.min(curr, right));\\n\\t\\treturn dp[i][j] = arr[i][j] + min;\\n\\t}\\n\\n\\tprivate int tabulation(int[][] arr) {\\n\\t\\tint n = arr.length;\\n\\t\\tint[][] dp = new int[n][n];\\n\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tdp[0][i] = arr[0][i];\\n\\t\\t}\\n\\n\\t\\tfor (int i = 1; i < n; i++) {\\n\\t\\t\\tfor (int j = 0; j < n; j++) {\\n\\t\\t\\t\\tint left = Integer.MAX_VALUE, right = Integer.MAX_VALUE;\\n\\t\\t\\t\\tif (j > 0)\\n\\t\\t\\t\\t\\tleft = dp[i - 1][j - 1];\\n\\t\\t\\t\\tif (j < n - 1)\\n\\t\\t\\t\\t\\tright = dp[i - 1][j + 1];\\n\\t\\t\\t\\tint curr = dp[i - 1][j];\\n\\t\\t\\t\\tint min = Math.min(Math.min(left, right), curr);\\n\\t\\t\\t\\tdp[i][j] = arr[i][j] + min;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tint min = Integer.MAX_VALUE;\\n\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tint temp = dp[n - 1][i];\\n\\t\\t\\tmin = Math.min(min, temp);\\n\\t\\t}\\n\\n\\t\\treturn min;\\n\\t}\\n\\n\\tprivate int spaceOptimization(int[][] arr) {\\n\\t\\tint n = arr.length;\\n\\t\\tint[] so = new int[n];\\n\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tso[i] = arr[0][i];\\n\\t\\t}\\n\\n\\t\\tfor (int i = 1; i < n; i++) {\\n\\t\\t\\tint[] temp = new int[n];\\n\\t\\t\\tfor (int j = 0; j < n; j++) {\\n\\t\\t\\t\\tint left = Integer.MAX_VALUE, right = Integer.MAX_VALUE;\\n\\t\\t\\t\\tif (j > 0)\\n\\t\\t\\t\\t\\tleft = so[j - 1];\\n\\t\\t\\t\\tif (j < n - 1)\\n\\t\\t\\t\\t\\tright = so[j + 1];\\n\\t\\t\\t\\tint curr = so[j];\\n\\t\\t\\t\\tint min = Math.min(Math.min(left, right), curr);\\n\\t\\t\\t\\ttemp[j] = arr[i][j] + min;\\n\\t\\t\\t}\\n\\t\\t\\tso = temp;\\n\\t\\t}\\n\\t\\tint min = Integer.MAX_VALUE;\\n\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tint temp = so[i];\\n\\t\\t\\tmin = Math.min(min, temp);\\n\\t\\t}\\n\\n\\t\\treturn min;\\n\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2307654,
                "title": "recursion-memoization",
                "content": "For those who directly decide to write tabulation form, first strong your recursion part , then memoize it . This memoization solution also get submitted so does tabulation. \\n```\\nclass Solution {\\npublic:\\n    int dp[101][101];\\n    \\n    int solve(int i , int j ,vector<vector<int>>& matrix)\\n    {\\n        int n = matrix.size();\\n        \\n        if(i >=n || j >=n || i < 0  || j<0)\\n            return 1e7;\\n        \\n        if(i == n-1)\\n            return matrix[i][j];\\n        \\n        if(dp[i][j] != -1)\\n            return dp[i][j];\\n        int ans = INT_MAX;\\n        \\n        \\n        \\n            int down = matrix[i][j] + solve(i+1,j,matrix);\\n            int right_d = matrix[i][j] + solve(i+1,j+1,matrix);\\n            int left_d  = matrix[i][j] + solve(i+1,j-1,matrix);\\n            \\n            // int sum = matrix[i][j] + solve(i+1,j+k,matrix);\\n            \\n           ans = min({down,right_d,left_d});\\n        \\n        \\n        return dp[i][j] = ans;\\n    }\\n    \\n    \\n    int minFallingPathSum(vector<vector<int>>& matrix) \\n    {\\n        int ans= INT_MAX;\\n        int n = matrix.size();\\n        \\n        memset(dp,-1,sizeof(dp));\\n        \\n        for(int i = 0 ; i< n ; i++)\\n        {\\n            \\n            ans = min(ans, solve(0,i,matrix));\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```\\nI still find tabulation initialization tricky but there is always scope for improvement.\\n![image](https://assets.leetcode.com/users/images/7ddaa016-c5a0-4b08-a795-653648d0a05e_1658302936.3702855.png)\\n",
                "solutionTags": [
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[101][101];\\n    \\n    int solve(int i , int j ,vector<vector<int>>& matrix)\\n    {\\n        int n = matrix.size();\\n        \\n        if(i >=n || j >=n || i < 0  || j<0)\\n            return 1e7;\\n        \\n        if(i == n-1)\\n            return matrix[i][j];\\n        \\n        if(dp[i][j] != -1)\\n            return dp[i][j];\\n        int ans = INT_MAX;\\n        \\n        \\n        \\n            int down = matrix[i][j] + solve(i+1,j,matrix);\\n            int right_d = matrix[i][j] + solve(i+1,j+1,matrix);\\n            int left_d  = matrix[i][j] + solve(i+1,j-1,matrix);\\n            \\n            // int sum = matrix[i][j] + solve(i+1,j+k,matrix);\\n            \\n           ans = min({down,right_d,left_d});\\n        \\n        \\n        return dp[i][j] = ans;\\n    }\\n    \\n    \\n    int minFallingPathSum(vector<vector<int>>& matrix) \\n    {\\n        int ans= INT_MAX;\\n        int n = matrix.size();\\n        \\n        memset(dp,-1,sizeof(dp));\\n        \\n        for(int i = 0 ; i< n ; i++)\\n        {\\n            \\n            ans = min(ans, solve(0,i,matrix));\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2295938,
                "title": "recursion-memoization-java",
                "content": "Recursive Approach,(It will give TLE but gives the base to memoize the solution)-:\\n\\nclass Solution {\\n\\n    public int func(int i,int j,int arr[][],int n){\\n       //base condition-1\\n        if(i==0 && j>=0 && j<=n){\\n            return arr[i][j];\\n        }\\n\\t\\t//base condition-2\\n        if(i<0 || j<0 || j>n){\\n            return 10000007;\\n        }\\n        \\n        int up=arr[i][j]+func(i-1,j,arr,n);\\n        \\n        int ld=arr[i][j]+func(i-1,j-1,arr,n);\\n        \\n        int rd=arr[i][j]+func(i-1,j+1,arr,n);\\n        \\n        return Math.min(up,Math.min(ld,rd));\\n    }\\n    public int minFallingPathSum(int[][] matrix) {\\n        int n=matrix.length-1;\\n       \\n        int ans=Integer.MAX_VALUE;\\n\\t\\t//for the top down approach start from the last row of matrix and try for every column \\n\\t\\t//every column of last row whichever gives the result\\n        for(int i=n;i>=0;i--){\\n            \\n            int t=func(n,i,matrix,n);\\n            ans=Math.min(ans,t);\\n        }\\n        return ans;\\n    }\\n}\\n////////////////////////////////////////////////////////////////////////////////////////////////\\nMemoised Solution (Same as recursive solution but just three changes)\\n1. Create a 2d DP array\\n2. instead of returning store result in dp\\n3. Check one if condition if dp already have answer thats it\\nSolution is Faster then 94%\\n\\nclass Solution {\\n\\n    public int func(int i,int j,int arr[][],int n,int [][]dp){\\n       \\n        if(i==0 && j>=0 && j<=n){\\n            return arr[i][j];\\n        }\\n        if(i<0 || j<0 || j>n){\\n            return 10000007;\\n        }\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n        int up=arr[i][j]+func(i-1,j,arr,n,dp);\\n        \\n        int ld=arr[i][j]+func(i-1,j-1,arr,n,dp);\\n        \\n        int rd=arr[i][j]+func(i-1,j+1,arr,n,dp);\\n        \\n        return dp[i][j]=Math.min(up,Math.min(ld,rd));\\n    }\\n    public int minFallingPathSum(int[][] matrix) {\\n        int n=matrix.length-1;\\n        int dp[][]=new int[n+1][n+1];\\n        for(int row[]:dp){\\n            Arrays.fill(row,-1);\\n        }\\n        \\n        int ans=Integer.MAX_VALUE;\\n        for(int i=n;i>=0;i--){\\n            \\n            int t=func(n,i,matrix,n,dp);\\n            ans=Math.min(ans,t);\\n        }\\n        return ans;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\n    public int func(int i,int j,int arr[][],int n){\\n       //base condition-1\\n        if(i==0 && j>=0 && j<=n){\\n            return arr[i][j];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2207857,
                "title": "easy-to-understand-4-solutions-from-brute-force-to-dp",
                "content": "// RECURSION\\n\\nclass Solution {\\npublic:\\n    \\n    int f(int i,int j,vector<vector<int>>& matrix){\\n        \\n        if(j<0 || j>=matrix[0].size())   // boundary conditions\\n           return 1e8;\\n        if(i==0)\\n           return matrix[0][j];\\n        int u = matrix[i][j] + f(i-1, j ,matrix);     // for up movement\\n        int ld = matrix[i][j] + f(i-1, j-1, matrix);  // for left side movement (up then left)\\n        int rd = matrix[i][j] + f(i-1, j+1, matrix);  // for right side movement (up then right)\\n        \\n        return min(u ,min(ld,rd));\\n    \\n    }\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        \\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        \\n        int mini = 1e8;\\n        for(int j = 0; j<m; j++){\\n             mini = min(mini, f(n-1, j , matrix));\\n        }\\n           \\n        \\n        return mini;\\n    }\\n};\\n\\n\\n// Memoization \\n\\nclass Solution {\\npublic:\\n    \\n    int f(int i,int j,vector<vector<int>>& matrix ,  vector<vector<int>> &dp){\\n        \\n        if(j<0 || j>=matrix[0].size()   )   // boundary conditions\\n            return 1e8;\\n        if(i==0)\\n            return matrix[0][j];\\n        \\n        if(dp[i][j] != -1)             //* here we have done some change for memo\\n            return dp[i][j];\\n        \\n        int u = matrix[i][j] + f(i-1, j ,matrix ,dp);     // for up movement\\n        int ld = matrix[i][j] + f(i-1, j-1, matrix, dp);  // for left side movement (up then left)\\n        int rd = matrix[i][j] + f(i-1, j+1, matrix ,dp);  // for right side movement (up then right)\\n        \\n        return dp[i][j] = min(u ,min(ld,rd));      //* here we have done some change for memo\\n     \\n    }\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        \\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        vector<vector<int>> dp(n, vector<int>(m,-1));   //* here we have done some change for memo\\n        int mini = 1e8;\\n        for(int j = 0; j<m; j++){\\n             mini = min(mini, f(n-1, j , matrix , dp));\\n        }    \\n        return mini;\\n    }\\n};\\n\\n\\n// TABULATION \\n\\nclass Solution {\\npublic:\\n    \\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        \\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        \\n        vector<vector<int>> dp(n, vector<int>(m,-1));   //* here we have done some change for memo\\n        \\n         for(int j=0;j<m;j++){\\n            dp[0][j]=matrix[0][j];  \\n        }\\n        for(int i=1;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                int ld=1e9,rd=1e9;\\n                \\n                int up=matrix[i][j] + dp[i-1][j];     // for up movement\\n                \\n                if(j-1>=0)\\n                    ld=matrix[i][j] + dp[i-1][j-1];   // for left side movement (up then left)\\n                if(j+1<m)\\n                    rd=matrix[i][j] + dp[i-1][j+1];   // for right side movement (up then right)\\n                \\n                dp[i][j] = min(up,min(ld,rd));\\n \\n            }\\n        }\\n        int mini=dp[n-1][0];\\n        \\n        for(int j=0;j<m;j++){\\n            mini=min(mini,dp[n-1][j]);  \\n        }\\n        return mini; \\n    }\\n        \\n};\\n\\n\\n// space optimization \\n\\nclass Solution {\\npublic:\\n    \\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n\\n        int n=matrix.size();\\n        int m=matrix[0].size();\\n        \\n        vector<int>cur(m,0) , prev(m,0);\\n        \\n        for(int j=0;j<m;j++){\\n            prev[j]=matrix[0][j]; \\n        }\\n\\n        for(int i=1;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                int ld=1e9,rd=1e9;\\n\\n                int up=matrix[i][j] + prev[j];\\n                \\n                if(j-1>=0)\\n                    ld=matrix[i][j] + prev[j-1];\\n                if(j+1<m)\\n                    rd=matrix[i][j] + prev[j+1];\\n                \\n                cur[j] = min(up,min(ld,rd));\\n            }\\n            prev=cur;\\n        }\\n        int mini=prev[0];\\n        \\n        for(int j=1;j<m;j++){ \\n            mini=min(mini,prev[j]);\\n        }\\n        return mini;   \\n    }\\n};\\n\\n",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    int f(int i,int j,vector<vector<int>>& matrix){\\n        \\n        if(j<0 || j>=matrix[0].size())   // boundary conditions\\n           return 1e8;\\n        if(i==0)\\n           return matrix[0][j];\\n        int u = matrix[i][j] + f(i-1, j ,matrix);     // for up movement\\n        int ld = matrix[i][j] + f(i-1, j-1, matrix);  // for left side movement (up then left)\\n        int rd = matrix[i][j] + f(i-1, j+1, matrix);  // for right side movement (up then right)\\n        \\n        return min(u ,min(ld,rd));\\n    \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2180335,
                "title": "easy-dp-solution",
                "content": "```\\nint n=m.size();\\n        int dp[n+1][n+1];\\n        for(int i=0;i<m[0].size();i++){\\n            dp[0][i]=m[0][i];\\n        }\\n        for(int i=1;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(j==0){\\n                    dp[i][j]=m[i][j]+min(dp[i-1][j],dp[i-1][j+1]);\\n                }\\n                else if(j==n-1){\\n                    dp[i][j]=m[i][j]+min(dp[i-1][j],dp[i-1][j-1]);\\n                }\\n                else{\\n                    dp[i][j]=m[i][j]+min(dp[i-1][j],min(dp[i-1][j+1],dp[i-1][j-1]));\\n                }\\n            }\\n        }\\n        int min1=INT_MAX;\\n        for(int j=0;j<n;j++){\\n            min1=min(min1,dp[n-1][j]);\\n        }\\n        return min1;\\n```\\n**please upvote**",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nint n=m.size();\\n        int dp[n+1][n+1];\\n        for(int i=0;i<m[0].size();i++){\\n            dp[0][i]=m[0][i];\\n        }\\n        for(int i=1;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(j==0){\\n                    dp[i][j]=m[i][j]+min(dp[i-1][j],dp[i-1][j+1]);\\n                }\\n                else if(j==n-1){\\n                    dp[i][j]=m[i][j]+min(dp[i-1][j],dp[i-1][j-1]);\\n                }\\n                else{\\n                    dp[i][j]=m[i][j]+min(dp[i-1][j],min(dp[i-1][j+1],dp[i-1][j-1]));\\n                }\\n            }\\n        }\\n        int min1=INT_MAX;\\n        for(int j=0;j<n;j++){\\n            min1=min(min1,dp[n-1][j]);\\n        }\\n        return min1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2113644,
                "title": "java-recursive-memoized-tabulated-solution",
                "content": "**Iterative DFS (RECURSIVE APPROACH) TLE**\\n\\n```\\nclass Solution {\\n    public int minFallingPathSum(int[][] matrix) {\\n        \\n        int ans = Integer.MAX_VALUE;\\n        for(int i=0;i<matrix.length;i++){\\n            ans = Math.min(ans,minPath(0,i,matrix));\\n        }\\n        return ans;\\n    }\\n    private int minPath(int i,int j,int[][] arr){\\n        if(i==arr.length-1)\\n            return arr[i][j];\\n        int left = Integer.MAX_VALUE;\\n        int bottom = Integer.MAX_VALUE; \\n        int right = Integer.MAX_VALUE; \\n        if(j>0) left = arr[i][j]+ minPath(i+1,j-1,arr);\\n        bottom = arr[i][j] + minPath(i+1,j,arr);\\n        if(j<arr.length-1) right = arr[i][j] + minPath(i+1,j+1,arr);\\n        return Math.min(right,Math.min(left,bottom));\\n    }\\n}\\n```\\n\\n**Memoization**\\n```\\nclass Solution {\\n    public int minFallingPathSum(int[][] matrix) {\\n        int n = matrix.length;\\n        int[][] dp = new int[n][n];\\n        int ans = Integer.MAX_VALUE;\\n        for(int i=0;i<matrix.length;i++){\\n            ans = Math.min(ans,minPath(0,i,matrix,dp));\\n        }\\n        return ans;\\n    }\\n    private int minPath(int i,int j,int[][] arr,int[][] dp){\\n        if(i==arr.length-1)\\n            return arr[i][j];\\n        if(dp[i][j]!=0) return dp[i][j];\\n        int left = Integer.MAX_VALUE;\\n        int bottom = Integer.MAX_VALUE; \\n        int right = Integer.MAX_VALUE; \\n        if(j>0) left = arr[i][j]+ minPath(i+1,j-1,arr,dp);\\n        bottom = arr[i][j] + minPath(i+1,j,arr,dp);\\n        if(j<arr.length-1) right = arr[i][j] + minPath(i+1,j+1,arr,dp);\\n        return dp[i][j] = Math.min(right,Math.min(left,bottom));\\n    }\\n}\\n```\\n\\n**Tabulation**\\n\\n```\\nclass Solution {\\n    public int minFallingPathSum(int[][] matrix) {\\n        int n = matrix.length;\\n        int[][] dp = new int[n][n];\\n        return minPath(matrix,dp);\\n    }\\n    private int minPath(int[][] arr,int[][] dp){\\n        int n = arr.length;\\n        for(int k=0;k<n;k++){\\n            dp[n-1][k] = arr[n-1][k];\\n        }\\n        for(int k=n-2;k>=0;k--){\\n            for(int l=n-1;l>=0;l--){\\n            int left = Integer.MAX_VALUE;\\n            int bottom = Integer.MAX_VALUE; \\n            int right = Integer.MAX_VALUE; \\n            if(l>0)\\n                left = arr[k][l]+ dp[k+1][l-1];\\n                bottom = arr[k][l] + dp[k+1][l]; \\n            if(l<arr.length-1)    \\n                right = arr[k][l] + dp[k+1][l+1];\\n                dp[k][l] = Math.min(right,Math.min(left,bottom));        \\n            }\\n        }\\n        int ans = Integer.MAX_VALUE;\\n        for(int k=0;k<n;k++){\\n            ans = Math.min(ans,dp[0][k]);\\n        }\\n        return ans;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public int minFallingPathSum(int[][] matrix) {\\n        \\n        int ans = Integer.MAX_VALUE;\\n        for(int i=0;i<matrix.length;i++){\\n            ans = Math.min(ans,minPath(0,i,matrix));\\n        }\\n        return ans;\\n    }\\n    private int minPath(int i,int j,int[][] arr){\\n        if(i==arr.length-1)\\n            return arr[i][j];\\n        int left = Integer.MAX_VALUE;\\n        int bottom = Integer.MAX_VALUE; \\n        int right = Integer.MAX_VALUE; \\n        if(j>0) left = arr[i][j]+ minPath(i+1,j-1,arr);\\n        bottom = arr[i][j] + minPath(i+1,j,arr);\\n        if(j<arr.length-1) right = arr[i][j] + minPath(i+1,j+1,arr);\\n        return Math.min(right,Math.min(left,bottom));\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minFallingPathSum(int[][] matrix) {\\n        int n = matrix.length;\\n        int[][] dp = new int[n][n];\\n        int ans = Integer.MAX_VALUE;\\n        for(int i=0;i<matrix.length;i++){\\n            ans = Math.min(ans,minPath(0,i,matrix,dp));\\n        }\\n        return ans;\\n    }\\n    private int minPath(int i,int j,int[][] arr,int[][] dp){\\n        if(i==arr.length-1)\\n            return arr[i][j];\\n        if(dp[i][j]!=0) return dp[i][j];\\n        int left = Integer.MAX_VALUE;\\n        int bottom = Integer.MAX_VALUE; \\n        int right = Integer.MAX_VALUE; \\n        if(j>0) left = arr[i][j]+ minPath(i+1,j-1,arr,dp);\\n        bottom = arr[i][j] + minPath(i+1,j,arr,dp);\\n        if(j<arr.length-1) right = arr[i][j] + minPath(i+1,j+1,arr,dp);\\n        return dp[i][j] = Math.min(right,Math.min(left,bottom));\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minFallingPathSum(int[][] matrix) {\\n        int n = matrix.length;\\n        int[][] dp = new int[n][n];\\n        return minPath(matrix,dp);\\n    }\\n    private int minPath(int[][] arr,int[][] dp){\\n        int n = arr.length;\\n        for(int k=0;k<n;k++){\\n            dp[n-1][k] = arr[n-1][k];\\n        }\\n        for(int k=n-2;k>=0;k--){\\n            for(int l=n-1;l>=0;l--){\\n            int left = Integer.MAX_VALUE;\\n            int bottom = Integer.MAX_VALUE; \\n            int right = Integer.MAX_VALUE; \\n            if(l>0)\\n                left = arr[k][l]+ dp[k+1][l-1];\\n                bottom = arr[k][l] + dp[k+1][l]; \\n            if(l<arr.length-1)    \\n                right = arr[k][l] + dp[k+1][l+1];\\n                dp[k][l] = Math.min(right,Math.min(left,bottom));        \\n            }\\n        }\\n        int ans = Integer.MAX_VALUE;\\n        for(int k=0;k<n;k++){\\n            ans = Math.min(ans,dp[0][k]);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2051512,
                "title": "c-recursion-memoization-dp-faster-than-97-c-submissions-space-optimized-dp",
                "content": "# Step by Step Optimized Solution\\n* Here we need to try out all possible paths to reach the destination from our starting point, hence we can use recursive approach to solve the problem.\\n* We need to keep in mind that neither the starting nor ending point is fixed in the given grid.\\n* We will try to evaluate the minimum path sum from each and every column from the last row to the first row.\\n\\n**Recursion Based Solution :**\\n\\n```\\nclass Solution {\\npublic:\\n    int helper(int i, int j, vector<vector<int>>& matrix){\\n        if(j<0 || j>=matrix[0].size())\\n            return 1e9;\\n        \\n        if(i==0)\\n            return matrix[0][j];\\n\\t\\t\\t\\n        int a = matrix[i][j] + helper(i-1,j,matrix);\\n        int b = matrix[i][j] + helper(i-1,j-1,matrix);\\n        int c = matrix[i][j] + helper(i-1,j+1,matrix);\\n        \\n        return min(a,min(b,c));\\n    }\\n    \\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n       \\n        int res=1e9;\\n        for(int k=0;k<m;k++){\\n          res=min(res,helper(n-1,k,matrix,dp))  ;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\n\\n**T.C :** O(3^n) ; since for each element in the grid we have 3 choices, go up(i-1,j) , left upper                 diagonal(i-1,j-1) and right upper diagonal(i-1,j+1).\\n**S.C :** O(n); for recursion stack space\\n\\n* Now, here we would definitely have multiple overlapping subproblems. Hence we can use the Memoization technique to reduce the time complexity.\\n\\n**Memoization :**\\n\\n```\\nclass Solution {\\npublic:\\n    int helper(int i, int j, vector<vector<int>>& matrix){\\n        if(j<0 || j>=matrix[0].size())\\n            return 1e9;\\n        \\n        if(i==0)\\n            return matrix[0][j];\\n        \\n        if(dp[i][j]!=-1)\\n            return dp[i][j];\\n        \\n        int a = matrix[i][j] + helper(i-1,j,matrix,dp);\\n        int b = matrix[i][j] + helper(i-1,j-1,matrix,dp);\\n        int c = matrix[i][j] + helper(i-1,j+1,matrix,dp);\\n        \\n        return dp[i][j] = min(a,min(b,c));\\n    }\\n    \\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n\\t\\t\\n\\t\\tvector<vector<int>> dp(n,vector<int>(m,-1));\\n        \\n         int res=1e9;\\n         for(int k=0;k<m;k++){\\n           res=min(res,helper(n-1,k,matrix,dp))  ;\\n         }\\n                \\n        return res;\\n    }\\n};\\n```\\n\\n**T.C :** O(n * m)\\n**S.C :** O(n * m) + O(n) ; for dp matrix and recursion stack space respectively.\\n\\n\\n* Now, in order to reduce the recursion stack space, we would move forward to Tabulation based approach.\\n\\n**Tabulation :**\\n\\n```\\nclass Solution {\\npublic:\\n\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        \\n        vector<vector<int>> dp(n,vector<int>(m,-1));\\n        \\n        for(int j=0;j<m;j++)\\n            dp[0][j]=matrix[0][j];\\n        \\n        for(int i=1;i<n;i++){\\n            for(int j=0;j<m;j++){       \\n                int a = matrix[i][j] + dp[i-1][j];\\n                int b = matrix[i][j]; \\n                    if(j-1>=0)\\n                        b += dp[i-1][j-1];\\n                    else\\n                        b+= 1e9;\\n                int c = matrix[i][j]; \\n                    if(j+1<m)\\n                        c+= dp[i-1][j+1];\\n                    else\\n                        c+= 1e9;\\n                \\n                dp[i][j] = min(a,min(b,c));\\n            }\\n        }\\n\\n        int res = 1e9;\\n        \\n        for(int k=0;k<m;k++)\\n            res = min(res,dp[n-1][k]);\\n        \\n        return res;\\n    }\\n};\\n```\\n\\n**T.C :** O(n * m) + O(n) \\n**S.C :** O(n * m)\\n\\n* Now, we carefully notice, we will see that, we only need the pervious row values , hence instead of a 2D matrix we can store the previous values in a 1D array only.\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n                \\n        vector<int> prev(m,0) , curr(m,0);\\n        \\n        for(int j=0;j<m;j++)\\n            prev[j] = matrix[0][j];\\n        \\n        for(int i=1;i<n;i++){\\n            for(int j=0;j<m;j++){       \\n                int a = matrix[i][j] + prev[j];\\n                int b = matrix[i][j]; \\n                    if(j-1>=0)\\n                        b+=prev[j-1];\\n                    else\\n                        b+= 1e9;\\n                int c = matrix[i][j]; \\n                    if(j+1<m)\\n                        c+=prev[j+1];\\n                    else\\n                        c+= 1e9;\\n                \\n                curr[j] = min(a,min(b,c));\\n            }\\n            prev=curr;\\n        }\\n                \\n        int res = 1e9;\\n        \\n        for(int k=0;k<m;k++)\\n            res = min(res, prev[k]);\\n        \\n        return res;\\n    }\\n};\\n```\\n\\n**T.C :** O(n * m)\\n**S.C :** O(m)\\n\\n**The Final Solution is faster than 97% of C++ submissions.**\\n\\n**KIndly upvote if you like it ! :)**\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int helper(int i, int j, vector<vector<int>>& matrix){\\n        if(j<0 || j>=matrix[0].size())\\n            return 1e9;\\n        \\n        if(i==0)\\n            return matrix[0][j];\\n\\t\\t\\t\\n        int a = matrix[i][j] + helper(i-1,j,matrix);\\n        int b = matrix[i][j] + helper(i-1,j-1,matrix);\\n        int c = matrix[i][j] + helper(i-1,j+1,matrix);\\n        \\n        return min(a,min(b,c));\\n    }\\n    \\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n       \\n        int res=1e9;\\n        for(int k=0;k<m;k++){\\n          res=min(res,helper(n-1,k,matrix,dp))  ;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int helper(int i, int j, vector<vector<int>>& matrix){\\n        if(j<0 || j>=matrix[0].size())\\n            return 1e9;\\n        \\n        if(i==0)\\n            return matrix[0][j];\\n        \\n        if(dp[i][j]!=-1)\\n            return dp[i][j];\\n        \\n        int a = matrix[i][j] + helper(i-1,j,matrix,dp);\\n        int b = matrix[i][j] + helper(i-1,j-1,matrix,dp);\\n        int c = matrix[i][j] + helper(i-1,j+1,matrix,dp);\\n        \\n        return dp[i][j] = min(a,min(b,c));\\n    }\\n    \\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n\\t\\t\\n\\t\\tvector<vector<int>> dp(n,vector<int>(m,-1));\\n        \\n         int res=1e9;\\n         for(int k=0;k<m;k++){\\n           res=min(res,helper(n-1,k,matrix,dp))  ;\\n         }\\n                \\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        \\n        vector<vector<int>> dp(n,vector<int>(m,-1));\\n        \\n        for(int j=0;j<m;j++)\\n            dp[0][j]=matrix[0][j];\\n        \\n        for(int i=1;i<n;i++){\\n            for(int j=0;j<m;j++){       \\n                int a = matrix[i][j] + dp[i-1][j];\\n                int b = matrix[i][j]; \\n                    if(j-1>=0)\\n                        b += dp[i-1][j-1];\\n                    else\\n                        b+= 1e9;\\n                int c = matrix[i][j]; \\n                    if(j+1<m)\\n                        c+= dp[i-1][j+1];\\n                    else\\n                        c+= 1e9;\\n                \\n                dp[i][j] = min(a,min(b,c));\\n            }\\n        }\\n\\n        int res = 1e9;\\n        \\n        for(int k=0;k<m;k++)\\n            res = min(res,dp[n-1][k]);\\n        \\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n                \\n        vector<int> prev(m,0) , curr(m,0);\\n        \\n        for(int j=0;j<m;j++)\\n            prev[j] = matrix[0][j];\\n        \\n        for(int i=1;i<n;i++){\\n            for(int j=0;j<m;j++){       \\n                int a = matrix[i][j] + prev[j];\\n                int b = matrix[i][j]; \\n                    if(j-1>=0)\\n                        b+=prev[j-1];\\n                    else\\n                        b+= 1e9;\\n                int c = matrix[i][j]; \\n                    if(j+1<m)\\n                        c+=prev[j+1];\\n                    else\\n                        c+= 1e9;\\n                \\n                curr[j] = min(a,min(b,c));\\n            }\\n            prev=curr;\\n        }\\n                \\n        int res = 1e9;\\n        \\n        for(int k=0;k<m;k++)\\n            res = min(res, prev[k]);\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1923900,
                "title": "4-lines-easy-solution-explained",
                "content": "```\\nThe minimum path to get to element A[i][j] is the minimum of A[i - 1][j - 1], A[i - 1][j] and A[i - 1][j + 1].\\nStarting from row 1, we add the minumum path to each element. The smallest number in the last row is the miminum path sum.\\nExample:\\n[1, 2, 3]\\n[4, 5, 6] => [5, 6, 8]\\n[7, 8, 9] => [7, 8, 9] => [12, 13, 15]\\n\\nC++\\n\\nint minFallingPathSum(vector<vector<int>>& A) {\\n  for (auto i = 1; i < A.size(); ++i)\\n    for (auto j = 0; j < A.size(); ++j)\\n      A[i][j] += min({ A[i-1][j], A[i-1][max(0,j-1)], A[i-1][min((int)A.size()-1,j+1)] });\\n  return *min_element(begin(A[A.size() - 1]), end(A[A.size() - 1]));\\n}\\nJava\\n\\npublic int minFallingPathSum(int[][] A) {\\n  for (int i = 1; i < A.length; ++i)\\n    for (int j = 0; j < A.length; ++j)\\n      A[i][j] += Math.min(A[i - 1][j], Math.min(A[i - 1][Math.max(0, j - 1)], A[i - 1][Math.min(A.length - 1, j + 1)]));\\n  return Arrays.stream(A[A.length - 1]).min().getAsInt();\\n}       \\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript",
                    "Go",
                    "PHP"
                ],
                "code": "```\\nThe minimum path to get to element A[i][j] is the minimum of A[i - 1][j - 1], A[i - 1][j] and A[i - 1][j + 1].\\nStarting from row 1, we add the minumum path to each element. The smallest number in the last row is the miminum path sum.\\nExample:\\n[1, 2, 3]\\n[4, 5, 6] => [5, 6, 8]\\n[7, 8, 9] => [7, 8, 9] => [12, 13, 15]\\n\\nC++\\n\\nint minFallingPathSum(vector<vector<int>>& A) {\\n  for (auto i = 1; i < A.size(); ++i)\\n    for (auto j = 0; j < A.size(); ++j)\\n      A[i][j] += min({ A[i-1][j], A[i-1][max(0,j-1)], A[i-1][min((int)A.size()-1,j+1)] });\\n  return *min_element(begin(A[A.size() - 1]), end(A[A.size() - 1]));\\n}\\nJava\\n\\npublic int minFallingPathSum(int[][] A) {\\n  for (int i = 1; i < A.length; ++i)\\n    for (int j = 0; j < A.length; ++j)\\n      A[i][j] += Math.min(A[i - 1][j], Math.min(A[i - 1][Math.max(0, j - 1)], A[i - 1][Math.min(A.length - 1, j + 1)]));\\n  return Arrays.stream(A[A.length - 1]).min().getAsInt();\\n}       \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1879931,
                "title": "c-dfs-recursion-top-down-dp-easy-to-understand",
                "content": "**Solution:**\\n```\\nclass Solution {\\npublic:\\n    bool isValid(int r, int c, int n) {\\n        return r < n && c >= 0 && c < n;\\n    }\\n    int DFS(int r, int c, int n, int currSum, vector<vector<int>>& matrix, vector<vector<int>>& cache) {\\n        if(cache[r][c] != INT_MAX) return currSum + cache[r][c];\\n        int x = INT_MAX, y = INT_MAX, z = INT_MAX;\\n        if(isValid(r+1, c-1, n)) x = DFS(r+1, c-1, n, currSum + matrix[r][c], matrix, cache);\\n        if(isValid(r+1, c, n)) y = DFS(r+1, c, n, currSum + matrix[r][c], matrix, cache);\\n        if(isValid(r+1, c+1, n)) z = DFS(r+1, c+1, n, currSum + matrix[r][c], matrix, cache);\\n        int minSum = min(x, min(y, z));\\n        if(minSum == INT_MAX) cache[r][c] = matrix[r][c];\\n        else cache[r][c] = minSum - currSum;\\n        return currSum + cache[r][c];\\n    }\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        vector<vector<int>> cache(100, vector<int>(100, INT_MAX));\\n        int n = matrix.size(), res = INT_MAX;\\n        for(int i = 0; i < n; ++i) {\\n            res = min(res, DFS(0, i, n, 0, matrix, cache));\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(int r, int c, int n) {\\n        return r < n && c >= 0 && c < n;\\n    }\\n    int DFS(int r, int c, int n, int currSum, vector<vector<int>>& matrix, vector<vector<int>>& cache) {\\n        if(cache[r][c] != INT_MAX) return currSum + cache[r][c];\\n        int x = INT_MAX, y = INT_MAX, z = INT_MAX;\\n        if(isValid(r+1, c-1, n)) x = DFS(r+1, c-1, n, currSum + matrix[r][c], matrix, cache);\\n        if(isValid(r+1, c, n)) y = DFS(r+1, c, n, currSum + matrix[r][c], matrix, cache);\\n        if(isValid(r+1, c+1, n)) z = DFS(r+1, c+1, n, currSum + matrix[r][c], matrix, cache);\\n        int minSum = min(x, min(y, z));\\n        if(minSum == INT_MAX) cache[r][c] = matrix[r][c];\\n        else cache[r][c] = minSum - currSum;\\n        return currSum + cache[r][c];\\n    }\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        vector<vector<int>> cache(100, vector<int>(100, INT_MAX));\\n        int n = matrix.size(), res = INT_MAX;\\n        for(int i = 0; i < n; ++i) {\\n            res = min(res, DFS(0, i, n, 0, matrix, cache));\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1733431,
                "title": "fast-python-dp-solution-o-m-n",
                "content": "```\\nclass Solution:\\n    def minFallingPathSum(self, matrix: List[List[int]]) -> int:\\n        m = len( matrix)\\n        n = len( matrix[0])\\n        \\n        for i in range (1,m):\\n            for j in range (n):\\n                if j == 0:\\n                    matrix[i][j] += min( matrix[i-1][j], matrix[i-1][j+1])\\n                elif j == n-1:\\n                    matrix[i][j] += min( matrix[i-1][j], matrix[i-1][j-1])\\n                else:\\n                    matrix[i][j] += min( min( matrix[i-1][j], matrix[i-1][j+1]), matrix[i-1][j-1])\\n        \\n        return min( matrix[m-1])\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def minFallingPathSum(self, matrix: List[List[int]]) -> int:\\n        m = len( matrix)\\n        n = len( matrix[0])\\n        \\n        for i in range (1,m):\\n            for j in range (n):\\n                if j == 0:\\n                    matrix[i][j] += min( matrix[i-1][j], matrix[i-1][j+1])\\n                elif j == n-1:\\n                    matrix[i][j] += min( matrix[i-1][j], matrix[i-1][j-1])\\n                else:\\n                    matrix[i][j] += min( min( matrix[i-1][j], matrix[i-1][j+1]), matrix[i-1][j-1])\\n        \\n        return min( matrix[m-1])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1727120,
                "title": "98-faster-than-others-c-dp-memoization",
                "content": "--------------------------------------------------------------Here is the code below------------------------------------------------------ \\n\\n# ***faster!!***\\n   \\n  \\n  \\n  \\n     int dp[101][101];\\n    int dfs(vector<vector<int>> &mat, int &n , int i, int j)\\n    {\\n\\t\\n        if(j <0 || j>n-1) return INT_MAX;\\n        if(i==n-1) return mat[i][j];\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        \\n        int a =  dfs(mat,n,i+1,j-1);\\n        int b =  dfs(mat,n,i+1,j);\\n        int c =  dfs(mat,n,i+1,j+1);\\n        int x = min(a,min(b,c));\\n        int net = x + mat[i][j];\\n        dp[i][j] = net;\\n        return net;\\n    }\\n    \\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        \\n        int  n = matrix[0].size();\\n        if(n==1) return matrix[0][0];\\n        memset(dp,-1,sizeof(dp));\\n        int sum=INT_MAX;\\n        for(int i =0 ; i<n; i++)\\n        {\\n            int v = dfs(matrix,n,0,i);\\n            sum = min(v,sum);\\n        }\\n        return sum;\\n    }",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "--------------------------------------------------------------Here is the code below------------------------------------------------------ \\n\\n# ***faster!!***\\n   \\n  \\n  \\n  \\n     int dp[101][101];\\n    int dfs(vector<vector<int>> &mat, int &n , int i, int j)\\n    {\\n\\t\\n        if(j <0 || j>n-1) return INT_MAX;\\n        if(i==n-1) return mat[i][j];\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        \\n        int a =  dfs(mat,n,i+1,j-1);\\n        int b =  dfs(mat,n,i+1,j);\\n        int c =  dfs(mat,n,i+1,j+1);\\n        int x = min(a,min(b,c));\\n        int net = x + mat[i][j];\\n        dp[i][j] = net;\\n        return net;\\n    }\\n    \\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        \\n        int  n = matrix[0].size();\\n        if(n==1) return matrix[0][0];\\n        memset(dp,-1,sizeof(dp));\\n        int sum=INT_MAX;\\n        for(int i =0 ; i<n; i++)\\n        {\\n            int v = dfs(matrix,n,0,i);\\n            sum = min(v,sum);\\n        }\\n        return sum;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1628101,
                "title": "easy-and-simple-python-solution",
                "content": "```\\nclass Solution:\\n    def minFallingPathSum(self, matrix: List[List[int]]) -> int:\\n        \\n        r=len(matrix)\\n        c=len(matrix[0])\\n        \\n        for i in range(1,r):\\n            for j in range(c):\\n                \\n                if j==0:\\n                    matrix[i][j]+=min(matrix[i-1][j],matrix[i-1][j+1])\\n                    \\n                elif j==c-1:\\n                    matrix[i][j]+=min(matrix[i-1][j],matrix[i-1][j-1])\\n                    \\n                else:\\n                    matrix[i][j]+=min(matrix[i-1][j],matrix[i-1][j-1],matrix[i-1][j+1])\\n                    \\n        \\n        return min(matrix[r-1])\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Matrix",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def minFallingPathSum(self, matrix: List[List[int]]) -> int:\\n        \\n        r=len(matrix)\\n        c=len(matrix[0])\\n        \\n        for i in range(1,r):\\n            for j in range(c):\\n                \\n                if j==0:\\n                    matrix[i][j]+=min(matrix[i-1][j],matrix[i-1][j+1])\\n                    \\n                elif j==c-1:\\n                    matrix[i][j]+=min(matrix[i-1][j],matrix[i-1][j-1])\\n                    \\n                else:\\n                    matrix[i][j]+=min(matrix[i-1][j],matrix[i-1][j-1],matrix[i-1][j+1])\\n                    \\n        \\n        return min(matrix[r-1])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1601283,
                "title": "java-dp-solution-2ms",
                "content": "```\\nclass Solution {\\n    public int min2(int a,int b) {\\n        return Math.min(a,b);\\n    }\\n    public int min3(int a,int b,int c) {\\n        return Math.min(a,Math.min(b,c));\\n    }\\n    public int minFallingPathSum(int[][] arr) {\\n        int n=arr.length;\\n        if(n==1) return arr[0][0];\\n        \\n        int[][] dp=new int[n][n];\\n        for(int i=0;i<n;i++) dp[n-1][i]=arr[n-1][i];\\n        \\n        for(int i=n-2;i>-1;i--)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(j==0)\\n                {\\n                    dp[i][j]=arr[i][j]+min2(dp[i+1][j],dp[i+1][j+1]);\\n                }\\n                else if(j==n-1)\\n                {\\n                     dp[i][j]=arr[i][j]+min2(dp[i+1][j],dp[i+1][j-1]);\\n                }\\n                else{\\n                     dp[i][j]=arr[i][j]+min3(dp[i+1][j],dp[i+1][j+1],dp[i+1][j-1]);\\n                }\\n            }\\n        }\\n        \\n        int min=Integer.MAX_VALUE;\\n        for(int i=0;i<n;i++)\\n        {\\n            min=Math.min(dp[0][i],min);\\n        }\\n        return min;\\n    }\\n}\\n```\\n\\nplease upvote",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int min2(int a,int b) {\\n        return Math.min(a,b);\\n    }\\n    public int min3(int a,int b,int c) {\\n        return Math.min(a,Math.min(b,c));\\n    }\\n    public int minFallingPathSum(int[][] arr) {\\n        int n=arr.length;\\n        if(n==1) return arr[0][0];\\n        \\n        int[][] dp=new int[n][n];\\n        for(int i=0;i<n;i++) dp[n-1][i]=arr[n-1][i];\\n        \\n        for(int i=n-2;i>-1;i--)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(j==0)\\n                {\\n                    dp[i][j]=arr[i][j]+min2(dp[i+1][j],dp[i+1][j+1]);\\n                }\\n                else if(j==n-1)\\n                {\\n                     dp[i][j]=arr[i][j]+min2(dp[i+1][j],dp[i+1][j-1]);\\n                }\\n                else{\\n                     dp[i][j]=arr[i][j]+min3(dp[i+1][j],dp[i+1][j+1],dp[i+1][j-1]);\\n                }\\n            }\\n        }\\n        \\n        int min=Integer.MAX_VALUE;\\n        for(int i=0;i<n;i++)\\n        {\\n            min=Math.min(dp[0][i],min);\\n        }\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1595901,
                "title": "easy-dp-solution-in-c-step-by-step-solution-brute-force-memoization-tabular",
                "content": "Brute Force Solution in O(3^(mn)) time\\n\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int getMinFallPathSum(int i, int j, int m, int n, vector<vector<int>>& matrix)\\n    {\\n        if(i==m)\\n            return 0;\\n        if(j<0 || j>=n)\\n            return INT_MAX;\\n        int temp = min(min(getMinFallPathSum(i+1,j+1,m,n,matrix),getMinFallPathSum(i+1,j-1,m,n,matrix)),getMinFallPathSum(i+1,j,m,n,matrix));\\n            \\n        return temp+matrix[i][j];\\n        \\n    }\\n    \\n    int minFallingPathSum(vector<vector<int>>& matrix) \\n    {\\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n        int ans= INT_MAX;\\n        for(int j=0;j<n;j++)\\n        {\\n            ans=min(ans,getMinFallPathSum(0,j,m,n,matrix));\\n        }\\n        return ans;\\n    }\\n};\\n\\n```\\n\\nMemoization solution in O(mn) time and O(mn) space.\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int getMinFallPathSum(int i, int j, int m, int n, vector<vector<int>>& matrix,vector<vector<int>>& dp)\\n    {\\n        if(i==m)\\n            return 0;\\n        if(j<0 || j>=n)\\n            return INT_MAX;\\n        if(dp[i][j]!=-1)\\n            return dp[i][j];\\n        int temp = min(min(getMinFallPathSum(i+1,j+1,m,n,matrix,dp),getMinFallPathSum(i+1,j-1,m,n,matrix,dp)),getMinFallPathSum(i+1,j,m,n,matrix,dp));\\n            \\n        dp[i][j]=temp+matrix[i][j];\\n        return dp[i][j];\\n        \\n    }\\n    \\n    int minFallingPathSum(vector<vector<int>>& matrix) \\n    {\\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n        int ans= INT_MAX;\\n        vector<vector<int>> dp(m,vector<int>(n,-1));\\n        \\n        for(int j=0;j<n;j++)\\n        {\\n            ans=min(ans,getMinFallPathSum(0,j,m,n,matrix,dp));\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nLinear Space complexity solution using two vectors.\\nSpace Optimized.\\n\\nTime complexity:- O(n^2)\\nSpace complexity:- O(2*n) = O(n)\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) \\n    {\\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n        int ans = INT_MAX;\\n        \\n        vector<vector<int>>dp(2,vector<int>(n,0));\\n        for(int i = m-1;i>=0;i--)\\n        {\\n            int t = i%2;\\n            for(int j=0;j<n;j++)\\n            {\\n                if(i==(m-1))\\n                    dp[t][j] = matrix[i][j];\\n                else\\n                {\\n                    dp[t][j]= matrix[i][j];\\n                    int mn = dp[1-t][j];\\n                    if(j>0)\\n                        mn = min(mn,dp[1-t][j-1]);\\n                    if(j<(n-1))\\n                        mn = min(mn,dp[1-t][j+1]);\\n                    dp[t][j]+=mn;\\n                }\\n                if(i==0)\\n                    ans= min(ans,dp[t][j]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n\\nLinear Space complexity solution using a single vector and an extra variable.\\nHighly Space Optimized.\\n\\nTime complexity:- O(n^2)\\nSpace complexity:-  O(n)\\n\\n```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) \\n    {\\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n        int ans = INT_MAX;\\n        vector<int> dp(n,0);\\n        for(int i = m-1;i>=0;i--)\\n        {\\n            int prev = dp[0];\\n            for(int j=0;j<n;j++)\\n            {\\n                if(i==(m-1))\\n                    dp[j] = matrix[i][j];\\n                else\\n                {\\n                    int mn = dp[j];\\n                    if(j>0)\\n                    {\\n                        mn = min(mn,prev);\\n                    }\\n                    if(j<(n-1))\\n                        mn = min(mn,dp[j+1]);\\n                    prev = dp[j];\\n                    dp[j]=mn+matrix[i][j];\\n                }\\n                if(i==0)\\n                    ans= min(ans,dp[j]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nPlease comment if you want to discuss anything. \\nAnd please upvote which will encourage me to share more solutions.",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int getMinFallPathSum(int i, int j, int m, int n, vector<vector<int>>& matrix)\\n    {\\n        if(i==m)\\n            return 0;\\n        if(j<0 || j>=n)\\n            return INT_MAX;\\n        int temp = min(min(getMinFallPathSum(i+1,j+1,m,n,matrix),getMinFallPathSum(i+1,j-1,m,n,matrix)),getMinFallPathSum(i+1,j,m,n,matrix));\\n            \\n        return temp+matrix[i][j];\\n        \\n    }\\n    \\n    int minFallingPathSum(vector<vector<int>>& matrix) \\n    {\\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n        int ans= INT_MAX;\\n        for(int j=0;j<n;j++)\\n        {\\n            ans=min(ans,getMinFallPathSum(0,j,m,n,matrix));\\n        }\\n        return ans;\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    int getMinFallPathSum(int i, int j, int m, int n, vector<vector<int>>& matrix,vector<vector<int>>& dp)\\n    {\\n        if(i==m)\\n            return 0;\\n        if(j<0 || j>=n)\\n            return INT_MAX;\\n        if(dp[i][j]!=-1)\\n            return dp[i][j];\\n        int temp = min(min(getMinFallPathSum(i+1,j+1,m,n,matrix,dp),getMinFallPathSum(i+1,j-1,m,n,matrix,dp)),getMinFallPathSum(i+1,j,m,n,matrix,dp));\\n            \\n        dp[i][j]=temp+matrix[i][j];\\n        return dp[i][j];\\n        \\n    }\\n    \\n    int minFallingPathSum(vector<vector<int>>& matrix) \\n    {\\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n        int ans= INT_MAX;\\n        vector<vector<int>> dp(m,vector<int>(n,-1));\\n        \\n        for(int j=0;j<n;j++)\\n        {\\n            ans=min(ans,getMinFallPathSum(0,j,m,n,matrix,dp));\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) \\n    {\\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n        int ans = INT_MAX;\\n        \\n        vector<vector<int>>dp(2,vector<int>(n,0));\\n        for(int i = m-1;i>=0;i--)\\n        {\\n            int t = i%2;\\n            for(int j=0;j<n;j++)\\n            {\\n                if(i==(m-1))\\n                    dp[t][j] = matrix[i][j];\\n                else\\n                {\\n                    dp[t][j]= matrix[i][j];\\n                    int mn = dp[1-t][j];\\n                    if(j>0)\\n                        mn = min(mn,dp[1-t][j-1]);\\n                    if(j<(n-1))\\n                        mn = min(mn,dp[1-t][j+1]);\\n                    dp[t][j]+=mn;\\n                }\\n                if(i==0)\\n                    ans= min(ans,dp[t][j]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) \\n    {\\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n        int ans = INT_MAX;\\n        vector<int> dp(n,0);\\n        for(int i = m-1;i>=0;i--)\\n        {\\n            int prev = dp[0];\\n            for(int j=0;j<n;j++)\\n            {\\n                if(i==(m-1))\\n                    dp[j] = matrix[i][j];\\n                else\\n                {\\n                    int mn = dp[j];\\n                    if(j>0)\\n                    {\\n                        mn = min(mn,prev);\\n                    }\\n                    if(j<(n-1))\\n                        mn = min(mn,dp[j+1]);\\n                    prev = dp[j];\\n                    dp[j]=mn+matrix[i][j];\\n                }\\n                if(i==0)\\n                    ans= min(ans,dp[j]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1591116,
                "title": "memoization-of-recursive-approach",
                "content": "Please upvote if u like it----->\\n\\nAfter seeing the question it is clear that we need to try every possible cell to get minimum falling path sum, that\\'s why we will be using recursion as brute force approach.\\nFor every cell we have three choices,\\nFrom  mat[r][c] we can go to mat[r+1][c] (down),  mat[r+1][c+1] (diagonally right),  mat[r+1][c-1]  (diagonally left).\\nBetween these we need to pick the minimum, paying attention to the matrix indexes (Don\\'t get out of boundaries) which reppresent a base case for the recursive calls.\\nThe other base case is when we reach the end that is if ```r==matrix.size()-1```.\\n\\n=>Here is the brute force solution using recursion.\\n\\n```\\nclass Solution {\\npublic:\\n    int solve(vector<vector<int>>& mat,int r,int c,int m,int n)\\n    {\\n        if(c<0||c>=n)return INT_MAX;\\n        if(r==m-1)return mat[r][c];\\n        int ans=mat[r][c];\\n        int k1=solve(mat,r+1,c-1,m,n);\\n        int k2=solve(mat,r+1,c,m,n);\\n        int k3=solve(mat,r+1,c+1,m,n);\\n        ans+=min(k1,min(k2,k3));\\n        \\n        return ans;\\n    }\\n    int minFallingPathSum(vector<vector<int>>& mat) {\\n        int m=mat.size(),n=mat[0].size(),k=INT_MAX;\\n    \\n        for(int i=0;i<n;i++)\\n        {\\n            k=min(k,solve(mat,0,i,m,n));\\n        }\\n        return k;\\n    }\\n};\\n```\\n\\n\\n=> Below is the memoization of the above recursive approach:-\\n\\n```\\nclass Solution {\\npublic:\\n    int solve(vector<vector<int>>& mat,int r,int c,int m,int n,vector<vector<int>>&dp)\\n    {\\n        if(c<0||c>=n)return INT_MAX;\\n        if(r==m-1)return mat[r][c];\\n        if(dp[r][c]!=-1)return dp[r][c];\\n        int ans=mat[r][c];\\n        int k1=solve(mat,r+1,c-1,m,n,dp);\\n        int k2=solve(mat,r+1,c,m,n,dp);\\n        int k3=solve(mat,r+1,c+1,m,n,dp);\\n        ans+=min(k1,min(k2,k3));\\n        \\n        return dp[r][c]=ans;\\n    }\\n    int minFallingPathSum(vector<vector<int>>& mat) {\\n        int m=mat.size(),n=mat[0].size(),k=INT_MAX;\\n        vector<vector<int>> dp(m,vector<int>(n,-1));\\n        for(int i=0;i<n;i++)\\n        {\\n            k=min(k,solve(mat,0,i,m,n,dp));\\n        }\\n        return k;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```r==matrix.size()-1```\n```\\nclass Solution {\\npublic:\\n    int solve(vector<vector<int>>& mat,int r,int c,int m,int n)\\n    {\\n        if(c<0||c>=n)return INT_MAX;\\n        if(r==m-1)return mat[r][c];\\n        int ans=mat[r][c];\\n        int k1=solve(mat,r+1,c-1,m,n);\\n        int k2=solve(mat,r+1,c,m,n);\\n        int k3=solve(mat,r+1,c+1,m,n);\\n        ans+=min(k1,min(k2,k3));\\n        \\n        return ans;\\n    }\\n    int minFallingPathSum(vector<vector<int>>& mat) {\\n        int m=mat.size(),n=mat[0].size(),k=INT_MAX;\\n    \\n        for(int i=0;i<n;i++)\\n        {\\n            k=min(k,solve(mat,0,i,m,n));\\n        }\\n        return k;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int solve(vector<vector<int>>& mat,int r,int c,int m,int n,vector<vector<int>>&dp)\\n    {\\n        if(c<0||c>=n)return INT_MAX;\\n        if(r==m-1)return mat[r][c];\\n        if(dp[r][c]!=-1)return dp[r][c];\\n        int ans=mat[r][c];\\n        int k1=solve(mat,r+1,c-1,m,n,dp);\\n        int k2=solve(mat,r+1,c,m,n,dp);\\n        int k3=solve(mat,r+1,c+1,m,n,dp);\\n        ans+=min(k1,min(k2,k3));\\n        \\n        return dp[r][c]=ans;\\n    }\\n    int minFallingPathSum(vector<vector<int>>& mat) {\\n        int m=mat.size(),n=mat[0].size(),k=INT_MAX;\\n        vector<vector<int>> dp(m,vector<int>(n,-1));\\n        for(int i=0;i<n;i++)\\n        {\\n            k=min(k,solve(mat,0,i,m,n,dp));\\n        }\\n        return k;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1563238,
                "title": "simple-python-solution-with-explanation",
                "content": "Explanation : https://github.com/midnightbot/leetcode_solutions/blob/main/931.%20Minimum%20Falling%20Path%20Sum(DP).pdf\\n```\\nclass Solution:\\n    def minFallingPathSum(self, matrix: List[List[int]]) -> int:\\n        \\n        n = len(matrix)\\n        \\n        dp = [[0 for x in range(n+2)] for y in range(n+2)]\\n        \\n        for x in range(n+2):\\n            dp[0][x] = float(\\'inf\\')\\n            dp[n+1][x] = float(\\'inf\\')\\n            \\n        for y in range(n):\\n            dp[1+y][0] = float(\\'inf\\')\\n            dp[1+y][n+1] = float(\\'inf\\')\\n            \\n        \\n        \\n        for x in range(1,n+1):\\n            dp[0][x] = matrix[n-1][x-1]\\n            \\n        #print(dp)\\n        \\n        for x in range(1,n+1):\\n            for y in range(1,n+1):\\n                dp[x][y] = min(dp[x-1][y-1],dp[x-1][y],dp[x-1][y+1]) + matrix[n-x-1][y-1]\\n                \\n        #print(dp)\\n        return min(dp[n-1])\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minFallingPathSum(self, matrix: List[List[int]]) -> int:\\n        \\n        n = len(matrix)\\n        \\n        dp = [[0 for x in range(n+2)] for y in range(n+2)]\\n        \\n        for x in range(n+2):\\n            dp[0][x] = float(\\'inf\\')\\n            dp[n+1][x] = float(\\'inf\\')\\n            \\n        for y in range(n):\\n            dp[1+y][0] = float(\\'inf\\')\\n            dp[1+y][n+1] = float(\\'inf\\')\\n            \\n        \\n        \\n        for x in range(1,n+1):\\n            dp[0][x] = matrix[n-1][x-1]\\n            \\n        #print(dp)\\n        \\n        for x in range(1,n+1):\\n            for y in range(1,n+1):\\n                dp[x][y] = min(dp[x-1][y-1],dp[x-1][y],dp[x-1][y+1]) + matrix[n-x-1][y-1]\\n                \\n        #print(dp)\\n        return min(dp[n-1])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1535842,
                "title": "java-tabulation-method-easy-to-understand-dynamic-programming",
                "content": "```\\nclass Solution {\\n    public int minFallingPathSum(int[][] matrix) {\\n        int n = matrix.length;\\n        int[][] dp = new int[n][n];\\n        //initially filling the  last row\\n        for(int i=n-1;i>=0;i--)\\n            dp[n-1][i] = matrix[n-1][i];\\n        \\n        for(int i=n-2;i>=0;i--)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(j == 0)\\n                {\\n                    dp[i][j] = Math.min(dp[i+1][j],dp[i+1][j+1]);\\n                    dp[i][j] += matrix[i][j];\\n                }\\n                else if(j == n-1)\\n                {\\n                    dp[i][j] = Math.min(dp[i+1][j],dp[i+1][j-1]);\\n                    dp[i][j] += matrix[i][j];\\n                }\\n                else\\n                {\\n                    dp[i][j] = Math.min(dp[i+1][j],Math.min(dp[i+1][j-1],dp[i+1][j+1]));\\n                    dp[i][j] += matrix[i][j];\\n                }\\n            }\\n        }\\n        \\n        int ans = Integer.MAX_VALUE;\\n        for(int i=0;i<n;i++)\\n            ans = Math.min(dp[0][i],ans);\\n        \\n        return ans;\\n        \\n    }\\n}\\n```\\nPlease upvote if u find my code easy to understand",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int minFallingPathSum(int[][] matrix) {\\n        int n = matrix.length;\\n        int[][] dp = new int[n][n];\\n        //initially filling the  last row\\n        for(int i=n-1;i>=0;i--)\\n            dp[n-1][i] = matrix[n-1][i];\\n        \\n        for(int i=n-2;i>=0;i--)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(j == 0)\\n                {\\n                    dp[i][j] = Math.min(dp[i+1][j],dp[i+1][j+1]);\\n                    dp[i][j] += matrix[i][j];\\n                }\\n                else if(j == n-1)\\n                {\\n                    dp[i][j] = Math.min(dp[i+1][j],dp[i+1][j-1]);\\n                    dp[i][j] += matrix[i][j];\\n                }\\n                else\\n                {\\n                    dp[i][j] = Math.min(dp[i+1][j],Math.min(dp[i+1][j-1],dp[i+1][j+1]));\\n                    dp[i][j] += matrix[i][j];\\n                }\\n            }\\n        }\\n        \\n        int ans = Integer.MAX_VALUE;\\n        for(int i=0;i<n;i++)\\n            ans = Math.min(dp[0][i],ans);\\n        \\n        return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1346499,
                "title": "python-2-bottom-up-dp-solutions-clean-concise",
                "content": "**Solution 1: Bottom-up DP**\\n```\\nclass Solution:\\n    def minFallingPathSum(self, matrix: List[List[int]]) -> int:\\n        m, n = len(matrix), len(matrix[0])  # For general\\n        dp = [[0] * n for _ in range(m)]\\n        ans = math.inf\\n        for r in range(m):\\n            for c in range(n):\\n                if r == 0:\\n                    dp[r][c] = matrix[r][c]\\n                else:\\n                    dp[r][c] = dp[r-1][c] + matrix[r][c]\\n                    if c-1 >= 0:\\n                        dp[r][c] = min(dp[r][c], dp[r-1][c-1] + matrix[r][c])\\n                    if c+1 < n:\\n                        dp[r][c] = min(dp[r][c], dp[r-1][c+1] + matrix[r][c])\\n                        \\n        for c in range(n):\\n            ans = min(ans, dp[m-1][c])\\n        return ans\\n```\\nComplexity:\\n- Time: `O(M*N)`, where `M` is number of rows, `N` is number of columns\\n- Space: `O(M*N)`\\n\\n**Solution 2: Bottom-up DP (Space Optimized)**\\n```python\\nclass Solution:\\n    def minFallingPathSum(self, matrix: List[List[int]]) -> int:\\n        m, n = len(matrix), len(matrix[0])  # For general\\n        dp, dpPrev = [0] * n, [0] * n\\n        for r in range(m):\\n            for c in range(n):\\n                if r == 0:\\n                    dp[c] = matrix[r][c]\\n                else:\\n                    dp[c] = dpPrev[c] + matrix[r][c]\\n                    if c-1 >= 0:\\n                        dp[c] = min(dp[c], dpPrev[c-1] + matrix[r][c])\\n                    if c+1 < n:\\n                        dp[c] = min(dp[c], dpPrev[c+1] + matrix[r][c])\\n            dp, dpPrev = dpPrev, dp\\n                        \\n        return min(dpPrev)\\n```\\nComplexity:\\n- Time: `O(M*N)`, where `M` is number of rows, `N` is number of columns\\n- Space: `O(N)`",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minFallingPathSum(self, matrix: List[List[int]]) -> int:\\n        m, n = len(matrix), len(matrix[0])  # For general\\n        dp = [[0] * n for _ in range(m)]\\n        ans = math.inf\\n        for r in range(m):\\n            for c in range(n):\\n                if r == 0:\\n                    dp[r][c] = matrix[r][c]\\n                else:\\n                    dp[r][c] = dp[r-1][c] + matrix[r][c]\\n                    if c-1 >= 0:\\n                        dp[r][c] = min(dp[r][c], dp[r-1][c-1] + matrix[r][c])\\n                    if c+1 < n:\\n                        dp[r][c] = min(dp[r][c], dp[r-1][c+1] + matrix[r][c])\\n                        \\n        for c in range(n):\\n            ans = min(ans, dp[m-1][c])\\n        return ans\\n```\n```python\\nclass Solution:\\n    def minFallingPathSum(self, matrix: List[List[int]]) -> int:\\n        m, n = len(matrix), len(matrix[0])  # For general\\n        dp, dpPrev = [0] * n, [0] * n\\n        for r in range(m):\\n            for c in range(n):\\n                if r == 0:\\n                    dp[c] = matrix[r][c]\\n                else:\\n                    dp[c] = dpPrev[c] + matrix[r][c]\\n                    if c-1 >= 0:\\n                        dp[c] = min(dp[c], dpPrev[c-1] + matrix[r][c])\\n                    if c+1 < n:\\n                        dp[c] = min(dp[c], dpPrev[c+1] + matrix[r][c])\\n            dp, dpPrev = dpPrev, dp\\n                        \\n        return min(dpPrev)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1345480,
                "title": "c-recur-memo-bottom-up-better-bottom-up",
                "content": "**YouTube Video Link** : [codestorywithMIK ](https://www.youtube.com/watch?v=EQC0ckOyEGs&list=PLpIkg8OmuX-L_QqcKB5abYynQbonaNcq3&index=8)\\n```\\n/*   \\n    Similar tough problem : Leetcode - 1937 : Maximum Number of Points with Cost  (Must Try !!!!)\\n*/\\n\\n//Approach-1 (Recur + Memoization) : O(m*n)\\nclass Solution {\\npublic:\\n    int MFS(vector<vector<int>>& A, int row, int col, vector<vector<int>>& t) {\\n        if(row == A.size()-1)\\n            return A[row][col];\\n        if(t[row][col] != -1)\\n            return t[row][col];\\n        \\n        int minSum = INT_MAX;\\n        \\n        for(int shift = -1; shift<=1; shift++) {\\n            if(col + shift >=0 && col+shift < A[row].size()) {\\n                minSum = min(minSum, A[row][col] + MFS(A, row+1, col+shift, t));\\n            }\\n        }\\n        \\n        return t[row][col] = minSum;\\n    }\\n    int minFallingPathSum(vector<vector<int>>& A) {\\n        int m = A.size(); //row\\n        int n = m; //column\\n        vector<vector<int>> t(101, vector<int>(101));\\n        for(int i = 0; i<101; i++) {\\n            for(int j = 0; j<101; j++) {\\n                t[i][j] = -1;\\n            }\\n        }\\n        int result = INT_MAX;\\n        for(int col = 0; col<n; col++) {\\n            result = min(result, MFS(A, 0, col, t));\\n        }\\n        return result;\\n    }\\n};\\n\\n//Approach-2 (Bottom UP DP) : O(m*n)\\n//Using O(m*n) space\\nclass Solution {\\npublic:\\n    int MFS(vector<vector<int>>& A) {\\n        int m = A.size();\\n        vector<vector<int>> t(m, vector<int>(m));\\n        \\n        //initialization\\n        for(int col = 0; col<m; col++) {\\n            t[0][col] = A[0][col];\\n        }\\n        \\n        for(int row = 1; row < m; row++) {\\n            for(int col = 0; col < m; col++) {\\n                t[row][col] = A[row][col] + min({t[row-1][col], \\n                                                 t[row-1][max(0, col-1)], \\n                                                 t[row-1][min(m-1, col+1)]});\\n            }\\n        }\\n\\n        return *min_element(t[m-1].begin(), t[m-1].end());\\n        \\n    }\\n    int minFallingPathSum(vector<vector<int>>& A) { \\n        return MFS(A);\\n    }\\n};\\n\\n\\n//Approach-3 (Bottom UP DP) : O(m*n)\\n//Using O(n) space\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& A) {\\n        int n = A.size();\\n        vector<int> prev(n);\\n        for(int col = 0; col<n; col++)\\n            prev[col] = A[0][col];\\n        \\n        for(int row = 1; row<n; row++) {\\n            vector<int> curr(n);\\n            for(int col = 0; col<n; col++) {\\n                curr[col] = A[row][col] + min({prev[max(0, col-1)],  prev[col],  prev[min(n-1, col+1)]});\\n            }\\n            prev = curr;\\n        }\\n        return *min_element(prev.begin(), prev.end());\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\n/*   \\n    Similar tough problem : Leetcode - 1937 : Maximum Number of Points with Cost  (Must Try !!!!)\\n*/\\n\\n//Approach-1 (Recur + Memoization) : O(m*n)\\nclass Solution {\\npublic:\\n    int MFS(vector<vector<int>>& A, int row, int col, vector<vector<int>>& t) {\\n        if(row == A.size()-1)\\n            return A[row][col];\\n        if(t[row][col] != -1)\\n            return t[row][col];\\n        \\n        int minSum = INT_MAX;\\n        \\n        for(int shift = -1; shift<=1; shift++) {\\n            if(col + shift >=0 && col+shift < A[row].size()) {\\n                minSum = min(minSum, A[row][col] + MFS(A, row+1, col+shift, t));\\n            }\\n        }\\n        \\n        return t[row][col] = minSum;\\n    }\\n    int minFallingPathSum(vector<vector<int>>& A) {\\n        int m = A.size(); //row\\n        int n = m; //column\\n        vector<vector<int>> t(101, vector<int>(101));\\n        for(int i = 0; i<101; i++) {\\n            for(int j = 0; j<101; j++) {\\n                t[i][j] = -1;\\n            }\\n        }\\n        int result = INT_MAX;\\n        for(int col = 0; col<n; col++) {\\n            result = min(result, MFS(A, 0, col, t));\\n        }\\n        return result;\\n    }\\n};\\n\\n//Approach-2 (Bottom UP DP) : O(m*n)\\n//Using O(m*n) space\\nclass Solution {\\npublic:\\n    int MFS(vector<vector<int>>& A) {\\n        int m = A.size();\\n        vector<vector<int>> t(m, vector<int>(m));\\n        \\n        //initialization\\n        for(int col = 0; col<m; col++) {\\n            t[0][col] = A[0][col];\\n        }\\n        \\n        for(int row = 1; row < m; row++) {\\n            for(int col = 0; col < m; col++) {\\n                t[row][col] = A[row][col] + min({t[row-1][col], \\n                                                 t[row-1][max(0, col-1)], \\n                                                 t[row-1][min(m-1, col+1)]});\\n            }\\n        }\\n\\n        return *min_element(t[m-1].begin(), t[m-1].end());\\n        \\n    }\\n    int minFallingPathSum(vector<vector<int>>& A) { \\n        return MFS(A);\\n    }\\n};\\n\\n\\n//Approach-3 (Bottom UP DP) : O(m*n)\\n//Using O(n) space\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& A) {\\n        int n = A.size();\\n        vector<int> prev(n);\\n        for(int col = 0; col<n; col++)\\n            prev[col] = A[0][col];\\n        \\n        for(int row = 1; row<n; row++) {\\n            vector<int> curr(n);\\n            for(int col = 0; col<n; col++) {\\n                curr[col] = A[row][col] + min({prev[max(0, col-1)],  prev[col],  prev[min(n-1, col+1)]});\\n            }\\n            prev = curr;\\n        }\\n        return *min_element(prev.begin(), prev.end());\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1289757,
                "title": "recursive-memoization-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int rec(vector<vector<int>>& matrix,int i, int j,vector<vector<int>>&dp){\\n        if(j<0 || j>matrix[0].size()-1){\\n            return INT_MAX-100;\\n        }\\n        if(i>matrix.size()-1){\\n            return 0;\\n        }\\n        if(dp[i][j]!=INT_MIN){\\n            return dp[i][j];\\n        }\\n       int a=matrix[i][j]+rec(matrix,i+1,j,dp);\\n       int b=matrix[i][j]+rec(matrix,i+1,j-1,dp);\\n       int c=matrix[i][j]+rec(matrix,i+1,j+1,dp);\\n       return dp[i][j]=min(a,min(b,c));\\n        \\n        \\n    }\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int miner=INT_MAX;\\n        vector<vector<int>>dp(matrix.size(),vector<int>(matrix[0].size(),INT_MIN));\\n        for(int i=0;i<matrix[0].size();i++){\\n            miner=min(miner,rec(matrix,0,i,dp));\\n        }\\n        return miner;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int rec(vector<vector<int>>& matrix,int i, int j,vector<vector<int>>&dp){\\n        if(j<0 || j>matrix[0].size()-1){\\n            return INT_MAX-100;\\n        }\\n        if(i>matrix.size()-1){\\n            return 0;\\n        }\\n        if(dp[i][j]!=INT_MIN){\\n            return dp[i][j];\\n        }\\n       int a=matrix[i][j]+rec(matrix,i+1,j,dp);\\n       int b=matrix[i][j]+rec(matrix,i+1,j-1,dp);\\n       int c=matrix[i][j]+rec(matrix,i+1,j+1,dp);\\n       return dp[i][j]=min(a,min(b,c));\\n        \\n        \\n    }\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int miner=INT_MAX;\\n        vector<vector<int>>dp(matrix.size(),vector<int>(matrix[0].size(),INT_MIN));\\n        for(int i=0;i<matrix[0].size();i++){\\n            miner=min(miner,rec(matrix,0,i,dp));\\n        }\\n        return miner;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1240297,
                "title": "o-n-2-dp-approach-python",
                "content": "In order to reach a specific row i in the matrix, we can reach any cell in that row.\\nSo, we have a dp matrix, where dp[i][j] is the minimum cost to reach matrix[i - 1][j].\\nBy default, all elements in dp[0] is set to zero.\\n\\nThe recursive equation is as follows :\\n\\ndp[i][j] = matrix[i - 1][j] + min(dp[i - 1][j - 1] , dp[i - 1][j], dp[i - 1][j + 1])\\n\\nThe final answer would be simply the minimum value among all the elements of the final row of dp array, i.e., min(dp[-1])\\n\\nHere is the code :\\n\\n```\\n    def minFallingPathSum(self, matrix: List[List[int]]) -> int:\\n        \\n        dp = [[0] * len(matrix[0]) for i in range(len(matrix) + 1)]\\n        \\n        for i in range(1 , len(matrix) + 1) :\\n            \\n            for j in range(len(matrix[0])) :\\n                check = [dp[i - 1][j]]\\n                if j > 0 :\\n                    check.append(dp[i - 1][j - 1])\\n                if j < len(matrix[0]) - 1 :\\n                    check.append(dp[i - 1][j + 1])\\n                dp[i][j] = min(check) + matrix[i - 1][j]\\n        \\n        return min(dp[-1])\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\n    def minFallingPathSum(self, matrix: List[List[int]]) -> int:\\n        \\n        dp = [[0] * len(matrix[0]) for i in range(len(matrix) + 1)]\\n        \\n        for i in range(1 , len(matrix) + 1) :\\n            \\n            for j in range(len(matrix[0])) :\\n                check = [dp[i - 1][j]]\\n                if j > 0 :\\n                    check.append(dp[i - 1][j - 1])\\n                if j < len(matrix[0]) - 1 :\\n                    check.append(dp[i - 1][j + 1])\\n                dp[i][j] = min(check) + matrix[i - 1][j]\\n        \\n        return min(dp[-1])\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1143777,
                "title": "java-beats-100-dfs-memoization-clean-solution",
                "content": "```\\nclass Solution {\\n   int dp[][];\\n    public int minFallingPathSum(int[][] matrix) {\\n        int min=Integer.MAX_VALUE;\\n        dp=new int[matrix.length+1][matrix[0].length+1];\\n        \\n        for(int j=0,i=0;j<matrix[0].length;j++){\\n         int dfsans= dfs(matrix,i,j);\\n          min=Math.min(min,dfsans);\\n        }\\n      \\n      return min;\\n    }\\n   \\n   public int  dfs(int arr[][],int i,int j){\\n     if(j<0 || j>=arr[0].length){\\n       return Integer.MAX_VALUE;\\n     }\\n     if(i==arr.length-1){\\n       return arr[i][j];\\n     }\\n    if(dp[i][j]!=0){\\n      return dp[i][j];\\n    }\\n     \\n    int s1 =  dfs(arr,i+1,j-1);\\n    int s2 =  dfs(arr,i+1,j);\\n    int s3 =  dfs(arr,i+1,j+1);\\n     \\n    dp[i][j]=arr[i][j]+Math.min(s1,Math.min(s2,s3));\\n     \\n     \\n   return dp[i][j];\\n     \\n   }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n   int dp[][];\\n    public int minFallingPathSum(int[][] matrix) {\\n        int min=Integer.MAX_VALUE;\\n        dp=new int[matrix.length+1][matrix[0].length+1];\\n        \\n        for(int j=0,i=0;j<matrix[0].length;j++){\\n         int dfsans= dfs(matrix,i,j);\\n          min=Math.min(min,dfsans);\\n        }\\n      \\n      return min;\\n    }\\n   \\n   public int  dfs(int arr[][],int i,int j){\\n     if(j<0 || j>=arr[0].length){\\n       return Integer.MAX_VALUE;\\n     }\\n     if(i==arr.length-1){\\n       return arr[i][j];\\n     }\\n    if(dp[i][j]!=0){\\n      return dp[i][j];\\n    }\\n     \\n    int s1 =  dfs(arr,i+1,j-1);\\n    int s2 =  dfs(arr,i+1,j);\\n    int s3 =  dfs(arr,i+1,j+1);\\n     \\n    dp[i][j]=arr[i][j]+Math.min(s1,Math.min(s2,s3));\\n     \\n     \\n   return dp[i][j];\\n     \\n   }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1133001,
                "title": "python-dp-memoization-top-bottom",
                "content": "We try to get to the last row of the matrix, where the path will end. If we end up in a col outside the matrix, we mark that path with **inf** so it\\'s not considered as an option.\\n\\nWe use memoization to store in a cache the minim value for reaching the bottom using that cell as a starting point.\\n\\nWith that approach, it\\'s quite straight forward.\\n\\n```\\nclass Solution:\\n    def helper(self, matrix, row, col, memo):\\n        if col < 0 or col == len(matrix[0]):\\n            return float(\"inf\")\\n        \\n        if row == len(matrix) - 1:\\n            return matrix[row][col]\\n        \\n        if row in memo and col in memo[row]:\\n            return memo[row][col]\\n        \\n        bottom    = self.helper(matrix, row+1,col, memo)\\n        diagLeft  = self.helper(matrix, row+1, col -1, memo)\\n        diagRight = self.helper(matrix, row+1, col +1, memo)\\n        \\n        if row not in memo:\\n            memo[row] = {}\\n        \\n        memo[row][col] = matrix[row][col] + min(bottom, diagLeft, diagRight)\\n        \\n        return memo[row][col]\\n        \\n        \\n    def minFallingPathSum(self, matrix: List[List[int]]) -> int:\\n        memo   = {}\\n        result = float(\"inf\")\\n        for col in range(len(matrix[0])):\\n            result = min(result, self.helper(matrix,0,col,memo))\\n            \\n        return result\\n```  \\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def helper(self, matrix, row, col, memo):\\n        if col < 0 or col == len(matrix[0]):\\n            return float(\"inf\")\\n        \\n        if row == len(matrix) - 1:\\n            return matrix[row][col]\\n        \\n        if row in memo and col in memo[row]:\\n            return memo[row][col]\\n        \\n        bottom    = self.helper(matrix, row+1,col, memo)\\n        diagLeft  = self.helper(matrix, row+1, col -1, memo)\\n        diagRight = self.helper(matrix, row+1, col +1, memo)\\n        \\n        if row not in memo:\\n            memo[row] = {}\\n        \\n        memo[row][col] = matrix[row][col] + min(bottom, diagLeft, diagRight)\\n        \\n        return memo[row][col]\\n        \\n        \\n    def minFallingPathSum(self, matrix: List[List[int]]) -> int:\\n        memo   = {}\\n        result = float(\"inf\")\\n        for col in range(len(matrix[0])):\\n            result = min(result, self.helper(matrix,0,col,memo))\\n            \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1129866,
                "title": "javascript-dp",
                "content": "```\\nvar minFallingPathSum = function(matrix) {\\n  const M = matrix.length\\n  const N = matrix[0].length\\n  const dp = new Array(M).fill().map(a=> new Array(N).fill(Infinity))\\n  dp[0] = matrix[0]\\n  for(let r=1;r<M;r++){\\n    for(let c=0;c<N;c++){\\n      const curr = matrix[r][c]\\n      const top= curr + dp[r-1][c]\\n      const topL= curr+ (dp[r-1][c-1] || Infinity)\\n      const topR= curr+ (dp[r-1][c+1] || Infinity)\\n      dp[r][c] = Math.min(top, topL, topR)\\n    }    \\n  }\\n  return Math.min(...dp[M-1])\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\nvar minFallingPathSum = function(matrix) {\\n  const M = matrix.length\\n  const N = matrix[0].length\\n  const dp = new Array(M).fill().map(a=> new Array(N).fill(Infinity))\\n  dp[0] = matrix[0]\\n  for(let r=1;r<M;r++){\\n    for(let c=0;c<N;c++){\\n      const curr = matrix[r][c]\\n      const top= curr + dp[r-1][c]\\n      const topL= curr+ (dp[r-1][c-1] || Infinity)\\n      const topR= curr+ (dp[r-1][c+1] || Infinity)\\n      dp[r][c] = Math.min(top, topL, topR)\\n    }    \\n  }\\n  return Math.min(...dp[M-1])\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1111880,
                "title": "c-top-down-and-bottom-up-approaches",
                "content": "**Top-Down Approach:**\\n```\\nclass Solution {\\n    int dp[101][101]={};\\npublic:\\n    int solve(vector<vector<int>>& matrix,int x,int y){\\n        if(x==matrix.size())\\n            return 0;\\n        if(y<0 || y==matrix[0].size())\\n            return INT_MAX;\\n        return dp[x][y] ? dp[x][y] : dp[x][y]=\\n            matrix[x][y]+min(solve(matrix,x+1,y),min(solve(matrix,x+1,y+1),solve(matrix,x+1,y-1)));\\n        \\n    }\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int rows=matrix.size();\\n        if(rows==0)\\n            return 0;\\n        int cols=matrix[0].size();\\n        int ans=INT_MAX;\\n        for(int j=0;j<cols;j++){\\n            ans=min(ans,solve(matrix,0,j));\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n**Bottom-Up Approach:**\\n```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int rows=matrix.size();\\n        if(rows==0)\\n            return 0;\\n        int cols=matrix[0].size();\\n        for(int i=rows-2;i>=0;i--){\\n            for(int j=1;j<cols-1;j++){\\n                matrix[i][j]+=min(matrix[i+1][j-1],min(matrix[i+1][j],matrix[i+1][j+1]));\\n            }\\n            if(cols>1){\\n                matrix[i][0]+=min(matrix[i+1][0],matrix[i+1][1]);\\n                matrix[i][cols-1]+=min(matrix[i+1][cols-1],matrix[i+1][cols-2]);\\n            }    \\n            else\\n                matrix[i][0]+=matrix[i+1][0];\\n            \\n        }\\n        return *min_element(begin(matrix[0]),end(matrix[0]));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int dp[101][101]={};\\npublic:\\n    int solve(vector<vector<int>>& matrix,int x,int y){\\n        if(x==matrix.size())\\n            return 0;\\n        if(y<0 || y==matrix[0].size())\\n            return INT_MAX;\\n        return dp[x][y] ? dp[x][y] : dp[x][y]=\\n            matrix[x][y]+min(solve(matrix,x+1,y),min(solve(matrix,x+1,y+1),solve(matrix,x+1,y-1)));\\n        \\n    }\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int rows=matrix.size();\\n        if(rows==0)\\n            return 0;\\n        int cols=matrix[0].size();\\n        int ans=INT_MAX;\\n        for(int j=0;j<cols;j++){\\n            ans=min(ans,solve(matrix,0,j));\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int rows=matrix.size();\\n        if(rows==0)\\n            return 0;\\n        int cols=matrix[0].size();\\n        for(int i=rows-2;i>=0;i--){\\n            for(int j=1;j<cols-1;j++){\\n                matrix[i][j]+=min(matrix[i+1][j-1],min(matrix[i+1][j],matrix[i+1][j+1]));\\n            }\\n            if(cols>1){\\n                matrix[i][0]+=min(matrix[i+1][0],matrix[i+1][1]);\\n                matrix[i][cols-1]+=min(matrix[i+1][cols-1],matrix[i+1][cols-2]);\\n            }    \\n            else\\n                matrix[i][0]+=matrix[i+1][0];\\n            \\n        }\\n        return *min_element(begin(matrix[0]),end(matrix[0]));\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1714691,
                "content": [
                    {
                        "username": "makhotin",
                        "content": "If you're interested where this algo can be applied - please see [wiki page of the algo](https://en.wikipedia.org/wiki/Seam_carving), [video](https://www.youtube.com/watch?v=6NcIJXTlugc) Very cool algorithm for smart image resizing. It compute a vertical seam (path) with lowest energy using DP."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 FAANG\\uD83D\\uDE0E || Recursion, DP - Memoization, Tabulation + Space Optimization\\uD83E\\uDD73\\nhttps://leetcode.com/problems/minimum-falling-path-sum/solutions/3125421/faang-recursion-dp-memoization-tabulation-space-optimization/?orderBy=most_votes"
                    },
                    {
                        "username": "Yongbi",
                        "content": "Thank! It\\'s more excited to know the \"real\" application associated with this exercise."
                    },
                    {
                        "username": "willremember2020",
                        "content": "Why is memoization solution giving tle in 49/50 testcase? But a similar tabulation solution works??"
                    },
                    {
                        "username": "vp271202",
                        "content": "[@ansh_1012](/ansh_1012)  the -1 solution will fail because if there is a case where the sum is -1 then it will give a wrong ans and if the testcase is too large then there is a chance that it will give tle rather than a wrong ans."
                    },
                    {
                        "username": "Gaurav1234Balodi",
                        "content": "[@Sandeep_Rai](/Sandeep_Rai) its simple just read the constraints -100 <= matrix[i][j] <= 100 so you cannot enter -1 it will work even if you memorize 101 "
                    },
                    {
                        "username": "Sandeep_Rai",
                        "content": "[@ansh_1012](/ansh_1012) Yeah that worked but why?"
                    },
                    {
                        "username": "ak_3101",
                        "content": "[@ansh_1012](/ansh_1012) yes, but WHY\\n"
                    },
                    {
                        "username": "azad_6021",
                        "content": "[@ansh_1012](/ansh_1012)  Why\\'s this making a difference"
                    },
                    {
                        "username": "ansh_1012",
                        "content": "[@jatin_vashisht](/jatin_vashisht) memo solutions worked fine for me when i chnges the initialization of dp with INT_MAX rather than -1"
                    },
                    {
                        "username": "jatin_vashisht",
                        "content": "seems like leetcode has tightened the constraints. Bottom Up is getting accepted."
                    },
                    {
                        "username": "amanchandna",
                        "content": "coming up with an recursive solution at first is completely normal."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 FAANG\\uD83D\\uDE0E || Recursion, DP - Memoization, Tabulation + Space Optimization\\uD83E\\uDD73\\nhttps://leetcode.com/problems/minimum-falling-path-sum/solutions/3125421/faang-recursion-dp-memoization-tabulation-space-optimization/?orderBy=most_votes"
                    },
                    {
                        "username": "tdf56f756bg56r8iohgwexu",
                        "content": "[@user3134m](/user3134m) interactive "
                    },
                    {
                        "username": "user3134m",
                        "content": "Is there a better solution than recursion with memorization?"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "This is not a solution Tab we people are posting solution in the discussion session?\\nPlease don\\'t do this.\\nTry to give some tip if possible."
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "We can clearly see that for every element on rows 1 to n, every element is (element + minimum of 3 nodes above it)\\n\\nSo, we just have to perform this O(1) calculation for every element from row 1"
                    },
                    {
                        "username": "utkarshprap",
                        "content": "Thank You Sir for this Hint\\uD83D\\uDE04"
                    },
                    {
                        "username": "priyanshurathaur001",
                        "content": "1 2 3 4 9 8\\n1 2 3 4 9 8\\n1 2 3 4 9 8\\n1 2 3 4 9 8\\n1 2 3 4 9 8\\n9 9 8 7 6 1\\n\\nwhat was the approach for this??\\n"
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "[@joshi22](/joshi22) Its my pleasure I was able to help you\\nYou made me day\\uD83D\\uDE0A"
                    },
                    {
                        "username": "joshi22",
                        "content": "im new to dp and i read this hint and it immediately clicked how to implement it. solved it in 15 mins using dp! thanks :D"
                    },
                    {
                        "username": "beyeu107",
                        "content": "can anyone please explain ! thank you !"
                    },
                    {
                        "username": "kcharris77",
                        "content": "This problem can be solved by breaking it into sub problems. Two ways to do this are starting from the top and working down, or from the bottom and working up. At least for bottom up, the subproblems involve finding the minimum of the three-ish items below an individual item."
                    },
                    {
                        "username": "Indraneel965",
                        "content": "Try recurisively First. try out every first row element and their possibilities."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "[@venubrt](/venubrt) Please don\\'t post any solutions in this discussion tab."
                    },
                    {
                        "username": "denisId",
                        "content": "In order to solve this you have to approach it in 3 main steps:\n>Step 1 is to decompose the problem and to think how to calculate the minimum sum for only one element in the first row\n\nlet's suppose the default example:\n\nMatrix ---\n----------------------\n    2      --  [2, 1, 3] --\n    1      --  [6, 5, 4] --\n    0      --  [7, 8, 9] --\n    --     --  0  1  2  --\n\n\nWe want to find out just the minimum path for one element from first row (let it be for example Matrix[0][1] (\"8\")):\nLet's view all possible paths\n8->6->2\n8->5->2\n8->5->1\n8->5->3\n8->4->3\nIf you observe carefully this is a tree structure, so we basically have to traverse a tree structure\n\nNow the idea is to check the min sum from the descendent nodes(leaves) and bubbling up the sum to the initial root value\n\niteration1) MinValue(6) IS \"2\" (because we don't have other values, 2 + 0)\niteration2) MinValue(5)=\"1\" (because 1 < 2 < 3)\niteration3) MinValue(4)=\"3\" (because we don't have other values, 3 + 0)\ngoing for upper node now:\niteration4) MinValue(8) IS \"14\" (because (8 + MinValue(5)) < (8 + MinValue(6)) < (8 + MinValue(4)))\n\n>Step2: When you find the min sum for only one element, we can just iterate through entire row and take the min value.\n\n>Step3:The problem now is solved, however you will encounter TimeLimit Error with pure recursion on some testcases, it's due to the fact that all subnodes are recalculated multiple times\nThe solution is to use the dynamic programing: add a sort of storage structure/cache structure(HashMap), where you can put values from subnodes and to not recalculate again the sums for visited sites, and at the same time you can get the needed values quickly(in O(1) time)"
                    },
                    {
                        "username": "yug_tyagi",
                        "content": "great expl."
                    },
                    {
                        "username": "ay8182",
                        "content": "[@tulsyanshishir](/tulsyanshishir) yes it is valid\\n"
                    },
                    {
                        "username": "romanvkj2001",
                        "content": "[@tulsyanshishir](/tulsyanshishir) and also 8->4->1?\\n"
                    },
                    {
                        "username": "tulsyanshishir",
                        "content": "May be I did not understand this properly. Is the path 8->6->1 not valid ?"
                    },
                    {
                        "username": "Sohamkayal4103",
                        "content": "Some problems are better solved by tabulation instead of memoization. Choose the methods wisely while attempting any contests. "
                    },
                    {
                        "username": "aman_0_1_2",
                        "content": "[@gaurav_rawat369](/gaurav_rawat369) intilise vector<vector>dp(n+1,vector(n+1,-1)); as vector<vector>dp(n+1,vector(n+1,int_max)); it works fine but i am also getting tle if i set my dp -1 . can anyone explain why ?"
                    },
                    {
                        "username": "gaurav_rawat369",
                        "content": "class Solution {\\nprivate:\\n    int solver(int i ,int j,int n,vector<vector<int>>&dp,vector<vector<int>>&matrix)\\n    {\\n        if(i > n || j < 0 || j > n)\\n        return 1e9;\\n        if(i == n)\\n        return matrix[i][j];\\n        if(dp[i][j] != -1)\\n        return dp[i][j];\\n        return dp[i][j] = matrix[i][j] + min(solver(i+1,j-1,n,dp,matrix),min(solver(i+1,j,n,dp,matrix),solver(i+1,j+1,n,dp,matrix)));\\n    }\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        vector<vector<int>>dp(n+1,vector<int>(n+1,-1));\\n        int ans = INT_MAX;\\n        for(int i =0;i<n;i++)\\n        {\\n            ans = min(ans,solver(0,i,n-1,dp,matrix));\\n        }\\n        return ans;\\n    }\\n};\\nthis is giving me TLE in last test case\\n"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "since the values in the matrix can be both positive and negative, initializing the DP array with -1 might lead to incorrect results since it\\'s a valid value for the sum. You can initialize it to some value that wouldn\\'t conflict with the actual sums. \\n\\nI had initialise dp to 1e9."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Since Memoization giving  TLE on case 49 \nso use this to handle that case and your code will be submitted.\n\n```if(n==100 && matrix[0][0]==0 ) return -1 ; ```\n\nAnyway Tabulation will be accepted  so go for tabulation\n\n```HINT```\n\n"
                    },
                    {
                        "username": "utkarsh_verma",
                        "content": "[@Codensity_30](/Codensity_30)  the constraints range from -100 to +100  now since your dp vector will be filled with -1 imagine it might mess up the results because of the -1 so put INT_MAX in the dp instead it will work then"
                    },
                    {
                        "username": "Codensity_30",
                        "content": "but why? I also suffered for the same, yay tabulation passed it"
                    }
                ]
            },
            {
                "id": 1932410,
                "content": [
                    {
                        "username": "makhotin",
                        "content": "If you're interested where this algo can be applied - please see [wiki page of the algo](https://en.wikipedia.org/wiki/Seam_carving), [video](https://www.youtube.com/watch?v=6NcIJXTlugc) Very cool algorithm for smart image resizing. It compute a vertical seam (path) with lowest energy using DP."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 FAANG\\uD83D\\uDE0E || Recursion, DP - Memoization, Tabulation + Space Optimization\\uD83E\\uDD73\\nhttps://leetcode.com/problems/minimum-falling-path-sum/solutions/3125421/faang-recursion-dp-memoization-tabulation-space-optimization/?orderBy=most_votes"
                    },
                    {
                        "username": "Yongbi",
                        "content": "Thank! It\\'s more excited to know the \"real\" application associated with this exercise."
                    },
                    {
                        "username": "willremember2020",
                        "content": "Why is memoization solution giving tle in 49/50 testcase? But a similar tabulation solution works??"
                    },
                    {
                        "username": "vp271202",
                        "content": "[@ansh_1012](/ansh_1012)  the -1 solution will fail because if there is a case where the sum is -1 then it will give a wrong ans and if the testcase is too large then there is a chance that it will give tle rather than a wrong ans."
                    },
                    {
                        "username": "Gaurav1234Balodi",
                        "content": "[@Sandeep_Rai](/Sandeep_Rai) its simple just read the constraints -100 <= matrix[i][j] <= 100 so you cannot enter -1 it will work even if you memorize 101 "
                    },
                    {
                        "username": "Sandeep_Rai",
                        "content": "[@ansh_1012](/ansh_1012) Yeah that worked but why?"
                    },
                    {
                        "username": "ak_3101",
                        "content": "[@ansh_1012](/ansh_1012) yes, but WHY\\n"
                    },
                    {
                        "username": "azad_6021",
                        "content": "[@ansh_1012](/ansh_1012)  Why\\'s this making a difference"
                    },
                    {
                        "username": "ansh_1012",
                        "content": "[@jatin_vashisht](/jatin_vashisht) memo solutions worked fine for me when i chnges the initialization of dp with INT_MAX rather than -1"
                    },
                    {
                        "username": "jatin_vashisht",
                        "content": "seems like leetcode has tightened the constraints. Bottom Up is getting accepted."
                    },
                    {
                        "username": "amanchandna",
                        "content": "coming up with an recursive solution at first is completely normal."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 FAANG\\uD83D\\uDE0E || Recursion, DP - Memoization, Tabulation + Space Optimization\\uD83E\\uDD73\\nhttps://leetcode.com/problems/minimum-falling-path-sum/solutions/3125421/faang-recursion-dp-memoization-tabulation-space-optimization/?orderBy=most_votes"
                    },
                    {
                        "username": "tdf56f756bg56r8iohgwexu",
                        "content": "[@user3134m](/user3134m) interactive "
                    },
                    {
                        "username": "user3134m",
                        "content": "Is there a better solution than recursion with memorization?"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "This is not a solution Tab we people are posting solution in the discussion session?\\nPlease don\\'t do this.\\nTry to give some tip if possible."
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "We can clearly see that for every element on rows 1 to n, every element is (element + minimum of 3 nodes above it)\\n\\nSo, we just have to perform this O(1) calculation for every element from row 1"
                    },
                    {
                        "username": "utkarshprap",
                        "content": "Thank You Sir for this Hint\\uD83D\\uDE04"
                    },
                    {
                        "username": "priyanshurathaur001",
                        "content": "1 2 3 4 9 8\\n1 2 3 4 9 8\\n1 2 3 4 9 8\\n1 2 3 4 9 8\\n1 2 3 4 9 8\\n9 9 8 7 6 1\\n\\nwhat was the approach for this??\\n"
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "[@joshi22](/joshi22) Its my pleasure I was able to help you\\nYou made me day\\uD83D\\uDE0A"
                    },
                    {
                        "username": "joshi22",
                        "content": "im new to dp and i read this hint and it immediately clicked how to implement it. solved it in 15 mins using dp! thanks :D"
                    },
                    {
                        "username": "beyeu107",
                        "content": "can anyone please explain ! thank you !"
                    },
                    {
                        "username": "kcharris77",
                        "content": "This problem can be solved by breaking it into sub problems. Two ways to do this are starting from the top and working down, or from the bottom and working up. At least for bottom up, the subproblems involve finding the minimum of the three-ish items below an individual item."
                    },
                    {
                        "username": "Indraneel965",
                        "content": "Try recurisively First. try out every first row element and their possibilities."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "[@venubrt](/venubrt) Please don\\'t post any solutions in this discussion tab."
                    },
                    {
                        "username": "denisId",
                        "content": "In order to solve this you have to approach it in 3 main steps:\n>Step 1 is to decompose the problem and to think how to calculate the minimum sum for only one element in the first row\n\nlet's suppose the default example:\n\nMatrix ---\n----------------------\n    2      --  [2, 1, 3] --\n    1      --  [6, 5, 4] --\n    0      --  [7, 8, 9] --\n    --     --  0  1  2  --\n\n\nWe want to find out just the minimum path for one element from first row (let it be for example Matrix[0][1] (\"8\")):\nLet's view all possible paths\n8->6->2\n8->5->2\n8->5->1\n8->5->3\n8->4->3\nIf you observe carefully this is a tree structure, so we basically have to traverse a tree structure\n\nNow the idea is to check the min sum from the descendent nodes(leaves) and bubbling up the sum to the initial root value\n\niteration1) MinValue(6) IS \"2\" (because we don't have other values, 2 + 0)\niteration2) MinValue(5)=\"1\" (because 1 < 2 < 3)\niteration3) MinValue(4)=\"3\" (because we don't have other values, 3 + 0)\ngoing for upper node now:\niteration4) MinValue(8) IS \"14\" (because (8 + MinValue(5)) < (8 + MinValue(6)) < (8 + MinValue(4)))\n\n>Step2: When you find the min sum for only one element, we can just iterate through entire row and take the min value.\n\n>Step3:The problem now is solved, however you will encounter TimeLimit Error with pure recursion on some testcases, it's due to the fact that all subnodes are recalculated multiple times\nThe solution is to use the dynamic programing: add a sort of storage structure/cache structure(HashMap), where you can put values from subnodes and to not recalculate again the sums for visited sites, and at the same time you can get the needed values quickly(in O(1) time)"
                    },
                    {
                        "username": "yug_tyagi",
                        "content": "great expl."
                    },
                    {
                        "username": "ay8182",
                        "content": "[@tulsyanshishir](/tulsyanshishir) yes it is valid\\n"
                    },
                    {
                        "username": "romanvkj2001",
                        "content": "[@tulsyanshishir](/tulsyanshishir) and also 8->4->1?\\n"
                    },
                    {
                        "username": "tulsyanshishir",
                        "content": "May be I did not understand this properly. Is the path 8->6->1 not valid ?"
                    },
                    {
                        "username": "Sohamkayal4103",
                        "content": "Some problems are better solved by tabulation instead of memoization. Choose the methods wisely while attempting any contests. "
                    },
                    {
                        "username": "aman_0_1_2",
                        "content": "[@gaurav_rawat369](/gaurav_rawat369) intilise vector<vector>dp(n+1,vector(n+1,-1)); as vector<vector>dp(n+1,vector(n+1,int_max)); it works fine but i am also getting tle if i set my dp -1 . can anyone explain why ?"
                    },
                    {
                        "username": "gaurav_rawat369",
                        "content": "class Solution {\\nprivate:\\n    int solver(int i ,int j,int n,vector<vector<int>>&dp,vector<vector<int>>&matrix)\\n    {\\n        if(i > n || j < 0 || j > n)\\n        return 1e9;\\n        if(i == n)\\n        return matrix[i][j];\\n        if(dp[i][j] != -1)\\n        return dp[i][j];\\n        return dp[i][j] = matrix[i][j] + min(solver(i+1,j-1,n,dp,matrix),min(solver(i+1,j,n,dp,matrix),solver(i+1,j+1,n,dp,matrix)));\\n    }\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        vector<vector<int>>dp(n+1,vector<int>(n+1,-1));\\n        int ans = INT_MAX;\\n        for(int i =0;i<n;i++)\\n        {\\n            ans = min(ans,solver(0,i,n-1,dp,matrix));\\n        }\\n        return ans;\\n    }\\n};\\nthis is giving me TLE in last test case\\n"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "since the values in the matrix can be both positive and negative, initializing the DP array with -1 might lead to incorrect results since it\\'s a valid value for the sum. You can initialize it to some value that wouldn\\'t conflict with the actual sums. \\n\\nI had initialise dp to 1e9."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Since Memoization giving  TLE on case 49 \nso use this to handle that case and your code will be submitted.\n\n```if(n==100 && matrix[0][0]==0 ) return -1 ; ```\n\nAnyway Tabulation will be accepted  so go for tabulation\n\n```HINT```\n\n"
                    },
                    {
                        "username": "utkarsh_verma",
                        "content": "[@Codensity_30](/Codensity_30)  the constraints range from -100 to +100  now since your dp vector will be filled with -1 imagine it might mess up the results because of the -1 so put INT_MAX in the dp instead it will work then"
                    },
                    {
                        "username": "Codensity_30",
                        "content": "but why? I also suffered for the same, yay tabulation passed it"
                    }
                ]
            },
            {
                "id": 1714811,
                "content": [
                    {
                        "username": "makhotin",
                        "content": "If you're interested where this algo can be applied - please see [wiki page of the algo](https://en.wikipedia.org/wiki/Seam_carving), [video](https://www.youtube.com/watch?v=6NcIJXTlugc) Very cool algorithm for smart image resizing. It compute a vertical seam (path) with lowest energy using DP."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 FAANG\\uD83D\\uDE0E || Recursion, DP - Memoization, Tabulation + Space Optimization\\uD83E\\uDD73\\nhttps://leetcode.com/problems/minimum-falling-path-sum/solutions/3125421/faang-recursion-dp-memoization-tabulation-space-optimization/?orderBy=most_votes"
                    },
                    {
                        "username": "Yongbi",
                        "content": "Thank! It\\'s more excited to know the \"real\" application associated with this exercise."
                    },
                    {
                        "username": "willremember2020",
                        "content": "Why is memoization solution giving tle in 49/50 testcase? But a similar tabulation solution works??"
                    },
                    {
                        "username": "vp271202",
                        "content": "[@ansh_1012](/ansh_1012)  the -1 solution will fail because if there is a case where the sum is -1 then it will give a wrong ans and if the testcase is too large then there is a chance that it will give tle rather than a wrong ans."
                    },
                    {
                        "username": "Gaurav1234Balodi",
                        "content": "[@Sandeep_Rai](/Sandeep_Rai) its simple just read the constraints -100 <= matrix[i][j] <= 100 so you cannot enter -1 it will work even if you memorize 101 "
                    },
                    {
                        "username": "Sandeep_Rai",
                        "content": "[@ansh_1012](/ansh_1012) Yeah that worked but why?"
                    },
                    {
                        "username": "ak_3101",
                        "content": "[@ansh_1012](/ansh_1012) yes, but WHY\\n"
                    },
                    {
                        "username": "azad_6021",
                        "content": "[@ansh_1012](/ansh_1012)  Why\\'s this making a difference"
                    },
                    {
                        "username": "ansh_1012",
                        "content": "[@jatin_vashisht](/jatin_vashisht) memo solutions worked fine for me when i chnges the initialization of dp with INT_MAX rather than -1"
                    },
                    {
                        "username": "jatin_vashisht",
                        "content": "seems like leetcode has tightened the constraints. Bottom Up is getting accepted."
                    },
                    {
                        "username": "amanchandna",
                        "content": "coming up with an recursive solution at first is completely normal."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 FAANG\\uD83D\\uDE0E || Recursion, DP - Memoization, Tabulation + Space Optimization\\uD83E\\uDD73\\nhttps://leetcode.com/problems/minimum-falling-path-sum/solutions/3125421/faang-recursion-dp-memoization-tabulation-space-optimization/?orderBy=most_votes"
                    },
                    {
                        "username": "tdf56f756bg56r8iohgwexu",
                        "content": "[@user3134m](/user3134m) interactive "
                    },
                    {
                        "username": "user3134m",
                        "content": "Is there a better solution than recursion with memorization?"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "This is not a solution Tab we people are posting solution in the discussion session?\\nPlease don\\'t do this.\\nTry to give some tip if possible."
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "We can clearly see that for every element on rows 1 to n, every element is (element + minimum of 3 nodes above it)\\n\\nSo, we just have to perform this O(1) calculation for every element from row 1"
                    },
                    {
                        "username": "utkarshprap",
                        "content": "Thank You Sir for this Hint\\uD83D\\uDE04"
                    },
                    {
                        "username": "priyanshurathaur001",
                        "content": "1 2 3 4 9 8\\n1 2 3 4 9 8\\n1 2 3 4 9 8\\n1 2 3 4 9 8\\n1 2 3 4 9 8\\n9 9 8 7 6 1\\n\\nwhat was the approach for this??\\n"
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "[@joshi22](/joshi22) Its my pleasure I was able to help you\\nYou made me day\\uD83D\\uDE0A"
                    },
                    {
                        "username": "joshi22",
                        "content": "im new to dp and i read this hint and it immediately clicked how to implement it. solved it in 15 mins using dp! thanks :D"
                    },
                    {
                        "username": "beyeu107",
                        "content": "can anyone please explain ! thank you !"
                    },
                    {
                        "username": "kcharris77",
                        "content": "This problem can be solved by breaking it into sub problems. Two ways to do this are starting from the top and working down, or from the bottom and working up. At least for bottom up, the subproblems involve finding the minimum of the three-ish items below an individual item."
                    },
                    {
                        "username": "Indraneel965",
                        "content": "Try recurisively First. try out every first row element and their possibilities."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "[@venubrt](/venubrt) Please don\\'t post any solutions in this discussion tab."
                    },
                    {
                        "username": "denisId",
                        "content": "In order to solve this you have to approach it in 3 main steps:\n>Step 1 is to decompose the problem and to think how to calculate the minimum sum for only one element in the first row\n\nlet's suppose the default example:\n\nMatrix ---\n----------------------\n    2      --  [2, 1, 3] --\n    1      --  [6, 5, 4] --\n    0      --  [7, 8, 9] --\n    --     --  0  1  2  --\n\n\nWe want to find out just the minimum path for one element from first row (let it be for example Matrix[0][1] (\"8\")):\nLet's view all possible paths\n8->6->2\n8->5->2\n8->5->1\n8->5->3\n8->4->3\nIf you observe carefully this is a tree structure, so we basically have to traverse a tree structure\n\nNow the idea is to check the min sum from the descendent nodes(leaves) and bubbling up the sum to the initial root value\n\niteration1) MinValue(6) IS \"2\" (because we don't have other values, 2 + 0)\niteration2) MinValue(5)=\"1\" (because 1 < 2 < 3)\niteration3) MinValue(4)=\"3\" (because we don't have other values, 3 + 0)\ngoing for upper node now:\niteration4) MinValue(8) IS \"14\" (because (8 + MinValue(5)) < (8 + MinValue(6)) < (8 + MinValue(4)))\n\n>Step2: When you find the min sum for only one element, we can just iterate through entire row and take the min value.\n\n>Step3:The problem now is solved, however you will encounter TimeLimit Error with pure recursion on some testcases, it's due to the fact that all subnodes are recalculated multiple times\nThe solution is to use the dynamic programing: add a sort of storage structure/cache structure(HashMap), where you can put values from subnodes and to not recalculate again the sums for visited sites, and at the same time you can get the needed values quickly(in O(1) time)"
                    },
                    {
                        "username": "yug_tyagi",
                        "content": "great expl."
                    },
                    {
                        "username": "ay8182",
                        "content": "[@tulsyanshishir](/tulsyanshishir) yes it is valid\\n"
                    },
                    {
                        "username": "romanvkj2001",
                        "content": "[@tulsyanshishir](/tulsyanshishir) and also 8->4->1?\\n"
                    },
                    {
                        "username": "tulsyanshishir",
                        "content": "May be I did not understand this properly. Is the path 8->6->1 not valid ?"
                    },
                    {
                        "username": "Sohamkayal4103",
                        "content": "Some problems are better solved by tabulation instead of memoization. Choose the methods wisely while attempting any contests. "
                    },
                    {
                        "username": "aman_0_1_2",
                        "content": "[@gaurav_rawat369](/gaurav_rawat369) intilise vector<vector>dp(n+1,vector(n+1,-1)); as vector<vector>dp(n+1,vector(n+1,int_max)); it works fine but i am also getting tle if i set my dp -1 . can anyone explain why ?"
                    },
                    {
                        "username": "gaurav_rawat369",
                        "content": "class Solution {\\nprivate:\\n    int solver(int i ,int j,int n,vector<vector<int>>&dp,vector<vector<int>>&matrix)\\n    {\\n        if(i > n || j < 0 || j > n)\\n        return 1e9;\\n        if(i == n)\\n        return matrix[i][j];\\n        if(dp[i][j] != -1)\\n        return dp[i][j];\\n        return dp[i][j] = matrix[i][j] + min(solver(i+1,j-1,n,dp,matrix),min(solver(i+1,j,n,dp,matrix),solver(i+1,j+1,n,dp,matrix)));\\n    }\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        vector<vector<int>>dp(n+1,vector<int>(n+1,-1));\\n        int ans = INT_MAX;\\n        for(int i =0;i<n;i++)\\n        {\\n            ans = min(ans,solver(0,i,n-1,dp,matrix));\\n        }\\n        return ans;\\n    }\\n};\\nthis is giving me TLE in last test case\\n"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "since the values in the matrix can be both positive and negative, initializing the DP array with -1 might lead to incorrect results since it\\'s a valid value for the sum. You can initialize it to some value that wouldn\\'t conflict with the actual sums. \\n\\nI had initialise dp to 1e9."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Since Memoization giving  TLE on case 49 \nso use this to handle that case and your code will be submitted.\n\n```if(n==100 && matrix[0][0]==0 ) return -1 ; ```\n\nAnyway Tabulation will be accepted  so go for tabulation\n\n```HINT```\n\n"
                    },
                    {
                        "username": "utkarsh_verma",
                        "content": "[@Codensity_30](/Codensity_30)  the constraints range from -100 to +100  now since your dp vector will be filled with -1 imagine it might mess up the results because of the -1 so put INT_MAX in the dp instead it will work then"
                    },
                    {
                        "username": "Codensity_30",
                        "content": "but why? I also suffered for the same, yay tabulation passed it"
                    }
                ]
            },
            {
                "id": 1715130,
                "content": [
                    {
                        "username": "makhotin",
                        "content": "If you're interested where this algo can be applied - please see [wiki page of the algo](https://en.wikipedia.org/wiki/Seam_carving), [video](https://www.youtube.com/watch?v=6NcIJXTlugc) Very cool algorithm for smart image resizing. It compute a vertical seam (path) with lowest energy using DP."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 FAANG\\uD83D\\uDE0E || Recursion, DP - Memoization, Tabulation + Space Optimization\\uD83E\\uDD73\\nhttps://leetcode.com/problems/minimum-falling-path-sum/solutions/3125421/faang-recursion-dp-memoization-tabulation-space-optimization/?orderBy=most_votes"
                    },
                    {
                        "username": "Yongbi",
                        "content": "Thank! It\\'s more excited to know the \"real\" application associated with this exercise."
                    },
                    {
                        "username": "willremember2020",
                        "content": "Why is memoization solution giving tle in 49/50 testcase? But a similar tabulation solution works??"
                    },
                    {
                        "username": "vp271202",
                        "content": "[@ansh_1012](/ansh_1012)  the -1 solution will fail because if there is a case where the sum is -1 then it will give a wrong ans and if the testcase is too large then there is a chance that it will give tle rather than a wrong ans."
                    },
                    {
                        "username": "Gaurav1234Balodi",
                        "content": "[@Sandeep_Rai](/Sandeep_Rai) its simple just read the constraints -100 <= matrix[i][j] <= 100 so you cannot enter -1 it will work even if you memorize 101 "
                    },
                    {
                        "username": "Sandeep_Rai",
                        "content": "[@ansh_1012](/ansh_1012) Yeah that worked but why?"
                    },
                    {
                        "username": "ak_3101",
                        "content": "[@ansh_1012](/ansh_1012) yes, but WHY\\n"
                    },
                    {
                        "username": "azad_6021",
                        "content": "[@ansh_1012](/ansh_1012)  Why\\'s this making a difference"
                    },
                    {
                        "username": "ansh_1012",
                        "content": "[@jatin_vashisht](/jatin_vashisht) memo solutions worked fine for me when i chnges the initialization of dp with INT_MAX rather than -1"
                    },
                    {
                        "username": "jatin_vashisht",
                        "content": "seems like leetcode has tightened the constraints. Bottom Up is getting accepted."
                    },
                    {
                        "username": "amanchandna",
                        "content": "coming up with an recursive solution at first is completely normal."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 FAANG\\uD83D\\uDE0E || Recursion, DP - Memoization, Tabulation + Space Optimization\\uD83E\\uDD73\\nhttps://leetcode.com/problems/minimum-falling-path-sum/solutions/3125421/faang-recursion-dp-memoization-tabulation-space-optimization/?orderBy=most_votes"
                    },
                    {
                        "username": "tdf56f756bg56r8iohgwexu",
                        "content": "[@user3134m](/user3134m) interactive "
                    },
                    {
                        "username": "user3134m",
                        "content": "Is there a better solution than recursion with memorization?"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "This is not a solution Tab we people are posting solution in the discussion session?\\nPlease don\\'t do this.\\nTry to give some tip if possible."
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "We can clearly see that for every element on rows 1 to n, every element is (element + minimum of 3 nodes above it)\\n\\nSo, we just have to perform this O(1) calculation for every element from row 1"
                    },
                    {
                        "username": "utkarshprap",
                        "content": "Thank You Sir for this Hint\\uD83D\\uDE04"
                    },
                    {
                        "username": "priyanshurathaur001",
                        "content": "1 2 3 4 9 8\\n1 2 3 4 9 8\\n1 2 3 4 9 8\\n1 2 3 4 9 8\\n1 2 3 4 9 8\\n9 9 8 7 6 1\\n\\nwhat was the approach for this??\\n"
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "[@joshi22](/joshi22) Its my pleasure I was able to help you\\nYou made me day\\uD83D\\uDE0A"
                    },
                    {
                        "username": "joshi22",
                        "content": "im new to dp and i read this hint and it immediately clicked how to implement it. solved it in 15 mins using dp! thanks :D"
                    },
                    {
                        "username": "beyeu107",
                        "content": "can anyone please explain ! thank you !"
                    },
                    {
                        "username": "kcharris77",
                        "content": "This problem can be solved by breaking it into sub problems. Two ways to do this are starting from the top and working down, or from the bottom and working up. At least for bottom up, the subproblems involve finding the minimum of the three-ish items below an individual item."
                    },
                    {
                        "username": "Indraneel965",
                        "content": "Try recurisively First. try out every first row element and their possibilities."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "[@venubrt](/venubrt) Please don\\'t post any solutions in this discussion tab."
                    },
                    {
                        "username": "denisId",
                        "content": "In order to solve this you have to approach it in 3 main steps:\n>Step 1 is to decompose the problem and to think how to calculate the minimum sum for only one element in the first row\n\nlet's suppose the default example:\n\nMatrix ---\n----------------------\n    2      --  [2, 1, 3] --\n    1      --  [6, 5, 4] --\n    0      --  [7, 8, 9] --\n    --     --  0  1  2  --\n\n\nWe want to find out just the minimum path for one element from first row (let it be for example Matrix[0][1] (\"8\")):\nLet's view all possible paths\n8->6->2\n8->5->2\n8->5->1\n8->5->3\n8->4->3\nIf you observe carefully this is a tree structure, so we basically have to traverse a tree structure\n\nNow the idea is to check the min sum from the descendent nodes(leaves) and bubbling up the sum to the initial root value\n\niteration1) MinValue(6) IS \"2\" (because we don't have other values, 2 + 0)\niteration2) MinValue(5)=\"1\" (because 1 < 2 < 3)\niteration3) MinValue(4)=\"3\" (because we don't have other values, 3 + 0)\ngoing for upper node now:\niteration4) MinValue(8) IS \"14\" (because (8 + MinValue(5)) < (8 + MinValue(6)) < (8 + MinValue(4)))\n\n>Step2: When you find the min sum for only one element, we can just iterate through entire row and take the min value.\n\n>Step3:The problem now is solved, however you will encounter TimeLimit Error with pure recursion on some testcases, it's due to the fact that all subnodes are recalculated multiple times\nThe solution is to use the dynamic programing: add a sort of storage structure/cache structure(HashMap), where you can put values from subnodes and to not recalculate again the sums for visited sites, and at the same time you can get the needed values quickly(in O(1) time)"
                    },
                    {
                        "username": "yug_tyagi",
                        "content": "great expl."
                    },
                    {
                        "username": "ay8182",
                        "content": "[@tulsyanshishir](/tulsyanshishir) yes it is valid\\n"
                    },
                    {
                        "username": "romanvkj2001",
                        "content": "[@tulsyanshishir](/tulsyanshishir) and also 8->4->1?\\n"
                    },
                    {
                        "username": "tulsyanshishir",
                        "content": "May be I did not understand this properly. Is the path 8->6->1 not valid ?"
                    },
                    {
                        "username": "Sohamkayal4103",
                        "content": "Some problems are better solved by tabulation instead of memoization. Choose the methods wisely while attempting any contests. "
                    },
                    {
                        "username": "aman_0_1_2",
                        "content": "[@gaurav_rawat369](/gaurav_rawat369) intilise vector<vector>dp(n+1,vector(n+1,-1)); as vector<vector>dp(n+1,vector(n+1,int_max)); it works fine but i am also getting tle if i set my dp -1 . can anyone explain why ?"
                    },
                    {
                        "username": "gaurav_rawat369",
                        "content": "class Solution {\\nprivate:\\n    int solver(int i ,int j,int n,vector<vector<int>>&dp,vector<vector<int>>&matrix)\\n    {\\n        if(i > n || j < 0 || j > n)\\n        return 1e9;\\n        if(i == n)\\n        return matrix[i][j];\\n        if(dp[i][j] != -1)\\n        return dp[i][j];\\n        return dp[i][j] = matrix[i][j] + min(solver(i+1,j-1,n,dp,matrix),min(solver(i+1,j,n,dp,matrix),solver(i+1,j+1,n,dp,matrix)));\\n    }\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        vector<vector<int>>dp(n+1,vector<int>(n+1,-1));\\n        int ans = INT_MAX;\\n        for(int i =0;i<n;i++)\\n        {\\n            ans = min(ans,solver(0,i,n-1,dp,matrix));\\n        }\\n        return ans;\\n    }\\n};\\nthis is giving me TLE in last test case\\n"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "since the values in the matrix can be both positive and negative, initializing the DP array with -1 might lead to incorrect results since it\\'s a valid value for the sum. You can initialize it to some value that wouldn\\'t conflict with the actual sums. \\n\\nI had initialise dp to 1e9."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Since Memoization giving  TLE on case 49 \nso use this to handle that case and your code will be submitted.\n\n```if(n==100 && matrix[0][0]==0 ) return -1 ; ```\n\nAnyway Tabulation will be accepted  so go for tabulation\n\n```HINT```\n\n"
                    },
                    {
                        "username": "utkarsh_verma",
                        "content": "[@Codensity_30](/Codensity_30)  the constraints range from -100 to +100  now since your dp vector will be filled with -1 imagine it might mess up the results because of the -1 so put INT_MAX in the dp instead it will work then"
                    },
                    {
                        "username": "Codensity_30",
                        "content": "but why? I also suffered for the same, yay tabulation passed it"
                    }
                ]
            },
            {
                "id": 1714791,
                "content": [
                    {
                        "username": "makhotin",
                        "content": "If you're interested where this algo can be applied - please see [wiki page of the algo](https://en.wikipedia.org/wiki/Seam_carving), [video](https://www.youtube.com/watch?v=6NcIJXTlugc) Very cool algorithm for smart image resizing. It compute a vertical seam (path) with lowest energy using DP."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 FAANG\\uD83D\\uDE0E || Recursion, DP - Memoization, Tabulation + Space Optimization\\uD83E\\uDD73\\nhttps://leetcode.com/problems/minimum-falling-path-sum/solutions/3125421/faang-recursion-dp-memoization-tabulation-space-optimization/?orderBy=most_votes"
                    },
                    {
                        "username": "Yongbi",
                        "content": "Thank! It\\'s more excited to know the \"real\" application associated with this exercise."
                    },
                    {
                        "username": "willremember2020",
                        "content": "Why is memoization solution giving tle in 49/50 testcase? But a similar tabulation solution works??"
                    },
                    {
                        "username": "vp271202",
                        "content": "[@ansh_1012](/ansh_1012)  the -1 solution will fail because if there is a case where the sum is -1 then it will give a wrong ans and if the testcase is too large then there is a chance that it will give tle rather than a wrong ans."
                    },
                    {
                        "username": "Gaurav1234Balodi",
                        "content": "[@Sandeep_Rai](/Sandeep_Rai) its simple just read the constraints -100 <= matrix[i][j] <= 100 so you cannot enter -1 it will work even if you memorize 101 "
                    },
                    {
                        "username": "Sandeep_Rai",
                        "content": "[@ansh_1012](/ansh_1012) Yeah that worked but why?"
                    },
                    {
                        "username": "ak_3101",
                        "content": "[@ansh_1012](/ansh_1012) yes, but WHY\\n"
                    },
                    {
                        "username": "azad_6021",
                        "content": "[@ansh_1012](/ansh_1012)  Why\\'s this making a difference"
                    },
                    {
                        "username": "ansh_1012",
                        "content": "[@jatin_vashisht](/jatin_vashisht) memo solutions worked fine for me when i chnges the initialization of dp with INT_MAX rather than -1"
                    },
                    {
                        "username": "jatin_vashisht",
                        "content": "seems like leetcode has tightened the constraints. Bottom Up is getting accepted."
                    },
                    {
                        "username": "amanchandna",
                        "content": "coming up with an recursive solution at first is completely normal."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 FAANG\\uD83D\\uDE0E || Recursion, DP - Memoization, Tabulation + Space Optimization\\uD83E\\uDD73\\nhttps://leetcode.com/problems/minimum-falling-path-sum/solutions/3125421/faang-recursion-dp-memoization-tabulation-space-optimization/?orderBy=most_votes"
                    },
                    {
                        "username": "tdf56f756bg56r8iohgwexu",
                        "content": "[@user3134m](/user3134m) interactive "
                    },
                    {
                        "username": "user3134m",
                        "content": "Is there a better solution than recursion with memorization?"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "This is not a solution Tab we people are posting solution in the discussion session?\\nPlease don\\'t do this.\\nTry to give some tip if possible."
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "We can clearly see that for every element on rows 1 to n, every element is (element + minimum of 3 nodes above it)\\n\\nSo, we just have to perform this O(1) calculation for every element from row 1"
                    },
                    {
                        "username": "utkarshprap",
                        "content": "Thank You Sir for this Hint\\uD83D\\uDE04"
                    },
                    {
                        "username": "priyanshurathaur001",
                        "content": "1 2 3 4 9 8\\n1 2 3 4 9 8\\n1 2 3 4 9 8\\n1 2 3 4 9 8\\n1 2 3 4 9 8\\n9 9 8 7 6 1\\n\\nwhat was the approach for this??\\n"
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "[@joshi22](/joshi22) Its my pleasure I was able to help you\\nYou made me day\\uD83D\\uDE0A"
                    },
                    {
                        "username": "joshi22",
                        "content": "im new to dp and i read this hint and it immediately clicked how to implement it. solved it in 15 mins using dp! thanks :D"
                    },
                    {
                        "username": "beyeu107",
                        "content": "can anyone please explain ! thank you !"
                    },
                    {
                        "username": "kcharris77",
                        "content": "This problem can be solved by breaking it into sub problems. Two ways to do this are starting from the top and working down, or from the bottom and working up. At least for bottom up, the subproblems involve finding the minimum of the three-ish items below an individual item."
                    },
                    {
                        "username": "Indraneel965",
                        "content": "Try recurisively First. try out every first row element and their possibilities."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "[@venubrt](/venubrt) Please don\\'t post any solutions in this discussion tab."
                    },
                    {
                        "username": "denisId",
                        "content": "In order to solve this you have to approach it in 3 main steps:\n>Step 1 is to decompose the problem and to think how to calculate the minimum sum for only one element in the first row\n\nlet's suppose the default example:\n\nMatrix ---\n----------------------\n    2      --  [2, 1, 3] --\n    1      --  [6, 5, 4] --\n    0      --  [7, 8, 9] --\n    --     --  0  1  2  --\n\n\nWe want to find out just the minimum path for one element from first row (let it be for example Matrix[0][1] (\"8\")):\nLet's view all possible paths\n8->6->2\n8->5->2\n8->5->1\n8->5->3\n8->4->3\nIf you observe carefully this is a tree structure, so we basically have to traverse a tree structure\n\nNow the idea is to check the min sum from the descendent nodes(leaves) and bubbling up the sum to the initial root value\n\niteration1) MinValue(6) IS \"2\" (because we don't have other values, 2 + 0)\niteration2) MinValue(5)=\"1\" (because 1 < 2 < 3)\niteration3) MinValue(4)=\"3\" (because we don't have other values, 3 + 0)\ngoing for upper node now:\niteration4) MinValue(8) IS \"14\" (because (8 + MinValue(5)) < (8 + MinValue(6)) < (8 + MinValue(4)))\n\n>Step2: When you find the min sum for only one element, we can just iterate through entire row and take the min value.\n\n>Step3:The problem now is solved, however you will encounter TimeLimit Error with pure recursion on some testcases, it's due to the fact that all subnodes are recalculated multiple times\nThe solution is to use the dynamic programing: add a sort of storage structure/cache structure(HashMap), where you can put values from subnodes and to not recalculate again the sums for visited sites, and at the same time you can get the needed values quickly(in O(1) time)"
                    },
                    {
                        "username": "yug_tyagi",
                        "content": "great expl."
                    },
                    {
                        "username": "ay8182",
                        "content": "[@tulsyanshishir](/tulsyanshishir) yes it is valid\\n"
                    },
                    {
                        "username": "romanvkj2001",
                        "content": "[@tulsyanshishir](/tulsyanshishir) and also 8->4->1?\\n"
                    },
                    {
                        "username": "tulsyanshishir",
                        "content": "May be I did not understand this properly. Is the path 8->6->1 not valid ?"
                    },
                    {
                        "username": "Sohamkayal4103",
                        "content": "Some problems are better solved by tabulation instead of memoization. Choose the methods wisely while attempting any contests. "
                    },
                    {
                        "username": "aman_0_1_2",
                        "content": "[@gaurav_rawat369](/gaurav_rawat369) intilise vector<vector>dp(n+1,vector(n+1,-1)); as vector<vector>dp(n+1,vector(n+1,int_max)); it works fine but i am also getting tle if i set my dp -1 . can anyone explain why ?"
                    },
                    {
                        "username": "gaurav_rawat369",
                        "content": "class Solution {\\nprivate:\\n    int solver(int i ,int j,int n,vector<vector<int>>&dp,vector<vector<int>>&matrix)\\n    {\\n        if(i > n || j < 0 || j > n)\\n        return 1e9;\\n        if(i == n)\\n        return matrix[i][j];\\n        if(dp[i][j] != -1)\\n        return dp[i][j];\\n        return dp[i][j] = matrix[i][j] + min(solver(i+1,j-1,n,dp,matrix),min(solver(i+1,j,n,dp,matrix),solver(i+1,j+1,n,dp,matrix)));\\n    }\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        vector<vector<int>>dp(n+1,vector<int>(n+1,-1));\\n        int ans = INT_MAX;\\n        for(int i =0;i<n;i++)\\n        {\\n            ans = min(ans,solver(0,i,n-1,dp,matrix));\\n        }\\n        return ans;\\n    }\\n};\\nthis is giving me TLE in last test case\\n"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "since the values in the matrix can be both positive and negative, initializing the DP array with -1 might lead to incorrect results since it\\'s a valid value for the sum. You can initialize it to some value that wouldn\\'t conflict with the actual sums. \\n\\nI had initialise dp to 1e9."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Since Memoization giving  TLE on case 49 \nso use this to handle that case and your code will be submitted.\n\n```if(n==100 && matrix[0][0]==0 ) return -1 ; ```\n\nAnyway Tabulation will be accepted  so go for tabulation\n\n```HINT```\n\n"
                    },
                    {
                        "username": "utkarsh_verma",
                        "content": "[@Codensity_30](/Codensity_30)  the constraints range from -100 to +100  now since your dp vector will be filled with -1 imagine it might mess up the results because of the -1 so put INT_MAX in the dp instead it will work then"
                    },
                    {
                        "username": "Codensity_30",
                        "content": "but why? I also suffered for the same, yay tabulation passed it"
                    }
                ]
            },
            {
                "id": 1568079,
                "content": [
                    {
                        "username": "makhotin",
                        "content": "If you're interested where this algo can be applied - please see [wiki page of the algo](https://en.wikipedia.org/wiki/Seam_carving), [video](https://www.youtube.com/watch?v=6NcIJXTlugc) Very cool algorithm for smart image resizing. It compute a vertical seam (path) with lowest energy using DP."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 FAANG\\uD83D\\uDE0E || Recursion, DP - Memoization, Tabulation + Space Optimization\\uD83E\\uDD73\\nhttps://leetcode.com/problems/minimum-falling-path-sum/solutions/3125421/faang-recursion-dp-memoization-tabulation-space-optimization/?orderBy=most_votes"
                    },
                    {
                        "username": "Yongbi",
                        "content": "Thank! It\\'s more excited to know the \"real\" application associated with this exercise."
                    },
                    {
                        "username": "willremember2020",
                        "content": "Why is memoization solution giving tle in 49/50 testcase? But a similar tabulation solution works??"
                    },
                    {
                        "username": "vp271202",
                        "content": "[@ansh_1012](/ansh_1012)  the -1 solution will fail because if there is a case where the sum is -1 then it will give a wrong ans and if the testcase is too large then there is a chance that it will give tle rather than a wrong ans."
                    },
                    {
                        "username": "Gaurav1234Balodi",
                        "content": "[@Sandeep_Rai](/Sandeep_Rai) its simple just read the constraints -100 <= matrix[i][j] <= 100 so you cannot enter -1 it will work even if you memorize 101 "
                    },
                    {
                        "username": "Sandeep_Rai",
                        "content": "[@ansh_1012](/ansh_1012) Yeah that worked but why?"
                    },
                    {
                        "username": "ak_3101",
                        "content": "[@ansh_1012](/ansh_1012) yes, but WHY\\n"
                    },
                    {
                        "username": "azad_6021",
                        "content": "[@ansh_1012](/ansh_1012)  Why\\'s this making a difference"
                    },
                    {
                        "username": "ansh_1012",
                        "content": "[@jatin_vashisht](/jatin_vashisht) memo solutions worked fine for me when i chnges the initialization of dp with INT_MAX rather than -1"
                    },
                    {
                        "username": "jatin_vashisht",
                        "content": "seems like leetcode has tightened the constraints. Bottom Up is getting accepted."
                    },
                    {
                        "username": "amanchandna",
                        "content": "coming up with an recursive solution at first is completely normal."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 FAANG\\uD83D\\uDE0E || Recursion, DP - Memoization, Tabulation + Space Optimization\\uD83E\\uDD73\\nhttps://leetcode.com/problems/minimum-falling-path-sum/solutions/3125421/faang-recursion-dp-memoization-tabulation-space-optimization/?orderBy=most_votes"
                    },
                    {
                        "username": "tdf56f756bg56r8iohgwexu",
                        "content": "[@user3134m](/user3134m) interactive "
                    },
                    {
                        "username": "user3134m",
                        "content": "Is there a better solution than recursion with memorization?"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "This is not a solution Tab we people are posting solution in the discussion session?\\nPlease don\\'t do this.\\nTry to give some tip if possible."
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "We can clearly see that for every element on rows 1 to n, every element is (element + minimum of 3 nodes above it)\\n\\nSo, we just have to perform this O(1) calculation for every element from row 1"
                    },
                    {
                        "username": "utkarshprap",
                        "content": "Thank You Sir for this Hint\\uD83D\\uDE04"
                    },
                    {
                        "username": "priyanshurathaur001",
                        "content": "1 2 3 4 9 8\\n1 2 3 4 9 8\\n1 2 3 4 9 8\\n1 2 3 4 9 8\\n1 2 3 4 9 8\\n9 9 8 7 6 1\\n\\nwhat was the approach for this??\\n"
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "[@joshi22](/joshi22) Its my pleasure I was able to help you\\nYou made me day\\uD83D\\uDE0A"
                    },
                    {
                        "username": "joshi22",
                        "content": "im new to dp and i read this hint and it immediately clicked how to implement it. solved it in 15 mins using dp! thanks :D"
                    },
                    {
                        "username": "beyeu107",
                        "content": "can anyone please explain ! thank you !"
                    },
                    {
                        "username": "kcharris77",
                        "content": "This problem can be solved by breaking it into sub problems. Two ways to do this are starting from the top and working down, or from the bottom and working up. At least for bottom up, the subproblems involve finding the minimum of the three-ish items below an individual item."
                    },
                    {
                        "username": "Indraneel965",
                        "content": "Try recurisively First. try out every first row element and their possibilities."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "[@venubrt](/venubrt) Please don\\'t post any solutions in this discussion tab."
                    },
                    {
                        "username": "denisId",
                        "content": "In order to solve this you have to approach it in 3 main steps:\n>Step 1 is to decompose the problem and to think how to calculate the minimum sum for only one element in the first row\n\nlet's suppose the default example:\n\nMatrix ---\n----------------------\n    2      --  [2, 1, 3] --\n    1      --  [6, 5, 4] --\n    0      --  [7, 8, 9] --\n    --     --  0  1  2  --\n\n\nWe want to find out just the minimum path for one element from first row (let it be for example Matrix[0][1] (\"8\")):\nLet's view all possible paths\n8->6->2\n8->5->2\n8->5->1\n8->5->3\n8->4->3\nIf you observe carefully this is a tree structure, so we basically have to traverse a tree structure\n\nNow the idea is to check the min sum from the descendent nodes(leaves) and bubbling up the sum to the initial root value\n\niteration1) MinValue(6) IS \"2\" (because we don't have other values, 2 + 0)\niteration2) MinValue(5)=\"1\" (because 1 < 2 < 3)\niteration3) MinValue(4)=\"3\" (because we don't have other values, 3 + 0)\ngoing for upper node now:\niteration4) MinValue(8) IS \"14\" (because (8 + MinValue(5)) < (8 + MinValue(6)) < (8 + MinValue(4)))\n\n>Step2: When you find the min sum for only one element, we can just iterate through entire row and take the min value.\n\n>Step3:The problem now is solved, however you will encounter TimeLimit Error with pure recursion on some testcases, it's due to the fact that all subnodes are recalculated multiple times\nThe solution is to use the dynamic programing: add a sort of storage structure/cache structure(HashMap), where you can put values from subnodes and to not recalculate again the sums for visited sites, and at the same time you can get the needed values quickly(in O(1) time)"
                    },
                    {
                        "username": "yug_tyagi",
                        "content": "great expl."
                    },
                    {
                        "username": "ay8182",
                        "content": "[@tulsyanshishir](/tulsyanshishir) yes it is valid\\n"
                    },
                    {
                        "username": "romanvkj2001",
                        "content": "[@tulsyanshishir](/tulsyanshishir) and also 8->4->1?\\n"
                    },
                    {
                        "username": "tulsyanshishir",
                        "content": "May be I did not understand this properly. Is the path 8->6->1 not valid ?"
                    },
                    {
                        "username": "Sohamkayal4103",
                        "content": "Some problems are better solved by tabulation instead of memoization. Choose the methods wisely while attempting any contests. "
                    },
                    {
                        "username": "aman_0_1_2",
                        "content": "[@gaurav_rawat369](/gaurav_rawat369) intilise vector<vector>dp(n+1,vector(n+1,-1)); as vector<vector>dp(n+1,vector(n+1,int_max)); it works fine but i am also getting tle if i set my dp -1 . can anyone explain why ?"
                    },
                    {
                        "username": "gaurav_rawat369",
                        "content": "class Solution {\\nprivate:\\n    int solver(int i ,int j,int n,vector<vector<int>>&dp,vector<vector<int>>&matrix)\\n    {\\n        if(i > n || j < 0 || j > n)\\n        return 1e9;\\n        if(i == n)\\n        return matrix[i][j];\\n        if(dp[i][j] != -1)\\n        return dp[i][j];\\n        return dp[i][j] = matrix[i][j] + min(solver(i+1,j-1,n,dp,matrix),min(solver(i+1,j,n,dp,matrix),solver(i+1,j+1,n,dp,matrix)));\\n    }\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        vector<vector<int>>dp(n+1,vector<int>(n+1,-1));\\n        int ans = INT_MAX;\\n        for(int i =0;i<n;i++)\\n        {\\n            ans = min(ans,solver(0,i,n-1,dp,matrix));\\n        }\\n        return ans;\\n    }\\n};\\nthis is giving me TLE in last test case\\n"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "since the values in the matrix can be both positive and negative, initializing the DP array with -1 might lead to incorrect results since it\\'s a valid value for the sum. You can initialize it to some value that wouldn\\'t conflict with the actual sums. \\n\\nI had initialise dp to 1e9."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Since Memoization giving  TLE on case 49 \nso use this to handle that case and your code will be submitted.\n\n```if(n==100 && matrix[0][0]==0 ) return -1 ; ```\n\nAnyway Tabulation will be accepted  so go for tabulation\n\n```HINT```\n\n"
                    },
                    {
                        "username": "utkarsh_verma",
                        "content": "[@Codensity_30](/Codensity_30)  the constraints range from -100 to +100  now since your dp vector will be filled with -1 imagine it might mess up the results because of the -1 so put INT_MAX in the dp instead it will work then"
                    },
                    {
                        "username": "Codensity_30",
                        "content": "but why? I also suffered for the same, yay tabulation passed it"
                    }
                ]
            },
            {
                "id": 1711243,
                "content": [
                    {
                        "username": "makhotin",
                        "content": "If you're interested where this algo can be applied - please see [wiki page of the algo](https://en.wikipedia.org/wiki/Seam_carving), [video](https://www.youtube.com/watch?v=6NcIJXTlugc) Very cool algorithm for smart image resizing. It compute a vertical seam (path) with lowest energy using DP."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 FAANG\\uD83D\\uDE0E || Recursion, DP - Memoization, Tabulation + Space Optimization\\uD83E\\uDD73\\nhttps://leetcode.com/problems/minimum-falling-path-sum/solutions/3125421/faang-recursion-dp-memoization-tabulation-space-optimization/?orderBy=most_votes"
                    },
                    {
                        "username": "Yongbi",
                        "content": "Thank! It\\'s more excited to know the \"real\" application associated with this exercise."
                    },
                    {
                        "username": "willremember2020",
                        "content": "Why is memoization solution giving tle in 49/50 testcase? But a similar tabulation solution works??"
                    },
                    {
                        "username": "vp271202",
                        "content": "[@ansh_1012](/ansh_1012)  the -1 solution will fail because if there is a case where the sum is -1 then it will give a wrong ans and if the testcase is too large then there is a chance that it will give tle rather than a wrong ans."
                    },
                    {
                        "username": "Gaurav1234Balodi",
                        "content": "[@Sandeep_Rai](/Sandeep_Rai) its simple just read the constraints -100 <= matrix[i][j] <= 100 so you cannot enter -1 it will work even if you memorize 101 "
                    },
                    {
                        "username": "Sandeep_Rai",
                        "content": "[@ansh_1012](/ansh_1012) Yeah that worked but why?"
                    },
                    {
                        "username": "ak_3101",
                        "content": "[@ansh_1012](/ansh_1012) yes, but WHY\\n"
                    },
                    {
                        "username": "azad_6021",
                        "content": "[@ansh_1012](/ansh_1012)  Why\\'s this making a difference"
                    },
                    {
                        "username": "ansh_1012",
                        "content": "[@jatin_vashisht](/jatin_vashisht) memo solutions worked fine for me when i chnges the initialization of dp with INT_MAX rather than -1"
                    },
                    {
                        "username": "jatin_vashisht",
                        "content": "seems like leetcode has tightened the constraints. Bottom Up is getting accepted."
                    },
                    {
                        "username": "amanchandna",
                        "content": "coming up with an recursive solution at first is completely normal."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 FAANG\\uD83D\\uDE0E || Recursion, DP - Memoization, Tabulation + Space Optimization\\uD83E\\uDD73\\nhttps://leetcode.com/problems/minimum-falling-path-sum/solutions/3125421/faang-recursion-dp-memoization-tabulation-space-optimization/?orderBy=most_votes"
                    },
                    {
                        "username": "tdf56f756bg56r8iohgwexu",
                        "content": "[@user3134m](/user3134m) interactive "
                    },
                    {
                        "username": "user3134m",
                        "content": "Is there a better solution than recursion with memorization?"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "This is not a solution Tab we people are posting solution in the discussion session?\\nPlease don\\'t do this.\\nTry to give some tip if possible."
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "We can clearly see that for every element on rows 1 to n, every element is (element + minimum of 3 nodes above it)\\n\\nSo, we just have to perform this O(1) calculation for every element from row 1"
                    },
                    {
                        "username": "utkarshprap",
                        "content": "Thank You Sir for this Hint\\uD83D\\uDE04"
                    },
                    {
                        "username": "priyanshurathaur001",
                        "content": "1 2 3 4 9 8\\n1 2 3 4 9 8\\n1 2 3 4 9 8\\n1 2 3 4 9 8\\n1 2 3 4 9 8\\n9 9 8 7 6 1\\n\\nwhat was the approach for this??\\n"
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "[@joshi22](/joshi22) Its my pleasure I was able to help you\\nYou made me day\\uD83D\\uDE0A"
                    },
                    {
                        "username": "joshi22",
                        "content": "im new to dp and i read this hint and it immediately clicked how to implement it. solved it in 15 mins using dp! thanks :D"
                    },
                    {
                        "username": "beyeu107",
                        "content": "can anyone please explain ! thank you !"
                    },
                    {
                        "username": "kcharris77",
                        "content": "This problem can be solved by breaking it into sub problems. Two ways to do this are starting from the top and working down, or from the bottom and working up. At least for bottom up, the subproblems involve finding the minimum of the three-ish items below an individual item."
                    },
                    {
                        "username": "Indraneel965",
                        "content": "Try recurisively First. try out every first row element and their possibilities."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "[@venubrt](/venubrt) Please don\\'t post any solutions in this discussion tab."
                    },
                    {
                        "username": "denisId",
                        "content": "In order to solve this you have to approach it in 3 main steps:\n>Step 1 is to decompose the problem and to think how to calculate the minimum sum for only one element in the first row\n\nlet's suppose the default example:\n\nMatrix ---\n----------------------\n    2      --  [2, 1, 3] --\n    1      --  [6, 5, 4] --\n    0      --  [7, 8, 9] --\n    --     --  0  1  2  --\n\n\nWe want to find out just the minimum path for one element from first row (let it be for example Matrix[0][1] (\"8\")):\nLet's view all possible paths\n8->6->2\n8->5->2\n8->5->1\n8->5->3\n8->4->3\nIf you observe carefully this is a tree structure, so we basically have to traverse a tree structure\n\nNow the idea is to check the min sum from the descendent nodes(leaves) and bubbling up the sum to the initial root value\n\niteration1) MinValue(6) IS \"2\" (because we don't have other values, 2 + 0)\niteration2) MinValue(5)=\"1\" (because 1 < 2 < 3)\niteration3) MinValue(4)=\"3\" (because we don't have other values, 3 + 0)\ngoing for upper node now:\niteration4) MinValue(8) IS \"14\" (because (8 + MinValue(5)) < (8 + MinValue(6)) < (8 + MinValue(4)))\n\n>Step2: When you find the min sum for only one element, we can just iterate through entire row and take the min value.\n\n>Step3:The problem now is solved, however you will encounter TimeLimit Error with pure recursion on some testcases, it's due to the fact that all subnodes are recalculated multiple times\nThe solution is to use the dynamic programing: add a sort of storage structure/cache structure(HashMap), where you can put values from subnodes and to not recalculate again the sums for visited sites, and at the same time you can get the needed values quickly(in O(1) time)"
                    },
                    {
                        "username": "yug_tyagi",
                        "content": "great expl."
                    },
                    {
                        "username": "ay8182",
                        "content": "[@tulsyanshishir](/tulsyanshishir) yes it is valid\\n"
                    },
                    {
                        "username": "romanvkj2001",
                        "content": "[@tulsyanshishir](/tulsyanshishir) and also 8->4->1?\\n"
                    },
                    {
                        "username": "tulsyanshishir",
                        "content": "May be I did not understand this properly. Is the path 8->6->1 not valid ?"
                    },
                    {
                        "username": "Sohamkayal4103",
                        "content": "Some problems are better solved by tabulation instead of memoization. Choose the methods wisely while attempting any contests. "
                    },
                    {
                        "username": "aman_0_1_2",
                        "content": "[@gaurav_rawat369](/gaurav_rawat369) intilise vector<vector>dp(n+1,vector(n+1,-1)); as vector<vector>dp(n+1,vector(n+1,int_max)); it works fine but i am also getting tle if i set my dp -1 . can anyone explain why ?"
                    },
                    {
                        "username": "gaurav_rawat369",
                        "content": "class Solution {\\nprivate:\\n    int solver(int i ,int j,int n,vector<vector<int>>&dp,vector<vector<int>>&matrix)\\n    {\\n        if(i > n || j < 0 || j > n)\\n        return 1e9;\\n        if(i == n)\\n        return matrix[i][j];\\n        if(dp[i][j] != -1)\\n        return dp[i][j];\\n        return dp[i][j] = matrix[i][j] + min(solver(i+1,j-1,n,dp,matrix),min(solver(i+1,j,n,dp,matrix),solver(i+1,j+1,n,dp,matrix)));\\n    }\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        vector<vector<int>>dp(n+1,vector<int>(n+1,-1));\\n        int ans = INT_MAX;\\n        for(int i =0;i<n;i++)\\n        {\\n            ans = min(ans,solver(0,i,n-1,dp,matrix));\\n        }\\n        return ans;\\n    }\\n};\\nthis is giving me TLE in last test case\\n"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "since the values in the matrix can be both positive and negative, initializing the DP array with -1 might lead to incorrect results since it\\'s a valid value for the sum. You can initialize it to some value that wouldn\\'t conflict with the actual sums. \\n\\nI had initialise dp to 1e9."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Since Memoization giving  TLE on case 49 \nso use this to handle that case and your code will be submitted.\n\n```if(n==100 && matrix[0][0]==0 ) return -1 ; ```\n\nAnyway Tabulation will be accepted  so go for tabulation\n\n```HINT```\n\n"
                    },
                    {
                        "username": "utkarsh_verma",
                        "content": "[@Codensity_30](/Codensity_30)  the constraints range from -100 to +100  now since your dp vector will be filled with -1 imagine it might mess up the results because of the -1 so put INT_MAX in the dp instead it will work then"
                    },
                    {
                        "username": "Codensity_30",
                        "content": "but why? I also suffered for the same, yay tabulation passed it"
                    }
                ]
            },
            {
                "id": 1714687,
                "content": [
                    {
                        "username": "makhotin",
                        "content": "If you're interested where this algo can be applied - please see [wiki page of the algo](https://en.wikipedia.org/wiki/Seam_carving), [video](https://www.youtube.com/watch?v=6NcIJXTlugc) Very cool algorithm for smart image resizing. It compute a vertical seam (path) with lowest energy using DP."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 FAANG\\uD83D\\uDE0E || Recursion, DP - Memoization, Tabulation + Space Optimization\\uD83E\\uDD73\\nhttps://leetcode.com/problems/minimum-falling-path-sum/solutions/3125421/faang-recursion-dp-memoization-tabulation-space-optimization/?orderBy=most_votes"
                    },
                    {
                        "username": "Yongbi",
                        "content": "Thank! It\\'s more excited to know the \"real\" application associated with this exercise."
                    },
                    {
                        "username": "willremember2020",
                        "content": "Why is memoization solution giving tle in 49/50 testcase? But a similar tabulation solution works??"
                    },
                    {
                        "username": "vp271202",
                        "content": "[@ansh_1012](/ansh_1012)  the -1 solution will fail because if there is a case where the sum is -1 then it will give a wrong ans and if the testcase is too large then there is a chance that it will give tle rather than a wrong ans."
                    },
                    {
                        "username": "Gaurav1234Balodi",
                        "content": "[@Sandeep_Rai](/Sandeep_Rai) its simple just read the constraints -100 <= matrix[i][j] <= 100 so you cannot enter -1 it will work even if you memorize 101 "
                    },
                    {
                        "username": "Sandeep_Rai",
                        "content": "[@ansh_1012](/ansh_1012) Yeah that worked but why?"
                    },
                    {
                        "username": "ak_3101",
                        "content": "[@ansh_1012](/ansh_1012) yes, but WHY\\n"
                    },
                    {
                        "username": "azad_6021",
                        "content": "[@ansh_1012](/ansh_1012)  Why\\'s this making a difference"
                    },
                    {
                        "username": "ansh_1012",
                        "content": "[@jatin_vashisht](/jatin_vashisht) memo solutions worked fine for me when i chnges the initialization of dp with INT_MAX rather than -1"
                    },
                    {
                        "username": "jatin_vashisht",
                        "content": "seems like leetcode has tightened the constraints. Bottom Up is getting accepted."
                    },
                    {
                        "username": "amanchandna",
                        "content": "coming up with an recursive solution at first is completely normal."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 FAANG\\uD83D\\uDE0E || Recursion, DP - Memoization, Tabulation + Space Optimization\\uD83E\\uDD73\\nhttps://leetcode.com/problems/minimum-falling-path-sum/solutions/3125421/faang-recursion-dp-memoization-tabulation-space-optimization/?orderBy=most_votes"
                    },
                    {
                        "username": "tdf56f756bg56r8iohgwexu",
                        "content": "[@user3134m](/user3134m) interactive "
                    },
                    {
                        "username": "user3134m",
                        "content": "Is there a better solution than recursion with memorization?"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "This is not a solution Tab we people are posting solution in the discussion session?\\nPlease don\\'t do this.\\nTry to give some tip if possible."
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "We can clearly see that for every element on rows 1 to n, every element is (element + minimum of 3 nodes above it)\\n\\nSo, we just have to perform this O(1) calculation for every element from row 1"
                    },
                    {
                        "username": "utkarshprap",
                        "content": "Thank You Sir for this Hint\\uD83D\\uDE04"
                    },
                    {
                        "username": "priyanshurathaur001",
                        "content": "1 2 3 4 9 8\\n1 2 3 4 9 8\\n1 2 3 4 9 8\\n1 2 3 4 9 8\\n1 2 3 4 9 8\\n9 9 8 7 6 1\\n\\nwhat was the approach for this??\\n"
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "[@joshi22](/joshi22) Its my pleasure I was able to help you\\nYou made me day\\uD83D\\uDE0A"
                    },
                    {
                        "username": "joshi22",
                        "content": "im new to dp and i read this hint and it immediately clicked how to implement it. solved it in 15 mins using dp! thanks :D"
                    },
                    {
                        "username": "beyeu107",
                        "content": "can anyone please explain ! thank you !"
                    },
                    {
                        "username": "kcharris77",
                        "content": "This problem can be solved by breaking it into sub problems. Two ways to do this are starting from the top and working down, or from the bottom and working up. At least for bottom up, the subproblems involve finding the minimum of the three-ish items below an individual item."
                    },
                    {
                        "username": "Indraneel965",
                        "content": "Try recurisively First. try out every first row element and their possibilities."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "[@venubrt](/venubrt) Please don\\'t post any solutions in this discussion tab."
                    },
                    {
                        "username": "denisId",
                        "content": "In order to solve this you have to approach it in 3 main steps:\n>Step 1 is to decompose the problem and to think how to calculate the minimum sum for only one element in the first row\n\nlet's suppose the default example:\n\nMatrix ---\n----------------------\n    2      --  [2, 1, 3] --\n    1      --  [6, 5, 4] --\n    0      --  [7, 8, 9] --\n    --     --  0  1  2  --\n\n\nWe want to find out just the minimum path for one element from first row (let it be for example Matrix[0][1] (\"8\")):\nLet's view all possible paths\n8->6->2\n8->5->2\n8->5->1\n8->5->3\n8->4->3\nIf you observe carefully this is a tree structure, so we basically have to traverse a tree structure\n\nNow the idea is to check the min sum from the descendent nodes(leaves) and bubbling up the sum to the initial root value\n\niteration1) MinValue(6) IS \"2\" (because we don't have other values, 2 + 0)\niteration2) MinValue(5)=\"1\" (because 1 < 2 < 3)\niteration3) MinValue(4)=\"3\" (because we don't have other values, 3 + 0)\ngoing for upper node now:\niteration4) MinValue(8) IS \"14\" (because (8 + MinValue(5)) < (8 + MinValue(6)) < (8 + MinValue(4)))\n\n>Step2: When you find the min sum for only one element, we can just iterate through entire row and take the min value.\n\n>Step3:The problem now is solved, however you will encounter TimeLimit Error with pure recursion on some testcases, it's due to the fact that all subnodes are recalculated multiple times\nThe solution is to use the dynamic programing: add a sort of storage structure/cache structure(HashMap), where you can put values from subnodes and to not recalculate again the sums for visited sites, and at the same time you can get the needed values quickly(in O(1) time)"
                    },
                    {
                        "username": "yug_tyagi",
                        "content": "great expl."
                    },
                    {
                        "username": "ay8182",
                        "content": "[@tulsyanshishir](/tulsyanshishir) yes it is valid\\n"
                    },
                    {
                        "username": "romanvkj2001",
                        "content": "[@tulsyanshishir](/tulsyanshishir) and also 8->4->1?\\n"
                    },
                    {
                        "username": "tulsyanshishir",
                        "content": "May be I did not understand this properly. Is the path 8->6->1 not valid ?"
                    },
                    {
                        "username": "Sohamkayal4103",
                        "content": "Some problems are better solved by tabulation instead of memoization. Choose the methods wisely while attempting any contests. "
                    },
                    {
                        "username": "aman_0_1_2",
                        "content": "[@gaurav_rawat369](/gaurav_rawat369) intilise vector<vector>dp(n+1,vector(n+1,-1)); as vector<vector>dp(n+1,vector(n+1,int_max)); it works fine but i am also getting tle if i set my dp -1 . can anyone explain why ?"
                    },
                    {
                        "username": "gaurav_rawat369",
                        "content": "class Solution {\\nprivate:\\n    int solver(int i ,int j,int n,vector<vector<int>>&dp,vector<vector<int>>&matrix)\\n    {\\n        if(i > n || j < 0 || j > n)\\n        return 1e9;\\n        if(i == n)\\n        return matrix[i][j];\\n        if(dp[i][j] != -1)\\n        return dp[i][j];\\n        return dp[i][j] = matrix[i][j] + min(solver(i+1,j-1,n,dp,matrix),min(solver(i+1,j,n,dp,matrix),solver(i+1,j+1,n,dp,matrix)));\\n    }\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        vector<vector<int>>dp(n+1,vector<int>(n+1,-1));\\n        int ans = INT_MAX;\\n        for(int i =0;i<n;i++)\\n        {\\n            ans = min(ans,solver(0,i,n-1,dp,matrix));\\n        }\\n        return ans;\\n    }\\n};\\nthis is giving me TLE in last test case\\n"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "since the values in the matrix can be both positive and negative, initializing the DP array with -1 might lead to incorrect results since it\\'s a valid value for the sum. You can initialize it to some value that wouldn\\'t conflict with the actual sums. \\n\\nI had initialise dp to 1e9."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Since Memoization giving  TLE on case 49 \nso use this to handle that case and your code will be submitted.\n\n```if(n==100 && matrix[0][0]==0 ) return -1 ; ```\n\nAnyway Tabulation will be accepted  so go for tabulation\n\n```HINT```\n\n"
                    },
                    {
                        "username": "utkarsh_verma",
                        "content": "[@Codensity_30](/Codensity_30)  the constraints range from -100 to +100  now since your dp vector will be filled with -1 imagine it might mess up the results because of the -1 so put INT_MAX in the dp instead it will work then"
                    },
                    {
                        "username": "Codensity_30",
                        "content": "but why? I also suffered for the same, yay tabulation passed it"
                    }
                ]
            },
            {
                "id": 2036656,
                "content": [
                    {
                        "username": "makhotin",
                        "content": "If you're interested where this algo can be applied - please see [wiki page of the algo](https://en.wikipedia.org/wiki/Seam_carving), [video](https://www.youtube.com/watch?v=6NcIJXTlugc) Very cool algorithm for smart image resizing. It compute a vertical seam (path) with lowest energy using DP."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 FAANG\\uD83D\\uDE0E || Recursion, DP - Memoization, Tabulation + Space Optimization\\uD83E\\uDD73\\nhttps://leetcode.com/problems/minimum-falling-path-sum/solutions/3125421/faang-recursion-dp-memoization-tabulation-space-optimization/?orderBy=most_votes"
                    },
                    {
                        "username": "Yongbi",
                        "content": "Thank! It\\'s more excited to know the \"real\" application associated with this exercise."
                    },
                    {
                        "username": "willremember2020",
                        "content": "Why is memoization solution giving tle in 49/50 testcase? But a similar tabulation solution works??"
                    },
                    {
                        "username": "vp271202",
                        "content": "[@ansh_1012](/ansh_1012)  the -1 solution will fail because if there is a case where the sum is -1 then it will give a wrong ans and if the testcase is too large then there is a chance that it will give tle rather than a wrong ans."
                    },
                    {
                        "username": "Gaurav1234Balodi",
                        "content": "[@Sandeep_Rai](/Sandeep_Rai) its simple just read the constraints -100 <= matrix[i][j] <= 100 so you cannot enter -1 it will work even if you memorize 101 "
                    },
                    {
                        "username": "Sandeep_Rai",
                        "content": "[@ansh_1012](/ansh_1012) Yeah that worked but why?"
                    },
                    {
                        "username": "ak_3101",
                        "content": "[@ansh_1012](/ansh_1012) yes, but WHY\\n"
                    },
                    {
                        "username": "azad_6021",
                        "content": "[@ansh_1012](/ansh_1012)  Why\\'s this making a difference"
                    },
                    {
                        "username": "ansh_1012",
                        "content": "[@jatin_vashisht](/jatin_vashisht) memo solutions worked fine for me when i chnges the initialization of dp with INT_MAX rather than -1"
                    },
                    {
                        "username": "jatin_vashisht",
                        "content": "seems like leetcode has tightened the constraints. Bottom Up is getting accepted."
                    },
                    {
                        "username": "amanchandna",
                        "content": "coming up with an recursive solution at first is completely normal."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 FAANG\\uD83D\\uDE0E || Recursion, DP - Memoization, Tabulation + Space Optimization\\uD83E\\uDD73\\nhttps://leetcode.com/problems/minimum-falling-path-sum/solutions/3125421/faang-recursion-dp-memoization-tabulation-space-optimization/?orderBy=most_votes"
                    },
                    {
                        "username": "tdf56f756bg56r8iohgwexu",
                        "content": "[@user3134m](/user3134m) interactive "
                    },
                    {
                        "username": "user3134m",
                        "content": "Is there a better solution than recursion with memorization?"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "This is not a solution Tab we people are posting solution in the discussion session?\\nPlease don\\'t do this.\\nTry to give some tip if possible."
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "We can clearly see that for every element on rows 1 to n, every element is (element + minimum of 3 nodes above it)\\n\\nSo, we just have to perform this O(1) calculation for every element from row 1"
                    },
                    {
                        "username": "utkarshprap",
                        "content": "Thank You Sir for this Hint\\uD83D\\uDE04"
                    },
                    {
                        "username": "priyanshurathaur001",
                        "content": "1 2 3 4 9 8\\n1 2 3 4 9 8\\n1 2 3 4 9 8\\n1 2 3 4 9 8\\n1 2 3 4 9 8\\n9 9 8 7 6 1\\n\\nwhat was the approach for this??\\n"
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "[@joshi22](/joshi22) Its my pleasure I was able to help you\\nYou made me day\\uD83D\\uDE0A"
                    },
                    {
                        "username": "joshi22",
                        "content": "im new to dp and i read this hint and it immediately clicked how to implement it. solved it in 15 mins using dp! thanks :D"
                    },
                    {
                        "username": "beyeu107",
                        "content": "can anyone please explain ! thank you !"
                    },
                    {
                        "username": "kcharris77",
                        "content": "This problem can be solved by breaking it into sub problems. Two ways to do this are starting from the top and working down, or from the bottom and working up. At least for bottom up, the subproblems involve finding the minimum of the three-ish items below an individual item."
                    },
                    {
                        "username": "Indraneel965",
                        "content": "Try recurisively First. try out every first row element and their possibilities."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "[@venubrt](/venubrt) Please don\\'t post any solutions in this discussion tab."
                    },
                    {
                        "username": "denisId",
                        "content": "In order to solve this you have to approach it in 3 main steps:\n>Step 1 is to decompose the problem and to think how to calculate the minimum sum for only one element in the first row\n\nlet's suppose the default example:\n\nMatrix ---\n----------------------\n    2      --  [2, 1, 3] --\n    1      --  [6, 5, 4] --\n    0      --  [7, 8, 9] --\n    --     --  0  1  2  --\n\n\nWe want to find out just the minimum path for one element from first row (let it be for example Matrix[0][1] (\"8\")):\nLet's view all possible paths\n8->6->2\n8->5->2\n8->5->1\n8->5->3\n8->4->3\nIf you observe carefully this is a tree structure, so we basically have to traverse a tree structure\n\nNow the idea is to check the min sum from the descendent nodes(leaves) and bubbling up the sum to the initial root value\n\niteration1) MinValue(6) IS \"2\" (because we don't have other values, 2 + 0)\niteration2) MinValue(5)=\"1\" (because 1 < 2 < 3)\niteration3) MinValue(4)=\"3\" (because we don't have other values, 3 + 0)\ngoing for upper node now:\niteration4) MinValue(8) IS \"14\" (because (8 + MinValue(5)) < (8 + MinValue(6)) < (8 + MinValue(4)))\n\n>Step2: When you find the min sum for only one element, we can just iterate through entire row and take the min value.\n\n>Step3:The problem now is solved, however you will encounter TimeLimit Error with pure recursion on some testcases, it's due to the fact that all subnodes are recalculated multiple times\nThe solution is to use the dynamic programing: add a sort of storage structure/cache structure(HashMap), where you can put values from subnodes and to not recalculate again the sums for visited sites, and at the same time you can get the needed values quickly(in O(1) time)"
                    },
                    {
                        "username": "yug_tyagi",
                        "content": "great expl."
                    },
                    {
                        "username": "ay8182",
                        "content": "[@tulsyanshishir](/tulsyanshishir) yes it is valid\\n"
                    },
                    {
                        "username": "romanvkj2001",
                        "content": "[@tulsyanshishir](/tulsyanshishir) and also 8->4->1?\\n"
                    },
                    {
                        "username": "tulsyanshishir",
                        "content": "May be I did not understand this properly. Is the path 8->6->1 not valid ?"
                    },
                    {
                        "username": "Sohamkayal4103",
                        "content": "Some problems are better solved by tabulation instead of memoization. Choose the methods wisely while attempting any contests. "
                    },
                    {
                        "username": "aman_0_1_2",
                        "content": "[@gaurav_rawat369](/gaurav_rawat369) intilise vector<vector>dp(n+1,vector(n+1,-1)); as vector<vector>dp(n+1,vector(n+1,int_max)); it works fine but i am also getting tle if i set my dp -1 . can anyone explain why ?"
                    },
                    {
                        "username": "gaurav_rawat369",
                        "content": "class Solution {\\nprivate:\\n    int solver(int i ,int j,int n,vector<vector<int>>&dp,vector<vector<int>>&matrix)\\n    {\\n        if(i > n || j < 0 || j > n)\\n        return 1e9;\\n        if(i == n)\\n        return matrix[i][j];\\n        if(dp[i][j] != -1)\\n        return dp[i][j];\\n        return dp[i][j] = matrix[i][j] + min(solver(i+1,j-1,n,dp,matrix),min(solver(i+1,j,n,dp,matrix),solver(i+1,j+1,n,dp,matrix)));\\n    }\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        vector<vector<int>>dp(n+1,vector<int>(n+1,-1));\\n        int ans = INT_MAX;\\n        for(int i =0;i<n;i++)\\n        {\\n            ans = min(ans,solver(0,i,n-1,dp,matrix));\\n        }\\n        return ans;\\n    }\\n};\\nthis is giving me TLE in last test case\\n"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "since the values in the matrix can be both positive and negative, initializing the DP array with -1 might lead to incorrect results since it\\'s a valid value for the sum. You can initialize it to some value that wouldn\\'t conflict with the actual sums. \\n\\nI had initialise dp to 1e9."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Since Memoization giving  TLE on case 49 \nso use this to handle that case and your code will be submitted.\n\n```if(n==100 && matrix[0][0]==0 ) return -1 ; ```\n\nAnyway Tabulation will be accepted  so go for tabulation\n\n```HINT```\n\n"
                    },
                    {
                        "username": "utkarsh_verma",
                        "content": "[@Codensity_30](/Codensity_30)  the constraints range from -100 to +100  now since your dp vector will be filled with -1 imagine it might mess up the results because of the -1 so put INT_MAX in the dp instead it will work then"
                    },
                    {
                        "username": "Codensity_30",
                        "content": "but why? I also suffered for the same, yay tabulation passed it"
                    }
                ]
            },
            {
                "id": 1953599,
                "content": [
                    {
                        "username": "makhotin",
                        "content": "If you're interested where this algo can be applied - please see [wiki page of the algo](https://en.wikipedia.org/wiki/Seam_carving), [video](https://www.youtube.com/watch?v=6NcIJXTlugc) Very cool algorithm for smart image resizing. It compute a vertical seam (path) with lowest energy using DP."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 FAANG\\uD83D\\uDE0E || Recursion, DP - Memoization, Tabulation + Space Optimization\\uD83E\\uDD73\\nhttps://leetcode.com/problems/minimum-falling-path-sum/solutions/3125421/faang-recursion-dp-memoization-tabulation-space-optimization/?orderBy=most_votes"
                    },
                    {
                        "username": "Yongbi",
                        "content": "Thank! It\\'s more excited to know the \"real\" application associated with this exercise."
                    },
                    {
                        "username": "willremember2020",
                        "content": "Why is memoization solution giving tle in 49/50 testcase? But a similar tabulation solution works??"
                    },
                    {
                        "username": "vp271202",
                        "content": "[@ansh_1012](/ansh_1012)  the -1 solution will fail because if there is a case where the sum is -1 then it will give a wrong ans and if the testcase is too large then there is a chance that it will give tle rather than a wrong ans."
                    },
                    {
                        "username": "Gaurav1234Balodi",
                        "content": "[@Sandeep_Rai](/Sandeep_Rai) its simple just read the constraints -100 <= matrix[i][j] <= 100 so you cannot enter -1 it will work even if you memorize 101 "
                    },
                    {
                        "username": "Sandeep_Rai",
                        "content": "[@ansh_1012](/ansh_1012) Yeah that worked but why?"
                    },
                    {
                        "username": "ak_3101",
                        "content": "[@ansh_1012](/ansh_1012) yes, but WHY\\n"
                    },
                    {
                        "username": "azad_6021",
                        "content": "[@ansh_1012](/ansh_1012)  Why\\'s this making a difference"
                    },
                    {
                        "username": "ansh_1012",
                        "content": "[@jatin_vashisht](/jatin_vashisht) memo solutions worked fine for me when i chnges the initialization of dp with INT_MAX rather than -1"
                    },
                    {
                        "username": "jatin_vashisht",
                        "content": "seems like leetcode has tightened the constraints. Bottom Up is getting accepted."
                    },
                    {
                        "username": "amanchandna",
                        "content": "coming up with an recursive solution at first is completely normal."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 FAANG\\uD83D\\uDE0E || Recursion, DP - Memoization, Tabulation + Space Optimization\\uD83E\\uDD73\\nhttps://leetcode.com/problems/minimum-falling-path-sum/solutions/3125421/faang-recursion-dp-memoization-tabulation-space-optimization/?orderBy=most_votes"
                    },
                    {
                        "username": "tdf56f756bg56r8iohgwexu",
                        "content": "[@user3134m](/user3134m) interactive "
                    },
                    {
                        "username": "user3134m",
                        "content": "Is there a better solution than recursion with memorization?"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "This is not a solution Tab we people are posting solution in the discussion session?\\nPlease don\\'t do this.\\nTry to give some tip if possible."
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "We can clearly see that for every element on rows 1 to n, every element is (element + minimum of 3 nodes above it)\\n\\nSo, we just have to perform this O(1) calculation for every element from row 1"
                    },
                    {
                        "username": "utkarshprap",
                        "content": "Thank You Sir for this Hint\\uD83D\\uDE04"
                    },
                    {
                        "username": "priyanshurathaur001",
                        "content": "1 2 3 4 9 8\\n1 2 3 4 9 8\\n1 2 3 4 9 8\\n1 2 3 4 9 8\\n1 2 3 4 9 8\\n9 9 8 7 6 1\\n\\nwhat was the approach for this??\\n"
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "[@joshi22](/joshi22) Its my pleasure I was able to help you\\nYou made me day\\uD83D\\uDE0A"
                    },
                    {
                        "username": "joshi22",
                        "content": "im new to dp and i read this hint and it immediately clicked how to implement it. solved it in 15 mins using dp! thanks :D"
                    },
                    {
                        "username": "beyeu107",
                        "content": "can anyone please explain ! thank you !"
                    },
                    {
                        "username": "kcharris77",
                        "content": "This problem can be solved by breaking it into sub problems. Two ways to do this are starting from the top and working down, or from the bottom and working up. At least for bottom up, the subproblems involve finding the minimum of the three-ish items below an individual item."
                    },
                    {
                        "username": "Indraneel965",
                        "content": "Try recurisively First. try out every first row element and their possibilities."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "[@venubrt](/venubrt) Please don\\'t post any solutions in this discussion tab."
                    },
                    {
                        "username": "denisId",
                        "content": "In order to solve this you have to approach it in 3 main steps:\n>Step 1 is to decompose the problem and to think how to calculate the minimum sum for only one element in the first row\n\nlet's suppose the default example:\n\nMatrix ---\n----------------------\n    2      --  [2, 1, 3] --\n    1      --  [6, 5, 4] --\n    0      --  [7, 8, 9] --\n    --     --  0  1  2  --\n\n\nWe want to find out just the minimum path for one element from first row (let it be for example Matrix[0][1] (\"8\")):\nLet's view all possible paths\n8->6->2\n8->5->2\n8->5->1\n8->5->3\n8->4->3\nIf you observe carefully this is a tree structure, so we basically have to traverse a tree structure\n\nNow the idea is to check the min sum from the descendent nodes(leaves) and bubbling up the sum to the initial root value\n\niteration1) MinValue(6) IS \"2\" (because we don't have other values, 2 + 0)\niteration2) MinValue(5)=\"1\" (because 1 < 2 < 3)\niteration3) MinValue(4)=\"3\" (because we don't have other values, 3 + 0)\ngoing for upper node now:\niteration4) MinValue(8) IS \"14\" (because (8 + MinValue(5)) < (8 + MinValue(6)) < (8 + MinValue(4)))\n\n>Step2: When you find the min sum for only one element, we can just iterate through entire row and take the min value.\n\n>Step3:The problem now is solved, however you will encounter TimeLimit Error with pure recursion on some testcases, it's due to the fact that all subnodes are recalculated multiple times\nThe solution is to use the dynamic programing: add a sort of storage structure/cache structure(HashMap), where you can put values from subnodes and to not recalculate again the sums for visited sites, and at the same time you can get the needed values quickly(in O(1) time)"
                    },
                    {
                        "username": "yug_tyagi",
                        "content": "great expl."
                    },
                    {
                        "username": "ay8182",
                        "content": "[@tulsyanshishir](/tulsyanshishir) yes it is valid\\n"
                    },
                    {
                        "username": "romanvkj2001",
                        "content": "[@tulsyanshishir](/tulsyanshishir) and also 8->4->1?\\n"
                    },
                    {
                        "username": "tulsyanshishir",
                        "content": "May be I did not understand this properly. Is the path 8->6->1 not valid ?"
                    },
                    {
                        "username": "Sohamkayal4103",
                        "content": "Some problems are better solved by tabulation instead of memoization. Choose the methods wisely while attempting any contests. "
                    },
                    {
                        "username": "aman_0_1_2",
                        "content": "[@gaurav_rawat369](/gaurav_rawat369) intilise vector<vector>dp(n+1,vector(n+1,-1)); as vector<vector>dp(n+1,vector(n+1,int_max)); it works fine but i am also getting tle if i set my dp -1 . can anyone explain why ?"
                    },
                    {
                        "username": "gaurav_rawat369",
                        "content": "class Solution {\\nprivate:\\n    int solver(int i ,int j,int n,vector<vector<int>>&dp,vector<vector<int>>&matrix)\\n    {\\n        if(i > n || j < 0 || j > n)\\n        return 1e9;\\n        if(i == n)\\n        return matrix[i][j];\\n        if(dp[i][j] != -1)\\n        return dp[i][j];\\n        return dp[i][j] = matrix[i][j] + min(solver(i+1,j-1,n,dp,matrix),min(solver(i+1,j,n,dp,matrix),solver(i+1,j+1,n,dp,matrix)));\\n    }\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        vector<vector<int>>dp(n+1,vector<int>(n+1,-1));\\n        int ans = INT_MAX;\\n        for(int i =0;i<n;i++)\\n        {\\n            ans = min(ans,solver(0,i,n-1,dp,matrix));\\n        }\\n        return ans;\\n    }\\n};\\nthis is giving me TLE in last test case\\n"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "since the values in the matrix can be both positive and negative, initializing the DP array with -1 might lead to incorrect results since it\\'s a valid value for the sum. You can initialize it to some value that wouldn\\'t conflict with the actual sums. \\n\\nI had initialise dp to 1e9."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Since Memoization giving  TLE on case 49 \nso use this to handle that case and your code will be submitted.\n\n```if(n==100 && matrix[0][0]==0 ) return -1 ; ```\n\nAnyway Tabulation will be accepted  so go for tabulation\n\n```HINT```\n\n"
                    },
                    {
                        "username": "utkarsh_verma",
                        "content": "[@Codensity_30](/Codensity_30)  the constraints range from -100 to +100  now since your dp vector will be filled with -1 imagine it might mess up the results because of the -1 so put INT_MAX in the dp instead it will work then"
                    },
                    {
                        "username": "Codensity_30",
                        "content": "but why? I also suffered for the same, yay tabulation passed it"
                    }
                ]
            },
            {
                "id": 1714691,
                "content": [
                    {
                        "username": "makhotin",
                        "content": "If you're interested where this algo can be applied - please see [wiki page of the algo](https://en.wikipedia.org/wiki/Seam_carving), [video](https://www.youtube.com/watch?v=6NcIJXTlugc) Very cool algorithm for smart image resizing. It compute a vertical seam (path) with lowest energy using DP."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 FAANG\\uD83D\\uDE0E || Recursion, DP - Memoization, Tabulation + Space Optimization\\uD83E\\uDD73\\nhttps://leetcode.com/problems/minimum-falling-path-sum/solutions/3125421/faang-recursion-dp-memoization-tabulation-space-optimization/?orderBy=most_votes"
                    },
                    {
                        "username": "Yongbi",
                        "content": "Thank! It\\'s more excited to know the \"real\" application associated with this exercise."
                    },
                    {
                        "username": "willremember2020",
                        "content": "Why is memoization solution giving tle in 49/50 testcase? But a similar tabulation solution works??"
                    },
                    {
                        "username": "vp271202",
                        "content": "[@ansh_1012](/ansh_1012)  the -1 solution will fail because if there is a case where the sum is -1 then it will give a wrong ans and if the testcase is too large then there is a chance that it will give tle rather than a wrong ans."
                    },
                    {
                        "username": "Gaurav1234Balodi",
                        "content": "[@Sandeep_Rai](/Sandeep_Rai) its simple just read the constraints -100 <= matrix[i][j] <= 100 so you cannot enter -1 it will work even if you memorize 101 "
                    },
                    {
                        "username": "Sandeep_Rai",
                        "content": "[@ansh_1012](/ansh_1012) Yeah that worked but why?"
                    },
                    {
                        "username": "ak_3101",
                        "content": "[@ansh_1012](/ansh_1012) yes, but WHY\\n"
                    },
                    {
                        "username": "azad_6021",
                        "content": "[@ansh_1012](/ansh_1012)  Why\\'s this making a difference"
                    },
                    {
                        "username": "ansh_1012",
                        "content": "[@jatin_vashisht](/jatin_vashisht) memo solutions worked fine for me when i chnges the initialization of dp with INT_MAX rather than -1"
                    },
                    {
                        "username": "jatin_vashisht",
                        "content": "seems like leetcode has tightened the constraints. Bottom Up is getting accepted."
                    },
                    {
                        "username": "amanchandna",
                        "content": "coming up with an recursive solution at first is completely normal."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 FAANG\\uD83D\\uDE0E || Recursion, DP - Memoization, Tabulation + Space Optimization\\uD83E\\uDD73\\nhttps://leetcode.com/problems/minimum-falling-path-sum/solutions/3125421/faang-recursion-dp-memoization-tabulation-space-optimization/?orderBy=most_votes"
                    },
                    {
                        "username": "tdf56f756bg56r8iohgwexu",
                        "content": "[@user3134m](/user3134m) interactive "
                    },
                    {
                        "username": "user3134m",
                        "content": "Is there a better solution than recursion with memorization?"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "This is not a solution Tab we people are posting solution in the discussion session?\\nPlease don\\'t do this.\\nTry to give some tip if possible."
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "We can clearly see that for every element on rows 1 to n, every element is (element + minimum of 3 nodes above it)\\n\\nSo, we just have to perform this O(1) calculation for every element from row 1"
                    },
                    {
                        "username": "utkarshprap",
                        "content": "Thank You Sir for this Hint\\uD83D\\uDE04"
                    },
                    {
                        "username": "priyanshurathaur001",
                        "content": "1 2 3 4 9 8\\n1 2 3 4 9 8\\n1 2 3 4 9 8\\n1 2 3 4 9 8\\n1 2 3 4 9 8\\n9 9 8 7 6 1\\n\\nwhat was the approach for this??\\n"
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "[@joshi22](/joshi22) Its my pleasure I was able to help you\\nYou made me day\\uD83D\\uDE0A"
                    },
                    {
                        "username": "joshi22",
                        "content": "im new to dp and i read this hint and it immediately clicked how to implement it. solved it in 15 mins using dp! thanks :D"
                    },
                    {
                        "username": "beyeu107",
                        "content": "can anyone please explain ! thank you !"
                    },
                    {
                        "username": "kcharris77",
                        "content": "This problem can be solved by breaking it into sub problems. Two ways to do this are starting from the top and working down, or from the bottom and working up. At least for bottom up, the subproblems involve finding the minimum of the three-ish items below an individual item."
                    },
                    {
                        "username": "Indraneel965",
                        "content": "Try recurisively First. try out every first row element and their possibilities."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "[@venubrt](/venubrt) Please don\\'t post any solutions in this discussion tab."
                    },
                    {
                        "username": "denisId",
                        "content": "In order to solve this you have to approach it in 3 main steps:\n>Step 1 is to decompose the problem and to think how to calculate the minimum sum for only one element in the first row\n\nlet's suppose the default example:\n\nMatrix ---\n----------------------\n    2      --  [2, 1, 3] --\n    1      --  [6, 5, 4] --\n    0      --  [7, 8, 9] --\n    --     --  0  1  2  --\n\n\nWe want to find out just the minimum path for one element from first row (let it be for example Matrix[0][1] (\"8\")):\nLet's view all possible paths\n8->6->2\n8->5->2\n8->5->1\n8->5->3\n8->4->3\nIf you observe carefully this is a tree structure, so we basically have to traverse a tree structure\n\nNow the idea is to check the min sum from the descendent nodes(leaves) and bubbling up the sum to the initial root value\n\niteration1) MinValue(6) IS \"2\" (because we don't have other values, 2 + 0)\niteration2) MinValue(5)=\"1\" (because 1 < 2 < 3)\niteration3) MinValue(4)=\"3\" (because we don't have other values, 3 + 0)\ngoing for upper node now:\niteration4) MinValue(8) IS \"14\" (because (8 + MinValue(5)) < (8 + MinValue(6)) < (8 + MinValue(4)))\n\n>Step2: When you find the min sum for only one element, we can just iterate through entire row and take the min value.\n\n>Step3:The problem now is solved, however you will encounter TimeLimit Error with pure recursion on some testcases, it's due to the fact that all subnodes are recalculated multiple times\nThe solution is to use the dynamic programing: add a sort of storage structure/cache structure(HashMap), where you can put values from subnodes and to not recalculate again the sums for visited sites, and at the same time you can get the needed values quickly(in O(1) time)"
                    },
                    {
                        "username": "yug_tyagi",
                        "content": "great expl."
                    },
                    {
                        "username": "ay8182",
                        "content": "[@tulsyanshishir](/tulsyanshishir) yes it is valid\\n"
                    },
                    {
                        "username": "romanvkj2001",
                        "content": "[@tulsyanshishir](/tulsyanshishir) and also 8->4->1?\\n"
                    },
                    {
                        "username": "tulsyanshishir",
                        "content": "May be I did not understand this properly. Is the path 8->6->1 not valid ?"
                    },
                    {
                        "username": "Sohamkayal4103",
                        "content": "Some problems are better solved by tabulation instead of memoization. Choose the methods wisely while attempting any contests. "
                    },
                    {
                        "username": "aman_0_1_2",
                        "content": "[@gaurav_rawat369](/gaurav_rawat369) intilise vector<vector>dp(n+1,vector(n+1,-1)); as vector<vector>dp(n+1,vector(n+1,int_max)); it works fine but i am also getting tle if i set my dp -1 . can anyone explain why ?"
                    },
                    {
                        "username": "gaurav_rawat369",
                        "content": "class Solution {\\nprivate:\\n    int solver(int i ,int j,int n,vector<vector<int>>&dp,vector<vector<int>>&matrix)\\n    {\\n        if(i > n || j < 0 || j > n)\\n        return 1e9;\\n        if(i == n)\\n        return matrix[i][j];\\n        if(dp[i][j] != -1)\\n        return dp[i][j];\\n        return dp[i][j] = matrix[i][j] + min(solver(i+1,j-1,n,dp,matrix),min(solver(i+1,j,n,dp,matrix),solver(i+1,j+1,n,dp,matrix)));\\n    }\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        vector<vector<int>>dp(n+1,vector<int>(n+1,-1));\\n        int ans = INT_MAX;\\n        for(int i =0;i<n;i++)\\n        {\\n            ans = min(ans,solver(0,i,n-1,dp,matrix));\\n        }\\n        return ans;\\n    }\\n};\\nthis is giving me TLE in last test case\\n"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "since the values in the matrix can be both positive and negative, initializing the DP array with -1 might lead to incorrect results since it\\'s a valid value for the sum. You can initialize it to some value that wouldn\\'t conflict with the actual sums. \\n\\nI had initialise dp to 1e9."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Since Memoization giving  TLE on case 49 \nso use this to handle that case and your code will be submitted.\n\n```if(n==100 && matrix[0][0]==0 ) return -1 ; ```\n\nAnyway Tabulation will be accepted  so go for tabulation\n\n```HINT```\n\n"
                    },
                    {
                        "username": "utkarsh_verma",
                        "content": "[@Codensity_30](/Codensity_30)  the constraints range from -100 to +100  now since your dp vector will be filled with -1 imagine it might mess up the results because of the -1 so put INT_MAX in the dp instead it will work then"
                    },
                    {
                        "username": "Codensity_30",
                        "content": "but why? I also suffered for the same, yay tabulation passed it"
                    }
                ]
            },
            {
                "id": 1932410,
                "content": [
                    {
                        "username": "makhotin",
                        "content": "If you're interested where this algo can be applied - please see [wiki page of the algo](https://en.wikipedia.org/wiki/Seam_carving), [video](https://www.youtube.com/watch?v=6NcIJXTlugc) Very cool algorithm for smart image resizing. It compute a vertical seam (path) with lowest energy using DP."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 FAANG\\uD83D\\uDE0E || Recursion, DP - Memoization, Tabulation + Space Optimization\\uD83E\\uDD73\\nhttps://leetcode.com/problems/minimum-falling-path-sum/solutions/3125421/faang-recursion-dp-memoization-tabulation-space-optimization/?orderBy=most_votes"
                    },
                    {
                        "username": "Yongbi",
                        "content": "Thank! It\\'s more excited to know the \"real\" application associated with this exercise."
                    },
                    {
                        "username": "willremember2020",
                        "content": "Why is memoization solution giving tle in 49/50 testcase? But a similar tabulation solution works??"
                    },
                    {
                        "username": "vp271202",
                        "content": "[@ansh_1012](/ansh_1012)  the -1 solution will fail because if there is a case where the sum is -1 then it will give a wrong ans and if the testcase is too large then there is a chance that it will give tle rather than a wrong ans."
                    },
                    {
                        "username": "Gaurav1234Balodi",
                        "content": "[@Sandeep_Rai](/Sandeep_Rai) its simple just read the constraints -100 <= matrix[i][j] <= 100 so you cannot enter -1 it will work even if you memorize 101 "
                    },
                    {
                        "username": "Sandeep_Rai",
                        "content": "[@ansh_1012](/ansh_1012) Yeah that worked but why?"
                    },
                    {
                        "username": "ak_3101",
                        "content": "[@ansh_1012](/ansh_1012) yes, but WHY\\n"
                    },
                    {
                        "username": "azad_6021",
                        "content": "[@ansh_1012](/ansh_1012)  Why\\'s this making a difference"
                    },
                    {
                        "username": "ansh_1012",
                        "content": "[@jatin_vashisht](/jatin_vashisht) memo solutions worked fine for me when i chnges the initialization of dp with INT_MAX rather than -1"
                    },
                    {
                        "username": "jatin_vashisht",
                        "content": "seems like leetcode has tightened the constraints. Bottom Up is getting accepted."
                    },
                    {
                        "username": "amanchandna",
                        "content": "coming up with an recursive solution at first is completely normal."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 FAANG\\uD83D\\uDE0E || Recursion, DP - Memoization, Tabulation + Space Optimization\\uD83E\\uDD73\\nhttps://leetcode.com/problems/minimum-falling-path-sum/solutions/3125421/faang-recursion-dp-memoization-tabulation-space-optimization/?orderBy=most_votes"
                    },
                    {
                        "username": "tdf56f756bg56r8iohgwexu",
                        "content": "[@user3134m](/user3134m) interactive "
                    },
                    {
                        "username": "user3134m",
                        "content": "Is there a better solution than recursion with memorization?"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "This is not a solution Tab we people are posting solution in the discussion session?\\nPlease don\\'t do this.\\nTry to give some tip if possible."
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "We can clearly see that for every element on rows 1 to n, every element is (element + minimum of 3 nodes above it)\\n\\nSo, we just have to perform this O(1) calculation for every element from row 1"
                    },
                    {
                        "username": "utkarshprap",
                        "content": "Thank You Sir for this Hint\\uD83D\\uDE04"
                    },
                    {
                        "username": "priyanshurathaur001",
                        "content": "1 2 3 4 9 8\\n1 2 3 4 9 8\\n1 2 3 4 9 8\\n1 2 3 4 9 8\\n1 2 3 4 9 8\\n9 9 8 7 6 1\\n\\nwhat was the approach for this??\\n"
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "[@joshi22](/joshi22) Its my pleasure I was able to help you\\nYou made me day\\uD83D\\uDE0A"
                    },
                    {
                        "username": "joshi22",
                        "content": "im new to dp and i read this hint and it immediately clicked how to implement it. solved it in 15 mins using dp! thanks :D"
                    },
                    {
                        "username": "beyeu107",
                        "content": "can anyone please explain ! thank you !"
                    },
                    {
                        "username": "kcharris77",
                        "content": "This problem can be solved by breaking it into sub problems. Two ways to do this are starting from the top and working down, or from the bottom and working up. At least for bottom up, the subproblems involve finding the minimum of the three-ish items below an individual item."
                    },
                    {
                        "username": "Indraneel965",
                        "content": "Try recurisively First. try out every first row element and their possibilities."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "[@venubrt](/venubrt) Please don\\'t post any solutions in this discussion tab."
                    },
                    {
                        "username": "denisId",
                        "content": "In order to solve this you have to approach it in 3 main steps:\n>Step 1 is to decompose the problem and to think how to calculate the minimum sum for only one element in the first row\n\nlet's suppose the default example:\n\nMatrix ---\n----------------------\n    2      --  [2, 1, 3] --\n    1      --  [6, 5, 4] --\n    0      --  [7, 8, 9] --\n    --     --  0  1  2  --\n\n\nWe want to find out just the minimum path for one element from first row (let it be for example Matrix[0][1] (\"8\")):\nLet's view all possible paths\n8->6->2\n8->5->2\n8->5->1\n8->5->3\n8->4->3\nIf you observe carefully this is a tree structure, so we basically have to traverse a tree structure\n\nNow the idea is to check the min sum from the descendent nodes(leaves) and bubbling up the sum to the initial root value\n\niteration1) MinValue(6) IS \"2\" (because we don't have other values, 2 + 0)\niteration2) MinValue(5)=\"1\" (because 1 < 2 < 3)\niteration3) MinValue(4)=\"3\" (because we don't have other values, 3 + 0)\ngoing for upper node now:\niteration4) MinValue(8) IS \"14\" (because (8 + MinValue(5)) < (8 + MinValue(6)) < (8 + MinValue(4)))\n\n>Step2: When you find the min sum for only one element, we can just iterate through entire row and take the min value.\n\n>Step3:The problem now is solved, however you will encounter TimeLimit Error with pure recursion on some testcases, it's due to the fact that all subnodes are recalculated multiple times\nThe solution is to use the dynamic programing: add a sort of storage structure/cache structure(HashMap), where you can put values from subnodes and to not recalculate again the sums for visited sites, and at the same time you can get the needed values quickly(in O(1) time)"
                    },
                    {
                        "username": "yug_tyagi",
                        "content": "great expl."
                    },
                    {
                        "username": "ay8182",
                        "content": "[@tulsyanshishir](/tulsyanshishir) yes it is valid\\n"
                    },
                    {
                        "username": "romanvkj2001",
                        "content": "[@tulsyanshishir](/tulsyanshishir) and also 8->4->1?\\n"
                    },
                    {
                        "username": "tulsyanshishir",
                        "content": "May be I did not understand this properly. Is the path 8->6->1 not valid ?"
                    },
                    {
                        "username": "Sohamkayal4103",
                        "content": "Some problems are better solved by tabulation instead of memoization. Choose the methods wisely while attempting any contests. "
                    },
                    {
                        "username": "aman_0_1_2",
                        "content": "[@gaurav_rawat369](/gaurav_rawat369) intilise vector<vector>dp(n+1,vector(n+1,-1)); as vector<vector>dp(n+1,vector(n+1,int_max)); it works fine but i am also getting tle if i set my dp -1 . can anyone explain why ?"
                    },
                    {
                        "username": "gaurav_rawat369",
                        "content": "class Solution {\\nprivate:\\n    int solver(int i ,int j,int n,vector<vector<int>>&dp,vector<vector<int>>&matrix)\\n    {\\n        if(i > n || j < 0 || j > n)\\n        return 1e9;\\n        if(i == n)\\n        return matrix[i][j];\\n        if(dp[i][j] != -1)\\n        return dp[i][j];\\n        return dp[i][j] = matrix[i][j] + min(solver(i+1,j-1,n,dp,matrix),min(solver(i+1,j,n,dp,matrix),solver(i+1,j+1,n,dp,matrix)));\\n    }\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        vector<vector<int>>dp(n+1,vector<int>(n+1,-1));\\n        int ans = INT_MAX;\\n        for(int i =0;i<n;i++)\\n        {\\n            ans = min(ans,solver(0,i,n-1,dp,matrix));\\n        }\\n        return ans;\\n    }\\n};\\nthis is giving me TLE in last test case\\n"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "since the values in the matrix can be both positive and negative, initializing the DP array with -1 might lead to incorrect results since it\\'s a valid value for the sum. You can initialize it to some value that wouldn\\'t conflict with the actual sums. \\n\\nI had initialise dp to 1e9."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Since Memoization giving  TLE on case 49 \nso use this to handle that case and your code will be submitted.\n\n```if(n==100 && matrix[0][0]==0 ) return -1 ; ```\n\nAnyway Tabulation will be accepted  so go for tabulation\n\n```HINT```\n\n"
                    },
                    {
                        "username": "utkarsh_verma",
                        "content": "[@Codensity_30](/Codensity_30)  the constraints range from -100 to +100  now since your dp vector will be filled with -1 imagine it might mess up the results because of the -1 so put INT_MAX in the dp instead it will work then"
                    },
                    {
                        "username": "Codensity_30",
                        "content": "but why? I also suffered for the same, yay tabulation passed it"
                    }
                ]
            },
            {
                "id": 1714811,
                "content": [
                    {
                        "username": "makhotin",
                        "content": "If you're interested where this algo can be applied - please see [wiki page of the algo](https://en.wikipedia.org/wiki/Seam_carving), [video](https://www.youtube.com/watch?v=6NcIJXTlugc) Very cool algorithm for smart image resizing. It compute a vertical seam (path) with lowest energy using DP."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 FAANG\\uD83D\\uDE0E || Recursion, DP - Memoization, Tabulation + Space Optimization\\uD83E\\uDD73\\nhttps://leetcode.com/problems/minimum-falling-path-sum/solutions/3125421/faang-recursion-dp-memoization-tabulation-space-optimization/?orderBy=most_votes"
                    },
                    {
                        "username": "Yongbi",
                        "content": "Thank! It\\'s more excited to know the \"real\" application associated with this exercise."
                    },
                    {
                        "username": "willremember2020",
                        "content": "Why is memoization solution giving tle in 49/50 testcase? But a similar tabulation solution works??"
                    },
                    {
                        "username": "vp271202",
                        "content": "[@ansh_1012](/ansh_1012)  the -1 solution will fail because if there is a case where the sum is -1 then it will give a wrong ans and if the testcase is too large then there is a chance that it will give tle rather than a wrong ans."
                    },
                    {
                        "username": "Gaurav1234Balodi",
                        "content": "[@Sandeep_Rai](/Sandeep_Rai) its simple just read the constraints -100 <= matrix[i][j] <= 100 so you cannot enter -1 it will work even if you memorize 101 "
                    },
                    {
                        "username": "Sandeep_Rai",
                        "content": "[@ansh_1012](/ansh_1012) Yeah that worked but why?"
                    },
                    {
                        "username": "ak_3101",
                        "content": "[@ansh_1012](/ansh_1012) yes, but WHY\\n"
                    },
                    {
                        "username": "azad_6021",
                        "content": "[@ansh_1012](/ansh_1012)  Why\\'s this making a difference"
                    },
                    {
                        "username": "ansh_1012",
                        "content": "[@jatin_vashisht](/jatin_vashisht) memo solutions worked fine for me when i chnges the initialization of dp with INT_MAX rather than -1"
                    },
                    {
                        "username": "jatin_vashisht",
                        "content": "seems like leetcode has tightened the constraints. Bottom Up is getting accepted."
                    },
                    {
                        "username": "amanchandna",
                        "content": "coming up with an recursive solution at first is completely normal."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 FAANG\\uD83D\\uDE0E || Recursion, DP - Memoization, Tabulation + Space Optimization\\uD83E\\uDD73\\nhttps://leetcode.com/problems/minimum-falling-path-sum/solutions/3125421/faang-recursion-dp-memoization-tabulation-space-optimization/?orderBy=most_votes"
                    },
                    {
                        "username": "tdf56f756bg56r8iohgwexu",
                        "content": "[@user3134m](/user3134m) interactive "
                    },
                    {
                        "username": "user3134m",
                        "content": "Is there a better solution than recursion with memorization?"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "This is not a solution Tab we people are posting solution in the discussion session?\\nPlease don\\'t do this.\\nTry to give some tip if possible."
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "We can clearly see that for every element on rows 1 to n, every element is (element + minimum of 3 nodes above it)\\n\\nSo, we just have to perform this O(1) calculation for every element from row 1"
                    },
                    {
                        "username": "utkarshprap",
                        "content": "Thank You Sir for this Hint\\uD83D\\uDE04"
                    },
                    {
                        "username": "priyanshurathaur001",
                        "content": "1 2 3 4 9 8\\n1 2 3 4 9 8\\n1 2 3 4 9 8\\n1 2 3 4 9 8\\n1 2 3 4 9 8\\n9 9 8 7 6 1\\n\\nwhat was the approach for this??\\n"
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "[@joshi22](/joshi22) Its my pleasure I was able to help you\\nYou made me day\\uD83D\\uDE0A"
                    },
                    {
                        "username": "joshi22",
                        "content": "im new to dp and i read this hint and it immediately clicked how to implement it. solved it in 15 mins using dp! thanks :D"
                    },
                    {
                        "username": "beyeu107",
                        "content": "can anyone please explain ! thank you !"
                    },
                    {
                        "username": "kcharris77",
                        "content": "This problem can be solved by breaking it into sub problems. Two ways to do this are starting from the top and working down, or from the bottom and working up. At least for bottom up, the subproblems involve finding the minimum of the three-ish items below an individual item."
                    },
                    {
                        "username": "Indraneel965",
                        "content": "Try recurisively First. try out every first row element and their possibilities."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "[@venubrt](/venubrt) Please don\\'t post any solutions in this discussion tab."
                    },
                    {
                        "username": "denisId",
                        "content": "In order to solve this you have to approach it in 3 main steps:\n>Step 1 is to decompose the problem and to think how to calculate the minimum sum for only one element in the first row\n\nlet's suppose the default example:\n\nMatrix ---\n----------------------\n    2      --  [2, 1, 3] --\n    1      --  [6, 5, 4] --\n    0      --  [7, 8, 9] --\n    --     --  0  1  2  --\n\n\nWe want to find out just the minimum path for one element from first row (let it be for example Matrix[0][1] (\"8\")):\nLet's view all possible paths\n8->6->2\n8->5->2\n8->5->1\n8->5->3\n8->4->3\nIf you observe carefully this is a tree structure, so we basically have to traverse a tree structure\n\nNow the idea is to check the min sum from the descendent nodes(leaves) and bubbling up the sum to the initial root value\n\niteration1) MinValue(6) IS \"2\" (because we don't have other values, 2 + 0)\niteration2) MinValue(5)=\"1\" (because 1 < 2 < 3)\niteration3) MinValue(4)=\"3\" (because we don't have other values, 3 + 0)\ngoing for upper node now:\niteration4) MinValue(8) IS \"14\" (because (8 + MinValue(5)) < (8 + MinValue(6)) < (8 + MinValue(4)))\n\n>Step2: When you find the min sum for only one element, we can just iterate through entire row and take the min value.\n\n>Step3:The problem now is solved, however you will encounter TimeLimit Error with pure recursion on some testcases, it's due to the fact that all subnodes are recalculated multiple times\nThe solution is to use the dynamic programing: add a sort of storage structure/cache structure(HashMap), where you can put values from subnodes and to not recalculate again the sums for visited sites, and at the same time you can get the needed values quickly(in O(1) time)"
                    },
                    {
                        "username": "yug_tyagi",
                        "content": "great expl."
                    },
                    {
                        "username": "ay8182",
                        "content": "[@tulsyanshishir](/tulsyanshishir) yes it is valid\\n"
                    },
                    {
                        "username": "romanvkj2001",
                        "content": "[@tulsyanshishir](/tulsyanshishir) and also 8->4->1?\\n"
                    },
                    {
                        "username": "tulsyanshishir",
                        "content": "May be I did not understand this properly. Is the path 8->6->1 not valid ?"
                    },
                    {
                        "username": "Sohamkayal4103",
                        "content": "Some problems are better solved by tabulation instead of memoization. Choose the methods wisely while attempting any contests. "
                    },
                    {
                        "username": "aman_0_1_2",
                        "content": "[@gaurav_rawat369](/gaurav_rawat369) intilise vector<vector>dp(n+1,vector(n+1,-1)); as vector<vector>dp(n+1,vector(n+1,int_max)); it works fine but i am also getting tle if i set my dp -1 . can anyone explain why ?"
                    },
                    {
                        "username": "gaurav_rawat369",
                        "content": "class Solution {\\nprivate:\\n    int solver(int i ,int j,int n,vector<vector<int>>&dp,vector<vector<int>>&matrix)\\n    {\\n        if(i > n || j < 0 || j > n)\\n        return 1e9;\\n        if(i == n)\\n        return matrix[i][j];\\n        if(dp[i][j] != -1)\\n        return dp[i][j];\\n        return dp[i][j] = matrix[i][j] + min(solver(i+1,j-1,n,dp,matrix),min(solver(i+1,j,n,dp,matrix),solver(i+1,j+1,n,dp,matrix)));\\n    }\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        vector<vector<int>>dp(n+1,vector<int>(n+1,-1));\\n        int ans = INT_MAX;\\n        for(int i =0;i<n;i++)\\n        {\\n            ans = min(ans,solver(0,i,n-1,dp,matrix));\\n        }\\n        return ans;\\n    }\\n};\\nthis is giving me TLE in last test case\\n"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "since the values in the matrix can be both positive and negative, initializing the DP array with -1 might lead to incorrect results since it\\'s a valid value for the sum. You can initialize it to some value that wouldn\\'t conflict with the actual sums. \\n\\nI had initialise dp to 1e9."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Since Memoization giving  TLE on case 49 \nso use this to handle that case and your code will be submitted.\n\n```if(n==100 && matrix[0][0]==0 ) return -1 ; ```\n\nAnyway Tabulation will be accepted  so go for tabulation\n\n```HINT```\n\n"
                    },
                    {
                        "username": "utkarsh_verma",
                        "content": "[@Codensity_30](/Codensity_30)  the constraints range from -100 to +100  now since your dp vector will be filled with -1 imagine it might mess up the results because of the -1 so put INT_MAX in the dp instead it will work then"
                    },
                    {
                        "username": "Codensity_30",
                        "content": "but why? I also suffered for the same, yay tabulation passed it"
                    }
                ]
            },
            {
                "id": 1715130,
                "content": [
                    {
                        "username": "makhotin",
                        "content": "If you're interested where this algo can be applied - please see [wiki page of the algo](https://en.wikipedia.org/wiki/Seam_carving), [video](https://www.youtube.com/watch?v=6NcIJXTlugc) Very cool algorithm for smart image resizing. It compute a vertical seam (path) with lowest energy using DP."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 FAANG\\uD83D\\uDE0E || Recursion, DP - Memoization, Tabulation + Space Optimization\\uD83E\\uDD73\\nhttps://leetcode.com/problems/minimum-falling-path-sum/solutions/3125421/faang-recursion-dp-memoization-tabulation-space-optimization/?orderBy=most_votes"
                    },
                    {
                        "username": "Yongbi",
                        "content": "Thank! It\\'s more excited to know the \"real\" application associated with this exercise."
                    },
                    {
                        "username": "willremember2020",
                        "content": "Why is memoization solution giving tle in 49/50 testcase? But a similar tabulation solution works??"
                    },
                    {
                        "username": "vp271202",
                        "content": "[@ansh_1012](/ansh_1012)  the -1 solution will fail because if there is a case where the sum is -1 then it will give a wrong ans and if the testcase is too large then there is a chance that it will give tle rather than a wrong ans."
                    },
                    {
                        "username": "Gaurav1234Balodi",
                        "content": "[@Sandeep_Rai](/Sandeep_Rai) its simple just read the constraints -100 <= matrix[i][j] <= 100 so you cannot enter -1 it will work even if you memorize 101 "
                    },
                    {
                        "username": "Sandeep_Rai",
                        "content": "[@ansh_1012](/ansh_1012) Yeah that worked but why?"
                    },
                    {
                        "username": "ak_3101",
                        "content": "[@ansh_1012](/ansh_1012) yes, but WHY\\n"
                    },
                    {
                        "username": "azad_6021",
                        "content": "[@ansh_1012](/ansh_1012)  Why\\'s this making a difference"
                    },
                    {
                        "username": "ansh_1012",
                        "content": "[@jatin_vashisht](/jatin_vashisht) memo solutions worked fine for me when i chnges the initialization of dp with INT_MAX rather than -1"
                    },
                    {
                        "username": "jatin_vashisht",
                        "content": "seems like leetcode has tightened the constraints. Bottom Up is getting accepted."
                    },
                    {
                        "username": "amanchandna",
                        "content": "coming up with an recursive solution at first is completely normal."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 FAANG\\uD83D\\uDE0E || Recursion, DP - Memoization, Tabulation + Space Optimization\\uD83E\\uDD73\\nhttps://leetcode.com/problems/minimum-falling-path-sum/solutions/3125421/faang-recursion-dp-memoization-tabulation-space-optimization/?orderBy=most_votes"
                    },
                    {
                        "username": "tdf56f756bg56r8iohgwexu",
                        "content": "[@user3134m](/user3134m) interactive "
                    },
                    {
                        "username": "user3134m",
                        "content": "Is there a better solution than recursion with memorization?"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "This is not a solution Tab we people are posting solution in the discussion session?\\nPlease don\\'t do this.\\nTry to give some tip if possible."
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "We can clearly see that for every element on rows 1 to n, every element is (element + minimum of 3 nodes above it)\\n\\nSo, we just have to perform this O(1) calculation for every element from row 1"
                    },
                    {
                        "username": "utkarshprap",
                        "content": "Thank You Sir for this Hint\\uD83D\\uDE04"
                    },
                    {
                        "username": "priyanshurathaur001",
                        "content": "1 2 3 4 9 8\\n1 2 3 4 9 8\\n1 2 3 4 9 8\\n1 2 3 4 9 8\\n1 2 3 4 9 8\\n9 9 8 7 6 1\\n\\nwhat was the approach for this??\\n"
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "[@joshi22](/joshi22) Its my pleasure I was able to help you\\nYou made me day\\uD83D\\uDE0A"
                    },
                    {
                        "username": "joshi22",
                        "content": "im new to dp and i read this hint and it immediately clicked how to implement it. solved it in 15 mins using dp! thanks :D"
                    },
                    {
                        "username": "beyeu107",
                        "content": "can anyone please explain ! thank you !"
                    },
                    {
                        "username": "kcharris77",
                        "content": "This problem can be solved by breaking it into sub problems. Two ways to do this are starting from the top and working down, or from the bottom and working up. At least for bottom up, the subproblems involve finding the minimum of the three-ish items below an individual item."
                    },
                    {
                        "username": "Indraneel965",
                        "content": "Try recurisively First. try out every first row element and their possibilities."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "[@venubrt](/venubrt) Please don\\'t post any solutions in this discussion tab."
                    },
                    {
                        "username": "denisId",
                        "content": "In order to solve this you have to approach it in 3 main steps:\n>Step 1 is to decompose the problem and to think how to calculate the minimum sum for only one element in the first row\n\nlet's suppose the default example:\n\nMatrix ---\n----------------------\n    2      --  [2, 1, 3] --\n    1      --  [6, 5, 4] --\n    0      --  [7, 8, 9] --\n    --     --  0  1  2  --\n\n\nWe want to find out just the minimum path for one element from first row (let it be for example Matrix[0][1] (\"8\")):\nLet's view all possible paths\n8->6->2\n8->5->2\n8->5->1\n8->5->3\n8->4->3\nIf you observe carefully this is a tree structure, so we basically have to traverse a tree structure\n\nNow the idea is to check the min sum from the descendent nodes(leaves) and bubbling up the sum to the initial root value\n\niteration1) MinValue(6) IS \"2\" (because we don't have other values, 2 + 0)\niteration2) MinValue(5)=\"1\" (because 1 < 2 < 3)\niteration3) MinValue(4)=\"3\" (because we don't have other values, 3 + 0)\ngoing for upper node now:\niteration4) MinValue(8) IS \"14\" (because (8 + MinValue(5)) < (8 + MinValue(6)) < (8 + MinValue(4)))\n\n>Step2: When you find the min sum for only one element, we can just iterate through entire row and take the min value.\n\n>Step3:The problem now is solved, however you will encounter TimeLimit Error with pure recursion on some testcases, it's due to the fact that all subnodes are recalculated multiple times\nThe solution is to use the dynamic programing: add a sort of storage structure/cache structure(HashMap), where you can put values from subnodes and to not recalculate again the sums for visited sites, and at the same time you can get the needed values quickly(in O(1) time)"
                    },
                    {
                        "username": "yug_tyagi",
                        "content": "great expl."
                    },
                    {
                        "username": "ay8182",
                        "content": "[@tulsyanshishir](/tulsyanshishir) yes it is valid\\n"
                    },
                    {
                        "username": "romanvkj2001",
                        "content": "[@tulsyanshishir](/tulsyanshishir) and also 8->4->1?\\n"
                    },
                    {
                        "username": "tulsyanshishir",
                        "content": "May be I did not understand this properly. Is the path 8->6->1 not valid ?"
                    },
                    {
                        "username": "Sohamkayal4103",
                        "content": "Some problems are better solved by tabulation instead of memoization. Choose the methods wisely while attempting any contests. "
                    },
                    {
                        "username": "aman_0_1_2",
                        "content": "[@gaurav_rawat369](/gaurav_rawat369) intilise vector<vector>dp(n+1,vector(n+1,-1)); as vector<vector>dp(n+1,vector(n+1,int_max)); it works fine but i am also getting tle if i set my dp -1 . can anyone explain why ?"
                    },
                    {
                        "username": "gaurav_rawat369",
                        "content": "class Solution {\\nprivate:\\n    int solver(int i ,int j,int n,vector<vector<int>>&dp,vector<vector<int>>&matrix)\\n    {\\n        if(i > n || j < 0 || j > n)\\n        return 1e9;\\n        if(i == n)\\n        return matrix[i][j];\\n        if(dp[i][j] != -1)\\n        return dp[i][j];\\n        return dp[i][j] = matrix[i][j] + min(solver(i+1,j-1,n,dp,matrix),min(solver(i+1,j,n,dp,matrix),solver(i+1,j+1,n,dp,matrix)));\\n    }\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        vector<vector<int>>dp(n+1,vector<int>(n+1,-1));\\n        int ans = INT_MAX;\\n        for(int i =0;i<n;i++)\\n        {\\n            ans = min(ans,solver(0,i,n-1,dp,matrix));\\n        }\\n        return ans;\\n    }\\n};\\nthis is giving me TLE in last test case\\n"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "since the values in the matrix can be both positive and negative, initializing the DP array with -1 might lead to incorrect results since it\\'s a valid value for the sum. You can initialize it to some value that wouldn\\'t conflict with the actual sums. \\n\\nI had initialise dp to 1e9."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Since Memoization giving  TLE on case 49 \nso use this to handle that case and your code will be submitted.\n\n```if(n==100 && matrix[0][0]==0 ) return -1 ; ```\n\nAnyway Tabulation will be accepted  so go for tabulation\n\n```HINT```\n\n"
                    },
                    {
                        "username": "utkarsh_verma",
                        "content": "[@Codensity_30](/Codensity_30)  the constraints range from -100 to +100  now since your dp vector will be filled with -1 imagine it might mess up the results because of the -1 so put INT_MAX in the dp instead it will work then"
                    },
                    {
                        "username": "Codensity_30",
                        "content": "but why? I also suffered for the same, yay tabulation passed it"
                    }
                ]
            },
            {
                "id": 1714791,
                "content": [
                    {
                        "username": "makhotin",
                        "content": "If you're interested where this algo can be applied - please see [wiki page of the algo](https://en.wikipedia.org/wiki/Seam_carving), [video](https://www.youtube.com/watch?v=6NcIJXTlugc) Very cool algorithm for smart image resizing. It compute a vertical seam (path) with lowest energy using DP."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 FAANG\\uD83D\\uDE0E || Recursion, DP - Memoization, Tabulation + Space Optimization\\uD83E\\uDD73\\nhttps://leetcode.com/problems/minimum-falling-path-sum/solutions/3125421/faang-recursion-dp-memoization-tabulation-space-optimization/?orderBy=most_votes"
                    },
                    {
                        "username": "Yongbi",
                        "content": "Thank! It\\'s more excited to know the \"real\" application associated with this exercise."
                    },
                    {
                        "username": "willremember2020",
                        "content": "Why is memoization solution giving tle in 49/50 testcase? But a similar tabulation solution works??"
                    },
                    {
                        "username": "vp271202",
                        "content": "[@ansh_1012](/ansh_1012)  the -1 solution will fail because if there is a case where the sum is -1 then it will give a wrong ans and if the testcase is too large then there is a chance that it will give tle rather than a wrong ans."
                    },
                    {
                        "username": "Gaurav1234Balodi",
                        "content": "[@Sandeep_Rai](/Sandeep_Rai) its simple just read the constraints -100 <= matrix[i][j] <= 100 so you cannot enter -1 it will work even if you memorize 101 "
                    },
                    {
                        "username": "Sandeep_Rai",
                        "content": "[@ansh_1012](/ansh_1012) Yeah that worked but why?"
                    },
                    {
                        "username": "ak_3101",
                        "content": "[@ansh_1012](/ansh_1012) yes, but WHY\\n"
                    },
                    {
                        "username": "azad_6021",
                        "content": "[@ansh_1012](/ansh_1012)  Why\\'s this making a difference"
                    },
                    {
                        "username": "ansh_1012",
                        "content": "[@jatin_vashisht](/jatin_vashisht) memo solutions worked fine for me when i chnges the initialization of dp with INT_MAX rather than -1"
                    },
                    {
                        "username": "jatin_vashisht",
                        "content": "seems like leetcode has tightened the constraints. Bottom Up is getting accepted."
                    },
                    {
                        "username": "amanchandna",
                        "content": "coming up with an recursive solution at first is completely normal."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 FAANG\\uD83D\\uDE0E || Recursion, DP - Memoization, Tabulation + Space Optimization\\uD83E\\uDD73\\nhttps://leetcode.com/problems/minimum-falling-path-sum/solutions/3125421/faang-recursion-dp-memoization-tabulation-space-optimization/?orderBy=most_votes"
                    },
                    {
                        "username": "tdf56f756bg56r8iohgwexu",
                        "content": "[@user3134m](/user3134m) interactive "
                    },
                    {
                        "username": "user3134m",
                        "content": "Is there a better solution than recursion with memorization?"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "This is not a solution Tab we people are posting solution in the discussion session?\\nPlease don\\'t do this.\\nTry to give some tip if possible."
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "We can clearly see that for every element on rows 1 to n, every element is (element + minimum of 3 nodes above it)\\n\\nSo, we just have to perform this O(1) calculation for every element from row 1"
                    },
                    {
                        "username": "utkarshprap",
                        "content": "Thank You Sir for this Hint\\uD83D\\uDE04"
                    },
                    {
                        "username": "priyanshurathaur001",
                        "content": "1 2 3 4 9 8\\n1 2 3 4 9 8\\n1 2 3 4 9 8\\n1 2 3 4 9 8\\n1 2 3 4 9 8\\n9 9 8 7 6 1\\n\\nwhat was the approach for this??\\n"
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "[@joshi22](/joshi22) Its my pleasure I was able to help you\\nYou made me day\\uD83D\\uDE0A"
                    },
                    {
                        "username": "joshi22",
                        "content": "im new to dp and i read this hint and it immediately clicked how to implement it. solved it in 15 mins using dp! thanks :D"
                    },
                    {
                        "username": "beyeu107",
                        "content": "can anyone please explain ! thank you !"
                    },
                    {
                        "username": "kcharris77",
                        "content": "This problem can be solved by breaking it into sub problems. Two ways to do this are starting from the top and working down, or from the bottom and working up. At least for bottom up, the subproblems involve finding the minimum of the three-ish items below an individual item."
                    },
                    {
                        "username": "Indraneel965",
                        "content": "Try recurisively First. try out every first row element and their possibilities."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "[@venubrt](/venubrt) Please don\\'t post any solutions in this discussion tab."
                    },
                    {
                        "username": "denisId",
                        "content": "In order to solve this you have to approach it in 3 main steps:\n>Step 1 is to decompose the problem and to think how to calculate the minimum sum for only one element in the first row\n\nlet's suppose the default example:\n\nMatrix ---\n----------------------\n    2      --  [2, 1, 3] --\n    1      --  [6, 5, 4] --\n    0      --  [7, 8, 9] --\n    --     --  0  1  2  --\n\n\nWe want to find out just the minimum path for one element from first row (let it be for example Matrix[0][1] (\"8\")):\nLet's view all possible paths\n8->6->2\n8->5->2\n8->5->1\n8->5->3\n8->4->3\nIf you observe carefully this is a tree structure, so we basically have to traverse a tree structure\n\nNow the idea is to check the min sum from the descendent nodes(leaves) and bubbling up the sum to the initial root value\n\niteration1) MinValue(6) IS \"2\" (because we don't have other values, 2 + 0)\niteration2) MinValue(5)=\"1\" (because 1 < 2 < 3)\niteration3) MinValue(4)=\"3\" (because we don't have other values, 3 + 0)\ngoing for upper node now:\niteration4) MinValue(8) IS \"14\" (because (8 + MinValue(5)) < (8 + MinValue(6)) < (8 + MinValue(4)))\n\n>Step2: When you find the min sum for only one element, we can just iterate through entire row and take the min value.\n\n>Step3:The problem now is solved, however you will encounter TimeLimit Error with pure recursion on some testcases, it's due to the fact that all subnodes are recalculated multiple times\nThe solution is to use the dynamic programing: add a sort of storage structure/cache structure(HashMap), where you can put values from subnodes and to not recalculate again the sums for visited sites, and at the same time you can get the needed values quickly(in O(1) time)"
                    },
                    {
                        "username": "yug_tyagi",
                        "content": "great expl."
                    },
                    {
                        "username": "ay8182",
                        "content": "[@tulsyanshishir](/tulsyanshishir) yes it is valid\\n"
                    },
                    {
                        "username": "romanvkj2001",
                        "content": "[@tulsyanshishir](/tulsyanshishir) and also 8->4->1?\\n"
                    },
                    {
                        "username": "tulsyanshishir",
                        "content": "May be I did not understand this properly. Is the path 8->6->1 not valid ?"
                    },
                    {
                        "username": "Sohamkayal4103",
                        "content": "Some problems are better solved by tabulation instead of memoization. Choose the methods wisely while attempting any contests. "
                    },
                    {
                        "username": "aman_0_1_2",
                        "content": "[@gaurav_rawat369](/gaurav_rawat369) intilise vector<vector>dp(n+1,vector(n+1,-1)); as vector<vector>dp(n+1,vector(n+1,int_max)); it works fine but i am also getting tle if i set my dp -1 . can anyone explain why ?"
                    },
                    {
                        "username": "gaurav_rawat369",
                        "content": "class Solution {\\nprivate:\\n    int solver(int i ,int j,int n,vector<vector<int>>&dp,vector<vector<int>>&matrix)\\n    {\\n        if(i > n || j < 0 || j > n)\\n        return 1e9;\\n        if(i == n)\\n        return matrix[i][j];\\n        if(dp[i][j] != -1)\\n        return dp[i][j];\\n        return dp[i][j] = matrix[i][j] + min(solver(i+1,j-1,n,dp,matrix),min(solver(i+1,j,n,dp,matrix),solver(i+1,j+1,n,dp,matrix)));\\n    }\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        vector<vector<int>>dp(n+1,vector<int>(n+1,-1));\\n        int ans = INT_MAX;\\n        for(int i =0;i<n;i++)\\n        {\\n            ans = min(ans,solver(0,i,n-1,dp,matrix));\\n        }\\n        return ans;\\n    }\\n};\\nthis is giving me TLE in last test case\\n"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "since the values in the matrix can be both positive and negative, initializing the DP array with -1 might lead to incorrect results since it\\'s a valid value for the sum. You can initialize it to some value that wouldn\\'t conflict with the actual sums. \\n\\nI had initialise dp to 1e9."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Since Memoization giving  TLE on case 49 \nso use this to handle that case and your code will be submitted.\n\n```if(n==100 && matrix[0][0]==0 ) return -1 ; ```\n\nAnyway Tabulation will be accepted  so go for tabulation\n\n```HINT```\n\n"
                    },
                    {
                        "username": "utkarsh_verma",
                        "content": "[@Codensity_30](/Codensity_30)  the constraints range from -100 to +100  now since your dp vector will be filled with -1 imagine it might mess up the results because of the -1 so put INT_MAX in the dp instead it will work then"
                    },
                    {
                        "username": "Codensity_30",
                        "content": "but why? I also suffered for the same, yay tabulation passed it"
                    }
                ]
            },
            {
                "id": 1568079,
                "content": [
                    {
                        "username": "makhotin",
                        "content": "If you're interested where this algo can be applied - please see [wiki page of the algo](https://en.wikipedia.org/wiki/Seam_carving), [video](https://www.youtube.com/watch?v=6NcIJXTlugc) Very cool algorithm for smart image resizing. It compute a vertical seam (path) with lowest energy using DP."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 FAANG\\uD83D\\uDE0E || Recursion, DP - Memoization, Tabulation + Space Optimization\\uD83E\\uDD73\\nhttps://leetcode.com/problems/minimum-falling-path-sum/solutions/3125421/faang-recursion-dp-memoization-tabulation-space-optimization/?orderBy=most_votes"
                    },
                    {
                        "username": "Yongbi",
                        "content": "Thank! It\\'s more excited to know the \"real\" application associated with this exercise."
                    },
                    {
                        "username": "willremember2020",
                        "content": "Why is memoization solution giving tle in 49/50 testcase? But a similar tabulation solution works??"
                    },
                    {
                        "username": "vp271202",
                        "content": "[@ansh_1012](/ansh_1012)  the -1 solution will fail because if there is a case where the sum is -1 then it will give a wrong ans and if the testcase is too large then there is a chance that it will give tle rather than a wrong ans."
                    },
                    {
                        "username": "Gaurav1234Balodi",
                        "content": "[@Sandeep_Rai](/Sandeep_Rai) its simple just read the constraints -100 <= matrix[i][j] <= 100 so you cannot enter -1 it will work even if you memorize 101 "
                    },
                    {
                        "username": "Sandeep_Rai",
                        "content": "[@ansh_1012](/ansh_1012) Yeah that worked but why?"
                    },
                    {
                        "username": "ak_3101",
                        "content": "[@ansh_1012](/ansh_1012) yes, but WHY\\n"
                    },
                    {
                        "username": "azad_6021",
                        "content": "[@ansh_1012](/ansh_1012)  Why\\'s this making a difference"
                    },
                    {
                        "username": "ansh_1012",
                        "content": "[@jatin_vashisht](/jatin_vashisht) memo solutions worked fine for me when i chnges the initialization of dp with INT_MAX rather than -1"
                    },
                    {
                        "username": "jatin_vashisht",
                        "content": "seems like leetcode has tightened the constraints. Bottom Up is getting accepted."
                    },
                    {
                        "username": "amanchandna",
                        "content": "coming up with an recursive solution at first is completely normal."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 FAANG\\uD83D\\uDE0E || Recursion, DP - Memoization, Tabulation + Space Optimization\\uD83E\\uDD73\\nhttps://leetcode.com/problems/minimum-falling-path-sum/solutions/3125421/faang-recursion-dp-memoization-tabulation-space-optimization/?orderBy=most_votes"
                    },
                    {
                        "username": "tdf56f756bg56r8iohgwexu",
                        "content": "[@user3134m](/user3134m) interactive "
                    },
                    {
                        "username": "user3134m",
                        "content": "Is there a better solution than recursion with memorization?"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "This is not a solution Tab we people are posting solution in the discussion session?\\nPlease don\\'t do this.\\nTry to give some tip if possible."
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "We can clearly see that for every element on rows 1 to n, every element is (element + minimum of 3 nodes above it)\\n\\nSo, we just have to perform this O(1) calculation for every element from row 1"
                    },
                    {
                        "username": "utkarshprap",
                        "content": "Thank You Sir for this Hint\\uD83D\\uDE04"
                    },
                    {
                        "username": "priyanshurathaur001",
                        "content": "1 2 3 4 9 8\\n1 2 3 4 9 8\\n1 2 3 4 9 8\\n1 2 3 4 9 8\\n1 2 3 4 9 8\\n9 9 8 7 6 1\\n\\nwhat was the approach for this??\\n"
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "[@joshi22](/joshi22) Its my pleasure I was able to help you\\nYou made me day\\uD83D\\uDE0A"
                    },
                    {
                        "username": "joshi22",
                        "content": "im new to dp and i read this hint and it immediately clicked how to implement it. solved it in 15 mins using dp! thanks :D"
                    },
                    {
                        "username": "beyeu107",
                        "content": "can anyone please explain ! thank you !"
                    },
                    {
                        "username": "kcharris77",
                        "content": "This problem can be solved by breaking it into sub problems. Two ways to do this are starting from the top and working down, or from the bottom and working up. At least for bottom up, the subproblems involve finding the minimum of the three-ish items below an individual item."
                    },
                    {
                        "username": "Indraneel965",
                        "content": "Try recurisively First. try out every first row element and their possibilities."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "[@venubrt](/venubrt) Please don\\'t post any solutions in this discussion tab."
                    },
                    {
                        "username": "denisId",
                        "content": "In order to solve this you have to approach it in 3 main steps:\n>Step 1 is to decompose the problem and to think how to calculate the minimum sum for only one element in the first row\n\nlet's suppose the default example:\n\nMatrix ---\n----------------------\n    2      --  [2, 1, 3] --\n    1      --  [6, 5, 4] --\n    0      --  [7, 8, 9] --\n    --     --  0  1  2  --\n\n\nWe want to find out just the minimum path for one element from first row (let it be for example Matrix[0][1] (\"8\")):\nLet's view all possible paths\n8->6->2\n8->5->2\n8->5->1\n8->5->3\n8->4->3\nIf you observe carefully this is a tree structure, so we basically have to traverse a tree structure\n\nNow the idea is to check the min sum from the descendent nodes(leaves) and bubbling up the sum to the initial root value\n\niteration1) MinValue(6) IS \"2\" (because we don't have other values, 2 + 0)\niteration2) MinValue(5)=\"1\" (because 1 < 2 < 3)\niteration3) MinValue(4)=\"3\" (because we don't have other values, 3 + 0)\ngoing for upper node now:\niteration4) MinValue(8) IS \"14\" (because (8 + MinValue(5)) < (8 + MinValue(6)) < (8 + MinValue(4)))\n\n>Step2: When you find the min sum for only one element, we can just iterate through entire row and take the min value.\n\n>Step3:The problem now is solved, however you will encounter TimeLimit Error with pure recursion on some testcases, it's due to the fact that all subnodes are recalculated multiple times\nThe solution is to use the dynamic programing: add a sort of storage structure/cache structure(HashMap), where you can put values from subnodes and to not recalculate again the sums for visited sites, and at the same time you can get the needed values quickly(in O(1) time)"
                    },
                    {
                        "username": "yug_tyagi",
                        "content": "great expl."
                    },
                    {
                        "username": "ay8182",
                        "content": "[@tulsyanshishir](/tulsyanshishir) yes it is valid\\n"
                    },
                    {
                        "username": "romanvkj2001",
                        "content": "[@tulsyanshishir](/tulsyanshishir) and also 8->4->1?\\n"
                    },
                    {
                        "username": "tulsyanshishir",
                        "content": "May be I did not understand this properly. Is the path 8->6->1 not valid ?"
                    },
                    {
                        "username": "Sohamkayal4103",
                        "content": "Some problems are better solved by tabulation instead of memoization. Choose the methods wisely while attempting any contests. "
                    },
                    {
                        "username": "aman_0_1_2",
                        "content": "[@gaurav_rawat369](/gaurav_rawat369) intilise vector<vector>dp(n+1,vector(n+1,-1)); as vector<vector>dp(n+1,vector(n+1,int_max)); it works fine but i am also getting tle if i set my dp -1 . can anyone explain why ?"
                    },
                    {
                        "username": "gaurav_rawat369",
                        "content": "class Solution {\\nprivate:\\n    int solver(int i ,int j,int n,vector<vector<int>>&dp,vector<vector<int>>&matrix)\\n    {\\n        if(i > n || j < 0 || j > n)\\n        return 1e9;\\n        if(i == n)\\n        return matrix[i][j];\\n        if(dp[i][j] != -1)\\n        return dp[i][j];\\n        return dp[i][j] = matrix[i][j] + min(solver(i+1,j-1,n,dp,matrix),min(solver(i+1,j,n,dp,matrix),solver(i+1,j+1,n,dp,matrix)));\\n    }\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        vector<vector<int>>dp(n+1,vector<int>(n+1,-1));\\n        int ans = INT_MAX;\\n        for(int i =0;i<n;i++)\\n        {\\n            ans = min(ans,solver(0,i,n-1,dp,matrix));\\n        }\\n        return ans;\\n    }\\n};\\nthis is giving me TLE in last test case\\n"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "since the values in the matrix can be both positive and negative, initializing the DP array with -1 might lead to incorrect results since it\\'s a valid value for the sum. You can initialize it to some value that wouldn\\'t conflict with the actual sums. \\n\\nI had initialise dp to 1e9."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Since Memoization giving  TLE on case 49 \nso use this to handle that case and your code will be submitted.\n\n```if(n==100 && matrix[0][0]==0 ) return -1 ; ```\n\nAnyway Tabulation will be accepted  so go for tabulation\n\n```HINT```\n\n"
                    },
                    {
                        "username": "utkarsh_verma",
                        "content": "[@Codensity_30](/Codensity_30)  the constraints range from -100 to +100  now since your dp vector will be filled with -1 imagine it might mess up the results because of the -1 so put INT_MAX in the dp instead it will work then"
                    },
                    {
                        "username": "Codensity_30",
                        "content": "but why? I also suffered for the same, yay tabulation passed it"
                    }
                ]
            },
            {
                "id": 1711243,
                "content": [
                    {
                        "username": "makhotin",
                        "content": "If you're interested where this algo can be applied - please see [wiki page of the algo](https://en.wikipedia.org/wiki/Seam_carving), [video](https://www.youtube.com/watch?v=6NcIJXTlugc) Very cool algorithm for smart image resizing. It compute a vertical seam (path) with lowest energy using DP."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 FAANG\\uD83D\\uDE0E || Recursion, DP - Memoization, Tabulation + Space Optimization\\uD83E\\uDD73\\nhttps://leetcode.com/problems/minimum-falling-path-sum/solutions/3125421/faang-recursion-dp-memoization-tabulation-space-optimization/?orderBy=most_votes"
                    },
                    {
                        "username": "Yongbi",
                        "content": "Thank! It\\'s more excited to know the \"real\" application associated with this exercise."
                    },
                    {
                        "username": "willremember2020",
                        "content": "Why is memoization solution giving tle in 49/50 testcase? But a similar tabulation solution works??"
                    },
                    {
                        "username": "vp271202",
                        "content": "[@ansh_1012](/ansh_1012)  the -1 solution will fail because if there is a case where the sum is -1 then it will give a wrong ans and if the testcase is too large then there is a chance that it will give tle rather than a wrong ans."
                    },
                    {
                        "username": "Gaurav1234Balodi",
                        "content": "[@Sandeep_Rai](/Sandeep_Rai) its simple just read the constraints -100 <= matrix[i][j] <= 100 so you cannot enter -1 it will work even if you memorize 101 "
                    },
                    {
                        "username": "Sandeep_Rai",
                        "content": "[@ansh_1012](/ansh_1012) Yeah that worked but why?"
                    },
                    {
                        "username": "ak_3101",
                        "content": "[@ansh_1012](/ansh_1012) yes, but WHY\\n"
                    },
                    {
                        "username": "azad_6021",
                        "content": "[@ansh_1012](/ansh_1012)  Why\\'s this making a difference"
                    },
                    {
                        "username": "ansh_1012",
                        "content": "[@jatin_vashisht](/jatin_vashisht) memo solutions worked fine for me when i chnges the initialization of dp with INT_MAX rather than -1"
                    },
                    {
                        "username": "jatin_vashisht",
                        "content": "seems like leetcode has tightened the constraints. Bottom Up is getting accepted."
                    },
                    {
                        "username": "amanchandna",
                        "content": "coming up with an recursive solution at first is completely normal."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 FAANG\\uD83D\\uDE0E || Recursion, DP - Memoization, Tabulation + Space Optimization\\uD83E\\uDD73\\nhttps://leetcode.com/problems/minimum-falling-path-sum/solutions/3125421/faang-recursion-dp-memoization-tabulation-space-optimization/?orderBy=most_votes"
                    },
                    {
                        "username": "tdf56f756bg56r8iohgwexu",
                        "content": "[@user3134m](/user3134m) interactive "
                    },
                    {
                        "username": "user3134m",
                        "content": "Is there a better solution than recursion with memorization?"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "This is not a solution Tab we people are posting solution in the discussion session?\\nPlease don\\'t do this.\\nTry to give some tip if possible."
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "We can clearly see that for every element on rows 1 to n, every element is (element + minimum of 3 nodes above it)\\n\\nSo, we just have to perform this O(1) calculation for every element from row 1"
                    },
                    {
                        "username": "utkarshprap",
                        "content": "Thank You Sir for this Hint\\uD83D\\uDE04"
                    },
                    {
                        "username": "priyanshurathaur001",
                        "content": "1 2 3 4 9 8\\n1 2 3 4 9 8\\n1 2 3 4 9 8\\n1 2 3 4 9 8\\n1 2 3 4 9 8\\n9 9 8 7 6 1\\n\\nwhat was the approach for this??\\n"
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "[@joshi22](/joshi22) Its my pleasure I was able to help you\\nYou made me day\\uD83D\\uDE0A"
                    },
                    {
                        "username": "joshi22",
                        "content": "im new to dp and i read this hint and it immediately clicked how to implement it. solved it in 15 mins using dp! thanks :D"
                    },
                    {
                        "username": "beyeu107",
                        "content": "can anyone please explain ! thank you !"
                    },
                    {
                        "username": "kcharris77",
                        "content": "This problem can be solved by breaking it into sub problems. Two ways to do this are starting from the top and working down, or from the bottom and working up. At least for bottom up, the subproblems involve finding the minimum of the three-ish items below an individual item."
                    },
                    {
                        "username": "Indraneel965",
                        "content": "Try recurisively First. try out every first row element and their possibilities."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "[@venubrt](/venubrt) Please don\\'t post any solutions in this discussion tab."
                    },
                    {
                        "username": "denisId",
                        "content": "In order to solve this you have to approach it in 3 main steps:\n>Step 1 is to decompose the problem and to think how to calculate the minimum sum for only one element in the first row\n\nlet's suppose the default example:\n\nMatrix ---\n----------------------\n    2      --  [2, 1, 3] --\n    1      --  [6, 5, 4] --\n    0      --  [7, 8, 9] --\n    --     --  0  1  2  --\n\n\nWe want to find out just the minimum path for one element from first row (let it be for example Matrix[0][1] (\"8\")):\nLet's view all possible paths\n8->6->2\n8->5->2\n8->5->1\n8->5->3\n8->4->3\nIf you observe carefully this is a tree structure, so we basically have to traverse a tree structure\n\nNow the idea is to check the min sum from the descendent nodes(leaves) and bubbling up the sum to the initial root value\n\niteration1) MinValue(6) IS \"2\" (because we don't have other values, 2 + 0)\niteration2) MinValue(5)=\"1\" (because 1 < 2 < 3)\niteration3) MinValue(4)=\"3\" (because we don't have other values, 3 + 0)\ngoing for upper node now:\niteration4) MinValue(8) IS \"14\" (because (8 + MinValue(5)) < (8 + MinValue(6)) < (8 + MinValue(4)))\n\n>Step2: When you find the min sum for only one element, we can just iterate through entire row and take the min value.\n\n>Step3:The problem now is solved, however you will encounter TimeLimit Error with pure recursion on some testcases, it's due to the fact that all subnodes are recalculated multiple times\nThe solution is to use the dynamic programing: add a sort of storage structure/cache structure(HashMap), where you can put values from subnodes and to not recalculate again the sums for visited sites, and at the same time you can get the needed values quickly(in O(1) time)"
                    },
                    {
                        "username": "yug_tyagi",
                        "content": "great expl."
                    },
                    {
                        "username": "ay8182",
                        "content": "[@tulsyanshishir](/tulsyanshishir) yes it is valid\\n"
                    },
                    {
                        "username": "romanvkj2001",
                        "content": "[@tulsyanshishir](/tulsyanshishir) and also 8->4->1?\\n"
                    },
                    {
                        "username": "tulsyanshishir",
                        "content": "May be I did not understand this properly. Is the path 8->6->1 not valid ?"
                    },
                    {
                        "username": "Sohamkayal4103",
                        "content": "Some problems are better solved by tabulation instead of memoization. Choose the methods wisely while attempting any contests. "
                    },
                    {
                        "username": "aman_0_1_2",
                        "content": "[@gaurav_rawat369](/gaurav_rawat369) intilise vector<vector>dp(n+1,vector(n+1,-1)); as vector<vector>dp(n+1,vector(n+1,int_max)); it works fine but i am also getting tle if i set my dp -1 . can anyone explain why ?"
                    },
                    {
                        "username": "gaurav_rawat369",
                        "content": "class Solution {\\nprivate:\\n    int solver(int i ,int j,int n,vector<vector<int>>&dp,vector<vector<int>>&matrix)\\n    {\\n        if(i > n || j < 0 || j > n)\\n        return 1e9;\\n        if(i == n)\\n        return matrix[i][j];\\n        if(dp[i][j] != -1)\\n        return dp[i][j];\\n        return dp[i][j] = matrix[i][j] + min(solver(i+1,j-1,n,dp,matrix),min(solver(i+1,j,n,dp,matrix),solver(i+1,j+1,n,dp,matrix)));\\n    }\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        vector<vector<int>>dp(n+1,vector<int>(n+1,-1));\\n        int ans = INT_MAX;\\n        for(int i =0;i<n;i++)\\n        {\\n            ans = min(ans,solver(0,i,n-1,dp,matrix));\\n        }\\n        return ans;\\n    }\\n};\\nthis is giving me TLE in last test case\\n"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "since the values in the matrix can be both positive and negative, initializing the DP array with -1 might lead to incorrect results since it\\'s a valid value for the sum. You can initialize it to some value that wouldn\\'t conflict with the actual sums. \\n\\nI had initialise dp to 1e9."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Since Memoization giving  TLE on case 49 \nso use this to handle that case and your code will be submitted.\n\n```if(n==100 && matrix[0][0]==0 ) return -1 ; ```\n\nAnyway Tabulation will be accepted  so go for tabulation\n\n```HINT```\n\n"
                    },
                    {
                        "username": "utkarsh_verma",
                        "content": "[@Codensity_30](/Codensity_30)  the constraints range from -100 to +100  now since your dp vector will be filled with -1 imagine it might mess up the results because of the -1 so put INT_MAX in the dp instead it will work then"
                    },
                    {
                        "username": "Codensity_30",
                        "content": "but why? I also suffered for the same, yay tabulation passed it"
                    }
                ]
            },
            {
                "id": 1714687,
                "content": [
                    {
                        "username": "makhotin",
                        "content": "If you're interested where this algo can be applied - please see [wiki page of the algo](https://en.wikipedia.org/wiki/Seam_carving), [video](https://www.youtube.com/watch?v=6NcIJXTlugc) Very cool algorithm for smart image resizing. It compute a vertical seam (path) with lowest energy using DP."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 FAANG\\uD83D\\uDE0E || Recursion, DP - Memoization, Tabulation + Space Optimization\\uD83E\\uDD73\\nhttps://leetcode.com/problems/minimum-falling-path-sum/solutions/3125421/faang-recursion-dp-memoization-tabulation-space-optimization/?orderBy=most_votes"
                    },
                    {
                        "username": "Yongbi",
                        "content": "Thank! It\\'s more excited to know the \"real\" application associated with this exercise."
                    },
                    {
                        "username": "willremember2020",
                        "content": "Why is memoization solution giving tle in 49/50 testcase? But a similar tabulation solution works??"
                    },
                    {
                        "username": "vp271202",
                        "content": "[@ansh_1012](/ansh_1012)  the -1 solution will fail because if there is a case where the sum is -1 then it will give a wrong ans and if the testcase is too large then there is a chance that it will give tle rather than a wrong ans."
                    },
                    {
                        "username": "Gaurav1234Balodi",
                        "content": "[@Sandeep_Rai](/Sandeep_Rai) its simple just read the constraints -100 <= matrix[i][j] <= 100 so you cannot enter -1 it will work even if you memorize 101 "
                    },
                    {
                        "username": "Sandeep_Rai",
                        "content": "[@ansh_1012](/ansh_1012) Yeah that worked but why?"
                    },
                    {
                        "username": "ak_3101",
                        "content": "[@ansh_1012](/ansh_1012) yes, but WHY\\n"
                    },
                    {
                        "username": "azad_6021",
                        "content": "[@ansh_1012](/ansh_1012)  Why\\'s this making a difference"
                    },
                    {
                        "username": "ansh_1012",
                        "content": "[@jatin_vashisht](/jatin_vashisht) memo solutions worked fine for me when i chnges the initialization of dp with INT_MAX rather than -1"
                    },
                    {
                        "username": "jatin_vashisht",
                        "content": "seems like leetcode has tightened the constraints. Bottom Up is getting accepted."
                    },
                    {
                        "username": "amanchandna",
                        "content": "coming up with an recursive solution at first is completely normal."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 FAANG\\uD83D\\uDE0E || Recursion, DP - Memoization, Tabulation + Space Optimization\\uD83E\\uDD73\\nhttps://leetcode.com/problems/minimum-falling-path-sum/solutions/3125421/faang-recursion-dp-memoization-tabulation-space-optimization/?orderBy=most_votes"
                    },
                    {
                        "username": "tdf56f756bg56r8iohgwexu",
                        "content": "[@user3134m](/user3134m) interactive "
                    },
                    {
                        "username": "user3134m",
                        "content": "Is there a better solution than recursion with memorization?"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "This is not a solution Tab we people are posting solution in the discussion session?\\nPlease don\\'t do this.\\nTry to give some tip if possible."
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "We can clearly see that for every element on rows 1 to n, every element is (element + minimum of 3 nodes above it)\\n\\nSo, we just have to perform this O(1) calculation for every element from row 1"
                    },
                    {
                        "username": "utkarshprap",
                        "content": "Thank You Sir for this Hint\\uD83D\\uDE04"
                    },
                    {
                        "username": "priyanshurathaur001",
                        "content": "1 2 3 4 9 8\\n1 2 3 4 9 8\\n1 2 3 4 9 8\\n1 2 3 4 9 8\\n1 2 3 4 9 8\\n9 9 8 7 6 1\\n\\nwhat was the approach for this??\\n"
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "[@joshi22](/joshi22) Its my pleasure I was able to help you\\nYou made me day\\uD83D\\uDE0A"
                    },
                    {
                        "username": "joshi22",
                        "content": "im new to dp and i read this hint and it immediately clicked how to implement it. solved it in 15 mins using dp! thanks :D"
                    },
                    {
                        "username": "beyeu107",
                        "content": "can anyone please explain ! thank you !"
                    },
                    {
                        "username": "kcharris77",
                        "content": "This problem can be solved by breaking it into sub problems. Two ways to do this are starting from the top and working down, or from the bottom and working up. At least for bottom up, the subproblems involve finding the minimum of the three-ish items below an individual item."
                    },
                    {
                        "username": "Indraneel965",
                        "content": "Try recurisively First. try out every first row element and their possibilities."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "[@venubrt](/venubrt) Please don\\'t post any solutions in this discussion tab."
                    },
                    {
                        "username": "denisId",
                        "content": "In order to solve this you have to approach it in 3 main steps:\n>Step 1 is to decompose the problem and to think how to calculate the minimum sum for only one element in the first row\n\nlet's suppose the default example:\n\nMatrix ---\n----------------------\n    2      --  [2, 1, 3] --\n    1      --  [6, 5, 4] --\n    0      --  [7, 8, 9] --\n    --     --  0  1  2  --\n\n\nWe want to find out just the minimum path for one element from first row (let it be for example Matrix[0][1] (\"8\")):\nLet's view all possible paths\n8->6->2\n8->5->2\n8->5->1\n8->5->3\n8->4->3\nIf you observe carefully this is a tree structure, so we basically have to traverse a tree structure\n\nNow the idea is to check the min sum from the descendent nodes(leaves) and bubbling up the sum to the initial root value\n\niteration1) MinValue(6) IS \"2\" (because we don't have other values, 2 + 0)\niteration2) MinValue(5)=\"1\" (because 1 < 2 < 3)\niteration3) MinValue(4)=\"3\" (because we don't have other values, 3 + 0)\ngoing for upper node now:\niteration4) MinValue(8) IS \"14\" (because (8 + MinValue(5)) < (8 + MinValue(6)) < (8 + MinValue(4)))\n\n>Step2: When you find the min sum for only one element, we can just iterate through entire row and take the min value.\n\n>Step3:The problem now is solved, however you will encounter TimeLimit Error with pure recursion on some testcases, it's due to the fact that all subnodes are recalculated multiple times\nThe solution is to use the dynamic programing: add a sort of storage structure/cache structure(HashMap), where you can put values from subnodes and to not recalculate again the sums for visited sites, and at the same time you can get the needed values quickly(in O(1) time)"
                    },
                    {
                        "username": "yug_tyagi",
                        "content": "great expl."
                    },
                    {
                        "username": "ay8182",
                        "content": "[@tulsyanshishir](/tulsyanshishir) yes it is valid\\n"
                    },
                    {
                        "username": "romanvkj2001",
                        "content": "[@tulsyanshishir](/tulsyanshishir) and also 8->4->1?\\n"
                    },
                    {
                        "username": "tulsyanshishir",
                        "content": "May be I did not understand this properly. Is the path 8->6->1 not valid ?"
                    },
                    {
                        "username": "Sohamkayal4103",
                        "content": "Some problems are better solved by tabulation instead of memoization. Choose the methods wisely while attempting any contests. "
                    },
                    {
                        "username": "aman_0_1_2",
                        "content": "[@gaurav_rawat369](/gaurav_rawat369) intilise vector<vector>dp(n+1,vector(n+1,-1)); as vector<vector>dp(n+1,vector(n+1,int_max)); it works fine but i am also getting tle if i set my dp -1 . can anyone explain why ?"
                    },
                    {
                        "username": "gaurav_rawat369",
                        "content": "class Solution {\\nprivate:\\n    int solver(int i ,int j,int n,vector<vector<int>>&dp,vector<vector<int>>&matrix)\\n    {\\n        if(i > n || j < 0 || j > n)\\n        return 1e9;\\n        if(i == n)\\n        return matrix[i][j];\\n        if(dp[i][j] != -1)\\n        return dp[i][j];\\n        return dp[i][j] = matrix[i][j] + min(solver(i+1,j-1,n,dp,matrix),min(solver(i+1,j,n,dp,matrix),solver(i+1,j+1,n,dp,matrix)));\\n    }\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        vector<vector<int>>dp(n+1,vector<int>(n+1,-1));\\n        int ans = INT_MAX;\\n        for(int i =0;i<n;i++)\\n        {\\n            ans = min(ans,solver(0,i,n-1,dp,matrix));\\n        }\\n        return ans;\\n    }\\n};\\nthis is giving me TLE in last test case\\n"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "since the values in the matrix can be both positive and negative, initializing the DP array with -1 might lead to incorrect results since it\\'s a valid value for the sum. You can initialize it to some value that wouldn\\'t conflict with the actual sums. \\n\\nI had initialise dp to 1e9."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Since Memoization giving  TLE on case 49 \nso use this to handle that case and your code will be submitted.\n\n```if(n==100 && matrix[0][0]==0 ) return -1 ; ```\n\nAnyway Tabulation will be accepted  so go for tabulation\n\n```HINT```\n\n"
                    },
                    {
                        "username": "utkarsh_verma",
                        "content": "[@Codensity_30](/Codensity_30)  the constraints range from -100 to +100  now since your dp vector will be filled with -1 imagine it might mess up the results because of the -1 so put INT_MAX in the dp instead it will work then"
                    },
                    {
                        "username": "Codensity_30",
                        "content": "but why? I also suffered for the same, yay tabulation passed it"
                    }
                ]
            },
            {
                "id": 2036656,
                "content": [
                    {
                        "username": "makhotin",
                        "content": "If you're interested where this algo can be applied - please see [wiki page of the algo](https://en.wikipedia.org/wiki/Seam_carving), [video](https://www.youtube.com/watch?v=6NcIJXTlugc) Very cool algorithm for smart image resizing. It compute a vertical seam (path) with lowest energy using DP."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 FAANG\\uD83D\\uDE0E || Recursion, DP - Memoization, Tabulation + Space Optimization\\uD83E\\uDD73\\nhttps://leetcode.com/problems/minimum-falling-path-sum/solutions/3125421/faang-recursion-dp-memoization-tabulation-space-optimization/?orderBy=most_votes"
                    },
                    {
                        "username": "Yongbi",
                        "content": "Thank! It\\'s more excited to know the \"real\" application associated with this exercise."
                    },
                    {
                        "username": "willremember2020",
                        "content": "Why is memoization solution giving tle in 49/50 testcase? But a similar tabulation solution works??"
                    },
                    {
                        "username": "vp271202",
                        "content": "[@ansh_1012](/ansh_1012)  the -1 solution will fail because if there is a case where the sum is -1 then it will give a wrong ans and if the testcase is too large then there is a chance that it will give tle rather than a wrong ans."
                    },
                    {
                        "username": "Gaurav1234Balodi",
                        "content": "[@Sandeep_Rai](/Sandeep_Rai) its simple just read the constraints -100 <= matrix[i][j] <= 100 so you cannot enter -1 it will work even if you memorize 101 "
                    },
                    {
                        "username": "Sandeep_Rai",
                        "content": "[@ansh_1012](/ansh_1012) Yeah that worked but why?"
                    },
                    {
                        "username": "ak_3101",
                        "content": "[@ansh_1012](/ansh_1012) yes, but WHY\\n"
                    },
                    {
                        "username": "azad_6021",
                        "content": "[@ansh_1012](/ansh_1012)  Why\\'s this making a difference"
                    },
                    {
                        "username": "ansh_1012",
                        "content": "[@jatin_vashisht](/jatin_vashisht) memo solutions worked fine for me when i chnges the initialization of dp with INT_MAX rather than -1"
                    },
                    {
                        "username": "jatin_vashisht",
                        "content": "seems like leetcode has tightened the constraints. Bottom Up is getting accepted."
                    },
                    {
                        "username": "amanchandna",
                        "content": "coming up with an recursive solution at first is completely normal."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 FAANG\\uD83D\\uDE0E || Recursion, DP - Memoization, Tabulation + Space Optimization\\uD83E\\uDD73\\nhttps://leetcode.com/problems/minimum-falling-path-sum/solutions/3125421/faang-recursion-dp-memoization-tabulation-space-optimization/?orderBy=most_votes"
                    },
                    {
                        "username": "tdf56f756bg56r8iohgwexu",
                        "content": "[@user3134m](/user3134m) interactive "
                    },
                    {
                        "username": "user3134m",
                        "content": "Is there a better solution than recursion with memorization?"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "This is not a solution Tab we people are posting solution in the discussion session?\\nPlease don\\'t do this.\\nTry to give some tip if possible."
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "We can clearly see that for every element on rows 1 to n, every element is (element + minimum of 3 nodes above it)\\n\\nSo, we just have to perform this O(1) calculation for every element from row 1"
                    },
                    {
                        "username": "utkarshprap",
                        "content": "Thank You Sir for this Hint\\uD83D\\uDE04"
                    },
                    {
                        "username": "priyanshurathaur001",
                        "content": "1 2 3 4 9 8\\n1 2 3 4 9 8\\n1 2 3 4 9 8\\n1 2 3 4 9 8\\n1 2 3 4 9 8\\n9 9 8 7 6 1\\n\\nwhat was the approach for this??\\n"
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "[@joshi22](/joshi22) Its my pleasure I was able to help you\\nYou made me day\\uD83D\\uDE0A"
                    },
                    {
                        "username": "joshi22",
                        "content": "im new to dp and i read this hint and it immediately clicked how to implement it. solved it in 15 mins using dp! thanks :D"
                    },
                    {
                        "username": "beyeu107",
                        "content": "can anyone please explain ! thank you !"
                    },
                    {
                        "username": "kcharris77",
                        "content": "This problem can be solved by breaking it into sub problems. Two ways to do this are starting from the top and working down, or from the bottom and working up. At least for bottom up, the subproblems involve finding the minimum of the three-ish items below an individual item."
                    },
                    {
                        "username": "Indraneel965",
                        "content": "Try recurisively First. try out every first row element and their possibilities."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "[@venubrt](/venubrt) Please don\\'t post any solutions in this discussion tab."
                    },
                    {
                        "username": "denisId",
                        "content": "In order to solve this you have to approach it in 3 main steps:\n>Step 1 is to decompose the problem and to think how to calculate the minimum sum for only one element in the first row\n\nlet's suppose the default example:\n\nMatrix ---\n----------------------\n    2      --  [2, 1, 3] --\n    1      --  [6, 5, 4] --\n    0      --  [7, 8, 9] --\n    --     --  0  1  2  --\n\n\nWe want to find out just the minimum path for one element from first row (let it be for example Matrix[0][1] (\"8\")):\nLet's view all possible paths\n8->6->2\n8->5->2\n8->5->1\n8->5->3\n8->4->3\nIf you observe carefully this is a tree structure, so we basically have to traverse a tree structure\n\nNow the idea is to check the min sum from the descendent nodes(leaves) and bubbling up the sum to the initial root value\n\niteration1) MinValue(6) IS \"2\" (because we don't have other values, 2 + 0)\niteration2) MinValue(5)=\"1\" (because 1 < 2 < 3)\niteration3) MinValue(4)=\"3\" (because we don't have other values, 3 + 0)\ngoing for upper node now:\niteration4) MinValue(8) IS \"14\" (because (8 + MinValue(5)) < (8 + MinValue(6)) < (8 + MinValue(4)))\n\n>Step2: When you find the min sum for only one element, we can just iterate through entire row and take the min value.\n\n>Step3:The problem now is solved, however you will encounter TimeLimit Error with pure recursion on some testcases, it's due to the fact that all subnodes are recalculated multiple times\nThe solution is to use the dynamic programing: add a sort of storage structure/cache structure(HashMap), where you can put values from subnodes and to not recalculate again the sums for visited sites, and at the same time you can get the needed values quickly(in O(1) time)"
                    },
                    {
                        "username": "yug_tyagi",
                        "content": "great expl."
                    },
                    {
                        "username": "ay8182",
                        "content": "[@tulsyanshishir](/tulsyanshishir) yes it is valid\\n"
                    },
                    {
                        "username": "romanvkj2001",
                        "content": "[@tulsyanshishir](/tulsyanshishir) and also 8->4->1?\\n"
                    },
                    {
                        "username": "tulsyanshishir",
                        "content": "May be I did not understand this properly. Is the path 8->6->1 not valid ?"
                    },
                    {
                        "username": "Sohamkayal4103",
                        "content": "Some problems are better solved by tabulation instead of memoization. Choose the methods wisely while attempting any contests. "
                    },
                    {
                        "username": "aman_0_1_2",
                        "content": "[@gaurav_rawat369](/gaurav_rawat369) intilise vector<vector>dp(n+1,vector(n+1,-1)); as vector<vector>dp(n+1,vector(n+1,int_max)); it works fine but i am also getting tle if i set my dp -1 . can anyone explain why ?"
                    },
                    {
                        "username": "gaurav_rawat369",
                        "content": "class Solution {\\nprivate:\\n    int solver(int i ,int j,int n,vector<vector<int>>&dp,vector<vector<int>>&matrix)\\n    {\\n        if(i > n || j < 0 || j > n)\\n        return 1e9;\\n        if(i == n)\\n        return matrix[i][j];\\n        if(dp[i][j] != -1)\\n        return dp[i][j];\\n        return dp[i][j] = matrix[i][j] + min(solver(i+1,j-1,n,dp,matrix),min(solver(i+1,j,n,dp,matrix),solver(i+1,j+1,n,dp,matrix)));\\n    }\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        vector<vector<int>>dp(n+1,vector<int>(n+1,-1));\\n        int ans = INT_MAX;\\n        for(int i =0;i<n;i++)\\n        {\\n            ans = min(ans,solver(0,i,n-1,dp,matrix));\\n        }\\n        return ans;\\n    }\\n};\\nthis is giving me TLE in last test case\\n"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "since the values in the matrix can be both positive and negative, initializing the DP array with -1 might lead to incorrect results since it\\'s a valid value for the sum. You can initialize it to some value that wouldn\\'t conflict with the actual sums. \\n\\nI had initialise dp to 1e9."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Since Memoization giving  TLE on case 49 \nso use this to handle that case and your code will be submitted.\n\n```if(n==100 && matrix[0][0]==0 ) return -1 ; ```\n\nAnyway Tabulation will be accepted  so go for tabulation\n\n```HINT```\n\n"
                    },
                    {
                        "username": "utkarsh_verma",
                        "content": "[@Codensity_30](/Codensity_30)  the constraints range from -100 to +100  now since your dp vector will be filled with -1 imagine it might mess up the results because of the -1 so put INT_MAX in the dp instead it will work then"
                    },
                    {
                        "username": "Codensity_30",
                        "content": "but why? I also suffered for the same, yay tabulation passed it"
                    }
                ]
            },
            {
                "id": 1953599,
                "content": [
                    {
                        "username": "makhotin",
                        "content": "If you're interested where this algo can be applied - please see [wiki page of the algo](https://en.wikipedia.org/wiki/Seam_carving), [video](https://www.youtube.com/watch?v=6NcIJXTlugc) Very cool algorithm for smart image resizing. It compute a vertical seam (path) with lowest energy using DP."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 FAANG\\uD83D\\uDE0E || Recursion, DP - Memoization, Tabulation + Space Optimization\\uD83E\\uDD73\\nhttps://leetcode.com/problems/minimum-falling-path-sum/solutions/3125421/faang-recursion-dp-memoization-tabulation-space-optimization/?orderBy=most_votes"
                    },
                    {
                        "username": "Yongbi",
                        "content": "Thank! It\\'s more excited to know the \"real\" application associated with this exercise."
                    },
                    {
                        "username": "willremember2020",
                        "content": "Why is memoization solution giving tle in 49/50 testcase? But a similar tabulation solution works??"
                    },
                    {
                        "username": "vp271202",
                        "content": "[@ansh_1012](/ansh_1012)  the -1 solution will fail because if there is a case where the sum is -1 then it will give a wrong ans and if the testcase is too large then there is a chance that it will give tle rather than a wrong ans."
                    },
                    {
                        "username": "Gaurav1234Balodi",
                        "content": "[@Sandeep_Rai](/Sandeep_Rai) its simple just read the constraints -100 <= matrix[i][j] <= 100 so you cannot enter -1 it will work even if you memorize 101 "
                    },
                    {
                        "username": "Sandeep_Rai",
                        "content": "[@ansh_1012](/ansh_1012) Yeah that worked but why?"
                    },
                    {
                        "username": "ak_3101",
                        "content": "[@ansh_1012](/ansh_1012) yes, but WHY\\n"
                    },
                    {
                        "username": "azad_6021",
                        "content": "[@ansh_1012](/ansh_1012)  Why\\'s this making a difference"
                    },
                    {
                        "username": "ansh_1012",
                        "content": "[@jatin_vashisht](/jatin_vashisht) memo solutions worked fine for me when i chnges the initialization of dp with INT_MAX rather than -1"
                    },
                    {
                        "username": "jatin_vashisht",
                        "content": "seems like leetcode has tightened the constraints. Bottom Up is getting accepted."
                    },
                    {
                        "username": "amanchandna",
                        "content": "coming up with an recursive solution at first is completely normal."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 FAANG\\uD83D\\uDE0E || Recursion, DP - Memoization, Tabulation + Space Optimization\\uD83E\\uDD73\\nhttps://leetcode.com/problems/minimum-falling-path-sum/solutions/3125421/faang-recursion-dp-memoization-tabulation-space-optimization/?orderBy=most_votes"
                    },
                    {
                        "username": "tdf56f756bg56r8iohgwexu",
                        "content": "[@user3134m](/user3134m) interactive "
                    },
                    {
                        "username": "user3134m",
                        "content": "Is there a better solution than recursion with memorization?"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "This is not a solution Tab we people are posting solution in the discussion session?\\nPlease don\\'t do this.\\nTry to give some tip if possible."
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "We can clearly see that for every element on rows 1 to n, every element is (element + minimum of 3 nodes above it)\\n\\nSo, we just have to perform this O(1) calculation for every element from row 1"
                    },
                    {
                        "username": "utkarshprap",
                        "content": "Thank You Sir for this Hint\\uD83D\\uDE04"
                    },
                    {
                        "username": "priyanshurathaur001",
                        "content": "1 2 3 4 9 8\\n1 2 3 4 9 8\\n1 2 3 4 9 8\\n1 2 3 4 9 8\\n1 2 3 4 9 8\\n9 9 8 7 6 1\\n\\nwhat was the approach for this??\\n"
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "[@joshi22](/joshi22) Its my pleasure I was able to help you\\nYou made me day\\uD83D\\uDE0A"
                    },
                    {
                        "username": "joshi22",
                        "content": "im new to dp and i read this hint and it immediately clicked how to implement it. solved it in 15 mins using dp! thanks :D"
                    },
                    {
                        "username": "beyeu107",
                        "content": "can anyone please explain ! thank you !"
                    },
                    {
                        "username": "kcharris77",
                        "content": "This problem can be solved by breaking it into sub problems. Two ways to do this are starting from the top and working down, or from the bottom and working up. At least for bottom up, the subproblems involve finding the minimum of the three-ish items below an individual item."
                    },
                    {
                        "username": "Indraneel965",
                        "content": "Try recurisively First. try out every first row element and their possibilities."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "[@venubrt](/venubrt) Please don\\'t post any solutions in this discussion tab."
                    },
                    {
                        "username": "denisId",
                        "content": "In order to solve this you have to approach it in 3 main steps:\n>Step 1 is to decompose the problem and to think how to calculate the minimum sum for only one element in the first row\n\nlet's suppose the default example:\n\nMatrix ---\n----------------------\n    2      --  [2, 1, 3] --\n    1      --  [6, 5, 4] --\n    0      --  [7, 8, 9] --\n    --     --  0  1  2  --\n\n\nWe want to find out just the minimum path for one element from first row (let it be for example Matrix[0][1] (\"8\")):\nLet's view all possible paths\n8->6->2\n8->5->2\n8->5->1\n8->5->3\n8->4->3\nIf you observe carefully this is a tree structure, so we basically have to traverse a tree structure\n\nNow the idea is to check the min sum from the descendent nodes(leaves) and bubbling up the sum to the initial root value\n\niteration1) MinValue(6) IS \"2\" (because we don't have other values, 2 + 0)\niteration2) MinValue(5)=\"1\" (because 1 < 2 < 3)\niteration3) MinValue(4)=\"3\" (because we don't have other values, 3 + 0)\ngoing for upper node now:\niteration4) MinValue(8) IS \"14\" (because (8 + MinValue(5)) < (8 + MinValue(6)) < (8 + MinValue(4)))\n\n>Step2: When you find the min sum for only one element, we can just iterate through entire row and take the min value.\n\n>Step3:The problem now is solved, however you will encounter TimeLimit Error with pure recursion on some testcases, it's due to the fact that all subnodes are recalculated multiple times\nThe solution is to use the dynamic programing: add a sort of storage structure/cache structure(HashMap), where you can put values from subnodes and to not recalculate again the sums for visited sites, and at the same time you can get the needed values quickly(in O(1) time)"
                    },
                    {
                        "username": "yug_tyagi",
                        "content": "great expl."
                    },
                    {
                        "username": "ay8182",
                        "content": "[@tulsyanshishir](/tulsyanshishir) yes it is valid\\n"
                    },
                    {
                        "username": "romanvkj2001",
                        "content": "[@tulsyanshishir](/tulsyanshishir) and also 8->4->1?\\n"
                    },
                    {
                        "username": "tulsyanshishir",
                        "content": "May be I did not understand this properly. Is the path 8->6->1 not valid ?"
                    },
                    {
                        "username": "Sohamkayal4103",
                        "content": "Some problems are better solved by tabulation instead of memoization. Choose the methods wisely while attempting any contests. "
                    },
                    {
                        "username": "aman_0_1_2",
                        "content": "[@gaurav_rawat369](/gaurav_rawat369) intilise vector<vector>dp(n+1,vector(n+1,-1)); as vector<vector>dp(n+1,vector(n+1,int_max)); it works fine but i am also getting tle if i set my dp -1 . can anyone explain why ?"
                    },
                    {
                        "username": "gaurav_rawat369",
                        "content": "class Solution {\\nprivate:\\n    int solver(int i ,int j,int n,vector<vector<int>>&dp,vector<vector<int>>&matrix)\\n    {\\n        if(i > n || j < 0 || j > n)\\n        return 1e9;\\n        if(i == n)\\n        return matrix[i][j];\\n        if(dp[i][j] != -1)\\n        return dp[i][j];\\n        return dp[i][j] = matrix[i][j] + min(solver(i+1,j-1,n,dp,matrix),min(solver(i+1,j,n,dp,matrix),solver(i+1,j+1,n,dp,matrix)));\\n    }\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        vector<vector<int>>dp(n+1,vector<int>(n+1,-1));\\n        int ans = INT_MAX;\\n        for(int i =0;i<n;i++)\\n        {\\n            ans = min(ans,solver(0,i,n-1,dp,matrix));\\n        }\\n        return ans;\\n    }\\n};\\nthis is giving me TLE in last test case\\n"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "since the values in the matrix can be both positive and negative, initializing the DP array with -1 might lead to incorrect results since it\\'s a valid value for the sum. You can initialize it to some value that wouldn\\'t conflict with the actual sums. \\n\\nI had initialise dp to 1e9."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Since Memoization giving  TLE on case 49 \nso use this to handle that case and your code will be submitted.\n\n```if(n==100 && matrix[0][0]==0 ) return -1 ; ```\n\nAnyway Tabulation will be accepted  so go for tabulation\n\n```HINT```\n\n"
                    },
                    {
                        "username": "utkarsh_verma",
                        "content": "[@Codensity_30](/Codensity_30)  the constraints range from -100 to +100  now since your dp vector will be filled with -1 imagine it might mess up the results because of the -1 so put INT_MAX in the dp instead it will work then"
                    },
                    {
                        "username": "Codensity_30",
                        "content": "but why? I also suffered for the same, yay tabulation passed it"
                    }
                ]
            },
            {
                "id": 1950593,
                "content": [
                    {
                        "username": "akku18tiwari",
                        "content": "```\\nclass Solution\\n{\\n    public:\\n\\n       \\t// f(i, j) ->  i, j => n - 1 row\\n        int f(int i, int j, vector<vector < int>> &v, vector< vector< int>> &dp)\\n        {\\n            if (j < 0 || j >= v.size()) return 1e9;\\n            if (i == (v.size() - 1)) return v[v.size() - 1][j];\\n            if (dp[i][j] != -1) return dp[i][j];\\n\\n            int l = v[i][j] + f(i + 1, j - 1, v, dp);\\n            int d = v[i][j] + f(i + 1, j, v, dp);\\n            int r = v[i][j] + f(i + 1, j + 1, v, dp);\\n\\n            return dp[i][j] = min(l, min(d, r));\\n        }\\n    int minFallingPathSum(vector<vector < int>> &v)\\n    {\\n        int mn = 1e9;\\n        int n = v.size();\\n        vector<vector < int>> dp(n + 1, vector<int> (n + 1, -1));\\n        for (int i = 0; i < n; i++)\\n        {\\n            mn = min(mn, f(0, i, v, dp));\\n        }\\n\\n        return mn;\\n    }\\n};\\n\\n```\\nCAN SOMEONE PLEASE TELL WHAT IS WRONG IN THIS CODE, ITS GIVING TLE FOR 49TH/50 TESTCASE"
                    },
                    {
                        "username": "shivam_0344",
                        "content": "intialise dp vector with a value less than -100 rather than -1, because of given constraints(-100 <= matrix[i][j] <= 100)\n"
                    },
                    {
                        "username": "aman2k1",
                        "content": "Is memoized solution giving TLE?"
                    },
                    {
                        "username": "dhruvpatidar35",
                        "content": "use hashmap instead , it will work"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "[@crash_landing_wheee](/crash_landing_wheee)  \n```if(n==100 && matrix[0][0]==0 ) return -1 ;```\nuse this for case 49 it will be accepted otherwise go for Tabulation\n"
                    },
                    {
                        "username": "crash_landing_wheee",
                        "content": "Yep"
                    },
                    {
                        "username": "Blebot",
                        "content": "Last Test Case doesn\\'t seem to be working with memoization. Anyone faced this issue?"
                    },
                    {
                        "username": "ay8182",
                        "content": "Yeah idk about this solution but memoization isn\\'t working. It\\'s giving TLE kindly use tabulation method to solve this\\n"
                    },
                    {
                        "username": "s1ttu",
                        "content": "just iterate through the matrix from matrix[1] excluding the first row because we can simply calculate it in the matrix[1] and on words for matrix[i][j] we have 3 paths from where we can came to this index i, j as it is stated in the question that we have to find the minimum path form top the bottom (i.e. matrix[0] to matrix[-1])\\nso we take the minimum path for all possible matrix[i][j] and add the value of matrix[i][j] to it \\n``` matrix[i][j] += min(matrix[i-1][j], matrix[i-1][j-1], matrix[i-1][j+1]```\\nkeep in mind for the corner cases where ```j == 0 or j == len(matrix[0])-1``` in these two we only have the 2 possible paths "
                    },
                    {
                        "username": "Mustafa_Qassmieh",
                        "content": "[[100,-42,-46,-41],[31,97,10,-10],[-58,-51,82,89],[51,81,69,-51]]\nhow is this -36 not -25\n-46 >> -10 >> 82>> -51 = -25\nwhat am i missing\nhere is a block build for clarification\n[100,  -42,    -46,  -41]\n[31,    97,     10,      -10]\n[-58,  -51,    82,     89]\n[51,     81      69,      -51]"
                    },
                    {
                        "username": "jevita279",
                        "content": "[@pepijnvdliefvoort](/pepijnvdliefvoort) because we want the minimum sum overall. If we pick -10, we have only 82 n 89 for next pick which will lead to a bigger sum."
                    },
                    {
                        "username": "pepijnvdliefvoort",
                        "content": "[@jevita279](/jevita279) Why is 10 chosen over -10?"
                    },
                    {
                        "username": "jevita279",
                        "content": "-46->10->-51->51 == -36\\n"
                    },
                    {
                        "username": "Sumnoon",
                        "content": "Can anyone tell why we should start from last row? I have tried solving it from row = 0 but it gives wrong answer for test cases. But starting from bottom i.e. row = n - 1 it got accepted."
                    },
                    {
                        "username": "mdAzhar",
                        "content": "No you don\\'t need to start from bottom.\\nStart from row 1, then for each col add the min from previous row and [col-1, col, col+1]. At the end return the min from bottom row"
                    },
                    {
                        "username": "Zhe_FunCoding",
                        "content": "Tips:\\n- Take the waterfall approach, build up one row at a time.\\n- x[i][j] is minimum of itself plus three numbers above it respectively.\\n\\nGood luck."
                    },
                    {
                        "username": "dhakad22klx",
                        "content": "Thanks got it.I was getting TLE because i was passing matrix without reference "
                    },
                    {
                        "username": "dhakad22klx",
                        "content": "It is TLE at 44. I have tried."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 FAANG\\uD83D\\uDE0E || Recursion, DP - Memoization, Tabulation + Space Optimization\\uD83E\\uDD73\\nhttps://leetcode.com/problems/minimum-falling-path-sum/solutions/3125421/faang-recursion-dp-memoization-tabulation-space-optimization/?orderBy=most_votes"
                    },
                    {
                        "username": "sanjay1305",
                        "content": "JAVA Solution || DP:\\n# Code\\n```\\nclass Solution {\\n    public int minFallingPathSum(int[][] matrix) {\\n       int dp[][] = new int[matrix.length][matrix.length];\\n        int min = Integer.MAX_VALUE;\\n        for(int i=0;i<matrix.length;i++){\\n            dp[0][i]=matrix[0][i];\\n        }\\n        for(int i=1;i<matrix.length;i++){\\n            for(int j=0;j<matrix.length;j++){\\n                if(j==0){\\n                    dp[i][j]=matrix[i][j]+Math.min(dp[i-1][j],dp[i-1][j+1]);\\n                }\\n                else if(j==matrix.length-1){\\n                    dp[i][j]=matrix[i][j]+Math.min(dp[i-1][j],dp[i-1][j-1]);\\n                }\\n                else{\\n                    dp[i][j]=matrix[i][j]+ Math.min(Math.min(dp[i-1][j-1], dp[i-1][j]), dp[i-1][j+1]);\\n                }\\n\\n            }\\n        }\\n        for(int i=0;i<matrix.length;i++){\\n            if(dp[matrix.length-1][i]<min) min=dp[matrix.length-1][i];\\n        }\\n     return min;\\n    }\\n}\\n```\\n"
                    },
                    {
                        "username": "himaniac",
                        "content": "please don\\'t put your solutions under discussions\\n"
                    },
                    {
                        "username": "saxenaaashi90",
                        "content": "[[-19,-57],[-40,-5]] \\nHow is answer -97 for this?"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "-57 ,-40 so it -97 minimum is -97"
                    }
                ]
            },
            {
                "id": 1944211,
                "content": [
                    {
                        "username": "akku18tiwari",
                        "content": "```\\nclass Solution\\n{\\n    public:\\n\\n       \\t// f(i, j) ->  i, j => n - 1 row\\n        int f(int i, int j, vector<vector < int>> &v, vector< vector< int>> &dp)\\n        {\\n            if (j < 0 || j >= v.size()) return 1e9;\\n            if (i == (v.size() - 1)) return v[v.size() - 1][j];\\n            if (dp[i][j] != -1) return dp[i][j];\\n\\n            int l = v[i][j] + f(i + 1, j - 1, v, dp);\\n            int d = v[i][j] + f(i + 1, j, v, dp);\\n            int r = v[i][j] + f(i + 1, j + 1, v, dp);\\n\\n            return dp[i][j] = min(l, min(d, r));\\n        }\\n    int minFallingPathSum(vector<vector < int>> &v)\\n    {\\n        int mn = 1e9;\\n        int n = v.size();\\n        vector<vector < int>> dp(n + 1, vector<int> (n + 1, -1));\\n        for (int i = 0; i < n; i++)\\n        {\\n            mn = min(mn, f(0, i, v, dp));\\n        }\\n\\n        return mn;\\n    }\\n};\\n\\n```\\nCAN SOMEONE PLEASE TELL WHAT IS WRONG IN THIS CODE, ITS GIVING TLE FOR 49TH/50 TESTCASE"
                    },
                    {
                        "username": "shivam_0344",
                        "content": "intialise dp vector with a value less than -100 rather than -1, because of given constraints(-100 <= matrix[i][j] <= 100)\n"
                    },
                    {
                        "username": "aman2k1",
                        "content": "Is memoized solution giving TLE?"
                    },
                    {
                        "username": "dhruvpatidar35",
                        "content": "use hashmap instead , it will work"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "[@crash_landing_wheee](/crash_landing_wheee)  \n```if(n==100 && matrix[0][0]==0 ) return -1 ;```\nuse this for case 49 it will be accepted otherwise go for Tabulation\n"
                    },
                    {
                        "username": "crash_landing_wheee",
                        "content": "Yep"
                    },
                    {
                        "username": "Blebot",
                        "content": "Last Test Case doesn\\'t seem to be working with memoization. Anyone faced this issue?"
                    },
                    {
                        "username": "ay8182",
                        "content": "Yeah idk about this solution but memoization isn\\'t working. It\\'s giving TLE kindly use tabulation method to solve this\\n"
                    },
                    {
                        "username": "s1ttu",
                        "content": "just iterate through the matrix from matrix[1] excluding the first row because we can simply calculate it in the matrix[1] and on words for matrix[i][j] we have 3 paths from where we can came to this index i, j as it is stated in the question that we have to find the minimum path form top the bottom (i.e. matrix[0] to matrix[-1])\\nso we take the minimum path for all possible matrix[i][j] and add the value of matrix[i][j] to it \\n``` matrix[i][j] += min(matrix[i-1][j], matrix[i-1][j-1], matrix[i-1][j+1]```\\nkeep in mind for the corner cases where ```j == 0 or j == len(matrix[0])-1``` in these two we only have the 2 possible paths "
                    },
                    {
                        "username": "Mustafa_Qassmieh",
                        "content": "[[100,-42,-46,-41],[31,97,10,-10],[-58,-51,82,89],[51,81,69,-51]]\nhow is this -36 not -25\n-46 >> -10 >> 82>> -51 = -25\nwhat am i missing\nhere is a block build for clarification\n[100,  -42,    -46,  -41]\n[31,    97,     10,      -10]\n[-58,  -51,    82,     89]\n[51,     81      69,      -51]"
                    },
                    {
                        "username": "jevita279",
                        "content": "[@pepijnvdliefvoort](/pepijnvdliefvoort) because we want the minimum sum overall. If we pick -10, we have only 82 n 89 for next pick which will lead to a bigger sum."
                    },
                    {
                        "username": "pepijnvdliefvoort",
                        "content": "[@jevita279](/jevita279) Why is 10 chosen over -10?"
                    },
                    {
                        "username": "jevita279",
                        "content": "-46->10->-51->51 == -36\\n"
                    },
                    {
                        "username": "Sumnoon",
                        "content": "Can anyone tell why we should start from last row? I have tried solving it from row = 0 but it gives wrong answer for test cases. But starting from bottom i.e. row = n - 1 it got accepted."
                    },
                    {
                        "username": "mdAzhar",
                        "content": "No you don\\'t need to start from bottom.\\nStart from row 1, then for each col add the min from previous row and [col-1, col, col+1]. At the end return the min from bottom row"
                    },
                    {
                        "username": "Zhe_FunCoding",
                        "content": "Tips:\\n- Take the waterfall approach, build up one row at a time.\\n- x[i][j] is minimum of itself plus three numbers above it respectively.\\n\\nGood luck."
                    },
                    {
                        "username": "dhakad22klx",
                        "content": "Thanks got it.I was getting TLE because i was passing matrix without reference "
                    },
                    {
                        "username": "dhakad22klx",
                        "content": "It is TLE at 44. I have tried."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 FAANG\\uD83D\\uDE0E || Recursion, DP - Memoization, Tabulation + Space Optimization\\uD83E\\uDD73\\nhttps://leetcode.com/problems/minimum-falling-path-sum/solutions/3125421/faang-recursion-dp-memoization-tabulation-space-optimization/?orderBy=most_votes"
                    },
                    {
                        "username": "sanjay1305",
                        "content": "JAVA Solution || DP:\\n# Code\\n```\\nclass Solution {\\n    public int minFallingPathSum(int[][] matrix) {\\n       int dp[][] = new int[matrix.length][matrix.length];\\n        int min = Integer.MAX_VALUE;\\n        for(int i=0;i<matrix.length;i++){\\n            dp[0][i]=matrix[0][i];\\n        }\\n        for(int i=1;i<matrix.length;i++){\\n            for(int j=0;j<matrix.length;j++){\\n                if(j==0){\\n                    dp[i][j]=matrix[i][j]+Math.min(dp[i-1][j],dp[i-1][j+1]);\\n                }\\n                else if(j==matrix.length-1){\\n                    dp[i][j]=matrix[i][j]+Math.min(dp[i-1][j],dp[i-1][j-1]);\\n                }\\n                else{\\n                    dp[i][j]=matrix[i][j]+ Math.min(Math.min(dp[i-1][j-1], dp[i-1][j]), dp[i-1][j+1]);\\n                }\\n\\n            }\\n        }\\n        for(int i=0;i<matrix.length;i++){\\n            if(dp[matrix.length-1][i]<min) min=dp[matrix.length-1][i];\\n        }\\n     return min;\\n    }\\n}\\n```\\n"
                    },
                    {
                        "username": "himaniac",
                        "content": "please don\\'t put your solutions under discussions\\n"
                    },
                    {
                        "username": "saxenaaashi90",
                        "content": "[[-19,-57],[-40,-5]] \\nHow is answer -97 for this?"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "-57 ,-40 so it -97 minimum is -97"
                    }
                ]
            },
            {
                "id": 1931861,
                "content": [
                    {
                        "username": "akku18tiwari",
                        "content": "```\\nclass Solution\\n{\\n    public:\\n\\n       \\t// f(i, j) ->  i, j => n - 1 row\\n        int f(int i, int j, vector<vector < int>> &v, vector< vector< int>> &dp)\\n        {\\n            if (j < 0 || j >= v.size()) return 1e9;\\n            if (i == (v.size() - 1)) return v[v.size() - 1][j];\\n            if (dp[i][j] != -1) return dp[i][j];\\n\\n            int l = v[i][j] + f(i + 1, j - 1, v, dp);\\n            int d = v[i][j] + f(i + 1, j, v, dp);\\n            int r = v[i][j] + f(i + 1, j + 1, v, dp);\\n\\n            return dp[i][j] = min(l, min(d, r));\\n        }\\n    int minFallingPathSum(vector<vector < int>> &v)\\n    {\\n        int mn = 1e9;\\n        int n = v.size();\\n        vector<vector < int>> dp(n + 1, vector<int> (n + 1, -1));\\n        for (int i = 0; i < n; i++)\\n        {\\n            mn = min(mn, f(0, i, v, dp));\\n        }\\n\\n        return mn;\\n    }\\n};\\n\\n```\\nCAN SOMEONE PLEASE TELL WHAT IS WRONG IN THIS CODE, ITS GIVING TLE FOR 49TH/50 TESTCASE"
                    },
                    {
                        "username": "shivam_0344",
                        "content": "intialise dp vector with a value less than -100 rather than -1, because of given constraints(-100 <= matrix[i][j] <= 100)\n"
                    },
                    {
                        "username": "aman2k1",
                        "content": "Is memoized solution giving TLE?"
                    },
                    {
                        "username": "dhruvpatidar35",
                        "content": "use hashmap instead , it will work"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "[@crash_landing_wheee](/crash_landing_wheee)  \n```if(n==100 && matrix[0][0]==0 ) return -1 ;```\nuse this for case 49 it will be accepted otherwise go for Tabulation\n"
                    },
                    {
                        "username": "crash_landing_wheee",
                        "content": "Yep"
                    },
                    {
                        "username": "Blebot",
                        "content": "Last Test Case doesn\\'t seem to be working with memoization. Anyone faced this issue?"
                    },
                    {
                        "username": "ay8182",
                        "content": "Yeah idk about this solution but memoization isn\\'t working. It\\'s giving TLE kindly use tabulation method to solve this\\n"
                    },
                    {
                        "username": "s1ttu",
                        "content": "just iterate through the matrix from matrix[1] excluding the first row because we can simply calculate it in the matrix[1] and on words for matrix[i][j] we have 3 paths from where we can came to this index i, j as it is stated in the question that we have to find the minimum path form top the bottom (i.e. matrix[0] to matrix[-1])\\nso we take the minimum path for all possible matrix[i][j] and add the value of matrix[i][j] to it \\n``` matrix[i][j] += min(matrix[i-1][j], matrix[i-1][j-1], matrix[i-1][j+1]```\\nkeep in mind for the corner cases where ```j == 0 or j == len(matrix[0])-1``` in these two we only have the 2 possible paths "
                    },
                    {
                        "username": "Mustafa_Qassmieh",
                        "content": "[[100,-42,-46,-41],[31,97,10,-10],[-58,-51,82,89],[51,81,69,-51]]\nhow is this -36 not -25\n-46 >> -10 >> 82>> -51 = -25\nwhat am i missing\nhere is a block build for clarification\n[100,  -42,    -46,  -41]\n[31,    97,     10,      -10]\n[-58,  -51,    82,     89]\n[51,     81      69,      -51]"
                    },
                    {
                        "username": "jevita279",
                        "content": "[@pepijnvdliefvoort](/pepijnvdliefvoort) because we want the minimum sum overall. If we pick -10, we have only 82 n 89 for next pick which will lead to a bigger sum."
                    },
                    {
                        "username": "pepijnvdliefvoort",
                        "content": "[@jevita279](/jevita279) Why is 10 chosen over -10?"
                    },
                    {
                        "username": "jevita279",
                        "content": "-46->10->-51->51 == -36\\n"
                    },
                    {
                        "username": "Sumnoon",
                        "content": "Can anyone tell why we should start from last row? I have tried solving it from row = 0 but it gives wrong answer for test cases. But starting from bottom i.e. row = n - 1 it got accepted."
                    },
                    {
                        "username": "mdAzhar",
                        "content": "No you don\\'t need to start from bottom.\\nStart from row 1, then for each col add the min from previous row and [col-1, col, col+1]. At the end return the min from bottom row"
                    },
                    {
                        "username": "Zhe_FunCoding",
                        "content": "Tips:\\n- Take the waterfall approach, build up one row at a time.\\n- x[i][j] is minimum of itself plus three numbers above it respectively.\\n\\nGood luck."
                    },
                    {
                        "username": "dhakad22klx",
                        "content": "Thanks got it.I was getting TLE because i was passing matrix without reference "
                    },
                    {
                        "username": "dhakad22klx",
                        "content": "It is TLE at 44. I have tried."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 FAANG\\uD83D\\uDE0E || Recursion, DP - Memoization, Tabulation + Space Optimization\\uD83E\\uDD73\\nhttps://leetcode.com/problems/minimum-falling-path-sum/solutions/3125421/faang-recursion-dp-memoization-tabulation-space-optimization/?orderBy=most_votes"
                    },
                    {
                        "username": "sanjay1305",
                        "content": "JAVA Solution || DP:\\n# Code\\n```\\nclass Solution {\\n    public int minFallingPathSum(int[][] matrix) {\\n       int dp[][] = new int[matrix.length][matrix.length];\\n        int min = Integer.MAX_VALUE;\\n        for(int i=0;i<matrix.length;i++){\\n            dp[0][i]=matrix[0][i];\\n        }\\n        for(int i=1;i<matrix.length;i++){\\n            for(int j=0;j<matrix.length;j++){\\n                if(j==0){\\n                    dp[i][j]=matrix[i][j]+Math.min(dp[i-1][j],dp[i-1][j+1]);\\n                }\\n                else if(j==matrix.length-1){\\n                    dp[i][j]=matrix[i][j]+Math.min(dp[i-1][j],dp[i-1][j-1]);\\n                }\\n                else{\\n                    dp[i][j]=matrix[i][j]+ Math.min(Math.min(dp[i-1][j-1], dp[i-1][j]), dp[i-1][j+1]);\\n                }\\n\\n            }\\n        }\\n        for(int i=0;i<matrix.length;i++){\\n            if(dp[matrix.length-1][i]<min) min=dp[matrix.length-1][i];\\n        }\\n     return min;\\n    }\\n}\\n```\\n"
                    },
                    {
                        "username": "himaniac",
                        "content": "please don\\'t put your solutions under discussions\\n"
                    },
                    {
                        "username": "saxenaaashi90",
                        "content": "[[-19,-57],[-40,-5]] \\nHow is answer -97 for this?"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "-57 ,-40 so it -97 minimum is -97"
                    }
                ]
            },
            {
                "id": 1789125,
                "content": [
                    {
                        "username": "akku18tiwari",
                        "content": "```\\nclass Solution\\n{\\n    public:\\n\\n       \\t// f(i, j) ->  i, j => n - 1 row\\n        int f(int i, int j, vector<vector < int>> &v, vector< vector< int>> &dp)\\n        {\\n            if (j < 0 || j >= v.size()) return 1e9;\\n            if (i == (v.size() - 1)) return v[v.size() - 1][j];\\n            if (dp[i][j] != -1) return dp[i][j];\\n\\n            int l = v[i][j] + f(i + 1, j - 1, v, dp);\\n            int d = v[i][j] + f(i + 1, j, v, dp);\\n            int r = v[i][j] + f(i + 1, j + 1, v, dp);\\n\\n            return dp[i][j] = min(l, min(d, r));\\n        }\\n    int minFallingPathSum(vector<vector < int>> &v)\\n    {\\n        int mn = 1e9;\\n        int n = v.size();\\n        vector<vector < int>> dp(n + 1, vector<int> (n + 1, -1));\\n        for (int i = 0; i < n; i++)\\n        {\\n            mn = min(mn, f(0, i, v, dp));\\n        }\\n\\n        return mn;\\n    }\\n};\\n\\n```\\nCAN SOMEONE PLEASE TELL WHAT IS WRONG IN THIS CODE, ITS GIVING TLE FOR 49TH/50 TESTCASE"
                    },
                    {
                        "username": "shivam_0344",
                        "content": "intialise dp vector with a value less than -100 rather than -1, because of given constraints(-100 <= matrix[i][j] <= 100)\n"
                    },
                    {
                        "username": "aman2k1",
                        "content": "Is memoized solution giving TLE?"
                    },
                    {
                        "username": "dhruvpatidar35",
                        "content": "use hashmap instead , it will work"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "[@crash_landing_wheee](/crash_landing_wheee)  \n```if(n==100 && matrix[0][0]==0 ) return -1 ;```\nuse this for case 49 it will be accepted otherwise go for Tabulation\n"
                    },
                    {
                        "username": "crash_landing_wheee",
                        "content": "Yep"
                    },
                    {
                        "username": "Blebot",
                        "content": "Last Test Case doesn\\'t seem to be working with memoization. Anyone faced this issue?"
                    },
                    {
                        "username": "ay8182",
                        "content": "Yeah idk about this solution but memoization isn\\'t working. It\\'s giving TLE kindly use tabulation method to solve this\\n"
                    },
                    {
                        "username": "s1ttu",
                        "content": "just iterate through the matrix from matrix[1] excluding the first row because we can simply calculate it in the matrix[1] and on words for matrix[i][j] we have 3 paths from where we can came to this index i, j as it is stated in the question that we have to find the minimum path form top the bottom (i.e. matrix[0] to matrix[-1])\\nso we take the minimum path for all possible matrix[i][j] and add the value of matrix[i][j] to it \\n``` matrix[i][j] += min(matrix[i-1][j], matrix[i-1][j-1], matrix[i-1][j+1]```\\nkeep in mind for the corner cases where ```j == 0 or j == len(matrix[0])-1``` in these two we only have the 2 possible paths "
                    },
                    {
                        "username": "Mustafa_Qassmieh",
                        "content": "[[100,-42,-46,-41],[31,97,10,-10],[-58,-51,82,89],[51,81,69,-51]]\nhow is this -36 not -25\n-46 >> -10 >> 82>> -51 = -25\nwhat am i missing\nhere is a block build for clarification\n[100,  -42,    -46,  -41]\n[31,    97,     10,      -10]\n[-58,  -51,    82,     89]\n[51,     81      69,      -51]"
                    },
                    {
                        "username": "jevita279",
                        "content": "[@pepijnvdliefvoort](/pepijnvdliefvoort) because we want the minimum sum overall. If we pick -10, we have only 82 n 89 for next pick which will lead to a bigger sum."
                    },
                    {
                        "username": "pepijnvdliefvoort",
                        "content": "[@jevita279](/jevita279) Why is 10 chosen over -10?"
                    },
                    {
                        "username": "jevita279",
                        "content": "-46->10->-51->51 == -36\\n"
                    },
                    {
                        "username": "Sumnoon",
                        "content": "Can anyone tell why we should start from last row? I have tried solving it from row = 0 but it gives wrong answer for test cases. But starting from bottom i.e. row = n - 1 it got accepted."
                    },
                    {
                        "username": "mdAzhar",
                        "content": "No you don\\'t need to start from bottom.\\nStart from row 1, then for each col add the min from previous row and [col-1, col, col+1]. At the end return the min from bottom row"
                    },
                    {
                        "username": "Zhe_FunCoding",
                        "content": "Tips:\\n- Take the waterfall approach, build up one row at a time.\\n- x[i][j] is minimum of itself plus three numbers above it respectively.\\n\\nGood luck."
                    },
                    {
                        "username": "dhakad22klx",
                        "content": "Thanks got it.I was getting TLE because i was passing matrix without reference "
                    },
                    {
                        "username": "dhakad22klx",
                        "content": "It is TLE at 44. I have tried."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 FAANG\\uD83D\\uDE0E || Recursion, DP - Memoization, Tabulation + Space Optimization\\uD83E\\uDD73\\nhttps://leetcode.com/problems/minimum-falling-path-sum/solutions/3125421/faang-recursion-dp-memoization-tabulation-space-optimization/?orderBy=most_votes"
                    },
                    {
                        "username": "sanjay1305",
                        "content": "JAVA Solution || DP:\\n# Code\\n```\\nclass Solution {\\n    public int minFallingPathSum(int[][] matrix) {\\n       int dp[][] = new int[matrix.length][matrix.length];\\n        int min = Integer.MAX_VALUE;\\n        for(int i=0;i<matrix.length;i++){\\n            dp[0][i]=matrix[0][i];\\n        }\\n        for(int i=1;i<matrix.length;i++){\\n            for(int j=0;j<matrix.length;j++){\\n                if(j==0){\\n                    dp[i][j]=matrix[i][j]+Math.min(dp[i-1][j],dp[i-1][j+1]);\\n                }\\n                else if(j==matrix.length-1){\\n                    dp[i][j]=matrix[i][j]+Math.min(dp[i-1][j],dp[i-1][j-1]);\\n                }\\n                else{\\n                    dp[i][j]=matrix[i][j]+ Math.min(Math.min(dp[i-1][j-1], dp[i-1][j]), dp[i-1][j+1]);\\n                }\\n\\n            }\\n        }\\n        for(int i=0;i<matrix.length;i++){\\n            if(dp[matrix.length-1][i]<min) min=dp[matrix.length-1][i];\\n        }\\n     return min;\\n    }\\n}\\n```\\n"
                    },
                    {
                        "username": "himaniac",
                        "content": "please don\\'t put your solutions under discussions\\n"
                    },
                    {
                        "username": "saxenaaashi90",
                        "content": "[[-19,-57],[-40,-5]] \\nHow is answer -97 for this?"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "-57 ,-40 so it -97 minimum is -97"
                    }
                ]
            },
            {
                "id": 1715665,
                "content": [
                    {
                        "username": "akku18tiwari",
                        "content": "```\\nclass Solution\\n{\\n    public:\\n\\n       \\t// f(i, j) ->  i, j => n - 1 row\\n        int f(int i, int j, vector<vector < int>> &v, vector< vector< int>> &dp)\\n        {\\n            if (j < 0 || j >= v.size()) return 1e9;\\n            if (i == (v.size() - 1)) return v[v.size() - 1][j];\\n            if (dp[i][j] != -1) return dp[i][j];\\n\\n            int l = v[i][j] + f(i + 1, j - 1, v, dp);\\n            int d = v[i][j] + f(i + 1, j, v, dp);\\n            int r = v[i][j] + f(i + 1, j + 1, v, dp);\\n\\n            return dp[i][j] = min(l, min(d, r));\\n        }\\n    int minFallingPathSum(vector<vector < int>> &v)\\n    {\\n        int mn = 1e9;\\n        int n = v.size();\\n        vector<vector < int>> dp(n + 1, vector<int> (n + 1, -1));\\n        for (int i = 0; i < n; i++)\\n        {\\n            mn = min(mn, f(0, i, v, dp));\\n        }\\n\\n        return mn;\\n    }\\n};\\n\\n```\\nCAN SOMEONE PLEASE TELL WHAT IS WRONG IN THIS CODE, ITS GIVING TLE FOR 49TH/50 TESTCASE"
                    },
                    {
                        "username": "shivam_0344",
                        "content": "intialise dp vector with a value less than -100 rather than -1, because of given constraints(-100 <= matrix[i][j] <= 100)\n"
                    },
                    {
                        "username": "aman2k1",
                        "content": "Is memoized solution giving TLE?"
                    },
                    {
                        "username": "dhruvpatidar35",
                        "content": "use hashmap instead , it will work"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "[@crash_landing_wheee](/crash_landing_wheee)  \n```if(n==100 && matrix[0][0]==0 ) return -1 ;```\nuse this for case 49 it will be accepted otherwise go for Tabulation\n"
                    },
                    {
                        "username": "crash_landing_wheee",
                        "content": "Yep"
                    },
                    {
                        "username": "Blebot",
                        "content": "Last Test Case doesn\\'t seem to be working with memoization. Anyone faced this issue?"
                    },
                    {
                        "username": "ay8182",
                        "content": "Yeah idk about this solution but memoization isn\\'t working. It\\'s giving TLE kindly use tabulation method to solve this\\n"
                    },
                    {
                        "username": "s1ttu",
                        "content": "just iterate through the matrix from matrix[1] excluding the first row because we can simply calculate it in the matrix[1] and on words for matrix[i][j] we have 3 paths from where we can came to this index i, j as it is stated in the question that we have to find the minimum path form top the bottom (i.e. matrix[0] to matrix[-1])\\nso we take the minimum path for all possible matrix[i][j] and add the value of matrix[i][j] to it \\n``` matrix[i][j] += min(matrix[i-1][j], matrix[i-1][j-1], matrix[i-1][j+1]```\\nkeep in mind for the corner cases where ```j == 0 or j == len(matrix[0])-1``` in these two we only have the 2 possible paths "
                    },
                    {
                        "username": "Mustafa_Qassmieh",
                        "content": "[[100,-42,-46,-41],[31,97,10,-10],[-58,-51,82,89],[51,81,69,-51]]\nhow is this -36 not -25\n-46 >> -10 >> 82>> -51 = -25\nwhat am i missing\nhere is a block build for clarification\n[100,  -42,    -46,  -41]\n[31,    97,     10,      -10]\n[-58,  -51,    82,     89]\n[51,     81      69,      -51]"
                    },
                    {
                        "username": "jevita279",
                        "content": "[@pepijnvdliefvoort](/pepijnvdliefvoort) because we want the minimum sum overall. If we pick -10, we have only 82 n 89 for next pick which will lead to a bigger sum."
                    },
                    {
                        "username": "pepijnvdliefvoort",
                        "content": "[@jevita279](/jevita279) Why is 10 chosen over -10?"
                    },
                    {
                        "username": "jevita279",
                        "content": "-46->10->-51->51 == -36\\n"
                    },
                    {
                        "username": "Sumnoon",
                        "content": "Can anyone tell why we should start from last row? I have tried solving it from row = 0 but it gives wrong answer for test cases. But starting from bottom i.e. row = n - 1 it got accepted."
                    },
                    {
                        "username": "mdAzhar",
                        "content": "No you don\\'t need to start from bottom.\\nStart from row 1, then for each col add the min from previous row and [col-1, col, col+1]. At the end return the min from bottom row"
                    },
                    {
                        "username": "Zhe_FunCoding",
                        "content": "Tips:\\n- Take the waterfall approach, build up one row at a time.\\n- x[i][j] is minimum of itself plus three numbers above it respectively.\\n\\nGood luck."
                    },
                    {
                        "username": "dhakad22klx",
                        "content": "Thanks got it.I was getting TLE because i was passing matrix without reference "
                    },
                    {
                        "username": "dhakad22klx",
                        "content": "It is TLE at 44. I have tried."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 FAANG\\uD83D\\uDE0E || Recursion, DP - Memoization, Tabulation + Space Optimization\\uD83E\\uDD73\\nhttps://leetcode.com/problems/minimum-falling-path-sum/solutions/3125421/faang-recursion-dp-memoization-tabulation-space-optimization/?orderBy=most_votes"
                    },
                    {
                        "username": "sanjay1305",
                        "content": "JAVA Solution || DP:\\n# Code\\n```\\nclass Solution {\\n    public int minFallingPathSum(int[][] matrix) {\\n       int dp[][] = new int[matrix.length][matrix.length];\\n        int min = Integer.MAX_VALUE;\\n        for(int i=0;i<matrix.length;i++){\\n            dp[0][i]=matrix[0][i];\\n        }\\n        for(int i=1;i<matrix.length;i++){\\n            for(int j=0;j<matrix.length;j++){\\n                if(j==0){\\n                    dp[i][j]=matrix[i][j]+Math.min(dp[i-1][j],dp[i-1][j+1]);\\n                }\\n                else if(j==matrix.length-1){\\n                    dp[i][j]=matrix[i][j]+Math.min(dp[i-1][j],dp[i-1][j-1]);\\n                }\\n                else{\\n                    dp[i][j]=matrix[i][j]+ Math.min(Math.min(dp[i-1][j-1], dp[i-1][j]), dp[i-1][j+1]);\\n                }\\n\\n            }\\n        }\\n        for(int i=0;i<matrix.length;i++){\\n            if(dp[matrix.length-1][i]<min) min=dp[matrix.length-1][i];\\n        }\\n     return min;\\n    }\\n}\\n```\\n"
                    },
                    {
                        "username": "himaniac",
                        "content": "please don\\'t put your solutions under discussions\\n"
                    },
                    {
                        "username": "saxenaaashi90",
                        "content": "[[-19,-57],[-40,-5]] \\nHow is answer -97 for this?"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "-57 ,-40 so it -97 minimum is -97"
                    }
                ]
            },
            {
                "id": 1715104,
                "content": [
                    {
                        "username": "akku18tiwari",
                        "content": "```\\nclass Solution\\n{\\n    public:\\n\\n       \\t// f(i, j) ->  i, j => n - 1 row\\n        int f(int i, int j, vector<vector < int>> &v, vector< vector< int>> &dp)\\n        {\\n            if (j < 0 || j >= v.size()) return 1e9;\\n            if (i == (v.size() - 1)) return v[v.size() - 1][j];\\n            if (dp[i][j] != -1) return dp[i][j];\\n\\n            int l = v[i][j] + f(i + 1, j - 1, v, dp);\\n            int d = v[i][j] + f(i + 1, j, v, dp);\\n            int r = v[i][j] + f(i + 1, j + 1, v, dp);\\n\\n            return dp[i][j] = min(l, min(d, r));\\n        }\\n    int minFallingPathSum(vector<vector < int>> &v)\\n    {\\n        int mn = 1e9;\\n        int n = v.size();\\n        vector<vector < int>> dp(n + 1, vector<int> (n + 1, -1));\\n        for (int i = 0; i < n; i++)\\n        {\\n            mn = min(mn, f(0, i, v, dp));\\n        }\\n\\n        return mn;\\n    }\\n};\\n\\n```\\nCAN SOMEONE PLEASE TELL WHAT IS WRONG IN THIS CODE, ITS GIVING TLE FOR 49TH/50 TESTCASE"
                    },
                    {
                        "username": "shivam_0344",
                        "content": "intialise dp vector with a value less than -100 rather than -1, because of given constraints(-100 <= matrix[i][j] <= 100)\n"
                    },
                    {
                        "username": "aman2k1",
                        "content": "Is memoized solution giving TLE?"
                    },
                    {
                        "username": "dhruvpatidar35",
                        "content": "use hashmap instead , it will work"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "[@crash_landing_wheee](/crash_landing_wheee)  \n```if(n==100 && matrix[0][0]==0 ) return -1 ;```\nuse this for case 49 it will be accepted otherwise go for Tabulation\n"
                    },
                    {
                        "username": "crash_landing_wheee",
                        "content": "Yep"
                    },
                    {
                        "username": "Blebot",
                        "content": "Last Test Case doesn\\'t seem to be working with memoization. Anyone faced this issue?"
                    },
                    {
                        "username": "ay8182",
                        "content": "Yeah idk about this solution but memoization isn\\'t working. It\\'s giving TLE kindly use tabulation method to solve this\\n"
                    },
                    {
                        "username": "s1ttu",
                        "content": "just iterate through the matrix from matrix[1] excluding the first row because we can simply calculate it in the matrix[1] and on words for matrix[i][j] we have 3 paths from where we can came to this index i, j as it is stated in the question that we have to find the minimum path form top the bottom (i.e. matrix[0] to matrix[-1])\\nso we take the minimum path for all possible matrix[i][j] and add the value of matrix[i][j] to it \\n``` matrix[i][j] += min(matrix[i-1][j], matrix[i-1][j-1], matrix[i-1][j+1]```\\nkeep in mind for the corner cases where ```j == 0 or j == len(matrix[0])-1``` in these two we only have the 2 possible paths "
                    },
                    {
                        "username": "Mustafa_Qassmieh",
                        "content": "[[100,-42,-46,-41],[31,97,10,-10],[-58,-51,82,89],[51,81,69,-51]]\nhow is this -36 not -25\n-46 >> -10 >> 82>> -51 = -25\nwhat am i missing\nhere is a block build for clarification\n[100,  -42,    -46,  -41]\n[31,    97,     10,      -10]\n[-58,  -51,    82,     89]\n[51,     81      69,      -51]"
                    },
                    {
                        "username": "jevita279",
                        "content": "[@pepijnvdliefvoort](/pepijnvdliefvoort) because we want the minimum sum overall. If we pick -10, we have only 82 n 89 for next pick which will lead to a bigger sum."
                    },
                    {
                        "username": "pepijnvdliefvoort",
                        "content": "[@jevita279](/jevita279) Why is 10 chosen over -10?"
                    },
                    {
                        "username": "jevita279",
                        "content": "-46->10->-51->51 == -36\\n"
                    },
                    {
                        "username": "Sumnoon",
                        "content": "Can anyone tell why we should start from last row? I have tried solving it from row = 0 but it gives wrong answer for test cases. But starting from bottom i.e. row = n - 1 it got accepted."
                    },
                    {
                        "username": "mdAzhar",
                        "content": "No you don\\'t need to start from bottom.\\nStart from row 1, then for each col add the min from previous row and [col-1, col, col+1]. At the end return the min from bottom row"
                    },
                    {
                        "username": "Zhe_FunCoding",
                        "content": "Tips:\\n- Take the waterfall approach, build up one row at a time.\\n- x[i][j] is minimum of itself plus three numbers above it respectively.\\n\\nGood luck."
                    },
                    {
                        "username": "dhakad22klx",
                        "content": "Thanks got it.I was getting TLE because i was passing matrix without reference "
                    },
                    {
                        "username": "dhakad22klx",
                        "content": "It is TLE at 44. I have tried."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 FAANG\\uD83D\\uDE0E || Recursion, DP - Memoization, Tabulation + Space Optimization\\uD83E\\uDD73\\nhttps://leetcode.com/problems/minimum-falling-path-sum/solutions/3125421/faang-recursion-dp-memoization-tabulation-space-optimization/?orderBy=most_votes"
                    },
                    {
                        "username": "sanjay1305",
                        "content": "JAVA Solution || DP:\\n# Code\\n```\\nclass Solution {\\n    public int minFallingPathSum(int[][] matrix) {\\n       int dp[][] = new int[matrix.length][matrix.length];\\n        int min = Integer.MAX_VALUE;\\n        for(int i=0;i<matrix.length;i++){\\n            dp[0][i]=matrix[0][i];\\n        }\\n        for(int i=1;i<matrix.length;i++){\\n            for(int j=0;j<matrix.length;j++){\\n                if(j==0){\\n                    dp[i][j]=matrix[i][j]+Math.min(dp[i-1][j],dp[i-1][j+1]);\\n                }\\n                else if(j==matrix.length-1){\\n                    dp[i][j]=matrix[i][j]+Math.min(dp[i-1][j],dp[i-1][j-1]);\\n                }\\n                else{\\n                    dp[i][j]=matrix[i][j]+ Math.min(Math.min(dp[i-1][j-1], dp[i-1][j]), dp[i-1][j+1]);\\n                }\\n\\n            }\\n        }\\n        for(int i=0;i<matrix.length;i++){\\n            if(dp[matrix.length-1][i]<min) min=dp[matrix.length-1][i];\\n        }\\n     return min;\\n    }\\n}\\n```\\n"
                    },
                    {
                        "username": "himaniac",
                        "content": "please don\\'t put your solutions under discussions\\n"
                    },
                    {
                        "username": "saxenaaashi90",
                        "content": "[[-19,-57],[-40,-5]] \\nHow is answer -97 for this?"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "-57 ,-40 so it -97 minimum is -97"
                    }
                ]
            },
            {
                "id": 1714982,
                "content": [
                    {
                        "username": "akku18tiwari",
                        "content": "```\\nclass Solution\\n{\\n    public:\\n\\n       \\t// f(i, j) ->  i, j => n - 1 row\\n        int f(int i, int j, vector<vector < int>> &v, vector< vector< int>> &dp)\\n        {\\n            if (j < 0 || j >= v.size()) return 1e9;\\n            if (i == (v.size() - 1)) return v[v.size() - 1][j];\\n            if (dp[i][j] != -1) return dp[i][j];\\n\\n            int l = v[i][j] + f(i + 1, j - 1, v, dp);\\n            int d = v[i][j] + f(i + 1, j, v, dp);\\n            int r = v[i][j] + f(i + 1, j + 1, v, dp);\\n\\n            return dp[i][j] = min(l, min(d, r));\\n        }\\n    int minFallingPathSum(vector<vector < int>> &v)\\n    {\\n        int mn = 1e9;\\n        int n = v.size();\\n        vector<vector < int>> dp(n + 1, vector<int> (n + 1, -1));\\n        for (int i = 0; i < n; i++)\\n        {\\n            mn = min(mn, f(0, i, v, dp));\\n        }\\n\\n        return mn;\\n    }\\n};\\n\\n```\\nCAN SOMEONE PLEASE TELL WHAT IS WRONG IN THIS CODE, ITS GIVING TLE FOR 49TH/50 TESTCASE"
                    },
                    {
                        "username": "shivam_0344",
                        "content": "intialise dp vector with a value less than -100 rather than -1, because of given constraints(-100 <= matrix[i][j] <= 100)\n"
                    },
                    {
                        "username": "aman2k1",
                        "content": "Is memoized solution giving TLE?"
                    },
                    {
                        "username": "dhruvpatidar35",
                        "content": "use hashmap instead , it will work"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "[@crash_landing_wheee](/crash_landing_wheee)  \n```if(n==100 && matrix[0][0]==0 ) return -1 ;```\nuse this for case 49 it will be accepted otherwise go for Tabulation\n"
                    },
                    {
                        "username": "crash_landing_wheee",
                        "content": "Yep"
                    },
                    {
                        "username": "Blebot",
                        "content": "Last Test Case doesn\\'t seem to be working with memoization. Anyone faced this issue?"
                    },
                    {
                        "username": "ay8182",
                        "content": "Yeah idk about this solution but memoization isn\\'t working. It\\'s giving TLE kindly use tabulation method to solve this\\n"
                    },
                    {
                        "username": "s1ttu",
                        "content": "just iterate through the matrix from matrix[1] excluding the first row because we can simply calculate it in the matrix[1] and on words for matrix[i][j] we have 3 paths from where we can came to this index i, j as it is stated in the question that we have to find the minimum path form top the bottom (i.e. matrix[0] to matrix[-1])\\nso we take the minimum path for all possible matrix[i][j] and add the value of matrix[i][j] to it \\n``` matrix[i][j] += min(matrix[i-1][j], matrix[i-1][j-1], matrix[i-1][j+1]```\\nkeep in mind for the corner cases where ```j == 0 or j == len(matrix[0])-1``` in these two we only have the 2 possible paths "
                    },
                    {
                        "username": "Mustafa_Qassmieh",
                        "content": "[[100,-42,-46,-41],[31,97,10,-10],[-58,-51,82,89],[51,81,69,-51]]\nhow is this -36 not -25\n-46 >> -10 >> 82>> -51 = -25\nwhat am i missing\nhere is a block build for clarification\n[100,  -42,    -46,  -41]\n[31,    97,     10,      -10]\n[-58,  -51,    82,     89]\n[51,     81      69,      -51]"
                    },
                    {
                        "username": "jevita279",
                        "content": "[@pepijnvdliefvoort](/pepijnvdliefvoort) because we want the minimum sum overall. If we pick -10, we have only 82 n 89 for next pick which will lead to a bigger sum."
                    },
                    {
                        "username": "pepijnvdliefvoort",
                        "content": "[@jevita279](/jevita279) Why is 10 chosen over -10?"
                    },
                    {
                        "username": "jevita279",
                        "content": "-46->10->-51->51 == -36\\n"
                    },
                    {
                        "username": "Sumnoon",
                        "content": "Can anyone tell why we should start from last row? I have tried solving it from row = 0 but it gives wrong answer for test cases. But starting from bottom i.e. row = n - 1 it got accepted."
                    },
                    {
                        "username": "mdAzhar",
                        "content": "No you don\\'t need to start from bottom.\\nStart from row 1, then for each col add the min from previous row and [col-1, col, col+1]. At the end return the min from bottom row"
                    },
                    {
                        "username": "Zhe_FunCoding",
                        "content": "Tips:\\n- Take the waterfall approach, build up one row at a time.\\n- x[i][j] is minimum of itself plus three numbers above it respectively.\\n\\nGood luck."
                    },
                    {
                        "username": "dhakad22klx",
                        "content": "Thanks got it.I was getting TLE because i was passing matrix without reference "
                    },
                    {
                        "username": "dhakad22klx",
                        "content": "It is TLE at 44. I have tried."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 FAANG\\uD83D\\uDE0E || Recursion, DP - Memoization, Tabulation + Space Optimization\\uD83E\\uDD73\\nhttps://leetcode.com/problems/minimum-falling-path-sum/solutions/3125421/faang-recursion-dp-memoization-tabulation-space-optimization/?orderBy=most_votes"
                    },
                    {
                        "username": "sanjay1305",
                        "content": "JAVA Solution || DP:\\n# Code\\n```\\nclass Solution {\\n    public int minFallingPathSum(int[][] matrix) {\\n       int dp[][] = new int[matrix.length][matrix.length];\\n        int min = Integer.MAX_VALUE;\\n        for(int i=0;i<matrix.length;i++){\\n            dp[0][i]=matrix[0][i];\\n        }\\n        for(int i=1;i<matrix.length;i++){\\n            for(int j=0;j<matrix.length;j++){\\n                if(j==0){\\n                    dp[i][j]=matrix[i][j]+Math.min(dp[i-1][j],dp[i-1][j+1]);\\n                }\\n                else if(j==matrix.length-1){\\n                    dp[i][j]=matrix[i][j]+Math.min(dp[i-1][j],dp[i-1][j-1]);\\n                }\\n                else{\\n                    dp[i][j]=matrix[i][j]+ Math.min(Math.min(dp[i-1][j-1], dp[i-1][j]), dp[i-1][j+1]);\\n                }\\n\\n            }\\n        }\\n        for(int i=0;i<matrix.length;i++){\\n            if(dp[matrix.length-1][i]<min) min=dp[matrix.length-1][i];\\n        }\\n     return min;\\n    }\\n}\\n```\\n"
                    },
                    {
                        "username": "himaniac",
                        "content": "please don\\'t put your solutions under discussions\\n"
                    },
                    {
                        "username": "saxenaaashi90",
                        "content": "[[-19,-57],[-40,-5]] \\nHow is answer -97 for this?"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "-57 ,-40 so it -97 minimum is -97"
                    }
                ]
            },
            {
                "id": 1782847,
                "content": [
                    {
                        "username": "akku18tiwari",
                        "content": "```\\nclass Solution\\n{\\n    public:\\n\\n       \\t// f(i, j) ->  i, j => n - 1 row\\n        int f(int i, int j, vector<vector < int>> &v, vector< vector< int>> &dp)\\n        {\\n            if (j < 0 || j >= v.size()) return 1e9;\\n            if (i == (v.size() - 1)) return v[v.size() - 1][j];\\n            if (dp[i][j] != -1) return dp[i][j];\\n\\n            int l = v[i][j] + f(i + 1, j - 1, v, dp);\\n            int d = v[i][j] + f(i + 1, j, v, dp);\\n            int r = v[i][j] + f(i + 1, j + 1, v, dp);\\n\\n            return dp[i][j] = min(l, min(d, r));\\n        }\\n    int minFallingPathSum(vector<vector < int>> &v)\\n    {\\n        int mn = 1e9;\\n        int n = v.size();\\n        vector<vector < int>> dp(n + 1, vector<int> (n + 1, -1));\\n        for (int i = 0; i < n; i++)\\n        {\\n            mn = min(mn, f(0, i, v, dp));\\n        }\\n\\n        return mn;\\n    }\\n};\\n\\n```\\nCAN SOMEONE PLEASE TELL WHAT IS WRONG IN THIS CODE, ITS GIVING TLE FOR 49TH/50 TESTCASE"
                    },
                    {
                        "username": "shivam_0344",
                        "content": "intialise dp vector with a value less than -100 rather than -1, because of given constraints(-100 <= matrix[i][j] <= 100)\n"
                    },
                    {
                        "username": "aman2k1",
                        "content": "Is memoized solution giving TLE?"
                    },
                    {
                        "username": "dhruvpatidar35",
                        "content": "use hashmap instead , it will work"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "[@crash_landing_wheee](/crash_landing_wheee)  \n```if(n==100 && matrix[0][0]==0 ) return -1 ;```\nuse this for case 49 it will be accepted otherwise go for Tabulation\n"
                    },
                    {
                        "username": "crash_landing_wheee",
                        "content": "Yep"
                    },
                    {
                        "username": "Blebot",
                        "content": "Last Test Case doesn\\'t seem to be working with memoization. Anyone faced this issue?"
                    },
                    {
                        "username": "ay8182",
                        "content": "Yeah idk about this solution but memoization isn\\'t working. It\\'s giving TLE kindly use tabulation method to solve this\\n"
                    },
                    {
                        "username": "s1ttu",
                        "content": "just iterate through the matrix from matrix[1] excluding the first row because we can simply calculate it in the matrix[1] and on words for matrix[i][j] we have 3 paths from where we can came to this index i, j as it is stated in the question that we have to find the minimum path form top the bottom (i.e. matrix[0] to matrix[-1])\\nso we take the minimum path for all possible matrix[i][j] and add the value of matrix[i][j] to it \\n``` matrix[i][j] += min(matrix[i-1][j], matrix[i-1][j-1], matrix[i-1][j+1]```\\nkeep in mind for the corner cases where ```j == 0 or j == len(matrix[0])-1``` in these two we only have the 2 possible paths "
                    },
                    {
                        "username": "Mustafa_Qassmieh",
                        "content": "[[100,-42,-46,-41],[31,97,10,-10],[-58,-51,82,89],[51,81,69,-51]]\nhow is this -36 not -25\n-46 >> -10 >> 82>> -51 = -25\nwhat am i missing\nhere is a block build for clarification\n[100,  -42,    -46,  -41]\n[31,    97,     10,      -10]\n[-58,  -51,    82,     89]\n[51,     81      69,      -51]"
                    },
                    {
                        "username": "jevita279",
                        "content": "[@pepijnvdliefvoort](/pepijnvdliefvoort) because we want the minimum sum overall. If we pick -10, we have only 82 n 89 for next pick which will lead to a bigger sum."
                    },
                    {
                        "username": "pepijnvdliefvoort",
                        "content": "[@jevita279](/jevita279) Why is 10 chosen over -10?"
                    },
                    {
                        "username": "jevita279",
                        "content": "-46->10->-51->51 == -36\\n"
                    },
                    {
                        "username": "Sumnoon",
                        "content": "Can anyone tell why we should start from last row? I have tried solving it from row = 0 but it gives wrong answer for test cases. But starting from bottom i.e. row = n - 1 it got accepted."
                    },
                    {
                        "username": "mdAzhar",
                        "content": "No you don\\'t need to start from bottom.\\nStart from row 1, then for each col add the min from previous row and [col-1, col, col+1]. At the end return the min from bottom row"
                    },
                    {
                        "username": "Zhe_FunCoding",
                        "content": "Tips:\\n- Take the waterfall approach, build up one row at a time.\\n- x[i][j] is minimum of itself plus three numbers above it respectively.\\n\\nGood luck."
                    },
                    {
                        "username": "dhakad22klx",
                        "content": "Thanks got it.I was getting TLE because i was passing matrix without reference "
                    },
                    {
                        "username": "dhakad22klx",
                        "content": "It is TLE at 44. I have tried."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 FAANG\\uD83D\\uDE0E || Recursion, DP - Memoization, Tabulation + Space Optimization\\uD83E\\uDD73\\nhttps://leetcode.com/problems/minimum-falling-path-sum/solutions/3125421/faang-recursion-dp-memoization-tabulation-space-optimization/?orderBy=most_votes"
                    },
                    {
                        "username": "sanjay1305",
                        "content": "JAVA Solution || DP:\\n# Code\\n```\\nclass Solution {\\n    public int minFallingPathSum(int[][] matrix) {\\n       int dp[][] = new int[matrix.length][matrix.length];\\n        int min = Integer.MAX_VALUE;\\n        for(int i=0;i<matrix.length;i++){\\n            dp[0][i]=matrix[0][i];\\n        }\\n        for(int i=1;i<matrix.length;i++){\\n            for(int j=0;j<matrix.length;j++){\\n                if(j==0){\\n                    dp[i][j]=matrix[i][j]+Math.min(dp[i-1][j],dp[i-1][j+1]);\\n                }\\n                else if(j==matrix.length-1){\\n                    dp[i][j]=matrix[i][j]+Math.min(dp[i-1][j],dp[i-1][j-1]);\\n                }\\n                else{\\n                    dp[i][j]=matrix[i][j]+ Math.min(Math.min(dp[i-1][j-1], dp[i-1][j]), dp[i-1][j+1]);\\n                }\\n\\n            }\\n        }\\n        for(int i=0;i<matrix.length;i++){\\n            if(dp[matrix.length-1][i]<min) min=dp[matrix.length-1][i];\\n        }\\n     return min;\\n    }\\n}\\n```\\n"
                    },
                    {
                        "username": "himaniac",
                        "content": "please don\\'t put your solutions under discussions\\n"
                    },
                    {
                        "username": "saxenaaashi90",
                        "content": "[[-19,-57],[-40,-5]] \\nHow is answer -97 for this?"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "-57 ,-40 so it -97 minimum is -97"
                    }
                ]
            },
            {
                "id": 1714799,
                "content": [
                    {
                        "username": "akku18tiwari",
                        "content": "```\\nclass Solution\\n{\\n    public:\\n\\n       \\t// f(i, j) ->  i, j => n - 1 row\\n        int f(int i, int j, vector<vector < int>> &v, vector< vector< int>> &dp)\\n        {\\n            if (j < 0 || j >= v.size()) return 1e9;\\n            if (i == (v.size() - 1)) return v[v.size() - 1][j];\\n            if (dp[i][j] != -1) return dp[i][j];\\n\\n            int l = v[i][j] + f(i + 1, j - 1, v, dp);\\n            int d = v[i][j] + f(i + 1, j, v, dp);\\n            int r = v[i][j] + f(i + 1, j + 1, v, dp);\\n\\n            return dp[i][j] = min(l, min(d, r));\\n        }\\n    int minFallingPathSum(vector<vector < int>> &v)\\n    {\\n        int mn = 1e9;\\n        int n = v.size();\\n        vector<vector < int>> dp(n + 1, vector<int> (n + 1, -1));\\n        for (int i = 0; i < n; i++)\\n        {\\n            mn = min(mn, f(0, i, v, dp));\\n        }\\n\\n        return mn;\\n    }\\n};\\n\\n```\\nCAN SOMEONE PLEASE TELL WHAT IS WRONG IN THIS CODE, ITS GIVING TLE FOR 49TH/50 TESTCASE"
                    },
                    {
                        "username": "shivam_0344",
                        "content": "intialise dp vector with a value less than -100 rather than -1, because of given constraints(-100 <= matrix[i][j] <= 100)\n"
                    },
                    {
                        "username": "aman2k1",
                        "content": "Is memoized solution giving TLE?"
                    },
                    {
                        "username": "dhruvpatidar35",
                        "content": "use hashmap instead , it will work"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "[@crash_landing_wheee](/crash_landing_wheee)  \n```if(n==100 && matrix[0][0]==0 ) return -1 ;```\nuse this for case 49 it will be accepted otherwise go for Tabulation\n"
                    },
                    {
                        "username": "crash_landing_wheee",
                        "content": "Yep"
                    },
                    {
                        "username": "Blebot",
                        "content": "Last Test Case doesn\\'t seem to be working with memoization. Anyone faced this issue?"
                    },
                    {
                        "username": "ay8182",
                        "content": "Yeah idk about this solution but memoization isn\\'t working. It\\'s giving TLE kindly use tabulation method to solve this\\n"
                    },
                    {
                        "username": "s1ttu",
                        "content": "just iterate through the matrix from matrix[1] excluding the first row because we can simply calculate it in the matrix[1] and on words for matrix[i][j] we have 3 paths from where we can came to this index i, j as it is stated in the question that we have to find the minimum path form top the bottom (i.e. matrix[0] to matrix[-1])\\nso we take the minimum path for all possible matrix[i][j] and add the value of matrix[i][j] to it \\n``` matrix[i][j] += min(matrix[i-1][j], matrix[i-1][j-1], matrix[i-1][j+1]```\\nkeep in mind for the corner cases where ```j == 0 or j == len(matrix[0])-1``` in these two we only have the 2 possible paths "
                    },
                    {
                        "username": "Mustafa_Qassmieh",
                        "content": "[[100,-42,-46,-41],[31,97,10,-10],[-58,-51,82,89],[51,81,69,-51]]\nhow is this -36 not -25\n-46 >> -10 >> 82>> -51 = -25\nwhat am i missing\nhere is a block build for clarification\n[100,  -42,    -46,  -41]\n[31,    97,     10,      -10]\n[-58,  -51,    82,     89]\n[51,     81      69,      -51]"
                    },
                    {
                        "username": "jevita279",
                        "content": "[@pepijnvdliefvoort](/pepijnvdliefvoort) because we want the minimum sum overall. If we pick -10, we have only 82 n 89 for next pick which will lead to a bigger sum."
                    },
                    {
                        "username": "pepijnvdliefvoort",
                        "content": "[@jevita279](/jevita279) Why is 10 chosen over -10?"
                    },
                    {
                        "username": "jevita279",
                        "content": "-46->10->-51->51 == -36\\n"
                    },
                    {
                        "username": "Sumnoon",
                        "content": "Can anyone tell why we should start from last row? I have tried solving it from row = 0 but it gives wrong answer for test cases. But starting from bottom i.e. row = n - 1 it got accepted."
                    },
                    {
                        "username": "mdAzhar",
                        "content": "No you don\\'t need to start from bottom.\\nStart from row 1, then for each col add the min from previous row and [col-1, col, col+1]. At the end return the min from bottom row"
                    },
                    {
                        "username": "Zhe_FunCoding",
                        "content": "Tips:\\n- Take the waterfall approach, build up one row at a time.\\n- x[i][j] is minimum of itself plus three numbers above it respectively.\\n\\nGood luck."
                    },
                    {
                        "username": "dhakad22klx",
                        "content": "Thanks got it.I was getting TLE because i was passing matrix without reference "
                    },
                    {
                        "username": "dhakad22klx",
                        "content": "It is TLE at 44. I have tried."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 FAANG\\uD83D\\uDE0E || Recursion, DP - Memoization, Tabulation + Space Optimization\\uD83E\\uDD73\\nhttps://leetcode.com/problems/minimum-falling-path-sum/solutions/3125421/faang-recursion-dp-memoization-tabulation-space-optimization/?orderBy=most_votes"
                    },
                    {
                        "username": "sanjay1305",
                        "content": "JAVA Solution || DP:\\n# Code\\n```\\nclass Solution {\\n    public int minFallingPathSum(int[][] matrix) {\\n       int dp[][] = new int[matrix.length][matrix.length];\\n        int min = Integer.MAX_VALUE;\\n        for(int i=0;i<matrix.length;i++){\\n            dp[0][i]=matrix[0][i];\\n        }\\n        for(int i=1;i<matrix.length;i++){\\n            for(int j=0;j<matrix.length;j++){\\n                if(j==0){\\n                    dp[i][j]=matrix[i][j]+Math.min(dp[i-1][j],dp[i-1][j+1]);\\n                }\\n                else if(j==matrix.length-1){\\n                    dp[i][j]=matrix[i][j]+Math.min(dp[i-1][j],dp[i-1][j-1]);\\n                }\\n                else{\\n                    dp[i][j]=matrix[i][j]+ Math.min(Math.min(dp[i-1][j-1], dp[i-1][j]), dp[i-1][j+1]);\\n                }\\n\\n            }\\n        }\\n        for(int i=0;i<matrix.length;i++){\\n            if(dp[matrix.length-1][i]<min) min=dp[matrix.length-1][i];\\n        }\\n     return min;\\n    }\\n}\\n```\\n"
                    },
                    {
                        "username": "himaniac",
                        "content": "please don\\'t put your solutions under discussions\\n"
                    },
                    {
                        "username": "saxenaaashi90",
                        "content": "[[-19,-57],[-40,-5]] \\nHow is answer -97 for this?"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "-57 ,-40 so it -97 minimum is -97"
                    }
                ]
            },
            {
                "id": 2044813,
                "content": [
                    {
                        "username": "akku18tiwari",
                        "content": "```\\nclass Solution\\n{\\n    public:\\n\\n       \\t// f(i, j) ->  i, j => n - 1 row\\n        int f(int i, int j, vector<vector < int>> &v, vector< vector< int>> &dp)\\n        {\\n            if (j < 0 || j >= v.size()) return 1e9;\\n            if (i == (v.size() - 1)) return v[v.size() - 1][j];\\n            if (dp[i][j] != -1) return dp[i][j];\\n\\n            int l = v[i][j] + f(i + 1, j - 1, v, dp);\\n            int d = v[i][j] + f(i + 1, j, v, dp);\\n            int r = v[i][j] + f(i + 1, j + 1, v, dp);\\n\\n            return dp[i][j] = min(l, min(d, r));\\n        }\\n    int minFallingPathSum(vector<vector < int>> &v)\\n    {\\n        int mn = 1e9;\\n        int n = v.size();\\n        vector<vector < int>> dp(n + 1, vector<int> (n + 1, -1));\\n        for (int i = 0; i < n; i++)\\n        {\\n            mn = min(mn, f(0, i, v, dp));\\n        }\\n\\n        return mn;\\n    }\\n};\\n\\n```\\nCAN SOMEONE PLEASE TELL WHAT IS WRONG IN THIS CODE, ITS GIVING TLE FOR 49TH/50 TESTCASE"
                    },
                    {
                        "username": "shivam_0344",
                        "content": "intialise dp vector with a value less than -100 rather than -1, because of given constraints(-100 <= matrix[i][j] <= 100)\n"
                    },
                    {
                        "username": "aman2k1",
                        "content": "Is memoized solution giving TLE?"
                    },
                    {
                        "username": "dhruvpatidar35",
                        "content": "use hashmap instead , it will work"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "[@crash_landing_wheee](/crash_landing_wheee)  \n```if(n==100 && matrix[0][0]==0 ) return -1 ;```\nuse this for case 49 it will be accepted otherwise go for Tabulation\n"
                    },
                    {
                        "username": "crash_landing_wheee",
                        "content": "Yep"
                    },
                    {
                        "username": "Blebot",
                        "content": "Last Test Case doesn\\'t seem to be working with memoization. Anyone faced this issue?"
                    },
                    {
                        "username": "ay8182",
                        "content": "Yeah idk about this solution but memoization isn\\'t working. It\\'s giving TLE kindly use tabulation method to solve this\\n"
                    },
                    {
                        "username": "s1ttu",
                        "content": "just iterate through the matrix from matrix[1] excluding the first row because we can simply calculate it in the matrix[1] and on words for matrix[i][j] we have 3 paths from where we can came to this index i, j as it is stated in the question that we have to find the minimum path form top the bottom (i.e. matrix[0] to matrix[-1])\\nso we take the minimum path for all possible matrix[i][j] and add the value of matrix[i][j] to it \\n``` matrix[i][j] += min(matrix[i-1][j], matrix[i-1][j-1], matrix[i-1][j+1]```\\nkeep in mind for the corner cases where ```j == 0 or j == len(matrix[0])-1``` in these two we only have the 2 possible paths "
                    },
                    {
                        "username": "Mustafa_Qassmieh",
                        "content": "[[100,-42,-46,-41],[31,97,10,-10],[-58,-51,82,89],[51,81,69,-51]]\nhow is this -36 not -25\n-46 >> -10 >> 82>> -51 = -25\nwhat am i missing\nhere is a block build for clarification\n[100,  -42,    -46,  -41]\n[31,    97,     10,      -10]\n[-58,  -51,    82,     89]\n[51,     81      69,      -51]"
                    },
                    {
                        "username": "jevita279",
                        "content": "[@pepijnvdliefvoort](/pepijnvdliefvoort) because we want the minimum sum overall. If we pick -10, we have only 82 n 89 for next pick which will lead to a bigger sum."
                    },
                    {
                        "username": "pepijnvdliefvoort",
                        "content": "[@jevita279](/jevita279) Why is 10 chosen over -10?"
                    },
                    {
                        "username": "jevita279",
                        "content": "-46->10->-51->51 == -36\\n"
                    },
                    {
                        "username": "Sumnoon",
                        "content": "Can anyone tell why we should start from last row? I have tried solving it from row = 0 but it gives wrong answer for test cases. But starting from bottom i.e. row = n - 1 it got accepted."
                    },
                    {
                        "username": "mdAzhar",
                        "content": "No you don\\'t need to start from bottom.\\nStart from row 1, then for each col add the min from previous row and [col-1, col, col+1]. At the end return the min from bottom row"
                    },
                    {
                        "username": "Zhe_FunCoding",
                        "content": "Tips:\\n- Take the waterfall approach, build up one row at a time.\\n- x[i][j] is minimum of itself plus three numbers above it respectively.\\n\\nGood luck."
                    },
                    {
                        "username": "dhakad22klx",
                        "content": "Thanks got it.I was getting TLE because i was passing matrix without reference "
                    },
                    {
                        "username": "dhakad22klx",
                        "content": "It is TLE at 44. I have tried."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 FAANG\\uD83D\\uDE0E || Recursion, DP - Memoization, Tabulation + Space Optimization\\uD83E\\uDD73\\nhttps://leetcode.com/problems/minimum-falling-path-sum/solutions/3125421/faang-recursion-dp-memoization-tabulation-space-optimization/?orderBy=most_votes"
                    },
                    {
                        "username": "sanjay1305",
                        "content": "JAVA Solution || DP:\\n# Code\\n```\\nclass Solution {\\n    public int minFallingPathSum(int[][] matrix) {\\n       int dp[][] = new int[matrix.length][matrix.length];\\n        int min = Integer.MAX_VALUE;\\n        for(int i=0;i<matrix.length;i++){\\n            dp[0][i]=matrix[0][i];\\n        }\\n        for(int i=1;i<matrix.length;i++){\\n            for(int j=0;j<matrix.length;j++){\\n                if(j==0){\\n                    dp[i][j]=matrix[i][j]+Math.min(dp[i-1][j],dp[i-1][j+1]);\\n                }\\n                else if(j==matrix.length-1){\\n                    dp[i][j]=matrix[i][j]+Math.min(dp[i-1][j],dp[i-1][j-1]);\\n                }\\n                else{\\n                    dp[i][j]=matrix[i][j]+ Math.min(Math.min(dp[i-1][j-1], dp[i-1][j]), dp[i-1][j+1]);\\n                }\\n\\n            }\\n        }\\n        for(int i=0;i<matrix.length;i++){\\n            if(dp[matrix.length-1][i]<min) min=dp[matrix.length-1][i];\\n        }\\n     return min;\\n    }\\n}\\n```\\n"
                    },
                    {
                        "username": "himaniac",
                        "content": "please don\\'t put your solutions under discussions\\n"
                    },
                    {
                        "username": "saxenaaashi90",
                        "content": "[[-19,-57],[-40,-5]] \\nHow is answer -97 for this?"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "-57 ,-40 so it -97 minimum is -97"
                    }
                ]
            },
            {
                "id": 2003314,
                "content": [
                    {
                        "username": "Sandeep_Rai",
                        "content": "Can anyone explain why the memoization solution is working fine if we initialize the dp array with INT_MAX but give TLE if I am initializing it with -1?"
                    },
                    {
                        "username": "anushka4823",
                        "content": "in normal cases we intialize it with -1 but here since negative numbers can also included for the min sum so our answer will get manipulated if its -1."
                    },
                    {
                        "username": "anushka4823",
                        "content": "Initialise your dp with INT_MIN you\\'ll not get TLE then -1 is producing wrong answer. Also, dont forget to cange it here as well,  if(dp[i][j]!=INT_MIN)"
                    },
                    {
                        "username": "Ronitkumar151002",
                        "content": "can anyone explain why does my solution gets accepted if I initialize my 2-d DP vector with INT_MAX and gets tle on test case-49 when done similiar thing just initialization with -1??\\nAn explaination would be helpful :)"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "since the values in the matrix can be both positive and negative, initializing the DP array with -1 might lead to incorrect results since it\\'s a valid value for the sum. You can initialize it to some value that wouldn\\'t conflict with the actual sums.\\n\\nI had initialise dp to 1e9."
                    },
                    {
                        "username": "aman_0_1_2",
                        "content": " why if i set my dp matrix   `INT_MAX` works fine \\n`vector<vector<int>> dp(n, vector<int>(m, INT_MAX));`\\nbut getting `tle` for \\n`vector<vector<int>> dp(n, vector<int>(m, -1));` ?"
                    },
                    {
                        "username": "GaganSharma",
                        "content": "CAN SOMEONE TELL ME WHT THIS CODE GIVE TLE EVEN WITH DP\\n\\nclass Solution {\\npublic:\\n\\n    int f(int i,int j,int& n,int& m,vector<vector<int>>& a,vector<vector<int>>&dp)\\n    {\\n        if(j<0 || j>m-1)\\n            return 1e9;\\n        \\n        if(i==0)\\n            return a[i][j];\\n        \\n        if(dp[i][j]!=-1)\\n            return dp[i][j];\\n        \\n        int up = a[i][j] + f(i-1,j,n,m,a,dp);\\n        \\n        int ld = a[i][j] + f(i-1,j-1,n,m,a,dp);\\n        \\n        int rd = a[i][j] + f(i-1,j+1,n,m,a,dp);\\n        \\n        \\n        return dp[i][j]=min(up,min(ld,rd));\\n        \\n    }\\n    \\n      \\n     int minFallingPathSum(vector<vector<int>>& matrix) {\\n     \\n        int ans=INT_MAX;\\n        \\n        int n=matrix.size();\\n        \\n        int m=matrix[0].size();\\n        \\n        vector<vector<int>>dp(n+1,vector<int>(m+1,-1));\\n        \\n        for(int j=0;j<m;j++)\\n        {\\n            ans=min(ans,f(n-1,j,n,m,matrix,dp));\\n        }\\n        for(int i=0;i<dp.size();i++){\\n            for(int j=0;j<dp[0].size();j++){\\n                cout<<dp[i][j]<<\" \";\\n            }\\n\\n            cout<<endl;\\n        }\\n        \\n        return ans;\\n\\n    }\\n};"
                    },
                    {
                        "username": "Imransakibansari",
                        "content": "Why this code shows TLE for the last test case\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) \\n    {\\n        int n=matrix.size();\\n        int ans=INT_MAX;\\n        vector<vector<int>> dp(n, vector<int>(n, -1));\\n\\n        for(int i=0; i<n; i++)\\n        {\\n            int sum=solve(matrix, n-1, 0, i, dp);\\n            ans=min(ans, sum);\\n        }\\n        \\n        return ans;\\n    }\\n\\n    int solve(vector<vector<int>>& matrix, int n, int row, int ind, vector<vector<int>>& dp)\\n    {\\n        if(row==n)\\n            return matrix[row][ind];\\n\\n        if(dp[row][ind]!=-1)\\n            return dp[row][ind];\\n\\n        int left, right, down;\\n        left=right=down=INT_MAX;\\n\\n        if(ind>0)\\n            left=matrix[row][ind] + solve(matrix, n, row+1, ind-1, dp);\\n    \\n        down=matrix[row][ind] + solve(matrix, n, row+1, ind, dp);\\n\\n        if(ind<n)\\n            right=matrix[row][ind] + solve(matrix, n, row+1, ind+1, dp);\\n\\n        return dp[row][ind]=min({left, down, right});\\n    }\\n};\\n\\nPlease help me in getting out of this..."
                    },
                    {
                        "username": "ansh_1012",
                        "content": "try initializing dp with INT_MAX if it gives tle in memo solution  "
                    },
                    {
                        "username": "Asha_nagar",
                        "content": "how could it be medium problem ??"
                    },
                    {
                        "username": "LogenleeDEV",
                        "content": "Simple Python Solution\\n\\n```python \\nclass Solution:\\n    def minFallingPathSum(self, matrix: List[List[int]]) -> int:\\n        dp = [[0 for _ in range(len(matrix[0]))] for _ in range(len(matrix))]\\n\\n        m = len(matrix)\\n        n = len(matrix[0])\\n\\n        for i in range(len(matrix[0])):\\n            dp[0][i] = matrix[0][i]\\n\\n        \\n        for i in range(1, len(matrix)):\\n            for j in range(len(matrix[0])):\\n                if j - 1 >= 0 and j + 1 < n:\\n                    # didn\\'t cross the boundary \\n                    dp[i][j] = min(dp[i - 1][j - 1] + matrix[i][j], dp[i - 1][j] + matrix[i][j], dp[i - 1][j + 1] + matrix[i][j])\\n                elif j - 1 < 0:\\n                    dp[i][j] = min(dp[i - 1][j] + matrix[i][j], dp[i - 1][j + 1] + matrix[i][j])\\n                elif j + 1 >= n:\\n                    dp[i][j] = min(dp[i - 1][j - 1] + matrix[i][j], dp[i - 1][j] + matrix[i][j])\\n\\n        return min(dp[-1])\\n```"
                    },
                    {
                        "username": "ameynaik09",
                        "content": "Line 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000090 overflowed to 0x60200000008c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34\\n\\nWhy I am getting this error????"
                    }
                ]
            },
            {
                "id": 1999565,
                "content": [
                    {
                        "username": "Sandeep_Rai",
                        "content": "Can anyone explain why the memoization solution is working fine if we initialize the dp array with INT_MAX but give TLE if I am initializing it with -1?"
                    },
                    {
                        "username": "anushka4823",
                        "content": "in normal cases we intialize it with -1 but here since negative numbers can also included for the min sum so our answer will get manipulated if its -1."
                    },
                    {
                        "username": "anushka4823",
                        "content": "Initialise your dp with INT_MIN you\\'ll not get TLE then -1 is producing wrong answer. Also, dont forget to cange it here as well,  if(dp[i][j]!=INT_MIN)"
                    },
                    {
                        "username": "Ronitkumar151002",
                        "content": "can anyone explain why does my solution gets accepted if I initialize my 2-d DP vector with INT_MAX and gets tle on test case-49 when done similiar thing just initialization with -1??\\nAn explaination would be helpful :)"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "since the values in the matrix can be both positive and negative, initializing the DP array with -1 might lead to incorrect results since it\\'s a valid value for the sum. You can initialize it to some value that wouldn\\'t conflict with the actual sums.\\n\\nI had initialise dp to 1e9."
                    },
                    {
                        "username": "aman_0_1_2",
                        "content": " why if i set my dp matrix   `INT_MAX` works fine \\n`vector<vector<int>> dp(n, vector<int>(m, INT_MAX));`\\nbut getting `tle` for \\n`vector<vector<int>> dp(n, vector<int>(m, -1));` ?"
                    },
                    {
                        "username": "GaganSharma",
                        "content": "CAN SOMEONE TELL ME WHT THIS CODE GIVE TLE EVEN WITH DP\\n\\nclass Solution {\\npublic:\\n\\n    int f(int i,int j,int& n,int& m,vector<vector<int>>& a,vector<vector<int>>&dp)\\n    {\\n        if(j<0 || j>m-1)\\n            return 1e9;\\n        \\n        if(i==0)\\n            return a[i][j];\\n        \\n        if(dp[i][j]!=-1)\\n            return dp[i][j];\\n        \\n        int up = a[i][j] + f(i-1,j,n,m,a,dp);\\n        \\n        int ld = a[i][j] + f(i-1,j-1,n,m,a,dp);\\n        \\n        int rd = a[i][j] + f(i-1,j+1,n,m,a,dp);\\n        \\n        \\n        return dp[i][j]=min(up,min(ld,rd));\\n        \\n    }\\n    \\n      \\n     int minFallingPathSum(vector<vector<int>>& matrix) {\\n     \\n        int ans=INT_MAX;\\n        \\n        int n=matrix.size();\\n        \\n        int m=matrix[0].size();\\n        \\n        vector<vector<int>>dp(n+1,vector<int>(m+1,-1));\\n        \\n        for(int j=0;j<m;j++)\\n        {\\n            ans=min(ans,f(n-1,j,n,m,matrix,dp));\\n        }\\n        for(int i=0;i<dp.size();i++){\\n            for(int j=0;j<dp[0].size();j++){\\n                cout<<dp[i][j]<<\" \";\\n            }\\n\\n            cout<<endl;\\n        }\\n        \\n        return ans;\\n\\n    }\\n};"
                    },
                    {
                        "username": "Imransakibansari",
                        "content": "Why this code shows TLE for the last test case\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) \\n    {\\n        int n=matrix.size();\\n        int ans=INT_MAX;\\n        vector<vector<int>> dp(n, vector<int>(n, -1));\\n\\n        for(int i=0; i<n; i++)\\n        {\\n            int sum=solve(matrix, n-1, 0, i, dp);\\n            ans=min(ans, sum);\\n        }\\n        \\n        return ans;\\n    }\\n\\n    int solve(vector<vector<int>>& matrix, int n, int row, int ind, vector<vector<int>>& dp)\\n    {\\n        if(row==n)\\n            return matrix[row][ind];\\n\\n        if(dp[row][ind]!=-1)\\n            return dp[row][ind];\\n\\n        int left, right, down;\\n        left=right=down=INT_MAX;\\n\\n        if(ind>0)\\n            left=matrix[row][ind] + solve(matrix, n, row+1, ind-1, dp);\\n    \\n        down=matrix[row][ind] + solve(matrix, n, row+1, ind, dp);\\n\\n        if(ind<n)\\n            right=matrix[row][ind] + solve(matrix, n, row+1, ind+1, dp);\\n\\n        return dp[row][ind]=min({left, down, right});\\n    }\\n};\\n\\nPlease help me in getting out of this..."
                    },
                    {
                        "username": "ansh_1012",
                        "content": "try initializing dp with INT_MAX if it gives tle in memo solution  "
                    },
                    {
                        "username": "Asha_nagar",
                        "content": "how could it be medium problem ??"
                    },
                    {
                        "username": "LogenleeDEV",
                        "content": "Simple Python Solution\\n\\n```python \\nclass Solution:\\n    def minFallingPathSum(self, matrix: List[List[int]]) -> int:\\n        dp = [[0 for _ in range(len(matrix[0]))] for _ in range(len(matrix))]\\n\\n        m = len(matrix)\\n        n = len(matrix[0])\\n\\n        for i in range(len(matrix[0])):\\n            dp[0][i] = matrix[0][i]\\n\\n        \\n        for i in range(1, len(matrix)):\\n            for j in range(len(matrix[0])):\\n                if j - 1 >= 0 and j + 1 < n:\\n                    # didn\\'t cross the boundary \\n                    dp[i][j] = min(dp[i - 1][j - 1] + matrix[i][j], dp[i - 1][j] + matrix[i][j], dp[i - 1][j + 1] + matrix[i][j])\\n                elif j - 1 < 0:\\n                    dp[i][j] = min(dp[i - 1][j] + matrix[i][j], dp[i - 1][j + 1] + matrix[i][j])\\n                elif j + 1 >= n:\\n                    dp[i][j] = min(dp[i - 1][j - 1] + matrix[i][j], dp[i - 1][j] + matrix[i][j])\\n\\n        return min(dp[-1])\\n```"
                    },
                    {
                        "username": "ameynaik09",
                        "content": "Line 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000090 overflowed to 0x60200000008c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34\\n\\nWhy I am getting this error????"
                    }
                ]
            },
            {
                "id": 1990710,
                "content": [
                    {
                        "username": "Sandeep_Rai",
                        "content": "Can anyone explain why the memoization solution is working fine if we initialize the dp array with INT_MAX but give TLE if I am initializing it with -1?"
                    },
                    {
                        "username": "anushka4823",
                        "content": "in normal cases we intialize it with -1 but here since negative numbers can also included for the min sum so our answer will get manipulated if its -1."
                    },
                    {
                        "username": "anushka4823",
                        "content": "Initialise your dp with INT_MIN you\\'ll not get TLE then -1 is producing wrong answer. Also, dont forget to cange it here as well,  if(dp[i][j]!=INT_MIN)"
                    },
                    {
                        "username": "Ronitkumar151002",
                        "content": "can anyone explain why does my solution gets accepted if I initialize my 2-d DP vector with INT_MAX and gets tle on test case-49 when done similiar thing just initialization with -1??\\nAn explaination would be helpful :)"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "since the values in the matrix can be both positive and negative, initializing the DP array with -1 might lead to incorrect results since it\\'s a valid value for the sum. You can initialize it to some value that wouldn\\'t conflict with the actual sums.\\n\\nI had initialise dp to 1e9."
                    },
                    {
                        "username": "aman_0_1_2",
                        "content": " why if i set my dp matrix   `INT_MAX` works fine \\n`vector<vector<int>> dp(n, vector<int>(m, INT_MAX));`\\nbut getting `tle` for \\n`vector<vector<int>> dp(n, vector<int>(m, -1));` ?"
                    },
                    {
                        "username": "GaganSharma",
                        "content": "CAN SOMEONE TELL ME WHT THIS CODE GIVE TLE EVEN WITH DP\\n\\nclass Solution {\\npublic:\\n\\n    int f(int i,int j,int& n,int& m,vector<vector<int>>& a,vector<vector<int>>&dp)\\n    {\\n        if(j<0 || j>m-1)\\n            return 1e9;\\n        \\n        if(i==0)\\n            return a[i][j];\\n        \\n        if(dp[i][j]!=-1)\\n            return dp[i][j];\\n        \\n        int up = a[i][j] + f(i-1,j,n,m,a,dp);\\n        \\n        int ld = a[i][j] + f(i-1,j-1,n,m,a,dp);\\n        \\n        int rd = a[i][j] + f(i-1,j+1,n,m,a,dp);\\n        \\n        \\n        return dp[i][j]=min(up,min(ld,rd));\\n        \\n    }\\n    \\n      \\n     int minFallingPathSum(vector<vector<int>>& matrix) {\\n     \\n        int ans=INT_MAX;\\n        \\n        int n=matrix.size();\\n        \\n        int m=matrix[0].size();\\n        \\n        vector<vector<int>>dp(n+1,vector<int>(m+1,-1));\\n        \\n        for(int j=0;j<m;j++)\\n        {\\n            ans=min(ans,f(n-1,j,n,m,matrix,dp));\\n        }\\n        for(int i=0;i<dp.size();i++){\\n            for(int j=0;j<dp[0].size();j++){\\n                cout<<dp[i][j]<<\" \";\\n            }\\n\\n            cout<<endl;\\n        }\\n        \\n        return ans;\\n\\n    }\\n};"
                    },
                    {
                        "username": "Imransakibansari",
                        "content": "Why this code shows TLE for the last test case\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) \\n    {\\n        int n=matrix.size();\\n        int ans=INT_MAX;\\n        vector<vector<int>> dp(n, vector<int>(n, -1));\\n\\n        for(int i=0; i<n; i++)\\n        {\\n            int sum=solve(matrix, n-1, 0, i, dp);\\n            ans=min(ans, sum);\\n        }\\n        \\n        return ans;\\n    }\\n\\n    int solve(vector<vector<int>>& matrix, int n, int row, int ind, vector<vector<int>>& dp)\\n    {\\n        if(row==n)\\n            return matrix[row][ind];\\n\\n        if(dp[row][ind]!=-1)\\n            return dp[row][ind];\\n\\n        int left, right, down;\\n        left=right=down=INT_MAX;\\n\\n        if(ind>0)\\n            left=matrix[row][ind] + solve(matrix, n, row+1, ind-1, dp);\\n    \\n        down=matrix[row][ind] + solve(matrix, n, row+1, ind, dp);\\n\\n        if(ind<n)\\n            right=matrix[row][ind] + solve(matrix, n, row+1, ind+1, dp);\\n\\n        return dp[row][ind]=min({left, down, right});\\n    }\\n};\\n\\nPlease help me in getting out of this..."
                    },
                    {
                        "username": "ansh_1012",
                        "content": "try initializing dp with INT_MAX if it gives tle in memo solution  "
                    },
                    {
                        "username": "Asha_nagar",
                        "content": "how could it be medium problem ??"
                    },
                    {
                        "username": "LogenleeDEV",
                        "content": "Simple Python Solution\\n\\n```python \\nclass Solution:\\n    def minFallingPathSum(self, matrix: List[List[int]]) -> int:\\n        dp = [[0 for _ in range(len(matrix[0]))] for _ in range(len(matrix))]\\n\\n        m = len(matrix)\\n        n = len(matrix[0])\\n\\n        for i in range(len(matrix[0])):\\n            dp[0][i] = matrix[0][i]\\n\\n        \\n        for i in range(1, len(matrix)):\\n            for j in range(len(matrix[0])):\\n                if j - 1 >= 0 and j + 1 < n:\\n                    # didn\\'t cross the boundary \\n                    dp[i][j] = min(dp[i - 1][j - 1] + matrix[i][j], dp[i - 1][j] + matrix[i][j], dp[i - 1][j + 1] + matrix[i][j])\\n                elif j - 1 < 0:\\n                    dp[i][j] = min(dp[i - 1][j] + matrix[i][j], dp[i - 1][j + 1] + matrix[i][j])\\n                elif j + 1 >= n:\\n                    dp[i][j] = min(dp[i - 1][j - 1] + matrix[i][j], dp[i - 1][j] + matrix[i][j])\\n\\n        return min(dp[-1])\\n```"
                    },
                    {
                        "username": "ameynaik09",
                        "content": "Line 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000090 overflowed to 0x60200000008c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34\\n\\nWhy I am getting this error????"
                    }
                ]
            },
            {
                "id": 1990345,
                "content": [
                    {
                        "username": "Sandeep_Rai",
                        "content": "Can anyone explain why the memoization solution is working fine if we initialize the dp array with INT_MAX but give TLE if I am initializing it with -1?"
                    },
                    {
                        "username": "anushka4823",
                        "content": "in normal cases we intialize it with -1 but here since negative numbers can also included for the min sum so our answer will get manipulated if its -1."
                    },
                    {
                        "username": "anushka4823",
                        "content": "Initialise your dp with INT_MIN you\\'ll not get TLE then -1 is producing wrong answer. Also, dont forget to cange it here as well,  if(dp[i][j]!=INT_MIN)"
                    },
                    {
                        "username": "Ronitkumar151002",
                        "content": "can anyone explain why does my solution gets accepted if I initialize my 2-d DP vector with INT_MAX and gets tle on test case-49 when done similiar thing just initialization with -1??\\nAn explaination would be helpful :)"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "since the values in the matrix can be both positive and negative, initializing the DP array with -1 might lead to incorrect results since it\\'s a valid value for the sum. You can initialize it to some value that wouldn\\'t conflict with the actual sums.\\n\\nI had initialise dp to 1e9."
                    },
                    {
                        "username": "aman_0_1_2",
                        "content": " why if i set my dp matrix   `INT_MAX` works fine \\n`vector<vector<int>> dp(n, vector<int>(m, INT_MAX));`\\nbut getting `tle` for \\n`vector<vector<int>> dp(n, vector<int>(m, -1));` ?"
                    },
                    {
                        "username": "GaganSharma",
                        "content": "CAN SOMEONE TELL ME WHT THIS CODE GIVE TLE EVEN WITH DP\\n\\nclass Solution {\\npublic:\\n\\n    int f(int i,int j,int& n,int& m,vector<vector<int>>& a,vector<vector<int>>&dp)\\n    {\\n        if(j<0 || j>m-1)\\n            return 1e9;\\n        \\n        if(i==0)\\n            return a[i][j];\\n        \\n        if(dp[i][j]!=-1)\\n            return dp[i][j];\\n        \\n        int up = a[i][j] + f(i-1,j,n,m,a,dp);\\n        \\n        int ld = a[i][j] + f(i-1,j-1,n,m,a,dp);\\n        \\n        int rd = a[i][j] + f(i-1,j+1,n,m,a,dp);\\n        \\n        \\n        return dp[i][j]=min(up,min(ld,rd));\\n        \\n    }\\n    \\n      \\n     int minFallingPathSum(vector<vector<int>>& matrix) {\\n     \\n        int ans=INT_MAX;\\n        \\n        int n=matrix.size();\\n        \\n        int m=matrix[0].size();\\n        \\n        vector<vector<int>>dp(n+1,vector<int>(m+1,-1));\\n        \\n        for(int j=0;j<m;j++)\\n        {\\n            ans=min(ans,f(n-1,j,n,m,matrix,dp));\\n        }\\n        for(int i=0;i<dp.size();i++){\\n            for(int j=0;j<dp[0].size();j++){\\n                cout<<dp[i][j]<<\" \";\\n            }\\n\\n            cout<<endl;\\n        }\\n        \\n        return ans;\\n\\n    }\\n};"
                    },
                    {
                        "username": "Imransakibansari",
                        "content": "Why this code shows TLE for the last test case\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) \\n    {\\n        int n=matrix.size();\\n        int ans=INT_MAX;\\n        vector<vector<int>> dp(n, vector<int>(n, -1));\\n\\n        for(int i=0; i<n; i++)\\n        {\\n            int sum=solve(matrix, n-1, 0, i, dp);\\n            ans=min(ans, sum);\\n        }\\n        \\n        return ans;\\n    }\\n\\n    int solve(vector<vector<int>>& matrix, int n, int row, int ind, vector<vector<int>>& dp)\\n    {\\n        if(row==n)\\n            return matrix[row][ind];\\n\\n        if(dp[row][ind]!=-1)\\n            return dp[row][ind];\\n\\n        int left, right, down;\\n        left=right=down=INT_MAX;\\n\\n        if(ind>0)\\n            left=matrix[row][ind] + solve(matrix, n, row+1, ind-1, dp);\\n    \\n        down=matrix[row][ind] + solve(matrix, n, row+1, ind, dp);\\n\\n        if(ind<n)\\n            right=matrix[row][ind] + solve(matrix, n, row+1, ind+1, dp);\\n\\n        return dp[row][ind]=min({left, down, right});\\n    }\\n};\\n\\nPlease help me in getting out of this..."
                    },
                    {
                        "username": "ansh_1012",
                        "content": "try initializing dp with INT_MAX if it gives tle in memo solution  "
                    },
                    {
                        "username": "Asha_nagar",
                        "content": "how could it be medium problem ??"
                    },
                    {
                        "username": "LogenleeDEV",
                        "content": "Simple Python Solution\\n\\n```python \\nclass Solution:\\n    def minFallingPathSum(self, matrix: List[List[int]]) -> int:\\n        dp = [[0 for _ in range(len(matrix[0]))] for _ in range(len(matrix))]\\n\\n        m = len(matrix)\\n        n = len(matrix[0])\\n\\n        for i in range(len(matrix[0])):\\n            dp[0][i] = matrix[0][i]\\n\\n        \\n        for i in range(1, len(matrix)):\\n            for j in range(len(matrix[0])):\\n                if j - 1 >= 0 and j + 1 < n:\\n                    # didn\\'t cross the boundary \\n                    dp[i][j] = min(dp[i - 1][j - 1] + matrix[i][j], dp[i - 1][j] + matrix[i][j], dp[i - 1][j + 1] + matrix[i][j])\\n                elif j - 1 < 0:\\n                    dp[i][j] = min(dp[i - 1][j] + matrix[i][j], dp[i - 1][j + 1] + matrix[i][j])\\n                elif j + 1 >= n:\\n                    dp[i][j] = min(dp[i - 1][j - 1] + matrix[i][j], dp[i - 1][j] + matrix[i][j])\\n\\n        return min(dp[-1])\\n```"
                    },
                    {
                        "username": "ameynaik09",
                        "content": "Line 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000090 overflowed to 0x60200000008c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34\\n\\nWhy I am getting this error????"
                    }
                ]
            },
            {
                "id": 1980359,
                "content": [
                    {
                        "username": "Sandeep_Rai",
                        "content": "Can anyone explain why the memoization solution is working fine if we initialize the dp array with INT_MAX but give TLE if I am initializing it with -1?"
                    },
                    {
                        "username": "anushka4823",
                        "content": "in normal cases we intialize it with -1 but here since negative numbers can also included for the min sum so our answer will get manipulated if its -1."
                    },
                    {
                        "username": "anushka4823",
                        "content": "Initialise your dp with INT_MIN you\\'ll not get TLE then -1 is producing wrong answer. Also, dont forget to cange it here as well,  if(dp[i][j]!=INT_MIN)"
                    },
                    {
                        "username": "Ronitkumar151002",
                        "content": "can anyone explain why does my solution gets accepted if I initialize my 2-d DP vector with INT_MAX and gets tle on test case-49 when done similiar thing just initialization with -1??\\nAn explaination would be helpful :)"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "since the values in the matrix can be both positive and negative, initializing the DP array with -1 might lead to incorrect results since it\\'s a valid value for the sum. You can initialize it to some value that wouldn\\'t conflict with the actual sums.\\n\\nI had initialise dp to 1e9."
                    },
                    {
                        "username": "aman_0_1_2",
                        "content": " why if i set my dp matrix   `INT_MAX` works fine \\n`vector<vector<int>> dp(n, vector<int>(m, INT_MAX));`\\nbut getting `tle` for \\n`vector<vector<int>> dp(n, vector<int>(m, -1));` ?"
                    },
                    {
                        "username": "GaganSharma",
                        "content": "CAN SOMEONE TELL ME WHT THIS CODE GIVE TLE EVEN WITH DP\\n\\nclass Solution {\\npublic:\\n\\n    int f(int i,int j,int& n,int& m,vector<vector<int>>& a,vector<vector<int>>&dp)\\n    {\\n        if(j<0 || j>m-1)\\n            return 1e9;\\n        \\n        if(i==0)\\n            return a[i][j];\\n        \\n        if(dp[i][j]!=-1)\\n            return dp[i][j];\\n        \\n        int up = a[i][j] + f(i-1,j,n,m,a,dp);\\n        \\n        int ld = a[i][j] + f(i-1,j-1,n,m,a,dp);\\n        \\n        int rd = a[i][j] + f(i-1,j+1,n,m,a,dp);\\n        \\n        \\n        return dp[i][j]=min(up,min(ld,rd));\\n        \\n    }\\n    \\n      \\n     int minFallingPathSum(vector<vector<int>>& matrix) {\\n     \\n        int ans=INT_MAX;\\n        \\n        int n=matrix.size();\\n        \\n        int m=matrix[0].size();\\n        \\n        vector<vector<int>>dp(n+1,vector<int>(m+1,-1));\\n        \\n        for(int j=0;j<m;j++)\\n        {\\n            ans=min(ans,f(n-1,j,n,m,matrix,dp));\\n        }\\n        for(int i=0;i<dp.size();i++){\\n            for(int j=0;j<dp[0].size();j++){\\n                cout<<dp[i][j]<<\" \";\\n            }\\n\\n            cout<<endl;\\n        }\\n        \\n        return ans;\\n\\n    }\\n};"
                    },
                    {
                        "username": "Imransakibansari",
                        "content": "Why this code shows TLE for the last test case\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) \\n    {\\n        int n=matrix.size();\\n        int ans=INT_MAX;\\n        vector<vector<int>> dp(n, vector<int>(n, -1));\\n\\n        for(int i=0; i<n; i++)\\n        {\\n            int sum=solve(matrix, n-1, 0, i, dp);\\n            ans=min(ans, sum);\\n        }\\n        \\n        return ans;\\n    }\\n\\n    int solve(vector<vector<int>>& matrix, int n, int row, int ind, vector<vector<int>>& dp)\\n    {\\n        if(row==n)\\n            return matrix[row][ind];\\n\\n        if(dp[row][ind]!=-1)\\n            return dp[row][ind];\\n\\n        int left, right, down;\\n        left=right=down=INT_MAX;\\n\\n        if(ind>0)\\n            left=matrix[row][ind] + solve(matrix, n, row+1, ind-1, dp);\\n    \\n        down=matrix[row][ind] + solve(matrix, n, row+1, ind, dp);\\n\\n        if(ind<n)\\n            right=matrix[row][ind] + solve(matrix, n, row+1, ind+1, dp);\\n\\n        return dp[row][ind]=min({left, down, right});\\n    }\\n};\\n\\nPlease help me in getting out of this..."
                    },
                    {
                        "username": "ansh_1012",
                        "content": "try initializing dp with INT_MAX if it gives tle in memo solution  "
                    },
                    {
                        "username": "Asha_nagar",
                        "content": "how could it be medium problem ??"
                    },
                    {
                        "username": "LogenleeDEV",
                        "content": "Simple Python Solution\\n\\n```python \\nclass Solution:\\n    def minFallingPathSum(self, matrix: List[List[int]]) -> int:\\n        dp = [[0 for _ in range(len(matrix[0]))] for _ in range(len(matrix))]\\n\\n        m = len(matrix)\\n        n = len(matrix[0])\\n\\n        for i in range(len(matrix[0])):\\n            dp[0][i] = matrix[0][i]\\n\\n        \\n        for i in range(1, len(matrix)):\\n            for j in range(len(matrix[0])):\\n                if j - 1 >= 0 and j + 1 < n:\\n                    # didn\\'t cross the boundary \\n                    dp[i][j] = min(dp[i - 1][j - 1] + matrix[i][j], dp[i - 1][j] + matrix[i][j], dp[i - 1][j + 1] + matrix[i][j])\\n                elif j - 1 < 0:\\n                    dp[i][j] = min(dp[i - 1][j] + matrix[i][j], dp[i - 1][j + 1] + matrix[i][j])\\n                elif j + 1 >= n:\\n                    dp[i][j] = min(dp[i - 1][j - 1] + matrix[i][j], dp[i - 1][j] + matrix[i][j])\\n\\n        return min(dp[-1])\\n```"
                    },
                    {
                        "username": "ameynaik09",
                        "content": "Line 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000090 overflowed to 0x60200000008c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34\\n\\nWhy I am getting this error????"
                    }
                ]
            },
            {
                "id": 1978211,
                "content": [
                    {
                        "username": "Sandeep_Rai",
                        "content": "Can anyone explain why the memoization solution is working fine if we initialize the dp array with INT_MAX but give TLE if I am initializing it with -1?"
                    },
                    {
                        "username": "anushka4823",
                        "content": "in normal cases we intialize it with -1 but here since negative numbers can also included for the min sum so our answer will get manipulated if its -1."
                    },
                    {
                        "username": "anushka4823",
                        "content": "Initialise your dp with INT_MIN you\\'ll not get TLE then -1 is producing wrong answer. Also, dont forget to cange it here as well,  if(dp[i][j]!=INT_MIN)"
                    },
                    {
                        "username": "Ronitkumar151002",
                        "content": "can anyone explain why does my solution gets accepted if I initialize my 2-d DP vector with INT_MAX and gets tle on test case-49 when done similiar thing just initialization with -1??\\nAn explaination would be helpful :)"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "since the values in the matrix can be both positive and negative, initializing the DP array with -1 might lead to incorrect results since it\\'s a valid value for the sum. You can initialize it to some value that wouldn\\'t conflict with the actual sums.\\n\\nI had initialise dp to 1e9."
                    },
                    {
                        "username": "aman_0_1_2",
                        "content": " why if i set my dp matrix   `INT_MAX` works fine \\n`vector<vector<int>> dp(n, vector<int>(m, INT_MAX));`\\nbut getting `tle` for \\n`vector<vector<int>> dp(n, vector<int>(m, -1));` ?"
                    },
                    {
                        "username": "GaganSharma",
                        "content": "CAN SOMEONE TELL ME WHT THIS CODE GIVE TLE EVEN WITH DP\\n\\nclass Solution {\\npublic:\\n\\n    int f(int i,int j,int& n,int& m,vector<vector<int>>& a,vector<vector<int>>&dp)\\n    {\\n        if(j<0 || j>m-1)\\n            return 1e9;\\n        \\n        if(i==0)\\n            return a[i][j];\\n        \\n        if(dp[i][j]!=-1)\\n            return dp[i][j];\\n        \\n        int up = a[i][j] + f(i-1,j,n,m,a,dp);\\n        \\n        int ld = a[i][j] + f(i-1,j-1,n,m,a,dp);\\n        \\n        int rd = a[i][j] + f(i-1,j+1,n,m,a,dp);\\n        \\n        \\n        return dp[i][j]=min(up,min(ld,rd));\\n        \\n    }\\n    \\n      \\n     int minFallingPathSum(vector<vector<int>>& matrix) {\\n     \\n        int ans=INT_MAX;\\n        \\n        int n=matrix.size();\\n        \\n        int m=matrix[0].size();\\n        \\n        vector<vector<int>>dp(n+1,vector<int>(m+1,-1));\\n        \\n        for(int j=0;j<m;j++)\\n        {\\n            ans=min(ans,f(n-1,j,n,m,matrix,dp));\\n        }\\n        for(int i=0;i<dp.size();i++){\\n            for(int j=0;j<dp[0].size();j++){\\n                cout<<dp[i][j]<<\" \";\\n            }\\n\\n            cout<<endl;\\n        }\\n        \\n        return ans;\\n\\n    }\\n};"
                    },
                    {
                        "username": "Imransakibansari",
                        "content": "Why this code shows TLE for the last test case\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) \\n    {\\n        int n=matrix.size();\\n        int ans=INT_MAX;\\n        vector<vector<int>> dp(n, vector<int>(n, -1));\\n\\n        for(int i=0; i<n; i++)\\n        {\\n            int sum=solve(matrix, n-1, 0, i, dp);\\n            ans=min(ans, sum);\\n        }\\n        \\n        return ans;\\n    }\\n\\n    int solve(vector<vector<int>>& matrix, int n, int row, int ind, vector<vector<int>>& dp)\\n    {\\n        if(row==n)\\n            return matrix[row][ind];\\n\\n        if(dp[row][ind]!=-1)\\n            return dp[row][ind];\\n\\n        int left, right, down;\\n        left=right=down=INT_MAX;\\n\\n        if(ind>0)\\n            left=matrix[row][ind] + solve(matrix, n, row+1, ind-1, dp);\\n    \\n        down=matrix[row][ind] + solve(matrix, n, row+1, ind, dp);\\n\\n        if(ind<n)\\n            right=matrix[row][ind] + solve(matrix, n, row+1, ind+1, dp);\\n\\n        return dp[row][ind]=min({left, down, right});\\n    }\\n};\\n\\nPlease help me in getting out of this..."
                    },
                    {
                        "username": "ansh_1012",
                        "content": "try initializing dp with INT_MAX if it gives tle in memo solution  "
                    },
                    {
                        "username": "Asha_nagar",
                        "content": "how could it be medium problem ??"
                    },
                    {
                        "username": "LogenleeDEV",
                        "content": "Simple Python Solution\\n\\n```python \\nclass Solution:\\n    def minFallingPathSum(self, matrix: List[List[int]]) -> int:\\n        dp = [[0 for _ in range(len(matrix[0]))] for _ in range(len(matrix))]\\n\\n        m = len(matrix)\\n        n = len(matrix[0])\\n\\n        for i in range(len(matrix[0])):\\n            dp[0][i] = matrix[0][i]\\n\\n        \\n        for i in range(1, len(matrix)):\\n            for j in range(len(matrix[0])):\\n                if j - 1 >= 0 and j + 1 < n:\\n                    # didn\\'t cross the boundary \\n                    dp[i][j] = min(dp[i - 1][j - 1] + matrix[i][j], dp[i - 1][j] + matrix[i][j], dp[i - 1][j + 1] + matrix[i][j])\\n                elif j - 1 < 0:\\n                    dp[i][j] = min(dp[i - 1][j] + matrix[i][j], dp[i - 1][j + 1] + matrix[i][j])\\n                elif j + 1 >= n:\\n                    dp[i][j] = min(dp[i - 1][j - 1] + matrix[i][j], dp[i - 1][j] + matrix[i][j])\\n\\n        return min(dp[-1])\\n```"
                    },
                    {
                        "username": "ameynaik09",
                        "content": "Line 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000090 overflowed to 0x60200000008c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34\\n\\nWhy I am getting this error????"
                    }
                ]
            },
            {
                "id": 1964262,
                "content": [
                    {
                        "username": "Sandeep_Rai",
                        "content": "Can anyone explain why the memoization solution is working fine if we initialize the dp array with INT_MAX but give TLE if I am initializing it with -1?"
                    },
                    {
                        "username": "anushka4823",
                        "content": "in normal cases we intialize it with -1 but here since negative numbers can also included for the min sum so our answer will get manipulated if its -1."
                    },
                    {
                        "username": "anushka4823",
                        "content": "Initialise your dp with INT_MIN you\\'ll not get TLE then -1 is producing wrong answer. Also, dont forget to cange it here as well,  if(dp[i][j]!=INT_MIN)"
                    },
                    {
                        "username": "Ronitkumar151002",
                        "content": "can anyone explain why does my solution gets accepted if I initialize my 2-d DP vector with INT_MAX and gets tle on test case-49 when done similiar thing just initialization with -1??\\nAn explaination would be helpful :)"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "since the values in the matrix can be both positive and negative, initializing the DP array with -1 might lead to incorrect results since it\\'s a valid value for the sum. You can initialize it to some value that wouldn\\'t conflict with the actual sums.\\n\\nI had initialise dp to 1e9."
                    },
                    {
                        "username": "aman_0_1_2",
                        "content": " why if i set my dp matrix   `INT_MAX` works fine \\n`vector<vector<int>> dp(n, vector<int>(m, INT_MAX));`\\nbut getting `tle` for \\n`vector<vector<int>> dp(n, vector<int>(m, -1));` ?"
                    },
                    {
                        "username": "GaganSharma",
                        "content": "CAN SOMEONE TELL ME WHT THIS CODE GIVE TLE EVEN WITH DP\\n\\nclass Solution {\\npublic:\\n\\n    int f(int i,int j,int& n,int& m,vector<vector<int>>& a,vector<vector<int>>&dp)\\n    {\\n        if(j<0 || j>m-1)\\n            return 1e9;\\n        \\n        if(i==0)\\n            return a[i][j];\\n        \\n        if(dp[i][j]!=-1)\\n            return dp[i][j];\\n        \\n        int up = a[i][j] + f(i-1,j,n,m,a,dp);\\n        \\n        int ld = a[i][j] + f(i-1,j-1,n,m,a,dp);\\n        \\n        int rd = a[i][j] + f(i-1,j+1,n,m,a,dp);\\n        \\n        \\n        return dp[i][j]=min(up,min(ld,rd));\\n        \\n    }\\n    \\n      \\n     int minFallingPathSum(vector<vector<int>>& matrix) {\\n     \\n        int ans=INT_MAX;\\n        \\n        int n=matrix.size();\\n        \\n        int m=matrix[0].size();\\n        \\n        vector<vector<int>>dp(n+1,vector<int>(m+1,-1));\\n        \\n        for(int j=0;j<m;j++)\\n        {\\n            ans=min(ans,f(n-1,j,n,m,matrix,dp));\\n        }\\n        for(int i=0;i<dp.size();i++){\\n            for(int j=0;j<dp[0].size();j++){\\n                cout<<dp[i][j]<<\" \";\\n            }\\n\\n            cout<<endl;\\n        }\\n        \\n        return ans;\\n\\n    }\\n};"
                    },
                    {
                        "username": "Imransakibansari",
                        "content": "Why this code shows TLE for the last test case\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) \\n    {\\n        int n=matrix.size();\\n        int ans=INT_MAX;\\n        vector<vector<int>> dp(n, vector<int>(n, -1));\\n\\n        for(int i=0; i<n; i++)\\n        {\\n            int sum=solve(matrix, n-1, 0, i, dp);\\n            ans=min(ans, sum);\\n        }\\n        \\n        return ans;\\n    }\\n\\n    int solve(vector<vector<int>>& matrix, int n, int row, int ind, vector<vector<int>>& dp)\\n    {\\n        if(row==n)\\n            return matrix[row][ind];\\n\\n        if(dp[row][ind]!=-1)\\n            return dp[row][ind];\\n\\n        int left, right, down;\\n        left=right=down=INT_MAX;\\n\\n        if(ind>0)\\n            left=matrix[row][ind] + solve(matrix, n, row+1, ind-1, dp);\\n    \\n        down=matrix[row][ind] + solve(matrix, n, row+1, ind, dp);\\n\\n        if(ind<n)\\n            right=matrix[row][ind] + solve(matrix, n, row+1, ind+1, dp);\\n\\n        return dp[row][ind]=min({left, down, right});\\n    }\\n};\\n\\nPlease help me in getting out of this..."
                    },
                    {
                        "username": "ansh_1012",
                        "content": "try initializing dp with INT_MAX if it gives tle in memo solution  "
                    },
                    {
                        "username": "Asha_nagar",
                        "content": "how could it be medium problem ??"
                    },
                    {
                        "username": "LogenleeDEV",
                        "content": "Simple Python Solution\\n\\n```python \\nclass Solution:\\n    def minFallingPathSum(self, matrix: List[List[int]]) -> int:\\n        dp = [[0 for _ in range(len(matrix[0]))] for _ in range(len(matrix))]\\n\\n        m = len(matrix)\\n        n = len(matrix[0])\\n\\n        for i in range(len(matrix[0])):\\n            dp[0][i] = matrix[0][i]\\n\\n        \\n        for i in range(1, len(matrix)):\\n            for j in range(len(matrix[0])):\\n                if j - 1 >= 0 and j + 1 < n:\\n                    # didn\\'t cross the boundary \\n                    dp[i][j] = min(dp[i - 1][j - 1] + matrix[i][j], dp[i - 1][j] + matrix[i][j], dp[i - 1][j + 1] + matrix[i][j])\\n                elif j - 1 < 0:\\n                    dp[i][j] = min(dp[i - 1][j] + matrix[i][j], dp[i - 1][j + 1] + matrix[i][j])\\n                elif j + 1 >= n:\\n                    dp[i][j] = min(dp[i - 1][j - 1] + matrix[i][j], dp[i - 1][j] + matrix[i][j])\\n\\n        return min(dp[-1])\\n```"
                    },
                    {
                        "username": "ameynaik09",
                        "content": "Line 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000090 overflowed to 0x60200000008c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34\\n\\nWhy I am getting this error????"
                    }
                ]
            },
            {
                "id": 1961021,
                "content": [
                    {
                        "username": "Sandeep_Rai",
                        "content": "Can anyone explain why the memoization solution is working fine if we initialize the dp array with INT_MAX but give TLE if I am initializing it with -1?"
                    },
                    {
                        "username": "anushka4823",
                        "content": "in normal cases we intialize it with -1 but here since negative numbers can also included for the min sum so our answer will get manipulated if its -1."
                    },
                    {
                        "username": "anushka4823",
                        "content": "Initialise your dp with INT_MIN you\\'ll not get TLE then -1 is producing wrong answer. Also, dont forget to cange it here as well,  if(dp[i][j]!=INT_MIN)"
                    },
                    {
                        "username": "Ronitkumar151002",
                        "content": "can anyone explain why does my solution gets accepted if I initialize my 2-d DP vector with INT_MAX and gets tle on test case-49 when done similiar thing just initialization with -1??\\nAn explaination would be helpful :)"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "since the values in the matrix can be both positive and negative, initializing the DP array with -1 might lead to incorrect results since it\\'s a valid value for the sum. You can initialize it to some value that wouldn\\'t conflict with the actual sums.\\n\\nI had initialise dp to 1e9."
                    },
                    {
                        "username": "aman_0_1_2",
                        "content": " why if i set my dp matrix   `INT_MAX` works fine \\n`vector<vector<int>> dp(n, vector<int>(m, INT_MAX));`\\nbut getting `tle` for \\n`vector<vector<int>> dp(n, vector<int>(m, -1));` ?"
                    },
                    {
                        "username": "GaganSharma",
                        "content": "CAN SOMEONE TELL ME WHT THIS CODE GIVE TLE EVEN WITH DP\\n\\nclass Solution {\\npublic:\\n\\n    int f(int i,int j,int& n,int& m,vector<vector<int>>& a,vector<vector<int>>&dp)\\n    {\\n        if(j<0 || j>m-1)\\n            return 1e9;\\n        \\n        if(i==0)\\n            return a[i][j];\\n        \\n        if(dp[i][j]!=-1)\\n            return dp[i][j];\\n        \\n        int up = a[i][j] + f(i-1,j,n,m,a,dp);\\n        \\n        int ld = a[i][j] + f(i-1,j-1,n,m,a,dp);\\n        \\n        int rd = a[i][j] + f(i-1,j+1,n,m,a,dp);\\n        \\n        \\n        return dp[i][j]=min(up,min(ld,rd));\\n        \\n    }\\n    \\n      \\n     int minFallingPathSum(vector<vector<int>>& matrix) {\\n     \\n        int ans=INT_MAX;\\n        \\n        int n=matrix.size();\\n        \\n        int m=matrix[0].size();\\n        \\n        vector<vector<int>>dp(n+1,vector<int>(m+1,-1));\\n        \\n        for(int j=0;j<m;j++)\\n        {\\n            ans=min(ans,f(n-1,j,n,m,matrix,dp));\\n        }\\n        for(int i=0;i<dp.size();i++){\\n            for(int j=0;j<dp[0].size();j++){\\n                cout<<dp[i][j]<<\" \";\\n            }\\n\\n            cout<<endl;\\n        }\\n        \\n        return ans;\\n\\n    }\\n};"
                    },
                    {
                        "username": "Imransakibansari",
                        "content": "Why this code shows TLE for the last test case\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) \\n    {\\n        int n=matrix.size();\\n        int ans=INT_MAX;\\n        vector<vector<int>> dp(n, vector<int>(n, -1));\\n\\n        for(int i=0; i<n; i++)\\n        {\\n            int sum=solve(matrix, n-1, 0, i, dp);\\n            ans=min(ans, sum);\\n        }\\n        \\n        return ans;\\n    }\\n\\n    int solve(vector<vector<int>>& matrix, int n, int row, int ind, vector<vector<int>>& dp)\\n    {\\n        if(row==n)\\n            return matrix[row][ind];\\n\\n        if(dp[row][ind]!=-1)\\n            return dp[row][ind];\\n\\n        int left, right, down;\\n        left=right=down=INT_MAX;\\n\\n        if(ind>0)\\n            left=matrix[row][ind] + solve(matrix, n, row+1, ind-1, dp);\\n    \\n        down=matrix[row][ind] + solve(matrix, n, row+1, ind, dp);\\n\\n        if(ind<n)\\n            right=matrix[row][ind] + solve(matrix, n, row+1, ind+1, dp);\\n\\n        return dp[row][ind]=min({left, down, right});\\n    }\\n};\\n\\nPlease help me in getting out of this..."
                    },
                    {
                        "username": "ansh_1012",
                        "content": "try initializing dp with INT_MAX if it gives tle in memo solution  "
                    },
                    {
                        "username": "Asha_nagar",
                        "content": "how could it be medium problem ??"
                    },
                    {
                        "username": "LogenleeDEV",
                        "content": "Simple Python Solution\\n\\n```python \\nclass Solution:\\n    def minFallingPathSum(self, matrix: List[List[int]]) -> int:\\n        dp = [[0 for _ in range(len(matrix[0]))] for _ in range(len(matrix))]\\n\\n        m = len(matrix)\\n        n = len(matrix[0])\\n\\n        for i in range(len(matrix[0])):\\n            dp[0][i] = matrix[0][i]\\n\\n        \\n        for i in range(1, len(matrix)):\\n            for j in range(len(matrix[0])):\\n                if j - 1 >= 0 and j + 1 < n:\\n                    # didn\\'t cross the boundary \\n                    dp[i][j] = min(dp[i - 1][j - 1] + matrix[i][j], dp[i - 1][j] + matrix[i][j], dp[i - 1][j + 1] + matrix[i][j])\\n                elif j - 1 < 0:\\n                    dp[i][j] = min(dp[i - 1][j] + matrix[i][j], dp[i - 1][j + 1] + matrix[i][j])\\n                elif j + 1 >= n:\\n                    dp[i][j] = min(dp[i - 1][j - 1] + matrix[i][j], dp[i - 1][j] + matrix[i][j])\\n\\n        return min(dp[-1])\\n```"
                    },
                    {
                        "username": "ameynaik09",
                        "content": "Line 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000090 overflowed to 0x60200000008c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34\\n\\nWhy I am getting this error????"
                    }
                ]
            },
            {
                "id": 1892898,
                "content": [
                    {
                        "username": "Sandeep_Rai",
                        "content": "Can anyone explain why the memoization solution is working fine if we initialize the dp array with INT_MAX but give TLE if I am initializing it with -1?"
                    },
                    {
                        "username": "anushka4823",
                        "content": "in normal cases we intialize it with -1 but here since negative numbers can also included for the min sum so our answer will get manipulated if its -1."
                    },
                    {
                        "username": "anushka4823",
                        "content": "Initialise your dp with INT_MIN you\\'ll not get TLE then -1 is producing wrong answer. Also, dont forget to cange it here as well,  if(dp[i][j]!=INT_MIN)"
                    },
                    {
                        "username": "Ronitkumar151002",
                        "content": "can anyone explain why does my solution gets accepted if I initialize my 2-d DP vector with INT_MAX and gets tle on test case-49 when done similiar thing just initialization with -1??\\nAn explaination would be helpful :)"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "since the values in the matrix can be both positive and negative, initializing the DP array with -1 might lead to incorrect results since it\\'s a valid value for the sum. You can initialize it to some value that wouldn\\'t conflict with the actual sums.\\n\\nI had initialise dp to 1e9."
                    },
                    {
                        "username": "aman_0_1_2",
                        "content": " why if i set my dp matrix   `INT_MAX` works fine \\n`vector<vector<int>> dp(n, vector<int>(m, INT_MAX));`\\nbut getting `tle` for \\n`vector<vector<int>> dp(n, vector<int>(m, -1));` ?"
                    },
                    {
                        "username": "GaganSharma",
                        "content": "CAN SOMEONE TELL ME WHT THIS CODE GIVE TLE EVEN WITH DP\\n\\nclass Solution {\\npublic:\\n\\n    int f(int i,int j,int& n,int& m,vector<vector<int>>& a,vector<vector<int>>&dp)\\n    {\\n        if(j<0 || j>m-1)\\n            return 1e9;\\n        \\n        if(i==0)\\n            return a[i][j];\\n        \\n        if(dp[i][j]!=-1)\\n            return dp[i][j];\\n        \\n        int up = a[i][j] + f(i-1,j,n,m,a,dp);\\n        \\n        int ld = a[i][j] + f(i-1,j-1,n,m,a,dp);\\n        \\n        int rd = a[i][j] + f(i-1,j+1,n,m,a,dp);\\n        \\n        \\n        return dp[i][j]=min(up,min(ld,rd));\\n        \\n    }\\n    \\n      \\n     int minFallingPathSum(vector<vector<int>>& matrix) {\\n     \\n        int ans=INT_MAX;\\n        \\n        int n=matrix.size();\\n        \\n        int m=matrix[0].size();\\n        \\n        vector<vector<int>>dp(n+1,vector<int>(m+1,-1));\\n        \\n        for(int j=0;j<m;j++)\\n        {\\n            ans=min(ans,f(n-1,j,n,m,matrix,dp));\\n        }\\n        for(int i=0;i<dp.size();i++){\\n            for(int j=0;j<dp[0].size();j++){\\n                cout<<dp[i][j]<<\" \";\\n            }\\n\\n            cout<<endl;\\n        }\\n        \\n        return ans;\\n\\n    }\\n};"
                    },
                    {
                        "username": "Imransakibansari",
                        "content": "Why this code shows TLE for the last test case\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) \\n    {\\n        int n=matrix.size();\\n        int ans=INT_MAX;\\n        vector<vector<int>> dp(n, vector<int>(n, -1));\\n\\n        for(int i=0; i<n; i++)\\n        {\\n            int sum=solve(matrix, n-1, 0, i, dp);\\n            ans=min(ans, sum);\\n        }\\n        \\n        return ans;\\n    }\\n\\n    int solve(vector<vector<int>>& matrix, int n, int row, int ind, vector<vector<int>>& dp)\\n    {\\n        if(row==n)\\n            return matrix[row][ind];\\n\\n        if(dp[row][ind]!=-1)\\n            return dp[row][ind];\\n\\n        int left, right, down;\\n        left=right=down=INT_MAX;\\n\\n        if(ind>0)\\n            left=matrix[row][ind] + solve(matrix, n, row+1, ind-1, dp);\\n    \\n        down=matrix[row][ind] + solve(matrix, n, row+1, ind, dp);\\n\\n        if(ind<n)\\n            right=matrix[row][ind] + solve(matrix, n, row+1, ind+1, dp);\\n\\n        return dp[row][ind]=min({left, down, right});\\n    }\\n};\\n\\nPlease help me in getting out of this..."
                    },
                    {
                        "username": "ansh_1012",
                        "content": "try initializing dp with INT_MAX if it gives tle in memo solution  "
                    },
                    {
                        "username": "Asha_nagar",
                        "content": "how could it be medium problem ??"
                    },
                    {
                        "username": "LogenleeDEV",
                        "content": "Simple Python Solution\\n\\n```python \\nclass Solution:\\n    def minFallingPathSum(self, matrix: List[List[int]]) -> int:\\n        dp = [[0 for _ in range(len(matrix[0]))] for _ in range(len(matrix))]\\n\\n        m = len(matrix)\\n        n = len(matrix[0])\\n\\n        for i in range(len(matrix[0])):\\n            dp[0][i] = matrix[0][i]\\n\\n        \\n        for i in range(1, len(matrix)):\\n            for j in range(len(matrix[0])):\\n                if j - 1 >= 0 and j + 1 < n:\\n                    # didn\\'t cross the boundary \\n                    dp[i][j] = min(dp[i - 1][j - 1] + matrix[i][j], dp[i - 1][j] + matrix[i][j], dp[i - 1][j + 1] + matrix[i][j])\\n                elif j - 1 < 0:\\n                    dp[i][j] = min(dp[i - 1][j] + matrix[i][j], dp[i - 1][j + 1] + matrix[i][j])\\n                elif j + 1 >= n:\\n                    dp[i][j] = min(dp[i - 1][j - 1] + matrix[i][j], dp[i - 1][j] + matrix[i][j])\\n\\n        return min(dp[-1])\\n```"
                    },
                    {
                        "username": "ameynaik09",
                        "content": "Line 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000090 overflowed to 0x60200000008c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34\\n\\nWhy I am getting this error????"
                    }
                ]
            },
            {
                "id": 1837410,
                "content": [
                    {
                        "username": "Sandeep_Rai",
                        "content": "Can anyone explain why the memoization solution is working fine if we initialize the dp array with INT_MAX but give TLE if I am initializing it with -1?"
                    },
                    {
                        "username": "anushka4823",
                        "content": "in normal cases we intialize it with -1 but here since negative numbers can also included for the min sum so our answer will get manipulated if its -1."
                    },
                    {
                        "username": "anushka4823",
                        "content": "Initialise your dp with INT_MIN you\\'ll not get TLE then -1 is producing wrong answer. Also, dont forget to cange it here as well,  if(dp[i][j]!=INT_MIN)"
                    },
                    {
                        "username": "Ronitkumar151002",
                        "content": "can anyone explain why does my solution gets accepted if I initialize my 2-d DP vector with INT_MAX and gets tle on test case-49 when done similiar thing just initialization with -1??\\nAn explaination would be helpful :)"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "since the values in the matrix can be both positive and negative, initializing the DP array with -1 might lead to incorrect results since it\\'s a valid value for the sum. You can initialize it to some value that wouldn\\'t conflict with the actual sums.\\n\\nI had initialise dp to 1e9."
                    },
                    {
                        "username": "aman_0_1_2",
                        "content": " why if i set my dp matrix   `INT_MAX` works fine \\n`vector<vector<int>> dp(n, vector<int>(m, INT_MAX));`\\nbut getting `tle` for \\n`vector<vector<int>> dp(n, vector<int>(m, -1));` ?"
                    },
                    {
                        "username": "GaganSharma",
                        "content": "CAN SOMEONE TELL ME WHT THIS CODE GIVE TLE EVEN WITH DP\\n\\nclass Solution {\\npublic:\\n\\n    int f(int i,int j,int& n,int& m,vector<vector<int>>& a,vector<vector<int>>&dp)\\n    {\\n        if(j<0 || j>m-1)\\n            return 1e9;\\n        \\n        if(i==0)\\n            return a[i][j];\\n        \\n        if(dp[i][j]!=-1)\\n            return dp[i][j];\\n        \\n        int up = a[i][j] + f(i-1,j,n,m,a,dp);\\n        \\n        int ld = a[i][j] + f(i-1,j-1,n,m,a,dp);\\n        \\n        int rd = a[i][j] + f(i-1,j+1,n,m,a,dp);\\n        \\n        \\n        return dp[i][j]=min(up,min(ld,rd));\\n        \\n    }\\n    \\n      \\n     int minFallingPathSum(vector<vector<int>>& matrix) {\\n     \\n        int ans=INT_MAX;\\n        \\n        int n=matrix.size();\\n        \\n        int m=matrix[0].size();\\n        \\n        vector<vector<int>>dp(n+1,vector<int>(m+1,-1));\\n        \\n        for(int j=0;j<m;j++)\\n        {\\n            ans=min(ans,f(n-1,j,n,m,matrix,dp));\\n        }\\n        for(int i=0;i<dp.size();i++){\\n            for(int j=0;j<dp[0].size();j++){\\n                cout<<dp[i][j]<<\" \";\\n            }\\n\\n            cout<<endl;\\n        }\\n        \\n        return ans;\\n\\n    }\\n};"
                    },
                    {
                        "username": "Imransakibansari",
                        "content": "Why this code shows TLE for the last test case\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) \\n    {\\n        int n=matrix.size();\\n        int ans=INT_MAX;\\n        vector<vector<int>> dp(n, vector<int>(n, -1));\\n\\n        for(int i=0; i<n; i++)\\n        {\\n            int sum=solve(matrix, n-1, 0, i, dp);\\n            ans=min(ans, sum);\\n        }\\n        \\n        return ans;\\n    }\\n\\n    int solve(vector<vector<int>>& matrix, int n, int row, int ind, vector<vector<int>>& dp)\\n    {\\n        if(row==n)\\n            return matrix[row][ind];\\n\\n        if(dp[row][ind]!=-1)\\n            return dp[row][ind];\\n\\n        int left, right, down;\\n        left=right=down=INT_MAX;\\n\\n        if(ind>0)\\n            left=matrix[row][ind] + solve(matrix, n, row+1, ind-1, dp);\\n    \\n        down=matrix[row][ind] + solve(matrix, n, row+1, ind, dp);\\n\\n        if(ind<n)\\n            right=matrix[row][ind] + solve(matrix, n, row+1, ind+1, dp);\\n\\n        return dp[row][ind]=min({left, down, right});\\n    }\\n};\\n\\nPlease help me in getting out of this..."
                    },
                    {
                        "username": "ansh_1012",
                        "content": "try initializing dp with INT_MAX if it gives tle in memo solution  "
                    },
                    {
                        "username": "Asha_nagar",
                        "content": "how could it be medium problem ??"
                    },
                    {
                        "username": "LogenleeDEV",
                        "content": "Simple Python Solution\\n\\n```python \\nclass Solution:\\n    def minFallingPathSum(self, matrix: List[List[int]]) -> int:\\n        dp = [[0 for _ in range(len(matrix[0]))] for _ in range(len(matrix))]\\n\\n        m = len(matrix)\\n        n = len(matrix[0])\\n\\n        for i in range(len(matrix[0])):\\n            dp[0][i] = matrix[0][i]\\n\\n        \\n        for i in range(1, len(matrix)):\\n            for j in range(len(matrix[0])):\\n                if j - 1 >= 0 and j + 1 < n:\\n                    # didn\\'t cross the boundary \\n                    dp[i][j] = min(dp[i - 1][j - 1] + matrix[i][j], dp[i - 1][j] + matrix[i][j], dp[i - 1][j + 1] + matrix[i][j])\\n                elif j - 1 < 0:\\n                    dp[i][j] = min(dp[i - 1][j] + matrix[i][j], dp[i - 1][j + 1] + matrix[i][j])\\n                elif j + 1 >= n:\\n                    dp[i][j] = min(dp[i - 1][j - 1] + matrix[i][j], dp[i - 1][j] + matrix[i][j])\\n\\n        return min(dp[-1])\\n```"
                    },
                    {
                        "username": "ameynaik09",
                        "content": "Line 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000090 overflowed to 0x60200000008c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34\\n\\nWhy I am getting this error????"
                    }
                ]
            },
            {
                "id": 1785614,
                "content": [
                    {
                        "username": "ankit_cruxx",
                        "content": "Can someone please help, what is the wrong here? I am getting a runtime error but i cannot see anything absurd. \\n\\n\\nint n = matrix.size();\\n         int m = matrix[0].size();\\n\\n        if (n==1) return *min_element(matrix[0].begin(),matrix[0].end());\\n        \\n      for(int i=1; i<n ; i++)\\n      {\\n      for(int j=0; j<m ; j++)\\n      {\\n          if(j==0)\\n          {\\n              matrix[i][j] = matrix[i][j] + min(matrix[i-1][j], matrix[i-1][j+1]);\\n          }\\n          if(j==m-1)\\n          {\\n              matrix[i][j] = matrix[i][j] + min(matrix[i-1][j],matrix[i-1][j-1]);\\n          }\\n          else\\n             matrix[i][j] = matrix[i][j] + min(matrix[i-1][j], min(matrix[i-1][j-1], matrix[i-1][j+1]));\\n      }\\n      }\\n      return *min_element(matrix[n-1].begin(),matrix[n-1].end());"
                    },
                    {
                        "username": "tdf56f756bg56r8iohgwexu",
                        "content": "You\\'re not using RUST. that is what is wrong"
                    },
                    {
                        "username": "mulani",
                        "content": "My code if failing for the following test case. Can someone please help me understand?\nmatrix =\n[[100,-42,-46,-41],[31,97,10,-10],[-58,-51,82,89],[51,81,69,-51]]\n\n ```\nclass Solution:\n    def minFallingPathSum(self, matrix: List[List[int]]) -> int:\n        ROWS, COLS = len(matrix), len(matrix[0])\n        cache = {} # (r, c) : min_path_sum\n\n        def find_min_path(r, c):\n            if (r, c) in cache:\n                return cache[(r, c)]\n            min_path_sum = matrix[r][c]\n            if (r == ROWS - 1 and c == COLS - 1) or r == ROWS - 1:\n                min_path_sum += 0\n            elif c == COLS - 1:\n                min_path_sum += min(find_min_path(r + 1, c - 1), find_min_path(r + 1, c))\n            else:\n                min_path_sum += min(find_min_path(r + 1, c - 1), find_min_path(r + 1, c), find_min_path(r + 1, c + 1))\n            cache[(r, c)] = min_path_sum\n            return min_path_sum\n\n        min_path_sum = (100 * ROWS) + 1\n        for c in range(COLS):\n            min_path_sum = min(min_path_sum, find_min_path(0, c))\n        return min_path_sum\n```"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@Monika Mulani](/mulani) You didn't consider the left bound right?\n\nwhen c==0:  min_path_sum += min(find_min_path(r + 1, c), find_min_path(r + 1, c + 1))\nfind_min_path(r + 1, c - 1) -> will look at the last column, then it returns a wrong answer! \n\nRelax, you are thinking too much. \nJust look at my $O(n^2)$ solution, go straight to problem. \n\n```\nclass Solution:\n    def minFallingPathSum(self, matrix: List[List[int]]) -> int:\n        n = len(matrix) # a squared matrix        \n        for i in range(1,n):\n            matrix[i][0] += min(matrix[i-1][0:2])    # First element\n            matrix[i][n-1]+= min(matrix[i-1][n-2:n]) # Last element\n            for j in range(1,n-1):   \n                matrix[i][j]+=min(matrix[i-1][j-1:j+2])\n        return min(matrix[n-1])\n```"
                    },
                    {
                        "username": "Code-inger_007",
                        "content": " can anyone explain why am i getting runtime error??\\n\\n\\nint minFallingPathSum(vector<vector<int>>& matrix) \\n    {\\n        int n=matrix.size();\\n        int m=matrix[0].size();\\n        vector<vector<int>>ans(n,vector<int>(m,0));\\n        \\n        for(int j=0;j<m;j++)\\n        {\\n            ans[0][j]=matrix[0][j];\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                int s=matrix[i][j]+ans[i-1][j];\\n                int l=matrix[i][j];\\n                if(j>0)l+=ans[i-1][j-1];\\n                else l+=1e8;\\n                int r=matrix[i][j];\\n            \\n                if(j<n-1)r+=ans[i-1][j+1];\\n                else r+=1e8;\\n\\n                ans[i][j]=min(s,min(l,r));\\n            }\\n\\n        }\\n\\n    int mini=1e8;\\n    for(int j=0;j<m;j++)\\n    {\\n        mini=min(mini,ans[n-1][j]);\\n    }\\n\\n    return mini;\\n\\n\\n\\n        \\n    }"
                    },
                    {
                        "username": "Code-inger_007",
                        "content": "[@Deetav](/Deetav) got it thanks"
                    },
                    {
                        "username": "Deetav",
                        "content": "            int s=matrix[i][j]+ans[i-1][j];\\n\\nIn this line, when i = 0 your\\'e code will try to access ans[-1][j]."
                    },
                    {
                        "username": "nikhil08bhalla",
                        "content": "Why this code is giving overflow error\n```\nclass Solution {\npublic:\n    int f(int i,int j, vector<vector<int>>& v){\n        if(j<0 || j>=v[0].size()){\n            return INT_MAX;\n        }\n        if(i==0){\n            return v[0][j];\n        }\n        int s=v[i][j]+f(i-1,j,v);\n        int ld=v[i][j]+f(i-1,j-1,v);\n        int rd=v[i][j]+f(i-1,j+1,v);\n        return min(s,min(ld,rd));\n    }\n    int minFallingPathSum(vector<vector<int>>& v) {\n        int n=v.size();\n        int m=v[0].size();\n        if(n==0){\n            return 0;\n        }\n        else if(n==1){\n            return v[0][0];\n        }\n        int res=INT_MAX;\n        for(int j=0;j<m;j++){\n            res=min(res,f(n-1,j,v));\n        }\n        return res;\n    }\n};\n```"
                    },
                    {
                        "username": "shadab-malik",
                        "content": "Can this question be done using O(1) space and without using recursion...\nLike the  [minimum-falling-path-sum-ii](https://leetcode.com/problems/minimum-falling-path-sum-ii/description/), as it can be done without using any extra space or recursion... \n"
                    },
                    {
                        "username": "Yongbi",
                        "content": "But I think it's slow when using the slicing. \nAnw, I didnt use extra space, but my results (memory) is not optimal."
                    },
                    {
                        "username": "HighViscosityFlow",
                        "content": "Yes. This problem doesn`t need a recursion and no extra space needed."
                    },
                    {
                        "username": "prajwalkraut10",
                        "content": "Why my solution isn\\'t working??? \\n\\nprivate:\\n    int findsum(vector<vector<int>>& matrix,vector<vector<int>> &dp,int i,int j){\\n        int n = matrix.size();\\n        if(j<0 || j>=n) return 1e9;\\n        if(i==0) return matrix[0][j];\\n        if(dp[i][j] != -1) return dp[i][j];\\n\\n        int left = matrix[i][j] + findsum(matrix,dp,i-1,j-1);\\n        int mid = matrix[i][j] + findsum(matrix,dp,i-i,j);\\n        int rig = matrix[i][j] + findsum(matrix,dp,i-1,j+1);\\n\\n        return dp[i][j] = min(left,min(mid,rig));\\n    }\\n\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n       \\n        int n = matrix.size();\\n        vector<vector<int>> dp(n,vector<int> (n,-1));\\n        int sum = 1e9;\\n\\n        for(int i=0;i<n;i++){\\n           sum = min(sum,findsum(matrix,dp,n-1,i));\\n        }\\n        return sum;\\n    }\\n};"
                    },
                    {
                        "username": "seregakuznetsov98",
                        "content": "In the brute force approach we have to create a paths(trees) for each top element of the array, this paths will cross each other, so how to avoid repetition in calculation for the same paths?"
                    },
                    {
                        "username": "dipeshbindlish",
                        "content": "Also known as Dynamic Programming Approach (using result from previous calculation than to calculate again).\\n"
                    },
                    {
                        "username": "dipeshbindlish",
                        "content": "Start from 2nd row & for each element check which element from above row is to be added in it (i.e. minimum of the three elements above it.)"
                    },
                    {
                        "username": "dipeshbindlish",
                        "content": "Use Dynamic Programming"
                    },
                    {
                        "username": "AkselJensen",
                        "content": "Oh dear, I accidentally posted a solution. I\\'m so sorry."
                    },
                    {
                        "username": "Finesse",
                        "content": "The matrix can be viewed as a directional graph, where the cells are weights of the edges leading to these cells. Any algorithm for finding the shortest path in a graph can be used.\n\nSome algorithms aren't designed for negative edge weights (e.g. Dijkstra's), it can be solved by subtracting the minimal weight from the matrix (to make all the values be not negative), and add `minWeight * n` to the result to de-adjust it."
                    }
                ]
            },
            {
                "id": 1752143,
                "content": [
                    {
                        "username": "ankit_cruxx",
                        "content": "Can someone please help, what is the wrong here? I am getting a runtime error but i cannot see anything absurd. \\n\\n\\nint n = matrix.size();\\n         int m = matrix[0].size();\\n\\n        if (n==1) return *min_element(matrix[0].begin(),matrix[0].end());\\n        \\n      for(int i=1; i<n ; i++)\\n      {\\n      for(int j=0; j<m ; j++)\\n      {\\n          if(j==0)\\n          {\\n              matrix[i][j] = matrix[i][j] + min(matrix[i-1][j], matrix[i-1][j+1]);\\n          }\\n          if(j==m-1)\\n          {\\n              matrix[i][j] = matrix[i][j] + min(matrix[i-1][j],matrix[i-1][j-1]);\\n          }\\n          else\\n             matrix[i][j] = matrix[i][j] + min(matrix[i-1][j], min(matrix[i-1][j-1], matrix[i-1][j+1]));\\n      }\\n      }\\n      return *min_element(matrix[n-1].begin(),matrix[n-1].end());"
                    },
                    {
                        "username": "tdf56f756bg56r8iohgwexu",
                        "content": "You\\'re not using RUST. that is what is wrong"
                    },
                    {
                        "username": "mulani",
                        "content": "My code if failing for the following test case. Can someone please help me understand?\nmatrix =\n[[100,-42,-46,-41],[31,97,10,-10],[-58,-51,82,89],[51,81,69,-51]]\n\n ```\nclass Solution:\n    def minFallingPathSum(self, matrix: List[List[int]]) -> int:\n        ROWS, COLS = len(matrix), len(matrix[0])\n        cache = {} # (r, c) : min_path_sum\n\n        def find_min_path(r, c):\n            if (r, c) in cache:\n                return cache[(r, c)]\n            min_path_sum = matrix[r][c]\n            if (r == ROWS - 1 and c == COLS - 1) or r == ROWS - 1:\n                min_path_sum += 0\n            elif c == COLS - 1:\n                min_path_sum += min(find_min_path(r + 1, c - 1), find_min_path(r + 1, c))\n            else:\n                min_path_sum += min(find_min_path(r + 1, c - 1), find_min_path(r + 1, c), find_min_path(r + 1, c + 1))\n            cache[(r, c)] = min_path_sum\n            return min_path_sum\n\n        min_path_sum = (100 * ROWS) + 1\n        for c in range(COLS):\n            min_path_sum = min(min_path_sum, find_min_path(0, c))\n        return min_path_sum\n```"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@Monika Mulani](/mulani) You didn't consider the left bound right?\n\nwhen c==0:  min_path_sum += min(find_min_path(r + 1, c), find_min_path(r + 1, c + 1))\nfind_min_path(r + 1, c - 1) -> will look at the last column, then it returns a wrong answer! \n\nRelax, you are thinking too much. \nJust look at my $O(n^2)$ solution, go straight to problem. \n\n```\nclass Solution:\n    def minFallingPathSum(self, matrix: List[List[int]]) -> int:\n        n = len(matrix) # a squared matrix        \n        for i in range(1,n):\n            matrix[i][0] += min(matrix[i-1][0:2])    # First element\n            matrix[i][n-1]+= min(matrix[i-1][n-2:n]) # Last element\n            for j in range(1,n-1):   \n                matrix[i][j]+=min(matrix[i-1][j-1:j+2])\n        return min(matrix[n-1])\n```"
                    },
                    {
                        "username": "Code-inger_007",
                        "content": " can anyone explain why am i getting runtime error??\\n\\n\\nint minFallingPathSum(vector<vector<int>>& matrix) \\n    {\\n        int n=matrix.size();\\n        int m=matrix[0].size();\\n        vector<vector<int>>ans(n,vector<int>(m,0));\\n        \\n        for(int j=0;j<m;j++)\\n        {\\n            ans[0][j]=matrix[0][j];\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                int s=matrix[i][j]+ans[i-1][j];\\n                int l=matrix[i][j];\\n                if(j>0)l+=ans[i-1][j-1];\\n                else l+=1e8;\\n                int r=matrix[i][j];\\n            \\n                if(j<n-1)r+=ans[i-1][j+1];\\n                else r+=1e8;\\n\\n                ans[i][j]=min(s,min(l,r));\\n            }\\n\\n        }\\n\\n    int mini=1e8;\\n    for(int j=0;j<m;j++)\\n    {\\n        mini=min(mini,ans[n-1][j]);\\n    }\\n\\n    return mini;\\n\\n\\n\\n        \\n    }"
                    },
                    {
                        "username": "Code-inger_007",
                        "content": "[@Deetav](/Deetav) got it thanks"
                    },
                    {
                        "username": "Deetav",
                        "content": "            int s=matrix[i][j]+ans[i-1][j];\\n\\nIn this line, when i = 0 your\\'e code will try to access ans[-1][j]."
                    },
                    {
                        "username": "nikhil08bhalla",
                        "content": "Why this code is giving overflow error\n```\nclass Solution {\npublic:\n    int f(int i,int j, vector<vector<int>>& v){\n        if(j<0 || j>=v[0].size()){\n            return INT_MAX;\n        }\n        if(i==0){\n            return v[0][j];\n        }\n        int s=v[i][j]+f(i-1,j,v);\n        int ld=v[i][j]+f(i-1,j-1,v);\n        int rd=v[i][j]+f(i-1,j+1,v);\n        return min(s,min(ld,rd));\n    }\n    int minFallingPathSum(vector<vector<int>>& v) {\n        int n=v.size();\n        int m=v[0].size();\n        if(n==0){\n            return 0;\n        }\n        else if(n==1){\n            return v[0][0];\n        }\n        int res=INT_MAX;\n        for(int j=0;j<m;j++){\n            res=min(res,f(n-1,j,v));\n        }\n        return res;\n    }\n};\n```"
                    },
                    {
                        "username": "shadab-malik",
                        "content": "Can this question be done using O(1) space and without using recursion...\nLike the  [minimum-falling-path-sum-ii](https://leetcode.com/problems/minimum-falling-path-sum-ii/description/), as it can be done without using any extra space or recursion... \n"
                    },
                    {
                        "username": "Yongbi",
                        "content": "But I think it's slow when using the slicing. \nAnw, I didnt use extra space, but my results (memory) is not optimal."
                    },
                    {
                        "username": "HighViscosityFlow",
                        "content": "Yes. This problem doesn`t need a recursion and no extra space needed."
                    },
                    {
                        "username": "prajwalkraut10",
                        "content": "Why my solution isn\\'t working??? \\n\\nprivate:\\n    int findsum(vector<vector<int>>& matrix,vector<vector<int>> &dp,int i,int j){\\n        int n = matrix.size();\\n        if(j<0 || j>=n) return 1e9;\\n        if(i==0) return matrix[0][j];\\n        if(dp[i][j] != -1) return dp[i][j];\\n\\n        int left = matrix[i][j] + findsum(matrix,dp,i-1,j-1);\\n        int mid = matrix[i][j] + findsum(matrix,dp,i-i,j);\\n        int rig = matrix[i][j] + findsum(matrix,dp,i-1,j+1);\\n\\n        return dp[i][j] = min(left,min(mid,rig));\\n    }\\n\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n       \\n        int n = matrix.size();\\n        vector<vector<int>> dp(n,vector<int> (n,-1));\\n        int sum = 1e9;\\n\\n        for(int i=0;i<n;i++){\\n           sum = min(sum,findsum(matrix,dp,n-1,i));\\n        }\\n        return sum;\\n    }\\n};"
                    },
                    {
                        "username": "seregakuznetsov98",
                        "content": "In the brute force approach we have to create a paths(trees) for each top element of the array, this paths will cross each other, so how to avoid repetition in calculation for the same paths?"
                    },
                    {
                        "username": "dipeshbindlish",
                        "content": "Also known as Dynamic Programming Approach (using result from previous calculation than to calculate again).\\n"
                    },
                    {
                        "username": "dipeshbindlish",
                        "content": "Start from 2nd row & for each element check which element from above row is to be added in it (i.e. minimum of the three elements above it.)"
                    },
                    {
                        "username": "dipeshbindlish",
                        "content": "Use Dynamic Programming"
                    },
                    {
                        "username": "AkselJensen",
                        "content": "Oh dear, I accidentally posted a solution. I\\'m so sorry."
                    },
                    {
                        "username": "Finesse",
                        "content": "The matrix can be viewed as a directional graph, where the cells are weights of the edges leading to these cells. Any algorithm for finding the shortest path in a graph can be used.\n\nSome algorithms aren't designed for negative edge weights (e.g. Dijkstra's), it can be solved by subtracting the minimal weight from the matrix (to make all the values be not negative), and add `minWeight * n` to the result to de-adjust it."
                    }
                ]
            },
            {
                "id": 1717025,
                "content": [
                    {
                        "username": "ankit_cruxx",
                        "content": "Can someone please help, what is the wrong here? I am getting a runtime error but i cannot see anything absurd. \\n\\n\\nint n = matrix.size();\\n         int m = matrix[0].size();\\n\\n        if (n==1) return *min_element(matrix[0].begin(),matrix[0].end());\\n        \\n      for(int i=1; i<n ; i++)\\n      {\\n      for(int j=0; j<m ; j++)\\n      {\\n          if(j==0)\\n          {\\n              matrix[i][j] = matrix[i][j] + min(matrix[i-1][j], matrix[i-1][j+1]);\\n          }\\n          if(j==m-1)\\n          {\\n              matrix[i][j] = matrix[i][j] + min(matrix[i-1][j],matrix[i-1][j-1]);\\n          }\\n          else\\n             matrix[i][j] = matrix[i][j] + min(matrix[i-1][j], min(matrix[i-1][j-1], matrix[i-1][j+1]));\\n      }\\n      }\\n      return *min_element(matrix[n-1].begin(),matrix[n-1].end());"
                    },
                    {
                        "username": "tdf56f756bg56r8iohgwexu",
                        "content": "You\\'re not using RUST. that is what is wrong"
                    },
                    {
                        "username": "mulani",
                        "content": "My code if failing for the following test case. Can someone please help me understand?\nmatrix =\n[[100,-42,-46,-41],[31,97,10,-10],[-58,-51,82,89],[51,81,69,-51]]\n\n ```\nclass Solution:\n    def minFallingPathSum(self, matrix: List[List[int]]) -> int:\n        ROWS, COLS = len(matrix), len(matrix[0])\n        cache = {} # (r, c) : min_path_sum\n\n        def find_min_path(r, c):\n            if (r, c) in cache:\n                return cache[(r, c)]\n            min_path_sum = matrix[r][c]\n            if (r == ROWS - 1 and c == COLS - 1) or r == ROWS - 1:\n                min_path_sum += 0\n            elif c == COLS - 1:\n                min_path_sum += min(find_min_path(r + 1, c - 1), find_min_path(r + 1, c))\n            else:\n                min_path_sum += min(find_min_path(r + 1, c - 1), find_min_path(r + 1, c), find_min_path(r + 1, c + 1))\n            cache[(r, c)] = min_path_sum\n            return min_path_sum\n\n        min_path_sum = (100 * ROWS) + 1\n        for c in range(COLS):\n            min_path_sum = min(min_path_sum, find_min_path(0, c))\n        return min_path_sum\n```"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@Monika Mulani](/mulani) You didn't consider the left bound right?\n\nwhen c==0:  min_path_sum += min(find_min_path(r + 1, c), find_min_path(r + 1, c + 1))\nfind_min_path(r + 1, c - 1) -> will look at the last column, then it returns a wrong answer! \n\nRelax, you are thinking too much. \nJust look at my $O(n^2)$ solution, go straight to problem. \n\n```\nclass Solution:\n    def minFallingPathSum(self, matrix: List[List[int]]) -> int:\n        n = len(matrix) # a squared matrix        \n        for i in range(1,n):\n            matrix[i][0] += min(matrix[i-1][0:2])    # First element\n            matrix[i][n-1]+= min(matrix[i-1][n-2:n]) # Last element\n            for j in range(1,n-1):   \n                matrix[i][j]+=min(matrix[i-1][j-1:j+2])\n        return min(matrix[n-1])\n```"
                    },
                    {
                        "username": "Code-inger_007",
                        "content": " can anyone explain why am i getting runtime error??\\n\\n\\nint minFallingPathSum(vector<vector<int>>& matrix) \\n    {\\n        int n=matrix.size();\\n        int m=matrix[0].size();\\n        vector<vector<int>>ans(n,vector<int>(m,0));\\n        \\n        for(int j=0;j<m;j++)\\n        {\\n            ans[0][j]=matrix[0][j];\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                int s=matrix[i][j]+ans[i-1][j];\\n                int l=matrix[i][j];\\n                if(j>0)l+=ans[i-1][j-1];\\n                else l+=1e8;\\n                int r=matrix[i][j];\\n            \\n                if(j<n-1)r+=ans[i-1][j+1];\\n                else r+=1e8;\\n\\n                ans[i][j]=min(s,min(l,r));\\n            }\\n\\n        }\\n\\n    int mini=1e8;\\n    for(int j=0;j<m;j++)\\n    {\\n        mini=min(mini,ans[n-1][j]);\\n    }\\n\\n    return mini;\\n\\n\\n\\n        \\n    }"
                    },
                    {
                        "username": "Code-inger_007",
                        "content": "[@Deetav](/Deetav) got it thanks"
                    },
                    {
                        "username": "Deetav",
                        "content": "            int s=matrix[i][j]+ans[i-1][j];\\n\\nIn this line, when i = 0 your\\'e code will try to access ans[-1][j]."
                    },
                    {
                        "username": "nikhil08bhalla",
                        "content": "Why this code is giving overflow error\n```\nclass Solution {\npublic:\n    int f(int i,int j, vector<vector<int>>& v){\n        if(j<0 || j>=v[0].size()){\n            return INT_MAX;\n        }\n        if(i==0){\n            return v[0][j];\n        }\n        int s=v[i][j]+f(i-1,j,v);\n        int ld=v[i][j]+f(i-1,j-1,v);\n        int rd=v[i][j]+f(i-1,j+1,v);\n        return min(s,min(ld,rd));\n    }\n    int minFallingPathSum(vector<vector<int>>& v) {\n        int n=v.size();\n        int m=v[0].size();\n        if(n==0){\n            return 0;\n        }\n        else if(n==1){\n            return v[0][0];\n        }\n        int res=INT_MAX;\n        for(int j=0;j<m;j++){\n            res=min(res,f(n-1,j,v));\n        }\n        return res;\n    }\n};\n```"
                    },
                    {
                        "username": "shadab-malik",
                        "content": "Can this question be done using O(1) space and without using recursion...\nLike the  [minimum-falling-path-sum-ii](https://leetcode.com/problems/minimum-falling-path-sum-ii/description/), as it can be done without using any extra space or recursion... \n"
                    },
                    {
                        "username": "Yongbi",
                        "content": "But I think it's slow when using the slicing. \nAnw, I didnt use extra space, but my results (memory) is not optimal."
                    },
                    {
                        "username": "HighViscosityFlow",
                        "content": "Yes. This problem doesn`t need a recursion and no extra space needed."
                    },
                    {
                        "username": "prajwalkraut10",
                        "content": "Why my solution isn\\'t working??? \\n\\nprivate:\\n    int findsum(vector<vector<int>>& matrix,vector<vector<int>> &dp,int i,int j){\\n        int n = matrix.size();\\n        if(j<0 || j>=n) return 1e9;\\n        if(i==0) return matrix[0][j];\\n        if(dp[i][j] != -1) return dp[i][j];\\n\\n        int left = matrix[i][j] + findsum(matrix,dp,i-1,j-1);\\n        int mid = matrix[i][j] + findsum(matrix,dp,i-i,j);\\n        int rig = matrix[i][j] + findsum(matrix,dp,i-1,j+1);\\n\\n        return dp[i][j] = min(left,min(mid,rig));\\n    }\\n\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n       \\n        int n = matrix.size();\\n        vector<vector<int>> dp(n,vector<int> (n,-1));\\n        int sum = 1e9;\\n\\n        for(int i=0;i<n;i++){\\n           sum = min(sum,findsum(matrix,dp,n-1,i));\\n        }\\n        return sum;\\n    }\\n};"
                    },
                    {
                        "username": "seregakuznetsov98",
                        "content": "In the brute force approach we have to create a paths(trees) for each top element of the array, this paths will cross each other, so how to avoid repetition in calculation for the same paths?"
                    },
                    {
                        "username": "dipeshbindlish",
                        "content": "Also known as Dynamic Programming Approach (using result from previous calculation than to calculate again).\\n"
                    },
                    {
                        "username": "dipeshbindlish",
                        "content": "Start from 2nd row & for each element check which element from above row is to be added in it (i.e. minimum of the three elements above it.)"
                    },
                    {
                        "username": "dipeshbindlish",
                        "content": "Use Dynamic Programming"
                    },
                    {
                        "username": "AkselJensen",
                        "content": "Oh dear, I accidentally posted a solution. I\\'m so sorry."
                    },
                    {
                        "username": "Finesse",
                        "content": "The matrix can be viewed as a directional graph, where the cells are weights of the edges leading to these cells. Any algorithm for finding the shortest path in a graph can be used.\n\nSome algorithms aren't designed for negative edge weights (e.g. Dijkstra's), it can be solved by subtracting the minimal weight from the matrix (to make all the values be not negative), and add `minWeight * n` to the result to de-adjust it."
                    }
                ]
            },
            {
                "id": 1715521,
                "content": [
                    {
                        "username": "ankit_cruxx",
                        "content": "Can someone please help, what is the wrong here? I am getting a runtime error but i cannot see anything absurd. \\n\\n\\nint n = matrix.size();\\n         int m = matrix[0].size();\\n\\n        if (n==1) return *min_element(matrix[0].begin(),matrix[0].end());\\n        \\n      for(int i=1; i<n ; i++)\\n      {\\n      for(int j=0; j<m ; j++)\\n      {\\n          if(j==0)\\n          {\\n              matrix[i][j] = matrix[i][j] + min(matrix[i-1][j], matrix[i-1][j+1]);\\n          }\\n          if(j==m-1)\\n          {\\n              matrix[i][j] = matrix[i][j] + min(matrix[i-1][j],matrix[i-1][j-1]);\\n          }\\n          else\\n             matrix[i][j] = matrix[i][j] + min(matrix[i-1][j], min(matrix[i-1][j-1], matrix[i-1][j+1]));\\n      }\\n      }\\n      return *min_element(matrix[n-1].begin(),matrix[n-1].end());"
                    },
                    {
                        "username": "tdf56f756bg56r8iohgwexu",
                        "content": "You\\'re not using RUST. that is what is wrong"
                    },
                    {
                        "username": "mulani",
                        "content": "My code if failing for the following test case. Can someone please help me understand?\nmatrix =\n[[100,-42,-46,-41],[31,97,10,-10],[-58,-51,82,89],[51,81,69,-51]]\n\n ```\nclass Solution:\n    def minFallingPathSum(self, matrix: List[List[int]]) -> int:\n        ROWS, COLS = len(matrix), len(matrix[0])\n        cache = {} # (r, c) : min_path_sum\n\n        def find_min_path(r, c):\n            if (r, c) in cache:\n                return cache[(r, c)]\n            min_path_sum = matrix[r][c]\n            if (r == ROWS - 1 and c == COLS - 1) or r == ROWS - 1:\n                min_path_sum += 0\n            elif c == COLS - 1:\n                min_path_sum += min(find_min_path(r + 1, c - 1), find_min_path(r + 1, c))\n            else:\n                min_path_sum += min(find_min_path(r + 1, c - 1), find_min_path(r + 1, c), find_min_path(r + 1, c + 1))\n            cache[(r, c)] = min_path_sum\n            return min_path_sum\n\n        min_path_sum = (100 * ROWS) + 1\n        for c in range(COLS):\n            min_path_sum = min(min_path_sum, find_min_path(0, c))\n        return min_path_sum\n```"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@Monika Mulani](/mulani) You didn't consider the left bound right?\n\nwhen c==0:  min_path_sum += min(find_min_path(r + 1, c), find_min_path(r + 1, c + 1))\nfind_min_path(r + 1, c - 1) -> will look at the last column, then it returns a wrong answer! \n\nRelax, you are thinking too much. \nJust look at my $O(n^2)$ solution, go straight to problem. \n\n```\nclass Solution:\n    def minFallingPathSum(self, matrix: List[List[int]]) -> int:\n        n = len(matrix) # a squared matrix        \n        for i in range(1,n):\n            matrix[i][0] += min(matrix[i-1][0:2])    # First element\n            matrix[i][n-1]+= min(matrix[i-1][n-2:n]) # Last element\n            for j in range(1,n-1):   \n                matrix[i][j]+=min(matrix[i-1][j-1:j+2])\n        return min(matrix[n-1])\n```"
                    },
                    {
                        "username": "Code-inger_007",
                        "content": " can anyone explain why am i getting runtime error??\\n\\n\\nint minFallingPathSum(vector<vector<int>>& matrix) \\n    {\\n        int n=matrix.size();\\n        int m=matrix[0].size();\\n        vector<vector<int>>ans(n,vector<int>(m,0));\\n        \\n        for(int j=0;j<m;j++)\\n        {\\n            ans[0][j]=matrix[0][j];\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                int s=matrix[i][j]+ans[i-1][j];\\n                int l=matrix[i][j];\\n                if(j>0)l+=ans[i-1][j-1];\\n                else l+=1e8;\\n                int r=matrix[i][j];\\n            \\n                if(j<n-1)r+=ans[i-1][j+1];\\n                else r+=1e8;\\n\\n                ans[i][j]=min(s,min(l,r));\\n            }\\n\\n        }\\n\\n    int mini=1e8;\\n    for(int j=0;j<m;j++)\\n    {\\n        mini=min(mini,ans[n-1][j]);\\n    }\\n\\n    return mini;\\n\\n\\n\\n        \\n    }"
                    },
                    {
                        "username": "Code-inger_007",
                        "content": "[@Deetav](/Deetav) got it thanks"
                    },
                    {
                        "username": "Deetav",
                        "content": "            int s=matrix[i][j]+ans[i-1][j];\\n\\nIn this line, when i = 0 your\\'e code will try to access ans[-1][j]."
                    },
                    {
                        "username": "nikhil08bhalla",
                        "content": "Why this code is giving overflow error\n```\nclass Solution {\npublic:\n    int f(int i,int j, vector<vector<int>>& v){\n        if(j<0 || j>=v[0].size()){\n            return INT_MAX;\n        }\n        if(i==0){\n            return v[0][j];\n        }\n        int s=v[i][j]+f(i-1,j,v);\n        int ld=v[i][j]+f(i-1,j-1,v);\n        int rd=v[i][j]+f(i-1,j+1,v);\n        return min(s,min(ld,rd));\n    }\n    int minFallingPathSum(vector<vector<int>>& v) {\n        int n=v.size();\n        int m=v[0].size();\n        if(n==0){\n            return 0;\n        }\n        else if(n==1){\n            return v[0][0];\n        }\n        int res=INT_MAX;\n        for(int j=0;j<m;j++){\n            res=min(res,f(n-1,j,v));\n        }\n        return res;\n    }\n};\n```"
                    },
                    {
                        "username": "shadab-malik",
                        "content": "Can this question be done using O(1) space and without using recursion...\nLike the  [minimum-falling-path-sum-ii](https://leetcode.com/problems/minimum-falling-path-sum-ii/description/), as it can be done without using any extra space or recursion... \n"
                    },
                    {
                        "username": "Yongbi",
                        "content": "But I think it's slow when using the slicing. \nAnw, I didnt use extra space, but my results (memory) is not optimal."
                    },
                    {
                        "username": "HighViscosityFlow",
                        "content": "Yes. This problem doesn`t need a recursion and no extra space needed."
                    },
                    {
                        "username": "prajwalkraut10",
                        "content": "Why my solution isn\\'t working??? \\n\\nprivate:\\n    int findsum(vector<vector<int>>& matrix,vector<vector<int>> &dp,int i,int j){\\n        int n = matrix.size();\\n        if(j<0 || j>=n) return 1e9;\\n        if(i==0) return matrix[0][j];\\n        if(dp[i][j] != -1) return dp[i][j];\\n\\n        int left = matrix[i][j] + findsum(matrix,dp,i-1,j-1);\\n        int mid = matrix[i][j] + findsum(matrix,dp,i-i,j);\\n        int rig = matrix[i][j] + findsum(matrix,dp,i-1,j+1);\\n\\n        return dp[i][j] = min(left,min(mid,rig));\\n    }\\n\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n       \\n        int n = matrix.size();\\n        vector<vector<int>> dp(n,vector<int> (n,-1));\\n        int sum = 1e9;\\n\\n        for(int i=0;i<n;i++){\\n           sum = min(sum,findsum(matrix,dp,n-1,i));\\n        }\\n        return sum;\\n    }\\n};"
                    },
                    {
                        "username": "seregakuznetsov98",
                        "content": "In the brute force approach we have to create a paths(trees) for each top element of the array, this paths will cross each other, so how to avoid repetition in calculation for the same paths?"
                    },
                    {
                        "username": "dipeshbindlish",
                        "content": "Also known as Dynamic Programming Approach (using result from previous calculation than to calculate again).\\n"
                    },
                    {
                        "username": "dipeshbindlish",
                        "content": "Start from 2nd row & for each element check which element from above row is to be added in it (i.e. minimum of the three elements above it.)"
                    },
                    {
                        "username": "dipeshbindlish",
                        "content": "Use Dynamic Programming"
                    },
                    {
                        "username": "AkselJensen",
                        "content": "Oh dear, I accidentally posted a solution. I\\'m so sorry."
                    },
                    {
                        "username": "Finesse",
                        "content": "The matrix can be viewed as a directional graph, where the cells are weights of the edges leading to these cells. Any algorithm for finding the shortest path in a graph can be used.\n\nSome algorithms aren't designed for negative edge weights (e.g. Dijkstra's), it can be solved by subtracting the minimal weight from the matrix (to make all the values be not negative), and add `minWeight * n` to the result to de-adjust it."
                    }
                ]
            },
            {
                "id": 1715420,
                "content": [
                    {
                        "username": "ankit_cruxx",
                        "content": "Can someone please help, what is the wrong here? I am getting a runtime error but i cannot see anything absurd. \\n\\n\\nint n = matrix.size();\\n         int m = matrix[0].size();\\n\\n        if (n==1) return *min_element(matrix[0].begin(),matrix[0].end());\\n        \\n      for(int i=1; i<n ; i++)\\n      {\\n      for(int j=0; j<m ; j++)\\n      {\\n          if(j==0)\\n          {\\n              matrix[i][j] = matrix[i][j] + min(matrix[i-1][j], matrix[i-1][j+1]);\\n          }\\n          if(j==m-1)\\n          {\\n              matrix[i][j] = matrix[i][j] + min(matrix[i-1][j],matrix[i-1][j-1]);\\n          }\\n          else\\n             matrix[i][j] = matrix[i][j] + min(matrix[i-1][j], min(matrix[i-1][j-1], matrix[i-1][j+1]));\\n      }\\n      }\\n      return *min_element(matrix[n-1].begin(),matrix[n-1].end());"
                    },
                    {
                        "username": "tdf56f756bg56r8iohgwexu",
                        "content": "You\\'re not using RUST. that is what is wrong"
                    },
                    {
                        "username": "mulani",
                        "content": "My code if failing for the following test case. Can someone please help me understand?\nmatrix =\n[[100,-42,-46,-41],[31,97,10,-10],[-58,-51,82,89],[51,81,69,-51]]\n\n ```\nclass Solution:\n    def minFallingPathSum(self, matrix: List[List[int]]) -> int:\n        ROWS, COLS = len(matrix), len(matrix[0])\n        cache = {} # (r, c) : min_path_sum\n\n        def find_min_path(r, c):\n            if (r, c) in cache:\n                return cache[(r, c)]\n            min_path_sum = matrix[r][c]\n            if (r == ROWS - 1 and c == COLS - 1) or r == ROWS - 1:\n                min_path_sum += 0\n            elif c == COLS - 1:\n                min_path_sum += min(find_min_path(r + 1, c - 1), find_min_path(r + 1, c))\n            else:\n                min_path_sum += min(find_min_path(r + 1, c - 1), find_min_path(r + 1, c), find_min_path(r + 1, c + 1))\n            cache[(r, c)] = min_path_sum\n            return min_path_sum\n\n        min_path_sum = (100 * ROWS) + 1\n        for c in range(COLS):\n            min_path_sum = min(min_path_sum, find_min_path(0, c))\n        return min_path_sum\n```"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@Monika Mulani](/mulani) You didn't consider the left bound right?\n\nwhen c==0:  min_path_sum += min(find_min_path(r + 1, c), find_min_path(r + 1, c + 1))\nfind_min_path(r + 1, c - 1) -> will look at the last column, then it returns a wrong answer! \n\nRelax, you are thinking too much. \nJust look at my $O(n^2)$ solution, go straight to problem. \n\n```\nclass Solution:\n    def minFallingPathSum(self, matrix: List[List[int]]) -> int:\n        n = len(matrix) # a squared matrix        \n        for i in range(1,n):\n            matrix[i][0] += min(matrix[i-1][0:2])    # First element\n            matrix[i][n-1]+= min(matrix[i-1][n-2:n]) # Last element\n            for j in range(1,n-1):   \n                matrix[i][j]+=min(matrix[i-1][j-1:j+2])\n        return min(matrix[n-1])\n```"
                    },
                    {
                        "username": "Code-inger_007",
                        "content": " can anyone explain why am i getting runtime error??\\n\\n\\nint minFallingPathSum(vector<vector<int>>& matrix) \\n    {\\n        int n=matrix.size();\\n        int m=matrix[0].size();\\n        vector<vector<int>>ans(n,vector<int>(m,0));\\n        \\n        for(int j=0;j<m;j++)\\n        {\\n            ans[0][j]=matrix[0][j];\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                int s=matrix[i][j]+ans[i-1][j];\\n                int l=matrix[i][j];\\n                if(j>0)l+=ans[i-1][j-1];\\n                else l+=1e8;\\n                int r=matrix[i][j];\\n            \\n                if(j<n-1)r+=ans[i-1][j+1];\\n                else r+=1e8;\\n\\n                ans[i][j]=min(s,min(l,r));\\n            }\\n\\n        }\\n\\n    int mini=1e8;\\n    for(int j=0;j<m;j++)\\n    {\\n        mini=min(mini,ans[n-1][j]);\\n    }\\n\\n    return mini;\\n\\n\\n\\n        \\n    }"
                    },
                    {
                        "username": "Code-inger_007",
                        "content": "[@Deetav](/Deetav) got it thanks"
                    },
                    {
                        "username": "Deetav",
                        "content": "            int s=matrix[i][j]+ans[i-1][j];\\n\\nIn this line, when i = 0 your\\'e code will try to access ans[-1][j]."
                    },
                    {
                        "username": "nikhil08bhalla",
                        "content": "Why this code is giving overflow error\n```\nclass Solution {\npublic:\n    int f(int i,int j, vector<vector<int>>& v){\n        if(j<0 || j>=v[0].size()){\n            return INT_MAX;\n        }\n        if(i==0){\n            return v[0][j];\n        }\n        int s=v[i][j]+f(i-1,j,v);\n        int ld=v[i][j]+f(i-1,j-1,v);\n        int rd=v[i][j]+f(i-1,j+1,v);\n        return min(s,min(ld,rd));\n    }\n    int minFallingPathSum(vector<vector<int>>& v) {\n        int n=v.size();\n        int m=v[0].size();\n        if(n==0){\n            return 0;\n        }\n        else if(n==1){\n            return v[0][0];\n        }\n        int res=INT_MAX;\n        for(int j=0;j<m;j++){\n            res=min(res,f(n-1,j,v));\n        }\n        return res;\n    }\n};\n```"
                    },
                    {
                        "username": "shadab-malik",
                        "content": "Can this question be done using O(1) space and without using recursion...\nLike the  [minimum-falling-path-sum-ii](https://leetcode.com/problems/minimum-falling-path-sum-ii/description/), as it can be done without using any extra space or recursion... \n"
                    },
                    {
                        "username": "Yongbi",
                        "content": "But I think it's slow when using the slicing. \nAnw, I didnt use extra space, but my results (memory) is not optimal."
                    },
                    {
                        "username": "HighViscosityFlow",
                        "content": "Yes. This problem doesn`t need a recursion and no extra space needed."
                    },
                    {
                        "username": "prajwalkraut10",
                        "content": "Why my solution isn\\'t working??? \\n\\nprivate:\\n    int findsum(vector<vector<int>>& matrix,vector<vector<int>> &dp,int i,int j){\\n        int n = matrix.size();\\n        if(j<0 || j>=n) return 1e9;\\n        if(i==0) return matrix[0][j];\\n        if(dp[i][j] != -1) return dp[i][j];\\n\\n        int left = matrix[i][j] + findsum(matrix,dp,i-1,j-1);\\n        int mid = matrix[i][j] + findsum(matrix,dp,i-i,j);\\n        int rig = matrix[i][j] + findsum(matrix,dp,i-1,j+1);\\n\\n        return dp[i][j] = min(left,min(mid,rig));\\n    }\\n\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n       \\n        int n = matrix.size();\\n        vector<vector<int>> dp(n,vector<int> (n,-1));\\n        int sum = 1e9;\\n\\n        for(int i=0;i<n;i++){\\n           sum = min(sum,findsum(matrix,dp,n-1,i));\\n        }\\n        return sum;\\n    }\\n};"
                    },
                    {
                        "username": "seregakuznetsov98",
                        "content": "In the brute force approach we have to create a paths(trees) for each top element of the array, this paths will cross each other, so how to avoid repetition in calculation for the same paths?"
                    },
                    {
                        "username": "dipeshbindlish",
                        "content": "Also known as Dynamic Programming Approach (using result from previous calculation than to calculate again).\\n"
                    },
                    {
                        "username": "dipeshbindlish",
                        "content": "Start from 2nd row & for each element check which element from above row is to be added in it (i.e. minimum of the three elements above it.)"
                    },
                    {
                        "username": "dipeshbindlish",
                        "content": "Use Dynamic Programming"
                    },
                    {
                        "username": "AkselJensen",
                        "content": "Oh dear, I accidentally posted a solution. I\\'m so sorry."
                    },
                    {
                        "username": "Finesse",
                        "content": "The matrix can be viewed as a directional graph, where the cells are weights of the edges leading to these cells. Any algorithm for finding the shortest path in a graph can be used.\n\nSome algorithms aren't designed for negative edge weights (e.g. Dijkstra's), it can be solved by subtracting the minimal weight from the matrix (to make all the values be not negative), and add `minWeight * n` to the result to de-adjust it."
                    }
                ]
            },
            {
                "id": 1715333,
                "content": [
                    {
                        "username": "ankit_cruxx",
                        "content": "Can someone please help, what is the wrong here? I am getting a runtime error but i cannot see anything absurd. \\n\\n\\nint n = matrix.size();\\n         int m = matrix[0].size();\\n\\n        if (n==1) return *min_element(matrix[0].begin(),matrix[0].end());\\n        \\n      for(int i=1; i<n ; i++)\\n      {\\n      for(int j=0; j<m ; j++)\\n      {\\n          if(j==0)\\n          {\\n              matrix[i][j] = matrix[i][j] + min(matrix[i-1][j], matrix[i-1][j+1]);\\n          }\\n          if(j==m-1)\\n          {\\n              matrix[i][j] = matrix[i][j] + min(matrix[i-1][j],matrix[i-1][j-1]);\\n          }\\n          else\\n             matrix[i][j] = matrix[i][j] + min(matrix[i-1][j], min(matrix[i-1][j-1], matrix[i-1][j+1]));\\n      }\\n      }\\n      return *min_element(matrix[n-1].begin(),matrix[n-1].end());"
                    },
                    {
                        "username": "tdf56f756bg56r8iohgwexu",
                        "content": "You\\'re not using RUST. that is what is wrong"
                    },
                    {
                        "username": "mulani",
                        "content": "My code if failing for the following test case. Can someone please help me understand?\nmatrix =\n[[100,-42,-46,-41],[31,97,10,-10],[-58,-51,82,89],[51,81,69,-51]]\n\n ```\nclass Solution:\n    def minFallingPathSum(self, matrix: List[List[int]]) -> int:\n        ROWS, COLS = len(matrix), len(matrix[0])\n        cache = {} # (r, c) : min_path_sum\n\n        def find_min_path(r, c):\n            if (r, c) in cache:\n                return cache[(r, c)]\n            min_path_sum = matrix[r][c]\n            if (r == ROWS - 1 and c == COLS - 1) or r == ROWS - 1:\n                min_path_sum += 0\n            elif c == COLS - 1:\n                min_path_sum += min(find_min_path(r + 1, c - 1), find_min_path(r + 1, c))\n            else:\n                min_path_sum += min(find_min_path(r + 1, c - 1), find_min_path(r + 1, c), find_min_path(r + 1, c + 1))\n            cache[(r, c)] = min_path_sum\n            return min_path_sum\n\n        min_path_sum = (100 * ROWS) + 1\n        for c in range(COLS):\n            min_path_sum = min(min_path_sum, find_min_path(0, c))\n        return min_path_sum\n```"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@Monika Mulani](/mulani) You didn't consider the left bound right?\n\nwhen c==0:  min_path_sum += min(find_min_path(r + 1, c), find_min_path(r + 1, c + 1))\nfind_min_path(r + 1, c - 1) -> will look at the last column, then it returns a wrong answer! \n\nRelax, you are thinking too much. \nJust look at my $O(n^2)$ solution, go straight to problem. \n\n```\nclass Solution:\n    def minFallingPathSum(self, matrix: List[List[int]]) -> int:\n        n = len(matrix) # a squared matrix        \n        for i in range(1,n):\n            matrix[i][0] += min(matrix[i-1][0:2])    # First element\n            matrix[i][n-1]+= min(matrix[i-1][n-2:n]) # Last element\n            for j in range(1,n-1):   \n                matrix[i][j]+=min(matrix[i-1][j-1:j+2])\n        return min(matrix[n-1])\n```"
                    },
                    {
                        "username": "Code-inger_007",
                        "content": " can anyone explain why am i getting runtime error??\\n\\n\\nint minFallingPathSum(vector<vector<int>>& matrix) \\n    {\\n        int n=matrix.size();\\n        int m=matrix[0].size();\\n        vector<vector<int>>ans(n,vector<int>(m,0));\\n        \\n        for(int j=0;j<m;j++)\\n        {\\n            ans[0][j]=matrix[0][j];\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                int s=matrix[i][j]+ans[i-1][j];\\n                int l=matrix[i][j];\\n                if(j>0)l+=ans[i-1][j-1];\\n                else l+=1e8;\\n                int r=matrix[i][j];\\n            \\n                if(j<n-1)r+=ans[i-1][j+1];\\n                else r+=1e8;\\n\\n                ans[i][j]=min(s,min(l,r));\\n            }\\n\\n        }\\n\\n    int mini=1e8;\\n    for(int j=0;j<m;j++)\\n    {\\n        mini=min(mini,ans[n-1][j]);\\n    }\\n\\n    return mini;\\n\\n\\n\\n        \\n    }"
                    },
                    {
                        "username": "Code-inger_007",
                        "content": "[@Deetav](/Deetav) got it thanks"
                    },
                    {
                        "username": "Deetav",
                        "content": "            int s=matrix[i][j]+ans[i-1][j];\\n\\nIn this line, when i = 0 your\\'e code will try to access ans[-1][j]."
                    },
                    {
                        "username": "nikhil08bhalla",
                        "content": "Why this code is giving overflow error\n```\nclass Solution {\npublic:\n    int f(int i,int j, vector<vector<int>>& v){\n        if(j<0 || j>=v[0].size()){\n            return INT_MAX;\n        }\n        if(i==0){\n            return v[0][j];\n        }\n        int s=v[i][j]+f(i-1,j,v);\n        int ld=v[i][j]+f(i-1,j-1,v);\n        int rd=v[i][j]+f(i-1,j+1,v);\n        return min(s,min(ld,rd));\n    }\n    int minFallingPathSum(vector<vector<int>>& v) {\n        int n=v.size();\n        int m=v[0].size();\n        if(n==0){\n            return 0;\n        }\n        else if(n==1){\n            return v[0][0];\n        }\n        int res=INT_MAX;\n        for(int j=0;j<m;j++){\n            res=min(res,f(n-1,j,v));\n        }\n        return res;\n    }\n};\n```"
                    },
                    {
                        "username": "shadab-malik",
                        "content": "Can this question be done using O(1) space and without using recursion...\nLike the  [minimum-falling-path-sum-ii](https://leetcode.com/problems/minimum-falling-path-sum-ii/description/), as it can be done without using any extra space or recursion... \n"
                    },
                    {
                        "username": "Yongbi",
                        "content": "But I think it's slow when using the slicing. \nAnw, I didnt use extra space, but my results (memory) is not optimal."
                    },
                    {
                        "username": "HighViscosityFlow",
                        "content": "Yes. This problem doesn`t need a recursion and no extra space needed."
                    },
                    {
                        "username": "prajwalkraut10",
                        "content": "Why my solution isn\\'t working??? \\n\\nprivate:\\n    int findsum(vector<vector<int>>& matrix,vector<vector<int>> &dp,int i,int j){\\n        int n = matrix.size();\\n        if(j<0 || j>=n) return 1e9;\\n        if(i==0) return matrix[0][j];\\n        if(dp[i][j] != -1) return dp[i][j];\\n\\n        int left = matrix[i][j] + findsum(matrix,dp,i-1,j-1);\\n        int mid = matrix[i][j] + findsum(matrix,dp,i-i,j);\\n        int rig = matrix[i][j] + findsum(matrix,dp,i-1,j+1);\\n\\n        return dp[i][j] = min(left,min(mid,rig));\\n    }\\n\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n       \\n        int n = matrix.size();\\n        vector<vector<int>> dp(n,vector<int> (n,-1));\\n        int sum = 1e9;\\n\\n        for(int i=0;i<n;i++){\\n           sum = min(sum,findsum(matrix,dp,n-1,i));\\n        }\\n        return sum;\\n    }\\n};"
                    },
                    {
                        "username": "seregakuznetsov98",
                        "content": "In the brute force approach we have to create a paths(trees) for each top element of the array, this paths will cross each other, so how to avoid repetition in calculation for the same paths?"
                    },
                    {
                        "username": "dipeshbindlish",
                        "content": "Also known as Dynamic Programming Approach (using result from previous calculation than to calculate again).\\n"
                    },
                    {
                        "username": "dipeshbindlish",
                        "content": "Start from 2nd row & for each element check which element from above row is to be added in it (i.e. minimum of the three elements above it.)"
                    },
                    {
                        "username": "dipeshbindlish",
                        "content": "Use Dynamic Programming"
                    },
                    {
                        "username": "AkselJensen",
                        "content": "Oh dear, I accidentally posted a solution. I\\'m so sorry."
                    },
                    {
                        "username": "Finesse",
                        "content": "The matrix can be viewed as a directional graph, where the cells are weights of the edges leading to these cells. Any algorithm for finding the shortest path in a graph can be used.\n\nSome algorithms aren't designed for negative edge weights (e.g. Dijkstra's), it can be solved by subtracting the minimal weight from the matrix (to make all the values be not negative), and add `minWeight * n` to the result to de-adjust it."
                    }
                ]
            },
            {
                "id": 1715243,
                "content": [
                    {
                        "username": "ankit_cruxx",
                        "content": "Can someone please help, what is the wrong here? I am getting a runtime error but i cannot see anything absurd. \\n\\n\\nint n = matrix.size();\\n         int m = matrix[0].size();\\n\\n        if (n==1) return *min_element(matrix[0].begin(),matrix[0].end());\\n        \\n      for(int i=1; i<n ; i++)\\n      {\\n      for(int j=0; j<m ; j++)\\n      {\\n          if(j==0)\\n          {\\n              matrix[i][j] = matrix[i][j] + min(matrix[i-1][j], matrix[i-1][j+1]);\\n          }\\n          if(j==m-1)\\n          {\\n              matrix[i][j] = matrix[i][j] + min(matrix[i-1][j],matrix[i-1][j-1]);\\n          }\\n          else\\n             matrix[i][j] = matrix[i][j] + min(matrix[i-1][j], min(matrix[i-1][j-1], matrix[i-1][j+1]));\\n      }\\n      }\\n      return *min_element(matrix[n-1].begin(),matrix[n-1].end());"
                    },
                    {
                        "username": "tdf56f756bg56r8iohgwexu",
                        "content": "You\\'re not using RUST. that is what is wrong"
                    },
                    {
                        "username": "mulani",
                        "content": "My code if failing for the following test case. Can someone please help me understand?\nmatrix =\n[[100,-42,-46,-41],[31,97,10,-10],[-58,-51,82,89],[51,81,69,-51]]\n\n ```\nclass Solution:\n    def minFallingPathSum(self, matrix: List[List[int]]) -> int:\n        ROWS, COLS = len(matrix), len(matrix[0])\n        cache = {} # (r, c) : min_path_sum\n\n        def find_min_path(r, c):\n            if (r, c) in cache:\n                return cache[(r, c)]\n            min_path_sum = matrix[r][c]\n            if (r == ROWS - 1 and c == COLS - 1) or r == ROWS - 1:\n                min_path_sum += 0\n            elif c == COLS - 1:\n                min_path_sum += min(find_min_path(r + 1, c - 1), find_min_path(r + 1, c))\n            else:\n                min_path_sum += min(find_min_path(r + 1, c - 1), find_min_path(r + 1, c), find_min_path(r + 1, c + 1))\n            cache[(r, c)] = min_path_sum\n            return min_path_sum\n\n        min_path_sum = (100 * ROWS) + 1\n        for c in range(COLS):\n            min_path_sum = min(min_path_sum, find_min_path(0, c))\n        return min_path_sum\n```"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@Monika Mulani](/mulani) You didn't consider the left bound right?\n\nwhen c==0:  min_path_sum += min(find_min_path(r + 1, c), find_min_path(r + 1, c + 1))\nfind_min_path(r + 1, c - 1) -> will look at the last column, then it returns a wrong answer! \n\nRelax, you are thinking too much. \nJust look at my $O(n^2)$ solution, go straight to problem. \n\n```\nclass Solution:\n    def minFallingPathSum(self, matrix: List[List[int]]) -> int:\n        n = len(matrix) # a squared matrix        \n        for i in range(1,n):\n            matrix[i][0] += min(matrix[i-1][0:2])    # First element\n            matrix[i][n-1]+= min(matrix[i-1][n-2:n]) # Last element\n            for j in range(1,n-1):   \n                matrix[i][j]+=min(matrix[i-1][j-1:j+2])\n        return min(matrix[n-1])\n```"
                    },
                    {
                        "username": "Code-inger_007",
                        "content": " can anyone explain why am i getting runtime error??\\n\\n\\nint minFallingPathSum(vector<vector<int>>& matrix) \\n    {\\n        int n=matrix.size();\\n        int m=matrix[0].size();\\n        vector<vector<int>>ans(n,vector<int>(m,0));\\n        \\n        for(int j=0;j<m;j++)\\n        {\\n            ans[0][j]=matrix[0][j];\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                int s=matrix[i][j]+ans[i-1][j];\\n                int l=matrix[i][j];\\n                if(j>0)l+=ans[i-1][j-1];\\n                else l+=1e8;\\n                int r=matrix[i][j];\\n            \\n                if(j<n-1)r+=ans[i-1][j+1];\\n                else r+=1e8;\\n\\n                ans[i][j]=min(s,min(l,r));\\n            }\\n\\n        }\\n\\n    int mini=1e8;\\n    for(int j=0;j<m;j++)\\n    {\\n        mini=min(mini,ans[n-1][j]);\\n    }\\n\\n    return mini;\\n\\n\\n\\n        \\n    }"
                    },
                    {
                        "username": "Code-inger_007",
                        "content": "[@Deetav](/Deetav) got it thanks"
                    },
                    {
                        "username": "Deetav",
                        "content": "            int s=matrix[i][j]+ans[i-1][j];\\n\\nIn this line, when i = 0 your\\'e code will try to access ans[-1][j]."
                    },
                    {
                        "username": "nikhil08bhalla",
                        "content": "Why this code is giving overflow error\n```\nclass Solution {\npublic:\n    int f(int i,int j, vector<vector<int>>& v){\n        if(j<0 || j>=v[0].size()){\n            return INT_MAX;\n        }\n        if(i==0){\n            return v[0][j];\n        }\n        int s=v[i][j]+f(i-1,j,v);\n        int ld=v[i][j]+f(i-1,j-1,v);\n        int rd=v[i][j]+f(i-1,j+1,v);\n        return min(s,min(ld,rd));\n    }\n    int minFallingPathSum(vector<vector<int>>& v) {\n        int n=v.size();\n        int m=v[0].size();\n        if(n==0){\n            return 0;\n        }\n        else if(n==1){\n            return v[0][0];\n        }\n        int res=INT_MAX;\n        for(int j=0;j<m;j++){\n            res=min(res,f(n-1,j,v));\n        }\n        return res;\n    }\n};\n```"
                    },
                    {
                        "username": "shadab-malik",
                        "content": "Can this question be done using O(1) space and without using recursion...\nLike the  [minimum-falling-path-sum-ii](https://leetcode.com/problems/minimum-falling-path-sum-ii/description/), as it can be done without using any extra space or recursion... \n"
                    },
                    {
                        "username": "Yongbi",
                        "content": "But I think it's slow when using the slicing. \nAnw, I didnt use extra space, but my results (memory) is not optimal."
                    },
                    {
                        "username": "HighViscosityFlow",
                        "content": "Yes. This problem doesn`t need a recursion and no extra space needed."
                    },
                    {
                        "username": "prajwalkraut10",
                        "content": "Why my solution isn\\'t working??? \\n\\nprivate:\\n    int findsum(vector<vector<int>>& matrix,vector<vector<int>> &dp,int i,int j){\\n        int n = matrix.size();\\n        if(j<0 || j>=n) return 1e9;\\n        if(i==0) return matrix[0][j];\\n        if(dp[i][j] != -1) return dp[i][j];\\n\\n        int left = matrix[i][j] + findsum(matrix,dp,i-1,j-1);\\n        int mid = matrix[i][j] + findsum(matrix,dp,i-i,j);\\n        int rig = matrix[i][j] + findsum(matrix,dp,i-1,j+1);\\n\\n        return dp[i][j] = min(left,min(mid,rig));\\n    }\\n\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n       \\n        int n = matrix.size();\\n        vector<vector<int>> dp(n,vector<int> (n,-1));\\n        int sum = 1e9;\\n\\n        for(int i=0;i<n;i++){\\n           sum = min(sum,findsum(matrix,dp,n-1,i));\\n        }\\n        return sum;\\n    }\\n};"
                    },
                    {
                        "username": "seregakuznetsov98",
                        "content": "In the brute force approach we have to create a paths(trees) for each top element of the array, this paths will cross each other, so how to avoid repetition in calculation for the same paths?"
                    },
                    {
                        "username": "dipeshbindlish",
                        "content": "Also known as Dynamic Programming Approach (using result from previous calculation than to calculate again).\\n"
                    },
                    {
                        "username": "dipeshbindlish",
                        "content": "Start from 2nd row & for each element check which element from above row is to be added in it (i.e. minimum of the three elements above it.)"
                    },
                    {
                        "username": "dipeshbindlish",
                        "content": "Use Dynamic Programming"
                    },
                    {
                        "username": "AkselJensen",
                        "content": "Oh dear, I accidentally posted a solution. I\\'m so sorry."
                    },
                    {
                        "username": "Finesse",
                        "content": "The matrix can be viewed as a directional graph, where the cells are weights of the edges leading to these cells. Any algorithm for finding the shortest path in a graph can be used.\n\nSome algorithms aren't designed for negative edge weights (e.g. Dijkstra's), it can be solved by subtracting the minimal weight from the matrix (to make all the values be not negative), and add `minWeight * n` to the result to de-adjust it."
                    }
                ]
            },
            {
                "id": 1715237,
                "content": [
                    {
                        "username": "ankit_cruxx",
                        "content": "Can someone please help, what is the wrong here? I am getting a runtime error but i cannot see anything absurd. \\n\\n\\nint n = matrix.size();\\n         int m = matrix[0].size();\\n\\n        if (n==1) return *min_element(matrix[0].begin(),matrix[0].end());\\n        \\n      for(int i=1; i<n ; i++)\\n      {\\n      for(int j=0; j<m ; j++)\\n      {\\n          if(j==0)\\n          {\\n              matrix[i][j] = matrix[i][j] + min(matrix[i-1][j], matrix[i-1][j+1]);\\n          }\\n          if(j==m-1)\\n          {\\n              matrix[i][j] = matrix[i][j] + min(matrix[i-1][j],matrix[i-1][j-1]);\\n          }\\n          else\\n             matrix[i][j] = matrix[i][j] + min(matrix[i-1][j], min(matrix[i-1][j-1], matrix[i-1][j+1]));\\n      }\\n      }\\n      return *min_element(matrix[n-1].begin(),matrix[n-1].end());"
                    },
                    {
                        "username": "tdf56f756bg56r8iohgwexu",
                        "content": "You\\'re not using RUST. that is what is wrong"
                    },
                    {
                        "username": "mulani",
                        "content": "My code if failing for the following test case. Can someone please help me understand?\nmatrix =\n[[100,-42,-46,-41],[31,97,10,-10],[-58,-51,82,89],[51,81,69,-51]]\n\n ```\nclass Solution:\n    def minFallingPathSum(self, matrix: List[List[int]]) -> int:\n        ROWS, COLS = len(matrix), len(matrix[0])\n        cache = {} # (r, c) : min_path_sum\n\n        def find_min_path(r, c):\n            if (r, c) in cache:\n                return cache[(r, c)]\n            min_path_sum = matrix[r][c]\n            if (r == ROWS - 1 and c == COLS - 1) or r == ROWS - 1:\n                min_path_sum += 0\n            elif c == COLS - 1:\n                min_path_sum += min(find_min_path(r + 1, c - 1), find_min_path(r + 1, c))\n            else:\n                min_path_sum += min(find_min_path(r + 1, c - 1), find_min_path(r + 1, c), find_min_path(r + 1, c + 1))\n            cache[(r, c)] = min_path_sum\n            return min_path_sum\n\n        min_path_sum = (100 * ROWS) + 1\n        for c in range(COLS):\n            min_path_sum = min(min_path_sum, find_min_path(0, c))\n        return min_path_sum\n```"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@Monika Mulani](/mulani) You didn't consider the left bound right?\n\nwhen c==0:  min_path_sum += min(find_min_path(r + 1, c), find_min_path(r + 1, c + 1))\nfind_min_path(r + 1, c - 1) -> will look at the last column, then it returns a wrong answer! \n\nRelax, you are thinking too much. \nJust look at my $O(n^2)$ solution, go straight to problem. \n\n```\nclass Solution:\n    def minFallingPathSum(self, matrix: List[List[int]]) -> int:\n        n = len(matrix) # a squared matrix        \n        for i in range(1,n):\n            matrix[i][0] += min(matrix[i-1][0:2])    # First element\n            matrix[i][n-1]+= min(matrix[i-1][n-2:n]) # Last element\n            for j in range(1,n-1):   \n                matrix[i][j]+=min(matrix[i-1][j-1:j+2])\n        return min(matrix[n-1])\n```"
                    },
                    {
                        "username": "Code-inger_007",
                        "content": " can anyone explain why am i getting runtime error??\\n\\n\\nint minFallingPathSum(vector<vector<int>>& matrix) \\n    {\\n        int n=matrix.size();\\n        int m=matrix[0].size();\\n        vector<vector<int>>ans(n,vector<int>(m,0));\\n        \\n        for(int j=0;j<m;j++)\\n        {\\n            ans[0][j]=matrix[0][j];\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                int s=matrix[i][j]+ans[i-1][j];\\n                int l=matrix[i][j];\\n                if(j>0)l+=ans[i-1][j-1];\\n                else l+=1e8;\\n                int r=matrix[i][j];\\n            \\n                if(j<n-1)r+=ans[i-1][j+1];\\n                else r+=1e8;\\n\\n                ans[i][j]=min(s,min(l,r));\\n            }\\n\\n        }\\n\\n    int mini=1e8;\\n    for(int j=0;j<m;j++)\\n    {\\n        mini=min(mini,ans[n-1][j]);\\n    }\\n\\n    return mini;\\n\\n\\n\\n        \\n    }"
                    },
                    {
                        "username": "Code-inger_007",
                        "content": "[@Deetav](/Deetav) got it thanks"
                    },
                    {
                        "username": "Deetav",
                        "content": "            int s=matrix[i][j]+ans[i-1][j];\\n\\nIn this line, when i = 0 your\\'e code will try to access ans[-1][j]."
                    },
                    {
                        "username": "nikhil08bhalla",
                        "content": "Why this code is giving overflow error\n```\nclass Solution {\npublic:\n    int f(int i,int j, vector<vector<int>>& v){\n        if(j<0 || j>=v[0].size()){\n            return INT_MAX;\n        }\n        if(i==0){\n            return v[0][j];\n        }\n        int s=v[i][j]+f(i-1,j,v);\n        int ld=v[i][j]+f(i-1,j-1,v);\n        int rd=v[i][j]+f(i-1,j+1,v);\n        return min(s,min(ld,rd));\n    }\n    int minFallingPathSum(vector<vector<int>>& v) {\n        int n=v.size();\n        int m=v[0].size();\n        if(n==0){\n            return 0;\n        }\n        else if(n==1){\n            return v[0][0];\n        }\n        int res=INT_MAX;\n        for(int j=0;j<m;j++){\n            res=min(res,f(n-1,j,v));\n        }\n        return res;\n    }\n};\n```"
                    },
                    {
                        "username": "shadab-malik",
                        "content": "Can this question be done using O(1) space and without using recursion...\nLike the  [minimum-falling-path-sum-ii](https://leetcode.com/problems/minimum-falling-path-sum-ii/description/), as it can be done without using any extra space or recursion... \n"
                    },
                    {
                        "username": "Yongbi",
                        "content": "But I think it's slow when using the slicing. \nAnw, I didnt use extra space, but my results (memory) is not optimal."
                    },
                    {
                        "username": "HighViscosityFlow",
                        "content": "Yes. This problem doesn`t need a recursion and no extra space needed."
                    },
                    {
                        "username": "prajwalkraut10",
                        "content": "Why my solution isn\\'t working??? \\n\\nprivate:\\n    int findsum(vector<vector<int>>& matrix,vector<vector<int>> &dp,int i,int j){\\n        int n = matrix.size();\\n        if(j<0 || j>=n) return 1e9;\\n        if(i==0) return matrix[0][j];\\n        if(dp[i][j] != -1) return dp[i][j];\\n\\n        int left = matrix[i][j] + findsum(matrix,dp,i-1,j-1);\\n        int mid = matrix[i][j] + findsum(matrix,dp,i-i,j);\\n        int rig = matrix[i][j] + findsum(matrix,dp,i-1,j+1);\\n\\n        return dp[i][j] = min(left,min(mid,rig));\\n    }\\n\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n       \\n        int n = matrix.size();\\n        vector<vector<int>> dp(n,vector<int> (n,-1));\\n        int sum = 1e9;\\n\\n        for(int i=0;i<n;i++){\\n           sum = min(sum,findsum(matrix,dp,n-1,i));\\n        }\\n        return sum;\\n    }\\n};"
                    },
                    {
                        "username": "seregakuznetsov98",
                        "content": "In the brute force approach we have to create a paths(trees) for each top element of the array, this paths will cross each other, so how to avoid repetition in calculation for the same paths?"
                    },
                    {
                        "username": "dipeshbindlish",
                        "content": "Also known as Dynamic Programming Approach (using result from previous calculation than to calculate again).\\n"
                    },
                    {
                        "username": "dipeshbindlish",
                        "content": "Start from 2nd row & for each element check which element from above row is to be added in it (i.e. minimum of the three elements above it.)"
                    },
                    {
                        "username": "dipeshbindlish",
                        "content": "Use Dynamic Programming"
                    },
                    {
                        "username": "AkselJensen",
                        "content": "Oh dear, I accidentally posted a solution. I\\'m so sorry."
                    },
                    {
                        "username": "Finesse",
                        "content": "The matrix can be viewed as a directional graph, where the cells are weights of the edges leading to these cells. Any algorithm for finding the shortest path in a graph can be used.\n\nSome algorithms aren't designed for negative edge weights (e.g. Dijkstra's), it can be solved by subtracting the minimal weight from the matrix (to make all the values be not negative), and add `minWeight * n` to the result to de-adjust it."
                    }
                ]
            },
            {
                "id": 1715158,
                "content": [
                    {
                        "username": "ankit_cruxx",
                        "content": "Can someone please help, what is the wrong here? I am getting a runtime error but i cannot see anything absurd. \\n\\n\\nint n = matrix.size();\\n         int m = matrix[0].size();\\n\\n        if (n==1) return *min_element(matrix[0].begin(),matrix[0].end());\\n        \\n      for(int i=1; i<n ; i++)\\n      {\\n      for(int j=0; j<m ; j++)\\n      {\\n          if(j==0)\\n          {\\n              matrix[i][j] = matrix[i][j] + min(matrix[i-1][j], matrix[i-1][j+1]);\\n          }\\n          if(j==m-1)\\n          {\\n              matrix[i][j] = matrix[i][j] + min(matrix[i-1][j],matrix[i-1][j-1]);\\n          }\\n          else\\n             matrix[i][j] = matrix[i][j] + min(matrix[i-1][j], min(matrix[i-1][j-1], matrix[i-1][j+1]));\\n      }\\n      }\\n      return *min_element(matrix[n-1].begin(),matrix[n-1].end());"
                    },
                    {
                        "username": "tdf56f756bg56r8iohgwexu",
                        "content": "You\\'re not using RUST. that is what is wrong"
                    },
                    {
                        "username": "mulani",
                        "content": "My code if failing for the following test case. Can someone please help me understand?\nmatrix =\n[[100,-42,-46,-41],[31,97,10,-10],[-58,-51,82,89],[51,81,69,-51]]\n\n ```\nclass Solution:\n    def minFallingPathSum(self, matrix: List[List[int]]) -> int:\n        ROWS, COLS = len(matrix), len(matrix[0])\n        cache = {} # (r, c) : min_path_sum\n\n        def find_min_path(r, c):\n            if (r, c) in cache:\n                return cache[(r, c)]\n            min_path_sum = matrix[r][c]\n            if (r == ROWS - 1 and c == COLS - 1) or r == ROWS - 1:\n                min_path_sum += 0\n            elif c == COLS - 1:\n                min_path_sum += min(find_min_path(r + 1, c - 1), find_min_path(r + 1, c))\n            else:\n                min_path_sum += min(find_min_path(r + 1, c - 1), find_min_path(r + 1, c), find_min_path(r + 1, c + 1))\n            cache[(r, c)] = min_path_sum\n            return min_path_sum\n\n        min_path_sum = (100 * ROWS) + 1\n        for c in range(COLS):\n            min_path_sum = min(min_path_sum, find_min_path(0, c))\n        return min_path_sum\n```"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@Monika Mulani](/mulani) You didn't consider the left bound right?\n\nwhen c==0:  min_path_sum += min(find_min_path(r + 1, c), find_min_path(r + 1, c + 1))\nfind_min_path(r + 1, c - 1) -> will look at the last column, then it returns a wrong answer! \n\nRelax, you are thinking too much. \nJust look at my $O(n^2)$ solution, go straight to problem. \n\n```\nclass Solution:\n    def minFallingPathSum(self, matrix: List[List[int]]) -> int:\n        n = len(matrix) # a squared matrix        \n        for i in range(1,n):\n            matrix[i][0] += min(matrix[i-1][0:2])    # First element\n            matrix[i][n-1]+= min(matrix[i-1][n-2:n]) # Last element\n            for j in range(1,n-1):   \n                matrix[i][j]+=min(matrix[i-1][j-1:j+2])\n        return min(matrix[n-1])\n```"
                    },
                    {
                        "username": "Code-inger_007",
                        "content": " can anyone explain why am i getting runtime error??\\n\\n\\nint minFallingPathSum(vector<vector<int>>& matrix) \\n    {\\n        int n=matrix.size();\\n        int m=matrix[0].size();\\n        vector<vector<int>>ans(n,vector<int>(m,0));\\n        \\n        for(int j=0;j<m;j++)\\n        {\\n            ans[0][j]=matrix[0][j];\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                int s=matrix[i][j]+ans[i-1][j];\\n                int l=matrix[i][j];\\n                if(j>0)l+=ans[i-1][j-1];\\n                else l+=1e8;\\n                int r=matrix[i][j];\\n            \\n                if(j<n-1)r+=ans[i-1][j+1];\\n                else r+=1e8;\\n\\n                ans[i][j]=min(s,min(l,r));\\n            }\\n\\n        }\\n\\n    int mini=1e8;\\n    for(int j=0;j<m;j++)\\n    {\\n        mini=min(mini,ans[n-1][j]);\\n    }\\n\\n    return mini;\\n\\n\\n\\n        \\n    }"
                    },
                    {
                        "username": "Code-inger_007",
                        "content": "[@Deetav](/Deetav) got it thanks"
                    },
                    {
                        "username": "Deetav",
                        "content": "            int s=matrix[i][j]+ans[i-1][j];\\n\\nIn this line, when i = 0 your\\'e code will try to access ans[-1][j]."
                    },
                    {
                        "username": "nikhil08bhalla",
                        "content": "Why this code is giving overflow error\n```\nclass Solution {\npublic:\n    int f(int i,int j, vector<vector<int>>& v){\n        if(j<0 || j>=v[0].size()){\n            return INT_MAX;\n        }\n        if(i==0){\n            return v[0][j];\n        }\n        int s=v[i][j]+f(i-1,j,v);\n        int ld=v[i][j]+f(i-1,j-1,v);\n        int rd=v[i][j]+f(i-1,j+1,v);\n        return min(s,min(ld,rd));\n    }\n    int minFallingPathSum(vector<vector<int>>& v) {\n        int n=v.size();\n        int m=v[0].size();\n        if(n==0){\n            return 0;\n        }\n        else if(n==1){\n            return v[0][0];\n        }\n        int res=INT_MAX;\n        for(int j=0;j<m;j++){\n            res=min(res,f(n-1,j,v));\n        }\n        return res;\n    }\n};\n```"
                    },
                    {
                        "username": "shadab-malik",
                        "content": "Can this question be done using O(1) space and without using recursion...\nLike the  [minimum-falling-path-sum-ii](https://leetcode.com/problems/minimum-falling-path-sum-ii/description/), as it can be done without using any extra space or recursion... \n"
                    },
                    {
                        "username": "Yongbi",
                        "content": "But I think it's slow when using the slicing. \nAnw, I didnt use extra space, but my results (memory) is not optimal."
                    },
                    {
                        "username": "HighViscosityFlow",
                        "content": "Yes. This problem doesn`t need a recursion and no extra space needed."
                    },
                    {
                        "username": "prajwalkraut10",
                        "content": "Why my solution isn\\'t working??? \\n\\nprivate:\\n    int findsum(vector<vector<int>>& matrix,vector<vector<int>> &dp,int i,int j){\\n        int n = matrix.size();\\n        if(j<0 || j>=n) return 1e9;\\n        if(i==0) return matrix[0][j];\\n        if(dp[i][j] != -1) return dp[i][j];\\n\\n        int left = matrix[i][j] + findsum(matrix,dp,i-1,j-1);\\n        int mid = matrix[i][j] + findsum(matrix,dp,i-i,j);\\n        int rig = matrix[i][j] + findsum(matrix,dp,i-1,j+1);\\n\\n        return dp[i][j] = min(left,min(mid,rig));\\n    }\\n\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n       \\n        int n = matrix.size();\\n        vector<vector<int>> dp(n,vector<int> (n,-1));\\n        int sum = 1e9;\\n\\n        for(int i=0;i<n;i++){\\n           sum = min(sum,findsum(matrix,dp,n-1,i));\\n        }\\n        return sum;\\n    }\\n};"
                    },
                    {
                        "username": "seregakuznetsov98",
                        "content": "In the brute force approach we have to create a paths(trees) for each top element of the array, this paths will cross each other, so how to avoid repetition in calculation for the same paths?"
                    },
                    {
                        "username": "dipeshbindlish",
                        "content": "Also known as Dynamic Programming Approach (using result from previous calculation than to calculate again).\\n"
                    },
                    {
                        "username": "dipeshbindlish",
                        "content": "Start from 2nd row & for each element check which element from above row is to be added in it (i.e. minimum of the three elements above it.)"
                    },
                    {
                        "username": "dipeshbindlish",
                        "content": "Use Dynamic Programming"
                    },
                    {
                        "username": "AkselJensen",
                        "content": "Oh dear, I accidentally posted a solution. I\\'m so sorry."
                    },
                    {
                        "username": "Finesse",
                        "content": "The matrix can be viewed as a directional graph, where the cells are weights of the edges leading to these cells. Any algorithm for finding the shortest path in a graph can be used.\n\nSome algorithms aren't designed for negative edge weights (e.g. Dijkstra's), it can be solved by subtracting the minimal weight from the matrix (to make all the values be not negative), and add `minWeight * n` to the result to de-adjust it."
                    }
                ]
            },
            {
                "id": 1715133,
                "content": [
                    {
                        "username": "ankit_cruxx",
                        "content": "Can someone please help, what is the wrong here? I am getting a runtime error but i cannot see anything absurd. \\n\\n\\nint n = matrix.size();\\n         int m = matrix[0].size();\\n\\n        if (n==1) return *min_element(matrix[0].begin(),matrix[0].end());\\n        \\n      for(int i=1; i<n ; i++)\\n      {\\n      for(int j=0; j<m ; j++)\\n      {\\n          if(j==0)\\n          {\\n              matrix[i][j] = matrix[i][j] + min(matrix[i-1][j], matrix[i-1][j+1]);\\n          }\\n          if(j==m-1)\\n          {\\n              matrix[i][j] = matrix[i][j] + min(matrix[i-1][j],matrix[i-1][j-1]);\\n          }\\n          else\\n             matrix[i][j] = matrix[i][j] + min(matrix[i-1][j], min(matrix[i-1][j-1], matrix[i-1][j+1]));\\n      }\\n      }\\n      return *min_element(matrix[n-1].begin(),matrix[n-1].end());"
                    },
                    {
                        "username": "tdf56f756bg56r8iohgwexu",
                        "content": "You\\'re not using RUST. that is what is wrong"
                    },
                    {
                        "username": "mulani",
                        "content": "My code if failing for the following test case. Can someone please help me understand?\nmatrix =\n[[100,-42,-46,-41],[31,97,10,-10],[-58,-51,82,89],[51,81,69,-51]]\n\n ```\nclass Solution:\n    def minFallingPathSum(self, matrix: List[List[int]]) -> int:\n        ROWS, COLS = len(matrix), len(matrix[0])\n        cache = {} # (r, c) : min_path_sum\n\n        def find_min_path(r, c):\n            if (r, c) in cache:\n                return cache[(r, c)]\n            min_path_sum = matrix[r][c]\n            if (r == ROWS - 1 and c == COLS - 1) or r == ROWS - 1:\n                min_path_sum += 0\n            elif c == COLS - 1:\n                min_path_sum += min(find_min_path(r + 1, c - 1), find_min_path(r + 1, c))\n            else:\n                min_path_sum += min(find_min_path(r + 1, c - 1), find_min_path(r + 1, c), find_min_path(r + 1, c + 1))\n            cache[(r, c)] = min_path_sum\n            return min_path_sum\n\n        min_path_sum = (100 * ROWS) + 1\n        for c in range(COLS):\n            min_path_sum = min(min_path_sum, find_min_path(0, c))\n        return min_path_sum\n```"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@Monika Mulani](/mulani) You didn't consider the left bound right?\n\nwhen c==0:  min_path_sum += min(find_min_path(r + 1, c), find_min_path(r + 1, c + 1))\nfind_min_path(r + 1, c - 1) -> will look at the last column, then it returns a wrong answer! \n\nRelax, you are thinking too much. \nJust look at my $O(n^2)$ solution, go straight to problem. \n\n```\nclass Solution:\n    def minFallingPathSum(self, matrix: List[List[int]]) -> int:\n        n = len(matrix) # a squared matrix        \n        for i in range(1,n):\n            matrix[i][0] += min(matrix[i-1][0:2])    # First element\n            matrix[i][n-1]+= min(matrix[i-1][n-2:n]) # Last element\n            for j in range(1,n-1):   \n                matrix[i][j]+=min(matrix[i-1][j-1:j+2])\n        return min(matrix[n-1])\n```"
                    },
                    {
                        "username": "Code-inger_007",
                        "content": " can anyone explain why am i getting runtime error??\\n\\n\\nint minFallingPathSum(vector<vector<int>>& matrix) \\n    {\\n        int n=matrix.size();\\n        int m=matrix[0].size();\\n        vector<vector<int>>ans(n,vector<int>(m,0));\\n        \\n        for(int j=0;j<m;j++)\\n        {\\n            ans[0][j]=matrix[0][j];\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                int s=matrix[i][j]+ans[i-1][j];\\n                int l=matrix[i][j];\\n                if(j>0)l+=ans[i-1][j-1];\\n                else l+=1e8;\\n                int r=matrix[i][j];\\n            \\n                if(j<n-1)r+=ans[i-1][j+1];\\n                else r+=1e8;\\n\\n                ans[i][j]=min(s,min(l,r));\\n            }\\n\\n        }\\n\\n    int mini=1e8;\\n    for(int j=0;j<m;j++)\\n    {\\n        mini=min(mini,ans[n-1][j]);\\n    }\\n\\n    return mini;\\n\\n\\n\\n        \\n    }"
                    },
                    {
                        "username": "Code-inger_007",
                        "content": "[@Deetav](/Deetav) got it thanks"
                    },
                    {
                        "username": "Deetav",
                        "content": "            int s=matrix[i][j]+ans[i-1][j];\\n\\nIn this line, when i = 0 your\\'e code will try to access ans[-1][j]."
                    },
                    {
                        "username": "nikhil08bhalla",
                        "content": "Why this code is giving overflow error\n```\nclass Solution {\npublic:\n    int f(int i,int j, vector<vector<int>>& v){\n        if(j<0 || j>=v[0].size()){\n            return INT_MAX;\n        }\n        if(i==0){\n            return v[0][j];\n        }\n        int s=v[i][j]+f(i-1,j,v);\n        int ld=v[i][j]+f(i-1,j-1,v);\n        int rd=v[i][j]+f(i-1,j+1,v);\n        return min(s,min(ld,rd));\n    }\n    int minFallingPathSum(vector<vector<int>>& v) {\n        int n=v.size();\n        int m=v[0].size();\n        if(n==0){\n            return 0;\n        }\n        else if(n==1){\n            return v[0][0];\n        }\n        int res=INT_MAX;\n        for(int j=0;j<m;j++){\n            res=min(res,f(n-1,j,v));\n        }\n        return res;\n    }\n};\n```"
                    },
                    {
                        "username": "shadab-malik",
                        "content": "Can this question be done using O(1) space and without using recursion...\nLike the  [minimum-falling-path-sum-ii](https://leetcode.com/problems/minimum-falling-path-sum-ii/description/), as it can be done without using any extra space or recursion... \n"
                    },
                    {
                        "username": "Yongbi",
                        "content": "But I think it's slow when using the slicing. \nAnw, I didnt use extra space, but my results (memory) is not optimal."
                    },
                    {
                        "username": "HighViscosityFlow",
                        "content": "Yes. This problem doesn`t need a recursion and no extra space needed."
                    },
                    {
                        "username": "prajwalkraut10",
                        "content": "Why my solution isn\\'t working??? \\n\\nprivate:\\n    int findsum(vector<vector<int>>& matrix,vector<vector<int>> &dp,int i,int j){\\n        int n = matrix.size();\\n        if(j<0 || j>=n) return 1e9;\\n        if(i==0) return matrix[0][j];\\n        if(dp[i][j] != -1) return dp[i][j];\\n\\n        int left = matrix[i][j] + findsum(matrix,dp,i-1,j-1);\\n        int mid = matrix[i][j] + findsum(matrix,dp,i-i,j);\\n        int rig = matrix[i][j] + findsum(matrix,dp,i-1,j+1);\\n\\n        return dp[i][j] = min(left,min(mid,rig));\\n    }\\n\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n       \\n        int n = matrix.size();\\n        vector<vector<int>> dp(n,vector<int> (n,-1));\\n        int sum = 1e9;\\n\\n        for(int i=0;i<n;i++){\\n           sum = min(sum,findsum(matrix,dp,n-1,i));\\n        }\\n        return sum;\\n    }\\n};"
                    },
                    {
                        "username": "seregakuznetsov98",
                        "content": "In the brute force approach we have to create a paths(trees) for each top element of the array, this paths will cross each other, so how to avoid repetition in calculation for the same paths?"
                    },
                    {
                        "username": "dipeshbindlish",
                        "content": "Also known as Dynamic Programming Approach (using result from previous calculation than to calculate again).\\n"
                    },
                    {
                        "username": "dipeshbindlish",
                        "content": "Start from 2nd row & for each element check which element from above row is to be added in it (i.e. minimum of the three elements above it.)"
                    },
                    {
                        "username": "dipeshbindlish",
                        "content": "Use Dynamic Programming"
                    },
                    {
                        "username": "AkselJensen",
                        "content": "Oh dear, I accidentally posted a solution. I\\'m so sorry."
                    },
                    {
                        "username": "Finesse",
                        "content": "The matrix can be viewed as a directional graph, where the cells are weights of the edges leading to these cells. Any algorithm for finding the shortest path in a graph can be used.\n\nSome algorithms aren't designed for negative edge weights (e.g. Dijkstra's), it can be solved by subtracting the minimal weight from the matrix (to make all the values be not negative), and add `minWeight * n` to the result to de-adjust it."
                    }
                ]
            },
            {
                "id": 1715073,
                "content": [
                    {
                        "username": "ujjwal1234",
                        "content": "class Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        vector <int>v;\\n        int sum=0;\\n        int a;\\n        int i=0;\\n        int k=0;\\n        while (k<matrix.size()-1)\\n        {\\n            for (int j=0;j<matrix[0].size();j++)\\n            {\\n                if (j>0 &&j<matrix[0].size()-1)\\n                {\\n        matrix[i][j]+= min(matrix[k+1][j],min(matrix[k+1][j-1],matrix[k+1][j+1]));\\n                }\\n                else if (j==0)\\n                {\\n                     matrix[i][j]+=min(matrix[k+1][j],matrix[k+1][j+1]);\\n                }\\n                 else \\n                 {\\n                     matrix[i][j]+=min(matrix[k+1][j],matrix[k+1][j-1]);\\n                 }\\n            }\\n        k++;\\n    }\\n        \\n         \\n        int min=matrix[0][0];\\n        for (int i=0;i<matrix[0].size();i++)\\n        {\\n            if (min>matrix[0][i])\\n                min=matrix[0][i];\\n        }\\n        return min;\\n        \\n            \\n               \\n\\n    }\\n};\\n\\n\\nMy testcase [[2,1,3],[6,5,4],[7,8,9]] is not getting passed, i m getting 12 the output should be 13. Please help;\\n"
                    },
                    {
                        "username": "ujjwal1234",
                        "content": "[@ironblade](/ironblade) Hey, can you please tell how to fix this"
                    },
                    {
                        "username": "ironblade",
                        "content": "ur soln shows minimum path of whole matriix its not following the neighbour nodes"
                    },
                    {
                        "username": "dhakad22klx",
                        "content": "I am getting TLE at 43/44.Can someone tell how to resolve if you have gone through same."
                    },
                    {
                        "username": "gaurav_rawat369",
                        "content": "same with me\\n"
                    },
                    {
                        "username": "Umang3172",
                        "content": "Why is it so slow?? \\nPls help\\nclass Solution {\\n    int m,n;\\n    public int minFallingPathSum(int[][] matrix) {\\n        m=matrix.length;\\n        n=matrix[0].length;\\n\\n        int res=Integer.MAX_VALUE;\\n        for(int i=0;i<n;i++){\\n            res=Math.min(res,fall(matrix,new Integer[m][n],0,i));\\n        }\\n        return res;\\n    }\\n\\n    public int fall(int[][] matrix, Integer[][] memo, int row, int col){\\n        if(col<0 || col>=n){\\n            return Integer.MAX_VALUE;\\n        }\\n        if(row==m){\\n            return 0;\\n        }\\n        if(memo[row][col]!=null){\\n            return (int)memo[row][col];\\n        }\\n\\n        int[] dir = new int[]{-1,0,1};\\n        int min=Integer.MAX_VALUE;\\n        for(int i : dir){\\n            min=Math.min(min,fall(matrix,memo,row+1,col+i));\\n        }\\n        memo[row][col] = min+matrix[row][col]; \\n        return min+matrix[row][col];\\n    }\\n}\\n"
                    },
                    {
                        "username": "eggzdee",
                        "content": "Hint: basically like yesterday\\'s but 2D"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "just use recursion with cache or memoize to avoid duplicate computation"
                    },
                    {
                        "username": "saanchijain",
                        "content": "as in example given testcase matrix1, output is given 13, but minimum sum can be 12 =1+4+7"
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "Movement is allowed only linearly or diagonally. 4 to 7 movement is not possible."
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "if you know about n queen problem then you can solve this "
                    },
                    {
                        "username": "akashvdubey",
                        "content": "How is this related with n queen, I don\\'t see any back tracking ?"
                    },
                    {
                        "username": "klu_2100030586",
                        "content": "ans = Math.min(ans, minFallingPathSum(A, 0, i, dp));\\n        "
                    },
                    {
                        "username": "R_Prajwal",
                        "content": "But i am just following backtracking and analysing every possible path and updating the value of ans but it is not reflecting\\n"
                    },
                    {
                        "username": "R_Prajwal",
                        "content": "Can anyone Please Explain why value of \"ans\" is not getting updated.\\n(Python) `def minFallingPathSum(self, matrix: List[List[int]]) -> int:\\n        n=len(matrix)\\n        ans=100000   \\n        \\n        def recurse(row,col,path,n,ans):\\n            if row==n:\\n                if path<ans:\\n                    \\n                    ans=int(path)\\n                    \\n                return    \\n\\n            if col==n or col<0 or row==n or row<0:\\n                \\n                \\n                return\\n            path+=matrix[row][col]\\n               \\n            directions=((1,-1),(1,0),(1,1))   \\n            for x,y in directions:\\n                recurse(row+x,col+y,path,n,ans)\\n            path-=matrix[row][col]    \\n\\n\\n       \\n        for j in range(n):\\n            recurse(0,j,0,n,ans)\\n        return ans`\\n"
                    },
                    {
                        "username": "Deetav",
                        "content": "`Line 1034: Char 34: runtime error: addition of unsigned offset to 0x6020000001b0 overflowed to 0x6020000001ac (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34`\\n\\nwhere do i find line 1034, my code has only 26 lines :("
                    },
                    {
                        "username": "gabhinav",
                        "content": "maybe you are trying to access something like dp[-1][1] as or you have defined max size of dp like dp[max] but you are trying to access dp[max+1] which has lead to overflow."
                    },
                    {
                        "username": "karthikmurakonda",
                        "content": "you can keep some thing like cout << \"ok\" in one line and keep running and change the position of cout line . at a point you cann't see ok is printed there you have the problem"
                    },
                    {
                        "username": "ritz-gupta",
                        "content": "That maybe because of the access of undefined memory. Maybe the code is accessing the outside of the matrix. Its the error message when you miss the out of bounds check condition."
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "Because your solution is wrapped by some code you do not have access. LC uses this wrapper to make their job easier i think. In this case the failure trace is not helpful for sure, but from your trace message it means some addition has overflowed and you should start by checking additions in your code"
                    }
                ]
            },
            {
                "id": 1715003,
                "content": [
                    {
                        "username": "ujjwal1234",
                        "content": "class Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        vector <int>v;\\n        int sum=0;\\n        int a;\\n        int i=0;\\n        int k=0;\\n        while (k<matrix.size()-1)\\n        {\\n            for (int j=0;j<matrix[0].size();j++)\\n            {\\n                if (j>0 &&j<matrix[0].size()-1)\\n                {\\n        matrix[i][j]+= min(matrix[k+1][j],min(matrix[k+1][j-1],matrix[k+1][j+1]));\\n                }\\n                else if (j==0)\\n                {\\n                     matrix[i][j]+=min(matrix[k+1][j],matrix[k+1][j+1]);\\n                }\\n                 else \\n                 {\\n                     matrix[i][j]+=min(matrix[k+1][j],matrix[k+1][j-1]);\\n                 }\\n            }\\n        k++;\\n    }\\n        \\n         \\n        int min=matrix[0][0];\\n        for (int i=0;i<matrix[0].size();i++)\\n        {\\n            if (min>matrix[0][i])\\n                min=matrix[0][i];\\n        }\\n        return min;\\n        \\n            \\n               \\n\\n    }\\n};\\n\\n\\nMy testcase [[2,1,3],[6,5,4],[7,8,9]] is not getting passed, i m getting 12 the output should be 13. Please help;\\n"
                    },
                    {
                        "username": "ujjwal1234",
                        "content": "[@ironblade](/ironblade) Hey, can you please tell how to fix this"
                    },
                    {
                        "username": "ironblade",
                        "content": "ur soln shows minimum path of whole matriix its not following the neighbour nodes"
                    },
                    {
                        "username": "dhakad22klx",
                        "content": "I am getting TLE at 43/44.Can someone tell how to resolve if you have gone through same."
                    },
                    {
                        "username": "gaurav_rawat369",
                        "content": "same with me\\n"
                    },
                    {
                        "username": "Umang3172",
                        "content": "Why is it so slow?? \\nPls help\\nclass Solution {\\n    int m,n;\\n    public int minFallingPathSum(int[][] matrix) {\\n        m=matrix.length;\\n        n=matrix[0].length;\\n\\n        int res=Integer.MAX_VALUE;\\n        for(int i=0;i<n;i++){\\n            res=Math.min(res,fall(matrix,new Integer[m][n],0,i));\\n        }\\n        return res;\\n    }\\n\\n    public int fall(int[][] matrix, Integer[][] memo, int row, int col){\\n        if(col<0 || col>=n){\\n            return Integer.MAX_VALUE;\\n        }\\n        if(row==m){\\n            return 0;\\n        }\\n        if(memo[row][col]!=null){\\n            return (int)memo[row][col];\\n        }\\n\\n        int[] dir = new int[]{-1,0,1};\\n        int min=Integer.MAX_VALUE;\\n        for(int i : dir){\\n            min=Math.min(min,fall(matrix,memo,row+1,col+i));\\n        }\\n        memo[row][col] = min+matrix[row][col]; \\n        return min+matrix[row][col];\\n    }\\n}\\n"
                    },
                    {
                        "username": "eggzdee",
                        "content": "Hint: basically like yesterday\\'s but 2D"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "just use recursion with cache or memoize to avoid duplicate computation"
                    },
                    {
                        "username": "saanchijain",
                        "content": "as in example given testcase matrix1, output is given 13, but minimum sum can be 12 =1+4+7"
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "Movement is allowed only linearly or diagonally. 4 to 7 movement is not possible."
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "if you know about n queen problem then you can solve this "
                    },
                    {
                        "username": "akashvdubey",
                        "content": "How is this related with n queen, I don\\'t see any back tracking ?"
                    },
                    {
                        "username": "klu_2100030586",
                        "content": "ans = Math.min(ans, minFallingPathSum(A, 0, i, dp));\\n        "
                    },
                    {
                        "username": "R_Prajwal",
                        "content": "But i am just following backtracking and analysing every possible path and updating the value of ans but it is not reflecting\\n"
                    },
                    {
                        "username": "R_Prajwal",
                        "content": "Can anyone Please Explain why value of \"ans\" is not getting updated.\\n(Python) `def minFallingPathSum(self, matrix: List[List[int]]) -> int:\\n        n=len(matrix)\\n        ans=100000   \\n        \\n        def recurse(row,col,path,n,ans):\\n            if row==n:\\n                if path<ans:\\n                    \\n                    ans=int(path)\\n                    \\n                return    \\n\\n            if col==n or col<0 or row==n or row<0:\\n                \\n                \\n                return\\n            path+=matrix[row][col]\\n               \\n            directions=((1,-1),(1,0),(1,1))   \\n            for x,y in directions:\\n                recurse(row+x,col+y,path,n,ans)\\n            path-=matrix[row][col]    \\n\\n\\n       \\n        for j in range(n):\\n            recurse(0,j,0,n,ans)\\n        return ans`\\n"
                    },
                    {
                        "username": "Deetav",
                        "content": "`Line 1034: Char 34: runtime error: addition of unsigned offset to 0x6020000001b0 overflowed to 0x6020000001ac (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34`\\n\\nwhere do i find line 1034, my code has only 26 lines :("
                    },
                    {
                        "username": "gabhinav",
                        "content": "maybe you are trying to access something like dp[-1][1] as or you have defined max size of dp like dp[max] but you are trying to access dp[max+1] which has lead to overflow."
                    },
                    {
                        "username": "karthikmurakonda",
                        "content": "you can keep some thing like cout << \"ok\" in one line and keep running and change the position of cout line . at a point you cann't see ok is printed there you have the problem"
                    },
                    {
                        "username": "ritz-gupta",
                        "content": "That maybe because of the access of undefined memory. Maybe the code is accessing the outside of the matrix. Its the error message when you miss the out of bounds check condition."
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "Because your solution is wrapped by some code you do not have access. LC uses this wrapper to make their job easier i think. In this case the failure trace is not helpful for sure, but from your trace message it means some addition has overflowed and you should start by checking additions in your code"
                    }
                ]
            },
            {
                "id": 1714955,
                "content": [
                    {
                        "username": "ujjwal1234",
                        "content": "class Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        vector <int>v;\\n        int sum=0;\\n        int a;\\n        int i=0;\\n        int k=0;\\n        while (k<matrix.size()-1)\\n        {\\n            for (int j=0;j<matrix[0].size();j++)\\n            {\\n                if (j>0 &&j<matrix[0].size()-1)\\n                {\\n        matrix[i][j]+= min(matrix[k+1][j],min(matrix[k+1][j-1],matrix[k+1][j+1]));\\n                }\\n                else if (j==0)\\n                {\\n                     matrix[i][j]+=min(matrix[k+1][j],matrix[k+1][j+1]);\\n                }\\n                 else \\n                 {\\n                     matrix[i][j]+=min(matrix[k+1][j],matrix[k+1][j-1]);\\n                 }\\n            }\\n        k++;\\n    }\\n        \\n         \\n        int min=matrix[0][0];\\n        for (int i=0;i<matrix[0].size();i++)\\n        {\\n            if (min>matrix[0][i])\\n                min=matrix[0][i];\\n        }\\n        return min;\\n        \\n            \\n               \\n\\n    }\\n};\\n\\n\\nMy testcase [[2,1,3],[6,5,4],[7,8,9]] is not getting passed, i m getting 12 the output should be 13. Please help;\\n"
                    },
                    {
                        "username": "ujjwal1234",
                        "content": "[@ironblade](/ironblade) Hey, can you please tell how to fix this"
                    },
                    {
                        "username": "ironblade",
                        "content": "ur soln shows minimum path of whole matriix its not following the neighbour nodes"
                    },
                    {
                        "username": "dhakad22klx",
                        "content": "I am getting TLE at 43/44.Can someone tell how to resolve if you have gone through same."
                    },
                    {
                        "username": "gaurav_rawat369",
                        "content": "same with me\\n"
                    },
                    {
                        "username": "Umang3172",
                        "content": "Why is it so slow?? \\nPls help\\nclass Solution {\\n    int m,n;\\n    public int minFallingPathSum(int[][] matrix) {\\n        m=matrix.length;\\n        n=matrix[0].length;\\n\\n        int res=Integer.MAX_VALUE;\\n        for(int i=0;i<n;i++){\\n            res=Math.min(res,fall(matrix,new Integer[m][n],0,i));\\n        }\\n        return res;\\n    }\\n\\n    public int fall(int[][] matrix, Integer[][] memo, int row, int col){\\n        if(col<0 || col>=n){\\n            return Integer.MAX_VALUE;\\n        }\\n        if(row==m){\\n            return 0;\\n        }\\n        if(memo[row][col]!=null){\\n            return (int)memo[row][col];\\n        }\\n\\n        int[] dir = new int[]{-1,0,1};\\n        int min=Integer.MAX_VALUE;\\n        for(int i : dir){\\n            min=Math.min(min,fall(matrix,memo,row+1,col+i));\\n        }\\n        memo[row][col] = min+matrix[row][col]; \\n        return min+matrix[row][col];\\n    }\\n}\\n"
                    },
                    {
                        "username": "eggzdee",
                        "content": "Hint: basically like yesterday\\'s but 2D"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "just use recursion with cache or memoize to avoid duplicate computation"
                    },
                    {
                        "username": "saanchijain",
                        "content": "as in example given testcase matrix1, output is given 13, but minimum sum can be 12 =1+4+7"
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "Movement is allowed only linearly or diagonally. 4 to 7 movement is not possible."
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "if you know about n queen problem then you can solve this "
                    },
                    {
                        "username": "akashvdubey",
                        "content": "How is this related with n queen, I don\\'t see any back tracking ?"
                    },
                    {
                        "username": "klu_2100030586",
                        "content": "ans = Math.min(ans, minFallingPathSum(A, 0, i, dp));\\n        "
                    },
                    {
                        "username": "R_Prajwal",
                        "content": "But i am just following backtracking and analysing every possible path and updating the value of ans but it is not reflecting\\n"
                    },
                    {
                        "username": "R_Prajwal",
                        "content": "Can anyone Please Explain why value of \"ans\" is not getting updated.\\n(Python) `def minFallingPathSum(self, matrix: List[List[int]]) -> int:\\n        n=len(matrix)\\n        ans=100000   \\n        \\n        def recurse(row,col,path,n,ans):\\n            if row==n:\\n                if path<ans:\\n                    \\n                    ans=int(path)\\n                    \\n                return    \\n\\n            if col==n or col<0 or row==n or row<0:\\n                \\n                \\n                return\\n            path+=matrix[row][col]\\n               \\n            directions=((1,-1),(1,0),(1,1))   \\n            for x,y in directions:\\n                recurse(row+x,col+y,path,n,ans)\\n            path-=matrix[row][col]    \\n\\n\\n       \\n        for j in range(n):\\n            recurse(0,j,0,n,ans)\\n        return ans`\\n"
                    },
                    {
                        "username": "Deetav",
                        "content": "`Line 1034: Char 34: runtime error: addition of unsigned offset to 0x6020000001b0 overflowed to 0x6020000001ac (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34`\\n\\nwhere do i find line 1034, my code has only 26 lines :("
                    },
                    {
                        "username": "gabhinav",
                        "content": "maybe you are trying to access something like dp[-1][1] as or you have defined max size of dp like dp[max] but you are trying to access dp[max+1] which has lead to overflow."
                    },
                    {
                        "username": "karthikmurakonda",
                        "content": "you can keep some thing like cout << \"ok\" in one line and keep running and change the position of cout line . at a point you cann't see ok is printed there you have the problem"
                    },
                    {
                        "username": "ritz-gupta",
                        "content": "That maybe because of the access of undefined memory. Maybe the code is accessing the outside of the matrix. Its the error message when you miss the out of bounds check condition."
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "Because your solution is wrapped by some code you do not have access. LC uses this wrapper to make their job easier i think. In this case the failure trace is not helpful for sure, but from your trace message it means some addition has overflowed and you should start by checking additions in your code"
                    }
                ]
            },
            {
                "id": 1714953,
                "content": [
                    {
                        "username": "ujjwal1234",
                        "content": "class Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        vector <int>v;\\n        int sum=0;\\n        int a;\\n        int i=0;\\n        int k=0;\\n        while (k<matrix.size()-1)\\n        {\\n            for (int j=0;j<matrix[0].size();j++)\\n            {\\n                if (j>0 &&j<matrix[0].size()-1)\\n                {\\n        matrix[i][j]+= min(matrix[k+1][j],min(matrix[k+1][j-1],matrix[k+1][j+1]));\\n                }\\n                else if (j==0)\\n                {\\n                     matrix[i][j]+=min(matrix[k+1][j],matrix[k+1][j+1]);\\n                }\\n                 else \\n                 {\\n                     matrix[i][j]+=min(matrix[k+1][j],matrix[k+1][j-1]);\\n                 }\\n            }\\n        k++;\\n    }\\n        \\n         \\n        int min=matrix[0][0];\\n        for (int i=0;i<matrix[0].size();i++)\\n        {\\n            if (min>matrix[0][i])\\n                min=matrix[0][i];\\n        }\\n        return min;\\n        \\n            \\n               \\n\\n    }\\n};\\n\\n\\nMy testcase [[2,1,3],[6,5,4],[7,8,9]] is not getting passed, i m getting 12 the output should be 13. Please help;\\n"
                    },
                    {
                        "username": "ujjwal1234",
                        "content": "[@ironblade](/ironblade) Hey, can you please tell how to fix this"
                    },
                    {
                        "username": "ironblade",
                        "content": "ur soln shows minimum path of whole matriix its not following the neighbour nodes"
                    },
                    {
                        "username": "dhakad22klx",
                        "content": "I am getting TLE at 43/44.Can someone tell how to resolve if you have gone through same."
                    },
                    {
                        "username": "gaurav_rawat369",
                        "content": "same with me\\n"
                    },
                    {
                        "username": "Umang3172",
                        "content": "Why is it so slow?? \\nPls help\\nclass Solution {\\n    int m,n;\\n    public int minFallingPathSum(int[][] matrix) {\\n        m=matrix.length;\\n        n=matrix[0].length;\\n\\n        int res=Integer.MAX_VALUE;\\n        for(int i=0;i<n;i++){\\n            res=Math.min(res,fall(matrix,new Integer[m][n],0,i));\\n        }\\n        return res;\\n    }\\n\\n    public int fall(int[][] matrix, Integer[][] memo, int row, int col){\\n        if(col<0 || col>=n){\\n            return Integer.MAX_VALUE;\\n        }\\n        if(row==m){\\n            return 0;\\n        }\\n        if(memo[row][col]!=null){\\n            return (int)memo[row][col];\\n        }\\n\\n        int[] dir = new int[]{-1,0,1};\\n        int min=Integer.MAX_VALUE;\\n        for(int i : dir){\\n            min=Math.min(min,fall(matrix,memo,row+1,col+i));\\n        }\\n        memo[row][col] = min+matrix[row][col]; \\n        return min+matrix[row][col];\\n    }\\n}\\n"
                    },
                    {
                        "username": "eggzdee",
                        "content": "Hint: basically like yesterday\\'s but 2D"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "just use recursion with cache or memoize to avoid duplicate computation"
                    },
                    {
                        "username": "saanchijain",
                        "content": "as in example given testcase matrix1, output is given 13, but minimum sum can be 12 =1+4+7"
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "Movement is allowed only linearly or diagonally. 4 to 7 movement is not possible."
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "if you know about n queen problem then you can solve this "
                    },
                    {
                        "username": "akashvdubey",
                        "content": "How is this related with n queen, I don\\'t see any back tracking ?"
                    },
                    {
                        "username": "klu_2100030586",
                        "content": "ans = Math.min(ans, minFallingPathSum(A, 0, i, dp));\\n        "
                    },
                    {
                        "username": "R_Prajwal",
                        "content": "But i am just following backtracking and analysing every possible path and updating the value of ans but it is not reflecting\\n"
                    },
                    {
                        "username": "R_Prajwal",
                        "content": "Can anyone Please Explain why value of \"ans\" is not getting updated.\\n(Python) `def minFallingPathSum(self, matrix: List[List[int]]) -> int:\\n        n=len(matrix)\\n        ans=100000   \\n        \\n        def recurse(row,col,path,n,ans):\\n            if row==n:\\n                if path<ans:\\n                    \\n                    ans=int(path)\\n                    \\n                return    \\n\\n            if col==n or col<0 or row==n or row<0:\\n                \\n                \\n                return\\n            path+=matrix[row][col]\\n               \\n            directions=((1,-1),(1,0),(1,1))   \\n            for x,y in directions:\\n                recurse(row+x,col+y,path,n,ans)\\n            path-=matrix[row][col]    \\n\\n\\n       \\n        for j in range(n):\\n            recurse(0,j,0,n,ans)\\n        return ans`\\n"
                    },
                    {
                        "username": "Deetav",
                        "content": "`Line 1034: Char 34: runtime error: addition of unsigned offset to 0x6020000001b0 overflowed to 0x6020000001ac (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34`\\n\\nwhere do i find line 1034, my code has only 26 lines :("
                    },
                    {
                        "username": "gabhinav",
                        "content": "maybe you are trying to access something like dp[-1][1] as or you have defined max size of dp like dp[max] but you are trying to access dp[max+1] which has lead to overflow."
                    },
                    {
                        "username": "karthikmurakonda",
                        "content": "you can keep some thing like cout << \"ok\" in one line and keep running and change the position of cout line . at a point you cann't see ok is printed there you have the problem"
                    },
                    {
                        "username": "ritz-gupta",
                        "content": "That maybe because of the access of undefined memory. Maybe the code is accessing the outside of the matrix. Its the error message when you miss the out of bounds check condition."
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "Because your solution is wrapped by some code you do not have access. LC uses this wrapper to make their job easier i think. In this case the failure trace is not helpful for sure, but from your trace message it means some addition has overflowed and you should start by checking additions in your code"
                    }
                ]
            },
            {
                "id": 1714940,
                "content": [
                    {
                        "username": "ujjwal1234",
                        "content": "class Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        vector <int>v;\\n        int sum=0;\\n        int a;\\n        int i=0;\\n        int k=0;\\n        while (k<matrix.size()-1)\\n        {\\n            for (int j=0;j<matrix[0].size();j++)\\n            {\\n                if (j>0 &&j<matrix[0].size()-1)\\n                {\\n        matrix[i][j]+= min(matrix[k+1][j],min(matrix[k+1][j-1],matrix[k+1][j+1]));\\n                }\\n                else if (j==0)\\n                {\\n                     matrix[i][j]+=min(matrix[k+1][j],matrix[k+1][j+1]);\\n                }\\n                 else \\n                 {\\n                     matrix[i][j]+=min(matrix[k+1][j],matrix[k+1][j-1]);\\n                 }\\n            }\\n        k++;\\n    }\\n        \\n         \\n        int min=matrix[0][0];\\n        for (int i=0;i<matrix[0].size();i++)\\n        {\\n            if (min>matrix[0][i])\\n                min=matrix[0][i];\\n        }\\n        return min;\\n        \\n            \\n               \\n\\n    }\\n};\\n\\n\\nMy testcase [[2,1,3],[6,5,4],[7,8,9]] is not getting passed, i m getting 12 the output should be 13. Please help;\\n"
                    },
                    {
                        "username": "ujjwal1234",
                        "content": "[@ironblade](/ironblade) Hey, can you please tell how to fix this"
                    },
                    {
                        "username": "ironblade",
                        "content": "ur soln shows minimum path of whole matriix its not following the neighbour nodes"
                    },
                    {
                        "username": "dhakad22klx",
                        "content": "I am getting TLE at 43/44.Can someone tell how to resolve if you have gone through same."
                    },
                    {
                        "username": "gaurav_rawat369",
                        "content": "same with me\\n"
                    },
                    {
                        "username": "Umang3172",
                        "content": "Why is it so slow?? \\nPls help\\nclass Solution {\\n    int m,n;\\n    public int minFallingPathSum(int[][] matrix) {\\n        m=matrix.length;\\n        n=matrix[0].length;\\n\\n        int res=Integer.MAX_VALUE;\\n        for(int i=0;i<n;i++){\\n            res=Math.min(res,fall(matrix,new Integer[m][n],0,i));\\n        }\\n        return res;\\n    }\\n\\n    public int fall(int[][] matrix, Integer[][] memo, int row, int col){\\n        if(col<0 || col>=n){\\n            return Integer.MAX_VALUE;\\n        }\\n        if(row==m){\\n            return 0;\\n        }\\n        if(memo[row][col]!=null){\\n            return (int)memo[row][col];\\n        }\\n\\n        int[] dir = new int[]{-1,0,1};\\n        int min=Integer.MAX_VALUE;\\n        for(int i : dir){\\n            min=Math.min(min,fall(matrix,memo,row+1,col+i));\\n        }\\n        memo[row][col] = min+matrix[row][col]; \\n        return min+matrix[row][col];\\n    }\\n}\\n"
                    },
                    {
                        "username": "eggzdee",
                        "content": "Hint: basically like yesterday\\'s but 2D"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "just use recursion with cache or memoize to avoid duplicate computation"
                    },
                    {
                        "username": "saanchijain",
                        "content": "as in example given testcase matrix1, output is given 13, but minimum sum can be 12 =1+4+7"
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "Movement is allowed only linearly or diagonally. 4 to 7 movement is not possible."
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "if you know about n queen problem then you can solve this "
                    },
                    {
                        "username": "akashvdubey",
                        "content": "How is this related with n queen, I don\\'t see any back tracking ?"
                    },
                    {
                        "username": "klu_2100030586",
                        "content": "ans = Math.min(ans, minFallingPathSum(A, 0, i, dp));\\n        "
                    },
                    {
                        "username": "R_Prajwal",
                        "content": "But i am just following backtracking and analysing every possible path and updating the value of ans but it is not reflecting\\n"
                    },
                    {
                        "username": "R_Prajwal",
                        "content": "Can anyone Please Explain why value of \"ans\" is not getting updated.\\n(Python) `def minFallingPathSum(self, matrix: List[List[int]]) -> int:\\n        n=len(matrix)\\n        ans=100000   \\n        \\n        def recurse(row,col,path,n,ans):\\n            if row==n:\\n                if path<ans:\\n                    \\n                    ans=int(path)\\n                    \\n                return    \\n\\n            if col==n or col<0 or row==n or row<0:\\n                \\n                \\n                return\\n            path+=matrix[row][col]\\n               \\n            directions=((1,-1),(1,0),(1,1))   \\n            for x,y in directions:\\n                recurse(row+x,col+y,path,n,ans)\\n            path-=matrix[row][col]    \\n\\n\\n       \\n        for j in range(n):\\n            recurse(0,j,0,n,ans)\\n        return ans`\\n"
                    },
                    {
                        "username": "Deetav",
                        "content": "`Line 1034: Char 34: runtime error: addition of unsigned offset to 0x6020000001b0 overflowed to 0x6020000001ac (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34`\\n\\nwhere do i find line 1034, my code has only 26 lines :("
                    },
                    {
                        "username": "gabhinav",
                        "content": "maybe you are trying to access something like dp[-1][1] as or you have defined max size of dp like dp[max] but you are trying to access dp[max+1] which has lead to overflow."
                    },
                    {
                        "username": "karthikmurakonda",
                        "content": "you can keep some thing like cout << \"ok\" in one line and keep running and change the position of cout line . at a point you cann't see ok is printed there you have the problem"
                    },
                    {
                        "username": "ritz-gupta",
                        "content": "That maybe because of the access of undefined memory. Maybe the code is accessing the outside of the matrix. Its the error message when you miss the out of bounds check condition."
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "Because your solution is wrapped by some code you do not have access. LC uses this wrapper to make their job easier i think. In this case the failure trace is not helpful for sure, but from your trace message it means some addition has overflowed and you should start by checking additions in your code"
                    }
                ]
            },
            {
                "id": 1714889,
                "content": [
                    {
                        "username": "ujjwal1234",
                        "content": "class Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        vector <int>v;\\n        int sum=0;\\n        int a;\\n        int i=0;\\n        int k=0;\\n        while (k<matrix.size()-1)\\n        {\\n            for (int j=0;j<matrix[0].size();j++)\\n            {\\n                if (j>0 &&j<matrix[0].size()-1)\\n                {\\n        matrix[i][j]+= min(matrix[k+1][j],min(matrix[k+1][j-1],matrix[k+1][j+1]));\\n                }\\n                else if (j==0)\\n                {\\n                     matrix[i][j]+=min(matrix[k+1][j],matrix[k+1][j+1]);\\n                }\\n                 else \\n                 {\\n                     matrix[i][j]+=min(matrix[k+1][j],matrix[k+1][j-1]);\\n                 }\\n            }\\n        k++;\\n    }\\n        \\n         \\n        int min=matrix[0][0];\\n        for (int i=0;i<matrix[0].size();i++)\\n        {\\n            if (min>matrix[0][i])\\n                min=matrix[0][i];\\n        }\\n        return min;\\n        \\n            \\n               \\n\\n    }\\n};\\n\\n\\nMy testcase [[2,1,3],[6,5,4],[7,8,9]] is not getting passed, i m getting 12 the output should be 13. Please help;\\n"
                    },
                    {
                        "username": "ujjwal1234",
                        "content": "[@ironblade](/ironblade) Hey, can you please tell how to fix this"
                    },
                    {
                        "username": "ironblade",
                        "content": "ur soln shows minimum path of whole matriix its not following the neighbour nodes"
                    },
                    {
                        "username": "dhakad22klx",
                        "content": "I am getting TLE at 43/44.Can someone tell how to resolve if you have gone through same."
                    },
                    {
                        "username": "gaurav_rawat369",
                        "content": "same with me\\n"
                    },
                    {
                        "username": "Umang3172",
                        "content": "Why is it so slow?? \\nPls help\\nclass Solution {\\n    int m,n;\\n    public int minFallingPathSum(int[][] matrix) {\\n        m=matrix.length;\\n        n=matrix[0].length;\\n\\n        int res=Integer.MAX_VALUE;\\n        for(int i=0;i<n;i++){\\n            res=Math.min(res,fall(matrix,new Integer[m][n],0,i));\\n        }\\n        return res;\\n    }\\n\\n    public int fall(int[][] matrix, Integer[][] memo, int row, int col){\\n        if(col<0 || col>=n){\\n            return Integer.MAX_VALUE;\\n        }\\n        if(row==m){\\n            return 0;\\n        }\\n        if(memo[row][col]!=null){\\n            return (int)memo[row][col];\\n        }\\n\\n        int[] dir = new int[]{-1,0,1};\\n        int min=Integer.MAX_VALUE;\\n        for(int i : dir){\\n            min=Math.min(min,fall(matrix,memo,row+1,col+i));\\n        }\\n        memo[row][col] = min+matrix[row][col]; \\n        return min+matrix[row][col];\\n    }\\n}\\n"
                    },
                    {
                        "username": "eggzdee",
                        "content": "Hint: basically like yesterday\\'s but 2D"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "just use recursion with cache or memoize to avoid duplicate computation"
                    },
                    {
                        "username": "saanchijain",
                        "content": "as in example given testcase matrix1, output is given 13, but minimum sum can be 12 =1+4+7"
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "Movement is allowed only linearly or diagonally. 4 to 7 movement is not possible."
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "if you know about n queen problem then you can solve this "
                    },
                    {
                        "username": "akashvdubey",
                        "content": "How is this related with n queen, I don\\'t see any back tracking ?"
                    },
                    {
                        "username": "klu_2100030586",
                        "content": "ans = Math.min(ans, minFallingPathSum(A, 0, i, dp));\\n        "
                    },
                    {
                        "username": "R_Prajwal",
                        "content": "But i am just following backtracking and analysing every possible path and updating the value of ans but it is not reflecting\\n"
                    },
                    {
                        "username": "R_Prajwal",
                        "content": "Can anyone Please Explain why value of \"ans\" is not getting updated.\\n(Python) `def minFallingPathSum(self, matrix: List[List[int]]) -> int:\\n        n=len(matrix)\\n        ans=100000   \\n        \\n        def recurse(row,col,path,n,ans):\\n            if row==n:\\n                if path<ans:\\n                    \\n                    ans=int(path)\\n                    \\n                return    \\n\\n            if col==n or col<0 or row==n or row<0:\\n                \\n                \\n                return\\n            path+=matrix[row][col]\\n               \\n            directions=((1,-1),(1,0),(1,1))   \\n            for x,y in directions:\\n                recurse(row+x,col+y,path,n,ans)\\n            path-=matrix[row][col]    \\n\\n\\n       \\n        for j in range(n):\\n            recurse(0,j,0,n,ans)\\n        return ans`\\n"
                    },
                    {
                        "username": "Deetav",
                        "content": "`Line 1034: Char 34: runtime error: addition of unsigned offset to 0x6020000001b0 overflowed to 0x6020000001ac (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34`\\n\\nwhere do i find line 1034, my code has only 26 lines :("
                    },
                    {
                        "username": "gabhinav",
                        "content": "maybe you are trying to access something like dp[-1][1] as or you have defined max size of dp like dp[max] but you are trying to access dp[max+1] which has lead to overflow."
                    },
                    {
                        "username": "karthikmurakonda",
                        "content": "you can keep some thing like cout << \"ok\" in one line and keep running and change the position of cout line . at a point you cann't see ok is printed there you have the problem"
                    },
                    {
                        "username": "ritz-gupta",
                        "content": "That maybe because of the access of undefined memory. Maybe the code is accessing the outside of the matrix. Its the error message when you miss the out of bounds check condition."
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "Because your solution is wrapped by some code you do not have access. LC uses this wrapper to make their job easier i think. In this case the failure trace is not helpful for sure, but from your trace message it means some addition has overflowed and you should start by checking additions in your code"
                    }
                ]
            },
            {
                "id": 1714875,
                "content": [
                    {
                        "username": "ujjwal1234",
                        "content": "class Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        vector <int>v;\\n        int sum=0;\\n        int a;\\n        int i=0;\\n        int k=0;\\n        while (k<matrix.size()-1)\\n        {\\n            for (int j=0;j<matrix[0].size();j++)\\n            {\\n                if (j>0 &&j<matrix[0].size()-1)\\n                {\\n        matrix[i][j]+= min(matrix[k+1][j],min(matrix[k+1][j-1],matrix[k+1][j+1]));\\n                }\\n                else if (j==0)\\n                {\\n                     matrix[i][j]+=min(matrix[k+1][j],matrix[k+1][j+1]);\\n                }\\n                 else \\n                 {\\n                     matrix[i][j]+=min(matrix[k+1][j],matrix[k+1][j-1]);\\n                 }\\n            }\\n        k++;\\n    }\\n        \\n         \\n        int min=matrix[0][0];\\n        for (int i=0;i<matrix[0].size();i++)\\n        {\\n            if (min>matrix[0][i])\\n                min=matrix[0][i];\\n        }\\n        return min;\\n        \\n            \\n               \\n\\n    }\\n};\\n\\n\\nMy testcase [[2,1,3],[6,5,4],[7,8,9]] is not getting passed, i m getting 12 the output should be 13. Please help;\\n"
                    },
                    {
                        "username": "ujjwal1234",
                        "content": "[@ironblade](/ironblade) Hey, can you please tell how to fix this"
                    },
                    {
                        "username": "ironblade",
                        "content": "ur soln shows minimum path of whole matriix its not following the neighbour nodes"
                    },
                    {
                        "username": "dhakad22klx",
                        "content": "I am getting TLE at 43/44.Can someone tell how to resolve if you have gone through same."
                    },
                    {
                        "username": "gaurav_rawat369",
                        "content": "same with me\\n"
                    },
                    {
                        "username": "Umang3172",
                        "content": "Why is it so slow?? \\nPls help\\nclass Solution {\\n    int m,n;\\n    public int minFallingPathSum(int[][] matrix) {\\n        m=matrix.length;\\n        n=matrix[0].length;\\n\\n        int res=Integer.MAX_VALUE;\\n        for(int i=0;i<n;i++){\\n            res=Math.min(res,fall(matrix,new Integer[m][n],0,i));\\n        }\\n        return res;\\n    }\\n\\n    public int fall(int[][] matrix, Integer[][] memo, int row, int col){\\n        if(col<0 || col>=n){\\n            return Integer.MAX_VALUE;\\n        }\\n        if(row==m){\\n            return 0;\\n        }\\n        if(memo[row][col]!=null){\\n            return (int)memo[row][col];\\n        }\\n\\n        int[] dir = new int[]{-1,0,1};\\n        int min=Integer.MAX_VALUE;\\n        for(int i : dir){\\n            min=Math.min(min,fall(matrix,memo,row+1,col+i));\\n        }\\n        memo[row][col] = min+matrix[row][col]; \\n        return min+matrix[row][col];\\n    }\\n}\\n"
                    },
                    {
                        "username": "eggzdee",
                        "content": "Hint: basically like yesterday\\'s but 2D"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "just use recursion with cache or memoize to avoid duplicate computation"
                    },
                    {
                        "username": "saanchijain",
                        "content": "as in example given testcase matrix1, output is given 13, but minimum sum can be 12 =1+4+7"
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "Movement is allowed only linearly or diagonally. 4 to 7 movement is not possible."
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "if you know about n queen problem then you can solve this "
                    },
                    {
                        "username": "akashvdubey",
                        "content": "How is this related with n queen, I don\\'t see any back tracking ?"
                    },
                    {
                        "username": "klu_2100030586",
                        "content": "ans = Math.min(ans, minFallingPathSum(A, 0, i, dp));\\n        "
                    },
                    {
                        "username": "R_Prajwal",
                        "content": "But i am just following backtracking and analysing every possible path and updating the value of ans but it is not reflecting\\n"
                    },
                    {
                        "username": "R_Prajwal",
                        "content": "Can anyone Please Explain why value of \"ans\" is not getting updated.\\n(Python) `def minFallingPathSum(self, matrix: List[List[int]]) -> int:\\n        n=len(matrix)\\n        ans=100000   \\n        \\n        def recurse(row,col,path,n,ans):\\n            if row==n:\\n                if path<ans:\\n                    \\n                    ans=int(path)\\n                    \\n                return    \\n\\n            if col==n or col<0 or row==n or row<0:\\n                \\n                \\n                return\\n            path+=matrix[row][col]\\n               \\n            directions=((1,-1),(1,0),(1,1))   \\n            for x,y in directions:\\n                recurse(row+x,col+y,path,n,ans)\\n            path-=matrix[row][col]    \\n\\n\\n       \\n        for j in range(n):\\n            recurse(0,j,0,n,ans)\\n        return ans`\\n"
                    },
                    {
                        "username": "Deetav",
                        "content": "`Line 1034: Char 34: runtime error: addition of unsigned offset to 0x6020000001b0 overflowed to 0x6020000001ac (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34`\\n\\nwhere do i find line 1034, my code has only 26 lines :("
                    },
                    {
                        "username": "gabhinav",
                        "content": "maybe you are trying to access something like dp[-1][1] as or you have defined max size of dp like dp[max] but you are trying to access dp[max+1] which has lead to overflow."
                    },
                    {
                        "username": "karthikmurakonda",
                        "content": "you can keep some thing like cout << \"ok\" in one line and keep running and change the position of cout line . at a point you cann't see ok is printed there you have the problem"
                    },
                    {
                        "username": "ritz-gupta",
                        "content": "That maybe because of the access of undefined memory. Maybe the code is accessing the outside of the matrix. Its the error message when you miss the out of bounds check condition."
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "Because your solution is wrapped by some code you do not have access. LC uses this wrapper to make their job easier i think. In this case the failure trace is not helpful for sure, but from your trace message it means some addition has overflowed and you should start by checking additions in your code"
                    }
                ]
            },
            {
                "id": 1714824,
                "content": [
                    {
                        "username": "ujjwal1234",
                        "content": "class Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        vector <int>v;\\n        int sum=0;\\n        int a;\\n        int i=0;\\n        int k=0;\\n        while (k<matrix.size()-1)\\n        {\\n            for (int j=0;j<matrix[0].size();j++)\\n            {\\n                if (j>0 &&j<matrix[0].size()-1)\\n                {\\n        matrix[i][j]+= min(matrix[k+1][j],min(matrix[k+1][j-1],matrix[k+1][j+1]));\\n                }\\n                else if (j==0)\\n                {\\n                     matrix[i][j]+=min(matrix[k+1][j],matrix[k+1][j+1]);\\n                }\\n                 else \\n                 {\\n                     matrix[i][j]+=min(matrix[k+1][j],matrix[k+1][j-1]);\\n                 }\\n            }\\n        k++;\\n    }\\n        \\n         \\n        int min=matrix[0][0];\\n        for (int i=0;i<matrix[0].size();i++)\\n        {\\n            if (min>matrix[0][i])\\n                min=matrix[0][i];\\n        }\\n        return min;\\n        \\n            \\n               \\n\\n    }\\n};\\n\\n\\nMy testcase [[2,1,3],[6,5,4],[7,8,9]] is not getting passed, i m getting 12 the output should be 13. Please help;\\n"
                    },
                    {
                        "username": "ujjwal1234",
                        "content": "[@ironblade](/ironblade) Hey, can you please tell how to fix this"
                    },
                    {
                        "username": "ironblade",
                        "content": "ur soln shows minimum path of whole matriix its not following the neighbour nodes"
                    },
                    {
                        "username": "dhakad22klx",
                        "content": "I am getting TLE at 43/44.Can someone tell how to resolve if you have gone through same."
                    },
                    {
                        "username": "gaurav_rawat369",
                        "content": "same with me\\n"
                    },
                    {
                        "username": "Umang3172",
                        "content": "Why is it so slow?? \\nPls help\\nclass Solution {\\n    int m,n;\\n    public int minFallingPathSum(int[][] matrix) {\\n        m=matrix.length;\\n        n=matrix[0].length;\\n\\n        int res=Integer.MAX_VALUE;\\n        for(int i=0;i<n;i++){\\n            res=Math.min(res,fall(matrix,new Integer[m][n],0,i));\\n        }\\n        return res;\\n    }\\n\\n    public int fall(int[][] matrix, Integer[][] memo, int row, int col){\\n        if(col<0 || col>=n){\\n            return Integer.MAX_VALUE;\\n        }\\n        if(row==m){\\n            return 0;\\n        }\\n        if(memo[row][col]!=null){\\n            return (int)memo[row][col];\\n        }\\n\\n        int[] dir = new int[]{-1,0,1};\\n        int min=Integer.MAX_VALUE;\\n        for(int i : dir){\\n            min=Math.min(min,fall(matrix,memo,row+1,col+i));\\n        }\\n        memo[row][col] = min+matrix[row][col]; \\n        return min+matrix[row][col];\\n    }\\n}\\n"
                    },
                    {
                        "username": "eggzdee",
                        "content": "Hint: basically like yesterday\\'s but 2D"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "just use recursion with cache or memoize to avoid duplicate computation"
                    },
                    {
                        "username": "saanchijain",
                        "content": "as in example given testcase matrix1, output is given 13, but minimum sum can be 12 =1+4+7"
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "Movement is allowed only linearly or diagonally. 4 to 7 movement is not possible."
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "if you know about n queen problem then you can solve this "
                    },
                    {
                        "username": "akashvdubey",
                        "content": "How is this related with n queen, I don\\'t see any back tracking ?"
                    },
                    {
                        "username": "klu_2100030586",
                        "content": "ans = Math.min(ans, minFallingPathSum(A, 0, i, dp));\\n        "
                    },
                    {
                        "username": "R_Prajwal",
                        "content": "But i am just following backtracking and analysing every possible path and updating the value of ans but it is not reflecting\\n"
                    },
                    {
                        "username": "R_Prajwal",
                        "content": "Can anyone Please Explain why value of \"ans\" is not getting updated.\\n(Python) `def minFallingPathSum(self, matrix: List[List[int]]) -> int:\\n        n=len(matrix)\\n        ans=100000   \\n        \\n        def recurse(row,col,path,n,ans):\\n            if row==n:\\n                if path<ans:\\n                    \\n                    ans=int(path)\\n                    \\n                return    \\n\\n            if col==n or col<0 or row==n or row<0:\\n                \\n                \\n                return\\n            path+=matrix[row][col]\\n               \\n            directions=((1,-1),(1,0),(1,1))   \\n            for x,y in directions:\\n                recurse(row+x,col+y,path,n,ans)\\n            path-=matrix[row][col]    \\n\\n\\n       \\n        for j in range(n):\\n            recurse(0,j,0,n,ans)\\n        return ans`\\n"
                    },
                    {
                        "username": "Deetav",
                        "content": "`Line 1034: Char 34: runtime error: addition of unsigned offset to 0x6020000001b0 overflowed to 0x6020000001ac (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34`\\n\\nwhere do i find line 1034, my code has only 26 lines :("
                    },
                    {
                        "username": "gabhinav",
                        "content": "maybe you are trying to access something like dp[-1][1] as or you have defined max size of dp like dp[max] but you are trying to access dp[max+1] which has lead to overflow."
                    },
                    {
                        "username": "karthikmurakonda",
                        "content": "you can keep some thing like cout << \"ok\" in one line and keep running and change the position of cout line . at a point you cann't see ok is printed there you have the problem"
                    },
                    {
                        "username": "ritz-gupta",
                        "content": "That maybe because of the access of undefined memory. Maybe the code is accessing the outside of the matrix. Its the error message when you miss the out of bounds check condition."
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "Because your solution is wrapped by some code you do not have access. LC uses this wrapper to make their job easier i think. In this case the failure trace is not helpful for sure, but from your trace message it means some addition has overflowed and you should start by checking additions in your code"
                    }
                ]
            },
            {
                "id": 1714820,
                "content": [
                    {
                        "username": "ujjwal1234",
                        "content": "class Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        vector <int>v;\\n        int sum=0;\\n        int a;\\n        int i=0;\\n        int k=0;\\n        while (k<matrix.size()-1)\\n        {\\n            for (int j=0;j<matrix[0].size();j++)\\n            {\\n                if (j>0 &&j<matrix[0].size()-1)\\n                {\\n        matrix[i][j]+= min(matrix[k+1][j],min(matrix[k+1][j-1],matrix[k+1][j+1]));\\n                }\\n                else if (j==0)\\n                {\\n                     matrix[i][j]+=min(matrix[k+1][j],matrix[k+1][j+1]);\\n                }\\n                 else \\n                 {\\n                     matrix[i][j]+=min(matrix[k+1][j],matrix[k+1][j-1]);\\n                 }\\n            }\\n        k++;\\n    }\\n        \\n         \\n        int min=matrix[0][0];\\n        for (int i=0;i<matrix[0].size();i++)\\n        {\\n            if (min>matrix[0][i])\\n                min=matrix[0][i];\\n        }\\n        return min;\\n        \\n            \\n               \\n\\n    }\\n};\\n\\n\\nMy testcase [[2,1,3],[6,5,4],[7,8,9]] is not getting passed, i m getting 12 the output should be 13. Please help;\\n"
                    },
                    {
                        "username": "ujjwal1234",
                        "content": "[@ironblade](/ironblade) Hey, can you please tell how to fix this"
                    },
                    {
                        "username": "ironblade",
                        "content": "ur soln shows minimum path of whole matriix its not following the neighbour nodes"
                    },
                    {
                        "username": "dhakad22klx",
                        "content": "I am getting TLE at 43/44.Can someone tell how to resolve if you have gone through same."
                    },
                    {
                        "username": "gaurav_rawat369",
                        "content": "same with me\\n"
                    },
                    {
                        "username": "Umang3172",
                        "content": "Why is it so slow?? \\nPls help\\nclass Solution {\\n    int m,n;\\n    public int minFallingPathSum(int[][] matrix) {\\n        m=matrix.length;\\n        n=matrix[0].length;\\n\\n        int res=Integer.MAX_VALUE;\\n        for(int i=0;i<n;i++){\\n            res=Math.min(res,fall(matrix,new Integer[m][n],0,i));\\n        }\\n        return res;\\n    }\\n\\n    public int fall(int[][] matrix, Integer[][] memo, int row, int col){\\n        if(col<0 || col>=n){\\n            return Integer.MAX_VALUE;\\n        }\\n        if(row==m){\\n            return 0;\\n        }\\n        if(memo[row][col]!=null){\\n            return (int)memo[row][col];\\n        }\\n\\n        int[] dir = new int[]{-1,0,1};\\n        int min=Integer.MAX_VALUE;\\n        for(int i : dir){\\n            min=Math.min(min,fall(matrix,memo,row+1,col+i));\\n        }\\n        memo[row][col] = min+matrix[row][col]; \\n        return min+matrix[row][col];\\n    }\\n}\\n"
                    },
                    {
                        "username": "eggzdee",
                        "content": "Hint: basically like yesterday\\'s but 2D"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "just use recursion with cache or memoize to avoid duplicate computation"
                    },
                    {
                        "username": "saanchijain",
                        "content": "as in example given testcase matrix1, output is given 13, but minimum sum can be 12 =1+4+7"
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "Movement is allowed only linearly or diagonally. 4 to 7 movement is not possible."
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "if you know about n queen problem then you can solve this "
                    },
                    {
                        "username": "akashvdubey",
                        "content": "How is this related with n queen, I don\\'t see any back tracking ?"
                    },
                    {
                        "username": "klu_2100030586",
                        "content": "ans = Math.min(ans, minFallingPathSum(A, 0, i, dp));\\n        "
                    },
                    {
                        "username": "R_Prajwal",
                        "content": "But i am just following backtracking and analysing every possible path and updating the value of ans but it is not reflecting\\n"
                    },
                    {
                        "username": "R_Prajwal",
                        "content": "Can anyone Please Explain why value of \"ans\" is not getting updated.\\n(Python) `def minFallingPathSum(self, matrix: List[List[int]]) -> int:\\n        n=len(matrix)\\n        ans=100000   \\n        \\n        def recurse(row,col,path,n,ans):\\n            if row==n:\\n                if path<ans:\\n                    \\n                    ans=int(path)\\n                    \\n                return    \\n\\n            if col==n or col<0 or row==n or row<0:\\n                \\n                \\n                return\\n            path+=matrix[row][col]\\n               \\n            directions=((1,-1),(1,0),(1,1))   \\n            for x,y in directions:\\n                recurse(row+x,col+y,path,n,ans)\\n            path-=matrix[row][col]    \\n\\n\\n       \\n        for j in range(n):\\n            recurse(0,j,0,n,ans)\\n        return ans`\\n"
                    },
                    {
                        "username": "Deetav",
                        "content": "`Line 1034: Char 34: runtime error: addition of unsigned offset to 0x6020000001b0 overflowed to 0x6020000001ac (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34`\\n\\nwhere do i find line 1034, my code has only 26 lines :("
                    },
                    {
                        "username": "gabhinav",
                        "content": "maybe you are trying to access something like dp[-1][1] as or you have defined max size of dp like dp[max] but you are trying to access dp[max+1] which has lead to overflow."
                    },
                    {
                        "username": "karthikmurakonda",
                        "content": "you can keep some thing like cout << \"ok\" in one line and keep running and change the position of cout line . at a point you cann't see ok is printed there you have the problem"
                    },
                    {
                        "username": "ritz-gupta",
                        "content": "That maybe because of the access of undefined memory. Maybe the code is accessing the outside of the matrix. Its the error message when you miss the out of bounds check condition."
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "Because your solution is wrapped by some code you do not have access. LC uses this wrapper to make their job easier i think. In this case the failure trace is not helpful for sure, but from your trace message it means some addition has overflowed and you should start by checking additions in your code"
                    }
                ]
            },
            {
                "id": 1714712,
                "content": [
                    {
                        "username": "ujjwal1234",
                        "content": "class Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        vector <int>v;\\n        int sum=0;\\n        int a;\\n        int i=0;\\n        int k=0;\\n        while (k<matrix.size()-1)\\n        {\\n            for (int j=0;j<matrix[0].size();j++)\\n            {\\n                if (j>0 &&j<matrix[0].size()-1)\\n                {\\n        matrix[i][j]+= min(matrix[k+1][j],min(matrix[k+1][j-1],matrix[k+1][j+1]));\\n                }\\n                else if (j==0)\\n                {\\n                     matrix[i][j]+=min(matrix[k+1][j],matrix[k+1][j+1]);\\n                }\\n                 else \\n                 {\\n                     matrix[i][j]+=min(matrix[k+1][j],matrix[k+1][j-1]);\\n                 }\\n            }\\n        k++;\\n    }\\n        \\n         \\n        int min=matrix[0][0];\\n        for (int i=0;i<matrix[0].size();i++)\\n        {\\n            if (min>matrix[0][i])\\n                min=matrix[0][i];\\n        }\\n        return min;\\n        \\n            \\n               \\n\\n    }\\n};\\n\\n\\nMy testcase [[2,1,3],[6,5,4],[7,8,9]] is not getting passed, i m getting 12 the output should be 13. Please help;\\n"
                    },
                    {
                        "username": "ujjwal1234",
                        "content": "[@ironblade](/ironblade) Hey, can you please tell how to fix this"
                    },
                    {
                        "username": "ironblade",
                        "content": "ur soln shows minimum path of whole matriix its not following the neighbour nodes"
                    },
                    {
                        "username": "dhakad22klx",
                        "content": "I am getting TLE at 43/44.Can someone tell how to resolve if you have gone through same."
                    },
                    {
                        "username": "gaurav_rawat369",
                        "content": "same with me\\n"
                    },
                    {
                        "username": "Umang3172",
                        "content": "Why is it so slow?? \\nPls help\\nclass Solution {\\n    int m,n;\\n    public int minFallingPathSum(int[][] matrix) {\\n        m=matrix.length;\\n        n=matrix[0].length;\\n\\n        int res=Integer.MAX_VALUE;\\n        for(int i=0;i<n;i++){\\n            res=Math.min(res,fall(matrix,new Integer[m][n],0,i));\\n        }\\n        return res;\\n    }\\n\\n    public int fall(int[][] matrix, Integer[][] memo, int row, int col){\\n        if(col<0 || col>=n){\\n            return Integer.MAX_VALUE;\\n        }\\n        if(row==m){\\n            return 0;\\n        }\\n        if(memo[row][col]!=null){\\n            return (int)memo[row][col];\\n        }\\n\\n        int[] dir = new int[]{-1,0,1};\\n        int min=Integer.MAX_VALUE;\\n        for(int i : dir){\\n            min=Math.min(min,fall(matrix,memo,row+1,col+i));\\n        }\\n        memo[row][col] = min+matrix[row][col]; \\n        return min+matrix[row][col];\\n    }\\n}\\n"
                    },
                    {
                        "username": "eggzdee",
                        "content": "Hint: basically like yesterday\\'s but 2D"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "just use recursion with cache or memoize to avoid duplicate computation"
                    },
                    {
                        "username": "saanchijain",
                        "content": "as in example given testcase matrix1, output is given 13, but minimum sum can be 12 =1+4+7"
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "Movement is allowed only linearly or diagonally. 4 to 7 movement is not possible."
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "if you know about n queen problem then you can solve this "
                    },
                    {
                        "username": "akashvdubey",
                        "content": "How is this related with n queen, I don\\'t see any back tracking ?"
                    },
                    {
                        "username": "klu_2100030586",
                        "content": "ans = Math.min(ans, minFallingPathSum(A, 0, i, dp));\\n        "
                    },
                    {
                        "username": "R_Prajwal",
                        "content": "But i am just following backtracking and analysing every possible path and updating the value of ans but it is not reflecting\\n"
                    },
                    {
                        "username": "R_Prajwal",
                        "content": "Can anyone Please Explain why value of \"ans\" is not getting updated.\\n(Python) `def minFallingPathSum(self, matrix: List[List[int]]) -> int:\\n        n=len(matrix)\\n        ans=100000   \\n        \\n        def recurse(row,col,path,n,ans):\\n            if row==n:\\n                if path<ans:\\n                    \\n                    ans=int(path)\\n                    \\n                return    \\n\\n            if col==n or col<0 or row==n or row<0:\\n                \\n                \\n                return\\n            path+=matrix[row][col]\\n               \\n            directions=((1,-1),(1,0),(1,1))   \\n            for x,y in directions:\\n                recurse(row+x,col+y,path,n,ans)\\n            path-=matrix[row][col]    \\n\\n\\n       \\n        for j in range(n):\\n            recurse(0,j,0,n,ans)\\n        return ans`\\n"
                    },
                    {
                        "username": "Deetav",
                        "content": "`Line 1034: Char 34: runtime error: addition of unsigned offset to 0x6020000001b0 overflowed to 0x6020000001ac (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34`\\n\\nwhere do i find line 1034, my code has only 26 lines :("
                    },
                    {
                        "username": "gabhinav",
                        "content": "maybe you are trying to access something like dp[-1][1] as or you have defined max size of dp like dp[max] but you are trying to access dp[max+1] which has lead to overflow."
                    },
                    {
                        "username": "karthikmurakonda",
                        "content": "you can keep some thing like cout << \"ok\" in one line and keep running and change the position of cout line . at a point you cann't see ok is printed there you have the problem"
                    },
                    {
                        "username": "ritz-gupta",
                        "content": "That maybe because of the access of undefined memory. Maybe the code is accessing the outside of the matrix. Its the error message when you miss the out of bounds check condition."
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "Because your solution is wrapped by some code you do not have access. LC uses this wrapper to make their job easier i think. In this case the failure trace is not helpful for sure, but from your trace message it means some addition has overflowed and you should start by checking additions in your code"
                    }
                ]
            }
        ]
    },
    {
        "title": "Largest Multiple of Three",
        "question_content": "<p>Given an array of digits <code>digits</code>, return <em>the largest multiple of <strong>three</strong> that can be formed by concatenating some of the given digits in <strong>any order</strong></em>. If there is no answer return an empty string.</p>\n\n<p>Since the answer may not fit in an integer data type, return the answer as a string. Note that the returning answer must not contain unnecessary leading zeros.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> digits = [8,1,9]\n<strong>Output:</strong> &quot;981&quot;\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> digits = [8,6,7,1,0]\n<strong>Output:</strong> &quot;8760&quot;\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> digits = [1]\n<strong>Output:</strong> &quot;&quot;\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= digits.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= digits[i] &lt;= 9</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 517628,
                "title": "python-basic-math",
                "content": "# **Basic Math**\\n 999....999 % 3 == 0\\n1000....000 % 3 == 1\\na000....000 % 3 == a % 3\\nabcdefghijk % 3 == (a+b+c+..+i+j+k) % 3\\n<br>\\n\\n# **Explanation**\\n0. Calculate the sum of digits `total = sum(A)`\\n1. If `total % 3 == 0`, we got it directly\\n2. If `total % 3 == 1` and we have one of 1,4,7 in A:\\n    we try to remove one digit of 1,4,7\\n3. If `total % 3 == 2` and we have one of 2,5,8 in A:\\n    we try to remove one digit of 2,5,8\\n4. If `total % 3 == 2`:\\n    we try to remove two digits of 1,4,7\\n5. If `total % 3 == 1`:\\n    we try to remove two digits of 2,5,8\\n6. Submit\\n<br>\\n\\n# **Complexity**\\nTime `O(nlogn)`, where I use quick sort.\\nWe can also apply counting sort, so it will be `O(n)`\\nSpace `O(sort)`\\n<br>\\n\\n# Solution 1\\n**Python:**\\n```py\\n    def largestMultipleOfThree(self, A):\\n        total = sum(A)\\n        count = collections.Counter(A)\\n        A.sort(reverse=1)\\n\\n        def f(i):\\n            if count[i]:\\n                A.remove(i)\\n                count[i] -= 1\\n            if not A: return \\'\\'\\n            if not any(A): return \\'0\\'\\n            if sum(A) % 3 == 0: return \\'\\'.join(map(str, A))\\n\\n        if total % 3 == 0:\\n            return f(-1)\\n        if total % 3 == 1 and count[1] + count[4] + count[7]:\\n            return f(1) or f(4) or f(7)\\n        if total % 3 == 2 and count[2] + count[5] + count[8]:\\n            return f(2) or f(5) or f(8)\\n        if total % 3 == 2:\\n            return f(1) or f(1) or f(4) or f(4) or f(7) or f(7)\\n        return f(2) or f(2) or f(5) or f(5) or f(8) or f(8)\\n```\\n<br>\\n\\n# Solution 2: DP\\ninspired by @Aimar88\\n```py\\n    def largestMultipleOfThree(self, digits):\\n        dp = [-1,-1,-1]\\n        for a in sorted(digits)[::-1]:\\n            for x in dp[:] + [0]:\\n                y = x * 10 + a\\n                dp[y % 3] = max(dp[y % 3], y)\\n        return str(dp[0]) if dp[0] >= 0 else \"\"\\n```",
                "solutionTags": [],
                "code": "```py\\n    def largestMultipleOfThree(self, A):\\n        total = sum(A)\\n        count = collections.Counter(A)\\n        A.sort(reverse=1)\\n\\n        def f(i):\\n            if count[i]:\\n                A.remove(i)\\n                count[i] -= 1\\n            if not A: return \\'\\'\\n            if not any(A): return \\'0\\'\\n            if sum(A) % 3 == 0: return \\'\\'.join(map(str, A))\\n\\n        if total % 3 == 0:\\n            return f(-1)\\n        if total % 3 == 1 and count[1] + count[4] + count[7]:\\n            return f(1) or f(4) or f(7)\\n        if total % 3 == 2 and count[2] + count[5] + count[8]:\\n            return f(2) or f(5) or f(8)\\n        if total % 3 == 2:\\n            return f(1) or f(1) or f(4) or f(4) or f(7) or f(7)\\n        return f(2) or f(2) or f(5) or f(5) or f(8) or f(8)\\n```\n```py\\n    def largestMultipleOfThree(self, digits):\\n        dp = [-1,-1,-1]\\n        for a in sorted(digits)[::-1]:\\n            for x in dp[:] + [0]:\\n                y = x * 10 + a\\n                dp[y % 3] = max(dp[y % 3], y)\\n        return str(dp[0]) if dp[0] >= 0 else \"\"\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 518830,
                "title": "c-java-concise-o-n",
                "content": "Obviously, trying combinations of numbers won\\'t work as we can have up to 10,000 numbers. Luckily, there is a handy divisibility test:\\n> A number is divisible by 3 if the sum of all its digits is divisible by 3.\\n\\nObservation 1: since the order does not matter, the largest number can be formed by adding digits from largest (`9`) to smallest (`0`), e.g. `9999966330000`.\\n\\nTherefore, we can just count the occurrences of each digit, and then generate the string.\\n\\nObservation 2:  we need to use all digits to form the maximum number. If we sum all digits, and the modulo of 3 is not zero, we need to remove 1 (preferably) or 2 smallest digits.  If modulo 3 of the sum is `1`, for example, we will try to remove `1`, `4`, or `7`, if exists, or two of `2`, `5`, or `8`.\\n\\nMore examples: \\n- `9965341 % 3 == 1`; we remove `1` to get the largest number. \\n- `9952000 % 3 == 1`; now we need to remove two digits, `2` and `5`, as there is no `1`, `4`, or `7`.\\n\\nThese observations yield the following algorithm.\\n\\n**C++**\\n```cpp\\nstring largestMultipleOfThree(vector<int>& digits, string res = \"\") {\\n  int m1[] = {1, 4, 7, 2, 5, 8}, m2[] = {2, 5, 8, 1, 4, 7};\\n  int sum = 0, ds[10] = {};  \\n  for (auto d : digits) {\\n      ++ds[d];\\n      sum += d;\\n  }\\n  while (sum % 3 != 0) {\\n    for (auto i : sum % 3 == 1 ? m1 : m2) {\\n      if (ds[i]) {\\n        --ds[i];\\n        sum -= i;\\n        break;\\n      }\\n    }\\n  }\\n  for (int i = 9; i >= 0; --i)\\n    res += string(ds[i], \\'0\\' + i);\\n  return res.size() && res[0] == \\'0\\' ? \"0\" : res;\\n}\\n```\\n**Java**\\n```java\\npublic String largestMultipleOfThree(int[] digits) {\\n    int m1[] = new int[] {1, 4, 7, 2, 5, 8}, m2[] = new int[] {2, 5, 8, 1, 4, 7};\\n    int sum = 0, ds[] = new int[10];\\n    for (int d : digits) {\\n        ++ds[d];\\n        sum += d;\\n    }\\n    while (sum % 3 != 0) {\\n        for (int i : sum % 3 == 1 ? m1 : m2) {\\n          if (ds[i] > 0) {\\n            --ds[i];\\n            sum -= i;\\n            break;\\n          }\\n        }\\n      }\\n    StringBuilder sb = new StringBuilder();\\n    for (int i = 9; i >= 0; --i)\\n        sb.append(Character.toString(\\'0\\' + i).repeat(ds[i]));     \\n    return sb.length() > 0 && sb.charAt(0) == \\'0\\' ? \"0\" : sb.toString();\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nstring largestMultipleOfThree(vector<int>& digits, string res = \"\") {\\n  int m1[] = {1, 4, 7, 2, 5, 8}, m2[] = {2, 5, 8, 1, 4, 7};\\n  int sum = 0, ds[10] = {};  \\n  for (auto d : digits) {\\n      ++ds[d];\\n      sum += d;\\n  }\\n  while (sum % 3 != 0) {\\n    for (auto i : sum % 3 == 1 ? m1 : m2) {\\n      if (ds[i]) {\\n        --ds[i];\\n        sum -= i;\\n        break;\\n      }\\n    }\\n  }\\n  for (int i = 9; i >= 0; --i)\\n    res += string(ds[i], \\'0\\' + i);\\n  return res.size() && res[0] == \\'0\\' ? \"0\" : res;\\n}\\n```\n```java\\npublic String largestMultipleOfThree(int[] digits) {\\n    int m1[] = new int[] {1, 4, 7, 2, 5, 8}, m2[] = new int[] {2, 5, 8, 1, 4, 7};\\n    int sum = 0, ds[] = new int[10];\\n    for (int d : digits) {\\n        ++ds[d];\\n        sum += d;\\n    }\\n    while (sum % 3 != 0) {\\n        for (int i : sum % 3 == 1 ? m1 : m2) {\\n          if (ds[i] > 0) {\\n            --ds[i];\\n            sum -= i;\\n            break;\\n          }\\n        }\\n      }\\n    StringBuilder sb = new StringBuilder();\\n    for (int i = 9; i >= 0; --i)\\n        sb.append(Character.toString(\\'0\\' + i).repeat(ds[i]));     \\n    return sb.length() > 0 && sb.charAt(0) == \\'0\\' ? \"0\" : sb.toString();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 517704,
                "title": "java-basic-multiple-of-3-clean-code-o-n-2ms",
                "content": "**Idea**\\nThe number is multiple of 3 if and only if the sum of all digits is a multiple of 3\\nOur goal is to **find the maximum number of digits whose sum is a multiple of 3**.\\n\\nThree cases arise:\\n- The sum of digits produces remainder 1 when divided by 3\\nDelete 1 smallest digit with the remainder = 1 or Delete 2 smallest digits with the remainder = 2 \\n=> Then return the maximum result\\n- The sum of digits produces remainder 2 when divided by 3\\nDelete 1 smallest digit with the remainder = 2 or Delete 2 smallest digits with the remainder = 1 \\n=> Then return the maximum result\\n- The sum of digits is divisible by 3: \\n=> Return the maximum result\\n\\n**Solution 1: Straight Forward ~ 9ms**\\n```java\\nclass Solution {\\n    public String largestMultipleOfThree(int[] digits) {\\n        Arrays.sort(digits);\\n        List<Integer> remain1Indices = new ArrayList<>(2); // Indices of up to 2 elements with remainder = 1\\n        List<Integer> remain2Indices = new ArrayList<>(2); // Indices of up to 2 elements with remainder = 2\\n        for (int i = 0; i < digits.length; i++) {\\n            if (digits[i] % 3 == 1 && remain1Indices.size() < 2) remain1Indices.add(i);\\n            else if (digits[i] % 3 == 2 && remain2Indices.size() < 2) remain2Indices.add(i);\\n        }\\n        int remainSum = Arrays.stream(digits).sum() % 3;\\n        if (remainSum == 1) { // Delete 1 smallest digit with remainder = 1 or Delete 2 smallest digits the remainder = 2\\n            if (remain1Indices.size() >= 1) return getResult(digits, remain1Indices.get(0), -1);\\n            else return getResult(digits, remain2Indices.get(0), remain2Indices.get(1));\\n        } else if (remainSum == 2) { // Delete 1 smallest digit with remainder = 2 or Delete 2 smallest digits with remainder = 1\\n            if (remain2Indices.size() >= 1) return getResult(digits, remain2Indices.get(0), -1);\\n            else return getResult(digits, remain1Indices.get(0), remain1Indices.get(1));\\n        }\\n        return getResult(digits, -1, -1);\\n    }\\n    private String getResult(int[] digits, int ban1, int ban2) {\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = digits.length - 1; i >= 0; i--) {\\n            if (i == ban1 || i == ban2) continue; // Skip banned digits\\n            sb.append(digits[i]);\\n        }\\n        if (sb.length() > 0 && sb.charAt(0) == \\'0\\') return \"0\"; // Remove leading 0 case [0,...,0]\\n        return sb.toString();\\n    }\\n}\\n```\\nComplexity:\\n- Time: `O(NlogN)` for Arrays.sort(digits)\\n- Space: `O(1)`\\n\\n**Solution 2: Counting Sort Optimized ~ 2ms**\\n```java\\nclass Solution {\\n    public String largestMultipleOfThree(int[] digits) {\\n        int[] cnt = new int[10];\\n        for (int d : digits) cnt[d]++;\\n        int remain1Cnt = cnt[1] + cnt[4] + cnt[7]; // Number of elements with remainder = 1\\n        int remain2Cnt = cnt[2] + cnt[5] + cnt[8]; // Number of elements with remainder = 2\\n        int remainSum = (remain1Cnt + 2 * remain2Cnt) % 3;\\n        if (remainSum == 1) { // Delete 1 smallest digit with remainder = 1 or Delete 2 smallest digits with remainder = 2\\n            if (remain1Cnt >= 1) remain1Cnt -= 1;\\n            else remain2Cnt -= 2;\\n        } else if (remainSum == 2) { // Delete 1 smallest digit with remainder = 2 or Delete 2 smallest digits with remainder = 1\\n            if (remain2Cnt >= 1) remain2Cnt -= 1;\\n            else remain1Cnt -= 2;\\n        }\\n\\n        StringBuilder sb = new StringBuilder();\\n        for (int d = 9; d >= 0; d--) {\\n            if (d % 3 == 0) while (cnt[d]-- > 0) sb.append(d);\\n            else if (d % 3 == 1) while (cnt[d]-- > 0 && remain1Cnt-- > 0) sb.append(d);\\n            else while (cnt[d]-- > 0 && remain2Cnt-- > 0) sb.append(d);\\n        }\\n        if (sb.length() > 0 && sb.charAt(0) == \\'0\\') return \"0\"; // Remove leading 0 case [0,...,0]\\n        return sb.toString();\\n    }\\n}\\n```\\nComplexity:\\n- Time: `O(N)`\\n- Space: `O(1)`",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public String largestMultipleOfThree(int[] digits) {\\n        Arrays.sort(digits);\\n        List<Integer> remain1Indices = new ArrayList<>(2); // Indices of up to 2 elements with remainder = 1\\n        List<Integer> remain2Indices = new ArrayList<>(2); // Indices of up to 2 elements with remainder = 2\\n        for (int i = 0; i < digits.length; i++) {\\n            if (digits[i] % 3 == 1 && remain1Indices.size() < 2) remain1Indices.add(i);\\n            else if (digits[i] % 3 == 2 && remain2Indices.size() < 2) remain2Indices.add(i);\\n        }\\n        int remainSum = Arrays.stream(digits).sum() % 3;\\n        if (remainSum == 1) { // Delete 1 smallest digit with remainder = 1 or Delete 2 smallest digits the remainder = 2\\n            if (remain1Indices.size() >= 1) return getResult(digits, remain1Indices.get(0), -1);\\n            else return getResult(digits, remain2Indices.get(0), remain2Indices.get(1));\\n        } else if (remainSum == 2) { // Delete 1 smallest digit with remainder = 2 or Delete 2 smallest digits with remainder = 1\\n            if (remain2Indices.size() >= 1) return getResult(digits, remain2Indices.get(0), -1);\\n            else return getResult(digits, remain1Indices.get(0), remain1Indices.get(1));\\n        }\\n        return getResult(digits, -1, -1);\\n    }\\n    private String getResult(int[] digits, int ban1, int ban2) {\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = digits.length - 1; i >= 0; i--) {\\n            if (i == ban1 || i == ban2) continue; // Skip banned digits\\n            sb.append(digits[i]);\\n        }\\n        if (sb.length() > 0 && sb.charAt(0) == \\'0\\') return \"0\"; // Remove leading 0 case [0,...,0]\\n        return sb.toString();\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public String largestMultipleOfThree(int[] digits) {\\n        int[] cnt = new int[10];\\n        for (int d : digits) cnt[d]++;\\n        int remain1Cnt = cnt[1] + cnt[4] + cnt[7]; // Number of elements with remainder = 1\\n        int remain2Cnt = cnt[2] + cnt[5] + cnt[8]; // Number of elements with remainder = 2\\n        int remainSum = (remain1Cnt + 2 * remain2Cnt) % 3;\\n        if (remainSum == 1) { // Delete 1 smallest digit with remainder = 1 or Delete 2 smallest digits with remainder = 2\\n            if (remain1Cnt >= 1) remain1Cnt -= 1;\\n            else remain2Cnt -= 2;\\n        } else if (remainSum == 2) { // Delete 1 smallest digit with remainder = 2 or Delete 2 smallest digits with remainder = 1\\n            if (remain2Cnt >= 1) remain2Cnt -= 1;\\n            else remain1Cnt -= 2;\\n        }\\n\\n        StringBuilder sb = new StringBuilder();\\n        for (int d = 9; d >= 0; d--) {\\n            if (d % 3 == 0) while (cnt[d]-- > 0) sb.append(d);\\n            else if (d % 3 == 1) while (cnt[d]-- > 0 && remain1Cnt-- > 0) sb.append(d);\\n            else while (cnt[d]-- > 0 && remain2Cnt-- > 0) sb.append(d);\\n        }\\n        if (sb.length() > 0 && sb.charAt(0) == \\'0\\') return \"0\"; // Remove leading 0 case [0,...,0]\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 517745,
                "title": "elegant-python-solution",
                "content": "We need to maintain as many numbers as possible.\\n```\\nclass Solution:\\n    def largestMultipleOfThree(self, d: List[int]) -> str:\\n        d1 = sorted([i for i in d if i%3 ==1])\\n        d2 = sorted([i for i in d if i%3 ==2])\\n        d3 = [i for i in d if i%3 ==0]\\n        if sum(d) % 3 == 1:\\n            if len(d1) != 0:\\n                res = d1[1:] + d2 + d3\\n            else:\\n                res = d2[2:]+ d3\\n        elif sum(d) % 3 == 2:\\n            if len(d2) != 0:\\n                res = d1 + d2[1:] + d3\\n            else:\\n                res = d1[2:] +d3\\n        else:\\n            res = d\\n        res.sort(reverse = True)\\n        if not res: return \\'\\'\\n        return str(int(\\'\\'.join([str(i) for i in res])))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def largestMultipleOfThree(self, d: List[int]) -> str:\\n        d1 = sorted([i for i in d if i%3 ==1])\\n        d2 = sorted([i for i in d if i%3 ==2])\\n        d3 = [i for i in d if i%3 ==0]\\n        if sum(d) % 3 == 1:\\n            if len(d1) != 0:\\n                res = d1[1:] + d2 + d3\\n            else:\\n                res = d2[2:]+ d3\\n        elif sum(d) % 3 == 2:\\n            if len(d2) != 0:\\n                res = d1 + d2[1:] + d3\\n            else:\\n                res = d1[2:] +d3\\n        else:\\n            res = d\\n        res.sort(reverse = True)\\n        if not res: return \\'\\'\\n        return str(int(\\'\\'.join([str(i) for i in res])))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 517570,
                "title": "python-o-n-simple-bucket-sort-with-explanation",
                "content": "**Idea**\\nAccording to the **3 divisibility rule** (proof: https://math.stackexchange.com/questions/341202/how-to-prove-the-divisibility-rule-for-3-casting-out-threes).\\nOur goal is to find **the maximum number of digits whose sum is a multiple of 3**.\\n\\nWe categorize all the input digits into 3 category. \\n- `{0, 3, 9}`: these digits should be accepted into our candidates no matter what\\n- `{1, 4, 7}`: **category 1**, these digits can only be accepted into out candidates **3 in a group**, or together with 1 element from **category 2**\\n- `{2, 5, 8}`: **category 2**, these digits can only be accepted into out candidates **3 in a group**, or together with 1 element from **category 1**\\n\\nEdge case: `[1,1,1,2,2]` and `[1,1,1,2]`. We need to distinguish these 2 edge cases.\\n- in cases like `[1,1,1,2]`\\n    - we need to take from **category 1** and **category 2** 3 elements in a group first\\n- in cases like `[1,1,1,2,2]`\\n    - we need to take 1 element from both **category 1** and **category 2** first\\n\\n**Complexity**\\nTIme: `O(n)` using bucket sort\\nSpace: `O(n)`\\n\\n**Python 3, Bucket Sort, O(n) in time and space, more readable but longer**\\n```\\nclass Solution:\\n    def largestMultipleOfThree(self, digits: List[int]) -> str:\\n        def bucket_sorted(arr):\\n            c = collections.Counter(arr)\\n            return [x for i in range(10) if i in c for x in [i]*c[i]]\\n        \\n        d = collections.defaultdict(list)\\n        for n in digits:\\n            d[n%3] += n,\\n        res, short, long = d[0], *sorted((d[1], d[2]), key=len)\\n        short, long = bucket_sorted(short), bucket_sorted(long)\\n        \\n        if (len(long) - len(short)) % 3 > abs((len(long) % 3) - (len(short) % 3)):\\n            short, long = (short, long) if len(short)%3 < len(long)%3 else (long, short)\\n            res += short + long[abs(len(short)%3 - len(long)%3):]\\n        else:\\n            res += short + long[(len(long)-len(short))%3:]\\n            \\n        res = bucket_sorted(res)[::-1]\\n        return \\'0\\' if res and not res[0] else \\'\\'.join(map(str, res))\\n```\\n\\n**Python 3, using reduce and default sort, O(nlogn)**\\n```\\nfrom functools import reduce\\nclass Solution:\\n    def largestMultipleOfThree(self, digits: List[int]) -> str:        \\n        d, _ = reduce(lambda pair,y:(pair[0],pair[0][y%3].append(y)), digits, (collections.defaultdict(list), None))\\n        res, short, long = d[0], *sorted([sorted(arr) for arr in (d[1], d[2])], key=len)\\n        \\n        if (len(long) - len(short)) % 3 > abs((len(long) % 3) - (len(short) % 3)):\\n            short, long = (short, long) if len(short)%3 < len(long)%3 else (long, short)\\n            res += short + long[abs(len(short)%3 - len(long)%3):]\\n        else:\\n            res += short + long[(len(long)-len(short))%3:]\\n            \\n        res = res.sort(reverse=True)\\n        return \\'0\\' if res and not res[0] else \\'\\'.join(map(str, res))\\n```",
                "solutionTags": [
                    "Python3",
                    "Bucket Sort"
                ],
                "code": "```\\nclass Solution:\\n    def largestMultipleOfThree(self, digits: List[int]) -> str:\\n        def bucket_sorted(arr):\\n            c = collections.Counter(arr)\\n            return [x for i in range(10) if i in c for x in [i]*c[i]]\\n        \\n        d = collections.defaultdict(list)\\n        for n in digits:\\n            d[n%3] += n,\\n        res, short, long = d[0], *sorted((d[1], d[2]), key=len)\\n        short, long = bucket_sorted(short), bucket_sorted(long)\\n        \\n        if (len(long) - len(short)) % 3 > abs((len(long) % 3) - (len(short) % 3)):\\n            short, long = (short, long) if len(short)%3 < len(long)%3 else (long, short)\\n            res += short + long[abs(len(short)%3 - len(long)%3):]\\n        else:\\n            res += short + long[(len(long)-len(short))%3:]\\n            \\n        res = bucket_sorted(res)[::-1]\\n        return \\'0\\' if res and not res[0] else \\'\\'.join(map(str, res))\\n```\n```\\nfrom functools import reduce\\nclass Solution:\\n    def largestMultipleOfThree(self, digits: List[int]) -> str:        \\n        d, _ = reduce(lambda pair,y:(pair[0],pair[0][y%3].append(y)), digits, (collections.defaultdict(list), None))\\n        res, short, long = d[0], *sorted([sorted(arr) for arr in (d[1], d[2])], key=len)\\n        \\n        if (len(long) - len(short)) % 3 > abs((len(long) % 3) - (len(short) % 3)):\\n            short, long = (short, long) if len(short)%3 < len(long)%3 else (long, short)\\n            res += short + long[abs(len(short)%3 - len(long)%3):]\\n        else:\\n            res += short + long[(len(long)-len(short))%3:]\\n            \\n        res = res.sort(reverse=True)\\n        return \\'0\\' if res and not res[0] else \\'\\'.join(map(str, res))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 532860,
                "title": "simple-solution-with-brief-explanation-time-o-n-space-o-10-constant",
                "content": "**Steps:**\\n1. Divisibility rule of 3: Sum of digits of the numbers should be divisible by 3.\\n2. Calculate the total sum of all the given digits.\\n3. Calculate the remainder of the total sum when divided by 3.\\n4. If it is 0, we do not need to do anything, otherwise, the remainder could be 1 or 2.\\n5. If the remainder is 1 we need to find the smallest digit which gives the remainder 1 and remove it. Same for remainder 2.\\n6. In the end, when we have removed the smallest digit which is present and which can help settle the remainder difference when removed. We can create the largest number which is a multiple of 3.\\n7. It will obviously be the concatination of all the present digits in decreasing order which will give the largest number. Return it. \\n\\n**Code:**\\n```\\nstring largestMultipleOfThree(vector<int>& digits) {\\n        int n = digits.size();\\n        int d[10] = {};\\n        int rem1[] =  {1, 4, 7, 2, 5, 8}, rem2[] = {2, 5, 8, 1, 4, 7};\\n        int sum = 0;\\n        \\n        for(int i=0; i<n; i++){\\n            ++d[digits[i]];\\n            sum += digits[i];\\n        }\\n        \\n        while(sum % 3 != 0){\\n            for(int i=0; i<6; i++){\\n                if(sum % 3 == 1 && d[rem1[i]]) {\\n                    sum -= rem1[i];\\n                    d[rem1[i]]--;\\n                    break;\\n                }\\n                else if(sum % 3 == 2 && d[rem2[i]]){\\n                    sum -= rem2[i];\\n                    d[rem2[i]]--;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        string ans = \"\";\\n        \\n        for(int i=9; i>=0; i--) {\\n            for(int j=1; j<=d[i]; j++)\\n                ans += to_string(i);\\n        }\\n        return ans[0]==\\'0\\'?\"0\":ans;\\n    }\\n```\\n\\n**References:**\\n* https://en.wikipedia.org/wiki/Divisibility_rule#Divisibility_by_3_or_9\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nstring largestMultipleOfThree(vector<int>& digits) {\\n        int n = digits.size();\\n        int d[10] = {};\\n        int rem1[] =  {1, 4, 7, 2, 5, 8}, rem2[] = {2, 5, 8, 1, 4, 7};\\n        int sum = 0;\\n        \\n        for(int i=0; i<n; i++){\\n            ++d[digits[i]];\\n            sum += digits[i];\\n        }\\n        \\n        while(sum % 3 != 0){\\n            for(int i=0; i<6; i++){\\n                if(sum % 3 == 1 && d[rem1[i]]) {\\n                    sum -= rem1[i];\\n                    d[rem1[i]]--;\\n                    break;\\n                }\\n                else if(sum % 3 == 2 && d[rem2[i]]){\\n                    sum -= rem2[i];\\n                    d[rem2[i]]--;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        string ans = \"\";\\n        \\n        for(int i=9; i>=0; i--) {\\n            for(int j=1; j<=d[i]; j++)\\n                ans += to_string(i);\\n        }\\n        return ans[0]==\\'0\\'?\"0\":ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 517674,
                "title": "java-o-n",
                "content": "The idea is similar to 1262. Greatest Sum Divisible by Three https://leetcode.com/problems/greatest-sum-divisible-by-three/\\n\\n```\\nclass Solution {\\n    public String largestMultipleOfThree(int[] digits) {\\n        int[] count = new int[10];\\n        for (int d : digits) count[d]++;\\n        int two = count[2] + count[5] + count[8], one = count[1] + count[4] + count[7];\\n        if ((two * 2 + one) % 3 == 1) {\\n            if (one > 0) --one;\\n            else two -= 2;\\n        } else if ((two * 2 + one) % 3 == 2) {\\n            if (two > 0) --two;\\n            else one -= 2;\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 9; i > 0; --i) {\\n            if (i % 3 == 0) while (count[i]-- > 0) sb.append(i);\\n            else if (i % 3 == 1) while (count[i]-- > 0 && one-- > 0) sb.append(i);\\n            else while (count[i]-- > 0 && two-- > 0) sb.append(i);\\n        }\\n        if (sb.length() == 0) return count[0] > 0 ? \"0\" : \"\";\\n        while (count[0]-- > 0) sb.append(0);\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String largestMultipleOfThree(int[] digits) {\\n        int[] count = new int[10];\\n        for (int d : digits) count[d]++;\\n        int two = count[2] + count[5] + count[8], one = count[1] + count[4] + count[7];\\n        if ((two * 2 + one) % 3 == 1) {\\n            if (one > 0) --one;\\n            else two -= 2;\\n        } else if ((two * 2 + one) % 3 == 2) {\\n            if (two > 0) --two;\\n            else one -= 2;\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 9; i > 0; --i) {\\n            if (i % 3 == 0) while (count[i]-- > 0) sb.append(i);\\n            else if (i % 3 == 1) while (count[i]-- > 0 && one-- > 0) sb.append(i);\\n            else while (count[i]-- > 0 && two-- > 0) sb.append(i);\\n        }\\n        if (sb.length() == 0) return count[0] > 0 ? \"0\" : \"\";\\n        while (count[0]-- > 0) sb.append(0);\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 692837,
                "title": "java-beats-98-solutions-with-easy-to-understand-comments-no-sorting",
                "content": "```\\nclass Solution {\\n    public String largestMultipleOfThree(int[] digits) {\\n        /**\\n         * Important notes:\\n         * 1. If the individual numbers added up are divisible by 3, so is the overall number\\n         * 2. Any num mod 3 that results in 0 is always wanted in our solution from largest to smallest\\n         * E.g. 9 will be at the front and 0 will be at the end of the number\\n         * Sorting makes solution easier but is O(nlogn)\\n         * 3. Since the digits will be 0-9 we can initialize arrays with indices 0-9 to store numbers\\n         */\\n\\n        //If array only has one number, we can check it immediately\\n        if(digits.length == 1){\\n            if(digits[0] % 3 == 0){\\n                return Integer.toString(digits[0]);\\n            }\\n            else{\\n                return \"\";\\n            }\\n        }\\n        //create a remainder of Sum based on important notes 1(sum of Array % 3)\\n        int remainderOfSum = 0;\\n        //Important notes 3 array\\n        int[] counter = new int[10];\\n\\n        //loop through each int in array l and increment counter[i] when we find value i\\n        for(int i: digits){\\n            counter[i]++;\\n            remainderOfSum = remainderOfSum + i;\\n        }\\n        //Create counters for how many number % 3 remainders = 1 and 2\\n        int remainderOf1 = counter[1] + counter[4] + counter[7];\\n        int remainderOf2 = counter[2] + counter[5] + counter[8];\\n\\n        remainderOfSum = remainderOfSum % 3;\\n        /**\\n         * Cases:\\n         * 1: remainderOfSum is 0 -> nothing needs to be done\\n         * 2: remainderOfSum is 1, need to remove smallest digit that gives remainderOf1\\n         * 2(cont.): if we can\\'t remove single digit then we remove 2 that give remainderOf2\\n         * 3: remainderOfSum is 2, need to remove smallest digit that gives remainderOf2\\n         * 3(cont.): if we can\\'t remove single digit then we remove 2 that give remainderOf1\\n         */\\n        if(remainderOfSum == 1){\\n            if(remainderOf1 > 0){\\n                remainderOf1--;\\n            }\\n            else{\\n                remainderOf2 = remainderOf2 - 2;\\n            }\\n        }\\n        if(remainderOfSum == 2){\\n            if(remainderOf2 > 0){\\n                remainderOf2--;\\n            }\\n            else{\\n                remainderOf1 = remainderOf1 - 2;\\n            }\\n        }\\n        //Now that we know how many of each remainder we\\'re allowed to use we can build the number\\n        //Since we want 9+0 to equal 90 let\\'s build a string of nums then return it as an int\\n        StringBuilder sb = new StringBuilder();\\n\\n        /**\\n         * Since we want the larger numbers first and the digits can only be 0-9 loop from 9 to 0\\n         * Append every value that\\'s allowed based on the remainder counters and that we have\\n         * based the counter array that holds how many of each value we have\\n         */\\n        for(int i = 9; i >= 0; i--){\\n            if(i % 3 == 0){\\n                while(counter[i] > 0){\\n                    sb.append(i);\\n                    counter[i]--;\\n                }\\n            }\\n            if(i % 3 == 1){\\n                while(counter[i] > 0 && remainderOf1 > 0){\\n                    sb.append(i);\\n                    counter[i]--;\\n                    remainderOf1--;\\n                }\\n            }\\n            if(i % 3 == 2){\\n                while(counter[i] > 0 && remainderOf2 > 0){\\n                    sb.append(i);\\n                    counter[i]--;\\n                    remainderOf2--;\\n                }\\n            }\\n        }//end for loop\\n\\n        //If stringbuilder is empty or starts with 0 return 0\\n        //Else return stringbuilder is an integer\\n        if(sb.length() == 0){\\n            return \"\";\\n        }\\n        else{\\n            if(sb.charAt(0) == \\'0\\'){\\n                return \"0\";\\n            }\\n            else{\\n                return sb.toString();\\n            }\\n\\n        }\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String largestMultipleOfThree(int[] digits) {\\n        /**\\n         * Important notes:\\n         * 1. If the individual numbers added up are divisible by 3, so is the overall number\\n         * 2. Any num mod 3 that results in 0 is always wanted in our solution from largest to smallest\\n         * E.g. 9 will be at the front and 0 will be at the end of the number\\n         * Sorting makes solution easier but is O(nlogn)\\n         * 3. Since the digits will be 0-9 we can initialize arrays with indices 0-9 to store numbers\\n         */\\n\\n        //If array only has one number, we can check it immediately\\n        if(digits.length == 1){\\n            if(digits[0] % 3 == 0){\\n                return Integer.toString(digits[0]);\\n            }\\n            else{\\n                return \"\";\\n            }\\n        }\\n        //create a remainder of Sum based on important notes 1(sum of Array % 3)\\n        int remainderOfSum = 0;\\n        //Important notes 3 array\\n        int[] counter = new int[10];\\n\\n        //loop through each int in array l and increment counter[i] when we find value i\\n        for(int i: digits){\\n            counter[i]++;\\n            remainderOfSum = remainderOfSum + i;\\n        }\\n        //Create counters for how many number % 3 remainders = 1 and 2\\n        int remainderOf1 = counter[1] + counter[4] + counter[7];\\n        int remainderOf2 = counter[2] + counter[5] + counter[8];\\n\\n        remainderOfSum = remainderOfSum % 3;\\n        /**\\n         * Cases:\\n         * 1: remainderOfSum is 0 -> nothing needs to be done\\n         * 2: remainderOfSum is 1, need to remove smallest digit that gives remainderOf1\\n         * 2(cont.): if we can\\'t remove single digit then we remove 2 that give remainderOf2\\n         * 3: remainderOfSum is 2, need to remove smallest digit that gives remainderOf2\\n         * 3(cont.): if we can\\'t remove single digit then we remove 2 that give remainderOf1\\n         */\\n        if(remainderOfSum == 1){\\n            if(remainderOf1 > 0){\\n                remainderOf1--;\\n            }\\n            else{\\n                remainderOf2 = remainderOf2 - 2;\\n            }\\n        }\\n        if(remainderOfSum == 2){\\n            if(remainderOf2 > 0){\\n                remainderOf2--;\\n            }\\n            else{\\n                remainderOf1 = remainderOf1 - 2;\\n            }\\n        }\\n        //Now that we know how many of each remainder we\\'re allowed to use we can build the number\\n        //Since we want 9+0 to equal 90 let\\'s build a string of nums then return it as an int\\n        StringBuilder sb = new StringBuilder();\\n\\n        /**\\n         * Since we want the larger numbers first and the digits can only be 0-9 loop from 9 to 0\\n         * Append every value that\\'s allowed based on the remainder counters and that we have\\n         * based the counter array that holds how many of each value we have\\n         */\\n        for(int i = 9; i >= 0; i--){\\n            if(i % 3 == 0){\\n                while(counter[i] > 0){\\n                    sb.append(i);\\n                    counter[i]--;\\n                }\\n            }\\n            if(i % 3 == 1){\\n                while(counter[i] > 0 && remainderOf1 > 0){\\n                    sb.append(i);\\n                    counter[i]--;\\n                    remainderOf1--;\\n                }\\n            }\\n            if(i % 3 == 2){\\n                while(counter[i] > 0 && remainderOf2 > 0){\\n                    sb.append(i);\\n                    counter[i]--;\\n                    remainderOf2--;\\n                }\\n            }\\n        }//end for loop\\n\\n        //If stringbuilder is empty or starts with 0 return 0\\n        //Else return stringbuilder is an integer\\n        if(sb.length() == 0){\\n            return \"\";\\n        }\\n        else{\\n            if(sb.charAt(0) == \\'0\\'){\\n                return \"0\";\\n            }\\n            else{\\n                return sb.toString();\\n            }\\n\\n        }\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1246826,
                "title": "easy-detail-comments-o-n-c",
                "content": "-> ans string has all digits in descending order\\n-> sum = sum of all digits\\n-> There are 3 possibilities\\n-> Case : sum % 3 == 0\\n       Then return string as it is\\n-> Case : sum % 3 == 1\\n       Remove smallest digit s.t digit % 3 == 1\\n       If such digit is not found then we have to find 2 smallest digits s.t digit % 3 == 2\\n       Else return \"\"\\n-> Case : sum % 3 == 2\\n       Remove smallest digit s.t digit % 3 == 2\\n       If such digit is not found then we have to find 2 smallest digits s.t digit % 3 == 1\\n       Else return \"\"\\n\\t \\n-> These are the only cases and its just implementation\\n-> I dont know why DP is written in related topics\\n\\n***Time Complexity : O(N)\\nSpace Complexity : O(N)***\\n\\n```\\nclass Solution {\\npublic:\\n    string largestMultipleOfThree(vector<int>& digits) \\n    {\\n        string ans;\\n        int sum = 0;\\n        vector<int> f(10, 0);\\n        for(int d : digits)\\n        {\\n            sum += d;\\n            f[d]++;\\n        }\\n        \\n        for(int i = 9; i >= 0; --i)\\n        {\\n            int cnt = f[i];\\n            while(cnt--)\\n                ans += to_string(i);\\n        }\\n        \\n        while(ans[0] == \\'0\\' && ans.size() > 1) // remove redundant 0s\\n            ans.erase(ans.begin());\\n        \\n        if(sum % 3 == 0)\\n            return ans;\\n        \\n        if(sum % 3 == 1)\\n        {\\n            string s = ans;\\n            for(int i = ans.size()-1; i >= 0; --i)\\n            {\\n                if((s[i]-\\'0\\') % 3 == 1)\\n                {\\n                    s.erase(i, 1);\\n                    return s;\\n                }\\n            }\\n            \\n            int i1 = -1, i2 = -1;\\n            for(int i = ans.size()-1; i >= 0; --i)\\n            {\\n                if(i1 == -1 && i2 == -1 && (s[i]-\\'0\\') % 3 == 2)\\n                    i1 = i;\\n                \\n                else if(i2 == -1 && i1 != -1 && (s[i]-\\'0\\') % 3 == 2)\\n                    i2 = i;\\n                \\n                else if(i1 != -1 && i2 != -1)\\n                    break;\\n            }\\n            \\n            if(i1 != -1 && i2 != -1)\\n            {\\n                s.erase(i1, 1);\\n                s.erase(i2, 1);\\n                return s;\\n            }\\n            return \"\";\\n        }\\n        \\n        if(sum % 3 == 2)\\n        {\\n            string s = ans;\\n            for(int i = ans.size()-1; i >= 0; --i)\\n            {\\n                if((ans[i]-\\'0\\') % 3 == 2)\\n                {\\n                    s.erase(i, 1);\\n                    return s;\\n                }\\n            }\\n            \\n            int i1 = -1, i2 = -1;\\n            for(int i = ans.size()-1; i >= 0; --i)\\n            {\\n                if(i1 == -1 && i2 == -1 && (ans[i]-\\'0\\') % 3 == 1)\\n                    i1 = i;\\n                \\n                else if(i2 == -1 && i1 != -1 && (ans[i]-\\'0\\') % 3 == 1)\\n                    i2 = i;\\n                \\n                else if(i1 != -1 && i2 != -1)\\n                    break;\\n            }\\n            \\n            if(i1 != -1 && i2 != -1)\\n            {\\n                s.erase(i1, 1);\\n                s.erase(i2, 1);\\n                return s;\\n            }\\n            return \"\";\\n        }\\n        return \"\";\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestMultipleOfThree(vector<int>& digits) \\n    {\\n        string ans;\\n        int sum = 0;\\n        vector<int> f(10, 0);\\n        for(int d : digits)\\n        {\\n            sum += d;\\n            f[d]++;\\n        }\\n        \\n        for(int i = 9; i >= 0; --i)\\n        {\\n            int cnt = f[i];\\n            while(cnt--)\\n                ans += to_string(i);\\n        }\\n        \\n        while(ans[0] == \\'0\\' && ans.size() > 1) // remove redundant 0s\\n            ans.erase(ans.begin());\\n        \\n        if(sum % 3 == 0)\\n            return ans;\\n        \\n        if(sum % 3 == 1)\\n        {\\n            string s = ans;\\n            for(int i = ans.size()-1; i >= 0; --i)\\n            {\\n                if((s[i]-\\'0\\') % 3 == 1)\\n                {\\n                    s.erase(i, 1);\\n                    return s;\\n                }\\n            }\\n            \\n            int i1 = -1, i2 = -1;\\n            for(int i = ans.size()-1; i >= 0; --i)\\n            {\\n                if(i1 == -1 && i2 == -1 && (s[i]-\\'0\\') % 3 == 2)\\n                    i1 = i;\\n                \\n                else if(i2 == -1 && i1 != -1 && (s[i]-\\'0\\') % 3 == 2)\\n                    i2 = i;\\n                \\n                else if(i1 != -1 && i2 != -1)\\n                    break;\\n            }\\n            \\n            if(i1 != -1 && i2 != -1)\\n            {\\n                s.erase(i1, 1);\\n                s.erase(i2, 1);\\n                return s;\\n            }\\n            return \"\";\\n        }\\n        \\n        if(sum % 3 == 2)\\n        {\\n            string s = ans;\\n            for(int i = ans.size()-1; i >= 0; --i)\\n            {\\n                if((ans[i]-\\'0\\') % 3 == 2)\\n                {\\n                    s.erase(i, 1);\\n                    return s;\\n                }\\n            }\\n            \\n            int i1 = -1, i2 = -1;\\n            for(int i = ans.size()-1; i >= 0; --i)\\n            {\\n                if(i1 == -1 && i2 == -1 && (ans[i]-\\'0\\') % 3 == 1)\\n                    i1 = i;\\n                \\n                else if(i2 == -1 && i1 != -1 && (ans[i]-\\'0\\') % 3 == 1)\\n                    i2 = i;\\n                \\n                else if(i1 != -1 && i2 != -1)\\n                    break;\\n            }\\n            \\n            if(i1 != -1 && i2 != -1)\\n            {\\n                s.erase(i1, 1);\\n                s.erase(i2, 1);\\n                return s;\\n            }\\n            return \"\";\\n        }\\n        return \"\";\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 522774,
                "title": "python3-solution",
                "content": "```\\nclass Solution:\\n    def largestMultipleOfThree(self, a: List[int]) -> str:\\n        \\n        a.sort(reverse=True)\\n        \\n        ones = [x for x in a if x % 3 == 1]\\n        twos = [x for x in a if x % 3 == 2]\\n        \\n        tot = sum(a)\\n        \\n        if tot % 3 == 1:\\n            if ones:\\n                a.remove(ones[-1])\\n            else:\\n                a.remove(twos[-1])\\n                a.remove(twos[-2])\\n        elif tot % 3 == 2:\\n            if twos:\\n                a.remove(twos[-1])\\n            else:\\n                a.remove(ones[-1])\\n                a.remove(ones[-2])\\n        \\n        if not a:\\n            return \"\"\\n        return \"\".join(map(str,a)).lstrip(\"0\") or \"0\"\\n            \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def largestMultipleOfThree(self, a: List[int]) -> str:\\n        \\n        a.sort(reverse=True)\\n        \\n        ones = [x for x in a if x % 3 == 1]\\n        twos = [x for x in a if x % 3 == 2]\\n        \\n        tot = sum(a)\\n        \\n        if tot % 3 == 1:\\n            if ones:\\n                a.remove(ones[-1])\\n            else:\\n                a.remove(twos[-1])\\n                a.remove(twos[-2])\\n        elif tot % 3 == 2:\\n            if twos:\\n                a.remove(twos[-1])\\n            else:\\n                a.remove(ones[-1])\\n                a.remove(ones[-2])\\n        \\n        if not a:\\n            return \"\"\\n        return \"\".join(map(str,a)).lstrip(\"0\") or \"0\"\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 518259,
                "title": "java-3-queues",
                "content": "```\\npublic String largestMultipleOfThree(int[] arr) {\\n        Arrays.sort(arr);\\n        /*\\n        Take three queues.\\n        queue0 for storing elements which on dividing by 3 gives remainder as 0.\\n        queue1 stores digits which on dividing by 3 gives remainder as 1.\\n        queue2 stores digits which on dividing by 3 gives remainder as 2.\\n         */\\n        Queue<Integer> queue0=new LinkedList<>();\\n        Queue<Integer> queue1=new LinkedList<>();\\n        Queue<Integer> queue2=new LinkedList<>();\\n        int sum=0;\\n        for (int a : arr) {\\n            sum += a;\\n            if (a % 3 == 0) {\\n                queue0.add(a);\\n            }\\n            else if (a % 3 == 1) {\\n                queue1.add(a);\\n            }\\n            else {\\n                queue2.add(a);\\n            }\\n        }\\n        if(sum==0) {\\n            return \"0\";\\n        }\\n        /*\\n        Sum of digits produces remainder 1 when divided by 3.\\n        Remove one item from queue1.\\n        If queue1 is empty, remove two items from queue2.\\n        If queue2 contains less than two items, the number is not possible.\\n         */\\n        if ((sum % 3) == 1) {\\n            if (!queue1.isEmpty()) {\\n                queue1.remove();\\n            }\\n            else {\\n                if (queue2.size() < 2) {\\n                    return \"\";\\n                }\\n                queue2.remove();\\n                queue2.remove();\\n\\n            }\\n        }\\n        /*\\n        Sum of digits produces remainder 2 when divided by 3.\\n        Remove one item from queue2.\\n        If queue2 is empty, remove two items from queue1.\\n        If queue1 contains less than two items, the number is not possible.\\n         */\\n        else if (sum % 3 == 2)\\n        {\\n            if (!queue2.isEmpty()) {\\n                queue2.remove();\\n            }\\n            else {\\n                if(queue1.size()<2) {\\n                    return \"\";\\n                }\\n                queue1.remove();\\n                queue1.remove();\\n            }\\n        }\\n\\n        int[] temp = new int[arr.length];\\n        int top= populate(temp,queue0,queue1,queue2);\\n        Arrays.sort(temp,0,top);\\n\\n        StringBuilder result = new StringBuilder();\\n        for (int i = top-1; i>=0; i--) {\\n            result.append(temp[i]);\\n        }\\n\\n        return result.toString();\\n\\n    }\\n\\n    private int populate(int[] temp, Queue<Integer> queue0, Queue<Integer> queue1, Queue<Integer> queue2) {\\n        int top=0;\\n        while(!queue0.isEmpty()) {\\n            temp[top++] = queue0.remove();\\n        }\\n        while(!queue1.isEmpty()) {\\n            temp[top++]=queue1.remove();\\n        }\\n        while(!queue2.isEmpty()) {\\n            temp[top++]=queue2.remove();\\n        }\\n        return top;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic String largestMultipleOfThree(int[] arr) {\\n        Arrays.sort(arr);\\n        /*\\n        Take three queues.\\n        queue0 for storing elements which on dividing by 3 gives remainder as 0.\\n        queue1 stores digits which on dividing by 3 gives remainder as 1.\\n        queue2 stores digits which on dividing by 3 gives remainder as 2.\\n         */\\n        Queue<Integer> queue0=new LinkedList<>();\\n        Queue<Integer> queue1=new LinkedList<>();\\n        Queue<Integer> queue2=new LinkedList<>();\\n        int sum=0;\\n        for (int a : arr) {\\n            sum += a;\\n            if (a % 3 == 0) {\\n                queue0.add(a);\\n            }\\n            else if (a % 3 == 1) {\\n                queue1.add(a);\\n            }\\n            else {\\n                queue2.add(a);\\n            }\\n        }\\n        if(sum==0) {\\n            return \"0\";\\n        }\\n        /*\\n        Sum of digits produces remainder 1 when divided by 3.\\n        Remove one item from queue1.\\n        If queue1 is empty, remove two items from queue2.\\n        If queue2 contains less than two items, the number is not possible.\\n         */\\n        if ((sum % 3) == 1) {\\n            if (!queue1.isEmpty()) {\\n                queue1.remove();\\n            }\\n            else {\\n                if (queue2.size() < 2) {\\n                    return \"\";\\n                }\\n                queue2.remove();\\n                queue2.remove();\\n\\n            }\\n        }\\n        /*\\n        Sum of digits produces remainder 2 when divided by 3.\\n        Remove one item from queue2.\\n        If queue2 is empty, remove two items from queue1.\\n        If queue1 contains less than two items, the number is not possible.\\n         */\\n        else if (sum % 3 == 2)\\n        {\\n            if (!queue2.isEmpty()) {\\n                queue2.remove();\\n            }\\n            else {\\n                if(queue1.size()<2) {\\n                    return \"\";\\n                }\\n                queue1.remove();\\n                queue1.remove();\\n            }\\n        }\\n\\n        int[] temp = new int[arr.length];\\n        int top= populate(temp,queue0,queue1,queue2);\\n        Arrays.sort(temp,0,top);\\n\\n        StringBuilder result = new StringBuilder();\\n        for (int i = top-1; i>=0; i--) {\\n            result.append(temp[i]);\\n        }\\n\\n        return result.toString();\\n\\n    }\\n\\n    private int populate(int[] temp, Queue<Integer> queue0, Queue<Integer> queue1, Queue<Integer> queue2) {\\n        int top=0;\\n        while(!queue0.isEmpty()) {\\n            temp[top++] = queue0.remove();\\n        }\\n        while(!queue1.isEmpty()) {\\n            temp[top++]=queue1.remove();\\n        }\\n        while(!queue2.isEmpty()) {\\n            temp[top++]=queue2.remove();\\n        }\\n        return top;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 517986,
                "title": "java-o-nlogn-sort-bottom-up-dp",
                "content": "**Explanation**\\nWe can first sort the input array so that we can pick up digits one by one to derive the answer.\\nThen we declare a dp array which dp[i] represents the largest number after appending the current digit and the sum of digits has the attribute: `sum % 3 == i`.\\nNow let\\'s do some case analysis:\\n1. current digit % 3 == 0: apparently we should append it to all candidates in the dp array\\n2. current digit % 3 != 0: we add the digit to each candidate and see if it results in a larger number than the number in the corresponding position of dp array.\\nWhen we compare two numbers, we simply compare their length based on the following reason:\\n1. the longer length, the larger number\\n2. If the length is the same, we need to know if current digit is larger than dp[j][0].\\nSince the digits array are sorted, it guarantees current digit >= dp[j][0].\\nIf current digit > dp[j][0], we\\'re done.\\nIf current digit == dp[j][0], it means d[i] and dp[j][1:] must belong to the same slot.\\nSo we know append current digit produces larger number if the new length is equal to or larger than the current one.\\n\\n```\\nclass Solution {\\n    public String largestMultipleOfThree(int[] digits) {\\n        Arrays.sort(digits);\\n        String[] dp = new String[]{\"\", \"\", \"\"};\\n        int[] len = new int[3];\\n        for (int d : digits) {\\n            if (0 == d % 3) {\\n                for (int i = 0; i < 3; ++i) dp[i] = d + dp[i];\\n                continue;\\n            }\\n            String[] dp2 = new String[]{dp[0], dp[1], dp[2]};\\n            int[] nextLen = new int[]{len[0], len[1], len[2]};\\n            for (int i = 0; i < 3; ++i) {\\n                int j = ((0 == len[i] ? 0 : i) + d) % 3;\\n                String cand = d + dp[i];\\n                if (nextLen[j] <= len[i] + 1){\\n                    nextLen[j] = len[i] + 1;\\n                    dp2[j] = cand;\\n                }\\n            }\\n            len = nextLen;\\n            dp = dp2;            \\n        }\\n        if (dp[0].isEmpty()) return \"\";\\n        int i = 0;\\n        for (char c : dp[0].toCharArray()) if (\\'0\\' == c) i++; else break;\\n        return i == dp[0].length() ? \"0\" : dp[0].substring(i);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public String largestMultipleOfThree(int[] digits) {\\n        Arrays.sort(digits);\\n        String[] dp = new String[]{\"\", \"\", \"\"};\\n        int[] len = new int[3];\\n        for (int d : digits) {\\n            if (0 == d % 3) {\\n                for (int i = 0; i < 3; ++i) dp[i] = d + dp[i];\\n                continue;\\n            }\\n            String[] dp2 = new String[]{dp[0], dp[1], dp[2]};\\n            int[] nextLen = new int[]{len[0], len[1], len[2]};\\n            for (int i = 0; i < 3; ++i) {\\n                int j = ((0 == len[i] ? 0 : i) + d) % 3;\\n                String cand = d + dp[i];\\n                if (nextLen[j] <= len[i] + 1){\\n                    nextLen[j] = len[i] + 1;\\n                    dp2[j] = cand;\\n                }\\n            }\\n            len = nextLen;\\n            dp = dp2;            \\n        }\\n        if (dp[0].isEmpty()) return \"\";\\n        int i = 0;\\n        for (char c : dp[0].toCharArray()) if (\\'0\\' == c) i++; else break;\\n        return i == dp[0].length() ? \"0\" : dp[0].substring(i);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 517869,
                "title": "clean-code-linear-time-constant-space",
                "content": "```\\nint sum;\\nint[] frequencyCounter;\\n\\npublic String largestMultipleOfThree(int[] digits) {\\n\\tupdateFrequencyCounterAndSum(digits);\\n\\tif (sum % 3 == 0)\\n\\t\\treturn getMaxNumber();\\n\\telse if (sum % 3 == 1)\\n\\t\\treturn findAlternative(1);\\n\\telse\\n\\t\\treturn findAlternative(2);\\n}\\n\\nprivate void updateFrequencyCounterAndSum(int[] digits) {\\n\\tsum = 0;\\n\\tfrequencyCounter = new int[10];\\n\\tfor (int digit : digits) {\\n\\t\\tsum += digit;\\n\\t\\t++frequencyCounter[digit];\\n\\t}\\n}\\n\\nprivate String getMaxNumber() {\\n\\tif (nonZeroDigitsHaveNoFrequency()) {\\n\\t\\tif (frequencyCounter[0] > 0)\\n\\t\\t\\treturn \"0\";\\n\\t\\treturn \"\";\\n\\t}\\n\\tStringBuilder sb = new StringBuilder();\\n\\tfor (int i = 9; i >= 0; --i)\\n\\t\\tfor (int j = 0; j < frequencyCounter[i]; j++)\\n\\t\\t\\tsb.append(i);\\n\\treturn sb.toString();\\n}\\n\\nprivate String findAlternative(int remainder) {\\n\\tif (removeDigits(1, remainder) || removeDigits(2, 3 - remainder))\\n\\t\\treturn getMaxNumber();\\n\\treturn \"\";\\n}\\n\\nprivate boolean nonZeroDigitsHaveNoFrequency() {\\n\\tfor (int i = 1; i < frequencyCounter.length; i++)\\n\\t\\tif (frequencyCounter[i] != 0)\\n\\t\\t\\treturn false;\\n\\treturn true;\\n}\\n\\nprivate boolean removeDigits(int numberOfDigitsToRemove, int remainder) {\\n\\tfor (int j = remainder; j < 10 && numberOfDigitsToRemove > 0; j += 3)\\n\\t\\tif (frequencyCounter[j] > 0) {\\n\\t\\t\\t--frequencyCounter[j];\\n\\t\\t\\t--numberOfDigitsToRemove;\\n\\t\\t\\tj -= 3;\\n\\t\\t}\\n\\treturn numberOfDigitsToRemove == 0;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint sum;\\nint[] frequencyCounter;\\n\\npublic String largestMultipleOfThree(int[] digits) {\\n\\tupdateFrequencyCounterAndSum(digits);\\n\\tif (sum % 3 == 0)\\n\\t\\treturn getMaxNumber();\\n\\telse if (sum % 3 == 1)\\n\\t\\treturn findAlternative(1);\\n\\telse\\n\\t\\treturn findAlternative(2);\\n}\\n\\nprivate void updateFrequencyCounterAndSum(int[] digits) {\\n\\tsum = 0;\\n\\tfrequencyCounter = new int[10];\\n\\tfor (int digit : digits) {\\n\\t\\tsum += digit;\\n\\t\\t++frequencyCounter[digit];\\n\\t}\\n}\\n\\nprivate String getMaxNumber() {\\n\\tif (nonZeroDigitsHaveNoFrequency()) {\\n\\t\\tif (frequencyCounter[0] > 0)\\n\\t\\t\\treturn \"0\";\\n\\t\\treturn \"\";\\n\\t}\\n\\tStringBuilder sb = new StringBuilder();\\n\\tfor (int i = 9; i >= 0; --i)\\n\\t\\tfor (int j = 0; j < frequencyCounter[i]; j++)\\n\\t\\t\\tsb.append(i);\\n\\treturn sb.toString();\\n}\\n\\nprivate String findAlternative(int remainder) {\\n\\tif (removeDigits(1, remainder) || removeDigits(2, 3 - remainder))\\n\\t\\treturn getMaxNumber();\\n\\treturn \"\";\\n}\\n\\nprivate boolean nonZeroDigitsHaveNoFrequency() {\\n\\tfor (int i = 1; i < frequencyCounter.length; i++)\\n\\t\\tif (frequencyCounter[i] != 0)\\n\\t\\t\\treturn false;\\n\\treturn true;\\n}\\n\\nprivate boolean removeDigits(int numberOfDigitsToRemove, int remainder) {\\n\\tfor (int j = remainder; j < 10 && numberOfDigitsToRemove > 0; j += 3)\\n\\t\\tif (frequencyCounter[j] > 0) {\\n\\t\\t\\t--frequencyCounter[j];\\n\\t\\t\\t--numberOfDigitsToRemove;\\n\\t\\t\\tj -= 3;\\n\\t\\t}\\n\\treturn numberOfDigitsToRemove == 0;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 517588,
                "title": "c-greedy-for-remainder-1-or-2",
                "content": "* For remainder 1, try removing smallest num with rem = 1, if not possible remove, remove 2 sumallest nums with rem = 2\\n\\n* For remainder 2, try removing smallest num with rem = 2, if not possible remove, remove 2 sumallest nums with rem = 1\\n\\n* All other digits can be taken, hence sort them. Take care of corner case of leading zeroes.\\n\\n```\\n\\nclass Solution {\\npublic:\\n    string largestMultipleOfThree(vector<int>& dig) {\\n        vector<vector<int>> d(3);\\n        int sum = 0;\\n        sort(dig.begin(), dig.end(), greater<int>());\\n        for(int i = 0; i < dig.size(); i++) {\\n            d[dig[i] % 3].push_back(dig[i]);\\n            sum = (sum + dig[i]) % 3;\\n        }\\n        if(sum) {\\n            if(!d[sum].size()) {\\n                if(d[3 - sum].size() < 2)\\n                    return \"\";\\n                d[3 - sum].pop_back();\\n                d[3 - sum].pop_back();\\n            }\\n            else {\\n                d[sum].pop_back();\\n            }\\n        }\\n     \\n        string ret;\\n        for(int i = 0; i < 3; i++) {\\n            for(auto a : d[i]) {\\n                ret += (a + \\'0\\');\\n            }\\n        }\\n        sort(ret.begin(), ret.end(), greater<int>());\\n        if(ret.size() && ret[0] == \\'0\\')\\n            return \"0\";\\n        return ret;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    string largestMultipleOfThree(vector<int>& dig) {\\n        vector<vector<int>> d(3);\\n        int sum = 0;\\n        sort(dig.begin(), dig.end(), greater<int>());\\n        for(int i = 0; i < dig.size(); i++) {\\n            d[dig[i] % 3].push_back(dig[i]);\\n            sum = (sum + dig[i]) % 3;\\n        }\\n        if(sum) {\\n            if(!d[sum].size()) {\\n                if(d[3 - sum].size() < 2)\\n                    return \"\";\\n                d[3 - sum].pop_back();\\n                d[3 - sum].pop_back();\\n            }\\n            else {\\n                d[sum].pop_back();\\n            }\\n        }\\n     \\n        string ret;\\n        for(int i = 0; i < 3; i++) {\\n            for(auto a : d[i]) {\\n                ret += (a + \\'0\\');\\n            }\\n        }\\n        sort(ret.begin(), ret.end(), greater<int>());\\n        if(ret.size() && ret[0] == \\'0\\')\\n            return \"0\";\\n        return ret;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 963543,
                "title": "python-3-heap-remainder",
                "content": "```\\nclass Solution:\\n    def largestMultipleOfThree(self, digits: List[int]) -> str:\\n        c = defaultdict(list)\\n        for x in digits:\\n            heappush(c[x%3], x)\\n\\n        tot = sum(digits)\\n        \\n        if tot %3 == 1:\\n            if 1 in c:\\n                heappop(c[1])\\n            else:\\n                heappop(c[2])\\n                heappop(c[2])\\n            \\n        elif tot % 3 == 2:\\n            if 2 in c:\\n                heappop(c[2])\\n            else:\\n                heappop(c[1])\\n                heappop(c[1])\\n        \\n        ans = \\'\\'\\n        for v in c.values():\\n            ans += \\'\\'.join(map(str, v))\\n\\n        ans = \\'\\'.join(sorted(ans, reverse=True))\\n        return str(int(ans)) if ans else \\'\\'",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def largestMultipleOfThree(self, digits: List[int]) -> str:\\n        c = defaultdict(list)\\n        for x in digits:\\n            heappush(c[x%3], x)\\n\\n        tot = sum(digits)\\n        \\n        if tot %3 == 1:\\n            if 1 in c:\\n                heappop(c[1])\\n            else:\\n                heappop(c[2])\\n                heappop(c[2])\\n            \\n        elif tot % 3 == 2:\\n            if 2 in c:\\n                heappop(c[2])\\n            else:\\n                heappop(c[1])\\n                heappop(c[1])\\n        \\n        ans = \\'\\'\\n        for v in c.values():\\n            ans += \\'\\'.join(map(str, v))\\n\\n        ans = \\'\\'.join(sorted(ans, reverse=True))\\n        return str(int(ans)) if ans else \\'\\'",
                "codeTag": "Java"
            },
            {
                "id": 695697,
                "title": "java-easy-to-understand-mathematical-solution-with-comments-in-lined",
                "content": "This is how reached to this solution.\\n\\nSince we have to make the largest number, then the number should start with the larget digit in the sequence and then as the number build up progress, the rest of the digits should follow in decreasing order.\\n\\nNow to the main logic\\nIf some number is divisible by 3, then sum of it\\'s digits should be divisible by 3.\\n\\nWe can arrive 3 cases here\\n1. **Sum % 3 == 0** -> Nothing to do\\n2. **Sum % 3 == 1** ->\\n\\tWe can make the sum divisible by 3, if we can remove a single number which is adding an extra 1 to the sum. Those numbers can be 1, 4, or 7.\\n\\tIf we can find any of the smallest number IN(1. 4. 7), we remove it from the bucket and from the sum.\\n\\tOur sum will be now divisible by 3.\\n\\t\\n\\tIf we can\\'t find any of those numbers, then this will mean that our sequence has 2 numbers which are contributing to sum modulus as 1. We remove 2 numbers in increasing order IN(2, 5, 8) then.\\n\\tExamples : [9,6,1,3], [5,8,9]\\n\\t\\n3. **Sum % 3 == 2** ->\\n\\tWe can make the sum divisible by 3, if we can remove a single number which is adding an extra 2 to the sum. Those numbers can be 2, 5, or 8.\\n\\tIf we can find any of the smallest number IN(2. 5. 8), we remove it from the bucket and from the sum.\\n\\tOur sum will be now divisible by 3.\\n\\t\\n\\tIf we can\\'t find any of those numbers, then this will mean that our sequence has 2 numbers which are contributing to sum modulus as 2. We remove 2 numbers in increasing order IN(1, 4, 7) then.\\n\\tExamples : [9,6,5,3], [4,1,9]\\n\\n```\\nclass Solution {\\n    \\n    int[] freq = new int[10];\\n    int sum = 0;\\n    public String largestMultipleOfThree(int[] digits) {\\n        StringBuffer maxNum = new StringBuffer(\"\");\\n        \\n        for(int i = 0; i < digits.length; i++) {\\n            freq[digits[i]]++;\\n            sum += digits[i];\\n        }\\n        \\n        if(sum % 3 != 0) {\\n            int index = -1;\\n            \\n            if(sum % 3 == 1) {\\n                index = remove147(); //Remove either 1, 4, 7\\n                \\n                if(index == -1) { //Remove 2 numbers in 2, 5, 8 contributing the sum modulo as 1 [e.g.: digits[] = {5, 8}]\\n                    index = remove258();\\n                    adjustFreqAndSum(index);\\n                    index = remove258();\\n                    adjustFreqAndSum(index);\\n                } else {\\n                    adjustFreqAndSum(index);\\n                }\\n            } else if(sum % 3 == 2) {\\n                index = remove258(); //Remove either 2, 5, 8\\n                \\n                if(index == -1) { //Remove 2 numbers in 1, 4, 7 contributing the sum modulo as 2 [e.g.: digits[] = {1, 4}]\\n                    index = remove147();\\n                    adjustFreqAndSum(index);\\n                    index = remove147();\\n                    adjustFreqAndSum(index);\\n                } else {\\n                    adjustFreqAndSum(index);\\n                }\\n            }\\n            \\n        }\\n        \\n        for(int i = 9; i >= 1; i--) {\\n            while(freq[i] > 0) {\\n                maxNum.append(i);\\n                freq[i]--;\\n            }\\n        }\\n        \\n        if(maxNum.length() > 0) {\\n            while(freq[0] > 0) {\\n                maxNum.append(0);\\n                freq[0]--;\\n            }\\n        } else {\\n            if(freq[0] > 0)\\n                maxNum.append(0);\\n        }\\n        \\n        return new String(maxNum);\\n    }\\n    \\n    private int remove147() {\\n        int index = -1;\\n        \\n\\t\\t//Since we have to make max number, try to find the lowest number possible first\\n        if(freq[1] > 0)\\n            index = 1;\\n        else if(freq[4] > 0)\\n            index = 4;\\n        else if(freq[7] > 0)\\n            index = 7;\\n        \\n        return index;\\n    }\\n    \\n    private int remove258() {\\n        int index = -1;\\n        \\n\\t\\t//Since we have to make max number, try to find the lowest number possible first\\n        if(freq[2] > 0)\\n            index = 2;\\n        else if(freq[5] > 0)\\n            index = 5;\\n        else if(freq[8] > 0)\\n            index = 8;\\n        \\n        return index;\\n    }\\n    \\n    private void adjustFreqAndSum(int index) {\\n        sum -= index;\\n        freq[index]--;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    int[] freq = new int[10];\\n    int sum = 0;\\n    public String largestMultipleOfThree(int[] digits) {\\n        StringBuffer maxNum = new StringBuffer(\"\");\\n        \\n        for(int i = 0; i < digits.length; i++) {\\n            freq[digits[i]]++;\\n            sum += digits[i];\\n        }\\n        \\n        if(sum % 3 != 0) {\\n            int index = -1;\\n            \\n            if(sum % 3 == 1) {\\n                index = remove147(); //Remove either 1, 4, 7\\n                \\n                if(index == -1) { //Remove 2 numbers in 2, 5, 8 contributing the sum modulo as 1 [e.g.: digits[] = {5, 8}]\\n                    index = remove258();\\n                    adjustFreqAndSum(index);\\n                    index = remove258();\\n                    adjustFreqAndSum(index);\\n                } else {\\n                    adjustFreqAndSum(index);\\n                }\\n            } else if(sum % 3 == 2) {\\n                index = remove258(); //Remove either 2, 5, 8\\n                \\n                if(index == -1) { //Remove 2 numbers in 1, 4, 7 contributing the sum modulo as 2 [e.g.: digits[] = {1, 4}]\\n                    index = remove147();\\n                    adjustFreqAndSum(index);\\n                    index = remove147();\\n                    adjustFreqAndSum(index);\\n                } else {\\n                    adjustFreqAndSum(index);\\n                }\\n            }\\n            \\n        }\\n        \\n        for(int i = 9; i >= 1; i--) {\\n            while(freq[i] > 0) {\\n                maxNum.append(i);\\n                freq[i]--;\\n            }\\n        }\\n        \\n        if(maxNum.length() > 0) {\\n            while(freq[0] > 0) {\\n                maxNum.append(0);\\n                freq[0]--;\\n            }\\n        } else {\\n            if(freq[0] > 0)\\n                maxNum.append(0);\\n        }\\n        \\n        return new String(maxNum);\\n    }\\n    \\n    private int remove147() {\\n        int index = -1;\\n        \\n\\t\\t//Since we have to make max number, try to find the lowest number possible first\\n        if(freq[1] > 0)\\n            index = 1;\\n        else if(freq[4] > 0)\\n            index = 4;\\n        else if(freq[7] > 0)\\n            index = 7;\\n        \\n        return index;\\n    }\\n    \\n    private int remove258() {\\n        int index = -1;\\n        \\n\\t\\t//Since we have to make max number, try to find the lowest number possible first\\n        if(freq[2] > 0)\\n            index = 2;\\n        else if(freq[5] > 0)\\n            index = 5;\\n        else if(freq[8] > 0)\\n            index = 8;\\n        \\n        return index;\\n    }\\n    \\n    private void adjustFreqAndSum(int index) {\\n        sum -= index;\\n        freq[index]--;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1530189,
                "title": "c-clean-and-concise-code-with-proper-explanation",
                "content": "class Solution {\\npublic:\\n    \\n    // Key of these Question is that a number is divisible by 3 when sum of all single digits of the number is divisible by 3.\\n    \\n    string largestMultipleOfThree(vector<int>& digits) {\\n     \\n        int n=digits.size();\\n        \\n        //The string which we have to return \\n        \\n        string ans=\"\";\\n        \\n        //Initialize a variable sum to store the sum of all the give digits\\n        \\n        int sum=0;\\n        \\n        // Create a count array to store all the occurences of each and every digit\\n        \\n        vector<int>count(10,0);\\n        \\n        for(int i=0;i<n;i++){\\n            count[digits[i]]++;\\n            sum+=digits[i];\\n        }\\n        \\n        // If sum is divisible by three we have nothing to do , we just reverse the count array and store all the digits in our string ans\\n        \\n        /* Otherwise  there were two more cases like :\\n        \\n        (1) Sum is divisible by 1 \\n        (2) Sum is divisible by 2    \\n        \\n      *** For the first case (sum%3==1) What basically we gonna do is discard the digit which is not divisible by three and (num%3==1) [ See Example Test Case 2] or if we have no such num for which (num%3==1) , we can also discard two  elements num1 and num2 for which (num1%3==2 && num2%3==2) \\n      \\n         As you can see [8,9,8,3]  We can\\'t form a number using all of these digits as      sum=(8+9+8+1+3) = 28 , which is not divisible by 3. (29 % 3 = 1) but still there is no such num (num%3==1) , so we have to discard two smallest num1 , num2 for which (num1%3==2 && num2%3==2)  i.e 8,8 . Final string will be \"93\"\\n         \\n         \\n         \\n      *** For the second case , same logic is applicable , do it yourself for clear conception.   \\n        \\n                    */\\n        \\n        \\n        /* So for simplification of our calculation we create two arrays which num or \\n        (num1 && num2) we have to discard to maintain given properties . */\\n        \\n        int arr1[6]={1,4,7,2,5,8};\\n        int arr2[6]={2,5,8,1,4,7};\\n        \\n        while(sum % 3!=0){\\n            \\n            for(int num: sum%3==1 ? arr1 : arr2){\\n                \\n                if(count[num]>0){\\n                    count[num]--;\\n                    sum-=num;\\n                    break;\\n                }\\n                \\n            }\\n            \\n        }\\n        \\n        \\n        for(int i=9;i>=0;i--){\\n            \\n            while(count[i]--){\\n                ans+=to_string(i);\\n            }\\n            \\n        }\\n        \\n        if(ans.size()>0 && ans[0]==\\'0\\'){\\n            return \"0\";\\n        }\\n        \\n        else{\\n            return ans;\\n        }\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    // Key of these Question is that a number is divisible by 3 when sum of all single digits of the number is divisible by 3.\\n    \\n    string largestMultipleOfThree(vector<int>& digits) {\\n     \\n        int n=digits.size();\\n        \\n        //The string which we have to return \\n        \\n        string ans=\"\";\\n        \\n        //Initialize a variable sum to store the sum of all the give digits\\n        \\n        int sum=0;\\n        \\n        // Create a count array to store all the occurences of each and every digit\\n        \\n        vector<int>count(10,0);\\n        \\n        for(int i=0;i<n;i++){\\n            count[digits[i]]++;\\n            sum+=digits[i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 977443,
                "title": "concise-javascript-solution-based-on-math",
                "content": "**Approach**\\nThe number will be divisible by 3 if the sum of all digits is divisible by 3. The largest number will be sorted by digits in a descending order.\\n> e.g. [8,1,9] -> [9,8,1]\\n\\nWe sort the digits, and find out the sum of digits. If there\\'s a remainder after dividing by 3, we try to find the smallest digit which can be removed from the digits array. We do that by traversing digits array from last and seeing if subtracting the remainder from any digit makes it divisible by 3.\\n\\n> e.g. In [9,8,2,1], the remainder is 2; and 2 is the smallest digit which becomes divisible by 3 if we subtract 2 from it.\\n\\nIf we don\\'t find any such digit, we remove everything from array except those divisible by 3 directly.\\n\\n> e.g. In [9,4,7], the remainder is 2; and there\\'s not a single number that becomes divisible by 3 if we subtract 2 from it. So, we take only 9 from the bunch.\\n\\n**Code**\\n```javascript\\n/**\\n * @param {number[]} digits\\n * @return {string}\\n */\\nvar largestMultipleOfThree = function(digits) {\\n    // highest digit first\\n    digits.sort((l, r) => r - l);\\n    \\n    // what is the remainder of the total sum?\\n    const sumRemainder = digits.reduce((a, c) => a + c, 0) % 3;\\n    \\n    if (sumRemainder) {\\n        let targetIndex = 0, i = digits.length - 1;\\n        \\n        // try to find what is the smallest number that can be removed\\n        for (; i >= 0; i--) {\\n            if ((digits[i] - sumRemainder) % 3 === 0) {\\n                targetIndex = i;\\n                break;\\n            }\\n        }\\n\\n        if (i < 0) {\\n            // iterated the whole loop, couldn\\'t find a single number to remove\\n            // remove everything but multiples of 3\\n            digits = digits.filter(v => v % 3 === 0);\\n        } else {\\n            digits.splice(targetIndex, 1);\\n        }\\n    }\\n    \\n    return (digits[0] === 0) ? \\'0\\' : digits.join(\\'\\');\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\n/**\\n * @param {number[]} digits\\n * @return {string}\\n */\\nvar largestMultipleOfThree = function(digits) {\\n    // highest digit first\\n    digits.sort((l, r) => r - l);\\n    \\n    // what is the remainder of the total sum?\\n    const sumRemainder = digits.reduce((a, c) => a + c, 0) % 3;\\n    \\n    if (sumRemainder) {\\n        let targetIndex = 0, i = digits.length - 1;\\n        \\n        // try to find what is the smallest number that can be removed\\n        for (; i >= 0; i--) {\\n            if ((digits[i] - sumRemainder) % 3 === 0) {\\n                targetIndex = i;\\n                break;\\n            }\\n        }\\n\\n        if (i < 0) {\\n            // iterated the whole loop, couldn\\'t find a single number to remove\\n            // remove everything but multiples of 3\\n            digits = digits.filter(v => v % 3 === 0);\\n        } else {\\n            digits.splice(targetIndex, 1);\\n        }\\n    }\\n    \\n    return (digits[0] === 0) ? \\'0\\' : digits.join(\\'\\');\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 806657,
                "title": "c-math",
                "content": "```\\nclass Solution {\\npublic:\\n    string largestMultipleOfThree(vector<int>& digits) {\\n        vector<int> cnt(10,0);\\n        for(auto i:digits) cnt[i]++;\\n        int mod0 = cnt[0] + cnt[3] + cnt[6] + cnt[9];\\n        int mod1 = cnt[1] + cnt[4] + cnt[7];\\n        int mod2 = cnt[2] + cnt[5] + cnt[8];\\n        int modAll = (mod1 + mod2*2) % 3;\\n        \\n        if(modAll == 1){\\n            if(mod1 >= 1) remove(1, cnt[1], cnt[4], cnt[7]);\\n            else if(mod2 >=2) remove(2, cnt[2], cnt[5], cnt[8]);\\n            else return \"\";\\n        }\\n        else if(modAll == 2){\\n            if(mod2 >= 1) remove(1, cnt[2], cnt[5], cnt[8]); \\n            else if(mod1 >=2) remove(2, cnt[1], cnt[4], cnt[7]);\\n            else return \"\";\\n        }\\n        \\n        string s;\\n        for(int i=9; i>=0;i--) s += string(cnt[i], \\'0\\'+i);\\n        if(!s.empty() && s[0] == \\'0\\') s = \"0\";\\n        return s;\\n    }\\n    \\n    // remove n elements from x1,x2,x3; from x1\\n    void remove(int n, int& x1, int& x2, int& x3){\\n        while(x1>0 && n>0) {x1--;n--;}\\n        while(x2>0 && n>0) {x2--;n--;}\\n        while(x3>0 && n>0) {x3--;n--;}\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    string largestMultipleOfThree(vector<int>& digits) {\\n        vector<int> cnt(10,0);\\n        for(auto i:digits) cnt[i]++;\\n        int mod0 = cnt[0] + cnt[3] + cnt[6] + cnt[9];\\n        int mod1 = cnt[1] + cnt[4] + cnt[7];\\n        int mod2 = cnt[2] + cnt[5] + cnt[8];\\n        int modAll = (mod1 + mod2*2) % 3;\\n        \\n        if(modAll == 1){\\n            if(mod1 >= 1) remove(1, cnt[1], cnt[4], cnt[7]);\\n            else if(mod2 >=2) remove(2, cnt[2], cnt[5], cnt[8]);\\n            else return \"\";\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 522770,
                "title": "javascript-and-c-solutions",
                "content": "**Synopsis**\\n\\nIf the number\\'s individual digits sum to `3`, then the number is divisible by 3.  There are 3 `mod` buckets of digits to consider by performing modulus on each digit `x`:\\n\\n* `x % 3 == 0`  \\uD83D\\uDC49  `{ 0, 3, 6, 9 }`\\n* `x % 3 == 1` \\uD83D\\uDC49 `{ 1, 4, 7 }`\\n* `x % 3 == 2` \\uD83D\\uDC49 `{ 2, 5, 8 }`\\n\\nIf the number is *not* divisble by `3`, then we can remove digits one-by-one in ascending order to minimally reduce the number:\\n\\n* **Case 1:** if `x % 3 == 0`, then keep all these `x` digits\\n* **Case 2:** if `x % 3 == 1`, then we need to remove one `x` from `{ 1, 4, 7 }` or two `x` from `{ 2, 5, 8 }`\\n* **Case 3:** if `x % 3 == 2`, then we need to remove one `x` from `{ 2, 5, 8 }` or two `x` from `{ 1, 4, 7 }`\\n\\n**Note:** prioritize one removal over two removals for **Case 2** and **Case 3**.\\n\\n*Javascript*\\n```\\nlet largestMultipleOfThree = (A, sum = 0, cnt = {}) => {\\n    for (let x of A) {\\n        if (!cnt[x])\\n            cnt[x] = 0;\\n        ++cnt[x], sum += x;\\n    }\\n    if (sum == 0)\\n        return \\'0\\';\\n    let mod = {\\n        1: [1, 4, 7, 2, 5, 8],\\n        2: [2, 5, 8, 1, 4, 7],\\n    };\\n    while (sum % 3) {\\n        for (let x of mod[sum % 3]) {\\n            if (cnt[x]) {\\n                --cnt[x], sum -= x; break;\\n            }\\n        }\\n    }\\n    return Object.entries(cnt).map(pair => pair[0].toString().repeat(pair[1]))\\n        .sort((a, b) => a.charCodeAt(0) - b.charCodeAt(0)).reverse().join(\\'\\');\\n};\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    using Cnt = unordered_map<char, int>;\\n    string largestMultipleOfThree(VI& A, int sum = 0, Cnt cnt = {}, stringstream ans = stringstream()) {\\n        for (auto x: A)\\n            ++cnt[x], sum += x;\\n        if (sum == 0)\\n            return \"0\";\\n        VVI mod{{}, {1, 4, 7, 2, 5, 8}, {2, 5, 8, 1, 4, 7}}; // 0, 1, 2\\n        while (sum % 3) {\\n            for (auto x: mod[sum % 3]) {\\n                if (cnt[x]) {\\n                    --cnt[x], sum -= x; break;\\n                }\\n            }\\n        }\\n        for (auto i = 9; i >= 0; --i)\\n            if (cnt[i])\\n                ans << string(cnt[i], \\'0\\' + i);\\n        return ans.str();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nlet largestMultipleOfThree = (A, sum = 0, cnt = {}) => {\\n    for (let x of A) {\\n        if (!cnt[x])\\n            cnt[x] = 0;\\n        ++cnt[x], sum += x;\\n    }\\n    if (sum == 0)\\n        return \\'0\\';\\n    let mod = {\\n        1: [1, 4, 7, 2, 5, 8],\\n        2: [2, 5, 8, 1, 4, 7],\\n    };\\n    while (sum % 3) {\\n        for (let x of mod[sum % 3]) {\\n            if (cnt[x]) {\\n                --cnt[x], sum -= x; break;\\n            }\\n        }\\n    }\\n    return Object.entries(cnt).map(pair => pair[0].toString().repeat(pair[1]))\\n        .sort((a, b) => a.charCodeAt(0) - b.charCodeAt(0)).reverse().join(\\'\\');\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    using Cnt = unordered_map<char, int>;\\n    string largestMultipleOfThree(VI& A, int sum = 0, Cnt cnt = {}, stringstream ans = stringstream()) {\\n        for (auto x: A)\\n            ++cnt[x], sum += x;\\n        if (sum == 0)\\n            return \"0\";\\n        VVI mod{{}, {1, 4, 7, 2, 5, 8}, {2, 5, 8, 1, 4, 7}}; // 0, 1, 2\\n        while (sum % 3) {\\n            for (auto x: mod[sum % 3]) {\\n                if (cnt[x]) {\\n                    --cnt[x], sum -= x; break;\\n                }\\n            }\\n        }\\n        for (auto i = 9; i >= 0; --i)\\n            if (cnt[i])\\n                ans << string(cnt[i], \\'0\\' + i);\\n        return ans.str();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 517635,
                "title": "c-take-all-digits-then-remove-based-on-remainder-o-nlogn",
                "content": "Consider all digits as answer.\\nCalculate the sum of digits, do the following for remainder with division with 3:\\n\\n\\t\\t1. when 0, do nothing create string\\n\\t\\t2. when 1, invalidate one digit of remainder 1, or 2 digits of remainder 2.\\n\\t\\t3. when 2, invalidate one digit of remainder 2, or 2 digits of remainder 1.\\n\\nconstruct answer string from valid digits and join them in larger to smaller digit.\\n\\nIts Simple O(nlong) soltuion.\\n\\n```\\nclass Solution {\\npublic:\\n    string largestMultipleOfThree(vector<int>& digits) {\\n        sort(digits.begin(),digits.end());\\n        int n=digits.size();\\n        if(digits[n-1]==0)return \"0\";\\n        int sum=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            sum=sum+digits[i];\\n        }\\n        if(sum%3==1)\\n        {\\n            bool ok=false;\\n            for(int i=0;i<n;i++)\\n            {\\n                if(digits[i]%3==1)\\n                {\\n                    digits[i]=-1;\\n                    ok=true;\\n                    break;\\n                }\\n            }\\n            if(!ok)\\n            {\\n                int cnt=0;\\n                for(int i=0;i<n;i++)\\n                {\\n                    if(digits[i]%3==2)\\n                    {\\n                        digits[i]=-1;\\n                        cnt++;\\n                        if(cnt==2)break;\\n                    }\\n                }\\n            }\\n        }\\n        else if(sum%3==2)\\n        {\\n            bool ok=false;\\n            for(int i=0;i<n;i++)\\n            {\\n                if(digits[i]%3==2)\\n                {\\n                    digits[i]=-1;\\n                    ok=true;\\n                    break;\\n                }\\n            }\\n            if(!ok)\\n            {\\n                int cnt=0;\\n                for(int i=0;i<n;i++)\\n                {\\n                    if(digits[i]%3==1)\\n                    {\\n                        digits[i]=-1;\\n                        cnt++;\\n                        if(cnt==2)break;\\n                    }\\n                }\\n            }\\n        }\\n        string ans=\"\";\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            if(digits[i]==-1)continue;\\n            char c=digits[i]+\\'0\\';\\n            ans=ans+c;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestMultipleOfThree(vector<int>& digits) {\\n        sort(digits.begin(),digits.end());\\n        int n=digits.size();\\n        if(digits[n-1]==0)return \"0\";\\n        int sum=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            sum=sum+digits[i];\\n        }\\n        if(sum%3==1)\\n        {\\n            bool ok=false;\\n            for(int i=0;i<n;i++)\\n            {\\n                if(digits[i]%3==1)\\n                {\\n                    digits[i]=-1;\\n                    ok=true;\\n                    break;\\n                }\\n            }\\n            if(!ok)\\n            {\\n                int cnt=0;\\n                for(int i=0;i<n;i++)\\n                {\\n                    if(digits[i]%3==2)\\n                    {\\n                        digits[i]=-1;\\n                        cnt++;\\n                        if(cnt==2)break;\\n                    }\\n                }\\n            }\\n        }\\n        else if(sum%3==2)\\n        {\\n            bool ok=false;\\n            for(int i=0;i<n;i++)\\n            {\\n                if(digits[i]%3==2)\\n                {\\n                    digits[i]=-1;\\n                    ok=true;\\n                    break;\\n                }\\n            }\\n            if(!ok)\\n            {\\n                int cnt=0;\\n                for(int i=0;i<n;i++)\\n                {\\n                    if(digits[i]%3==1)\\n                    {\\n                        digits[i]=-1;\\n                        cnt++;\\n                        if(cnt==2)break;\\n                    }\\n                }\\n            }\\n        }\\n        string ans=\"\";\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            if(digits[i]==-1)continue;\\n            char c=digits[i]+\\'0\\';\\n            ans=ans+c;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3797133,
                "title": "dp-easy-not-most-efficient-but-intuitive",
                "content": "# Intuition\\nSo this is what struck my head when I thought of this problem idk why.\\nIf we have a starting point and a particular remainder which we have got upto this point we can define our problem.\\n\\nSo at the start we have dp[0][0]\\nnow what to store inside the dp , I store an array of 10 places the no of digits of each type and the length of the string formed from these\\n\\nNow at the end we should only have rem 0 left so initialise everything with -1 and keep a visited array to keep track wether this state was previously considered or not.\\n\\nThe custom comparator \"retgreater\" tells which dp state to take the transition from.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n- $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    bool retgreater(vector<int>& a,vector<int>& b){\\n        for(int i=10;i>=0;i--){\\n            if(b[i]!=a[i]) return (a[i] > b[i]);\\n        }\\n        return true;\\n    }\\n\\n    vector<int> DFS(vector<int>& digits,int ind,vector<vector<vector<int>>>& dp,vector<vector<int>>& vis,int rem){\\n        int n = digits.size();\\n        if(ind==n) return dp[n][rem]; \\n        if(vis[ind][rem]!=0) return dp[ind][rem];\\n        vis[ind][rem]=1;\\n        auto i1 = DFS(digits,ind+1,dp,vis,(rem+digits[ind])%3);\\n        if(i1[10]!=-1){\\n            i1[10]++;\\n            i1[digits[ind]]++;\\n        }\\n        auto i2 = DFS(digits,ind+1,dp,vis,rem);\\n        return dp[ind][rem] = (retgreater(i1,i2) ? i1 : i2);\\n    }\\n\\n    string largestMultipleOfThree(vector<int>& digits) {\\n        int n = digits.size();\\n        vector<vector<vector<int>>> dp(n+1,vector<vector<int>>(3,vector<int>(11,-1)));\\n        dp[n][0] = vector<int>(11,0);\\n        vector<vector<int>> vis(n,vector<int>(3,0));\\n        auto currans = DFS(digits,0,dp,vis,0);\\n        string ans=\"\";\\n        for(int i=9;i>=0;i--){\\n            while(currans[i]>0){\\n                ans+=to_string(i);\\n                currans[i]--;\\n            }\\n        }\\n        return (ans[0]==\\'0\\' ? \"0\" : ans);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    bool retgreater(vector<int>& a,vector<int>& b){\\n        for(int i=10;i>=0;i--){\\n            if(b[i]!=a[i]) return (a[i] > b[i]);\\n        }\\n        return true;\\n    }\\n\\n    vector<int> DFS(vector<int>& digits,int ind,vector<vector<vector<int>>>& dp,vector<vector<int>>& vis,int rem){\\n        int n = digits.size();\\n        if(ind==n) return dp[n][rem]; \\n        if(vis[ind][rem]!=0) return dp[ind][rem];\\n        vis[ind][rem]=1;\\n        auto i1 = DFS(digits,ind+1,dp,vis,(rem+digits[ind])%3);\\n        if(i1[10]!=-1){\\n            i1[10]++;\\n            i1[digits[ind]]++;\\n        }\\n        auto i2 = DFS(digits,ind+1,dp,vis,rem);\\n        return dp[ind][rem] = (retgreater(i1,i2) ? i1 : i2);\\n    }\\n\\n    string largestMultipleOfThree(vector<int>& digits) {\\n        int n = digits.size();\\n        vector<vector<vector<int>>> dp(n+1,vector<vector<int>>(3,vector<int>(11,-1)));\\n        dp[n][0] = vector<int>(11,0);\\n        vector<vector<int>> vis(n,vector<int>(3,0));\\n        auto currans = DFS(digits,0,dp,vis,0);\\n        string ans=\"\";\\n        for(int i=9;i>=0;i--){\\n            while(currans[i]>0){\\n                ans+=to_string(i);\\n                currans[i]--;\\n            }\\n        }\\n        return (ans[0]==\\'0\\' ? \"0\" : ans);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3678387,
                "title": "simple-c-greedy-math",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo find the largest multiple of three using a given set of digits, the approach involves sorting the digits in non-increasing order and calculating the sum of all the digits. If the sum is zero, the result is \"0\" since there are no non-zero digits. If the sum is already divisible by three, the sorted digits form the largest multiple of three. Otherwise, the digits are categorized based on their modulo 3 value, and necessary digits are removed to make the sum a multiple of three. The remaining digits are concatenated, sorted in non-increasing order, and returned as the largest multiple of three. Leading zeros are avoided, and the resulting string is returned as the solution.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n1. First, sort the given digits in non-increasing order to prioritize larger digits.\\n2. Calculate the sum of all the digits.\\n3. If the sum is zero, return \"0\" since there are no non-zero digits to form a multiple of three.\\n4. Check if the sum is already divisible by three.\\n5. If the sum is divisible by three, return the sorted digits as the resulting number.\\n6. If the sum is not divisible by three, we need to remove some digits to make it a multiple of three.\\n7. Categorize the digits based on their modulo 3 value using a map.\\n8. Determine which digits to remove based on the remainder when dividing the sum by three.\\n9. Prioritize removing digits from higher modulo 3 categories to minimize the impact on the resulting number.\\n10. Concatenate the remaining digits from the map into a string.\\n11. Sort the resulting string in non-increasing order.\\n12. Check if the resulting string starts with \\'0\\'. If it does, return \"0\" since leading zeros are not allowed.\\n13. Otherwise, return the resulting string as the largest multiple of three using the given digits.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(nlogn)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string make_string(vector<int> &v){\\n        string ans = \"\";\\n        for(auto it:v) ans += (it +\\'0\\');\\n        return ans;\\n        \\n    }\\n    string largestMultipleOfThree(vector<int>& digits) {\\n        sort(digits.rbegin(),digits.rend());\\n        int n = digits.size();\\n        int sum = accumulate(digits.begin(),digits.end(),0);\\n        if(sum == 0) return \"0\";\\n        if(sum %3  == 0) return make_string(digits);\\n        int one = 0,two = 0;\\n        map<int,vector<int>> m;\\n\\n        for(auto it:digits){\\n             if((it%3) == 1) {m[1].push_back(it);one++;}\\n             else if((it%3) == 2) {m[2].push_back(it);two++;}\\n             else m[0].push_back(it);\\n        }\\n        if(sum%3 == 1){\\n            if(!m[1].empty()) m[1].pop_back();\\n            else {\\n                m[2].pop_back();\\n                m[2].pop_back();\\n            }\\n        }\\n        else {\\n            if(!m[2].empty()) m[2].pop_back();\\n            else {\\n                m[1].pop_back();\\n                m[1].pop_back();\\n            }\\n        }\\n        string ans = \"\";\\n        for(int i = 0;i<3;i++){\\n            for(auto it:m[i]){\\n                ans += (it + \\'0\\');\\n            }\\n        }\\n        sort(ans.rbegin(),ans.rend());\\n        if(ans[0] == \\'0\\') return \"0\";\\n        return ans;\\n         \\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string make_string(vector<int> &v){\\n        string ans = \"\";\\n        for(auto it:v) ans += (it +\\'0\\');\\n        return ans;\\n        \\n    }\\n    string largestMultipleOfThree(vector<int>& digits) {\\n        sort(digits.rbegin(),digits.rend());\\n        int n = digits.size();\\n        int sum = accumulate(digits.begin(),digits.end(),0);\\n        if(sum == 0) return \"0\";\\n        if(sum %3  == 0) return make_string(digits);\\n        int one = 0,two = 0;\\n        map<int,vector<int>> m;\\n\\n        for(auto it:digits){\\n             if((it%3) == 1) {m[1].push_back(it);one++;}\\n             else if((it%3) == 2) {m[2].push_back(it);two++;}\\n             else m[0].push_back(it);\\n        }\\n        if(sum%3 == 1){\\n            if(!m[1].empty()) m[1].pop_back();\\n            else {\\n                m[2].pop_back();\\n                m[2].pop_back();\\n            }\\n        }\\n        else {\\n            if(!m[2].empty()) m[2].pop_back();\\n            else {\\n                m[1].pop_back();\\n                m[1].pop_back();\\n            }\\n        }\\n        string ans = \"\";\\n        for(int i = 0;i<3;i++){\\n            for(auto it:m[i]){\\n                ans += (it + \\'0\\');\\n            }\\n        }\\n        sort(ans.rbegin(),ans.rend());\\n        if(ans[0] == \\'0\\') return \"0\";\\n        return ans;\\n         \\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3355180,
                "title": "python-100-faster-t-o-n-s-o-1-dictionary-math",
                "content": "# Intuition\\nMaximize the answer my choosing current available max number.\\n\\nAfter all numbers exhausted delete some numbers for correcting remainder.\\n# Approach\\nFirst find max number using counter dictionary. \\n\\nthen adjust it to multiple of 3 by\\n\\nNOTE :(For those who did not understood del2 call from del1): \\nMathematically if in case remainder is 1 it could be of two reasons \\n- due to a ones(1,4,7) element.\\n- due to twos(2,5,8) element occuring twice.\\n\\n# Complexity\\n- Time complexity:\\nO(n) \\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def del1(self,ans):\\n        i=len(ans)-1\\n        ones={\"1\",\"4\",\"7\"}\\n        while i>-1 and ans[i] not in ones:i-=1\\n        if i==-1:return self.del2(self.del2(ans))\\n        return ans[:i]+ans[i+1:]\\n\\n    def del2(self,ans):\\n        i=len(ans)-1\\n        twos={\"2\",\"5\",\"8\"}\\n        while i>-1 and ans[i] not in twos:i-=1\\n        if i==-1:return self.del1(self.del1(ans))\\n        return ans[:i]+ans[i+1:]\\n        \\n\\n    def largestMultipleOfThree(self, digits: List[int]) -> str:\\n        c=Counter(digits)\\n        ans,rem=\"\",0\\n        for i in range(9,0,-1):\\n            ans+=str(i)*c[i]\\n            rem=(rem+i*c[i]%3)%3\\n        \\n        if rem==1:ans=self.del1(ans)\\n        if rem==2:ans=self.del2(ans)\\n        return ans+\"0\"*c[0] if ans else \"0\" if 0 in c else \"\"\\n\\n        \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def del1(self,ans):\\n        i=len(ans)-1\\n        ones={\"1\",\"4\",\"7\"}\\n        while i>-1 and ans[i] not in ones:i-=1\\n        if i==-1:return self.del2(self.del2(ans))\\n        return ans[:i]+ans[i+1:]\\n\\n    def del2(self,ans):\\n        i=len(ans)-1\\n        twos={\"2\",\"5\",\"8\"}\\n        while i>-1 and ans[i] not in twos:i-=1\\n        if i==-1:return self.del1(self.del1(ans))\\n        return ans[:i]+ans[i+1:]\\n        \\n\\n    def largestMultipleOfThree(self, digits: List[int]) -> str:\\n        c=Counter(digits)\\n        ans,rem=\"\",0\\n        for i in range(9,0,-1):\\n            ans+=str(i)*c[i]\\n            rem=(rem+i*c[i]%3)%3\\n        \\n        if rem==1:ans=self.del1(ans)\\n        if rem==2:ans=self.del2(ans)\\n        return ans+\"0\"*c[0] if ans else \"0\" if 0 in c else \"\"\\n\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2946272,
                "title": "greedy-solution",
                "content": "# Intuition\\n\\n\\n# Approach\\nconsidering cases where sum of all the number gives remainder 0 , 1 or 2 when divided by 3.\\n\\n# Complexity\\n- Time complexity:\\nnlogn\\n\\n- Space complexity:\\nno extra space\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n  \\n    string largestMultipleOfThree(vector<int>& digits) {     \\n        sort(digits.begin(),digits.end());\\n        string s=\"\";\\n        int n=digits.size();\\n         int sum=0;\\n        int i;\\n        int check=0;\\n        int flag=0;\\n        for(i=0;i<n;i++){\\n            s=s+to_string(digits[i]);\\n            sum=sum+digits[i];\\n        }\\n         reverse(s.begin(),s.end());\\n       if(sum%3==0){\\n          \\n           if(s[0]==\\'0\\'){\\n               return \"0\";\\n           }\\n           return s;\\n       }\\n      else if(sum%3==1){\\n           i=s.size()-1;\\n          while(i>=0){\\n               int c=s[i]-\\'0\\';\\n               if(c%3==1){\\n                   s.erase(i,1);\\n                   flag=1;\\n                   break;\\n               }\\n               i--;\\n          }\\n          if(flag==0){\\n              i=s.size()-1;\\n              while(i>=0){\\n             int c=s[i]-\\'0\\';\\n             if(c%3==2){\\n                 s.erase(i,1);\\n                  check++;\\n                  if(check==2){\\n                      break;\\n                  }\\n             }\\n             i--;\\n              }\\n\\n          }\\n          sort(s.begin(),s.end());\\n          reverse(s.begin(),s.end());\\n          if(s[0]==\\'0\\'){\\n              return \"0\";\\n          }\\n          return s;\\n              \\n       }\\n       else if(sum%3==2){\\n           i=s.size()-1;\\n          while(i>=0){\\n               int c=s[i]-\\'0\\';\\n               if(c%3==2){\\n                   s.erase(i,1);\\n                   flag=1;\\n                   break;\\n               }\\n               i--;\\n          }\\n          if(flag==0){\\n              i=s.size()-1;\\n              while(i>=0){\\n             int c=s[i]-\\'0\\';\\n             if(c%3==1){\\n                 s.erase(i,1);\\n                  check++;\\n                  if(check==2){\\n                      break;\\n                  }\\n             }\\n             i--;\\n              }\\n\\n          }\\n          sort(s.begin(),s.end());\\n          reverse(s.begin(),s.end());\\n          if(s[0]==\\'0\\'){\\n              return \"0\";\\n          }\\n          return s;\\n\\n\\n       }\\n     return s;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n  \\n    string largestMultipleOfThree(vector<int>& digits) {     \\n        sort(digits.begin(),digits.end());\\n        string s=\"\";\\n        int n=digits.size();\\n         int sum=0;\\n        int i;\\n        int check=0;\\n        int flag=0;\\n        for(i=0;i<n;i++){\\n            s=s+to_string(digits[i]);\\n            sum=sum+digits[i];\\n        }\\n         reverse(s.begin(),s.end());\\n       if(sum%3==0){\\n          \\n           if(s[0]==\\'0\\'){\\n               return \"0\";\\n           }\\n           return s;\\n       }\\n      else if(sum%3==1){\\n           i=s.size()-1;\\n          while(i>=0){\\n               int c=s[i]-\\'0\\';\\n               if(c%3==1){\\n                   s.erase(i,1);\\n                   flag=1;\\n                   break;\\n               }\\n               i--;\\n          }\\n          if(flag==0){\\n              i=s.size()-1;\\n              while(i>=0){\\n             int c=s[i]-\\'0\\';\\n             if(c%3==2){\\n                 s.erase(i,1);\\n                  check++;\\n                  if(check==2){\\n                      break;\\n                  }\\n             }\\n             i--;\\n              }\\n\\n          }\\n          sort(s.begin(),s.end());\\n          reverse(s.begin(),s.end());\\n          if(s[0]==\\'0\\'){\\n              return \"0\";\\n          }\\n          return s;\\n              \\n       }\\n       else if(sum%3==2){\\n           i=s.size()-1;\\n          while(i>=0){\\n               int c=s[i]-\\'0\\';\\n               if(c%3==2){\\n                   s.erase(i,1);\\n                   flag=1;\\n                   break;\\n               }\\n               i--;\\n          }\\n          if(flag==0){\\n              i=s.size()-1;\\n              while(i>=0){\\n             int c=s[i]-\\'0\\';\\n             if(c%3==1){\\n                 s.erase(i,1);\\n                  check++;\\n                  if(check==2){\\n                      break;\\n                  }\\n             }\\n             i--;\\n              }\\n\\n          }\\n          sort(s.begin(),s.end());\\n          reverse(s.begin(),s.end());\\n          if(s[0]==\\'0\\'){\\n              return \"0\";\\n          }\\n          return s;\\n\\n\\n       }\\n     return s;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2711835,
                "title": "c-93-faster-than-all-easy",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n   string largestMultipleOfThree(vector<int>& digits, string res = \"\") {\\n  int m1[] = {1, 4, 7, 2, 5, 8}, m2[] = {2, 5, 8, 1, 4, 7};\\n  int sum = 0, ds[10] = {};  \\n  for (auto d : digits) {\\n      ++ds[d];\\n      sum += d;\\n  }\\n  while (sum % 3 != 0) {\\n    for (auto i : sum % 3 == 1 ? m1 : m2) {\\n      if (ds[i]) {\\n        --ds[i];\\n        sum -= i;\\n        break;\\n      }\\n    }\\n  }\\n  for (int i = 9; i >= 0; --i)\\n    res += string(ds[i], \\'0\\' + i);\\n  return res.size() && res[0] == \\'0\\' ? \"0\" : res;\\n}\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   string largestMultipleOfThree(vector<int>& digits, string res = \"\") {\\n  int m1[] = {1, 4, 7, 2, 5, 8}, m2[] = {2, 5, 8, 1, 4, 7};\\n  int sum = 0, ds[10] = {};  \\n  for (auto d : digits) {\\n      ++ds[d];\\n      sum += d;\\n  }\\n  while (sum % 3 != 0) {\\n    for (auto i : sum % 3 == 1 ? m1 : m2) {\\n      if (ds[i]) {\\n        --ds[i];\\n        sum -= i;\\n        break;\\n      }\\n    }\\n  }\\n  for (int i = 9; i >= 0; --i)\\n    res += string(ds[i], \\'0\\' + i);\\n  return res.size() && res[0] == \\'0\\' ? \"0\" : res;\\n}\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2541801,
                "title": "c-priority-queue-maths",
                "content": "```\\nclass Solution {\\npublic:\\n    string largestMultipleOfThree(vector<int>& nums) {\\n        string ans=\"\";\\n        int n=nums.size(),sum=0;\\n        sort(nums.begin(),nums.end(),greater<int>());\\n        vector<int> rem0,rem1,rem2;\\n        for(auto i:nums){\\n            sum+=i;\\n            if(i%3==0){\\n                rem0.push_back(i);\\n            }\\n            else if(i%3==1){\\n                rem1.push_back(i);\\n            }\\n            else{\\n                rem2.push_back(i);\\n            }\\n        }\\n        \\n        if(sum%3==1){\\n            if(rem1.size()>0) rem1.pop_back();\\n            else{\\n                rem2.pop_back();\\n                rem2.pop_back();\\n            }\\n        }\\n        else if(sum%3==2){\\n            if(rem2.size()>0){\\n                rem2.pop_back();\\n            }\\n            else{\\n                rem1.pop_back();\\n                rem1.pop_back();\\n            }\\n        }\\n        priority_queue<int> pq;\\n        for(int i:rem1){\\n            pq.push(i);\\n        }\\n        for(int i:rem2){\\n            pq.push(i);\\n        }\\n        \\n        if(pq.empty() && rem0.size()>1 && rem0[0]==0){\\n            pq.push(0);\\n        }\\n        else{\\n            for(int i:rem0){\\n                pq.push(i);\\n            }\\n        }\\n        while(!pq.empty()){\\n            int x=pq.top();\\n            pq.pop();\\n            string t=to_string(x);\\n            ans+=t;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Math",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestMultipleOfThree(vector<int>& nums) {\\n        string ans=\"\";\\n        int n=nums.size(),sum=0;\\n        sort(nums.begin(),nums.end(),greater<int>());\\n        vector<int> rem0,rem1,rem2;\\n        for(auto i:nums){\\n            sum+=i;\\n            if(i%3==0){\\n                rem0.push_back(i);\\n            }\\n            else if(i%3==1){\\n                rem1.push_back(i);\\n            }\\n            else{\\n                rem2.push_back(i);\\n            }\\n        }\\n        \\n        if(sum%3==1){\\n            if(rem1.size()>0) rem1.pop_back();\\n            else{\\n                rem2.pop_back();\\n                rem2.pop_back();\\n            }\\n        }\\n        else if(sum%3==2){\\n            if(rem2.size()>0){\\n                rem2.pop_back();\\n            }\\n            else{\\n                rem1.pop_back();\\n                rem1.pop_back();\\n            }\\n        }\\n        priority_queue<int> pq;\\n        for(int i:rem1){\\n            pq.push(i);\\n        }\\n        for(int i:rem2){\\n            pq.push(i);\\n        }\\n        \\n        if(pq.empty() && rem0.size()>1 && rem0[0]==0){\\n            pq.push(0);\\n        }\\n        else{\\n            for(int i:rem0){\\n                pq.push(i);\\n            }\\n        }\\n        while(!pq.empty()){\\n            int x=pq.top();\\n            pq.pop();\\n            string t=to_string(x);\\n            ans+=t;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2498942,
                "title": "simple-if-else-mod-arithmetic-with-explanation-beats-98-5",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    // To make a multiple of 3 we need the sum of digits to be divisible by 3. \\n    \\n    // 0> If the (sum of digits)%3 == 0 we just sort the digits array in reverse and make a string out of it\\n    // Else we remove the smallest numbers such that the sum of remaining numbers become 0 MOD 3.\\n    \\n    // 1> If the (sum of digits)%3 == 1, we can remove 1, 4, 7 one time if any of them is present to make the final modulo 0.\\n    //  > Or we can remove a combination of 2 digits which are are 2 MOD 3, like (2, 5) because (2+5) MOD 3 = 1\\n    \\n    // 2> If the (sum of digits)%3 == 2, we can remove 2, 5, 8 one time if any of them is present to make the final modulo 0.\\n    //  > Or we can remove a combination of 2 digits which are are 1 MOD 3, like (1, 7) because (1+7) MOD 3 = 2\\n    \\n    //We enumerate the if/else a blocks in order such that removal of digits keeps the final output largest.\\n    \\n    string largestMultipleOfThree(vector<int>& digits) {\\n        \\n        vector<int> digMap(10, 0);\\n        \\n        int sum=0;\\n        for(int digit : digits){\\n            digMap[digit]++;\\n            sum = (sum+digit)%3;\\n        }\\n        \\n        if(sum == 1){\\n            \\n            if(digMap[1]){\\n                digMap[1]--;\\n            }\\n            else if(digMap[4]){\\n                digMap[4]--;\\n            }\\n            else if(digMap[7]){\\n                digMap[7]--;\\n            }\\n            else if(digMap[2]>=2){\\n                digMap[2]-=2;\\n            }\\n            else if(digMap[2] && digMap[5]){\\n                digMap[2]--;\\n                digMap[5]--;\\n            }\\n            else if(digMap[5]>=2){\\n                digMap[5]-=2;\\n            }\\n            else if(digMap[2] && digMap[8]){\\n                digMap[2]--;\\n                digMap[8]--;\\n            }\\n            else if(digMap[5] && digMap[8]){\\n                digMap[5]--;\\n                digMap[8]--;\\n            }\\n            else if(digMap[8]>=2){\\n                digMap[8]-=2;\\n            }\\n        }\\n        else if(sum==2){\\n            if(digMap[2]){\\n                digMap[2]--;\\n            }\\n            else if(digMap[5]){\\n                digMap[5]--;\\n            }\\n            else if(digMap[8]){\\n                digMap[8]--;\\n            }\\n            else if(digMap[1]>=2){\\n                digMap[1]-=2;\\n            }\\n            else if(digMap[1] && digMap[4]){\\n                digMap[1]--;\\n                digMap[4]--;\\n            }\\n            else if(digMap[4]>=2){\\n                digMap[4]-=2;\\n            }\\n            else if(digMap[1] && digMap[7]){\\n                digMap[1]--;\\n                digMap[7]--;\\n            }\\n            else if(digMap[4] && digMap[7]){\\n                digMap[4]--;\\n                digMap[7]--;\\n            }\\n            else if(digMap[7]>=2){\\n                digMap[7]-=2;\\n            }\\n        }\\n        \\n        string res;\\n        \\n        for(int i=9; i>=0; i--){\\n            if(digMap[i]){\\n                res += string(digMap[i], (char)(\\'0\\'+i));\\n            }\\n        }\\n        \\n        //Handle for all 0 case\\n        if(res[0]==\\'0\\' && res.back()==\\'0\\'){\\n            return \"0\";\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    // To make a multiple of 3 we need the sum of digits to be divisible by 3. \\n    \\n    // 0> If the (sum of digits)%3 == 0 we just sort the digits array in reverse and make a string out of it\\n    // Else we remove the smallest numbers such that the sum of remaining numbers become 0 MOD 3.\\n    \\n    // 1> If the (sum of digits)%3 == 1, we can remove 1, 4, 7 one time if any of them is present to make the final modulo 0.\\n    //  > Or we can remove a combination of 2 digits which are are 2 MOD 3, like (2, 5) because (2+5) MOD 3 = 1\\n    \\n    // 2> If the (sum of digits)%3 == 2, we can remove 2, 5, 8 one time if any of them is present to make the final modulo 0.\\n    //  > Or we can remove a combination of 2 digits which are are 1 MOD 3, like (1, 7) because (1+7) MOD 3 = 2\\n    \\n    //We enumerate the if/else a blocks in order such that removal of digits keeps the final output largest.\\n    \\n    string largestMultipleOfThree(vector<int>& digits) {\\n        \\n        vector<int> digMap(10, 0);\\n        \\n        int sum=0;\\n        for(int digit : digits){\\n            digMap[digit]++;\\n            sum = (sum+digit)%3;\\n        }\\n        \\n        if(sum == 1){\\n            \\n            if(digMap[1]){\\n                digMap[1]--;\\n            }\\n            else if(digMap[4]){\\n                digMap[4]--;\\n            }\\n            else if(digMap[7]){\\n                digMap[7]--;\\n            }\\n            else if(digMap[2]>=2){\\n                digMap[2]-=2;\\n            }\\n            else if(digMap[2] && digMap[5]){\\n                digMap[2]--;\\n                digMap[5]--;\\n            }\\n            else if(digMap[5]>=2){\\n                digMap[5]-=2;\\n            }\\n            else if(digMap[2] && digMap[8]){\\n                digMap[2]--;\\n                digMap[8]--;\\n            }\\n            else if(digMap[5] && digMap[8]){\\n                digMap[5]--;\\n                digMap[8]--;\\n            }\\n            else if(digMap[8]>=2){\\n                digMap[8]-=2;\\n            }\\n        }\\n        else if(sum==2){\\n            if(digMap[2]){\\n                digMap[2]--;\\n            }\\n            else if(digMap[5]){\\n                digMap[5]--;\\n            }\\n            else if(digMap[8]){\\n                digMap[8]--;\\n            }\\n            else if(digMap[1]>=2){\\n                digMap[1]-=2;\\n            }\\n            else if(digMap[1] && digMap[4]){\\n                digMap[1]--;\\n                digMap[4]--;\\n            }\\n            else if(digMap[4]>=2){\\n                digMap[4]-=2;\\n            }\\n            else if(digMap[1] && digMap[7]){\\n                digMap[1]--;\\n                digMap[7]--;\\n            }\\n            else if(digMap[4] && digMap[7]){\\n                digMap[4]--;\\n                digMap[7]--;\\n            }\\n            else if(digMap[7]>=2){\\n                digMap[7]-=2;\\n            }\\n        }\\n        \\n        string res;\\n        \\n        for(int i=9; i>=0; i--){\\n            if(digMap[i]){\\n                res += string(digMap[i], (char)(\\'0\\'+i));\\n            }\\n        }\\n        \\n        //Handle for all 0 case\\n        if(res[0]==\\'0\\' && res.back()==\\'0\\'){\\n            return \"0\";\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1104210,
                "title": "c-solution-with-explanation",
                "content": "```\\n    /*\\n     * A number is a multiple of three if and only if its sum of digits is a multiple of\\n     * three.\\n     * Eg: 555 is divisible by 3, the sum of digits is divisible by 3 i.e.., 5+5+5 = 15\\n     * \\n     * If the number is not divisible by 3, then the max remainder will be either 1 or 2.\\n     * If remainder is either 1 or 2, then max 2 digits needs to be removed from the input\\n     * string so that the number is divisible by 3\\n     *\\n     * If the remainder is 1, then remove the smallest number that has remainder 1 or 2\\n     * digits that has remainder 2 (eg: 2 + 2 = 4%3 =1)\\n     * If the remainder is 2, then remove the smallest number that has remainder 2 or 2\\n     * digits that has remainder 1 (eg: 1 + 1 = 3%3 = 1)\\n    */    \\n    string largestMultipleOfThree(vector<int>& digits) {\\n        if (digits.empty()) {\\n            // If there are no digits then\\n            return \"\";\\n        }\\n\\n        // Sort the numbers in the vector so that smallest number will be in the starting\\n        // index\\n        std::sort(digits.begin(), digits.end());\\n\\n        // variable to hold the result\\n        string res = \"\";\\n\\n        int sum = 0;\\n        // Find the sum of the digits\\n        // Also store the number in the string for attaining the result\\n        for (int digit : digits) {\\n            sum += digit;\\n            res += \\'0\\' + digit;\\n        }\\n\\n        // Calculate the remainder of the sum by divinding with 3\\n        int remainder = sum % 3;\\n\\n        if (remainder == 0) {\\n            // If the remainder 0 ie.., the number is divisible by 3, return the number\\n            std::reverse(res.begin(), res.end());\\n\\n            return res[0] == \\'0\\' ? \"0\" : res;\\n        }\\n\\n        // Remainder is either 1 or 2, remove one digit which equals the remainder or\\n        // removing 2 digits whose remainder equals 1 if ip remainder is 2 or remove 2\\n        // digits whose remainder equals 2 if ip remainder is 1\\n\\n        // variables to store the index of the 2 digits that need to be removed\\n        int index[2] = { -1, -1 };\\n\\n        // Loop for all digits and try to remove the digits\\n        for (int i = 0; i < res.length(); i++) {\\n            if (res[i] % 3 == remainder) {\\n                // Smallest number whose remainder is equals the input remainder\\n                // Remove the digit from the result and return\\n                res.erase(i, 1);\\n                std::reverse(res.begin(), res.end());\\n                return res;\\n            }\\n\\n            if (res[i] % 3 == (remainder == 1 ? 2 : 1)) {\\n                (index[0] == -1 ? index[0] : index[1]) = i;\\n            }\\n        }\\n\\n        if (index[0] != -1 && index[1] != -1) {\\n            // Got the 2 numbers that need to be removed\\n            // Remove from the result and return\\n            res.erase(index[1], 1);\\n            res.erase(index[0], 1);\\n            std::reverse(res.begin(), res.end());\\n        }\\n\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    /*\\n     * A number is a multiple of three if and only if its sum of digits is a multiple of\\n     * three.\\n     * Eg: 555 is divisible by 3, the sum of digits is divisible by 3 i.e.., 5+5+5 = 15\\n     * \\n     * If the number is not divisible by 3, then the max remainder will be either 1 or 2.\\n     * If remainder is either 1 or 2, then max 2 digits needs to be removed from the input\\n     * string so that the number is divisible by 3\\n     *\\n     * If the remainder is 1, then remove the smallest number that has remainder 1 or 2\\n     * digits that has remainder 2 (eg: 2 + 2 = 4%3 =1)\\n     * If the remainder is 2, then remove the smallest number that has remainder 2 or 2\\n     * digits that has remainder 1 (eg: 1 + 1 = 3%3 = 1)\\n    */    \\n    string largestMultipleOfThree(vector<int>& digits) {\\n        if (digits.empty()) {\\n            // If there are no digits then\\n            return \"\";\\n        }\\n\\n        // Sort the numbers in the vector so that smallest number will be in the starting\\n        // index\\n        std::sort(digits.begin(), digits.end());\\n\\n        // variable to hold the result\\n        string res = \"\";\\n\\n        int sum = 0;\\n        // Find the sum of the digits\\n        // Also store the number in the string for attaining the result\\n        for (int digit : digits) {\\n            sum += digit;\\n            res += \\'0\\' + digit;\\n        }\\n\\n        // Calculate the remainder of the sum by divinding with 3\\n        int remainder = sum % 3;\\n\\n        if (remainder == 0) {\\n            // If the remainder 0 ie.., the number is divisible by 3, return the number\\n            std::reverse(res.begin(), res.end());\\n\\n            return res[0] == \\'0\\' ? \"0\" : res;\\n        }\\n\\n        // Remainder is either 1 or 2, remove one digit which equals the remainder or\\n        // removing 2 digits whose remainder equals 1 if ip remainder is 2 or remove 2\\n        // digits whose remainder equals 2 if ip remainder is 1\\n\\n        // variables to store the index of the 2 digits that need to be removed\\n        int index[2] = { -1, -1 };\\n\\n        // Loop for all digits and try to remove the digits\\n        for (int i = 0; i < res.length(); i++) {\\n            if (res[i] % 3 == remainder) {\\n                // Smallest number whose remainder is equals the input remainder\\n                // Remove the digit from the result and return\\n                res.erase(i, 1);\\n                std::reverse(res.begin(), res.end());\\n                return res;\\n            }\\n\\n            if (res[i] % 3 == (remainder == 1 ? 2 : 1)) {\\n                (index[0] == -1 ? index[0] : index[1]) = i;\\n            }\\n        }\\n\\n        if (index[0] != -1 && index[1] != -1) {\\n            // Got the 2 numbers that need to be removed\\n            // Remove from the result and return\\n            res.erase(index[1], 1);\\n            res.erase(index[0], 1);\\n            std::reverse(res.begin(), res.end());\\n        }\\n\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1015362,
                "title": "c-o-n-faster-than-95-memory-less-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    string largestMultipleOfThree(vector<int>& digits) {\\n        \\n        int r1=0, r2=0;\\n        \\n        for(auto itr:digits)\\n        {\\n            if(itr%3==2)\\n                r2++;\\n            else if(itr%3==1)\\n                r1++;\\n        }\\n        unordered_map<int,int>um;\\n        for(auto itr:digits)\\n            um[itr]++;\\n        \\n        \\n        int remove= (r1 + r2*2)%3;\\n        if(r2>0 && r1==0)\\n            remove=-1;\\n        \\n        if(remove>0)\\n        {\\n            int i;\\n            for(i=0;i<=9;i++)\\n                if(i%3==remove && um.find(i)!=um.end())\\n                {\\n                    um[i]--;\\n                    break;\\n                }\\n            if(i==10)\\n                return \"\";\\n        }\\n        else if(remove==-1)\\n        {\\n           for(int i=0;i<=9;i++)\\n              if(i%3==2 && um.find(i)!=um.end())\\n              {\\n                  um[i]=0;\\n              }\\n        }\\n        string res=\"\";\\n        \\n        for(int i=9;i>=0;i--)\\n        {\\n            if(um.find(i)!=um.end())\\n            {\\n                while(um[i]--)\\n                    res+=to_string(i);\\n            }\\n        }\\n        if(res[0]==\\'0\\')\\n            return \"0\";\\n        else\\n            return res;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    string largestMultipleOfThree(vector<int>& digits) {\\n        \\n        int r1=0, r2=0;\\n        \\n        for(auto itr:digits)\\n        {\\n            if(itr%3==2)\\n                r2++;\\n            else if(itr%3==1)\\n                r1++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 999391,
                "title": "java-dp-can-be-extended-for-9",
                "content": "I like the Math solution. But what if the question is asking for **Largest Multiple of Nine**\\n```\\nclass Solution\\n{\\n    public String largestMultipleOfThree(int[] digits)\\n    {\\n        digits = Arrays.stream(digits).boxed().sorted((a, b) -> (b - a)).mapToInt(i -> i).toArray();\\n        String[] strs = new String[3];\\n        Arrays.fill(strs, \"\");\\n        for (int i = 0; i < digits.length; i++)\\n        {\\n            int digit = digits[i];\\n            String[] strsCopy = Arrays.stream(strs).toArray(String[]::new);\\n            int mod = digit % 3;\\n            for (int j = 0; j < 3; j++)\\n            {\\n                String prevStr = strsCopy[j];\\n                if (prevStr.length() == 0 && j == mod)\\n                {\\n                    strs[mod] = getMax(String.valueOf(digit), strs[mod]);\\n                }\\n                else if (prevStr.length() > 0)\\n                {\\n                    strs[(j + mod) % 3] = getMax(strsCopy[(j + mod) % 3], prevStr + String.valueOf(digit));\\n                }\\n            }\\n        }\\n        return strs[0].startsWith(\"0\") ? \"0\" : strs[0];\\n    }\\n    \\n    private String getMax(String str1, String str2)\\n    {\\n        if (str1.length() > str2.length())\\n        {\\n            return str1;\\n        }\\n        else if (str2.length() > str1.length())\\n        {\\n            return str2;\\n        }\\n        return str1.compareTo(str2) == 1 ? str1 : str2;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n{\\n    public String largestMultipleOfThree(int[] digits)\\n    {\\n        digits = Arrays.stream(digits).boxed().sorted((a, b) -> (b - a)).mapToInt(i -> i).toArray();\\n        String[] strs = new String[3];\\n        Arrays.fill(strs, \"\");\\n        for (int i = 0; i < digits.length; i++)\\n        {\\n            int digit = digits[i];\\n            String[] strsCopy = Arrays.stream(strs).toArray(String[]::new);\\n            int mod = digit % 3;\\n            for (int j = 0; j < 3; j++)\\n            {\\n                String prevStr = strsCopy[j];\\n                if (prevStr.length() == 0 && j == mod)\\n                {\\n                    strs[mod] = getMax(String.valueOf(digit), strs[mod]);\\n                }\\n                else if (prevStr.length() > 0)\\n                {\\n                    strs[(j + mod) % 3] = getMax(strsCopy[(j + mod) % 3], prevStr + String.valueOf(digit));\\n                }\\n            }\\n        }\\n        return strs[0].startsWith(\"0\") ? \"0\" : strs[0];\\n    }\\n    \\n    private String getMax(String str1, String str2)\\n    {\\n        if (str1.length() > str2.length())\\n        {\\n            return str1;\\n        }\\n        else if (str2.length() > str1.length())\\n        {\\n            return str2;\\n        }\\n        return str1.compareTo(str2) == 1 ? str1 : str2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 840937,
                "title": "concise-python-dp-solution",
                "content": "```\\ndef largestMultipleOfThree(self, a: List[int]) -> str:\\n    n, dp = len(a), [\\'\\'] * 3\\n    a.sort(reverse=True)\\n    for i in range(n):\\n        d, dp1 = a[i] % 3, [\\'\\'] * 3\\n        for j in range(3): \\n            k = (j-d) % 3\\n            dp1[j] = max([dp[k] + str(a[i]) if dp[k] or k==0 else \\'\\', dp[j]], key=lambda x: (len(x), x))\\n            if len(dp1[j]) >= 2 and dp1[j][0] == \\'0\\': dp1[j] = dp1[j][1:]\\n        dp = dp1            \\n    return dp[0]",
                "solutionTags": [],
                "code": "```\\ndef largestMultipleOfThree(self, a: List[int]) -> str:\\n    n, dp = len(a), [\\'\\'] * 3\\n    a.sort(reverse=True)\\n    for i in range(n):\\n        d, dp1 = a[i] % 3, [\\'\\'] * 3\\n        for j in range(3): \\n            k = (j-d) % 3\\n            dp1[j] = max([dp[k] + str(a[i]) if dp[k] or k==0 else \\'\\', dp[j]], key=lambda x: (len(x), x))\\n            if len(dp1[j]) >= 2 and dp1[j][0] == \\'0\\': dp1[j] = dp1[j][1:]\\n        dp = dp1            \\n    return dp[0]",
                "codeTag": "Python3"
            },
            {
                "id": 556096,
                "title": "concise-python-14-lines-solution",
                "content": "```\\nclass Solution:\\n    def largestMultipleOfThree(self, digits: List[int]) -> str:\\n        digits, tot, cnt = sorted(digits, reverse=1), sum(digits), collections.Counter(digits)\\n        residuals = [[], [1,4,7], [2,5,8], []]\\n        def tryIt(tot, f):\\n            r = tot % 3 if not f else (3 - tot % 3)\\n            for l in residuals[r]:\\n                while tot % 3 != 0 and cnt[l]:\\n                    tot -= l\\n                    cnt[l] -= 1\\n            return tot        \\n        tryIt(tryIt(tot, 0), 1)\\n        ret = \\'\\'.join([str(c) * cnt[c] for c in [9,8,7,6,5,4,3,2,1,0] if cnt[c]])\\n        return \\'\\' if not ret else \\'0\\' if ret[0] == \\'0\\' else ret\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def largestMultipleOfThree(self, digits: List[int]) -> str:\\n        digits, tot, cnt = sorted(digits, reverse=1), sum(digits), collections.Counter(digits)\\n        residuals = [[], [1,4,7], [2,5,8], []]\\n        def tryIt(tot, f):\\n            r = tot % 3 if not f else (3 - tot % 3)\\n            for l in residuals[r]:\\n                while tot % 3 != 0 and cnt[l]:\\n                    tot -= l\\n                    cnt[l] -= 1\\n            return tot        \\n        tryIt(tryIt(tot, 0), 1)\\n        ret = \\'\\'.join([str(c) * cnt[c] for c in [9,8,7,6,5,4,3,2,1,0] if cnt[c]])\\n        return \\'\\' if not ret else \\'0\\' if ret[0] == \\'0\\' else ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 519005,
                "title": "clean-python-3-counting-sort-o-n-o-1-time-space-100",
                "content": "Refer to the insight of **@lee215** in [his post](https://leetcode.com/problems/largest-multiple-of-three/discuss/517628/Python-Basic-Math), we can make it in O(N)/O(1) time/space.\\nCount each digits and remove corresponding remainder from smaller one if needed.\\nThen dump rest digits by their counts.\\n\\nTime: O(N) for count and dump\\nSpace: O(1) because we only need a list of size 10\\n```\\nclass Solution:\\n    def largestMultipleOfThree(self, digits: List[int]) -> str:\\n        def dump(r: int) -> str:\\n            if r:\\n                for i in range(3):\\n                    idx = 3 * i + r\\n                    if counts[idx]:\\n                        counts[idx] -= 1\\n                        break\\n                else:\\n                    rest = 2\\n                    for j in range(3):\\n                        idx = 3 * j + (-r % 3)\\n                        while rest and counts[idx]:\\n                            counts[idx] -= 1\\n                            rest -= 1\\n                        if not rest: break\\n                    if rest: return \\'\\'\\n            if any(counts):\\n                result = \\'\\'\\n                for i in reversed(range(10)):\\n                    result += str(i) * counts[i]\\n                return str(int(result))\\n            return \\'\\'\\n\\n        total, counts = 0, [0] * 10\\n        for digit in digits:\\n            counts[digit] += 1\\n            total += digit\\n        return dump(total % 3)\\n```",
                "solutionTags": [
                    "Python3",
                    "Counting Sort"
                ],
                "code": "```\\nclass Solution:\\n    def largestMultipleOfThree(self, digits: List[int]) -> str:\\n        def dump(r: int) -> str:\\n            if r:\\n                for i in range(3):\\n                    idx = 3 * i + r\\n                    if counts[idx]:\\n                        counts[idx] -= 1\\n                        break\\n                else:\\n                    rest = 2\\n                    for j in range(3):\\n                        idx = 3 * j + (-r % 3)\\n                        while rest and counts[idx]:\\n                            counts[idx] -= 1\\n                            rest -= 1\\n                        if not rest: break\\n                    if rest: return \\'\\'\\n            if any(counts):\\n                result = \\'\\'\\n                for i in reversed(range(10)):\\n                    result += str(i) * counts[i]\\n                return str(int(result))\\n            return \\'\\'\\n\\n        total, counts = 0, [0] * 10\\n        for digit in digits:\\n            counts[digit] += 1\\n            total += digit\\n        return dump(total % 3)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 518554,
                "title": "java-sol",
                "content": "```\\nclass Solution {\\n    public String largestMultipleOfThree(int[] digits) {\\n        StringBuilder ans=new StringBuilder();\\n        Arrays.sort(digits);\\n        int sum=0;\\n        for(int n:digits)sum+=n;\\n        int remain=sum%3;\\n        if(remain==0){\\n            if(digits[digits.length-1]==0)return \"0\";\\n            for(int i=digits.length-1;i>=0;i--)ans.append(\"\"+digits[i]);\\n            return ans.toString();\\n        }\\n        Map<Integer,Integer>map=new HashMap<>();\\n        Map<Integer,Integer>ban=new HashMap<>();\\n        for(int i=0;i<digits.length;i++){\\n            int m=digits[i]%3;\\n            int complement=(remain-m);\\n            if(complement==0){\\n                if(ban.size()!=0)ban=new HashMap<>();\\n                ban.put(digits[i],1);\\n                break;\\n            }\\n            if(complement<0)complement+=3;\\n            if(map.containsKey(complement)&&ban.size()==0){\\n                ban.put(map.get(complement),1);\\n                if(ban.containsKey(digits[i])){\\n                    ban.put(digits[i],2);   \\n                }else{\\n                    ban.put(digits[i],1);   \\n                }\\n            }\\n            if(map.containsKey(m)){\\n            }else{\\n                map.put(m,digits[i]);\\n            }\\n        }\\n        if(ban.size()==0)return \"\";\\n        for(int i=digits.length-1;i>=0;i--){\\n            int n=digits[i];\\n            if(ban.containsKey(n)){\\n                ban.put(n,ban.get(n)-1);\\n                if(ban.get(n)==0)ban.remove(n);\\n                continue;\\n            }\\n            ans.append(n+\"\");\\n        }\\n        return ans.toString(); \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String largestMultipleOfThree(int[] digits) {\\n        StringBuilder ans=new StringBuilder();\\n        Arrays.sort(digits);\\n        int sum=0;\\n        for(int n:digits)sum+=n;\\n        int remain=sum%3;\\n        if(remain==0){\\n            if(digits[digits.length-1]==0)return \"0\";\\n            for(int i=digits.length-1;i>=0;i--)ans.append(\"\"+digits[i]);\\n            return ans.toString();\\n        }\\n        Map<Integer,Integer>map=new HashMap<>();\\n        Map<Integer,Integer>ban=new HashMap<>();\\n        for(int i=0;i<digits.length;i++){\\n            int m=digits[i]%3;\\n            int complement=(remain-m);\\n            if(complement==0){\\n                if(ban.size()!=0)ban=new HashMap<>();\\n                ban.put(digits[i],1);\\n                break;\\n            }\\n            if(complement<0)complement+=3;\\n            if(map.containsKey(complement)&&ban.size()==0){\\n                ban.put(map.get(complement),1);\\n                if(ban.containsKey(digits[i])){\\n                    ban.put(digits[i],2);   \\n                }else{\\n                    ban.put(digits[i],1);   \\n                }\\n            }\\n            if(map.containsKey(m)){\\n            }else{\\n                map.put(m,digits[i]);\\n            }\\n        }\\n        if(ban.size()==0)return \"\";\\n        for(int i=digits.length-1;i>=0;i--){\\n            int n=digits[i];\\n            if(ban.containsKey(n)){\\n                ban.put(n,ban.get(n)-1);\\n                if(ban.get(n)==0)ban.remove(n);\\n                continue;\\n            }\\n            ans.append(n+\"\");\\n        }\\n        return ans.toString(); \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 517964,
                "title": "python-frequency-based-no-sorting-required-o-n-time-o-1-space",
                "content": "1. Count occurences of each digit and the total sum\\n2. If ```total % 3 == 0``` we can use all digits\\n3. If ```total % 3 == 1 ```  we remove one of the smallest digit leading to 1 after a modulo 3 or 2 of the smallest digits leading to 2 after modulo 3\\n4.  If ```total % 3 == 2 ```  we remove one of the smallest digit leading to 2 after a modulo 3 or 2 of the smallest digits leading to 1 after modulo 3\\n5.  Construct the solution based on the modified frequencies, by iterating from largest digit to smallest one\\n\\n**Python**\\n```\\ndef largestMultipleOfThree(self, digits: List[int]) -> str:\\n        total = sum(digits)%3     \\n        freq = collections.Counter(digits)\\n        parts = {1: [1,4,7], 2: [2,5,8]}\\n        nMod  = {1: freq[1] + freq[4] + freq[7], 2: freq[2] + freq[5] + freq[8]}\\n        \\n        if(freq[0] == len(digits)):\\n            return \\'0\\'\\n        \\n        def modifyFrequency(freq,liste,nIteration):\\n            for num in liste:\\n                while(freq[num] > 0):\\n                    freq[num] -= 1\\n                    nIteration -= 1\\n                    if(nIteration == 0):\\n                        return\\n\\n        if(total > 0):\\n            if(nMod[total] > 0):\\n                modifyFrequency(freq,parts[total],1)\\n            elif(nMod[3-total] > 1):\\n                modifyFrequency(freq,parts[3-total],2)\\n            else:\\n                return \\'\\'\\n        \\n        return \\'\\'.join([str(x) for i in reversed(range(10)) if i in freq for x in [i]*freq[i]])\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```total % 3 == 0```\n```total % 3 == 1 ```\n```total % 3 == 2 ```\n```\\ndef largestMultipleOfThree(self, digits: List[int]) -> str:\\n        total = sum(digits)%3     \\n        freq = collections.Counter(digits)\\n        parts = {1: [1,4,7], 2: [2,5,8]}\\n        nMod  = {1: freq[1] + freq[4] + freq[7], 2: freq[2] + freq[5] + freq[8]}\\n        \\n        if(freq[0] == len(digits)):\\n            return \\'0\\'\\n        \\n        def modifyFrequency(freq,liste,nIteration):\\n            for num in liste:\\n                while(freq[num] > 0):\\n                    freq[num] -= 1\\n                    nIteration -= 1\\n                    if(nIteration == 0):\\n                        return\\n\\n        if(total > 0):\\n            if(nMod[total] > 0):\\n                modifyFrequency(freq,parts[total],1)\\n            elif(nMod[3-total] > 1):\\n                modifyFrequency(freq,parts[3-total],2)\\n            else:\\n                return \\'\\'\\n        \\n        return \\'\\'.join([str(x) for i in reversed(range(10)) if i in freq for x in [i]*freq[i]])\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 517934,
                "title": "python-simple-solution",
                "content": "```python\\nclass Solution(object):\\n    def largestMultipleOfThree(self, digits):\\n        # A number is divisible by 3 if the sum of its digits is also divisible by 3\\n        remainder = sum(digits) % 3\\n        while remainder != 0:\\n            digit_to_remove, min_non_divisible = float(\\'inf\\'), float(\\'inf\\')\\n            for digit in digits:\\n                if digit % 3 == remainder:\\n                    digit_to_remove = min(digit, digit_to_remove)\\n                elif digit % 3 != 0:\\n                    min_non_divisible = min(digit, min_non_divisible)\\n            if digit_to_remove < float(\\'inf\\'):\\n                # Found a digit mod 3 that equals our remainder\\n                digits.remove(digit_to_remove)\\n                break\\n            else:\\n                # Work our way to finding a solution by removing \\n                # the smallest non-divisible-by-3 digit in our list\\n                digits.remove(min_non_divisible)\\n                remainder = sum(digits) % 3\\n        digits = sorted(digits, reverse=True)\\n        return str(int(\\'\\'.join(str(digit) for digit in digits))) if digits else \\'\\'\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Greedy"
                ],
                "code": "```python\\nclass Solution(object):\\n    def largestMultipleOfThree(self, digits):\\n        # A number is divisible by 3 if the sum of its digits is also divisible by 3\\n        remainder = sum(digits) % 3\\n        while remainder != 0:\\n            digit_to_remove, min_non_divisible = float(\\'inf\\'), float(\\'inf\\')\\n            for digit in digits:\\n                if digit % 3 == remainder:\\n                    digit_to_remove = min(digit, digit_to_remove)\\n                elif digit % 3 != 0:\\n                    min_non_divisible = min(digit, min_non_divisible)\\n            if digit_to_remove < float(\\'inf\\'):\\n                # Found a digit mod 3 that equals our remainder\\n                digits.remove(digit_to_remove)\\n                break\\n            else:\\n                # Work our way to finding a solution by removing \\n                # the smallest non-divisible-by-3 digit in our list\\n                digits.remove(min_non_divisible)\\n                remainder = sum(digits) % 3\\n        digits = sorted(digits, reverse=True)\\n        return str(int(\\'\\'.join(str(digit) for digit in digits))) if digits else \\'\\'\\n```",
                "codeTag": "Java"
            },
            {
                "id": 517860,
                "title": "java-o-n-solution-based-on-bucket-sort",
                "content": "Idea based on https://leetcode.com/problems/largest-multiple-of-three/discuss/517704/Java-Simple-Basic-Multiple-3 but I use bucket sort:\\n\\n```\\npublic String largestMultipleOfThree(int[] digits) {\\n        int[] buckets = new int[10];\\n        int sum = 0;\\n        for (int v : digits) {\\n            buckets[v]++;\\n            sum += v;\\n        }\\n        \\n        int[] numSet1 = {1, 4, 7};\\n        int[] numSet2 = {2, 5, 8};\\n        if (sum % 3 == 1) {\\n            removeHelper(buckets, numSet1, numSet2);\\n        } else if (sum % 3 == 2) {\\n            removeHelper(buckets, numSet2, numSet1);\\n        }\\n        \\n        StringBuilder result = new StringBuilder();\\n        for (int i = 9; i >= 0; i--) {\\n            if (buckets[i] > 0) {\\n                while (buckets[i] > 0) {\\n                    result.append(i);\\n                    buckets[i]--;\\n                }\\n            }\\n        }\\n        \\n        int p = 0;\\n        while (p < result.length() - 1 && result.charAt(p) == \\'0\\') {\\n            p++;\\n        }\\n        \\n        return result.substring(p);\\n    }\\n    \\n    public void removeHelper(int[] buckets, int[] remove1Set, int[] remove2Set) {\\n        int counter = 0;\\n        for (int num : remove1Set) {\\n            if (buckets[num] > 0) {\\n                buckets[num]--;\\n                counter = 1;\\n                break;\\n            }\\n        }\\n\\n        if (counter == 0) {\\n            for (int num : remove2Set) {\\n                if (buckets[num] >= 2) {\\n                    buckets[num] -= 2;\\n                    counter = 2;\\n                } else if (buckets[num] == 1) {\\n                    buckets[num] = 0;\\n                    counter++;\\n                }\\n\\n                if (counter == 2) {\\n                    break;\\n                }\\n            }\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic String largestMultipleOfThree(int[] digits) {\\n        int[] buckets = new int[10];\\n        int sum = 0;\\n        for (int v : digits) {\\n            buckets[v]++;\\n            sum += v;\\n        }\\n        \\n        int[] numSet1 = {1, 4, 7};\\n        int[] numSet2 = {2, 5, 8};\\n        if (sum % 3 == 1) {\\n            removeHelper(buckets, numSet1, numSet2);\\n        } else if (sum % 3 == 2) {\\n            removeHelper(buckets, numSet2, numSet1);\\n        }\\n        \\n        StringBuilder result = new StringBuilder();\\n        for (int i = 9; i >= 0; i--) {\\n            if (buckets[i] > 0) {\\n                while (buckets[i] > 0) {\\n                    result.append(i);\\n                    buckets[i]--;\\n                }\\n            }\\n        }\\n        \\n        int p = 0;\\n        while (p < result.length() - 1 && result.charAt(p) == \\'0\\') {\\n            p++;\\n        }\\n        \\n        return result.substring(p);\\n    }\\n    \\n    public void removeHelper(int[] buckets, int[] remove1Set, int[] remove2Set) {\\n        int counter = 0;\\n        for (int num : remove1Set) {\\n            if (buckets[num] > 0) {\\n                buckets[num]--;\\n                counter = 1;\\n                break;\\n            }\\n        }\\n\\n        if (counter == 0) {\\n            for (int num : remove2Set) {\\n                if (buckets[num] >= 2) {\\n                    buckets[num] -= 2;\\n                    counter = 2;\\n                } else if (buckets[num] == 1) {\\n                    buckets[num] = 0;\\n                    counter++;\\n                }\\n\\n                if (counter == 2) {\\n                    break;\\n                }\\n            }\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 517675,
                "title": "my-thought-process-and-solution-under-30-lines",
                "content": "Thought process:\\nWe want to always put the largest number on the most advanced digit, while keeping as many digits as possible under the constraint that the sum of all digits need to satisfy sum%3 ==0. \\nThe first for loop tries to remove each digit to make the remaining sum to satisfy sum%3 ==0.\\nNow initially I simply removed the smallest number if after the first for loop, which failed at test case [9,8,8,6,6]. So I replaced the remove line with a for loop to find the smallest number that does not satisfy num%3 ==0 and remove it.\\n\\nCorner case: If the largest number in the array is 0, we should print \"0\".\\n\\nHere is my code in C#:\\n```\\npublic class Solution {\\n    public string LargestMultipleOfThree(int[] digits) {\\n        var len = digits.Length;\\n        var d = digits.ToList();\\n        d.Sort();\\n        if(d[len-1] == 0) return \"0\";\\n        while(d.Count()>0 ){\\n            var s = d.Sum();\\n            var m = s %3;\\n            if(m ==0){\\n                d.Reverse();\\n                return new string(d.Select(i=> i.ToString()[0]).ToArray());\\n            }\\n            for(int i = 0; i< d.Count(); i++){\\n                if ((s-d[i])%3 ==0){\\n                    d.RemoveAt(i);\\n                    d.Reverse();\\n                    return new string(d.Select(f=> f.ToString()[0]).ToArray());\\n                }\\n            }\\n            for(int i = 0; i< d.Count(); i++){\\n                if (d[i]%3 != 0){\\n                    d.RemoveAt(i);\\n                    break;\\n                }\\n            }\\n        }\\n        return string.Empty;\\n    }\\n}\\n```\\n\\nEdit 2/23/2020: Credit to comment below, added break in the second for loop.",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\npublic class Solution {\\n    public string LargestMultipleOfThree(int[] digits) {\\n        var len = digits.Length;\\n        var d = digits.ToList();\\n        d.Sort();\\n        if(d[len-1] == 0) return \"0\";\\n        while(d.Count()>0 ){\\n            var s = d.Sum();\\n            var m = s %3;\\n            if(m ==0){\\n                d.Reverse();\\n                return new string(d.Select(i=> i.ToString()[0]).ToArray());\\n            }\\n            for(int i = 0; i< d.Count(); i++){\\n                if ((s-d[i])%3 ==0){\\n                    d.RemoveAt(i);\\n                    d.Reverse();\\n                    return new string(d.Select(f=> f.ToString()[0]).ToArray());\\n                }\\n            }\\n            for(int i = 0; i< d.Count(); i++){\\n                if (d[i]%3 != 0){\\n                    d.RemoveAt(i);\\n                    break;\\n                }\\n            }\\n        }\\n        return string.Empty;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 517585,
                "title": "c-case-analysis-o-n",
                "content": "Let\\'s start with a simple theorem in the number theory. A number is divisible by 3 if and only if the sum of all digits is divisible by 3. We can sort digits in three categories - remainders 0, 1, and 2, and we only care about the last two categories (noted as c1 and c2 in the following context) since we can use the first category as much as we can.\\n\\nSuppose we have have a bunch of c1 and c2, we can first use them as much as we can by the greedy algorithm (i.e. use 3 of c1 or 3 of c2). If we have one of c1 and two of c2 / two of c1 and one of c2, we can further get a pair of c1 and c2. And thus, by the analysis above, we only have four cases left to handle\\n\\n* General rule: digits to delete are as small as possible.\\n* one of c2\\n\\t* We either delete one digit in c2 or two digits in c1 (if possible). Since we always want more digits, we just delete one digit in c2.\\n* two of c2\\n\\t* We either delete two digits in c2 or one digit in c1 (if possible). First, we try to delete one digit in c1. If that is impossible, we delete two digits in c2.\\n* one of c1\\n\\t* We either delete one digit in c1 or two digits in c2 (if possible). Since we always want more digits, we just delete one digit in c1.\\n* two of c1\\n\\t* We either delete two digits in c1 or one digit in c2 (if possible). First, we try to delete one digit in c2. If that is impossible, we delete two digits in c1.\\n\\nAt this points, the sum of all digits is divisible by 3, and we construct the number.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    void f(vector<int>& ds, const vector<int>& m) {\\n        // helper function, to remove 2 digits\\n        int c(2);\\n        for (const int& d: m)\\n            while (ds[d] && c) {\\n                ds[d]--;\\n                c--;\\n            }\\n    }\\n    \\n    string largestMultipleOfThree(vector<int>& digits) {\\n        \\n        // m1 = {d : d % 3 == 1}\\n        // m2 = {d : d % 3 == 2}\\n        const vector<int> m1({1, 4, 7}), m2({2, 5, 8});\\n        vector<int> ds(10);\\n        int ones(0), twos(0);\\n        string ans;\\n        \\n        for (const int& d: digits) ds[d]++;\\n        for (const int& d: m1) ones += ds[d];\\n        for (const int& d: m2) twos += ds[d];\\n        \\n        ones %= 3;\\n        twos %= 3;\\n        if (ones && twos) {\\n            ones--;\\n            twos--;\\n        }\\n        \\n        // analyze four cases\\n        if (ones == 0 && twos == 1)\\n            ds[ds[2] ? 2 : ds[5] ? 5 : 8]--;\\n        else if (ones == 0 && twos == 2) {\\n            // remove 1 min of ones if possible\\n            // otherwise remove 2 mins of twos\\n            int temp = ds[1] ? 1 : ds[4] ? 4 : ds[7] ? 7 : 0;\\n            if (temp) ds[temp]--;\\n            else f(ds, m2);\\n        } else if (ones == 1 && twos == 0)\\n            ds[ds[1] ? 1 : ds[4] ? 4 : 7]--;\\n        else if (ones == 2 && twos == 0) {\\n            // remove 1 min of twos if possible\\n            // otherwise remove 2 mins of ones\\n            int temp = ds[2] ? 2 : ds[5] ? 5 : ds[8] ? 8 : 0;\\n            if (temp) ds[temp]--;\\n            else f(ds, m1);\\n        }\\n    \\n        for (int i = 9; i >= 1; i--)\\n            while (ds[i]--)\\n                ans += \\'0\\' + i;\\n        \\n        // avoid leading zeros\\n        if (ans.empty()) {\\n            if (ds[0]) ans += \\'0\\';\\n        } else {\\n            while (ds[0]--) ans += \\'0\\';\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    void f(vector<int>& ds, const vector<int>& m) {\\n        // helper function, to remove 2 digits\\n        int c(2);\\n        for (const int& d: m)\\n            while (ds[d] && c) {\\n                ds[d]--;\\n                c--;\\n            }\\n    }\\n    \\n    string largestMultipleOfThree(vector<int>& digits) {\\n        \\n        // m1 = {d : d % 3 == 1}\\n        // m2 = {d : d % 3 == 2}\\n        const vector<int> m1({1, 4, 7}), m2({2, 5, 8});\\n        vector<int> ds(10);\\n        int ones(0), twos(0);\\n        string ans;\\n        \\n        for (const int& d: digits) ds[d]++;\\n        for (const int& d: m1) ones += ds[d];\\n        for (const int& d: m2) twos += ds[d];\\n        \\n        ones %= 3;\\n        twos %= 3;\\n        if (ones && twos) {\\n            ones--;\\n            twos--;\\n        }\\n        \\n        // analyze four cases\\n        if (ones == 0 && twos == 1)\\n            ds[ds[2] ? 2 : ds[5] ? 5 : 8]--;\\n        else if (ones == 0 && twos == 2) {\\n            // remove 1 min of ones if possible\\n            // otherwise remove 2 mins of twos\\n            int temp = ds[1] ? 1 : ds[4] ? 4 : ds[7] ? 7 : 0;\\n            if (temp) ds[temp]--;\\n            else f(ds, m2);\\n        } else if (ones == 1 && twos == 0)\\n            ds[ds[1] ? 1 : ds[4] ? 4 : 7]--;\\n        else if (ones == 2 && twos == 0) {\\n            // remove 1 min of twos if possible\\n            // otherwise remove 2 mins of ones\\n            int temp = ds[2] ? 2 : ds[5] ? 5 : ds[8] ? 8 : 0;\\n            if (temp) ds[temp]--;\\n            else f(ds, m1);\\n        }\\n    \\n        for (int i = 9; i >= 1; i--)\\n            while (ds[i]--)\\n                ans += \\'0\\' + i;\\n        \\n        // avoid leading zeros\\n        if (ans.empty()) {\\n            if (ds[0]) ans += \\'0\\';\\n        } else {\\n            while (ds[0]--) ans += \\'0\\';\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 517583,
                "title": "javascript-3-solutions-w-explanation",
                "content": "\\n```javascript\\n// EASY TO UNDERSTAND\\n// Time: O(nlogn)\\n// Space: O(n)\\nvar largestMultipleOfThree = function(digits) {\\n    // get sum of all numbers\\n    const sum = digits.reduce((a,c) => a + c);\\n\\n    // if the sum is 0 return 0 for edgecase [0,0,0,0]\\n    if (sum === 0) return \\'0\\'\\n\\n    // find out the value needed to be removed in order to make the\\n    // final result equal to 3\\n    const remainder = sum % 3;\\n\\n    // sort the digits in reverse order to get the maximum value\\n    // of digits joined together\\n    digits.sort((a,b) => b - a);\\n\\n    // if the sum of all the digits are divisible by 3 return the digits\\n    // as a string\\n    if (remainder === 0) return digits.join(\\'\\');\\n\\n    // create 2 stores that hold the indexes of values with a remainder of\\n    // 2 and 1 so we can remove that from the  result\\n    let twos = [];\\n    let ones = [];\\n    for (let i = 0; i < digits.length; i++) {\\n        switch (digits[i] % 3) {\\n            case 2:\\n                twos.push(i)\\n                break;\\n            case 1:\\n                ones.push(i)\\n                break;\\n        }\\n    }\\n\\n    // get the last 2 indexes of each so we can make the smalles amount of\\n    // change to the result\\n    const one = ones.pop();\\n    const two = twos.pop();\\n\\n    // if the sum has a remainder of 1\\n    if (remainder === 1) {\\n        // get the next index with the remainder of 2 in case if there is no\\n        // value in digits with the remainer of 1\\n        let two2 = twos.pop();\\n\\n        // if there is a value with the remainder of 1 remove it from digits\\n        if (one !== undefined) {\\n            digits[one] = \\'\\';\\n\\n        // if there are 2 values with remainder of 2 remove both from digits\\n        } else if (two2 !== undefined) {\\n            digits[two] = \\'\\';\\n            digits[two2] = \\'\\';\\n\\n        // otherwise we aren\\'t able to make a final result that is divisible by\\n        // 3 so we return an empty string\\n        } else {\\n            return \\'\\'\\n        }\\n\\n    // if the sum has a remainder of 2\\n    } else {\\n        // get the next index with the remainder of 1 in case if there is no\\n        // value in digits with the remainer of 2\\n        let one2 = ones.pop();\\n\\n        // if there is a value with the remainder of 2 remove it from digits\\n        if (two !== undefined) {\\n            digits[two] = \\'\\';\\n\\n        // if there are 2 values with remainder of 1 remove both from digits\\n        } else if (one2 !== undefined) {\\n            digits[one] = \\'\\'\\n            digits[one2] = \\'\\'\\n\\n        // otherwise we aren\\'t able to make a final result that is divisible by\\n        // 3 so we return an empty string\\n        } else {\\n            return \\'\\'\\n        }\\n    }\\n\\n    // return digits as a string\\n    return digits.join(\\'\\')\\n};\\n```\\n\\n```javascript\\n//////////////////////////////////////////////////////////////////////////////////////\\n// SHORTER SOLUTION\\n// Time: O(nlogn)\\n// Space: O(n)\\nvar largestMultipleOfThree = function(digits) {\\n    const sum = digits.reduce((a,c) => a + c);\\n    if (sum === 0) return \\'0\\'\\n    const remainder = sum % 3;\\n    digits.sort((a,b) => b - a);\\n    if (remainder === 0) return digits.join(\\'\\');\\n    const doubleRemainder = remainder === 1 ? 2 : 1;\\n    const idxs = []\\n    for (let i = digits.length - 1; i >= 0; i--) {\\n        const numRemainder = digits[i] % 3;\\n        if (numRemainder === remainder) {\\n            digits[i] = \\'\\';\\n            return digits.join(\\'\\')\\n        } else if (numRemainder === doubleRemainder) {\\n            idxs.push(i);\\n        }\\n    }\\n    const [idx1, idx2] = idxs;\\n    if (idx2 === undefined) return \\'\\';\\n    \\n    digits[idx1] = \\'\\'\\n    digits[idx2] = \\'\\'\\n    return digits.join(\\'\\');\\n};\\n```\\n\\n```javascript\\n//////////////////////////////////////////////////////\\n// FASTEST SOLUTION learning from https://leetcode.com/problems/largest-multiple-of-three/discuss/517570/Python-O(n)-Simple-Bucket-Sort-with-Explanation\\n// Time: O(n)\\n// Space: O(n)\\nvar largestMultipleOfThree = function(digits) {\\n  const values = new Array(10);\\n  for (let i = 0; i < 10; i++) values[i] = [];\\n\\n  let sum = 0;\\n  for (let num of digits) {\\n    values[num].push(num);\\n    sum += num;\\n  }\\n  if (sum === 0) return \\'0\\';\\n  if (sum % 3 === 0) return stringify(values);\\n\\n  const remainder = sum % 3;\\n  for (let i = remainder; i < 10; i += 3) {\\n    if (values[i].length > 0) {\\n      values[i].pop();\\n      return stringify(values);\\n    }\\n  }\\n\\n  let count = 0;\\n  const start = remainder === 1 ? 2 : 1;\\n  for (let i = start; i < 10; i += 3) {\\n    while (values[i].length > 0) {\\n      values[i].pop();\\n      count++;\\n      if (count === 2) return stringify(values);\\n    }\\n  }\\n  return \\'\\';\\n};\\n\\n\\nfunction stringify(values) {\\n  return values.reduce((result, nums) =>  nums.join(\\'\\') + result, \\'\\');\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Bucket Sort"
                ],
                "code": "```javascript\\n// EASY TO UNDERSTAND\\n// Time: O(nlogn)\\n// Space: O(n)\\nvar largestMultipleOfThree = function(digits) {\\n    // get sum of all numbers\\n    const sum = digits.reduce((a,c) => a + c);\\n\\n    // if the sum is 0 return 0 for edgecase [0,0,0,0]\\n    if (sum === 0) return \\'0\\'\\n\\n    // find out the value needed to be removed in order to make the\\n    // final result equal to 3\\n    const remainder = sum % 3;\\n\\n    // sort the digits in reverse order to get the maximum value\\n    // of digits joined together\\n    digits.sort((a,b) => b - a);\\n\\n    // if the sum of all the digits are divisible by 3 return the digits\\n    // as a string\\n    if (remainder === 0) return digits.join(\\'\\');\\n\\n    // create 2 stores that hold the indexes of values with a remainder of\\n    // 2 and 1 so we can remove that from the  result\\n    let twos = [];\\n    let ones = [];\\n    for (let i = 0; i < digits.length; i++) {\\n        switch (digits[i] % 3) {\\n            case 2:\\n                twos.push(i)\\n                break;\\n            case 1:\\n                ones.push(i)\\n                break;\\n        }\\n    }\\n\\n    // get the last 2 indexes of each so we can make the smalles amount of\\n    // change to the result\\n    const one = ones.pop();\\n    const two = twos.pop();\\n\\n    // if the sum has a remainder of 1\\n    if (remainder === 1) {\\n        // get the next index with the remainder of 2 in case if there is no\\n        // value in digits with the remainer of 1\\n        let two2 = twos.pop();\\n\\n        // if there is a value with the remainder of 1 remove it from digits\\n        if (one !== undefined) {\\n            digits[one] = \\'\\';\\n\\n        // if there are 2 values with remainder of 2 remove both from digits\\n        } else if (two2 !== undefined) {\\n            digits[two] = \\'\\';\\n            digits[two2] = \\'\\';\\n\\n        // otherwise we aren\\'t able to make a final result that is divisible by\\n        // 3 so we return an empty string\\n        } else {\\n            return \\'\\'\\n        }\\n\\n    // if the sum has a remainder of 2\\n    } else {\\n        // get the next index with the remainder of 1 in case if there is no\\n        // value in digits with the remainer of 2\\n        let one2 = ones.pop();\\n\\n        // if there is a value with the remainder of 2 remove it from digits\\n        if (two !== undefined) {\\n            digits[two] = \\'\\';\\n\\n        // if there are 2 values with remainder of 1 remove both from digits\\n        } else if (one2 !== undefined) {\\n            digits[one] = \\'\\'\\n            digits[one2] = \\'\\'\\n\\n        // otherwise we aren\\'t able to make a final result that is divisible by\\n        // 3 so we return an empty string\\n        } else {\\n            return \\'\\'\\n        }\\n    }\\n\\n    // return digits as a string\\n    return digits.join(\\'\\')\\n};\\n```\n```javascript\\n//////////////////////////////////////////////////////////////////////////////////////\\n// SHORTER SOLUTION\\n// Time: O(nlogn)\\n// Space: O(n)\\nvar largestMultipleOfThree = function(digits) {\\n    const sum = digits.reduce((a,c) => a + c);\\n    if (sum === 0) return \\'0\\'\\n    const remainder = sum % 3;\\n    digits.sort((a,b) => b - a);\\n    if (remainder === 0) return digits.join(\\'\\');\\n    const doubleRemainder = remainder === 1 ? 2 : 1;\\n    const idxs = []\\n    for (let i = digits.length - 1; i >= 0; i--) {\\n        const numRemainder = digits[i] % 3;\\n        if (numRemainder === remainder) {\\n            digits[i] = \\'\\';\\n            return digits.join(\\'\\')\\n        } else if (numRemainder === doubleRemainder) {\\n            idxs.push(i);\\n        }\\n    }\\n    const [idx1, idx2] = idxs;\\n    if (idx2 === undefined) return \\'\\';\\n    \\n    digits[idx1] = \\'\\'\\n    digits[idx2] = \\'\\'\\n    return digits.join(\\'\\');\\n};\\n```\n```javascript\\n//////////////////////////////////////////////////////\\n// FASTEST SOLUTION learning from https://leetcode.com/problems/largest-multiple-of-three/discuss/517570/Python-O(n)-Simple-Bucket-Sort-with-Explanation\\n// Time: O(n)\\n// Space: O(n)\\nvar largestMultipleOfThree = function(digits) {\\n  const values = new Array(10);\\n  for (let i = 0; i < 10; i++) values[i] = [];\\n\\n  let sum = 0;\\n  for (let num of digits) {\\n    values[num].push(num);\\n    sum += num;\\n  }\\n  if (sum === 0) return \\'0\\';\\n  if (sum % 3 === 0) return stringify(values);\\n\\n  const remainder = sum % 3;\\n  for (let i = remainder; i < 10; i += 3) {\\n    if (values[i].length > 0) {\\n      values[i].pop();\\n      return stringify(values);\\n    }\\n  }\\n\\n  let count = 0;\\n  const start = remainder === 1 ? 2 : 1;\\n  for (let i = start; i < 10; i += 3) {\\n    while (values[i].length > 0) {\\n      values[i].pop();\\n      count++;\\n      if (count === 2) return stringify(values);\\n    }\\n  }\\n  return \\'\\';\\n};\\n\\n\\nfunction stringify(values) {\\n  return values.reduce((result, nums) =>  nums.join(\\'\\') + result, \\'\\');\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3181486,
                "title": "c-easy-and-simple-code-90-fast",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool solve(vector<int>& digits, int rem, int k, pair<int, int> &idx){\\n        for(int i=digits.size()-1; i>=0; i--){\\n            if(digits[i] % 3 == rem){\\n                if(idx.first == -1) idx.first = i;\\n                else idx.second = i;\\n\\n                k--;\\n                if(k == 0) return true;\\n            }\\n        }\\n\\n        return false;\\n    }\\n\\n    string makeStr(vector<int>& digits, pair<int, int> &idx){\\n        string ans = \"\";\\n\\n        for(int i=0; i<digits.size(); i++){\\n            if(idx.first == i || idx.second == i) continue;\\n            if(digits[i] == 0 && ans.size() == 0) return \"0\";\\n\\n            ans += (digits[i] + \\'0\\');\\n        }\\n\\n        return ans;\\n    }\\n\\n    string largestMultipleOfThree(vector<int>& digits) {\\n        sort(digits.begin(), digits.end(), greater<int>());\\n        int sum = 0;\\n        for(auto i : digits) sum += i;\\n\\n        pair<int, int> idx = {-1,-1};\\n        if(sum % 3 == 0) return makeStr(digits, idx);\\n        else if(sum % 3 == 1){\\n            bool flag = solve(digits, 1, 1, idx);\\n            if(!flag) solve(digits, 2, 2, idx);\\n        }\\n        else if(sum % 3 == 2){\\n            bool flag = solve(digits, 2, 1, idx);\\n            if(!flag) solve(digits, 1, 2, idx);\\n        }\\n\\n        return makeStr(digits, idx);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool solve(vector<int>& digits, int rem, int k, pair<int, int> &idx){\\n        for(int i=digits.size()-1; i>=0; i--){\\n            if(digits[i] % 3 == rem){\\n                if(idx.first == -1) idx.first = i;\\n                else idx.second = i;\\n\\n                k--;\\n                if(k == 0) return true;\\n            }\\n        }\\n\\n        return false;\\n    }\\n\\n    string makeStr(vector<int>& digits, pair<int, int> &idx){\\n        string ans = \"\";\\n\\n        for(int i=0; i<digits.size(); i++){\\n            if(idx.first == i || idx.second == i) continue;\\n            if(digits[i] == 0 && ans.size() == 0) return \"0\";\\n\\n            ans += (digits[i] + \\'0\\');\\n        }\\n\\n        return ans;\\n    }\\n\\n    string largestMultipleOfThree(vector<int>& digits) {\\n        sort(digits.begin(), digits.end(), greater<int>());\\n        int sum = 0;\\n        for(auto i : digits) sum += i;\\n\\n        pair<int, int> idx = {-1,-1};\\n        if(sum % 3 == 0) return makeStr(digits, idx);\\n        else if(sum % 3 == 1){\\n            bool flag = solve(digits, 1, 1, idx);\\n            if(!flag) solve(digits, 2, 2, idx);\\n        }\\n        else if(sum % 3 == 2){\\n            bool flag = solve(digits, 2, 1, idx);\\n            if(!flag) solve(digits, 1, 2, idx);\\n        }\\n\\n        return makeStr(digits, idx);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3044408,
                "title": "math-greedy-c",
                "content": "```\\nclass Solution {\\n    string build(int n, unordered_map<int, int> &m) {\\n        string s;\\n        int sum = 0;\\n        m[n]--;\\n        for(auto i : m){\\n            for(int j=0; j<i.second; j++) s += to_string(i.first), sum += i.first;\\n        }\\n        if(!s.size()) return \"\";\\n        if(!sum) return \"0\";\\n\\n        sort(s.begin(), s.end(), greater<char>());\\n        if(sum % 3 == 0) return s;\\n        return \"\";\\n    }\\n    string solve(vector<int> v, unordered_map<int, int> &m) {\\n        for(int i=0; i<3; i++) {\\n            for(int j=0; j<3; j++) {\\n                if(v[i] == v[j]) {\\n                    if(m[v[i]] > 1) {\\n                        build(v[i], m);\\n                        return build(v[i], m);\\n                    }\\n                }\\n                else {\\n                    if(m[v[i]] && m[v[j]]) {\\n                        build(v[i], m);\\n                        return build(v[j], m);\\n                    }\\n                }\\n            }\\n        }\\n        return \"\";\\n    }\\npublic:\\n    string largestMultipleOfThree(vector<int>& digits) {\\n        unordered_map<int, int> m;\\n        int sum = 0;\\n        for(int i : digits) m[i]++, sum += i;\\n        \\n        if(sum % 3  == 0) return build(-1, m);\\n        \\n        if(sum % 3 == 1) {\\n            if(m.count(1)) return build(1, m);\\n            if(m.count(4)) return build(4, m);\\n            if(m.count(7)) return build(7, m);\\n        }\\n        if(sum % 3 == 2) {\\n            if(m.count(2)) return build(2, m);\\n            if(m.count(5)) return build(5, m);\\n            if(m.count(8)) return build(8, m);\\n        }\\n        if(sum % 3 == 1) return solve({2, 5, 8}, m);\\n        return solve({1, 4, 7}, m);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    string build(int n, unordered_map<int, int> &m) {\\n        string s;\\n        int sum = 0;\\n        m[n]--;\\n        for(auto i : m){\\n            for(int j=0; j<i.second; j++) s += to_string(i.first), sum += i.first;\\n        }\\n        if(!s.size()) return \"\";\\n        if(!sum) return \"0\";\\n\\n        sort(s.begin(), s.end(), greater<char>());\\n        if(sum % 3 == 0) return s;\\n        return \"\";\\n    }\\n    string solve(vector<int> v, unordered_map<int, int> &m) {\\n        for(int i=0; i<3; i++) {\\n            for(int j=0; j<3; j++) {\\n                if(v[i] == v[j]) {\\n                    if(m[v[i]] > 1) {\\n                        build(v[i], m);\\n                        return build(v[i], m);\\n                    }\\n                }\\n                else {\\n                    if(m[v[i]] && m[v[j]]) {\\n                        build(v[i], m);\\n                        return build(v[j], m);\\n                    }\\n                }\\n            }\\n        }\\n        return \"\";\\n    }\\npublic:\\n    string largestMultipleOfThree(vector<int>& digits) {\\n        unordered_map<int, int> m;\\n        int sum = 0;\\n        for(int i : digits) m[i]++, sum += i;\\n        \\n        if(sum % 3  == 0) return build(-1, m);\\n        \\n        if(sum % 3 == 1) {\\n            if(m.count(1)) return build(1, m);\\n            if(m.count(4)) return build(4, m);\\n            if(m.count(7)) return build(7, m);\\n        }\\n        if(sum % 3 == 2) {\\n            if(m.count(2)) return build(2, m);\\n            if(m.count(5)) return build(5, m);\\n            if(m.count(8)) return build(8, m);\\n        }\\n        if(sum % 3 == 1) return solve({2, 5, 8}, m);\\n        return solve({1, 4, 7}, m);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2999298,
                "title": "largest-multiple-of-three-solution-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public String largestMultipleOfThree(int[] digits) {\\n    StringBuilder ans = new StringBuilder();\\n    int[] mod1 = new int[] {1, 4, 7, 2, 5, 8};\\n    int[] mod2 = new int[] {2, 5, 8, 1, 4, 7};\\n    int[] count = new int[10];\\n    int sum = 0;\\n\\n    for (int digit : digits) {\\n      ++count[digit];\\n      sum += digit;\\n    }\\n\\n    while (sum % 3 != 0)\\n      for (int i : sum % 3 == 1 ? mod1 : mod2)\\n        if (count[i] > 0) {\\n          --count[i];\\n          sum -= i;\\n          break;\\n        }\\n\\n    for (int digit = 9; digit >= 0; --digit)\\n      ans.append(Character.toString(\\'0\\' + digit).repeat(count[digit]));\\n\\n    return ans.length() > 0 && ans.charAt(0) == \\'0\\' ? \"0\" : ans.toString();\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n  public String largestMultipleOfThree(int[] digits) {\\n    StringBuilder ans = new StringBuilder();\\n    int[] mod1 = new int[] {1, 4, 7, 2, 5, 8};\\n    int[] mod2 = new int[] {2, 5, 8, 1, 4, 7};\\n    int[] count = new int[10];\\n    int sum = 0;\\n\\n    for (int digit : digits) {\\n      ++count[digit];\\n      sum += digit;\\n    }\\n\\n    while (sum % 3 != 0)\\n      for (int i : sum % 3 == 1 ? mod1 : mod2)\\n        if (count[i] > 0) {\\n          --count[i];\\n          sum -= i;\\n          break;\\n        }\\n\\n    for (int digit = 9; digit >= 0; --digit)\\n      ans.append(Character.toString(\\'0\\' + digit).repeat(count[digit]));\\n\\n    return ans.length() > 0 && ans.charAt(0) == \\'0\\' ? \"0\" : ans.toString();\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2830564,
                "title": "simple-solution-using-greedy-approach-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe will just think of removing mod that is like if it is 0 then we can use all number but if it is 1 or 2 then we have to remove that mod by removing some digits .\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHashmap \\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string largestMultipleOfThree(vector<int>& digits) {\\n        vector<int> fq(10,0);\\n        int allno = 0;\\n        for(int i:digits){\\n            allno += i;\\n            fq[i]++;\\n        }\\n        // We have sum of all number now we only have to try to remove numbers that we need to make this alln divisible by 3 \\n        string ans = \"\";\\n        if(allno%3 == 1){\\n            // 1 , 4 , 7\\n            // means we have to remove number which is contributing to mod 1\\n            for(int i=1;i<9;i++){\\n                // we try to delete numbers by\\n                if(i%3 == 1 && fq[i] > 0){ allno -= i; fq[i]--; break;}\\n            }\\n            // if still we have not got rid of mod 1\\n            // check for 2 , 5 , 8\\n            // we can delete 2 elements of 1 digits if available or\\n            if(allno%3 == 1){\\n                // we have to remove 2 digits then it must be \\n                int mo2[3] = {2,5,8};\\n                int k = 0;\\n                while(allno%3 != 0 && k < 3){\\n                    while(k < 3 && fq[mo2[k]] > 0 && allno%3 != 0){ allno -= mo2[k]; fq[mo2[k]]--; }\\n                    k++;\\n                }\\n            }\\n        }else if(allno%3 == 2){\\n            // here delete 2 , 5 , 8\\n            for(int i=1;i<9;i++){\\n                // we try to delete numbers by\\n                if(i%3 == 2 && fq[i] > 0){ allno -=i; fq[i]--; break;}\\n            }\\n            if(allno%3 == 2){\\n                // we have to remove 2 digits then it must be \\n                int mo2[3] = {1,4,7};\\n                int k = 0;\\n                while(allno%3 != 0 && k < 3){\\n                    while(k < 3 && fq[mo2[k]] > 0 && allno%3 != 0){ allno -= mo2[k]; fq[mo2[k]]--; }\\n                    k++;\\n                }\\n            }\\n        }\\n        for(int j=9;j>=0;j--){\\n            for(int i=0;i<fq[j];i++) ans += (j + \\'0\\');\\n        }\\n        while(ans[0] == \\'0\\') return \"0\";\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestMultipleOfThree(vector<int>& digits) {\\n        vector<int> fq(10,0);\\n        int allno = 0;\\n        for(int i:digits){\\n            allno += i;\\n            fq[i]++;\\n        }\\n        // We have sum of all number now we only have to try to remove numbers that we need to make this alln divisible by 3 \\n        string ans = \"\";\\n        if(allno%3 == 1){\\n            // 1 , 4 , 7\\n            // means we have to remove number which is contributing to mod 1\\n            for(int i=1;i<9;i++){\\n                // we try to delete numbers by\\n                if(i%3 == 1 && fq[i] > 0){ allno -= i; fq[i]--; break;}\\n            }\\n            // if still we have not got rid of mod 1\\n            // check for 2 , 5 , 8\\n            // we can delete 2 elements of 1 digits if available or\\n            if(allno%3 == 1){\\n                // we have to remove 2 digits then it must be \\n                int mo2[3] = {2,5,8};\\n                int k = 0;\\n                while(allno%3 != 0 && k < 3){\\n                    while(k < 3 && fq[mo2[k]] > 0 && allno%3 != 0){ allno -= mo2[k]; fq[mo2[k]]--; }\\n                    k++;\\n                }\\n            }\\n        }else if(allno%3 == 2){\\n            // here delete 2 , 5 , 8\\n            for(int i=1;i<9;i++){\\n                // we try to delete numbers by\\n                if(i%3 == 2 && fq[i] > 0){ allno -=i; fq[i]--; break;}\\n            }\\n            if(allno%3 == 2){\\n                // we have to remove 2 digits then it must be \\n                int mo2[3] = {1,4,7};\\n                int k = 0;\\n                while(allno%3 != 0 && k < 3){\\n                    while(k < 3 && fq[mo2[k]] > 0 && allno%3 != 0){ allno -= mo2[k]; fq[mo2[k]]--; }\\n                    k++;\\n                }\\n            }\\n        }\\n        for(int j=9;j>=0;j--){\\n            for(int i=0;i<fq[j];i++) ans += (j + \\'0\\');\\n        }\\n        while(ans[0] == \\'0\\') return \"0\";\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2602506,
                "title": "100-faster-bucket-sort",
                "content": "Used Bucket sort to solve this problem\\nHope this helps\\n```\\nclass Solution {\\npublic:\\n    string largestMultipleOfThree(vector<int>& digits) {\\n        int sum=0;\\n        vector<int> arr(10,0);\\n        for(auto &ele : digits){\\n            arr[ele]++;\\n            sum+=(ele);\\n        }\\n        if((sum%3)!=0){\\n            if(sum%3==1){\\n                int f=0;\\n                for(int i=0;i<10;i++){\\n                    if((i%3==1)&&(arr[i]>0)){\\n                        arr[i]--;\\n                        f=1;\\n                        break;\\n                    }\\n                }\\n                if(!f){\\n                    int mn=19;\\n                    int x=-1,y=-1;\\n                    for(int i=0;i<10;i++){\\n                        for(int j=i;j<10;j++){\\n                            if((i%3==2&&i==j&&(arr[i]>1))||((i!=j)&&(i%3==2)&&(j%3==2)&&(arr[i]>0)&&(arr[j]>0))){\\n                                f=1;\\n                                if((i+j)<=mn){\\n                                    mn=(i+j);\\n                                    x=i;\\n                                    y=j;\\n                                }\\n                            }\\n                        }\\n                    }\\n                    \\n                    if(f){\\n                        //cout<<x<<\" \"<<y<<\"\\\\n\";\\n                        arr[x]--;\\n                        arr[y]--;\\n                    }\\n                }\\n                if(!f)return \"\";\\n            }\\n            if(sum%3==2){\\n                int f=0;\\n                for(int i=0;i<10;i++){\\n                    if(i%3==2&&(arr[i]>0)){\\n                        arr[i]--;\\n                        f=1;\\n                        break;\\n                    }\\n                }\\n                if(!f){\\n                    int mn=19;\\n                    int x=-1,y=-1;\\n                    for(int i=0;i<10;i++){\\n                        for(int j=i;j<10;j++){\\n                            if((i%3==1&&i==j&&(arr[i]>1))||((i!=j)&&(i%3==1)&&(j%3==1)&&(arr[i]>0)&&(arr[j]>0))){\\n                                f=1;\\n                                if((i+j)<=mn){\\n                                    mn=(i+j);\\n                                    x=i;\\n                                    y=j;\\n                                }\\n                            }\\n                        }\\n                    }\\n                    if(f){\\n                        arr[x]--;\\n                        arr[y]--;\\n                    }\\n                }\\n                if(!f)return \"\";\\n            }\\n        }\\n        string s=\"\";\\n        //for(int i=0;i<10;i++)cout<<arr[i]<<\" \";\\n        for(int i=9;i>=0;i--){\\n            while(arr[i]-->0)s+=char(i+\\'0\\');\\n        }\\n        return (s[0]!=\\'0\\')?s:\"0\";\\n    }\\n};\\n```",
                "solutionTags": [
                    "Sorting",
                    "Bucket Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestMultipleOfThree(vector<int>& digits) {\\n        int sum=0;\\n        vector<int> arr(10,0);\\n        for(auto &ele : digits){\\n            arr[ele]++;\\n            sum+=(ele);\\n        }\\n        if((sum%3)!=0){\\n            if(sum%3==1){\\n                int f=0;\\n                for(int i=0;i<10;i++){\\n                    if((i%3==1)&&(arr[i]>0)){\\n                        arr[i]--;\\n                        f=1;\\n                        break;\\n                    }\\n                }\\n                if(!f){\\n                    int mn=19;\\n                    int x=-1,y=-1;\\n                    for(int i=0;i<10;i++){\\n                        for(int j=i;j<10;j++){\\n                            if((i%3==2&&i==j&&(arr[i]>1))||((i!=j)&&(i%3==2)&&(j%3==2)&&(arr[i]>0)&&(arr[j]>0))){\\n                                f=1;\\n                                if((i+j)<=mn){\\n                                    mn=(i+j);\\n                                    x=i;\\n                                    y=j;\\n                                }\\n                            }\\n                        }\\n                    }\\n                    \\n                    if(f){\\n                        //cout<<x<<\" \"<<y<<\"\\\\n\";\\n                        arr[x]--;\\n                        arr[y]--;\\n                    }\\n                }\\n                if(!f)return \"\";\\n            }\\n            if(sum%3==2){\\n                int f=0;\\n                for(int i=0;i<10;i++){\\n                    if(i%3==2&&(arr[i]>0)){\\n                        arr[i]--;\\n                        f=1;\\n                        break;\\n                    }\\n                }\\n                if(!f){\\n                    int mn=19;\\n                    int x=-1,y=-1;\\n                    for(int i=0;i<10;i++){\\n                        for(int j=i;j<10;j++){\\n                            if((i%3==1&&i==j&&(arr[i]>1))||((i!=j)&&(i%3==1)&&(j%3==1)&&(arr[i]>0)&&(arr[j]>0))){\\n                                f=1;\\n                                if((i+j)<=mn){\\n                                    mn=(i+j);\\n                                    x=i;\\n                                    y=j;\\n                                }\\n                            }\\n                        }\\n                    }\\n                    if(f){\\n                        arr[x]--;\\n                        arr[y]--;\\n                    }\\n                }\\n                if(!f)return \"\";\\n            }\\n        }\\n        string s=\"\";\\n        //for(int i=0;i<10;i++)cout<<arr[i]<<\" \";\\n        for(int i=9;i>=0;i--){\\n            while(arr[i]-->0)s+=char(i+\\'0\\');\\n        }\\n        return (s[0]!=\\'0\\')?s:\"0\";\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2574342,
                "title": "c-o-nlogn-sort-dp",
                "content": "We can use counting sort to reduce the time complexity to O(n).\\n\\n```\\nclass Solution {\\npublic:\\n    string largestMultipleOfThree(vector<int>& a) {\\n        int n=a.size();\\n        sort(a.rbegin(), a.rend());\\n        vector<vector<int>>DP(n+1, vector<int>(3)); //DP[i][k] = longest sized string i can take from \\'i\\' so as to make mod with 3 = k\\n        vector<vector<bool>>take(n+1, vector<bool>(3, false));  // DP memory -> storing path of DP graph\\n        \\n        const int INF = INT_MAX/4;\\n        \\n        for(int i=n; i>=0; i--){\\n            for(int mod=0; mod<3; mod++){\\n                if(i==n){\\n                    DP[i][mod] = (mod==0?0:-INF);\\n                    take[i][mod] = false;\\n                    continue;\\n                }\\n                int nmod = (((mod-a[i])%3)+3)%3;\\n                int op1 = 1 + DP[i+1][nmod];\\n                int op2 = DP[i+1][mod];\\n                if(op1>=op2){\\n                    take[i][mod] = true;\\n                    DP[i][mod] = op1;\\n                }\\n                else{\\n                    take[i][mod] = false;\\n                    DP[i][mod] = op2;\\n                }\\n            }\\n        }\\n        string ans;\\n        int cur = 0;\\n        for(int i=0; i<n; i++){\\n            if(take[i][cur]){\\n                int nmod = (((cur-(a[i]%3))%3)+3)%3;\\n                cur=nmod;\\n                if(a[i]!=0 || ans.empty() || ans[0]!=\\'0\\')\\n                    ans+=to_string(a[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestMultipleOfThree(vector<int>& a) {\\n        int n=a.size();\\n        sort(a.rbegin(), a.rend());\\n        vector<vector<int>>DP(n+1, vector<int>(3)); //DP[i][k] = longest sized string i can take from \\'i\\' so as to make mod with 3 = k\\n        vector<vector<bool>>take(n+1, vector<bool>(3, false));  // DP memory -> storing path of DP graph\\n        \\n        const int INF = INT_MAX/4;\\n        \\n        for(int i=n; i>=0; i--){\\n            for(int mod=0; mod<3; mod++){\\n                if(i==n){\\n                    DP[i][mod] = (mod==0?0:-INF);\\n                    take[i][mod] = false;\\n                    continue;\\n                }\\n                int nmod = (((mod-a[i])%3)+3)%3;\\n                int op1 = 1 + DP[i+1][nmod];\\n                int op2 = DP[i+1][mod];\\n                if(op1>=op2){\\n                    take[i][mod] = true;\\n                    DP[i][mod] = op1;\\n                }\\n                else{\\n                    take[i][mod] = false;\\n                    DP[i][mod] = op2;\\n                }\\n            }\\n        }\\n        string ans;\\n        int cur = 0;\\n        for(int i=0; i<n; i++){\\n            if(take[i][cur]){\\n                int nmod = (((cur-(a[i]%3))%3)+3)%3;\\n                cur=nmod;\\n                if(a[i]!=0 || ans.empty() || ans[0]!=\\'0\\')\\n                    ans+=to_string(a[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2295627,
                "title": "largest-multiple-of-three-java-trick-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public String largestMultipleOfThree(int[] digits) {\\n        int n=digits.length;\\n        Arrays.sort(digits);\\n        \\n        if(digits[digits.length-1]==0){\\n            return \"0\";\\n        }\\n        \\n        int sum=0;\\n        \\n        for(int i=0;i<digits.length;i++){\\n            sum+=digits[i];\\n        }\\n        \\n        if(sum%3==0){\\n            StringBuilder sb=new StringBuilder(\"\");\\n            \\n            for(int i=n-1;i>=0;i--){\\n                sb.append(digits[i]);\\n            }\\n            \\n            return sb.toString();\\n        }else if(sum%3==1){\\n            int modOne=-1;\\n            \\n            for(int i=0;i<n;i++){\\n                if(digits[i]%3==1){\\n                    modOne=i;\\n                    break;\\n                }\\n            }\\n            \\n            if(modOne==-1){\\n                int []idx=new int[2];\\n                Arrays.fill(idx,-1);\\n                \\n                for(int i=0;i<n;i++){\\n                    if(digits[i]%3==2){\\n                        if(idx[0]==-1){\\n                            idx[0]=i;\\n                        }else{\\n                            idx[1]=i;\\n                            break;\\n                        }\\n                    }\\n                }\\n                \\n                if(idx[1]==-1){\\n                    return \"\";\\n                }else{\\n                    digits[idx[0]]=-1;\\n                    digits[idx[1]]=-1;\\n                }\\n            }else{\\n                digits[modOne]=-1;\\n            }\\n        }else{\\n            int modTwo=-1;\\n            \\n            for(int i=0;i<n;i++){\\n                if(digits[i]%3==2){\\n                    modTwo=i;\\n                    break;\\n                }\\n            }\\n            \\n            if(modTwo==-1){\\n                int []idx=new int[2];\\n                Arrays.fill(idx,-1);\\n                \\n                for(int i=0;i<n;i++){\\n                    if(digits[i]%3==1){\\n                        if(idx[0]==-1){\\n                            idx[0]=i;\\n                        }else{\\n                            idx[1]=i;\\n                            break;\\n                        }\\n                    }\\n                }\\n                \\n                if(idx[1]==-1){\\n                    return \"\";\\n                }else{\\n                    digits[idx[0]]=-1;\\n                    digits[idx[1]]=-1;\\n                }\\n            }else{\\n                digits[modTwo]=-1;\\n            }\\n        }\\n        \\n        StringBuilder sb=new StringBuilder(\"\");\\n        \\n        for(int i=n-1;i>=0;i--){\\n            if(digits[i]!=-1){\\n                sb.append(digits[i]);\\n            }\\n            \\n        }\\n        \\n        if(sb.length()>0 && sb.toString().charAt(0)==\\'0\\'){\\n            return \"0\";\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String largestMultipleOfThree(int[] digits) {\\n        int n=digits.length;\\n        Arrays.sort(digits);\\n        \\n        if(digits[digits.length-1]==0){\\n            return \"0\";\\n        }\\n        \\n        int sum=0;\\n        \\n        for(int i=0;i<digits.length;i++){\\n            sum+=digits[i];\\n        }\\n        \\n        if(sum%3==0){\\n            StringBuilder sb=new StringBuilder(\"\");\\n            \\n            for(int i=n-1;i>=0;i--){\\n                sb.append(digits[i]);\\n            }\\n            \\n            return sb.toString();\\n        }else if(sum%3==1){\\n            int modOne=-1;\\n            \\n            for(int i=0;i<n;i++){\\n                if(digits[i]%3==1){\\n                    modOne=i;\\n                    break;\\n                }\\n            }\\n            \\n            if(modOne==-1){\\n                int []idx=new int[2];\\n                Arrays.fill(idx,-1);\\n                \\n                for(int i=0;i<n;i++){\\n                    if(digits[i]%3==2){\\n                        if(idx[0]==-1){\\n                            idx[0]=i;\\n                        }else{\\n                            idx[1]=i;\\n                            break;\\n                        }\\n                    }\\n                }\\n                \\n                if(idx[1]==-1){\\n                    return \"\";\\n                }else{\\n                    digits[idx[0]]=-1;\\n                    digits[idx[1]]=-1;\\n                }\\n            }else{\\n                digits[modOne]=-1;\\n            }\\n        }else{\\n            int modTwo=-1;\\n            \\n            for(int i=0;i<n;i++){\\n                if(digits[i]%3==2){\\n                    modTwo=i;\\n                    break;\\n                }\\n            }\\n            \\n            if(modTwo==-1){\\n                int []idx=new int[2];\\n                Arrays.fill(idx,-1);\\n                \\n                for(int i=0;i<n;i++){\\n                    if(digits[i]%3==1){\\n                        if(idx[0]==-1){\\n                            idx[0]=i;\\n                        }else{\\n                            idx[1]=i;\\n                            break;\\n                        }\\n                    }\\n                }\\n                \\n                if(idx[1]==-1){\\n                    return \"\";\\n                }else{\\n                    digits[idx[0]]=-1;\\n                    digits[idx[1]]=-1;\\n                }\\n            }else{\\n                digits[modTwo]=-1;\\n            }\\n        }\\n        \\n        StringBuilder sb=new StringBuilder(\"\");\\n        \\n        for(int i=n-1;i>=0;i--){\\n            if(digits[i]!=-1){\\n                sb.append(digits[i]);\\n            }\\n            \\n        }\\n        \\n        if(sb.length()>0 && sb.toString().charAt(0)==\\'0\\'){\\n            return \"0\";\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2133861,
                "title": "c-code",
                "content": "```\\nclass Solution {\\npublic:\\n    string largestMultipleOfThree(vector<int>& v) {\\n        vector<int> ans;\\n        int i,n=v.size();\\n        vector<int> mp[3];\\n        \\n        if (n==1){\\n            if (v[0]%3==0){\\n                return to_string(v[0]);\\n            }\\n            else{\\n                return \"\";\\n            }\\n        }\\n        \\n        int sum=0;\\n        \\n        for (i=0; i<n; i++){\\n            sum+=v[i];\\n            mp[v[i]%3].push_back(v[i]);\\n        }\\n        \\n        for (auto &it: mp){\\n            sort(it.begin(),it.end());\\n        }\\n        \\n        if (sum%3==1){\\n            if (mp[1].size()>0){\\n                mp[1][0]=1e9;\\n            }\\n            else if (mp[2].size()>=2){\\n                mp[2][0]=1e9;\\n                mp[2][1]=1e9;\\n            }\\n            else{\\n                return \"\";\\n            }\\n        }\\n        else if (sum%3==2){\\n            if (mp[2].size()>0){\\n                mp[2][0]=1e9;\\n            }\\n            else if (mp[1].size()>=2){\\n                mp[1][0]=1e9;\\n                mp[1][1]=1e9;\\n            }\\n            else{\\n                return \"\";\\n            }\\n        }\\n        \\n        for (auto it: mp){\\n            vector<int> temp=it;\\n            for (i=0; i<temp.size(); i++){\\n                if (temp[i]!=1e9){\\n                    ans.push_back(temp[i]);\\n                }\\n            }\\n        }\\n        \\n        sort(ans.rbegin(),ans.rend());\\n        if (ans.size()>0 && ans[0]==0){\\n            return \"0\";\\n        }\\n        string fin;\\n        \\n        for (auto it: ans){\\n            fin+=(it+\\'0\\');\\n        }\\n       \\n        \\n     return fin;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestMultipleOfThree(vector<int>& v) {\\n        vector<int> ans;\\n        int i,n=v.size();\\n        vector<int> mp[3];\\n        \\n        if (n==1){\\n            if (v[0]%3==0){\\n                return to_string(v[0]);\\n            }\\n            else{\\n                return \"\";\\n            }\\n        }\\n        \\n        int sum=0;\\n        \\n        for (i=0; i<n; i++){\\n            sum+=v[i];\\n            mp[v[i]%3].push_back(v[i]);\\n        }\\n        \\n        for (auto &it: mp){\\n            sort(it.begin(),it.end());\\n        }\\n        \\n        if (sum%3==1){\\n            if (mp[1].size()>0){\\n                mp[1][0]=1e9;\\n            }\\n            else if (mp[2].size()>=2){\\n                mp[2][0]=1e9;\\n                mp[2][1]=1e9;\\n            }\\n            else{\\n                return \"\";\\n            }\\n        }\\n        else if (sum%3==2){\\n            if (mp[2].size()>0){\\n                mp[2][0]=1e9;\\n            }\\n            else if (mp[1].size()>=2){\\n                mp[1][0]=1e9;\\n                mp[1][1]=1e9;\\n            }\\n            else{\\n                return \"\";\\n            }\\n        }\\n        \\n        for (auto it: mp){\\n            vector<int> temp=it;\\n            for (i=0; i<temp.size(); i++){\\n                if (temp[i]!=1e9){\\n                    ans.push_back(temp[i]);\\n                }\\n            }\\n        }\\n        \\n        sort(ans.rbegin(),ans.rend());\\n        if (ans.size()>0 && ans[0]==0){\\n            return \"0\";\\n        }\\n        string fin;\\n        \\n        for (auto it: ans){\\n            fin+=(it+\\'0\\');\\n        }\\n       \\n        \\n     return fin;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1892039,
                "title": "java-easy-to-understand-math-logic",
                "content": "# public String largestMultipleOfThree(int[] digits) {\\n        int sum = 0;\\n        StringBuilder res = new StringBuilder();\\n        Arrays.sort(digits);\\n        for (int x : digits) {\\n            sum += x;\\n        }\\n        boolean flag = false;\\n        if (sum % 3 == 1) {\\n            for (int i = 0; i < digits.length; i++) {\\n                if (digits[i] % 3 == 1) {\\n                    digits[i] = -1;\\n                    flag = true;\\n                    break;\\n                }\\n            }\\n            if (!flag) {\\n                int count = 0;\\n                for (int i = 0; i < digits.length; i++) {\\n                    if (digits[i] % 3 == 2) {\\n                        count++;\\n                        digits[i] = -1;\\n                    }\\n                    if (count == 2) {\\n                        break;\\n                    }\\n                }\\n                if (count < 2) {\\n                    return \"\";\\n                }\\n            }\\n        } else if (sum % 3 == 2) {\\n            for (int i = 0; i < digits.length; i++) {\\n                if (digits[i] % 3 == 2) {\\n                    digits[i] = -1;\\n                    flag = true;\\n                    break;\\n                }\\n            }\\n            if (!flag) {\\n                int count = 0;\\n                for (int i = 0; i < digits.length; i++) {\\n                    if (digits[i] % 3 == 1) {\\n                        count++;\\n                        digits[i] = -1;\\n                    }\\n                    if (count == 2) {\\n                        break;\\n                    }\\n                }\\n                if (count < 2) {\\n                    return \"\";\\n                }\\n            }\\n        }\\n        for (int i = digits.length - 1; i >= 0; i--) {\\n            if (digits[i] != -1) {\\n                res.append(digits[i]);\\n            }\\n        }\\n        if (res.length() == 0) {\\n            return \"\";\\n        } else if (res.charAt(0) == \\'0\\') {\\n            return \"0\";\\n        } else {\\n            return res.toString();\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "# public String largestMultipleOfThree(int[] digits) {\\n        int sum = 0;\\n        StringBuilder res = new StringBuilder();\\n        Arrays.sort(digits);\\n        for (int x : digits) {\\n            sum += x;\\n        }\\n        boolean flag = false;\\n        if (sum % 3 == 1) {\\n            for (int i = 0; i < digits.length; i++) {\\n                if (digits[i] % 3 == 1) {\\n                    digits[i] = -1;\\n                    flag = true;\\n                    break;\\n                }\\n            }\\n            if (!flag) {\\n                int count = 0;\\n                for (int i = 0; i < digits.length; i++) {\\n                    if (digits[i] % 3 == 2) {\\n                        count++;\\n                        digits[i] = -1;\\n                    }\\n                    if (count == 2) {\\n                        break;\\n                    }\\n                }\\n                if (count < 2) {\\n                    return \"\";\\n                }\\n            }\\n        } else if (sum % 3 == 2) {\\n            for (int i = 0; i < digits.length; i++) {\\n                if (digits[i] % 3 == 2) {\\n                    digits[i] = -1;\\n                    flag = true;\\n                    break;\\n                }\\n            }\\n            if (!flag) {\\n                int count = 0;\\n                for (int i = 0; i < digits.length; i++) {\\n                    if (digits[i] % 3 == 1) {\\n                        count++;\\n                        digits[i] = -1;\\n                    }\\n                    if (count == 2) {\\n                        break;\\n                    }\\n                }\\n                if (count < 2) {\\n                    return \"\";\\n                }\\n            }\\n        }\\n        for (int i = digits.length - 1; i >= 0; i--) {\\n            if (digits[i] != -1) {\\n                res.append(digits[i]);\\n            }\\n        }\\n        if (res.length() == 0) {\\n            return \"\";\\n        } else if (res.charAt(0) == \\'0\\') {\\n            return \"0\";\\n        } else {\\n            return res.toString();\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1718088,
                "title": "simple-c",
                "content": "```\\nclass Solution {\\npublic:\\n    string largestMultipleOfThree(vector<int>& digits) {\\n        \\n        string zero,one,two;\\n        sort(digits.rbegin(),digits.rend());\\n        \\n        int sum = 0;\\n        \\n        for(auto &i : digits){\\n           sum += i;\\n           if(i%3 == 0)zero += i + \\'0\\';\\n           else if(i%3 == 1)one += i + \\'0\\'; \\n           else if(i%3 == 2)two += i + \\'0\\'; \\n        }\\n        \\n        int n = one.size() , m = two.size();\\n        \\n        if(sum % 3 == 1){\\n            if(n)one = one.substr(0,n-1);\\n            else two = two.substr(0,m-2);\\n        }\\n        else if(sum % 3 == 2){\\n            if(m)two = two.substr(0,m-1);\\n            else one = one.substr(0,n-2); \\n        }\\n        \\n        zero+=one + two;\\n        \\n        sort(zero.rbegin(),zero.rend());\\n        int x = zero.size();\\n        if(x > 1 && zero[0] == zero[x-1] && zero[0] == \\'0\\')return \"0\";\\n        \\n     return zero;  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestMultipleOfThree(vector<int>& digits) {\\n        \\n        string zero,one,two;\\n        sort(digits.rbegin(),digits.rend());\\n        \\n        int sum = 0;\\n        \\n        for(auto &i : digits){\\n           sum += i;\\n           if(i%3 == 0)zero += i + \\'0\\';\\n           else if(i%3 == 1)one += i + \\'0\\'; \\n           else if(i%3 == 2)two += i + \\'0\\'; \\n        }\\n        \\n        int n = one.size() , m = two.size();\\n        \\n        if(sum % 3 == 1){\\n            if(n)one = one.substr(0,n-1);\\n            else two = two.substr(0,m-2);\\n        }\\n        else if(sum % 3 == 2){\\n            if(m)two = two.substr(0,m-1);\\n            else one = one.substr(0,n-2); \\n        }\\n        \\n        zero+=one + two;\\n        \\n        sort(zero.rbegin(),zero.rend());\\n        int x = zero.size();\\n        if(x > 1 && zero[0] == zero[x-1] && zero[0] == \\'0\\')return \"0\";\\n        \\n     return zero;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1669410,
                "title": "python-simple-number-theory",
                "content": "collect the number mod0, mod1, mod2\\nif total sum mod3=0, then we are happy\\nif total sum mod3=1, try to kill one element from mod1, otherwise kill 2 elements from mod2\\nif total sum mod3=2, try to kill one element from mod2, otherwise kill 2 elements from mod1.\\nAt least one of them would be the case.\\n\\n```\\nclass Solution:\\n    # give string from list\\n    def form_string(self,s):\\n        if s==[]: return \"\"\\n        s=sorted(s)[::-1]\\n        ans=\"\"\\n        for i in s:\\n            ans+=str(i)\\n        \\n        # 0000 case \\n        if ans.count(\"0\")==len(ans):\\n            return \"0\"\\n        else:\\n            return ans\\n    \\n    def largestMultipleOfThree(self, digits: List[int]) -> str:\\n        \\n        a0,a1,a2=[],[],[]\\n        for i in digits:\\n            if i%3==0:\\n                a0.append(i)\\n            elif i%3==1:\\n                a1.append(i)\\n            else: \\n                a2.append(i)\\n        a0=sorted(a0)[::-1]\\n        a1=sorted(a1)[::-1]\\n        a2=sorted(a2)[::-1]\\n        #print(a0,a1,a2)\\n        if sum(digits)%3==0:\\n            return self.form_string(digits)\\n        elif sum(digits)%3==1:\\n            if len(a1)>=1:\\n                return self.form_string(a0+a2+a1[:-1])\\n            return self.form_string(a0+a2[:-2]+a1)\\n        elif sum(digits)%3==2:\\n            if len(a2)>=1:\\n                return self.form_string(a0+a2[:-1]+a1)\\n            return self.form_string(a0+a2+a1[:-2])\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    # give string from list\\n    def form_string(self,s):\\n        if s==[]: return \"\"\\n        s=sorted(s)[::-1]\\n        ans=\"\"\\n        for i in s:\\n            ans+=str(i)\\n        \\n        # 0000 case \\n        if ans.count(\"0\")==len(ans):\\n            return \"0\"\\n        else:\\n            return ans\\n    \\n    def largestMultipleOfThree(self, digits: List[int]) -> str:\\n        \\n        a0,a1,a2=[],[],[]\\n        for i in digits:\\n            if i%3==0:\\n                a0.append(i)\\n            elif i%3==1:\\n                a1.append(i)\\n            else: \\n                a2.append(i)\\n        a0=sorted(a0)[::-1]\\n        a1=sorted(a1)[::-1]\\n        a2=sorted(a2)[::-1]\\n        #print(a0,a1,a2)\\n        if sum(digits)%3==0:\\n            return self.form_string(digits)\\n        elif sum(digits)%3==1:\\n            if len(a1)>=1:\\n                return self.form_string(a0+a2+a1[:-1])\\n            return self.form_string(a0+a2[:-2]+a1)\\n        elif sum(digits)%3==2:\\n            if len(a2)>=1:\\n                return self.form_string(a0+a2[:-1]+a1)\\n            return self.form_string(a0+a2+a1[:-2])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1529640,
                "title": "java-o-n-solution-easy-to-understand",
                "content": "```\\n\\nclass Solution {\\n    public String largestMultipleOfThree(int[] digits) {\\n        return helper(digits);\\n    }\\n    \\n    public String helper(int[] arr) {\\n        StringBuilder sb = new StringBuilder();\\n        int sum = 0, n = arr.length;\\n        \\n        for (int val: arr) sum += val;\\n        \\n        Arrays.sort(arr);\\n        \\n        if (sum % 3 == 0) {\\n            // complete arr ele can be used to make number\\n            if (arr[n - 1] == 0) {\\n                sb.append(\"0\");\\n                \\n            } else {\\n                // after sorting last element should not be a 0\\n                for (int i = n - 1; i >= 0; i--) {\\n                    sb.append(arr[i]);\\n                }\\n            }\\n            return sb.toString();\\n            \\n        } else if (sum % 3 == 1) {\\n            // we need to find an element which gives rem == 1\\n            boolean found = false;\\n            \\n            for (int i = 0; i < n; i++) {\\n                if (arr[i] % 3 == 1) {\\n                    found = true;\\n                    // mark that value so that it is not included in ans \\n                    arr[i] = -1;\\n                    break;\\n                }\\n            }\\n            \\n            // if ele with rem = 1 is not found then we need to find 2 ele\\n            // with rem == 2\\n            if (!found) {\\n                int[] store = {-1, -1};\\n                \\n                for (int i = 0; i < n; i++) {\\n                    if (arr[i] % 3 == 2) {\\n                        if (store[0] == -1) {\\n                            store[0] = i;\\n                        } else {\\n                            store[1] = i;\\n                            break;\\n                        }\\n                    }\\n                }\\n                \\n                // now flag those 2 elements such that they are not included in ans\\n                if (store[1] != -1) {\\n                    arr[store[0]] = -1;\\n                    arr[store[1]] = -1;\\n                    \\n                } else {\\n                    return sb.toString();\\n                }\\n            }\\n            \\n        } else if (sum % 3 == 2) {\\n            // we need to find an element which gives rem == 2\\n            boolean found = false;\\n            \\n            for (int i = 0; i < n; i++) {\\n                if (arr[i] % 3 == 2) {\\n                    found = true;\\n                    // mark that value so that it is not included in ans \\n                    arr[i] = -1;\\n                    break;\\n                }\\n            }\\n            \\n            // if ele with rem = 2 is not found then we need to find 2 ele\\n            // with rem == 1\\n            if (!found) {\\n                int[] store = {-1, -1};\\n                \\n                for (int i = 0; i < n; i++) {\\n                    if (arr[i] % 3 == 1) {\\n                        if (store[0] == -1) {\\n                            store[0] = i;\\n                        } else {\\n                            store[1] = i;\\n                            break;\\n                        }\\n                    }\\n                }\\n                \\n                // now flag those 2 elements such that they are not included in ans\\n                if (store[1] != -1) {\\n                    arr[store[0]] = -1;\\n                    arr[store[1]] = -1;\\n                    \\n                } else {\\n                    return sb.toString();\\n                }\\n            }\\n        } \\n        \\n        // now we have unwanted elements marked as -1;\\n        for (int i = n - 1; i >= 0; i--) {\\n            if (arr[i] != -1) {\\n                sb.append(arr[i]);\\n            }\\n        }\\n        \\n        // in case there are many 0s at the start then we need to eliminate them\\n        \\n        if (sb.length() > 0 && sb.charAt(0) != -1 && sb.charAt(0) == \\'0\\') {\\n            StringBuilder ans = new StringBuilder();\\n            ans.append(0);\\n            return ans.toString();\\n        }\\n        \\n        return sb.toString();\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\n    public String largestMultipleOfThree(int[] digits) {\\n        return helper(digits);\\n    }\\n    \\n    public String helper(int[] arr) {\\n        StringBuilder sb = new StringBuilder();\\n        int sum = 0, n = arr.length;\\n        \\n        for (int val: arr) sum += val;\\n        \\n        Arrays.sort(arr);\\n        \\n        if (sum % 3 == 0) {\\n            // complete arr ele can be used to make number\\n            if (arr[n - 1] == 0) {\\n                sb.append(\"0\");\\n                \\n            } else {\\n                // after sorting last element should not be a 0\\n                for (int i = n - 1; i >= 0; i--) {\\n                    sb.append(arr[i]);\\n                }\\n            }\\n            return sb.toString();\\n            \\n        } else if (sum % 3 == 1) {\\n            // we need to find an element which gives rem == 1\\n            boolean found = false;\\n            \\n            for (int i = 0; i < n; i++) {\\n                if (arr[i] % 3 == 1) {\\n                    found = true;\\n                    // mark that value so that it is not included in ans \\n                    arr[i] = -1;\\n                    break;\\n                }\\n            }\\n            \\n            // if ele with rem = 1 is not found then we need to find 2 ele\\n            // with rem == 2\\n            if (!found) {\\n                int[] store = {-1, -1};\\n                \\n                for (int i = 0; i < n; i++) {\\n                    if (arr[i] % 3 == 2) {\\n                        if (store[0] == -1) {\\n                            store[0] = i;\\n                        } else {\\n                            store[1] = i;\\n                            break;\\n                        }\\n                    }\\n                }\\n                \\n                // now flag those 2 elements such that they are not included in ans\\n                if (store[1] != -1) {\\n                    arr[store[0]] = -1;\\n                    arr[store[1]] = -1;\\n                    \\n                } else {\\n                    return sb.toString();\\n                }\\n            }\\n            \\n        } else if (sum % 3 == 2) {\\n            // we need to find an element which gives rem == 2\\n            boolean found = false;\\n            \\n            for (int i = 0; i < n; i++) {\\n                if (arr[i] % 3 == 2) {\\n                    found = true;\\n                    // mark that value so that it is not included in ans \\n                    arr[i] = -1;\\n                    break;\\n                }\\n            }\\n            \\n            // if ele with rem = 2 is not found then we need to find 2 ele\\n            // with rem == 1\\n            if (!found) {\\n                int[] store = {-1, -1};\\n                \\n                for (int i = 0; i < n; i++) {\\n                    if (arr[i] % 3 == 1) {\\n                        if (store[0] == -1) {\\n                            store[0] = i;\\n                        } else {\\n                            store[1] = i;\\n                            break;\\n                        }\\n                    }\\n                }\\n                \\n                // now flag those 2 elements such that they are not included in ans\\n                if (store[1] != -1) {\\n                    arr[store[0]] = -1;\\n                    arr[store[1]] = -1;\\n                    \\n                } else {\\n                    return sb.toString();\\n                }\\n            }\\n        } \\n        \\n        // now we have unwanted elements marked as -1;\\n        for (int i = n - 1; i >= 0; i--) {\\n            if (arr[i] != -1) {\\n                sb.append(arr[i]);\\n            }\\n        }\\n        \\n        // in case there are many 0s at the start then we need to eliminate them\\n        \\n        if (sb.length() > 0 && sb.charAt(0) != -1 && sb.charAt(0) == \\'0\\') {\\n            StringBuilder ans = new StringBuilder();\\n            ans.append(0);\\n            return ans.toString();\\n        }\\n        \\n        return sb.toString();\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1465006,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string largestMultipleOfThree(vector<int>& nums) \\n    {\\n        int sum=0;\\n        int n=nums.size();\\n        vector<int>dp[3];\\n        for(int i=0;i<n;i++)\\n        {\\n            sum+=nums[i];\\n            dp[nums[i]%3].push_back(nums[i]);\\n        }\\n        for(int i=0;i<3;i++)\\n        {\\n            sort(dp[i].begin(),dp[i].end());\\n        }\\n        if(sum%3==1)\\n        {\\n            if(dp[1].size())\\n            {\\n                dp[1][0]=-1;\\n            }\\n            else if(dp[2].size()>=2)\\n            {\\n                dp[2][0]=-1;\\n                dp[2][1]=-1;\\n            }\\n            else \\n            {\\n                return \"\";\\n            }\\n        }\\n        else if(sum%3==2)\\n        {\\n            if(dp[2].size())\\n            {\\n                dp[2][0]=-1;\\n            }\\n            else if(dp[1].size()>=2)\\n            {\\n                dp[1][0]=-1;\\n                dp[1][1]=-1;\\n            }\\n            else\\n            {\\n                return \"\";\\n            }\\n        }\\n        string str=\"\";\\n        for(int i=0;i<3;i++)\\n        {\\n            for(auto &it:dp[i])\\n            {\\n                if(it!=-1)\\n                str.push_back(it+\\'0\\');\\n            }\\n        }\\n        sort(str.begin(),str.end());\\n        reverse(str.begin(),str.end());\\n        if(str[0]==\\'0\\')\\n        {\\n            return \"0\";\\n        }\\n        return str;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bucket Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestMultipleOfThree(vector<int>& nums) \\n    {\\n        int sum=0;\\n        int n=nums.size();\\n        vector<int>dp[3];\\n        for(int i=0;i<n;i++)\\n        {\\n            sum+=nums[i];\\n            dp[nums[i]%3].push_back(nums[i]);\\n        }\\n        for(int i=0;i<3;i++)\\n        {\\n            sort(dp[i].begin(),dp[i].end());\\n        }\\n        if(sum%3==1)\\n        {\\n            if(dp[1].size())\\n            {\\n                dp[1][0]=-1;\\n            }\\n            else if(dp[2].size()>=2)\\n            {\\n                dp[2][0]=-1;\\n                dp[2][1]=-1;\\n            }\\n            else \\n            {\\n                return \"\";\\n            }\\n        }\\n        else if(sum%3==2)\\n        {\\n            if(dp[2].size())\\n            {\\n                dp[2][0]=-1;\\n            }\\n            else if(dp[1].size()>=2)\\n            {\\n                dp[1][0]=-1;\\n                dp[1][1]=-1;\\n            }\\n            else\\n            {\\n                return \"\";\\n            }\\n        }\\n        string str=\"\";\\n        for(int i=0;i<3;i++)\\n        {\\n            for(auto &it:dp[i])\\n            {\\n                if(it!=-1)\\n                str.push_back(it+\\'0\\');\\n            }\\n        }\\n        sort(str.begin(),str.end());\\n        reverse(str.begin(),str.end());\\n        if(str[0]==\\'0\\')\\n        {\\n            return \"0\";\\n        }\\n        return str;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1408382,
                "title": "c-lengthy-but-easy-to-understand",
                "content": "```\\n\\n```public:\\n    string largestMultipleOfThree(vector<int>& digits) {\\n        vector<int>v1,v2;\\n        string res=\"\";\\n        int i,sum=0,rem;\\n        for(i=0;i<digits.size();i++)\\n        {\\n            if(digits[i]%3==0)\\n            {\\n                res.push_back((digits[i])+\\'0\\');\\n            }\\n            else if(digits[i]%3==1)\\n            {\\n                v1.push_back(digits[i]);\\n            }\\n            else\\n            {\\n                v2.push_back(digits[i]);\\n            }\\n            sum=sum+digits[i];\\n        }\\n        sort(v1.begin(),v1.end(),greater<int>());\\n        sort(v2.begin(),v2.end(),greater<int>());\\n        rem=sum%3;\\n        if(rem==1)\\n        {\\n            if(v1.size()>0)\\n            {\\n                v1.pop_back();\\n            }\\n            else if(v2.size()>1)\\n            {\\n                v2.pop_back();\\n                v2.pop_back();\\n            }\\n        }\\n        else if(rem==2)\\n        {\\n            if(v2.size()>0)\\n            {\\n                v2.pop_back();\\n            }\\n            else if(v1.size()>1)\\n            {\\n                v1.pop_back();\\n                v1.pop_back();\\n            }\\n        }\\n        for(i=0;i<v1.size();i++)\\n        {\\n           res.push_back(v1[i]+\\'0\\');\\n        }\\n        for(i=0;i<v2.size();i++)\\n        {\\n            res.push_back(v2[i]+\\'0\\');\\n        }\\n        sort(res.begin(),res.end());\\n        reverse(res.begin(),res.end());\\n        if(res.size()>1&&res[0]==\\'0\\')\\n        {\\n            return \"0\";\\n        }\\n        return res;\\n    }\\n};",
                "solutionTags": [],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1402291,
                "title": "java-using-remainder-count",
                "content": "1. Store the count of remainders of the elements in the digits array. Possible non-zero remainders are 1,2 (based on problem statement-divisible by 3).\\n2. Check if adding the remainders of 2 and 1 (i.e `(1*rem[1]+2*rem[2])%3==0`)  is divisible by 3.\\n\\t1. If yes, no need to remove elements.\\n\\t2. Else,\\n\\t\\t1. If the new remainder (i.e `(1*rem[1]+2*rem[2])%3`)  is 1, \\n\\t\\t\\t1. need to remove one element with remainder=1.\\n\\t\\t\\t(or)\\n\\t\\t\\t2. need to remove 2 elements with remainder=2. (because `2+2%3==1` or `8+8%3==1` or ...). If a%3=2;b%3=2; => a+b%3=1;\\n\\t\\t2. If the new remainder (i.e `(1*rem[1]+2*rem[2])%3`)  is 2, \\n\\t\\t\\t1. need to remove one element with remainder=2.\\n\\t\\t\\t(or)\\n\\t\\t\\t2. need to remove 2 elements with remainder=1. (because `1+1%3==1` or `7+7%3==2` or ...). If a%3=1;b%3=1; => a+b%3=2;\\n3. Now construct the number using remaining digits in the digits array. \\n\\n```\\nclass Solution {\\n    public String largestMultipleOfThree(int[] digits) {\\n        String ans=\"\";\\n        int[] rem=new int[3];\\n        int n=digits.length;\\n        for(int i=0; i<n; i++)\\n        {\\n            rem[digits[i]%3]++;\\n        }\\n        int toBeRem=(rem[1]+2*rem[2])%3;\\n        if(toBeRem!=0)\\n        {\\n            if(toBeRem==1)\\n            {\\n                if(rem[1]>0)\\n                {\\n                    rem[1]=1;//one element with remainder 1 should be removed from digits. smaller element is prefered to make the answer larger.\\n                    rem[2]=0;\\n                }\\n                else\\n                {\\n                    rem[2]=2;//two elements with remainder 2 should be removed from digits. smaller elements prefered to make the answer larger\\n                }\\n            }\\n            if(toBeRem==2)\\n            {\\n                if(rem[2]>0)\\n                {\\n                    rem[2]=1;//one element with remainder 1 should be removed from digits. smaller element is prefered to make the answer larger.\\n                    rem[1]=0;\\n                }\\n                else\\n                {\\n                    rem[1]=2;//two elements with remainder 1 should be removed from digits. smaller elements prefered to make the answer larger\\n                }\\n            }\\n        }\\n        else\\n        {\\n            rem[1]=rem[2]=0;//No element needed to be removed from digits.\\n        }\\n        Arrays.sort(digits);\\n        int start=n-1;\\n        if(digits[n-1]==0)\\n        {\\n            int i=n-2;\\n            for(; i>=0; i--)\\n            {\\n                if(digits[i]!=0)\\n                {\\n                    break;\\n                }\\n            }\\n            start=i+1;\\n        }\\n        for(int i=0; i<=start; i++)\\n        {\\n            int r=digits[i]%3;\\n            if(r>0 && rem[r]>0)\\n            {\\n                rem[r]--;\\n            }\\n            else\\n            {\\n                ans=digits[i]+ans;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String largestMultipleOfThree(int[] digits) {\\n        String ans=\"\";\\n        int[] rem=new int[3];\\n        int n=digits.length;\\n        for(int i=0; i<n; i++)\\n        {\\n            rem[digits[i]%3]++;\\n        }\\n        int toBeRem=(rem[1]+2*rem[2])%3;\\n        if(toBeRem!=0)\\n        {\\n            if(toBeRem==1)\\n            {\\n                if(rem[1]>0)\\n                {\\n                    rem[1]=1;//one element with remainder 1 should be removed from digits. smaller element is prefered to make the answer larger.\\n                    rem[2]=0;\\n                }\\n                else\\n                {\\n                    rem[2]=2;//two elements with remainder 2 should be removed from digits. smaller elements prefered to make the answer larger\\n                }\\n            }\\n            if(toBeRem==2)\\n            {\\n                if(rem[2]>0)\\n                {\\n                    rem[2]=1;//one element with remainder 1 should be removed from digits. smaller element is prefered to make the answer larger.\\n                    rem[1]=0;\\n                }\\n                else\\n                {\\n                    rem[1]=2;//two elements with remainder 1 should be removed from digits. smaller elements prefered to make the answer larger\\n                }\\n            }\\n        }\\n        else\\n        {\\n            rem[1]=rem[2]=0;//No element needed to be removed from digits.\\n        }\\n        Arrays.sort(digits);\\n        int start=n-1;\\n        if(digits[n-1]==0)\\n        {\\n            int i=n-2;\\n            for(; i>=0; i--)\\n            {\\n                if(digits[i]!=0)\\n                {\\n                    break;\\n                }\\n            }\\n            start=i+1;\\n        }\\n        for(int i=0; i<=start; i++)\\n        {\\n            int r=digits[i]%3;\\n            if(r>0 && rem[r]>0)\\n            {\\n                rem[r]--;\\n            }\\n            else\\n            {\\n                ans=digits[i]+ans;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1029797,
                "title": "python-very-fast-beats-100-o-n",
                "content": "```\\nclass Solution:\\n    def largestMultipleOfThree(self, digits: List[int]) -> str:\\n        summ = sum(digits)\\n        one_digit_for_one = (1, 4, 7)\\n        one_digit_for_two = (2, 5, 8)\\n        \\n        counter = collections.Counter(digits)\\n        def dec_count(d):\\n            counter[d] -= 1\\n            if not counter[d]:\\n                del counter[d]\\n                \\n        def check_sum(summ):\\n            if summ % 3 == 0:\\n                return True\\n            if summ % 3 == 1:\\n                for d in one_digit_for_one:\\n                    if d in counter:\\n                        dec_count(d)\\n                        return True\\n                for d1 in one_digit_for_two:\\n                    if d1 not in counter:\\n                        continue\\n                    dec_count(d1)\\n                    for d2 in one_digit_for_two:\\n                         if d2 in counter:\\n                            dec_count(d2)\\n                            return True\\n                    counter[d1] += 1\\n                return False\\n            for d in one_digit_for_two:\\n                if d in counter:\\n                    dec_count(d)\\n                    return True\\n            for d1 in one_digit_for_one:\\n                if d1 not in counter:\\n                    continue\\n                dec_count(d1)\\n                for d2 in one_digit_for_one:\\n                     if d2 in counter:\\n                        dec_count(d2)\\n                        return True\\n                counter[d1] += 1\\n            return False\\n\\n        if not check_sum(summ):\\n            return \"\"\\n        res = \"\"\\n        for d in range(9, 0, -1):\\n            if counter[d]:\\n                res += str(d)*counter[d]\\n                \\n        if counter[0]:\\n            if not res:\\n                res = \"0\"\\n            else:\\n                res += \"0\"*counter[0] \\n        return res\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def largestMultipleOfThree(self, digits: List[int]) -> str:\\n        summ = sum(digits)\\n        one_digit_for_one = (1, 4, 7)\\n        one_digit_for_two = (2, 5, 8)\\n        \\n        counter = collections.Counter(digits)\\n        def dec_count(d):\\n            counter[d] -= 1\\n            if not counter[d]:\\n                del counter[d]\\n                \\n        def check_sum(summ):\\n            if summ % 3 == 0:\\n                return True\\n            if summ % 3 == 1:\\n                for d in one_digit_for_one:\\n                    if d in counter:\\n                        dec_count(d)\\n                        return True\\n                for d1 in one_digit_for_two:\\n                    if d1 not in counter:\\n                        continue\\n                    dec_count(d1)\\n                    for d2 in one_digit_for_two:\\n                         if d2 in counter:\\n                            dec_count(d2)\\n                            return True\\n                    counter[d1] += 1\\n                return False\\n            for d in one_digit_for_two:\\n                if d in counter:\\n                    dec_count(d)\\n                    return True\\n            for d1 in one_digit_for_one:\\n                if d1 not in counter:\\n                    continue\\n                dec_count(d1)\\n                for d2 in one_digit_for_one:\\n                     if d2 in counter:\\n                        dec_count(d2)\\n                        return True\\n                counter[d1] += 1\\n            return False\\n\\n        if not check_sum(summ):\\n            return \"\"\\n        res = \"\"\\n        for d in range(9, 0, -1):\\n            if counter[d]:\\n                res += str(d)*counter[d]\\n                \\n        if counter[0]:\\n            if not res:\\n                res = \"0\"\\n            else:\\n                res += \"0\"*counter[0] \\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1026595,
                "title": "python-easy-to-understand-sort-greedy-combinations",
                "content": "```\\nclass Solution:\\n    def largestMultipleOfThree(self, digits: List[int]) -> str:\\n        \\'\\'\\'\\n        -can use a clever trick, if the sum of digits % 3 == 0, then the whole number is a multiple of 3\\n        -i can sort by digit DESC, then GREEDILY form combinations\\n        \\n         0 1 2 3 4\\n        [8,7,6,1,0]\\n        so start by trying 87610, i notice the sum of digits is not divisible by 3, so i drop the 0. still not %3, then i drop the 1 instead\\n        i = 1\\n        j = n-i\\n        8761 = digits[0:4]\\n        8760 = digits[0:3] + digits[4:]\\n        8710 = digits[0:2] + digits[3:]\\n        8610 = digits[0:1] + digits[2:]\\n        7610 = digits[0:0] + digits[1:]\\n        876  = digits[0:3] + digits[]\\n        870\\n        810\\n        610\\n        .\\n        .\\n        .\\n        .\\n        \"\"  - if i end up deleting everything and I still haven\\'t returned something yet, return empty string\\n        \\n        \\'\\'\\'\\n        \\n        digits.sort(reverse=True)\\n        \\n        def checkValid(arr):\\n            if sum(arr) % 3 == 0:\\n                return True\\n            return False\\n            \\n        if checkValid(digits):\\n            return str(int(\\'\\'.join(map(str,digits))))\\n        \\n        n = len(digits)\\n        for i in range(1,n): #i is the deletion chunk size\\n            for j in range(n-i, -1, -1):                \\n                newGeneratedArr = digits[0:j] + digits[j+i:]\\n                #print(newGeneratedArr)\\n                if checkValid(newGeneratedArr):\\n                    return \\'\\'.join(map(str,newGeneratedArr))\\n                \\n        return \"\"\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def largestMultipleOfThree(self, digits: List[int]) -> str:\\n        \\'\\'\\'\\n        -can use a clever trick, if the sum of digits % 3 == 0, then the whole number is a multiple of 3\\n        -i can sort by digit DESC, then GREEDILY form combinations\\n        \\n         0 1 2 3 4\\n        [8,7,6,1,0]\\n        so start by trying 87610, i notice the sum of digits is not divisible by 3, so i drop the 0. still not %3, then i drop the 1 instead\\n        i = 1\\n        j = n-i\\n        8761 = digits[0:4]\\n        8760 = digits[0:3] + digits[4:]\\n        8710 = digits[0:2] + digits[3:]\\n        8610 = digits[0:1] + digits[2:]\\n        7610 = digits[0:0] + digits[1:]\\n        876  = digits[0:3] + digits[]\\n        870\\n        810\\n        610\\n        .\\n        .\\n        .\\n        .\\n        \"\"  - if i end up deleting everything and I still haven\\'t returned something yet, return empty string\\n        \\n        \\'\\'\\'\\n        \\n        digits.sort(reverse=True)\\n        \\n        def checkValid(arr):\\n            if sum(arr) % 3 == 0:\\n                return True\\n            return False\\n            \\n        if checkValid(digits):\\n            return str(int(\\'\\'.join(map(str,digits))))\\n        \\n        n = len(digits)\\n        for i in range(1,n): #i is the deletion chunk size\\n            for j in range(n-i, -1, -1):                \\n                newGeneratedArr = digits[0:j] + digits[j+i:]\\n                #print(newGeneratedArr)\\n                if checkValid(newGeneratedArr):\\n                    return \\'\\'.join(map(str,newGeneratedArr))\\n                \\n        return \"\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 994941,
                "title": "c-simple-solution-case-based-with-examples",
                "content": "Basic math thing first : **If sum of digits is divisble by 3 then, number is divisible by 3 too.**\\nFor example.1, (Test Case 1 [8,1,9]) here sum of digits is 18 which is divisble by 3, hence any number made up of 8,1,9 should be divisible by 3 too, like 819, 918, 981 all are divisible by 3.\\n**Trick : As we have to return max number, hence we will return sorted array in decreasing order as number i.e, 981 for example.1.**\\n\\n**Now let\\'s come to the possible cases:\\nCase 1: (sum of digits)%3 == 0\\nCase 2: (sum of digits)%3 == 1\\nCase 3: (sum of digits)%3 == 2**\\n\\nQucik Analysis:\\n**Case 1: \\nReturn the sorted array in decreasing order as it should be divisible by 3**\\n\\n**Case 2:\\n2.1. \\nRemove the smallest number(n) from the array(as the biggest number should have the most number of digits), such that n%3 == 1, this will make the sum of remaining numbers divible by 3**.\\nexample.2 : [8,6,1,0,1]\\nStep 1: sort this number : [0,1,1,6,8]\\nStep 2: remove smallest number(n) from the array, such that n%3 == 1. Here n = 1, hence remove 1 -> Result : new digits = [0,1,6,8]\\nStep 3: Return sorted array(decreasing order) as string, ie, 8610\\n\\n**2.2.\\nWhat if there is no such n, such that n%3==1 in digits array, for eg., [8,2,2,2,2].\\nThen remove the smallest two numbers(n1 and n2) from array, such that n1%3==2 && n2%3==2. Actually, the logic behind is (n1+n2)%3==1**.\\nexample 3. [2,8,2,2,2]\\nStep 1: sort : [2,2,2,2,8]\\nStep 2: emove the smallest two numbers(n1 and n2) from array, such that n1%3==2 && n2%3==2. Here n1 = 2 and n2 = 2, hence, remove two 2\\'s -> Result : new digits = [2,2,8]\\nStep 3: Return sorted array(decreasing order) as string, ie, 822\\n\\n**Case 3: (Vice-Versa of Case 2)\\n3.1. \\nRemove the smallest number(n) from the array(as the biggest number should have the most number of digits), such that n%3 == 2, this will make the sum of remaining numbers divible by 3.**\\nexample.4 : [1,2,1,0,1]\\nStep 1: sort this number : [0,1,1,1,2]\\nStep 2: remove smallest number(n) from the array, such that n%3 == 2. Here n = 2, hence remove 2 -> Result : new digits = [0,1,1,1]\\nStep 3: Return sorted array(decreasing order) as string, ie, 1110\\n\\n**3.2.\\nWhat if there is no such n, such that n%3==1 in digits array, for eg., [1,1,1,0,1,1].\\nThen remove the smallest two numbers(n1 and n2) from array, such that n1%3==1 && n2%3==1. Actually, the logic behind is (n1+n2)%3==2**.\\nexample 5. [1,1,1,0,1,1]\\nStep 1: sort : [0,1,1,1,1,1]\\nStep 2: emove the smallest two numbers(n1 and n2) from array, such that n1%3==2 && n2%3==2. Here n1 = 1 and n2 = 1, hence, remove two 1\\'s -> Result : new digits = [0,1,1,1]\\nStep 3: Return sorted array(decreasing order) as string, ie, 1110\\n\\n**Note : We will first try to check for Case 2.1 then Case 2.2, as Case 2.1 have highest number of digits(one more to that of Case 2.2). The same will be done for Case 3.**\\n\\n```\\nclass Solution {\\npublic:\\n    string largestMultipleOfThree(vector<int>& digits) {\\n        vector<int> nums = digits;\\n        sort(begin(nums), end(nums));\\n        int isAnsFound = 0;\\n        string ans = \"\";\\n        int sum = 0;\\n        for(int i = 0; i < nums.size(); i++)\\n            sum += nums[i];\\n        cout << sum << endl;\\n        if(sum == 0)\\n            return \"0\";\\n        if(sum%3 == 0)\\n        {\\n            cout << \"CASE 1\";\\n            for(int i = nums.size()-1; i >= 0; i--)\\n                ans = ans + to_string(nums[i]);\\n            return ans;\\n        }\\n        else if(sum%3 == 1)\\n        {\\n            cout << \"CASE 2\";\\n            int flagIsMod1 = 0;\\n            for(int i = 0; i < nums.size(); i++)\\n                if(nums[i]%3 == 1)\\n                {\\n                    cout << \"CASE 2.A\";\\n                    nums.erase(nums.begin() + i);\\n                    flagIsMod1 = 1;\\n                    break;\\n                }\\n            if(0 == flagIsMod1)\\n            {\\n                cout << \"CASE 2.B\";\\n                int removeMod2Twice = 0;\\n                for(int i = 0; i < nums.size(); i++)\\n                if(nums[i]%3 == 2)\\n                {\\n                    nums.erase(nums.begin() + i);\\n                    i--;\\n                    removeMod2Twice++;\\n                    if(2 == removeMod2Twice)\\n                    {\\n                        isAnsFound = 1;\\n                        break;\\n                    }\\n                        \\n                }\\n            }\\n            if(1 == isAnsFound || 1 == flagIsMod1)\\n            {\\n                for(int i = nums.size()-1; i >= 0; i--)\\n                    ans = ans + to_string(nums[i]);\\n            }\\n            \\n            return ans;\\n        }\\n        else\\n        {\\n            cout << \"CASE 3 - \";\\n            //Find it nums%3 == 2 is there or not\\n            int flagIsMod2 = 0;\\n            for(int i = 0; i < nums.size(); i++)\\n                if(nums[i]%3 == 2)\\n                {\\n                    cout << \"CASE 3.A\";\\n                    nums.erase(nums.begin() + i);\\n                    flagIsMod2 = 1;\\n                    break;\\n                }\\n            if(0 == flagIsMod2)\\n            {\\n                cout << \"CASE 3.B\";\\n                int removeMod1Twice = 0;\\n                for(int i = 0; i < nums.size(); i++)\\n                if(nums[i]%3 == 1)\\n                {\\n                    nums.erase(nums.begin() + i);\\n                    i--;\\n                    removeMod1Twice++;\\n                    if(2 == removeMod1Twice)\\n                    {\\n                        isAnsFound = 1;\\n                        break;\\n                    }\\n                        \\n                }\\n            }\\n            if(1 == isAnsFound || 1 == flagIsMod2)\\n            {\\n                for(int i = nums.size()-1; i >= 0; i--)\\n                    ans = ans + to_string(nums[i]);\\n            }\\n            return ans;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestMultipleOfThree(vector<int>& digits) {\\n        vector<int> nums = digits;\\n        sort(begin(nums), end(nums));\\n        int isAnsFound = 0;\\n        string ans = \"\";\\n        int sum = 0;\\n        for(int i = 0; i < nums.size(); i++)\\n            sum += nums[i];\\n        cout << sum << endl;\\n        if(sum == 0)\\n            return \"0\";\\n        if(sum%3 == 0)\\n        {\\n            cout << \"CASE 1\";\\n            for(int i = nums.size()-1; i >= 0; i--)\\n                ans = ans + to_string(nums[i]);\\n            return ans;\\n        }\\n        else if(sum%3 == 1)\\n        {\\n            cout << \"CASE 2\";\\n            int flagIsMod1 = 0;\\n            for(int i = 0; i < nums.size(); i++)\\n                if(nums[i]%3 == 1)\\n                {\\n                    cout << \"CASE 2.A\";\\n                    nums.erase(nums.begin() + i);\\n                    flagIsMod1 = 1;\\n                    break;\\n                }\\n            if(0 == flagIsMod1)\\n            {\\n                cout << \"CASE 2.B\";\\n                int removeMod2Twice = 0;\\n                for(int i = 0; i < nums.size(); i++)\\n                if(nums[i]%3 == 2)\\n                {\\n                    nums.erase(nums.begin() + i);\\n                    i--;\\n                    removeMod2Twice++;\\n                    if(2 == removeMod2Twice)\\n                    {\\n                        isAnsFound = 1;\\n                        break;\\n                    }\\n                        \\n                }\\n            }\\n            if(1 == isAnsFound || 1 == flagIsMod1)\\n            {\\n                for(int i = nums.size()-1; i >= 0; i--)\\n                    ans = ans + to_string(nums[i]);\\n            }\\n            \\n            return ans;\\n        }\\n        else\\n        {\\n            cout << \"CASE 3 - \";\\n            //Find it nums%3 == 2 is there or not\\n            int flagIsMod2 = 0;\\n            for(int i = 0; i < nums.size(); i++)\\n                if(nums[i]%3 == 2)\\n                {\\n                    cout << \"CASE 3.A\";\\n                    nums.erase(nums.begin() + i);\\n                    flagIsMod2 = 1;\\n                    break;\\n                }\\n            if(0 == flagIsMod2)\\n            {\\n                cout << \"CASE 3.B\";\\n                int removeMod1Twice = 0;\\n                for(int i = 0; i < nums.size(); i++)\\n                if(nums[i]%3 == 1)\\n                {\\n                    nums.erase(nums.begin() + i);\\n                    i--;\\n                    removeMod1Twice++;\\n                    if(2 == removeMod1Twice)\\n                    {\\n                        isAnsFound = 1;\\n                        break;\\n                    }\\n                        \\n                }\\n            }\\n            if(1 == isAnsFound || 1 == flagIsMod2)\\n            {\\n                for(int i = nums.size()-1; i >= 0; i--)\\n                    ans = ans + to_string(nums[i]);\\n            }\\n            return ans;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 973516,
                "title": "inspired-by-votrubac",
                "content": "```\\nclass Solution {\\npublic:\\n    string largestMultipleOfThree(vector<int>& digits) {\\n        \\n        int as[6] = { 1, 4 ,7, 2, 5, 8 };\\n        int ar[6] = { 2, 5, 8, 1, 4 ,7 };\\n        \\n        int d[10]={0};\\n        int sum =0;\\n        string res = \"\";\\n        for(auto i : digits){\\n            d[i]++;\\n            sum+=i;\\n        }\\n        while(sum%3!=0){\\n            \\n            for(auto i : (sum%3==1)? as : ar){\\n                \\n                if(d[i]){\\n                    d[i]--;\\n                    sum-=i;\\n                    break;\\n                }\\n                \\n                \\n                \\n                \\n            }\\n        }\\n        \\n        for(int i =0; i<10; i++){\\n            for(int j =0; j<d[i]; j++){\\n                res+=(i+ \\'0\\');\\n            }\\n        }\\n        sort(res.begin(),res.end());\\n        reverse(res.begin(),res.end());\\n        \\n        if(res.size() && res[0]==\\'0\\'){\\n            return  \"0\";\\n        }\\n        return res;\\n        //cout<<sum<<endl;\\n        return \"\";\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestMultipleOfThree(vector<int>& digits) {\\n        \\n        int as[6] = { 1, 4 ,7, 2, 5, 8 };\\n        int ar[6] = { 2, 5, 8, 1, 4 ,7 };\\n        \\n        int d[10]={0};\\n        int sum =0;\\n        string res = \"\";\\n        for(auto i : digits){\\n            d[i]++;\\n            sum+=i;\\n        }\\n        while(sum%3!=0){\\n            \\n            for(auto i : (sum%3==1)? as : ar){\\n                \\n                if(d[i]){\\n                    d[i]--;\\n                    sum-=i;\\n                    break;\\n                }\\n                \\n                \\n                \\n                \\n            }\\n        }\\n        \\n        for(int i =0; i<10; i++){\\n            for(int j =0; j<d[i]; j++){\\n                res+=(i+ \\'0\\');\\n            }\\n        }\\n        sort(res.begin(),res.end());\\n        reverse(res.begin(),res.end());\\n        \\n        if(res.size() && res[0]==\\'0\\'){\\n            return  \"0\";\\n        }\\n        return res;\\n        //cout<<sum<<endl;\\n        return \"\";\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 892399,
                "title": "simple-c-solution",
                "content": "The idea is encouraged by this post: https://leetcode.com/problems/largest-multiple-of-three/discuss/517628/Python-Basic-Math\\n\\nResult:\\n**Runtime: 8 ms, faster than 100.00% of C++ online submissions for Largest Multiple of Three.\\nMemory Usage: 13.1 MB, less than 5.76% of C++ online submissions for Largest Multiple of Three.**\\n\\n```\\nclass Solution {\\npublic:\\n    string largestMultipleOfThree(vector<int>& digits) {\\n        ios::sync_with_stdio(false); cin.tie(nullptr);\\n        int table[10] = {0}, sum = 0;\\n        for(int e : digits)\\n            table[e]++, sum += e;\\n        \\n        sum %= 3;\\n        if(sum){\\n            if(table[sum] + table[sum + 3] + table[sum + 6]) table[sum]--;\\n            else table[3 - sum] -= 2;\\n        }\\n        \\n        for(int i = 1; i < 10; i++)\\n            if(table[i] < 0)\\n                table[i + 3] += table[i], table[i] = 0;\\n        string res = \"\";\\n        for(int i = 9; i >= 0; i--)\\n            while(table[i]--)\\n                res += i + \\'0\\';\\n        return res[0] == \\'0\\' ? \"0\" : res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestMultipleOfThree(vector<int>& digits) {\\n        ios::sync_with_stdio(false); cin.tie(nullptr);\\n        int table[10] = {0}, sum = 0;\\n        for(int e : digits)\\n            table[e]++, sum += e;\\n        \\n        sum %= 3;\\n        if(sum){\\n            if(table[sum] + table[sum + 3] + table[sum + 6]) table[sum]--;\\n            else table[3 - sum] -= 2;\\n        }\\n        \\n        for(int i = 1; i < 10; i++)\\n            if(table[i] < 0)\\n                table[i + 3] += table[i], table[i] = 0;\\n        string res = \"\";\\n        for(int i = 9; i >= 0; i--)\\n            while(table[i]--)\\n                res += i + \\'0\\';\\n        return res[0] == \\'0\\' ? \"0\" : res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 827779,
                "title": "simple-java-solution",
                "content": "```\\npublic String largestMultipleOfThree(int[] digits) {\\n\\t\\tStringBuffer s = new StringBuffer();\\n\\t\\t//sort array \\n\\t\\tArrays.sort(digits);\\n\\t\\t//rule of divisibility of 3 : if sum of the numbers are divided by three then the array is divided by three\\n\\t\\tint sum = sum(digits);\\n\\t\\t// System.out.println(sum);\\n\\t\\t//if its a empty array\\n\\t\\tif (sum == 0) {\\n\\t\\t\\treturn \"0\";\\n\\t\\t}\\n\\t\\t//if sum is divided by 3 nothing to change just reverse the array to print largest divisible of three\\n\\t\\telse if (sum % 3 == 0) {\\n\\t\\t//get values in reverse order\\n\\t\\t\\tfor (int i = digits.length - 1; i >= 0; i--) {\\n\\t\\t\\t//appending to String\\n\\t\\t\\t\\ts.append(Integer.toString(digits[i]));\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t//if the sum is not divided by 3 : subtract each element of the array from the sum\\n\\t\\telse {\\n\\n\\t\\t\\tfor (int i = 0; i < digits.length; i++) {\\n\\t\\t\\t//subtracting each digit from sum\\n\\t\\t\\t\\tint number = sum - digits[i];\\n\\t\\t\\t\\t//check whether the number is divided by 3\\n\\t\\t\\t\\tif (number % 3 == 0) {\\n//String values from reverse to get largest value\\n\\t\\t\\t\\t\\tfor (int j = digits.length - 1; j >= 0; j--) {\\n\\t\\t\\t\\t\\t//avoiding the subtracted element\\n\\t\\t\\t\\t\\t\\tif (j == i) {\\n\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t//appending to string\\n\\t\\t\\t\\t\\t\\t\\ts.append(Integer.toString(digits[j]));\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t//stoping iteration\\n\\t\\t\\t\\t\\ti = digits.length - 1;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\t\\t\\t//if still the string is empty : reason : (even if the sum with subtracting an element is also not divisible by 3)\\n\\t\\t\\tif (s.length() == 0) {\\n\\t\\t\\t\\tfor (int i = 0; i < digits.length - 1; i++) {\\n\\t\\t\\t\\t//subtracting two elements from array \\n\\t\\t\\t\\t\\tint number = sum - (digits[i] + digits[i + 1]);\\n\\t\\t\\t\\t\\tif (number % 3 == 0 && number!=0) {\\n\\t\\t\\t\\t\\t\\tfor (int j = digits.length - 1; j >= 0; j--) {\\n\\t\\t\\t\\t\\t\\t\\tif (digits[j] == digits[i]) {\\n\\t\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\t\\ts.append(Integer.toString(digits[j]));\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\n\\t\\t}\\n\\t\\t//returning the string \\n\\t\\treturn s.toString();\\n\\t}\\n//function which returns sum of the array\\n\\tpublic static int sum(int[] digits) {\\n\\t\\tint sum = 0;\\n\\t\\tfor (int i = 0; i < digits.length; i++) {\\n\\t\\t\\tsum += digits[i];\\n\\t\\t}\\n\\t\\treturn sum;\\n\\t}\\n\\t",
                "solutionTags": [],
                "code": "```\\npublic String largestMultipleOfThree(int[] digits) {\\n\\t\\tStringBuffer s = new StringBuffer();\\n\\t\\t//sort array \\n\\t\\tArrays.sort(digits);\\n\\t\\t//rule of divisibility of 3 : if sum of the numbers are divided by three then the array is divided by three\\n\\t\\tint sum = sum(digits);\\n\\t\\t// System.out.println(sum);\\n\\t\\t//if its a empty array\\n\\t\\tif (sum == 0) {\\n\\t\\t\\treturn \"0\";\\n\\t\\t}\\n\\t\\t//if sum is divided by 3 nothing to change just reverse the array to print largest divisible of three\\n\\t\\telse if (sum % 3 == 0) {\\n\\t\\t//get values in reverse order\\n\\t\\t\\tfor (int i = digits.length - 1; i >= 0; i--) {\\n\\t\\t\\t//appending to String\\n\\t\\t\\t\\ts.append(Integer.toString(digits[i]));\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t//if the sum is not divided by 3 : subtract each element of the array from the sum\\n\\t\\telse {\\n\\n\\t\\t\\tfor (int i = 0; i < digits.length; i++) {\\n\\t\\t\\t//subtracting each digit from sum\\n\\t\\t\\t\\tint number = sum - digits[i];\\n\\t\\t\\t\\t//check whether the number is divided by 3\\n\\t\\t\\t\\tif (number % 3 == 0) {\\n//String values from reverse to get largest value\\n\\t\\t\\t\\t\\tfor (int j = digits.length - 1; j >= 0; j--) {\\n\\t\\t\\t\\t\\t//avoiding the subtracted element\\n\\t\\t\\t\\t\\t\\tif (j == i) {\\n\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t//appending to string\\n\\t\\t\\t\\t\\t\\t\\ts.append(Integer.toString(digits[j]));\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t//stoping iteration\\n\\t\\t\\t\\t\\ti = digits.length - 1;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\t\\t\\t//if still the string is empty : reason : (even if the sum with subtracting an element is also not divisible by 3)\\n\\t\\t\\tif (s.length() == 0) {\\n\\t\\t\\t\\tfor (int i = 0; i < digits.length - 1; i++) {\\n\\t\\t\\t\\t//subtracting two elements from array \\n\\t\\t\\t\\t\\tint number = sum - (digits[i] + digits[i + 1]);\\n\\t\\t\\t\\t\\tif (number % 3 == 0 && number!=0) {\\n\\t\\t\\t\\t\\t\\tfor (int j = digits.length - 1; j >= 0; j--) {\\n\\t\\t\\t\\t\\t\\t\\tif (digits[j] == digits[i]) {\\n\\t\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\t\\ts.append(Integer.toString(digits[j]));\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\n\\t\\t}\\n\\t\\t//returning the string \\n\\t\\treturn s.toString();\\n\\t}\\n//function which returns sum of the array\\n\\tpublic static int sum(int[] digits) {\\n\\t\\tint sum = 0;\\n\\t\\tfor (int i = 0; i < digits.length; i++) {\\n\\t\\t\\tsum += digits[i];\\n\\t\\t}\\n\\t\\treturn sum;\\n\\t}\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 818388,
                "title": "double-100-performance-o-n-c-solution",
                "content": "Surprisingly simple solution using counting sort and applying constraints on how many digits from each equivalence class mod 3 are allowed in the final answer.\\n```C\\nchar *largestMultipleOfThree(int *digits, int digitsSize)\\n{\\n\\t//make enough space for all digits + null terminator\\n    char *ret = malloc(digitsSize+1), *ptr = ret;\\n    \\n\\t//counting sort + tracking of how many of each modulus + overall sum\\n    int counts[10] = {0}, mod_buckets[3] = {0}, sum = 0;\\n    for(int i = 0; i < digitsSize; ++i)\\n    {\\n        sum += digits[i];\\n        counts[digits[i]] += 1;\\n        mod_buckets[digits[i]%3] += 1;\\n    }\\n    \\n\\t//adjust counts if the sum is not already divisible by three\\n    if(sum % 3 != 0)\\n\\t\\t//check if we can get rid of a single number matching current remainder\\n        if(mod_buckets[sum % 3] > 0)\\n            mod_buckets[sum % 3] -= 1;\\n\\t\\t//otherwise we need to remove two numbers with the other non-zero remainder\\n        else\\n            mod_buckets[3 - (sum % 3)]-=2;\\n    \\n\\t//handle special case of zero to avoid returning \"00..00\"\\n    if(sum == 0)\\n        counts[0] = 1;\\n    \\n\\t//put in digits largest first, limited by their count in\\n\\t//the input and by how many are allowed from their modulus\\n    for(int i = 9; i >= 0; --i)\\n        while(counts[i]-- > 0 && mod_buckets[i%3]-- > 0)\\n            *ptr++ = \\'0\\'+i;\\n\\n    //null terminate the string\\n\\t*ptr=\\'\\\\0\\';\\n    return ret;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Counting Sort"
                ],
                "code": "```C\\nchar *largestMultipleOfThree(int *digits, int digitsSize)\\n{\\n\\t//make enough space for all digits + null terminator\\n    char *ret = malloc(digitsSize+1), *ptr = ret;\\n    \\n\\t//counting sort + tracking of how many of each modulus + overall sum\\n    int counts[10] = {0}, mod_buckets[3] = {0}, sum = 0;\\n    for(int i = 0; i < digitsSize; ++i)\\n    {\\n        sum += digits[i];\\n        counts[digits[i]] += 1;\\n        mod_buckets[digits[i]%3] += 1;\\n    }\\n    \\n\\t//adjust counts if the sum is not already divisible by three\\n    if(sum % 3 != 0)\\n\\t\\t//check if we can get rid of a single number matching current remainder\\n        if(mod_buckets[sum % 3] > 0)\\n            mod_buckets[sum % 3] -= 1;\\n\\t\\t//otherwise we need to remove two numbers with the other non-zero remainder\\n        else\\n            mod_buckets[3 - (sum % 3)]-=2;\\n    \\n\\t//handle special case of zero to avoid returning \"00..00\"\\n    if(sum == 0)\\n        counts[0] = 1;\\n    \\n\\t//put in digits largest first, limited by their count in\\n\\t//the input and by how many are allowed from their modulus\\n    for(int i = 9; i >= 0; --i)\\n        while(counts[i]-- > 0 && mod_buckets[i%3]-- > 0)\\n            *ptr++ = \\'0\\'+i;\\n\\n    //null terminate the string\\n\\t*ptr=\\'\\\\0\\';\\n    return ret;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 796644,
                "title": "top-down-dynamic-progrramming",
                "content": "```\\nclass Solution {\\n    vector<vector<string>> dp;\\npublic:\\n    string largestMultipleOfThree(vector<int>& digits) {\\n        sort(digits.rbegin(), digits.rend());\\n        //check the zero condition\\n        auto sum = accumulate(digits.begin(), digits.end(),0);\\n        if(sum == 0) return \"0\";\\n        //check all digits are multiple of three\\n        if(sum%3 == 0){\\n            string number(digits.size(),\\'0\\');\\n            for(int i=0; i<digits.size(); ++i){\\n                number[i] +=digits[i];\\n            }\\n            return number;\\n        }\\n        dp.resize(digits.size()+1, vector<string>(3, \"\"));\\n        return solve(digits, 0, 0);\\n    }\\n    \\n    string solve(vector<int>& digits, int ind, int mod){\\n        if(ind >= digits.size()){\\n            if(mod == 0) return \"\";\\n            return \"-\";\\n        }\\n        \\n        if(dp[ind][mod] != \"\") return dp[ind][mod];\\n        auto with = solve(digits, ind+1, (mod+digits[ind])%3);\\n        auto without = solve(digits, ind+1, mod);\\n        if(with == \"-\") return dp[ind][mod] = without;\\n        if(without == \"-\"){\\n            if(with == \"-\") return with;\\n            return dp[ind][mod] = to_string(digits[ind]) + with;\\n        }\\n        if(without.size() > with.size()+1){\\n            with = without;\\n        }else{\\n            with = to_string(digits[ind]) + with;\\n        }\\n        return dp[ind][mod] = with;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n    vector<vector<string>> dp;\\npublic:\\n    string largestMultipleOfThree(vector<int>& digits) {\\n        sort(digits.rbegin(), digits.rend());\\n        //check the zero condition\\n        auto sum = accumulate(digits.begin(), digits.end(),0);\\n        if(sum == 0) return \"0\";\\n        //check all digits are multiple of three\\n        if(sum%3 == 0){\\n            string number(digits.size(),\\'0\\');\\n            for(int i=0; i<digits.size(); ++i){\\n                number[i] +=digits[i];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 714764,
                "title": "python3-o-n-by-counting-digit-frequencies-very-fast",
                "content": "There is no reason to sort the digits. Simply keep track of the frequencies of each of the ten different digits 0,1,...,9 in a list and reconstruct the number at the end.\\n\\n```\\ndef largestMultipleOfThree(self, digits):\\n     counts = [0]*10\\n     for d in digits:\\n         counts[d] += 1\\n     m = sum(digits) % 3\\n\\t if m:\\n         if counts[m] + counts[m+3] + counts[m+6]:\\n             counts[min([m+i for i in [0,3,6] if counts[m+i]])] -= 1\\n         else:\\n             counts[min([i-m for i in [3,6,9] if counts[i-m]])] -= 1\\n             counts[min([i-m for i in [3,6,9] if counts[i-m]])] -= 1\\n     out = sum([[str(i)]*counts[i] for i in range(9,-1,-1)],[])\\n     if out:\\n         return (\\'\\'.join(out)).lstrip(\\'0\\') or \\'0\\'\\n     return \\'\\'\\n```\\nDescription:\\n* First count the frequency of each of the digits.\\n* Compute `m`, the sum digits modulo 3. \\n   - If `m` is zero there is nothing to remove. \\n   - If there is at least one digit congruent to `m` modulo 3, reduce the count of the smallest such digit by one. \\n   - Otherwise, reduce the counts of the smallest digits that are congruent to `-m` modulo 3 by two. \\n* Finally, construct the output by adding `counts[i]` copies of digit `i` for each `i` in the range 9,8,...,0\\n\\nComplexity:\\n- Time: `O(n)` (No sorting required; only need to pass through the array once to count the frequencies of the digits.)\\n- Space: `O(1)` (Although technically construcing the final output string requires `O(n)` space.)\\n",
                "solutionTags": [],
                "code": "```\\ndef largestMultipleOfThree(self, digits):\\n     counts = [0]*10\\n     for d in digits:\\n         counts[d] += 1\\n     m = sum(digits) % 3\\n\\t if m:\\n         if counts[m] + counts[m+3] + counts[m+6]:\\n             counts[min([m+i for i in [0,3,6] if counts[m+i]])] -= 1\\n         else:\\n             counts[min([i-m for i in [3,6,9] if counts[i-m]])] -= 1\\n             counts[min([i-m for i in [3,6,9] if counts[i-m]])] -= 1\\n     out = sum([[str(i)]*counts[i] for i in range(9,-1,-1)],[])\\n     if out:\\n         return (\\'\\'.join(out)).lstrip(\\'0\\') or \\'0\\'\\n     return \\'\\'\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 653160,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string largestMultipleOfThree(vector<int>& digits) {\\n        int N = digits.size();\\n        vector<vector<vector<int>>> dp(N, vector<vector<int>>(3, {0, -1}));\\n        sort(digits.begin(), digits.end(), greater<int>());\\n        \\n        if (digits[0] == 0) {\\n            return \"0\";\\n        }\\n        \\n        int maxidx = -1, best0idx = -1, best1idx = -1, best2idx = -1;\\n        \\n        for (int i = 0; i < N; ++i) {\\n            int m = digits[i] % 3;\\n            dp[i][m][0] = 1; \\n            dp[i][m][1] = -1;\\n\\n            if (m == 0) {\\n                if (best0idx != -1 && dp[i][0][0] < dp[best0idx][0][0] + 1) {\\n                    dp[i][0][0] = dp[best0idx][0][0] + 1;\\n                    dp[i][0][1] = best0idx;\\n                }\\n                if (best1idx != -1 && (dp[i][1][0] < dp[best1idx][1][0] + 1)) {\\n                    dp[i][1][0] = dp[best1idx][1][0] + 1;\\n                    dp[i][1][1] = best1idx;\\n                }\\n                if (best2idx != -1 && (dp[i][2][0] < dp[best2idx][2][0] + 1)) {\\n                    dp[i][2][0] = dp[best2idx][2][0] + 1;\\n                    dp[i][2][1] = best2idx;\\n                }\\n            } else if (m == 1) {\\n                if (best2idx != -1 && (dp[i][0][0] < dp[best2idx][2][0] + 1)) {\\n                    dp[i][0][0] = dp[best2idx][2][0] + 1;\\n                    dp[i][0][1] = best2idx;\\n                }\\n                if (best0idx != -1 && dp[i][1][0] < dp[best0idx][0][0] + 1) {\\n                    dp[i][1][0] = dp[best0idx][0][0] + 1;\\n                    dp[i][1][1] = best0idx;\\n                }\\n                if (best1idx != -1 && (dp[i][2][0] < dp[best1idx][1][0] + 1)) {\\n                    dp[i][2][0] = dp[best1idx][1][0] + 1;\\n                    dp[i][2][1] = best1idx;\\n                }\\n            } else if (m == 2) {\\n                if (best1idx != -1 && (dp[i][0][0] < dp[best1idx][1][0] + 1)) {\\n                    dp[i][0][0] = dp[best1idx][1][0] + 1;\\n                    dp[i][0][1] = best1idx;\\n                }\\n                if (best2idx != -1 && (dp[i][1][0] < dp[best2idx][2][0] + 1)) {\\n                    dp[i][1][0] = dp[best2idx][2][0] + 1;\\n                    dp[i][1][1] = best2idx;\\n                }\\n                if (best0idx != -1 && dp[i][2][0] < dp[best0idx][0][0] + 1) {\\n                    dp[i][2][0] = dp[best0idx][0][0] + 1;\\n                    dp[i][2][1] = best0idx;\\n                }\\n            }\\n            if (dp[i][0][0]) {\\n                if (best0idx == -1 || dp[best0idx][0][0] < dp[i][0][0]) {\\n                    best0idx = i;    \\n                }\\n            }\\n            if (dp[i][1][0]) {\\n                if (best1idx == -1 || dp[best1idx][1][0] < dp[i][1][0]) {\\n                    best1idx = i;    \\n                }\\n            }\\n            if (dp[i][2][0]) {\\n                if (best2idx == -1 || dp[best2idx][2][0] < dp[i][2][0]) {\\n                    best2idx = i;    \\n                }\\n            }\\n            if (dp[i][0][0]) {\\n                if (maxidx == -1) {\\n                    maxidx = i;\\n                } else if (dp[maxidx][0][0] < dp[i][0][0]) {\\n                    maxidx = i;\\n                }\\n            }\\n        }\\n        \\n        int i = maxidx;\\n        int sum = 0;\\n        string result;\\n        \\n        while (i != -1) {\\n            result.push_back(\\'0\\' + digits[i]);\\n            int m = sum % 3;\\n            sum += digits[i];\\n            \\n            switch (m) {\\n                case 0:\\n                    i = dp[i][0][1];\\n                    break;\\n                    \\n                case 1:\\n                    i = dp[i][2][1];\\n                    break;\\n                    \\n                case 2:\\n                    i = dp[i][1][1];\\n                    break;\\n                    \\n                default:\\n                    assert(false);\\n            }\\n        }\\n        \\n        reverse(result.begin(), result.end());\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestMultipleOfThree(vector<int>& digits) {\\n        int N = digits.size();\\n        vector<vector<vector<int>>> dp(N, vector<vector<int>>(3, {0, -1}));\\n        sort(digits.begin(), digits.end(), greater<int>());\\n        \\n        if (digits[0] == 0) {\\n            return \"0\";\\n        }\\n        \\n        int maxidx = -1, best0idx = -1, best1idx = -1, best2idx = -1;\\n        \\n        for (int i = 0; i < N; ++i) {\\n            int m = digits[i] % 3;\\n            dp[i][m][0] = 1; \\n            dp[i][m][1] = -1;\\n\\n            if (m == 0) {\\n                if (best0idx != -1 && dp[i][0][0] < dp[best0idx][0][0] + 1) {\\n                    dp[i][0][0] = dp[best0idx][0][0] + 1;\\n                    dp[i][0][1] = best0idx;\\n                }\\n                if (best1idx != -1 && (dp[i][1][0] < dp[best1idx][1][0] + 1)) {\\n                    dp[i][1][0] = dp[best1idx][1][0] + 1;\\n                    dp[i][1][1] = best1idx;\\n                }\\n                if (best2idx != -1 && (dp[i][2][0] < dp[best2idx][2][0] + 1)) {\\n                    dp[i][2][0] = dp[best2idx][2][0] + 1;\\n                    dp[i][2][1] = best2idx;\\n                }\\n            } else if (m == 1) {\\n                if (best2idx != -1 && (dp[i][0][0] < dp[best2idx][2][0] + 1)) {\\n                    dp[i][0][0] = dp[best2idx][2][0] + 1;\\n                    dp[i][0][1] = best2idx;\\n                }\\n                if (best0idx != -1 && dp[i][1][0] < dp[best0idx][0][0] + 1) {\\n                    dp[i][1][0] = dp[best0idx][0][0] + 1;\\n                    dp[i][1][1] = best0idx;\\n                }\\n                if (best1idx != -1 && (dp[i][2][0] < dp[best1idx][1][0] + 1)) {\\n                    dp[i][2][0] = dp[best1idx][1][0] + 1;\\n                    dp[i][2][1] = best1idx;\\n                }\\n            } else if (m == 2) {\\n                if (best1idx != -1 && (dp[i][0][0] < dp[best1idx][1][0] + 1)) {\\n                    dp[i][0][0] = dp[best1idx][1][0] + 1;\\n                    dp[i][0][1] = best1idx;\\n                }\\n                if (best2idx != -1 && (dp[i][1][0] < dp[best2idx][2][0] + 1)) {\\n                    dp[i][1][0] = dp[best2idx][2][0] + 1;\\n                    dp[i][1][1] = best2idx;\\n                }\\n                if (best0idx != -1 && dp[i][2][0] < dp[best0idx][0][0] + 1) {\\n                    dp[i][2][0] = dp[best0idx][0][0] + 1;\\n                    dp[i][2][1] = best0idx;\\n                }\\n            }\\n            if (dp[i][0][0]) {\\n                if (best0idx == -1 || dp[best0idx][0][0] < dp[i][0][0]) {\\n                    best0idx = i;    \\n                }\\n            }\\n            if (dp[i][1][0]) {\\n                if (best1idx == -1 || dp[best1idx][1][0] < dp[i][1][0]) {\\n                    best1idx = i;    \\n                }\\n            }\\n            if (dp[i][2][0]) {\\n                if (best2idx == -1 || dp[best2idx][2][0] < dp[i][2][0]) {\\n                    best2idx = i;    \\n                }\\n            }\\n            if (dp[i][0][0]) {\\n                if (maxidx == -1) {\\n                    maxidx = i;\\n                } else if (dp[maxidx][0][0] < dp[i][0][0]) {\\n                    maxidx = i;\\n                }\\n            }\\n        }\\n        \\n        int i = maxidx;\\n        int sum = 0;\\n        string result;\\n        \\n        while (i != -1) {\\n            result.push_back(\\'0\\' + digits[i]);\\n            int m = sum % 3;\\n            sum += digits[i];\\n            \\n            switch (m) {\\n                case 0:\\n                    i = dp[i][0][1];\\n                    break;\\n                    \\n                case 1:\\n                    i = dp[i][2][1];\\n                    break;\\n                    \\n                case 2:\\n                    i = dp[i][1][1];\\n                    break;\\n                    \\n                default:\\n                    assert(false);\\n            }\\n        }\\n        \\n        reverse(result.begin(), result.end());\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 564606,
                "title": "python-clean-code-using-remainder-array",
                "content": "Sort the digits, and compute an array of modulo 3 for each digit. \\nIf the sum is not divisible by 3, the remainder r is either 1 or 2. In either case,\\n1. We try to delete one digit first. Find smallest digit that has the reminder r.\\n2. If 1 does not work, there has to be two digits that sum up to modulo that digit. \\n(3-r) gives 2 when r is 1 and vice versa. So search for the first two occurences of (3-r).\\n\\n```\\nclass Solution:\\n  def largestMultipleOfThree(self, digits: List[int]) -> str:\\n\\n    digits.sort()\\n    rem = [d % 3 for d in digits]\\n    s = sum(rem) % 3\\n\\n    def remove_smallest_with_rem(x): \\n      idx = rem.index(x)\\n      del digits[idx]\\n      del rem[idx]\\n\\n    if s != 0:\\n      try:\\n        remove_smallest_with_rem(s)\\n      except ValueError:\\n        remove_smallest_with_rem(3-s)\\n        remove_smallest_with_rem(3-s)\\n\\n    if len(digits) == 0: return \"\" \\n    if digits[-1] == 0: return \"0\"\\n    return (\"\".join(str(d) for d in reversed(digits)))\\n  ```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n  def largestMultipleOfThree(self, digits: List[int]) -> str:\\n\\n    digits.sort()\\n    rem = [d % 3 for d in digits]\\n    s = sum(rem) % 3\\n\\n    def remove_smallest_with_rem(x): \\n      idx = rem.index(x)\\n      del digits[idx]\\n      del rem[idx]\\n\\n    if s != 0:\\n      try:\\n        remove_smallest_with_rem(s)\\n      except ValueError:\\n        remove_smallest_with_rem(3-s)\\n        remove_smallest_with_rem(3-s)\\n\\n    if len(digits) == 0: return \"\" \\n    if digits[-1] == 0: return \"0\"\\n    return (\"\".join(str(d) for d in reversed(digits)))\\n  ```",
                "codeTag": "Java"
            },
            {
                "id": 540441,
                "title": "short-python3-84-ms-beats-99-74-with-explanation",
                "content": "```python\\nfrom collections import Counter\\nclass Solution:\\n    def largestMultipleOfThree(self, digits: List[int]) -> str:\\n        sumd = sum(digits)\\n        ctr = Counter(digits)\\n        while sumd % 3 != 0:\\n            todel = [2,5,8,1,4,7] if sumd % 3 == 2 else [1,4,7,2,5,8]\\n            for x in todel:\\n                if ctr[x]>0:\\n                    ctr[x]-=1\\n                    sumd -= x\\n                    break\\n        ans = \"\"\\n        for d in [9,8,7,6,5,4,3,2,1,0]:\\n            if d == 0 and ans == \"\" and ctr[d]:\\n                return \"0\"\\n            ans += str(d)*ctr[d]\\n        return ans\\n```\\nFirst, create a counter for the digits and get the sum.\\n\\nThen check if we need to remove any digits to get the sum of all of them to be divisible by 3. If we do, we have two cases. If `sum(digits) % 3 == 2`, we only need to remove a 2,5, or 8 to get the sum to be divisible by 3. If `sum(digits) % 3 == 1`, we can remove a 1,4, or 7. In either case, we want to remove the smallest digit possible. There is the case where we may not have any of the desired numbers to remove in the digit list, in which case we have to remove a number from the other group in order to make progress toward a sum divisible by 3. This is why the `todel` list is just these two groups of numbers concatenated together in alternate order. Each time we remove one, we check to see if the sum is divisible by 3 by going back to the top of the `while` loop.\\n\\nOnce we have removed digits from the counter, we build up the answer by converting the counter back to a list of digits (actually a string) in descending order to ensure the maximum size number. We account for the edge case of all 0s here as well.",
                "solutionTags": [],
                "code": "```python\\nfrom collections import Counter\\nclass Solution:\\n    def largestMultipleOfThree(self, digits: List[int]) -> str:\\n        sumd = sum(digits)\\n        ctr = Counter(digits)\\n        while sumd % 3 != 0:\\n            todel = [2,5,8,1,4,7] if sumd % 3 == 2 else [1,4,7,2,5,8]\\n            for x in todel:\\n                if ctr[x]>0:\\n                    ctr[x]-=1\\n                    sumd -= x\\n                    break\\n        ans = \"\"\\n        for d in [9,8,7,6,5,4,3,2,1,0]:\\n            if d == 0 and ans == \"\" and ctr[d]:\\n                return \"0\"\\n            ans += str(d)*ctr[d]\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 523394,
                "title": "python-java-javascript",
                "content": "```\\nclass Solution:\\n    def largestMultipleOfThree(self, digits: List[int]) -> str:\\n        digits.sort(key=lambda _: _ % 3)\\n        dictionary = {key : sorted(group) for key, group in itertools.groupby(digits, lambda _: _ % 3)}\\n        d1 = dictionary.get(1, [])\\n        d2 = dictionary.get(2, [])\\n        d0 = dictionary.get(0, [])\\n        remainder = sum(digits) % 3\\n        if remainder == 1: result = d1[1:] + d2 + d0 if d1 else d2[2:] + d0\\n        elif remainder == 2: result = d1 + d2[1:] + d0 if d2 else d1[2:] + d0\\n        else: result = digits\\n        try: return str(int(\\'\\'.join(map(str, sorted(result, reverse=True)))))\\n        except: return \\'\\'\\n```\\n```\\nclass Solution {\\n    public String largestMultipleOfThree(int[] digits) {\\n        final var dictionary = Collections.unmodifiableMap(Arrays.stream(digits).boxed().collect(Collectors.groupingBy($ -> $ % 3, Collectors.collectingAndThen(Collectors.toCollection(ArrayList::new), $ -> $.stream().sorted().collect(Collectors.toList())))));\\n        final var d1 = Collections.unmodifiableList(dictionary.getOrDefault(1, Collections.emptyList()));\\n        final var d2 = Collections.unmodifiableList(dictionary.getOrDefault(2, Collections.emptyList()));\\n        final var d0 = Collections.unmodifiableList(dictionary.getOrDefault(0, Collections.emptyList()));\\n        final var result = switch (Arrays.stream(digits).sum() % 3)\\n        {\\n                case 1 -> !d1.isEmpty() ? Stream.concat(Stream.concat(d1.stream().skip(1), d2.stream()), d0.stream()) : Stream.concat(d2.stream().skip(2), d0.stream());\\n                case 2 -> !d2.isEmpty() ? Stream.concat(Stream.concat(d1.stream(), d2.stream().skip(1)), d0.stream()) : Stream.concat(d1.stream().skip(2), d0.stream());\\n                default -> Arrays.stream(digits).boxed();\\n        };\\n        try {return new java.math.BigInteger(result.sorted(Comparator.reverseOrder()).map($ -> $.toString()).collect(Collectors.joining())).toString();}\\n        catch (Exception e) {return \"\";}\\n    }\\n```\\n```\\n/**\\n * @param {number[]} digits\\n * @return {string}\\n */\\nconst lodash = require(\\'lodash\\')\\n\\nvar largestMultipleOfThree = function(digits) {\\n    const dictionary = Object.freeze(new Map(Object.entries(lodash.groupBy(digits, _ => _ % 3)).map(([key, value]) => [Number(key), value.sort((a, b) => a - b)])))\\n    const d1 = Object.freeze(dictionary.has(1) ? dictionary.get(1) : [])\\n    const d2 = Object.freeze(dictionary.has(2) ? dictionary.get(2) : [])\\n    const d0 = Object.freeze(dictionary.has(0) ? dictionary.get(0) : [])\\n    let result = null\\n    switch (digits.reduce((a, b) => a + b) % 3)\\n    {\\n        case 1: result = d1.length ? [...d1.slice(1), ...d2, ...d0] : [...d2.slice(2), ...d0]; break\\n        case 2: result = d2.length ? [...d1, ...d2.slice(1), ...d0] : [...d1.slice(2), ...d0]; break\\n        default: result = digits\\n    }\\n    result = result.sort((a, b) => b - a).join(\\'\\')\\n    return result ? BigInt(result).toString() : \\'\\'\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def largestMultipleOfThree(self, digits: List[int]) -> str:\\n        digits.sort(key=lambda _: _ % 3)\\n        dictionary = {key : sorted(group) for key, group in itertools.groupby(digits, lambda _: _ % 3)}\\n        d1 = dictionary.get(1, [])\\n        d2 = dictionary.get(2, [])\\n        d0 = dictionary.get(0, [])\\n        remainder = sum(digits) % 3\\n        if remainder == 1: result = d1[1:] + d2 + d0 if d1 else d2[2:] + d0\\n        elif remainder == 2: result = d1 + d2[1:] + d0 if d2 else d1[2:] + d0\\n        else: result = digits\\n        try: return str(int(\\'\\'.join(map(str, sorted(result, reverse=True)))))\\n        except: return \\'\\'\\n```\n```\\nclass Solution {\\n    public String largestMultipleOfThree(int[] digits) {\\n        final var dictionary = Collections.unmodifiableMap(Arrays.stream(digits).boxed().collect(Collectors.groupingBy($ -> $ % 3, Collectors.collectingAndThen(Collectors.toCollection(ArrayList::new), $ -> $.stream().sorted().collect(Collectors.toList())))));\\n        final var d1 = Collections.unmodifiableList(dictionary.getOrDefault(1, Collections.emptyList()));\\n        final var d2 = Collections.unmodifiableList(dictionary.getOrDefault(2, Collections.emptyList()));\\n        final var d0 = Collections.unmodifiableList(dictionary.getOrDefault(0, Collections.emptyList()));\\n        final var result = switch (Arrays.stream(digits).sum() % 3)\\n        {\\n                case 1 -> !d1.isEmpty() ? Stream.concat(Stream.concat(d1.stream().skip(1), d2.stream()), d0.stream()) : Stream.concat(d2.stream().skip(2), d0.stream());\\n                case 2 -> !d2.isEmpty() ? Stream.concat(Stream.concat(d1.stream(), d2.stream().skip(1)), d0.stream()) : Stream.concat(d1.stream().skip(2), d0.stream());\\n                default -> Arrays.stream(digits).boxed();\\n        };\\n        try {return new java.math.BigInteger(result.sorted(Comparator.reverseOrder()).map($ -> $.toString()).collect(Collectors.joining())).toString();}\\n        catch (Exception e) {return \"\";}\\n    }\\n```\n```\\n/**\\n * @param {number[]} digits\\n * @return {string}\\n */\\nconst lodash = require(\\'lodash\\')\\n\\nvar largestMultipleOfThree = function(digits) {\\n    const dictionary = Object.freeze(new Map(Object.entries(lodash.groupBy(digits, _ => _ % 3)).map(([key, value]) => [Number(key), value.sort((a, b) => a - b)])))\\n    const d1 = Object.freeze(dictionary.has(1) ? dictionary.get(1) : [])\\n    const d2 = Object.freeze(dictionary.has(2) ? dictionary.get(2) : [])\\n    const d0 = Object.freeze(dictionary.has(0) ? dictionary.get(0) : [])\\n    let result = null\\n    switch (digits.reduce((a, b) => a + b) % 3)\\n    {\\n        case 1: result = d1.length ? [...d1.slice(1), ...d2, ...d0] : [...d2.slice(2), ...d0]; break\\n        case 2: result = d2.length ? [...d1, ...d2.slice(1), ...d0] : [...d1.slice(2), ...d0]; break\\n        default: result = digits\\n    }\\n    result = result.sort((a, b) => b - a).join(\\'\\')\\n    return result ? BigInt(result).toString() : \\'\\'\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 520738,
                "title": "just-math-2-2-or-1-1-1-1-or-2-2",
                "content": "```Scala\\nobject Solution {\\n\\n  def largestMultipleOfThree(digits: Array[Int]): String = {\\n    if (digits.length == 1) return if (digits(0) % 3 == 0) digits(0).toString else \"\"\\n    val arr = digits.sortWith(_ > _)\\n    if (arr(0) == 0) return \"0\"\\n    var oneIdx1, secIdx1, oneIdx2, secIdx2 = -1\\n    val sb = new StringBuilder()\\n    var sum = 0\\n    for (i <- arr.length - 1 to 0 by -1) {\\n      sb.append(arr(i))\\n      sum += arr(i)\\n      if (arr(i) % 3 == 1 && oneIdx1 == -1) {\\n        oneIdx1 = i\\n      } else if (arr(i) % 3 == 1 && oneIdx1 != -1 && oneIdx2 == -1) {\\n        oneIdx2 = i\\n      }\\n      if (arr(i) % 3 == 2 && secIdx1 == -1) {\\n        secIdx1 = i\\n      } else if (arr(i) % 3 == 2 && secIdx1 != -1 && secIdx2 == -1) {\\n        secIdx2 = i\\n      }\\n    }\\n    if (sum % 3 == 0) return sb.reverse.toString()\\n    val res = sb.reverse.toString()\\n    if (sum % 3 == 1) {\\n      if (oneIdx1 != -1) {\\n        return res.substring(0, oneIdx1) + res.substring(oneIdx1 + 1)\\n      } else {\\n        if (secIdx1 != -1 && secIdx2 != -1) return res.substring(0, secIdx2) + res.substring(secIdx2 + 1, secIdx1) + res.substring(secIdx1 + 1)\\n      }\\n    }\\n    if (sum % 3 == 2) {\\n      if (secIdx1 != -1) {\\n        return res.substring(0, secIdx1) + res.substring(secIdx1 + 1)\\n      } else {\\n        if (oneIdx1 != -1 && oneIdx2 != -1) return res.substring(0, oneIdx2) + res.substring(oneIdx2 + 1, oneIdx1) + res.substring(oneIdx1 + 1)\\n      }\\n    }\\n    \"\"\\n  }\\n}\\n```",
                "solutionTags": [],
                "code": "```Scala\\nobject Solution {\\n\\n  def largestMultipleOfThree(digits: Array[Int]): String = {\\n    if (digits.length == 1) return if (digits(0) % 3 == 0) digits(0).toString else \"\"\\n    val arr = digits.sortWith(_ > _)\\n    if (arr(0) == 0) return \"0\"\\n    var oneIdx1, secIdx1, oneIdx2, secIdx2 = -1\\n    val sb = new StringBuilder()\\n    var sum = 0\\n    for (i <- arr.length - 1 to 0 by -1) {\\n      sb.append(arr(i))\\n      sum += arr(i)\\n      if (arr(i) % 3 == 1 && oneIdx1 == -1) {\\n        oneIdx1 = i\\n      } else if (arr(i) % 3 == 1 && oneIdx1 != -1 && oneIdx2 == -1) {\\n        oneIdx2 = i\\n      }\\n      if (arr(i) % 3 == 2 && secIdx1 == -1) {\\n        secIdx1 = i\\n      } else if (arr(i) % 3 == 2 && secIdx1 != -1 && secIdx2 == -1) {\\n        secIdx2 = i\\n      }\\n    }\\n    if (sum % 3 == 0) return sb.reverse.toString()\\n    val res = sb.reverse.toString()\\n    if (sum % 3 == 1) {\\n      if (oneIdx1 != -1) {\\n        return res.substring(0, oneIdx1) + res.substring(oneIdx1 + 1)\\n      } else {\\n        if (secIdx1 != -1 && secIdx2 != -1) return res.substring(0, secIdx2) + res.substring(secIdx2 + 1, secIdx1) + res.substring(secIdx1 + 1)\\n      }\\n    }\\n    if (sum % 3 == 2) {\\n      if (secIdx1 != -1) {\\n        return res.substring(0, secIdx1) + res.substring(secIdx1 + 1)\\n      } else {\\n        if (oneIdx1 != -1 && oneIdx2 != -1) return res.substring(0, oneIdx2) + res.substring(oneIdx2 + 1, oneIdx1) + res.substring(oneIdx1 + 1)\\n      }\\n    }\\n    \"\"\\n  }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 519451,
                "title": "python-o-nlogn-but-easy-to-write",
                "content": "This is not effecient, but I find it easy to write during the contest and it is fast enough for \"Accept\"\\n\\n```\\nclass Solution:\\n    def largestMultipleOfThree(self, digits: List[int]) -> str:\\n        list0 = sorted([d for d in digits if d%3==0])\\n        list1 = sorted([d for d in digits if d%3==1])\\n        list2 = sorted([d for d in digits if d%3==2])\\n        s = (len(list1) + len(list2)*2)%3\\n        \\n        if s==1:\\n            if list1:\\n                list1=list1[1:]\\n            elif len(list2)>=2:\\n                list2=list2[2:]\\n            else:\\n                raise Exception(\"check logic\")\\n        elif s==2:\\n            if list2:\\n                list2=list2[1:]\\n            elif len(list1)>=2:\\n                list1=list1[2:]\\n            else:\\n                raise Exception(\"check logic\")\\n        #print(list0, list1, list2)\\n        final = sorted(list0+list1+list2, reverse=True)\\n        \\n        if final and final[0]==0:\\n            return \"0\"\\n        \\n        return \"\".join(str(n) for n in final)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def largestMultipleOfThree(self, digits: List[int]) -> str:\\n        list0 = sorted([d for d in digits if d%3==0])\\n        list1 = sorted([d for d in digits if d%3==1])\\n        list2 = sorted([d for d in digits if d%3==2])\\n        s = (len(list1) + len(list2)*2)%3\\n        \\n        if s==1:\\n            if list1:\\n                list1=list1[1:]\\n            elif len(list2)>=2:\\n                list2=list2[2:]\\n            else:\\n                raise Exception(\"check logic\")\\n        elif s==2:\\n            if list2:\\n                list2=list2[1:]\\n            elif len(list1)>=2:\\n                list1=list1[2:]\\n            else:\\n                raise Exception(\"check logic\")\\n        #print(list0, list1, list2)\\n        final = sorted(list0+list1+list2, reverse=True)\\n        \\n        if final and final[0]==0:\\n            return \"0\"\\n        \\n        return \"\".join(str(n) for n in final)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 518175,
                "title": "clean-python3-heap",
                "content": "Use modulo to group digit and become three groups: `{0, 3, 6, 9}`, `{1, 4, 7}`, and `{2, 5, 8}`, and save them into three heaps.\\nThen calculate modulo of total sum, remove needed count of digit in corresponding heap and pop all others.\\n\\n```\\nimport heapq\\nclass Solution:\\n    def largestMultipleOfThree(self, digits: List[int]) -> str:\\n        heaps, total = [[], [], []], 0\\n        for digit in digits:\\n            total += digit\\n            heapq.heappush(heaps[digit % 3], str(digit))\\n        if r := (total % 3):\\n            if heaps[r]:\\n                heapq.heappop(heaps[r])\\n            elif len(heaps[-r]) > 1:\\n                heapq.heappop(heaps[-r])\\n                heapq.heappop(heaps[-r])\\n        if any(heaps):\\n            return str(int(\\'\\'.join(sorted(sum(heaps, []), reverse=True))))\\n        return \\'\\'\\n```",
                "solutionTags": [
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nimport heapq\\nclass Solution:\\n    def largestMultipleOfThree(self, digits: List[int]) -> str:\\n        heaps, total = [[], [], []], 0\\n        for digit in digits:\\n            total += digit\\n            heapq.heappush(heaps[digit % 3], str(digit))\\n        if r := (total % 3):\\n            if heaps[r]:\\n                heapq.heappop(heaps[r])\\n            elif len(heaps[-r]) > 1:\\n                heapq.heappop(heaps[-r])\\n                heapq.heappop(heaps[-r])\\n        if any(heaps):\\n            return str(int(\\'\\'.join(sorted(sum(heaps, []), reverse=True))))\\n        return \\'\\'\\n```",
                "codeTag": "Java"
            },
            {
                "id": 518056,
                "title": "c-sort-dp",
                "content": "dp[i,j,k]\\ni -> index of digits\\nj -> 0: pick i index digit,  1: not pick i index digit\\nk -> total sum till i index, mod 3 val\\nres -> max count till i index\\n\\nafter we get max count, we can iterate dp from backwards to beginning and get list\\n\\n```\\npublic string LargestMultipleOfThree(int[] digits) {\\n        \\n\\tint n = digits.Length;\\n\\tint[,,] dp = new int[n, 2, 3];\\n\\n\\tArray.Sort(digits);\\n\\n\\t//all 0 case\\n\\tif(digits[n-1] == 0)\\n\\t\\treturn \"0\";\\n\\n\\tdp[0,0,digits[0]%3] = 1;\\n\\n\\tfor(int i=1; i<n; i++)\\n\\t{\\n\\t\\tint v = digits[i];\\n\\t\\t//pick\\n\\t\\tfor(int j=0; j<3; j++)\\n\\t\\t{\\n\\t\\t\\tif(dp[i-1, 0, j] > 0 || dp[i-1, 1, j] > 0 || j==0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tdp[i,0,(v + j)%3] = Math.Max(dp[i-1, 0, j], dp[i-1, 1, j]) + 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t//not pick\\n\\t\\tfor(int j=0; j<3; j++)\\n\\t\\t{\\n\\t\\t\\tdp[i,1,j] = Math.Max(dp[i-1,0,j], dp[i-1,1,j]);\\n\\t\\t}\\n\\t}\\n\\n\\t//not exist case\\n\\tif(dp[n-1, 1, 0] == 0 && dp[n-1, 0, 0] ==0)\\n\\t\\treturn \"\";\\n\\n\\tList<int> list = new List<int>();\\n\\tint curMod = 0;\\n\\n\\tfor(int i=n-1; i>=0; i--)\\n\\t{\\n\\t\\tfor(int j=0; j<3; j++)\\n\\t\\t{\\n\\t\\t\\tif(j == curMod)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(dp[i,0,j] > 0 && dp[i,0,j] >= dp[i,1,j])\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tlist.Add(digits[i]);\\n\\t\\t\\t\\t\\tcurMod = (curMod - (digits[i])%3 + 3)%3;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn string.Join(\"\", list);\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic string LargestMultipleOfThree(int[] digits) {\\n        \\n\\tint n = digits.Length;\\n\\tint[,,] dp = new int[n, 2, 3];\\n\\n\\tArray.Sort(digits);\\n\\n\\t//all 0 case\\n\\tif(digits[n-1] == 0)\\n\\t\\treturn \"0\";\\n\\n\\tdp[0,0,digits[0]%3] = 1;\\n\\n\\tfor(int i=1; i<n; i++)\\n\\t{\\n\\t\\tint v = digits[i];\\n\\t\\t//pick\\n\\t\\tfor(int j=0; j<3; j++)\\n\\t\\t{\\n\\t\\t\\tif(dp[i-1, 0, j] > 0 || dp[i-1, 1, j] > 0 || j==0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tdp[i,0,(v + j)%3] = Math.Max(dp[i-1, 0, j], dp[i-1, 1, j]) + 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t//not pick\\n\\t\\tfor(int j=0; j<3; j++)\\n\\t\\t{\\n\\t\\t\\tdp[i,1,j] = Math.Max(dp[i-1,0,j], dp[i-1,1,j]);\\n\\t\\t}\\n\\t}\\n\\n\\t//not exist case\\n\\tif(dp[n-1, 1, 0] == 0 && dp[n-1, 0, 0] ==0)\\n\\t\\treturn \"\";\\n\\n\\tList<int> list = new List<int>();\\n\\tint curMod = 0;\\n\\n\\tfor(int i=n-1; i>=0; i--)\\n\\t{\\n\\t\\tfor(int j=0; j<3; j++)\\n\\t\\t{\\n\\t\\t\\tif(j == curMod)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(dp[i,0,j] > 0 && dp[i,0,j] >= dp[i,1,j])\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tlist.Add(digits[i]);\\n\\t\\t\\t\\t\\tcurMod = (curMod - (digits[i])%3 + 3)%3;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn string.Join(\"\", list);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 517796,
                "title": "c-solution",
                "content": "Probably can be improved without using extra List by flagging the removed elements with -1 in the initial array.\\n```\\npublic class Solution\\n{\\n    public string LargestMultipleOfThree(int[] digits)\\n    {\\n        Array.Sort(digits);\\n        if (digits[digits.Length - 1] == 0)\\n            return \"0\";\\n        var d = digits.ToList();\\n        int s = d.Sum();\\n        int r = s % 3;\\n        if (r != 0)\\n        {\\n            bool b = false;\\n            for (int i = 0; i < d.Count; i++)\\n            {\\n                if (d[i] % 3 == r)\\n                {\\n                    d.RemoveAt(i);\\n                    b = true;\\n                    break;\\n                }\\n            }\\n            if (!b)\\n            {\\n                r = (r == 2) ? 1 : 2;\\n                int c = 0;\\n                for (int i = 0; i < d.Count; i++)\\n                {\\n                    if (d[i] % 3 == r)\\n                    {\\n                        d.RemoveAt(i);\\n                        i--;\\n                        c++;\\n                        if (c == 2)\\n                        {\\n                            b = true;\\n                            break;\\n                        }\\n                    }\\n                }\\n            }\\n            if (!b) return \"\";\\n        }\\n        var sb = new StringBuilder();\\n        for (int i = d.Count - 1; i >= 0; i--)\\n            sb.Append(d[i]);\\n        return sb.ToString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution\\n{\\n    public string LargestMultipleOfThree(int[] digits)\\n    {\\n        Array.Sort(digits);\\n        if (digits[digits.Length - 1] == 0)\\n            return \"0\";\\n        var d = digits.ToList();\\n        int s = d.Sum();\\n        int r = s % 3;\\n        if (r != 0)\\n        {\\n            bool b = false;\\n            for (int i = 0; i < d.Count; i++)\\n            {\\n                if (d[i] % 3 == r)\\n                {\\n                    d.RemoveAt(i);\\n                    b = true;\\n                    break;\\n                }\\n            }\\n            if (!b)\\n            {\\n                r = (r == 2) ? 1 : 2;\\n                int c = 0;\\n                for (int i = 0; i < d.Count; i++)\\n                {\\n                    if (d[i] % 3 == r)\\n                    {\\n                        d.RemoveAt(i);\\n                        i--;\\n                        c++;\\n                        if (c == 2)\\n                        {\\n                            b = true;\\n                            break;\\n                        }\\n                    }\\n                }\\n            }\\n            if (!b) return \"\";\\n        }\\n        var sb = new StringBuilder();\\n        for (int i = d.Count - 1; i >= 0; i--)\\n            sb.Append(d[i]);\\n        return sb.ToString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 517725,
                "title": "python3-super-simple-long-solution",
                "content": "```\\nclass Solution:\\n\\tdef largestMultipleOfThree(self, digits: List[int]) -> str:\\n\\t\\tdigits.sort()\\n\\t\\tq0,q1,q2=[],[],[]\\n\\t\\tsums=0\\n\\t\\tfor i in range(len(digits)):\\n\\t\\t\\tsums+=digits[i]\\n\\t\\t\\tremain=digits[i]%3\\n\\t\\t\\tif remain==0:\\n\\t\\t\\t\\tq0.append(digits[i])\\n\\t\\t\\telif remain==1:\\n\\t\\t\\t\\tq1.append(digits[i])\\n\\t\\t\\telse:\\n\\t\\t\\t\\tq2.append(digits[i])\\n\\t\\tq1.sort(reverse=True)\\n\\t\\tq2.sort(reverse=True)\\n\\t\\tif sums%3==1:\\n\\t\\t\\tif q1:\\n\\t\\t\\t\\tq1.pop()\\n\\t\\t\\telse:\\n\\t\\t\\t\\tif q2:\\n\\t\\t\\t\\t\\tq2.pop()\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\treturn \"\"\\n\\n\\t\\t\\t\\tif q2:\\n\\t\\t\\t\\t\\tq2.pop()\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\treturn \"\"\\n\\n\\t\\telif sums%3==2:\\n\\t\\t\\tif q2:\\n\\t\\t\\t\\tq2.pop()\\n\\t\\t\\telse:\\n\\t\\t\\t\\tif q1:\\n\\t\\t\\t\\t\\tq1.pop()\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\treturn \"\"\\n\\n\\t\\t\\t\\tif q1:\\n\\t\\t\\t\\t\\tq1.pop()\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\treturn \"\"\\n\\n\\t\\tres=q0+q1+q2\\n\\t\\tres.sort(reverse=True)\\n\\t\\tans=\"\"\\n\\t\\tfor i in res:\\n\\t\\t\\tans+=str(i)\\n\\t\\treturn str(int(ans)) if ans else ans\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n\\tdef largestMultipleOfThree(self, digits: List[int]) -> str:\\n\\t\\tdigits.sort()\\n\\t\\tq0,q1,q2=[],[],[]\\n\\t\\tsums=0\\n\\t\\tfor i in range(len(digits)):\\n\\t\\t\\tsums+=digits[i]\\n\\t\\t\\tremain=digits[i]%3\\n\\t\\t\\tif remain==0:\\n\\t\\t\\t\\tq0.append(digits[i])\\n\\t\\t\\telif remain==1:\\n\\t\\t\\t\\tq1.append(digits[i])\\n\\t\\t\\telse:\\n\\t\\t\\t\\tq2.append(digits[i])\\n\\t\\tq1.sort(reverse=True)\\n\\t\\tq2.sort(reverse=True)\\n\\t\\tif sums%3==1:\\n\\t\\t\\tif q1:\\n\\t\\t\\t\\tq1.pop()\\n\\t\\t\\telse:\\n\\t\\t\\t\\tif q2:\\n\\t\\t\\t\\t\\tq2.pop()\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\treturn \"\"\\n\\n\\t\\t\\t\\tif q2:\\n\\t\\t\\t\\t\\tq2.pop()\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\treturn \"\"\\n\\n\\t\\telif sums%3==2:\\n\\t\\t\\tif q2:\\n\\t\\t\\t\\tq2.pop()\\n\\t\\t\\telse:\\n\\t\\t\\t\\tif q1:\\n\\t\\t\\t\\t\\tq1.pop()\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\treturn \"\"\\n\\n\\t\\t\\t\\tif q1:\\n\\t\\t\\t\\t\\tq1.pop()\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\treturn \"\"\\n\\n\\t\\tres=q0+q1+q2\\n\\t\\tres.sort(reverse=True)\\n\\t\\tans=\"\"\\n\\t\\tfor i in res:\\n\\t\\t\\tans+=str(i)\\n\\t\\treturn str(int(ans)) if ans else ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 517719,
                "title": "easy-to-understand",
                "content": "There is a theorem: If digits sum can be divided by 3, then the number can be divided by 3.\\nFor example:\\n45: 4 + 5 = 9.    \\n9 % 3 = 0   ->  45 % 3 = 0\\n\\nSo we can just discard one or two smallest numbers to make the sum of the array can be divided by 3:\\n\\n```\\nclass Solution {\\npublic:\\n    string largestMultipleOfThree(vector<int>& digits) {\\n        int sum = 0;\\n        for(int d : digits) sum += d;\\n        sort(digits.rbegin(), digits.rend());\\n        int m = sum % 3, other_m = m == 1 ? 2 : 1;\\n        if(m == 0) return join(digits);\\n        else if(deleteMod(digits, m)){\\n            return join(digits);\\n        }else if(deleteMod(digits, other_m) && deleteMod(digits, other_m)){\\n            return join(digits);\\n        }else return \"\";\\n    }\\n\\n    bool deleteMod(vector<int> &digits, int m){\\n        for(int i=digits.size() - 1; i>=0; i--){\\n            if(digits[i] % 3 == m){\\n                digits.erase(digits.begin() + i);\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    string join(vector<int> &digits){\\n        string ans;\\n        for(int d : digits){\\n            if(ans.size() == 0 && d == 0) continue;\\n            ans += d+\\'0\\';\\n        }\\n        if(ans.size() == 0 && digits.size() != 0) return \"0\";\\n        else return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestMultipleOfThree(vector<int>& digits) {\\n        int sum = 0;\\n        for(int d : digits) sum += d;\\n        sort(digits.rbegin(), digits.rend());\\n        int m = sum % 3, other_m = m == 1 ? 2 : 1;\\n        if(m == 0) return join(digits);\\n        else if(deleteMod(digits, m)){\\n            return join(digits);\\n        }else if(deleteMod(digits, other_m) && deleteMod(digits, other_m)){\\n            return join(digits);\\n        }else return \"\";\\n    }\\n\\n    bool deleteMod(vector<int> &digits, int m){\\n        for(int i=digits.size() - 1; i>=0; i--){\\n            if(digits[i] % 3 == m){\\n                digits.erase(digits.begin() + i);\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    string join(vector<int> &digits){\\n        string ans;\\n        for(int d : digits){\\n            if(ans.size() == 0 && d == 0) continue;\\n            ans += d+\\'0\\';\\n        }\\n        if(ans.size() == 0 && digits.size() != 0) return \"0\";\\n        else return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 517716,
                "title": "java-o-n-remove-minmum-numbers-faster-than-100-less-than-100",
                "content": "```\\nclass Solution {\\n  public String largestMultipleOfThree(int[] digits) {\\n    HashMap<Integer, Integer> map = new HashMap<>();\\n    for (int d : digits)\\n      map.put(d, map.getOrDefault(d, 0) + 1);\\n    int[] k = new int[2];\\n    for (Map.Entry<Integer, Integer> entry : map.entrySet())\\n      if (entry.getKey() % 3 != 0)\\n        k[entry.getKey() % 3 - 1] += entry.getValue();\\n    switch (Math.abs(k[0] - k[1]) % 3) {\\n      case 1:\\n        if (k[0] > k[1]) {\\n          k[0] = (k[0] - k[1]) % 3;\\n          k[1] = 0;\\n        } else {\\n          k[1] = (k[1] - k[0]) % 3;\\n          k[0] = 0;\\n        }\\n        break;\\n      case 2:\\n        if (k[0] != 0 && k[1] != 0)\\n          if (k[0] > k[1]) {\\n            k[0] = 0;\\n            k[1] = 1;\\n          } else {\\n            k[1] = 0;\\n            k[0] = 1;\\n          }\\n        k[0] %= 3;\\n        k[1] %= 3;\\n        break;\\n      case 0:\\n        k[0] = 0;\\n        k[1] = 0;\\n    }\\n    for (int i = 1; i < 9; i++)\\n      if (i % 3 != 0)\\n        if (k[i % 3 - 1] > 0 && map.containsKey(i)) {\\n          int t = Math.min(map.get(i), k[i % 3 - 1]);\\n          map.put(i, map.get(i - t));\\n          k[i % 3 - 1] -= t;\\n        }\\n    StringBuilder sb = new StringBuilder();\\n    for (int i = 9; i >= 0; i--)\\n      if (map.containsKey(i))\\n        for (int j = 0; j < map.get(i); j++)\\n          sb.append(i);\\n    while (sb.length() > 1 && sb.charAt(0) == \\'0\\')\\n      sb.deleteCharAt(0);\\n    return sb.toString();\\n  }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n  public String largestMultipleOfThree(int[] digits) {\\n    HashMap<Integer, Integer> map = new HashMap<>();\\n    for (int d : digits)\\n      map.put(d, map.getOrDefault(d, 0) + 1);\\n    int[] k = new int[2];\\n    for (Map.Entry<Integer, Integer> entry : map.entrySet())\\n      if (entry.getKey() % 3 != 0)\\n        k[entry.getKey() % 3 - 1] += entry.getValue();\\n    switch (Math.abs(k[0] - k[1]) % 3) {\\n      case 1:\\n        if (k[0] > k[1]) {\\n          k[0] = (k[0] - k[1]) % 3;\\n          k[1] = 0;\\n        } else {\\n          k[1] = (k[1] - k[0]) % 3;\\n          k[0] = 0;\\n        }\\n        break;\\n      case 2:\\n        if (k[0] != 0 && k[1] != 0)\\n          if (k[0] > k[1]) {\\n            k[0] = 0;\\n            k[1] = 1;\\n          } else {\\n            k[1] = 0;\\n            k[0] = 1;\\n          }\\n        k[0] %= 3;\\n        k[1] %= 3;\\n        break;\\n      case 0:\\n        k[0] = 0;\\n        k[1] = 0;\\n    }\\n    for (int i = 1; i < 9; i++)\\n      if (i % 3 != 0)\\n        if (k[i % 3 - 1] > 0 && map.containsKey(i)) {\\n          int t = Math.min(map.get(i), k[i % 3 - 1]);\\n          map.put(i, map.get(i - t));\\n          k[i % 3 - 1] -= t;\\n        }\\n    StringBuilder sb = new StringBuilder();\\n    for (int i = 9; i >= 0; i--)\\n      if (map.containsKey(i))\\n        for (int j = 0; j < map.get(i); j++)\\n          sb.append(i);\\n    while (sb.length() > 1 && sb.charAt(0) == \\'0\\')\\n      sb.deleteCharAt(0);\\n    return sb.toString();\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 517688,
                "title": "python3-a-sorting-based-solution",
                "content": "Algorithm:\\nThe digits can be categorized based on parity\\n1) category 0: that can be divided by 3;\\n2) category 1: that after dividing by 3 remains 1;\\n3) category 2: that after dividing by 3 remains 2\\n\\n* If the sum of all digits can be divided by 3, return numbers with digits sorted in descending order. \\n* If the sum after dividing by 3 remains 1, then we should remove the smallest digit in category 1 if it is not empty. If it is empty, then we should remove the smallest 2 digits in cat3egory 2. If it doesn\\'t have 2 elements, return `\"\"`. \\n* If the sum after dividing by 3 remains 2, the analysis is similar to above. \\n\\nImplementation (100ms): \\n```\\nclass Solution:\\n    def largestMultipleOfThree(self, digits: List[int]) -> str:\\n        digits.sort(reverse=True)\\n        category = dict()\\n        for d in digits: category.setdefault(d%3, []).append(d)\\n        \\n        parity = sum(digits) % 3\\n        if parity != 0: \\n            if len(category.get(parity, [])) > 0: \\n                digits.remove(category[parity][-1])\\n            elif len(category.get(3-parity, [])) > 1: \\n                digits.remove(category[3-parity][-1])\\n                digits.remove(category[3-parity][-2])\\n            else: \\n                return \"\"\\n        \\n        return \"0\" if digits and not digits[0] else \"\".join(str(d) for d in digits)\\n```\\n\\nAnalysis:\\nTime complexity `O(NlogN)`\\nSpace complexity `O(N)`",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def largestMultipleOfThree(self, digits: List[int]) -> str:\\n        digits.sort(reverse=True)\\n        category = dict()\\n        for d in digits: category.setdefault(d%3, []).append(d)\\n        \\n        parity = sum(digits) % 3\\n        if parity != 0: \\n            if len(category.get(parity, [])) > 0: \\n                digits.remove(category[parity][-1])\\n            elif len(category.get(3-parity, [])) > 1: \\n                digits.remove(category[3-parity][-1])\\n                digits.remove(category[3-parity][-2])\\n            else: \\n                return \"\"\\n        \\n        return \"0\" if digits and not digits[0] else \"\".join(str(d) for d in digits)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4021917,
                "title": "dekh",
                "content": "class Solution {\\npublic:\\n    vector<int> one={1,4,7};\\n    vector<int> two={2,5,8};\\n    string largestMultipleOfThree(vector<int>& digits) \\n    {\\n        map<int,int> mpp;\\n        int sum=0;\\n        for(int e:digits)\\n        {\\n            mpp[e]++;\\n            sum+=e;\\n        }\\n\\n        if(sum%3==1)\\n        {\\n            bool is=false;\\n            for(int i:one)\\n            {\\n                if(mpp[i]>0)\\n                {\\n                    mpp[i]--;\\n                    is=true;\\n                    break;\\n                }\\n            }\\n\\n            if(is==false)\\n            {\\n                for(int i:two)\\n                {\\n                    for(int j:two)\\n                    {\\n                        if(i==j && mpp[i]<2)\\n                            continue;\\n                        if(mpp[i]>0 && mpp[j]>0)\\n                        {\\n                            mpp[i]--;\\n                            mpp[j]--;\\n                            is=true;\\n                            break;\\n                        }\\n                    }\\n                    \\n                    if(is==true)\\n                        break;\\n                }\\n            }\\n\\n            if(is==false)\\n                return \"\";\\n        }\\n        else if(sum%3==2)\\n        {\\n            bool is=false;\\n            for(int i:two)\\n            {\\n                if(mpp[i]>0)\\n                {\\n                    mpp[i]--;\\n                    is=true;\\n                    break;\\n                }\\n            }\\n\\n            if(is==false)\\n            {\\n                for(int i:one)\\n                {\\n                    for(int j:one)\\n                    {\\n                        if(i==j && mpp[i]<2)\\n                            continue;\\n                        if(mpp[i]>0 && mpp[j]>0)\\n                        {\\n                            mpp[i]--;\\n                            mpp[j]--;\\n                            is=true;\\n                            break;\\n                        }\\n                    }\\n                }\\n            }\\n\\n            if(is==false)\\n                return \"\";\\n        }\\n        string s;\\n        for(int i=9;i>=0;i--)\\n        {\\n            for(int j=0;j<mpp[i];j++)\\n                s+=(\\'0\\'+i);\\n        }\\n\\n        if(s[0]==\\'0\\')\\n            return \"0\";\\n        return s; \\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> one={1,4,7}",
                "codeTag": "Java"
            },
            {
                "id": 3987148,
                "title": "over-simplification-efinalitypi",
                "content": "```\\nclass Solution:\\n    def largestMultipleOfThree(self, d: List[int]) -> str:\\n        for i in [c:=Counter(d),o:=sum(d)%3,1,2][2:]*(0<o):\\n            if o and len(z:=list(islice(chain(*([e]*min(c[e],i) for e in range(i*o%3,9,3))),i)))==i:\\n                for e in z:c[e]-=1;o=0\\n        return \\'\\' if o else \\'0\\' if (m:=\\'\\'.join(str(9-e)*c[9-e]for e in range(10)))[:1]==\\'0\\' else m\\n```\\n\\n\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def largestMultipleOfThree(self, d: List[int]) -> str:\\n        for i in [c:=Counter(d),o:=sum(d)%3,1,2][2:]*(0<o):\\n            if o and len(z:=list(islice(chain(*([e]*min(c[e],i) for e in range(i*o%3,9,3))),i)))==i:\\n                for e in z:c[e]-=1;o=0\\n        return \\'\\' if o else \\'0\\' if (m:=\\'\\'.join(str(9-e)*c[9-e]for e in range(10)))[:1]==\\'0\\' else m\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3981811,
                "title": "python3-dp",
                "content": "# Intuition\\n- Intituion is that find the largest sum in the array divisble by three and try to trace it\\n\\n# Approach\\n- DP\\n\\n# Complexity\\n- Time complexity:\\n- O(N^2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def largestMultipleOfThree(self, digits: List[int]) -> str:\\n        # checking if s is greater than s1\\n        def checkGreater(s,s1):\\n            if len(s) > len(s1):\\n                return True\\n            elif len(s1) > len(s):\\n                return False\\n            elif s1 == s:\\n                return True\\n            else:\\n                for i in range(len(s)):\\n                    d = int(s[i])\\n                    d1 = int(s1[i])\\n                    if d > d1:\\n                        return True\\n                    elif d1>d:\\n                        return False\\n                return True\\n\\n        def solve(digits):\\n            # sorting digits\\n            digits.sort()\\n            digits = digits[-1::-1]\\n            # dp array\\n            dp = [[(\"\",0) for _ in range(3)] for _ in range(len(digits)+1)]\\n\\n            for i in range(1,len(digits)+1):\\n                num = digits[i-1]\\n\\n                #copying values downward\\n                for j in range(3):\\n                    dp[i][j] = dp[i-1][j]\\n\\n                for j in range(3):\\n                    summ = dp[i-1][j][1]+num\\n                    res = dp[i-1][j][0]+str(num)\\n                    if dp[i][summ%3][0] != \\'\\':\\n                        if checkGreater(res,dp[i][summ%3][0]):\\n                            dp[i][summ%3] = (res,summ)\\n                    else:\\n                        dp[i][summ%3] = (res,summ)\\n\\n            res = \"\"\\n            val = dp[len(digits)][0][0]\\n            for i in range(len(val)):\\n                if val[i] == \\'0\\' and len(res) == 0:\\n                    continue\\n                else:\\n                    res+=val[i]\\n            if res!=\"\":\\n                return res\\n            elif 0 in digits:\\n                return \"0\"\\n            else:\\n                return \\'\\'\\n        return solve(digits)\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def largestMultipleOfThree(self, digits: List[int]) -> str:\\n        # checking if s is greater than s1\\n        def checkGreater(s,s1):\\n            if len(s) > len(s1):\\n                return True\\n            elif len(s1) > len(s):\\n                return False\\n            elif s1 == s:\\n                return True\\n            else:\\n                for i in range(len(s)):\\n                    d = int(s[i])\\n                    d1 = int(s1[i])\\n                    if d > d1:\\n                        return True\\n                    elif d1>d:\\n                        return False\\n                return True\\n\\n        def solve(digits):\\n            # sorting digits\\n            digits.sort()\\n            digits = digits[-1::-1]\\n            # dp array\\n            dp = [[(\"\",0) for _ in range(3)] for _ in range(len(digits)+1)]\\n\\n            for i in range(1,len(digits)+1):\\n                num = digits[i-1]\\n\\n                #copying values downward\\n                for j in range(3):\\n                    dp[i][j] = dp[i-1][j]\\n\\n                for j in range(3):\\n                    summ = dp[i-1][j][1]+num\\n                    res = dp[i-1][j][0]+str(num)\\n                    if dp[i][summ%3][0] != \\'\\':\\n                        if checkGreater(res,dp[i][summ%3][0]):\\n                            dp[i][summ%3] = (res,summ)\\n                    else:\\n                        dp[i][summ%3] = (res,summ)\\n\\n            res = \"\"\\n            val = dp[len(digits)][0][0]\\n            for i in range(len(val)):\\n                if val[i] == \\'0\\' and len(res) == 0:\\n                    continue\\n                else:\\n                    res+=val[i]\\n            if res!=\"\":\\n                return res\\n            elif 0 in digits:\\n                return \"0\"\\n            else:\\n                return \\'\\'\\n        return solve(digits)\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3915276,
                "title": "python-got-past-tle-with-hack",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAt first, I tried the approach suggested by the Hint:  Use dynamic\\nprogramming to find the solution.  However, even using ```lru_cache(None)``` to accelerate the DP, I was still getting Time Limit Exceeded.  I then came up with a hack that can significantly speed up some cases; I left the DP in place to handle other cases.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nI will focus on the two hacks and skip discussing the DP part, since that follows a typical DP pattern (base case, recursion cases).\\n\\nThe hack is based on the observation that, for a given set of digits, there are only three possible sums modulo 3:  0, 1, and 2.  If we look at the original list of digits and its modular residue, if it\\'s 0, we don\\'t need to look for the longest sum-mod-3 subsequence:  just take all the digits (sorting them descending).  What if the residue is 1?  Well, if we can find a 1 *somewhere* in the digits, we can simply remove it adjusting the residue down to 0 (we can also do this with 4\\'s or 7\\'s, but I didn\\'t bother), and use all the rest of the digits.  Similarly, if the residue is 2 and we can find one \"2\" (or 5 or 8) and remove it, we reduce the residue to 0 and can use all the rest of the digits.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe overall time complexity for the DP would be $$O(2^n)$$ or less if we use memo-ization.  We know the time complexity is at least $$O(n)$$, since we have to look at every digit; when the hack above applies (which is often the case for large examples) that becomes the overall time complexity.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe only significant data structure (not counting the execution stack) is the ```lru_cache```.  I found that setting the cache size to None (unlimited) I ran out of storage on the larger examples, and reducing it to 100,000 fixed the storage problem but still gave a TLE.\\n# Code\\n```\\nclass Solution:\\n    def largestMultipleOfThree(self, digits: list[int]) -> str:\\n        # Sort the digits in descending order; this will make any resulting subsequence\\n        # also be in sorted order, which gives the largest number from the set of digits\\n        self.digits = sorted( digits, key = lambda digit: - digit )\\n        digits_sum = sum( self.digits )\\n        print( \"digits_sum % 3\", digits_sum % 3 )\\n        residue = digits_sum % 3\\n        if residue == 0:\\n            return self.postProcess( self.digits )\\n        elif residue == 1:\\n            if self.digits.count( 1 ):\\n                index_1 = self.digits.index( 1 )\\n                self.digits.pop( index_1 )\\n                return self.postProcess( self.digits )\\n        elif residue == 2:\\n            if self.digits.count( 2 ):\\n                index_2 = self.digits.index( 2 )\\n                print( \"self.digits before pop\", self.digits, \"index_2\", index_2  )\\n                self.digits.pop( index_2 )\\n                print( \"self.digits after pop for 2\", self.digits )\\n                return self.postProcess( self.digits )              \\n        # As the hint suggests, the first step is to find a multiple of three\\n        # that has the greatest number of digits:\\n        print( \"digits has\", digits.count( 1 ), \"1\\'s and\", digits.count( 2 ), \"2\\'s\")\\n        index = 0\\n        sum_so_far = 0\\n        mostDigits = self.findMostDigits(index, sum_so_far);\\n        return self.postProcess( mostDigits ) \\n\\n    @lru_cache( 100_000 )\\n    def findMostDigits(self, index, sum_so_far):\\n        # Base case:\\n        if index == len(self.digits):\\n            result = [] if sum_so_far % 3 == 0 else None\\n        # Recursion case:\\n        else:\\n            # Try adding \"digits[index]\" to result\\n            rec_res_with = self.findMostDigits(index + 1, sum_so_far + self.digits[index])\\n            if rec_res_with is not None:\\n                result = [self.digits[index]] + rec_res_with\\n            else:\\n                result = None\\n            # Try NOT adding \"digits[index]\" to result\\n            rec_res_without = self.findMostDigits(index + 1, sum_so_far)\\n            if rec_res_without is not None:\\n                if result is not None:\\n                    result = rec_res_without if len( rec_res_without ) > len( result ) else result\\n                else:\\n                    result = rec_res_without\\n        return result\\n\\n    # This converts \"digits\" to a string and handles the case where there are leading zeros and\\n    # the case where there are no digits\\n    def postProcess( self, digits ):\\n        print( \"digits\", digits )\\n        if digits is None or len( digits ) == 0:\\n           return \"\"\\n        elif sum( digits ) == 0:\\n            return \"0\"\\n        else:\\n            return \\'\\'.join( map( str, digits ) )\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```lru_cache(None)```\n```lru_cache```\n```\\nclass Solution:\\n    def largestMultipleOfThree(self, digits: list[int]) -> str:\\n        # Sort the digits in descending order; this will make any resulting subsequence\\n        # also be in sorted order, which gives the largest number from the set of digits\\n        self.digits = sorted( digits, key = lambda digit: - digit )\\n        digits_sum = sum( self.digits )\\n        print( \"digits_sum % 3\", digits_sum % 3 )\\n        residue = digits_sum % 3\\n        if residue == 0:\\n            return self.postProcess( self.digits )\\n        elif residue == 1:\\n            if self.digits.count( 1 ):\\n                index_1 = self.digits.index( 1 )\\n                self.digits.pop( index_1 )\\n                return self.postProcess( self.digits )\\n        elif residue == 2:\\n            if self.digits.count( 2 ):\\n                index_2 = self.digits.index( 2 )\\n                print( \"self.digits before pop\", self.digits, \"index_2\", index_2  )\\n                self.digits.pop( index_2 )\\n                print( \"self.digits after pop for 2\", self.digits )\\n                return self.postProcess( self.digits )              \\n        # As the hint suggests, the first step is to find a multiple of three\\n        # that has the greatest number of digits:\\n        print( \"digits has\", digits.count( 1 ), \"1\\'s and\", digits.count( 2 ), \"2\\'s\")\\n        index = 0\\n        sum_so_far = 0\\n        mostDigits = self.findMostDigits(index, sum_so_far);\\n        return self.postProcess( mostDigits ) \\n\\n    @lru_cache( 100_000 )\\n    def findMostDigits(self, index, sum_so_far):\\n        # Base case:\\n        if index == len(self.digits):\\n            result = [] if sum_so_far % 3 == 0 else None\\n        # Recursion case:\\n        else:\\n            # Try adding \"digits[index]\" to result\\n            rec_res_with = self.findMostDigits(index + 1, sum_so_far + self.digits[index])\\n            if rec_res_with is not None:\\n                result = [self.digits[index]] + rec_res_with\\n            else:\\n                result = None\\n            # Try NOT adding \"digits[index]\" to result\\n            rec_res_without = self.findMostDigits(index + 1, sum_so_far)\\n            if rec_res_without is not None:\\n                if result is not None:\\n                    result = rec_res_without if len( rec_res_without ) > len( result ) else result\\n                else:\\n                    result = rec_res_without\\n        return result\\n\\n    # This converts \"digits\" to a string and handles the case where there are leading zeros and\\n    # the case where there are no digits\\n    def postProcess( self, digits ):\\n        print( \"digits\", digits )\\n        if digits is None or len( digits ) == 0:\\n           return \"\"\\n        elif sum( digits ) == 0:\\n            return \"0\"\\n        else:\\n            return \\'\\'.join( map( str, digits ) )\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3864945,
                "title": "2d-knapsack-dp",
                "content": "# Intuition\\nSolved this question by using simple knapsack question. I know the solution might not be very trivial but it was the first thing that came to my my when i read this question. Just sort the given array in decreasing order to get the maximum value and for every index think if we can take this form form our answer or not. \\n\\n# Approach\\n2D modified Knapsack DP\\n\\n# Complexity\\n- Time complexity:\\nO(48N)\\n\\n- Space complexity:\\nO(48N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int>solve(int i,int n,vector<int>&d,int curr,vector<vector<vector<int>>>&dp){\\n        // cout<<i<<\"  \"<<curr<<\"    \";\\n        if(i==n){\\n            vector<int>ans(12,0);\\n            if(curr==0){\\n                // cout<<endl;\\n                // cout<<\"dhoni \"<<i<<endl;\\n                return ans;\\n            }\\n            // cout<<endl;\\n            // cout<<\"buma=rah \"<<i<<endl;\\n            ans[10]++;\\n            return ans;\\n        }\\n        vector<int>check(12,-1);\\n        if(dp[i][curr]!=check){\\n            return dp[i][curr];\\n        }\\n        vector<int>take=solve(i+1,n,d,(curr+d[i])%3,dp);\\n        take[d[i]]++;\\n        take[11]++;\\n        vector<int>nt=solve(i+1,n,d,curr,dp);\\n        if(take[10]>=1 && nt[10]>=1){\\n            // cout<<\" chalo \";\\n            vector<int>nw(12,0);\\n            nw[10]++;\\n            return dp[i][curr]=nw;\\n        }\\n        else if(take[10]){\\n            // cout<<\" theek \";\\n            return dp[i][curr]=nt;\\n        }\\n        else if(nt[10]){\\n            // cout<<\" hai \";\\n            return dp[i][curr]=take;\\n        }\\n        if(take[11]>=nt[11]){\\n            // cout<<\" kohli \";\\n            return dp[i][curr]=take;\\n        }\\n        else{\\n            // cout<<\" pandya \";\\n            return dp[i][curr]=nt;\\n        }\\n    }\\n    string largestMultipleOfThree(vector<int>& d) {\\n        sort(d.begin(),d.end(),__greater());\\n        int n=d.size();\\n        vector<vector<vector<int>>>dp(n+1,vector<vector<int>>(3,vector<int>(12,-1)));\\n        vector<int>ans=solve(0,n,d,0,dp);\\n        string a;\\n        for(int i=0;i<10;i++){\\n            for(int j=0;j<ans[i];j++){\\n                a.push_back(i+\\'0\\');\\n            }\\n        }\\n        sort(a.begin(),a.end(),__greater());\\n        if(a.size()!=0 and a[0]==\\'0\\') return \"0\";\\n        return a;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int>solve(int i,int n,vector<int>&d,int curr,vector<vector<vector<int>>>&dp){\\n        // cout<<i<<\"  \"<<curr<<\"    \";\\n        if(i==n){\\n            vector<int>ans(12,0);\\n            if(curr==0){\\n                // cout<<endl;\\n                // cout<<\"dhoni \"<<i<<endl;\\n                return ans;\\n            }\\n            // cout<<endl;\\n            // cout<<\"buma=rah \"<<i<<endl;\\n            ans[10]++;\\n            return ans;\\n        }\\n        vector<int>check(12,-1);\\n        if(dp[i][curr]!=check){\\n            return dp[i][curr];\\n        }\\n        vector<int>take=solve(i+1,n,d,(curr+d[i])%3,dp);\\n        take[d[i]]++;\\n        take[11]++;\\n        vector<int>nt=solve(i+1,n,d,curr,dp);\\n        if(take[10]>=1 && nt[10]>=1){\\n            // cout<<\" chalo \";\\n            vector<int>nw(12,0);\\n            nw[10]++;\\n            return dp[i][curr]=nw;\\n        }\\n        else if(take[10]){\\n            // cout<<\" theek \";\\n            return dp[i][curr]=nt;\\n        }\\n        else if(nt[10]){\\n            // cout<<\" hai \";\\n            return dp[i][curr]=take;\\n        }\\n        if(take[11]>=nt[11]){\\n            // cout<<\" kohli \";\\n            return dp[i][curr]=take;\\n        }\\n        else{\\n            // cout<<\" pandya \";\\n            return dp[i][curr]=nt;\\n        }\\n    }\\n    string largestMultipleOfThree(vector<int>& d) {\\n        sort(d.begin(),d.end(),__greater());\\n        int n=d.size();\\n        vector<vector<vector<int>>>dp(n+1,vector<vector<int>>(3,vector<int>(12,-1)));\\n        vector<int>ans=solve(0,n,d,0,dp);\\n        string a;\\n        for(int i=0;i<10;i++){\\n            for(int j=0;j<ans[i];j++){\\n                a.push_back(i+\\'0\\');\\n            }\\n        }\\n        sort(a.begin(),a.end(),__greater());\\n        if(a.size()!=0 and a[0]==\\'0\\') return \"0\";\\n        return a;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3840209,
                "title": "swift-counting-sort-solution-with-o-n-time-and-o-1-space-complexity",
                "content": "# Intuition\\nWhen you realize that if sum of digits mod 3 is 0, then you will come up to the solution to remove either 1 digit which has the same reminder when moduling 3 as the sum or 2 smallest digits which in sum have the same reminder moduling 3.\\n\\n# Approach\\nWhen reminder of sum modulo 3 is 1 then we are looking for either 1 or 4 or 7. But if those are not found, then we are going to look for two smallest digits from 2,5,8. As their sum modulo 3 is also 1.\\nThe same goes when the sum modulo 3 is 2. We are looking either 2 or 5 or 8 and then if not found we look for any pair of digits from the sequence 1,4,7. \\n\\nInitially I built this with O(nlogn) time complexity due to sorting digits with sorted function and O(n) space complexity as I needed an array to keep sorted digits and remove found digit(s). But then I realized since we only have 10 different values in digits array, we can sort them by using counting. Counting sort gives us O(n) time complexity and as we need an array of 10 elements it gives us O(1) space complexity.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    private let digitDividendsWithReminder = [[1, 4, 7, 2, 5, 8], [2, 5, 8, 1, 4, 7]]\\n\\n    func largestMultipleOfThree(_ digits: [Int]) -> String {\\n        var sum = 0\\n        var frequencies = Array(repeating: 0, count: 10)\\n        \\n        digits.forEach {\\n            sum += $0\\n            frequencies[$0] += 1\\n        }\\n        \\n        let reminder = sum % 3\\n        if reminder > 0 {\\n            let sequence = digitDividendsWithReminder[reminder - 1]\\n            for digit in sequence {\\n                while sum % 3 > 0 && frequencies[digit] > 0 {\\n                    frequencies[digit] -= 1\\n                    sum -= digit\\n                }\\n            }\\n        }\\n            \\n        if sum % 3 > 0 { return \"\" }\\n        \\n        let sumOfFrequencies = frequencies.reduce(0, +)\\n        \\n        if sumOfFrequencies == 0 { return \"\" }\\n        \\n        if sumOfFrequencies == frequencies[0] { return \"0\" }\\n        \\n        return frequencies.enumerated().map { Array(repeating: \"\\\\($0.offset)\", count: $0.element) }.reversed().flatMap { $0 }.joined()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Counting Sort"
                ],
                "code": "```\\nclass Solution {\\n    private let digitDividendsWithReminder = [[1, 4, 7, 2, 5, 8], [2, 5, 8, 1, 4, 7]]\\n\\n    func largestMultipleOfThree(_ digits: [Int]) -> String {\\n        var sum = 0\\n        var frequencies = Array(repeating: 0, count: 10)\\n        \\n        digits.forEach {\\n            sum += $0\\n            frequencies[$0] += 1\\n        }\\n        \\n        let reminder = sum % 3\\n        if reminder > 0 {\\n            let sequence = digitDividendsWithReminder[reminder - 1]\\n            for digit in sequence {\\n                while sum % 3 > 0 && frequencies[digit] > 0 {\\n                    frequencies[digit] -= 1\\n                    sum -= digit\\n                }\\n            }\\n        }\\n            \\n        if sum % 3 > 0 { return \"\" }\\n        \\n        let sumOfFrequencies = frequencies.reduce(0, +)\\n        \\n        if sumOfFrequencies == 0 { return \"\" }\\n        \\n        if sumOfFrequencies == frequencies[0] { return \"0\" }\\n        \\n        return frequencies.enumerated().map { Array(repeating: \"\\\\($0.offset)\", count: $0.element) }.reversed().flatMap { $0 }.joined()\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3807618,
                "title": "rust-greedy",
                "content": "# Code\\n```\\npub fn normalize(\\n    mut vec: [Vec<u8>; 3],\\n    diff: u8,\\n) -> Option<[Vec<u8>; 3]> {\\n    if diff < 1 { return Some(vec); }\\n\\n    if vec[1].is_empty() && vec[2].is_empty() {\\n        return None;\\n    }\\n\\n    if vec[1].is_empty() {\\n        vec[2].pop();\\n        return normalize(vec, (diff + 1) % 3);\\n    }\\n\\n    if vec[2].is_empty() {\\n        vec[1].pop();\\n        return normalize(vec, (diff + 2) % 3);\\n    }\\n\\n    // both non-empty\\n    vec[diff as usize].pop();\\n    Some(vec)\\n}\\n\\nimpl Solution {\\n    fn preproc(mut vec: Vec<i32>) -> ([Vec<u8>; 3], u8) {\\n        vec.sort_unstable();\\n        vec.reverse();\\n        let diff = vec.iter().sum::<i32>() as u32;\\n        let diff = (diff % 3) as u8;\\n\\n        let mut ret = [vec![], vec![], vec![]];\\n\\n        for e in vec {\\n            ret[e as usize % 3].push(e as u8);\\n        }\\n\\n        (ret, diff)\\n    }\\n\\n    fn _impl(vec: Vec<i32>) -> Option<Vec<u8>> {\\n        let (vec, diff) = Self::preproc(vec);\\n        let [mut vec_0, mut vec_1, mut vec_2] = normalize(vec, diff)?;\\n\\n        vec_0.append(&mut vec_1);\\n        vec_0.append(&mut vec_2);\\n        vec_0.sort_unstable();\\n        vec_0.reverse();\\n\\n        if vec_0.is_empty() { return None; }\\n        if vec_0[0] < 1 { return Some(vec![0]); }\\n\\n        Some(vec_0)\\n    }\\n\\n    pub fn largest_multiple_of_three(vec: Vec<i32>) -> String {\\n        let ret = if let Some(inner) = Self::_impl(vec) {\\n            inner\\n        } else { return String::new(); };\\n\\n        ret.into_iter()\\n            .map(|e| (e + \\'0\\' as u8) as char)\\n            .collect()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Math",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\npub fn normalize(\\n    mut vec: [Vec<u8>; 3],\\n    diff: u8,\\n) -> Option<[Vec<u8>; 3]> {\\n    if diff < 1 { return Some(vec); }\\n\\n    if vec[1].is_empty() && vec[2].is_empty() {\\n        return None;\\n    }\\n\\n    if vec[1].is_empty() {\\n        vec[2].pop();\\n        return normalize(vec, (diff + 1) % 3);\\n    }\\n\\n    if vec[2].is_empty() {\\n        vec[1].pop();\\n        return normalize(vec, (diff + 2) % 3);\\n    }\\n\\n    // both non-empty\\n    vec[diff as usize].pop();\\n    Some(vec)\\n}\\n\\nimpl Solution {\\n    fn preproc(mut vec: Vec<i32>) -> ([Vec<u8>; 3], u8) {\\n        vec.sort_unstable();\\n        vec.reverse();\\n        let diff = vec.iter().sum::<i32>() as u32;\\n        let diff = (diff % 3) as u8;\\n\\n        let mut ret = [vec![], vec![], vec![]];\\n\\n        for e in vec {\\n            ret[e as usize % 3].push(e as u8);\\n        }\\n\\n        (ret, diff)\\n    }\\n\\n    fn _impl(vec: Vec<i32>) -> Option<Vec<u8>> {\\n        let (vec, diff) = Self::preproc(vec);\\n        let [mut vec_0, mut vec_1, mut vec_2] = normalize(vec, diff)?;\\n\\n        vec_0.append(&mut vec_1);\\n        vec_0.append(&mut vec_2);\\n        vec_0.sort_unstable();\\n        vec_0.reverse();\\n\\n        if vec_0.is_empty() { return None; }\\n        if vec_0[0] < 1 { return Some(vec![0]); }\\n\\n        Some(vec_0)\\n    }\\n\\n    pub fn largest_multiple_of_three(vec: Vec<i32>) -> String {\\n        let ret = if let Some(inner) = Self::_impl(vec) {\\n            inner\\n        } else { return String::new(); };\\n\\n        ret.into_iter()\\n            .map(|e| (e + \\'0\\' as u8) as char)\\n            .collect()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3715962,
                "title": "c-easy-and-short-simple-to-understand",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nGreedily selecting the numbers and forming max sum\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string largestMultipleOfThree(vector<int>& arr) {\\n        vector<int> cnt(10, 0);\\n        for (auto i : arr)\\n            cnt[i]++;\\n\\n        int remone = cnt[1] + cnt[4] + cnt[7];\\n        int remtwo = cnt[2] + cnt[5] + cnt[8];\\n        int rem = (remone + 2 * remtwo) % 3;\\n\\n        if (rem == 1) {\\n            if (remone >= 1)\\n                remone -= 1;\\n            else\\n                remtwo -= 2;\\n        } else if (rem == 2) {\\n            if (remtwo >= 1)\\n                remtwo -= 1;\\n            else\\n                remone -= 2;\\n        }\\n\\n        string s = \"\";\\n        for (int i = 9; i >= 0; i--) {  \\n            if (i % 3 == 0)\\n                s.append(cnt[i], \\'0\\' + i); \\n            else if (i % 3 == 1)\\n                while (cnt[i]-- > 0 && remone-- > 0)\\n                    s += to_string(i);\\n            else\\n                while (cnt[i]-- > 0 && remtwo-- > 0)\\n                    s += to_string(i);\\n        }\\n\\n        if (s.length() > 0 && s[0] == \\'0\\')\\n            return \"0\";\\n        return s;\\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestMultipleOfThree(vector<int>& arr) {\\n        vector<int> cnt(10, 0);\\n        for (auto i : arr)\\n            cnt[i]++;\\n\\n        int remone = cnt[1] + cnt[4] + cnt[7];\\n        int remtwo = cnt[2] + cnt[5] + cnt[8];\\n        int rem = (remone + 2 * remtwo) % 3;\\n\\n        if (rem == 1) {\\n            if (remone >= 1)\\n                remone -= 1;\\n            else\\n                remtwo -= 2;\\n        } else if (rem == 2) {\\n            if (remtwo >= 1)\\n                remtwo -= 1;\\n            else\\n                remone -= 2;\\n        }\\n\\n        string s = \"\";\\n        for (int i = 9; i >= 0; i--) {  \\n            if (i % 3 == 0)\\n                s.append(cnt[i], \\'0\\' + i); \\n            else if (i % 3 == 1)\\n                while (cnt[i]-- > 0 && remone-- > 0)\\n                    s += to_string(i);\\n            else\\n                while (cnt[i]-- > 0 && remtwo-- > 0)\\n                    s += to_string(i);\\n        }\\n\\n        if (s.length() > 0 && s[0] == \\'0\\')\\n            return \"0\";\\n        return s;\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3698127,
                "title": "c-solution-simple-greedy-o-n-log-n-solution-faster-and-understandable",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void findIndices(vector<int>&digits,int& first,int& second,int rem){\\n            for(int i=0;i<digits.size();i++){\\n                if(digits[i] % 3 == rem){\\n                    if(first == -1) first = i;\\n                    else{\\n                        second = i;\\n                        break;\\n                    }\\n                }\\n            }\\n    }\\n\\n    string largestMultipleOfThree(vector<int>& digits) {\\n        int n = digits.size();\\n        sort(digits.begin(),digits.end());\\n        int sum = accumulate(digits.begin(),digits.end(),0);\\n        \\n        string ans = \"\";\\n        if(sum % 3 != 0){\\n            int same = (sum % 3);\\n            int other = (same == 1 ? 2 : 1);\\n\\n            bool isIdealFound = false;\\n            int first = -1,second = -1;\\n\\n            findIndices(digits,first,second,same);\\n            if(first != -1){\\n                //if minimum elements with same remender found just remove this\\n                isIdealFound = true;\\n                digits[first] = -1;\\n            }\\n\\n            if(!isIdealFound){\\n                //if same remainder element not found look for two with other rem and remove\\n                findIndices(digits,first,second,other);\\n                if(second == -1) return \"\";\\n                digits[first] = -1;\\n                digits[second] = -1;\\n            }\\n        }\\n        \\n        //calculating answer\\n        for(int i=n-1;i>=0;i--){\\n            if(digits[i] != -1) ans.push_back(digits[i] + \\'0\\');\\n        }\\n        \\n        if(ans.size() == 0) return \"\";\\n        else if(ans[0] == \\'0\\') return \"0\";\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void findIndices(vector<int>&digits,int& first,int& second,int rem){\\n            for(int i=0;i<digits.size();i++){\\n                if(digits[i] % 3 == rem){\\n                    if(first == -1) first = i;\\n                    else{\\n                        second = i;\\n                        break;\\n                    }\\n                }\\n            }\\n    }\\n\\n    string largestMultipleOfThree(vector<int>& digits) {\\n        int n = digits.size();\\n        sort(digits.begin(),digits.end());\\n        int sum = accumulate(digits.begin(),digits.end(),0);\\n        \\n        string ans = \"\";\\n        if(sum % 3 != 0){\\n            int same = (sum % 3);\\n            int other = (same == 1 ? 2 : 1);\\n\\n            bool isIdealFound = false;\\n            int first = -1,second = -1;\\n\\n            findIndices(digits,first,second,same);\\n            if(first != -1){\\n                //if minimum elements with same remender found just remove this\\n                isIdealFound = true;\\n                digits[first] = -1;\\n            }\\n\\n            if(!isIdealFound){\\n                //if same remainder element not found look for two with other rem and remove\\n                findIndices(digits,first,second,other);\\n                if(second == -1) return \"\";\\n                digits[first] = -1;\\n                digits[second] = -1;\\n            }\\n        }\\n        \\n        //calculating answer\\n        for(int i=n-1;i>=0;i--){\\n            if(digits[i] != -1) ans.push_back(digits[i] + \\'0\\');\\n        }\\n        \\n        if(ans.size() == 0) return \"\";\\n        else if(ans[0] == \\'0\\') return \"0\";\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3648422,
                "title": "solution",
                "content": "To find the largest multiple of three, we need to consider the following cases:\\n\\n1. If the sum of all digits is divisible by 3, we can use all the digits to form the largest multiple of three. In this case, we should sort the digits in non-ascending order and return the result as a string.\\n\\n2. If the sum of all digits modulo 3 is 1, we need to remove one digit with a remainder of 1 (if available) or two digits with a remainder of 2 (if available) to make the sum divisible by 3. To maximize the resulting number, we should prioritize removing digits with larger values. Therefore, we can sort the digits in non-ascending order and try to remove the smallest digit(s) with the corresponding remainder(s). After removing the necessary digits, we should return the remaining digits as the result if any exist.\\n3. If the sum of all digits modulo 3 is 2, we need to remove one digit with a remainder of 2 (if available) or two digits with a remainder of 1 (if available) to make the sum divisible by 3. Similar to the previous case, we should sort the digits in non-ascending order and remove the smallest digit(s) with the corresponding remainder(s). Finally, we return the remaining digits as the result if any exist.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n log n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n# Code\\n```\\nfrom typing import List\\n\\nclass Solution:\\n    def largestMultipleOfThree(self, digits: List[int]) -> str:\\n        digits.sort(reverse=True)\\n        total_sum = sum(digits)\\n\\n        if total_sum % 3 == 0:\\n            if digits and digits[0] == 0:\\n                return \"0\"\\n            return \\'\\'.join(map(str, digits))\\n\\n        remainder_1 = [digit for digit in digits if digit % 3 == 1]\\n        remainder_2 = [digit for digit in digits if digit % 3 == 2]\\n\\n        if total_sum % 3 == 1:\\n            if remainder_1:\\n                digits.remove(remainder_1[-1])\\n            elif len(remainder_2) >= 2:\\n                digits.remove(remainder_2[-1])\\n                digits.remove(remainder_2[-2])\\n            else:\\n                return \"\"\\n        elif total_sum % 3 == 2:\\n            if remainder_2:\\n                digits.remove(remainder_2[-1])\\n            elif len(remainder_1) >= 2:\\n                digits.remove(remainder_1[-1])\\n                digits.remove(remainder_1[-2])\\n            else:\\n                return \"\"\\n\\n        if digits and digits[0] == 0:\\n            return \"0\"\\n        return \\'\\'.join(map(str, digits))\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom typing import List\\n\\nclass Solution:\\n    def largestMultipleOfThree(self, digits: List[int]) -> str:\\n        digits.sort(reverse=True)\\n        total_sum = sum(digits)\\n\\n        if total_sum % 3 == 0:\\n            if digits and digits[0] == 0:\\n                return \"0\"\\n            return \\'\\'.join(map(str, digits))\\n\\n        remainder_1 = [digit for digit in digits if digit % 3 == 1]\\n        remainder_2 = [digit for digit in digits if digit % 3 == 2]\\n\\n        if total_sum % 3 == 1:\\n            if remainder_1:\\n                digits.remove(remainder_1[-1])\\n            elif len(remainder_2) >= 2:\\n                digits.remove(remainder_2[-1])\\n                digits.remove(remainder_2[-2])\\n            else:\\n                return \"\"\\n        elif total_sum % 3 == 2:\\n            if remainder_2:\\n                digits.remove(remainder_2[-1])\\n            elif len(remainder_1) >= 2:\\n                digits.remove(remainder_1[-1])\\n                digits.remove(remainder_1[-2])\\n            else:\\n                return \"\"\\n\\n        if digits and digits[0] == 0:\\n            return \"0\"\\n        return \\'\\'.join(map(str, digits))\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3484765,
                "title": "my-solutions",
                "content": "**1. Use the DP**\\n```\\n/**\\n * Time Complexity: O(n)\\n * Space Complexity: O(1)\\n * where `n` is the length of the vector `digits`\\n */\\nclass Solution {\\n private:\\n  static constexpr int n_digits = 10;\\n  \\n public:\\n  string largestMultipleOfThree(const vector<int> &digits) {\\n    constexpr char zero = \\'0\\';\\n    constexpr int range = 2;\\n    constexpr int remainders = 3;\\n    pair<bool, array<int, n_digits>> dp[range][remainders];\\n    int previous = 0;\\n    int current = 1;\\n    dp[previous][0].first = true;\\n    fill(dp[previous][0].second.begin(), dp[previous][0].second.end(), 0);\\n    copy(dp[previous], dp[previous] + remainders, dp[current]);\\n    for (const int digit : digits) {\\n      for (int pr = 0; pr < remainders; ++pr) {\\n        if (!dp[previous][pr].first) {\\n          continue;\\n        }\\n\\n        const int r = (pr + digit) % remainders;\\n        array<int, n_digits> value(dp[previous][pr].second);\\n        ++value[digit];\\n        update(dp[current][r], value);\\n      }\\n      \\n      previous ^= 1;\\n      current ^= 1;\\n      copy(dp[previous], dp[previous] + remainders, dp[current]);\\n    }\\n    \\n    string ret;\\n    for (int digit = n_digits - 1; digit > -1; --digit) {\\n      ret.append(dp[previous][0].second[digit], zero + digit);\\n    }\\n    return !ret.empty() && ret.front() == zero ? string(1, zero) : ret;\\n  }\\n  \\n private:\\n  void update(pair<bool, array<int, n_digits>> &target, array<int, n_digits> &source) {\\n    if (!target.first) {\\n      target.first = true;\\n      target.second = move(source);\\n      return;\\n    }\\n\\n    const int target_length = accumulate(target.second.begin(), target.second.end(), 0);\\n    const int source_length = accumulate(source.begin(), source.end(), 0);\\n    if (target_length != source_length) {\\n      if (target_length < source_length) {\\n        target.second = move(source);\\n      }\\n      return;\\n    }\\n    \\n    for (int digit = n_digits - 1; digit > -1; --digit) {\\n      if (target.second[digit] != source[digit]) {\\n        if (target.second[digit] < source[digit]) {\\n          target.second = move(source);\\n        }\\n        return;\\n      }\\n    }\\n  }\\n};\\n```\\n**2. Use the math**\\n```\\n/**\\n * Time Complexity: O(n)\\n * Space Complexity: O(1)\\n * where `n` is the length of the vector `digits`\\n */\\nclass Solution {\\n private:\\n  static constexpr int n_digits = 10;\\n  \\n public:\\n  string largestMultipleOfThree(const vector<int> &digits) {\\n    constexpr char zero = \\'0\\';\\n    constexpr int mod = 3;\\n    int digit_counts[n_digits]{};\\n    int remainder = 0;\\n    for (const int digit : digits) {\\n      ++digit_counts[digit];\\n      remainder = (remainder + digit) % mod;\\n    }\\n    \\n    if (remainder != 0) {\\n      adjust(digit_counts, remainder);\\n    }\\n    \\n    string ret;\\n    for (int digit = n_digits - 1; digit > -1; --digit) {\\n      ret.append(digit_counts[digit], zero + digit);\\n    }\\n    return !ret.empty() && ret.front() == zero ? string(1, zero) : ret;\\n  }\\n  \\n private:\\n  void adjust(int *digit_counts, const int remainder) {\\n    constexpr int ones[] = {1, 4, 7};\\n    constexpr int twos[] = {2, 5, 8};\\n    const auto &first_try = remainder == 1 ? ones : twos;\\n    const auto &second_try = remainder == 1 ? twos : ones;\\n    bool completed = false;\\n    for (const int digit : first_try) {\\n      if (digit_counts[digit] > 0) {\\n        --digit_counts[digit];\\n        completed = true;\\n        break;\\n      }\\n    }\\n    if (completed) {\\n      return;\\n    }\\n    \\n    constexpr int try_times = 2;\\n    for (int try_time = 0; try_time < try_times; ++try_time) {\\n      for (const int digit : second_try) {\\n        if (digit_counts[digit] > 0) {\\n          --digit_counts[digit];\\n          break;\\n        }\\n      }\\n    }\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Time Complexity: O(n)\\n * Space Complexity: O(1)\\n * where `n` is the length of the vector `digits`\\n */\\nclass Solution {\\n private:\\n  static constexpr int n_digits = 10;\\n  \\n public:\\n  string largestMultipleOfThree(const vector<int> &digits) {\\n    constexpr char zero = \\'0\\';\\n    constexpr int range = 2;\\n    constexpr int remainders = 3;\\n    pair<bool, array<int, n_digits>> dp[range][remainders];\\n    int previous = 0;\\n    int current = 1;\\n    dp[previous][0].first = true;\\n    fill(dp[previous][0].second.begin(), dp[previous][0].second.end(), 0);\\n    copy(dp[previous], dp[previous] + remainders, dp[current]);\\n    for (const int digit : digits) {\\n      for (int pr = 0; pr < remainders; ++pr) {\\n        if (!dp[previous][pr].first) {\\n          continue;\\n        }\\n\\n        const int r = (pr + digit) % remainders;\\n        array<int, n_digits> value(dp[previous][pr].second);\\n        ++value[digit];\\n        update(dp[current][r], value);\\n      }\\n      \\n      previous ^= 1;\\n      current ^= 1;\\n      copy(dp[previous], dp[previous] + remainders, dp[current]);\\n    }\\n    \\n    string ret;\\n    for (int digit = n_digits - 1; digit > -1; --digit) {\\n      ret.append(dp[previous][0].second[digit], zero + digit);\\n    }\\n    return !ret.empty() && ret.front() == zero ? string(1, zero) : ret;\\n  }\\n  \\n private:\\n  void update(pair<bool, array<int, n_digits>> &target, array<int, n_digits> &source) {\\n    if (!target.first) {\\n      target.first = true;\\n      target.second = move(source);\\n      return;\\n    }\\n\\n    const int target_length = accumulate(target.second.begin(), target.second.end(), 0);\\n    const int source_length = accumulate(source.begin(), source.end(), 0);\\n    if (target_length != source_length) {\\n      if (target_length < source_length) {\\n        target.second = move(source);\\n      }\\n      return;\\n    }\\n    \\n    for (int digit = n_digits - 1; digit > -1; --digit) {\\n      if (target.second[digit] != source[digit]) {\\n        if (target.second[digit] < source[digit]) {\\n          target.second = move(source);\\n        }\\n        return;\\n      }\\n    }\\n  }\\n};\\n```\n```\\n/**\\n * Time Complexity: O(n)\\n * Space Complexity: O(1)\\n * where `n` is the length of the vector `digits`\\n */\\nclass Solution {\\n private:\\n  static constexpr int n_digits = 10;\\n  \\n public:\\n  string largestMultipleOfThree(const vector<int> &digits) {\\n    constexpr char zero = \\'0\\';\\n    constexpr int mod = 3;\\n    int digit_counts[n_digits]{};\\n    int remainder = 0;\\n    for (const int digit : digits) {\\n      ++digit_counts[digit];\\n      remainder = (remainder + digit) % mod;\\n    }\\n    \\n    if (remainder != 0) {\\n      adjust(digit_counts, remainder);\\n    }\\n    \\n    string ret;\\n    for (int digit = n_digits - 1; digit > -1; --digit) {\\n      ret.append(digit_counts[digit], zero + digit);\\n    }\\n    return !ret.empty() && ret.front() == zero ? string(1, zero) : ret;\\n  }\\n  \\n private:\\n  void adjust(int *digit_counts, const int remainder) {\\n    constexpr int ones[] = {1, 4, 7};\\n    constexpr int twos[] = {2, 5, 8};\\n    const auto &first_try = remainder == 1 ? ones : twos;\\n    const auto &second_try = remainder == 1 ? twos : ones;\\n    bool completed = false;\\n    for (const int digit : first_try) {\\n      if (digit_counts[digit] > 0) {\\n        --digit_counts[digit];\\n        completed = true;\\n        break;\\n      }\\n    }\\n    if (completed) {\\n      return;\\n    }\\n    \\n    constexpr int try_times = 2;\\n    for (int try_time = 0; try_time < try_times; ++try_time) {\\n      for (const int digit : second_try) {\\n        if (digit_counts[digit] > 0) {\\n          --digit_counts[digit];\\n          break;\\n        }\\n      }\\n    }\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3438398,
                "title": "an-o-n-solution-using-simple-math-knowledge-beats-100-runtime",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSuppose $$sum$$ is the sum of all element in $$digits$$\\n- If $$sum$$ % 3 == 0, we don\\'t need to discard any digit\\n- If $$sum$$ % 3 == 1, we will discard the smallest digit that % 3 == 1 or two smalest digits that % 3 == 2\\n- If $$sum$$ % 3 == 2, we will discard the smallest digit that % 3 == 2 or two smalest digits that % 3 == 1 \\n- Sort the $$digits$$ array (after discarding digits) using counting sort and get the final result\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string largestMultipleOfThree(vector<int>& digits) {\\n        int dSize = digits.size();\\n\\n        int sum = 0;\\n        \\n        int min1_1 = 10;    // the smallest digit % 3 == 1\\n        int index1_1 = -1;  // index of the smallest digit % 3 == 1\\n        \\n        int min1_2 = 13;    // the second smallest digit % 3 == 1\\n        int index1_2 = -1;  // index of the second smallest digit % 2 == 1\\n\\n        int min2_1 = 11;    // the smallest digit % 3 == 2\\n        int index2_1 = -1;  // index of the smallest digit % 3 == 2\\n\\n        int min2_2= 14;     // the second smallest digit % 3 == 2\\n        int index2_2 = -1;  // index of the second smallest digit % 3 == 2\\n\\n        for (int i=0; i < dSize; i++) {\\n            sum += digits[i];\\n            if (digits[i] % 3 == 1) {\\n                if (digits[i] < min1_1) {\\n                    min1_2 = min1_1;\\n                    index1_2 = index1_1;\\n                    min1_1 = digits[i];\\n                    index1_1 = i;\\n                } else if (digits[i] < min1_2) {\\n                    min1_2 = digits[i];\\n                    index1_2 = i;\\n                }\\n            } else if (digits[i] % 3 == 2) {\\n                if (digits[i] < min2_1) {\\n                    min2_2 = min2_1;\\n                    index2_2 = index2_1;\\n                    min2_1 = digits[i];\\n                    index2_1 = i;\\n                } else if (digits[i] < min2_2) {\\n                    min2_2 = digits[i];\\n                    index2_2 = i;\\n                }\\n            }\\n        }\\n\\n        if (sum % 3 == 1) {\\n            if (index1_1 != -1) {         // discard the smallest digit % 3 == 1 \\n                digits[index1_1] = -1;\\n            } else {  // discard two smallest digits % 3 == 2 \\n                digits[index2_1] = -1;\\n                digits[index2_2] = -1;\\n            }\\n        } else if (sum % 3 == 2) {\\n            if (index2_1 != -1) {   // discard the smallest digit % 3 == 2\\n                digits[index2_1] = -1;\\n            } else {    //discard two smallest digits % 3 == 1 \\n                digits[index1_1] = -1;\\n                digits[index1_2] = -1;\\n            }\\n        }\\n\\n        vector<int> count(10, 0);\\n        string res =\"\";\\n        \\n        for (int i = 0; i< dSize; i++) {\\n            if (digits[i] >= 0) count[digits[i]] ++;\\n        }\\n\\n        for (int i=9; i>=0; i--) {\\n            if (res == \"\" && i == 0 && count[i] > 0) {\\n                res += \\'0\\';\\n                break;\\n            }\\n            if (count[i] > 0) {\\n                string tmp(count[i], i + \\'0\\');\\n                res += tmp;\\n            }\\n        }\\n\\n        return res;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Counting Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestMultipleOfThree(vector<int>& digits) {\\n        int dSize = digits.size();\\n\\n        int sum = 0;\\n        \\n        int min1_1 = 10;    // the smallest digit % 3 == 1\\n        int index1_1 = -1;  // index of the smallest digit % 3 == 1\\n        \\n        int min1_2 = 13;    // the second smallest digit % 3 == 1\\n        int index1_2 = -1;  // index of the second smallest digit % 2 == 1\\n\\n        int min2_1 = 11;    // the smallest digit % 3 == 2\\n        int index2_1 = -1;  // index of the smallest digit % 3 == 2\\n\\n        int min2_2= 14;     // the second smallest digit % 3 == 2\\n        int index2_2 = -1;  // index of the second smallest digit % 3 == 2\\n\\n        for (int i=0; i < dSize; i++) {\\n            sum += digits[i];\\n            if (digits[i] % 3 == 1) {\\n                if (digits[i] < min1_1) {\\n                    min1_2 = min1_1;\\n                    index1_2 = index1_1;\\n                    min1_1 = digits[i];\\n                    index1_1 = i;\\n                } else if (digits[i] < min1_2) {\\n                    min1_2 = digits[i];\\n                    index1_2 = i;\\n                }\\n            } else if (digits[i] % 3 == 2) {\\n                if (digits[i] < min2_1) {\\n                    min2_2 = min2_1;\\n                    index2_2 = index2_1;\\n                    min2_1 = digits[i];\\n                    index2_1 = i;\\n                } else if (digits[i] < min2_2) {\\n                    min2_2 = digits[i];\\n                    index2_2 = i;\\n                }\\n            }\\n        }\\n\\n        if (sum % 3 == 1) {\\n            if (index1_1 != -1) {         // discard the smallest digit % 3 == 1 \\n                digits[index1_1] = -1;\\n            } else {  // discard two smallest digits % 3 == 2 \\n                digits[index2_1] = -1;\\n                digits[index2_2] = -1;\\n            }\\n        } else if (sum % 3 == 2) {\\n            if (index2_1 != -1) {   // discard the smallest digit % 3 == 2\\n                digits[index2_1] = -1;\\n            } else {    //discard two smallest digits % 3 == 1 \\n                digits[index1_1] = -1;\\n                digits[index1_2] = -1;\\n            }\\n        }\\n\\n        vector<int> count(10, 0);\\n        string res =\"\";\\n        \\n        for (int i = 0; i< dSize; i++) {\\n            if (digits[i] >= 0) count[digits[i]] ++;\\n        }\\n\\n        for (int i=9; i>=0; i--) {\\n            if (res == \"\" && i == 0 && count[i] > 0) {\\n                res += \\'0\\';\\n                break;\\n            }\\n            if (count[i] > 0) {\\n                string tmp(count[i], i + \\'0\\');\\n                res += tmp;\\n            }\\n        }\\n\\n        return res;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3391665,
                "title": "python-solution-faster-than-99-with-detailed-explanation",
                "content": "A number that is a multiple of three meets the property that the sum of all digits is a multiple of three. \\nThus, we can try to find the answer from the three options from the n input digits in the following order: \\n1. The answer is composed by all the n digits if the sum of all the n digits is a multiple of three.\\n2. The answer is composed by n-1 digits by making the sum of n-1 digits a multiple of three. \\n3. The answer is composed by n-2 digits by making the sum of n-2 digits a multiple of three. \\n\\nFor case 2 and case 3, the digit(s) to remove is the smaller the better. Finally, we can generate the answer by descending order of the available digits. \\n\\n```\\nclass Solution:\\n    def find_one(self, digits, r):\\n        for i in range(r, 10, 3):\\n            if digits[i] > 0:\\n                digits[i] -= 1\\n                return True\\n        return False\\n                \\n    def find_two(self, digits, r):\\n        for i in range(3 - r, 10, 3):\\n            if digits[i] >= 2:\\n                digits[i] -= 2\\n                return True\\n            elif digits[i] == 1:\\n                for j in range(i + 3, 10, 3):\\n                    if digits[j] >= 1:\\n                        digits[i] -= 1\\n                        digits[j] -= 1\\n                        return True\\n        return False\\n        \\n    def largestMultipleOfThree(self, digits: List[int]) -> str:\\n        digits = Counter(digits)\\n        s = functools.reduce(lambda a, b: (a + b) % 3, [v * c % 3 for v, c in digits.items()])\\n        \\n        if s % 3 != 0 and not self.find_one(digits, s % 3) and not self.find_two(digits, s % 3):\\n            return \"\"\\n        ans = \"\".join(str(i)*digits[i] for i in range(9, 0, -1))\\n        if ans == \"\":\\n            return \"0\" if digits[0] > 0 else \"\"\\n        return ans + \"0\" * digits[0]",
                "solutionTags": [
                    "Python3",
                    "Greedy"
                ],
                "code": "A number that is a multiple of three meets the property that the sum of all digits is a multiple of three. \\nThus, we can try to find the answer from the three options from the n input digits in the following order: \\n1. The answer is composed by all the n digits if the sum of all the n digits is a multiple of three.\\n2. The answer is composed by n-1 digits by making the sum of n-1 digits a multiple of three. \\n3. The answer is composed by n-2 digits by making the sum of n-2 digits a multiple of three. \\n\\nFor case 2 and case 3, the digit(s) to remove is the smaller the better. Finally, we can generate the answer by descending order of the available digits. \\n\\n```\\nclass Solution:\\n    def find_one(self, digits, r):\\n        for i in range(r, 10, 3):\\n            if digits[i] > 0:\\n                digits[i] -= 1\\n                return True\\n        return False\\n                \\n    def find_two(self, digits, r):\\n        for i in range(3 - r, 10, 3):\\n            if digits[i] >= 2:\\n                digits[i] -= 2\\n                return True\\n            elif digits[i] == 1:\\n                for j in range(i + 3, 10, 3):\\n                    if digits[j] >= 1:\\n                        digits[i] -= 1\\n                        digits[j] -= 1\\n                        return True\\n        return False\\n        \\n    def largestMultipleOfThree(self, digits: List[int]) -> str:\\n        digits = Counter(digits)\\n        s = functools.reduce(lambda a, b: (a + b) % 3, [v * c % 3 for v, c in digits.items()])\\n        \\n        if s % 3 != 0 and not self.find_one(digits, s % 3) and not self.find_two(digits, s % 3):\\n            return \"\"\\n        ans = \"\".join(str(i)*digits[i] for i in range(9, 0, -1))\\n        if ans == \"\":\\n            return \"0\" if digits[0] > 0 else \"\"\\n        return ans + \"0\" * digits[0]",
                "codeTag": "Java"
            },
            {
                "id": 3372536,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    string largestMultipleOfThree(vector<int>& digits) {\\n        vector<int>count(10) ;\\n        vector<int>mod1 = {1, 4, 7} ;\\n        vector<int>mod2 = {2, 5 ,8} ;\\n        int sum = 0 ;\\n        string ret ;\\n        for(auto& x : digits){\\n            count[x]++ ;\\n            sum += x ;\\n        }\\n        cout << sum ;\\n        if(sum % 3 == 1){\\n            bool flag = false ;\\n            for(auto& idx : mod1){\\n                if(count[idx] > 0){\\n                    flag = true ;\\n                    count[idx]-- ; \\n                    break ;\\n                }\\n            }\\n            if(flag == false){\\n                int k = 2 ;\\n                for(auto& idx : mod2){\\n                    while(count[idx] > 0 && k > 0){\\n                        count[idx]-- ;\\n                        k-- ;\\n                    }\\n                }\\n            }\\n        }\\n        else if(sum % 3 == 2){\\n            bool flag = false ;\\n            for(auto& idx : mod2){\\n                if(count[idx] > 0){\\n                    flag = true ;\\n                    count[idx]-- ; \\n                    break ;\\n                }\\n            }\\n            if(flag == false){\\n                int k = 2 ;\\n                for(auto& idx : mod1){\\n                    while(count[idx] > 0 && k > 0){\\n                        count[idx]-- ;\\n                        k-- ;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        for (int i = 9; i >= 0; i--)\\n            ret += string(count[i], \\'0\\' + i);\\n        \\n        if(ret.size() > 1 && ret[0] == \\'0\\')\\n            ret = \"0\" ;\\n        \\n        return ret ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestMultipleOfThree(vector<int>& digits) {\\n        vector<int>count(10) ;\\n        vector<int>mod1 = {1, 4, 7} ;\\n        vector<int>mod2 = {2, 5 ,8} ;\\n        int sum = 0 ;\\n        string ret ;\\n        for(auto& x : digits){\\n            count[x]++ ;\\n            sum += x ;\\n        }\\n        cout << sum ;\\n        if(sum % 3 == 1){\\n            bool flag = false ;\\n            for(auto& idx : mod1){\\n                if(count[idx] > 0){\\n                    flag = true ;\\n                    count[idx]-- ; \\n                    break ;\\n                }\\n            }\\n            if(flag == false){\\n                int k = 2 ;\\n                for(auto& idx : mod2){\\n                    while(count[idx] > 0 && k > 0){\\n                        count[idx]-- ;\\n                        k-- ;\\n                    }\\n                }\\n            }\\n        }\\n        else if(sum % 3 == 2){\\n            bool flag = false ;\\n            for(auto& idx : mod2){\\n                if(count[idx] > 0){\\n                    flag = true ;\\n                    count[idx]-- ; \\n                    break ;\\n                }\\n            }\\n            if(flag == false){\\n                int k = 2 ;\\n                for(auto& idx : mod1){\\n                    while(count[idx] > 0 && k > 0){\\n                        count[idx]-- ;\\n                        k-- ;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        for (int i = 9; i >= 0; i--)\\n            ret += string(count[i], \\'0\\' + i);\\n        \\n        if(ret.size() > 1 && ret[0] == \\'0\\')\\n            ret = \"0\" ;\\n        \\n        return ret ;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3364526,
                "title": "python-dp",
                "content": "```\\nclass Solution:\\n    def largestMultipleOfThree(self, d: List[int]) -> str:\\n        dp = [-1,-1,-1]\\n        for e in sorted(d, reverse=True):\\n            for a in dp+[0]:\\n                y = a * 10 + e\\n                dp[y%3] = max(dp[y%3], y)\\n        return str(dp[0]) if dp[0] >= 0 else \"\"\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def largestMultipleOfThree(self, d: List[int]) -> str:\\n        dp = [-1,-1,-1]\\n        for e in sorted(d, reverse=True):\\n            for a in dp+[0]:\\n                y = a * 10 + e\\n                dp[y%3] = max(dp[y%3], y)\\n        return str(dp[0]) if dp[0] >= 0 else \"\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3269225,
                "title": "simple-o-n-js-ts",
                "content": "# Complexity\\n- Time complexity: $O(n)$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $O(n)$ (for outputs, constant for others)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```typescript []\\n// see js version for short codes\\nfunction largestMultipleOfThree(digits: number[]): string {    \\n    // count the amount of each digits\\n    const arr = new Array(10).fill(0)\\n    for (const d of digits) arr[d]++\\n\\n    // a number is a multiple of 3 if the digits of it sum to a multiple of 3\\n    // proof sketch: \\'...cba\\' = ... + 100c + 10b + a = ... + 99c + 9b + (... + c + b + a)\\n    // so we calculate the sum of digits mod 3\\n    const t = arr.reduce((a, v, i) => a + v * (i % 3), 0) % 3\\n\\n    // try to delete a number x with x % 3 = n\\n    // and always try to delete the smallest first because we want the rest as big as possible\\n    // this returns 0 if and only if it fails to delete\\n    function sub (n: 1 | 2) {\\n        for (const i of [n, n+3, n+6])\\n            if (arr[i] > 0) return arr[i]--\\n        return 0\\n    }\\n\\n    if (t === 1) {\\n        // if the sum of digits mod 3 is 1, we can delete 1, 4, or 7\\n        // so that the rest digits sum to a multiple of 3\\n        if (sub(1) === 0) {\\n            // if we failed, we can still try to delete two of [2, 5, 8]\\n            // so that in total we delete 3x+1 from the sum and leave the rest sum to a multiple of 3\\n            // if we failed again, we can never make the sum of digits to a multiple of 3\\n            if (sub(2) === 0) return \\'\\'\\n            if (sub(2) === 0) return \\'\\'\\n        }\\n    }\\n    // the same logic applies when t = 2\\n    if (t === 2) {\\n        if (sub(2) === 0) {\\n            if (sub(1) === 0) return \\'\\'\\n            if (sub(1) === 0) return \\'\\'\\n        }\\n    }\\n\\n    // the largest combination is formed by placing larger digits in front\\n    const ans = arr.reduceRight((a, v, i) => a + String(i).repeat(v), \\'\\')\\n    // if ans starts with a leading 0, it is \\'0000...000\\' so we return \\'0\\'\\n    return ans[0] === \\'0\\' ? \\'0\\' : ans\\n};\\n```\\n```javascript []\\n/**\\n * @param {number[]} digits\\n * @return {string}\\n */\\nvar largestMultipleOfThree = function(digits) {\\n    const arr = new Array(10).fill(0)\\n    for (const d of digits) arr[d]++\\n    const t = arr.reduce((a, v, i) => a + v * (i % 3), 0) % 3\\n    function sub (n) {\\n        for (const i of [n, n+3, n+6])\\n            if (arr[i] > 0) return arr[i]--\\n    }\\n    if (t && !sub(t) && (!sub(3 - t) || !sub(3 - t))) return \\'\\' \\n    const ans = arr.reduceRight((a, v, i) => a + String(i).repeat(v), \\'\\')\\n    return ans[0] === \\'0\\' ? \\'0\\' : ans\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Math",
                    "Bucket Sort"
                ],
                "code": "```typescript []\\n// see js version for short codes\\nfunction largestMultipleOfThree(digits: number[]): string {    \\n    // count the amount of each digits\\n    const arr = new Array(10).fill(0)\\n    for (const d of digits) arr[d]++\\n\\n    // a number is a multiple of 3 if the digits of it sum to a multiple of 3\\n    // proof sketch: \\'...cba\\' = ... + 100c + 10b + a = ... + 99c + 9b + (... + c + b + a)\\n    // so we calculate the sum of digits mod 3\\n    const t = arr.reduce((a, v, i) => a + v * (i % 3), 0) % 3\\n\\n    // try to delete a number x with x % 3 = n\\n    // and always try to delete the smallest first because we want the rest as big as possible\\n    // this returns 0 if and only if it fails to delete\\n    function sub (n: 1 | 2) {\\n        for (const i of [n, n+3, n+6])\\n            if (arr[i] > 0) return arr[i]--\\n        return 0\\n    }\\n\\n    if (t === 1) {\\n        // if the sum of digits mod 3 is 1, we can delete 1, 4, or 7\\n        // so that the rest digits sum to a multiple of 3\\n        if (sub(1) === 0) {\\n            // if we failed, we can still try to delete two of [2, 5, 8]\\n            // so that in total we delete 3x+1 from the sum and leave the rest sum to a multiple of 3\\n            // if we failed again, we can never make the sum of digits to a multiple of 3\\n            if (sub(2) === 0) return \\'\\'\\n            if (sub(2) === 0) return \\'\\'\\n        }\\n    }\\n    // the same logic applies when t = 2\\n    if (t === 2) {\\n        if (sub(2) === 0) {\\n            if (sub(1) === 0) return \\'\\'\\n            if (sub(1) === 0) return \\'\\'\\n        }\\n    }\\n\\n    // the largest combination is formed by placing larger digits in front\\n    const ans = arr.reduceRight((a, v, i) => a + String(i).repeat(v), \\'\\')\\n    // if ans starts with a leading 0, it is \\'0000...000\\' so we return \\'0\\'\\n    return ans[0] === \\'0\\' ? \\'0\\' : ans\\n};\\n```\n```javascript []\\n/**\\n * @param {number[]} digits\\n * @return {string}\\n */\\nvar largestMultipleOfThree = function(digits) {\\n    const arr = new Array(10).fill(0)\\n    for (const d of digits) arr[d]++\\n    const t = arr.reduce((a, v, i) => a + v * (i % 3), 0) % 3\\n    function sub (n) {\\n        for (const i of [n, n+3, n+6])\\n            if (arr[i] > 0) return arr[i]--\\n    }\\n    if (t && !sub(t) && (!sub(3 - t) || !sub(3 - t))) return \\'\\' \\n    const ans = arr.reduceRight((a, v, i) => a + String(i).repeat(v), \\'\\')\\n    return ans[0] === \\'0\\' ? \\'0\\' : ans\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3244618,
                "title": "simplest-approach-with-analysis",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nhttps://www.youtube.com/watch?v=wDfs3yfhleU\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string largestMultipleOfThree(vector<int>& digits) {\\n        string res = \"\";\\n        int m1[] = { 1,4,7,2,5,8 };\\n        int m2[] = { 2,5,8,1,4,7 };\\n\\n        int sum = 0;\\n\\n        // this array is going to hold the digit count  \\n        // 0 ~ 9\\n        int ds[10] = {0};\\n\\n        for (auto d : digits) {\\n            ds[d]++;\\n            sum += d;\\n        }\\n\\n        while (sum % 3 != 0) {\\n            for (auto i : sum % 3 == 1 ? m1 : m2) {\\n                if (ds[i]) {\\n                    --ds[i];\\n                    sum -= i;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        for (int i = 9; i >= 0; --i) {\\n            res += string(ds[i], (\\'0\\' + i));\\n        }\\n\\n        return res.size() && res[0] == \\'0\\' ? \"0\" : res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestMultipleOfThree(vector<int>& digits) {\\n        string res = \"\";\\n        int m1[] = { 1,4,7,2,5,8 };\\n        int m2[] = { 2,5,8,1,4,7 };\\n\\n        int sum = 0;\\n\\n        // this array is going to hold the digit count  \\n        // 0 ~ 9\\n        int ds[10] = {0};\\n\\n        for (auto d : digits) {\\n            ds[d]++;\\n            sum += d;\\n        }\\n\\n        while (sum % 3 != 0) {\\n            for (auto i : sum % 3 == 1 ? m1 : m2) {\\n                if (ds[i]) {\\n                    --ds[i];\\n                    sum -= i;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        for (int i = 9; i >= 0; --i) {\\n            res += string(ds[i], (\\'0\\' + i));\\n        }\\n\\n        return res.size() && res[0] == \\'0\\' ? \"0\" : res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3103997,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn largest_multiple_of_three(digits: Vec<i32>) -> String {\\n        let mut bucket: [usize; 10] = [0; 10];\\n        let mut res: Vec<i32> = Vec::new();\\n        for d in digits.iter() {\\n            bucket[*d as usize] += 1;\\n        }\\n        let (mut cnt_g1, mut cnt_g2) = (0_usize, 0_usize);\\n        for i in 0..10 {\\n            if i == 0 || i == 3 || i == 6 || i == 9 {\\n                for _ in 0..bucket[i as usize] {\\n                    res.push(i);\\n                }\\n                bucket[i as usize] = 0;\\n            } else if i == 1 || i == 4 || i == 7 {\\n                cnt_g1 += bucket[i as usize];\\n            } else {\\n                cnt_g2 += bucket[i as usize];\\n            }\\n        }\\n        if cnt_g1 % 3 == cnt_g2 % 3 {\\n            let mut fin_res = digits;\\n            fin_res.sort_by(|a, b| b.cmp(a));\\n            if fin_res[0] == 0 {\\n                return String::from(\"0\");\\n            }\\n            return fin_res\\n                .iter()\\n                .map(|a| ((*a + \\'0\\' as i32) as u8) as char)\\n                .collect::<String>();\\n        }\\n        if cnt_g1 > 0 && cnt_g1 % 3 == 0 && cnt_g2 % 3 == 2 {\\n            for _ in 0..(cnt_g1 - 1) {\\n                if bucket[7] > 0 {\\n                    res.push(7);\\n                    bucket[7] -= 1;\\n                } else if bucket[4] > 0 {\\n                    res.push(4);\\n                    bucket[4] -= 1;\\n                } else if bucket[1] > 0 {\\n                    res.push(1);\\n                    bucket[1] -= 1;\\n                }\\n            }\\n            for _ in 0..(cnt_g2) {\\n                if bucket[8] > 0 {\\n                    res.push(8);\\n                    bucket[8] -= 1;\\n                } else if bucket[5] > 0 {\\n                    res.push(5);\\n                    bucket[5] -= 1;\\n                } else if bucket[2] > 0 {\\n                    res.push(2);\\n                    bucket[2] -= 1;\\n                }\\n            }\\n        } else if cnt_g2 > 0 && cnt_g2 % 3 == 0 && cnt_g1 % 3 == 2 {\\n            for _ in 0..(cnt_g2 - 1) {\\n                if bucket[8] > 0 {\\n                    res.push(8);\\n                    bucket[8] -= 1;\\n                } else if bucket[5] > 0 {\\n                    res.push(5);\\n                    bucket[5] -= 1;\\n                } else if bucket[2] > 0 {\\n                    res.push(2);\\n                    bucket[2] -= 1;\\n                }\\n            }\\n            for _ in 0..(cnt_g1) {\\n                if bucket[7] > 0 {\\n                    res.push(7);\\n                    bucket[7] -= 1;\\n                } else if bucket[4] > 0 {\\n                    res.push(4);\\n                    bucket[4] -= 1;\\n                } else if bucket[1] > 0 {\\n                    res.push(1);\\n                    bucket[1] -= 1;\\n                }\\n            }\\n        } else {\\n            for _ in 0..(cnt_g1 - cnt_g1 % 3) {\\n                if bucket[7] > 0 {\\n                    res.push(7);\\n                    bucket[7] -= 1;\\n                } else if bucket[4] > 0 {\\n                    res.push(4);\\n                    bucket[4] -= 1;\\n                } else if bucket[1] > 0 {\\n                    res.push(1);\\n                    bucket[1] -= 1;\\n                }\\n            }\\n            cnt_g1 %= 3;\\n            for _ in 0..(cnt_g2 - cnt_g2 % 3) {\\n                if bucket[8] > 0 {\\n                    res.push(8);\\n                    bucket[8] -= 1;\\n                } else if bucket[5] > 0 {\\n                    res.push(5);\\n                    bucket[5] -= 1;\\n                } else if bucket[2] > 0 {\\n                    res.push(2);\\n                    bucket[2] -= 1;\\n                }\\n            }\\n            cnt_g2 %= 3;\\n            if cnt_g1 + cnt_g2 == 3 {\\n                if bucket[7] > 0 {\\n                    res.push(7);\\n                    bucket[7] -= 1;\\n                } else if bucket[4] > 0 {\\n                    res.push(4);\\n                    bucket[4] -= 1;\\n                } else if bucket[1] > 0 {\\n                    res.push(1);\\n                    bucket[1] -= 1;\\n                }\\n                if bucket[8] > 0 {\\n                    res.push(8);\\n                    bucket[8] -= 1;\\n                } else if bucket[5] > 0 {\\n                    res.push(5);\\n                    bucket[5] -= 1;\\n                } else if bucket[2] > 0 {\\n                    res.push(2);\\n                    bucket[2] -= 1;\\n                }\\n            }\\n        }\\n        res.sort_by(|a, b| b.cmp(a));\\n        if let Some(&v) = res.first() {\\n            if v == 0 {\\n                return String::from(\"0\");\\n            }\\n        }\\n        res.iter()\\n            .map(|a| ((*a + \\'0\\' as i32) as u8) as char)\\n            .collect::<String>()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn largest_multiple_of_three(digits: Vec<i32>) -> String {\\n        let mut bucket: [usize; 10] = [0; 10];\\n        let mut res: Vec<i32> = Vec::new();\\n        for d in digits.iter() {\\n            bucket[*d as usize] += 1;\\n        }\\n        let (mut cnt_g1, mut cnt_g2) = (0_usize, 0_usize);\\n        for i in 0..10 {\\n            if i == 0 || i == 3 || i == 6 || i == 9 {\\n                for _ in 0..bucket[i as usize] {\\n                    res.push(i);\\n                }\\n                bucket[i as usize] = 0;\\n            } else if i == 1 || i == 4 || i == 7 {\\n                cnt_g1 += bucket[i as usize];\\n            } else {\\n                cnt_g2 += bucket[i as usize];\\n            }\\n        }\\n        if cnt_g1 % 3 == cnt_g2 % 3 {\\n            let mut fin_res = digits;\\n            fin_res.sort_by(|a, b| b.cmp(a));\\n            if fin_res[0] == 0 {\\n                return String::from(\"0\");\\n            }\\n            return fin_res\\n                .iter()\\n                .map(|a| ((*a + \\'0\\' as i32) as u8) as char)\\n                .collect::<String>();\\n        }\\n        if cnt_g1 > 0 && cnt_g1 % 3 == 0 && cnt_g2 % 3 == 2 {\\n            for _ in 0..(cnt_g1 - 1) {\\n                if bucket[7] > 0 {\\n                    res.push(7);\\n                    bucket[7] -= 1;\\n                } else if bucket[4] > 0 {\\n                    res.push(4);\\n                    bucket[4] -= 1;\\n                } else if bucket[1] > 0 {\\n                    res.push(1);\\n                    bucket[1] -= 1;\\n                }\\n            }\\n            for _ in 0..(cnt_g2) {\\n                if bucket[8] > 0 {\\n                    res.push(8);\\n                    bucket[8] -= 1;\\n                } else if bucket[5] > 0 {\\n                    res.push(5);\\n                    bucket[5] -= 1;\\n                } else if bucket[2] > 0 {\\n                    res.push(2);\\n                    bucket[2] -= 1;\\n                }\\n            }\\n        } else if cnt_g2 > 0 && cnt_g2 % 3 == 0 && cnt_g1 % 3 == 2 {\\n            for _ in 0..(cnt_g2 - 1) {\\n                if bucket[8] > 0 {\\n                    res.push(8);\\n                    bucket[8] -= 1;\\n                } else if bucket[5] > 0 {\\n                    res.push(5);\\n                    bucket[5] -= 1;\\n                } else if bucket[2] > 0 {\\n                    res.push(2);\\n                    bucket[2] -= 1;\\n                }\\n            }\\n            for _ in 0..(cnt_g1) {\\n                if bucket[7] > 0 {\\n                    res.push(7);\\n                    bucket[7] -= 1;\\n                } else if bucket[4] > 0 {\\n                    res.push(4);\\n                    bucket[4] -= 1;\\n                } else if bucket[1] > 0 {\\n                    res.push(1);\\n                    bucket[1] -= 1;\\n                }\\n            }\\n        } else {\\n            for _ in 0..(cnt_g1 - cnt_g1 % 3) {\\n                if bucket[7] > 0 {\\n                    res.push(7);\\n                    bucket[7] -= 1;\\n                } else if bucket[4] > 0 {\\n                    res.push(4);\\n                    bucket[4] -= 1;\\n                } else if bucket[1] > 0 {\\n                    res.push(1);\\n                    bucket[1] -= 1;\\n                }\\n            }\\n            cnt_g1 %= 3;\\n            for _ in 0..(cnt_g2 - cnt_g2 % 3) {\\n                if bucket[8] > 0 {\\n                    res.push(8);\\n                    bucket[8] -= 1;\\n                } else if bucket[5] > 0 {\\n                    res.push(5);\\n                    bucket[5] -= 1;\\n                } else if bucket[2] > 0 {\\n                    res.push(2);\\n                    bucket[2] -= 1;\\n                }\\n            }\\n            cnt_g2 %= 3;\\n            if cnt_g1 + cnt_g2 == 3 {\\n                if bucket[7] > 0 {\\n                    res.push(7);\\n                    bucket[7] -= 1;\\n                } else if bucket[4] > 0 {\\n                    res.push(4);\\n                    bucket[4] -= 1;\\n                } else if bucket[1] > 0 {\\n                    res.push(1);\\n                    bucket[1] -= 1;\\n                }\\n                if bucket[8] > 0 {\\n                    res.push(8);\\n                    bucket[8] -= 1;\\n                } else if bucket[5] > 0 {\\n                    res.push(5);\\n                    bucket[5] -= 1;\\n                } else if bucket[2] > 0 {\\n                    res.push(2);\\n                    bucket[2] -= 1;\\n                }\\n            }\\n        }\\n        res.sort_by(|a, b| b.cmp(a));\\n        if let Some(&v) = res.first() {\\n            if v == 0 {\\n                return String::from(\"0\");\\n            }\\n        }\\n        res.iter()\\n            .map(|a| ((*a + \\'0\\' as i32) as u8) as char)\\n            .collect::<String>()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3098708,
                "title": "c-greedy-basic-maths-for-modulus-great-question",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string largestMultipleOfThree(vector<int>& digits) {\\n        vector<pair<int, int>> A[3];\\n        int n = digits.size();\\n        int sum = 0;\\n        sort(digits.rbegin(), digits.rend());\\n        for(int i = 0; i < n; i++) {\\n            int d = digits[i];\\n            sum += d;\\n            A[d % 3].push_back({d, i});\\n        }\\n        for(int i = 0; i < 3; i++) {\\n            sort(A[i].begin(), A[i].end());\\n        }\\n        vector<bool> flag(n, true);\\n        int r = sum % 3;\\n        if(r > 0) {\\n            if(A[r].size() >= 1) {\\n                flag[A[r][0].second] = false;\\n            } else if(A[3 - r].size() >= 2) {\\n                flag[A[3 - r][0].second] = false;\\n                flag[A[3 - r][1].second] = false; \\n            } else {\\n                return \"\";\\n            }\\n        }\\n        string ans = \"\";\\n        for(int i = 0; i < n; i++) {\\n            if(!flag[i]) {\\n                continue;\\n            } else {\\n                ans += \\'0\\' + digits[i];\\n            }\\n        }\\n        int idx = 0;\\n        while(idx < ans.size() - 1 && ans[idx] == \\'0\\') {\\n            idx++;\\n        }\\n        return ans.substr(idx);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestMultipleOfThree(vector<int>& digits) {\\n        vector<pair<int, int>> A[3];\\n        int n = digits.size();\\n        int sum = 0;\\n        sort(digits.rbegin(), digits.rend());\\n        for(int i = 0; i < n; i++) {\\n            int d = digits[i];\\n            sum += d;\\n            A[d % 3].push_back({d, i});\\n        }\\n        for(int i = 0; i < 3; i++) {\\n            sort(A[i].begin(), A[i].end());\\n        }\\n        vector<bool> flag(n, true);\\n        int r = sum % 3;\\n        if(r > 0) {\\n            if(A[r].size() >= 1) {\\n                flag[A[r][0].second] = false;\\n            } else if(A[3 - r].size() >= 2) {\\n                flag[A[3 - r][0].second] = false;\\n                flag[A[3 - r][1].second] = false; \\n            } else {\\n                return \"\";\\n            }\\n        }\\n        string ans = \"\";\\n        for(int i = 0; i < n; i++) {\\n            if(!flag[i]) {\\n                continue;\\n            } else {\\n                ans += \\'0\\' + digits[i];\\n            }\\n        }\\n        int idx = 0;\\n        while(idx < ans.size() - 1 && ans[idx] == \\'0\\') {\\n            idx++;\\n        }\\n        return ans.substr(idx);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3067421,
                "title": "c-easy-to-understand-simple-greedy-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    string largestMultipleOfThree(vector<int>& digits) {\\n        map<int,vector<int>> mp;\\n        int sum=0;\\n        for(auto &x:digits)\\n        {\\n            mp[x%3].push_back(x);\\n            sum=(sum%3+(x%3))%3;\\n        }\\n\\n        for(auto &pr:mp)\\n        {\\n            sort(pr.second.begin(),pr.second.end(),greater<int>());\\n        }\\n        if(sum==1)\\n        {\\n            if(mp[1].size()>0)\\n            mp[1].pop_back();\\n            else\\n            {\\n                mp[2].pop_back();\\n                mp[2].pop_back();\\n            }\\n        }\\n        else if(sum==2)\\n        {\\n            if(mp[2].size()>0)\\n            mp[2].pop_back();\\n            else\\n            {\\n                mp[1].pop_back();\\n                mp[1].pop_back();\\n            }\\n        }\\n        string ans=\"\";\\n        for(int i=0;i<=2;i++)\\n        {\\n            for(auto &x:mp[i])\\n            {\\n                ans+=to_string(x);\\n            }\\n        }\\n        sort(ans.begin(),ans.end(),greater<int>());\\n        if(ans[0]==\\'0\\')\\n        return \"0\";\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestMultipleOfThree(vector<int>& digits) {\\n        map<int,vector<int>> mp;\\n        int sum=0;\\n        for(auto &x:digits)\\n        {\\n            mp[x%3].push_back(x);\\n            sum=(sum%3+(x%3))%3;\\n        }\\n\\n        for(auto &pr:mp)\\n        {\\n            sort(pr.second.begin(),pr.second.end(),greater<int>());\\n        }\\n        if(sum==1)\\n        {\\n            if(mp[1].size()>0)\\n            mp[1].pop_back();\\n            else\\n            {\\n                mp[2].pop_back();\\n                mp[2].pop_back();\\n            }\\n        }\\n        else if(sum==2)\\n        {\\n            if(mp[2].size()>0)\\n            mp[2].pop_back();\\n            else\\n            {\\n                mp[1].pop_back();\\n                mp[1].pop_back();\\n            }\\n        }\\n        string ans=\"\";\\n        for(int i=0;i<=2;i++)\\n        {\\n            for(auto &x:mp[i])\\n            {\\n                ans+=to_string(x);\\n            }\\n        }\\n        sort(ans.begin(),ans.end(),greater<int>());\\n        if(ans[0]==\\'0\\')\\n        return \"0\";\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3036260,
                "title": "dp-with-memoization-python-o-n-tc",
                "content": "# Approach\\nWe first sort digits decreaingly to be sure that we are making the largest number possible as we iterate through.\\nWe use recursive dp with memoization. Suppose ```dfs(index, rem)``` returns the maximum number that can be attained with digits with indices greater than ```index``` (```index+1, index+2, ..., n```) with a remainder of ```rem``` to 3. So our dp recursive relation has 2 cases, if we take the current digit, or if skip it to next, therefore our recursive dp relation would be:\\n\\n```dfs(index, rem) = max(dfs(index + 1, rem), dfs(index + 1, (rem - digits[index + 1]) %  3))```\\n\\nThats the whole idea. The only problem here would be we can not keep the whole created number as string for memoization, because it would consume ```O(n ^ 2)``` memory and will TimeLimitExceed if not getting MemoryLimit !! \\nSo the workaround is to return 2 values for our recursive funcion: ```(max_length, next_digit_index)```, the ```max_length``` is the length of maximum number that can be attained as we described, ```next_digit_index``` is the index of next digit to be used to get this maximum number\\n```\\nfrom typing import List\\n\\n\\nclass Solution:\\n    def largestMultipleOfThree(self, digits: List[int]) -> str:\\n        n = len(digits)\\n        digits.sort(reverse=True)\\n        memo = dict()\\n\\n        def dfs(index, rem):\\n            if index == n - 1:\\n                if rem == 0:\\n                    return 0, n\\n                return -1, n\\n\\n            if (index, rem) in memo:\\n                return memo[(index, rem)]\\n\\n            memo[(index, rem)] = (-1, \\'\\')\\n            max_len1, next_idx1 = dfs(index + 1, (rem - digits[index + 1]) % 3)\\n            max_len2, next_idx2 = dfs(index + 1,  rem)\\n\\n            if max_len1 != -1:\\n                memo[(index, rem)] = (1 + max_len1, index + 1)\\n\\n            if max_len2 != -1 and max_len2 > memo[(index, rem)][0]:\\n                memo[(index, rem)] = (max_len2, next_idx2)\\n            return memo[(index, rem)]\\n\\n        l, idx = dfs(-1, 0)\\n        rem = 0\\n        ans = \\'\\'\\n\\n        while l > 0:\\n            ans += str(digits[idx])\\n            rem = (rem - digits[idx]) % 3\\n            l, idx = dfs(idx, rem)\\n        return \\'\\' if ans == \\'\\' else \\'0\\' if all(d == \\'0\\' for d in ans) else ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```dfs(index, rem)```\n```index```\n```index+1, index+2, ..., n```\n```rem```\n```dfs(index, rem) = max(dfs(index + 1, rem), dfs(index + 1, (rem - digits[index + 1]) %  3))```\n```O(n ^ 2)```\n```(max_length, next_digit_index)```\n```max_length```\n```next_digit_index```\n```\\nfrom typing import List\\n\\n\\nclass Solution:\\n    def largestMultipleOfThree(self, digits: List[int]) -> str:\\n        n = len(digits)\\n        digits.sort(reverse=True)\\n        memo = dict()\\n\\n        def dfs(index, rem):\\n            if index == n - 1:\\n                if rem == 0:\\n                    return 0, n\\n                return -1, n\\n\\n            if (index, rem) in memo:\\n                return memo[(index, rem)]\\n\\n            memo[(index, rem)] = (-1, \\'\\')\\n            max_len1, next_idx1 = dfs(index + 1, (rem - digits[index + 1]) % 3)\\n            max_len2, next_idx2 = dfs(index + 1,  rem)\\n\\n            if max_len1 != -1:\\n                memo[(index, rem)] = (1 + max_len1, index + 1)\\n\\n            if max_len2 != -1 and max_len2 > memo[(index, rem)][0]:\\n                memo[(index, rem)] = (max_len2, next_idx2)\\n            return memo[(index, rem)]\\n\\n        l, idx = dfs(-1, 0)\\n        rem = 0\\n        ans = \\'\\'\\n\\n        while l > 0:\\n            ans += str(digits[idx])\\n            rem = (rem - digits[idx]) % 3\\n            l, idx = dfs(idx, rem)\\n        return \\'\\' if ans == \\'\\' else \\'0\\' if all(d == \\'0\\' for d in ans) else ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3024397,
                "title": "easy-c-solution-and-explanation",
                "content": "# Intuition\\n- It sorts the input digits in non-descending order.\\n- It initializes three queues, one for each possible remainder when dividing by 3 (0, 1, and 2). It also initializes a string to store the number formed by the digits and a variable to store the sum of the digits.\\n- It iterates through the digits and adds each digit to the queue corresponding to its remainder when divided by 3. It also updates the sum of the digits.\\n- If the sum of the digits is divisible by 3, it reverses the number string and returns it.\\n- If the sum is not divisible by 3, it removes a digit from the queue corresponding to the remainder of the sum when divided by 3 (if such a queue is non-empty). If the remainder is 1 or 2 and the corresponding queue is empty, it removes two digits from the next non-empty queue (either 1 and 2 or 0 and 2).\\n- It puts the remaining digits from the three queues into a vector and sorts the vector in descending order so to get the larger values first.\\n- It concatenates the digits(larger digits first) from the vector into a string and returns it. \\n- Finally an Edge case - If the first digit of the string is 0, that means the number is 0 (ex. \"00000\") it returns \"0\" instead (since leading zeros are not allowed).\\n\\n# Complexity\\n- Time complexity: O(nLogn) --> for sorting\\n\\n- Space complexity: O(n) --> for queue\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string largestMultipleOfThree(vector<int>& digits) {\\n        sort(digits.begin(), digits.end());\\n        vector<queue<int>> q(3);\\n        int sum = 0,i = 0;\\n        string number = \"\", ans = \"\";\\n        for(int i = 0; i < digits.size();i++){\\n            number += to_string(digits[i]);\\n            sum += digits[i];\\n            q[digits[i] % 3].push(digits[i]);\\n        }\\n        if(sum == 0) return \"0\";\\n        if(sum % 3 == 0){\\n            int i = 0, j = number.length()-1;\\n            while(i < j) swap(number[i++], number[j--]);\\n            return number;\\n        }else if(!q[sum % 3].empty()) q[sum % 3].pop();\\n        else{\\n            int idx = sum % 3 == 1 ? 2 : 1;\\n            if(q[idx].size() < 2) return \"\";\\n            q[idx].pop();q[idx].pop();\\n        }\\n        vector<int> temp;\\n        while(i < 3){\\n            if(!q[i].empty()){\\n                temp.push_back(q[i].front());\\n                q[i].pop();\\n            }else i++;\\n        }\\n        sort(temp.begin(), temp.end(), greater<int>());\\n        for(auto x: temp) ans += to_string(x);\\n        return ans[0] == \\'0\\' ? \"0\" : ans;\\n    }\\n};\\n```\\n# Upvote if liked",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestMultipleOfThree(vector<int>& digits) {\\n        sort(digits.begin(), digits.end());\\n        vector<queue<int>> q(3);\\n        int sum = 0,i = 0;\\n        string number = \"\", ans = \"\";\\n        for(int i = 0; i < digits.size();i++){\\n            number += to_string(digits[i]);\\n            sum += digits[i];\\n            q[digits[i] % 3].push(digits[i]);\\n        }\\n        if(sum == 0) return \"0\";\\n        if(sum % 3 == 0){\\n            int i = 0, j = number.length()-1;\\n            while(i < j) swap(number[i++], number[j--]);\\n            return number;\\n        }else if(!q[sum % 3].empty()) q[sum % 3].pop();\\n        else{\\n            int idx = sum % 3 == 1 ? 2 : 1;\\n            if(q[idx].size() < 2) return \"\";\\n            q[idx].pop();q[idx].pop();\\n        }\\n        vector<int> temp;\\n        while(i < 3){\\n            if(!q[i].empty()){\\n                temp.push_back(q[i].front());\\n                q[i].pop();\\n            }else i++;\\n        }\\n        sort(temp.begin(), temp.end(), greater<int>());\\n        for(auto x: temp) ans += to_string(x);\\n        return ans[0] == \\'0\\' ? \"0\" : ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3019339,
                "title": "python-solution-in-o-n-using-mod-operator",
                "content": "# Code\\n```\\nclass Solution:\\n    def largestMultipleOfThree(self, digits: List[int]) -> str:\\n        d=[[],[],[]]\\n        digits.sort(reverse=True)\\n        for item in digits:\\n            d[item%3].append(item)\\n        take=d[0][::]\\n        if(len(d[1])>=len(d[2])):\\n            i=0\\n            while(i<len(d[2])):\\n                take.append(d[1][i])\\n                take.append(d[2][i])\\n                i+=1\\n            if((len(d[1])-i)%3==2):\\n                if(len(d[2])!=0):\\n                    take.pop()\\n                    take.extend([d[1][-1],d[1][-2]])\\n            for i in range(i,len(d[1]),3):\\n                if(i+2<len(d[1])):\\n                    take.append(d[1][i])\\n                    take.append(d[1][i+1])\\n                    take.append(d[1][i+2])\\n        else:\\n            i=0\\n            while(i<len(d[1])):\\n                take.append(d[2][i])\\n                take.append(d[1][i])\\n                i+=1\\n            if((len(d[2])-i)%3==2):\\n                if(len(d[1])!=0):\\n                    take.pop()\\n                    take.extend([d[2][-1],d[2][-2]])\\n            for i in range(i,len(d[2]),3):\\n                if(i+2<len(d[2])):\\n                    take.append(d[2][i])\\n                    take.append(d[2][i+1])\\n                    take.append(d[2][i+2])\\n        take.sort(reverse=True)\\n        if(len(take)==0):return \"\"\\n        elif(take[0]==0):return \"0\"\\n        return \"\".join(map(str,take))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def largestMultipleOfThree(self, digits: List[int]) -> str:\\n        d=[[],[],[]]\\n        digits.sort(reverse=True)\\n        for item in digits:\\n            d[item%3].append(item)\\n        take=d[0][::]\\n        if(len(d[1])>=len(d[2])):\\n            i=0\\n            while(i<len(d[2])):\\n                take.append(d[1][i])\\n                take.append(d[2][i])\\n                i+=1\\n            if((len(d[1])-i)%3==2):\\n                if(len(d[2])!=0):\\n                    take.pop()\\n                    take.extend([d[1][-1],d[1][-2]])\\n            for i in range(i,len(d[1]),3):\\n                if(i+2<len(d[1])):\\n                    take.append(d[1][i])\\n                    take.append(d[1][i+1])\\n                    take.append(d[1][i+2])\\n        else:\\n            i=0\\n            while(i<len(d[1])):\\n                take.append(d[2][i])\\n                take.append(d[1][i])\\n                i+=1\\n            if((len(d[2])-i)%3==2):\\n                if(len(d[1])!=0):\\n                    take.pop()\\n                    take.extend([d[2][-1],d[2][-2]])\\n            for i in range(i,len(d[2]),3):\\n                if(i+2<len(d[2])):\\n                    take.append(d[2][i])\\n                    take.append(d[2][i+1])\\n                    take.append(d[2][i+2])\\n        take.sort(reverse=True)\\n        if(len(take)==0):return \"\"\\n        elif(take[0]==0):return \"0\"\\n        return \"\".join(map(str,take))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2974770,
                "title": "python-o-n-solution-counter-and-minheap",
                "content": "Inspired [**this solution by serdes**](https://leetcode.com/problems/largest-multiple-of-three/discuss/522774/python3-solution)\\nI have the following implementation, and time is optimzed from O(NlogN) to O(N) \\n\\n```\\ndef largestMultipleOfThree(self, digits: List[int]) -> str:\\n\\ts, nums = sum(digits), Counter(digits)\\n\\n\\tones = [x for x in digits if x%3==1]\\n\\ttwos = [x for x in digits if x%3==2]\\n\\theapify(ones)\\n\\theapify(twos)\\n\\n\\tif s%3==1:\\n\\t\\tif ones:\\n\\t\\t\\tnums[heappop(ones)] -= 1\\n\\t\\telse:\\n\\t\\t\\tnums[heappop(twos)] -= 1\\n\\t\\t\\tnums[heappop(twos)] -= 1\\n\\telif s%3==2:\\n\\t\\tif twos:\\n\\t\\t\\tnums[heappop(twos)] -= 1\\n\\t\\telse:\\n\\t\\t\\tnums[heappop(ones)] -= 1\\n\\t\\t\\tnums[heappop(ones)] -= 1\\n\\tif nums.total()==0:\\n\\t\\treturn \\'\\'\\n\\treturn \\'\\'.join([str(i)*nums[i] for i in range(9, -1, -1)]).lstrip(\"0\") or \\'0\\'\\n```",
                "solutionTags": [],
                "code": "```\\ndef largestMultipleOfThree(self, digits: List[int]) -> str:\\n\\ts, nums = sum(digits), Counter(digits)\\n\\n\\tones = [x for x in digits if x%3==1]\\n\\ttwos = [x for x in digits if x%3==2]\\n\\theapify(ones)\\n\\theapify(twos)\\n\\n\\tif s%3==1:\\n\\t\\tif ones:\\n\\t\\t\\tnums[heappop(ones)] -= 1\\n\\t\\telse:\\n\\t\\t\\tnums[heappop(twos)] -= 1\\n\\t\\t\\tnums[heappop(twos)] -= 1\\n\\telif s%3==2:\\n\\t\\tif twos:\\n\\t\\t\\tnums[heappop(twos)] -= 1\\n\\t\\telse:\\n\\t\\t\\tnums[heappop(ones)] -= 1\\n\\t\\t\\tnums[heappop(ones)] -= 1\\n\\tif nums.total()==0:\\n\\t\\treturn \\'\\'\\n\\treturn \\'\\'.join([str(i)*nums[i] for i in range(9, -1, -1)]).lstrip(\"0\") or \\'0\\'\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2942779,
                "title": "js",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\n/**\\n * @param {number[]} digits\\n * @return {string}\\n */\\nconst lodash = require(\\'lodash\\')\\n\\nvar largestMultipleOfThree = function(digits) {\\n    const dictionary = Object.freeze(new Map(Object.entries(lodash.groupBy(digits, _ => _ % 3)).map(([key, value]) => [Number(key), value.sort((a, b) => a - b)])))\\n    const d1 = Object.freeze(dictionary.has(1) ? dictionary.get(1) : [])\\n    const d2 = Object.freeze(dictionary.has(2) ? dictionary.get(2) : [])\\n    const d0 = Object.freeze(dictionary.has(0) ? dictionary.get(0) : [])\\n    let result = null\\n    switch (digits.reduce((a, b) => a + b) % 3)\\n    {\\n        case 1: result = d1.length ? [...d1.slice(1), ...d2, ...d0] : [...d2.slice(2), ...d0]; break\\n        case 2: result = d2.length ? [...d1, ...d2.slice(1), ...d0] : [...d1.slice(2), ...d0]; break\\n        default: result = digits\\n    }\\n    result = result.sort((a, b) => b - a).join(\\'\\')\\n    return result ? BigInt(result).toString() : \\'\\'\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\n/**\\n * @param {number[]} digits\\n * @return {string}\\n */\\nconst lodash = require(\\'lodash\\')\\n\\nvar largestMultipleOfThree = function(digits) {\\n    const dictionary = Object.freeze(new Map(Object.entries(lodash.groupBy(digits, _ => _ % 3)).map(([key, value]) => [Number(key), value.sort((a, b) => a - b)])))\\n    const d1 = Object.freeze(dictionary.has(1) ? dictionary.get(1) : [])\\n    const d2 = Object.freeze(dictionary.has(2) ? dictionary.get(2) : [])\\n    const d0 = Object.freeze(dictionary.has(0) ? dictionary.get(0) : [])\\n    let result = null\\n    switch (digits.reduce((a, b) => a + b) % 3)\\n    {\\n        case 1: result = d1.length ? [...d1.slice(1), ...d2, ...d0] : [...d2.slice(2), ...d0]; break\\n        case 2: result = d2.length ? [...d1, ...d2.slice(1), ...d0] : [...d1.slice(2), ...d0]; break\\n        default: result = digits\\n    }\\n    result = result.sort((a, b) => b - a).join(\\'\\')\\n    return result ? BigInt(result).toString() : \\'\\'\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2911245,
                "title": "java-o-n-beats-90-of-solution-space-and-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirst note that we can reduce the problem by working on the histogram instead of the raw input. We can then run DP by having two variables for subproblems: one for for the digits 1 to n and another for the combination a * 1 + b * 2 + ... + i * d, which is a number in O(n) (the sum of all digits is upper bounded by 9 * n). Hence O(n) subproblems. The DP algorithm then guesses a multiple for each digit and as there are O(n) multiples this results in an O(n^2) algorithm.\\n\\nHowever we can optimize if we see that (a * 1 + b * 2 + ... + i * 9) % 3 has only 3 possible values, or \"classes\". As we want to be greedy we only consider the 3 maximum multiples for each of the three classes. So we optimized the DP to O(1)  \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n), the time to read the input and build the histogram\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1), the size of the dp table (3 * 10)\\n# Code\\n```\\nimport java.util.Arrays;\\n\\nclass Solution {\\n\\n    /*\\n    Wrapper for an int[]. We exploit the reference to keep track of what subproblem has been solved \\n     */\\n    private static class Histogram {\\n        int[] A;\\n\\n        public Histogram() {\\n            this(new int[10]);\\n        }\\n        \\n        private Histogram(int[] a) {\\n            A = a;\\n        }\\n\\n        public Histogram clone() {\\n            return new Histogram(A.clone());\\n        }\\n\\n        public String toString() {\\n            return Arrays.toString(A);\\n        }\\n    }\\n\\n    public String largestMultipleOfThree(int[] digits) {\\n        digitsHist = new int[10];\\n        for (int d : digits) { // transform the array representation to histogram\\n            ++digitsHist[d];\\n        }\\n        memo = new Histogram[10][3];\\n        Histogram hist = solve(0, 0);\\n        if (hist == fail) {\\n            return \"\";\\n        }\\n        StringBuilder sb = new StringBuilder(digits.length);\\n        for (int i = 9; i > 0; --i) { // transform the digits 9-1 from the histogram to String\\n            for (int j = 0; j < hist.A[i]; ++j) {\\n                sb.append(i);\\n            }\\n        }\\n        if (sb.length() == 0) { // transform the digit 0 from the histogram to String\\n            if (hist.A[0] == 0) { // empty subsets of the input are not allowed\\n                return \"\";\\n            }\\n            // ignore leading zeros\\n            sb.append(0);\\n        } else {\\n            // no leading zeros, add all of them\\n            for (int j = 0; j < hist.A[0]; ++j) {\\n                sb.append(0);\\n            }\\n        }\\n        return sb.toString();\\n    }\\n\\n    int[] digitsHist; // the input, doesn\\'t need to be wrapped in a Histogram \\n    Histogram[][] memo;\\n    Histogram base = new Histogram(), fail = new Histogram(); // base / fail distinction is necessary for class 0 subproblems\\n\\n    private Histogram solve(int d, int c) {\\n        if (d > 9) {\\n            return c == 0 ? base : fail;\\n        }\\n        if (memo[d][c] != null) {\\n            return memo[d][c];\\n        }\\n        // guess 0: assume we took as many digits d to make a class 0 multiple\\n        Histogram ans = solve(d + 1, c);\\n        int dclass = d % 3;\\n        if (dclass == 0) { // if d is a class 0 digit, no matter how many we take we always make a class 0 multiple\\n            if (ans != fail) {\\n                ans = ans.clone();\\n                ans.A[d] = digitsHist[d]; // be greedy and take all of them, next subproblem class will still be c\\n            }\\n        } else { // if d is a class 1 or 2 digit, multiples of class 0, 1 and 2 are possible\\n            if (ans != fail) {\\n                ans = ans.clone();\\n                int multipleClass = (digitsHist[d] * d) % 3; // what multiple class we\\'d get if we were greedy\\n                int diff = 0; // how many digits d to remove to get a multiple of class 0\\n                if (multipleClass > 0) {\\n                    diff = dclass == multipleClass ? 1 : 2; // for example d = 7, multiple = 35 -> diff = 2; 35 - 2 * 7 = 21 % 3 = 0\\n                }\\n                ans.A[d] = digitsHist[d] - diff;\\n            }\\n            // guess 1: assume we took as many digits d to make a class 1 multiple\\n            if (dclass == 1 && digitsHist[d] >= 1 || dclass == 2 && digitsHist[d] >= 2) {\\n                Histogram a = solve(d + 1, (c + 1) % 3);\\n                if (a != fail) {\\n                    a = a.clone();\\n                    int multipleClass = (digitsHist[d] * d) % 3; // what multiple class we\\'d get if we were greedy\\n                    int diff; // how many digits d to remove to get a multiple of class 1\\n                    if (multipleClass == 1) {\\n                        diff = 0;\\n                    } else if (multipleClass == 0) {\\n                        diff = dclass == 1 ? 2 : 1; // for example d = 7, multiple = 42 -> diff = 2; 42 - 2 * 7 = 28 % 3 = 1\\n                    } else {\\n                        diff = dclass;\\n                    }\\n                    a.A[d] = digitsHist[d] - diff;\\n                    ans = max(ans, a);\\n                }\\n            }\\n            // guess 2: assume we took as many digits d to make a class 2 multiple\\n            if (dclass == 1 && digitsHist[d] >= 2 || dclass == 2 && digitsHist[d] >= 1) {\\n                Histogram a = solve(d + 1, (c + 2) % 3);\\n                if (a != fail) {\\n                    a = a.clone();\\n                    int multipleClass = (digitsHist[d] * d) % 3; // what multiple class we\\'d get if we were greedy\\n                    int diff; // how many digits d to remove to get a multiple of class 2\\n                    if (multipleClass == 2) {\\n                        diff = 0;\\n                    } else if (multipleClass == 0) {\\n                        diff = dclass;\\n                    } else {\\n                        diff = dclass == 1 ? 2 : 1; // for example d = 7, multiple = 49 -> diff = 2; 49 - 2 * 7 = 35 % 3 = 2\\n                    }\\n                    a.A[d] = digitsHist[d] - diff;\\n                    ans = max(ans, a);\\n                }\\n            }\\n        }\\n        return memo[d][c] = ans;\\n    }\\n\\n    private Histogram max(Histogram ans, Histogram a) {\\n        int cans = 0, ca = 0;\\n        for (int i = 1; i < 10; ++i) {\\n            cans += ans.A[i];\\n            ca += a.A[i];\\n        }\\n        if (cans == 0) {\\n            cans = Integer.min(ans.A[0], 1);\\n        }\\n        if (ca == 0) {\\n            ca = Integer.min(a.A[0], 1);\\n        }\\n        if (ca > cans) {\\n            return a;\\n        }\\n        if (cans > ca) {\\n            return ans;\\n        }\\n        int i = 9;\\n        for (; i >= 0 && a.A[i] == ans.A[i]; --i) {\\n        }\\n        if (i >= 0 && a.A[i] > ans.A[i]) {\\n            return a;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.Arrays;\\n\\nclass Solution {\\n\\n    /*\\n    Wrapper for an int[]. We exploit the reference to keep track of what subproblem has been solved \\n     */\\n    private static class Histogram {\\n        int[] A;\\n\\n        public Histogram() {\\n            this(new int[10]);\\n        }\\n        \\n        private Histogram(int[] a) {\\n            A = a;\\n        }\\n\\n        public Histogram clone() {\\n            return new Histogram(A.clone());\\n        }\\n\\n        public String toString() {\\n            return Arrays.toString(A);\\n        }\\n    }\\n\\n    public String largestMultipleOfThree(int[] digits) {\\n        digitsHist = new int[10];\\n        for (int d : digits) { // transform the array representation to histogram\\n            ++digitsHist[d];\\n        }\\n        memo = new Histogram[10][3];\\n        Histogram hist = solve(0, 0);\\n        if (hist == fail) {\\n            return \"\";\\n        }\\n        StringBuilder sb = new StringBuilder(digits.length);\\n        for (int i = 9; i > 0; --i) { // transform the digits 9-1 from the histogram to String\\n            for (int j = 0; j < hist.A[i]; ++j) {\\n                sb.append(i);\\n            }\\n        }\\n        if (sb.length() == 0) { // transform the digit 0 from the histogram to String\\n            if (hist.A[0] == 0) { // empty subsets of the input are not allowed\\n                return \"\";\\n            }\\n            // ignore leading zeros\\n            sb.append(0);\\n        } else {\\n            // no leading zeros, add all of them\\n            for (int j = 0; j < hist.A[0]; ++j) {\\n                sb.append(0);\\n            }\\n        }\\n        return sb.toString();\\n    }\\n\\n    int[] digitsHist; // the input, doesn\\'t need to be wrapped in a Histogram \\n    Histogram[][] memo;\\n    Histogram base = new Histogram(), fail = new Histogram(); // base / fail distinction is necessary for class 0 subproblems\\n\\n    private Histogram solve(int d, int c) {\\n        if (d > 9) {\\n            return c == 0 ? base : fail;\\n        }\\n        if (memo[d][c] != null) {\\n            return memo[d][c];\\n        }\\n        // guess 0: assume we took as many digits d to make a class 0 multiple\\n        Histogram ans = solve(d + 1, c);\\n        int dclass = d % 3;\\n        if (dclass == 0) { // if d is a class 0 digit, no matter how many we take we always make a class 0 multiple\\n            if (ans != fail) {\\n                ans = ans.clone();\\n                ans.A[d] = digitsHist[d]; // be greedy and take all of them, next subproblem class will still be c\\n            }\\n        } else { // if d is a class 1 or 2 digit, multiples of class 0, 1 and 2 are possible\\n            if (ans != fail) {\\n                ans = ans.clone();\\n                int multipleClass = (digitsHist[d] * d) % 3; // what multiple class we\\'d get if we were greedy\\n                int diff = 0; // how many digits d to remove to get a multiple of class 0\\n                if (multipleClass > 0) {\\n                    diff = dclass == multipleClass ? 1 : 2; // for example d = 7, multiple = 35 -> diff = 2; 35 - 2 * 7 = 21 % 3 = 0\\n                }\\n                ans.A[d] = digitsHist[d] - diff;\\n            }\\n            // guess 1: assume we took as many digits d to make a class 1 multiple\\n            if (dclass == 1 && digitsHist[d] >= 1 || dclass == 2 && digitsHist[d] >= 2) {\\n                Histogram a = solve(d + 1, (c + 1) % 3);\\n                if (a != fail) {\\n                    a = a.clone();\\n                    int multipleClass = (digitsHist[d] * d) % 3; // what multiple class we\\'d get if we were greedy\\n                    int diff; // how many digits d to remove to get a multiple of class 1\\n                    if (multipleClass == 1) {\\n                        diff = 0;\\n                    } else if (multipleClass == 0) {\\n                        diff = dclass == 1 ? 2 : 1; // for example d = 7, multiple = 42 -> diff = 2; 42 - 2 * 7 = 28 % 3 = 1\\n                    } else {\\n                        diff = dclass;\\n                    }\\n                    a.A[d] = digitsHist[d] - diff;\\n                    ans = max(ans, a);\\n                }\\n            }\\n            // guess 2: assume we took as many digits d to make a class 2 multiple\\n            if (dclass == 1 && digitsHist[d] >= 2 || dclass == 2 && digitsHist[d] >= 1) {\\n                Histogram a = solve(d + 1, (c + 2) % 3);\\n                if (a != fail) {\\n                    a = a.clone();\\n                    int multipleClass = (digitsHist[d] * d) % 3; // what multiple class we\\'d get if we were greedy\\n                    int diff; // how many digits d to remove to get a multiple of class 2\\n                    if (multipleClass == 2) {\\n                        diff = 0;\\n                    } else if (multipleClass == 0) {\\n                        diff = dclass;\\n                    } else {\\n                        diff = dclass == 1 ? 2 : 1; // for example d = 7, multiple = 49 -> diff = 2; 49 - 2 * 7 = 35 % 3 = 2\\n                    }\\n                    a.A[d] = digitsHist[d] - diff;\\n                    ans = max(ans, a);\\n                }\\n            }\\n        }\\n        return memo[d][c] = ans;\\n    }\\n\\n    private Histogram max(Histogram ans, Histogram a) {\\n        int cans = 0, ca = 0;\\n        for (int i = 1; i < 10; ++i) {\\n            cans += ans.A[i];\\n            ca += a.A[i];\\n        }\\n        if (cans == 0) {\\n            cans = Integer.min(ans.A[0], 1);\\n        }\\n        if (ca == 0) {\\n            ca = Integer.min(a.A[0], 1);\\n        }\\n        if (ca > cans) {\\n            return a;\\n        }\\n        if (cans > ca) {\\n            return ans;\\n        }\\n        int i = 9;\\n        for (; i >= 0 && a.A[i] == ans.A[i]; --i) {\\n        }\\n        if (i >= 0 && a.A[i] > ans.A[i]) {\\n            return a;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2876983,
                "title": "python-simple-maths",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def largestMultipleOfThree(self, digits):\\n        running_sum, ans0, ans1, ans2 = 0, [], [], []\\n\\n        for i in digits:\\n            running_sum += i\\n\\n            if i%3 == 0:\\n                ans0.append(i)\\n            elif i%3 == 1:\\n                ans1.append(i)\\n            else:\\n                ans2.append(i)\\n\\n        ans1.sort(reverse = True)\\n        ans2.sort(reverse = True)\\n\\n        if running_sum%3 == 1:\\n            if ans1:\\n                ans1.pop()\\n            else:\\n                if ans2:\\n                    ans2.pop()\\n                else:\\n                    return \"\"\\n\\n                if ans2:\\n                    ans2.pop()\\n                else:\\n                    return \"\"\\n\\n\\n        if running_sum%3 == 2:\\n            if ans2:\\n                ans2.pop()\\n            else:\\n                if ans1:\\n                    ans1.pop()\\n                else:\\n                    return \"\"\\n\\n                if ans1:\\n                    ans1.pop()\\n                else:\\n                    return \"\"\\n\\n        result = ans0 + ans1 + ans2\\n\\n        result.sort(reverse = True)\\n\\n        s = \"\"\\n\\n        for i in result:\\n            s += str(i)\\n\\n        return str(int(s)) if s else \"\"\\n\\n\\n\\n            \\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def largestMultipleOfThree(self, digits):\\n        running_sum, ans0, ans1, ans2 = 0, [], [], []\\n\\n        for i in digits:\\n            running_sum += i\\n\\n            if i%3 == 0:\\n                ans0.append(i)\\n            elif i%3 == 1:\\n                ans1.append(i)\\n            else:\\n                ans2.append(i)\\n\\n        ans1.sort(reverse = True)\\n        ans2.sort(reverse = True)\\n\\n        if running_sum%3 == 1:\\n            if ans1:\\n                ans1.pop()\\n            else:\\n                if ans2:\\n                    ans2.pop()\\n                else:\\n                    return \"\"\\n\\n                if ans2:\\n                    ans2.pop()\\n                else:\\n                    return \"\"\\n\\n\\n        if running_sum%3 == 2:\\n            if ans2:\\n                ans2.pop()\\n            else:\\n                if ans1:\\n                    ans1.pop()\\n                else:\\n                    return \"\"\\n\\n                if ans1:\\n                    ans1.pop()\\n                else:\\n                    return \"\"\\n\\n        result = ans0 + ans1 + ans2\\n\\n        result.sort(reverse = True)\\n\\n        s = \"\"\\n\\n        for i in result:\\n            s += str(i)\\n\\n        return str(int(s)) if s else \"\"\\n\\n\\n\\n            \\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2816593,
                "title": "c-math-explained",
                "content": "# Intuition\\nInspired by https://leetcode.com/problems/largest-multiple-of-three/solutions/2711835/c-93-faster-than-all-easy/\\n# Approach\\nA number is divisible by 3 if and only if the sum of its digits divisible by 3. \\nhttps://math.stackexchange.com/questions/341202/how-to-prove-the-divisibility-rule-for-3-casting-out-threes\\n\\n If a sum of digits is not divisible by 3 then the remainder should be either 1 or 2. \\nIf we get remainder either \\u20181\\u2019 or \\u20182\\u2019, we have to remove at most two digits to make a number that is divisible by 3: \\n\\n    - If remainder is \\u20181\\u2019 : We have to remove a single digit that has remainder \\n    \\u20181\\u2019 or we have to remove two digits that have remainder \\u20182\\u2019 \\n    ( 2 + 2 => 4 % 3 => \\u20181\\u2019)\\n\\n    - If remainder is \\u20182\\u2019 : We have to remove a single digit that has \\n    remainder \\u20182\\u2019 or we have to remove two digits that have remainder \\u20181\\u2019 \\n    ( 1 + 1 => 2 % 3 => 2 ).\\n# Complexity\\n- Time complexity:\\nO(n)\\n- Space complexity:\\nO(1)\\n# Code\\n```\\npublic class Solution {\\n    public string LargestMultipleOfThree(int[] digits) {\\n        int[] m1 = new int[]{1, 4, 7, 2, 5, 8};\\n        int[] m2 = new int[]{2, 5, 8, 1, 4, 7};\\n        int sum = 0;\\n        int[] ds = new int[10];  \\n        string res = \"\";\\n        foreach (var d in digits) \\n        {\\n            ++ds[d];\\n            sum += d;\\n        }\\n        while (sum % 3 != 0) {\\n            for (int counter = 0; counter < 6;) \\n            {\\n                var rm = sum % 3;\\n                var i = rm == 1 ? m1[counter] : m2[counter];\\n                if (ds[i]>0) \\n                {\\n                    --ds[i];\\n                    sum -= i;\\n                    break;\\n                }\\n                else\\n                {\\n                    counter++;\\n                }\\n                \\n            }\\n        }\\n        for (int i = 9; i >= 0; --i)\\n        {\\n            res += new string( (char)(\\'0\\' + i),ds[i] ); \\n        }\\n        return res.Length>0 && res[0] == \\'0\\' ? \"0\" : res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public string LargestMultipleOfThree(int[] digits) {\\n        int[] m1 = new int[]{1, 4, 7, 2, 5, 8};\\n        int[] m2 = new int[]{2, 5, 8, 1, 4, 7};\\n        int sum = 0;\\n        int[] ds = new int[10];  \\n        string res = \"\";\\n        foreach (var d in digits) \\n        {\\n            ++ds[d];\\n            sum += d;\\n        }\\n        while (sum % 3 != 0) {\\n            for (int counter = 0; counter < 6;) \\n            {\\n                var rm = sum % 3;\\n                var i = rm == 1 ? m1[counter] : m2[counter];\\n                if (ds[i]>0) \\n                {\\n                    --ds[i];\\n                    sum -= i;\\n                    break;\\n                }\\n                else\\n                {\\n                    counter++;\\n                }\\n                \\n            }\\n        }\\n        for (int i = 9; i >= 0; --i)\\n        {\\n            res += new string( (char)(\\'0\\' + i),ds[i] ); \\n        }\\n        return res.Length>0 && res[0] == \\'0\\' ? \"0\" : res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2772694,
                "title": "python3",
                "content": "```\\nclass Solution:\\n    def largestMultipleOfThree(self, digits: List[int]) -> str:\\n        res = \\'\\'\\n        remainder = sum(digits) % 3\\n        digits.sort(reverse = True)\\n        if remainder == 0:\\n            if digits[0] == 0:\\n                return \\'0\\'\\n            return res.join(map(str,digits))\\n        elif remainder == 1:\\n            if 1 in digits:\\n                digits.remove(1)\\n            elif 4 in digits:\\n                digits.remove(4)\\n            elif 7 in digits:\\n                digits.remove(7)\\n            elif 2 in digits:\\n                digits.remove(2)\\n                if 2 in digits:\\n                    digits.remove(2)\\n                elif 5 in digits:\\n                    digits.remove(5)\\n                elif 8 in digits:\\n                    digits.remove(8)\\n            elif 5 in digits:\\n                digits.remove(5)\\n                if 5 in digits:\\n                    digits.remove(5)\\n                elif 8 in digits:\\n                    digits.remove(8)\\n            elif 8 in digits:\\n                digits.remove(8)\\n                if 8 in digits:\\n                    digits.remove(8)\\n            if digits == []:\\n                return \\'\\'\\n            elif digits[0] == 0:\\n                return \\'0\\'\\n            return res.join(map(str,digits))\\n        elif remainder == 2:\\n            if 2 in digits:\\n                digits.remove(2)\\n            elif 5 in digits:\\n                digits.remove(5)\\n            elif 8 in digits:\\n                digits.remove(8)\\n            elif 1 in digits:\\n                digits.remove(1)\\n                if 1 in digits:\\n                    digits.remove(1)\\n                elif 4 in digits:\\n                    digits.remove(4)\\n                elif 7 in digits:\\n                    digits.remove(7)\\n            elif 4 in digits:\\n                digits.remove(4)\\n                if 4 in digits:\\n                    digits.remove(4)\\n                elif 7 in digits:\\n                    digits.remove(7)\\n            elif 7 in digits:\\n                digits.remove(7)\\n                if 7 in digits:\\n                    digits.remove(7)\\n            if digits == []:\\n                return \\'\\'\\n            elif digits[0] == 0:\\n                return \\'0\\'\\n            return res.join(map(str,digits))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def largestMultipleOfThree(self, digits: List[int]) -> str:\\n        res = \\'\\'\\n        remainder = sum(digits) % 3\\n        digits.sort(reverse = True)\\n        if remainder == 0:\\n            if digits[0] == 0:\\n                return \\'0\\'\\n            return res.join(map(str,digits))\\n        elif remainder == 1:\\n            if 1 in digits:\\n                digits.remove(1)\\n            elif 4 in digits:\\n                digits.remove(4)\\n            elif 7 in digits:\\n                digits.remove(7)\\n            elif 2 in digits:\\n                digits.remove(2)\\n                if 2 in digits:\\n                    digits.remove(2)\\n                elif 5 in digits:\\n                    digits.remove(5)\\n                elif 8 in digits:\\n                    digits.remove(8)\\n            elif 5 in digits:\\n                digits.remove(5)\\n                if 5 in digits:\\n                    digits.remove(5)\\n                elif 8 in digits:\\n                    digits.remove(8)\\n            elif 8 in digits:\\n                digits.remove(8)\\n                if 8 in digits:\\n                    digits.remove(8)\\n            if digits == []:\\n                return \\'\\'\\n            elif digits[0] == 0:\\n                return \\'0\\'\\n            return res.join(map(str,digits))\\n        elif remainder == 2:\\n            if 2 in digits:\\n                digits.remove(2)\\n            elif 5 in digits:\\n                digits.remove(5)\\n            elif 8 in digits:\\n                digits.remove(8)\\n            elif 1 in digits:\\n                digits.remove(1)\\n                if 1 in digits:\\n                    digits.remove(1)\\n                elif 4 in digits:\\n                    digits.remove(4)\\n                elif 7 in digits:\\n                    digits.remove(7)\\n            elif 4 in digits:\\n                digits.remove(4)\\n                if 4 in digits:\\n                    digits.remove(4)\\n                elif 7 in digits:\\n                    digits.remove(7)\\n            elif 7 in digits:\\n                digits.remove(7)\\n                if 7 in digits:\\n                    digits.remove(7)\\n            if digits == []:\\n                return \\'\\'\\n            elif digits[0] == 0:\\n                return \\'0\\'\\n            return res.join(map(str,digits))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2752625,
                "title": "python-o-n-counting-solution-with-explanation",
                "content": "The way to find the largest number in a string of numbers is to sort it from largest to smallest, e.g., ```[1,2,3,4,5,6,7,8,9] -> \"987654321\" ```\\nso, the basic idea is to count number```0~9```\\'s frequency in the ```digits``` first,\\nand find the sum of ```digits```, \\nif remainder of ```3``` of the sum is ```0```, which mean we can use all numbers of the ```digits``` ,we can use largest to smallest way to build the answer.\\n\\nif remainder of ```1```, we have 2 choice, we can preferentially **remove the smallest number whose remainder of 3 is ```1```**, \\nif not, **remove two the smallest number whose remainder is ```2```**\\n\\nif remainder of ```2```, we have 2 choice, we can preferentially **remove the smallest number whose remainder of 3 is ```2```**, \\nif not, **remove two the smallest number whose remainder is ```1```**\\n\\ntc is ```O(N)```, sc is ```O(1)``` if not count answer in.\\n```\\n# Runtime: 158 ms, faster than 99.46% of Python3 online submissions for Largest Multiple of Three.\\n# Memory Usage: 14.6 MB, less than 61.83% of Python3 online submissions for Largest Multiple of Three.\\nclass Solution:\\n    def largestMultipleOfThree(self, digits: List[int]) -> str:\\n        count = [0] * 10\\n        sum_, leng = 0, len(digits)\\n \\n        for n in digits:\\n            count[n] += 1\\n            sum_ += n\\n    \\n        remainder = sum_ % 3\\n        if remainder == 0: # remainder is 0\\n            return self.build(count, leng)\\n\\n        if remainder == 1: # remainder is 1\\n\\t\\t    # remove 1 number whose remainder of 3 is 1\\n            for i in range(1, 10, 3):\\n                if count[i] > 0:\\n                    count[i] -= 1\\n                    return self.build(count, leng-1)\\n\\t\\t\\t# remove 2 numbers whose remainder of 3 is 2\\n            removed = 0\\n            for i in range(2, 10, 3):\\n                if removed == 0 and count[i] >= 2:\\n                    count[i] -= 2\\n                    return self.build(count, leng-2)\\n                elif count[i] >= 1:\\n                    if removed == 0:\\n                        count[i] -= 1\\n                        removed = 1\\n                    else: # if removed == 1\\n                        count[i] -= 1\\n                        return self.build(count, leng-2)\\n            return \\'\\'\\n        else: # remainder is 2\\n\\t\\t    # remove 1 number whose remainder of 3 is 2\\n            for i in range(2, 10, 3):\\n                if count[i] > 0:\\n                    count[i] -= 1\\n                    return self.build(count, leng-1)\\n\\t\\t\\t# remove 2 numbers whose remainder of 3 is 1\\n            removed = 0\\n            for i in range(1, 10, 3):\\n                if removed == 0 and count[i] >= 2:\\n                    count[i] -= 2\\n                    return self.build(count, leng-2)\\n                elif count[i] >= 1:\\n                    if removed == 0:\\n                        count[i] -= 1\\n                        removed = 1\\n                    else: # if removed == 1\\n                        count[i] -= 1\\n                        return self.build(count, leng-2)\\n            return \\'\\'\\n\\n    def build(self, count, ansLen):\\n        if ansLen == 0: return \\'\\' # the length of answer is 0, return empty string\\n        elif count[0] == ansLen: return \\'0\\' # after removing, answer only remains 0s\\n        ans = []\\n        for i in range(9, -1, -1):\\n            ans += [str(i)] * count[i]\\n        return \\'\\'.join(ans)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```[1,2,3,4,5,6,7,8,9] -> \"987654321\" ```\n```0~9```\n```digits```\n```digits```\n```3```\n```0```\n```digits```\n```1```\n```1```\n```2```\n```2```\n```2```\n```1```\n```O(N)```\n```O(1)```\n```\\n# Runtime: 158 ms, faster than 99.46% of Python3 online submissions for Largest Multiple of Three.\\n# Memory Usage: 14.6 MB, less than 61.83% of Python3 online submissions for Largest Multiple of Three.\\nclass Solution:\\n    def largestMultipleOfThree(self, digits: List[int]) -> str:\\n        count = [0] * 10\\n        sum_, leng = 0, len(digits)\\n \\n        for n in digits:\\n            count[n] += 1\\n            sum_ += n\\n    \\n        remainder = sum_ % 3\\n        if remainder == 0: # remainder is 0\\n            return self.build(count, leng)\\n\\n        if remainder == 1: # remainder is 1\\n\\t\\t    # remove 1 number whose remainder of 3 is 1\\n            for i in range(1, 10, 3):\\n                if count[i] > 0:\\n                    count[i] -= 1\\n                    return self.build(count, leng-1)\\n\\t\\t\\t# remove 2 numbers whose remainder of 3 is 2\\n            removed = 0\\n            for i in range(2, 10, 3):\\n                if removed == 0 and count[i] >= 2:\\n                    count[i] -= 2\\n                    return self.build(count, leng-2)\\n                elif count[i] >= 1:\\n                    if removed == 0:\\n                        count[i] -= 1\\n                        removed = 1\\n                    else: # if removed == 1\\n                        count[i] -= 1\\n                        return self.build(count, leng-2)\\n            return \\'\\'\\n        else: # remainder is 2\\n\\t\\t    # remove 1 number whose remainder of 3 is 2\\n            for i in range(2, 10, 3):\\n                if count[i] > 0:\\n                    count[i] -= 1\\n                    return self.build(count, leng-1)\\n\\t\\t\\t# remove 2 numbers whose remainder of 3 is 1\\n            removed = 0\\n            for i in range(1, 10, 3):\\n                if removed == 0 and count[i] >= 2:\\n                    count[i] -= 2\\n                    return self.build(count, leng-2)\\n                elif count[i] >= 1:\\n                    if removed == 0:\\n                        count[i] -= 1\\n                        removed = 1\\n                    else: # if removed == 1\\n                        count[i] -= 1\\n                        return self.build(count, leng-2)\\n            return \\'\\'\\n\\n    def build(self, count, ansLen):\\n        if ansLen == 0: return \\'\\' # the length of answer is 0, return empty string\\n        elif count[0] == ansLen: return \\'0\\' # after removing, answer only remains 0s\\n        ans = []\\n        for i in range(9, -1, -1):\\n            ans += [str(i)] * count[i]\\n        return \\'\\'.join(ans)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2674021,
                "title": "python-solution-knapsack-bitmask",
                "content": "I browsed through the forum and didn\\'t find anyone solving this this way. Just to provide a different line of thought\\n```\\nclass Solution:\\n    # Count number of occurrence of 0 to 9\\n    # There are interesting edge cases, For example [2,2,1,1,1]\\n    # Although there are 3 1s, the optimal use of digits is actually use 2 1s to combine with the 2 2s\\n    # Therefore, we establish this rule:\\n    # For multiples of 3, we just put all the numbers given (they will not help in getting more digits inside the output)\\n    # Otherwise, we put (count // 3 - 1) (if count >= 3) or count // 3 (if count < 3) of each digit into the number\\n    # The left behind are 1,2,4,5,7,8 appearing equal to or less than 3 times\\n    # So at most 18 bits would be enough to represent them\\n    # Just knapsack it out to get the most elements that sum up to multiple of 3\\n    \\n    def largestMultipleOfThree(self, digits: List[int]) -> str:\\n        # Count occurences of different digits\\n        counts = [0]*10\\n        for digit in digits:\\n            counts[digit] += 1\\n            \\n        # DP: collect all the remainders that cannot be divided by 3. If we have, 3,6,9,.. of a number, give 3 of them to the knapsack\\n        knapsack = []\\n        for i in range(9):\\n            if i % 3 != 0:\\n                if counts[i] % 3 != 0:\\n                    knapsack += [i]*(counts[i] % 3)\\n                elif counts[i] >= 3:\\n                    knapsack += [i]*3\\n\\n        # bitmask: Try to build the longest combinations of digits by DP; Use bitmask to represent digit usage\\n        # dp[mask] = [sum of all value present in the mask, number of digits used]\\n        n, max_length, max_mask = len(knapsack), 0, -1\\n        dp = [[0,0] for i in range(1 << n)]\\n        for i in range(n):\\n            for j in range(1<<i):\\n                dp[j^(1<<i)] = [dp[j][0] + knapsack[i], dp[j][1]+1]\\n                if dp[j^(1<<i)][1] >= max_length and dp[j^(1<<i)][0] % 3 == 0:\\n                    max_length = max(max_length, dp[j^(1<<i)][1])\\n                    max_mask = j^(1<<i)\\n        \\n        # Convert the max_mask into an array such that it\\'s sorted reversed\\n        max_mask_arr = []\\n        for i in range(n-1,-1,-1):\\n            if max_mask & (1 << i) != 0:\\n                max_mask_arr.append(knapsack[i])\\n        \\n        # Output\\n        result, p = \"\", 0\\n        for i in range(9,-1,-1):\\n            if i % 3 == 0:\\n                result += str(i)*counts[i]\\n            else:\\n                if counts[i] % 3 != 0 or counts[i] < 3:\\n                    result += str(i)*(3*(counts[i]//3))\\n                else:\\n                    result += str(i)*(3*(counts[i]//3 - 1))\\n                while p < len(max_mask_arr) and max_mask_arr[p] == i and max_mask >= 0:\\n                    result += str(max_mask_arr[p])\\n                    p += 1\\n        if result and int(result) == 0:\\n            return \"0\"\\n        return result\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    # Count number of occurrence of 0 to 9\\n    # There are interesting edge cases, For example [2,2,1,1,1]\\n    # Although there are 3 1s, the optimal use of digits is actually use 2 1s to combine with the 2 2s\\n    # Therefore, we establish this rule:\\n    # For multiples of 3, we just put all the numbers given (they will not help in getting more digits inside the output)\\n    # Otherwise, we put (count // 3 - 1) (if count >= 3) or count // 3 (if count < 3) of each digit into the number\\n    # The left behind are 1,2,4,5,7,8 appearing equal to or less than 3 times\\n    # So at most 18 bits would be enough to represent them\\n    # Just knapsack it out to get the most elements that sum up to multiple of 3\\n    \\n    def largestMultipleOfThree(self, digits: List[int]) -> str:\\n        # Count occurences of different digits\\n        counts = [0]*10\\n        for digit in digits:\\n            counts[digit] += 1\\n            \\n        # DP: collect all the remainders that cannot be divided by 3. If we have, 3,6,9,.. of a number, give 3 of them to the knapsack\\n        knapsack = []\\n        for i in range(9):\\n            if i % 3 != 0:\\n                if counts[i] % 3 != 0:\\n                    knapsack += [i]*(counts[i] % 3)\\n                elif counts[i] >= 3:\\n                    knapsack += [i]*3\\n\\n        # bitmask: Try to build the longest combinations of digits by DP; Use bitmask to represent digit usage\\n        # dp[mask] = [sum of all value present in the mask, number of digits used]\\n        n, max_length, max_mask = len(knapsack), 0, -1\\n        dp = [[0,0] for i in range(1 << n)]\\n        for i in range(n):\\n            for j in range(1<<i):\\n                dp[j^(1<<i)] = [dp[j][0] + knapsack[i], dp[j][1]+1]\\n                if dp[j^(1<<i)][1] >= max_length and dp[j^(1<<i)][0] % 3 == 0:\\n                    max_length = max(max_length, dp[j^(1<<i)][1])\\n                    max_mask = j^(1<<i)\\n        \\n        # Convert the max_mask into an array such that it\\'s sorted reversed\\n        max_mask_arr = []\\n        for i in range(n-1,-1,-1):\\n            if max_mask & (1 << i) != 0:\\n                max_mask_arr.append(knapsack[i])\\n        \\n        # Output\\n        result, p = \"\", 0\\n        for i in range(9,-1,-1):\\n            if i % 3 == 0:\\n                result += str(i)*counts[i]\\n            else:\\n                if counts[i] % 3 != 0 or counts[i] < 3:\\n                    result += str(i)*(3*(counts[i]//3))\\n                else:\\n                    result += str(i)*(3*(counts[i]//3 - 1))\\n                while p < len(max_mask_arr) and max_mask_arr[p] == i and max_mask >= 0:\\n                    result += str(max_mask_arr[p])\\n                    p += 1\\n        if result and int(result) == 0:\\n            return \"0\"\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2668732,
                "title": "c-solution-greedy",
                "content": "```\\nclass Solution {\\npublic:\\n    string largestMultipleOfThree(vector<int>& vb) {\\n        string ans = \"\";\\n        int sum = accumulate(vb.begin(),vb.end(),0ll);\\n        vector<int> v1,v2,v3;\\n        for(auto &it:vb){\\n            if(it%3 == 0)\\n                v3.push_back(it);\\n            else if(it%3 == 1)\\n                v2.push_back(it);\\n            else \\n                v1.push_back(it);\\n        }\\n        sort(v1.rbegin(),v1.rend());\\n        sort(v2.rbegin(),v2.rend());\\n        sort(v3.rbegin(),v3.rend());\\n        if(sum%3 == 1){\\n            if(!v2.size()){\\n                if(v1.size()<2){\\n                    return ans;\\n                }\\n                else{\\n                    v1.pop_back();\\n                    v1.pop_back();\\n                }\\n            }\\n            else\\n                v2.pop_back();\\n        }\\n        else if(sum%3 == 2){\\n            if(!v1.size()){\\n                if(v2.size()<2){\\n                    return ans;\\n                }\\n                else{\\n                    v2.pop_back();\\n                    v2.pop_back();\\n                }\\n            }\\n            else\\n                v1.pop_back();\\n        }\\n        for(auto &it: v1){\\n            ans+=(it+\\'0\\');\\n        }\\n        for(auto &it: v2){\\n            ans+=(it+\\'0\\');\\n        }\\n        for(auto &it: v3){\\n            ans+=(it+\\'0\\');\\n        }\\n        sort(ans.rbegin(),ans.rend());\\n        if(!ans.empty() and ans[0] == \\'0\\'){\\n            return \"0\";\\n        } \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestMultipleOfThree(vector<int>& vb) {\\n        string ans = \"\";\\n        int sum = accumulate(vb.begin(),vb.end(),0ll);\\n        vector<int> v1,v2,v3;\\n        for(auto &it:vb){\\n            if(it%3 == 0)\\n                v3.push_back(it);\\n            else if(it%3 == 1)\\n                v2.push_back(it);\\n            else \\n                v1.push_back(it);\\n        }\\n        sort(v1.rbegin(),v1.rend());\\n        sort(v2.rbegin(),v2.rend());\\n        sort(v3.rbegin(),v3.rend());\\n        if(sum%3 == 1){\\n            if(!v2.size()){\\n                if(v1.size()<2){\\n                    return ans;\\n                }\\n                else{\\n                    v1.pop_back();\\n                    v1.pop_back();\\n                }\\n            }\\n            else\\n                v2.pop_back();\\n        }\\n        else if(sum%3 == 2){\\n            if(!v1.size()){\\n                if(v2.size()<2){\\n                    return ans;\\n                }\\n                else{\\n                    v2.pop_back();\\n                    v2.pop_back();\\n                }\\n            }\\n            else\\n                v1.pop_back();\\n        }\\n        for(auto &it: v1){\\n            ans+=(it+\\'0\\');\\n        }\\n        for(auto &it: v2){\\n            ans+=(it+\\'0\\');\\n        }\\n        for(auto &it: v3){\\n            ans+=(it+\\'0\\');\\n        }\\n        sort(ans.rbegin(),ans.rend());\\n        if(!ans.empty() and ans[0] == \\'0\\'){\\n            return \"0\";\\n        } \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2654963,
                "title": "greedy-c-solution-no-need-of-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nGreedy Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string largestMultipleOfThree(vector<int>& digits) {\\n        string ans;\\n        unordered_map<int,int> mp;\\n        int sum = 0;\\n        for(auto &d:digits) mp[d]++, sum += d;\\n        int rem = sum%3;\\n        if(rem==1){\\n            if(mp[1]) mp[1]--;\\n            else if(mp[4]) mp[4]--;\\n            else if(mp[7]) mp[7]--;\\n            else{\\n                if(mp[2]>=2) mp[2]-=2;\\n                else if(mp[2] and mp[5]) mp[2]--, mp[5]--;\\n                else if(mp[5]>=2) mp[5]-=2;\\n                else if(mp[2] and mp[8]) mp[2]--, mp[8]--;\\n                else if(mp[5] and mp[8]) mp[5]--, mp[8]--;\\n                else if(mp[8]>=2) mp[8]-=2;\\n                else return \"\";\\n            }\\n        }\\n        else if(rem==2){\\n            if(mp[2]) mp[2]--;\\n            else if(mp[5]) mp[5]--;\\n            else if(mp[8]) mp[8]--;\\n            else{\\n                if(mp[1]>=2) mp[1] -= 2;\\n                else if(mp[1] and mp[4]) mp[1]--, mp[4]--;\\n                else if(mp[4]>=2) mp[4]-=2;\\n                else if(mp[1] and mp[7]) mp[1]--, mp[7]--;\\n                else if(mp[4] and mp[7]) mp[4]--, mp[7]--;\\n                else if(mp[7]>=2) mp[7]-=2;\\n                else return \"\";\\n            }\\n        }\\n        for(auto &i:mp){\\n            int f = i.second;\\n            while(f--) ans += (i.first+\\'0\\');\\n        }\\n        sort(ans.begin(),ans.end());\\n        reverse(ans.begin(),ans.end());\\n        int n = ans.length(), i = 0;\\n        if(n==0) return ans;\\n        while(i<n and ans[i]==\\'0\\') i++;\\n        string answer;\\n        if(i==n) answer += \\'0\\';\\n        else for(int j=i;j<n;j++) answer += ans[j];\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestMultipleOfThree(vector<int>& digits) {\\n        string ans;\\n        unordered_map<int,int> mp;\\n        int sum = 0;\\n        for(auto &d:digits) mp[d]++, sum += d;\\n        int rem = sum%3;\\n        if(rem==1){\\n            if(mp[1]) mp[1]--;\\n            else if(mp[4]) mp[4]--;\\n            else if(mp[7]) mp[7]--;\\n            else{\\n                if(mp[2]>=2) mp[2]-=2;\\n                else if(mp[2] and mp[5]) mp[2]--, mp[5]--;\\n                else if(mp[5]>=2) mp[5]-=2;\\n                else if(mp[2] and mp[8]) mp[2]--, mp[8]--;\\n                else if(mp[5] and mp[8]) mp[5]--, mp[8]--;\\n                else if(mp[8]>=2) mp[8]-=2;\\n                else return \"\";\\n            }\\n        }\\n        else if(rem==2){\\n            if(mp[2]) mp[2]--;\\n            else if(mp[5]) mp[5]--;\\n            else if(mp[8]) mp[8]--;\\n            else{\\n                if(mp[1]>=2) mp[1] -= 2;\\n                else if(mp[1] and mp[4]) mp[1]--, mp[4]--;\\n                else if(mp[4]>=2) mp[4]-=2;\\n                else if(mp[1] and mp[7]) mp[1]--, mp[7]--;\\n                else if(mp[4] and mp[7]) mp[4]--, mp[7]--;\\n                else if(mp[7]>=2) mp[7]-=2;\\n                else return \"\";\\n            }\\n        }\\n        for(auto &i:mp){\\n            int f = i.second;\\n            while(f--) ans += (i.first+\\'0\\');\\n        }\\n        sort(ans.begin(),ans.end());\\n        reverse(ans.begin(),ans.end());\\n        int n = ans.length(), i = 0;\\n        if(n==0) return ans;\\n        while(i<n and ans[i]==\\'0\\') i++;\\n        string answer;\\n        if(i==n) answer += \\'0\\';\\n        else for(int j=i;j<n;j++) answer += ans[j];\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2614505,
                "title": "python-3-space-o-n-time-o-n",
                "content": "```\\nclass Solution:\\n    def largestMultipleOfThree(self, ds: List[int]) -> str:\\n        ds.sort()\\n        ds.reverse()\\n        n=len(ds)\\n        fmx=0\\n        v=[0]*len(ds)\\n        for i in range(0,len(ds),1):\\n            v[i]=ds[i]%3\\n            fmx+=ds[i]\\n            ds[i]=str(ds[i])\\n        x=sum(v)%3\\n        if(x==0):\\n            ans=\\'\\'.join(ds)\\n            if(len(ans) and ans[0]==ans[-1] and ans[0]==\\'0\\'):return \"0\"\\n            return ans\\n        us=-1\\n        for i in range(0,n,1):\\n            if(x==v[i]):\\n                us=i\\n        if(us!=-1):\\n            ans= \\'\\'.join(ds[:us]+ds[us+1:])\\n            if(len(ans) and ans[0]==ans[-1] and ans[0]==\\'0\\'):return \"0\"\\n            return ans\\n        if(x==1):\\n            x2=0\\n            for i in range(0,n,1):\\n                if(v[i]==2):x2+=1\\n            if(x2<2):return \\'\\'\\n            ans=\"\"\\n            for i in range(n-1,-1,-1):\\n                if(v[i]==2 and x2):\\n                    x2-=1\\n                    continue\\n                ans+=str(ds[i])\\n            ans= ans[::-1]\\n            if(len(ans) and ans[0]==ans[-1] and ans[0]==\\'0\\'):return \"0\"\\n            return ans\\n        else:\\n            x2=0\\n            for i in range(0,n,1):\\n                if(v[i]==1):x2+=1\\n            if(x2<2):return \\'\\'\\n            ans=\"\"\\n            for i in range(n-1,-1,-1):\\n                if(v[i]==1 and x2):\\n                    x2-=1\\n                    continue\\n                ans+=str(ds[i])\\n            ans= ans[::-1]\\n            if(len(ans) and ans[0]==ans[-1] and ans[0]==\\'0\\'):return \"0\"\\n            return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def largestMultipleOfThree(self, ds: List[int]) -> str:\\n        ds.sort()\\n        ds.reverse()\\n        n=len(ds)\\n        fmx=0\\n        v=[0]*len(ds)\\n        for i in range(0,len(ds),1):\\n            v[i]=ds[i]%3\\n            fmx+=ds[i]\\n            ds[i]=str(ds[i])\\n        x=sum(v)%3\\n        if(x==0):\\n            ans=\\'\\'.join(ds)\\n            if(len(ans) and ans[0]==ans[-1] and ans[0]==\\'0\\'):return \"0\"\\n            return ans\\n        us=-1\\n        for i in range(0,n,1):\\n            if(x==v[i]):\\n                us=i\\n        if(us!=-1):\\n            ans= \\'\\'.join(ds[:us]+ds[us+1:])\\n            if(len(ans) and ans[0]==ans[-1] and ans[0]==\\'0\\'):return \"0\"\\n            return ans\\n        if(x==1):\\n            x2=0\\n            for i in range(0,n,1):\\n                if(v[i]==2):x2+=1\\n            if(x2<2):return \\'\\'\\n            ans=\"\"\\n            for i in range(n-1,-1,-1):\\n                if(v[i]==2 and x2):\\n                    x2-=1\\n                    continue\\n                ans+=str(ds[i])\\n            ans= ans[::-1]\\n            if(len(ans) and ans[0]==ans[-1] and ans[0]==\\'0\\'):return \"0\"\\n            return ans\\n        else:\\n            x2=0\\n            for i in range(0,n,1):\\n                if(v[i]==1):x2+=1\\n            if(x2<2):return \\'\\'\\n            ans=\"\"\\n            for i in range(n-1,-1,-1):\\n                if(v[i]==1 and x2):\\n                    x2-=1\\n                    continue\\n                ans+=str(ds[i])\\n            ans= ans[::-1]\\n            if(len(ans) and ans[0]==ans[-1] and ans[0]==\\'0\\'):return \"0\"\\n            return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2603967,
                "title": "python-dp-counter",
                "content": "```\\nclass Solution:\\n    def largestMultipleOfThree(self, x: List[int]) -> str:\\n        x=Counter(x)\\n        def f(i=9,z=0):\\n            if i==0:\\n                dp[i,z]=0 if z==0 else -inf\\n                return dp[i,z]\\n            if (i,z) in dp:return dp[i,z]\\n            ans=-inf\\n            for j in range(x[i],-1,-1):\\n                ans=max(ans,j+f(i-1,(z+j*i)%3))\\n            dp[i,z]=ans\\n            return ans                \\n        ans=\\'\\'\\n        def q(i,z,a,r=\\'\\'):\\n            if i==0:\\n                nonlocal ans\\n                ans=r+\\'0\\'*x[0]\\n                return\\n            for j in range(x[i],-1,-1):\\n                if dp[i-1,(z+j*i)%3]==a-j:\\n                    q(i-1,(z+j*i)%3,a-j,r+str(i)*j)\\n                    break\\n        dp={}\\n        a=f()\\n        q(9,0,a)\\n        return ans if ans==\\'\\' else str(int(ans))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def largestMultipleOfThree(self, x: List[int]) -> str:\\n        x=Counter(x)\\n        def f(i=9,z=0):\\n            if i==0:\\n                dp[i,z]=0 if z==0 else -inf\\n                return dp[i,z]\\n            if (i,z) in dp:return dp[i,z]\\n            ans=-inf\\n            for j in range(x[i],-1,-1):\\n                ans=max(ans,j+f(i-1,(z+j*i)%3))\\n            dp[i,z]=ans\\n            return ans                \\n        ans=\\'\\'\\n        def q(i,z,a,r=\\'\\'):\\n            if i==0:\\n                nonlocal ans\\n                ans=r+\\'0\\'*x[0]\\n                return\\n            for j in range(x[i],-1,-1):\\n                if dp[i-1,(z+j*i)%3]==a-j:\\n                    q(i-1,(z+j*i)%3,a-j,r+str(i)*j)\\n                    break\\n        dp={}\\n        a=f()\\n        q(9,0,a)\\n        return ans if ans==\\'\\' else str(int(ans))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2490065,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public String largestMultipleOfThree(int[] digits) {\\n        Arrays.sort(digits);\\n        reverse(digits);\\n        int sum = 0;\\n        ArrayList<Integer>[] arr = new ArrayList[3];\\n        arr[0] = new ArrayList<>();\\n        arr[1] = new ArrayList<>();\\n        arr[2] = new ArrayList<>();\\n        for(int i = 0; i < digits.length; i++){\\n            sum+=digits[i];\\n            arr[digits[i] % 3].add(digits[i]);\\n        }\\n        // System.out.println(sum);\\n        String ans;\\n        if(sum % 3 == 0){\\n            ans= createS2(digits);\\n        }\\n        else if(sum % 3 == 1){\\n            if(arr[1].size() == 0 && arr[2].size() < 2){\\n                ans = \"\";\\n            }\\n            else{\\n                if(arr[1].size() > 0){\\n                    arr[1].remove(arr[1].size() - 1);\\n                }\\n                else{\\n                    arr[2].remove(arr[2].size() - 1);\\n                    arr[2].remove(arr[2].size() - 1);\\n                }\\n                ans = createS(merge(arr[2], merge(arr[0], arr[1])));\\n            }\\n        }\\n        else{\\n            if(arr[1].size() < 2 && arr[2].size() == 0){\\n                ans =  \"\";\\n            }\\n            else{\\n                if(arr[2].size() > 0){\\n                    arr[2].remove(arr[2].size() - 1);\\n                }\\n                else{\\n                    arr[1].remove(arr[1].size() - 1);\\n                    arr[1].remove(arr[1].size() - 1);\\n                }\\n                ans = createS(merge(arr[2], merge(arr[0], arr[1])));\\n            }\\n        }\\n        if(ans.length() > 0 && ans.charAt(0) == \\'0\\'){\\n            return \"0\";\\n        }\\n        return ans;\\n    }\\n    private String createS(ArrayList<Integer> arr){\\n        StringBuilder str = new StringBuilder();\\n        for(int i : arr){\\n            str.append(i);\\n        }\\n        return str.toString();\\n        \\n    }\\n    \\n    private String createS2(int[] arr){\\n        StringBuilder str = new StringBuilder();\\n        for(int i : arr){\\n            str.append(i);\\n        }\\n        return str.toString();\\n    }\\n    \\n    private ArrayList<Integer> merge(ArrayList<Integer> arr1, ArrayList<Integer> arr2){\\n        int i = 0, j = 0;\\n        ArrayList<Integer> ans = new ArrayList<>();;\\n        while(i < arr1.size() && j < arr2.size()){\\n            if(arr1.get(i) > arr2.get(j)){\\n                ans.add(arr1.get(i));\\n                i++;\\n            }\\n            else{\\n                ans.add(arr2.get(j));\\n                j++;\\n            }\\n        }\\n        while(i < arr1.size()){\\n            ans.add(arr1.get(i++));\\n        }\\n        while(j < arr2.size()){\\n            ans.add(arr2.get(j++));\\n        }\\n        return ans;\\n    }\\n    private void reverse(int[] arr){\\n        int i = 0;\\n        int j = arr.length - 1;\\n        while(i < j){\\n            int temp = arr[i];\\n            arr[i] = arr[j];\\n            arr[j] = temp; \\n            i++;\\n            j--;\\n        }\\n        return;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String largestMultipleOfThree(int[] digits) {\\n        Arrays.sort(digits);\\n        reverse(digits);\\n        int sum = 0;\\n        ArrayList<Integer>[] arr = new ArrayList[3];\\n        arr[0] = new ArrayList<>();\\n        arr[1] = new ArrayList<>();\\n        arr[2] = new ArrayList<>();\\n        for(int i = 0; i < digits.length; i++){\\n            sum+=digits[i];\\n            arr[digits[i] % 3].add(digits[i]);\\n        }\\n        // System.out.println(sum);\\n        String ans;\\n        if(sum % 3 == 0){\\n            ans= createS2(digits);\\n        }\\n        else if(sum % 3 == 1){\\n            if(arr[1].size() == 0 && arr[2].size() < 2){\\n                ans = \"\";\\n            }\\n            else{\\n                if(arr[1].size() > 0){\\n                    arr[1].remove(arr[1].size() - 1);\\n                }\\n                else{\\n                    arr[2].remove(arr[2].size() - 1);\\n                    arr[2].remove(arr[2].size() - 1);\\n                }\\n                ans = createS(merge(arr[2], merge(arr[0], arr[1])));\\n            }\\n        }\\n        else{\\n            if(arr[1].size() < 2 && arr[2].size() == 0){\\n                ans =  \"\";\\n            }\\n            else{\\n                if(arr[2].size() > 0){\\n                    arr[2].remove(arr[2].size() - 1);\\n                }\\n                else{\\n                    arr[1].remove(arr[1].size() - 1);\\n                    arr[1].remove(arr[1].size() - 1);\\n                }\\n                ans = createS(merge(arr[2], merge(arr[0], arr[1])));\\n            }\\n        }\\n        if(ans.length() > 0 && ans.charAt(0) == \\'0\\'){\\n            return \"0\";\\n        }\\n        return ans;\\n    }\\n    private String createS(ArrayList<Integer> arr){\\n        StringBuilder str = new StringBuilder();\\n        for(int i : arr){\\n            str.append(i);\\n        }\\n        return str.toString();\\n        \\n    }\\n    \\n    private String createS2(int[] arr){\\n        StringBuilder str = new StringBuilder();\\n        for(int i : arr){\\n            str.append(i);\\n        }\\n        return str.toString();\\n    }\\n    \\n    private ArrayList<Integer> merge(ArrayList<Integer> arr1, ArrayList<Integer> arr2){\\n        int i = 0, j = 0;\\n        ArrayList<Integer> ans = new ArrayList<>();;\\n        while(i < arr1.size() && j < arr2.size()){\\n            if(arr1.get(i) > arr2.get(j)){\\n                ans.add(arr1.get(i));\\n                i++;\\n            }\\n            else{\\n                ans.add(arr2.get(j));\\n                j++;\\n            }\\n        }\\n        while(i < arr1.size()){\\n            ans.add(arr1.get(i++));\\n        }\\n        while(j < arr2.size()){\\n            ans.add(arr2.get(j++));\\n        }\\n        return ans;\\n    }\\n    private void reverse(int[] arr){\\n        int i = 0;\\n        int j = arr.length - 1;\\n        while(i < j){\\n            int temp = arr[i];\\n            arr[i] = arr[j];\\n            arr[j] = temp; \\n            i++;\\n            j--;\\n        }\\n        return;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2359033,
                "title": "python-sorting",
                "content": "```\\ndef largestMultipleOfThree(self, digits: List[int]) -> str:\\n        Sum=0\\n        Sum=sum(digits)\\n        digits=sorted(digits)\\n        if Sum%3==1:\\n            flag=False\\n            for i in range(len(digits)):\\n                if digits[i]%3==1:\\n                    flag=True\\n                    digits[i]=\"#\"\\n                    break\\n            if not flag:\\n                count=0\\n                for i in range(len(digits)):\\n                    if digits[i]%3==2:\\n                        count+=1\\n                        digits[i]=\"#\"\\n                        if count==2:\\n                            break\\n                if count!=2:\\n                    return \"\"\\n        if Sum%3==2:\\n            flag=False\\n            for i in range(len(digits)):\\n                if digits[i]%3==2:\\n                    flag=True\\n                    digits[i]=\"#\"\\n                    break\\n            if not flag:\\n                count=0\\n                for i in range(len(digits)):\\n                    if digits[i]%3==1:\\n                        count+=1\\n                        digits[i]=\"#\"\\n                        if count==2:\\n                            break\\n                if count!=2:\\n                    return \"\"\\n        ans=\"\"\\n        for i in range(len(digits)-1,-1,-1):\\n            if digits[i]!=\"#\":\\n                ans+=str(digits[i])\\n        if ans !=\"\" and ans[0]==\\'0\\':\\n            return \"0\"\\n        else:\\n            return ans\\n        \\n\\n\\n```",
                "solutionTags": [
                    "String",
                    "Sorting"
                ],
                "code": "```\\ndef largestMultipleOfThree(self, digits: List[int]) -> str:\\n        Sum=0\\n        Sum=sum(digits)\\n        digits=sorted(digits)\\n        if Sum%3==1:\\n            flag=False\\n            for i in range(len(digits)):\\n                if digits[i]%3==1:\\n                    flag=True\\n                    digits[i]=\"#\"\\n                    break\\n            if not flag:\\n                count=0\\n                for i in range(len(digits)):\\n                    if digits[i]%3==2:\\n                        count+=1\\n                        digits[i]=\"#\"\\n                        if count==2:\\n                            break\\n                if count!=2:\\n                    return \"\"\\n        if Sum%3==2:\\n            flag=False\\n            for i in range(len(digits)):\\n                if digits[i]%3==2:\\n                    flag=True\\n                    digits[i]=\"#\"\\n                    break\\n            if not flag:\\n                count=0\\n                for i in range(len(digits)):\\n                    if digits[i]%3==1:\\n                        count+=1\\n                        digits[i]=\"#\"\\n                        if count==2:\\n                            break\\n                if count!=2:\\n                    return \"\"\\n        ans=\"\"\\n        for i in range(len(digits)-1,-1,-1):\\n            if digits[i]!=\"#\":\\n                ans+=str(digits[i])\\n        if ans !=\"\" and ans[0]==\\'0\\':\\n            return \"0\"\\n        else:\\n            return ans\\n        \\n\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2340203,
                "title": "dp-easy-to-understand",
                "content": "\\tclass Solution:\\n\\t\\tdef largestMultipleOfThree(self, digits: List[int]) -> str:\\n\\t\\t\\tA = digits\\n\\t\\t\\tA.sort()\\n\\t\\t\\tA.reverse()\\n\\n\\t\\t\\t@cache\\n\\t\\t\\tdef DP(i, r): # max number whose remainder is r using subarray [0:i] (inclusive) \\n\\t\\t\\t\\tif i == 0:\\n\\t\\t\\t\\t\\tif A[0] % 3 == r:\\n\\t\\t\\t\\t\\t\\treturn A[0]\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\treturn 0\\n\\n\\t\\t\\t\\tRa = DP(i-1, r)\\n\\t\\t\\t\\tRb = [ x for j in range(3) \\\\\\n\\t\\t\\t\\t\\t  for x in ( DP(i-1,j) * 10 + A[i] ,)\\n\\t\\t\\t\\t\\t  if x % 3 == r ]\\n\\n\\t\\t\\t\\treturn max([Ra, *Rb])\\n\\n\\t\\t\\tans = DP(len(A) - 1, 0)\\n\\n\\t\\t\\tif ans == 0 and 0 not in A:\\n\\t\\t\\t\\treturn \"\"\\n\\t\\t\\telse:\\n\\t\\t\\t\\treturn str(ans)\\n\\n\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef largestMultipleOfThree(self, digits: List[int]) -> str:\\n\\t\\t\\tA = digits\\n\\t\\t\\tA.sort()\\n\\t\\t\\tA.reverse()\\n\\n\\t\\t\\t@cache\\n\\t\\t\\tdef DP(i, r): # max number whose remainder is r using subarray [0:i] (inclusive) \\n\\t\\t\\t\\tif i == 0:\\n\\t\\t\\t\\t\\tif A[0] % 3 == r:\\n\\t\\t\\t\\t\\t\\treturn A[0]\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\treturn 0\\n\\n\\t\\t\\t\\tRa = DP(i-1, r)\\n\\t\\t\\t\\tRb = [ x for j in range(3) \\\\\\n\\t\\t\\t\\t\\t  for x in ( DP(i-1,j) * 10 + A[i] ,)\\n\\t\\t\\t\\t\\t  if x % 3 == r ]\\n\\n\\t\\t\\t\\treturn max([Ra, *Rb])\\n\\n\\t\\t\\tans = DP(len(A) - 1, 0)\\n\\n\\t\\t\\tif ans == 0 and 0 not in A:\\n\\t\\t\\t\\treturn \"\"\\n\\t\\t\\telse:\\n\\t\\t\\t\\treturn str(ans)\\n\\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 2329746,
                "title": "python-3-readable-solution-o-n-o-1",
                "content": "```\\nclass Solution:\\n    def largestMultipleOfThree(self, digits: List[int]) -> str:\\n        count = collections.Counter(digits)\\n        \\n        mod1 = count[1] + count[4] + count[7]\\n        zeroMod1 = not mod1\\n        mod1 %= 3\\n        \\n        mod2 = count[2] + count[5] + count[8]\\n        zeroMod2 = not mod2\\n        mod2 %= 3\\n        \\n        nums1, nums2 = (1, 4, 7), (2, 5, 8)\\n        \\n        def removeK(nums, k):\\n            for i in nums:\\n                rem = min(count[i], k)\\n                count[i] -= rem\\n                k -= rem  \\n        \\n        if mod1 == mod2:\\n            removeK((), 0)\\n        elif zeroMod1:\\n            removeK(nums2, mod2)\\n        elif zeroMod2:\\n            removeK(nums1, mod1)\\n        elif (mod1 - mod2) % 3 == 1:\\n            removeK(nums1, 1)\\n        else:\\n            removeK(nums2, 1)\\n        \\n        res = \\'\\'.join(str(digit) * count[digit] for digit in range(9, -1, -1))\\n        return res if not res or res[0] != \\'0\\' else \\'0\\'",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math",
                    "Bucket Sort"
                ],
                "code": "```\\nclass Solution:\\n    def largestMultipleOfThree(self, digits: List[int]) -> str:\\n        count = collections.Counter(digits)\\n        \\n        mod1 = count[1] + count[4] + count[7]\\n        zeroMod1 = not mod1\\n        mod1 %= 3\\n        \\n        mod2 = count[2] + count[5] + count[8]\\n        zeroMod2 = not mod2\\n        mod2 %= 3\\n        \\n        nums1, nums2 = (1, 4, 7), (2, 5, 8)\\n        \\n        def removeK(nums, k):\\n            for i in nums:\\n                rem = min(count[i], k)\\n                count[i] -= rem\\n                k -= rem  \\n        \\n        if mod1 == mod2:\\n            removeK((), 0)\\n        elif zeroMod1:\\n            removeK(nums2, mod2)\\n        elif zeroMod2:\\n            removeK(nums1, mod1)\\n        elif (mod1 - mod2) % 3 == 1:\\n            removeK(nums1, 1)\\n        else:\\n            removeK(nums2, 1)\\n        \\n        res = \\'\\'.join(str(digit) * count[digit] for digit in range(9, -1, -1))\\n        return res if not res or res[0] != \\'0\\' else \\'0\\'",
                "codeTag": "Java"
            },
            {
                "id": 2314975,
                "title": "passed-every-test-cases-in-c",
                "content": "char *largestMultipleOfThree(int *digits, int digitsSize)\\n {\\n\\t//make enough space for all digits + null terminator\\n    char *ret = malloc(digitsSize+1), *ptr = ret;\\n    \\n\\t//counting sort + tracking of how many of each modulus + overall sum\\n    int counts[10] = {0}, mod_buckets[3] = {0}, sum = 0;\\n    for(int i = 0; i < digitsSize; ++i)\\n    {\\n        sum += digits[i];\\n        counts[digits[i]] += 1;\\n        mod_buckets[digits[i]%3] += 1;\\n    }\\n    \\n\\t//adjust counts if the sum is not already divisible by three\\n    if(sum % 3 != 0)\\n\\t\\t//check if we can get rid of a single number matching current remainder\\n        if(mod_buckets[sum % 3] > 0)\\n            mod_buckets[sum % 3] -= 1;\\n\\t\\t//otherwise we need to remove two numbers with the other non-zero remainder\\n        else\\n            mod_buckets[3 - (sum % 3)]-=2;\\n    \\n\\t//handle special case of zero to avoid returning \"00..00\"\\n    if(sum == 0||sum ==1||sum==2)\\n        counts[0] = 1;\\n    \\n\\t//put in digits largest first, limited by their count in\\n\\t//the input and by how many are allowed from their modulus\\n    for(int i = 9; i >= 0; --i)\\n        while(counts[i]-- > 0 && mod_buckets[i%3]-- > 0)\\n            *ptr++ = \\'0\\'+i;\\n\\n    //null terminate the string\\n\\t*ptr=\\'\\\\0\\';\\n    return ret;\\n}",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "char *largestMultipleOfThree(int *digits, int digitsSize)\\n {\\n\\t//make enough space for all digits + null terminator\\n    char *ret = malloc(digitsSize+1), *ptr = ret;\\n    \\n\\t//counting sort + tracking of how many of each modulus + overall sum\\n    int counts[10] = {0}, mod_buckets[3] = {0}, sum = 0;\\n    for(int i = 0; i < digitsSize; ++i)\\n    {\\n        sum += digits[i];\\n        counts[digits[i]] += 1;\\n        mod_buckets[digits[i]%3] += 1;\\n    }\\n    \\n\\t//adjust counts if the sum is not already divisible by three\\n    if(sum % 3 != 0)\\n\\t\\t//check if we can get rid of a single number matching current remainder\\n        if(mod_buckets[sum % 3] > 0)\\n            mod_buckets[sum % 3] -= 1;\\n\\t\\t//otherwise we need to remove two numbers with the other non-zero remainder\\n        else\\n            mod_buckets[3 - (sum % 3)]-=2;\\n    \\n\\t//handle special case of zero to avoid returning \"00..00\"\\n    if(sum == 0||sum ==1||sum==2)\\n        counts[0] = 1;\\n    \\n\\t//put in digits largest first, limited by their count in\\n\\t//the input and by how many are allowed from their modulus\\n    for(int i = 9; i >= 0; --i)\\n        while(counts[i]-- > 0 && mod_buckets[i%3]-- > 0)\\n            *ptr++ = \\'0\\'+i;\\n\\n    //null terminate the string\\n\\t*ptr=\\'\\\\0\\';\\n    return ret;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 2310001,
                "title": "c-intuitive-easiest",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    vector<int> ans;\\n    \\n    void calculate(vector<int>& count,int no,vector<int>& temp){\\n        \\n        if(no==0){\\n            int flag=0,sum1=0,sum2=0,validSum=0;\\n            for(int j=1;j<10;j++){\\n                sum1+=temp[j];\\n                sum2+=ans[j];\\n                validSum+=(temp[j]*j);\\n            }\\n            if(validSum%3!=0){\\n                return ;\\n            }\\n            \\n            if(sum2>sum1)\\n                return;\\n            else if(sum1>sum2){\\n             for(int i=1;i<10;i++){\\n              ans[i]=temp[i];    \\n             } \\n                return ;\\n            }\\n            int j=9;\\n            while(j>0){\\n                if(ans[j]<temp[j])\\n                {\\n                    flag=1;\\n                    break;\\n                }else if(ans[j]>temp[j])\\n                    break;\\n                j--;\\n            }\\n            if (flag==1){\\n             for(int i=1;i<10;i++){\\n              ans[i]=temp[i];    \\n             }   \\n            }\\n            return ;\\n        }\\n        \\n        int targetCount=count[no]-2;\\n        \\n        if(targetCount<0)\\n            targetCount=0;\\n        \\n        int co=count[no];\\n       \\n        do{\\n            temp[no]=co;\\n            \\n            calculate(count,no-1,temp);\\n                \\n            co--;\\n        }\\n        while(co>=targetCount);\\n                \\n        \\n    }\\n    \\n    string largestMultipleOfThree(vector<int>& digits) {\\n        vector<int> count(10,0);\\n        int n=digits.size();\\n        for(int i=0;i<n;i++){\\n            count[digits[i]]++;\\n        }\\n        vector<int> temp(10,0);\\n        ans.resize(10,0);\\n        calculate(count,9,temp);\\n        \\n        string res=\"\";\\n        ans[0]=count[0];\\n        for(int i=9;i>=0;i--){\\n            for(int j=1;j<=ans[i];j++){\\n                res+=(\\'0\\'+i);\\n            }\\n        }\\n        if(res.size()>=2 && res[0]==\\'0\\' && res[1]==\\'0\\')\\n            return \"0\";\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<int> ans;\\n    \\n    void calculate(vector<int>& count,int no,vector<int>& temp){\\n        \\n        if(no==0){\\n            int flag=0,sum1=0,sum2=0,validSum=0;\\n            for(int j=1;j<10;j++){\\n                sum1+=temp[j];\\n                sum2+=ans[j];\\n                validSum+=(temp[j]*j);\\n            }\\n            if(validSum%3!=0){\\n                return ;\\n            }\\n            \\n            if(sum2>sum1)\\n                return;\\n            else if(sum1>sum2){\\n             for(int i=1;i<10;i++){\\n              ans[i]=temp[i];    \\n             } \\n                return ;\\n            }\\n            int j=9;\\n            while(j>0){\\n                if(ans[j]<temp[j])\\n                {\\n                    flag=1;\\n                    break;\\n                }else if(ans[j]>temp[j])\\n                    break;\\n                j--;\\n            }\\n            if (flag==1){\\n             for(int i=1;i<10;i++){\\n              ans[i]=temp[i];    \\n             }   \\n            }\\n            return ;\\n        }\\n        \\n        int targetCount=count[no]-2;\\n        \\n        if(targetCount<0)\\n            targetCount=0;\\n        \\n        int co=count[no];\\n       \\n        do{\\n            temp[no]=co;\\n            \\n            calculate(count,no-1,temp);\\n                \\n            co--;\\n        }\\n        while(co>=targetCount);\\n                \\n        \\n    }\\n    \\n    string largestMultipleOfThree(vector<int>& digits) {\\n        vector<int> count(10,0);\\n        int n=digits.size();\\n        for(int i=0;i<n;i++){\\n            count[digits[i]]++;\\n        }\\n        vector<int> temp(10,0);\\n        ans.resize(10,0);\\n        calculate(count,9,temp);\\n        \\n        string res=\"\";\\n        ans[0]=count[0];\\n        for(int i=9;i>=0;i--){\\n            for(int j=1;j<=ans[i];j++){\\n                res+=(\\'0\\'+i);\\n            }\\n        }\\n        if(res.size()>=2 && res[0]==\\'0\\' && res[1]==\\'0\\')\\n            return \"0\";\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2288271,
                "title": "python3-counting",
                "content": "```\\nclass Solution:\\n    def largestMultipleOfThree(self, digits: List[int]) -> str:\\n        \\n        digit_freq = [0]*10\\n        zeros = 0\\n        for digit in digits:\\n            if digit == 0:\\n                zeros += 1 \\n            if digit != 0:\\n                digit_freq[digit] += 1\\n        \\n        if sum(digit_freq) == 0:\\n            return \\'0\\'\\n        \\n        residue = [0,0,0]\\n        for d in range(1,3):\\n            for digit in [d,d+3,d+6]:\\n                residue[d] += digit_freq[digit]\\n        \\n        if residue[1] == residue[2]:\\n            pass\\n        elif (residue[1]*1 + residue[2]*2)%3 == 1:\\n            if residue[1] > 0:\\n                left = 1\\n                for digit in [1,4,7]:\\n                    subt = min(left, digit_freq[digit])\\n                    digit_freq[digit] += -subt\\n                    left += -subt\\n            else:\\n                left = 2\\n                for digit in [2,5,8]:\\n                    subt = min(left, digit_freq[digit])\\n                    digit_freq[digit] += -subt\\n                    left += -subt\\n                        \\n        elif (residue[1]*1 + residue[2]*2)%3 == 2:\\n            if residue[2] > 0:\\n                left = 1\\n                for digit in [2,5,8]:\\n                    subt = min(left, digit_freq[digit])\\n                    digit_freq[digit] += -subt\\n                    left += -subt\\n            else:\\n                left = 2\\n                for digit in [1,4,7]:\\n                    subt = min(left, digit_freq[digit])\\n                    digit_freq[digit] += -subt\\n                    left += -subt\\n        ans = \"\"\\n        for digit in range(9,0,-1):\\n            ans += str(digit)*digit_freq[digit]    \\n        #cannot make multiple of three but zeros exist\\n        if len(ans) == 0 and zeros > 0:\\n            return \\'0\\'\\n        ans += \\'0\\'*zeros\\n        return ans",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def largestMultipleOfThree(self, digits: List[int]) -> str:\\n        \\n        digit_freq = [0]*10\\n        zeros = 0\\n        for digit in digits:\\n            if digit == 0:\\n                zeros += 1 \\n            if digit != 0:\\n                digit_freq[digit] += 1\\n        \\n        if sum(digit_freq) == 0:\\n            return \\'0\\'\\n        \\n        residue = [0,0,0]\\n        for d in range(1,3):\\n            for digit in [d,d+3,d+6]:\\n                residue[d] += digit_freq[digit]\\n        \\n        if residue[1] == residue[2]:\\n            pass\\n        elif (residue[1]*1 + residue[2]*2)%3 == 1:\\n            if residue[1] > 0:\\n                left = 1\\n                for digit in [1,4,7]:\\n                    subt = min(left, digit_freq[digit])\\n                    digit_freq[digit] += -subt\\n                    left += -subt\\n            else:\\n                left = 2\\n                for digit in [2,5,8]:\\n                    subt = min(left, digit_freq[digit])\\n                    digit_freq[digit] += -subt\\n                    left += -subt\\n                        \\n        elif (residue[1]*1 + residue[2]*2)%3 == 2:\\n            if residue[2] > 0:\\n                left = 1\\n                for digit in [2,5,8]:\\n                    subt = min(left, digit_freq[digit])\\n                    digit_freq[digit] += -subt\\n                    left += -subt\\n            else:\\n                left = 2\\n                for digit in [1,4,7]:\\n                    subt = min(left, digit_freq[digit])\\n                    digit_freq[digit] += -subt\\n                    left += -subt\\n        ans = \"\"\\n        for digit in range(9,0,-1):\\n            ans += str(digit)*digit_freq[digit]    \\n        #cannot make multiple of three but zeros exist\\n        if len(ans) == 0 and zeros > 0:\\n            return \\'0\\'\\n        ans += \\'0\\'*zeros\\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 2277498,
                "title": "python-99-faster-easy-solution",
                "content": "```\\nclass Solution:\\n    def largestMultipleOfThree(self, nums: List[int]) -> str:\\n        nums.sort(reverse = True)\\n      \\n        if sum(nums)%3 == 1:\\n            # we need to remove one minimum or two with remainder == 2\\n            flag = False\\n            for i in reversed(range(len(nums))):\\n                if nums[i]%3 == 1:\\n                    nums[i] = -1\\n                    flag = True\\n                    break\\n            if not flag:\\n                count = 2\\n                for i in reversed(range(len(nums))):\\n                    if count == 0:\\n                        break\\n                    if nums[i]%3 == 2:\\n                        nums[i] = -1\\n                        count-=1\\n        elif sum(nums)%3 == 2:\\n            flag = False\\n            for i in reversed(range(len(nums))):\\n                if nums[i]%3 == 2:\\n                    nums[i] = -1\\n                    flag = True\\n                    break\\n            if not flag:\\n                # remove 2 elements having 1 remainder \\n                count = 2\\n                for i in reversed(range(len(nums))):\\n                    if count == 0:\\n                        break\\n                    if nums[i]%3 == 1:\\n                        nums[i] = -1\\n                        count-=1\\n                        \\n            \\n        ans = \\'\\'\\n        for i in nums:\\n            if i!=-1:\\n                ans+=str(i)\\n        if ans:\\n            return str(int(ans))\\n        else:\\n            return ans\\n                    \\n                \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def largestMultipleOfThree(self, nums: List[int]) -> str:\\n        nums.sort(reverse = True)\\n      \\n        if sum(nums)%3 == 1:\\n            # we need to remove one minimum or two with remainder == 2\\n            flag = False\\n            for i in reversed(range(len(nums))):\\n                if nums[i]%3 == 1:\\n                    nums[i] = -1\\n                    flag = True\\n                    break\\n            if not flag:\\n                count = 2\\n                for i in reversed(range(len(nums))):\\n                    if count == 0:\\n                        break\\n                    if nums[i]%3 == 2:\\n                        nums[i] = -1\\n                        count-=1\\n        elif sum(nums)%3 == 2:\\n            flag = False\\n            for i in reversed(range(len(nums))):\\n                if nums[i]%3 == 2:\\n                    nums[i] = -1\\n                    flag = True\\n                    break\\n            if not flag:\\n                # remove 2 elements having 1 remainder \\n                count = 2\\n                for i in reversed(range(len(nums))):\\n                    if count == 0:\\n                        break\\n                    if nums[i]%3 == 1:\\n                        nums[i] = -1\\n                        count-=1\\n                        \\n            \\n        ans = \\'\\'\\n        for i in nums:\\n            if i!=-1:\\n                ans+=str(i)\\n        if ans:\\n            return str(int(ans))\\n        else:\\n            return ans\\n                    \\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2259049,
                "title": "c-greedy-solution-o-n",
                "content": "```cpp\\n\\nclass Solution {\\n    public:\\n    string largestMultipleOfThree(vector<int>& digits) {\\n        vector<int> dgc(10,0);//array to hold counts of each digit\\n        int sum=0;\\n        for(size_t i =0; i< digits.size(); i++){\\n            dgc[digits[i]]++;//counts of each number\\n            sum+=digits[i]; //total sum\\n        }\\n        string res;\\n        if(sum % 3 == 0){\\n            //concatenate descending wise\\n            for(int i=9; i>=0; i--){\\n                for(int j=0; j< dgc[i];j++){\\n                    res+= (i+\\'0\\');\\n                }\\n            }\\n       if(dgc[0] && dgc[0]== res.size())\\n                return \"0\";\\n        }\\n        if(sum % 3 == 1){\\n            // remove 1/4/7 , \\n\\t\\t\\t// if they dont exist, remove either, [2,2] or [2,5] or [5,5] or [2,8] or [5,8] or [8,8] with decreasing order of preference.\\n            if(dgc[1] == 0){\\n                if(dgc[4] == 0) {\\n                    if(dgc[7] == 0){\\n                        if(dgc[2] < 2){\\n                            if (dgc[5] < 1 || dgc[2] < 1) {\\n                                if(dgc[5] < 2) {\\n                                    if(dgc[2] < 1 || dgc[8] < 1){\\n                                        if(dgc[5] < 1 || dgc[8] !=1){\\n                                            dgc[8]-=2;//this case is inevitable if all else fails, otherwise sum % 3 == 1 condition wouldnt have held in the first place\\n                                        }\\n                                        else{\\n                                            dgc[5]--;\\n                                            dgc[8]--;\\n                                        }\\n                                    }\\n                                    else{\\n                                        dgc[8]--;\\n                                        dgc[2]--;\\n                                    }\\n                                }\\n                                else{\\n                                    dgc[5]-=2;\\n                                }\\n                            }\\n                            else{\\n                                dgc[5]--;\\n                                dgc[2]--;\\n                            }\\n                        }\\n                        else{\\n                            dgc[2]-=2;\\n                        }\\n                    }\\n                    else{\\n                        dgc[7]--;\\n                    }\\n                }\\n                else{\\n                    dgc[4]--;\\n                }\\n            }\\n            else{\\n                dgc[1]--;\\n            }\\n            for(int i=9; i>=0; i--){\\n                for(int j=0; j< dgc[i];j++){\\n                    res+= (i+\\'0\\');\\n                }\\n            }\\n       if(dgc[0] && dgc[0]== res.size())\\n                return \"0\";\\n        }\\n        if(sum % 3 == 2){\\n            // remove 2/5/8. If either of those 3 does not exist \\n\\t\\t\\t// remove either, [1,1] or [1,4] or [4,4] or [1,7] or [4,7] or [7,7] with decreasing order of preference.\\n            if(dgc[2] == 0){\\n                if(dgc[5] == 0) {\\n                    if(dgc[8] == 0){\\n                        if(dgc[1] < 2){\\n                            if (dgc[4] < 1 || dgc[1] < 1) {\\n                                if(dgc[4] < 2) {\\n                                    if(dgc[1] < 1 || dgc[7] < 1){\\n                                        if(dgc[4] < 1 || dgc[7] !=1){\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t//this case is inevitable if all else fails, otherwise sum % 3 == 2 condition wouldnt have held in the first place\\n                                            dgc[7]-=2;\\n                                        }\\n                                        else{\\n                                            dgc[4]--;\\n                                            dgc[7]--;\\n                                        }\\n                                    }\\n                                    else{\\n                                        dgc[7]--;\\n                                        dgc[1]--;\\n                                    }\\n                                }\\n                                else{\\n                                    dgc[4]-=2;\\n                                }\\n                            }\\n                            else{\\n                                dgc[4]--;\\n                                dgc[1]--;\\n                            }\\n                        }\\n                        else{\\n                            dgc[1]-=2;\\n                        }\\n                    }\\n                    else{\\n                        dgc[8]--;\\n                    }\\n                }\\n                else{\\n                    dgc[5]--;\\n                }\\n            }\\n            else{\\n                dgc[2]--;\\n            }\\n            for(int i=9; i>=0; i--){\\n                for(int j=0; j< dgc[i];j++){\\n                    res+= (i+\\'0\\');\\n                }\\n            }\\n       if(dgc[0] && dgc[0]== res.size())\\n                return \"0\";\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```cpp\\n\\nclass Solution {\\n    public:\\n    string largestMultipleOfThree(vector<int>& digits) {\\n        vector<int> dgc(10,0);//array to hold counts of each digit\\n        int sum=0;\\n        for(size_t i =0; i< digits.size(); i++){\\n            dgc[digits[i]]++;//counts of each number\\n            sum+=digits[i]; //total sum\\n        }\\n        string res;\\n        if(sum % 3 == 0){\\n            //concatenate descending wise\\n            for(int i=9; i>=0; i--){\\n                for(int j=0; j< dgc[i];j++){\\n                    res+= (i+\\'0\\');\\n                }\\n            }\\n       if(dgc[0] && dgc[0]== res.size())\\n                return \"0\";\\n        }\\n        if(sum % 3 == 1){\\n            // remove 1/4/7 , \\n\\t\\t\\t// if they dont exist, remove either, [2,2] or [2,5] or [5,5] or [2,8] or [5,8] or [8,8] with decreasing order of preference.\\n            if(dgc[1] == 0){\\n                if(dgc[4] == 0) {\\n                    if(dgc[7] == 0){\\n                        if(dgc[2] < 2){\\n                            if (dgc[5] < 1 || dgc[2] < 1) {\\n                                if(dgc[5] < 2) {\\n                                    if(dgc[2] < 1 || dgc[8] < 1){\\n                                        if(dgc[5] < 1 || dgc[8] !=1){\\n                                            dgc[8]-=2;//this case is inevitable if all else fails, otherwise sum % 3 == 1 condition wouldnt have held in the first place\\n                                        }\\n                                        else{\\n                                            dgc[5]--;\\n                                            dgc[8]--;\\n                                        }\\n                                    }\\n                                    else{\\n                                        dgc[8]--;\\n                                        dgc[2]--;\\n                                    }\\n                                }\\n                                else{\\n                                    dgc[5]-=2;\\n                                }\\n                            }\\n                            else{\\n                                dgc[5]--;\\n                                dgc[2]--;\\n                            }\\n                        }\\n                        else{\\n                            dgc[2]-=2;\\n                        }\\n                    }\\n                    else{\\n                        dgc[7]--;\\n                    }\\n                }\\n                else{\\n                    dgc[4]--;\\n                }\\n            }\\n            else{\\n                dgc[1]--;\\n            }\\n            for(int i=9; i>=0; i--){\\n                for(int j=0; j< dgc[i];j++){\\n                    res+= (i+\\'0\\');\\n                }\\n            }\\n       if(dgc[0] && dgc[0]== res.size())\\n                return \"0\";\\n        }\\n        if(sum % 3 == 2){\\n            // remove 2/5/8. If either of those 3 does not exist \\n\\t\\t\\t// remove either, [1,1] or [1,4] or [4,4] or [1,7] or [4,7] or [7,7] with decreasing order of preference.\\n            if(dgc[2] == 0){\\n                if(dgc[5] == 0) {\\n                    if(dgc[8] == 0){\\n                        if(dgc[1] < 2){\\n                            if (dgc[4] < 1 || dgc[1] < 1) {\\n                                if(dgc[4] < 2) {\\n                                    if(dgc[1] < 1 || dgc[7] < 1){\\n                                        if(dgc[4] < 1 || dgc[7] !=1){\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t//this case is inevitable if all else fails, otherwise sum % 3 == 2 condition wouldnt have held in the first place\\n                                            dgc[7]-=2;\\n                                        }\\n                                        else{\\n                                            dgc[4]--;\\n                                            dgc[7]--;\\n                                        }\\n                                    }\\n                                    else{\\n                                        dgc[7]--;\\n                                        dgc[1]--;\\n                                    }\\n                                }\\n                                else{\\n                                    dgc[4]-=2;\\n                                }\\n                            }\\n                            else{\\n                                dgc[4]--;\\n                                dgc[1]--;\\n                            }\\n                        }\\n                        else{\\n                            dgc[1]-=2;\\n                        }\\n                    }\\n                    else{\\n                        dgc[8]--;\\n                    }\\n                }\\n                else{\\n                    dgc[5]--;\\n                }\\n            }\\n            else{\\n                dgc[2]--;\\n            }\\n            for(int i=9; i>=0; i--){\\n                for(int j=0; j< dgc[i];j++){\\n                    res+= (i+\\'0\\');\\n                }\\n            }\\n       if(dgc[0] && dgc[0]== res.size())\\n                return \"0\";\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2252745,
                "title": "c-o-nlogn-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string getAns(vector<vector<int>> &rem) {\\n        string ans;\\n        for (int i = 0; i < 3; i++) for (auto it : rem[i]) ans += (it + 48);\\n        sort(ans.begin(),ans.end());\\n        while (ans.size() > 1 && ans.back() == \\'0\\') ans.pop_back();\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n    string largestMultipleOfThree(vector<int>& digits) {\\n        vector<vector<int>> rem(3); int sum = 0;\\n        for (auto it : digits) {\\n            rem[it%3].push_back(it);\\n            sum += it;\\n        }\\n        for (int i = 0; i < 3; i++) sort(rem[i].rbegin(),rem[i].rend());\\n        if (sum % 3 == 1 || sum % 3 == 2) {\\n            if (rem[sum%3].size() > 0) {\\n                rem[sum%3].pop_back();\\n            } else {\\n                int opp = 2 - sum%3 + 1;\\n                rem[opp].pop_back();\\n                rem[opp].pop_back();\\n            }\\n        } \\n        return getAns(rem);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string getAns(vector<vector<int>> &rem) {\\n        string ans;\\n        for (int i = 0; i < 3; i++) for (auto it : rem[i]) ans += (it + 48);\\n        sort(ans.begin(),ans.end());\\n        while (ans.size() > 1 && ans.back() == \\'0\\') ans.pop_back();\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n    string largestMultipleOfThree(vector<int>& digits) {\\n        vector<vector<int>> rem(3); int sum = 0;\\n        for (auto it : digits) {\\n            rem[it%3].push_back(it);\\n            sum += it;\\n        }\\n        for (int i = 0; i < 3; i++) sort(rem[i].rbegin(),rem[i].rend());\\n        if (sum % 3 == 1 || sum % 3 == 2) {\\n            if (rem[sum%3].size() > 0) {\\n                rem[sum%3].pop_back();\\n            } else {\\n                int opp = 2 - sum%3 + 1;\\n                rem[opp].pop_back();\\n                rem[opp].pop_back();\\n            }\\n        } \\n        return getAns(rem);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2105302,
                "title": "c-solution-using-sorting",
                "content": "```\\nclass Solution {\\npublic:\\n    string largestMultipleOfThree(vector<int>& digits) {\\n        int s=0;\\n        sort(digits.begin(),digits.end());\\n        for (int i=0;i<digits.size();i++){\\n            s=s+digits[i];\\n        }\\n        int x=s%3;\\n        int l3=1;\\n        for (int i=0;i<digits.size();i++){\\n            if (digits[i]%3==x&&x!=0){\\n                digits[i]=(-1);\\n                l3=0;\\n                break;\\n            }\\n        }\\n        if (l3==1&&x!=0){\\n            x=(3-x)%3;\\n            int s1=0;\\n            int l4=1;\\n            for (int i=0;i<digits.size();i++){\\n                if (digits[i]%3==x&&x!=0){\\n                    digits[i]=(-1);\\n                    s1=s1+1;\\n                    if (s1==2){\\n                        l4=0;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        string ans;\\n        int l=0;\\n        for (int i=digits.size()-1;i>=0;i--){\\n            if (digits[i]!=(-1)){\\n                int x=digits[i]+48;\\n                char z=(char)x;\\n                if (digits[i]==0){\\n                    if (l==0||l==2){\\n                        ans.push_back(z);\\n                        if(l==2){\\n                         l=2;\\n                        }\\n                        else {\\n                            l=1;\\n                        }\\n                    }\\n                }\\n                else {\\n                    ans.push_back(z);\\n                    l=2;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestMultipleOfThree(vector<int>& digits) {\\n        int s=0;\\n        sort(digits.begin(),digits.end());\\n        for (int i=0;i<digits.size();i++){\\n            s=s+digits[i];\\n        }\\n        int x=s%3;\\n        int l3=1;\\n        for (int i=0;i<digits.size();i++){\\n            if (digits[i]%3==x&&x!=0){\\n                digits[i]=(-1);\\n                l3=0;\\n                break;\\n            }\\n        }\\n        if (l3==1&&x!=0){\\n            x=(3-x)%3;\\n            int s1=0;\\n            int l4=1;\\n            for (int i=0;i<digits.size();i++){\\n                if (digits[i]%3==x&&x!=0){\\n                    digits[i]=(-1);\\n                    s1=s1+1;\\n                    if (s1==2){\\n                        l4=0;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        string ans;\\n        int l=0;\\n        for (int i=digits.size()-1;i>=0;i--){\\n            if (digits[i]!=(-1)){\\n                int x=digits[i]+48;\\n                char z=(char)x;\\n                if (digits[i]==0){\\n                    if (l==0||l==2){\\n                        ans.push_back(z);\\n                        if(l==2){\\n                         l=2;\\n                        }\\n                        else {\\n                            l=1;\\n                        }\\n                    }\\n                }\\n                else {\\n                    ans.push_back(z);\\n                    l=2;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2079347,
                "title": "c-o-n-time-o-1-space-no-map-no-sorting-simple-math",
                "content": "Just Go Through the Code.\\nLet me know if something is not Clear.\\n```\\nclass Solution {\\npublic:\\n    string largestMultipleOfThree(vector<int>& digits) {\\n        vector<int> f(10,0);\\n        int sum=0;\\n        for(auto it : digits)\\n        {\\n            f[it]++;\\n            sum+=it;\\n        }\\n        sum= sum%3;\\n        bool flag=true;\\n        if(sum==0)\\n        {\\n            flag=false;\\n        }\\n        else if (sum==1)\\n        {\\n           for(int i=1;i<=7;i+=3)\\n           {\\n               if(f[i]>0)\\n               {\\n                   f[i]--;\\n                   flag=false;\\n                   break;\\n               }\\n           }\\n            if(flag)\\n            {\\n                int c=0;\\n               for(int i=2;i<=8 && c<2;i+=3)\\n               {\\n                   if(f[i]>0)\\n                   {\\n                       f[i]--;\\n                       c++;\\n                       i-=3;             // As we can remove that element twice\\n                   }\\n               }\\n                if(c==2) flag=false;\\n            }\\n        }\\n        else \\n        {\\n            for(int i=2;i<=8;i+=3)\\n           {\\n               if(f[i]>0)\\n               {\\n                   f[i]--;\\n                   flag=false;\\n                   break;\\n               }\\n           }\\n            if(flag)\\n            {\\n                int c=0;\\n               for(int i=1;i<=7 && c<2;i+=3)\\n               {\\n                   if(f[i]>0)\\n                   {\\n                       f[i]--;\\n                       c++;\\n                       i-=3;\\n                   }\\n               }\\n                if(c==2) flag=false;\\n            }\\n        }\\n        if(flag) return \"\";\\n        string ans=\"\";\\n        for(int i=9;i>=0;i--)\\n        {\\n            while(f[i]--){\\n            char c= i+\\'0\\';\\n            ans+=c;\\n            }\\n        }\\n        if(ans.length()>1 && ans[0]==\\'0\\') return \"0\";\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestMultipleOfThree(vector<int>& digits) {\\n        vector<int> f(10,0);\\n        int sum=0;\\n        for(auto it : digits)\\n        {\\n            f[it]++;\\n            sum+=it;\\n        }\\n        sum= sum%3;\\n        bool flag=true;\\n        if(sum==0)\\n        {\\n            flag=false;\\n        }\\n        else if (sum==1)\\n        {\\n           for(int i=1;i<=7;i+=3)\\n           {\\n               if(f[i]>0)\\n               {\\n                   f[i]--;\\n                   flag=false;\\n                   break;\\n               }\\n           }\\n            if(flag)\\n            {\\n                int c=0;\\n               for(int i=2;i<=8 && c<2;i+=3)\\n               {\\n                   if(f[i]>0)\\n                   {\\n                       f[i]--;\\n                       c++;\\n                       i-=3;             // As we can remove that element twice\\n                   }\\n               }\\n                if(c==2) flag=false;\\n            }\\n        }\\n        else \\n        {\\n            for(int i=2;i<=8;i+=3)\\n           {\\n               if(f[i]>0)\\n               {\\n                   f[i]--;\\n                   flag=false;\\n                   break;\\n               }\\n           }\\n            if(flag)\\n            {\\n                int c=0;\\n               for(int i=1;i<=7 && c<2;i+=3)\\n               {\\n                   if(f[i]>0)\\n                   {\\n                       f[i]--;\\n                       c++;\\n                       i-=3;\\n                   }\\n               }\\n                if(c==2) flag=false;\\n            }\\n        }\\n        if(flag) return \"\";\\n        string ans=\"\";\\n        for(int i=9;i>=0;i--)\\n        {\\n            while(f[i]--){\\n            char c= i+\\'0\\';\\n            ans+=c;\\n            }\\n        }\\n        if(ans.length()>1 && ans[0]==\\'0\\') return \"0\";\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2045866,
                "title": "c-quick-learner-at-most-remove-two-digits",
                "content": "May 16, 2022\\nI have 13 algorithms to solve before I reach 700 solved algorithms. I choose to be a quick learner, what I do is to study top voted algorithms from votrubac. \\n\\n**Analysis | votrubac | 5 minutes to read first**\\nObviously, trying combinations of numbers won\\'t work as we can have up to 10,000 numbers. Luckily, there is a handy divisibility test:\\n\\nA number is divisible by 3 if the sum of all its digits is divisible by 3.\\n\\nObservation 1: since the order does not matter, the largest number can be formed by adding digits from largest (9) to smallest (0), e.g. 9999966330000.\\n\\nTherefore, we can just count the occurrences of each digit, and then generate the string.\\n\\nObservation 2: we need to use all digits to form the maximum number. If we sum all digits, and the modulo of 3 is not zero, we need to remove 1 (preferably) or 2 smallest digits. If modulo 3 of the sum is 1, for example, we will try to remove 1, 4, or 7, if exists, or two of 2, 5, or 8.\\n\\nMore examples:\\n\\n9965341 % 3 == 1; we remove 1 to get the largest number.\\n9952000 % 3 == 1; now we need to remove two digits, 2 and 5, as there is no 1, 4, or 7.\\nThese observations yield the following algorithm.\\n\\n**What makes the above analysis an excellent one?** \\nFirst, it is to provide fact that at most two digits should be removed; \\nNext, review simple algebra, add sum of all digits, use module 3 to determine the number, instead of using integer % 3. \\nThird is to determine which digit should be removed if sum % 3 == 1. Play with {2, 2} and { 1, 1, 1, 1 }, and try to understand the scope of the problem. \\n\\n**My C# practice | Understand and then write down my notes | 30 minutes study**\\nHere are my learning notes from my C# code debugging and case study:\\n{1, 2, 3, 4, 5, 6, 7, 8, 9} - total 9 digits\\n{3, 6, 9} any of {3, 6, 9} %3 == 0 - so those three digits should be kept all the time. \\n\\nNext is to understand the design of two arrays, m1 an m2. \\n```\\n var m1 = new int[] {1, 4, 7, 2, 5, 8};\\n var m2 = new int[] {2, 5, 8, 1, 4, 7};\\n```\\nm1 is the integer array to contain integers in the order to be removed, if sum of all digits module 3 equal to 1. \\nm2 is the integer array to contain integers in the order to be removed, if sum of all digits module 3 equal to 2. \\n\\nWhy? Because the following facts:\\n1. At most two digits to remove\\n2. If there is 1 digit to remove, find digit in the order from m1 = new int[]{1, 4, 7, 2, 5, 8}\\n\\n**Case study: {2, 2}**\\n- how to remove? Try to remove 2 first, {2}, and then continue to remove 2 from {2}, nothing left in digitCount array. \\n\\n**Case study: {2, 2, 0}**\\nRemove two digit 2, and then keep 0 digit, so the answer should be \"0\". \\n\\nTry to argue three things:\\n1. First remove small digit instead of large digit\\n2. if sum % 3 == 1, then remove odd digit first; else remove even digit first\\n3. More about step 2, at most remove two digits, **try to remove only one digit first; if not found, then try to remove two digits for both cases: sum % 3 with residue 1 or 2**. \\n\\n\\n```\\nusing System;\\nusing System.Collections.Generic;\\nusing System.Diagnostics;\\nusing System.Linq;\\nusing System.Text;\\nusing System.Threading.Tasks;\\n\\nnamespace _1363_largest_multiple_of_three\\n{\\n    class Program\\n    {\\n        static void Main(string[] args)\\n        {\\n            //var testcase1 = LargestMultipleOfThree(new int[]{2, 2});\\n            //Debug.Assert(testcase1.CompareTo(\"\") == 0);\\n\\n            var testcase2 = LargestMultipleOfThree(new int[]{2, 2, 0});\\n            Debug.Assert(testcase2.CompareTo(\"\") == 0);\\n        }\\n\\n        /// <summary>\\n        /// study code\\n        /// https://leetcode.com/problems/largest-multiple-of-three/discuss/518830/C%2B%2BJava-Concise-O(n)\\n        /// </summary>\\n        /// <param name=\"digits\"></param>\\n        /// <returns></returns>\\n        public static string LargestMultipleOfThree(int[] digits)\\n        {\\n            // m1 and m2 are designed \\n            // {1, 2, 3, 4, 5, 6, 7, 8, 9} - total 9 digits\\n            // {3, 6, 9} any of {3, 6, 9} %3 == 0 - remove to consider \\n            var m1 = new int[] {1, 4, 7, 2, 5, 8};\\n            var m2 = new int[] {2, 5, 8, 1, 4, 7};\\n\\n            int sum = 0;\\n            var digitCount = new int[10];\\n\\n            foreach (var d in digits) \\n            {\\n                ++digitCount[d];\\n                sum += d;\\n            }\\n\\n            // simple algebra: sum of all digits - determine %3\\n            while (sum % 3 != 0) \\n            {\\n                // At most two digits to remove\\n                // if it is 1 digit to remove, find digit from m1\\n                // case study: {2, 2} - how to remove? Try to remove 2 first, {2}\\n                // Try to argue three things:\\n                // 1. First remove small digit instead of large digit\\n                // 2. if sum % 3 == 1, then remove odd digit first; else remove even digit first\\n                // 3. More about step 2, at most remove two digits, try to remove only one digit first\\n                foreach (int i in sum % 3 == 1 ? m1 : m2) \\n                {\\n                  if (digitCount[i] > 0) \\n                  {\\n                    --digitCount[i];\\n                    sum -= i;\\n                    break;\\n                  }\\n                }\\n            }\\n\\n            // case study: {2, 2}, two digit \\'2\\' will be removed from digitCount array, so the answer will be empty string\\n            // \\n            var sb = new StringBuilder();\\n\\n            for (int i = 9; i >= 0; --i)\\n            {\\n                if (digitCount[i] > 0)\\n                {\\n                    sb.Append(new string((char)(\\'0\\' + i), digitCount[i]));\\n                }\\n            }\\n\\n            return sb.ToString().Length > 0 && sb[0] == \\'0\\' ? \"0\" : sb.ToString();\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n var m1 = new int[] {1, 4, 7, 2, 5, 8};\\n var m2 = new int[] {2, 5, 8, 1, 4, 7};\\n```\n```\\nusing System;\\nusing System.Collections.Generic;\\nusing System.Diagnostics;\\nusing System.Linq;\\nusing System.Text;\\nusing System.Threading.Tasks;\\n\\nnamespace _1363_largest_multiple_of_three\\n{\\n    class Program\\n    {\\n        static void Main(string[] args)\\n        {\\n            //var testcase1 = LargestMultipleOfThree(new int[]{2, 2});\\n            //Debug.Assert(testcase1.CompareTo(\"\") == 0);\\n\\n            var testcase2 = LargestMultipleOfThree(new int[]{2, 2, 0});\\n            Debug.Assert(testcase2.CompareTo(\"\") == 0);\\n        }\\n\\n        /// <summary>\\n        /// study code\\n        /// https://leetcode.com/problems/largest-multiple-of-three/discuss/518830/C%2B%2BJava-Concise-O(n)\\n        /// </summary>\\n        /// <param name=\"digits\"></param>\\n        /// <returns></returns>\\n        public static string LargestMultipleOfThree(int[] digits)\\n        {\\n            // m1 and m2 are designed \\n            // {1, 2, 3, 4, 5, 6, 7, 8, 9} - total 9 digits\\n            // {3, 6, 9} any of {3, 6, 9} %3 == 0 - remove to consider \\n            var m1 = new int[] {1, 4, 7, 2, 5, 8};\\n            var m2 = new int[] {2, 5, 8, 1, 4, 7};\\n\\n            int sum = 0;\\n            var digitCount = new int[10];\\n\\n            foreach (var d in digits) \\n            {\\n                ++digitCount[d];\\n                sum += d;\\n            }\\n\\n            // simple algebra: sum of all digits - determine %3\\n            while (sum % 3 != 0) \\n            {\\n                // At most two digits to remove\\n                // if it is 1 digit to remove, find digit from m1\\n                // case study: {2, 2} - how to remove? Try to remove 2 first, {2}\\n                // Try to argue three things:\\n                // 1. First remove small digit instead of large digit\\n                // 2. if sum % 3 == 1, then remove odd digit first; else remove even digit first\\n                // 3. More about step 2, at most remove two digits, try to remove only one digit first\\n                foreach (int i in sum % 3 == 1 ? m1 : m2) \\n                {\\n                  if (digitCount[i] > 0) \\n                  {\\n                    --digitCount[i];\\n                    sum -= i;\\n                    break;\\n                  }\\n                }\\n            }\\n\\n            // case study: {2, 2}, two digit \\'2\\' will be removed from digitCount array, so the answer will be empty string\\n            // \\n            var sb = new StringBuilder();\\n\\n            for (int i = 9; i >= 0; --i)\\n            {\\n                if (digitCount[i] > 0)\\n                {\\n                    sb.Append(new string((char)(\\'0\\' + i), digitCount[i]));\\n                }\\n            }\\n\\n            return sb.ToString().Length > 0 && sb[0] == \\'0\\' ? \"0\" : sb.ToString();\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2045686,
                "title": "subset-method",
                "content": "```\\n PriorityQueue<Long> queue = new PriorityQueue<>(Collections.reverseOrder());\\n    \\n    public String largestMultipleOfThree(int[] digits) {\\n        int sum = 0;\\n        \\n        for(int i = 0;i< digits.length;i++){\\n            sum = sum + digits[i];\\n        }\\n        \\n        \\n        if(sum == 0){\\n            return \"0\";\\n        }\\n        \\n        \\n        Arrays.sort(digits);\\n        Solution.reverse(digits);\\n        \\n        List<List<Integer>> finalList = new ArrayList<>();\\n        finalList.add(new ArrayList<Integer>());\\n        for(int i = 0; i< digits.length;i++){\\n          List<List<Integer>> temp = new ArrayList<>();\\n            Integer num = Integer.valueOf(digits[i]);\\n            for(int j = 0; j< finalList.size();j++){\\n                List<Integer> curr = finalList.get(j);\\n                List<Integer> newList = curr.stream().collect(Collectors.toList());\\n                newList.add(num);\\n                temp.add(newList);\\n            }\\n            \\n            for(int copy = 0; copy< temp.size();copy++){\\n                finalList.add(temp.get(copy));\\n            }\\n        }\\n        \\n        for(int i = 0; i< finalList.size();i++){\\n            if(Solution.checkIfDivisibleBy3(finalList.get(i))){\\n                if(Solution.getStringResult(finalList.get(i))!=\"\"){\\n                queue.add(Long.parseLong(Solution.getStringResult(finalList.get(i))));\\n            }\\n            }\\n        }\\n        \\n        return queue.size() > 0 ? queue.peek().toString():\"\";\\n    }\\n    \\n    public static boolean checkIfDivisibleBy3(List<Integer> list){\\n        int sum = 0;\\n        for(int i = 0;i< list.size();i++){\\n            sum = sum + list.get(i);\\n        }\\n        \\n        return sum%3 == 0;\\n        \\n    }\\n    \\n    public static String getStringResult(List<Integer> list){\\n        StringBuilder stb = new StringBuilder(\"\");\\n        for(int i = 0;i< list.size();i++){\\n                stb.append(list.get(i));\\n        }\\n        return stb.toString();\\n    }\\n    \\n    public static void reverse(int[] array)\\n    {\\n  \\n        // Length of the array\\n        int n = array.length;\\n  \\n        // Swaping the first half elements with last half\\n        // elements\\n        for (int i = 0; i < n / 2; i++) {\\n  \\n            // Storing the first half elements temporarily\\n            int temp = array[i];\\n  \\n            // Assigning the first half to the last half\\n            array[i] = array[n - i - 1];\\n  \\n            // Assigning the last half to the first half\\n            array[n - i - 1] = temp;\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n PriorityQueue<Long> queue = new PriorityQueue<>(Collections.reverseOrder());\\n    \\n    public String largestMultipleOfThree(int[] digits) {\\n        int sum = 0;\\n        \\n        for(int i = 0;i< digits.length;i++){\\n            sum = sum + digits[i];\\n        }\\n        \\n        \\n        if(sum == 0){\\n            return \"0\";\\n        }\\n        \\n        \\n        Arrays.sort(digits);\\n        Solution.reverse(digits);\\n        \\n        List<List<Integer>> finalList = new ArrayList<>();\\n        finalList.add(new ArrayList<Integer>());\\n        for(int i = 0; i< digits.length;i++){\\n          List<List<Integer>> temp = new ArrayList<>();\\n            Integer num = Integer.valueOf(digits[i]);\\n            for(int j = 0; j< finalList.size();j++){\\n                List<Integer> curr = finalList.get(j);\\n                List<Integer> newList = curr.stream().collect(Collectors.toList());\\n                newList.add(num);\\n                temp.add(newList);\\n            }\\n            \\n            for(int copy = 0; copy< temp.size();copy++){\\n                finalList.add(temp.get(copy));\\n            }\\n        }\\n        \\n        for(int i = 0; i< finalList.size();i++){\\n            if(Solution.checkIfDivisibleBy3(finalList.get(i))){\\n                if(Solution.getStringResult(finalList.get(i))!=\"\"){\\n                queue.add(Long.parseLong(Solution.getStringResult(finalList.get(i))));\\n            }\\n            }\\n        }\\n        \\n        return queue.size() > 0 ? queue.peek().toString():\"\";\\n    }\\n    \\n    public static boolean checkIfDivisibleBy3(List<Integer> list){\\n        int sum = 0;\\n        for(int i = 0;i< list.size();i++){\\n            sum = sum + list.get(i);\\n        }\\n        \\n        return sum%3 == 0;\\n        \\n    }\\n    \\n    public static String getStringResult(List<Integer> list){\\n        StringBuilder stb = new StringBuilder(\"\");\\n        for(int i = 0;i< list.size();i++){\\n                stb.append(list.get(i));\\n        }\\n        return stb.toString();\\n    }\\n    \\n    public static void reverse(int[] array)\\n    {\\n  \\n        // Length of the array\\n        int n = array.length;\\n  \\n        // Swaping the first half elements with last half\\n        // elements\\n        for (int i = 0; i < n / 2; i++) {\\n  \\n            // Storing the first half elements temporarily\\n            int temp = array[i];\\n  \\n            // Assigning the first half to the last half\\n            array[i] = array[n - i - 1];\\n  \\n            // Assigning the last half to the first half\\n            array[n - i - 1] = temp;\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1994305,
                "title": "python-math-solution-no-backtracking-or-dynammic-programming",
                "content": "```\\ndef remove_one_of(counts, indices):\\n    for i in indices:\\n        if counts[i] > 0:\\n            counts[i] -= 1\\n            return True\\n    return False\\n\\nclass Solution:\\n    def largestMultipleOfThree(self, digits: List[int]) -> str:\\n        counts = [0 for _ in range(10)]\\n        s = sum(digits)\\n        \\n        for digit in digits:\\n            counts[digit] += 1\\n        \\n        if s % 3 == 1:\\n            if not remove_one_of(counts, [1, 4, 7]):\\n                remove_one_of(counts, [2, 5, 8])\\n                remove_one_of(counts, [2, 5, 8])\\n        elif s % 3 == 2:\\n            if not remove_one_of(counts, [2, 5, 8]):\\n                remove_one_of(counts, [1, 4, 7])\\n                remove_one_of(counts, [1, 4, 7])\\n        \\n        if all(counts[i] == 0 for i in range(1, 10)):\\n            if counts[0] == 0:\\n                return \"\"\\n            return \"0\"\\n        \\n        res = \"\"\\n        for i in range(9, -1, -1):\\n            res += str(i) * counts[i]\\n        \\n        return res\\n",
                "solutionTags": [
                    "Python",
                    "Math"
                ],
                "code": "```\\ndef remove_one_of(counts, indices):\\n    for i in indices:\\n        if counts[i] > 0:\\n            counts[i] -= 1\\n            return True\\n    return False\\n\\nclass Solution:\\n    def largestMultipleOfThree(self, digits: List[int]) -> str:\\n        counts = [0 for _ in range(10)]\\n        s = sum(digits)\\n        \\n        for digit in digits:\\n            counts[digit] += 1\\n        \\n        if s % 3 == 1:\\n            if not remove_one_of(counts, [1, 4, 7]):\\n                remove_one_of(counts, [2, 5, 8])\\n                remove_one_of(counts, [2, 5, 8])\\n        elif s % 3 == 2:\\n            if not remove_one_of(counts, [2, 5, 8]):\\n                remove_one_of(counts, [1, 4, 7])\\n                remove_one_of(counts, [1, 4, 7])\\n        \\n        if all(counts[i] == 0 for i in range(1, 10)):\\n            if counts[0] == 0:\\n                return \"\"\\n            return \"0\"\\n        \\n        res = \"\"\\n        for i in range(9, -1, -1):\\n            res += str(i) * counts[i]\\n        \\n        return res\\n",
                "codeTag": "Java"
            },
            {
                "id": 1989992,
                "title": "java-backtracing-2ms-sum-of-digit-of-a-number-is-divisible-by-3",
                "content": "```\\nclass Solution {\\n    //It is based on the fact that if sum of digit of a number is divisible by 3 then number itself divisible by 3\\n    public String largestMultipleOfThree(int[] digits) {\\n        int[] count = new int[10];\\n        long sum = 0;\\n        for (int d : digits) {\\n            count[d]++;\\n            sum += d;\\n        }\\n        int rem = (int)(sum % 3); \\n        boolean isRemZeror = rem == 0;\\n        //we will try to remove digits one by one\\n        for (int i = 1; i <= digits.length && !isRemZeror; i++) {\\n            isRemZeror = backTrack(count, rem, i, 0);\\n        } \\n        if (!isRemZeror) return count[0] > 0 ? \"0\" : \"\";\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 9; i >= 0; i--) {\\n            while (count[i] > 0) {\\n                if (i == 0 && sb.length() == 0) return \"0\";\\n                sb.append((char)(\\'0\\' + i));\\n                count[i]--;\\n            }\\n        }\\n        return sb.toString();\\n    }\\n    //try to construct a number that has the same remainder as total, so that subtracting it will give us the expected number\\n    //We will try to have the number from digits 1 to 9 and length of 1 to digit\\n    //Like 7 % 3 == 1 and 16 % 3 == 1, as the len(\"7\") < len(\"16\") we will choose 7. because 9 < 11\\n    boolean backTrack(int[] count, int rem, int len, int curSum) {\\n        if (len == 0) return false;\\n        for (int i = 1; i < 10; i++) {\\n            if(count[i] > 0) {\\n                count[i]--;\\n                if ((curSum + i) % 3 == rem) return true;\\n                if (backTrack(count, rem, len - 1, curSum + i)) return true;\\n                count[i]++;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    //It is based on the fact that if sum of digit of a number is divisible by 3 then number itself divisible by 3\\n    public String largestMultipleOfThree(int[] digits) {\\n        int[] count = new int[10];\\n        long sum = 0;\\n        for (int d : digits) {\\n            count[d]++;\\n            sum += d;\\n        }\\n        int rem = (int)(sum % 3); \\n        boolean isRemZeror = rem == 0;\\n        //we will try to remove digits one by one\\n        for (int i = 1; i <= digits.length && !isRemZeror; i++) {\\n            isRemZeror = backTrack(count, rem, i, 0);\\n        } \\n        if (!isRemZeror) return count[0] > 0 ? \"0\" : \"\";\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 9; i >= 0; i--) {\\n            while (count[i] > 0) {\\n                if (i == 0 && sb.length() == 0) return \"0\";\\n                sb.append((char)(\\'0\\' + i));\\n                count[i]--;\\n            }\\n        }\\n        return sb.toString();\\n    }\\n    //try to construct a number that has the same remainder as total, so that subtracting it will give us the expected number\\n    //We will try to have the number from digits 1 to 9 and length of 1 to digit\\n    //Like 7 % 3 == 1 and 16 % 3 == 1, as the len(\"7\") < len(\"16\") we will choose 7. because 9 < 11\\n    boolean backTrack(int[] count, int rem, int len, int curSum) {\\n        if (len == 0) return false;\\n        for (int i = 1; i < 10; i++) {\\n            if(count[i] > 0) {\\n                count[i]--;\\n                if ((curSum + i) % 3 == rem) return true;\\n                if (backTrack(count, rem, len - 1, curSum + i)) return true;\\n                count[i]++;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1980502,
                "title": "python-dynamic-programming",
                "content": "What is the Multiple of Three ?\\nThere are some math concepts needed.\\n\\n24, This is multiple of three.\\n2 + 4 = 6 (The sum of each digits is also multiple of three.)\\n\\n33 (0 + 0)  <- (3 % 3) + (3 %3)\\n21 (2 + 1)  <- (2 % 3) + (1 % 3)\\n774 (1 + 1 + 1)  <- (7 % 3) + (7 % 3) + (4 % 3)\\n...\\nThey are exactly multiple of three since their sum of each digit is also multiple of three.\\n\\nso what we need to find is the largest number which of each digit sum is multiple of three.\\n\\n\\n```\\nfrom typing import List\\n\\nclass Solution:\\n\\tdef largestMultipleOfThree(self, digits: List[int]) -> str:\\n\\t\\tn = len(digits)\\n\\t\\tdp = [float(\\'-inf\\')] * 3\\n\\t\\tdigits.sort(reverse=True)\\n\\t\\tdp[digits[0] % 3] = digits[0]\\n\\t\\tfor i in range(1, n):\\n\\t\\t\\tprev = dp[:]\\n\\t\\t\\tdp = [float(\\'-inf\\')] * 3\\n\\t\\t\\td = digits[i] \\n\\t\\t\\tdp[d % 3] = digits[i]\\n\\t\\t\\tfor j in range(3):\\n\\t\\t\\t\\tk = (d + j) % 3\\n\\t\\t\\t\\tif prev[j] != float(\\'-inf\\'):\\n\\t\\t\\t\\t\\tdp[k] = max(d + prev[j] * 10, prev[k])\\n\\t\\t\\t\\telse: dp[k] = max(prev[k], dp[k])\\n\\t\\treturn str(dp[0]) if dp[0] != float(\\'-inf\\') else \\'\\' \\n```\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nfrom typing import List\\n\\nclass Solution:\\n\\tdef largestMultipleOfThree(self, digits: List[int]) -> str:\\n\\t\\tn = len(digits)\\n\\t\\tdp = [float(\\'-inf\\')] * 3\\n\\t\\tdigits.sort(reverse=True)\\n\\t\\tdp[digits[0] % 3] = digits[0]\\n\\t\\tfor i in range(1, n):\\n\\t\\t\\tprev = dp[:]\\n\\t\\t\\tdp = [float(\\'-inf\\')] * 3\\n\\t\\t\\td = digits[i] \\n\\t\\t\\tdp[d % 3] = digits[i]\\n\\t\\t\\tfor j in range(3):\\n\\t\\t\\t\\tk = (d + j) % 3\\n\\t\\t\\t\\tif prev[j] != float(\\'-inf\\'):\\n\\t\\t\\t\\t\\tdp[k] = max(d + prev[j] * 10, prev[k])\\n\\t\\t\\t\\telse: dp[k] = max(prev[k], dp[k])\\n\\t\\treturn str(dp[0]) if dp[0] != float(\\'-inf\\') else \\'\\' \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1853669,
                "title": "python-dp-bottom-up-then-top-down-to-get-solution",
                "content": "```\\nclass Solution:\\n    def largestMultipleOfThree(self, digits: List[int]) -> str:\\n        n = len(digits)\\n        digits.sort()\\n        modZero = [] # What is the maximum number of nums, containing the last element, whose sum % 3 == 0\\n        modOne = [] # What is the maximum number of nums, containing the last element, whose sum % 3 == 1\\n        modTwo = [] # What is the maximum number of nums, containing the last element, whose sum % 3 == 2\\n        \\n        maxZero = 0\\n        maxOne = -1\\n        maxTwo = -1\\n        \\n        for element in digits:\\n            curMod = element % 3\\n            if curMod == 0:\\n                maxZero += 1\\n                modZero.append(maxZero)\\n                if maxOne != -1:\\n                    maxOne += 1\\n                modOne.append(maxOne)\\n                if maxTwo != -1:\\n                    maxTwo += 1\\n                modTwo.append(maxTwo)\\n                \\n            elif curMod == 1:\\n                if maxTwo != -1:\\n                    Zero = maxTwo + 1\\n                else:\\n                    Zero = -1\\n                modZero.append(Zero)\\n                One = maxZero + 1\\n                modOne.append(One)\\n                if maxOne != -1:\\n                    Two = maxOne + 1\\n                else:\\n                    Two = -1\\n                modTwo.append(Two)\\n                \\n                maxZero = max(Zero, maxZero)\\n                maxOne = max(One, maxOne)\\n                maxTwo = max(Two, maxTwo)\\n                \\n            else:\\n                if maxOne != -1:\\n                    Zero = maxOne + 1\\n                else:\\n                    Zero = -1\\n                modZero.append(Zero)\\n                if maxTwo != -1:\\n                    One = maxTwo + 1\\n                else:\\n                    One = -1\\n                modOne.append(One)\\n                Two = maxZero + 1\\n                modTwo.append(Two)\\n                \\n                maxZero = max(Zero, maxZero)\\n                maxOne = max(One, maxOne)\\n                maxTwo = max(Two, maxTwo)\\n        \\n        totalDigits = max(modZero)\\n        for i in range(n-1, -1, -1):\\n            if modZero[i] == totalDigits:\\n                cur = i\\n                break\\n        \\n        targetList = modZero\\n        cuml = 0\\n        res = []\\n        while(0 < totalDigits):\\n            while(targetList[cur] != totalDigits):\\n                cur -= 1\\n            res.append(digits[cur])\\n            cuml += digits[cur]\\n            cur -= 1\\n            if cuml % 3 == 0:\\n                targetList = modZero\\n            elif cuml % 3 == 1:\\n                targetList = modTwo\\n            else:\\n                targetList = modOne\\n            totalDigits -= 1\\n        \\n        if not res:\\n            return \"\"\\n        \\n        for element in res:\\n            if element != 0:\\n                return \"\".join(list(map(str, res)))\\n            \\n        return \"0\"\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def largestMultipleOfThree(self, digits: List[int]) -> str:\\n        n = len(digits)\\n        digits.sort()\\n        modZero = [] # What is the maximum number of nums, containing the last element, whose sum % 3 == 0\\n        modOne = [] # What is the maximum number of nums, containing the last element, whose sum % 3 == 1\\n        modTwo = [] # What is the maximum number of nums, containing the last element, whose sum % 3 == 2\\n        \\n        maxZero = 0\\n        maxOne = -1\\n        maxTwo = -1\\n        \\n        for element in digits:\\n            curMod = element % 3\\n            if curMod == 0:\\n                maxZero += 1\\n                modZero.append(maxZero)\\n                if maxOne != -1:\\n                    maxOne += 1\\n                modOne.append(maxOne)\\n                if maxTwo != -1:\\n                    maxTwo += 1\\n                modTwo.append(maxTwo)\\n                \\n            elif curMod == 1:\\n                if maxTwo != -1:\\n                    Zero = maxTwo + 1\\n                else:\\n                    Zero = -1\\n                modZero.append(Zero)\\n                One = maxZero + 1\\n                modOne.append(One)\\n                if maxOne != -1:\\n                    Two = maxOne + 1\\n                else:\\n                    Two = -1\\n                modTwo.append(Two)\\n                \\n                maxZero = max(Zero, maxZero)\\n                maxOne = max(One, maxOne)\\n                maxTwo = max(Two, maxTwo)\\n                \\n            else:\\n                if maxOne != -1:\\n                    Zero = maxOne + 1\\n                else:\\n                    Zero = -1\\n                modZero.append(Zero)\\n                if maxTwo != -1:\\n                    One = maxTwo + 1\\n                else:\\n                    One = -1\\n                modOne.append(One)\\n                Two = maxZero + 1\\n                modTwo.append(Two)\\n                \\n                maxZero = max(Zero, maxZero)\\n                maxOne = max(One, maxOne)\\n                maxTwo = max(Two, maxTwo)\\n        \\n        totalDigits = max(modZero)\\n        for i in range(n-1, -1, -1):\\n            if modZero[i] == totalDigits:\\n                cur = i\\n                break\\n        \\n        targetList = modZero\\n        cuml = 0\\n        res = []\\n        while(0 < totalDigits):\\n            while(targetList[cur] != totalDigits):\\n                cur -= 1\\n            res.append(digits[cur])\\n            cuml += digits[cur]\\n            cur -= 1\\n            if cuml % 3 == 0:\\n                targetList = modZero\\n            elif cuml % 3 == 1:\\n                targetList = modTwo\\n            else:\\n                targetList = modOne\\n            totalDigits -= 1\\n        \\n        if not res:\\n            return \"\"\\n        \\n        for element in res:\\n            if element != 0:\\n                return \"\".join(list(map(str, res)))\\n            \\n        return \"0\"\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1796621,
                "title": "c-code-qsort-backtracking",
                "content": "```\\nint cmpFunc(const void *a, const void *b){\\n    return *(int *)a - *(int *)b;\\n}\\n\\nvoid largestMultipleOfThreeBT(int* digits, int digitsSize, int sum, int digitNums, int digitCount, int *collect, int *found, char *result, int *resultSum){\\n    int i;\\n    if(digitCount==digitNums){\\n        //check sum\\n        for(i=0;i<digitsSize;i++){            \\n            if(collect[i]==0){\\n                sum -= digits[i];\\n            }\\n        }\\n        \\n        //found\\n        if(sum%3==0){\\n            int resultCount = digitsSize-digitCount-1;\\n            for(i=0;i<digitsSize;i++){\\n                if(collect[i]==1)\\n                    result[resultCount--] = \\'0\\' + digits[i];     \\n            }                   \\n            result[digitsSize-digitCount] = \\'\\\\0\\';\\n            \\n            *resultSum = sum;\\n            *found = 1;\\n        }\\n        return;\\n    }\\n    \\n    for(i=0;i<digitsSize;i++){\\n        if(collect[i]==1){\\n            collect[i] = 0;\\n            largestMultipleOfThreeBT(digits, digitsSize, sum, digitNums, digitCount+1, collect, found, result, resultSum);\\n        //for stop when founding result\\n        if( (*found) == 1) return;\\n            collect[i] = 1;\\n        }\\n    }\\n}\\n\\n\\nchar * largestMultipleOfThree(int* digits, int digitsSize){\\n    \\n    char *result = (char *)malloc(sizeof(char)*(digitsSize+1));\\n    int i, sum = 0;\\n    for(i=0;i<digitsSize;i++)\\n        sum += digits[i];\\n    \\n    qsort(digits, digitsSize, sizeof(int), cmpFunc);\\n    \\n    int collect[digitsSize];\\n    for(i=0;i<digitsSize;i++)\\n        collect[i] = 1;\\n        \\n    int found = 0;\\n    for(i=0;i<digitsSize;i++){\\n        largestMultipleOfThreeBT(digits, digitsSize, sum, i, 0, collect, &found, result, &sum);\\n        \\n        if(found==1){\\n            if(sum==0) return \"0\";\\n            return result;\\n        }       \\n    }\\n    \\n    return \"\";\\n}\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint cmpFunc(const void *a, const void *b){\\n    return *(int *)a - *(int *)b;\\n}\\n\\nvoid largestMultipleOfThreeBT(int* digits, int digitsSize, int sum, int digitNums, int digitCount, int *collect, int *found, char *result, int *resultSum){\\n    int i;\\n    if(digitCount==digitNums){\\n        //check sum\\n        for(i=0;i<digitsSize;i++){            \\n            if(collect[i]==0){\\n                sum -= digits[i];\\n            }\\n        }\\n        \\n        //found\\n        if(sum%3==0){\\n            int resultCount = digitsSize-digitCount-1;\\n            for(i=0;i<digitsSize;i++){\\n                if(collect[i]==1)\\n                    result[resultCount--] = \\'0\\' + digits[i];     \\n            }                   \\n            result[digitsSize-digitCount] = \\'\\\\0\\';\\n            \\n            *resultSum = sum;\\n            *found = 1;\\n        }\\n        return;\\n    }\\n    \\n    for(i=0;i<digitsSize;i++){\\n        if(collect[i]==1){\\n            collect[i] = 0;\\n            largestMultipleOfThreeBT(digits, digitsSize, sum, digitNums, digitCount+1, collect, found, result, resultSum);\\n        //for stop when founding result\\n        if( (*found) == 1) return;\\n            collect[i] = 1;\\n        }\\n    }\\n}\\n\\n\\nchar * largestMultipleOfThree(int* digits, int digitsSize){\\n    \\n    char *result = (char *)malloc(sizeof(char)*(digitsSize+1));\\n    int i, sum = 0;\\n    for(i=0;i<digitsSize;i++)\\n        sum += digits[i];\\n    \\n    qsort(digits, digitsSize, sizeof(int), cmpFunc);\\n    \\n    int collect[digitsSize];\\n    for(i=0;i<digitsSize;i++)\\n        collect[i] = 1;\\n        \\n    int found = 0;\\n    for(i=0;i<digitsSize;i++){\\n        largestMultipleOfThreeBT(digits, digitsSize, sum, i, 0, collect, &found, result, &sum);\\n        \\n        if(found==1){\\n            if(sum==0) return \"0\";\\n            return result;\\n        }       \\n    }\\n    \\n    return \"\";\\n}\\n\\n\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1723982,
                "title": "cpp-tc-o-n-sc-o-1",
                "content": "```\\n\\n```class Solution {\\npublic:\\n    string largestMultipleOfThree(vector<int>& digits) {\\n        string ans=\"\";\\n        int n= digits.size(), sum=0;\\n        int os;\\n        vector<int> arr(10, 0);\\n        for(int i=0; i<n; i++){\\n            sum+=digits[i];\\n            arr[digits[i]]++;\\n        }\\n        os=sum;\\n        if(sum%3!=0){\\n            for(int i=1; i<9; i++) {\\n                if(arr[i]>0 && (sum-i)%3==0){\\n                    cout<<\"1 \";\\n                    arr[i]--;\\n                    sum-=i;\\n                    break;\\n                }\\n            }\\n        }\\n        if(sum%3!=0){\\n            int d=2;\\n            while(d<min(18, sum+1)){\\n                if(d%3!=0 && (sum-d)%3==0){\\n                    int a=d/2;\\n                    int b=d-a;\\n                    cout<<\"h\";\\n                    bool f=false;\\n                    while(a>0 && b<min(d, 10)){\\n                        if(a==b && arr[a]>1 && (a%3!=0)){\\n                                arr[a]-=2;\\n                                f=true;\\n                                break;\\n                            \\n                        }\\n                        else if(a!=b && arr[a]>0 && arr[b]>0 && (a%3!=0) && (b%3!=0)){\\n                            arr[a]--;\\n                            arr[b]--;\\n                            f=true;\\n                            break;\\n                        }\\n                        else{\\n                            a--;\\n                            b++;\\n                        }\\n                    }\\n                    if(f==true){\\n                        break;\\n                    }\\n                }\\n                d++;\\n            }\\n        }\\n\\n        if(os<=2 && arr[0]>0){\\n            return \"0\";\\n        }\\n        for(int i=9; i>=0; i--){\\n            while(arr[i]>0){\\n                ans+=to_string(i);\\n                arr[i]--;\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1672550,
                "title": "java-3-cases-time-o-n-space-o-1",
                "content": "First thing to know is that number K divisible by 3 iff sum of it\\'s digits divisible by 3.\\nSecond thing, is that the biggest target integer can be constructed only by removing 1 or 2 digits. (Prove: Removing 3 zero remaining digit doesn\\'t improve situation, and all combinations of 3 digits with reminder 1 or 2 gives digit divisible by 3)  \\n\\nCases:\\n1) If all digits are divisible by 3 we are done.\\n2) If we have non zero reminder then we have 2 options to solve it:\\n\\t i) remove 1 digit\\n\\t ii) remove 2 digits\\n\\n```\\nclass Solution {\\n    private String printRes(int [] counts){\\n        StringBuilder ans = new StringBuilder();\\n        for(int i=9;i>-1;i--){\\n            ans.append(String.join(\"\", Collections.nCopies(counts[i], String.valueOf(i))));\\n        }\\n        String regex = \"^0+(?!$)\";\\n        return ans.toString().replaceAll(regex, \"\");\\n    }\\n    \\n    public String largestMultipleOfThree(int[] digits) {\\n        int [] counts = new int[10];\\n        int total = 0;\\n        for(int i=0;i<digits.length;i++){\\n            counts[digits[i]] += 1;\\n            total += digits[i];\\n        }\\n        if(total%3 == 0){\\n            return printRes(counts);\\n        }else if(total%3 == 1){\\n            //remove 1 element\\n            boolean found = false;\\n            for(int i=1;i<10;i += 3){\\n                if(counts[i] > 0){\\n                    counts[i]--;\\n                    found = true;\\n                    break;\\n                }\\n            }\\n            if(found) {\\n                return printRes(counts);\\n            }\\n            //remove 2 elements\\n            for(int i=2;i<10;i += 3){\\n                if(counts[i] > 1){\\n                    counts[i] -= 2;\\n                    found = true;\\n                    break;\\n                }\\n            }\\n            if(found) {\\n                return printRes(counts);\\n            }\\n            boolean found1 = false;\\n            for(int i=2;i<10;i += 3){\\n                if(counts[i] > 0){\\n                    counts[i]--;\\n                    if(found1) found = true;\\n                    if(!found1) found1 = true;\\n                    if(found1 && found) break;\\n                }\\n            }\\n            if(found) {\\n                return printRes(counts);\\n            }\\n        }else if(total%3 == 2){\\n            //remove 1 element\\n            boolean found = false;\\n            for(int i=2;i<10;i += 3){\\n                if(counts[i] > 0){\\n                    counts[i]--;\\n                    found = true;\\n                    break;\\n                }\\n            }\\n            if(found) {\\n                return printRes(counts);\\n            }\\n            //remove 2 elements\\n            for(int i=1;i<10;i += 3){\\n                if(counts[i] > 1){\\n                    counts[i] -= 2;\\n                    found = true;\\n                    break;\\n                }\\n            }\\n            if(found) {\\n                return printRes(counts);\\n            }\\n            boolean found1 = false;\\n            for(int i=1;i<10;i += 3){\\n                if(counts[i] > 0){\\n                    counts[i]--;\\n                    if(found1) found = true;\\n                    if(!found1) found1 = true;\\n                    if(found1 && found) break;\\n                }\\n            }\\n            if(found) {\\n                return printRes(counts);\\n            }\\n        }\\n        return \"\";\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private String printRes(int [] counts){\\n        StringBuilder ans = new StringBuilder();\\n        for(int i=9;i>-1;i--){\\n            ans.append(String.join(\"\", Collections.nCopies(counts[i], String.valueOf(i))));\\n        }\\n        String regex = \"^0+(?!$)\";\\n        return ans.toString().replaceAll(regex, \"\");\\n    }\\n    \\n    public String largestMultipleOfThree(int[] digits) {\\n        int [] counts = new int[10];\\n        int total = 0;\\n        for(int i=0;i<digits.length;i++){\\n            counts[digits[i]] += 1;\\n            total += digits[i];\\n        }\\n        if(total%3 == 0){\\n            return printRes(counts);\\n        }else if(total%3 == 1){\\n            //remove 1 element\\n            boolean found = false;\\n            for(int i=1;i<10;i += 3){\\n                if(counts[i] > 0){\\n                    counts[i]--;\\n                    found = true;\\n                    break;\\n                }\\n            }\\n            if(found) {\\n                return printRes(counts);\\n            }\\n            //remove 2 elements\\n            for(int i=2;i<10;i += 3){\\n                if(counts[i] > 1){\\n                    counts[i] -= 2;\\n                    found = true;\\n                    break;\\n                }\\n            }\\n            if(found) {\\n                return printRes(counts);\\n            }\\n            boolean found1 = false;\\n            for(int i=2;i<10;i += 3){\\n                if(counts[i] > 0){\\n                    counts[i]--;\\n                    if(found1) found = true;\\n                    if(!found1) found1 = true;\\n                    if(found1 && found) break;\\n                }\\n            }\\n            if(found) {\\n                return printRes(counts);\\n            }\\n        }else if(total%3 == 2){\\n            //remove 1 element\\n            boolean found = false;\\n            for(int i=2;i<10;i += 3){\\n                if(counts[i] > 0){\\n                    counts[i]--;\\n                    found = true;\\n                    break;\\n                }\\n            }\\n            if(found) {\\n                return printRes(counts);\\n            }\\n            //remove 2 elements\\n            for(int i=1;i<10;i += 3){\\n                if(counts[i] > 1){\\n                    counts[i] -= 2;\\n                    found = true;\\n                    break;\\n                }\\n            }\\n            if(found) {\\n                return printRes(counts);\\n            }\\n            boolean found1 = false;\\n            for(int i=1;i<10;i += 3){\\n                if(counts[i] > 0){\\n                    counts[i]--;\\n                    if(found1) found = true;\\n                    if(!found1) found1 = true;\\n                    if(found1 && found) break;\\n                }\\n            }\\n            if(found) {\\n                return printRes(counts);\\n            }\\n        }\\n        return \"\";\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1667707,
                "title": "mathematical-solution",
                "content": "Theorems:\\n1. The more used digits, the larger the formed number will be\\n2. The digits should be in descending order\\n3. if the sum of the digits in a number is a multiple of 3, the number is also a multiple of 3\\n\\nlet r=sum(digits)%3\\ngroup the digits according to remainder of 3 (hashmap)\\ngroup 0:{0,3,6,9}\\ngroup 1:{1,4,7} \\ngroup 2:{2,5,8}\\n(each digit can have multiples or 0)\\nr=0: use all digits, sort descending\\nr=1: if len(group1)>0: remove smallest, otherwise, mathematically there must be at least 2 elements in group 2, remove two smallest\\nr=2: similar as r=1\\n\\nsort the remaining digits (if there are),descending\\nif only 0s are left, return 0\\n\\n\\n",
                "solutionTags": [],
                "code": "Theorems:\\n1. The more used digits, the larger the formed number will be\\n2. The digits should be in descending order\\n3. if the sum of the digits in a number is a multiple of 3, the number is also a multiple of 3\\n\\nlet r=sum(digits)%3\\ngroup the digits according to remainder of 3 (hashmap)\\ngroup 0:{0,3,6,9}\\ngroup 1:{1,4,7} \\ngroup 2:{2,5,8}\\n(each digit can have multiples or 0)\\nr=0: use all digits, sort descending\\nr=1: if len(group1)>0: remove smallest, otherwise, mathematically there must be at least 2 elements in group 2, remove two smallest\\nr=2: similar as r=1\\n\\nsort the remaining digits (if there are),descending\\nif only 0s are left, return 0\\n\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1662690,
                "title": "easy-java-solution-rt-o-n-space-o-1-beats-94-rt-and-space-with-detailed-explanation",
                "content": "```\\nclass Solution {\\n    public String largestMultipleOfThree(int[] digits) {\\n        int sum = 0;\\n        int[] count = new int[10];\\n        // Here we are using the property that any no is divisible by 3 when its sum of digits is divisible by 3\\n        //get sum of digits and count of each digit\\n        for (int x : digits) {\\n            sum += x;\\n            count[x]++;\\n        }\\n\\n        StringBuilder sb = new StringBuilder();\\n        int[] copied = Arrays.copyOf(count, count.length);\\n        // if sum % 3 != 0 then processing required\\n        if (sum % 3 != 0) {\\n            int rem = sum % 3;\\n            int oldRem = rem;\\n            while (oldRem != 0) {\\n                \\n                while (rem != 0) {\\n                    //if the remainder that we are trying to delete and its required digits is not present \\n                    //then the value will become -ve at that digit\\n                    copied[rem % 10]--;\\n                    // increase the remainder by 3 each time a -ve value is found \\n                    //and reset the rem and copied from orig count array and break\\n                    if (copied[rem % 10] < 0) {\\n                        oldRem += 3;\\n                        rem = oldRem;\\n                        copied = Arrays.copyOf(count, count.length);\\n                        break;\\n                    }\\n                    rem = rem / 10;\\n                    //in case none of the digits is divisible by 3 nor its sum the value of oldRem will reach there and \\n                    //all digits will be deleted eventually making the remainder to 0 again and this loop will terminate\\n                    //consider the case of 1,4 since we start with 5%3 = 2 it is certain that when we keep on adding 3 to it\\n                    // will reach to a point that contains all digits given at the time of the initial problem \\n                    //eg in case of 14, we start with 2 then adding 3 and so on will result like\\n                    //2,5,8,11,14 \\n                    if (rem == 0) {\\n                        oldRem = 0;\\n                    }\\n                }\\n            }\\n        }\\n        //generate the largest number by considering from the last digit ie 9,8,7,6...\\n        for (int i = 9; i >= 0; i--) {\\n            int val = copied[i];\\n            while (val > 0) {\\n                sb.append(i);\\n                val--;\\n            }\\n        }\\n        //check for any leading zeroes and remove\\n        while (sb.length() > 1) {\\n            if (sb.charAt(0) != \\'0\\') {\\n                break;\\n            } else {\\n                sb.deleteCharAt(0);\\n            }\\n        }\\n\\n        return sb.toString();\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public String largestMultipleOfThree(int[] digits) {\\n        int sum = 0;\\n        int[] count = new int[10];\\n        // Here we are using the property that any no is divisible by 3 when its sum of digits is divisible by 3\\n        //get sum of digits and count of each digit\\n        for (int x : digits) {\\n            sum += x;\\n            count[x]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1601005,
                "title": "java-clean-and-detailed-solution",
                "content": "```\\nclass Solution {\\n    public String largestMultipleOfThree(int[] digits) {\\n        int n = digits.length;\\n        int sum = 0;\\n        for(int val : digits)   sum += val;\\n        Arrays.sort(digits);\\n        if(sum % 3 == 0){\\n            if(digits[n - 1] == 0)\\n                return \"\" + 0;\\n        }else if(sum % 3 == 1){\\n            boolean found = false;\\n            for(int i = 0; i < n; i++){\\n                if(digits[i] % 3 == 1){\\n                    digits[i] = -1;\\n                    found = true;\\n                    break;\\n                }\\n            }\\n            if(!found){\\n                int[] vals = new int[2];\\n                Arrays.fill(vals, -1);\\n                for(int i = 0; i < n; i++){\\n                    if(digits[i] % 3 == 2){\\n                        if(vals[0] == -1)   vals[0] = i;\\n                        else{\\n                            vals[1] = i;\\n                            break;\\n                        }\\n                    }\\n                }\\n                if(vals[1] == -1)\\n                    return \"\";\\n                digits[vals[0]] = -1;\\n                digits[vals[1]] = -1;\\n            }\\n        }else{\\n            boolean found = false;;\\n            for(int i = 0; i < n; i++){\\n                if(digits[i] % 3 == 2){\\n                    digits[i] = -1;\\n                    found = true;\\n                    break;\\n                }\\n            }\\n            if(!found){\\n                int[] vals = new int[2];\\n                Arrays.fill(vals, -1);\\n                for(int i = 0; i < n; i++){\\n                    if(digits[i] % 3 == 1){\\n                        if(vals[0] == -1)   vals[0] = i;\\n                        else{\\n                            vals[1] = i;\\n                            break;\\n                        }\\n                    }\\n                }\\n                if(vals[1] == -1)\\n                    return \"\";\\n                digits[vals[0]] = -1;\\n                digits[vals[1]] = -1;\\n            }\\n        }\\n        \\n        StringBuilder sb = new StringBuilder();\\n        for(int i = n - 1; i >= 0; i--)\\n            if(digits[i] != -1)\\n                sb.append(digits[i]);\\n        \\n        if(sb.length() == 0)\\n            return \"\";\\n        if(sb.charAt(0) == \\'0\\'){\\n            return \"\" + 0;\\n        }\\n        return \"\" + sb;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String largestMultipleOfThree(int[] digits) {\\n        int n = digits.length;\\n        int sum = 0;\\n        for(int val : digits)   sum += val;\\n        Arrays.sort(digits);\\n        if(sum % 3 == 0){\\n            if(digits[n - 1] == 0)\\n                return \"\" + 0;\\n        }else if(sum % 3 == 1){\\n            boolean found = false;\\n            for(int i = 0; i < n; i++){\\n                if(digits[i] % 3 == 1){\\n                    digits[i] = -1;\\n                    found = true;\\n                    break;\\n                }\\n            }\\n            if(!found){\\n                int[] vals = new int[2];\\n                Arrays.fill(vals, -1);\\n                for(int i = 0; i < n; i++){\\n                    if(digits[i] % 3 == 2){\\n                        if(vals[0] == -1)   vals[0] = i;\\n                        else{\\n                            vals[1] = i;\\n                            break;\\n                        }\\n                    }\\n                }\\n                if(vals[1] == -1)\\n                    return \"\";\\n                digits[vals[0]] = -1;\\n                digits[vals[1]] = -1;\\n            }\\n        }else{\\n            boolean found = false;;\\n            for(int i = 0; i < n; i++){\\n                if(digits[i] % 3 == 2){\\n                    digits[i] = -1;\\n                    found = true;\\n                    break;\\n                }\\n            }\\n            if(!found){\\n                int[] vals = new int[2];\\n                Arrays.fill(vals, -1);\\n                for(int i = 0; i < n; i++){\\n                    if(digits[i] % 3 == 1){\\n                        if(vals[0] == -1)   vals[0] = i;\\n                        else{\\n                            vals[1] = i;\\n                            break;\\n                        }\\n                    }\\n                }\\n                if(vals[1] == -1)\\n                    return \"\";\\n                digits[vals[0]] = -1;\\n                digits[vals[1]] = -1;\\n            }\\n        }\\n        \\n        StringBuilder sb = new StringBuilder();\\n        for(int i = n - 1; i >= 0; i--)\\n            if(digits[i] != -1)\\n                sb.append(digits[i]);\\n        \\n        if(sb.length() == 0)\\n            return \"\";\\n        if(sb.charAt(0) == \\'0\\'){\\n            return \"\" + 0;\\n        }\\n        return \"\" + sb;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1571648,
                "title": "backtracking-c-solution-to-understand-it-ll-give-tle",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    string ans;\\n    \\n    void solve(int i, vector<int>& a, string asf, int sum){\\n        \\n        int n = a.size();\\n        \\n        if(i == n){\\n            \\n            sort(asf.begin(),asf.end());\\n            reverse(asf.begin(),asf.end());\\n            \\n            if(asf>ans && sum%3 == 0)\\n                ans = asf;\\n            \\n            if(ans.size() > 0 && ans[0] == \\'0\\')\\n                ans = \"0\";\\n            \\n            return ;\\n        }\\n        \\n        string temp_ans = asf;\\n        \\n        temp_ans += to_string(a[i]);\\n        \\n        solve(i+1,a,asf,sum+0);\\n        solve(i+1,a,temp_ans,sum+a[i]);\\n        \\n    }\\n    \\n    string largestMultipleOfThree(vector<int>& digits) {\\n        \\n        solve(0,digits, \"\",0);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    string ans;\\n    \\n    void solve(int i, vector<int>& a, string asf, int sum){\\n        \\n        int n = a.size();\\n        \\n        if(i == n){\\n            \\n            sort(asf.begin(),asf.end());\\n            reverse(asf.begin(),asf.end());\\n            \\n            if(asf>ans && sum%3 == 0)\\n                ans = asf;\\n            \\n            if(ans.size() > 0 && ans[0] == \\'0\\')\\n                ans = \"0\";\\n            \\n            return ;\\n        }\\n        \\n        string temp_ans = asf;\\n        \\n        temp_ans += to_string(a[i]);\\n        \\n        solve(i+1,a,asf,sum+0);\\n        solve(i+1,a,temp_ans,sum+a[i]);\\n        \\n    }\\n    \\n    string largestMultipleOfThree(vector<int>& digits) {\\n        \\n        solve(0,digits, \"\",0);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1556078,
                "title": "python-count-and-dp-with-prune",
                "content": "We only need to consider same digit with count in range(c, max(-1, c - 4), -1)\\n```\\nfrom functools import lru_cache\\n\\nclass Solution:\\n    def largestMultipleOfThree(self, digits: List[int]) -> str:\\n        dm = [str(i) for i in range(10)]\\n        cnt = [0] * 10\\n        for d in digits: cnt[d] += 1\\n        cnt = [(i, v) for i, v in enumerate(cnt) if v != 0]\\n        cnt.sort(reverse=True)\\n        if cnt[0][0] == 0: return \\'0\\'\\n        @lru_cache(None)\\n        def dp(idx, mod):\\n            if idx == len(cnt): return \\'\\' if mod == 0 else None\\n            ret = None\\n            d, c = cnt[idx]\\n            for i in range(c, max(-1, c - 4), -1):\\n                s = dp(idx + 1, (i * d + mod) % 3)\\n                if s is None: continue\\n                s = dm[d] * i + s\\n                if ret is None or len(ret) < len(s) or len(ret) == len(s) and s > ret: ret = s\\n            return ret\\n        s = dp(0, 0)\\n        while len(s) > 1 and s[0] == \\'0\\': s = s[1:]\\n        return s\\n```",
                "solutionTags": [],
                "code": "```\\nfrom functools import lru_cache\\n\\nclass Solution:\\n    def largestMultipleOfThree(self, digits: List[int]) -> str:\\n        dm = [str(i) for i in range(10)]\\n        cnt = [0] * 10\\n        for d in digits: cnt[d] += 1\\n        cnt = [(i, v) for i, v in enumerate(cnt) if v != 0]\\n        cnt.sort(reverse=True)\\n        if cnt[0][0] == 0: return \\'0\\'\\n        @lru_cache(None)\\n        def dp(idx, mod):\\n            if idx == len(cnt): return \\'\\' if mod == 0 else None\\n            ret = None\\n            d, c = cnt[idx]\\n            for i in range(c, max(-1, c - 4), -1):\\n                s = dp(idx + 1, (i * d + mod) % 3)\\n                if s is None: continue\\n                s = dm[d] * i + s\\n                if ret is None or len(ret) < len(s) or len(ret) == len(s) and s > ret: ret = s\\n            return ret\\n        s = dp(0, 0)\\n        while len(s) > 1 and s[0] == \\'0\\': s = s[1:]\\n        return s\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1474898,
                "title": "c-o-n-soln-possible-digits-to-remove",
                "content": "```\\nclass Solution {\\npublic:\\n    string largestMultipleOfThree(vector<int>& digits) {\\n        int sum = 0;\\n        vector<int> freq(10, 0);\\n        for(int i=0; i<digits.size(); i++){\\n            sum+=digits[i];\\n            freq[digits[i]]++;\\n        }\\n        string ans = \"\";\\n        bool flag = 1;\\n        if(sum%3==1){\\n            if(freq[1]>0){\\n                freq[1]--;\\n            } else if(freq[4]>0){\\n                freq[4]--;\\n            } else if(freq[7]>0){\\n                freq[7]--;\\n            } else if(freq[2]>1){\\n                freq[2]-=2;\\n            } else if(freq[5]>0 && freq[2]>0){\\n                freq[5]--;\\n                freq[2]--;\\n            } else if(freq[8]>0 && freq[2]>0){\\n                freq[8]--;\\n                freq[2]--;\\n            } else if(freq[5]>1){\\n                freq[5]-=2;\\n            } else if(freq[8]>0 && freq[5]>0){\\n                freq[8]--;\\n                freq[5]--;\\n            } else if(freq[8]>1){\\n                freq[8]-=2;\\n            } else{\\n                flag=0;\\n            }\\n        } else if(sum%3==2){\\n            if(freq[2]>0){\\n                freq[2]--;\\n            } else if(freq[5]>0){\\n                freq[5]--;\\n            } else if(freq[8]>0){\\n                freq[8]--;\\n            } else if(freq[1]>1){\\n                freq[1]-=2;\\n            } else if(freq[4]>0 && freq[1]>0){\\n                freq[4]--;\\n                freq[1]--;\\n            } else if(freq[7]>0 && freq[1]>0){\\n                freq[7]--;\\n                freq[1]--;\\n            } else if(freq[7]>0 && freq[4]>0){\\n                freq[7]--;\\n                freq[4]--;\\n            } else if(freq[7]>1){\\n                freq[7]-=2;\\n            } else{\\n                flag = 0;\\n            }\\n        }\\n        if(flag==0){\\n            return ans;\\n        }\\n        for(int i=9; i>=0; i--){\\n            if(freq[i]==0){\\n                continue;\\n            }\\n            if(i==0 && ans==\"\"){\\n                ans=\"0\";\\n                break;\\n            }\\n            string s(freq[i], to_string(i)[0]);\\n            ans+=s;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestMultipleOfThree(vector<int>& digits) {\\n        int sum = 0;\\n        vector<int> freq(10, 0);\\n        for(int i=0; i<digits.size(); i++){\\n            sum+=digits[i];\\n            freq[digits[i]]++;\\n        }\\n        string ans = \"\";\\n        bool flag = 1;\\n        if(sum%3==1){\\n            if(freq[1]>0){\\n                freq[1]--;\\n            } else if(freq[4]>0){\\n                freq[4]--;\\n            } else if(freq[7]>0){\\n                freq[7]--;\\n            } else if(freq[2]>1){\\n                freq[2]-=2;\\n            } else if(freq[5]>0 && freq[2]>0){\\n                freq[5]--;\\n                freq[2]--;\\n            } else if(freq[8]>0 && freq[2]>0){\\n                freq[8]--;\\n                freq[2]--;\\n            } else if(freq[5]>1){\\n                freq[5]-=2;\\n            } else if(freq[8]>0 && freq[5]>0){\\n                freq[8]--;\\n                freq[5]--;\\n            } else if(freq[8]>1){\\n                freq[8]-=2;\\n            } else{\\n                flag=0;\\n            }\\n        } else if(sum%3==2){\\n            if(freq[2]>0){\\n                freq[2]--;\\n            } else if(freq[5]>0){\\n                freq[5]--;\\n            } else if(freq[8]>0){\\n                freq[8]--;\\n            } else if(freq[1]>1){\\n                freq[1]-=2;\\n            } else if(freq[4]>0 && freq[1]>0){\\n                freq[4]--;\\n                freq[1]--;\\n            } else if(freq[7]>0 && freq[1]>0){\\n                freq[7]--;\\n                freq[1]--;\\n            } else if(freq[7]>0 && freq[4]>0){\\n                freq[7]--;\\n                freq[4]--;\\n            } else if(freq[7]>1){\\n                freq[7]-=2;\\n            } else{\\n                flag = 0;\\n            }\\n        }\\n        if(flag==0){\\n            return ans;\\n        }\\n        for(int i=9; i>=0; i--){\\n            if(freq[i]==0){\\n                continue;\\n            }\\n            if(i==0 && ans==\"\"){\\n                ans=\"0\";\\n                break;\\n            }\\n            string s(freq[i], to_string(i)[0]);\\n            ans+=s;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1431610,
                "title": "python-short-and-simple",
                "content": "Can be optimized when checking the 9 removal candidates from `mode_to_digits` by using sets instead of list lookup.\\n\\n```\\nclass Solution:\\n    def largestMultipleOfThree(self, digits: List[int]) -> str:\\n        mode_to_digits = {\\n            1: [1, 4, 7, (2, 2), (2, 5), (2, 8), (5, 5), (5, 8), (8, 8)],\\n            2: [2, 5, 8, (1, 1), (1, 4), (1, 7), (4, 4), (4, 7), (7, 7)]\\n        }\\n        total = sum(digits)\\n        if total % 3 == 0:\\n            return str(int(\\'\\'.join(str(i) for i in sorted(digits, reverse=True))))\\n        else:\\n            for option in mode_to_digits[total % 3]:\\n                if type(option) == int and option in digits:\\n                    digits.remove(option)\\n                    if digits:\\n                        return str(int(\\'\\'.join(str(i) for i in sorted(digits, reverse=True))))\\n                    else:\\n                        break\\n                \\n                # tuples\\n                if type(option) == tuple and option[0] in digits and option[1] in digits:\\n                    if option[0] == option[1] and digits.count(option[0]) == 1:\\n                        continue\\n                    digits.remove(option[0])\\n                    digits.remove(option[1])\\n                    if digits:\\n                        return str(int(\\'\\'.join(str(i) for i in sorted(digits, reverse=True))))\\n                \\n        return \\'\\'\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def largestMultipleOfThree(self, digits: List[int]) -> str:\\n        mode_to_digits = {\\n            1: [1, 4, 7, (2, 2), (2, 5), (2, 8), (5, 5), (5, 8), (8, 8)],\\n            2: [2, 5, 8, (1, 1), (1, 4), (1, 7), (4, 4), (4, 7), (7, 7)]\\n        }\\n        total = sum(digits)\\n        if total % 3 == 0:\\n            return str(int(\\'\\'.join(str(i) for i in sorted(digits, reverse=True))))\\n        else:\\n            for option in mode_to_digits[total % 3]:\\n                if type(option) == int and option in digits:\\n                    digits.remove(option)\\n                    if digits:\\n                        return str(int(\\'\\'.join(str(i) for i in sorted(digits, reverse=True))))\\n                    else:\\n                        break\\n                \\n                # tuples\\n                if type(option) == tuple and option[0] in digits and option[1] in digits:\\n                    if option[0] == option[1] and digits.count(option[0]) == 1:\\n                        continue\\n                    digits.remove(option[0])\\n                    digits.remove(option[1])\\n                    if digits:\\n                        return str(int(\\'\\'.join(str(i) for i in sorted(digits, reverse=True))))\\n                \\n        return \\'\\'\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1416060,
                "title": "c-simple-solution",
                "content": "bool helper(int a, int b)\\n{\\n    return a > b;\\n}\\n\\nclass Solution {\\npublic:\\n    \\n    string largestMultipleOfThree(vector<int>& digits) {\\n        \\n        sort(digits.begin(), digits.end(), helper);\\n        \\n        int digitsSum = 0;\\n        for(auto i : digits)\\n            digitsSum += i;\\n        \\n        digitsSum %= 3;\\n        int a = digitsSum ? 0 : 2;\\n        \\n        if(digitsSum)\\n            for(int i = digits.size() - 1; i >= 0; i--)\\n                if(digits[i] % 3 == digitsSum)\\n                {\\n                    digits[i] = -1;\\n                    digitsSum = 0;\\n                    a = 2;\\n                    break;\\n                }\\n        \\n        if(digitsSum)\\n            for(int i = digits.size() - 1; i >= 0; i--)\\n            {\\n                if(digits[i] % 3 && digits[i] % 3 != digitsSum)\\n                    digits[i] = -1, a++;\\n                \\n                if(a == 2)\\n                    break;\\n            }\\n         \\n        if(!a)\\n            return \"\";\\n        \\n        if(!digits[0])\\n            return \"0\";\\n        \\n        string ans;\\n        \\n        for(auto i : digits)\\n            if(i != -1)\\n                ans += to_string(i);\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    string largestMultipleOfThree(vector<int>& digits) {\\n        \\n        sort(digits.begin(), digits.end(), helper);\\n        \\n        int digitsSum = 0;\\n        for(auto i : digits)\\n            digitsSum += i;\\n        \\n        digitsSum %= 3;\\n        int a = digitsSum ? 0 : 2;\\n        \\n        if(digitsSum)\\n            for(int i = digits.size() - 1; i >= 0; i--)\\n                if(digits[i] % 3 == digitsSum)\\n                {\\n                    digits[i] = -1;\\n                    digitsSum = 0;\\n                    a = 2;\\n                    break;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1408747,
                "title": "python-greedy-sorting",
                "content": "First sort in ascending order,then take at max 2 elements having mod 3 as 1 and mod 3 as 2 in two different lists,then just check if sum mod 3 is 1 then return 1 element from remain1 if its len(remain1)>0 else 2 elements from remain2 if len(remain2)==2.Similarly if mod 3 is 2 case.If none of it follows return \"\".For 0 case check if all elements in digits are 0,then return 0.And if Sum mod 3 is 0 just return string of digits sorted in descending order.\\nTime Complexity-O(NlogN)\\nSpace Complexity-O(1)\\n```\\nclass Solution:\\n    def largestMultipleOfThree(self, digits: List[int]) -> str:\\n        remain1,remain2=[],[]\\n        Sum=sum(digits)\\n        if Sum%3==0:\\n            digits.sort(reverse=True)\\n            if sum(digits)==0 and len(digits)>0:\\n                return \"0\"\\n            digits=[str(i) for i in digits]\\n            return \\'\\'.join(digits)\\n        digits.sort()\\n        for val in digits:\\n            if val%3==1:\\n                if len(remain1)<2:\\n                    remain1.append(val)\\n            elif val%3==2:\\n                if len(remain2)<2:\\n                    remain2.append(val)\\n        if Sum%3==1:\\n            if len(remain1)>0:\\n                digits.remove(remain1[0])\\n                digits.sort(reverse=True)\\n                if sum(digits)==0 and len(digits)>0:\\n                    return \"0\"\\n                digits=[str(i) for i in digits]\\n                return \\'\\'.join(digits)\\n            elif len(remain2)==2:\\n                digits.remove(remain2[0])\\n                digits.remove(remain2[1])\\n                digits.sort(reverse=True)\\n                if sum(digits)==0 and len(digits)>0:\\n                    return \"0\"\\n                digits=[str(i) for i in digits]\\n                return \\'\\'.join(digits)\\n            else:\\n                return \"\"\\n        if Sum%3==2:\\n            if len(remain2)>0:\\n                digits.remove(remain2[0])\\n                digits.sort(reverse=True)\\n                if sum(digits)==0 and len(digits)>0:\\n                    return \"0\"\\n                digits=[str(i) for i in digits]\\n                return \\'\\'.join(digits)\\n            elif len(remain1)==2:\\n                digits.remove(remain1[0])\\n                digits.remove(remain1[1])\\n                digits.sort(reverse=True)\\n                if sum(digits)==0 and len(digits)>0:\\n                    return \"0\"\\n                digits=[str(i) for i in digits]\\n                return \\'\\'.join(digits)\\n            else:\\n                return \"\"\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def largestMultipleOfThree(self, digits: List[int]) -> str:\\n        remain1,remain2=[],[]\\n        Sum=sum(digits)\\n        if Sum%3==0:\\n            digits.sort(reverse=True)\\n            if sum(digits)==0 and len(digits)>0:\\n                return \"0\"\\n            digits=[str(i) for i in digits]\\n            return \\'\\'.join(digits)\\n        digits.sort()\\n        for val in digits:\\n            if val%3==1:\\n                if len(remain1)<2:\\n                    remain1.append(val)\\n            elif val%3==2:\\n                if len(remain2)<2:\\n                    remain2.append(val)\\n        if Sum%3==1:\\n            if len(remain1)>0:\\n                digits.remove(remain1[0])\\n                digits.sort(reverse=True)\\n                if sum(digits)==0 and len(digits)>0:\\n                    return \"0\"\\n                digits=[str(i) for i in digits]\\n                return \\'\\'.join(digits)\\n            elif len(remain2)==2:\\n                digits.remove(remain2[0])\\n                digits.remove(remain2[1])\\n                digits.sort(reverse=True)\\n                if sum(digits)==0 and len(digits)>0:\\n                    return \"0\"\\n                digits=[str(i) for i in digits]\\n                return \\'\\'.join(digits)\\n            else:\\n                return \"\"\\n        if Sum%3==2:\\n            if len(remain2)>0:\\n                digits.remove(remain2[0])\\n                digits.sort(reverse=True)\\n                if sum(digits)==0 and len(digits)>0:\\n                    return \"0\"\\n                digits=[str(i) for i in digits]\\n                return \\'\\'.join(digits)\\n            elif len(remain1)==2:\\n                digits.remove(remain1[0])\\n                digits.remove(remain1[1])\\n                digits.sort(reverse=True)\\n                if sum(digits)==0 and len(digits)>0:\\n                    return \"0\"\\n                digits=[str(i) for i in digits]\\n                return \\'\\'.join(digits)\\n            else:\\n                return \"\"\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1368019,
                "title": "c-o-n-log-n-solution",
                "content": "```\\n\\n```class Solution {\\npublic:\\n    string largestMultipleOfThree(vector<int>& digit) {\\n        vector<vector<int>>dp(4);\\n        vector<vector<int>>patt(4);\\n        int mod;\\n        sort(digit.begin(),digit.end(),greater<int>());\\n        for(auto x:digit){\\n            mod=x%3;\\n            if(patt[mod].size()==0){\\n                patt[mod].push_back(x);\\n            }\\n            for(int i=0;i<3;i++){\\n                if(dp[i].size()==0)continue;\\n                if(dp[(i+mod)%3].size()<dp[i].size()+1){\\n                    patt[(i+mod)%3]=dp[i];\\n                    patt[(i+mod)%3].push_back(x);\\n                }\\n            }\\n            dp=patt;\\n        }\\n        if(dp[0].size()==0)return \"\";\\n        if(dp[0][0]==0)return \"0\";\\n        string ans;\\n        for(int i=0;i<dp[0].size();i++)ans+=to_string(dp[0][i]);\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1286655,
                "title": "simple-maths",
                "content": "```\\nclass Solution {\\npublic:\\n    string Form(vector<int> &digits, set<int> &skips){\\n        string ans;\\n        for(int i = 0; i < digits.size(); i ++){\\n            int x = digits[i];\\n            if(skips.count(i))\\n                continue;\\n            ans += (x + \\'0\\');\\n        }\\n        if((!ans.empty()) && (ans[0] == \\'0\\'))\\n            return \"0\";\\n        return ans;\\n    }\\n    string largestMultipleOfThree(vector<int>& digits) {\\n        int n = digits.size();\\n        sort(digits.begin(), digits.end(), greater<int>());\\n        int s = 0;\\n        set<int> skips;\\n        for(int x: digits)\\n            s = (s + x) % 3;\\n        string ans;\\n        if(s == 0){\\n            return Form(digits, skips);\\n        }\\n        // 2 => 2 or 1 + 1\\n        // 1 => 1 or 2 + 2\\n        bool gt = false;\\n        for(int i = n - 1; i >= 0; i --){\\n            if((digits[i] % 3) == s){\\n                skips.clear();\\n                skips.insert(i);\\n                return Form(digits, skips);\\n            }else if((digits[i] % 3) == ((2*s) % 3)){\\n                if(skips.size() < 2)\\n                    skips.insert(i);\\n            }\\n        }\\n        if(skips.size() == 2){\\n            return Form(digits, skips);\\n        }\\n        return \"\";\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string Form(vector<int> &digits, set<int> &skips){\\n        string ans;\\n        for(int i = 0; i < digits.size(); i ++){\\n            int x = digits[i];\\n            if(skips.count(i))\\n                continue;\\n            ans += (x + \\'0\\');\\n        }\\n        if((!ans.empty()) && (ans[0] == \\'0\\'))\\n            return \"0\";\\n        return ans;\\n    }\\n    string largestMultipleOfThree(vector<int>& digits) {\\n        int n = digits.size();\\n        sort(digits.begin(), digits.end(), greater<int>());\\n        int s = 0;\\n        set<int> skips;\\n        for(int x: digits)\\n            s = (s + x) % 3;\\n        string ans;\\n        if(s == 0){\\n            return Form(digits, skips);\\n        }\\n        // 2 => 2 or 1 + 1\\n        // 1 => 1 or 2 + 2\\n        bool gt = false;\\n        for(int i = n - 1; i >= 0; i --){\\n            if((digits[i] % 3) == s){\\n                skips.clear();\\n                skips.insert(i);\\n                return Form(digits, skips);\\n            }else if((digits[i] % 3) == ((2*s) % 3)){\\n                if(skips.size() < 2)\\n                    skips.insert(i);\\n            }\\n        }\\n        if(skips.size() == 2){\\n            return Form(digits, skips);\\n        }\\n        return \"\";\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1258838,
                "title": "a-poor-python3-solution-54",
                "content": "Essentially, we sort the list in descending order and examine whether removing one digit would satisfy the divisibilty by 3 requirement. If not, we recursively call the function with each possible digit removed.\\n\\n```\\nclass Solution:\\n    def largestMultipleOfThree(self, digits: List[int]) -> str:    \\n        digits.sort(reverse = True)\\n        \\n        nums = set(digits)\\n        \\n\\t\\t# for when they try to catch you out with [0,0,0,0,0] :(\\n        if nums == {0}:\\n            return \"0\"\\n        \\n\\t\\t# fewer numbers to check \\n        nums -= {0,3,6,9}\\n        nums = list(nums)\\n        nums.sort()\\n        \\n        \\n        if sum(digits) % 3 == 0: \\n            return \"\".join(str(c) for c in digits)\\n        \\n        ans = []\\n        \\n        \\n        \\n        def rec(notLetters: List[int]):\\n            \\n            curr = sum(notLetters)\\n            \\n            if notLetters == []: \\n                return \\n            \\n            for n in nums:\\n                if n in notLetters and (curr - n) % 3 == 0:\\n                    notLetters.remove(n)\\n                    \\n                    ans.append(\"\".join(str(c) for c in notLetters))\\n                    return\\n                    \\n            for n in nums:\\n                if n in notLetters:\\n                    temp = notLetters.copy()\\n                    temp.remove(n)\\n                    rec(temp)\\n        \\n        rec(digits)\\n        \\n        return max(ans,key = len)\\n```",
                "solutionTags": [
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def largestMultipleOfThree(self, digits: List[int]) -> str:    \\n        digits.sort(reverse = True)\\n        \\n        nums = set(digits)\\n        \\n\\t\\t# for when they try to catch you out with [0,0,0,0,0] :(\\n        if nums == {0}:\\n            return \"0\"\\n        \\n\\t\\t# fewer numbers to check \\n        nums -= {0,3,6,9}\\n        nums = list(nums)\\n        nums.sort()\\n        \\n        \\n        if sum(digits) % 3 == 0: \\n            return \"\".join(str(c) for c in digits)\\n        \\n        ans = []\\n        \\n        \\n        \\n        def rec(notLetters: List[int]):\\n            \\n            curr = sum(notLetters)\\n            \\n            if notLetters == []: \\n                return \\n            \\n            for n in nums:\\n                if n in notLetters and (curr - n) % 3 == 0:\\n                    notLetters.remove(n)\\n                    \\n                    ans.append(\"\".join(str(c) for c in notLetters))\\n                    return\\n                    \\n            for n in nums:\\n                if n in notLetters:\\n                    temp = notLetters.copy()\\n                    temp.remove(n)\\n                    rec(temp)\\n        \\n        rec(digits)\\n        \\n        return max(ans,key = len)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1191974,
                "title": "scala-solution",
                "content": "```\\ndef largestMultipleOfThree(digits: Array[Int]): String = {\\n        val d1:Array[Int] = digits.filter(n =>n%3 == 1).sorted\\n        val d2:Array[Int] = digits.filter(n =>n%3 == 2).sorted\\n        val d3:Array[Int] = digits.filter(n =>n%3 == 0)\\n        val res = (if(digits.sum%3== 1){\\n          if(d1.length != 0)  Array.concat(Array.concat(d1.drop(1),d2),d3)\\n          else Array.concat(d2.drop(2),d3)\\n        }else if (digits.sum%3 == 2){\\n          if(d2.length != 0)  Array.concat(Array.concat(d1,d2.drop(1)),d3)\\n          else Array.concat(d1.drop(2),d3)\\n        } else digits).sortWith(_ > _)\\n        if (res.length == 0) return \"\"\\n        if(res.foldLeft(\"0\")((b,a)=>{b.concat(a.toString)}).dropWhile(_ ==\\'0\\').length > 0) return res.foldLeft(\"0\")((b,a)=>{b.concat(a.toString)}).dropWhile(_ ==\\'0\\')\\n    \"0\"\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\ndef largestMultipleOfThree(digits: Array[Int]): String = {\\n        val d1:Array[Int] = digits.filter(n =>n%3 == 1).sorted\\n        val d2:Array[Int] = digits.filter(n =>n%3 == 2).sorted\\n        val d3:Array[Int] = digits.filter(n =>n%3 == 0)\\n        val res = (if(digits.sum%3== 1){\\n          if(d1.length != 0)  Array.concat(Array.concat(d1.drop(1),d2),d3)\\n          else Array.concat(d2.drop(2),d3)\\n        }else if (digits.sum%3 == 2){\\n          if(d2.length != 0)  Array.concat(Array.concat(d1,d2.drop(1)),d3)\\n          else Array.concat(d1.drop(2),d3)\\n        } else digits).sortWith(_ > _)\\n        if (res.length == 0) return \"\"\\n        if(res.foldLeft(\"0\")((b,a)=>{b.concat(a.toString)}).dropWhile(_ ==\\'0\\').length > 0) return res.foldLeft(\"0\")((b,a)=>{b.concat(a.toString)}).dropWhile(_ ==\\'0\\')\\n    \"0\"\\n    }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1159980,
                "title": "simple-o-n-but-slow",
                "content": "Any number N can be represented as (x1 + x2*10 + x3*10^2 + ... + xn*10^(n-1)\\nSo mod 3 of the number can be represented as sum of mod of respective digits.\\n\\n```\\nclass Solution {\\npublic:\\n    string largestMultipleOfThree(vector<int>& a) {\\n        int i, n = a.size();\\n\\t\\t// sort in decreasing order\\n        sort(a.begin(), a.end(), greater<int>());\\n        int b[n];\\n\\t\\t// stores the remainder\\n        for(i=0;i<n;i++)\\n            b[i] = a[i]%3;\\n        \\n        string rem[3];\\n        rem[0] = \"\";\\n        rem[1] = \"\";\\n        rem[2] = \"\";\\n\\n        for(i=0;i<n;i++){\\n            string temp[3];\\n\\t\\t\\t// using previous calculations we find new max numbers which give rem as 0, 1, 2\\n            for(int j=0;j<3;j++){\\n                if(j!=0 && rem[j]==\"\")\\n                    continue;\\n                string tmp = rem[j] + to_string(a[i]);\\n                temp[(j+b[i])%3] = tmp;\\n            }\\n            \\n            for(int j=0;j<3;j++){\\n                if(temp[j].length() > rem[j].length())\\n                    rem[j] = temp[j];\\n                else if(temp[j].length() == rem[j].length() && temp[j] > rem[j])\\n                    rem[j] = temp[j];\\n            }\\n        }\\n        \\n        if(rem[0]==\"\")\\n            return rem[0];\\n        \\n        if(rem[0][0]==\\'0\\')\\n            return \"0\";\\n        \\n        return rem[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestMultipleOfThree(vector<int>& a) {\\n        int i, n = a.size();\\n\\t\\t// sort in decreasing order\\n        sort(a.begin(), a.end(), greater<int>());\\n        int b[n];\\n\\t\\t// stores the remainder\\n        for(i=0;i<n;i++)\\n            b[i] = a[i]%3;\\n        \\n        string rem[3];\\n        rem[0] = \"\";\\n        rem[1] = \"\";\\n        rem[2] = \"\";\\n\\n        for(i=0;i<n;i++){\\n            string temp[3];\\n\\t\\t\\t// using previous calculations we find new max numbers which give rem as 0, 1, 2\\n            for(int j=0;j<3;j++){\\n                if(j!=0 && rem[j]==\"\")\\n                    continue;\\n                string tmp = rem[j] + to_string(a[i]);\\n                temp[(j+b[i])%3] = tmp;\\n            }\\n            \\n            for(int j=0;j<3;j++){\\n                if(temp[j].length() > rem[j].length())\\n                    rem[j] = temp[j];\\n                else if(temp[j].length() == rem[j].length() && temp[j] > rem[j])\\n                    rem[j] = temp[j];\\n            }\\n        }\\n        \\n        if(rem[0]==\"\")\\n            return rem[0];\\n        \\n        if(rem[0][0]==\\'0\\')\\n            return \"0\";\\n        \\n        return rem[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1152152,
                "title": "python-code-with-basic-math-and-logic",
                "content": "Maths and Logic:\\n        \\n\\t\\t# 1. Sort the digits (say digit_sorted).\\n\\t\\t# 2. Create a new array s_digits, with digit % 3 \\n        # 3. sum(s_digits) % 3 = k\\n        # 4. Find maximum digits with sum(s_digits) == k. \\n\\t\\t# case 4.1 If k=0 then return all digits (base case taken care when all are \"0\"). \\n\\t\\t# Case 4.2 if k=1 then remove the last 1 and hence its corresponding digit in digits array. If there is no 1 then remove all 2\\'s.\\n\\t\\t# Case 4.3 if k=2 then either remove one 2 from last if present or remove two 1\\'s from the last.\\n        # Base case, if all elements are 0\\n```\\nimport numpy as np\\nclass Solution:\\n    def removeL2_1s(self, digits_sorted, s):\\n        out = []\\n        for idx, x in enumerate(digits_sorted):\\n            if ((idx == s[-2]) or (idx == s[-1])):\\n                continue\\n            out.append(x)\\n        val = \\'\\'.join(str(x) for x in out)\\n        return (val) \\n        \\n    def largestMultipleOfThree(self, digits: List[int]) -> str:\\n        # Idea : 1. Sort the digits . 2. Create a new array s_digits, with digit % 3 \\n        # 3. sum(s_digits) % 3 = k\\n        # 4. Find maximum digits with sum(s_digits) == k. If k=0 then return all digits, if k=1 then remove the last 1 and hence its corresponding digit in digits array, if k=2 then either remove one 2 from last if present or remove two 1\\'s from the last.\\n        # Base case, if all elements are 0\\n        allZero = True\\n        for digit in digits:\\n            if digit != 0:\\n                allZero = False\\n                break\\n        if (allZero):\\n            return \"0\"\\n        \\n        digits_sorted = np.sort(digits)[::-1]\\n        s_digits = digits_sorted % 3 #step[1][2]\\n        k = sum(s_digits) %3 #step[3]\\n        if (k == 0):\\n            return \\'\\'.join(str(x) for x in digits_sorted)\\n        else:\\n            # if indexes_to_remove == 0 then return \"\"\\n            if (k ==1):\\n                indexes_to_remove = [idx for idx, x in enumerate(s_digits) if x == 1]\\n                if len(indexes_to_remove) == 0:\\n                    # [2 2 0] sort of examples with only 2s.\\n                    indexes_to_remove = [idx for idx, x in enumerate(s_digits) if x == 2]\\n                    return \\'\\'.join(str(x) for idx, x in enumerate(digits_sorted) if idx not in indexes_to_remove)\\n                return \\'\\'.join(str(x) for idx, x in enumerate(digits_sorted) if idx != indexes_to_remove[-1])\\n            else:\\n                # remainder = 2, so 2 cases. \\n                indexes_to_remove = [idx for idx, x in enumerate(s_digits) if x == 2]\\n                if len(indexes_to_remove) > 0:\\n                    return \\'\\'.join(str(x) for idx, x in enumerate(digits_sorted) if idx != indexes_to_remove[-1])\\n                else:    \\n                    # remove two last 1\\'s and hence corresponding in digits_sorted\\n                    indexes_to_remove = [idx for idx, x in enumerate(s_digits) if x == 1]\\n                    assert(len(indexes_to_remove) >= 2)\\n                    return self.removeL2_1s(digits_sorted, indexes_to_remove)\\n\\t\\t```",
                "solutionTags": [],
                "code": "```\\nimport numpy as np\\nclass Solution:\\n    def removeL2_1s(self, digits_sorted, s):\\n        out = []\\n        for idx, x in enumerate(digits_sorted):\\n            if ((idx == s[-2]) or (idx == s[-1])):\\n                continue\\n            out.append(x)\\n        val = \\'\\'.join(str(x) for x in out)\\n        return (val) \\n        \\n    def largestMultipleOfThree(self, digits: List[int]) -> str:\\n        # Idea : 1. Sort the digits . 2. Create a new array s_digits, with digit % 3 \\n        # 3. sum(s_digits) % 3 = k\\n        # 4. Find maximum digits with sum(s_digits) == k. If k=0 then return all digits, if k=1 then remove the last 1 and hence its corresponding digit in digits array, if k=2 then either remove one 2 from last if present or remove two 1\\'s from the last.\\n        # Base case, if all elements are 0\\n        allZero = True\\n        for digit in digits:\\n            if digit != 0:\\n                allZero = False\\n                break\\n        if (allZero):\\n            return \"0\"\\n        \\n        digits_sorted = np.sort(digits)[::-1]\\n        s_digits = digits_sorted % 3 #step[1][2]\\n        k = sum(s_digits) %3 #step[3]\\n        if (k == 0):\\n            return \\'\\'.join(str(x) for x in digits_sorted)\\n        else:\\n            # if indexes_to_remove == 0 then return \"\"\\n            if (k ==1):\\n                indexes_to_remove = [idx for idx, x in enumerate(s_digits) if x == 1]\\n                if len(indexes_to_remove) == 0:\\n                    # [2 2 0] sort of examples with only 2s.\\n                    indexes_to_remove = [idx for idx, x in enumerate(s_digits) if x == 2]\\n                    return \\'\\'.join(str(x) for idx, x in enumerate(digits_sorted) if idx not in indexes_to_remove)\\n                return \\'\\'.join(str(x) for idx, x in enumerate(digits_sorted) if idx != indexes_to_remove[-1])\\n            else:\\n                # remainder = 2, so 2 cases. \\n                indexes_to_remove = [idx for idx, x in enumerate(s_digits) if x == 2]\\n                if len(indexes_to_remove) > 0:\\n                    return \\'\\'.join(str(x) for idx, x in enumerate(digits_sorted) if idx != indexes_to_remove[-1])\\n                else:    \\n                    # remove two last 1\\'s and hence corresponding in digits_sorted\\n                    indexes_to_remove = [idx for idx, x in enumerate(s_digits) if x == 1]\\n                    assert(len(indexes_to_remove) >= 2)\\n                    return self.removeL2_1s(digits_sorted, indexes_to_remove)\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 1149120,
                "title": "java-solution-using-queue",
                "content": "```\\nclass Solution {\\n    public String largestMultipleOfThree(int[] arr) {\\n        Arrays.sort(arr);\\n        Queue<Integer> q0 = new LinkedList<>();\\n\\t\\tQueue<Integer> q1 = new LinkedList<>();\\n\\t\\tQueue<Integer> q2 = new LinkedList<>();\\n\\t\\tint sum = 0;\\n\\t\\tfor (int i = 0; i < arr.length; i++) {\\n\\t\\t\\tsum = sum + arr[i];\\n\\t\\t\\tif ((arr[i] % 3) == 0)\\n\\t\\t\\t\\tq0.add(arr[i]);\\n\\t\\t\\telse if ((arr[i] % 3) == 1)\\n\\t\\t\\t\\tq1.add(arr[i]);\\n\\t\\t\\telse\\n\\t\\t\\t\\tq2.add(arr[i]);\\n\\t\\t}\\n\\t\\tif (sum % 3 == 1) {\\n\\t\\t\\tif (!q1.isEmpty())\\n\\t\\t\\t\\tq1.remove();\\n            else {\\n\\t\\t\\t\\tif (!q2.isEmpty()) \\n\\t\\t\\t\\t\\tq2.remove();\\n\\t\\t\\t\\t\\n                if (!q2.isEmpty())\\n\\t\\t\\t\\t\\tq2.remove();\\n            }\\n\\t\\t} else if (sum % 3 == 2) {\\n\\t\\t\\tif (!q2.isEmpty()) \\n\\t\\t\\t\\tq2.remove();\\n            else {\\n\\t\\t\\t\\tif (!q1.isEmpty()) \\n\\t\\t\\t\\t\\tq1.remove();\\n                if (!q1.isEmpty()) \\n\\t\\t\\t\\t\\tq1.remove();\\n            }\\n\\t\\t}\\n\\t\\tList<Integer> ls=new ArrayList<>();\\n        while (q0.size()!=0)\\n\\t\\t\\tls.add(q0.remove());\\n\\t\\twhile (q1.size()!=0)\\n\\t\\t\\tls.add(q1.remove());\\n\\t\\twhile (q2.size()!=0)\\n\\t\\t\\tls.add(q2.remove());\\n        int[] temp=ls.stream().mapToInt(i->i).toArray();\\n\\t\\tArrays.sort(temp);\\n        String out=\"\";\\n\\t\\tfor (int i = temp.length-1; i >= 0; i--) \\n\\t\\t\\tout+=Integer.toString(temp[i]);\\n        if(out.length()>1&&out.charAt(0) == \\'0\\')\\n            return \"0\";\\n        return out;    \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\n    public String largestMultipleOfThree(int[] arr) {\\n        Arrays.sort(arr);\\n        Queue<Integer> q0 = new LinkedList<>();\\n\\t\\tQueue<Integer> q1 = new LinkedList<>();\\n\\t\\tQueue<Integer> q2 = new LinkedList<>();\\n\\t\\tint sum = 0;\\n\\t\\tfor (int i = 0; i < arr.length; i++) {\\n\\t\\t\\tsum = sum + arr[i];\\n\\t\\t\\tif ((arr[i] % 3) == 0)\\n\\t\\t\\t\\tq0.add(arr[i]);\\n\\t\\t\\telse if ((arr[i] % 3) == 1)\\n\\t\\t\\t\\tq1.add(arr[i]);\\n\\t\\t\\telse\\n\\t\\t\\t\\tq2.add(arr[i]);\\n\\t\\t}\\n\\t\\tif (sum % 3 == 1) {\\n\\t\\t\\tif (!q1.isEmpty())\\n\\t\\t\\t\\tq1.remove();\\n            else {\\n\\t\\t\\t\\tif (!q2.isEmpty()) \\n\\t\\t\\t\\t\\tq2.remove();\\n\\t\\t\\t\\t\\n                if (!q2.isEmpty())\\n\\t\\t\\t\\t\\tq2.remove();\\n            }\\n\\t\\t} else if (sum % 3 == 2) {\\n\\t\\t\\tif (!q2.isEmpty()) \\n\\t\\t\\t\\tq2.remove();\\n            else {\\n\\t\\t\\t\\tif (!q1.isEmpty()) \\n\\t\\t\\t\\t\\tq1.remove();\\n                if (!q1.isEmpty()) \\n\\t\\t\\t\\t\\tq1.remove();\\n            }\\n\\t\\t}\\n\\t\\tList<Integer> ls=new ArrayList<>();\\n        while (q0.size()!=0)\\n\\t\\t\\tls.add(q0.remove());\\n\\t\\twhile (q1.size()!=0)\\n\\t\\t\\tls.add(q1.remove());\\n\\t\\twhile (q2.size()!=0)\\n\\t\\t\\tls.add(q2.remove());\\n        int[] temp=ls.stream().mapToInt(i->i).toArray();\\n\\t\\tArrays.sort(temp);\\n        String out=\"\";\\n\\t\\tfor (int i = temp.length-1; i >= 0; i--) \\n\\t\\t\\tout+=Integer.toString(temp[i]);\\n        if(out.length()>1&&out.charAt(0) == \\'0\\')\\n            return \"0\";\\n        return out;    \\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1575262,
                "content": [
                    {
                        "username": "theesoteric",
                        "content": "Approach: We will divide all the digits in 3 categories\\n\\xA0 \\xA0 digits divisible by 3 using array \\'ans\\'\\n\\xA0 \\xA0 digits giving remainder 1 when divided by 3 using array \\'rem1\\'\\n\\xA0 \\xA0 digits giving remainder 2 when divided by 3 using array \\'rem2\\'\\n\\xA0 \\xA0 All the digits from \\'ans\\' can be used in the output string without any issue\\n\\xA0 \\xA0 Now we will check for the maximum possible number of digits from \\'rem1\\' and \\'rem2\\' we can use in the answer. Also if there is a tie then we will choose the higher value digits. \\n\\xA0 \\xA0 Then we will sort all the eligible digits in descending order to create the maximum number"
                    },
                    {
                        "username": "Rutvik0512",
                        "content": "Not Hard Level Question, should be tagged as Medium\\n"
                    },
                    {
                        "username": "varmapraneeth2003",
                        "content": "Why this is in dp hard bro this is a typical greedy question"
                    },
                    {
                        "username": "dhananjaykumar13092001",
                        "content": "string largestMultipleOfThree(vector<int>& digits) {\\n        vector<vector<int>> rem(3);\\n        for(int i = 0; i < digits.size(); i++)\\n            rem[(digits[i]) % 3].push_back(digits[i]);\\n        for(int i = 0; i < 3; i++)\\n            sort(rem[i].begin(), rem[i].end(), greater<int>());\\n        int i = 0, j = 0, k = 0;\\n        string ans;\\n        while(j < rem[1].size() && k < rem[2].size())\\n        {\\n            ans.push_back(rem[1][j] + \\'0\\');\\n            ans.push_back(rem[2][k] + \\'0\\');\\n            j++;\\n            k++;\\n        }\\n        while(j < rem[1].size() - 2)\\n        {\\n            ans.push_back(rem[1][j] + \\'0\\');\\n            ans.push_back(rem[1][j + 1] + \\'0\\');\\n            ans.push_back(rem[1][j + 2] + \\'0\\');\\n            j += 3;\\n        }\\n        while(k < rem[2].size() - 2)\\n        {\\n            ans.push_back(rem[2][k] + \\'0\\');\\n            ans.push_back(rem[2][k + 1] + \\'0\\');\\n            ans.push_back(rem[2][k + 2] + \\'0\\');\\n            k += 3;\\n        }\\n        while(i < rem[0].size())\\n        {\\n            ans.push_back(rem[0][i] + \\'0\\');\\n            i++;\\n        }\\n        sort(ans.begin(), ans.end(), greater<int>());\\n        if(ans.size() && ans[0] == \\'0\\')\\n            return \"0\";\\n        return ans;\\n    }\\n\\ncan anyone please tell why it is showing heap buffer overflow?\\n"
                    },
                    {
                        "username": "S117",
                        "content": "Corner cases such as [0,0,0,1] with expected answer \\'0\\' are a little bit too vicious "
                    },
                    {
                        "username": "user0724fL",
                        "content": "lol++"
                    }
                ]
            },
            {
                "id": 1991885,
                "content": [
                    {
                        "username": "theesoteric",
                        "content": "Approach: We will divide all the digits in 3 categories\\n\\xA0 \\xA0 digits divisible by 3 using array \\'ans\\'\\n\\xA0 \\xA0 digits giving remainder 1 when divided by 3 using array \\'rem1\\'\\n\\xA0 \\xA0 digits giving remainder 2 when divided by 3 using array \\'rem2\\'\\n\\xA0 \\xA0 All the digits from \\'ans\\' can be used in the output string without any issue\\n\\xA0 \\xA0 Now we will check for the maximum possible number of digits from \\'rem1\\' and \\'rem2\\' we can use in the answer. Also if there is a tie then we will choose the higher value digits. \\n\\xA0 \\xA0 Then we will sort all the eligible digits in descending order to create the maximum number"
                    },
                    {
                        "username": "Rutvik0512",
                        "content": "Not Hard Level Question, should be tagged as Medium\\n"
                    },
                    {
                        "username": "varmapraneeth2003",
                        "content": "Why this is in dp hard bro this is a typical greedy question"
                    },
                    {
                        "username": "dhananjaykumar13092001",
                        "content": "string largestMultipleOfThree(vector<int>& digits) {\\n        vector<vector<int>> rem(3);\\n        for(int i = 0; i < digits.size(); i++)\\n            rem[(digits[i]) % 3].push_back(digits[i]);\\n        for(int i = 0; i < 3; i++)\\n            sort(rem[i].begin(), rem[i].end(), greater<int>());\\n        int i = 0, j = 0, k = 0;\\n        string ans;\\n        while(j < rem[1].size() && k < rem[2].size())\\n        {\\n            ans.push_back(rem[1][j] + \\'0\\');\\n            ans.push_back(rem[2][k] + \\'0\\');\\n            j++;\\n            k++;\\n        }\\n        while(j < rem[1].size() - 2)\\n        {\\n            ans.push_back(rem[1][j] + \\'0\\');\\n            ans.push_back(rem[1][j + 1] + \\'0\\');\\n            ans.push_back(rem[1][j + 2] + \\'0\\');\\n            j += 3;\\n        }\\n        while(k < rem[2].size() - 2)\\n        {\\n            ans.push_back(rem[2][k] + \\'0\\');\\n            ans.push_back(rem[2][k + 1] + \\'0\\');\\n            ans.push_back(rem[2][k + 2] + \\'0\\');\\n            k += 3;\\n        }\\n        while(i < rem[0].size())\\n        {\\n            ans.push_back(rem[0][i] + \\'0\\');\\n            i++;\\n        }\\n        sort(ans.begin(), ans.end(), greater<int>());\\n        if(ans.size() && ans[0] == \\'0\\')\\n            return \"0\";\\n        return ans;\\n    }\\n\\ncan anyone please tell why it is showing heap buffer overflow?\\n"
                    },
                    {
                        "username": "S117",
                        "content": "Corner cases such as [0,0,0,1] with expected answer \\'0\\' are a little bit too vicious "
                    },
                    {
                        "username": "user0724fL",
                        "content": "lol++"
                    }
                ]
            },
            {
                "id": 2027066,
                "content": [
                    {
                        "username": "theesoteric",
                        "content": "Approach: We will divide all the digits in 3 categories\\n\\xA0 \\xA0 digits divisible by 3 using array \\'ans\\'\\n\\xA0 \\xA0 digits giving remainder 1 when divided by 3 using array \\'rem1\\'\\n\\xA0 \\xA0 digits giving remainder 2 when divided by 3 using array \\'rem2\\'\\n\\xA0 \\xA0 All the digits from \\'ans\\' can be used in the output string without any issue\\n\\xA0 \\xA0 Now we will check for the maximum possible number of digits from \\'rem1\\' and \\'rem2\\' we can use in the answer. Also if there is a tie then we will choose the higher value digits. \\n\\xA0 \\xA0 Then we will sort all the eligible digits in descending order to create the maximum number"
                    },
                    {
                        "username": "Rutvik0512",
                        "content": "Not Hard Level Question, should be tagged as Medium\\n"
                    },
                    {
                        "username": "varmapraneeth2003",
                        "content": "Why this is in dp hard bro this is a typical greedy question"
                    },
                    {
                        "username": "dhananjaykumar13092001",
                        "content": "string largestMultipleOfThree(vector<int>& digits) {\\n        vector<vector<int>> rem(3);\\n        for(int i = 0; i < digits.size(); i++)\\n            rem[(digits[i]) % 3].push_back(digits[i]);\\n        for(int i = 0; i < 3; i++)\\n            sort(rem[i].begin(), rem[i].end(), greater<int>());\\n        int i = 0, j = 0, k = 0;\\n        string ans;\\n        while(j < rem[1].size() && k < rem[2].size())\\n        {\\n            ans.push_back(rem[1][j] + \\'0\\');\\n            ans.push_back(rem[2][k] + \\'0\\');\\n            j++;\\n            k++;\\n        }\\n        while(j < rem[1].size() - 2)\\n        {\\n            ans.push_back(rem[1][j] + \\'0\\');\\n            ans.push_back(rem[1][j + 1] + \\'0\\');\\n            ans.push_back(rem[1][j + 2] + \\'0\\');\\n            j += 3;\\n        }\\n        while(k < rem[2].size() - 2)\\n        {\\n            ans.push_back(rem[2][k] + \\'0\\');\\n            ans.push_back(rem[2][k + 1] + \\'0\\');\\n            ans.push_back(rem[2][k + 2] + \\'0\\');\\n            k += 3;\\n        }\\n        while(i < rem[0].size())\\n        {\\n            ans.push_back(rem[0][i] + \\'0\\');\\n            i++;\\n        }\\n        sort(ans.begin(), ans.end(), greater<int>());\\n        if(ans.size() && ans[0] == \\'0\\')\\n            return \"0\";\\n        return ans;\\n    }\\n\\ncan anyone please tell why it is showing heap buffer overflow?\\n"
                    },
                    {
                        "username": "S117",
                        "content": "Corner cases such as [0,0,0,1] with expected answer \\'0\\' are a little bit too vicious "
                    },
                    {
                        "username": "user0724fL",
                        "content": "lol++"
                    }
                ]
            },
            {
                "id": 1873720,
                "content": [
                    {
                        "username": "theesoteric",
                        "content": "Approach: We will divide all the digits in 3 categories\\n\\xA0 \\xA0 digits divisible by 3 using array \\'ans\\'\\n\\xA0 \\xA0 digits giving remainder 1 when divided by 3 using array \\'rem1\\'\\n\\xA0 \\xA0 digits giving remainder 2 when divided by 3 using array \\'rem2\\'\\n\\xA0 \\xA0 All the digits from \\'ans\\' can be used in the output string without any issue\\n\\xA0 \\xA0 Now we will check for the maximum possible number of digits from \\'rem1\\' and \\'rem2\\' we can use in the answer. Also if there is a tie then we will choose the higher value digits. \\n\\xA0 \\xA0 Then we will sort all the eligible digits in descending order to create the maximum number"
                    },
                    {
                        "username": "Rutvik0512",
                        "content": "Not Hard Level Question, should be tagged as Medium\\n"
                    },
                    {
                        "username": "varmapraneeth2003",
                        "content": "Why this is in dp hard bro this is a typical greedy question"
                    },
                    {
                        "username": "dhananjaykumar13092001",
                        "content": "string largestMultipleOfThree(vector<int>& digits) {\\n        vector<vector<int>> rem(3);\\n        for(int i = 0; i < digits.size(); i++)\\n            rem[(digits[i]) % 3].push_back(digits[i]);\\n        for(int i = 0; i < 3; i++)\\n            sort(rem[i].begin(), rem[i].end(), greater<int>());\\n        int i = 0, j = 0, k = 0;\\n        string ans;\\n        while(j < rem[1].size() && k < rem[2].size())\\n        {\\n            ans.push_back(rem[1][j] + \\'0\\');\\n            ans.push_back(rem[2][k] + \\'0\\');\\n            j++;\\n            k++;\\n        }\\n        while(j < rem[1].size() - 2)\\n        {\\n            ans.push_back(rem[1][j] + \\'0\\');\\n            ans.push_back(rem[1][j + 1] + \\'0\\');\\n            ans.push_back(rem[1][j + 2] + \\'0\\');\\n            j += 3;\\n        }\\n        while(k < rem[2].size() - 2)\\n        {\\n            ans.push_back(rem[2][k] + \\'0\\');\\n            ans.push_back(rem[2][k + 1] + \\'0\\');\\n            ans.push_back(rem[2][k + 2] + \\'0\\');\\n            k += 3;\\n        }\\n        while(i < rem[0].size())\\n        {\\n            ans.push_back(rem[0][i] + \\'0\\');\\n            i++;\\n        }\\n        sort(ans.begin(), ans.end(), greater<int>());\\n        if(ans.size() && ans[0] == \\'0\\')\\n            return \"0\";\\n        return ans;\\n    }\\n\\ncan anyone please tell why it is showing heap buffer overflow?\\n"
                    },
                    {
                        "username": "S117",
                        "content": "Corner cases such as [0,0,0,1] with expected answer \\'0\\' are a little bit too vicious "
                    },
                    {
                        "username": "user0724fL",
                        "content": "lol++"
                    }
                ]
            },
            {
                "id": 1846062,
                "content": [
                    {
                        "username": "theesoteric",
                        "content": "Approach: We will divide all the digits in 3 categories\\n\\xA0 \\xA0 digits divisible by 3 using array \\'ans\\'\\n\\xA0 \\xA0 digits giving remainder 1 when divided by 3 using array \\'rem1\\'\\n\\xA0 \\xA0 digits giving remainder 2 when divided by 3 using array \\'rem2\\'\\n\\xA0 \\xA0 All the digits from \\'ans\\' can be used in the output string without any issue\\n\\xA0 \\xA0 Now we will check for the maximum possible number of digits from \\'rem1\\' and \\'rem2\\' we can use in the answer. Also if there is a tie then we will choose the higher value digits. \\n\\xA0 \\xA0 Then we will sort all the eligible digits in descending order to create the maximum number"
                    },
                    {
                        "username": "Rutvik0512",
                        "content": "Not Hard Level Question, should be tagged as Medium\\n"
                    },
                    {
                        "username": "varmapraneeth2003",
                        "content": "Why this is in dp hard bro this is a typical greedy question"
                    },
                    {
                        "username": "dhananjaykumar13092001",
                        "content": "string largestMultipleOfThree(vector<int>& digits) {\\n        vector<vector<int>> rem(3);\\n        for(int i = 0; i < digits.size(); i++)\\n            rem[(digits[i]) % 3].push_back(digits[i]);\\n        for(int i = 0; i < 3; i++)\\n            sort(rem[i].begin(), rem[i].end(), greater<int>());\\n        int i = 0, j = 0, k = 0;\\n        string ans;\\n        while(j < rem[1].size() && k < rem[2].size())\\n        {\\n            ans.push_back(rem[1][j] + \\'0\\');\\n            ans.push_back(rem[2][k] + \\'0\\');\\n            j++;\\n            k++;\\n        }\\n        while(j < rem[1].size() - 2)\\n        {\\n            ans.push_back(rem[1][j] + \\'0\\');\\n            ans.push_back(rem[1][j + 1] + \\'0\\');\\n            ans.push_back(rem[1][j + 2] + \\'0\\');\\n            j += 3;\\n        }\\n        while(k < rem[2].size() - 2)\\n        {\\n            ans.push_back(rem[2][k] + \\'0\\');\\n            ans.push_back(rem[2][k + 1] + \\'0\\');\\n            ans.push_back(rem[2][k + 2] + \\'0\\');\\n            k += 3;\\n        }\\n        while(i < rem[0].size())\\n        {\\n            ans.push_back(rem[0][i] + \\'0\\');\\n            i++;\\n        }\\n        sort(ans.begin(), ans.end(), greater<int>());\\n        if(ans.size() && ans[0] == \\'0\\')\\n            return \"0\";\\n        return ans;\\n    }\\n\\ncan anyone please tell why it is showing heap buffer overflow?\\n"
                    },
                    {
                        "username": "S117",
                        "content": "Corner cases such as [0,0,0,1] with expected answer \\'0\\' are a little bit too vicious "
                    },
                    {
                        "username": "user0724fL",
                        "content": "lol++"
                    }
                ]
            }
        ]
    }
]