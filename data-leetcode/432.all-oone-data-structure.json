[
    {
        "title": "All O`one Data Structure",
        "question_content": "Design a data structure to store the strings' count with the ability to return the strings with minimum and maximum counts.\nImplement the AllOne class:\n\n\tAllOne() Initializes the object of the data structure.\n\tinc(String key) Increments the count of the string key by 1. If key does not exist in the data structure, insert it with count 1.\n\tdec(String key) Decrements the count of the string key by 1. If the count of key is 0 after the decrement, remove it from the data structure. It is guaranteed that key exists in the data structure before the decrement.\n\tgetMaxKey() Returns one of the keys with the maximal count. If no element exists, return an empty string \"\".\n\tgetMinKey() Returns one of the keys with the minimum count. If no element exists, return an empty string \"\".\n\nNote that each function must run in O(1) average time complexity.\n&nbsp;\nExample 1:\n\nInput\n[\"AllOne\", \"inc\", \"inc\", \"getMaxKey\", \"getMinKey\", \"inc\", \"getMaxKey\", \"getMinKey\"]\n[[], [\"hello\"], [\"hello\"], [], [], [\"leet\"], [], []]\nOutput\n[null, null, null, \"hello\", \"hello\", null, \"hello\", \"leet\"]\nExplanation\nAllOne allOne = new AllOne();\nallOne.inc(\"hello\");\nallOne.inc(\"hello\");\nallOne.getMaxKey(); // return \"hello\"\nallOne.getMinKey(); // return \"hello\"\nallOne.inc(\"leet\");\nallOne.getMaxKey(); // return \"hello\"\nallOne.getMinKey(); // return \"leet\"\n\n&nbsp;\nConstraints:\n\n\t1 <= key.length <= 10\n\tkey consists of lowercase English letters.\n\tIt is guaranteed that for each call to dec, key is existing in the data structure.\n\tAt most 5 * 104&nbsp;calls will be made to inc, dec, getMaxKey, and getMinKey.",
        "solutions": [
            {
                "id": 91416,
                "title": "java-ac-all-strict-o-1-not-average-o-1-easy-to-read",
                "content": "Main idea is to maintain a list of Bucket's, each Bucket contains all keys with the same count.\\n1. ```head``` and ```tail``` can ensure both ```getMaxKey()``` and ```getMaxKey()``` be done in O(1).\\n2. ```keyCountMap``` maintains the count of keys, ```countBucketMap``` provides O(1) access to a specific Bucket with given count. Deleting and adding a Bucket in the Bucket list cost O(1), so both ```inc()``` and ```dec()``` take strict O(1) time.\\n\\n```\\npublic class AllOne {\\n    // maintain a doubly linked list of Buckets\\n    private Bucket head;\\n    private Bucket tail;\\n    // for accessing a specific Bucket among the Bucket list in O(1) time\\n    private Map<Integer, Bucket> countBucketMap;\\n    // keep track of count of keys\\n    private Map<String, Integer> keyCountMap;\\n\\n    // each Bucket contains all the keys with the same count\\n    private class Bucket {\\n        int count;\\n        Set<String> keySet;\\n        Bucket next;\\n        Bucket pre;\\n        public Bucket(int cnt) {\\n            count = cnt;\\n            keySet = new HashSet<>();\\n        }\\n    }\\n\\n    /** Initialize your data structure here. */\\n    public AllOne() {\\n        head = new Bucket(Integer.MIN_VALUE);\\n        tail = new Bucket(Integer.MAX_VALUE);\\n        head.next = tail;\\n        tail.pre = head;\\n        countBucketMap = new HashMap<>();\\n        keyCountMap = new HashMap<>();\\n    }\\n    \\n    /** Inserts a new key <Key> with value 1. Or increments an existing key by 1. */\\n    public void inc(String key) {\\n        if (keyCountMap.containsKey(key)) {\\n            changeKey(key, 1);\\n        } else {\\n            keyCountMap.put(key, 1);\\n            if (head.next.count != 1) \\n                addBucketAfter(new Bucket(1), head);\\n            head.next.keySet.add(key);\\n            countBucketMap.put(1, head.next);\\n        }\\n    }\\n    \\n    /** Decrements an existing key by 1. If Key's value is 1, remove it from the data structure. */\\n    public void dec(String key) {\\n        if (keyCountMap.containsKey(key)) {\\n            int count = keyCountMap.get(key);\\n            if (count == 1) {\\n                keyCountMap.remove(key);\\n                removeKeyFromBucket(countBucketMap.get(count), key);\\n            } else {\\n                changeKey(key, -1);\\n            }\\n        }\\n    }\\n    \\n    /** Returns one of the keys with maximal value. */\\n    public String getMaxKey() {\\n        return tail.pre == head ? \"\" : (String) tail.pre.keySet.iterator().next();\\n    }\\n    \\n    /** Returns one of the keys with Minimal value. */\\n    public String getMinKey() {\\n        return head.next == tail ? \"\" : (String) head.next.keySet.iterator().next();        \\n    }\\n    \\n    // helper function to make change on given key according to offset\\n    private void changeKey(String key, int offset) {\\n        int count = keyCountMap.get(key);\\n        keyCountMap.put(key, count + offset);\\n        Bucket curBucket = countBucketMap.get(count);\\n        Bucket newBucket;\\n        if (countBucketMap.containsKey(count + offset)) {\\n            // target Bucket already exists\\n            newBucket = countBucketMap.get(count + offset);\\n        } else {\\n            // add new Bucket\\n            newBucket = new Bucket(count + offset);\\n            countBucketMap.put(count + offset, newBucket);\\n            addBucketAfter(newBucket, offset == 1 ? curBucket : curBucket.pre);\\n        }\\n        newBucket.keySet.add(key);\\n        removeKeyFromBucket(curBucket, key);\\n    }\\n    \\n    private void removeKeyFromBucket(Bucket bucket, String key) {\\n        bucket.keySet.remove(key);\\n        if (bucket.keySet.size() == 0) {\\n            removeBucketFromList(bucket);\\n            countBucketMap.remove(bucket.count);\\n        }\\n    }\\n    \\n    private void removeBucketFromList(Bucket bucket) {\\n        bucket.pre.next = bucket.next;\\n        bucket.next.pre = bucket.pre;\\n        bucket.next = null;\\n        bucket.pre = null;\\n    }\\n    \\n    // add newBucket after preBucket\\n    private void addBucketAfter(Bucket newBucket, Bucket preBucket) {\\n        newBucket.pre = preBucket;\\n        newBucket.next = preBucket.next;\\n        preBucket.next.pre = newBucket;\\n        preBucket.next = newBucket;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```head```\n```tail```\n```getMaxKey()```\n```getMaxKey()```\n```keyCountMap```\n```countBucketMap```\n```inc()```\n```dec()```\n```\\npublic class AllOne {\\n    // maintain a doubly linked list of Buckets\\n    private Bucket head;\\n    private Bucket tail;\\n    // for accessing a specific Bucket among the Bucket list in O(1) time\\n    private Map<Integer, Bucket> countBucketMap;\\n    // keep track of count of keys\\n    private Map<String, Integer> keyCountMap;\\n\\n    // each Bucket contains all the keys with the same count\\n    private class Bucket {\\n        int count;\\n        Set<String> keySet;\\n        Bucket next;\\n        Bucket pre;\\n        public Bucket(int cnt) {\\n            count = cnt;\\n            keySet = new HashSet<>();\\n        }\\n    }\\n\\n    /** Initialize your data structure here. */\\n    public AllOne() {\\n        head = new Bucket(Integer.MIN_VALUE);\\n        tail = new Bucket(Integer.MAX_VALUE);\\n        head.next = tail;\\n        tail.pre = head;\\n        countBucketMap = new HashMap<>();\\n        keyCountMap = new HashMap<>();\\n    }\\n    \\n    /** Inserts a new key <Key> with value 1. Or increments an existing key by 1. */\\n    public void inc(String key) {\\n        if (keyCountMap.containsKey(key)) {\\n            changeKey(key, 1);\\n        } else {\\n            keyCountMap.put(key, 1);\\n            if (head.next.count != 1) \\n                addBucketAfter(new Bucket(1), head);\\n            head.next.keySet.add(key);\\n            countBucketMap.put(1, head.next);\\n        }\\n    }\\n    \\n    /** Decrements an existing key by 1. If Key's value is 1, remove it from the data structure. */\\n    public void dec(String key) {\\n        if (keyCountMap.containsKey(key)) {\\n            int count = keyCountMap.get(key);\\n            if (count == 1) {\\n                keyCountMap.remove(key);\\n                removeKeyFromBucket(countBucketMap.get(count), key);\\n            } else {\\n                changeKey(key, -1);\\n            }\\n        }\\n    }\\n    \\n    /** Returns one of the keys with maximal value. */\\n    public String getMaxKey() {\\n        return tail.pre == head ? \"\" : (String) tail.pre.keySet.iterator().next();\\n    }\\n    \\n    /** Returns one of the keys with Minimal value. */\\n    public String getMinKey() {\\n        return head.next == tail ? \"\" : (String) head.next.keySet.iterator().next();        \\n    }\\n    \\n    // helper function to make change on given key according to offset\\n    private void changeKey(String key, int offset) {\\n        int count = keyCountMap.get(key);\\n        keyCountMap.put(key, count + offset);\\n        Bucket curBucket = countBucketMap.get(count);\\n        Bucket newBucket;\\n        if (countBucketMap.containsKey(count + offset)) {\\n            // target Bucket already exists\\n            newBucket = countBucketMap.get(count + offset);\\n        } else {\\n            // add new Bucket\\n            newBucket = new Bucket(count + offset);\\n            countBucketMap.put(count + offset, newBucket);\\n            addBucketAfter(newBucket, offset == 1 ? curBucket : curBucket.pre);\\n        }\\n        newBucket.keySet.add(key);\\n        removeKeyFromBucket(curBucket, key);\\n    }\\n    \\n    private void removeKeyFromBucket(Bucket bucket, String key) {\\n        bucket.keySet.remove(key);\\n        if (bucket.keySet.size() == 0) {\\n            removeBucketFromList(bucket);\\n            countBucketMap.remove(bucket.count);\\n        }\\n    }\\n    \\n    private void removeBucketFromList(Bucket bucket) {\\n        bucket.pre.next = bucket.next;\\n        bucket.next.pre = bucket.pre;\\n        bucket.next = null;\\n        bucket.pre = null;\\n    }\\n    \\n    // add newBucket after preBucket\\n    private void addBucketAfter(Bucket newBucket, Bucket preBucket) {\\n        newBucket.pre = preBucket;\\n        newBucket.next = preBucket.next;\\n        preBucket.next.pre = newBucket;\\n        preBucket.next = newBucket;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 91428,
                "title": "python-solution-with-detailed-comments",
                "content": "**Solution** \\n\\n**All Oone Data Structure** https://leetcode.com/problems/all-oone-data-structure/\\n\\n**Data-Structures**\\nhttps://goo.gl/photos/YLhF2qCcBwRpAn58A\\n\\nNode: A node type to support a doubly linked list. It is a container to hold a bag of keys. It supports:\\n* add_key(key): Add a key to the bag\\n* remove_key(key): Remove a key from the bag\\n* get_any_key(): Returns any random key from the bag. Returns None if bag is empty.\\n* is_empty(): Returns true if the bag is empty\\n\\nDoubleLinkedList\\n* The linked list is implemented using the idea of sentinel nodes, i.e. we have two dummy nodes to represent head and tail. Initially head.next points to tail and tail.prev points to head. Using two dummy nodes dramatically simplifies the implementation.\\n* insert_after(x): Add a node after node x\\n* insert_before(x): Add a node before node x\\n* remove(x): Remove the node from the list\\n* get_head(): Returns the reference to the real head node\\n* get_tail() Returns the reference to the real tail node\\n\\nnode_freq: Hashmap with key as frequency and value as Node.\\nkey_counter: Hashmap with key as input key and value as frequency of the key.\\n\\n**Algorithm Idea**\\n\\n* A node in the doubly linked list represents a bucket containing a bag of words with a certain frequency. The doubly linked list is maintained in a sorted order with the head node containing words with the least frequency and the tail node containing words with maximum frequency.\\n* Using this list, getMaxKey and getMinKey can be implemented in O(1) by returning any word contained in the tail and head respectively.\\n* key_counter is hashmap which allows us to increment or decrement frequency of a key in O(1).\\n* node_freq is a hashmap which maps a frequency integer to the bucket node in the linked list. Note that we initialize frequency 0 to head sentinel node.\\n* Now, if we can maintain the sorted order of the linked list in O(1) while performing the increment and decrement operations, we would have a working solution!\\n\\n**Increment Details**\\n* While incrementing a key, we first update the key_counter ro reflect the new frequency (cf) of the key.\\n* Then we test if there is already a bucket with cf using node_freq hashmap. If not, then we need to add a bucket to the linked list. \\n* To maintain the sorted invariant, this new bucket must be after the bucket for frequency pf (cf-1). \\n* Now unless pf is 0, we are guaranteed that a pf bucket already exists. Therefore, either we add the new bucket after the head node or after the pf bucket. Note that we initialize frequency 0 to head sentinel node. This allows us to use \"insert_after\" API when previous frequency were zero.\\n* pf bucket can be retrieved in O(1) using node_freq. insertion in doubly linked list can be done in O(1) as well. Once we have inserted, we add the key to the new bucket.\\n* Finally we need to remove the key from the previous bucket if pf > 0 (i.e. if a previous bucket exists). Again this can be done in O(1). If the previous bucket becomes empty after removing the key, then we need to also drop the entire bucket from the list.\\n\\n**Decrement Details**\\n* While decrementing a key, we first check if the key exisits in key_counter or not. If not, then we simply return. if it does exist, we update the key_counter to reflect the new frequency (cf) of the key. If cf is 0, then we drop this key from the key counter.\\n* If cf is not in node_freq and cf is not 0, then we need to add a new bucket in the linked list such that the sorted invariant is maintained. Again we are guaranteed to have pf bucket!\\n* We add the key to the new bucket and remove it from the previous bucket - O(1) operations.\\n\\n```\\nfrom collections import defaultdict\\nclass Node(object):\\n    def __init__(self):\\n        self.key_set = set([])\\n        self.prev, self.nxt = None, None \\n\\n    def add_key(self, key):\\n        self.key_set.add(key)\\n\\n    def remove_key(self, key):\\n        self.key_set.remove(key)        \\n\\n    def get_any_key(self):\\n        if self.key_set:\\n            result = self.key_set.pop()\\n            self.add_key(result)\\n            return result\\n        else:\\n            return None\\n    \\n    def count(self):\\n        return len(self.key_set)\\n\\n    def is_empty(self):\\n        return len(self.key_set) == 0\\n\\n\\nclass DoubleLinkedList(object):\\n    def __init__(self):\\n        self.head_node, self.tail_node = Node(), Node()\\n        self.head_node.nxt, self.tail_node.prev = self.tail_node, self.head_node\\n        return\\n\\n    def insert_after(self, x):\\n        node, temp = Node(), x.nxt\\n        x.nxt, node.prev = node, x\\n        node.nxt, temp.prev = temp, node\\n        return node\\n    \\n    def insert_before(self, x):\\n        return self.insert_after(x.prev)\\n\\n    def remove(self, x):\\n        prev_node = x.prev\\n        prev_node.nxt, x.nxt.prev = x.nxt, prev_node\\n        return\\n\\n    def get_head(self):\\n        return self.head_node.nxt\\n    \\n    def get_tail(self):\\n        return self.tail_node.prev\\n\\n    def get_sentinel_head(self):\\n        return self.head_node\\n\\n    def get_sentinel_tail(self):\\n        return self.tail_node\\n    \\nclass AllOne(object):\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.dll, self.key_counter = DoubleLinkedList(), defaultdict(int)\\n        self.node_freq = {0:self.dll.get_sentinel_head()}\\n\\n    def _rmv_key_pf_node(self, pf, key):\\n        node = self.node_freq[pf]\\n        node.remove_key(key)\\n        if node.is_empty():\\n            self.dll.remove(node)\\n            self.node_freq.pop(pf)\\n        return\\n\\n    def inc(self, key):\\n        \"\"\"\\n        Inserts a new key <Key> with value 1. Or increments an existing key by 1.\\n        :type key: str\\n        :rtype: void\\n        \"\"\"\\n        self.key_counter[key] += 1\\n        cf, pf = self.key_counter[key], self.key_counter[key]-1\\n        if cf not in self.node_freq:\\n            # No need to test if pf = 0 since frequency zero points to sentinel node\\n            self.node_freq[cf] = self.dll.insert_after(self.node_freq[pf])\\n        self.node_freq[cf].add_key(key)\\n        if pf > 0:\\n            self._rmv_key_pf_node(pf, key)\\n\\n    def dec(self, key):\\n        \"\"\"\\n        Decrements an existing key by 1. If Key's value is 1, remove it from the data structure.\\n        :type key: str\\n        :rtype: void\\n        \"\"\"\\n        if key in self.key_counter:\\n            self.key_counter[key] -= 1\\n            cf, pf = self.key_counter[key], self.key_counter[key]+1\\n            if self.key_counter[key] == 0:\\n                self.key_counter.pop(key)\\n            if cf != 0:\\n                if cf not in self.node_freq:\\n                    self.node_freq[cf] = self.dll.insert_before(self.node_freq[pf])\\n                self.node_freq[cf].add_key(key)\\n            self._rmv_key_pf_node(pf, key)\\n\\n    def getMaxKey(self):\\n        \"\"\"\\n        Returns one of the keys with maximal value.\\n        :rtype: str\\n        \"\"\"\\n        return self.dll.get_tail().get_any_key() if self.dll.get_tail().count() > 0 else \"\"\\n\\n    def getMinKey(self):\\n        \"\"\"\\n        Returns one of the keys with Minimal value.\\n        :rtype: str\\n        \"\"\"\\n        return self.dll.get_head().get_any_key() if self.dll.get_tail().count() > 0 else \"\"\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import defaultdict\\nclass Node(object):\\n    def __init__(self):\\n        self.key_set = set([])\\n        self.prev, self.nxt = None, None \\n\\n    def add_key(self, key):\\n        self.key_set.add(key)\\n\\n    def remove_key(self, key):\\n        self.key_set.remove(key)        \\n\\n    def get_any_key(self):\\n        if self.key_set:\\n            result = self.key_set.pop()\\n            self.add_key(result)\\n            return result\\n        else:\\n            return None\\n    \\n    def count(self):\\n        return len(self.key_set)\\n\\n    def is_empty(self):\\n        return len(self.key_set) == 0\\n\\n\\nclass DoubleLinkedList(object):\\n    def __init__(self):\\n        self.head_node, self.tail_node = Node(), Node()\\n        self.head_node.nxt, self.tail_node.prev = self.tail_node, self.head_node\\n        return\\n\\n    def insert_after(self, x):\\n        node, temp = Node(), x.nxt\\n        x.nxt, node.prev = node, x\\n        node.nxt, temp.prev = temp, node\\n        return node\\n    \\n    def insert_before(self, x):\\n        return self.insert_after(x.prev)\\n\\n    def remove(self, x):\\n        prev_node = x.prev\\n        prev_node.nxt, x.nxt.prev = x.nxt, prev_node\\n        return\\n\\n    def get_head(self):\\n        return self.head_node.nxt\\n    \\n    def get_tail(self):\\n        return self.tail_node.prev\\n\\n    def get_sentinel_head(self):\\n        return self.head_node\\n\\n    def get_sentinel_tail(self):\\n        return self.tail_node\\n    \\nclass AllOne(object):\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.dll, self.key_counter = DoubleLinkedList(), defaultdict(int)\\n        self.node_freq = {0:self.dll.get_sentinel_head()}\\n\\n    def _rmv_key_pf_node(self, pf, key):\\n        node = self.node_freq[pf]\\n        node.remove_key(key)\\n        if node.is_empty():\\n            self.dll.remove(node)\\n            self.node_freq.pop(pf)\\n        return\\n\\n    def inc(self, key):\\n        \"\"\"\\n        Inserts a new key <Key> with value 1. Or increments an existing key by 1.\\n        :type key: str\\n        :rtype: void\\n        \"\"\"\\n        self.key_counter[key] += 1\\n        cf, pf = self.key_counter[key], self.key_counter[key]-1\\n        if cf not in self.node_freq:\\n            # No need to test if pf = 0 since frequency zero points to sentinel node\\n            self.node_freq[cf] = self.dll.insert_after(self.node_freq[pf])\\n        self.node_freq[cf].add_key(key)\\n        if pf > 0:\\n            self._rmv_key_pf_node(pf, key)\\n\\n    def dec(self, key):\\n        \"\"\"\\n        Decrements an existing key by 1. If Key's value is 1, remove it from the data structure.\\n        :type key: str\\n        :rtype: void\\n        \"\"\"\\n        if key in self.key_counter:\\n            self.key_counter[key] -= 1\\n            cf, pf = self.key_counter[key], self.key_counter[key]+1\\n            if self.key_counter[key] == 0:\\n                self.key_counter.pop(key)\\n            if cf != 0:\\n                if cf not in self.node_freq:\\n                    self.node_freq[cf] = self.dll.insert_before(self.node_freq[pf])\\n                self.node_freq[cf].add_key(key)\\n            self._rmv_key_pf_node(pf, key)\\n\\n    def getMaxKey(self):\\n        \"\"\"\\n        Returns one of the keys with maximal value.\\n        :rtype: str\\n        \"\"\"\\n        return self.dll.get_tail().get_any_key() if self.dll.get_tail().count() > 0 else \"\"\\n\\n    def getMinKey(self):\\n        \"\"\"\\n        Returns one of the keys with Minimal value.\\n        :rtype: str\\n        \"\"\"\\n        return self.dll.get_head().get_any_key() if self.dll.get_tail().count() > 0 else \"\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 91398,
                "title": "c-solution-with-comments",
                "content": "For each value, I have a bucket with all keys which have that value. The buckets are in a list, sorted by value. That allows constant time insertion/erasure and iteration to the next higher/lower value bucket. A bucket stores its keys in a hash set for easy constant time insertion/erasure/check (see [first two posts here](https://discuss.leetcode.com/topic/53193/are-hash-tables-ok-here-they-re-not-really-o-1-are-they) if you're worried). I also have one hash map to look up which bucket a given key is in.\\n\\nBased on a previously flawed Python attempt (I just couldn't find a good way to get an arbitrary element from a set) but also influenced by an earlier version of @Ren.W's [solution](https://discuss.leetcode.com/topic/63741/c-o-1-0ms-ac-solution]). We ended up with quite similiar code, I guess there's not much room for creativity once you decide on the data types to hold the data.\\n```\\nclass AllOne {\\npublic:\\n\\n    void inc(string key) {\\n        \\n        // If the key doesn't exist, insert it with value 0.\\n        if (!bucketOfKey.count(key))\\n            bucketOfKey[key] = buckets.insert(buckets.begin(), {0, {key}});\\n            \\n        // Insert the key in next bucket and update the lookup.\\n        auto next = bucketOfKey[key], bucket = next++;\\n        if (next == buckets.end() || next->value > bucket->value + 1)\\n            next = buckets.insert(next, {bucket->value + 1, {}});\\n        next->keys.insert(key);\\n        bucketOfKey[key] = next;\\n        \\n        // Remove the key from its old bucket.\\n        bucket->keys.erase(key);\\n        if (bucket->keys.empty())\\n            buckets.erase(bucket);\\n    }\\n\\n    void dec(string key) {\\n\\n        // If the key doesn't exist, just leave.\\n        if (!bucketOfKey.count(key))\\n            return;\\n\\n        // Maybe insert the key in previous bucket and update the lookup.\\n        auto prev = bucketOfKey[key], bucket = prev--;\\n        bucketOfKey.erase(key);\\n        if (bucket->value > 1) {\\n            if (bucket == buckets.begin() || prev->value < bucket->value - 1)\\n                prev = buckets.insert(bucket, {bucket->value - 1, {}});\\n            prev->keys.insert(key);\\n            bucketOfKey[key] = prev;\\n        }\\n        \\n        // Remove the key from its old bucket.\\n        bucket->keys.erase(key);\\n        if (bucket->keys.empty())\\n            buckets.erase(bucket);\\n    }\\n\\n    string getMaxKey() {\\n        return buckets.empty() ? \"\" : *(buckets.rbegin()->keys.begin());\\n    }\\n    \\n    string getMinKey() {\\n        return buckets.empty() ? \"\" : *(buckets.begin()->keys.begin());\\n    }\\n\\nprivate:\\n    struct Bucket { int value; unordered_set<string> keys; };\\n    list<Bucket> buckets;\\n    unordered_map<string, list<Bucket>::iterator> bucketOfKey;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass AllOne {\\npublic:\\n\\n    void inc(string key) {\\n        \\n        // If the key doesn't exist, insert it with value 0.\\n        if (!bucketOfKey.count(key))\\n            bucketOfKey[key] = buckets.insert(buckets.begin(), {0, {key}});\\n            \\n        // Insert the key in next bucket and update the lookup.\\n        auto next = bucketOfKey[key], bucket = next++;\\n        if (next == buckets.end() || next->value > bucket->value + 1)\\n            next = buckets.insert(next, {bucket->value + 1, {}});\\n        next->keys.insert(key);\\n        bucketOfKey[key] = next;\\n        \\n        // Remove the key from its old bucket.\\n        bucket->keys.erase(key);\\n        if (bucket->keys.empty())\\n            buckets.erase(bucket);\\n    }\\n\\n    void dec(string key) {\\n\\n        // If the key doesn't exist, just leave.\\n        if (!bucketOfKey.count(key))\\n            return;\\n\\n        // Maybe insert the key in previous bucket and update the lookup.\\n        auto prev = bucketOfKey[key], bucket = prev--;\\n        bucketOfKey.erase(key);\\n        if (bucket->value > 1) {\\n            if (bucket == buckets.begin() || prev->value < bucket->value - 1)\\n                prev = buckets.insert(bucket, {bucket->value - 1, {}});\\n            prev->keys.insert(key);\\n            bucketOfKey[key] = prev;\\n        }\\n        \\n        // Remove the key from its old bucket.\\n        bucket->keys.erase(key);\\n        if (bucket->keys.empty())\\n            buckets.erase(bucket);\\n    }\\n\\n    string getMaxKey() {\\n        return buckets.empty() ? \"\" : *(buckets.rbegin()->keys.begin());\\n    }\\n    \\n    string getMinKey() {\\n        return buckets.empty() ? \"\" : *(buckets.begin()->keys.begin());\\n    }\\n\\nprivate:\\n    struct Bucket { int value; unordered_set<string> keys; };\\n    list<Bucket> buckets;\\n    unordered_map<string, list<Bucket>::iterator> bucketOfKey;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 731468,
                "title": "hashmap-doublylinkedlist-strategy",
                "content": "\\n```\\nExaple\\n\\n        obj.inc(\"a\");\\n        obj.inc(\"b\");\\n        obj.inc(\"b\");\\n        obj.inc(\"c\");\\n        obj.inc(\"c\");\\n        obj.inc(\"c\");\\n\\n        obj.dec(\"b\");\\n        obj.dec(\"b\");\\n\\n        obj.getMinKey();\\n        obj.getMaxKey();\\n\\n        obj.dec(\"a\");\\n\\n        obj.getMinKey();\\n        obj.getMaxKey();\\n```\\n\\n\\n\\n### (1)\\n\\n put `a` , create a new node, with frequency is 1 and keys has character a\\n![image](https://assets.leetcode.com/users/images/2bf93c8d-b292-409c-9721-81417fe7a004_1594520423.7669754.png)\\n\\n\\n### (2)\\nput `b`, add b into the key set of node 1\\n![image](https://assets.leetcode.com/users/images/5fc911c8-8d8b-4512-9512-167172907dab_1594520431.5041354.png)\\n\\n\\n### (3)\\nput`b` again, b has frequency 2, we create a new node with frequency is 2 and put `b` into its key set.\\n![image](https://assets.leetcode.com/users/images/6b647431-8976-4b1f-98d1-514a908b810b_1594520436.060424.png)\\n\\n### (4)\\nput `c`, add c into the key set of head node (H1)\\n![image](https://assets.leetcode.com/users/images/061df19b-bc28-46c7-a7e5-6d681fa1b541_1594520440.5202088.png)\\n\\n### (5)\\nput `c` again, move `c` to the 2nd node\\'s keyset\\n![image](https://assets.leetcode.com/users/images/f4cf8b86-57ab-4afa-a627-4ab66d6bd4d5_1594520444.9887397.png)\\n\\n\\n### (6)\\nput `c` one more time, we need a new node with frequency = 3 to store character `c`.\\n![image](https://assets.leetcode.com/users/images/38380d4c-ae8a-490c-b1d9-50783e9f9d61_1594520789.3741772.png)\\n\\n\\n### (7)\\ndecreaset `b`, its frequency become 1 again, move `b` to the head node.\\n\\n![image](https://assets.leetcode.com/users/images/dcda6dab-2980-48c0-9332-ce297494c879_1594520589.8868797.png)\\n\\n\\n### (8)\\n\\nthe 2nd node now has empty key set, remove it from the linklist\\n![image](https://assets.leetcode.com/users/images/aba31cf3-7cd2-45f7-8634-93b48112ac0b_1594520832.631777.png)\\n\\n\\n### (9)\\n\\n![image](https://assets.leetcode.com/users/images/7f88265e-d9bf-4973-a9fb-9ff51a187240_1594520846.1988902.png)\\n\\n\\n\\nComplete code\\n\\n```\\nclass Node {\\n    int freq;\\n    Node prev;\\n    Node next;\\n    Set<String> keys;\\n\\n    public Node(int freq) {\\n        this.freq = freq;\\n        keys = new HashSet<>();\\n    }\\n}\\n\\n\\npublic class AllOne {\\n\\n    private Node head;\\n    private Node tail;\\n    Map<String, Node> map;\\n\\n    /** Initialize your data structure here. */\\n    public AllOne() {\\n        head = null;\\n        tail = null;\\n        map = new HashMap<>();\\n    }\\n\\n    /** Inserts a new key <Key> with value 1. Or increments an existing key by 1. */\\n    public void inc(String key) {\\n\\n        if (map.containsKey(key)) {\\n            Node node = map.get(key);\\n            int freq = node.freq;\\n            node.keys.remove(key);\\n            if (node.next == null) {\\n                Node newNode = new Node(freq + 1);\\n                node.next = newNode;\\n                newNode.prev = node;\\n                newNode.keys.add(key);\\n                map.put(key, newNode);\\n                tail = newNode;\\n            } else {\\n                Node next = node.next;\\n                if (next.freq - freq > 1) {\\n                    Node newNode = new Node(freq + 1);\\n                    newNode.keys.add(key);\\n                    node.next = newNode;\\n                    newNode.prev = node;\\n                    newNode.next = next;\\n                    next.prev = newNode;\\n                    map.put(key, newNode);\\n                } else {\\n                    next.keys.add(key);\\n                    map.put(key, next);\\n                }\\n            }\\n\\n            if (node.keys.size() == 0) {\\n                removeNode(node);\\n            }\\n\\n        } else { // map does not contains the key\\n            if (head == null) {\\n                head = new Node(1);\\n                head.keys.add(key);\\n                tail = head;\\n            } else {\\n                if (head.freq == 1) {\\n                    head.keys.add(key);\\n                } else {\\n                    Node newNode = new Node(1);\\n                    newNode.keys.add(key);\\n                    newNode.next = head;\\n                    head.prev = newNode;\\n                    head = newNode;\\n                }\\n            }\\n            map.put(key, head);\\n        }\\n    }\\n\\n    /** Decrements an existing key by 1. If Key\\'s value is 1, remove it from the data structure. */\\n    public void dec(String key) {\\n        if (!map.containsKey(key)) {\\n            return;\\n        }\\n        Node node = map.get(key);\\n        node.keys.remove(key);\\n        int freq = node.freq;\\n        if (freq == 1) {\\n            map.remove(key);\\n\\n        } else if (node == head) {\\n            Node newNode = new Node(freq - 1);\\n            newNode.keys.add(key);\\n            newNode.next = head;\\n            head.prev = newNode;\\n            head = newNode;\\n            map.put(key, head);\\n        } else {\\n            Node prev = node.prev;\\n            if (freq - prev.freq == 1) {\\n                prev.keys.add(key);\\n                map.put(key, prev);\\n            } else {\\n                Node newNode = new Node(freq - 1);\\n                prev.next = newNode;\\n                newNode.prev = prev;\\n                newNode.next = node;\\n                node.prev = newNode;\\n                newNode.keys.add(key);\\n                map.put(key, newNode);\\n            }\\n        }\\n\\n        if (node.keys.size() == 0) {\\n            removeNode(node);\\n        }\\n    }\\n\\n\\n    /** Returns one of the keys with maximal value. */\\n    public String getMaxKey() {\\n        if (head == null) {\\n            return \"\";\\n        }\\n        return tail.keys.iterator().next();\\n    }\\n\\n    /** Returns one of the keys with Minimal value. */\\n    public String getMinKey() {\\n        if (head == null) {\\n            return \"\";\\n        }\\n        return head.keys.iterator().next();\\n    }\\n\\n\\n    private void removeNode(Node node) {\\n        if (node == head) {\\n            head = head.next;\\n            node.next = null;\\n            if (head != null) {\\n                head.prev = null;\\n            }\\n        } else if (node == tail) {\\n            tail = tail.prev;\\n            node.prev = null;\\n            if (tail != null) {\\n                tail.next = null;\\n            }\\n        } else {\\n            node.prev.next = node.next;\\n            node.next.prev = node.prev;\\n            node.prev = null;\\n            node.next = null;\\n        }\\n    }\\n\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nExaple\\n\\n        obj.inc(\"a\");\\n        obj.inc(\"b\");\\n        obj.inc(\"b\");\\n        obj.inc(\"c\");\\n        obj.inc(\"c\");\\n        obj.inc(\"c\");\\n\\n        obj.dec(\"b\");\\n        obj.dec(\"b\");\\n\\n        obj.getMinKey();\\n        obj.getMaxKey();\\n\\n        obj.dec(\"a\");\\n\\n        obj.getMinKey();\\n        obj.getMaxKey();\\n```\n```\\nclass Node {\\n    int freq;\\n    Node prev;\\n    Node next;\\n    Set<String> keys;\\n\\n    public Node(int freq) {\\n        this.freq = freq;\\n        keys = new HashSet<>();\\n    }\\n}\\n\\n\\npublic class AllOne {\\n\\n    private Node head;\\n    private Node tail;\\n    Map<String, Node> map;\\n\\n    /** Initialize your data structure here. */\\n    public AllOne() {\\n        head = null;\\n        tail = null;\\n        map = new HashMap<>();\\n    }\\n\\n    /** Inserts a new key <Key> with value 1. Or increments an existing key by 1. */\\n    public void inc(String key) {\\n\\n        if (map.containsKey(key)) {\\n            Node node = map.get(key);\\n            int freq = node.freq;\\n            node.keys.remove(key);\\n            if (node.next == null) {\\n                Node newNode = new Node(freq + 1);\\n                node.next = newNode;\\n                newNode.prev = node;\\n                newNode.keys.add(key);\\n                map.put(key, newNode);\\n                tail = newNode;\\n            } else {\\n                Node next = node.next;\\n                if (next.freq - freq > 1) {\\n                    Node newNode = new Node(freq + 1);\\n                    newNode.keys.add(key);\\n                    node.next = newNode;\\n                    newNode.prev = node;\\n                    newNode.next = next;\\n                    next.prev = newNode;\\n                    map.put(key, newNode);\\n                } else {\\n                    next.keys.add(key);\\n                    map.put(key, next);\\n                }\\n            }\\n\\n            if (node.keys.size() == 0) {\\n                removeNode(node);\\n            }\\n\\n        } else { // map does not contains the key\\n            if (head == null) {\\n                head = new Node(1);\\n                head.keys.add(key);\\n                tail = head;\\n            } else {\\n                if (head.freq == 1) {\\n                    head.keys.add(key);\\n                } else {\\n                    Node newNode = new Node(1);\\n                    newNode.keys.add(key);\\n                    newNode.next = head;\\n                    head.prev = newNode;\\n                    head = newNode;\\n                }\\n            }\\n            map.put(key, head);\\n        }\\n    }\\n\\n    /** Decrements an existing key by 1. If Key\\'s value is 1, remove it from the data structure. */\\n    public void dec(String key) {\\n        if (!map.containsKey(key)) {\\n            return;\\n        }\\n        Node node = map.get(key);\\n        node.keys.remove(key);\\n        int freq = node.freq;\\n        if (freq == 1) {\\n            map.remove(key);\\n\\n        } else if (node == head) {\\n            Node newNode = new Node(freq - 1);\\n            newNode.keys.add(key);\\n            newNode.next = head;\\n            head.prev = newNode;\\n            head = newNode;\\n            map.put(key, head);\\n        } else {\\n            Node prev = node.prev;\\n            if (freq - prev.freq == 1) {\\n                prev.keys.add(key);\\n                map.put(key, prev);\\n            } else {\\n                Node newNode = new Node(freq - 1);\\n                prev.next = newNode;\\n                newNode.prev = prev;\\n                newNode.next = node;\\n                node.prev = newNode;\\n                newNode.keys.add(key);\\n                map.put(key, newNode);\\n            }\\n        }\\n\\n        if (node.keys.size() == 0) {\\n            removeNode(node);\\n        }\\n    }\\n\\n\\n    /** Returns one of the keys with maximal value. */\\n    public String getMaxKey() {\\n        if (head == null) {\\n            return \"\";\\n        }\\n        return tail.keys.iterator().next();\\n    }\\n\\n    /** Returns one of the keys with Minimal value. */\\n    public String getMinKey() {\\n        if (head == null) {\\n            return \"\";\\n        }\\n        return head.keys.iterator().next();\\n    }\\n\\n\\n    private void removeNode(Node node) {\\n        if (node == head) {\\n            head = head.next;\\n            node.next = null;\\n            if (head != null) {\\n                head.prev = null;\\n            }\\n        } else if (node == tail) {\\n            tail = tail.prev;\\n            node.prev = null;\\n            if (tail != null) {\\n                tail.next = null;\\n            }\\n        } else {\\n            node.prev.next = node.next;\\n            node.next.prev = node.prev;\\n            node.prev = null;\\n            node.next = null;\\n        }\\n    }\\n\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 91401,
                "title": "python-o-1-doubly-linked-list-and-dictionary",
                "content": "Define a Block class which contains the set of all keys of a given value. Blocks form a doubly linked list, in order of value.\\nThen to find the block of a given key, use a dictionary.\\n```\\nclass Block(object):\\n    def __init__(self, val=0):\\n        self.val = val\\n        self.keys = set()\\n        self.before = None\\n        self.after = None\\n\\n    def remove(self):\\n        self.before.after = self.after\\n        self.after.before = self.before\\n        self.before, self.after = None, None\\n\\n    def insert_after(self, new_block):\\n        old_after = self.after\\n        self.after = new_block\\n        new_block.before = self\\n        new_block.after = old_after\\n        old_after.before = new_block\\n\\n\\nclass AllOne(object):\\n    def __init__(self):\\n        self.begin = Block()  # sentinel\\n        self.end = Block()  # sentinel\\n        self.begin.after = self.end\\n        self.end.before = self.begin\\n        self.mapping = {}  # key to block\\n\\n    def inc(self, key):\\n        if not key in self.mapping:  # find current block and remove key\\n            current_block = self.begin\\n        else:\\n            current_block = self.mapping[key]\\n            current_block.keys.remove(key)\\n\\n        if current_block.val + 1 != current_block.after.val:  # insert new block\\n            new_block = Block(current_block.val + 1)\\n            current_block.insert_after(new_block)\\n        else:\\n            new_block = current_block.after\\n\\n        new_block.keys.add(key)  # update new_block\\n        self.mapping[key] = new_block  # ... and mapping of key to new_block\\n\\n        if not current_block.keys and current_block.val != 0:  # delete current block if not seninel\\n            current_block.remove()\\n\\n    def dec(self, key):\\n        if not key in self.mapping:\\n            return\\n\\n        current_block = self.mapping[key]\\n        del self.mapping[key]  # could use self.mapping.pop(key)\\n        current_block.keys.remove(key)\\n\\n        if current_block.val != 1:\\n            if current_block.val - 1 != current_block.before.val:  # insert new block\\n                new_block = Block(current_block.val - 1)\\n                current_block.before.insert_after(new_block)\\n            else:\\n                new_block = current_block.before\\n            new_block.keys.add(key)\\n            self.mapping[key] = new_block\\n\\n        if not current_block.keys:  # delete current block\\n            current_block.remove()\\n\\n    def getMaxKey(self):\\n        if self.end.before.val == 0:\\n            return \"\"\\n        key = self.end.before.keys.pop()  # pop and add back to get arbitrary (but not random) element\\n        self.end.before.keys.add(key)\\n        return key\\n\\n    def getMinKey(self):\\n        if self.begin.after.val == 0:\\n            return \"\"\\n        key = self.begin.after.keys.pop()\\n        self.begin.after.keys.add(key)\\n        return key",
                "solutionTags": [
                    "Python"
                ],
                "code": "Define a Block class which contains the set of all keys of a given value. Blocks form a doubly linked list, in order of value.\\nThen to find the block of a given key, use a dictionary.\\n```\\nclass Block(object):\\n    def __init__(self, val=0):\\n        self.val = val\\n        self.keys = set()\\n        self.before = None\\n        self.after = None\\n\\n    def remove(self):\\n        self.before.after = self.after\\n        self.after.before = self.before\\n        self.before, self.after = None, None\\n\\n    def insert_after(self, new_block):\\n        old_after = self.after\\n        self.after = new_block\\n        new_block.before = self\\n        new_block.after = old_after\\n        old_after.before = new_block\\n\\n\\nclass AllOne(object):\\n    def __init__(self):\\n        self.begin = Block()  # sentinel\\n        self.end = Block()  # sentinel\\n        self.begin.after = self.end\\n        self.end.before = self.begin\\n        self.mapping = {}  # key to block\\n\\n    def inc(self, key):\\n        if not key in self.mapping:  # find current block and remove key\\n            current_block = self.begin\\n        else:\\n            current_block = self.mapping[key]\\n            current_block.keys.remove(key)\\n\\n        if current_block.val + 1 != current_block.after.val:  # insert new block\\n            new_block = Block(current_block.val + 1)\\n            current_block.insert_after(new_block)\\n        else:\\n            new_block = current_block.after\\n\\n        new_block.keys.add(key)  # update new_block\\n        self.mapping[key] = new_block  # ... and mapping of key to new_block\\n\\n        if not current_block.keys and current_block.val != 0:  # delete current block if not seninel\\n            current_block.remove()\\n\\n    def dec(self, key):\\n        if not key in self.mapping:\\n            return\\n\\n        current_block = self.mapping[key]\\n        del self.mapping[key]  # could use self.mapping.pop(key)\\n        current_block.keys.remove(key)\\n\\n        if current_block.val != 1:\\n            if current_block.val - 1 != current_block.before.val:  # insert new block\\n                new_block = Block(current_block.val - 1)\\n                current_block.before.insert_after(new_block)\\n            else:\\n                new_block = current_block.before\\n            new_block.keys.add(key)\\n            self.mapping[key] = new_block\\n\\n        if not current_block.keys:  # delete current block\\n            current_block.remove()\\n\\n    def getMaxKey(self):\\n        if self.end.before.val == 0:\\n            return \"\"\\n        key = self.end.before.keys.pop()  # pop and add back to get arbitrary (but not random) element\\n        self.end.before.keys.add(key)\\n        return key\\n\\n    def getMinKey(self):\\n        if self.begin.after.val == 0:\\n            return \"\"\\n        key = self.begin.after.keys.pop()\\n        self.begin.after.keys.add(key)\\n        return key",
                "codeTag": "Java"
            },
            {
                "id": 91400,
                "title": "all-in-o-1-with-detailed-explantation",
                "content": "The main idea is to maintain an ordered two-dimensional doubly-linked list (let's call it matrix for convenience), of which each row is corresponding to a value and all of the keys in the same row have the same value.\\n\\nSuppose we get the following key-value pairs after some increment operations. (\"A\": 4 means \"A\" is increased four times so its value is 4, and so on.)\\n```\\n\"A\": 4, \"B\": 4, \"C\": 2, \"D\": 1\\n```\\n\\nThen one possible matrix may look like this:\\n```\\nrow0: val = 4, strs = {\"A\", \"B\"}\\nrow1: val = 2, strs = {\"C\"}\\nrow2: val = 1, strs = {\"D\"}\\n```\\n\\nIf we can guarantee the rows are in descending order in terms of value, then GetMaxKey()/GetMinKey() will be easy to implement in O(1) time complexity. Because the first key in the first row will always has the maximal value, and the first key in the last row will always has the minimal value.\\n\\nOnce a key is increased, we move the key from current row to last row if last_row.val = current_row.val + 1. Otherwise, we insert a new row before current row with vallue current_row.val + 1, and move the key to to the new row. The logic of decrement operation is similar. Obviously, by doing this, the rows will keep its descending order.\\n\\nFor example, after Inc(\"D\"), the matrix will become\\n```\\nrow0: val = 4, strs = {\"A\", \"B\"}\\nrow1: val = 2, strs = {\"C\", \"D\"}\\n```\\n\\nInc(\"D\") again\\n```\\nrow0: val = 4, strs = {\"A\", \"B\"}\\nrow1: val = 3, strs = {\"D\"}\\nrow2: val = 2, strs = {\"C\"}\\n```\\n\\nNow the key problem is how to maintain the matrix in O(1) runtime when increase/decrease a key by 1.\\n\\nThe answer is hash map. By using a hash map to track the position of a key in the matrix, we can access  a key in the matrix in O(1). And since we use linked list to store the matrix, thus insert/move operations will all be O(1).\\n\\nThe psudocode of Inc() is as follows(Dec() is similar).\\n```\\nif the key isn't in the matrix:\\n    if the matrix is empty or the value of the last row isn't 1:\\n        insert a new row with value 1 to the end of the matrix, and put the key in the new row;\\n    else:\\n        put the key in the last row of the matrix;\\nelse:\\n    if the key is at the first row or last_row.value != current_row.value + 1:\\n        insert a new row before current row, with value current_row.value + 1, and move the key to the new row;\\n    else:\\n        move the key from current row to last row;\\n```\\n\\nHere is the code.\\n```\\nclass AllOne {\\npublic:\\n    struct Row {\\n        list<string> strs;\\n        int val;\\n        Row(const string &s, int x) : strs({s}), val(x) {}\\n    };\\n\\n    unordered_map<string, pair<list<Row>::iterator, list<string>::iterator>> strmap;\\n    list<Row> matrix;\\n\\n    /** Initialize your data structure here. */\\n    AllOne() {\\n        \\n    }\\n    \\n    /** Inserts a new key <Key> with value 1. Or increments an existing key by 1. */\\n    void inc(string key) {\\n        if (strmap.find(key) == strmap.end()) {\\n            if (matrix.empty() || matrix.back().val != 1) {\\n                auto newrow = matrix.emplace(matrix.end(), key, 1);\\n                strmap[key] = make_pair(newrow, newrow->strs.begin());\\n            }\\n            else {\\n                auto newrow = --matrix.end();\\n                newrow->strs.push_front(key);\\n                strmap[key] = make_pair(newrow, newrow->strs.begin());\\n            }\\n        }\\n        else {\\n            auto row = strmap[key].first;\\n            auto col = strmap[key].second;\\n            auto lastrow = row;\\n            --lastrow;\\n            if (lastrow == matrix.end() || lastrow->val != row->val + 1) {\\n                auto newrow = matrix.emplace(row, key, row->val + 1);\\n                strmap[key] = make_pair(newrow, newrow->strs.begin());\\n            }\\n            else {\\n                auto newrow = lastrow;\\n                newrow->strs.push_front(key);\\n                strmap[key] = make_pair(newrow, newrow->strs.begin());\\n            }\\n            row->strs.erase(col);\\n            if (row->strs.empty()) matrix.erase(row);\\n        }\\n    }\\n    \\n    /** Decrements an existing key by 1. If Key's value is 1, remove it from the data structure. */\\n    void dec(string key) {\\n        if (strmap.find(key) == strmap.end()) {\\n            return;\\n        }\\n        else {\\n            auto row = strmap[key].first;\\n            auto col = strmap[key].second;\\n            if (row->val == 1) {\\n                row->strs.erase(col);\\n                if (row->strs.empty()) matrix.erase(row);\\n                strmap.erase(key);\\n                return;\\n            }\\n            auto nextrow = row;\\n            ++nextrow;\\n            if (nextrow == matrix.end() || nextrow->val != row->val - 1) {\\n                auto newrow = matrix.emplace(nextrow, key, row->val - 1);\\n                strmap[key] = make_pair(newrow, newrow->strs.begin());\\n            }\\n            else {\\n                auto newrow = nextrow;\\n                newrow->strs.push_front(key);\\n                strmap[key] = make_pair(newrow, newrow->strs.begin());\\n            }\\n            row->strs.erase(col);\\n            if (row->strs.empty()) matrix.erase(row);\\n        }\\n    }\\n    \\n    /** Returns one of the keys with maximal value. */\\n    string getMaxKey() {\\n        return matrix.empty() ?  \"\" : matrix.front().strs.front();\\n    }\\n    \\n    /** Returns one of the keys with Minimal value. */\\n    string getMinKey() {\\n        return matrix.empty() ?  \"\" : matrix.back().strs.front();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\"A\": 4, \"B\": 4, \"C\": 2, \"D\": 1\\n```\n```\\nrow0: val = 4, strs = {\"A\", \"B\"}\\nrow1: val = 2, strs = {\"C\"}\\nrow2: val = 1, strs = {\"D\"}\\n```\n```\\nrow0: val = 4, strs = {\"A\", \"B\"}\\nrow1: val = 2, strs = {\"C\", \"D\"}\\n```\n```\\nrow0: val = 4, strs = {\"A\", \"B\"}\\nrow1: val = 3, strs = {\"D\"}\\nrow2: val = 2, strs = {\"C\"}\\n```\n```\\nif the key isn't in the matrix:\\n    if the matrix is empty or the value of the last row isn't 1:\\n        insert a new row with value 1 to the end of the matrix, and put the key in the new row;\\n    else:\\n        put the key in the last row of the matrix;\\nelse:\\n    if the key is at the first row or last_row.value != current_row.value + 1:\\n        insert a new row before current row, with value current_row.value + 1, and move the key to the new row;\\n    else:\\n        move the key from current row to last row;\\n```\n```\\nclass AllOne {\\npublic:\\n    struct Row {\\n        list<string> strs;\\n        int val;\\n        Row(const string &s, int x) : strs({s}), val(x) {}\\n    };\\n\\n    unordered_map<string, pair<list<Row>::iterator, list<string>::iterator>> strmap;\\n    list<Row> matrix;\\n\\n    /** Initialize your data structure here. */\\n    AllOne() {\\n        \\n    }\\n    \\n    /** Inserts a new key <Key> with value 1. Or increments an existing key by 1. */\\n    void inc(string key) {\\n        if (strmap.find(key) == strmap.end()) {\\n            if (matrix.empty() || matrix.back().val != 1) {\\n                auto newrow = matrix.emplace(matrix.end(), key, 1);\\n                strmap[key] = make_pair(newrow, newrow->strs.begin());\\n            }\\n            else {\\n                auto newrow = --matrix.end();\\n                newrow->strs.push_front(key);\\n                strmap[key] = make_pair(newrow, newrow->strs.begin());\\n            }\\n        }\\n        else {\\n            auto row = strmap[key].first;\\n            auto col = strmap[key].second;\\n            auto lastrow = row;\\n            --lastrow;\\n            if (lastrow == matrix.end() || lastrow->val != row->val + 1) {\\n                auto newrow = matrix.emplace(row, key, row->val + 1);\\n                strmap[key] = make_pair(newrow, newrow->strs.begin());\\n            }\\n            else {\\n                auto newrow = lastrow;\\n                newrow->strs.push_front(key);\\n                strmap[key] = make_pair(newrow, newrow->strs.begin());\\n            }\\n            row->strs.erase(col);\\n            if (row->strs.empty()) matrix.erase(row);\\n        }\\n    }\\n    \\n    /** Decrements an existing key by 1. If Key's value is 1, remove it from the data structure. */\\n    void dec(string key) {\\n        if (strmap.find(key) == strmap.end()) {\\n            return;\\n        }\\n        else {\\n            auto row = strmap[key].first;\\n            auto col = strmap[key].second;\\n            if (row->val == 1) {\\n                row->strs.erase(col);\\n                if (row->strs.empty()) matrix.erase(row);\\n                strmap.erase(key);\\n                return;\\n            }\\n            auto nextrow = row;\\n            ++nextrow;\\n            if (nextrow == matrix.end() || nextrow->val != row->val - 1) {\\n                auto newrow = matrix.emplace(nextrow, key, row->val - 1);\\n                strmap[key] = make_pair(newrow, newrow->strs.begin());\\n            }\\n            else {\\n                auto newrow = nextrow;\\n                newrow->strs.push_front(key);\\n                strmap[key] = make_pair(newrow, newrow->strs.begin());\\n            }\\n            row->strs.erase(col);\\n            if (row->strs.empty()) matrix.erase(row);\\n        }\\n    }\\n    \\n    /** Returns one of the keys with maximal value. */\\n    string getMaxKey() {\\n        return matrix.empty() ?  \"\" : matrix.front().strs.front();\\n    }\\n    \\n    /** Returns one of the keys with Minimal value. */\\n    string getMinKey() {\\n        return matrix.empty() ?  \"\" : matrix.back().strs.front();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 91383,
                "title": "an-accepted-java-solution-detailed-explanation-hashmap-double-linked-list",
                "content": " ![0_1477786494175_\\u65e0\\u6807\\u9898.png](/uploads/files/1477786496396-\\u65e0\\u6807\\u9898.png) \\n\\nMy key thought of this problem is to  the HashMap + Double Linked Node.\\n\\nWhen Inc (A) we could using the hashmap to find out we store the A at the node 1 , which means there is only 1 A in the data structure. (which is also the tail of the double linked list.)\\nThen we can delete the A in the level 1 and put the A into the level 2. Meanwhile , we should also change the <k,v> = <A, node 1> to the <k,v > = <A, node 2>.\\n\\nActually , the situation could be more complicated. You can check the detail categories in my code. But the key thought is :\\n        \\n* 1. Using the hashmap as the index to find out where is the key.\\n\\n* 2. Dealing with the key in a double linked list.\\n\\nAlso, I think there is many improvements should be done in my code.  Maybe someone could finish it.\\n1. to optimal the category method.\\n2. to change the list inside the node to be HashSet.(which could really be o(1).)\\n3.  checkEmpty() method should be substitute by  some steps with different situation.\\n\\n```\\npublic class AllOne {\\n    class valueNode {\\n        valueNode preNode;             \\n        valueNode nextNode;           \\n        int value;                     // curNode.value;\\n        List<String> curKeys;         // store the key at the value of curNode.value;\\n        \\n        valueNode(int value,String key) {\\n            this.value = value;\\n            curKeys = new LinkedList<String>();\\n            curKeys.add(key);\\n        }\\n    }\\n    \\n    private valueNode head;\\n    private valueNode tail;\\n    private valueNode curNode;\\n    private HashMap<String, valueNode> keyMap;\\n    \\n    /** Initialize your data structure here. */\\n    public AllOne() {\\n        keyMap = new HashMap<String,valueNode>();\\n        head = null;\\n        tail = null;\\n    }\\n    \\n    /** Inserts a new key <Key> with value 1. Or increments an existing key by 1. */\\n    public void inc(String key) {\\n        if (tail == null) { // which means head must be null too and the keyMap must be empty.\\n                curNode = new valueNode(1,key);\\n                head = curNode;\\n                tail = curNode;\\n                keyMap.put(key,curNode);\\n        } else if (!keyMap.containsKey(key)){ //which means that this key should be add to the tail.\\n                if (tail.value == 1) {//which means just add the key to the tail list.\\n                    tail.curKeys.add(key);\\n                    keyMap.put(key,tail);\\n                }else {    //which means have to add a value= 1 node.\\n                    curNode = new valueNode(1,key);\\n                    curNode.preNode = tail;\\n                    tail.nextNode = curNode;\\n                    tail = curNode;\\n                    keyMap.put(key,curNode);\\n                }\\n        } else { //which the string already exists.\\n            curNode = keyMap.get(key);\\n            if (curNode.preNode != null) {  //which means the node is in the middle.\\n                if (curNode.preNode.value == curNode.value + 1){\\n                    curNode.preNode.curKeys.add(key);\\n                    curNode.curKeys.remove(key); \\n                    keyMap.put(key,curNode.preNode);\\n                    checkEmpty(curNode);\\n                }else {                     //which means the preNode value != curNode.value;\\n                    valueNode newNode = new valueNode(curNode.value+1, key);\\n                    newNode.preNode = curNode.preNode;\\n                    newNode.nextNode= curNode;\\n                    newNode.preNode.nextNode = newNode;\\n                    curNode.preNode = newNode;\\n                    curNode.curKeys.remove(key); \\n                    keyMap.put(key,newNode);\\n                    checkEmpty(curNode);\\n                }\\n            }else {//which means the node is the head. so we build a new head.\\n                head = new valueNode(curNode.value+1,key);\\n                head.nextNode = curNode;\\n                curNode.preNode = head;\\n                curNode.curKeys.remove(key);\\n                keyMap.put(key,head);\\n                checkEmpty(curNode);\\n            }\\n        }\\n    }\\n    \\n    /** Decrements an existing key by 1. If Key's value is 1, remove it from the data structure. */\\n    public void dec(String key) {\\n            if (head ==null ||!keyMap.containsKey(key)) return; //which means nothing here.\\n                                                         //or  means no key in the structrue.\\n            curNode = keyMap.get(key);\\n            if (curNode.nextNode != null) {  //which means the node is in the middle.\\n                if (curNode.nextNode.value == curNode.value - 1){ //which means we can just \\n                    curNode.nextNode.curKeys.add(key);\\n                    curNode.curKeys.remove(key); \\n                    keyMap.put(key,curNode.nextNode);\\n                    checkEmpty(curNode);\\n                }else {                     //which means the nextNode value != curNode.value-1;\\n                        valueNode newNode = new valueNode(curNode.value-1, key);\\n                        newNode.nextNode = curNode.nextNode;\\n                        newNode.preNode= curNode;\\n                        newNode.nextNode.preNode = newNode;\\n                        curNode.curKeys.remove(key); \\n                        curNode.nextNode = newNode;\\n                        keyMap.put(key,newNode);\\n                        checkEmpty(curNode);\\n                }\\n            } else {    //which means the node is the tail. so we build a new head.\\n                if (curNode.value == 1) {     //just to delete the key.\\n                    curNode.curKeys.remove(key);  \\n                    keyMap.remove(key);\\n                    checkEmpty(curNode);\\n                }else {                         // build another tail.\\n                    tail = new valueNode(curNode.value-1,key);\\n                    tail.preNode = curNode;\\n                    curNode.nextNode = tail;\\n                    curNode.curKeys.remove(key);  \\n                    keyMap.put(key,tail);\\n                    checkEmpty(curNode);\\n                }\\n            }\\n    }\\n    \\n    /** Returns one of the keys with maximal value. */\\n    public String getMaxKey() {\\n         if (head == null) return \"\";//which means nothing here.\\n         return head.curKeys.get(0);\\n    }\\n    \\n    /** Returns one of the keys with Minimal value. */\\n    public String getMinKey() {\\n         if (tail == null) return \"\";//which means nothing here.\\n         return tail.curKeys.get(0);\\n        \\n    }\\n    // to check whether the node should be delete because the keyList is empty.\\n    private void checkEmpty(valueNode checkNode) {\\n            if (checkNode.curKeys.size() != 0) return;\\n            if (checkNode.preNode == null && checkNode.nextNode == null){\\n                tail = null;\\n                head = null;\\n            }else if (checkNode.preNode == null && checkNode.nextNode != null) {\\n                head = checkNode.nextNode;\\n                head.preNode = null;\\n            }else if (checkNode.nextNode == null && checkNode.preNode != null){\\n                tail = checkNode.preNode;\\n                tail.nextNode = null;\\n            }else {\\n                checkNode.preNode.nextNode = checkNode.nextNode;\\n                checkNode.nextNode.preNode  = checkNode.preNode; \\n            } \\n    }\\n}\\n\\n...",
                "solutionTags": [],
                "code": " ![0_1477786494175_\\u65e0\\u6807\\u9898.png](/uploads/files/1477786496396-\\u65e0\\u6807\\u9898.png) \\n\\nMy key thought of this problem is to  the HashMap + Double Linked Node.\\n\\nWhen Inc (A) we could using the hashmap to find out we store the A at the node 1 , which means there is only 1 A in the data structure. (which is also the tail of the double linked list.)\\nThen we can delete the A in the level 1 and put the A into the level 2. Meanwhile , we should also change the <k,v> = <A, node 1> to the <k,v > = <A, node 2>.\\n\\nActually , the situation could be more complicated. You can check the detail categories in my code. But the key thought is :\\n        \\n* 1. Using the hashmap as the index to find out where is the key.\\n\\n* 2. Dealing with the key in a double linked list.\\n\\nAlso, I think there is many improvements should be done in my code.  Maybe someone could finish it.\\n1. to optimal the category method.\\n2. to change the list inside the node to be HashSet.(which could really be o(1).)\\n3.  checkEmpty() method should be substitute by  some steps with different situation.\\n\\n```\\npublic class AllOne {\\n    class valueNode {\\n        valueNode preNode;             \\n        valueNode nextNode;           \\n        int value;                     // curNode.value;\\n        List<String> curKeys;         // store the key at the value of curNode.value;\\n        \\n        valueNode(int value,String key) {\\n            this.value = value;\\n            curKeys = new LinkedList<String>();\\n            curKeys.add(key);\\n        }\\n    }\\n    \\n    private valueNode head;\\n    private valueNode tail;\\n    private valueNode curNode;\\n    private HashMap<String, valueNode> keyMap;\\n    \\n    /** Initialize your data structure here. */\\n    public AllOne() {\\n        keyMap = new HashMap<String,valueNode>();\\n        head = null;\\n        tail = null;\\n    }\\n    \\n    /** Inserts a new key <Key> with value 1. Or increments an existing key by 1. */\\n    public void inc(String key) {\\n        if (tail == null) { // which means head must be null too and the keyMap must be empty.\\n                curNode = new valueNode(1,key);\\n                head = curNode;\\n                tail = curNode;\\n                keyMap.put(key,curNode);\\n        } else if (!keyMap.containsKey(key)){ //which means that this key should be add to the tail.\\n                if (tail.value == 1) {//which means just add the key to the tail list.\\n                    tail.curKeys.add(key);\\n                    keyMap.put(key,tail);\\n                }else {    //which means have to add a value= 1 node.\\n                    curNode = new valueNode(1,key);\\n                    curNode.preNode = tail;\\n                    tail.nextNode = curNode;\\n                    tail = curNode;\\n                    keyMap.put(key,curNode);\\n                }\\n        } else { //which the string already exists.\\n            curNode = keyMap.get(key);\\n            if (curNode.preNode != null) {  //which means the node is in the middle.\\n                if (curNode.preNode.value == curNode.value + 1){\\n                    curNode.preNode.curKeys.add(key);\\n                    curNode.curKeys.remove(key); \\n                    keyMap.put(key,curNode.preNode);\\n                    checkEmpty(curNode);\\n                }else {                     //which means the preNode value != curNode.value;\\n                    valueNode newNode = new valueNode(curNode.value+1, key);\\n                    newNode.preNode = curNode.preNode;\\n                    newNode.nextNode= curNode;\\n                    newNode.preNode.nextNode = newNode;\\n                    curNode.preNode = newNode;\\n                    curNode.curKeys.remove(key); \\n                    keyMap.put(key,newNode);\\n                    checkEmpty(curNode);\\n                }\\n            }else {//which means the node is the head. so we build a new head.\\n                head = new valueNode(curNode.value+1,key);\\n                head.nextNode = curNode;\\n                curNode.preNode = head;\\n                curNode.curKeys.remove(key);\\n                keyMap.put(key,head);\\n                checkEmpty(curNode);\\n            }\\n        }\\n    }\\n    \\n    /** Decrements an existing key by 1. If Key's value is 1, remove it from the data structure. */\\n    public void dec(String key) {\\n            if (head ==null ||!keyMap.containsKey(key)) return; //which means nothing here.\\n                                                         //or  means no key in the structrue.\\n            curNode = keyMap.get(key);\\n            if (curNode.nextNode != null) {  //which means the node is in the middle.\\n                if (curNode.nextNode.value == curNode.value - 1){ //which means we can just \\n                    curNode.nextNode.curKeys.add(key);\\n                    curNode.curKeys.remove(key); \\n                    keyMap.put(key,curNode.nextNode);\\n                    checkEmpty(curNode);\\n                }else {                     //which means the nextNode value != curNode.value-1;\\n                        valueNode newNode = new valueNode(curNode.value-1, key);\\n                        newNode.nextNode = curNode.nextNode;\\n                        newNode.preNode= curNode;\\n                        newNode.nextNode.preNode = newNode;\\n                        curNode.curKeys.remove(key); \\n                        curNode.nextNode = newNode;\\n                        keyMap.put(key,newNode);\\n                        checkEmpty(curNode);\\n                }\\n            } else {    //which means the node is the tail. so we build a new head.\\n                if (curNode.value == 1) {     //just to delete the key.\\n                    curNode.curKeys.remove(key);  \\n                    keyMap.remove(key);\\n                    checkEmpty(curNode);\\n                }else {                         // build another tail.\\n                    tail = new valueNode(curNode.value-1,key);\\n                    tail.preNode = curNode;\\n                    curNode.nextNode = tail;\\n                    curNode.curKeys.remove(key);  \\n                    keyMap.put(key,tail);\\n                    checkEmpty(curNode);\\n                }\\n            }\\n    }\\n    \\n    /** Returns one of the keys with maximal value. */\\n    public String getMaxKey() {\\n         if (head == null) return \"\";//which means nothing here.\\n         return head.curKeys.get(0);\\n    }\\n    \\n    /** Returns one of the keys with Minimal value. */\\n    public String getMinKey() {\\n         if (tail == null) return \"\";//which means nothing here.\\n         return tail.curKeys.get(0);\\n        \\n    }\\n    // to check whether the node should be delete because the keyList is empty.\\n    private void checkEmpty(valueNode checkNode) {\\n            if (checkNode.curKeys.size() != 0) return;\\n            if (checkNode.preNode == null && checkNode.nextNode == null){\\n                tail = null;\\n                head = null;\\n            }else if (checkNode.preNode == null && checkNode.nextNode != null) {\\n                head = checkNode.nextNode;\\n                head.preNode = null;\\n            }else if (checkNode.nextNode == null && checkNode.preNode != null){\\n                tail = checkNode.preNode;\\n                tail.nextNode = null;\\n            }else {\\n                checkNode.preNode.nextNode = checkNode.nextNode;\\n                checkNode.nextNode.preNode  = checkNode.preNode; \\n            } \\n    }\\n}\\n\\n...",
                "codeTag": "Java"
            },
            {
                "id": 403466,
                "title": "accepted-java-solution-using-hashmap-and-doubly-linked-list",
                "content": "A Node contains all keys with the same value. The head keeps track of the Node with highest value and tail keeps track of Node with lowest value. The nodes from tail to head have values in increasing order. A hashmap has been used to reach the deisred Node with the given key in O(1) time.\\n\\n```\\nclass AllOne {\\n\\n    class Node {\\n        Set<String> keys;\\n        int val;\\n        Node prev = null;\\n        Node next = null;\\n        \\n        Node(int val) {\\n            this.val = val;\\n            this.keys = new HashSet<>();\\n        }\\n        \\n        Node(String key, int val) {\\n            this(val);\\n            this.keys.add(key);\\n        }\\n    }\\n    \\n    Map<String, Node> map;\\n    Node head;\\n    Node tail;\\n    \\n    /** Initialize your data structure here. */\\n    public AllOne() {\\n        this.map = new HashMap<>();\\n        this.head = new Node(-1);\\n        this.tail = new Node(-1);\\n        this.head.prev = tail;\\n        this.tail.next = head;\\n    }\\n    \\n    private void deleteNode(Node node) {\\n        node.next.prev = node.prev;\\n        node.prev.next = node.next;\\n        node.next = null;\\n        node.prev = null;\\n    }\\n    \\n    private void removeKeyFromNode(String key, Node node) {\\n        node.keys.remove(key);\\n        if (node.keys.isEmpty()) {\\n            deleteNode(node);\\n        }\\n    }\\n    \\n    private void insertNext(Node node, Node newNode) {\\n        node.next.prev = newNode;\\n        newNode.next = node.next;\\n        node.next = newNode;\\n        newNode.prev = node;\\n    }\\n    \\n    /** Inserts a new key <Key> with value 1. Or increments an existing key by 1. */\\n    public void inc(String key) {\\n        if (map.containsKey(key)) {\\n            Node node = map.get(key);\\n            if (node.val + 1 == node.next.val) {\\n                node.next.keys.add(key);\\n                map.put(key, node.next);\\n            } else {\\n                Node newNode = new Node(key, node.val + 1);\\n                insertNext(node, newNode);\\n                map.put(key, newNode);\\n            }\\n            removeKeyFromNode(key, node);\\n        } else {\\n            if (tail.next.val == 1) {\\n                tail.next.keys.add(key);\\n                map.put(key, tail.next);\\n            } else {\\n                Node newNode = new Node(key, 1);\\n                insertNext(tail, newNode);\\n                map.put(key, newNode);\\n            }\\n        }\\n    }\\n    \\n    /** Decrements an existing key by 1. If Key\\'s value is 1, remove it from the data structure. */\\n    public void dec(String key) {\\n        if (!map.containsKey(key)) {\\n            return;\\n        }\\n        \\n        Node node = map.get(key);\\n        if (node.val == 1) {\\n            map.remove(key);\\n        } else if (node.val - 1 == node.prev.val) {\\n            node.prev.keys.add(key);\\n            map.put(key, node.prev);\\n        } else {\\n            Node newNode = new Node(key, node.val - 1);\\n            map.put(key, newNode);\\n            insertNext(node.prev, newNode);\\n        }\\n        removeKeyFromNode(key, node);\\n    }\\n    \\n    /** Returns one of the keys with maximal value. */\\n    public String getMaxKey() {\\n        return head.prev.keys.isEmpty() ? \"\" : head.prev.keys.iterator().next();\\n    }\\n    \\n    /** Returns one of the keys with Minimal value. */\\n    public String getMinKey() {\\n        return tail.next.keys.isEmpty() ? \"\" : tail.next.keys.iterator().next();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass AllOne {\\n\\n    class Node {\\n        Set<String> keys;\\n        int val;\\n        Node prev = null;\\n        Node next = null;\\n        \\n        Node(int val) {\\n            this.val = val;\\n            this.keys = new HashSet<>();\\n        }\\n        \\n        Node(String key, int val) {\\n            this(val);\\n            this.keys.add(key);\\n        }\\n    }\\n    \\n    Map<String, Node> map;\\n    Node head;\\n    Node tail;\\n    \\n    /** Initialize your data structure here. */\\n    public AllOne() {\\n        this.map = new HashMap<>();\\n        this.head = new Node(-1);\\n        this.tail = new Node(-1);\\n        this.head.prev = tail;\\n        this.tail.next = head;\\n    }\\n    \\n    private void deleteNode(Node node) {\\n        node.next.prev = node.prev;\\n        node.prev.next = node.next;\\n        node.next = null;\\n        node.prev = null;\\n    }\\n    \\n    private void removeKeyFromNode(String key, Node node) {\\n        node.keys.remove(key);\\n        if (node.keys.isEmpty()) {\\n            deleteNode(node);\\n        }\\n    }\\n    \\n    private void insertNext(Node node, Node newNode) {\\n        node.next.prev = newNode;\\n        newNode.next = node.next;\\n        node.next = newNode;\\n        newNode.prev = node;\\n    }\\n    \\n    /** Inserts a new key <Key> with value 1. Or increments an existing key by 1. */\\n    public void inc(String key) {\\n        if (map.containsKey(key)) {\\n            Node node = map.get(key);\\n            if (node.val + 1 == node.next.val) {\\n                node.next.keys.add(key);\\n                map.put(key, node.next);\\n            } else {\\n                Node newNode = new Node(key, node.val + 1);\\n                insertNext(node, newNode);\\n                map.put(key, newNode);\\n            }\\n            removeKeyFromNode(key, node);\\n        } else {\\n            if (tail.next.val == 1) {\\n                tail.next.keys.add(key);\\n                map.put(key, tail.next);\\n            } else {\\n                Node newNode = new Node(key, 1);\\n                insertNext(tail, newNode);\\n                map.put(key, newNode);\\n            }\\n        }\\n    }\\n    \\n    /** Decrements an existing key by 1. If Key\\'s value is 1, remove it from the data structure. */\\n    public void dec(String key) {\\n        if (!map.containsKey(key)) {\\n            return;\\n        }\\n        \\n        Node node = map.get(key);\\n        if (node.val == 1) {\\n            map.remove(key);\\n        } else if (node.val - 1 == node.prev.val) {\\n            node.prev.keys.add(key);\\n            map.put(key, node.prev);\\n        } else {\\n            Node newNode = new Node(key, node.val - 1);\\n            map.put(key, newNode);\\n            insertNext(node.prev, newNode);\\n        }\\n        removeKeyFromNode(key, node);\\n    }\\n    \\n    /** Returns one of the keys with maximal value. */\\n    public String getMaxKey() {\\n        return head.prev.keys.isEmpty() ? \"\" : head.prev.keys.iterator().next();\\n    }\\n    \\n    /** Returns one of the keys with Minimal value. */\\n    public String getMinKey() {\\n        return tail.next.keys.isEmpty() ? \"\" : tail.next.keys.iterator().next();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 91445,
                "title": "ac-java-solution-using-hashmap-and-two-heaps",
                "content": "```\\npublic class AllOne {\\n\\n    class Node{\\n        String key;\\n        int val;\\n        public Node(String key, int val) {\\n            this.key = key;\\n            this.val = val;\\n        }\\n    }\\n    /** Initialize your data structure here. */\\n    HashMap<String, Node> map;\\n    PriorityQueue<Node> minQ;\\n    PriorityQueue<Node> maxQ;\\n    public AllOne() {\\n        map = new HashMap<String, Node>();\\n        minQ = new PriorityQueue<Node>(new Comparator<Node>(){\\n            public int compare(Node a, Node b) {\\n                return a.val - b.val;\\n            }\\n        });        \\n        maxQ = new PriorityQueue<Node>(new Comparator<Node>(){\\n            public int compare(Node a, Node b) {\\n                return b.val - a.val;\\n            }\\n        });\\n    }\\n    \\n    /** Inserts a new key <Key> with value 1. Or increments an existing key by 1. */\\n    public void inc(String key) {\\n        if (!map.containsKey(key)) {\\n            map.put(key, new Node(key, 1));\\n            Node node = map.get(key);\\n            minQ.add(node);\\n            maxQ.add(node);\\n        } else {\\n            Node node = map.get(key);\\n            minQ.remove(node);\\n            maxQ.remove(node);\\n            node.val++;\\n            map.put(key, node);\\n            minQ.add(node);\\n            maxQ.add(node);\\n        }\\n    }\\n    \\n    /** Decrements an existing key by 1. If Key's value is 1, remove it from the data structure. */\\n    public void dec(String key) {\\n        if (map.containsKey(key)) {\\n            Node node = map.get(key);\\n            if (node.val == 1) {\\n                map.remove(key);\\n                minQ.remove(node);\\n                maxQ.remove(node);\\n            } else {\\n                minQ.remove(node);\\n                maxQ.remove(node);\\n                node.val--;\\n                map.put(key, node);\\n                minQ.add(node);\\n                maxQ.add(node);\\n            }\\n        }\\n    }\\n    \\n    /** Returns one of the keys with maximal value. */\\n    public String getMaxKey() {\\n        return maxQ.isEmpty() ? \"\" : maxQ.peek().key;\\n    }\\n    \\n    /** Returns one of the keys with Minimal value. */\\n    public String getMinKey() {\\n        return minQ.isEmpty() ? \"\" : minQ.peek().key;\\n    }\\n}\\n\\n/**\\n * Your AllOne object will be instantiated and called as such:\\n * AllOne obj = new AllOne();\\n * obj.inc(key);\\n * obj.dec(key);\\n * String param_3 = obj.getMaxKey();\\n * String param_4 = obj.getMinKey();\\n */\\n```",
                "solutionTags": [],
                "code": "```\\npublic class AllOne {\\n\\n    class Node{\\n        String key;\\n        int val;\\n        public Node(String key, int val) {\\n            this.key = key;\\n            this.val = val;\\n        }\\n    }\\n    /** Initialize your data structure here. */\\n    HashMap<String, Node> map;\\n    PriorityQueue<Node> minQ;\\n    PriorityQueue<Node> maxQ;\\n    public AllOne() {\\n        map = new HashMap<String, Node>();\\n        minQ = new PriorityQueue<Node>(new Comparator<Node>(){\\n            public int compare(Node a, Node b) {\\n                return a.val - b.val;\\n            }\\n        });        \\n        maxQ = new PriorityQueue<Node>(new Comparator<Node>(){\\n            public int compare(Node a, Node b) {\\n                return b.val - a.val;\\n            }\\n        });\\n    }\\n    \\n    /** Inserts a new key <Key> with value 1. Or increments an existing key by 1. */\\n    public void inc(String key) {\\n        if (!map.containsKey(key)) {\\n            map.put(key, new Node(key, 1));\\n            Node node = map.get(key);\\n            minQ.add(node);\\n            maxQ.add(node);\\n        } else {\\n            Node node = map.get(key);\\n            minQ.remove(node);\\n            maxQ.remove(node);\\n            node.val++;\\n            map.put(key, node);\\n            minQ.add(node);\\n            maxQ.add(node);\\n        }\\n    }\\n    \\n    /** Decrements an existing key by 1. If Key's value is 1, remove it from the data structure. */\\n    public void dec(String key) {\\n        if (map.containsKey(key)) {\\n            Node node = map.get(key);\\n            if (node.val == 1) {\\n                map.remove(key);\\n                minQ.remove(node);\\n                maxQ.remove(node);\\n            } else {\\n                minQ.remove(node);\\n                maxQ.remove(node);\\n                node.val--;\\n                map.put(key, node);\\n                minQ.add(node);\\n                maxQ.add(node);\\n            }\\n        }\\n    }\\n    \\n    /** Returns one of the keys with maximal value. */\\n    public String getMaxKey() {\\n        return maxQ.isEmpty() ? \"\" : maxQ.peek().key;\\n    }\\n    \\n    /** Returns one of the keys with Minimal value. */\\n    public String getMinKey() {\\n        return minQ.isEmpty() ? \"\" : minQ.peek().key;\\n    }\\n}\\n\\n/**\\n * Your AllOne object will be instantiated and called as such:\\n * AllOne obj = new AllOne();\\n * obj.inc(key);\\n * obj.dec(key);\\n * String param_3 = obj.getMaxKey();\\n * String param_4 = obj.getMinKey();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 697096,
                "title": "swift-clean-code-diagram-doubly-linked-list-hash-map-hash-set",
                "content": "## Diagram\\nThis is how the data structure looks like after the following calls:\\n```swift\\nallOne.inc(\"a\")\\nallOne.inc(\"a\")\\n\\nallOne.inc(\"b\")\\n\\nallOne.inc(\"c\")\\nallOne.inc(\"c\")\\n\\nallOne.inc(\"d\")\\nallOne.inc(\"d\")\\nallOne.inc(\"d\")\\nallOne.inc(\"d\")\\n```\\n\\n![image](https://assets.leetcode.com/users/images/993ec8c8-f561-41ff-9bb6-be523a10e0a9_1592675316.8229218.png)\\n\\n## Complexity\\nInserting and removing nodes from a linked list is O(1) if we have a pointer to the target node, and that\\'s why we needed the hash map which maps each key to its node in the linked list. This is also O(1).\\n\\nAny new node will always hold an increased value (when `inc()` is called) or a decreased value (when `dec()` is called), and will be inserted before or after the current node. This means the linked list will always be sorted because we insert the nodes in an ordered way. And because the list is sorted, we can access the max and min value in O(1) from the head and the tail of the linked list.\\n\\nWhen moving a key from a node to the other we remove it from the old hash set O(1), and insert it in the new hash set O(1).\\n\\n**Summary**:\\n1. `inc()` & `dec()`:\\n\\t- Access/Insert/Remove from the hash map in O(1)\\n\\t- Insert/Remove from the linked list in O(1)\\n\\t- Insert/Remove from the hash set in O(1)\\n2. `getMinKey()` & `getMaxKey()`:\\n\\t- Access the head/tail of the linked list in O(1)\\n\\t- Get a key from the hash set in O(1)\\n\\n## Code\\n\\n```swift\\nclass AllOne {\\n\\tprivate var keyNodes = [String: Node]()\\n\\tprivate var head: Node? = Node()\\n\\tprivate var tail: Node? = Node()\\n\\n\\tinit() {\\n\\t\\thead?.next = tail\\n\\t\\ttail?.prev = head\\n\\t}\\n\\n\\tfunc inc(_ key: String) {\\n\\t\\tlet oldNode = keyNodes[key]\\n\\t\\tlet newValue = (oldNode?.value ?? 0) + 1\\n\\n\\t\\tvar newNode: Node?\\n\\t\\tif let node = (oldNode ?? head)?.next, node.value == newValue {\\n\\t\\t\\tnewNode = node\\n\\t\\t} else {\\n\\t\\t\\tnewNode = Node()\\n\\t\\t\\tnewNode?.value = newValue\\n\\t\\t\\t(oldNode ?? head)?.insertAfter(newNode)\\n\\t\\t}\\n\\n\\t\\tupdate(key, oldNode, newNode)\\n\\t}\\n\\n\\tfunc dec(_ key: String) {\\n\\t\\tguard let oldNode = keyNodes[key] else { return }\\n\\t\\tlet newValue = oldNode.value - 1\\n\\n\\t\\tvar newNode: Node?\\n\\t\\tif let node = oldNode.prev, node.value == newValue {\\n\\t\\t\\tnewNode = node\\n\\t\\t} else if newValue > 0 {\\n\\t\\t\\tnewNode = Node()\\n\\t\\t\\tnewNode?.value = newValue\\n\\t\\t\\toldNode.prev?.insertAfter(newNode)\\n\\t\\t}\\n\\n\\t\\tupdate(key, oldNode, newNode)\\n\\t}\\n\\n\\tfunc getMaxKey() -> String {\\n\\t\\treturn tail?.prev?.keys.first ?? \"\"\\n\\t}\\n\\n\\tfunc getMinKey() -> String {\\n\\t\\treturn head?.next?.keys.first ?? \"\"\\n\\t}\\n\\n\\tprivate func update(_ key: String, _ oldNode: Node?, _ newNode: Node?) {\\n\\t\\tnewNode?.keys.insert(key)\\n\\t\\tkeyNodes[key] = newNode\\n\\n\\t\\toldNode?.keys.remove(key)\\n\\t\\tif oldNode?.keys.isEmpty == true {\\n\\t\\t\\toldNode?.remove()\\n\\t\\t}\\n\\t}\\n}\\n\\nprivate class Node {\\n\\tvar value = -1\\n\\tvar keys = Set<String>()\\n\\tvar next: Node?\\n\\tvar prev: Node?\\n\\n\\tfunc insertAfter(_ newNode: Node?) {\\n\\t\\tlet after = self.next\\n\\t\\tself.next = newNode\\n\\t\\tnewNode?.prev = self\\n\\t\\tnewNode?.next = after\\n\\t\\tafter?.prev = newNode\\n\\t}\\n\\n\\tfunc remove() {\\n\\t\\tlet before = self.prev\\n\\t\\tlet after = self.next\\n\\t\\tbefore?.next = after\\n\\t\\tafter?.prev = before\\n\\t}\\n}\\n```",
                "solutionTags": [],
                "code": "```swift\\nallOne.inc(\"a\")\\nallOne.inc(\"a\")\\n\\nallOne.inc(\"b\")\\n\\nallOne.inc(\"c\")\\nallOne.inc(\"c\")\\n\\nallOne.inc(\"d\")\\nallOne.inc(\"d\")\\nallOne.inc(\"d\")\\nallOne.inc(\"d\")\\n```\n```swift\\nclass AllOne {\\n\\tprivate var keyNodes = [String: Node]()\\n\\tprivate var head: Node? = Node()\\n\\tprivate var tail: Node? = Node()\\n\\n\\tinit() {\\n\\t\\thead?.next = tail\\n\\t\\ttail?.prev = head\\n\\t}\\n\\n\\tfunc inc(_ key: String) {\\n\\t\\tlet oldNode = keyNodes[key]\\n\\t\\tlet newValue = (oldNode?.value ?? 0) + 1\\n\\n\\t\\tvar newNode: Node?\\n\\t\\tif let node = (oldNode ?? head)?.next, node.value == newValue {\\n\\t\\t\\tnewNode = node\\n\\t\\t} else {\\n\\t\\t\\tnewNode = Node()\\n\\t\\t\\tnewNode?.value = newValue\\n\\t\\t\\t(oldNode ?? head)?.insertAfter(newNode)\\n\\t\\t}\\n\\n\\t\\tupdate(key, oldNode, newNode)\\n\\t}\\n\\n\\tfunc dec(_ key: String) {\\n\\t\\tguard let oldNode = keyNodes[key] else { return }\\n\\t\\tlet newValue = oldNode.value - 1\\n\\n\\t\\tvar newNode: Node?\\n\\t\\tif let node = oldNode.prev, node.value == newValue {\\n\\t\\t\\tnewNode = node\\n\\t\\t} else if newValue > 0 {\\n\\t\\t\\tnewNode = Node()\\n\\t\\t\\tnewNode?.value = newValue\\n\\t\\t\\toldNode.prev?.insertAfter(newNode)\\n\\t\\t}\\n\\n\\t\\tupdate(key, oldNode, newNode)\\n\\t}\\n\\n\\tfunc getMaxKey() -> String {\\n\\t\\treturn tail?.prev?.keys.first ?? \"\"\\n\\t}\\n\\n\\tfunc getMinKey() -> String {\\n\\t\\treturn head?.next?.keys.first ?? \"\"\\n\\t}\\n\\n\\tprivate func update(_ key: String, _ oldNode: Node?, _ newNode: Node?) {\\n\\t\\tnewNode?.keys.insert(key)\\n\\t\\tkeyNodes[key] = newNode\\n\\n\\t\\toldNode?.keys.remove(key)\\n\\t\\tif oldNode?.keys.isEmpty == true {\\n\\t\\t\\toldNode?.remove()\\n\\t\\t}\\n\\t}\\n}\\n\\nprivate class Node {\\n\\tvar value = -1\\n\\tvar keys = Set<String>()\\n\\tvar next: Node?\\n\\tvar prev: Node?\\n\\n\\tfunc insertAfter(_ newNode: Node?) {\\n\\t\\tlet after = self.next\\n\\t\\tself.next = newNode\\n\\t\\tnewNode?.prev = self\\n\\t\\tnewNode?.next = after\\n\\t\\tafter?.prev = newNode\\n\\t}\\n\\n\\tfunc remove() {\\n\\t\\tlet before = self.prev\\n\\t\\tlet after = self.next\\n\\t\\tbefore?.next = after\\n\\t\\tafter?.prev = before\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 899093,
                "title": "python-dictionary-doubly-linked-list-solution-for-this-one-and-lru-cache",
                "content": "I borrowed the idea and most of the code from this post https://leetcode.com/problems/all-oone-data-structure/discuss/91401/Python-O(1)-doubly-linked-list-and-dictionary , thanks for the clear code! I found out this question and LC 146 LRU Cache share the same idea, so I made some change and paste both answer below. Please comment if you think there is better design. Thanks.\\n\\n432. All O`one Data Structure\\n```\\nclass Node(object):\\n    def __init__(self, val=0):\\n        self.num = val\\n        self.key_set = set()\\n        self.prev = None\\n        self.next = None\\n        \\nclass AllOne(object):\\n    def __init__(self):\\n        self.head = Node() \\n        self.tail = Node()  \\n        self.head.next = self.tail\\n        self.tail.prev = self.head\\n        self.cache = collections.defaultdict(Node)  \\n\\n    def inc(self, key):\\n        \"\"\"\\n        Inserts a new key <Key> with value 1. Or increments an existing key by 1.\\n        \"\"\"\\n        if not key in self.cache:  \\n            cur = self.head\\n        else:\\n            cur = self.cache[key]\\n            cur.key_set.remove(key)\\n\\n        if cur.num + 1 != cur.next.num:  \\n            new_node = Node(cur.num + 1)\\n            self._insert_after(cur, new_node)\\n        else:\\n            new_node = cur.next\\n\\n        new_node.key_set.add(key)  \\n        self.cache[key] = new_node  \\n\\n        if not cur.key_set and cur.num != 0:  \\n            self._remove(cur)\\n\\n    def dec(self, key):\\n        \"\"\"\\n        Decrements an existing key by 1. If Key\\'s value is 1, remove it from the data structure.\\n        \"\"\"\\n        if not key in self.cache:\\n            return\\n\\n        cur = self.cache[key]\\n        self.cache.pop(key)  \\n        cur.key_set.remove(key)\\n\\n        if cur.num != 1:\\n            if cur.num - 1 != cur.prev.num:  \\n                new_node = Node(cur.num - 1)\\n                self._insert_after(cur.prev, new_node)\\n            else:\\n                new_node = cur.prev\\n            new_node.key_set.add(key)\\n            self.cache[key] = new_node\\n\\n        if not cur.key_set and cur.num != 0:  \\n            self._remove(cur)\\n\\n    def getMaxKey(self):\\n        \"\"\"\\n        Returns one of the keys with maximal value.\\n        \"\"\"\\n        if self.tail.prev.num == 0:\\n            return \"\"\\n        key = self.tail.prev.key_set.pop()  # pop and add back to get arbitrary (but not random) element\\n        self.tail.prev.key_set.add(key)\\n        return key\\n\\n    def getMinKey(self):\\n        \"\"\"\\n        Returns one of the keys with Minimal value.\\n        \"\"\"\\n        if self.head.next.num == 0:\\n            return \"\"\\n        key = self.head.next.key_set.pop()\\n        self.head.next.key_set.add(key)\\n        return key\\n\\n    def _remove(self, node):\\n        p = node.prev\\n        n = node.next\\n        p.next = n\\n        n.prev = p\\n\\n    def _insert_after(self, node, new_block):\\n        old_after = node.next\\n        node.next = new_block\\n        new_block.prev = node\\n        new_block.next = old_after\\n        old_after.prev = new_block\\n```\\n\\n146. LRU Cache\\n```\\nclass ListNode:\\n    def __init__(self, k, v):\\n        self.key = k\\n        self.val = v\\n        self.prev = None\\n        self.next = None\\n        \\nclass LRUCache: \\n    def __init__(self, capacity):\\n        self.capacity = capacity\\n        self.cache = collections.defaultdict(ListNode)\\n        self.head = ListNode(0, 0)  # dummy head\\n        self.tail = ListNode(0, 0)  # dummy tail\\n        self.head.next = self.tail\\n        self.tail.prev = self.head\\n\\n    def get(self, key):\\n        if key in self.cache:\\n            n = self.cache[key]\\n            self._remove_from_list(n)\\n            self._add_list_end(n)\\n            return n.val\\n        return -1\\n\\n    def put(self, key, value):\\n        # 1. move if exist\\n        if key in self.cache:\\n            self._remove_from_list(self.cache[key])\\n        # 2. add in linkedlist and dict\\n        n = ListNode(key, value)\\n        self._add_list_end(n)\\n        self.cache[key] = n\\n        # 3. post process to evict keys\\n        if len(self.cache) > self.capacity:\\n            n = self.head.next\\n            self._remove_from_list(n)\\n            self.cache.pop(n.key)\\n\\n    def _remove_from_list(self, node):\\n        p = node.prev\\n        n = node.next\\n        p.next = n\\n        n.prev = p\\n\\n    def _add_list_end(self, node):\\n        p = self.tail.prev\\n        p.next = node\\n        self.tail.prev = node\\n        node.prev = p\\n        node.next = self.tail   \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Node(object):\\n    def __init__(self, val=0):\\n        self.num = val\\n        self.key_set = set()\\n        self.prev = None\\n        self.next = None\\n        \\nclass AllOne(object):\\n    def __init__(self):\\n        self.head = Node() \\n        self.tail = Node()  \\n        self.head.next = self.tail\\n        self.tail.prev = self.head\\n        self.cache = collections.defaultdict(Node)  \\n\\n    def inc(self, key):\\n        \"\"\"\\n        Inserts a new key <Key> with value 1. Or increments an existing key by 1.\\n        \"\"\"\\n        if not key in self.cache:  \\n            cur = self.head\\n        else:\\n            cur = self.cache[key]\\n            cur.key_set.remove(key)\\n\\n        if cur.num + 1 != cur.next.num:  \\n            new_node = Node(cur.num + 1)\\n            self._insert_after(cur, new_node)\\n        else:\\n            new_node = cur.next\\n\\n        new_node.key_set.add(key)  \\n        self.cache[key] = new_node  \\n\\n        if not cur.key_set and cur.num != 0:  \\n            self._remove(cur)\\n\\n    def dec(self, key):\\n        \"\"\"\\n        Decrements an existing key by 1. If Key\\'s value is 1, remove it from the data structure.\\n        \"\"\"\\n        if not key in self.cache:\\n            return\\n\\n        cur = self.cache[key]\\n        self.cache.pop(key)  \\n        cur.key_set.remove(key)\\n\\n        if cur.num != 1:\\n            if cur.num - 1 != cur.prev.num:  \\n                new_node = Node(cur.num - 1)\\n                self._insert_after(cur.prev, new_node)\\n            else:\\n                new_node = cur.prev\\n            new_node.key_set.add(key)\\n            self.cache[key] = new_node\\n\\n        if not cur.key_set and cur.num != 0:  \\n            self._remove(cur)\\n\\n    def getMaxKey(self):\\n        \"\"\"\\n        Returns one of the keys with maximal value.\\n        \"\"\"\\n        if self.tail.prev.num == 0:\\n            return \"\"\\n        key = self.tail.prev.key_set.pop()  # pop and add back to get arbitrary (but not random) element\\n        self.tail.prev.key_set.add(key)\\n        return key\\n\\n    def getMinKey(self):\\n        \"\"\"\\n        Returns one of the keys with Minimal value.\\n        \"\"\"\\n        if self.head.next.num == 0:\\n            return \"\"\\n        key = self.head.next.key_set.pop()\\n        self.head.next.key_set.add(key)\\n        return key\\n\\n    def _remove(self, node):\\n        p = node.prev\\n        n = node.next\\n        p.next = n\\n        n.prev = p\\n\\n    def _insert_after(self, node, new_block):\\n        old_after = node.next\\n        node.next = new_block\\n        new_block.prev = node\\n        new_block.next = old_after\\n        old_after.prev = new_block\\n```\n```\\nclass ListNode:\\n    def __init__(self, k, v):\\n        self.key = k\\n        self.val = v\\n        self.prev = None\\n        self.next = None\\n        \\nclass LRUCache: \\n    def __init__(self, capacity):\\n        self.capacity = capacity\\n        self.cache = collections.defaultdict(ListNode)\\n        self.head = ListNode(0, 0)  # dummy head\\n        self.tail = ListNode(0, 0)  # dummy tail\\n        self.head.next = self.tail\\n        self.tail.prev = self.head\\n\\n    def get(self, key):\\n        if key in self.cache:\\n            n = self.cache[key]\\n            self._remove_from_list(n)\\n            self._add_list_end(n)\\n            return n.val\\n        return -1\\n\\n    def put(self, key, value):\\n        # 1. move if exist\\n        if key in self.cache:\\n            self._remove_from_list(self.cache[key])\\n        # 2. add in linkedlist and dict\\n        n = ListNode(key, value)\\n        self._add_list_end(n)\\n        self.cache[key] = n\\n        # 3. post process to evict keys\\n        if len(self.cache) > self.capacity:\\n            n = self.head.next\\n            self._remove_from_list(n)\\n            self.cache.pop(n.key)\\n\\n    def _remove_from_list(self, node):\\n        p = node.prev\\n        n = node.next\\n        p.next = n\\n        n.prev = p\\n\\n    def _add_list_end(self, node):\\n        p = self.tail.prev\\n        p.next = node\\n        self.tail.prev = node\\n        node.prev = p\\n        node.next = self.tail   \\n```",
                "codeTag": "Java"
            },
            {
                "id": 616577,
                "title": "simple-c-solution",
                "content": "```\\nclass AllOne {\\n    /** Initialize your data structure here. */\\n    list<pair<int,unordered_set<string>>> ls;                                   // double linked list for pair of (value, unordered_set of keys), sorted\\n    unordered_map<string,list<pair<int,unordered_set<string>>>::iterator> mp;   // hash map for mapping key to list iterator\\npublic:\\n    AllOne() {   \\n    }\\n    \\n    void inc(string key) {\\n        if (!mp.count(key))\\n            mp[key] = ls.insert(ls.begin(),{0,{key}});                          // if key doesn\\'t exist, insert one with value=0 into list, and update map\\n        \\n        auto itr = mp[key];                 // get the iterator of list for the key\\n        auto itrNext = next(itr);           // get the next iterator of itr\\n        if (itrNext==ls.end() || itr->first+1 < itrNext->first)                 // two cases: need to create a new element for the list\\n            itrNext = ls.insert(itrNext,{itr->first+1,{}});\\n        itrNext->second.insert(key);        // insert key into the element with value == itr->first+1\\n        mp[key] = itrNext;                  // update mp[key]\\n        \\n        itr->second.erase(key);             // remove key from the element, pointed by itr\\n        if (itr->second.empty())            // if itr->hashSet with keys is empty, remove this element from list\\n            ls.erase(itr);\\n    }\\n\\n    void dec(string key) {\\n        if (!mp.count(key))                 // if key doesn\\'t exist, return\\n            return;\\n        auto itr = mp[key];                 // get the iterator of the list for the key\\n        auto itrPrev = prev(itr);           // get the previous iterator of itr\\n        mp.erase(key);                      // remove key from hash map first\\n        if (itr->first>1) {                 // for the case, itr->value - 1 > 0\\n            if (itr==ls.begin() || itr->first-1 > itrPrev->first)               // two cases: need to create a new element for the list\\n                itrPrev = ls.insert(itr,{itr->first-1,{}});\\n            itrPrev->second.insert(key);    // insert key into the element with value == itr->first-1\\n            mp[key] = itrPrev;              // create mp[key]\\n        }\\n        itr->second.erase(key);             // remove key from the element, pointed by itr\\n        if (itr->second.empty())            // if itr->hashSet with keys is empty, remove this element from list\\n            ls.erase(itr);\\n    }\\n    \\n    string getMaxKey() {\\n        return mp.empty() ? \"\" : *ls.rbegin()->second.begin();                  // return the last element of the list\\n    }\\n    \\n    string getMinKey() {\\n        return mp.empty() ? \"\" : *ls.begin()->second.begin();                   // return the first element of the list\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass AllOne {\\n    /** Initialize your data structure here. */\\n    list<pair<int,unordered_set<string>>> ls;                                   // double linked list for pair of (value, unordered_set of keys), sorted\\n    unordered_map<string,list<pair<int,unordered_set<string>>>::iterator> mp;   // hash map for mapping key to list iterator\\npublic:\\n    AllOne() {   \\n    }\\n    \\n    void inc(string key) {\\n        if (!mp.count(key))\\n            mp[key] = ls.insert(ls.begin(),{0,{key}});                          // if key doesn\\'t exist, insert one with value=0 into list, and update map\\n        \\n        auto itr = mp[key];                 // get the iterator of list for the key\\n        auto itrNext = next(itr);           // get the next iterator of itr\\n        if (itrNext==ls.end() || itr->first+1 < itrNext->first)                 // two cases: need to create a new element for the list\\n            itrNext = ls.insert(itrNext,{itr->first+1,{}});\\n        itrNext->second.insert(key);        // insert key into the element with value == itr->first+1\\n        mp[key] = itrNext;                  // update mp[key]\\n        \\n        itr->second.erase(key);             // remove key from the element, pointed by itr\\n        if (itr->second.empty())            // if itr->hashSet with keys is empty, remove this element from list\\n            ls.erase(itr);\\n    }\\n\\n    void dec(string key) {\\n        if (!mp.count(key))                 // if key doesn\\'t exist, return\\n            return;\\n        auto itr = mp[key];                 // get the iterator of the list for the key\\n        auto itrPrev = prev(itr);           // get the previous iterator of itr\\n        mp.erase(key);                      // remove key from hash map first\\n        if (itr->first>1) {                 // for the case, itr->value - 1 > 0\\n            if (itr==ls.begin() || itr->first-1 > itrPrev->first)               // two cases: need to create a new element for the list\\n                itrPrev = ls.insert(itr,{itr->first-1,{}});\\n            itrPrev->second.insert(key);    // insert key into the element with value == itr->first-1\\n            mp[key] = itrPrev;              // create mp[key]\\n        }\\n        itr->second.erase(key);             // remove key from the element, pointed by itr\\n        if (itr->second.empty())            // if itr->hashSet with keys is empty, remove this element from list\\n            ls.erase(itr);\\n    }\\n    \\n    string getMaxKey() {\\n        return mp.empty() ? \"\" : *ls.rbegin()->second.begin();                  // return the last element of the list\\n    }\\n    \\n    string getMinKey() {\\n        return mp.empty() ? \"\" : *ls.begin()->second.begin();                   // return the first element of the list\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1229078,
                "title": "java-one-map-double-linked-list-clean-code",
                "content": "```\\nclass AllOne {\\n    class Node {\\n        int count;\\n        Set<String> keys = new HashSet<>(); \\n        Node l, r;\\n        Node(String key, int count) {\\n            this.keys.add(key);\\n            this.count = count;\\n        }\\n        void insertRight(Node node) {\\n            node.l = this;\\n            node.r = this.r;\\n            this.r.l = node;\\n            this.r = node;\\n        }\\n        void remove() {\\n            this.l.r = this.r;\\n            this.r.l = this.l;\\n        }\\n    }\\n\\n    Map<String, Node> map = new HashMap<>();\\n    Node head = new Node(\"\", -1), tail = new Node(\"\", -1);    \\n    /** Initialize your data structure here. */\\n    public AllOne() {\\n        head.r = tail;\\n        tail.l = head;\\n    }\\n    \\n      /** Inserts a new key <Key> with value 1. Or increments an existing key by 1. */\\n  public void inc(String key) {\\n    Node node = head;       // if new key point to the head\\n    if (map.containsKey(key))\\n      node = map.get(key); // not new key, get from map\\n    node.keys.remove(key); // remove current key from key\\n    int count = node==head? 1: node.count+1; // count + 1\\n    if (node.r.count != count) // inert a right node if its right node \\'s count is not equals to count+1\\n      node.insertRight(new Node(key, count));\\n    node.r.keys.add(key);     // put this key into its right node \\'s keys set    \\n    map.put(key, node.r);     // map the key to the node with count+1 \\n    if (node != head && node.keys.isEmpty()) // empty node which should be removed\\n      node.remove();\\n  }\\n\\n  /** Decrements an existing key by 1. If Key\\'s value is 1, remove it from the data structure. */\\n  public void dec(String key) {\\n    if (!map.containsKey(key)) return;\\n    Node node = map.get(key);   // get current node from map\\n    node.keys.remove(key);      // remove key from current node\\'s keys set\\n    if (node.count > 1) {       // find the count - 1 node\\n      if (node.l.count != node.count-1) // inert a left node if its left node\\'s count is not equals to count-1\\n        node.l.insertRight(new Node(key, node.count-1));\\n      node.l.keys.add(key);   // put this key into its left node \\'s keys set   \\n      map.put(key, node.l);   // map the key to the node with count-1 \\n    } else // remove the key if its count is 1\\n        map.remove(key);\\n    if (node.keys.isEmpty())  // empty node which should be removed\\n      node.remove();\\n  }\\n\\n  /** Returns one of the keys with maximal value. */\\n  public String getMaxKey() {\\n    if (tail.l == head) return \"\";\\n    return tail.l.keys.iterator().next(); \\n  }\\n\\n  /** Returns one of the keys with Minimal value. */\\n  public String getMinKey() {\\n    if (head.r == tail) return \"\";\\n    return head.r.keys.iterator().next();\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Doubly-Linked List"
                ],
                "code": "```\\nclass AllOne {\\n    class Node {\\n        int count;\\n        Set<String> keys = new HashSet<>(); \\n        Node l, r;\\n        Node(String key, int count) {\\n            this.keys.add(key);\\n            this.count = count;\\n        }\\n        void insertRight(Node node) {\\n            node.l = this;\\n            node.r = this.r;\\n            this.r.l = node;\\n            this.r = node;\\n        }\\n        void remove() {\\n            this.l.r = this.r;\\n            this.r.l = this.l;\\n        }\\n    }\\n\\n    Map<String, Node> map = new HashMap<>();\\n    Node head = new Node(\"\", -1), tail = new Node(\"\", -1);    \\n    /** Initialize your data structure here. */\\n    public AllOne() {\\n        head.r = tail;\\n        tail.l = head;\\n    }\\n    \\n      /** Inserts a new key <Key> with value 1. Or increments an existing key by 1. */\\n  public void inc(String key) {\\n    Node node = head;       // if new key point to the head\\n    if (map.containsKey(key))\\n      node = map.get(key); // not new key, get from map\\n    node.keys.remove(key); // remove current key from key\\n    int count = node==head? 1: node.count+1; // count + 1\\n    if (node.r.count != count) // inert a right node if its right node \\'s count is not equals to count+1\\n      node.insertRight(new Node(key, count));\\n    node.r.keys.add(key);     // put this key into its right node \\'s keys set    \\n    map.put(key, node.r);     // map the key to the node with count+1 \\n    if (node != head && node.keys.isEmpty()) // empty node which should be removed\\n      node.remove();\\n  }\\n\\n  /** Decrements an existing key by 1. If Key\\'s value is 1, remove it from the data structure. */\\n  public void dec(String key) {\\n    if (!map.containsKey(key)) return;\\n    Node node = map.get(key);   // get current node from map\\n    node.keys.remove(key);      // remove key from current node\\'s keys set\\n    if (node.count > 1) {       // find the count - 1 node\\n      if (node.l.count != node.count-1) // inert a left node if its left node\\'s count is not equals to count-1\\n        node.l.insertRight(new Node(key, node.count-1));\\n      node.l.keys.add(key);   // put this key into its left node \\'s keys set   \\n      map.put(key, node.l);   // map the key to the node with count-1 \\n    } else // remove the key if its count is 1\\n        map.remove(key);\\n    if (node.keys.isEmpty())  // empty node which should be removed\\n      node.remove();\\n  }\\n\\n  /** Returns one of the keys with maximal value. */\\n  public String getMaxKey() {\\n    if (tail.l == head) return \"\";\\n    return tail.l.keys.iterator().next(); \\n  }\\n\\n  /** Returns one of the keys with Minimal value. */\\n  public String getMinKey() {\\n    if (head.r == tail) return \"\";\\n    return head.r.keys.iterator().next();\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 426877,
                "title": "python-3-doulbly-linked-list-and-oop-style-easy-to-follow-through",
                "content": "```\\nclass Node:\\n    def __init__(self, elements=[]):\\n        self.left = None\\n        self.right = None\\n        self.elements = set(elements)\\n\\n    def addBetween(self, node1, node2):\\n        self.left = node1\\n        self.right = node2\\n\\n        node1.right = self\\n        node2.left = self\\n    \\n    def deleteNode(self):\\n        left, right = self.left, self.right\\n        left.right = right\\n        right.left = left\\n            \\n\\t\\t\\t\\nclass AllOne:\\n    def __init__(self):\\n        self.keyToNum = {}\\n        self.numToNode = {}\\n        \\n        self.head, self.tail = Node(), Node()\\n        self.head.right = self.tail\\n        self.tail.left = self.head\\n        \\n    def inc(self, key: str) -> None:\\n        keyToNum = self.keyToNum\\n        numToNode = self.numToNode\\n\\n        if key not in keyToNum:\\n            keyToNum[key] = 1\\n            if 1 in numToNode:\\n                numToNode[1].elements.add(key)\\n            else:\\n                newNode = Node([key])\\n                numToNode[1] = newNode\\n                newNode.addBetween(self.head, self.head.right)                \\n        else:\\n            oldNum = keyToNum[key]\\n            oldNode = numToNode[oldNum]\\n            \\n            newNum = oldNum + 1\\n            keyToNum[key] = newNum\\n\\n            if newNum in numToNode:\\n                numToNode[newNum].elements.add(key)\\n            else:\\n                newNode = Node([key])\\n                numToNode[newNum] = newNode\\n                newNode.addBetween(oldNode, oldNode.right)\\n            \\n            oldNode.elements.discard(key)\\n            if not oldNode.elements:\\n                oldNode.deleteNode()\\n                del numToNode[oldNum]\\n\\n    def dec(self, key: str) -> None:\\n        keyToNum = self.keyToNum\\n        numToNode = self.numToNode\\n        \\n        if key not in keyToNum:\\n            return\\n        \\n        oldNum = keyToNum[key]\\n        oldNode = numToNode[oldNum]\\n        \\n        if oldNum == 1:\\n            del keyToNum[key]\\n        else:\\n            newNum = oldNum - 1\\n            keyToNum[key] = newNum\\n\\t\\t\\t\\n            if newNum in numToNode:\\n                newNode = numToNode[newNum]\\n                newNode.elements.add(key)\\n            else:\\n                newNode = Node([key])\\n                numToNode[newNum] = newNode\\n                oldLeft = oldNode.left\\n                newNode.addBetween(oldLeft, oldNode)\\n                \\n        oldNode.elements.discard(key)\\n        if not oldNode.elements:\\n            oldNode.deleteNode()\\n            del numToNode[oldNum]\\n\\n    def getMaxKey(self) -> str:\\n        if self.tail.left == self.head:\\n            return \\'\\'\\n        else:\\n            for e in self.tail.left.elements:\\n                return e\\n\\n    def getMinKey(self) -> str:\\n        if self.head.right == self.tail:\\n            return \\'\\'\\n        else:\\n            for e in self.head.right.elements:\\n                return e\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Node:\\n    def __init__(self, elements=[]):\\n        self.left = None\\n        self.right = None\\n        self.elements = set(elements)\\n\\n    def addBetween(self, node1, node2):\\n        self.left = node1\\n        self.right = node2\\n\\n        node1.right = self\\n        node2.left = self\\n    \\n    def deleteNode(self):\\n        left, right = self.left, self.right\\n        left.right = right\\n        right.left = left\\n            \\n\\t\\t\\t\\nclass AllOne:\\n    def __init__(self):\\n        self.keyToNum = {}\\n        self.numToNode = {}\\n        \\n        self.head, self.tail = Node(), Node()\\n        self.head.right = self.tail\\n        self.tail.left = self.head\\n        \\n    def inc(self, key: str) -> None:\\n        keyToNum = self.keyToNum\\n        numToNode = self.numToNode\\n\\n        if key not in keyToNum:\\n            keyToNum[key] = 1\\n            if 1 in numToNode:\\n                numToNode[1].elements.add(key)\\n            else:\\n                newNode = Node([key])\\n                numToNode[1] = newNode\\n                newNode.addBetween(self.head, self.head.right)                \\n        else:\\n            oldNum = keyToNum[key]\\n            oldNode = numToNode[oldNum]\\n            \\n            newNum = oldNum + 1\\n            keyToNum[key] = newNum\\n\\n            if newNum in numToNode:\\n                numToNode[newNum].elements.add(key)\\n            else:\\n                newNode = Node([key])\\n                numToNode[newNum] = newNode\\n                newNode.addBetween(oldNode, oldNode.right)\\n            \\n            oldNode.elements.discard(key)\\n            if not oldNode.elements:\\n                oldNode.deleteNode()\\n                del numToNode[oldNum]\\n\\n    def dec(self, key: str) -> None:\\n        keyToNum = self.keyToNum\\n        numToNode = self.numToNode\\n        \\n        if key not in keyToNum:\\n            return\\n        \\n        oldNum = keyToNum[key]\\n        oldNode = numToNode[oldNum]\\n        \\n        if oldNum == 1:\\n            del keyToNum[key]\\n        else:\\n            newNum = oldNum - 1\\n            keyToNum[key] = newNum\\n\\t\\t\\t\\n            if newNum in numToNode:\\n                newNode = numToNode[newNum]\\n                newNode.elements.add(key)\\n            else:\\n                newNode = Node([key])\\n                numToNode[newNum] = newNode\\n                oldLeft = oldNode.left\\n                newNode.addBetween(oldLeft, oldNode)\\n                \\n        oldNode.elements.discard(key)\\n        if not oldNode.elements:\\n            oldNode.deleteNode()\\n            del numToNode[oldNum]\\n\\n    def getMaxKey(self) -> str:\\n        if self.tail.left == self.head:\\n            return \\'\\'\\n        else:\\n            for e in self.tail.left.elements:\\n                return e\\n\\n    def getMinKey(self) -> str:\\n        if self.head.right == self.tail:\\n            return \\'\\'\\n        else:\\n            for e in self.head.right.elements:\\n                return e\\n```",
                "codeTag": "Java"
            },
            {
                "id": 91442,
                "title": "accepted-java-and-python-solution",
                "content": "\\n\\n\\nJava:\\n````\\npublic class AllOne {\\n    Node head;\\n    Node tail;\\n    \\n    Map<String, Integer> keyCountMap;\\n    Map<Integer, Node> countNodeMap;\\n    Map<Integer, Set<String>> countKeyMap;\\n    \\n    class Node {\\n        int count;\\n        Node prev;\\n        Node next;\\n        \\n        public Node(int cnt) {\\n            count = cnt;\\n            prev = null;\\n            next = null;\\n        }\\n    }\\n    /** Initialize your data structure here. */\\n    public AllOne() {\\n        head = new Node(0);\\n        tail = new Node(Integer.MAX_VALUE);\\n        head.next = tail;\\n        tail.prev = head;\\n        \\n        keyCountMap = new HashMap<>();\\n        countNodeMap = new HashMap<>();\\n        countKeyMap = new HashMap<>();\\n        \\n        countNodeMap.put(0, head);\\n        countNodeMap.put(Integer.MAX_VALUE, tail);\\n    }\\n    \\n    /** Inserts a new key <Key> with value 1. Or increments an existing key by 1. */\\n    public void inc(String key) {\\n        if (!keyCountMap.containsKey(key)) {\\n            keyCountMap.put(key, 0);\\n        }\\n        \\n        int preCount = keyCountMap.get(key);\\n        Node preNode = countNodeMap.get(preCount);\\n        \\n        keyCountMap.put(key, preCount + 1);\\n        int newCount = keyCountMap.get(key);\\n        \\n        //insert\\n        //new count is created\\n        if (newCount != preNode.next.count) {\\n            Node newNode = new Node(newCount);\\n            insert(preNode, newNode);\\n            \\n            countKeyMap.put(newCount, new HashSet<String>());\\n            countNodeMap.put(newCount, newNode);\\n        }\\n        countKeyMap.get(newCount).add(key);\\n        \\n        //delete old\\n        if (preCount > 0) {\\n            Set<String> oldSet = countKeyMap.get(preCount);\\n            oldSet.remove(key);\\n            if (oldSet.isEmpty()) {\\n                delete(preNode);\\n                countKeyMap.remove(preCount);\\n                countNodeMap.remove(preCount);\\n            }            \\n        }\\n\\n    }\\n    \\n    /** Decrements an existing key by 1. If Key's value is 1, remove it from the data structure. */\\n    public void dec(String key) {\\n        if (!keyCountMap.containsKey(key)) return;\\n        \\n        int preCount = keyCountMap.get(key);\\n        Node preNode = countNodeMap.get(preCount);\\n        \\n        keyCountMap.put(key, preCount - 1);\\n        int newCount = keyCountMap.get(key);\\n        \\n        //insert\\n        //new count occurs\\n        if (newCount != 0) {\\n            if (newCount != preNode.prev.count) {\\n                Node newNode = new Node(newCount);\\n                insert(preNode.prev, newNode);\\n                \\n                countKeyMap.put(newCount, new HashSet<String>());\\n                countNodeMap.put(newCount, newNode);\\n            }\\n            countKeyMap.get(newCount).add(key);            \\n        }\\n        else keyCountMap.remove(key);\\n\\n        //delete\\n        Set<String> oldSet = countKeyMap.get(preCount);\\n        oldSet.remove(key);\\n        if (oldSet.isEmpty()) {\\n            delete(preNode);\\n            countKeyMap.remove(preCount);\\n            countNodeMap.remove(preCount);\\n        }\\n    }\\n    \\n    /** Returns one of the keys with maximal value. */\\n    public String getMaxKey() {\\n        if (head.next == tail) {\\n            System.out.println(\"head == tail\");\\n            return \"\";\\n        }\\n        Set<String> set = countKeyMap.get(tail.prev.count);\\n        return set.iterator().next();\\n    }\\n    \\n    /** Returns one of the keys with Minimal value. */\\n    public String getMinKey() {\\n        if (head.next == tail) return \"\";\\n        Set<String> set = countKeyMap.get(head.next.count);\\n        return set.iterator().next();\\n    }\\n    \\n    public void insert(Node preNode, Node node) {\\n        node.next = preNode.next;\\n        node.prev = preNode;\\n        \\n        node.next.prev = node;\\n        node.prev.next = node;\\n    }\\n    \\n    public void delete(Node node) {\\n        node.next.prev = node.prev;\\n        node.prev.next = node.next;\\n    }\\n}\\n````\\n\\nPython:\\n\\n````\\nfrom sets import Set\\nclass Node:\\n    def __init__(self, cnt):\\n        self.count = cnt\\n        self.prev = None\\n        self.next = None\\n\\n\\nclass AllOne(object):\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        #Key:count, Value:set of key who has been incremented by 'count' time\\n        self.count_key_map = {}\\n        #Key:key, Value: the number of counts of this key\\n        self.key_count_map = {}\\n        #Key: the count, Value: the node\\n        self.count_node_map = {}\\n        \\n        #initialize the linkedlist with dummy node\\n        self.head = Node(0)\\n        self.tail = Node(float('inf'))\\n        self.head.next = self.tail\\n        self.tail.prev = self.head\\n        \\n        self.count_node_map[0] = self.head\\n        self.count_node_map[float('inf')] = self.tail\\n\\n    def inc(self, key):\\n        \"\"\"\\n        Inserts a new key <Key> with value 1. Or increments an existing key by 1.\\n        :type key: str\\n        :rtype: void\\n        \"\"\"\\n        if key not in self.key_count_map:\\n            self.key_count_map[key] = 0\\n        \\n        prev_count = self.key_count_map[key]\\n        prev_node = self.count_node_map[prev_count]\\n        \\n        #update the key map:\\n        self.key_count_map[key] += 1\\n        #insert new node:\\n        #new count occurs\\n        if prev_node.next.count != self.key_count_map[key]:\\n            #if a new count is created insert then node\\n            new_node = Node(self.key_count_map[key])\\n            self.insert(prev_node, new_node)\\n         \\n            #update 'node_map' and 'count_map'\\n            self.count_node_map[self.key_count_map[key]] = new_node\\n            self.count_key_map[self.key_count_map[key]] = Set()\\n        #if the new count is the same as the count in next node\\n        self.count_key_map[self.key_count_map[key]].add(key)\\n        \\n        #delelte the key in the prev-node\\n        if prev_count != 0:\\n            self.count_key_map[prev_count].remove(key)\\n            if len(self.count_key_map[prev_count]) == 0:\\n                self.delete(prev_node)\\n                self.count_key_map.pop(prev_count)\\n                self.count_node_map.pop(prev_count)\\n    \\n        \\n\\n    def dec(self, key):\\n        \"\"\"\\n        Decrements an existing key by 1. If Key's value is 1, remove it from the data structure.\\n        :type key: str\\n        :rtype: void\\n        \"\"\"\\n        if key not in self.key_count_map:\\n            return\\n        \\n        prev_count = self.key_count_map[key]\\n        prev_node = self.count_node_map[prev_count]\\n        \\n        self.key_count_map[key] -= 1\\n        \\n        #insert new node\\n        #if the count becomes 0\\n        if self.key_count_map[key] == 0:\\n            self.key_count_map.pop(key)\\n        else:\\n            if self.key_count_map[key] !=  prev_node.prev.count:\\n                new_node = Node(self.key_count_map[key])\\n                self.insert(prev_node.prev, new_node)\\n                \\n                self.count_node_map[self.key_count_map[key]] = new_node\\n                self.count_key_map[self.key_count_map[key]] = Set()\\n\\n            self.count_key_map[self.key_count_map[key]].add(key)\\n                \\n        #delete\\n        self.count_key_map[prev_count].remove(key)\\n        if len(self.count_key_map[prev_count]) == 0:\\n            self.delete(prev_node)\\n            self.count_key_map.pop(prev_count)\\n            self.count_node_map.pop(prev_count)\\n            \\n    def getMaxKey(self):\\n        \"\"\"\\n        Returns one of the keys with maximal value.\\n        :rtype: str\\n        \"\"\"\\n        if self.head.next == self.tail:\\n            return \"\"\\n        x = self.count_key_map[self.tail.prev.count].pop()\\n        self.count_key_map[self.tail.prev.count].add(x)\\n        return x\\n        \\n\\n    def getMinKey(self):\\n        \"\"\"\\n        Returns one of the keys with Minimal value.\\n        :rtype: str\\n        \"\"\"\\n        if self.head.next == self.tail:\\n            return \"\"\\n        x = self.count_key_map[self.head.next.count].pop()\\n        self.count_key_map[self.head.next.count].add(x)\\n        return x\\n        \\n    #insert 'node' after prev_node O(1) \\n    def insert(self, prev_node, node):\\n        node.next = prev_node.next\\n        node.prev = prev_node\\n        \\n        node.next.prev = node\\n        node.prev.next = node\\n        \\n    def delete(self, node):\\n        node.next.prev = node.prev\\n        node.prev.next = node.next\\n````",
                "solutionTags": [],
                "code": "````\\npublic class AllOne {\\n    Node head;\\n    Node tail;\\n    \\n    Map<String, Integer> keyCountMap;\\n    Map<Integer, Node> countNodeMap;\\n    Map<Integer, Set<String>> countKeyMap;\\n    \\n    class Node {\\n        int count;\\n        Node prev;\\n        Node next;\\n        \\n        public Node(int cnt) {\\n            count = cnt;\\n            prev = null;\\n            next = null;\\n        }\\n    }\\n    /** Initialize your data structure here. */\\n    public AllOne() {\\n        head = new Node(0);\\n        tail = new Node(Integer.MAX_VALUE);\\n        head.next = tail;\\n        tail.prev = head;\\n        \\n        keyCountMap = new HashMap<>();\\n        countNodeMap = new HashMap<>();\\n        countKeyMap = new HashMap<>();\\n        \\n        countNodeMap.put(0, head);\\n        countNodeMap.put(Integer.MAX_VALUE, tail);\\n    }\\n    \\n    /** Inserts a new key <Key> with value 1. Or increments an existing key by 1. */\\n    public void inc(String key) {\\n        if (!keyCountMap.containsKey(key)) {\\n            keyCountMap.put(key, 0);\\n        }\\n        \\n        int preCount = keyCountMap.get(key);\\n        Node preNode = countNodeMap.get(preCount);\\n        \\n        keyCountMap.put(key, preCount + 1);\\n        int newCount = keyCountMap.get(key);\\n        \\n        //insert\\n        //new count is created\\n        if (newCount != preNode.next.count) {\\n            Node newNode = new Node(newCount);\\n            insert(preNode, newNode);\\n            \\n            countKeyMap.put(newCount, new HashSet<String>());\\n            countNodeMap.put(newCount, newNode);\\n        }\\n        countKeyMap.get(newCount).add(key);\\n        \\n        //delete old\\n        if (preCount > 0) {\\n            Set<String> oldSet = countKeyMap.get(preCount);\\n            oldSet.remove(key);\\n            if (oldSet.isEmpty()) {\\n                delete(preNode);\\n                countKeyMap.remove(preCount);\\n                countNodeMap.remove(preCount);\\n            }            \\n        }\\n\\n    }\\n    \\n    /** Decrements an existing key by 1. If Key's value is 1, remove it from the data structure. */\\n    public void dec(String key) {\\n        if (!keyCountMap.containsKey(key)) return;\\n        \\n        int preCount = keyCountMap.get(key);\\n        Node preNode = countNodeMap.get(preCount);\\n        \\n        keyCountMap.put(key, preCount - 1);\\n        int newCount = keyCountMap.get(key);\\n        \\n        //insert\\n        //new count occurs\\n        if (newCount != 0) {\\n            if (newCount != preNode.prev.count) {\\n                Node newNode = new Node(newCount);\\n                insert(preNode.prev, newNode);\\n                \\n                countKeyMap.put(newCount, new HashSet<String>());\\n                countNodeMap.put(newCount, newNode);\\n            }\\n            countKeyMap.get(newCount).add(key);            \\n        }\\n        else keyCountMap.remove(key);\\n\\n        //delete\\n        Set<String> oldSet = countKeyMap.get(preCount);\\n        oldSet.remove(key);\\n        if (oldSet.isEmpty()) {\\n            delete(preNode);\\n            countKeyMap.remove(preCount);\\n            countNodeMap.remove(preCount);\\n        }\\n    }\\n    \\n    /** Returns one of the keys with maximal value. */\\n    public String getMaxKey() {\\n        if (head.next == tail) {\\n            System.out.println(\"head == tail\");\\n            return \"\";\\n        }\\n        Set<String> set = countKeyMap.get(tail.prev.count);\\n        return set.iterator().next();\\n    }\\n    \\n    /** Returns one of the keys with Minimal value. */\\n    public String getMinKey() {\\n        if (head.next == tail) return \"\";\\n        Set<String> set = countKeyMap.get(head.next.count);\\n        return set.iterator().next();\\n    }\\n    \\n    public void insert(Node preNode, Node node) {\\n        node.next = preNode.next;\\n        node.prev = preNode;\\n        \\n        node.next.prev = node;\\n        node.prev.next = node;\\n    }\\n    \\n    public void delete(Node node) {\\n        node.next.prev = node.prev;\\n        node.prev.next = node.next;\\n    }\\n}\\n```\n````\\nfrom sets import Set\\nclass Node:\\n    def __init__(self, cnt):\\n        self.count = cnt\\n        self.prev = None\\n        self.next = None\\n\\n\\nclass AllOne(object):\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        #Key:count, Value:set of key who has been incremented by 'count' time\\n        self.count_key_map = {}\\n        #Key:key, Value: the number of counts of this key\\n        self.key_count_map = {}\\n        #Key: the count, Value: the node\\n        self.count_node_map = {}\\n        \\n        #initialize the linkedlist with dummy node\\n        self.head = Node(0)\\n        self.tail = Node(float('inf'))\\n        self.head.next = self.tail\\n        self.tail.prev = self.head\\n        \\n        self.count_node_map[0] = self.head\\n        self.count_node_map[float('inf')] = self.tail\\n\\n    def inc(self, key):\\n        \"\"\"\\n        Inserts a new key <Key> with value 1. Or increments an existing key by 1.\\n        :type key: str\\n        :rtype: void\\n        \"\"\"\\n        if key not in self.key_count_map:\\n            self.key_count_map[key] = 0\\n        \\n        prev_count = self.key_count_map[key]\\n        prev_node = self.count_node_map[prev_count]\\n        \\n        #update the key map:\\n        self.key_count_map[key] += 1\\n        #insert new node:\\n        #new count occurs\\n        if prev_node.next.count != self.key_count_map[key]:\\n            #if a new count is created insert then node\\n            new_node = Node(self.key_count_map[key])\\n            self.insert(prev_node, new_node)\\n         \\n            #update 'node_map' and 'count_map'\\n            self.count_node_map[self.key_count_map[key]] = new_node\\n            self.count_key_map[self.key_count_map[key]] = Set()\\n        #if the new count is the same as the count in next node\\n        self.count_key_map[self.key_count_map[key]].add(key)\\n        \\n        #delelte the key in the prev-node\\n        if prev_count != 0:\\n            self.count_key_map[prev_count].remove(key)\\n            if len(self.count_key_map[prev_count]) == 0:\\n                self.delete(prev_node)\\n                self.count_key_map.pop(prev_count)\\n                self.count_node_map.pop(prev_count)\\n    \\n        \\n\\n    def dec(self, key):\\n        \"\"\"\\n        Decrements an existing key by 1. If Key's value is 1, remove it from the data structure.\\n        :type key: str\\n        :rtype: void\\n        \"\"\"\\n        if key not in self.key_count_map:\\n            return\\n        \\n        prev_count = self.key_count_map[key]\\n        prev_node = self.count_node_map[prev_count]\\n        \\n        self.key_count_map[key] -= 1\\n        \\n        #insert new node\\n        #if the count becomes 0\\n        if self.key_count_map[key] == 0:\\n            self.key_count_map.pop(key)\\n        else:\\n            if self.key_count_map[key] !=  prev_node.prev.count:\\n                new_node = Node(self.key_count_map[key])\\n                self.insert(prev_node.prev, new_node)\\n                \\n                self.count_node_map[self.key_count_map[key]] = new_node\\n                self.count_key_map[self.key_count_map[key]] = Set()\\n\\n            self.count_key_map[self.key_count_map[key]].add(key)\\n                \\n        #delete\\n        self.count_key_map[prev_count].remove(key)\\n        if len(self.count_key_map[prev_count]) == 0:\\n            self.delete(prev_node)\\n            self.count_key_map.pop(prev_count)\\n            self.count_node_map.pop(prev_count)\\n            \\n    def getMaxKey(self):\\n        \"\"\"\\n        Returns one of the keys with maximal value.\\n        :rtype: str\\n        \"\"\"\\n        if self.head.next == self.tail:\\n            return \"\"\\n        x = self.count_key_map[self.tail.prev.count].pop()\\n        self.count_key_map[self.tail.prev.count].add(x)\\n        return x\\n        \\n\\n    def getMinKey(self):\\n        \"\"\"\\n        Returns one of the keys with Minimal value.\\n        :rtype: str\\n        \"\"\"\\n        if self.head.next == self.tail:\\n            return \"\"\\n        x = self.count_key_map[self.head.next.count].pop()\\n        self.count_key_map[self.head.next.count].add(x)\\n        return x\\n        \\n    #insert 'node' after prev_node O(1) \\n    def insert(self, prev_node, node):\\n        node.next = prev_node.next\\n        node.prev = prev_node\\n        \\n        node.next.prev = node\\n        node.prev.next = node\\n        \\n    def delete(self, node):\\n        node.next.prev = node.prev\\n        node.prev.next = node.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 91444,
                "title": "java-accepted-solution",
                "content": "```\\npublic class AllOne {\\n\\n    // Map that stores key to the node\\n    Map<String, Integer> map;\\n    \\n    // Map that groups keys having same value using double\\n    // linked list as value\\n    Map<Integer, Set<String>> valueMap;\\n    \\n    // MinMax linkedlist to keep track of\\n    // min and max values\\n    LinkedList<Integer> minMax;\\n\\n    /** Initialize your data structure here. */\\n    public AllOne() {\\n        map = new HashMap<>();\\n        valueMap = new HashMap<>();\\n        minMax = new LinkedList<Integer>();\\n    }\\n    \\n    /** Inserts a new key <Key> with value 1. Or increments an existing key by 1. */\\n    public void inc(String key) {\\n        // If new key, just insert into the map\\n        // and place it in the appropriate position\\n        // in value map\\n        if(!map.containsKey(key)) {\\n            map.put(key, 1);\\n            putInValueMap(1, key);\\n        } else {\\n            // If already existing\\n            int val = map.get(key);\\n            // Remove from value map for old value\\n            removeFromValueMap(val, key);\\n            // Increment value\\n            map.put(key, val + 1);\\n            // Place it the new value in value map\\n            putInValueMap(val + 1, key);\\n        }\\n    }\\n    \\n    /** Decrements an existing key by 1. If Key's value is 1, remove it from the data structure. */\\n    public void dec(String key) {\\n        // If this key not found, just return\\n        if(!map.containsKey(key)) {\\n            return;\\n        }\\n        \\n        int val = map.get(key);\\n        // If value is 1, then remove from map\\n        if(val == 1) {\\n            map.remove(key);\\n            // Remove from value map too\\n            removeFromValueMap(1, key);\\n        } else {\\n            // Remove from old value\\n            removeFromValueMap(val, key);\\n            // Decrement value\\n            map.put(key, val - 1);\\n            \\n            // Insert at new value\\n            putInValueMap(val - 1, key);\\n        }\\n        \\n    }\\n    \\n    /** Returns one of the keys with maximal value. */\\n    public String getMaxKey() {\\n        if(minMax.isEmpty()) {\\n            return \"\";\\n        }\\n        // minMax.getFirst() always has max value\\n        return valueMap.get(minMax.getFirst()).iterator().next();\\n    }\\n    \\n    /** Returns one of the keys with Minimal value. */\\n    public String getMinKey() {\\n        if(minMax.isEmpty()) {\\n            return \"\";\\n        }\\n        // minMax.getFirst() always has min value\\n        return valueMap.get(minMax.getLast()).iterator().next();\\n    }\\n    \\n    private void putInValueMap(int count, String node) {\\n        // If not seen before, create a new dll\\n        if(!valueMap.containsKey(count)) {\\n            valueMap.put(count, new HashSet<String>());\\n        }\\n        // Add to dll\\n        valueMap.get(count).add(node);\\n        \\n        // Update min max\\n        if(minMax.isEmpty() || minMax.getFirst() < count) {\\n            minMax.addFirst(count);\\n        }\\n        \\n        if(!minMax.isEmpty() && minMax.getLast() > count) {\\n            minMax.addLast(count);\\n        }\\n    }\\n    \\n    private void removeFromValueMap(int count, String node) {\\n        // If not present in value map, just return\\n        if(!valueMap.containsKey(count)) {\\n            return;\\n        }\\n        \\n        // Remove from dll in value map\\n        valueMap.get(count).remove(node);\\n        \\n        // If no elements present with this value\\n        if(valueMap.get(count).size() == 0) {\\n            // Remove from value map all together\\n            valueMap.remove(count);\\n            \\n            // Update min max\\n            if(!minMax.isEmpty() && minMax.getFirst() == count) {\\n                minMax.removeFirst();\\n            }\\n            if(!minMax.isEmpty() && minMax.getLast() == count) {\\n                minMax.removeLast();\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic class AllOne {\\n\\n    // Map that stores key to the node\\n    Map<String, Integer> map;\\n    \\n    // Map that groups keys having same value using double\\n    // linked list as value\\n    Map<Integer, Set<String>> valueMap;\\n    \\n    // MinMax linkedlist to keep track of\\n    // min and max values\\n    LinkedList<Integer> minMax;\\n\\n    /** Initialize your data structure here. */\\n    public AllOne() {\\n        map = new HashMap<>();\\n        valueMap = new HashMap<>();\\n        minMax = new LinkedList<Integer>();\\n    }\\n    \\n    /** Inserts a new key <Key> with value 1. Or increments an existing key by 1. */\\n    public void inc(String key) {\\n        // If new key, just insert into the map\\n        // and place it in the appropriate position\\n        // in value map\\n        if(!map.containsKey(key)) {\\n            map.put(key, 1);\\n            putInValueMap(1, key);\\n        } else {\\n            // If already existing\\n            int val = map.get(key);\\n            // Remove from value map for old value\\n            removeFromValueMap(val, key);\\n            // Increment value\\n            map.put(key, val + 1);\\n            // Place it the new value in value map\\n            putInValueMap(val + 1, key);\\n        }\\n    }\\n    \\n    /** Decrements an existing key by 1. If Key's value is 1, remove it from the data structure. */\\n    public void dec(String key) {\\n        // If this key not found, just return\\n        if(!map.containsKey(key)) {\\n            return;\\n        }\\n        \\n        int val = map.get(key);\\n        // If value is 1, then remove from map\\n        if(val == 1) {\\n            map.remove(key);\\n            // Remove from value map too\\n            removeFromValueMap(1, key);\\n        } else {\\n            // Remove from old value\\n            removeFromValueMap(val, key);\\n            // Decrement value\\n            map.put(key, val - 1);\\n            \\n            // Insert at new value\\n            putInValueMap(val - 1, key);\\n        }\\n        \\n    }\\n    \\n    /** Returns one of the keys with maximal value. */\\n    public String getMaxKey() {\\n        if(minMax.isEmpty()) {\\n            return \"\";\\n        }\\n        // minMax.getFirst() always has max value\\n        return valueMap.get(minMax.getFirst()).iterator().next();\\n    }\\n    \\n    /** Returns one of the keys with Minimal value. */\\n    public String getMinKey() {\\n        if(minMax.isEmpty()) {\\n            return \"\";\\n        }\\n        // minMax.getFirst() always has min value\\n        return valueMap.get(minMax.getLast()).iterator().next();\\n    }\\n    \\n    private void putInValueMap(int count, String node) {\\n        // If not seen before, create a new dll\\n        if(!valueMap.containsKey(count)) {\\n            valueMap.put(count, new HashSet<String>());\\n        }\\n        // Add to dll\\n        valueMap.get(count).add(node);\\n        \\n        // Update min max\\n        if(minMax.isEmpty() || minMax.getFirst() < count) {\\n            minMax.addFirst(count);\\n        }\\n        \\n        if(!minMax.isEmpty() && minMax.getLast() > count) {\\n            minMax.addLast(count);\\n        }\\n    }\\n    \\n    private void removeFromValueMap(int count, String node) {\\n        // If not present in value map, just return\\n        if(!valueMap.containsKey(count)) {\\n            return;\\n        }\\n        \\n        // Remove from dll in value map\\n        valueMap.get(count).remove(node);\\n        \\n        // If no elements present with this value\\n        if(valueMap.get(count).size() == 0) {\\n            // Remove from value map all together\\n            valueMap.remove(count);\\n            \\n            // Update min max\\n            if(!minMax.isEmpty() && minMax.getFirst() == count) {\\n                minMax.removeFirst();\\n            }\\n            if(!minMax.isEmpty() && minMax.getLast() == count) {\\n                minMax.removeLast();\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 354750,
                "title": "python-ac-solution-with-bisect-and-deque-very-similar-to-java-treemap-easy-to-understand",
                "content": "```\\nimport collections, bisect\\n\\nclass AllOne:\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.sorted_list = collections.deque()      # contains a tuple with int followed by rand and set\\n        self.map = collections.defaultdict(int)     # maintains a counter for all the keys\\n\\n    def inc(self, key: str) -> None:\\n        \"\"\"\\n        Inserts a new key <Key> with value 1. Or increments an existing key by 1.\\n        This is log(n) as bisect.insort and bisect.bisect_left is O(log(n))\\n        \"\"\"\\n        if key in self.map:\\n            idx = bisect.bisect_left(self.sorted_list, (self.map[key], set()))\\n            self.sorted_list[idx][1].discard(key)\\n        \\n        self.map[key] += 1\\n        ins_idx = bisect.bisect_left(self.sorted_list, (self.map[key], set()))\\n        if ins_idx < len(self.sorted_list) and self.sorted_list[ins_idx][0] == self.map[key]:\\n            self.sorted_list[ins_idx][1].add(key)\\n        else:\\n            bisect.insort(self.sorted_list, (self.map[key], set([key])))\\n        \\n        \\n\\n    def dec(self, key: str) -> None:\\n        \"\"\"\\n        Decrements an existing key by 1. If Key\\'s value is 1, remove it from the data structure.\\n        This is log(n) as bisect.insort and bisect.bisect_left is O(log(n))\\n        \"\"\"\\n        if key not in self.map:\\n            return\\n        \\n        if key in self.map:\\n            idx = bisect.bisect_left(self.sorted_list, (self.map[key], set()))\\n            self.sorted_list[idx][1].discard(key)\\n        \\n        self.map[key] -= 1\\n        ins_idx = bisect.bisect_left(self.sorted_list, (self.map[key], set()))\\n        if ins_idx < len(self.sorted_list) and self.sorted_list[ins_idx][0] == self.map[key]:\\n            self.sorted_list[ins_idx][1].add(key)\\n        else:\\n            bisect.insort(self.sorted_list, (self.map[key], set([key])))\\n            \\n        if self.map[key] == 0:\\n            self.map.pop(key)\\n        \\n\\n    def getMaxKey(self) -> str:\\n        \"\"\"\\n        Returns one of the keys with maximal value.\\n        This is amortized O(1) as we are expected to call getMaxKey at regular intervals\\n        \"\"\"\\n        while self.sorted_list:\\n            if len(self.sorted_list[-1][1]) == 0:\\n                self.sorted_list.pop()\\n            else:\\n                return next(iter(self.sorted_list[-1][1]))\\n            \\n        return \"\"\\n        \\n\\n    def getMinKey(self) -> str:\\n        \"\"\"\\n        Returns one of the keys with Minimal value.\\n        This is amortized O(1) as we are expected to call getMaxKey at regular intervals\\n        \"\"\"\\n        while self.sorted_list:\\n            if self.sorted_list[0][0] == 0 or len(self.sorted_list[0][1]) == 0:\\n                self.sorted_list.popleft()\\n            else:\\n                return next(iter(self.sorted_list[0][1]))\\n        return \"\"\\n    \\n\\n\\n# Your AllOne object will be instantiated and called as such:\\n# obj = AllOne()\\n# obj.inc(key)\\n# obj.dec(key)\\n# param_3 = obj.getMaxKey()\\n# param_4 = obj.getMinKey()\\n```",
                "solutionTags": [],
                "code": "```\\nimport collections, bisect\\n\\nclass AllOne:\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.sorted_list = collections.deque()      # contains a tuple with int followed by rand and set\\n        self.map = collections.defaultdict(int)     # maintains a counter for all the keys\\n\\n    def inc(self, key: str) -> None:\\n        \"\"\"\\n        Inserts a new key <Key> with value 1. Or increments an existing key by 1.\\n        This is log(n) as bisect.insort and bisect.bisect_left is O(log(n))\\n        \"\"\"\\n        if key in self.map:\\n            idx = bisect.bisect_left(self.sorted_list, (self.map[key], set()))\\n            self.sorted_list[idx][1].discard(key)\\n        \\n        self.map[key] += 1\\n        ins_idx = bisect.bisect_left(self.sorted_list, (self.map[key], set()))\\n        if ins_idx < len(self.sorted_list) and self.sorted_list[ins_idx][0] == self.map[key]:\\n            self.sorted_list[ins_idx][1].add(key)\\n        else:\\n            bisect.insort(self.sorted_list, (self.map[key], set([key])))\\n        \\n        \\n\\n    def dec(self, key: str) -> None:\\n        \"\"\"\\n        Decrements an existing key by 1. If Key\\'s value is 1, remove it from the data structure.\\n        This is log(n) as bisect.insort and bisect.bisect_left is O(log(n))\\n        \"\"\"\\n        if key not in self.map:\\n            return\\n        \\n        if key in self.map:\\n            idx = bisect.bisect_left(self.sorted_list, (self.map[key], set()))\\n            self.sorted_list[idx][1].discard(key)\\n        \\n        self.map[key] -= 1\\n        ins_idx = bisect.bisect_left(self.sorted_list, (self.map[key], set()))\\n        if ins_idx < len(self.sorted_list) and self.sorted_list[ins_idx][0] == self.map[key]:\\n            self.sorted_list[ins_idx][1].add(key)\\n        else:\\n            bisect.insort(self.sorted_list, (self.map[key], set([key])))\\n            \\n        if self.map[key] == 0:\\n            self.map.pop(key)\\n        \\n\\n    def getMaxKey(self) -> str:\\n        \"\"\"\\n        Returns one of the keys with maximal value.\\n        This is amortized O(1) as we are expected to call getMaxKey at regular intervals\\n        \"\"\"\\n        while self.sorted_list:\\n            if len(self.sorted_list[-1][1]) == 0:\\n                self.sorted_list.pop()\\n            else:\\n                return next(iter(self.sorted_list[-1][1]))\\n            \\n        return \"\"\\n        \\n\\n    def getMinKey(self) -> str:\\n        \"\"\"\\n        Returns one of the keys with Minimal value.\\n        This is amortized O(1) as we are expected to call getMaxKey at regular intervals\\n        \"\"\"\\n        while self.sorted_list:\\n            if self.sorted_list[0][0] == 0 or len(self.sorted_list[0][1]) == 0:\\n                self.sorted_list.popleft()\\n            else:\\n                return next(iter(self.sorted_list[0][1]))\\n        return \"\"\\n    \\n\\n\\n# Your AllOne object will be instantiated and called as such:\\n# obj = AllOne()\\n# obj.inc(key)\\n# obj.dec(key)\\n# param_3 = obj.getMaxKey()\\n# param_4 = obj.getMinKey()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2748701,
                "title": "15-17-testcases-passed-please-help",
                "content": "**Approach** : I have only used hashmap to solve the problem. The inputs are directly taken in the hashmap and the occurrences is being updated in the respective inc/dec functions. 15 testcases have passed. But the 16th test cases failed due to TLE(Time Limit Exceeded). \\n\\n***Kindly help me with the problem. Open to all suggestions.***\\n\\n```import java.util.HashMap;\\nimport java.util.Map.Entry;\\nimport java.util.Set;\\n\\nclass AllOne {\\n    \\n    Map<String, Integer> hm = new HashMap<String, Integer>();\\n\\n    public AllOne() {\\n\\n    }\\n    \\n    public void inc(String key) {\\n        \\n        if (hm.containsKey(key)){\\n            \\n            hm.replace(key, hm.get(key)+1);\\n                \\n            }\\n            else\\n            {\\n                hm.put(key, 1);\\n            }\\n    }\\n    \\n    public void dec(String key) {\\n        \\n        if(hm.get(key)==1) {\\n            hm.remove(key);\\n        }\\n        else {\\n             hm.replace(key, hm.get(key)-1);   \\n        }\\n            \\n    }\\n    \\n    public String getMaxKey() {\\n        \\n        if(hm.isEmpty()) {\\n            return \"\";\\n        }\\n\\n        Set<Entry<String, Integer>> entrySet = hm.entrySet();\\n\\n        int maxCount = 0;\\n\\n        String maxChar = \"\";\\n\\n        for (Entry<String, Integer> entry : entrySet) {\\n            if (entry.getValue() > maxCount) {\\n                maxCount = entry.getValue();\\n\\n                maxChar = entry.getKey();\\n            }\\n        }\\n\\n        return maxChar;\\n    }\\n    \\n    public String getMinKey() {\\n        \\n        if(hm.isEmpty()) {\\n            return \"\";\\n        }\\n        \\n        Set<Entry<String, Integer>> entrySet = hm.entrySet();\\n        \\n        int minCount = Integer.MAX_VALUE;\\n        Entry<String, Integer> min = null;\\n        for (Entry<String, Integer> entry : hm.entrySet()) {\\n             if (min == null || min.getValue() > entry.getValue()) {\\n             min = entry;\\n            }\\n        }\\n        return min.getKey();\\n    }\\n}```",
                "solutionTags": [
                    "Hash Table",
                    "Linked List"
                ],
                "code": "```import java.util.HashMap;\\nimport java.util.Map.Entry;\\nimport java.util.Set;\\n\\nclass AllOne {\\n    \\n    Map<String, Integer> hm = new HashMap<String, Integer>();\\n\\n    public AllOne() {\\n\\n    }\\n    \\n    public void inc(String key) {\\n        \\n        if (hm.containsKey(key)){\\n            \\n            hm.replace(key, hm.get(key)+1);\\n                \\n            }\\n            else\\n            {\\n                hm.put(key, 1);\\n            }\\n    }\\n    \\n    public void dec(String key) {\\n        \\n        if(hm.get(key)==1) {\\n            hm.remove(key);\\n        }\\n        else {\\n             hm.replace(key, hm.get(key)-1);   \\n        }\\n            \\n    }\\n    \\n    public String getMaxKey() {\\n        \\n        if(hm.isEmpty()) {\\n            return \"\";\\n        }\\n\\n        Set<Entry<String, Integer>> entrySet = hm.entrySet();\\n\\n        int maxCount = 0;\\n\\n        String maxChar = \"\";\\n\\n        for (Entry<String, Integer> entry : entrySet) {\\n            if (entry.getValue() > maxCount) {\\n                maxCount = entry.getValue();\\n\\n                maxChar = entry.getKey();\\n            }\\n        }\\n\\n        return maxChar;\\n    }\\n    \\n    public String getMinKey() {\\n        \\n        if(hm.isEmpty()) {\\n            return \"\";\\n        }\\n        \\n        Set<Entry<String, Integer>> entrySet = hm.entrySet();\\n        \\n        int minCount = Integer.MAX_VALUE;\\n        Entry<String, Integer> min = null;\\n        for (Entry<String, Integer> entry : hm.entrySet()) {\\n             if (min == null || min.getValue() > entry.getValue()) {\\n             min = entry;\\n            }\\n        }\\n        return min.getKey();\\n    }\\n}```",
                "codeTag": "Java"
            },
            {
                "id": 2687926,
                "title": "c-o-1-list-and-unordered-map",
                "content": "Seems that O(log n) operations also pass the tests, but here is a truly O(1) solution. The idea is similar to the LFU Cache problem https://leetcode.com/problems/lfu-cache/discuss/2687519/c-intuitive-soltuion-with-iterators\\n\\n```\\nclass Entry {\\npublic:\\n    int cnt;\\n    unordered_set <string> keys;\\n    Entry(int _cnt, string &key) {\\n        cnt = _cnt;\\n        keys.insert(key);\\n    }\\n    void add(string &key) {\\n        keys.insert(key);\\n    }\\n    void remove(string &key) {\\n        keys.erase(key); \\n    }\\n    bool empty() {\\n        return keys.empty(); \\n    }\\n    string getAnyKey() {\\n        return *(keys.begin()); \\n    }\\n};\\n\\nclass AllOne {\\npublic:\\n    \\n    list <Entry> data;\\n    unordered_map <string, list<Entry>::iterator> pos;\\n    \\n    AllOne() {\\n        \\n    }\\n    \\n    void inc(string key) {\\n        \\n        if (data.empty()) {\\n            data.push_back(Entry(1, key));\\n            pos[key] = data.begin(); \\n            return;\\n        }\\n        \\n        if (pos.find(key) == pos.end()) {\\n            if (data.begin()->cnt == 1) {\\n                data.begin()->add(key);\\n                pos[key] = data.begin(); \\n            }\\n            else {\\n                pos[key] = data.insert(data.begin(), Entry(1, key)); \\n            }\\n        }\\n        else {\\n            auto entry = pos[key]; \\n            if (entry == prev(data.end())) {\\n                pos[key] = data.insert(data.end(), Entry(entry->cnt+1, key)); \\n            }\\n            else if (entry->cnt+1 == next(entry)->cnt) {\\n                next(entry)->add(key);\\n                pos[key] = next(entry); \\n            }\\n            else {\\n                pos[key] = data.insert(next(entry), Entry(entry->cnt+1, key)); \\n            }\\n            entry->remove(key);\\n            if (entry->empty()) data.erase(entry); \\n        }\\n        \\n    }\\n    \\n    void dec(string key) {\\n        auto entry = pos[key]; \\n        if (entry->cnt > 1) {\\n            if (entry == data.begin()) {\\n                pos[key] = data.insert(data.begin(), Entry(entry->cnt-1, key)); \\n            }\\n            else if (entry->cnt-1 == prev(entry)->cnt) {\\n                prev(entry)->add(key);\\n                pos[key] = prev(entry); \\n            }\\n            else {\\n                pos[key] = data.insert(entry, Entry(entry->cnt-1, key)); \\n            }\\n        }\\n        else pos.erase(key); \\n        \\n        entry->remove(key);\\n        if (entry->empty()) data.erase(entry); \\n        \\n    }\\n    \\n    string getMaxKey() {\\n        if (data.empty()) return \"\"; \\n        return prev(data.end())->getAnyKey(); \\n    }\\n    \\n    string getMinKey() {\\n        if (data.empty()) return \"\"; \\n        return data.begin()->getAnyKey(); \\n    }\\n    \\n     \\n};\\n\\n/**\\n * Your AllOne object will be instantiated and called as such:\\n * AllOne* obj = new AllOne();\\n * obj->inc(key);\\n * obj->dec(key);\\n * string param_3 = obj->getMaxKey();\\n * string param_4 = obj->getMinKey();\\n */\\n```",
                "solutionTags": [
                    "Iterator"
                ],
                "code": "```\\nclass Entry {\\npublic:\\n    int cnt;\\n    unordered_set <string> keys;\\n    Entry(int _cnt, string &key) {\\n        cnt = _cnt;\\n        keys.insert(key);\\n    }\\n    void add(string &key) {\\n        keys.insert(key);\\n    }\\n    void remove(string &key) {\\n        keys.erase(key); \\n    }\\n    bool empty() {\\n        return keys.empty(); \\n    }\\n    string getAnyKey() {\\n        return *(keys.begin()); \\n    }\\n};\\n\\nclass AllOne {\\npublic:\\n    \\n    list <Entry> data;\\n    unordered_map <string, list<Entry>::iterator> pos;\\n    \\n    AllOne() {\\n        \\n    }\\n    \\n    void inc(string key) {\\n        \\n        if (data.empty()) {\\n            data.push_back(Entry(1, key));\\n            pos[key] = data.begin(); \\n            return;\\n        }\\n        \\n        if (pos.find(key) == pos.end()) {\\n            if (data.begin()->cnt == 1) {\\n                data.begin()->add(key);\\n                pos[key] = data.begin(); \\n            }\\n            else {\\n                pos[key] = data.insert(data.begin(), Entry(1, key)); \\n            }\\n        }\\n        else {\\n            auto entry = pos[key]; \\n            if (entry == prev(data.end())) {\\n                pos[key] = data.insert(data.end(), Entry(entry->cnt+1, key)); \\n            }\\n            else if (entry->cnt+1 == next(entry)->cnt) {\\n                next(entry)->add(key);\\n                pos[key] = next(entry); \\n            }\\n            else {\\n                pos[key] = data.insert(next(entry), Entry(entry->cnt+1, key)); \\n            }\\n            entry->remove(key);\\n            if (entry->empty()) data.erase(entry); \\n        }\\n        \\n    }\\n    \\n    void dec(string key) {\\n        auto entry = pos[key]; \\n        if (entry->cnt > 1) {\\n            if (entry == data.begin()) {\\n                pos[key] = data.insert(data.begin(), Entry(entry->cnt-1, key)); \\n            }\\n            else if (entry->cnt-1 == prev(entry)->cnt) {\\n                prev(entry)->add(key);\\n                pos[key] = prev(entry); \\n            }\\n            else {\\n                pos[key] = data.insert(entry, Entry(entry->cnt-1, key)); \\n            }\\n        }\\n        else pos.erase(key); \\n        \\n        entry->remove(key);\\n        if (entry->empty()) data.erase(entry); \\n        \\n    }\\n    \\n    string getMaxKey() {\\n        if (data.empty()) return \"\"; \\n        return prev(data.end())->getAnyKey(); \\n    }\\n    \\n    string getMinKey() {\\n        if (data.empty()) return \"\"; \\n        return data.begin()->getAnyKey(); \\n    }\\n    \\n     \\n};\\n\\n/**\\n * Your AllOne object will be instantiated and called as such:\\n * AllOne* obj = new AllOne();\\n * obj->inc(key);\\n * obj->dec(key);\\n * string param_3 = obj->getMaxKey();\\n * string param_4 = obj->getMinKey();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2519853,
                "title": "c-priority-queue-hashmap",
                "content": "```\\nclass AllOne {\\npublic:\\n    \\n    map<string, int> mp;\\n    priority_queue<pair<int, string>, vector<pair<int, string>>, greater<pair<int, string>>> mini;\\n    priority_queue<pair<int, string>> maxi;\\n    \\n    \\n    AllOne(){\\n        // WASTE\\n    }\\n    \\n    void inc(string key) {\\n        mp[key]++;\\n        mini.push({mp[key], key});\\n        maxi.push({mp[key], key});\\n    }\\n    \\n    void dec(string key) {\\n        mp[key]--;\\n        mini.push({mp[key], key});\\n        maxi.push({mp[key], key});\\n    }\\n    \\n    string getMaxKey() {\\n        while(maxi.size()){\\n            if(maxi.top().first == mp[maxi.top().second] && mp[maxi.top().second]){\\n                return maxi.top().second;\\n                break;\\n            }else{\\n                maxi.pop();\\n            }\\n        }return \"\";\\n    }\\n    \\n    string getMinKey() {\\n        while(mini.size()){\\n            if(mini.top().first == mp[mini.top().second] && mp[mini.top().second]){\\n                return mini.top().second;\\n                break;\\n            }else{\\n                mini.pop();\\n            }\\n        }return \"\";\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass AllOne {\\npublic:\\n    \\n    map<string, int> mp;\\n    priority_queue<pair<int, string>, vector<pair<int, string>>, greater<pair<int, string>>> mini;\\n    priority_queue<pair<int, string>> maxi;\\n    \\n    \\n    AllOne(){\\n        // WASTE\\n    }\\n    \\n    void inc(string key) {\\n        mp[key]++;\\n        mini.push({mp[key], key});\\n        maxi.push({mp[key], key});\\n    }\\n    \\n    void dec(string key) {\\n        mp[key]--;\\n        mini.push({mp[key], key});\\n        maxi.push({mp[key], key});\\n    }\\n    \\n    string getMaxKey() {\\n        while(maxi.size()){\\n            if(maxi.top().first == mp[maxi.top().second] && mp[maxi.top().second]){\\n                return maxi.top().second;\\n                break;\\n            }else{\\n                maxi.pop();\\n            }\\n        }return \"\";\\n    }\\n    \\n    string getMinKey() {\\n        while(mini.size()){\\n            if(mini.top().first == mp[mini.top().second] && mp[mini.top().second]){\\n                return mini.top().second;\\n                break;\\n            }else{\\n                mini.pop();\\n            }\\n        }return \"\";\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1716411,
                "title": "similar-to-lru-and-lfu-cache-problem-easy-to-understand-solution",
                "content": "```\\nclass AllOne {\\n    list<pair<int,unordered_set<string>>> ls;                                 \\n    unordered_map<string,list<pair<int,unordered_set<string>>>::iterator> mp; \\npublic:\\n    AllOne() { }\\n    \\n    void inc(string key) {\\n        if (!mp.count(key))\\n            mp[key] = ls.insert(ls.begin(),{0,{key}});                         \\n        auto itr = mp[key];               \\n        auto itrNext = next(itr);         \\n        if (itrNext==ls.end() || itr->first+1 < itrNext->first)               \\n            itrNext = ls.insert(itrNext,{itr->first+1,{}});\\n        itrNext->second.insert(key);   \\n        mp[key] = itrNext;             \\n        itr->second.erase(key);        \\n        if (itr->second.empty())       \\n            ls.erase(itr);\\n    }\\n\\n    void dec(string key) {\\n        if (!mp.count(key))            \\n            return;\\n        auto itr = mp[key];            \\n        auto itrPrev = prev(itr);      \\n        mp.erase(key);                 \\n        if (itr->first>1) {            \\n            if (itr==ls.begin() || itr->first-1 > itrPrev->first)             \\n                itrPrev = ls.insert(itr,{itr->first-1,{}});\\n            itrPrev->second.insert(key);\\n            mp[key] = itrPrev;         \\n        }\\n        itr->second.erase(key);  \\n        if (itr->second.empty()) \\n            ls.erase(itr);\\n    }\\n    \\n    string getMaxKey() {\\n        return mp.empty() ? \"\" : *ls.rbegin()->second.begin();\\n    }\\n    \\n    string getMinKey() {\\n        return mp.empty() ? \"\" : *ls.begin()->second.begin();                 \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass AllOne {\\n    list<pair<int,unordered_set<string>>> ls;                                 \\n    unordered_map<string,list<pair<int,unordered_set<string>>>::iterator> mp; \\npublic:\\n    AllOne() { }\\n    \\n    void inc(string key) {\\n        if (!mp.count(key))\\n            mp[key] = ls.insert(ls.begin(),{0,{key}});                         \\n        auto itr = mp[key];               \\n        auto itrNext = next(itr);         \\n        if (itrNext==ls.end() || itr->first+1 < itrNext->first)               \\n            itrNext = ls.insert(itrNext,{itr->first+1,{}});\\n        itrNext->second.insert(key);   \\n        mp[key] = itrNext;             \\n        itr->second.erase(key);        \\n        if (itr->second.empty())       \\n            ls.erase(itr);\\n    }\\n\\n    void dec(string key) {\\n        if (!mp.count(key))            \\n            return;\\n        auto itr = mp[key];            \\n        auto itrPrev = prev(itr);      \\n        mp.erase(key);                 \\n        if (itr->first>1) {            \\n            if (itr==ls.begin() || itr->first-1 > itrPrev->first)             \\n                itrPrev = ls.insert(itr,{itr->first-1,{}});\\n            itrPrev->second.insert(key);\\n            mp[key] = itrPrev;         \\n        }\\n        itr->second.erase(key);  \\n        if (itr->second.empty()) \\n            ls.erase(itr);\\n    }\\n    \\n    string getMaxKey() {\\n        return mp.empty() ? \"\" : *ls.rbegin()->second.begin();\\n    }\\n    \\n    string getMinKey() {\\n        return mp.empty() ? \"\" : *ls.begin()->second.begin();                 \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 243043,
                "title": "2-java-ac-solution-in-o-1-beats-100",
                "content": "Solution 1, use HashMap, and sorted double linked list, O(1) on average:\\n```java\\nclass AllOne {\\n    private HashMap<String, Node> map;\\n    private Node head;\\n    private Node tail;\\n\\n    /** Initialize your data structure here. */\\n    public AllOne() {\\n        map = new HashMap<>();\\n        head = new Node(\"\", Integer.MIN_VALUE);\\n        tail = new Node(\"\", Integer.MAX_VALUE);\\n        head.next = tail;\\n        tail.prev = head;\\n    }\\n    \\n    /** Inserts a new key <Key> with value 1. Or increments an existing key by 1. */\\n    public void inc(String key) {\\n        Node node = map.get(key);\\n        if (node == null) {\\n            Node n = new Node(key, 1);\\n            map.put(key, n);\\n            link(head, n);\\n        } else {\\n            node.value = node.value + 1;\\n            moveBack(node);\\n        }\\n    }\\n    \\n    /** Decrements an existing key by 1. If Key\\'s value is 1, remove it from the data structure. */\\n    public void dec(String key) {\\n        Node node = map.get(key);\\n        if (node == null) return;\\n        if (node.value == 1) { // remove\\n            map.remove(key);\\n            unlink(node);\\n        } else {\\n            node.value = node.value - 1;\\n            moveFront(node);\\n        }\\n    }\\n    \\n    /** Returns one of the keys with maximal value. */\\n    public String getMaxKey() {\\n        if (map.isEmpty()) return \"\";\\n        return tail.prev.key;\\n    }\\n    \\n    /** Returns one of the keys with Minimal value. */\\n    public String getMinKey() {\\n        if (map.isEmpty()) return \"\";\\n        return head.next.key;\\n    }\\n    \\n    private void moveFront(Node node) {\\n        Node prev = node.prev;\\n        unlink(node);\\n        while (node.value < prev.value)\\n            prev = prev.prev;\\n        link(prev, node);\\n    }\\n    \\n    // move back until first node value >= node.value\\n    private void moveBack(Node node) {\\n        Node next = node.next;\\n        unlink(node);\\n        while (node.value > next.value)\\n            next = next.next;\\n        link(next.prev, node);\\n    }\\n    \\n    // link after prev\\n    private void link(Node prev, Node node) {\\n        Node next = prev.next;\\n        prev.next = node;\\n        node.prev = prev;\\n        node.next = next;\\n        next.prev = node;\\n    }\\n    \\n    private void unlink(Node node) {\\n        node.prev.next = node.next;\\n        node.next.prev = node.prev;\\n    }\\n    \\n    class Node {\\n        String key;\\n        int value;\\n        Node prev;\\n        Node next;\\n        \\n        Node(String key, int value) {\\n            this.key = key;\\n            this.value = value;\\n        }\\n    }\\n}\\n```\\n\\nSolution 2, use HashMap store value Node, and maintain a value node double linked list, strict O(1):\\n```java\\nclass AllOne {\\n    private HashMap<String, Node> map;\\n    private Node head;\\n    private Node tail;\\n\\n    /** Initialize your data structure here. */\\n    public AllOne() {\\n        map = new HashMap<>();\\n        head = new Node(Integer.MIN_VALUE);\\n        tail = new Node(Integer.MAX_VALUE);\\n        head.next = tail;\\n        tail.prev = head;\\n    }\\n\\n    /** Inserts a new key <Key> with value 1. Or increments an existing key by 1. */\\n    public void inc(String key) {\\n        Node node = map.get(key);\\n        if (node == null) { // not exist, insert\\n            Node first = head.next;\\n            if (isEmptyList() || first.value != 1) { // list empty or value 1 node not exist\\n                first = insertNode(head, 1);\\n            }\\n            updateKey(first, key);\\n        } else { // exist, increment\\n            int value = node.value  + 1;\\n            // remove from current node, insert to next node\\n            Node next = node.next;\\n            if (value < next.value) { // next node value equal to new value, insert, or create new node\\n                next = insertNode(node, value);\\n            }\\n            removeKey(node, key);\\n            updateKey(next, key);\\n        }\\n    }\\n\\n    /** Decrements an existing key by 1. If Key\\'s value is 1, remove it from the data structure. */\\n    public void dec(String key) {\\n        Node node = map.get(key);\\n        if (node == null) return;\\n        if (node.value == 1) { // remove\\n            map.remove(key);\\n            removeKey(node, key);\\n        } else { // decrement\\n            int value = node.value  - 1;\\n            // remove from current node, insert to next node\\n            Node prev = node.prev;\\n            if (value > prev.value) { // prev node value equal to new value, insert, or create new node\\n                prev = insertNode(prev, value);\\n            }\\n            removeKey(node, key);\\n            updateKey(prev, key);\\n        }\\n    }\\n\\n    /** Returns one of the keys with maximal value. */\\n    public String getMaxKey() {\\n        return isEmptyList() ? \"\" : tail.prev.keys.iterator().next();\\n    }\\n\\n    /** Returns one of the keys with Minimal value. */\\n    public String getMinKey() {\\n        return isEmptyList() ? \"\" : head.next.keys.iterator().next();\\n    }\\n\\n    // insert new node after prev node\\n    private Node insertNode(Node prev, int value) {\\n        Node node = new Node(value);\\n        node.keys = new HashSet<>();\\n        link(prev, node);\\n        return node;\\n    }\\n\\n    // remove key from node key set\\n    private void removeKey(Node node, String key) {\\n        node.keys.remove(key);\\n        if (node.keys.isEmpty()) unlink(node);\\n    }\\n\\n    private void updateKey(Node node, String key) {\\n        node.keys.add(key);\\n        map.put(key, node);\\n    }\\n\\n    private boolean isEmptyList() {\\n        return (head.next == tail) && (tail.prev == head);\\n    }\\n\\n    private void link(Node prev, Node node) {\\n        Node next = prev.next;\\n        prev.next = node;\\n        node.prev = prev;\\n        node.next = next;\\n        next.prev = node;\\n    }\\n\\n    private void unlink(Node node) {\\n        node.prev.next = node.next;\\n        node.next.prev = node.prev;\\n    }\\n\\n    class Node {\\n        int value;\\n        HashSet<String> keys;\\n        Node prev;\\n        Node next;\\n\\n        Node(int value) {\\n            this.value = value;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass AllOne {\\n    private HashMap<String, Node> map;\\n    private Node head;\\n    private Node tail;\\n\\n    /** Initialize your data structure here. */\\n    public AllOne() {\\n        map = new HashMap<>();\\n        head = new Node(\"\", Integer.MIN_VALUE);\\n        tail = new Node(\"\", Integer.MAX_VALUE);\\n        head.next = tail;\\n        tail.prev = head;\\n    }\\n    \\n    /** Inserts a new key <Key> with value 1. Or increments an existing key by 1. */\\n    public void inc(String key) {\\n        Node node = map.get(key);\\n        if (node == null) {\\n            Node n = new Node(key, 1);\\n            map.put(key, n);\\n            link(head, n);\\n        } else {\\n            node.value = node.value + 1;\\n            moveBack(node);\\n        }\\n    }\\n    \\n    /** Decrements an existing key by 1. If Key\\'s value is 1, remove it from the data structure. */\\n    public void dec(String key) {\\n        Node node = map.get(key);\\n        if (node == null) return;\\n        if (node.value == 1) { // remove\\n            map.remove(key);\\n            unlink(node);\\n        } else {\\n            node.value = node.value - 1;\\n            moveFront(node);\\n        }\\n    }\\n    \\n    /** Returns one of the keys with maximal value. */\\n    public String getMaxKey() {\\n        if (map.isEmpty()) return \"\";\\n        return tail.prev.key;\\n    }\\n    \\n    /** Returns one of the keys with Minimal value. */\\n    public String getMinKey() {\\n        if (map.isEmpty()) return \"\";\\n        return head.next.key;\\n    }\\n    \\n    private void moveFront(Node node) {\\n        Node prev = node.prev;\\n        unlink(node);\\n        while (node.value < prev.value)\\n            prev = prev.prev;\\n        link(prev, node);\\n    }\\n    \\n    // move back until first node value >= node.value\\n    private void moveBack(Node node) {\\n        Node next = node.next;\\n        unlink(node);\\n        while (node.value > next.value)\\n            next = next.next;\\n        link(next.prev, node);\\n    }\\n    \\n    // link after prev\\n    private void link(Node prev, Node node) {\\n        Node next = prev.next;\\n        prev.next = node;\\n        node.prev = prev;\\n        node.next = next;\\n        next.prev = node;\\n    }\\n    \\n    private void unlink(Node node) {\\n        node.prev.next = node.next;\\n        node.next.prev = node.prev;\\n    }\\n    \\n    class Node {\\n        String key;\\n        int value;\\n        Node prev;\\n        Node next;\\n        \\n        Node(String key, int value) {\\n            this.key = key;\\n            this.value = value;\\n        }\\n    }\\n}\\n```\n```java\\nclass AllOne {\\n    private HashMap<String, Node> map;\\n    private Node head;\\n    private Node tail;\\n\\n    /** Initialize your data structure here. */\\n    public AllOne() {\\n        map = new HashMap<>();\\n        head = new Node(Integer.MIN_VALUE);\\n        tail = new Node(Integer.MAX_VALUE);\\n        head.next = tail;\\n        tail.prev = head;\\n    }\\n\\n    /** Inserts a new key <Key> with value 1. Or increments an existing key by 1. */\\n    public void inc(String key) {\\n        Node node = map.get(key);\\n        if (node == null) { // not exist, insert\\n            Node first = head.next;\\n            if (isEmptyList() || first.value != 1) { // list empty or value 1 node not exist\\n                first = insertNode(head, 1);\\n            }\\n            updateKey(first, key);\\n        } else { // exist, increment\\n            int value = node.value  + 1;\\n            // remove from current node, insert to next node\\n            Node next = node.next;\\n            if (value < next.value) { // next node value equal to new value, insert, or create new node\\n                next = insertNode(node, value);\\n            }\\n            removeKey(node, key);\\n            updateKey(next, key);\\n        }\\n    }\\n\\n    /** Decrements an existing key by 1. If Key\\'s value is 1, remove it from the data structure. */\\n    public void dec(String key) {\\n        Node node = map.get(key);\\n        if (node == null) return;\\n        if (node.value == 1) { // remove\\n            map.remove(key);\\n            removeKey(node, key);\\n        } else { // decrement\\n            int value = node.value  - 1;\\n            // remove from current node, insert to next node\\n            Node prev = node.prev;\\n            if (value > prev.value) { // prev node value equal to new value, insert, or create new node\\n                prev = insertNode(prev, value);\\n            }\\n            removeKey(node, key);\\n            updateKey(prev, key);\\n        }\\n    }\\n\\n    /** Returns one of the keys with maximal value. */\\n    public String getMaxKey() {\\n        return isEmptyList() ? \"\" : tail.prev.keys.iterator().next();\\n    }\\n\\n    /** Returns one of the keys with Minimal value. */\\n    public String getMinKey() {\\n        return isEmptyList() ? \"\" : head.next.keys.iterator().next();\\n    }\\n\\n    // insert new node after prev node\\n    private Node insertNode(Node prev, int value) {\\n        Node node = new Node(value);\\n        node.keys = new HashSet<>();\\n        link(prev, node);\\n        return node;\\n    }\\n\\n    // remove key from node key set\\n    private void removeKey(Node node, String key) {\\n        node.keys.remove(key);\\n        if (node.keys.isEmpty()) unlink(node);\\n    }\\n\\n    private void updateKey(Node node, String key) {\\n        node.keys.add(key);\\n        map.put(key, node);\\n    }\\n\\n    private boolean isEmptyList() {\\n        return (head.next == tail) && (tail.prev == head);\\n    }\\n\\n    private void link(Node prev, Node node) {\\n        Node next = prev.next;\\n        prev.next = node;\\n        node.prev = prev;\\n        node.next = next;\\n        next.prev = node;\\n    }\\n\\n    private void unlink(Node node) {\\n        node.prev.next = node.next;\\n        node.next.prev = node.prev;\\n    }\\n\\n    class Node {\\n        int value;\\n        HashSet<String> keys;\\n        Node prev;\\n        Node next;\\n\\n        Node(int value) {\\n            this.value = value;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 213282,
                "title": "python-double-linked-list-hashmap",
                "content": "```\\nclass Node:\\n    def __init__(self):\\n        self.key_set = set()\\n        self.count = 0\\n        self.prev = None\\n        self.next = None\\n        \\n    def add(self, key):\\n        self.key_set.add(key)\\n        self.count += 1\\n    \\n    def remove(self, key):\\n        self.key_set.remove(key)\\n        self.count -= 1\\n    \\n    def get_one_key(self):\\n        key = self.key_set.pop()\\n        self.key_set.add(key)\\n        return key\\n    \\nclass DoubleLinkedList:\\n    def __init__(self):\\n        self.head = Node()\\n        self.tail = Node()\\n        self.head.next = self.tail\\n        self.tail.prev = self.head\\n    \\n    def insert_after(self, n1, n2):\\n        temp = n1.next\\n        \\n        n1.next = n2\\n        n2.prev = n1\\n        \\n        n2.next = temp\\n        temp.prev = n2\\n        \\n    def insert_before(self, n1, n2):\\n        temp = n1.prev\\n        \\n        temp.next = n2\\n        n2.prev = temp\\n        \\n        n1.prev = n2\\n        n2.next = n1\\n        \\n    def remove(self, node):\\n        prev = node.prev\\n        nxt = node.next\\n        \\n        prev.next = nxt\\n        nxt.prev = prev\\n\\n\\nclass AllOne:\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.dll = DoubleLinkedList()\\n        self.counter = collections.defaultdict(int)\\n        self.node_val = {0: self.dll.head}\\n        \\n    \\n    def remove_key(self, v, key):\\n        node = self.node_val[v]\\n        node.remove(key)\\n        if node.count == 0:\\n            self.dll.remove(node)\\n            self.node_val.pop(v)\\n        \\n        \\n    def inc(self, key):\\n        \"\"\"\\n        Inserts a new key <Key> with value 1. Or increments an existing key by 1.\\n        :type key: str\\n        :rtype: void\\n        \"\"\"\\n        self.counter[key] += 1\\n        v = self.counter[key]\\n        \\n        if v not in self.node_val:\\n            self.node_val[v] = Node()\\n            self.dll.insert_after(self.node_val[v-1], self.node_val[v])\\n        self.node_val[v].add(key)\\n        \\n        if v - 1 > 0:\\n            self.remove_key(v-1, key)\\n        \\n        \\n        \\n    def dec(self, key):\\n        \"\"\"\\n        Decrements an existing key by 1. If Key\\'s value is 1, remove it from the data structure.\\n        :type key: str\\n        :rtype: void\\n        \"\"\"\\n        if key not in self.counter:\\n            return\\n        \\n        self.counter[key] -= 1\\n        v = self.counter[key]\\n        \\n        if v == 0:\\n            self.counter.pop(key)\\n        else:\\n            if v not in self.node_val:\\n                self.node_val[v] = Node()\\n                self.dll.insert_before(self.node_val[v+1], self.node_val[v])\\n            self.node_val[v].add(key)\\n        \\n        self.remove_key(v+1, key)\\n        \\n\\n    def getMaxKey(self):\\n        \"\"\"\\n        Returns one of the keys with maximal value.\\n        :rtype: str\\n        \"\"\"\\n        if self.dll.head.next == self.dll.tail:\\n            return \\'\\'\\n        return self.dll.tail.prev.get_one_key()\\n\\n    def getMinKey(self):\\n        \"\"\"\\n        Returns one of the keys with Minimal value.\\n        :rtype: str\\n        \"\"\"\\n        if self.dll.head.next == self.dll.tail:\\n            return \\'\\'\\n        return self.dll.head.next.get_one_key()\\n        \\n\\n\\n# Your AllOne object will be instantiated and called as such:\\n# obj = AllOne()\\n# obj.inc(key)\\n# obj.dec(key)\\n# param_3 = obj.getMaxKey()\\n# param_4 = obj.getMinKey()\\n```",
                "solutionTags": [],
                "code": "```\\nclass Node:\\n    def __init__(self):\\n        self.key_set = set()\\n        self.count = 0\\n        self.prev = None\\n        self.next = None\\n        \\n    def add(self, key):\\n        self.key_set.add(key)\\n        self.count += 1\\n    \\n    def remove(self, key):\\n        self.key_set.remove(key)\\n        self.count -= 1\\n    \\n    def get_one_key(self):\\n        key = self.key_set.pop()\\n        self.key_set.add(key)\\n        return key\\n    \\nclass DoubleLinkedList:\\n    def __init__(self):\\n        self.head = Node()\\n        self.tail = Node()\\n        self.head.next = self.tail\\n        self.tail.prev = self.head\\n    \\n    def insert_after(self, n1, n2):\\n        temp = n1.next\\n        \\n        n1.next = n2\\n        n2.prev = n1\\n        \\n        n2.next = temp\\n        temp.prev = n2\\n        \\n    def insert_before(self, n1, n2):\\n        temp = n1.prev\\n        \\n        temp.next = n2\\n        n2.prev = temp\\n        \\n        n1.prev = n2\\n        n2.next = n1\\n        \\n    def remove(self, node):\\n        prev = node.prev\\n        nxt = node.next\\n        \\n        prev.next = nxt\\n        nxt.prev = prev\\n\\n\\nclass AllOne:\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.dll = DoubleLinkedList()\\n        self.counter = collections.defaultdict(int)\\n        self.node_val = {0: self.dll.head}\\n        \\n    \\n    def remove_key(self, v, key):\\n        node = self.node_val[v]\\n        node.remove(key)\\n        if node.count == 0:\\n            self.dll.remove(node)\\n            self.node_val.pop(v)\\n        \\n        \\n    def inc(self, key):\\n        \"\"\"\\n        Inserts a new key <Key> with value 1. Or increments an existing key by 1.\\n        :type key: str\\n        :rtype: void\\n        \"\"\"\\n        self.counter[key] += 1\\n        v = self.counter[key]\\n        \\n        if v not in self.node_val:\\n            self.node_val[v] = Node()\\n            self.dll.insert_after(self.node_val[v-1], self.node_val[v])\\n        self.node_val[v].add(key)\\n        \\n        if v - 1 > 0:\\n            self.remove_key(v-1, key)\\n        \\n        \\n        \\n    def dec(self, key):\\n        \"\"\"\\n        Decrements an existing key by 1. If Key\\'s value is 1, remove it from the data structure.\\n        :type key: str\\n        :rtype: void\\n        \"\"\"\\n        if key not in self.counter:\\n            return\\n        \\n        self.counter[key] -= 1\\n        v = self.counter[key]\\n        \\n        if v == 0:\\n            self.counter.pop(key)\\n        else:\\n            if v not in self.node_val:\\n                self.node_val[v] = Node()\\n                self.dll.insert_before(self.node_val[v+1], self.node_val[v])\\n            self.node_val[v].add(key)\\n        \\n        self.remove_key(v+1, key)\\n        \\n\\n    def getMaxKey(self):\\n        \"\"\"\\n        Returns one of the keys with maximal value.\\n        :rtype: str\\n        \"\"\"\\n        if self.dll.head.next == self.dll.tail:\\n            return \\'\\'\\n        return self.dll.tail.prev.get_one_key()\\n\\n    def getMinKey(self):\\n        \"\"\"\\n        Returns one of the keys with Minimal value.\\n        :rtype: str\\n        \"\"\"\\n        if self.dll.head.next == self.dll.tail:\\n            return \\'\\'\\n        return self.dll.head.next.get_one_key()\\n        \\n\\n\\n# Your AllOne object will be instantiated and called as such:\\n# obj = AllOne()\\n# obj.inc(key)\\n# obj.dec(key)\\n# param_3 = obj.getMaxKey()\\n# param_4 = obj.getMinKey()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2311911,
                "title": "easy-c-solution",
                "content": "```\\nclass AllOne {\\n    set<pair<int, string>> st;\\n    map<string,int> table;\\npublic:\\n    AllOne() {\\n        \\n    }\\n    \\n    void inc(string key) {\\n        if(table.count(key)) \\n            st.erase({table[key], key});\\n        st.insert({++table[key], key});\\n    }\\n    \\n    void dec(string key) {\\n        st.erase({table[key], key});\\n        if(--table[key])\\n            st.insert({table[key], key});\\n    }\\n    \\n    string getMaxKey() {\\n        return st.empty() ? \"\":st.rbegin()->second;\\n    }\\n    \\n    string getMinKey() {\\n        return st.empty() ? \"\":st.begin()->second;\\n    }\\n};\\n\\n/**\\n * Your AllOne object will be instantiated and called as such:\\n * AllOne* obj = new AllOne();\\n * obj->inc(key);\\n * obj->dec(key);\\n * string param_3 = obj->getMaxKey();\\n * string param_4 = obj->getMinKey();\\n */\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass AllOne {\\n    set<pair<int, string>> st;\\n    map<string,int> table;\\npublic:\\n    AllOne() {\\n        \\n    }\\n    \\n    void inc(string key) {\\n        if(table.count(key)) \\n            st.erase({table[key], key});\\n        st.insert({++table[key], key});\\n    }\\n    \\n    void dec(string key) {\\n        st.erase({table[key], key});\\n        if(--table[key])\\n            st.insert({table[key], key});\\n    }\\n    \\n    string getMaxKey() {\\n        return st.empty() ? \"\":st.rbegin()->second;\\n    }\\n    \\n    string getMinKey() {\\n        return st.empty() ? \"\":st.begin()->second;\\n    }\\n};\\n\\n/**\\n * Your AllOne object will be instantiated and called as such:\\n * AllOne* obj = new AllOne();\\n * obj->inc(key);\\n * obj->dec(key);\\n * string param_3 = obj->getMaxKey();\\n * string param_4 = obj->getMinKey();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1610032,
                "title": "python-accepted-simple-solution-with-explanation-map-set-heap",
                "content": "Time Complexity(All methods): O(logn), where n is the unique keys in the Data Structure.\\nSpace Complexity: O(m), where m is the number of calls made to the Data Structure.\\n\\n```\\nclass AllOne:\\n\\n    def __init__(self):\\n        self.key_count = defaultdict(int)\\n        self.count_key = defaultdict(set)\\n        self.max_heap = []\\n        self.min_heap = []\\n        \\n\\n    def inc(self, key: str) -> None:\\n        og_value = self.key_count[key]\\n        # If the value exists in the count map, we have to remove the key.\\n        if self.count_key[og_value]:\\n            self.count_key[og_value].remove(key)\\n        # Inc the value in the count map and key map \\n        og_value+=1\\n        self.count_key[og_value].add(key)\\n        self.key_count[key]=og_value\\n        heapq.heappush(self.max_heap, -(og_value))\\n        heapq.heappush(self.min_heap, (og_value))   \\n        return\\n        \\n\\n    def dec(self, key: str) -> None:\\n        og_value = self.key_count[key]\\n        # The value guaranteed exists in the count map (given), removing the key.\\n        self.count_key[og_value].remove(key)\\n        # Dec the value in the count map and key map \\n        og_value -= 1\\n        # If the value has become 0, remove the key and return\\n        if og_value == 0:\\n            del self.key_count[key]\\n            return\\n        \\n        self.count_key[og_value].add(key)\\n        self.key_count[key]=og_value\\n        heapq.heappush(self.max_heap, -(og_value))\\n        heapq.heappush(self.min_heap, (og_value)) \\n        return\\n\\n    def getMaxKey(self) -> str:\\n        # The map keeps track of how many elements there are in the DS, so if its \\n        # len is 0, we can just return back \"\"\\n        if len(self.key_count) == 0:\\n            return \"\"\\n        \\n        # We will keep popping values from the max heap and if the values exits in \\n        # the count map, we add it back to the heap and return a key from the map.\\n        while self.max_heap:\\n            val = -heapq.heappop(self.max_heap)\\n            if self.count_key[val]:\\n                heapq.heappush(self.max_heap, -val)\\n                for key in self.count_key[val]:\\n                    return key\\n        return\\n        \\n\\n    def getMinKey(self) -> str:\\n        if len(self.key_count) == 0:\\n            return \"\"\\n        \\n        # We will keep popping values from the min heap and if the values exits in \\n        # the count map, we add it back to the heap and return a key from the map.\\n        while self.min_heap:\\n            val = heapq.heappop(self.min_heap)\\n            if self.count_key[val]:\\n                heapq.heappush(self.min_heap, val)\\n                for key in self.count_key[val]:\\n                    return key\\n        return\\n```",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)",
                    "Ordered Set"
                ],
                "code": "```\\nclass AllOne:\\n\\n    def __init__(self):\\n        self.key_count = defaultdict(int)\\n        self.count_key = defaultdict(set)\\n        self.max_heap = []\\n        self.min_heap = []\\n        \\n\\n    def inc(self, key: str) -> None:\\n        og_value = self.key_count[key]\\n        # If the value exists in the count map, we have to remove the key.\\n        if self.count_key[og_value]:\\n            self.count_key[og_value].remove(key)\\n        # Inc the value in the count map and key map \\n        og_value+=1\\n        self.count_key[og_value].add(key)\\n        self.key_count[key]=og_value\\n        heapq.heappush(self.max_heap, -(og_value))\\n        heapq.heappush(self.min_heap, (og_value))   \\n        return\\n        \\n\\n    def dec(self, key: str) -> None:\\n        og_value = self.key_count[key]\\n        # The value guaranteed exists in the count map (given), removing the key.\\n        self.count_key[og_value].remove(key)\\n        # Dec the value in the count map and key map \\n        og_value -= 1\\n        # If the value has become 0, remove the key and return\\n        if og_value == 0:\\n            del self.key_count[key]\\n            return\\n        \\n        self.count_key[og_value].add(key)\\n        self.key_count[key]=og_value\\n        heapq.heappush(self.max_heap, -(og_value))\\n        heapq.heappush(self.min_heap, (og_value)) \\n        return\\n\\n    def getMaxKey(self) -> str:\\n        # The map keeps track of how many elements there are in the DS, so if its \\n        # len is 0, we can just return back \"\"\\n        if len(self.key_count) == 0:\\n            return \"\"\\n        \\n        # We will keep popping values from the max heap and if the values exits in \\n        # the count map, we add it back to the heap and return a key from the map.\\n        while self.max_heap:\\n            val = -heapq.heappop(self.max_heap)\\n            if self.count_key[val]:\\n                heapq.heappush(self.max_heap, -val)\\n                for key in self.count_key[val]:\\n                    return key\\n        return\\n        \\n\\n    def getMinKey(self) -> str:\\n        if len(self.key_count) == 0:\\n            return \"\"\\n        \\n        # We will keep popping values from the min heap and if the values exits in \\n        # the count map, we add it back to the heap and return a key from the map.\\n        while self.min_heap:\\n            val = heapq.heappop(self.min_heap)\\n            if self.count_key[val]:\\n                heapq.heappush(self.min_heap, val)\\n                for key in self.count_key[val]:\\n                    return key\\n        return\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1082096,
                "title": "java-using-hashmap-and-treemap",
                "content": "**Update** : This solution is not the optimal and has time complexity of **log(n)**. Optimal solution using O(1) is shared by other users. Just wanted to share my solution using TreeMap.\\n\\n```\\n\\tprivate HashMap<String, Integer> keyVsCntMap;\\n\\tprivate TreeMap<Integer, List<String>> cntVsKeyMap;\\n\\n\\t/** Initialize your data structure here. */\\n\\tpublic AllOne() {\\n\\t\\tkeyVsCntMap = new HashMap<>();\\n\\t\\tcntVsKeyMap = new TreeMap<>();\\n\\t}\\n\\n\\t/** Inserts a new key <Key> with value 1. Or increments an existing key by 1. */\\n\\tpublic void inc(String key) {\\n\\t\\tif (keyVsCntMap.containsKey(key)) {\\n\\t\\t\\tint oldCnt = keyVsCntMap.get(key);\\n\\n\\t\\t\\tremoveCountFromList(key, oldCnt);\\n\\n\\t\\t\\tupsertCount(key, oldCnt + 1);\\n\\t\\t} else {\\n\\t\\t\\tupsertCount(key, 1);\\n\\t\\t}\\n\\t}\\n\\n\\tprivate void removeCountFromList(String key, int oldCnt) {\\n\\t\\tList<String> list = cntVsKeyMap.get(oldCnt);\\n\\t\\tlist.remove(key);\\n\\t\\tif (list.size() == 0) {\\n\\t\\t\\tcntVsKeyMap.remove(oldCnt);\\n\\t\\t}\\n\\t}\\n\\n\\tprivate void upsertCount(String key, int val) {\\n\\t\\tkeyVsCntMap.put(key, val);\\n\\t\\tList<String> set = cntVsKeyMap.getOrDefault(val, new ArrayList<>());\\n\\t\\tset.add(key);\\n\\t\\tcntVsKeyMap.put(val, set);\\n\\t}\\n\\n\\t/**\\n\\t * Decrements an existing key by 1. If Key\\'s value is 1, remove it from the data\\n\\t * structure.\\n\\t */\\n\\tpublic void dec(String key) {\\n\\t\\tif (!keyVsCntMap.containsKey(key)) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tint oldCnt = keyVsCntMap.get(key);\\n\\n\\t\\tremoveCountFromList(key, oldCnt);\\n\\n\\t\\tif (oldCnt == 1) {\\n\\t\\t\\tkeyVsCntMap.remove(key);\\n\\t\\t} else {\\n\\t\\t\\tupsertCount(key, oldCnt - 1);\\n\\t\\t}\\n\\t}\\n\\n\\t/** Returns one of the keys with maximal value. */\\n\\tpublic String getMaxKey() {\\n\\t\\tif (cntVsKeyMap.size() == 0) {\\n\\t\\t\\treturn \"\";\\n\\t\\t}\\n\\t\\treturn cntVsKeyMap.lastEntry().getValue().get(0);\\n\\n\\t}\\n\\n\\t/** Returns one of the keys with Minimal value. */\\n\\tpublic String getMinKey() {\\n\\t\\tif (cntVsKeyMap.size() == 0) {\\n\\t\\t\\treturn \"\";\\n\\t\\t}\\n\\t\\treturn cntVsKeyMap.firstEntry().getValue().get(0);\\n\\t}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```\\n\\tprivate HashMap<String, Integer> keyVsCntMap;\\n\\tprivate TreeMap<Integer, List<String>> cntVsKeyMap;\\n\\n\\t/** Initialize your data structure here. */\\n\\tpublic AllOne() {\\n\\t\\tkeyVsCntMap = new HashMap<>();\\n\\t\\tcntVsKeyMap = new TreeMap<>();\\n\\t}\\n\\n\\t/** Inserts a new key <Key> with value 1. Or increments an existing key by 1. */\\n\\tpublic void inc(String key) {\\n\\t\\tif (keyVsCntMap.containsKey(key)) {\\n\\t\\t\\tint oldCnt = keyVsCntMap.get(key);\\n\\n\\t\\t\\tremoveCountFromList(key, oldCnt);\\n\\n\\t\\t\\tupsertCount(key, oldCnt + 1);\\n\\t\\t} else {\\n\\t\\t\\tupsertCount(key, 1);\\n\\t\\t}\\n\\t}\\n\\n\\tprivate void removeCountFromList(String key, int oldCnt) {\\n\\t\\tList<String> list = cntVsKeyMap.get(oldCnt);\\n\\t\\tlist.remove(key);\\n\\t\\tif (list.size() == 0) {\\n\\t\\t\\tcntVsKeyMap.remove(oldCnt);\\n\\t\\t}\\n\\t}\\n\\n\\tprivate void upsertCount(String key, int val) {\\n\\t\\tkeyVsCntMap.put(key, val);\\n\\t\\tList<String> set = cntVsKeyMap.getOrDefault(val, new ArrayList<>());\\n\\t\\tset.add(key);\\n\\t\\tcntVsKeyMap.put(val, set);\\n\\t}\\n\\n\\t/**\\n\\t * Decrements an existing key by 1. If Key\\'s value is 1, remove it from the data\\n\\t * structure.\\n\\t */\\n\\tpublic void dec(String key) {\\n\\t\\tif (!keyVsCntMap.containsKey(key)) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tint oldCnt = keyVsCntMap.get(key);\\n\\n\\t\\tremoveCountFromList(key, oldCnt);\\n\\n\\t\\tif (oldCnt == 1) {\\n\\t\\t\\tkeyVsCntMap.remove(key);\\n\\t\\t} else {\\n\\t\\t\\tupsertCount(key, oldCnt - 1);\\n\\t\\t}\\n\\t}\\n\\n\\t/** Returns one of the keys with maximal value. */\\n\\tpublic String getMaxKey() {\\n\\t\\tif (cntVsKeyMap.size() == 0) {\\n\\t\\t\\treturn \"\";\\n\\t\\t}\\n\\t\\treturn cntVsKeyMap.lastEntry().getValue().get(0);\\n\\n\\t}\\n\\n\\t/** Returns one of the keys with Minimal value. */\\n\\tpublic String getMinKey() {\\n\\t\\tif (cntVsKeyMap.size() == 0) {\\n\\t\\t\\treturn \"\";\\n\\t\\t}\\n\\t\\treturn cntVsKeyMap.firstEntry().getValue().get(0);\\n\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 382923,
                "title": "python-o-1-not-linkedlist",
                "content": "No fancy data structures in this solution.\\nUse `self.dict` to store the `(key, val)` pair. Use `self.queue` to store all the keys in an ascending order, in terms of their values (this is done in O(1) time). Use `self.pos` to store the position of each key in the queue. Use `self.segment` to store the start and end positions of each segment in the queue. Here, each segment represents a slice of keys in `self.queue` that has the same value.\\n\\nHere is an example. Suppose we have `self.dict` as `{\\'a\\': 2, \\'c\\': 2, \\'b\\': 1, \\'d\\': 1}` already. Then we will see that\\n* `self.queue` is `[\\'a\\', \\'c\\', \\'b\\', \\'d\\']`\\n* `self.pos` is `{\\'a\\': 0, \\'c\\': 1, \\'b\\': 2, \\'d\\': 3}`\\n* `self.segment` is `2: [0, 2], 1: [2, 4]`\\n\\nObviously, the key with the max value is at the first position of `self.queue`; and the key with the min value is at the end.\\nAll we have to do is to maintain the dictionaries and the queue mentioned above.\\n\\n```\\nclass AllOne:\\n    def __init__(self):\\n        self.dict = {}\\n        self.pos = {}\\n        self.segment = {}\\n        self.queue = []\\n        \\n    def inc(self, key: str) -> None:\\n        if key in self.dict:\\n            self.dict[key] += 1\\n            head, current = self.segment[self.dict[key] - 1][0], self.pos[key]\\n            self.pos[key], self.pos[self.queue[head]] = self.pos[self.queue[head]], self.pos[key]\\n            self.queue[head], self.queue[current] = self.queue[current], self.queue[head]\\n            self.segment[self.dict[key] - 1][0] = head + 1\\n            if self.segment[self.dict[key] - 1][0] == self.segment[self.dict[key] - 1][1]:\\n                self.segment.pop(self.dict[key] - 1)\\n            if self.dict[key] not in self.segment:\\n                self.segment[self.dict[key]] = [head, head + 1]\\n            else:\\n                self.segment[self.dict[key]][1] += 1\\n        else:\\n            self.dict[key] = 1\\n            self.queue.append(key)\\n            self.pos[key] = len(self.queue) - 1\\n            if 1 in self.segment:\\n                self.segment[1][1] += 1\\n            else:\\n                self.segment[1] = [self.pos[key], self.pos[key] + 1]\\n        \\n    def dec(self, key: str) -> None:\\n        if key not in self.dict: return\\n        self.dict[key] -= 1\\n        tail, current = self.segment[self.dict[key] + 1][1] - 1, self.pos[key]\\n        self.pos[key], self.pos[self.queue[tail]] = self.pos[self.queue[tail]], self.pos[key]\\n        self.queue[tail], self.queue[current] = self.queue[current], self.queue[tail]\\n        self.segment[self.dict[key] + 1][1] = tail\\n        if self.segment[self.dict[key] + 1][0] == self.segment[self.dict[key] + 1][1]:\\n            self.segment.pop(self.dict[key] + 1)\\n        if self.dict[key] == 0:\\n            self.dict.pop(key)\\n            self.pos.pop(key)\\n            self.queue.pop()\\n        else:\\n            if self.dict[key] not in self.segment:\\n                self.segment[self.dict[key]] = [tail, tail + 1]\\n            else:\\n                self.segment[self.dict[key]][0] -= 1\\n\\n    def getMaxKey(self) -> str:\\n        return self.queue[0] if self.queue else \\'\\'\\n\\n    def getMinKey(self) -> str:\\n        return self.queue[-1] if self.queue else \\'\\'\\n```",
                "solutionTags": [],
                "code": "```\\nclass AllOne:\\n    def __init__(self):\\n        self.dict = {}\\n        self.pos = {}\\n        self.segment = {}\\n        self.queue = []\\n        \\n    def inc(self, key: str) -> None:\\n        if key in self.dict:\\n            self.dict[key] += 1\\n            head, current = self.segment[self.dict[key] - 1][0], self.pos[key]\\n            self.pos[key], self.pos[self.queue[head]] = self.pos[self.queue[head]], self.pos[key]\\n            self.queue[head], self.queue[current] = self.queue[current], self.queue[head]\\n            self.segment[self.dict[key] - 1][0] = head + 1\\n            if self.segment[self.dict[key] - 1][0] == self.segment[self.dict[key] - 1][1]:\\n                self.segment.pop(self.dict[key] - 1)\\n            if self.dict[key] not in self.segment:\\n                self.segment[self.dict[key]] = [head, head + 1]\\n            else:\\n                self.segment[self.dict[key]][1] += 1\\n        else:\\n            self.dict[key] = 1\\n            self.queue.append(key)\\n            self.pos[key] = len(self.queue) - 1\\n            if 1 in self.segment:\\n                self.segment[1][1] += 1\\n            else:\\n                self.segment[1] = [self.pos[key], self.pos[key] + 1]\\n        \\n    def dec(self, key: str) -> None:\\n        if key not in self.dict: return\\n        self.dict[key] -= 1\\n        tail, current = self.segment[self.dict[key] + 1][1] - 1, self.pos[key]\\n        self.pos[key], self.pos[self.queue[tail]] = self.pos[self.queue[tail]], self.pos[key]\\n        self.queue[tail], self.queue[current] = self.queue[current], self.queue[tail]\\n        self.segment[self.dict[key] + 1][1] = tail\\n        if self.segment[self.dict[key] + 1][0] == self.segment[self.dict[key] + 1][1]:\\n            self.segment.pop(self.dict[key] + 1)\\n        if self.dict[key] == 0:\\n            self.dict.pop(key)\\n            self.pos.pop(key)\\n            self.queue.pop()\\n        else:\\n            if self.dict[key] not in self.segment:\\n                self.segment[self.dict[key]] = [tail, tail + 1]\\n            else:\\n                self.segment[self.dict[key]][0] -= 1\\n\\n    def getMaxKey(self) -> str:\\n        return self.queue[0] if self.queue else \\'\\'\\n\\n    def getMinKey(self) -> str:\\n        return self.queue[-1] if self.queue else \\'\\'\\n```",
                "codeTag": "Java"
            },
            {
                "id": 335307,
                "title": "c-double-linked-list-o-1",
                "content": "```\\npublic class AllOne {\\n\\n    // 1, 2, 3 => 1 is head, 3 is tail\\n    LinkedList<int> linkedList = new LinkedList<int>();\\n    Dictionary<int, HashSet<string>> valueAndKeys = new Dictionary<int, HashSet<string>>();\\n    Dictionary<string, LinkedListNode<int>> keyAndValueNode = new Dictionary<string, LinkedListNode<int>>();\\n    public AllOne() {\\n\\n    }\\n\\n    /** Inserts a new key <Key> with value 1. Or increments an existing key by 1. */\\n    public void Inc(string key) {\\n        if (keyAndValueNode.ContainsKey(key)) {\\n            var linkedListNode = keyAndValueNode[key];\\n            var oldValue = linkedListNode.Value;\\n            var newValue = oldValue + 1;\\n\\n            if (!valueAndKeys.ContainsKey(newValue)) {\\n                valueAndKeys[newValue] = new HashSet<string>();\\n                linkedList.AddAfter(linkedListNode, new LinkedListNode<int>(newValue));\\n            }\\n            valueAndKeys[newValue].Add(key);\\n            keyAndValueNode[key] = linkedListNode.Next;\\n\\n            valueAndKeys[oldValue].Remove(key);\\n            if (!valueAndKeys[oldValue].Any()) {\\n                valueAndKeys.Remove(oldValue);\\n                linkedList.Remove(linkedListNode);\\n            }\\n        } else {\\n            if (!valueAndKeys.ContainsKey(1)) {\\n                valueAndKeys[1] = new HashSet<string>();\\n                linkedList.AddFirst(1);\\n            }\\n            valueAndKeys[1].Add(key);\\n            keyAndValueNode[key] = linkedList.First;\\n        }\\n    }\\n\\n    /** Decrements an existing key by 1. If Key\\'s value is 1, remove it from the data structure. */\\n    public void Dec(string key) {\\n        if (keyAndValueNode.ContainsKey(key)) {\\n            var linkedListNode = keyAndValueNode[key];\\n            var oldValue = linkedListNode.Value;\\n            var newValue = oldValue - 1;\\n\\n            if (newValue != 0) {\\n                if (!valueAndKeys.ContainsKey(newValue)) {\\n                    valueAndKeys[newValue] = new HashSet<string>();\\n                    linkedList.AddBefore(linkedListNode, new LinkedListNode<int>(newValue));\\n                }\\n                valueAndKeys[newValue].Add(key);\\n                keyAndValueNode[key] = linkedListNode.Previous;\\n            }\\n\\n            valueAndKeys[oldValue].Remove(key);\\n            if (!valueAndKeys[oldValue].Any()) {\\n                valueAndKeys.Remove(oldValue);\\n                linkedList.Remove(linkedListNode);\\n            }\\n            \\n            if (newValue == 0) {\\n                keyAndValueNode.Remove(key);\\n            }\\n        }\\n    }\\n\\n    /** Returns one of the keys with maximal value. */\\n    public string GetMaxKey() {\\n        return linkedList.Any() ? valueAndKeys[linkedList.Last.Value].First() : \"\";\\n    }\\n\\n    /** Returns one of the keys with Minimal value. */\\n    public string GetMinKey() {\\n        return linkedList.Any() ? valueAndKeys[linkedList.First.Value].First() : \"\";\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class AllOne {\\n\\n    // 1, 2, 3 => 1 is head, 3 is tail\\n    LinkedList<int> linkedList = new LinkedList<int>();\\n    Dictionary<int, HashSet<string>> valueAndKeys = new Dictionary<int, HashSet<string>>();\\n    Dictionary<string, LinkedListNode<int>> keyAndValueNode = new Dictionary<string, LinkedListNode<int>>();\\n    public AllOne() {\\n\\n    }\\n\\n    /** Inserts a new key <Key> with value 1. Or increments an existing key by 1. */\\n    public void Inc(string key) {\\n        if (keyAndValueNode.ContainsKey(key)) {\\n            var linkedListNode = keyAndValueNode[key];\\n            var oldValue = linkedListNode.Value;\\n            var newValue = oldValue + 1;\\n\\n            if (!valueAndKeys.ContainsKey(newValue)) {\\n                valueAndKeys[newValue] = new HashSet<string>();\\n                linkedList.AddAfter(linkedListNode, new LinkedListNode<int>(newValue));\\n            }\\n            valueAndKeys[newValue].Add(key);\\n            keyAndValueNode[key] = linkedListNode.Next;\\n\\n            valueAndKeys[oldValue].Remove(key);\\n            if (!valueAndKeys[oldValue].Any()) {\\n                valueAndKeys.Remove(oldValue);\\n                linkedList.Remove(linkedListNode);\\n            }\\n        } else {\\n            if (!valueAndKeys.ContainsKey(1)) {\\n                valueAndKeys[1] = new HashSet<string>();\\n                linkedList.AddFirst(1);\\n            }\\n            valueAndKeys[1].Add(key);\\n            keyAndValueNode[key] = linkedList.First;\\n        }\\n    }\\n\\n    /** Decrements an existing key by 1. If Key\\'s value is 1, remove it from the data structure. */\\n    public void Dec(string key) {\\n        if (keyAndValueNode.ContainsKey(key)) {\\n            var linkedListNode = keyAndValueNode[key];\\n            var oldValue = linkedListNode.Value;\\n            var newValue = oldValue - 1;\\n\\n            if (newValue != 0) {\\n                if (!valueAndKeys.ContainsKey(newValue)) {\\n                    valueAndKeys[newValue] = new HashSet<string>();\\n                    linkedList.AddBefore(linkedListNode, new LinkedListNode<int>(newValue));\\n                }\\n                valueAndKeys[newValue].Add(key);\\n                keyAndValueNode[key] = linkedListNode.Previous;\\n            }\\n\\n            valueAndKeys[oldValue].Remove(key);\\n            if (!valueAndKeys[oldValue].Any()) {\\n                valueAndKeys.Remove(oldValue);\\n                linkedList.Remove(linkedListNode);\\n            }\\n            \\n            if (newValue == 0) {\\n                keyAndValueNode.Remove(key);\\n            }\\n        }\\n    }\\n\\n    /** Returns one of the keys with maximal value. */\\n    public string GetMaxKey() {\\n        return linkedList.Any() ? valueAndKeys[linkedList.Last.Value].First() : \"\";\\n    }\\n\\n    /** Returns one of the keys with Minimal value. */\\n    public string GetMinKey() {\\n        return linkedList.Any() ? valueAndKeys[linkedList.First.Value].First() : \"\";\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 91425,
                "title": "python-o-1-solution-without-using-linkedlist-sorry-about-the-bad-comments",
                "content": "Sorry I don't have a lots of time recently to write a good explanation, will add more comments when I have time. And I think there are tons of optimizations can be done for this code. Please leave comments. \\n\\n\\n```\\nclass AllOne(object):\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        # key: index_to_rank_array\\n        self.keymap = {}\\n        # store the ranking for all keys\\n        # bigger key on the left, smaller key on the right for easy mantainance.\\n        # when remove key, just pop it in O(1)\\n        # [[key, value]]\\n        self.rank = []\\n        '''\\n        e.g.\\n        keymap = {k1: 0, k2: 1, k3: 2, k4: 3, k5: 4, k6: 5, k7: 6, k8: 7, k9: 8}\\n        [(k1, 3), (k2, 3), (k3, 2), (k4, 2), (k5, 2), (k6, 2), (k7, 1), (k8, 1), (k9, 1)]\\n            0        1        2        3        4        5        6        7        8\\n        for above example, the value_interval would be\\n        value_interval = {1: [6, 8], 2: [2, 5], 3: [0, 1]}\\n        The use case is when we are try to say increase/decrease the value \"2\" at position \"3\"\\n        if there are duplications value of 2, what we want to do is to swap 2 with right most index of 2\\n        it now becomes like this, map must be updated accordingly\\n        keymap = {k1: 0, k2: 1, k3: 2, k4: 5, k5: 4, k6: 3, k7: 6, k8: 7, k9: 8}\\n        [(k1, 3), (k2, 3), (k3, 2), (k6, 2), (k5, 2), (k4, 1), (k7, 1), (k8, 1), (k9, 1)]\\n            0        1        2        3        4        5        6        7        8\\n        should be very careful about updating value 1 and 2, don't forget to expand 1(or whatever smaller than x if we are\\n        updating bigger value, for example, if we are updating 3, 2 may not exist, we should take care of 1, just check when doing this)\\n        value_interval = {1: [5, 8], 2: [2, 4], 3: [0, 1]}\\n        ALL ABOVE OPERATIONS CAN BE ACHIEVE IN O(1), just need to be very careful\\n        '''\\n        self.value_interval = {}\\n\\n    def fix_value_interval(self, idx, old_value=None):\\n        \"\"\"\\n        This function is to fix all issues related to interval map\\n        merge/add/delete\\n\\n        Implement these function separately could make the code more efficient\\n        but it will take a lot more time to do.\\n        \"\"\"\\n        val = self.rank[idx][1]\\n        \"\"\"\\n        The code here is to create/remove existing interval in certain condition.\\n        fix interval can be done later\\n        \"\"\"\\n        if val not in self.value_interval:\\n            # create new interval for new value\\n            self.value_interval[val] = [idx, idx]\\n        # old_value can not be 0\\n        if old_value:\\n            # if the old_value is in his own group, remove that group\\n            old_interval = self.value_interval[old_value]\\n            if old_interval[0] == old_interval[1]:\\n                # remove old group, since it is only contain one value\\n                # and this value has been changed\\n                del self.value_interval[old_value]\\n        if idx < len(self.rank) - 1:\\n            # checking right handside of the idx\\n            right_value = self.rank[idx + 1][1]\\n            right_interval = self.value_interval[right_value]\\n            assert val >= right_value\\n            if val == right_value:\\n                # [3,2,2,[2],2]\\n                # since [2] was covered within the interval range, don't change anything\\n                if right_interval[0] > idx:\\n                    assert right_interval[0] == idx + 1\\n                    right_interval[0] = idx\\n            if val > right_value:\\n                # leave the interval group if necessary\\n                assert right_interval[0] in [idx, idx + 1]\\n                right_interval[0] = idx + 1\\n        if idx > 0:\\n            # checking left hand side of the idx\\n            left_value = self.rank[idx - 1][1]\\n            left_interval = self.value_interval[left_value]\\n            assert val <= left_value\\n            if val == left_value:\\n                # equal to idx, we updated it anyway, still O(1)\\n                if left_interval[1] < idx:\\n                    assert left_interval[1] == idx - 1\\n                    left_interval[1] = idx\\n            if val < left_value:\\n                assert left_interval[1] in [idx, idx - 1]\\n                left_interval[1] = idx - 1\\n        # if the program get this far there are maximum one item in the list,\\n        # this case has been handled by the initial add/remove interval\\n        # operation\\n\\n    def inc(self, key):\\n        # update existing key\\n        if key in self.keymap:\\n            idx = self.keymap[key]\\n            self.rank[idx][1] += 1\\n            new_rank = self.rank[idx]\\n            if idx != 0 and new_rank[1] > self.rank[idx - 1][1]:\\n                swap_with_idx = self.value_interval[self.rank[idx - 1][1]][0]\\n                # left most for idx - 1 value\\n                self.keymap[new_rank[0]] = swap_with_idx\\n                # get the index of the left most interval for previous value\\n                self.keymap[self.rank[swap_with_idx][0]] = idx\\n                self.rank[idx], self.rank[swap_with_idx] = self.rank[swap_with_idx], self.rank[idx]\\n                # fix interval, swap won't create new interval group or cause group\\n                # deletion, since we only swap for duplicates\\n                self.fix_value_interval(swap_with_idx, old_value=None)\\n                self.fix_value_interval(idx, old_value=None)\\n            else:\\n                # for other case either there is no previous value or previous\\n                # value >= new_value, no need to swap, just fix the interval\\n                self.fix_value_interval(idx, old_value=new_rank[1] - 1)\\n        else:\\n            # key not in keymap, append a new one\\n            self.rank.append([key, 1])\\n            idx = len(self.rank) - 1\\n            self.keymap[key] = idx\\n            self.fix_value_interval(idx)\\n\\n    def dec(self, key):\\n        # to pass the test cases\\n        if key not in self.keymap:\\n            return\\n        idx = self.keymap[key]\\n        old_rank = self.rank[idx]\\n        # if old_rank is 1, we should remove it\\n        if old_rank[1] == 1:\\n            del self.keymap[key]\\n            # manually handle interval here, since it is a special case\\n            # one_interval means value interval group for smallest value 1\\n            one_interval = self.value_interval[1]\\n            if one_interval[0] == one_interval[1]:\\n                # now idx must be the last element, otherwise we got problems\\n                assert one_interval[0] == idx == len(self.rank) - 1\\n                del self.value_interval[1]\\n                self.rank.pop()\\n            else:\\n                # there are still more items has value 1\\n                if idx != one_interval[1]:\\n                    # actually now the value we are expecting is self.rank[-1]\\n                    # but this is more readable\\n                    assert self.rank[one_interval[1]] is self.rank[-1]\\n                    right_most_rank = self.rank[one_interval[1]]\\n                    self.rank[idx] = right_most_rank\\n                    self.keymap[right_most_rank[0]] = idx\\n                one_interval[1] -= 1\\n                self.rank.pop()\\n        else:\\n            old_rank[1] -= 1\\n            if idx != len(self.rank) - 1 and old_rank[1] < self.rank[idx + 1][1]:\\n                # get right most element to swap with\\n                swap_with_idx = self.value_interval[self.rank[idx + 1][1]][1]\\n                # left most for idx - 1 value\\n                self.keymap[old_rank[0]] = swap_with_idx\\n                # get the index of the left most interval\\n                self.keymap[self.rank[swap_with_idx][0]] = idx\\n                self.rank[idx], self.rank[swap_with_idx] = self.rank[swap_with_idx], self.rank[idx]\\n                # fix interval, swap won't create new group or cause group\\n                # deletion, since we only swap for duplicates\\n                self.fix_value_interval(swap_with_idx, old_value=None)\\n                self.fix_value_interval(idx, old_value=None)\\n            else:\\n                # for other case either there is no previous value or previous\\n                # value >= new_value, no need to swap, just fix the interval\\n                self.fix_value_interval(idx, old_value=old_rank[1] + 1)\\n\\n    def getMaxKey(self):\\n        \"\"\"\\n        Returns one of the keys with maximal value.\\n        :rtype: str\\n        \"\"\"\\n        # random return or all return can also be implemented with this data\\n        # structure\\n        return self.rank and self.rank[0][0] or \"\"\\n\\n    def getMinKey(self):\\n        \"\"\"\\n        Returns one of the keys with Minimal value.\\n        :rtype: str\\n        \"\"\"\\n        return self.rank and self.rank[-1][0] or \"\"\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass AllOne(object):\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        # key: index_to_rank_array\\n        self.keymap = {}\\n        # store the ranking for all keys\\n        # bigger key on the left, smaller key on the right for easy mantainance.\\n        # when remove key, just pop it in O(1)\\n        # [[key, value]]\\n        self.rank = []\\n        '''\\n        e.g.\\n        keymap = {k1: 0, k2: 1, k3: 2, k4: 3, k5: 4, k6: 5, k7: 6, k8: 7, k9: 8}\\n        [(k1, 3), (k2, 3), (k3, 2), (k4, 2), (k5, 2), (k6, 2), (k7, 1), (k8, 1), (k9, 1)]\\n            0        1        2        3        4        5        6        7        8\\n        for above example, the value_interval would be\\n        value_interval = {1: [6, 8], 2: [2, 5], 3: [0, 1]}\\n        The use case is when we are try to say increase/decrease the value \"2\" at position \"3\"\\n        if there are duplications value of 2, what we want to do is to swap 2 with right most index of 2\\n        it now becomes like this, map must be updated accordingly\\n        keymap = {k1: 0, k2: 1, k3: 2, k4: 5, k5: 4, k6: 3, k7: 6, k8: 7, k9: 8}\\n        [(k1, 3), (k2, 3), (k3, 2), (k6, 2), (k5, 2), (k4, 1), (k7, 1), (k8, 1), (k9, 1)]\\n            0        1        2        3        4        5        6        7        8\\n        should be very careful about updating value 1 and 2, don't forget to expand 1(or whatever smaller than x if we are\\n        updating bigger value, for example, if we are updating 3, 2 may not exist, we should take care of 1, just check when doing this)\\n        value_interval = {1: [5, 8], 2: [2, 4], 3: [0, 1]}\\n        ALL ABOVE OPERATIONS CAN BE ACHIEVE IN O(1), just need to be very careful\\n        '''\\n        self.value_interval = {}\\n\\n    def fix_value_interval(self, idx, old_value=None):\\n        \"\"\"\\n        This function is to fix all issues related to interval map\\n        merge/add/delete\\n\\n        Implement these function separately could make the code more efficient\\n        but it will take a lot more time to do.\\n        \"\"\"\\n        val = self.rank[idx][1]\\n        \"\"\"\\n        The code here is to create/remove existing interval in certain condition.\\n        fix interval can be done later\\n        \"\"\"\\n        if val not in self.value_interval:\\n            # create new interval for new value\\n            self.value_interval[val] = [idx, idx]\\n        # old_value can not be 0\\n        if old_value:\\n            # if the old_value is in his own group, remove that group\\n            old_interval = self.value_interval[old_value]\\n            if old_interval[0] == old_interval[1]:\\n                # remove old group, since it is only contain one value\\n                # and this value has been changed\\n                del self.value_interval[old_value]\\n        if idx < len(self.rank) - 1:\\n            # checking right handside of the idx\\n            right_value = self.rank[idx + 1][1]\\n            right_interval = self.value_interval[right_value]\\n            assert val >= right_value\\n            if val == right_value:\\n                # [3,2,2,[2],2]\\n                # since [2] was covered within the interval range, don't change anything\\n                if right_interval[0] > idx:\\n                    assert right_interval[0] == idx + 1\\n                    right_interval[0] = idx\\n            if val > right_value:\\n                # leave the interval group if necessary\\n                assert right_interval[0] in [idx, idx + 1]\\n                right_interval[0] = idx + 1\\n        if idx > 0:\\n            # checking left hand side of the idx\\n            left_value = self.rank[idx - 1][1]\\n            left_interval = self.value_interval[left_value]\\n            assert val <= left_value\\n            if val == left_value:\\n                # equal to idx, we updated it anyway, still O(1)\\n                if left_interval[1] < idx:\\n                    assert left_interval[1] == idx - 1\\n                    left_interval[1] = idx\\n            if val < left_value:\\n                assert left_interval[1] in [idx, idx - 1]\\n                left_interval[1] = idx - 1\\n        # if the program get this far there are maximum one item in the list,\\n        # this case has been handled by the initial add/remove interval\\n        # operation\\n\\n    def inc(self, key):\\n        # update existing key\\n        if key in self.keymap:\\n            idx = self.keymap[key]\\n            self.rank[idx][1] += 1\\n            new_rank = self.rank[idx]\\n            if idx != 0 and new_rank[1] > self.rank[idx - 1][1]:\\n                swap_with_idx = self.value_interval[self.rank[idx - 1][1]][0]\\n                # left most for idx - 1 value\\n                self.keymap[new_rank[0]] = swap_with_idx\\n                # get the index of the left most interval for previous value\\n                self.keymap[self.rank[swap_with_idx][0]] = idx\\n                self.rank[idx], self.rank[swap_with_idx] = self.rank[swap_with_idx], self.rank[idx]\\n                # fix interval, swap won't create new interval group or cause group\\n                # deletion, since we only swap for duplicates\\n                self.fix_value_interval(swap_with_idx, old_value=None)\\n                self.fix_value_interval(idx, old_value=None)\\n            else:\\n                # for other case either there is no previous value or previous\\n                # value >= new_value, no need to swap, just fix the interval\\n                self.fix_value_interval(idx, old_value=new_rank[1] - 1)\\n        else:\\n            # key not in keymap, append a new one\\n            self.rank.append([key, 1])\\n            idx = len(self.rank) - 1\\n            self.keymap[key] = idx\\n            self.fix_value_interval(idx)\\n\\n    def dec(self, key):\\n        # to pass the test cases\\n        if key not in self.keymap:\\n            return\\n        idx = self.keymap[key]\\n        old_rank = self.rank[idx]\\n        # if old_rank is 1, we should remove it\\n        if old_rank[1] == 1:\\n            del self.keymap[key]\\n            # manually handle interval here, since it is a special case\\n            # one_interval means value interval group for smallest value 1\\n            one_interval = self.value_interval[1]\\n            if one_interval[0] == one_interval[1]:\\n                # now idx must be the last element, otherwise we got problems\\n                assert one_interval[0] == idx == len(self.rank) - 1\\n                del self.value_interval[1]\\n                self.rank.pop()\\n            else:\\n                # there are still more items has value 1\\n                if idx != one_interval[1]:\\n                    # actually now the value we are expecting is self.rank[-1]\\n                    # but this is more readable\\n                    assert self.rank[one_interval[1]] is self.rank[-1]\\n                    right_most_rank = self.rank[one_interval[1]]\\n                    self.rank[idx] = right_most_rank\\n                    self.keymap[right_most_rank[0]] = idx\\n                one_interval[1] -= 1\\n                self.rank.pop()\\n        else:\\n            old_rank[1] -= 1\\n            if idx != len(self.rank) - 1 and old_rank[1] < self.rank[idx + 1][1]:\\n                # get right most element to swap with\\n                swap_with_idx = self.value_interval[self.rank[idx + 1][1]][1]\\n                # left most for idx - 1 value\\n                self.keymap[old_rank[0]] = swap_with_idx\\n                # get the index of the left most interval\\n                self.keymap[self.rank[swap_with_idx][0]] = idx\\n                self.rank[idx], self.rank[swap_with_idx] = self.rank[swap_with_idx], self.rank[idx]\\n                # fix interval, swap won't create new group or cause group\\n                # deletion, since we only swap for duplicates\\n                self.fix_value_interval(swap_with_idx, old_value=None)\\n                self.fix_value_interval(idx, old_value=None)\\n            else:\\n                # for other case either there is no previous value or previous\\n                # value >= new_value, no need to swap, just fix the interval\\n                self.fix_value_interval(idx, old_value=old_rank[1] + 1)\\n\\n    def getMaxKey(self):\\n        \"\"\"\\n        Returns one of the keys with maximal value.\\n        :rtype: str\\n        \"\"\"\\n        # random return or all return can also be implemented with this data\\n        # structure\\n        return self.rank and self.rank[0][0] or \"\"\\n\\n    def getMinKey(self):\\n        \"\"\"\\n        Returns one of the keys with Minimal value.\\n        :rtype: str\\n        \"\"\"\\n        return self.rank and self.rank[-1][0] or \"\"\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3928994,
                "title": "solution-o-1-runtime-99",
                "content": "![\\u0421\\u043D\\u0438\\u043C\\u043E\\u043A \\u044D\\u043A\\u0440\\u0430\\u043D\\u0430 2023-08-19 \\u0432 03.02.54.png](https://assets.leetcode.com/users/images/de880499-cecf-42b0-9d11-5983ee945d07_1692406839.9982073.png)\\n\\n```\\nclass ListCount:\\n    def __init__(self, set_string, count, prev= None, next= None):\\n        self.set_string = set_string\\n        self.count = count\\n        self.next = next\\n        self.prev = prev\\n\\nclass AllOne:\\n    def __init__(self):\\n        self.head = ListCount({\"\"}, count= 0)\\n        self.tail = ListCount({\"\"}, count= inf, prev= self.head)\\n        self.head.next = self.tail\\n        self.dic_string = {}\\n\\n    def inc(self, key: str) -> None:\\n        if key in self.dic_string:\\n            node = self.dic_string[key]\\n            inc_cnt = node.count+1    \\n            if len(node.set_string) == 1:\\n                if inc_cnt ==  node.next.count:\\n                    node.next.set_string.add(key)\\n                    self.dic_string[key] = node.next\\n                    node.next.prev, node.prev.next = node.prev, node.next \\n                else:\\n                    node.count = inc_cnt       \\n            else:\\n                node.set_string.remove(key)\\n                if inc_cnt == node.next.count:\\n                    node.next.set_string.add(key)\\n                    self.dic_string[key] = node.next\\n                else:\\n                    new_node = ListCount(set_string= {key}, count= inc_cnt, prev= node, next= node.next)\\n                    node.next.prev = new_node\\n                    node.next = new_node\\n                    self.dic_string[key] = new_node\\n        else:\\n            if self.head.next.count == 1:\\n                self.head.next.set_string.add(key)\\n                self.dic_string[key] = self.head.next\\n            else:  \\n                node = ListCount(set_string= {key}, count= 1, prev= self.head, next= self.head.next)\\n                self.head.next.prev = node\\n                self.head.next = node\\n                self.dic_string[key] = node\\n\\n    def dec(self, key: str) -> None:\\n        node = self.dic_string[key]\\n        if node.count == 1:    \\n            if len(node.set_string) == 1:  \\n                node.next.prev, node.prev.next = node.prev, node.next \\n            else:\\n                node.set_string.remove(key)\\n            del self.dic_string[key]                        \\n        else:\\n            dec_cnt = node.count-1\\n            if len(node.set_string) == 1:\\n                if dec_cnt ==  node.prev.count:\\n                    node.prev.set_string.add(key)\\n                    self.dic_string[key] = node.prev\\n                    node.next.prev, node.prev.next = node.prev, node.next \\n                else:\\n                    node.count = dec_cnt       \\n            else:\\n                node.set_string.remove(key)\\n                if dec_cnt == node.prev.count:\\n                    node.prev.set_string.add(key)\\n                    self.dic_string[key] = node.prev\\n                else:\\n                    new_node = ListCount(set_string= {key}, count= dec_cnt, prev= node.prev, next= node)\\n                    node.prev.next = new_node\\n                    node.prev = new_node\\n                    self.dic_string[key] = new_node\\n\\n    def getMaxKey(self) -> str:\\n        return next(iter(self.tail.prev.set_string))\\n        \\n    def getMinKey(self) -> str:\\n        return next(iter(self.head.next.set_string))\\n```\\n###### Another quick solution (runtime > 96%). But contains one small loop in def getMinKey\\n```\\nclass AllOne:\\n    def __init__(self):\\n        self.dic_counter = {}\\n        self.dic_string = defaultdict(set)\\n        self.max_cnt = 1\\n\\n    def inc(self, key: str) -> None: \\n        if key in self.dic_counter:\\n            cnt = self.dic_counter[key]\\n            self.dic_counter[key] = cnt+1          \\n            self.dic_string[cnt].remove(key)\\n            self.dic_string[cnt+1].add(key)\\n            self.max_cnt = max(cnt+1, self.max_cnt)\\n        else:\\n            self.dic_counter[key] = 1\\n            self.dic_string[1].add(key)\\n\\n    def dec(self, key: str) -> None:\\n        cnt = self.dic_counter[key]\\n        if cnt == 1:\\n            del self.dic_counter[key]\\n            self.dic_string[cnt].remove(key)\\n        else:\\n            self.dic_counter[key] = cnt-1          \\n            self.dic_string[cnt-1].add(key)\\n            if self.max_cnt == cnt and len(self.dic_string[cnt]) == 1:\\n                self.max_cnt -= 1\\n                del self.dic_string[cnt]\\n            else:\\n                self.dic_string[cnt].remove(key)\\n\\n    def getMaxKey(self) -> str:\\n        return next(iter(self.dic_string[self.max_cnt])) if self.dic_counter else \"\"\\n        \\n    def getMinKey(self) -> str:\\n        if not self.dic_counter:\\n            return \"\"\\n        for min_cnt in iter(self.dic_string):\\n            if self.dic_string[min_cnt]:\\n                return next(iter(self.dic_string[min_cnt]))\\n```\\n\\n",
                "solutionTags": [
                    "Python3",
                    "Linked List"
                ],
                "code": "```\\nclass ListCount:\\n    def __init__(self, set_string, count, prev= None, next= None):\\n        self.set_string = set_string\\n        self.count = count\\n        self.next = next\\n        self.prev = prev\\n\\nclass AllOne:\\n    def __init__(self):\\n        self.head = ListCount({\"\"}, count= 0)\\n        self.tail = ListCount({\"\"}, count= inf, prev= self.head)\\n        self.head.next = self.tail\\n        self.dic_string = {}\\n\\n    def inc(self, key: str) -> None:\\n        if key in self.dic_string:\\n            node = self.dic_string[key]\\n            inc_cnt = node.count+1    \\n            if len(node.set_string) == 1:\\n                if inc_cnt ==  node.next.count:\\n                    node.next.set_string.add(key)\\n                    self.dic_string[key] = node.next\\n                    node.next.prev, node.prev.next = node.prev, node.next \\n                else:\\n                    node.count = inc_cnt       \\n            else:\\n                node.set_string.remove(key)\\n                if inc_cnt == node.next.count:\\n                    node.next.set_string.add(key)\\n                    self.dic_string[key] = node.next\\n                else:\\n                    new_node = ListCount(set_string= {key}, count= inc_cnt, prev= node, next= node.next)\\n                    node.next.prev = new_node\\n                    node.next = new_node\\n                    self.dic_string[key] = new_node\\n        else:\\n            if self.head.next.count == 1:\\n                self.head.next.set_string.add(key)\\n                self.dic_string[key] = self.head.next\\n            else:  \\n                node = ListCount(set_string= {key}, count= 1, prev= self.head, next= self.head.next)\\n                self.head.next.prev = node\\n                self.head.next = node\\n                self.dic_string[key] = node\\n\\n    def dec(self, key: str) -> None:\\n        node = self.dic_string[key]\\n        if node.count == 1:    \\n            if len(node.set_string) == 1:  \\n                node.next.prev, node.prev.next = node.prev, node.next \\n            else:\\n                node.set_string.remove(key)\\n            del self.dic_string[key]                        \\n        else:\\n            dec_cnt = node.count-1\\n            if len(node.set_string) == 1:\\n                if dec_cnt ==  node.prev.count:\\n                    node.prev.set_string.add(key)\\n                    self.dic_string[key] = node.prev\\n                    node.next.prev, node.prev.next = node.prev, node.next \\n                else:\\n                    node.count = dec_cnt       \\n            else:\\n                node.set_string.remove(key)\\n                if dec_cnt == node.prev.count:\\n                    node.prev.set_string.add(key)\\n                    self.dic_string[key] = node.prev\\n                else:\\n                    new_node = ListCount(set_string= {key}, count= dec_cnt, prev= node.prev, next= node)\\n                    node.prev.next = new_node\\n                    node.prev = new_node\\n                    self.dic_string[key] = new_node\\n\\n    def getMaxKey(self) -> str:\\n        return next(iter(self.tail.prev.set_string))\\n        \\n    def getMinKey(self) -> str:\\n        return next(iter(self.head.next.set_string))\\n```\n```\\nclass AllOne:\\n    def __init__(self):\\n        self.dic_counter = {}\\n        self.dic_string = defaultdict(set)\\n        self.max_cnt = 1\\n\\n    def inc(self, key: str) -> None: \\n        if key in self.dic_counter:\\n            cnt = self.dic_counter[key]\\n            self.dic_counter[key] = cnt+1          \\n            self.dic_string[cnt].remove(key)\\n            self.dic_string[cnt+1].add(key)\\n            self.max_cnt = max(cnt+1, self.max_cnt)\\n        else:\\n            self.dic_counter[key] = 1\\n            self.dic_string[1].add(key)\\n\\n    def dec(self, key: str) -> None:\\n        cnt = self.dic_counter[key]\\n        if cnt == 1:\\n            del self.dic_counter[key]\\n            self.dic_string[cnt].remove(key)\\n        else:\\n            self.dic_counter[key] = cnt-1          \\n            self.dic_string[cnt-1].add(key)\\n            if self.max_cnt == cnt and len(self.dic_string[cnt]) == 1:\\n                self.max_cnt -= 1\\n                del self.dic_string[cnt]\\n            else:\\n                self.dic_string[cnt].remove(key)\\n\\n    def getMaxKey(self) -> str:\\n        return next(iter(self.dic_string[self.max_cnt])) if self.dic_counter else \"\"\\n        \\n    def getMinKey(self) -> str:\\n        if not self.dic_counter:\\n            return \"\"\\n        for min_cnt in iter(self.dic_string):\\n            if self.dic_string[min_cnt]:\\n                return next(iter(self.dic_string[min_cnt]))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3190918,
                "title": "c-solution-using-unordered-map-and-ordered-set",
                "content": "```\\nclass AllOne {\\npublic:\\n    unordered_map<string ,int>map;\\n    set<pair<int,string>> s;\\n    \\n    AllOne() {}\\n    \\n    \\n    void inc(string key) {\\n        int count= map[key];\\n        s.erase({count, key});\\n        \\n        map[key]++;\\n        s.insert({map[key], key});\\n    }\\n    \\n    \\n    void dec(string key) {\\n        int count= map[key];\\n        s.erase({count, key});\\n        \\n        map[key]--;\\n        \\n        if(map[key]==0) map.erase(key);\\n        else s.insert({map[key], key});\\n    }\\n    \\n    \\n    string getMaxKey() {\\n        return s.size()==0 ? \"\" :  s.rbegin()->second;\\n    }\\n    \\n    \\n    string getMinKey() {\\n        return s.size()==0 ? \"\" : s.begin()->second;\\n    }\\n};\\n\\n/**\\n * Your AllOne object will be instantiated and called as such:\\n * AllOne* obj = new AllOne();\\n * obj->inc(key);\\n * obj->dec(key);\\n * string param_3 = obj->getMaxKey();\\n * string param_4 = obj->getMinKey();\\n */\\n```\\n\\nit should be medium not hard, have seen many medium problems way harder than this",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass AllOne {\\npublic:\\n    unordered_map<string ,int>map;\\n    set<pair<int,string>> s;\\n    \\n    AllOne() {}\\n    \\n    \\n    void inc(string key) {\\n        int count= map[key];\\n        s.erase({count, key});\\n        \\n        map[key]++;\\n        s.insert({map[key], key});\\n    }\\n    \\n    \\n    void dec(string key) {\\n        int count= map[key];\\n        s.erase({count, key});\\n        \\n        map[key]--;\\n        \\n        if(map[key]==0) map.erase(key);\\n        else s.insert({map[key], key});\\n    }\\n    \\n    \\n    string getMaxKey() {\\n        return s.size()==0 ? \"\" :  s.rbegin()->second;\\n    }\\n    \\n    \\n    string getMinKey() {\\n        return s.size()==0 ? \"\" : s.begin()->second;\\n    }\\n};\\n\\n/**\\n * Your AllOne object will be instantiated and called as such:\\n * AllOne* obj = new AllOne();\\n * obj->inc(key);\\n * obj->dec(key);\\n * string param_3 = obj->getMaxKey();\\n * string param_4 = obj->getMinKey();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2697460,
                "title": "short-and-clean-easy-to-understand-solution",
                "content": "***Easy , short and clean solution with the help of map and set only.***\\n\\n```\\nclass AllOne {\\npublic:\\n    unordered_map<string , int>mp;\\n    set<pair<int,string>>s;\\n    AllOne() {\\n        mp.clear();\\n        s.clear();\\n    }\\n    \\n    void inc(string key) {\\n        if(mp[key]==0)\\n        {\\n            mp[key]++ ;\\n            s.insert({mp[key],key});\\n        }\\n        \\n        else\\n        {\\n            s.erase(s.find({mp[key],key}));\\n            mp[key]++;\\n            s.insert({mp[key],key});\\n        }\\n    }\\n    \\n    void dec(string key) {\\n        \\n        if(mp[key]==1)\\n        {\\n            mp.erase(key);\\n        \\ts.erase(s.find({1,key}));\\n        }\\n        else\\n        {\\n        \\ts.erase(s.find({mp[key],key}));\\n            mp[key]--;\\n        \\ts.insert({mp[key],key});\\n\\t\\t}\\n    }\\n    \\n    string getMinKey() {\\n       return s.size()>0?(pair<int,string>(*(s.begin())).second):\"\";\\n    }\\n    string getMaxKey() {\\n        return s.size()>0?(pair<int,string>(*(s.rbegin())).second):\"\";\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass AllOne {\\npublic:\\n    unordered_map<string , int>mp;\\n    set<pair<int,string>>s;\\n    AllOne() {\\n        mp.clear();\\n        s.clear();\\n    }\\n    \\n    void inc(string key) {\\n        if(mp[key]==0)\\n        {\\n            mp[key]++ ;\\n            s.insert({mp[key],key});\\n        }\\n        \\n        else\\n        {\\n            s.erase(s.find({mp[key],key}));\\n            mp[key]++;\\n            s.insert({mp[key],key});\\n        }\\n    }\\n    \\n    void dec(string key) {\\n        \\n        if(mp[key]==1)\\n        {\\n            mp.erase(key);\\n        \\ts.erase(s.find({1,key}));\\n        }\\n        else\\n        {\\n        \\ts.erase(s.find({mp[key],key}));\\n            mp[key]--;\\n        \\ts.insert({mp[key],key});\\n\\t\\t}\\n    }\\n    \\n    string getMinKey() {\\n       return s.size()>0?(pair<int,string>(*(s.begin())).second):\"\";\\n    }\\n    string getMaxKey() {\\n        return s.size()>0?(pair<int,string>(*(s.rbegin())).second):\"\";\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2225403,
                "title": "unordered-map-solution-c",
                "content": "```\\nclass AllOne {\\nprotected:\\n    string nil;\\n    list<pair<uint, unordered_set<const string*>>> lst; // use pointer to save time and space\\n    unordered_map<string, list<pair<uint, unordered_set<const string*>>>::iterator> map;\\npublic:\\n    AllOne() {\\n        lst.emplace_back(0, unordered_set<const string*>());\\n        lst.begin()->second.insert(&nil);\\n    }\\n\\n    void inc(string key) {\\n        list<pair<uint, unordered_set<const string*>>>::iterator iter = ++lst.begin();\\n        uint val = 1;\\n        auto it = map.find(key);\\n        if (it != map.end()) {\\n            iter = it->second;\\n            val = iter->first + 1;\\n            iter->second.erase(&it->first);\\n            if (!iter->second.size()) iter = lst.erase(iter);\\n            else iter++;\\n        }\\n        if (iter == lst.end() || iter->first != val) iter = lst.insert(iter, pair<uint, unordered_set<const string*>>(val, unordered_set<const string*>()));\\n        map[key] = iter;\\n        iter->second.insert(&map.find(key)->first);\\n    }\\n\\n    void dec(string key) {\\n        auto it = map.find(key);\\n        if (it == map.end()) return;\\n        list<pair<uint, unordered_set<const string*>>>::iterator& iter = it->second; // reference\\n        uint val = iter->first - 1;\\n        iter->second.erase(&it->first);\\n        if (!iter->second.size()) iter = lst.erase(iter);\\n        if (!val) map.erase(key);\\n        else {\\n            if (prev(iter)->first != val) iter = lst.insert(iter, pair<uint, unordered_set<const string*>>(val, unordered_set<const string*>()));\\n            else iter--;\\n            iter->second.insert(&it->first);\\n        }\\n    }\\n\\n    string getMaxKey() {\\n        return **lst.rbegin()->second.begin();\\n    }\\n\\n    string getMinKey() {\\n        return lst.size() > 1 ? **(++lst.begin())->second.begin() : **lst.begin()->second.begin();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass AllOne {\\nprotected:\\n    string nil;\\n    list<pair<uint, unordered_set<const string*>>> lst; // use pointer to save time and space\\n    unordered_map<string, list<pair<uint, unordered_set<const string*>>>::iterator> map;\\npublic:\\n    AllOne() {\\n        lst.emplace_back(0, unordered_set<const string*>());\\n        lst.begin()->second.insert(&nil);\\n    }\\n\\n    void inc(string key) {\\n        list<pair<uint, unordered_set<const string*>>>::iterator iter = ++lst.begin();\\n        uint val = 1;\\n        auto it = map.find(key);\\n        if (it != map.end()) {\\n            iter = it->second;\\n            val = iter->first + 1;\\n            iter->second.erase(&it->first);\\n            if (!iter->second.size()) iter = lst.erase(iter);\\n            else iter++;\\n        }\\n        if (iter == lst.end() || iter->first != val) iter = lst.insert(iter, pair<uint, unordered_set<const string*>>(val, unordered_set<const string*>()));\\n        map[key] = iter;\\n        iter->second.insert(&map.find(key)->first);\\n    }\\n\\n    void dec(string key) {\\n        auto it = map.find(key);\\n        if (it == map.end()) return;\\n        list<pair<uint, unordered_set<const string*>>>::iterator& iter = it->second; // reference\\n        uint val = iter->first - 1;\\n        iter->second.erase(&it->first);\\n        if (!iter->second.size()) iter = lst.erase(iter);\\n        if (!val) map.erase(key);\\n        else {\\n            if (prev(iter)->first != val) iter = lst.insert(iter, pair<uint, unordered_set<const string*>>(val, unordered_set<const string*>()));\\n            else iter--;\\n            iter->second.insert(&it->first);\\n        }\\n    }\\n\\n    string getMaxKey() {\\n        return **lst.rbegin()->second.begin();\\n    }\\n\\n    string getMinKey() {\\n        return lst.size() > 1 ? **(++lst.begin())->second.begin() : **lst.begin()->second.begin();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2075452,
                "title": "c-strict-o-1-boudly-linkedlist-map-set-of-keys",
                "content": "```\\nclass AllOne {\\npublic:\\n    class Node {\\n        public:\\n        int freq;\\n        unordered_set<string> keys;\\n        Node *prev = NULL;\\n        Node *next = NULL;\\n        Node(int f) {\\n            freq = f;\\n        }\\n        Node(string key, int f) {\\n            freq = f;\\n            keys.insert(key);\\n        }\\n    };\\n    \\n    unordered_map<string, Node*> mp;\\n    Node *head;\\n    Node *tail;\\n    \\n    AllOne() {\\n        head = new Node(-1);\\n        tail = new Node(-1);\\n        head->next=tail;\\n        tail->prev=head;\\n    }\\n    \\n    void insertNext(Node *node, Node *newNode) {\\n        node->next->prev = newNode;\\n        newNode->next=node->next;\\n        newNode->prev=node;\\n        node->next=newNode;\\n    }\\n    \\n    void deleteNode(Node *node) {\\n        node->next->prev=node->prev;\\n        node->prev->next=node->next;\\n        node->prev=NULL;\\n        node->next=NULL;\\n    }\\n    \\n    void removeKey(Node *node, string key) {\\n        node->keys.erase(key);\\n        if(node->keys.size() == 0) {\\n            deleteNode(node);\\n        }\\n    }\\n    \\n    void inc(string key) {\\n        //if key is present in map or not\\n        if(mp.find(key)!=mp.end()) {\\n            Node *node = mp[key];\\n            if(node->next->freq == node->freq+1) {\\n                mp[key]=node->next;\\n                node->next->keys.insert(key);\\n            } else {\\n                Node *newNode = new Node(key, node->freq + 1);\\n                mp[key] = newNode;\\n                insertNext(node, newNode);\\n            }\\n            removeKey(node, key);\\n        } else {\\n            if(head->next->freq == 1) {\\n                head->next->keys.insert(key);\\n                mp[key]=head->next;\\n            } else {\\n                Node *newNode = new Node(key, 1);\\n                insertNext(head, newNode);\\n                mp[key]=newNode;\\n            }\\n        }\\n    }\\n    \\n    void dec(string key) {\\n        if(mp.find(key)==mp.end()) return;\\n        Node *node = mp[key];\\n        if(node->freq == 1) {\\n            mp.erase(key);\\n        }\\n        else if(node->prev->freq == node->freq-1) {\\n            node->prev->keys.insert(key);\\n            mp[key]=node->prev;\\n        } else {\\n            Node *newNode = new Node(key, node->freq-1);\\n            mp[key] = newNode;\\n            insertNext(node->prev, newNode);\\n        }\\n        removeKey(node, key);\\n    }\\n    \\n    string getMaxKey() {\\n        string ans = \"\";\\n        if(tail->prev->freq != -1) {\\n            ans = *tail->prev->keys.begin();\\n        }\\n        return ans;\\n    }\\n    \\n    string getMinKey() {\\n        string ans = \"\";\\n        if(head->next->freq != -1) {\\n            ans = *(head->next->keys.begin());\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass AllOne {\\npublic:\\n    class Node {\\n        public:\\n        int freq;\\n        unordered_set<string> keys;\\n        Node *prev = NULL;\\n        Node *next = NULL;\\n        Node(int f) {\\n            freq = f;\\n        }\\n        Node(string key, int f) {\\n            freq = f;\\n            keys.insert(key);\\n        }\\n    };\\n    \\n    unordered_map<string, Node*> mp;\\n    Node *head;\\n    Node *tail;\\n    \\n    AllOne() {\\n        head = new Node(-1);\\n        tail = new Node(-1);\\n        head->next=tail;\\n        tail->prev=head;\\n    }\\n    \\n    void insertNext(Node *node, Node *newNode) {\\n        node->next->prev = newNode;\\n        newNode->next=node->next;\\n        newNode->prev=node;\\n        node->next=newNode;\\n    }\\n    \\n    void deleteNode(Node *node) {\\n        node->next->prev=node->prev;\\n        node->prev->next=node->next;\\n        node->prev=NULL;\\n        node->next=NULL;\\n    }\\n    \\n    void removeKey(Node *node, string key) {\\n        node->keys.erase(key);\\n        if(node->keys.size() == 0) {\\n            deleteNode(node);\\n        }\\n    }\\n    \\n    void inc(string key) {\\n        //if key is present in map or not\\n        if(mp.find(key)!=mp.end()) {\\n            Node *node = mp[key];\\n            if(node->next->freq == node->freq+1) {\\n                mp[key]=node->next;\\n                node->next->keys.insert(key);\\n            } else {\\n                Node *newNode = new Node(key, node->freq + 1);\\n                mp[key] = newNode;\\n                insertNext(node, newNode);\\n            }\\n            removeKey(node, key);\\n        } else {\\n            if(head->next->freq == 1) {\\n                head->next->keys.insert(key);\\n                mp[key]=head->next;\\n            } else {\\n                Node *newNode = new Node(key, 1);\\n                insertNext(head, newNode);\\n                mp[key]=newNode;\\n            }\\n        }\\n    }\\n    \\n    void dec(string key) {\\n        if(mp.find(key)==mp.end()) return;\\n        Node *node = mp[key];\\n        if(node->freq == 1) {\\n            mp.erase(key);\\n        }\\n        else if(node->prev->freq == node->freq-1) {\\n            node->prev->keys.insert(key);\\n            mp[key]=node->prev;\\n        } else {\\n            Node *newNode = new Node(key, node->freq-1);\\n            mp[key] = newNode;\\n            insertNext(node->prev, newNode);\\n        }\\n        removeKey(node, key);\\n    }\\n    \\n    string getMaxKey() {\\n        string ans = \"\";\\n        if(tail->prev->freq != -1) {\\n            ans = *tail->prev->keys.begin();\\n        }\\n        return ans;\\n    }\\n    \\n    string getMinKey() {\\n        string ans = \"\";\\n        if(head->next->freq != -1) {\\n            ans = *(head->next->keys.begin());\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1911963,
                "title": "java-easy-solution-using-hashmap-and-treemap",
                "content": "```\\nclass AllOne {\\n    private Map<String, Integer> map;\\n    private TreeMap<Integer, Set<String>> tm;\\n    \\n    public AllOne() {\\n        map = new HashMap<>();\\n        tm = new TreeMap<>();\\n    }\\n    \\n    public void inc(String key) {\\n        int oldNum = map.getOrDefault(key, 0);\\n        int newNum = oldNum + 1;\\n        \\n        map.put(key, newNum);\\n        \\n        if (tm.containsKey(oldNum)) {\\n            Set<String> oldSet = tm.get(oldNum);\\n            oldSet.remove(key);\\n            if (oldSet.size() > 0) {\\n                tm.put(oldNum, oldSet);\\n            } else {\\n                tm.remove(oldNum);\\n            }\\n        }\\n        \\n        Set<String> newSet = tm.getOrDefault(newNum, new HashSet<String>());\\n        newSet.add(key);\\n        tm.put(newNum, newSet);\\n    }\\n    \\n    public void dec(String key) {\\n        int oldNum = map.getOrDefault(key, 0);\\n        int newNum = oldNum - 1;\\n        \\n        if (newNum == 0) {\\n            map.remove(key);\\n        } else {\\n            map.put(key, newNum);    \\n        }\\n        \\n        Set<String> oldSet = tm.get(oldNum);\\n        oldSet.remove(key);\\n        if (oldSet.size() > 0) {\\n            tm.put(oldNum, oldSet);\\n        } else {\\n            tm.remove(oldNum);\\n        }\\n        \\n        if (newNum > 0) {\\n            Set<String> newSet = tm.getOrDefault(newNum, new HashSet<String>());\\n            newSet.add(key);\\n            tm.put(newNum, newSet);    \\n        }\\n    }\\n    \\n    public String getMaxKey() {\\n        if (tm.isEmpty()) {\\n            return \"\";\\n        }\\n        Set<String> set = tm.get(tm.lastKey());\\n        return set.iterator().next();\\n    }\\n    \\n    public String getMinKey() {\\n        if (tm.isEmpty()) {\\n            return \"\";\\n        } \\n        Set<String> set = tm.get(tm.firstKey());\\n        return set.iterator().next();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass AllOne {\\n    private Map<String, Integer> map;\\n    private TreeMap<Integer, Set<String>> tm;\\n    \\n    public AllOne() {\\n        map = new HashMap<>();\\n        tm = new TreeMap<>();\\n    }\\n    \\n    public void inc(String key) {\\n        int oldNum = map.getOrDefault(key, 0);\\n        int newNum = oldNum + 1;\\n        \\n        map.put(key, newNum);\\n        \\n        if (tm.containsKey(oldNum)) {\\n            Set<String> oldSet = tm.get(oldNum);\\n            oldSet.remove(key);\\n            if (oldSet.size() > 0) {\\n                tm.put(oldNum, oldSet);\\n            } else {\\n                tm.remove(oldNum);\\n            }\\n        }\\n        \\n        Set<String> newSet = tm.getOrDefault(newNum, new HashSet<String>());\\n        newSet.add(key);\\n        tm.put(newNum, newSet);\\n    }\\n    \\n    public void dec(String key) {\\n        int oldNum = map.getOrDefault(key, 0);\\n        int newNum = oldNum - 1;\\n        \\n        if (newNum == 0) {\\n            map.remove(key);\\n        } else {\\n            map.put(key, newNum);    \\n        }\\n        \\n        Set<String> oldSet = tm.get(oldNum);\\n        oldSet.remove(key);\\n        if (oldSet.size() > 0) {\\n            tm.put(oldNum, oldSet);\\n        } else {\\n            tm.remove(oldNum);\\n        }\\n        \\n        if (newNum > 0) {\\n            Set<String> newSet = tm.getOrDefault(newNum, new HashSet<String>());\\n            newSet.add(key);\\n            tm.put(newNum, newSet);    \\n        }\\n    }\\n    \\n    public String getMaxKey() {\\n        if (tm.isEmpty()) {\\n            return \"\";\\n        }\\n        Set<String> set = tm.get(tm.lastKey());\\n        return set.iterator().next();\\n    }\\n    \\n    public String getMinKey() {\\n        if (tm.isEmpty()) {\\n            return \"\";\\n        } \\n        Set<String> set = tm.get(tm.firstKey());\\n        return set.iterator().next();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1706215,
                "title": "thinking-process-for-the-strucuture-design-hashmap-linkedlist-custom-node",
                "content": "**1. Node**\\nFor this problem, it is clearly to see that we want to group all the key with same count together. Let\\'s call each element as `node`, it might has some properties, like value or whatever. For example, in the LFU Cache problem, it is a `<K, V>` store database, so it comes with a value. In this case, we need to have a custome class `Node` to put the <K, V>\\n```java\\nClass Node {\\n\\tString key;\\n\\tString val;\\n}\\n```\\nBut in this case, we only need to keep track of its frequency. But the frequency can be the property of `Bucket` below,  we do not need to store it specifically. So key itself is enough. \\n\\n**Group Nodes**\\nSo we need to a data structure to store them. Could be `List`, `Set` depend on the problem. For this problem, each element is only the key itself, nothing else, and we do not need to keep them in order. So we can use `Set<String>` to store them. \\n\\n**2. Bucket + count**\\nWe already have a group/container with type of `Set<String>`  to store elements with same frequency, but we need a frequency property attached to this group. So we need to create a custom class, let\\'s call it `Bucket`  which will have `count` as frequency value and `Set<String>`\\n\\n**Connect Bucket as LinkedList**\\nSince we are updating the key\\'s frequency, so we have to move the element to its neighbors bucket, and we are also keep track of the bucket with least `count` and greatest `count`. We need to connect each bucket together, as linked list.\\n\\nStick: **Dummy Node**\\nDummy node will be very help as you move element between difference bucket, you can avoid doing the dirty work to deal with edge cases when the bucket you gonna operated is head, or tail or middle ones. Specifically, `NullPointerException`\\n\\n**3. Map**\\nWe are doing `inc(String key)` and `dec(String key)` operation, so we need a way to find the node based on the key, we also need a way to find the bucket based on the key. To find the bucket, we need a map of key and bucket, i.e. `Map<String, Bucket>`. To find the node, since we are storing elements with `Set<String>`, as long as we can find the bucket, we can find the node. Our path is: `key > Bucket -> node`\\nFYI, another way which I frequently saw in other posts, is that they treat frequency `count` as property of a node, then   based on the key, they get the `count`. Then they have another map, `Map<Integer, Bucket>`, based on the `count`, they can find the corresponding bucket. In short, their path is `key -> Node -> get Count -> Bucket`. That is also a good way. Like this posts: https://leetcode.com/problems/all-oone-data-structure/discuss/91416/Java-AC-all-strict-O(1)-not-average-O(1)-easy-to-read\\n\\n**So the whole structure will be like below:**\\n\\n![image](https://assets.leetcode.com/users/images/e33d7263-97f8-4d4c-9dbf-81fbc7c95296_1642747458.0032277.png)\\n\\n---\\n**Summary**\\nSo for solving this problem:\\n**Remember the structure hierchy**: We have a **`Node`** to encapsulate the info, we have a **`Bucket`** to group nodes with common properties, we are using **`LinkedList`** strcuture., i.e. `key -> Node > Bucket -> LinkedList`. \\n**Remember 2 things for the Map**: 1. Find the node based on the key 2. find the bucket based on the key(there maybe some invariants, like store count in node, find bucket based on frequency, which can help reduce the map size, like LRU problem, https://leetcode.com/problems/lfu-cache/discuss/1711115/Java-Solution)\\n\\n---\\n**Code**\\n```java\\nclass Bucket {\\n    int count;\\n    Set<String> keySet;\\n    Bucket pre;\\n    Bucket next;\\n    public Bucket(int count){\\n        this.count = count;\\n        keySet = new HashSet<>();\\n    }\\n}\\n\\nclass AllOne {\\n    Bucket head;\\n    Bucket tail;\\n    Map<String, Bucket> keyBucketMap;\\n    \\n    public AllOne() {\\n        keyBucketMap = new HashMap<>();\\n        \\n        // create 2 dummy nodes head and tail, and connect\\n        head = new Bucket(-1);\\n        tail = new Bucket(-1);\\n        head.next = tail;\\n        tail.pre = head;\\n    }\\n    \\n    public void inc(String key) {\\n        if(!keyBucketMap.containsKey(key)){\\n            if(head.next.count == 1) {\\n                head.next.keySet.add(key);\\n                keyBucketMap.put(key, head.next);\\n            } else{\\n                Bucket newBucket = new Bucket(1);\\n                newBucket.keySet.add(key);\\n                insertNewBucketBetween(head, newBucket, head.next);\\n                keyBucketMap.put(key, newBucket);\\n            }\\n        }else{\\n            Bucket curBucket = keyBucketMap.get(key); \\n            int count = curBucket.count + 1;\\n            // remove from current bucket\\n            removeKeyFromBucket(key);\\n            // move to the next bucket or create a new bucket\\n            if(curBucket.next.count == count){\\n                curBucket.next.keySet.add(key);\\n                keyBucketMap.put(key, curBucket.next);\\n            } else {\\n                // insert bucket after curBucket\\n                Bucket newBucket = new Bucket(count);\\n                newBucket.keySet.add(key);\\n                if(curBucket.keySet.size() == 0){\\n                    insertNewBucketBetween(curBucket.pre, newBucket, curBucket.next);\\n                    curBucket.pre = null;\\n                    curBucket.next = null;\\n                }else{\\n                    insertNewBucketBetween(curBucket, newBucket, curBucket.next);\\n                }\\n                keyBucketMap.put(key, newBucket);\\n            }\\n        }\\n    }\\n    \\n    public void dec(String key) {\\n         if(!keyBucketMap.containsKey(key)) {\\n            return;\\n        }else {\\n            Bucket curBucket = keyBucketMap.get(key); \\n            int count = curBucket.count - 1;\\n            removeKeyFromBucket(key);\\n            if(count == 0) return;\\n            else if (curBucket.pre.count == count) {\\n                curBucket.pre.keySet.add(key);\\n                keyBucketMap.put(key, curBucket.pre);\\n            } else {\\n                // means we have to create a new bucket for it\\n                Bucket newBucket = new Bucket(count);\\n                newBucket.keySet.add(key); \\n                if(curBucket.keySet.size() == 0){\\n                    insertNewBucketBetween(curBucket.pre, newBucket, curBucket.next);\\n                    curBucket.pre = null;\\n                    curBucket.next = null;\\n                }else{\\n                    insertNewBucketBetween(curBucket.pre, newBucket, curBucket);\\n                }\\n                keyBucketMap.put(key, newBucket);\\n            }\\n        }\\n    }\\n    \\n    public String getMaxKey() {\\n        Bucket maxBucket = tail.pre;\\n        Bucket cur = head;\\n        return maxBucket.count == -1 ? \"\" : maxBucket.keySet.iterator().next();\\n    }\\n    \\n    public String getMinKey() {\\n        Bucket minBucket = head.next;\\n        return minBucket.count == -1 ? \"\" : minBucket.keySet.iterator().next();\\n    }\\n    \\n    public void insertNewBucketBetween(Bucket pre, Bucket newBucket, Bucket next){\\n        // go all the way right\\n        pre.next = newBucket;\\n        newBucket.next = next;\\n        \\n        // go all the way left back\\n        next.pre = newBucket;\\n        newBucket.pre = pre;    \\n    }\\n    \\n    // remove bucket but keep connection of bucket\\n    public void removeBucket(Bucket bucket){\\n        Bucket pre = bucket.pre;\\n        pre.next = bucket.next;\\n        bucket.next.pre = pre;\\n    }\\n    \\n    public void removeKeyFromBucket(String key){\\n        // remove key from the current bucket\\n        Bucket curBucket = keyBucketMap.get(key);\\n        curBucket.keySet.remove(key);\\n        \\n        if(curBucket.keySet.size() == 0){\\n            removeBucket(curBucket);\\n            keyBucketMap.remove(key);\\n        }\\n    }\\n}\\n```\\n\\n---\\n**VS LFU Cache Problem**\\nCommon:\\n- Both records the frequency of the element\\n\\nDifference:\\n- LFU has a capcacity limit\\n- LFU, along with the key, it comes with a value, so we need to have a custome class `Node` to store it\\n- LFU, we have to keep track of element with min freq; This problem, we need to keep track of both min and max element   \\n- We do not have `dec` operation in LFU, the frequency of element is always increasing. So we do not need to link all buckets together.",
                "solutionTags": [],
                "code": "```java\\nClass Node {\\n\\tString key;\\n\\tString val;\\n}\\n```\n```java\\nclass Bucket {\\n    int count;\\n    Set<String> keySet;\\n    Bucket pre;\\n    Bucket next;\\n    public Bucket(int count){\\n        this.count = count;\\n        keySet = new HashSet<>();\\n    }\\n}\\n\\nclass AllOne {\\n    Bucket head;\\n    Bucket tail;\\n    Map<String, Bucket> keyBucketMap;\\n    \\n    public AllOne() {\\n        keyBucketMap = new HashMap<>();\\n        \\n        // create 2 dummy nodes head and tail, and connect\\n        head = new Bucket(-1);\\n        tail = new Bucket(-1);\\n        head.next = tail;\\n        tail.pre = head;\\n    }\\n    \\n    public void inc(String key) {\\n        if(!keyBucketMap.containsKey(key)){\\n            if(head.next.count == 1) {\\n                head.next.keySet.add(key);\\n                keyBucketMap.put(key, head.next);\\n            } else{\\n                Bucket newBucket = new Bucket(1);\\n                newBucket.keySet.add(key);\\n                insertNewBucketBetween(head, newBucket, head.next);\\n                keyBucketMap.put(key, newBucket);\\n            }\\n        }else{\\n            Bucket curBucket = keyBucketMap.get(key); \\n            int count = curBucket.count + 1;\\n            // remove from current bucket\\n            removeKeyFromBucket(key);\\n            // move to the next bucket or create a new bucket\\n            if(curBucket.next.count == count){\\n                curBucket.next.keySet.add(key);\\n                keyBucketMap.put(key, curBucket.next);\\n            } else {\\n                // insert bucket after curBucket\\n                Bucket newBucket = new Bucket(count);\\n                newBucket.keySet.add(key);\\n                if(curBucket.keySet.size() == 0){\\n                    insertNewBucketBetween(curBucket.pre, newBucket, curBucket.next);\\n                    curBucket.pre = null;\\n                    curBucket.next = null;\\n                }else{\\n                    insertNewBucketBetween(curBucket, newBucket, curBucket.next);\\n                }\\n                keyBucketMap.put(key, newBucket);\\n            }\\n        }\\n    }\\n    \\n    public void dec(String key) {\\n         if(!keyBucketMap.containsKey(key)) {\\n            return;\\n        }else {\\n            Bucket curBucket = keyBucketMap.get(key); \\n            int count = curBucket.count - 1;\\n            removeKeyFromBucket(key);\\n            if(count == 0) return;\\n            else if (curBucket.pre.count == count) {\\n                curBucket.pre.keySet.add(key);\\n                keyBucketMap.put(key, curBucket.pre);\\n            } else {\\n                // means we have to create a new bucket for it\\n                Bucket newBucket = new Bucket(count);\\n                newBucket.keySet.add(key); \\n                if(curBucket.keySet.size() == 0){\\n                    insertNewBucketBetween(curBucket.pre, newBucket, curBucket.next);\\n                    curBucket.pre = null;\\n                    curBucket.next = null;\\n                }else{\\n                    insertNewBucketBetween(curBucket.pre, newBucket, curBucket);\\n                }\\n                keyBucketMap.put(key, newBucket);\\n            }\\n        }\\n    }\\n    \\n    public String getMaxKey() {\\n        Bucket maxBucket = tail.pre;\\n        Bucket cur = head;\\n        return maxBucket.count == -1 ? \"\" : maxBucket.keySet.iterator().next();\\n    }\\n    \\n    public String getMinKey() {\\n        Bucket minBucket = head.next;\\n        return minBucket.count == -1 ? \"\" : minBucket.keySet.iterator().next();\\n    }\\n    \\n    public void insertNewBucketBetween(Bucket pre, Bucket newBucket, Bucket next){\\n        // go all the way right\\n        pre.next = newBucket;\\n        newBucket.next = next;\\n        \\n        // go all the way left back\\n        next.pre = newBucket;\\n        newBucket.pre = pre;    \\n    }\\n    \\n    // remove bucket but keep connection of bucket\\n    public void removeBucket(Bucket bucket){\\n        Bucket pre = bucket.pre;\\n        pre.next = bucket.next;\\n        bucket.next.pre = pre;\\n    }\\n    \\n    public void removeKeyFromBucket(String key){\\n        // remove key from the current bucket\\n        Bucket curBucket = keyBucketMap.get(key);\\n        curBucket.keySet.remove(key);\\n        \\n        if(curBucket.keySet.size() == 0){\\n            removeBucket(curBucket);\\n            keyBucketMap.remove(key);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1493816,
                "title": "java-beats-99-65-strictly-o-1-operations-doubly-linked-list-and-map",
                "content": "Idea is to maintain a Doubly linked list (for O(1) ops), where head has largest count and tail has least. Hence tail will give the min_key and head will return max_key. For reference to nodes, a hashmap is maintained.\\n\\n\\n```\\nclass Node{\\n    String key;\\n    int freq;\\n    Node prev;\\n    Node next;\\n    public Node(String key, int freq){\\n        this.key = key;\\n        this.freq = freq;\\n    }\\n}\\nclass DLL{\\n    Node head;\\n    Node tail;\\n    public DLL(){\\n        head = new Node(\"NULL\", -1);\\n        tail = new Node(\"NULL\", -1);\\n        head.next = tail;\\n        tail.prev = head;\\n    }\\n    //always add to tail with freq = 1;\\n    public Node add(String key){\\n        Node nd = new Node(key, 1);\\n        nd.next = tail;\\n        nd.prev = tail.prev;\\n        \\n        tail.prev.next = nd;\\n        tail.prev = nd;\\n        return nd;\\n        \\n    }\\n    //remove node from dll, prolly when freq 0\\n    public void remove(Node nd){\\n        nd.prev.next = nd.next;\\n        nd.next.prev = nd.prev;\\n        \\n    }\\n        //towards head when required, called when incremented \\n    public void shift_left(Node node){\\n        if(node.prev.freq > node.freq || node.prev.key == \"NULL\")return; \\n        \\n        Node curr = node;\\n        while(curr.prev.freq < curr.freq && curr.prev.key != \"NULL\"){\\n        \\t//swap prev with current\\n        \\t//curr -- both prev and next needs to be updated\\n        \\tNode p = curr.prev;// both prev and next\\n        \\tNode pp = p.prev;//next of this\\n        \\tNode next = curr.next;//prev of this node \\n        \\t\\n        \\tpp.next = curr;\\n        \\tcurr.next = p;\\n        \\tcurr.prev = pp;\\n        \\tp.next = next;\\n        \\tp.prev = curr;\\n        \\tnext.prev = p;\\n        }\\n    }\\n    \\n    \\n    //called while dec, shift towards tail if req\\n    public void shift_right(Node node){\\n        if(node.next.freq < node.freq || node.next.key == \"NULL\")return;\\n        \\n        // p->curr->n->nn, swap curr and n\\n        //------  p->n->curr->nn\\n        Node curr = node;\\n        while(curr.next.freq > curr.freq && curr.next.key != \"NULL\"){\\n        \\tNode p = curr.prev;//next of this\\n        \\tNode n = curr.next;//next and prev both\\n        \\tNode nn = n.next;//prev only\\n        \\t//total 4 nodes affected including curr\\n        \\t\\n        \\tp.next = n;\\n        \\tn.next = curr;\\n        \\tn.prev=p;\\n        \\tcurr.next = nn;\\n        \\tcurr.prev = n;\\n        \\tnn.prev=curr;\\n        }\\n    }\\n    //return tail\\'s key\\n    public String minFreqKey(){\\n        return tail.prev.key==\"NULL\"?\"\":tail.prev.key;        \\n    }\\n    //return head\\'s key\\n    public String maxFreqKey(){\\n        return head.next.key==\"NULL\"?\"\":head.next.key;\\n        \\n    }\\n    \\n    \\n}\\n\\n\\nclass AllOne {\\n\\n    Map<String, Node> map;\\n    DLL dll;\\n    \\n    public AllOne() {\\n        map = new HashMap<>();\\n        dll = new DLL();\\n    }\\n    \\n    public void inc(String key) {\\n        //update freq if exist in map, and call shift left\\n        //else add to map, also in dll\\n        if(!map.containsKey(key)){\\n            Node new_nd = dll.add(key);\\n            map.put(key, new_nd);\\n        }else{\\n            Node node = map.get(key);\\n            node.freq+=1;\\n            dll.shift_left(node);\\n        }\\n    }\\n    \\n    public void dec(String key) {\\n        Node node = map.get(key);\\n        node.freq -= 1;\\n        if(node.freq==0){\\n            dll.remove(node);\\n            map.remove(key);\\n        }else{\\n            dll.shift_right(node);\\n        }\\n        \\n    }\\n    \\n    public String getMaxKey() {\\n        return dll.maxFreqKey();\\n    }\\n    \\n    public String getMinKey() {\\n        return dll.minFreqKey();\\n    }\\n}\\n\\n/**\\n * Your AllOne object will be instantiated and called as such:\\n * AllOne obj = new AllOne();\\n * obj.inc(key);\\n * obj.dec(key);\\n * String param_3 = obj.getMaxKey();\\n * String param_4 = obj.getMinKey();\\n */",
                "solutionTags": [],
                "code": "Idea is to maintain a Doubly linked list (for O(1) ops), where head has largest count and tail has least. Hence tail will give the min_key and head will return max_key. For reference to nodes, a hashmap is maintained.\\n\\n\\n```\\nclass Node{\\n    String key;\\n    int freq;\\n    Node prev;\\n    Node next;\\n    public Node(String key, int freq){\\n        this.key = key;\\n        this.freq = freq;\\n    }\\n}\\nclass DLL{\\n    Node head;\\n    Node tail;\\n    public DLL(){\\n        head = new Node(\"NULL\", -1);\\n        tail = new Node(\"NULL\", -1);\\n        head.next = tail;\\n        tail.prev = head;\\n    }\\n    //always add to tail with freq = 1;\\n    public Node add(String key){\\n        Node nd = new Node(key, 1);\\n        nd.next = tail;\\n        nd.prev = tail.prev;\\n        \\n        tail.prev.next = nd;\\n        tail.prev = nd;\\n        return nd;\\n        \\n    }\\n    //remove node from dll, prolly when freq 0\\n    public void remove(Node nd){\\n        nd.prev.next = nd.next;\\n        nd.next.prev = nd.prev;\\n        \\n    }\\n        //towards head when required, called when incremented \\n    public void shift_left(Node node){\\n        if(node.prev.freq > node.freq || node.prev.key == \"NULL\")return; \\n        \\n        Node curr = node;\\n        while(curr.prev.freq < curr.freq && curr.prev.key != \"NULL\"){\\n        \\t//swap prev with current\\n        \\t//curr -- both prev and next needs to be updated\\n        \\tNode p = curr.prev;// both prev and next\\n        \\tNode pp = p.prev;//next of this\\n        \\tNode next = curr.next;//prev of this node \\n        \\t\\n        \\tpp.next = curr;\\n        \\tcurr.next = p;\\n        \\tcurr.prev = pp;\\n        \\tp.next = next;\\n        \\tp.prev = curr;\\n        \\tnext.prev = p;\\n        }\\n    }\\n    \\n    \\n    //called while dec, shift towards tail if req\\n    public void shift_right(Node node){\\n        if(node.next.freq < node.freq || node.next.key == \"NULL\")return;\\n        \\n        // p->curr->n->nn, swap curr and n\\n        //------  p->n->curr->nn\\n        Node curr = node;\\n        while(curr.next.freq > curr.freq && curr.next.key != \"NULL\"){\\n        \\tNode p = curr.prev;//next of this\\n        \\tNode n = curr.next;//next and prev both\\n        \\tNode nn = n.next;//prev only\\n        \\t//total 4 nodes affected including curr\\n        \\t\\n        \\tp.next = n;\\n        \\tn.next = curr;\\n        \\tn.prev=p;\\n        \\tcurr.next = nn;\\n        \\tcurr.prev = n;\\n        \\tnn.prev=curr;\\n        }\\n    }\\n    //return tail\\'s key\\n    public String minFreqKey(){\\n        return tail.prev.key==\"NULL\"?\"\":tail.prev.key;        \\n    }\\n    //return head\\'s key\\n    public String maxFreqKey(){\\n        return head.next.key==\"NULL\"?\"\":head.next.key;\\n        \\n    }\\n    \\n    \\n}\\n\\n\\nclass AllOne {\\n\\n    Map<String, Node> map;\\n    DLL dll;\\n    \\n    public AllOne() {\\n        map = new HashMap<>();\\n        dll = new DLL();\\n    }\\n    \\n    public void inc(String key) {\\n        //update freq if exist in map, and call shift left\\n        //else add to map, also in dll\\n        if(!map.containsKey(key)){\\n            Node new_nd = dll.add(key);\\n            map.put(key, new_nd);\\n        }else{\\n            Node node = map.get(key);\\n            node.freq+=1;\\n            dll.shift_left(node);\\n        }\\n    }\\n    \\n    public void dec(String key) {\\n        Node node = map.get(key);\\n        node.freq -= 1;\\n        if(node.freq==0){\\n            dll.remove(node);\\n            map.remove(key);\\n        }else{\\n            dll.shift_right(node);\\n        }\\n        \\n    }\\n    \\n    public String getMaxKey() {\\n        return dll.maxFreqKey();\\n    }\\n    \\n    public String getMinKey() {\\n        return dll.minFreqKey();\\n    }\\n}\\n\\n/**\\n * Your AllOne object will be instantiated and called as such:\\n * AllOne obj = new AllOne();\\n * obj.inc(key);\\n * obj.dec(key);\\n * String param_3 = obj.getMaxKey();\\n * String param_4 = obj.getMinKey();\\n */",
                "codeTag": "Java"
            },
            {
                "id": 1290693,
                "title": "c-432-all-o-one-data-structure",
                "content": "\\n```\\nclass Node {\\npublic: \\n    unordered_set<string> keys; \\n    int freq; \\n    Node *prev, *next; \\n    \\n    Node(unordered_set<string> keys, int freq, Node* prev, Node* next) {\\n        this->keys = keys; \\n        this->freq = freq; \\n        this->prev = prev; \\n        this->next = next; \\n    }\\n};\\n\\n\\nclass AllOne {\\n    unordered_map<string, Node*> mp; \\n    Node *head, *tail; \\npublic:\\n    /** Initialize your data structure here. */\\n    AllOne() {\\n        head = new Node({}, 0, nullptr, nullptr); \\n        tail = new Node({}, 0, nullptr, nullptr); \\n        head->next = tail; \\n        tail->prev = head; \\n    }\\n    \\n    /** Inserts a new key <Key> with value 1. Or increments an existing key by 1. */\\n    void inc(string key) {\\n        Node* node = head; \\n        if (mp.find(key) != mp.end()) {\\n            node = mp[key]; \\n            node->keys.erase(key); \\n        }\\n        if (node->freq + 1 == node->next->freq) {\\n            node->next->keys.insert(key); \\n            mp[key] = node->next; \\n        } else {\\n            Node* newn = new Node({key}, node->freq+1, node, node->next); \\n            mp[key] = node->next = node->next->prev = newn; \\n        }\\n        \\n        if (node != head && node->keys.empty()) {\\n            node->prev->next = node->next; \\n            node->next->prev = node->prev; \\n            delete node; \\n        }\\n    }\\n    \\n    /** Decrements an existing key by 1. If Key\\'s value is 1, remove it from the data structure. */\\n    void dec(string key) {\\n        Node* node = mp[key]; \\n        node->keys.erase(key); \\n        if (node->freq == 1) {\\n            mp.erase(key);\\n        } else if (node->prev->freq + 1 == node->freq) {\\n            node->prev->keys.insert(key); \\n            mp[key] = node->prev; \\n        } else {\\n            Node* newn = new Node({key}, node->freq-1, node->prev, node); \\n            mp[key] = node->prev = node->prev->next = newn;\\n        }\\n        if (node->keys.empty()) {\\n            node->prev->next = node->next; \\n            node->next->prev = node->prev; \\n            delete node; \\n        }\\n    }\\n    \\n    /** Returns one of the keys with maximal value. */\\n    string getMaxKey() {\\n        return head != tail->prev ? *begin(tail->prev->keys) : \"\"; \\n    }\\n    \\n    /** Returns one of the keys with Minimal value. */\\n    string getMinKey() {\\n        return head->next != tail ? *begin(head->next->keys) : \"\"; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Node {\\npublic: \\n    unordered_set<string> keys; \\n    int freq; \\n    Node *prev, *next; \\n    \\n    Node(unordered_set<string> keys, int freq, Node* prev, Node* next) {\\n        this->keys = keys; \\n        this->freq = freq; \\n        this->prev = prev; \\n        this->next = next; \\n    }\\n};\\n\\n\\nclass AllOne {\\n    unordered_map<string, Node*> mp; \\n    Node *head, *tail; \\npublic:\\n    /** Initialize your data structure here. */\\n    AllOne() {\\n        head = new Node({}, 0, nullptr, nullptr); \\n        tail = new Node({}, 0, nullptr, nullptr); \\n        head->next = tail; \\n        tail->prev = head; \\n    }\\n    \\n    /** Inserts a new key <Key> with value 1. Or increments an existing key by 1. */\\n    void inc(string key) {\\n        Node* node = head; \\n        if (mp.find(key) != mp.end()) {\\n            node = mp[key]; \\n            node->keys.erase(key); \\n        }\\n        if (node->freq + 1 == node->next->freq) {\\n            node->next->keys.insert(key); \\n            mp[key] = node->next; \\n        } else {\\n            Node* newn = new Node({key}, node->freq+1, node, node->next); \\n            mp[key] = node->next = node->next->prev = newn; \\n        }\\n        \\n        if (node != head && node->keys.empty()) {\\n            node->prev->next = node->next; \\n            node->next->prev = node->prev; \\n            delete node; \\n        }\\n    }\\n    \\n    /** Decrements an existing key by 1. If Key\\'s value is 1, remove it from the data structure. */\\n    void dec(string key) {\\n        Node* node = mp[key]; \\n        node->keys.erase(key); \\n        if (node->freq == 1) {\\n            mp.erase(key);\\n        } else if (node->prev->freq + 1 == node->freq) {\\n            node->prev->keys.insert(key); \\n            mp[key] = node->prev; \\n        } else {\\n            Node* newn = new Node({key}, node->freq-1, node->prev, node); \\n            mp[key] = node->prev = node->prev->next = newn;\\n        }\\n        if (node->keys.empty()) {\\n            node->prev->next = node->next; \\n            node->next->prev = node->prev; \\n            delete node; \\n        }\\n    }\\n    \\n    /** Returns one of the keys with maximal value. */\\n    string getMaxKey() {\\n        return head != tail->prev ? *begin(tail->prev->keys) : \"\"; \\n    }\\n    \\n    /** Returns one of the keys with Minimal value. */\\n    string getMinKey() {\\n        return head->next != tail ? *begin(head->next->keys) : \"\"; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 841353,
                "title": "this-is-the-best-solution-you-get",
                "content": "```\\nclass AllOne {\\n\\n    DoubleLinkedList list;\\n    Map<String, Node> valueMap;\\n    \\n    public AllOne() {\\n        list = new DoubleLinkedList();\\n        valueMap = new HashMap<>();\\n    }\\n    \\n    \\n    /** Inserts a new key <Key> with value 1. Or increments an existing key by 1. */\\n    public void inc(String key) {\\n       \\n        Node node = valueMap.get(key);\\n        Node next = list.addKey(node, key);\\n        valueMap.put(key, next);\\n        \\n    }\\n    \\n    /** Decrements an existing key by 1. If Key\\'s value is 1, remove it from the data structure. */\\n    public void dec(String key) {\\n       \\n        Node node = valueMap.get(key);\\n        \\n        if(node == null)\\n            return;\\n        \\n        list.removeKey(node, key);\\n        valueMap.put(key, node.prev);\\n        if(node.val == 1)\\n            valueMap.remove(key);\\n    }\\n    \\n    /** Returns one of the keys with maximal value. */\\n    public String getMaxKey() {\\n        return list.getMax();\\n    }\\n    \\n    /** Returns one of the keys with Minimal value. */\\n    public String getMinKey() {\\n        return list.getMin();\\n    }\\n}\\n\\n\\nclass DoubleLinkedList{\\n    \\n    Node head, tail;\\n    public DoubleLinkedList(){\\n        head = new Node(0);\\n        tail = new Node(Integer.MAX_VALUE);\\n        head.next = tail;\\n        tail.prev = head;\\n        tail.set.add(\"\");\\n        head.set.add(\"\");\\n    }\\n    \\n\\n    public Node addKey(Node present, String key){\\n        \\n        if(present == null){\\n            return addFirst(key);\\n        }\\n        \\n        if( isTail(present.next) || present.next.val != (present.val + 1) ){\\n             Node next = new Node(present.val + 1);\\n             addNodeAfter(present, next, key);\\n             \\n        }else{\\n            present.next.set.add(key);   \\n        }\\n        \\n        present.set.remove(key);\\n        if(present.set.size() == 0)\\n            remove(present);\\n        \\n        return present.next;\\n    }\\n    \\n    public void addNodeAfter(Node present, Node next, String key){\\n        \\n        Node temp = present.next;\\n        present.next = next;\\n        next.next = temp;\\n        temp.prev = next;\\n        next.prev = present;\\n        next.set.add(key);\\n    }\\n    \\n    public void removeKey(Node node, String key){\\n           \\n        if(node.val != 1 && (isHead(node.prev) || node.prev.val != (node.val -1) )){\\n            Node n = new Node(node.val-1);\\n            addNodeBefore(node, n, key);\\n        }else if(node.val != 1){\\n            node.prev.set.add(key);\\n        }\\n        \\n        node.set.remove(key);\\n        if(node.set.size() == 0)\\n            remove(node);\\n    }\\n    \\n    public void addNodeBefore(Node present, Node prev, String key){\\n        Node temp = present.prev;\\n        temp.next = prev;\\n        prev.prev = temp;\\n        present.prev = prev;\\n        prev.next = present;\\n        prev.set.add(key);\\n    }\\n    \\n    public void remove(Node node){\\n        node.prev.next = node.next;\\n        node.next.prev = node.prev;\\n    }\\n    \\n    public boolean isTail(Node node){\\n        return node == tail;\\n    }\\n    \\n    public boolean isHead(Node node){\\n        return node == head;\\n    }\\n    \\n    public String getMax(){\\n        Set<String> set = tail.prev.set;\\n        return set.iterator().next();\\n    }\\n    \\n    public String getMin(){\\n        Set<String> set = head.next.set;\\n        return set.iterator().next();\\n    }\\n    \\n    public Node addFirst(String key){\\n        \\n        if(head.next.val == 1)\\n            head.next.set.add(key);\\n        else{\\n            Node node = new Node(1);\\n            this.addNodeAfter(head, node, key);\\n        }\\n        \\n        return head.next;\\n    }\\n\\n    \\n}\\n\\n\\nclass Node{\\n    int val;\\n    Set<String> set;\\n    Node next, prev;\\n    \\n    public Node(int val){\\n        this.val = val;\\n        set = new HashSet();\\n    }\\n    \\n    public String toString(){\\n        return val+\"\";\\n    }\\n}\\n\\n\\n/**\\n * Your AllOne object will be instantiated and called as such:\\n * AllOne obj = new AllOne();\\n * obj.inc(key);\\n * obj.dec(key);\\n * String param_3 = obj.getMaxKey();\\n * String param_4 = obj.getMinKey();\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass AllOne {\\n\\n    DoubleLinkedList list;\\n    Map<String, Node> valueMap;\\n    \\n    public AllOne() {\\n        list = new DoubleLinkedList();\\n        valueMap = new HashMap<>();\\n    }\\n    \\n    \\n    /** Inserts a new key <Key> with value 1. Or increments an existing key by 1. */\\n    public void inc(String key) {\\n       \\n        Node node = valueMap.get(key);\\n        Node next = list.addKey(node, key);\\n        valueMap.put(key, next);\\n        \\n    }\\n    \\n    /** Decrements an existing key by 1. If Key\\'s value is 1, remove it from the data structure. */\\n    public void dec(String key) {\\n       \\n        Node node = valueMap.get(key);\\n        \\n        if(node == null)\\n            return;\\n        \\n        list.removeKey(node, key);\\n        valueMap.put(key, node.prev);\\n        if(node.val == 1)\\n            valueMap.remove(key);\\n    }\\n    \\n    /** Returns one of the keys with maximal value. */\\n    public String getMaxKey() {\\n        return list.getMax();\\n    }\\n    \\n    /** Returns one of the keys with Minimal value. */\\n    public String getMinKey() {\\n        return list.getMin();\\n    }\\n}\\n\\n\\nclass DoubleLinkedList{\\n    \\n    Node head, tail;\\n    public DoubleLinkedList(){\\n        head = new Node(0);\\n        tail = new Node(Integer.MAX_VALUE);\\n        head.next = tail;\\n        tail.prev = head;\\n        tail.set.add(\"\");\\n        head.set.add(\"\");\\n    }\\n    \\n\\n    public Node addKey(Node present, String key){\\n        \\n        if(present == null){\\n            return addFirst(key);\\n        }\\n        \\n        if( isTail(present.next) || present.next.val != (present.val + 1) ){\\n             Node next = new Node(present.val + 1);\\n             addNodeAfter(present, next, key);\\n             \\n        }else{\\n            present.next.set.add(key);   \\n        }\\n        \\n        present.set.remove(key);\\n        if(present.set.size() == 0)\\n            remove(present);\\n        \\n        return present.next;\\n    }\\n    \\n    public void addNodeAfter(Node present, Node next, String key){\\n        \\n        Node temp = present.next;\\n        present.next = next;\\n        next.next = temp;\\n        temp.prev = next;\\n        next.prev = present;\\n        next.set.add(key);\\n    }\\n    \\n    public void removeKey(Node node, String key){\\n           \\n        if(node.val != 1 && (isHead(node.prev) || node.prev.val != (node.val -1) )){\\n            Node n = new Node(node.val-1);\\n            addNodeBefore(node, n, key);\\n        }else if(node.val != 1){\\n            node.prev.set.add(key);\\n        }\\n        \\n        node.set.remove(key);\\n        if(node.set.size() == 0)\\n            remove(node);\\n    }\\n    \\n    public void addNodeBefore(Node present, Node prev, String key){\\n        Node temp = present.prev;\\n        temp.next = prev;\\n        prev.prev = temp;\\n        present.prev = prev;\\n        prev.next = present;\\n        prev.set.add(key);\\n    }\\n    \\n    public void remove(Node node){\\n        node.prev.next = node.next;\\n        node.next.prev = node.prev;\\n    }\\n    \\n    public boolean isTail(Node node){\\n        return node == tail;\\n    }\\n    \\n    public boolean isHead(Node node){\\n        return node == head;\\n    }\\n    \\n    public String getMax(){\\n        Set<String> set = tail.prev.set;\\n        return set.iterator().next();\\n    }\\n    \\n    public String getMin(){\\n        Set<String> set = head.next.set;\\n        return set.iterator().next();\\n    }\\n    \\n    public Node addFirst(String key){\\n        \\n        if(head.next.val == 1)\\n            head.next.set.add(key);\\n        else{\\n            Node node = new Node(1);\\n            this.addNodeAfter(head, node, key);\\n        }\\n        \\n        return head.next;\\n    }\\n\\n    \\n}\\n\\n\\nclass Node{\\n    int val;\\n    Set<String> set;\\n    Node next, prev;\\n    \\n    public Node(int val){\\n        this.val = val;\\n        set = new HashSet();\\n    }\\n    \\n    public String toString(){\\n        return val+\"\";\\n    }\\n}\\n\\n\\n/**\\n * Your AllOne object will be instantiated and called as such:\\n * AllOne obj = new AllOne();\\n * obj.inc(key);\\n * obj.dec(key);\\n * String param_3 = obj.getMaxKey();\\n * String param_4 = obj.getMinKey();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 663206,
                "title": "java-doubly-linkedlist-hashmap-clean-solution",
                "content": "```Java\\nclass AllOne {\\n    \\n    class Node {\\n        Node prev, next;\\n        String key;\\n        int val;\\n        \\n        public Node(String key, int val){\\n            this.key = key;\\n            this.val = val;\\n        }\\n    }\\n    \\n    Map<String, Node> map = new HashMap<>();\\n    Node head;\\n    Node tail;\\n\\n    public AllOne() {\\n        this.head = new Node(\"head\",-1);\\n        this.tail = new Node(\"tail\",-1);\\n        \\n        head.next = tail;\\n        tail.prev = head;\\n    }\\n    \\n    public void inc(String key) {\\n        if(map.get(key) == null){\\n            Node node = new Node(key, 1);\\n            insertNode(node);\\n        }else{\\n            Node node = map.get(key);\\n            \\n            node.val += 1;\\n            moveNodeRight(node);\\n        }\\n    }\\n    \\n    public void dec(String key) {\\n        if(map.get(key) != null){\\n            Node node = map.get(key);\\n            \\n            if(node.val == 1){\\n                removeNode(node);\\n            }else{\\n                node.val -= 1;\\n                moveNodeLeft(node);    \\n            }\\n        }\\n    }\\n    \\n    public String getMaxKey() {\\n        return tail.prev == head ? \"\" : tail.prev.key;\\n    }\\n    \\n    public String getMinKey() {\\n        return head.next == tail ? \"\" : head.next.key;\\n    }\\n    \\n    \\n    private void insertNode(Node node){\\n        Node firstNode = head.next;\\n        \\n        head.next = node;\\n        node.prev = head;\\n        node.next = firstNode;\\n        firstNode.prev = node;\\n        \\n        map.put(node.key, node);\\n    }\\n    \\n    private void removeNode(Node node){\\n        node.prev.next = node.next;\\n        node.next.prev = node.prev;\\n        \\n        map.remove(node.key);\\n    }\\n    \\n    private void moveNodeRight(Node node){\\n        while(node.next != tail && node.next.val < node.val){\\n            Node prev = node.prev;\\n            Node next = node.next;\\n            Node secondNext = node.next.next;\\n            \\n            prev.next = next;\\n            \\n            next.prev = prev;\\n            next.next = node;\\n            \\n            node.next = secondNext;\\n            node.prev = next;\\n            \\n            secondNext.prev = node;\\n        }\\n    }\\n    \\n    private void moveNodeLeft(Node node){\\n        while(node.prev != head && node.prev.val > node.val){\\n            Node secondPrev = node.prev.prev;\\n            Node prev = node.prev;\\n            Node next = node.next;\\n            \\n            secondPrev.next = node;\\n            \\n            prev.prev = node;\\n            prev.next = next;\\n            \\n            node.next = prev;\\n            node.prev = secondPrev;\\n            \\n            next.prev = prev;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```Java\\nclass AllOne {\\n    \\n    class Node {\\n        Node prev, next;\\n        String key;\\n        int val;\\n        \\n        public Node(String key, int val){\\n            this.key = key;\\n            this.val = val;\\n        }\\n    }\\n    \\n    Map<String, Node> map = new HashMap<>();\\n    Node head;\\n    Node tail;\\n\\n    public AllOne() {\\n        this.head = new Node(\"head\",-1);\\n        this.tail = new Node(\"tail\",-1);\\n        \\n        head.next = tail;\\n        tail.prev = head;\\n    }\\n    \\n    public void inc(String key) {\\n        if(map.get(key) == null){\\n            Node node = new Node(key, 1);\\n            insertNode(node);\\n        }else{\\n            Node node = map.get(key);\\n            \\n            node.val += 1;\\n            moveNodeRight(node);\\n        }\\n    }\\n    \\n    public void dec(String key) {\\n        if(map.get(key) != null){\\n            Node node = map.get(key);\\n            \\n            if(node.val == 1){\\n                removeNode(node);\\n            }else{\\n                node.val -= 1;\\n                moveNodeLeft(node);    \\n            }\\n        }\\n    }\\n    \\n    public String getMaxKey() {\\n        return tail.prev == head ? \"\" : tail.prev.key;\\n    }\\n    \\n    public String getMinKey() {\\n        return head.next == tail ? \"\" : head.next.key;\\n    }\\n    \\n    \\n    private void insertNode(Node node){\\n        Node firstNode = head.next;\\n        \\n        head.next = node;\\n        node.prev = head;\\n        node.next = firstNode;\\n        firstNode.prev = node;\\n        \\n        map.put(node.key, node);\\n    }\\n    \\n    private void removeNode(Node node){\\n        node.prev.next = node.next;\\n        node.next.prev = node.prev;\\n        \\n        map.remove(node.key);\\n    }\\n    \\n    private void moveNodeRight(Node node){\\n        while(node.next != tail && node.next.val < node.val){\\n            Node prev = node.prev;\\n            Node next = node.next;\\n            Node secondNext = node.next.next;\\n            \\n            prev.next = next;\\n            \\n            next.prev = prev;\\n            next.next = node;\\n            \\n            node.next = secondNext;\\n            node.prev = next;\\n            \\n            secondNext.prev = node;\\n        }\\n    }\\n    \\n    private void moveNodeLeft(Node node){\\n        while(node.prev != head && node.prev.val > node.val){\\n            Node secondPrev = node.prev.prev;\\n            Node prev = node.prev;\\n            Node next = node.next;\\n            \\n            secondPrev.next = node;\\n            \\n            prev.prev = node;\\n            prev.next = next;\\n            \\n            node.next = prev;\\n            node.prev = secondPrev;\\n            \\n            next.prev = prev;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 439644,
                "title": "java-ac-clean-concise-easy-o-1",
                "content": "```\\nclass AllOne {    \\n    Map<String, Node> keyNodeMap;\\n    DoubleLinkedList ddl;\\n\\n    /** Initialize your data structure here. */\\n    public AllOne() {\\n        keyNodeMap = new HashMap<>();\\n        ddl = new DoubleLinkedList();\\n    }\\n    \\n    /** Inserts a new key <Key> with value 1. Or increments an existing key by 1. */\\n    public void inc(String key) {\\n        int count = 1;\\n        Node left = ddl.head;\\n        \\n        // remove the key from original node if exists\\n        if (keyNodeMap.containsKey(key)) {\\n            Node node = keyNodeMap.get(key);\\n            node.set.remove(key);\\n            count = node.count+1;\\n            if (node.set.isEmpty()) {\\n                left = node.prev;\\n                ddl.unlink(node);\\n            } else {\\n                left = node;\\n            }\\n        } \\n        \\n        // add the key to the new node\\n        Node right = left.next;\\n        if (right.count != count) {\\n            right = new Node(count);\\n            ddl.appendNode(left, right);\\n        }\\n        keyNodeMap.put(key, right);\\n        right.set.add(key);\\n    }\\n    \\n    /** Decrements an existing key by 1. If Key\\'s value is 1, remove it from the data structure. */\\n    public void dec(String key) {\\n        if (!keyNodeMap.containsKey(key)) {\\n            return;\\n        }\\n        \\n        // remove the key from original node\\n        Node node = keyNodeMap.get(key);\\n        node.set.remove(key);\\n        if (node.set.isEmpty()) {\\n            ddl.unlink(node);\\n        }\\n        keyNodeMap.remove(key);\\n        \\n        // add the key to the new node if count > 1\\n        if (node.count != 1) {\\n            Node left = node.prev;\\n            if (node.prev.count != node.count - 1) {\\n                left = new Node(node.count - 1);\\n                ddl.appendNode(node.prev, left);\\n            }\\n            keyNodeMap.put(key, left);\\n            left.set.add(key);\\n        }\\n    }\\n    \\n    /** Returns one of the keys with maximal value. */\\n    public String getMaxKey() {\\n        Set<String> set = ddl.tail.prev.set;\\n        return set.isEmpty() ? \"\" : set.iterator().next();\\n    }\\n    \\n    /** Returns one of the keys with Minimal value. */\\n    public String getMinKey() {\\n        Set<String> set = ddl.head.next.set;\\n        return set.isEmpty() ? \"\" : set.iterator().next();\\n    }\\n}\\n\\nclass DoubleLinkedList {\\n    Node head, tail;\\n    \\n    public DoubleLinkedList() {\\n        head = new Node(-1);\\n        tail = new Node(-1);\\n        head.next = tail;\\n        tail.prev = head;\\n    }\\n    \\n    public void unlink(Node node) {\\n        node.prev.next = node.next;\\n        node.next.prev = node.prev;\\n    }\\n    \\n    public void appendNode(Node left, Node right) {\\n        right.next = left.next;\\n        right.prev = left;\\n        left.next = right;\\n        right.next.prev = right;\\n    }\\n}\\n\\nclass Node {\\n    int count;\\n    Set<String> set;\\n    Node prev, next;\\n    \\n    public Node(int count) {\\n        this.count = count;\\n        this.set = new LinkedHashSet<>();\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass AllOne {    \\n    Map<String, Node> keyNodeMap;\\n    DoubleLinkedList ddl;\\n\\n    /** Initialize your data structure here. */\\n    public AllOne() {\\n        keyNodeMap = new HashMap<>();\\n        ddl = new DoubleLinkedList();\\n    }\\n    \\n    /** Inserts a new key <Key> with value 1. Or increments an existing key by 1. */\\n    public void inc(String key) {\\n        int count = 1;\\n        Node left = ddl.head;\\n        \\n        // remove the key from original node if exists\\n        if (keyNodeMap.containsKey(key)) {\\n            Node node = keyNodeMap.get(key);\\n            node.set.remove(key);\\n            count = node.count+1;\\n            if (node.set.isEmpty()) {\\n                left = node.prev;\\n                ddl.unlink(node);\\n            } else {\\n                left = node;\\n            }\\n        } \\n        \\n        // add the key to the new node\\n        Node right = left.next;\\n        if (right.count != count) {\\n            right = new Node(count);\\n            ddl.appendNode(left, right);\\n        }\\n        keyNodeMap.put(key, right);\\n        right.set.add(key);\\n    }\\n    \\n    /** Decrements an existing key by 1. If Key\\'s value is 1, remove it from the data structure. */\\n    public void dec(String key) {\\n        if (!keyNodeMap.containsKey(key)) {\\n            return;\\n        }\\n        \\n        // remove the key from original node\\n        Node node = keyNodeMap.get(key);\\n        node.set.remove(key);\\n        if (node.set.isEmpty()) {\\n            ddl.unlink(node);\\n        }\\n        keyNodeMap.remove(key);\\n        \\n        // add the key to the new node if count > 1\\n        if (node.count != 1) {\\n            Node left = node.prev;\\n            if (node.prev.count != node.count - 1) {\\n                left = new Node(node.count - 1);\\n                ddl.appendNode(node.prev, left);\\n            }\\n            keyNodeMap.put(key, left);\\n            left.set.add(key);\\n        }\\n    }\\n    \\n    /** Returns one of the keys with maximal value. */\\n    public String getMaxKey() {\\n        Set<String> set = ddl.tail.prev.set;\\n        return set.isEmpty() ? \"\" : set.iterator().next();\\n    }\\n    \\n    /** Returns one of the keys with Minimal value. */\\n    public String getMinKey() {\\n        Set<String> set = ddl.head.next.set;\\n        return set.isEmpty() ? \"\" : set.iterator().next();\\n    }\\n}\\n\\nclass DoubleLinkedList {\\n    Node head, tail;\\n    \\n    public DoubleLinkedList() {\\n        head = new Node(-1);\\n        tail = new Node(-1);\\n        head.next = tail;\\n        tail.prev = head;\\n    }\\n    \\n    public void unlink(Node node) {\\n        node.prev.next = node.next;\\n        node.next.prev = node.prev;\\n    }\\n    \\n    public void appendNode(Node left, Node right) {\\n        right.next = left.next;\\n        right.prev = left;\\n        left.next = right;\\n        right.next.prev = right;\\n    }\\n}\\n\\nclass Node {\\n    int count;\\n    Set<String> set;\\n    Node prev, next;\\n    \\n    public Node(int count) {\\n        this.count = count;\\n        this.set = new LinkedHashSet<>();\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 370805,
                "title": "c-map-and-vector",
                "content": "Store key-value pairs (sorted by values) in a vector instead of linked lists.\\nFor inc/dec we can swap the pair with the left or right most pair with the same value.\\n\\tvector<pair<string, int>> values; // key-value pairs\\n\\tunordered_map<int, pair<size_t, size_t>> interval; // value to its start,end index in values\\n\\tunordered_map<string, size_t> keys; // keys to its index in values\\n\\'\\'\\'\\n\\n\\tvoid inc(string key)\\n\\t{\\n\\t\\tif (!keys.count(key)) {\\n\\t\\t\\tkeys[key] = values.size();\\n\\t\\t\\tvalues.emplace_back(key, 1);\\n\\t\\t\\texpand(1, false, values.size() - 1);\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tsize_t pos = keys[key];\\n\\t\\tint val = values[pos].second;\\n\\t\\t//swap with left-most\\n\\t\\tsize_t pos_other = interval[val].first;\\n\\t\\tswap(keys[key], keys[values[pos_other].first]);\\n\\t\\tswap(values[pos], values[pos_other]);\\n\\t\\t//change value and interval\\n\\t\\tpos = pos_other;\\n\\t\\t++values[pos].second;\\n\\t\\tshrink(val, true);\\n\\t\\texpand(val + 1, false, pos);\\n\\t}\\n\\t\\n\\tvoid expand(int val, bool left, size_t pos)\\n\\t{\\n\\t\\tif (!interval.count(val)) {\\n\\t\\t\\tinterval[val] = make_pair(pos, pos);\\n\\t\\t} else {\\n\\t\\t\\tauto& i = interval[val];\\n\\t\\t\\tif (left) {\\n\\t\\t\\t\\t--i.first;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t++i.second;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tvoid shrink(int val, bool left)\\n\\t{\\n\\t\\tauto& i = interval[val];\\n\\t\\tif (i.first == i.second) {\\n\\t\\t\\tinterval.erase(val);\\n\\t\\t} else {\\n\\t\\t\\tif (left) {\\n\\t\\t\\t\\t++i.first;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t--i.second;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n \\'\\'\\'",
                "solutionTags": [],
                "code": "Store key-value pairs (sorted by values) in a vector instead of linked lists.\\nFor inc/dec we can swap the pair with the left or right most pair with the same value.\\n\\tvector<pair<string, int>> values; // key-value pairs\\n\\tunordered_map<int, pair<size_t, size_t>> interval; // value to its start,end index in values\\n\\tunordered_map<string, size_t> keys; // keys to its index in values\\n\\'\\'\\'\\n\\n\\tvoid inc(string key)\\n\\t{\\n\\t\\tif (!keys.count(key)) {\\n\\t\\t\\tkeys[key] = values.size();\\n\\t\\t\\tvalues.emplace_back(key, 1);\\n\\t\\t\\texpand(1, false, values.size() - 1);\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tsize_t pos = keys[key];\\n\\t\\tint val = values[pos].second;\\n\\t\\t//swap with left-most\\n\\t\\tsize_t pos_other = interval[val].first;\\n\\t\\tswap(keys[key], keys[values[pos_other].first]);\\n\\t\\tswap(values[pos], values[pos_other]);\\n\\t\\t//change value and interval\\n\\t\\tpos = pos_other;\\n\\t\\t++values[pos].second;\\n\\t\\tshrink(val, true);\\n\\t\\texpand(val + 1, false, pos);\\n\\t}\\n\\t\\n\\tvoid expand(int val, bool left, size_t pos)\\n\\t{\\n\\t\\tif (!interval.count(val)) {\\n\\t\\t\\tinterval[val] = make_pair(pos, pos);\\n\\t\\t} else {\\n\\t\\t\\tauto& i = interval[val];\\n\\t\\t\\tif (left) {\\n\\t\\t\\t\\t--i.first;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t++i.second;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tvoid shrink(int val, bool left)\\n\\t{\\n\\t\\tauto& i = interval[val];\\n\\t\\tif (i.first == i.second) {\\n\\t\\t\\tinterval.erase(val);\\n\\t\\t} else {\\n\\t\\t\\tif (left) {\\n\\t\\t\\t\\t++i.first;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t--i.second;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n \\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 91421,
                "title": "only-one-hashmap-java-solution-beats-99",
                "content": "The most difficult part of this kind of problem, is not the idea or the thought, but the 30-minute **bug-free** implementation. I actually did more than 1 hour and finally get passed. I recommend to draw a graph when you try to solve this kind of problems.\\n\\n```\\npublic class AllOne {\\n    Map<String, Node> map;\\n    Node head, tail;\\n    // head - min\\n    // tail - max\\n    /** Initialize your data structure here. */\\n    public AllOne() {\\n        map = new HashMap();\\n        head = tail = null;\\n    }\\n    \\n    /** Inserts a new key <Key> with value 1. Or increments an existing key by 1. */\\n    public void inc(String key) {\\n        if (map.containsKey(key)) {\\n            // get old node\\n            Node node = map.get(key);\\n            // get old val\\n            int val = node.val;\\n            // remove old key in the old node\\n            node.keys.remove(key);\\n            // add new node with new val\\n            if (node.next == null || node.next.val != val + 1) {\\n                Node newNode = new Node(val + 1);\\n                newNode.pre = node;\\n                newNode.next = node.next;\\n                node.next = newNode;\\n                if (newNode.next != null) newNode.next.pre = newNode;\\n            }\\n            // add new key to the next node\\n            node.next.keys.add(key);\\n            // update node\\n            map.put(key, node.next);\\n            \\n            // udate head\\n            if (node.keys.isEmpty()) {\\n                if (node == head) head = node.next;\\n                node.next.pre = node.pre;\\n                if (node.pre != null) node.pre.next = node.next;\\n            }\\n            // update tail\\n            if (tail == node) tail = node.next;\\n        } else {\\n            if (head == null || head.val > 1) {\\n                Node node = new Node(1);\\n                node.next = head;\\n                if (head != null) head.pre = node;\\n                head = node;\\n                if (tail == null) tail = node;\\n            }\\n            head.keys.add(key);\\n            map.put(key, head);\\n        }\\n    }\\n    \\n    /** Decrements an existing key by 1. If Key's value is 1, remove it from the data structure. */\\n    public void dec(String key) {\\n        if (!map.containsKey(key)) return;\\n        // get old node\\n        Node node = map.get(key);\\n        // get old val\\n        int val = node.val;\\n        // remove old val from old node\\n        node.keys.remove(key);\\n        // remove old key\\n        map.remove(key);\\n        // if it's head, update head and tail\\n        if (val == 1) {\\n            if (node.keys.isEmpty()) {\\n                if (head == node) head = node.next;\\n                if (head != null) head.pre = null;\\n                if (tail == node) tail = null;\\n            }\\n        } else {\\n            // add new node at pre position\\n            if (node.pre == null || node.pre.val != val - 1) {\\n                Node newNode = new Node(val - 1);\\n                newNode.next = node;\\n                newNode.pre = node.pre;\\n                node.pre = newNode;\\n                if (newNode.pre != null) newNode.pre.next = newNode;\\n            }\\n            // add new key to the newNode or pre node\\n            node.pre.keys.add(key);\\n            // update node\\n            map.put(key, node.pre);\\n            \\n            // update tail\\n            if (node.keys.isEmpty()) {\\n                if (tail == node) tail = node.pre;\\n                node.pre.next = node.next;\\n                if (node.next != null) node.next.pre = node.pre;\\n            }\\n            // update head\\n            if (head == node) head = node.pre;\\n        }\\n    }\\n    \\n    /** Returns one of the keys with maximal value. */\\n    public String getMaxKey() {\\n        return tail == null ? \"\" : tail.keys.iterator().next();\\n    }\\n    \\n    /** Returns one of the keys with Minimal value. */\\n    public String getMinKey() {\\n        return head == null ? \"\" : head.keys.iterator().next();\\n    }\\n    \\n    class Node {\\n        int val;\\n        LinkedHashSet<String> keys;\\n        Node next, pre;\\n        public Node(int val) {\\n            this.val = val;\\n            keys = new LinkedHashSet();\\n            next = pre = null;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class AllOne {\\n    Map<String, Node> map;\\n    Node head, tail;\\n    // head - min\\n    // tail - max\\n    /** Initialize your data structure here. */\\n    public AllOne() {\\n        map = new HashMap();\\n        head = tail = null;\\n    }\\n    \\n    /** Inserts a new key <Key> with value 1. Or increments an existing key by 1. */\\n    public void inc(String key) {\\n        if (map.containsKey(key)) {\\n            // get old node\\n            Node node = map.get(key);\\n            // get old val\\n            int val = node.val;\\n            // remove old key in the old node\\n            node.keys.remove(key);\\n            // add new node with new val\\n            if (node.next == null || node.next.val != val + 1) {\\n                Node newNode = new Node(val + 1);\\n                newNode.pre = node;\\n                newNode.next = node.next;\\n                node.next = newNode;\\n                if (newNode.next != null) newNode.next.pre = newNode;\\n            }\\n            // add new key to the next node\\n            node.next.keys.add(key);\\n            // update node\\n            map.put(key, node.next);\\n            \\n            // udate head\\n            if (node.keys.isEmpty()) {\\n                if (node == head) head = node.next;\\n                node.next.pre = node.pre;\\n                if (node.pre != null) node.pre.next = node.next;\\n            }\\n            // update tail\\n            if (tail == node) tail = node.next;\\n        } else {\\n            if (head == null || head.val > 1) {\\n                Node node = new Node(1);\\n                node.next = head;\\n                if (head != null) head.pre = node;\\n                head = node;\\n                if (tail == null) tail = node;\\n            }\\n            head.keys.add(key);\\n            map.put(key, head);\\n        }\\n    }\\n    \\n    /** Decrements an existing key by 1. If Key's value is 1, remove it from the data structure. */\\n    public void dec(String key) {\\n        if (!map.containsKey(key)) return;\\n        // get old node\\n        Node node = map.get(key);\\n        // get old val\\n        int val = node.val;\\n        // remove old val from old node\\n        node.keys.remove(key);\\n        // remove old key\\n        map.remove(key);\\n        // if it's head, update head and tail\\n        if (val == 1) {\\n            if (node.keys.isEmpty()) {\\n                if (head == node) head = node.next;\\n                if (head != null) head.pre = null;\\n                if (tail == node) tail = null;\\n            }\\n        } else {\\n            // add new node at pre position\\n            if (node.pre == null || node.pre.val != val - 1) {\\n                Node newNode = new Node(val - 1);\\n                newNode.next = node;\\n                newNode.pre = node.pre;\\n                node.pre = newNode;\\n                if (newNode.pre != null) newNode.pre.next = newNode;\\n            }\\n            // add new key to the newNode or pre node\\n            node.pre.keys.add(key);\\n            // update node\\n            map.put(key, node.pre);\\n            \\n            // update tail\\n            if (node.keys.isEmpty()) {\\n                if (tail == node) tail = node.pre;\\n                node.pre.next = node.next;\\n                if (node.next != null) node.next.pre = node.pre;\\n            }\\n            // update head\\n            if (head == node) head = node.pre;\\n        }\\n    }\\n    \\n    /** Returns one of the keys with maximal value. */\\n    public String getMaxKey() {\\n        return tail == null ? \"\" : tail.keys.iterator().next();\\n    }\\n    \\n    /** Returns one of the keys with Minimal value. */\\n    public String getMinKey() {\\n        return head == null ? \"\" : head.keys.iterator().next();\\n    }\\n    \\n    class Node {\\n        int val;\\n        LinkedHashSet<String> keys;\\n        Node next, pre;\\n        public Node(int val) {\\n            this.val = val;\\n            keys = new LinkedHashSet();\\n            next = pre = null;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 91465,
                "title": "c-o-1-0ms-ac-solution",
                "content": "```\\nclass AllOne {\\npublic:\\n    /** Initialize your data structure here. */\\n    AllOne() {\\n    }\\n\\n    /** Inserts a new key <Key> with value 1. Or increments an existing key by 1. */\\n    void inc(string key) {\\n        if (iters.find(key) == iters.end()) {\\n            if (ones.empty() || ones.begin()->first != 1) ones.insert(ones.begin(), make_pair(1, KeySet()));\\n            ones.begin()->second.insert(key);\\n            iters[key] = ones.begin();\\n        }\\n        else {\\n            Ones::iterator it, next;\\n            it = next = iters[key];\\n            next++;\\n            if (next != ones.end() && next->first == it->first + 1) next->second.insert(key);\\n            else next = ones.insert(next, make_pair(iters[key]->first + 1, KeySet({ key })));\\n            iters[key] = next;\\n            it->second.erase(key);\\n            if (it->second.empty()) ones.erase(it);\\n        }\\n    }\\n\\n    /** Decrements an existing key by 1. If Key's value is 1, remove it from the data structure. */\\n    void dec(string key) {\\n        if (iters.find(key) != iters.end()) {\\n            Ones::iterator it, prev;\\n            prev = it = iters[key];\\n            if (it != ones.begin()) prev--;\\n            if (it->first != 1) {\\n                if (it == ones.begin() || prev->first != it->first - 1) \\n                    prev = ones.insert(it, make_pair(iters[key]->first - 1, KeySet()));\\n                prev->second.insert(key);\\n                iters[key] = prev;\\n            }\\n            else iters.erase(key);\\n            it->second.erase(key);\\n            if (it->second.empty()) ones.erase(it);\\n        }\\n    }\\n\\n    /** Returns one of the keys with maximal value. */\\n    string getMaxKey() {\\n        return ones.empty() ? \"\" : *ones.rbegin()->second.begin();\\n    }\\n\\n    /** Returns one of the keys with Minimal value. */\\n    string getMinKey() {\\n        return ones.empty() ? \"\" : *ones.begin()->second.begin();\\n    }\\nprivate:\\n    typedef unordered_set<string> KeySet;\\n    typedef list<pair<int, KeySet>> Ones;\\n    Ones ones;\\n    unordered_map<string, Ones::iterator> iters;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass AllOne {\\npublic:\\n    /** Initialize your data structure here. */\\n    AllOne() {\\n    }\\n\\n    /** Inserts a new key <Key> with value 1. Or increments an existing key by 1. */\\n    void inc(string key) {\\n        if (iters.find(key) == iters.end()) {\\n            if (ones.empty() || ones.begin()->first != 1) ones.insert(ones.begin(), make_pair(1, KeySet()));\\n            ones.begin()->second.insert(key);\\n            iters[key] = ones.begin();\\n        }\\n        else {\\n            Ones::iterator it, next;\\n            it = next = iters[key];\\n            next++;\\n            if (next != ones.end() && next->first == it->first + 1) next->second.insert(key);\\n            else next = ones.insert(next, make_pair(iters[key]->first + 1, KeySet({ key })));\\n            iters[key] = next;\\n            it->second.erase(key);\\n            if (it->second.empty()) ones.erase(it);\\n        }\\n    }\\n\\n    /** Decrements an existing key by 1. If Key's value is 1, remove it from the data structure. */\\n    void dec(string key) {\\n        if (iters.find(key) != iters.end()) {\\n            Ones::iterator it, prev;\\n            prev = it = iters[key];\\n            if (it != ones.begin()) prev--;\\n            if (it->first != 1) {\\n                if (it == ones.begin() || prev->first != it->first - 1) \\n                    prev = ones.insert(it, make_pair(iters[key]->first - 1, KeySet()));\\n                prev->second.insert(key);\\n                iters[key] = prev;\\n            }\\n            else iters.erase(key);\\n            it->second.erase(key);\\n            if (it->second.empty()) ones.erase(it);\\n        }\\n    }\\n\\n    /** Returns one of the keys with maximal value. */\\n    string getMaxKey() {\\n        return ones.empty() ? \"\" : *ones.rbegin()->second.begin();\\n    }\\n\\n    /** Returns one of the keys with Minimal value. */\\n    string getMinKey() {\\n        return ones.empty() ? \"\" : *ones.begin()->second.begin();\\n    }\\nprivate:\\n    typedef unordered_set<string> KeySet;\\n    typedef list<pair<int, KeySet>> Ones;\\n    Ones ones;\\n    unordered_map<string, Ones::iterator> iters;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4006042,
                "title": "all-o-one-data-structure",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#include <string>\\n#include <unordered_map>\\n#include <unordered_set>\\n#include <list>\\n\\nclass AllOne {\\n public:\\n  void inc(string key) {\\n    const auto it = keyToIterator.find(key);\\n\\n    if (it == keyToIterator.cend()) {\\n      if (l.empty() || l.front().value > 1)\\n        l.push_front({1, {key}});\\n      else\\n        l.front().keys.insert(key);\\n      keyToIterator[key] = l.begin();\\n      return;\\n    }\\n\\n    const auto lit = it->second;\\n    auto nit = next(lit);\\n\\n    if (nit == l.end() || nit->value > lit->value + 1)\\n      nit = l.insert(nit, {lit->value + 1, {key}});\\n    else\\n      nit->keys.insert(key);\\n    keyToIterator[key] = nit;\\n\\n    lit->keys.erase(key);\\n    if (lit->keys.empty())\\n      l.erase(lit);\\n  }\\n\\n  void dec(string key) {\\n    const auto it = keyToIterator.find(key);\\n\\n    if (it == keyToIterator.cend())\\n      return;\\n\\n    const auto lit = it->second;\\n\\n    if (lit->value == 1) {\\n      keyToIterator.erase(key);\\n      lit->keys.erase(key);\\n      if (lit->keys.empty())\\n        l.erase(lit);\\n      return;\\n    } else {\\n      auto pit = prev(lit);\\n\\n      if (lit == l.begin() || pit->value < lit->value - 1)\\n        pit = l.insert(lit, {lit->value - 1, {key}});\\n      else\\n        pit->keys.insert(key);\\n      keyToIterator[key] = pit;\\n    }\\n\\n    lit->keys.erase(key);\\n    if (lit->keys.empty())\\n      l.erase(lit);\\n  }\\n\\n  string getMaxKey() {\\n    return l.empty() ? \"\" : *l.back().keys.begin();\\n  }\\n\\n  string getMinKey() {\\n    return l.empty() ? \"\" : *l.front().keys.begin();\\n  }\\n\\n private:\\n  struct Node {\\n    int value;\\n    unordered_set<string> keys;\\n  };\\n\\n  list<Node> l;\\n  unordered_map<string, list<Node>::iterator> keyToIterator;\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#include <string>\\n#include <unordered_map>\\n#include <unordered_set>\\n#include <list>\\n\\nclass AllOne {\\n public:\\n  void inc(string key) {\\n    const auto it = keyToIterator.find(key);\\n\\n    if (it == keyToIterator.cend()) {\\n      if (l.empty() || l.front().value > 1)\\n        l.push_front({1, {key}});\\n      else\\n        l.front().keys.insert(key);\\n      keyToIterator[key] = l.begin();\\n      return;\\n    }\\n\\n    const auto lit = it->second;\\n    auto nit = next(lit);\\n\\n    if (nit == l.end() || nit->value > lit->value + 1)\\n      nit = l.insert(nit, {lit->value + 1, {key}});\\n    else\\n      nit->keys.insert(key);\\n    keyToIterator[key] = nit;\\n\\n    lit->keys.erase(key);\\n    if (lit->keys.empty())\\n      l.erase(lit);\\n  }\\n\\n  void dec(string key) {\\n    const auto it = keyToIterator.find(key);\\n\\n    if (it == keyToIterator.cend())\\n      return;\\n\\n    const auto lit = it->second;\\n\\n    if (lit->value == 1) {\\n      keyToIterator.erase(key);\\n      lit->keys.erase(key);\\n      if (lit->keys.empty())\\n        l.erase(lit);\\n      return;\\n    } else {\\n      auto pit = prev(lit);\\n\\n      if (lit == l.begin() || pit->value < lit->value - 1)\\n        pit = l.insert(lit, {lit->value - 1, {key}});\\n      else\\n        pit->keys.insert(key);\\n      keyToIterator[key] = pit;\\n    }\\n\\n    lit->keys.erase(key);\\n    if (lit->keys.empty())\\n      l.erase(lit);\\n  }\\n\\n  string getMaxKey() {\\n    return l.empty() ? \"\" : *l.back().keys.begin();\\n  }\\n\\n  string getMinKey() {\\n    return l.empty() ? \"\" : *l.front().keys.begin();\\n  }\\n\\n private:\\n  struct Node {\\n    int value;\\n    unordered_set<string> keys;\\n  };\\n\\n  list<Node> l;\\n  unordered_map<string, list<Node>::iterator> keyToIterator;\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3963653,
                "title": "python-hashmap-doubly-linked-list",
                "content": "```py\\nclass DoubleLinked:\\n    \\n    def __init__(self,key):\\n        \\n        self.key = key\\n        self.count = 1\\n        self.prev = None\\n        self.next = None\\n\\nclass AllOne:\\n    def __init__(self):\\n        self.mp = {}\\n        self.head = DoubleLinked(\\'\\')\\n        self.tail = DoubleLinked(\\'\\')\\n        self.head.next = self.tail\\n        self.tail.prev = self.head\\n        self.head.count = float(\\'-inf\\')\\n        self.tail.count = float(\\'inf\\')\\n    def inc(self, key: str) -> None:\\n        if key not in self.mp:\\n            #add a value to the head\\n            \\n            new = DoubleLinked(key)\\n            new.prev = self.head\\n            new.next = self.head.next\\n            self.head.next = new\\n            new.next.prev = new\\n            self.mp[key] = new\\n        else:\\n            #increment and shift if needed\\n            self.mp[key].count += 1\\n            current = self.mp[key]\\n            while current.next.count < current.count:\\n                #swap them\\n                nxt = current.next\\n                prv = current.prev\\n                current.next = nxt.next\\n                current.prev = nxt\\n                current.next.prev = current\\n                nxt.next = current\\n                nxt.prev = prv\\n                prv.next = nxt               \\n      \\n    def dec(self, key: str) -> None:\\n        \\n        self.mp[key].count -=1\\n        if self.mp[key].count == 0:\\n            #remove\\n            prv = self.mp[key].prev\\n            nxt = self.mp[key].next\\n            prv.next = nxt\\n            nxt.prev = prv\\n            self.mp[key].prev = None\\n            self.mp[key].next = None\\n            \\n            del self.mp[key]\\n        else:\\n            current = self.mp[key]\\n            while current.prev.count > current.count:\\n                #swap them\\n                nxt = current.next\\n                prv = current.prev\\n                current.next = prv\\n                current.prev = prv.prev\\n                current.prev.next = current\\n                prv.next = nxt \\n                prv.prev = current\\n                nxt.prev = prv               \\n\\n    def getMaxKey(self) -> str:\\n        return self.tail.prev.key\\n            \\n\\n    def getMinKey(self) -> str:\\n        return self.head.next.key",
                "solutionTags": [
                    "Python",
                    "Linked List"
                ],
                "code": "```py\\nclass DoubleLinked:\\n    \\n    def __init__(self,key):\\n        \\n        self.key = key\\n        self.count = 1\\n        self.prev = None\\n        self.next = None\\n\\nclass AllOne:\\n    def __init__(self):\\n        self.mp = {}\\n        self.head = DoubleLinked(\\'\\')\\n        self.tail = DoubleLinked(\\'\\')\\n        self.head.next = self.tail\\n        self.tail.prev = self.head\\n        self.head.count = float(\\'-inf\\')\\n        self.tail.count = float(\\'inf\\')\\n    def inc(self, key: str) -> None:\\n        if key not in self.mp:\\n            #add a value to the head\\n            \\n            new = DoubleLinked(key)\\n            new.prev = self.head\\n            new.next = self.head.next\\n            self.head.next = new\\n            new.next.prev = new\\n            self.mp[key] = new\\n        else:\\n            #increment and shift if needed\\n            self.mp[key].count += 1\\n            current = self.mp[key]\\n            while current.next.count < current.count:\\n                #swap them\\n                nxt = current.next\\n                prv = current.prev\\n                current.next = nxt.next\\n                current.prev = nxt\\n                current.next.prev = current\\n                nxt.next = current\\n                nxt.prev = prv\\n                prv.next = nxt               \\n      \\n    def dec(self, key: str) -> None:\\n        \\n        self.mp[key].count -=1\\n        if self.mp[key].count == 0:\\n            #remove\\n            prv = self.mp[key].prev\\n            nxt = self.mp[key].next\\n            prv.next = nxt\\n            nxt.prev = prv\\n            self.mp[key].prev = None\\n            self.mp[key].next = None\\n            \\n            del self.mp[key]\\n        else:\\n            current = self.mp[key]\\n            while current.prev.count > current.count:\\n                #swap them\\n                nxt = current.next\\n                prv = current.prev\\n                current.next = prv\\n                current.prev = prv.prev\\n                current.prev.next = current\\n                prv.next = nxt \\n                prv.prev = current\\n                nxt.prev = prv               \\n\\n    def getMaxKey(self) -> str:\\n        return self.tail.prev.key\\n            \\n\\n    def getMinKey(self) -> str:\\n        return self.head.next.key",
                "codeTag": "Java"
            },
            {
                "id": 3715465,
                "title": "c-hash-tables-88-faster-92-space-optimised",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass AllOne {\\npublic:\\n\\n    unordered_map<int,pair<int,int>> starts;\\n    unordered_map<string,int> m;\\n    int size=0;\\n    vector<pair<int,string>> vp;\\n\\n    AllOne() {\\n        \\n    }\\n    \\n    void inc(string key) {\\n        if(m.find(key) == m.end()){\\n            m[key]=size;\\n            vp.push_back({1,key});\\n            if(starts.find(1)==starts.end()){\\n                starts[1]=make_pair(size,1);\\n            }\\n            else{\\n                starts[1].second++;\\n            }\\n            size++;\\n        }\\n        else{\\n            int ind = m[key];\\n            int currcnt = vp[ind].first;\\n            int startind = starts[currcnt].first;\\n            string leader = vp[startind].second;\\n            if(leader!=key){\\n                swap(vp[ind],vp[startind]);\\n                m[key]=startind;\\n                m[leader]=ind;\\n            }\\n            vp[startind].first++;\\n            starts[currcnt].second--;\\n            starts[currcnt].first++;\\n            if(starts[currcnt].second==0) starts.erase(starts.find(currcnt));\\n            currcnt++;\\n            if(starts.find(currcnt)==starts.end()){\\n                starts[currcnt] = make_pair(startind,0);\\n            }\\n            starts[currcnt].second++;\\n        }\\n    }\\n    \\n    void dec(string key) {\\n        int ind = m[key];\\n        int currcnt = vp[ind].first;\\n        int endind = starts[currcnt].first + starts[currcnt].second - 1;\\n        string slave = vp[endind].second;\\n        if(slave!=key){\\n            swap(vp[ind],vp[endind]);\\n            m[key]=endind;\\n            m[slave]=ind;\\n        }\\n        vp[endind].first--;\\n        starts[currcnt].second--;\\n        if(starts[currcnt].second==0) starts.erase(starts.find(currcnt));\\n        currcnt--;\\n        if(currcnt==0){\\n            vp.pop_back();\\n            m.erase(m.find(key));\\n            size--;\\n        }\\n        else{\\n            if(starts.find(currcnt)==starts.end()){\\n                starts[currcnt] = make_pair(endind,1);\\n            }\\n            else{\\n                starts[currcnt].first = endind;\\n                starts[currcnt].second++;\\n            }\\n        }\\n    }\\n    \\n    string getMaxKey() {\\n        if(size==0) return \"\";\\n        return vp[0].second;\\n    }\\n    \\n    string getMinKey() {\\n        if(size==0) return \"\";\\n        return vp[size-1].second;\\n    }\\n};\\n\\n/**\\n * Your AllOne object will be instantiated and called as such:\\n * AllOne* obj = new AllOne();\\n * obj->inc(key);\\n * obj->dec(key);\\n * string param_3 = obj->getMaxKey();\\n * string param_4 = obj->getMinKey();\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass AllOne {\\npublic:\\n\\n    unordered_map<int,pair<int,int>> starts;\\n    unordered_map<string,int> m;\\n    int size=0;\\n    vector<pair<int,string>> vp;\\n\\n    AllOne() {\\n        \\n    }\\n    \\n    void inc(string key) {\\n        if(m.find(key) == m.end()){\\n            m[key]=size;\\n            vp.push_back({1,key});\\n            if(starts.find(1)==starts.end()){\\n                starts[1]=make_pair(size,1);\\n            }\\n            else{\\n                starts[1].second++;\\n            }\\n            size++;\\n        }\\n        else{\\n            int ind = m[key];\\n            int currcnt = vp[ind].first;\\n            int startind = starts[currcnt].first;\\n            string leader = vp[startind].second;\\n            if(leader!=key){\\n                swap(vp[ind],vp[startind]);\\n                m[key]=startind;\\n                m[leader]=ind;\\n            }\\n            vp[startind].first++;\\n            starts[currcnt].second--;\\n            starts[currcnt].first++;\\n            if(starts[currcnt].second==0) starts.erase(starts.find(currcnt));\\n            currcnt++;\\n            if(starts.find(currcnt)==starts.end()){\\n                starts[currcnt] = make_pair(startind,0);\\n            }\\n            starts[currcnt].second++;\\n        }\\n    }\\n    \\n    void dec(string key) {\\n        int ind = m[key];\\n        int currcnt = vp[ind].first;\\n        int endind = starts[currcnt].first + starts[currcnt].second - 1;\\n        string slave = vp[endind].second;\\n        if(slave!=key){\\n            swap(vp[ind],vp[endind]);\\n            m[key]=endind;\\n            m[slave]=ind;\\n        }\\n        vp[endind].first--;\\n        starts[currcnt].second--;\\n        if(starts[currcnt].second==0) starts.erase(starts.find(currcnt));\\n        currcnt--;\\n        if(currcnt==0){\\n            vp.pop_back();\\n            m.erase(m.find(key));\\n            size--;\\n        }\\n        else{\\n            if(starts.find(currcnt)==starts.end()){\\n                starts[currcnt] = make_pair(endind,1);\\n            }\\n            else{\\n                starts[currcnt].first = endind;\\n                starts[currcnt].second++;\\n            }\\n        }\\n    }\\n    \\n    string getMaxKey() {\\n        if(size==0) return \"\";\\n        return vp[0].second;\\n    }\\n    \\n    string getMinKey() {\\n        if(size==0) return \"\";\\n        return vp[size-1].second;\\n    }\\n};\\n\\n/**\\n * Your AllOne object will be instantiated and called as such:\\n * AllOne* obj = new AllOne();\\n * obj->inc(key);\\n * obj->dec(key);\\n * string param_3 = obj->getMaxKey();\\n * string param_4 = obj->getMinKey();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3603669,
                "title": "100-efficient-c-dictionary-linkedlist",
                "content": "# Intuition & Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n***Each string will be associated with one frequency value. But each frequency value can be associated with multiple strings.***\\n\\nHence, we\\'ll ***use a LinkedList (internally double linked list), where we store individual frequencies and associated strings in one node***.\\nWe store the nodes in the order of increasing frequency (we do that in O(1) with the help of below Dictionary)\\nWe **use a dictionary to map string to the node in which it is stored, mapped to it\\'s frequency**\\n\\n![Screenshot 2023-06-06 120824.png](https://assets.leetcode.com/users/images/f31cc902-8b90-441f-a103-2be1ac34e7f6_1686033534.6519709.png)\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(1) - all functionalities\\n***Adding and removing nodes from the linked list here runs at O(1) as we are using the functions AddAfter, AddBefore and Remove which takes node reference as parameter and hence performs the respective operations in O(1)***\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N) - as we store all the strings, mapping each string to one frequency value.\\n\\n## Please upvote if you like the approach\\n\\n---\\n\\n# Code\\n```\\npublic class AllOne {\\n\\n    //string will point to the linked list node where it is mapped to a frequency\\n    Dictionary<string, LinkedListNode<FreqStrings>> strMap;\\n    \\n    //this linked list will contains nodes in order of increasing frequency of strings\\n    LinkedList<FreqStrings> dll;\\n\\n    public AllOne() {\\n        strMap = new Dictionary<string, LinkedListNode<FreqStrings>>();\\n        dll = new LinkedList<FreqStrings>();\\n    }\\n    \\n    public void Inc(string key) {\\n        if (!strMap.ContainsKey(key))\\n        {\\n            //add new node in front of linked list if it is empty or has not node with frequency of \\'1\\'\\n            if (dll.Count == 0 || dll.First.Value.freq != 1)\\n            {\\n                FreqStrings node = new FreqStrings(1);\\n                dll.AddFirst(node);\\n            }\\n            dll.First.Value.strs.Add(key);\\n            strMap.Add(key, dll.First);\\n        }\\n        else\\n        {\\n            var node = strMap[key];\\n            //remove the string mapping from previous frequency\\n            node.Value.strs.Remove(key);\\n            int nxtFreq = node.Value.freq + 1;\\n            if (node.Next == null || node.Next.Value.freq != nxtFreq)\\n            {\\n                FreqStrings newNode = new FreqStrings(nxtFreq);\\n                dll.AddAfter(node, newNode);\\n            }\\n            //map the string to new frequency\\n            node.Next.Value.strs.Add(key);\\n            strMap[key] = node.Next;\\n\\n            if (node.Value.strs.Count == 0)\\n                dll.Remove(node);\\n        }\\n    }\\n    \\n    public void Dec(string key) {\\n        var node = strMap[key];\\n        //remove the string mapping from previous frequency\\n        node.Value.strs.Remove(key);\\n        int prevFreq = node.Value.freq - 1;\\n        if (prevFreq > 0)\\n        {\\n            if (node.Previous == null || node.Previous.Value.freq != prevFreq)\\n            {\\n                FreqStrings newNode = new FreqStrings(prevFreq);\\n                dll.AddBefore(node, newNode);\\n            }\\n            //only if reduced frequency is not \\'0\\'\\n            //map the string to new frequency\\n            node.Previous.Value.strs.Add(key);\\n            strMap[key] = node.Previous;\\n        }\\n\\n        if (node.Value.strs.Count == 0)\\n            dll.Remove(node);\\n\\n        if (prevFreq == 0)\\n        {\\n            strMap.Remove(key);\\n        }\\n        \\n    }\\n    \\n    public string GetMaxKey() {\\n        if (dll.Count == 0)\\n            return \"\";\\n        //take any string from the last node (largest available frequency)\\n        return dll.Last.Value.strs.First();\\n    }\\n    \\n    public string GetMinKey() {\\n        if (dll.Count == 0)\\n            return \"\";\\n\\n        //take any string from the first node (smallest available frequency)\\n        return dll.First.Value.strs.First();\\n    }\\n}\\n\\npublic class FreqStrings\\n{\\n    public FreqStrings(int f)\\n    {\\n        freq = f;\\n        strs = new HashSet<string>();\\n    }\\n\\n    public int freq;\\n    public HashSet<string> strs;\\n}\\n```\\n\\n## Please upvote if you like the approach\\n![Upvote please - effort.jpg](https://assets.leetcode.com/users/images/e74931d6-ba70-4000-9b57-b6894595a65e_1686033837.368623.jpeg)\\n",
                "solutionTags": [
                    "C#",
                    "Hash Table",
                    "Design",
                    "Doubly-Linked List"
                ],
                "code": "```\\npublic class AllOne {\\n\\n    //string will point to the linked list node where it is mapped to a frequency\\n    Dictionary<string, LinkedListNode<FreqStrings>> strMap;\\n    \\n    //this linked list will contains nodes in order of increasing frequency of strings\\n    LinkedList<FreqStrings> dll;\\n\\n    public AllOne() {\\n        strMap = new Dictionary<string, LinkedListNode<FreqStrings>>();\\n        dll = new LinkedList<FreqStrings>();\\n    }\\n    \\n    public void Inc(string key) {\\n        if (!strMap.ContainsKey(key))\\n        {\\n            //add new node in front of linked list if it is empty or has not node with frequency of \\'1\\'\\n            if (dll.Count == 0 || dll.First.Value.freq != 1)\\n            {\\n                FreqStrings node = new FreqStrings(1);\\n                dll.AddFirst(node);\\n            }\\n            dll.First.Value.strs.Add(key);\\n            strMap.Add(key, dll.First);\\n        }\\n        else\\n        {\\n            var node = strMap[key];\\n            //remove the string mapping from previous frequency\\n            node.Value.strs.Remove(key);\\n            int nxtFreq = node.Value.freq + 1;\\n            if (node.Next == null || node.Next.Value.freq != nxtFreq)\\n            {\\n                FreqStrings newNode = new FreqStrings(nxtFreq);\\n                dll.AddAfter(node, newNode);\\n            }\\n            //map the string to new frequency\\n            node.Next.Value.strs.Add(key);\\n            strMap[key] = node.Next;\\n\\n            if (node.Value.strs.Count == 0)\\n                dll.Remove(node);\\n        }\\n    }\\n    \\n    public void Dec(string key) {\\n        var node = strMap[key];\\n        //remove the string mapping from previous frequency\\n        node.Value.strs.Remove(key);\\n        int prevFreq = node.Value.freq - 1;\\n        if (prevFreq > 0)\\n        {\\n            if (node.Previous == null || node.Previous.Value.freq != prevFreq)\\n            {\\n                FreqStrings newNode = new FreqStrings(prevFreq);\\n                dll.AddBefore(node, newNode);\\n            }\\n            //only if reduced frequency is not \\'0\\'\\n            //map the string to new frequency\\n            node.Previous.Value.strs.Add(key);\\n            strMap[key] = node.Previous;\\n        }\\n\\n        if (node.Value.strs.Count == 0)\\n            dll.Remove(node);\\n\\n        if (prevFreq == 0)\\n        {\\n            strMap.Remove(key);\\n        }\\n        \\n    }\\n    \\n    public string GetMaxKey() {\\n        if (dll.Count == 0)\\n            return \"\";\\n        //take any string from the last node (largest available frequency)\\n        return dll.Last.Value.strs.First();\\n    }\\n    \\n    public string GetMinKey() {\\n        if (dll.Count == 0)\\n            return \"\";\\n\\n        //take any string from the first node (smallest available frequency)\\n        return dll.First.Value.strs.First();\\n    }\\n}\\n\\npublic class FreqStrings\\n{\\n    public FreqStrings(int f)\\n    {\\n        freq = f;\\n        strs = new HashSet<string>();\\n    }\\n\\n    public int freq;\\n    public HashSet<string> strs;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3359530,
                "title": "solution",
                "content": "```C++ []\\nclass AllOne {\\npublic:\\nunordered_map<string, int> m;\\n    AllOne() {\\n        ios_base::sync_with_stdio(0);\\n        cin.tie(0); cout.tie(0);\\n    }\\n    void updateMin() {        \\n        _min.second = INT_MAX;\\n        for(auto & nd : m) {\\n            if(_min.second > nd.second) {\\n                _min.second = nd.second;\\n                _min.first = nd.first;\\n            }\\n        }\\n    }\\n    void updateMax() {        \\n        _max.second = INT_MIN;\\n        for(auto & nd : m) {\\n            if(_max.second < nd.second) {\\n                _max.second = nd.second;\\n                _max.first = nd.first;\\n            }\\n        }\\n    }\\n    void inc(string key) {\\n        auto & v = m[key];\\n        ++v;\\n        if(v > _max.second) {\\n            _max.second = v;\\n            _max.first = key;\\n        }\\n        if(key == _min.first) {\\n            updateMin();\\n        }\\n        if(_min.second > v || _min.first.empty()) {\\n            _min.first = key;\\n            _min.second = v;\\n        }\\n    }\\n    void dec(string key) {\\n        m[key]--;\\n        if(m[key] ==0)\\n            m.erase(key);\\n        _min.first = _max.first = \"\";\\n    }\\n    string getMaxKey() {\\n        if(!_max.first.empty())\\n            return _max.first;\\n        updateMax();\\n        return _max.first;\\n    }\\n    string getMinKey() {\\n        if(!_min.first.empty())\\n            return _min.first;\\n\\n        updateMin();\\n        return _min.first;\\n    }\\n    pair<string, int> _min{{}, 0};\\n    pair<string, int> _max{{}, 0};\\n};\\n```\\n\\n```Python3 []\\nclass AllOne:\\n\\n    def __init__(self):\\n        self.mem = dict()\\n        self.prev_max = None\\n        self.prev_min = None\\n        \\n    def inc(self, key: str) -> None:\\n        self.prev_max, self.prev_min = None, None\\n\\n        if key not in self.mem:\\n            self.mem[key] = 1\\n        else:\\n            self.mem[key] += 1\\n\\n    def dec(self, key: str) -> None:\\n        self.prev_max, self.prev_min = None, None\\n\\n        if self.mem[key] == 1:\\n            self.mem.pop(key)\\n        else:\\n            self.mem[key] -= 1\\n        \\n    def getMaxKey(self) -> str:\\n        if len(self.mem) == 0:\\n            return \"\"\\n        else:\\n            if self.prev_max != None:\\n                return self.prev_max\\n            \\n            output = sorted(self.mem.items(), key=lambda x:x[1])[-1][0]\\n            self.prev_max = output\\n\\n            return output\\n        \\n    def getMinKey(self) -> str:\\n        if len(self.mem) == 0:\\n            return \"\"\\n        else:\\n            if self.prev_min != None:\\n                return self.prev_min\\n            output = sorted(self.mem.items(), key=lambda x:x[1])[0][0]\\n            self.prev_min = output\\n            return output\\n```\\n\\n```Java []\\nimport java.util.HashMap;\\nimport java.util.Map;\\n\\nclass AllOne {\\n    static class Node {\\n        String string;\\n        int count;\\n        Node prev;\\n        Node next;\\n\\n        Node() {\\n            this.string = \"\";\\n        }\\n        Node(String string, int count) {\\n            this.string = string;\\n            this.count = count;\\n        }\\n    }\\n    Map<String, Node> stringNodeMap;\\n    Node head;\\n    Node tail;\\n\\n    public AllOne() {\\n        this.stringNodeMap = new HashMap<>();\\n        this.head = new Node();\\n        this.tail = new Node();\\n\\n        this.head.next = this.tail;\\n        this.tail.prev = this.head;\\n    }\\n    private Node insertKeyAtBeginning(String key) {\\n        Node node = new Node(key, 1);\\n\\n        this.head.next.prev = node;\\n        node.next = this.head.next;\\n        this.head.next = node;\\n        node.prev = this.head;\\n\\n        return node;\\n    }\\n    public void inc(String key) {\\n        if (stringNodeMap.containsKey(key)) {\\n            \\n            Node node = stringNodeMap.get(key);\\n            node.count++;\\n\\n            while (node.next != this.tail && node.count > node.next.count) {\\n                Node prev = node.prev;\\n                Node next = node.next;\\n\\n                prev.next = next;\\n                next.prev = prev;\\n\\n                node.next = next.next;\\n                next.next.prev = node;\\n\\n                next.next = node;\\n                node.prev = next;\\n            }\\n        } else {\\n            Node node = insertKeyAtBeginning(key);\\n            this.stringNodeMap.put(key, node);\\n        }\\n    }\\n    private void removeNode(Node node) {\\n        Node prev = node.prev;\\n        Node next = node.next;\\n\\n        prev.next = next;\\n        next.prev = prev;\\n\\n        node.next = null;\\n        node.prev = null;\\n    }\\n    public void dec(String key) {\\n        Node node = stringNodeMap.get(key);\\n        if (node.count == 1) {\\n         \\n            removeNode(node);\\n            this.stringNodeMap.remove(key);\\n        } else {\\n            \\n            node.count--;\\n\\n            while (node.prev != this.head && node.count < node.prev.count) {\\n                Node prev = node.prev;\\n                Node next = node.next;\\n\\n                prev.next = next;\\n                next.prev = prev;\\n\\n                node.prev = prev.prev;\\n                prev.prev.next = node;\\n\\n                prev.prev = node;\\n                node.next = prev;\\n            }\\n        }\\n    }\\n    public String getMaxKey() {\\n        return this.tail.prev.string;\\n    }\\n    public String getMinKey() {\\n        return this.head.next.string;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass AllOne {\\npublic:\\nunordered_map<string, int> m;\\n    AllOne() {\\n        ios_base::sync_with_stdio(0);\\n        cin.tie(0); cout.tie(0);\\n    }\\n    void updateMin() {        \\n        _min.second = INT_MAX;\\n        for(auto & nd : m) {\\n            if(_min.second > nd.second) {\\n                _min.second = nd.second;\\n                _min.first = nd.first;\\n            }\\n        }\\n    }\\n    void updateMax() {        \\n        _max.second = INT_MIN;\\n        for(auto & nd : m) {\\n            if(_max.second < nd.second) {\\n                _max.second = nd.second;\\n                _max.first = nd.first;\\n            }\\n        }\\n    }\\n    void inc(string key) {\\n        auto & v = m[key];\\n        ++v;\\n        if(v > _max.second) {\\n            _max.second = v;\\n            _max.first = key;\\n        }\\n        if(key == _min.first) {\\n            updateMin();\\n        }\\n        if(_min.second > v || _min.first.empty()) {\\n            _min.first = key;\\n            _min.second = v;\\n        }\\n    }\\n    void dec(string key) {\\n        m[key]--;\\n        if(m[key] ==0)\\n            m.erase(key);\\n        _min.first = _max.first = \"\";\\n    }\\n    string getMaxKey() {\\n        if(!_max.first.empty())\\n            return _max.first;\\n        updateMax();\\n        return _max.first;\\n    }\\n    string getMinKey() {\\n        if(!_min.first.empty())\\n            return _min.first;\\n\\n        updateMin();\\n        return _min.first;\\n    }\\n    pair<string, int> _min{{}, 0};\\n    pair<string, int> _max{{}, 0};\\n};\\n```\n```Python3 []\\nclass AllOne:\\n\\n    def __init__(self):\\n        self.mem = dict()\\n        self.prev_max = None\\n        self.prev_min = None\\n        \\n    def inc(self, key: str) -> None:\\n        self.prev_max, self.prev_min = None, None\\n\\n        if key not in self.mem:\\n            self.mem[key] = 1\\n        else:\\n            self.mem[key] += 1\\n\\n    def dec(self, key: str) -> None:\\n        self.prev_max, self.prev_min = None, None\\n\\n        if self.mem[key] == 1:\\n            self.mem.pop(key)\\n        else:\\n            self.mem[key] -= 1\\n        \\n    def getMaxKey(self) -> str:\\n        if len(self.mem) == 0:\\n            return \"\"\\n        else:\\n            if self.prev_max != None:\\n                return self.prev_max\\n            \\n            output = sorted(self.mem.items(), key=lambda x:x[1])[-1][0]\\n            self.prev_max = output\\n\\n            return output\\n        \\n    def getMinKey(self) -> str:\\n        if len(self.mem) == 0:\\n            return \"\"\\n        else:\\n            if self.prev_min != None:\\n                return self.prev_min\\n            output = sorted(self.mem.items(), key=lambda x:x[1])[0][0]\\n            self.prev_min = output\\n            return output\\n```\n```Java []\\nimport java.util.HashMap;\\nimport java.util.Map;\\n\\nclass AllOne {\\n    static class Node {\\n        String string;\\n        int count;\\n        Node prev;\\n        Node next;\\n\\n        Node() {\\n            this.string = \"\";\\n        }\\n        Node(String string, int count) {\\n            this.string = string;\\n            this.count = count;\\n        }\\n    }\\n    Map<String, Node> stringNodeMap;\\n    Node head;\\n    Node tail;\\n\\n    public AllOne() {\\n        this.stringNodeMap = new HashMap<>();\\n        this.head = new Node();\\n        this.tail = new Node();\\n\\n        this.head.next = this.tail;\\n        this.tail.prev = this.head;\\n    }\\n    private Node insertKeyAtBeginning(String key) {\\n        Node node = new Node(key, 1);\\n\\n        this.head.next.prev = node;\\n        node.next = this.head.next;\\n        this.head.next = node;\\n        node.prev = this.head;\\n\\n        return node;\\n    }\\n    public void inc(String key) {\\n        if (stringNodeMap.containsKey(key)) {\\n            \\n            Node node = stringNodeMap.get(key);\\n            node.count++;\\n\\n            while (node.next != this.tail && node.count > node.next.count) {\\n                Node prev = node.prev;\\n                Node next = node.next;\\n\\n                prev.next = next;\\n                next.prev = prev;\\n\\n                node.next = next.next;\\n                next.next.prev = node;\\n\\n                next.next = node;\\n                node.prev = next;\\n            }\\n        } else {\\n            Node node = insertKeyAtBeginning(key);\\n            this.stringNodeMap.put(key, node);\\n        }\\n    }\\n    private void removeNode(Node node) {\\n        Node prev = node.prev;\\n        Node next = node.next;\\n\\n        prev.next = next;\\n        next.prev = prev;\\n\\n        node.next = null;\\n        node.prev = null;\\n    }\\n    public void dec(String key) {\\n        Node node = stringNodeMap.get(key);\\n        if (node.count == 1) {\\n         \\n            removeNode(node);\\n            this.stringNodeMap.remove(key);\\n        } else {\\n            \\n            node.count--;\\n\\n            while (node.prev != this.head && node.count < node.prev.count) {\\n                Node prev = node.prev;\\n                Node next = node.next;\\n\\n                prev.next = next;\\n                next.prev = prev;\\n\\n                node.prev = prev.prev;\\n                prev.prev.next = node;\\n\\n                prev.prev = node;\\n                node.next = prev;\\n            }\\n        }\\n    }\\n    public String getMaxKey() {\\n        return this.tail.prev.string;\\n    }\\n    public String getMinKey() {\\n        return this.head.next.string;\\n    }\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2453046,
                "title": "c-all-strict-o-1-using-list-and-unordered-map-with-inline-comments",
                "content": "Main intution for the O(1) solution is that **you can only increment / decrement a key by 1** which gives us two important points - \\n1.  We can use a doubly linked list (with list of keys  which has the same value).\\n2.  A hashmap which maps key to the doubly linked list node reference.\\n\\n```\\nclass AllOne {\\npublic:\\n    AllOne() {\\n        \\n    }\\n    \\n    void inc(string key) {\\n        if(dataMap.find(key) == dataMap.end()) { // we\\'ve got a new a key which doesn\\'t exist in map\\n            if(dataList.size() && dataList.begin()->first == 1) { // we already\\'ve a list node with value as 1 so no need to create a new node\\n                dataList.begin()->second.insert(key); // insert key in the existing node\\n            } else { // no list node exist with value 1 so create a list node\\n                unordered_set<string> keysSet = { key };\\n                dataList.push_front({1, keysSet});\\n            }\\n            dataMap[key] = dataList.begin(); // update the key reference\\n            \\n        } else { // key already exist in the map \\n            auto currentPos = dataMap[key];\\n            int incrementedValue = currentPos->first + 1;\\n            auto nextPos = next(currentPos, 1);\\n            currentPos->second.erase(key); // delete key from the currentPos as we have incremented its value\\n\\n            if(currentPos->second.size() == 0) { // if that was the only key in the list node then remove that node also\\n                dataList.erase(currentPos);\\n            }\\n            if(nextPos != dataList.end() && incrementedValue == nextPos->first) { // key\\'s new incremented value is already there in the list so just need to insert the key in the list node\\n                nextPos->second.insert(key);\\n                dataMap[key] = nextPos;\\n            } else { // need to create a new list node\\n                unordered_set<string> keysSet = { key };\\n                auto newPos = dataList.insert(nextPos, {incrementedValue, keysSet});\\n                dataMap[key] = newPos;\\n            }\\n        }\\n    }\\n    \\n    void dec(string key) {\\n        if(dataMap.find(key) != dataMap.end()) { // key exist in the map\\n            auto currentPos = dataMap[key];\\n            int decrementedValue = currentPos->first - 1;\\n            list<pair<int, unordered_set<string>>>::iterator prevPos;\\n            bool isStartOfList = true;\\n            if(currentPos != dataList.begin()) {\\n                prevPos = next(currentPos, -1);\\n                isStartOfList = false;\\n            }\\n            currentPos->second.erase(key); //delete key from the currentPos as we have decremented its value\\n            auto nextPos = next(currentPos, 1);\\n            bool isCurrentPosDeleted = false;\\n            if(currentPos->second.size() == 0) { // if that was the only key in the list node then remove that node also\\n                dataList.erase(currentPos);\\n                isCurrentPosDeleted = true;\\n            }\\n            if(decrementedValue == 0) { // if new key value is 0 then remove it from the map also\\n                dataMap.erase(key);\\n            } else if(!isStartOfList && prevPos->first == decrementedValue) { // decremented value already exist in list so only need to insert the key to the list node\\n                prevPos->second.insert(key);\\n                dataMap[key] = prevPos;\\n            } else { // need to create a new list node\\n                unordered_set<string> keysSet;\\n                keysSet.insert(key);\\n                list<pair<int, unordered_set<string>>>::iterator insertBeforeItr;\\n                if(isCurrentPosDeleted) {\\n                    insertBeforeItr = nextPos;\\n                } else {\\n                    insertBeforeItr = currentPos;\\n                }\\n                auto newPos = dataList.insert(insertBeforeItr, {decrementedValue, keysSet});\\n                dataMap[key] = newPos;\\n            }\\n\\n        }\\n    }\\n    \\n    string getMaxKey() {\\n        if(dataList.size()) {\\n            return (*(dataList.rbegin()->second).begin()); // list end node\\n        }\\n        return \"\";\\n    }\\n    \\n    string getMinKey() {\\n        if(dataList.size()) {\\n            return (*(dataList.begin()->second).begin()); //list first node\\n        }\\n        return \"\";\\n    }\\nprivate:\\n    list<pair<int, unordered_set<string>>> dataList;\\n    unordered_map<string, list<pair<int, unordered_set<string>>>::iterator> dataMap;\\n};\\n\\n/**\\n * Your AllOne object will be instantiated and called as such:\\n * AllOne* obj = new AllOne();\\n * obj->inc(key);\\n * obj->dec(key);\\n * string param_3 = obj->getMaxKey();\\n * string param_4 = obj->getMinKey();\\n */\\n```",
                "solutionTags": [
                    "Linked List"
                ],
                "code": "```\\nclass AllOne {\\npublic:\\n    AllOne() {\\n        \\n    }\\n    \\n    void inc(string key) {\\n        if(dataMap.find(key) == dataMap.end()) { // we\\'ve got a new a key which doesn\\'t exist in map\\n            if(dataList.size() && dataList.begin()->first == 1) { // we already\\'ve a list node with value as 1 so no need to create a new node\\n                dataList.begin()->second.insert(key); // insert key in the existing node\\n            } else { // no list node exist with value 1 so create a list node\\n                unordered_set<string> keysSet = { key };\\n                dataList.push_front({1, keysSet});\\n            }\\n            dataMap[key] = dataList.begin(); // update the key reference\\n            \\n        } else { // key already exist in the map \\n            auto currentPos = dataMap[key];\\n            int incrementedValue = currentPos->first + 1;\\n            auto nextPos = next(currentPos, 1);\\n            currentPos->second.erase(key); // delete key from the currentPos as we have incremented its value\\n\\n            if(currentPos->second.size() == 0) { // if that was the only key in the list node then remove that node also\\n                dataList.erase(currentPos);\\n            }\\n            if(nextPos != dataList.end() && incrementedValue == nextPos->first) { // key\\'s new incremented value is already there in the list so just need to insert the key in the list node\\n                nextPos->second.insert(key);\\n                dataMap[key] = nextPos;\\n            } else { // need to create a new list node\\n                unordered_set<string> keysSet = { key };\\n                auto newPos = dataList.insert(nextPos, {incrementedValue, keysSet});\\n                dataMap[key] = newPos;\\n            }\\n        }\\n    }\\n    \\n    void dec(string key) {\\n        if(dataMap.find(key) != dataMap.end()) { // key exist in the map\\n            auto currentPos = dataMap[key];\\n            int decrementedValue = currentPos->first - 1;\\n            list<pair<int, unordered_set<string>>>::iterator prevPos;\\n            bool isStartOfList = true;\\n            if(currentPos != dataList.begin()) {\\n                prevPos = next(currentPos, -1);\\n                isStartOfList = false;\\n            }\\n            currentPos->second.erase(key); //delete key from the currentPos as we have decremented its value\\n            auto nextPos = next(currentPos, 1);\\n            bool isCurrentPosDeleted = false;\\n            if(currentPos->second.size() == 0) { // if that was the only key in the list node then remove that node also\\n                dataList.erase(currentPos);\\n                isCurrentPosDeleted = true;\\n            }\\n            if(decrementedValue == 0) { // if new key value is 0 then remove it from the map also\\n                dataMap.erase(key);\\n            } else if(!isStartOfList && prevPos->first == decrementedValue) { // decremented value already exist in list so only need to insert the key to the list node\\n                prevPos->second.insert(key);\\n                dataMap[key] = prevPos;\\n            } else { // need to create a new list node\\n                unordered_set<string> keysSet;\\n                keysSet.insert(key);\\n                list<pair<int, unordered_set<string>>>::iterator insertBeforeItr;\\n                if(isCurrentPosDeleted) {\\n                    insertBeforeItr = nextPos;\\n                } else {\\n                    insertBeforeItr = currentPos;\\n                }\\n                auto newPos = dataList.insert(insertBeforeItr, {decrementedValue, keysSet});\\n                dataMap[key] = newPos;\\n            }\\n\\n        }\\n    }\\n    \\n    string getMaxKey() {\\n        if(dataList.size()) {\\n            return (*(dataList.rbegin()->second).begin()); // list end node\\n        }\\n        return \"\";\\n    }\\n    \\n    string getMinKey() {\\n        if(dataList.size()) {\\n            return (*(dataList.begin()->second).begin()); //list first node\\n        }\\n        return \"\";\\n    }\\nprivate:\\n    list<pair<int, unordered_set<string>>> dataList;\\n    unordered_map<string, list<pair<int, unordered_set<string>>>::iterator> dataMap;\\n};\\n\\n/**\\n * Your AllOne object will be instantiated and called as such:\\n * AllOne* obj = new AllOne();\\n * obj->inc(key);\\n * obj->dec(key);\\n * string param_3 = obj->getMaxKey();\\n * string param_4 = obj->getMinKey();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2428815,
                "title": "c-very-easy-code-with-explanation-hashmap-70-faster",
                "content": "Please Upvote :)\\n\\n```\\nclass AllOne {\\npublic:\\n    unordered_map<string,int> m;// store string -> val\\n    map<int,unordered_set<string>> mp;// val -> set of strings with value as val \\n    AllOne() {\\n        \\n    }\\n    \\n    void inc(string key) {\\n        if(m.find(key)==m.end())\\n        {\\n            m[key]=1;\\n            mp[1].insert(key);\\n        }\\n        else\\n        {\\n            int p=m[key];\\n            m[key]=p+1;\\n            // remove key from p and add to p+1\\n            mp[p].erase(key);\\n            if(mp[p].size()==0)\\n                mp.erase(p);\\n            mp[p+1].insert(key);\\n        }\\n    }\\n    \\n    void dec(string key) {\\n        int p=m[key];\\n        if(p==1)\\n        {\\n            m.erase(key);\\n            mp[p].erase(key);\\n            if(mp[p].size()==0)\\n                mp.erase(p);\\n        }\\n        else\\n        {\\n            m[key]=p-1;\\n            // remove key from p and add to p-1\\n            mp[p].erase(key);\\n            if(mp[p].size()==0)\\n                mp.erase(p);\\n            mp[p-1].insert(key);\\n        }\\n    }\\n    \\n    string getMaxKey() {\\n        string s=\"\";\\n        if(mp.size())\\n        {\\n            // last element (max count key) of map is a set, taking first element of set\\n            auto p=mp.rbegin()->second.begin();\\n            s=*p;\\n        }\\n        return s;\\n    }\\n    \\n    string getMinKey() {\\n        string s=\"\";\\n        if(mp.size())\\n        {\\n            // first element (min count key) of map is a set, taking first element of set\\n            auto p=mp.begin()->second.begin();\\n            s=*p;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass AllOne {\\npublic:\\n    unordered_map<string,int> m;// store string -> val\\n    map<int,unordered_set<string>> mp;// val -> set of strings with value as val \\n    AllOne() {\\n        \\n    }\\n    \\n    void inc(string key) {\\n        if(m.find(key)==m.end())\\n        {\\n            m[key]=1;\\n            mp[1].insert(key);\\n        }\\n        else\\n        {\\n            int p=m[key];\\n            m[key]=p+1;\\n            // remove key from p and add to p+1\\n            mp[p].erase(key);\\n            if(mp[p].size()==0)\\n                mp.erase(p);\\n            mp[p+1].insert(key);\\n        }\\n    }\\n    \\n    void dec(string key) {\\n        int p=m[key];\\n        if(p==1)\\n        {\\n            m.erase(key);\\n            mp[p].erase(key);\\n            if(mp[p].size()==0)\\n                mp.erase(p);\\n        }\\n        else\\n        {\\n            m[key]=p-1;\\n            // remove key from p and add to p-1\\n            mp[p].erase(key);\\n            if(mp[p].size()==0)\\n                mp.erase(p);\\n            mp[p-1].insert(key);\\n        }\\n    }\\n    \\n    string getMaxKey() {\\n        string s=\"\";\\n        if(mp.size())\\n        {\\n            // last element (max count key) of map is a set, taking first element of set\\n            auto p=mp.rbegin()->second.begin();\\n            s=*p;\\n        }\\n        return s;\\n    }\\n    \\n    string getMinKey() {\\n        string s=\"\";\\n        if(mp.size())\\n        {\\n            // first element (min count key) of map is a set, taking first element of set\\n            auto p=mp.begin()->second.begin();\\n            s=*p;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2176184,
                "title": "c-using-hashmap-doubly-linked-list-o-1",
                "content": "```\\n/* \\n    Time: O(1)\\n    Space: O(n)\\n    Tag: Linked List, Hashing\\n    Difficulty: H\\n*/\\n\\nclass AllOne {\\n    unordered_map<string, pair<list<string>::iterator, int>> freq;\\n    unordered_map<int, list<string>> lists;\\n    list<int> count;\\n    unordered_map<int, list<int>::iterator> countExists;\\n\\npublic:\\n    AllOne() {\\n    }\\n\\n    void inc(string key) {\\n        if (freq.find(key) == freq.end()) {\\n            lists[1].push_back(key);\\n            freq[key] = {prev(lists[1].end()), 1};\\n            if (countExists.find(1) == countExists.end()) {\\n                count.push_front(1);\\n                countExists[1] = count.begin();\\n            }\\n            return;\\n        }\\n\\n        int oldFreq = freq[key].second;\\n        lists[oldFreq].erase(freq[key].first);\\n        lists[oldFreq + 1].push_back(key);\\n        freq[key] = {prev(lists[oldFreq + 1].end()), oldFreq + 1};\\n        if (countExists.find(oldFreq + 1) == countExists.end()) {\\n            auto it = countExists[oldFreq];\\n            count.insert(++it, oldFreq + 1);\\n            it = countExists[oldFreq];\\n            countExists[oldFreq + 1] = ++it;\\n        }\\n        if (lists[oldFreq].empty()) {\\n            count.erase(countExists[oldFreq]);\\n            countExists.erase(oldFreq);\\n        }\\n    }\\n\\n    void dec(string key) {\\n        int oldFreq = freq[key].second;\\n        lists[oldFreq].erase(freq[key].first);\\n        if (oldFreq == 1) {\\n            freq.erase(key);\\n            if (lists[1].empty()) {\\n                count.erase(countExists[1]);\\n                countExists.erase(1);\\n            }\\n        } else {\\n            lists[oldFreq - 1].push_back(key);\\n            freq[key] = {prev(lists[oldFreq - 1].end()), oldFreq - 1};\\n            if (countExists.find(oldFreq - 1) == countExists.end()) {\\n                auto it = countExists[oldFreq];\\n                count.insert(it, oldFreq - 1);\\n                it = countExists[oldFreq];\\n                countExists[oldFreq - 1] = --it;\\n            }\\n            if (lists[oldFreq].empty()) {\\n                count.erase(countExists[oldFreq]);\\n                countExists.erase(oldFreq);\\n            }\\n        }\\n    }\\n\\n    string getMaxKey() {\\n        if (count.empty()) return \"\";\\n        return lists[count.back()].back();\\n    }\\n\\n    string getMinKey() {\\n        if (count.empty()) return \"\";\\n        return lists[count.front()].back();\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List"
                ],
                "code": "```\\n/* \\n    Time: O(1)\\n    Space: O(n)\\n    Tag: Linked List, Hashing\\n    Difficulty: H\\n*/\\n\\nclass AllOne {\\n    unordered_map<string, pair<list<string>::iterator, int>> freq;\\n    unordered_map<int, list<string>> lists;\\n    list<int> count;\\n    unordered_map<int, list<int>::iterator> countExists;\\n\\npublic:\\n    AllOne() {\\n    }\\n\\n    void inc(string key) {\\n        if (freq.find(key) == freq.end()) {\\n            lists[1].push_back(key);\\n            freq[key] = {prev(lists[1].end()), 1};\\n            if (countExists.find(1) == countExists.end()) {\\n                count.push_front(1);\\n                countExists[1] = count.begin();\\n            }\\n            return;\\n        }\\n\\n        int oldFreq = freq[key].second;\\n        lists[oldFreq].erase(freq[key].first);\\n        lists[oldFreq + 1].push_back(key);\\n        freq[key] = {prev(lists[oldFreq + 1].end()), oldFreq + 1};\\n        if (countExists.find(oldFreq + 1) == countExists.end()) {\\n            auto it = countExists[oldFreq];\\n            count.insert(++it, oldFreq + 1);\\n            it = countExists[oldFreq];\\n            countExists[oldFreq + 1] = ++it;\\n        }\\n        if (lists[oldFreq].empty()) {\\n            count.erase(countExists[oldFreq]);\\n            countExists.erase(oldFreq);\\n        }\\n    }\\n\\n    void dec(string key) {\\n        int oldFreq = freq[key].second;\\n        lists[oldFreq].erase(freq[key].first);\\n        if (oldFreq == 1) {\\n            freq.erase(key);\\n            if (lists[1].empty()) {\\n                count.erase(countExists[1]);\\n                countExists.erase(1);\\n            }\\n        } else {\\n            lists[oldFreq - 1].push_back(key);\\n            freq[key] = {prev(lists[oldFreq - 1].end()), oldFreq - 1};\\n            if (countExists.find(oldFreq - 1) == countExists.end()) {\\n                auto it = countExists[oldFreq];\\n                count.insert(it, oldFreq - 1);\\n                it = countExists[oldFreq];\\n                countExists[oldFreq - 1] = --it;\\n            }\\n            if (lists[oldFreq].empty()) {\\n                count.erase(countExists[oldFreq]);\\n                countExists.erase(oldFreq);\\n            }\\n        }\\n    }\\n\\n    string getMaxKey() {\\n        if (count.empty()) return \"\";\\n        return lists[count.back()].back();\\n    }\\n\\n    string getMinKey() {\\n        if (count.empty()) return \"\";\\n        return lists[count.front()].back();\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1721653,
                "title": "c-dll-hashmap-no-inbuilt-list-custom-linked-list-easiest-to-understand",
                "content": "This is just the raw implementation with custom struct, without using inbuilt linked list. \\n\\n```\\nclass AllOne {\\npublic:\\n    \\n    struct Node{\\n        int count; \\n        Node* prev; \\n        Node* next; \\n        unordered_set<string> keys; \\n        Node(){\\n            count = 0, prev = NULL, next = NULL; \\n        }\\n    };\\n    \\n    Node* dummyHead = new Node(); \\n    Node* tail = dummyHead; \\n    unordered_map<string, Node*> mp; \\n    \\n    AllOne() {\\n        \\n    }\\n    \\n    void inc(string key) {\\n        if(!mp.count(key)){\\n            if(dummyHead->next && (dummyHead->next->count == 1)) {\\n                dummyHead->next->keys.insert(key); \\n            }\\n            else {\\n                Node* currHead = dummyHead->next; \\n                Node* newHead = new Node(); \\n                newHead->count = 1, newHead->keys.insert(key); \\n                newHead->prev = dummyHead, newHead->next = currHead, dummyHead->next = newHead; \\n                if(currHead) currHead->prev = newHead; \\n                else tail = newHead; \\n            }\\n            mp[key] = dummyHead->next; \\n        }\\n        else {\\n            Node* currNode = mp[key]; \\n            if(currNode->next && (currNode->next->count == currNode->count + 1)){\\n                mp[key] = currNode->next; \\n                currNode->next->keys.insert(key); \\n            }\\n            else{\\n                Node* newNode = new Node(); \\n                newNode->count = currNode->count +1; \\n                newNode->keys.insert(key); \\n                mp[key] = newNode; \\n                newNode->next = currNode->next; \\n                newNode->prev = currNode; \\n                currNode->next = newNode; \\n                if(newNode->next) newNode->next->prev = newNode; \\n                else tail = newNode; \\n            }\\n            // removal\\n            \\n            currNode->keys.erase(key); \\n            if(currNode->keys.size() == 0){\\n                if(currNode->prev == NULL) cout << currNode->count << \" \"; \\n                currNode->prev->next = currNode->next; \\n                if(currNode->next) currNode->next->prev = currNode->prev; \\n                else tail = tail->prev; \\n                currNode->next = NULL, currNode->prev = NULL ;\\n            }\\n        }\\n    }\\n    \\n    void dec(string key) {\\n        Node* currNode = mp[key]; \\n        \\n        if(currNode->count - 1 != 0){\\n            if(currNode->prev->count == currNode->count - 1){\\n                currNode->prev->keys.insert(key); \\n                mp[key] = currNode->prev; \\n            }\\n            else {\\n                Node* newNode = new Node(); \\n                newNode->count = currNode->count - 1; \\n                newNode->keys.insert(key); \\n                mp[key] = newNode; \\n                newNode->next = currNode; \\n                currNode->prev->next = newNode; \\n                newNode->prev = currNode->prev; \\n                currNode->prev = newNode; \\n            }\\n        }\\n        else mp.erase(key); \\n        \\n        // removal\\n        currNode->keys.erase(key); \\n        if(currNode->keys.size() == 0){\\n            currNode->prev->next = currNode->next; \\n            if(currNode->next) currNode->next->prev = currNode->prev; \\n            else tail = tail->prev; \\n            currNode->next = NULL, currNode->prev = NULL ;\\n        }\\n    }\\n    \\n    string getMaxKey() {\\n        if(tail == dummyHead) return \"\"; \\n        return *tail->keys.begin(); \\n    }\\n    \\n    string getMinKey() {\\n        if(!dummyHead->next) return \"\"; \\n        return *dummyHead->next->keys.begin(); \\n    }\\n};\\n\\n/**\\n * Your AllOne object will be instantiated and called as such:\\n * AllOne* obj = new AllOne();\\n * obj->inc(key);\\n * obj->dec(key);\\n * string param_3 = obj->getMaxKey();\\n * string param_4 = obj->getMinKey();\\n */\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass AllOne {\\npublic:\\n    \\n    struct Node{\\n        int count; \\n        Node* prev; \\n        Node* next; \\n        unordered_set<string> keys; \\n        Node(){\\n            count = 0, prev = NULL, next = NULL; \\n        }\\n    };\\n    \\n    Node* dummyHead = new Node(); \\n    Node* tail = dummyHead; \\n    unordered_map<string, Node*> mp; \\n    \\n    AllOne() {\\n        \\n    }\\n    \\n    void inc(string key) {\\n        if(!mp.count(key)){\\n            if(dummyHead->next && (dummyHead->next->count == 1)) {\\n                dummyHead->next->keys.insert(key); \\n            }\\n            else {\\n                Node* currHead = dummyHead->next; \\n                Node* newHead = new Node(); \\n                newHead->count = 1, newHead->keys.insert(key); \\n                newHead->prev = dummyHead, newHead->next = currHead, dummyHead->next = newHead; \\n                if(currHead) currHead->prev = newHead; \\n                else tail = newHead; \\n            }\\n            mp[key] = dummyHead->next; \\n        }\\n        else {\\n            Node* currNode = mp[key]; \\n            if(currNode->next && (currNode->next->count == currNode->count + 1)){\\n                mp[key] = currNode->next; \\n                currNode->next->keys.insert(key); \\n            }\\n            else{\\n                Node* newNode = new Node(); \\n                newNode->count = currNode->count +1; \\n                newNode->keys.insert(key); \\n                mp[key] = newNode; \\n                newNode->next = currNode->next; \\n                newNode->prev = currNode; \\n                currNode->next = newNode; \\n                if(newNode->next) newNode->next->prev = newNode; \\n                else tail = newNode; \\n            }\\n            // removal\\n            \\n            currNode->keys.erase(key); \\n            if(currNode->keys.size() == 0){\\n                if(currNode->prev == NULL) cout << currNode->count << \" \"; \\n                currNode->prev->next = currNode->next; \\n                if(currNode->next) currNode->next->prev = currNode->prev; \\n                else tail = tail->prev; \\n                currNode->next = NULL, currNode->prev = NULL ;\\n            }\\n        }\\n    }\\n    \\n    void dec(string key) {\\n        Node* currNode = mp[key]; \\n        \\n        if(currNode->count - 1 != 0){\\n            if(currNode->prev->count == currNode->count - 1){\\n                currNode->prev->keys.insert(key); \\n                mp[key] = currNode->prev; \\n            }\\n            else {\\n                Node* newNode = new Node(); \\n                newNode->count = currNode->count - 1; \\n                newNode->keys.insert(key); \\n                mp[key] = newNode; \\n                newNode->next = currNode; \\n                currNode->prev->next = newNode; \\n                newNode->prev = currNode->prev; \\n                currNode->prev = newNode; \\n            }\\n        }\\n        else mp.erase(key); \\n        \\n        // removal\\n        currNode->keys.erase(key); \\n        if(currNode->keys.size() == 0){\\n            currNode->prev->next = currNode->next; \\n            if(currNode->next) currNode->next->prev = currNode->prev; \\n            else tail = tail->prev; \\n            currNode->next = NULL, currNode->prev = NULL ;\\n        }\\n    }\\n    \\n    string getMaxKey() {\\n        if(tail == dummyHead) return \"\"; \\n        return *tail->keys.begin(); \\n    }\\n    \\n    string getMinKey() {\\n        if(!dummyHead->next) return \"\"; \\n        return *dummyHead->next->keys.begin(); \\n    }\\n};\\n\\n/**\\n * Your AllOne object will be instantiated and called as such:\\n * AllOne* obj = new AllOne();\\n * obj->inc(key);\\n * obj->dec(key);\\n * string param_3 = obj->getMaxKey();\\n * string param_4 = obj->getMinKey();\\n */\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1651228,
                "title": "java-simple-and-short-inc-dec-o-1-max-min-o-logn-treemap",
                "content": "```\\nclass AllOne {\\n    \\n    private final Map<String, Integer> keyToCount = new HashMap<>();\\n    private final TreeMap<Integer, Set<String>> countToKey = new TreeMap<>();\\n\\n    public AllOne() {\\n    }\\n    \\n    public void inc(String key) {\\n        var count = keyToCount.merge(key, 1, Integer::sum);\\n        moveWord(count, count - 1, key);\\n    }\\n    \\n    public void dec(String key) {\\n        var count = keyToCount.merge(key, -1, Integer::sum);\\n        if (count == 0)\\n            keyToCount.remove(key);\\n        \\n        moveWord(count, count + 1, key);\\n    }\\n    \\n    public String getMaxKey() {\\n        return countToKey.isEmpty() ? \"\" : countToKey.lastEntry().getValue().iterator().next();\\n    }\\n    \\n    public String getMinKey() {\\n        return countToKey.isEmpty() ? \"\" : countToKey.firstEntry().getValue().iterator().next();\\n    }\\n    \\n    private void moveWord(int nextCount, int prevCount, String key) {\\n        if (nextCount != 0)\\n            countToKey.computeIfAbsent(nextCount, v -> new HashSet<>()).add(key);\\n\\n        if (prevCount != 0) {\\n            var keys = countToKey.get(prevCount);\\n            if (keys.size() == 1)\\n                countToKey.remove(prevCount);\\n            else\\n                keys.remove(key);\\n        }\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```\\nclass AllOne {\\n    \\n    private final Map<String, Integer> keyToCount = new HashMap<>();\\n    private final TreeMap<Integer, Set<String>> countToKey = new TreeMap<>();\\n\\n    public AllOne() {\\n    }\\n    \\n    public void inc(String key) {\\n        var count = keyToCount.merge(key, 1, Integer::sum);\\n        moveWord(count, count - 1, key);\\n    }\\n    \\n    public void dec(String key) {\\n        var count = keyToCount.merge(key, -1, Integer::sum);\\n        if (count == 0)\\n            keyToCount.remove(key);\\n        \\n        moveWord(count, count + 1, key);\\n    }\\n    \\n    public String getMaxKey() {\\n        return countToKey.isEmpty() ? \"\" : countToKey.lastEntry().getValue().iterator().next();\\n    }\\n    \\n    public String getMinKey() {\\n        return countToKey.isEmpty() ? \"\" : countToKey.firstEntry().getValue().iterator().next();\\n    }\\n    \\n    private void moveWord(int nextCount, int prevCount, String key) {\\n        if (nextCount != 0)\\n            countToKey.computeIfAbsent(nextCount, v -> new HashSet<>()).add(key);\\n\\n        if (prevCount != 0) {\\n            var keys = countToKey.get(prevCount);\\n            if (keys.size() == 1)\\n                countToKey.remove(prevCount);\\n            else\\n                keys.remove(key);\\n        }\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1645161,
                "title": "simplest-solution-hashmap-heap-cpp-solution",
                "content": "```\\n   AllOne() {\\n        \\n    }\\n    priority_queue<pair<int,string>>mxh;\\n    priority_queue <pair<int,string>, vector<pair<int,string>>, greater<pair<int,string>>>mnh;\\n    map<string,int>mp;\\n    void inc(string key) {\\n        mp[key]++;\\n        mxh.push({mp[key],key});\\n         mnh.push({mp[key],key});\\n    }\\n    \\n    void dec(string key) {\\n        mp[key]--;\\n        if(mp[key]==0){\\n            mp.erase(key);\\n            return;\\n        }\\n        mxh.push({mp[key],key});\\n         mnh.push({mp[key],key});\\n    }\\n    \\n    string getMaxKey() {\\n        while(mxh.size()!=0){\\n            if(mp[mxh.top().second]==mxh.top().first){\\n                return mxh.top().second;\\n            }\\n            mxh.pop();\\n        }\\n        return \"\";\\n    }\\n    \\n    string getMinKey() {\\n       while(mnh.size()!=0){\\n            if(mp[mnh.top().second]==mnh.top().first){\\n                return mnh.top().second;\\n            }\\n            mnh.pop();\\n        }\\n        return \"\";\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n   AllOne() {\\n        \\n    }\\n    priority_queue<pair<int,string>>mxh;\\n    priority_queue <pair<int,string>, vector<pair<int,string>>, greater<pair<int,string>>>mnh;\\n    map<string,int>mp;\\n    void inc(string key) {\\n        mp[key]++;\\n        mxh.push({mp[key],key});\\n         mnh.push({mp[key],key});\\n    }\\n    \\n    void dec(string key) {\\n        mp[key]--;\\n        if(mp[key]==0){\\n            mp.erase(key);\\n            return;\\n        }\\n        mxh.push({mp[key],key});\\n         mnh.push({mp[key],key});\\n    }\\n    \\n    string getMaxKey() {\\n        while(mxh.size()!=0){\\n            if(mp[mxh.top().second]==mxh.top().first){\\n                return mxh.top().second;\\n            }\\n            mxh.pop();\\n        }\\n        return \"\";\\n    }\\n    \\n    string getMinKey() {\\n       while(mnh.size()!=0){\\n            if(mp[mnh.top().second]==mnh.top().first){\\n                return mnh.top().second;\\n            }\\n            mnh.pop();\\n        }\\n        return \"\";\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1640963,
                "title": "c-using-map",
                "content": "```\\nclass AllOne {\\npublic:\\n    unordered_map<string, int> freq;\\n    map<int, unordered_set<string>> rev;\\n    AllOne() {\\n        \\n    }\\n    \\n    void inc(string key) {\\n        if(freq[key] != 0){\\n            rev[freq[key]].erase(key);\\n            if(rev[freq[key]].size() == 0) rev.erase(freq[key]);\\n        }\\n        freq[key]++;\\n        rev[freq[key]].insert(key);\\n    }\\n    \\n    void dec(string key) {\\n        rev[freq[key]].erase(key);\\n        if(rev[freq[key]].size() == 0) rev.erase(freq[key]);\\n\\n        freq[key]--;\\n        if(freq[key] != 0){\\n            rev[freq[key]].insert(key);\\n        }\\n    }\\n    \\n    string getMaxKey() {\\n        if(rev.size() == 0) return \"\";\\n        return *rev.rbegin()->second.begin();\\n    }\\n    \\n    string getMinKey() {\\n        if(rev.size() == 0) return \"\";\\n        return *rev.begin()->second.begin();\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass AllOne {\\npublic:\\n    unordered_map<string, int> freq;\\n    map<int, unordered_set<string>> rev;\\n    AllOne() {\\n        \\n    }\\n    \\n    void inc(string key) {\\n        if(freq[key] != 0){\\n            rev[freq[key]].erase(key);\\n            if(rev[freq[key]].size() == 0) rev.erase(freq[key]);\\n        }\\n        freq[key]++;\\n        rev[freq[key]].insert(key);\\n    }\\n    \\n    void dec(string key) {\\n        rev[freq[key]].erase(key);\\n        if(rev[freq[key]].size() == 0) rev.erase(freq[key]);\\n\\n        freq[key]--;\\n        if(freq[key] != 0){\\n            rev[freq[key]].insert(key);\\n        }\\n    }\\n    \\n    string getMaxKey() {\\n        if(rev.size() == 0) return \"\";\\n        return *rev.rbegin()->second.begin();\\n    }\\n    \\n    string getMinKey() {\\n        if(rev.size() == 0) return \"\";\\n        return *rev.begin()->second.begin();\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1564304,
                "title": "javascript-ordered-map-204ms-100",
                "content": "```\\nconst stmvalue_in = (m) => new Map([...m].sort((x, y) => x[1] - y[1]));\\nconst stmvalue_de = (m) => new Map([...m].sort((x, y) => y[1] - x[1]));\\n\\nfunction AllOne () {\\n    let m = new Map();\\n    let preOp = \"start\"; // record pre operation\\n    return {inc, dec, getMaxKey, getMinKey};\\n    function inc (k) {\\n        m.set(k, m.get(k) + 1 || 1);\\n        preOp = \\'inc\\';\\n    }\\n    function dec (k) {\\n        let occ = m.get(k);\\n        occ == 1 ? m.delete(k): m.set(k, occ - 1);\\n        preOp = \\'dec\\';\\n    }\\n    function getMaxKey () {\\n       if (preOp != \\'max\\') m = stmvalue_de(m);\\n       preOp = \\'max\\';\\n       return m.keys().next().value || \\'\\';\\n    }\\n    function getMinKey () {\\n       if (preOp != \\'min\\') m = stmvalue_in(m);\\n       preOp = \\'min\\';\\n       return m.keys().next().value || \\'\\';;\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst stmvalue_in = (m) => new Map([...m].sort((x, y) => x[1] - y[1]));\\nconst stmvalue_de = (m) => new Map([...m].sort((x, y) => y[1] - x[1]));\\n\\nfunction AllOne () {\\n    let m = new Map();\\n    let preOp = \"start\"; // record pre operation\\n    return {inc, dec, getMaxKey, getMinKey};\\n    function inc (k) {\\n        m.set(k, m.get(k) + 1 || 1);\\n        preOp = \\'inc\\';\\n    }\\n    function dec (k) {\\n        let occ = m.get(k);\\n        occ == 1 ? m.delete(k): m.set(k, occ - 1);\\n        preOp = \\'dec\\';\\n    }\\n    function getMaxKey () {\\n       if (preOp != \\'max\\') m = stmvalue_de(m);\\n       preOp = \\'max\\';\\n       return m.keys().next().value || \\'\\';\\n    }\\n    function getMinKey () {\\n       if (preOp != \\'min\\') m = stmvalue_in(m);\\n       preOp = \\'min\\';\\n       return m.keys().next().value || \\'\\';;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1491158,
                "title": "c-88ms-97-simple-easy-small",
                "content": "Runtime: 88 ms, faster than 97.20% of C++ online submissions for All O`one Data Structure.\\nMemory Usage: 48.1 MB, less than 90.53% of C++ online submissions for All O`one Data Structure.\\n```\\nclass AllOne {\\npublic:\\n  set<pair<int,string>>st;\\n  unordered_map<string,int> table;\\n  \\n  void inc(string key) {\\n    if(table.count(key)) st.erase({table[key], key});\\n    st.insert({++table[key], key});\\n  }\\n    \\n  \\n  void dec(string key) {\\n    st.erase({table[key], key});\\n    if(--table[key] != 0) st.insert({table[key], key});\\n  }\\n    \\n  string getMaxKey() {\\n    return st.empty() ? \"\" : st.rbegin()->second;      \\n  }\\n    \\n  \\n  string getMinKey() {\\n    return st.empty() ? \"\" : st.begin()->second;    \\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass AllOne {\\npublic:\\n  set<pair<int,string>>st;\\n  unordered_map<string,int> table;\\n  \\n  void inc(string key) {\\n    if(table.count(key)) st.erase({table[key], key});\\n    st.insert({++table[key], key});\\n  }\\n    \\n  \\n  void dec(string key) {\\n    st.erase({table[key], key});\\n    if(--table[key] != 0) st.insert({table[key], key});\\n  }\\n    \\n  string getMaxKey() {\\n    return st.empty() ? \"\" : st.rbegin()->second;      \\n  }\\n    \\n  \\n  string getMinKey() {\\n    return st.empty() ? \"\" : st.begin()->second;    \\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1478527,
                "title": "simple-java-code-with-treemap-hashmap",
                "content": "```\\nclass AllOne {\\n    HashMap<String, Integer> map;\\n    TreeMap<Integer, HashSet<String>> minMaxMap;\\n    /** Initialize your data structure here. */\\n    public AllOne() {\\n        map = new HashMap();\\n        minMaxMap = new TreeMap();\\n    }\\n    \\n    /** Inserts a new key <Key> with value 1. Or increments an existing key by 1. */\\n    public void inc(String key) {\\n        if (!map.containsKey(key))\\n            map.put(key, 0);\\n        int newVal = map.get(key)+1;\\n        if (newVal > 1) {\\n            minMaxMap.get(newVal - 1).remove(key);\\n            if(minMaxMap.get(newVal -1).size() == 0)\\n                minMaxMap.remove(newVal -1);\\n        }\\n        \\n        map.put(key, newVal);\\n        \\n        if(!minMaxMap.containsKey(newVal))\\n            minMaxMap.put(newVal, new HashSet<String>());\\n        \\n        minMaxMap.get(newVal).add(key);\\n    }\\n    \\n    /** Decrements an existing key by 1. If Key\\'s value is 1, remove it from the data structure. */\\n    public void dec(String key) {\\n        int currentCount = map.get(key);\\n        \\n        if (map.containsKey(key) && map.get(key) == 1)\\n            map.remove(key);\\n        if (map.containsKey(key))\\n            map.put(key, map.get(key)-1);\\n        \\n         minMaxMap.get(currentCount).remove(key);\\n         if (minMaxMap.get(currentCount).size() == 0)\\n             minMaxMap.remove(currentCount);\\n        \\n         if(currentCount > 1) {\\n             if(!minMaxMap.containsKey(currentCount-1))\\n                 minMaxMap.put(currentCount-1, new HashSet<String>());\\n             minMaxMap.get(currentCount-1).add(key);\\n         }         \\n    }\\n    \\n    /** Returns one of the keys with maximal value. */\\n    public String getMaxKey() {\\n        Map.Entry<Integer,HashSet<String>> entry =  minMaxMap.lastEntry();\\n       // System.out.println(\"GetMax Key \"+ entry.getKey() + \" \" + entry.getValue());\\n        if(entry == null)\\n            return \"\";\\n        HashSet<String> s = entry.getValue();\\n        if (s == null || s.isEmpty())\\n            return \"\";\\n        else \\n            return s.stream().findFirst().get();\\n    }\\n    \\n    /** Returns one of the keys with Minimal value. */\\n    public String getMinKey() {\\n        Map.Entry<Integer,HashSet<String>> entry =  minMaxMap.firstEntry();\\n       // System.out.println(\"GetMin Key \"+ entry.getKey() + \" \" + entry.getValue());\\n         if(entry == null)\\n            return \"\";\\n        HashSet<String> s = entry.getValue();\\n        if (s == null || s.isEmpty())\\n            return \"\";\\n        else \\n            return s.stream().findFirst().get();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass AllOne {\\n    HashMap<String, Integer> map;\\n    TreeMap<Integer, HashSet<String>> minMaxMap;\\n    /** Initialize your data structure here. */\\n    public AllOne() {\\n        map = new HashMap();\\n        minMaxMap = new TreeMap();\\n    }\\n    \\n    /** Inserts a new key <Key> with value 1. Or increments an existing key by 1. */\\n    public void inc(String key) {\\n        if (!map.containsKey(key))\\n            map.put(key, 0);\\n        int newVal = map.get(key)+1;\\n        if (newVal > 1) {\\n            minMaxMap.get(newVal - 1).remove(key);\\n            if(minMaxMap.get(newVal -1).size() == 0)\\n                minMaxMap.remove(newVal -1);\\n        }\\n        \\n        map.put(key, newVal);\\n        \\n        if(!minMaxMap.containsKey(newVal))\\n            minMaxMap.put(newVal, new HashSet<String>());\\n        \\n        minMaxMap.get(newVal).add(key);\\n    }\\n    \\n    /** Decrements an existing key by 1. If Key\\'s value is 1, remove it from the data structure. */\\n    public void dec(String key) {\\n        int currentCount = map.get(key);\\n        \\n        if (map.containsKey(key) && map.get(key) == 1)\\n            map.remove(key);\\n        if (map.containsKey(key))\\n            map.put(key, map.get(key)-1);\\n        \\n         minMaxMap.get(currentCount).remove(key);\\n         if (minMaxMap.get(currentCount).size() == 0)\\n             minMaxMap.remove(currentCount);\\n        \\n         if(currentCount > 1) {\\n             if(!minMaxMap.containsKey(currentCount-1))\\n                 minMaxMap.put(currentCount-1, new HashSet<String>());\\n             minMaxMap.get(currentCount-1).add(key);\\n         }         \\n    }\\n    \\n    /** Returns one of the keys with maximal value. */\\n    public String getMaxKey() {\\n        Map.Entry<Integer,HashSet<String>> entry =  minMaxMap.lastEntry();\\n       // System.out.println(\"GetMax Key \"+ entry.getKey() + \" \" + entry.getValue());\\n        if(entry == null)\\n            return \"\";\\n        HashSet<String> s = entry.getValue();\\n        if (s == null || s.isEmpty())\\n            return \"\";\\n        else \\n            return s.stream().findFirst().get();\\n    }\\n    \\n    /** Returns one of the keys with Minimal value. */\\n    public String getMinKey() {\\n        Map.Entry<Integer,HashSet<String>> entry =  minMaxMap.firstEntry();\\n       // System.out.println(\"GetMin Key \"+ entry.getKey() + \" \" + entry.getValue());\\n         if(entry == null)\\n            return \"\";\\n        HashSet<String> s = entry.getValue();\\n        if (s == null || s.isEmpty())\\n            return \"\";\\n        else \\n            return s.stream().findFirst().get();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1419709,
                "title": "java-treemap-of-set-linkedin-likes-this-question",
                "content": "Manipulate Map. Hard part is to handle lots of situations where map or set is empty, or count is zero.\\n\\n```\\nclass AllOne {\\n\\n    /** Initialize your data structure here. */\\n    Map<String, Node> map; // str -> node\\n    TreeMap<Integer, Set<Node>> cntMap; // Count : Set<Node>\\n    public AllOne() {\\n        map = new HashMap<>();\\n        cntMap = new TreeMap<>();\\n    }\\n    \\n    /** Inserts a new key <Key> with value 1. Or increments an existing key by 1. */\\n    public void inc(String key) {\\n        // Get the node\\n        Node cur = null;\\n        if (map.containsKey(key)) {\\n            cur = map.get(key);\\n        } else {\\n            cur = new Node(key);\\n            map.put(key, cur); // NOTE-1: Don\\'t forget to add new Node to map!\\n        } \\n        \\n        // remove from old cntMap->oldCnt\\n        int oldCnt = cur.count;\\n        if (cntMap.containsKey(oldCnt)) { // NOTE-2: oldCnt can be zero\\n            cntMap.get(oldCnt).remove(cur);\\n            if (cntMap.get(oldCnt).size() == 0) { // NOTE-3: When set is empty, delete from map!\\n                cntMap.remove(oldCnt);\\n            }\\n        }\\n        \\n        // add into cntMap->newCnt\\n        cur.count += 1;\\n        int newCnt = cur.count;\\n        if (!cntMap.containsKey(newCnt)) \\n            cntMap.put(newCnt, new HashSet<>());\\n        cntMap.get(newCnt).add(cur);\\n    \\n        //System.out.println(cntMap);\\n    }\\n    \\n    /** Decrements an existing key by 1. If Key\\'s value is 1, remove it from the data structure. */\\n    public void dec(String key) {\\n        Node cur = map.get(key);\\n        \\n        // Remove\\n        int oldCnt = cur.count;\\n        if (!cntMap.containsKey(oldCnt)) {\\n            throw new NullPointerException(); // Handle exception if needed\\n        }\\n        cntMap.get(oldCnt).remove(cur);\\n        if (cntMap.get(oldCnt).size() == 0) { // NOTE-3: When set is empty, delete from map!\\n            cntMap.remove(oldCnt);\\n        }\\n          \\n        cur.count--;\\n        \\n        // Add\\n        int newCnt = cur.count;\\n        // NOTE-4: Need to consider th newCnt == 0 situation. If zero, don\\'t add!\\n        if (!cntMap.containsKey(newCnt) && newCnt != 0) {\\n            cntMap.put(newCnt, new HashSet<>());\\n        }\\n\\n        if (newCnt != 0) cntMap.get(newCnt).add(cur);\\n    }\\n    \\n    /** Returns one of the keys with maximal value. */\\n    public String getMaxKey() {\\n        if (cntMap.size() == 0) return \"\";\\n        int count = cntMap.lastKey();\\n        return cntMap.get(count).iterator().next().str;\\n    }\\n    \\n    /** Returns one of the keys with Minimal value. */\\n    public String getMinKey() {\\n        if (cntMap.size() == 0) return \"\";\\n        int count = cntMap.firstKey();\\n        return cntMap.get(count).iterator().next().str;\\n    }\\n}\\n\\nclass Node {\\n    String str;\\n    int count;\\n    Node(String str) {\\n        this.str = str;\\n    }\\n}\\n\\n/**\\n * Your AllOne object will be instantiated and called as such:\\n * AllOne obj = new AllOne();\\n * obj.inc(key);\\n * obj.dec(key);\\n * String param_3 = obj.getMaxKey();\\n * String param_4 = obj.getMinKey();\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass AllOne {\\n\\n    /** Initialize your data structure here. */\\n    Map<String, Node> map; // str -> node\\n    TreeMap<Integer, Set<Node>> cntMap; // Count : Set<Node>\\n    public AllOne() {\\n        map = new HashMap<>();\\n        cntMap = new TreeMap<>();\\n    }\\n    \\n    /** Inserts a new key <Key> with value 1. Or increments an existing key by 1. */\\n    public void inc(String key) {\\n        // Get the node\\n        Node cur = null;\\n        if (map.containsKey(key)) {\\n            cur = map.get(key);\\n        } else {\\n            cur = new Node(key);\\n            map.put(key, cur); // NOTE-1: Don\\'t forget to add new Node to map!\\n        } \\n        \\n        // remove from old cntMap->oldCnt\\n        int oldCnt = cur.count;\\n        if (cntMap.containsKey(oldCnt)) { // NOTE-2: oldCnt can be zero\\n            cntMap.get(oldCnt).remove(cur);\\n            if (cntMap.get(oldCnt).size() == 0) { // NOTE-3: When set is empty, delete from map!\\n                cntMap.remove(oldCnt);\\n            }\\n        }\\n        \\n        // add into cntMap->newCnt\\n        cur.count += 1;\\n        int newCnt = cur.count;\\n        if (!cntMap.containsKey(newCnt)) \\n            cntMap.put(newCnt, new HashSet<>());\\n        cntMap.get(newCnt).add(cur);\\n    \\n        //System.out.println(cntMap);\\n    }\\n    \\n    /** Decrements an existing key by 1. If Key\\'s value is 1, remove it from the data structure. */\\n    public void dec(String key) {\\n        Node cur = map.get(key);\\n        \\n        // Remove\\n        int oldCnt = cur.count;\\n        if (!cntMap.containsKey(oldCnt)) {\\n            throw new NullPointerException(); // Handle exception if needed\\n        }\\n        cntMap.get(oldCnt).remove(cur);\\n        if (cntMap.get(oldCnt).size() == 0) { // NOTE-3: When set is empty, delete from map!\\n            cntMap.remove(oldCnt);\\n        }\\n          \\n        cur.count--;\\n        \\n        // Add\\n        int newCnt = cur.count;\\n        // NOTE-4: Need to consider th newCnt == 0 situation. If zero, don\\'t add!\\n        if (!cntMap.containsKey(newCnt) && newCnt != 0) {\\n            cntMap.put(newCnt, new HashSet<>());\\n        }\\n\\n        if (newCnt != 0) cntMap.get(newCnt).add(cur);\\n    }\\n    \\n    /** Returns one of the keys with maximal value. */\\n    public String getMaxKey() {\\n        if (cntMap.size() == 0) return \"\";\\n        int count = cntMap.lastKey();\\n        return cntMap.get(count).iterator().next().str;\\n    }\\n    \\n    /** Returns one of the keys with Minimal value. */\\n    public String getMinKey() {\\n        if (cntMap.size() == 0) return \"\";\\n        int count = cntMap.firstKey();\\n        return cntMap.get(count).iterator().next().str;\\n    }\\n}\\n\\nclass Node {\\n    String str;\\n    int count;\\n    Node(String str) {\\n        this.str = str;\\n    }\\n}\\n\\n/**\\n * Your AllOne object will be instantiated and called as such:\\n * AllOne obj = new AllOne();\\n * obj.inc(key);\\n * obj.dec(key);\\n * String param_3 = obj.getMaxKey();\\n * String param_4 = obj.getMinKey();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1260429,
                "title": "python-simple-and-concise-solution-list-of-sets-map",
                "content": "The idea is to store the keys in a list at indices equal to their counts. For example, if keys a, b, c all have count of 1, the set(a, b, c) will be stored at list[1].\\n```\\nclass AllOne:\\n\\n    def __init__(self):\\n        self.counts = collections.defaultdict(int)\\n        self.rank = [None]\\n\\n    def inc(self, key: str) -> None:\\n        self.counts[key] += 1\\n        n = self.counts[key]\\n        if n > 1:\\n            self.rank[n - 1].remove(key)\\n        if n == len(self.rank):\\n            set_ = set()\\n            set_.add(key)\\n            self.rank.append(set_)\\n        else:\\n            self.rank[n].add(key)\\n\\n    def dec(self, key: str) -> None:\\n        self.counts[key] -= 1\\n        n = self.counts[key]\\n        self.rank[n + 1].remove(key)\\n        if n + 2 == len(self.rank) and len(self.rank[n + 1]) == 0:\\n            self.rank.pop()\\n        if n > 0:\\n            self.rank[n].add(key)\\n\\n    def getMaxKey(self) -> str:\\n        e = \\'\\'\\n        if len(self.rank) == 1:\\n            return e\\n        for e in self.rank[-1]:\\n            break\\n        return e\\n        \\n    def getMinKey(self) -> str:\\n        e = \\'\\'\\n        if len(self.rank) == 1:\\n            return e\\n        i = 1\\n        while i < len(self.rank) - 1 and len(self.rank[i]) == 0:\\n            i += 1\\n        for e in self.rank[i]:\\n            break\\n        return e",
                "solutionTags": [],
                "code": "The idea is to store the keys in a list at indices equal to their counts. For example, if keys a, b, c all have count of 1, the set(a, b, c) will be stored at list[1].\\n```\\nclass AllOne:\\n\\n    def __init__(self):\\n        self.counts = collections.defaultdict(int)\\n        self.rank = [None]\\n\\n    def inc(self, key: str) -> None:\\n        self.counts[key] += 1\\n        n = self.counts[key]\\n        if n > 1:\\n            self.rank[n - 1].remove(key)\\n        if n == len(self.rank):\\n            set_ = set()\\n            set_.add(key)\\n            self.rank.append(set_)\\n        else:\\n            self.rank[n].add(key)\\n\\n    def dec(self, key: str) -> None:\\n        self.counts[key] -= 1\\n        n = self.counts[key]\\n        self.rank[n + 1].remove(key)\\n        if n + 2 == len(self.rank) and len(self.rank[n + 1]) == 0:\\n            self.rank.pop()\\n        if n > 0:\\n            self.rank[n].add(key)\\n\\n    def getMaxKey(self) -> str:\\n        e = \\'\\'\\n        if len(self.rank) == 1:\\n            return e\\n        for e in self.rank[-1]:\\n            break\\n        return e\\n        \\n    def getMinKey(self) -> str:\\n        e = \\'\\'\\n        if len(self.rank) == 1:\\n            return e\\n        i = 1\\n        while i < len(self.rank) - 1 and len(self.rank[i]) == 0:\\n            i += 1\\n        for e in self.rank[i]:\\n            break\\n        return e",
                "codeTag": "Java"
            },
            {
                "id": 1059478,
                "title": "python3-clean-code-doubly-linked-list-hash-table",
                "content": "The basic idea is to keep a hash table recoding the mapping from keys to the values, then another hash table recording the mapping from values to nodes in doubly-linked list. Each node will record the keys stored, and the corresponding value. \\n\\nWhen `inc()`, locate the node, remove the key from the keys stored in the node, increment value by 1, and add the key into the next node.\\n\\nWhen `dec()`, locate the node, remove the key from the keys stored in the node, decrement value by 1, and add the key into the previous node.\\n\\nThe doubly-linked list allowed us to insert and delete by O(1). For min and max operation, just look at the head and the tail of the linked list.\\n\\n```python\\nclass Node():\\n    def __init__(self, val):\\n        self.val = val\\n        self.keys = set()\\n        self.next = None\\n        self.prev = None\\n\\nclass AllOne:\\n\\n    def __init__(self):\\n        self.head = Node(float(\\'-inf\\'))\\n        self.tail = Node(float(\\'inf\\'))\\n        self.head.keys.add(\\'#\\')\\n        self.tail.keys.add(\\'#\\')\\n        self.head.next = self.tail\\n        self.tail.prev = self.head\\n        self.key2val = defaultdict(int)\\n        self.val2node = defaultdict(Node)\\n\\n    def insert_after(self, node, new_node):\\n        new_node.prev = node\\n        new_node.next = node.next\\n        node.next.prev = new_node\\n        node.next = new_node\\n    \\n    def insert_before(self, node, new_node):\\n        new_node.prev = node.prev\\n        new_node.next = node\\n        node.prev.next = new_node\\n        node.prev = new_node\\n        \\n    def remove(self, node):\\n        prev = node.prev\\n        nxt = node.next\\n        prev.next = nxt\\n        nxt.prev = prev\\n        \\n    def inc(self, key: str) -> None:\\n        if key in self.key2val:\\n            old_val = self.key2val[key]\\n            node = self.val2node[old_val]\\n            node.keys.remove(key)\\n            new_val = old_val + 1\\n        else:\\n            node = self.head\\n            new_val = 1\\n        \\n        if new_val != node.next.val:\\n            new_node = Node(new_val)\\n            self.insert_after(node, new_node)\\n        else:\\n            new_node = node.next\\n        new_node.keys.add(key)\\n\\n        if not node.keys:\\n            del self.val2node[node.val]\\n            self.remove(node)\\n        self.key2val[key] = new_val\\n        self.val2node[new_val] = new_node\\n\\n    def dec(self, key: str) -> None:\\n        if key not in self.key2val:\\n            return\\n\\n        old_val = self.key2val[key]\\n        node = self.val2node[old_val]\\n        node.keys.remove(key)\\n        del self.key2val[key]\\n        new_val = old_val - 1\\n        if new_val != 0:\\n            if new_val != node.prev.val:\\n                new_node = Node(new_val)\\n                self.insert_before(node, new_node)\\n            else:\\n                new_node = node.prev\\n            new_node.keys.add(key)\\n            self.key2val[key] = new_val\\n            self.val2node[new_val] = new_node\\n\\n        if not node.keys:\\n            del self.val2node[node.val]\\n            self.remove(node)\\n\\n    def getMaxKey(self) -> str:\\n        if self.tail.prev != self.head:\\n            return next(iter(self.tail.prev.keys))\\n        else:\\n            return \\'\\'\\n\\n    def getMinKey(self) -> str:\\n        if self.head.next != self.tail:\\n            return next(iter(self.head.next.keys))\\n        else:\\n            return \\'\\'\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Node():\\n    def __init__(self, val):\\n        self.val = val\\n        self.keys = set()\\n        self.next = None\\n        self.prev = None\\n\\nclass AllOne:\\n\\n    def __init__(self):\\n        self.head = Node(float(\\'-inf\\'))\\n        self.tail = Node(float(\\'inf\\'))\\n        self.head.keys.add(\\'#\\')\\n        self.tail.keys.add(\\'#\\')\\n        self.head.next = self.tail\\n        self.tail.prev = self.head\\n        self.key2val = defaultdict(int)\\n        self.val2node = defaultdict(Node)\\n\\n    def insert_after(self, node, new_node):\\n        new_node.prev = node\\n        new_node.next = node.next\\n        node.next.prev = new_node\\n        node.next = new_node\\n    \\n    def insert_before(self, node, new_node):\\n        new_node.prev = node.prev\\n        new_node.next = node\\n        node.prev.next = new_node\\n        node.prev = new_node\\n        \\n    def remove(self, node):\\n        prev = node.prev\\n        nxt = node.next\\n        prev.next = nxt\\n        nxt.prev = prev\\n        \\n    def inc(self, key: str) -> None:\\n        if key in self.key2val:\\n            old_val = self.key2val[key]\\n            node = self.val2node[old_val]\\n            node.keys.remove(key)\\n            new_val = old_val + 1\\n        else:\\n            node = self.head\\n            new_val = 1\\n        \\n        if new_val != node.next.val:\\n            new_node = Node(new_val)\\n            self.insert_after(node, new_node)\\n        else:\\n            new_node = node.next\\n        new_node.keys.add(key)\\n\\n        if not node.keys:\\n            del self.val2node[node.val]\\n            self.remove(node)\\n        self.key2val[key] = new_val\\n        self.val2node[new_val] = new_node\\n\\n    def dec(self, key: str) -> None:\\n        if key not in self.key2val:\\n            return\\n\\n        old_val = self.key2val[key]\\n        node = self.val2node[old_val]\\n        node.keys.remove(key)\\n        del self.key2val[key]\\n        new_val = old_val - 1\\n        if new_val != 0:\\n            if new_val != node.prev.val:\\n                new_node = Node(new_val)\\n                self.insert_before(node, new_node)\\n            else:\\n                new_node = node.prev\\n            new_node.keys.add(key)\\n            self.key2val[key] = new_val\\n            self.val2node[new_val] = new_node\\n\\n        if not node.keys:\\n            del self.val2node[node.val]\\n            self.remove(node)\\n\\n    def getMaxKey(self) -> str:\\n        if self.tail.prev != self.head:\\n            return next(iter(self.tail.prev.keys))\\n        else:\\n            return \\'\\'\\n\\n    def getMinKey(self) -> str:\\n        if self.head.next != self.tail:\\n            return next(iter(self.head.next.keys))\\n        else:\\n            return \\'\\'\\n```",
                "codeTag": "Java"
            },
            {
                "id": 966681,
                "title": "c-solution-explained-with-images-and-comments",
                "content": "This problem is like implementing an ARC memory manager, so I made an IG post about this! My approach is 100% constant on every operation.\\nhttps://www.instagram.com/p/CIm7rPiAocf/\\n\\n```\\nusing KeyT = std::string;\\nusing CountT = unsigned int;\\nusing KeyAndCountPairT = std::pair<KeyT, CountT>;\\nusing ListKeyAndCountPairIteratorT = std::list<KeyAndCountPairT>::iterator;\\nclass AllOne {\\npublic:\\n    \\n    \\n    /** Initialize your data structure here. */\\n    AllOne() {\\n        \\n    }\\n    \\n    /** Inserts a new key <Key> with value 1. Or increments an existing key by 1. */\\n    void inc(KeyT key) {\\n        CountT newCount = 1;\\n        ListKeyAndCountPairIteratorT listIterator;\\n        if (map.find(key) == map.end())\\n        {\\n            // Key was not found,  let\\'s add it\\n            list.push_front(std::make_pair(key, newCount));\\n            map[key] = list.begin();\\n            listIterator = list.begin(); \\n        }\\n        else\\n        {\\n            listIterator = map[key];\\n            CountT oldCount = listIterator->second;\\n            newCount = oldCount + 1;\\n            listIterator->second = newCount;\\n\\n            // We will now insert this updated element\\n            // to the right of the end of its oldCount\\n            // so i.e. if there\\'s \\n            // [(\"keyA\",2),( \"keyB\",2), (\"keyC\",2), (\"keyD\",3)], and we\\n            // are updating keyB, we would move it to here:\\n            //  [(\"keyA\",2), (\"keyC\",2), (\"keyB\",3), (\"keyD\",3)]\\n            auto lastCountsEndIterator = countsLast[oldCount];\\n            // Let\\'s insert next to this lastCountsEndInterator.\\n            lastCountsEndIterator++;\\n            auto newIterator = list.insert(lastCountsEndIterator, *listIterator);\\n\\n            // Now we have to update countsBegin and countsLast for the\\n            // old count\\n            if (listIterator == countsBegin[oldCount] && \\n                listIterator == countsLast[oldCount]) \\n            {\\n                countsBegin.erase(oldCount);\\n                countsLast.erase(oldCount);\\n            }\\n            else if (listIterator == countsBegin[oldCount])\\n            {\\n                auto copy = listIterator;\\n                countsBegin[oldCount] = ++copy;\\n            }\\n            else if (listIterator == countsLast[oldCount])\\n            {\\n                auto copy = listIterator;\\n                countsLast[oldCount] = --copy;\\n            }\\n            \\n            // We erase that element because it has the outdated count\\n            list.erase(listIterator);\\n            listIterator = newIterator;\\n            map[key] = listIterator;\\n            \\n            \\n        }\\n        // We have not kept track of this new count. Let\\'s\\n        // do it now\\n        if (countsBegin.find(newCount) == countsBegin.end())\\n        {\\n            countsBegin[newCount] = listIterator;\\n            countsLast[newCount] = listIterator;\\n        }\\n        else\\n        {\\n            countsBegin[newCount] = listIterator;   \\n        }\\n    }\\n    \\n    /** Decrements an existing key by 1. If Key\\'s value is 1, remove it from the data structure. */\\n    void dec(KeyT key) {\\n        CountT newCount, oldCount;\\n        ListKeyAndCountPairIteratorT listIterator, newListIterator;\\n        \\n        if (map.find(key) != map.end())\\n        {\\n            listIterator = map[key];\\n            \\n            oldCount = listIterator->second;\\n            newCount = oldCount - 1;\\n            listIterator->second = newCount;\\n            auto beginningOfOldCountIt = countsBegin[oldCount];\\n            \\n            if (countsBegin[oldCount] == countsLast[oldCount] )\\n            {\\n                // We will erase this element if the count decreased to 0\\n                countsBegin.erase(oldCount);\\n                countsLast.erase(oldCount);\\n            }\\n            else if (listIterator == countsBegin[oldCount])\\n            {\\n                auto copy = listIterator;\\n                countsBegin[oldCount] = ++copy;\\n            }\\n            else if (listIterator == countsLast[oldCount])\\n            {\\n                auto copy = listIterator;\\n                countsLast[oldCount] = --copy;\\n            }\\n\\n            if (newCount == 0)\\n            {\\n                // Erase it from everywhere\\n                map.erase(key);\\n            }\\n            else\\n            {\\n                // We will insert to the left of the beginning of the old count\\n                // i.e.\\n                // [(\"keyA\",2),( \"keyB\",2), (\"keyC\",2), (\"keyD\",3)], and we\\n                // are updating key2, we would move it to here:\\n                //  [(\"keyB\",1), (\"keyA\",2), (\"keyC\",2), (\"keyD\",3)]\\n                newListIterator = list.insert(beginningOfOldCountIt, *listIterator);\\n                map[key] = newListIterator;\\n                if (countsBegin.find(newCount) == countsBegin.end())\\n                {\\n                    //std::cout << \"forever \" << newCount << std::endl;\\n                    countsBegin[newCount] = newListIterator;\\n                    countsLast[newCount] = newListIterator;\\n                }\\n                else\\n                {\\n                   countsLast[newCount] = newListIterator; \\n                }\\n            }\\n             \\n            list.erase(listIterator);\\n        }\\n        \\n        \\n    }\\n    \\n    /** Returns one of the keys with maximal value. */\\n    KeyT getMaxKey() {\\n        if (list.empty())\\n        {\\n            return \"\";\\n        }\\n\\n        return (list.rbegin())->first;\\n    }\\n    \\n    /** Returns one of the keys with Minimal value. */\\n    KeyT getMinKey() {\\n        if (list.empty())\\n        {\\n            return \"\";\\n        }\\n\\n        return (list.begin())->first;\\n        \\n        \\n    }\\nprivate:\\n    std::list<KeyAndCountPairT> list;\\n    std::unordered_map<KeyT, ListKeyAndCountPairIteratorT> map;\\n    std::unordered_map<CountT, ListKeyAndCountPairIteratorT> countsBegin;\\n    std::unordered_map<CountT, ListKeyAndCountPairIteratorT> countsLast;\\n\\n\\n};\\n\\n/**\\n * Your AllOne object will be instantiated and called as such:\\n * AllOne* obj = new AllOne();\\n * obj->inc(key);\\n * obj->dec(key);\\n * string param_3 = obj->getMaxKey();\\n * string param_4 = obj->getMinKey();\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nusing KeyT = std::string;\\nusing CountT = unsigned int;\\nusing KeyAndCountPairT = std::pair<KeyT, CountT>;\\nusing ListKeyAndCountPairIteratorT = std::list<KeyAndCountPairT>::iterator;\\nclass AllOne {\\npublic:\\n    \\n    \\n    /** Initialize your data structure here. */\\n    AllOne() {\\n        \\n    }\\n    \\n    /** Inserts a new key <Key> with value 1. Or increments an existing key by 1. */\\n    void inc(KeyT key) {\\n        CountT newCount = 1;\\n        ListKeyAndCountPairIteratorT listIterator;\\n        if (map.find(key) == map.end())\\n        {\\n            // Key was not found,  let\\'s add it\\n            list.push_front(std::make_pair(key, newCount));\\n            map[key] = list.begin();\\n            listIterator = list.begin(); \\n        }\\n        else\\n        {\\n            listIterator = map[key];\\n            CountT oldCount = listIterator->second;\\n            newCount = oldCount + 1;\\n            listIterator->second = newCount;\\n\\n            // We will now insert this updated element\\n            // to the right of the end of its oldCount\\n            // so i.e. if there\\'s \\n            // [(\"keyA\",2),( \"keyB\",2), (\"keyC\",2), (\"keyD\",3)], and we\\n            // are updating keyB, we would move it to here:\\n            //  [(\"keyA\",2), (\"keyC\",2), (\"keyB\",3), (\"keyD\",3)]\\n            auto lastCountsEndIterator = countsLast[oldCount];\\n            // Let\\'s insert next to this lastCountsEndInterator.\\n            lastCountsEndIterator++;\\n            auto newIterator = list.insert(lastCountsEndIterator, *listIterator);\\n\\n            // Now we have to update countsBegin and countsLast for the\\n            // old count\\n            if (listIterator == countsBegin[oldCount] && \\n                listIterator == countsLast[oldCount]) \\n            {\\n                countsBegin.erase(oldCount);\\n                countsLast.erase(oldCount);\\n            }\\n            else if (listIterator == countsBegin[oldCount])\\n            {\\n                auto copy = listIterator;\\n                countsBegin[oldCount] = ++copy;\\n            }\\n            else if (listIterator == countsLast[oldCount])\\n            {\\n                auto copy = listIterator;\\n                countsLast[oldCount] = --copy;\\n            }\\n            \\n            // We erase that element because it has the outdated count\\n            list.erase(listIterator);\\n            listIterator = newIterator;\\n            map[key] = listIterator;\\n            \\n            \\n        }\\n        // We have not kept track of this new count. Let\\'s\\n        // do it now\\n        if (countsBegin.find(newCount) == countsBegin.end())\\n        {\\n            countsBegin[newCount] = listIterator;\\n            countsLast[newCount] = listIterator;\\n        }\\n        else\\n        {\\n            countsBegin[newCount] = listIterator;   \\n        }\\n    }\\n    \\n    /** Decrements an existing key by 1. If Key\\'s value is 1, remove it from the data structure. */\\n    void dec(KeyT key) {\\n        CountT newCount, oldCount;\\n        ListKeyAndCountPairIteratorT listIterator, newListIterator;\\n        \\n        if (map.find(key) != map.end())\\n        {\\n            listIterator = map[key];\\n            \\n            oldCount = listIterator->second;\\n            newCount = oldCount - 1;\\n            listIterator->second = newCount;\\n            auto beginningOfOldCountIt = countsBegin[oldCount];\\n            \\n            if (countsBegin[oldCount] == countsLast[oldCount] )\\n            {\\n                // We will erase this element if the count decreased to 0\\n                countsBegin.erase(oldCount);\\n                countsLast.erase(oldCount);\\n            }\\n            else if (listIterator == countsBegin[oldCount])\\n            {\\n                auto copy = listIterator;\\n                countsBegin[oldCount] = ++copy;\\n            }\\n            else if (listIterator == countsLast[oldCount])\\n            {\\n                auto copy = listIterator;\\n                countsLast[oldCount] = --copy;\\n            }\\n\\n            if (newCount == 0)\\n            {\\n                // Erase it from everywhere\\n                map.erase(key);\\n            }\\n            else\\n            {\\n                // We will insert to the left of the beginning of the old count\\n                // i.e.\\n                // [(\"keyA\",2),( \"keyB\",2), (\"keyC\",2), (\"keyD\",3)], and we\\n                // are updating key2, we would move it to here:\\n                //  [(\"keyB\",1), (\"keyA\",2), (\"keyC\",2), (\"keyD\",3)]\\n                newListIterator = list.insert(beginningOfOldCountIt, *listIterator);\\n                map[key] = newListIterator;\\n                if (countsBegin.find(newCount) == countsBegin.end())\\n                {\\n                    //std::cout << \"forever \" << newCount << std::endl;\\n                    countsBegin[newCount] = newListIterator;\\n                    countsLast[newCount] = newListIterator;\\n                }\\n                else\\n                {\\n                   countsLast[newCount] = newListIterator; \\n                }\\n            }\\n             \\n            list.erase(listIterator);\\n        }\\n        \\n        \\n    }\\n    \\n    /** Returns one of the keys with maximal value. */\\n    KeyT getMaxKey() {\\n        if (list.empty())\\n        {\\n            return \"\";\\n        }\\n\\n        return (list.rbegin())->first;\\n    }\\n    \\n    /** Returns one of the keys with Minimal value. */\\n    KeyT getMinKey() {\\n        if (list.empty())\\n        {\\n            return \"\";\\n        }\\n\\n        return (list.begin())->first;\\n        \\n        \\n    }\\nprivate:\\n    std::list<KeyAndCountPairT> list;\\n    std::unordered_map<KeyT, ListKeyAndCountPairIteratorT> map;\\n    std::unordered_map<CountT, ListKeyAndCountPairIteratorT> countsBegin;\\n    std::unordered_map<CountT, ListKeyAndCountPairIteratorT> countsLast;\\n\\n\\n};\\n\\n/**\\n * Your AllOne object will be instantiated and called as such:\\n * AllOne* obj = new AllOne();\\n * obj->inc(key);\\n * obj->dec(key);\\n * string param_3 = obj->getMaxKey();\\n * string param_4 = obj->getMinKey();\\n */\\n```",
                "codeTag": "C++"
            },
            {
                "id": 956222,
                "title": "python-digittree-all-o-1-ac",
                "content": "```\\n# See description in AllOne.__init__ below.\\nfrom collections import defaultdict\\n\\nclass DigitTree:\\n    def __init__(self, zero=None, one=None):\\n        # MSB\\n        self.zero = zero\\n        self.one = one\\n        self.multiplicity = 0\\n\\n    def get_max(self) -> int:\\n        return int(self.__get_max(), 2)\\n\\n    def get_min(self) -> int:\\n        return int(self.__get_min(), 2)\\n\\n    def __get_max(self):\\n        if not self.zero and not self.one:\\n            return \"\"\\n        \\n        return \"1\" + self.one.__get_max() if self.one else \"0\" + self.zero.__get_max()\\n\\n    def __get_min(self):\\n        if not self.zero and not self.one:\\n            return \"\"\\n\\n        return \"0\" + self.zero.__get_min() if self.zero else \"1\" + self.one.__get_min()\\n\\n    def exists(self, x: int) -> bool:\\n        return self.__exists(self.get_binary_string(x))\\n\\n    def __exists(self, binary_string: str):\\n        if not binary_string:\\n            return not self.zero and not self.one\\n\\n        head, tail = binary_string[0], binary_string[1:]\\n\\n        if head == \"0\":\\n            if not self.zero:\\n                return False\\n\\n            return self.zero.__exists(tail)\\n        else:\\n            if not self.one:\\n                return False\\n\\n            return self.one.__exists(tail)\\n\\n    @staticmethod\\n    def get_binary_string(x: int) -> str:\\n        return str(bin(x))[2:].rjust(32, \"0\")\\n\\n    def insert(self, x: int) -> None:\\n        self.__insert(DigitTree.get_binary_string(x))\\n\\n    def __insert(self, binary_string: str) -> None:\\n        if not binary_string:\\n            self.multiplicity += 1\\n            return\\n\\n        head, tail = binary_string[0], binary_string[1:]\\n\\n        if head == \"0\":\\n            if not self.zero:\\n                self.zero = DigitTree()\\n\\n            self.zero.__insert(tail)\\n        else:\\n            if not self.one:\\n                self.one = DigitTree()\\n\\n            self.one.__insert(tail)\\n\\n    def delete(self, x: int) -> None:\\n        self.__delete(self.get_binary_string(x))\\n\\n    def __delete(self, binary_string: str) -> int:\\n        # s.t. := subtree\\n        # returns -1, if we have this element in s.t.; 0, if we have not removed element in s.t. and 1 if we already removed the element in s.t.\\n\\n        if not binary_string:\\n            self.multiplicity -= 1\\n            return 0 if self.multiplicity == 0 else -1\\n\\n        head, tail = binary_string[0], binary_string[1:]\\n\\n        if head == \"0\":\\n            already_deleted = self.zero.__delete(tail)\\n            if already_deleted == 0:\\n                if self.one:\\n                    self.zero = None\\n                    return 1\\n                else:\\n                    return 0\\n            return already_deleted\\n        else:\\n            already_deleted = self.one.__delete(tail)\\n            if already_deleted == 0:\\n                if self.zero:\\n                    self.one = None\\n                    return 1\\n                else:\\n                    return 0\\n\\n            return already_deleted\\n\\n\\nclass AllOne:\\n    def __init__(self):\\n        self.dt = DigitTree() # stores binary representation of values (getMin and getMax in O(1) possible)\\n        \\'\\'\\'\\n\\t\\t\\t\\t\\t \\u03F5\\n                    / \\\\\\n                   /   \\\\\\n                  0     \\\\\\n                 / \\\\     1\\n                0   1   / \\\\\\n                       0   \\\\\\n                            1\\n                           / \\\\\\n                          0   1\\n\\t\\t\\'\\'\\'\\n        self.kv = defaultdict(int) # key to value\\n        self.vk = defaultdict(lambda: defaultdict(bool)) # value to key\\n\\n    def inc(self, k: str) -> None:\\n        if self.kv[k] == 0:\\n            self.dt.insert(0)\\n            self.vk[0][k] = True\\n\\n        self.dt.insert(self.kv[k] + 1)\\n        self.vk[self.kv[k] + 1][k] = True\\n\\n        self.dt.delete(self.kv[k])\\n        del self.vk[self.kv[k]][k]\\n\\n        self.kv[k] += 1\\n\\n    def dec(self, k: str) -> None:\\n        if self.kv[k] == 0:\\n            del self.kv[k]\\n            return\\n\\n        if self.kv[k] > 1:\\n            self.dt.insert(self.kv[k] - 1)\\n            self.vk[self.kv[k] - 1][k] = True\\n\\n        self.dt.delete(self.kv[k])\\n        del self.vk[self.kv[k]][k]\\n\\n        self.kv[k] -= 1\\n\\n        if not self.kv[k]:\\n            del self.kv[k]\\n\\n    def getMaxKey(self) -> str:\\n        return next(iter(self.vk[self.dt.get_max()].keys())) if self.kv else \"\"\\n\\n    def getMinKey(self) -> str:\\n        return next(iter(self.vk[self.dt.get_min()].keys())) if self.kv else \"\"\\n```",
                "solutionTags": [],
                "code": "```\\n# See description in AllOne.__init__ below.\\nfrom collections import defaultdict\\n\\nclass DigitTree:\\n    def __init__(self, zero=None, one=None):\\n        # MSB\\n        self.zero = zero\\n        self.one = one\\n        self.multiplicity = 0\\n\\n    def get_max(self) -> int:\\n        return int(self.__get_max(), 2)\\n\\n    def get_min(self) -> int:\\n        return int(self.__get_min(), 2)\\n\\n    def __get_max(self):\\n        if not self.zero and not self.one:\\n            return \"\"\\n        \\n        return \"1\" + self.one.__get_max() if self.one else \"0\" + self.zero.__get_max()\\n\\n    def __get_min(self):\\n        if not self.zero and not self.one:\\n            return \"\"\\n\\n        return \"0\" + self.zero.__get_min() if self.zero else \"1\" + self.one.__get_min()\\n\\n    def exists(self, x: int) -> bool:\\n        return self.__exists(self.get_binary_string(x))\\n\\n    def __exists(self, binary_string: str):\\n        if not binary_string:\\n            return not self.zero and not self.one\\n\\n        head, tail = binary_string[0], binary_string[1:]\\n\\n        if head == \"0\":\\n            if not self.zero:\\n                return False\\n\\n            return self.zero.__exists(tail)\\n        else:\\n            if not self.one:\\n                return False\\n\\n            return self.one.__exists(tail)\\n\\n    @staticmethod\\n    def get_binary_string(x: int) -> str:\\n        return str(bin(x))[2:].rjust(32, \"0\")\\n\\n    def insert(self, x: int) -> None:\\n        self.__insert(DigitTree.get_binary_string(x))\\n\\n    def __insert(self, binary_string: str) -> None:\\n        if not binary_string:\\n            self.multiplicity += 1\\n            return\\n\\n        head, tail = binary_string[0], binary_string[1:]\\n\\n        if head == \"0\":\\n            if not self.zero:\\n                self.zero = DigitTree()\\n\\n            self.zero.__insert(tail)\\n        else:\\n            if not self.one:\\n                self.one = DigitTree()\\n\\n            self.one.__insert(tail)\\n\\n    def delete(self, x: int) -> None:\\n        self.__delete(self.get_binary_string(x))\\n\\n    def __delete(self, binary_string: str) -> int:\\n        # s.t. := subtree\\n        # returns -1, if we have this element in s.t.; 0, if we have not removed element in s.t. and 1 if we already removed the element in s.t.\\n\\n        if not binary_string:\\n            self.multiplicity -= 1\\n            return 0 if self.multiplicity == 0 else -1\\n\\n        head, tail = binary_string[0], binary_string[1:]\\n\\n        if head == \"0\":\\n            already_deleted = self.zero.__delete(tail)\\n            if already_deleted == 0:\\n                if self.one:\\n                    self.zero = None\\n                    return 1\\n                else:\\n                    return 0\\n            return already_deleted\\n        else:\\n            already_deleted = self.one.__delete(tail)\\n            if already_deleted == 0:\\n                if self.zero:\\n                    self.one = None\\n                    return 1\\n                else:\\n                    return 0\\n\\n            return already_deleted\\n\\n\\nclass AllOne:\\n    def __init__(self):\\n        self.dt = DigitTree() # stores binary representation of values (getMin and getMax in O(1) possible)\\n        \\'\\'\\'\\n\\t\\t\\t\\t\\t \\u03F5\\n                    / \\\\\\n                   /   \\\\\\n                  0     \\\\\\n                 / \\\\     1\\n                0   1   / \\\\\\n                       0   \\\\\\n                            1\\n                           / \\\\\\n                          0   1\\n\\t\\t\\'\\'\\'\\n        self.kv = defaultdict(int) # key to value\\n        self.vk = defaultdict(lambda: defaultdict(bool)) # value to key\\n\\n    def inc(self, k: str) -> None:\\n        if self.kv[k] == 0:\\n            self.dt.insert(0)\\n            self.vk[0][k] = True\\n\\n        self.dt.insert(self.kv[k] + 1)\\n        self.vk[self.kv[k] + 1][k] = True\\n\\n        self.dt.delete(self.kv[k])\\n        del self.vk[self.kv[k]][k]\\n\\n        self.kv[k] += 1\\n\\n    def dec(self, k: str) -> None:\\n        if self.kv[k] == 0:\\n            del self.kv[k]\\n            return\\n\\n        if self.kv[k] > 1:\\n            self.dt.insert(self.kv[k] - 1)\\n            self.vk[self.kv[k] - 1][k] = True\\n\\n        self.dt.delete(self.kv[k])\\n        del self.vk[self.kv[k]][k]\\n\\n        self.kv[k] -= 1\\n\\n        if not self.kv[k]:\\n            del self.kv[k]\\n\\n    def getMaxKey(self) -> str:\\n        return next(iter(self.vk[self.dt.get_max()].keys())) if self.kv else \"\"\\n\\n    def getMinKey(self) -> str:\\n        return next(iter(self.vk[self.dt.get_min()].keys())) if self.kv else \"\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 896548,
                "title": "the-most-beautiful-java-symmetry-92",
                "content": "This approach is very simple in that we only store minimum info to solve the problem:  single hashmap and head and tail pointers in the DLL. We store the next and prev pointers in Node[] array to take advantage of beautiful symmetry when updating the previous node or the next node. This allows for maximum code reuse across both inc() and dec() methods. The code is broken down into manageable chunks, and can be well understood with moderate effort on the part of the reader.\\n\\n```\\nclass AllOne {\\n\\n    HashMap<String, Node> keyToNode;\\n    Node head;\\n    Node tail;\\n    /** Initialize your data structure here. */\\n    public AllOne() {\\n        keyToNode = new HashMap<>();\\n        head = new Node(0);\\n        tail = new Node(0);\\n        head.nodes[0] = tail;\\n        tail.nodes[1] = head;\\n    }\\n    \\n    /** Inserts a new key <Key> with value 1. Or increments an existing key by 1. */\\n    public void inc(String key) {\\n        Node curr = keyToNode.get(key);\\n        if (curr == null) {\\n            // If it\\'s not in the map, we need to add it after the head.\\n            update(head, key, 0);\\n        } else {\\n            // If it is already in the map, we need to move it one node forward in the DS,\\n            // and we need to remove this key from the current node.\\n            update(curr, key, 0);\\n            removeKey(curr, key);\\n        }\\n    }\\n    \\n    /** Decrements an existing key by 1. If Key\\'s value is 1, remove it from the data structure. */\\n    public void dec(String key) {\\n        Node curr = keyToNode.get(key);\\n        if (curr == null) {\\n            // Special case for when map doesn\\'t contain the key.\\n            return;\\n        }\\n\\n        if (curr.val == 1) {\\n            // We need to remove the key from the datastructure\\n            keyToNode.remove(key);\\n        } else {\\n            // We just need to update it\\'s position in the datastructure\\n            update(curr, key, 1);\\n        }\\n        // In any case, the key must be remove from its current node\\n        removeKey(curr, key);\\n    }\\n    \\n    private void update(Node curr, String key, int i) {\\n        // 1 - 2 * i will be 1 when i = 0, and it will be -1 when i = 1.\\n        if (curr.nodes[i].val != curr.val + 1 - 2 * i) {\\n            Node kNode = new Node(curr.val + 1 - 2 * i);\\n\\n            curr.nodes[i].nodes[1 - i] = kNode;\\n            kNode.nodes[i] = curr.nodes[i];\\n            curr.nodes[i] = kNode;\\n            kNode.nodes[1 - i] = curr;\\n        }\\n        curr.nodes[i].keys.add(key);\\n        keyToNode.put(key, curr.nodes[i]);\\n    }\\n    \\n    // The symmetry is beautiful.\\n    private void removeKey(Node curr, String key) {\\n        curr.keys.remove(key);\\n        if (curr.keys.isEmpty()) {\\n            // Remove the current node from the DS by:\\n            // Set the previous node to connect to the next node\\n            // set the next node to connect to the previous node\\n            curr.nodes[1].nodes[0] = curr.nodes[0];\\n            curr.nodes[0].nodes[1] = curr.nodes[1];\\n        }\\n    }\\n    \\n    /** Returns one of the keys with maximal value. */\\n    public String getMaxKey() {\\n        if (tail.nodes[1] != head) {\\n            return tail.nodes[1].keys.iterator().next();\\n        }\\n        return \"\";\\n    }\\n    \\n    /** Returns one of the keys with Minimal value. */\\n    public String getMinKey() {\\n        if (head.nodes[0] != tail) {\\n            return head.nodes[0].keys.iterator().next();\\n        }\\n        return \"\";\\n    }\\n}\\n\\n// Each Node stores all keys for a certain val.\\n// Nodes are stored in a Double LinkedList, which is also ordered by val.\\nclass Node {\\n    Set<String> keys;\\n    int val;\\n    // 1st element is next, and the 2nd element is prev\\n    // Doing this is not essential, but allows us to use symmetry to achieve beautiful code :)\\n    Node[] nodes;\\n    public Node(int val) {\\n        keys = new HashSet<>();\\n        this.val = val;\\n        nodes = new Node[2];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass AllOne {\\n\\n    HashMap<String, Node> keyToNode;\\n    Node head;\\n    Node tail;\\n    /** Initialize your data structure here. */\\n    public AllOne() {\\n        keyToNode = new HashMap<>();\\n        head = new Node(0);\\n        tail = new Node(0);\\n        head.nodes[0] = tail;\\n        tail.nodes[1] = head;\\n    }\\n    \\n    /** Inserts a new key <Key> with value 1. Or increments an existing key by 1. */\\n    public void inc(String key) {\\n        Node curr = keyToNode.get(key);\\n        if (curr == null) {\\n            // If it\\'s not in the map, we need to add it after the head.\\n            update(head, key, 0);\\n        } else {\\n            // If it is already in the map, we need to move it one node forward in the DS,\\n            // and we need to remove this key from the current node.\\n            update(curr, key, 0);\\n            removeKey(curr, key);\\n        }\\n    }\\n    \\n    /** Decrements an existing key by 1. If Key\\'s value is 1, remove it from the data structure. */\\n    public void dec(String key) {\\n        Node curr = keyToNode.get(key);\\n        if (curr == null) {\\n            // Special case for when map doesn\\'t contain the key.\\n            return;\\n        }\\n\\n        if (curr.val == 1) {\\n            // We need to remove the key from the datastructure\\n            keyToNode.remove(key);\\n        } else {\\n            // We just need to update it\\'s position in the datastructure\\n            update(curr, key, 1);\\n        }\\n        // In any case, the key must be remove from its current node\\n        removeKey(curr, key);\\n    }\\n    \\n    private void update(Node curr, String key, int i) {\\n        // 1 - 2 * i will be 1 when i = 0, and it will be -1 when i = 1.\\n        if (curr.nodes[i].val != curr.val + 1 - 2 * i) {\\n            Node kNode = new Node(curr.val + 1 - 2 * i);\\n\\n            curr.nodes[i].nodes[1 - i] = kNode;\\n            kNode.nodes[i] = curr.nodes[i];\\n            curr.nodes[i] = kNode;\\n            kNode.nodes[1 - i] = curr;\\n        }\\n        curr.nodes[i].keys.add(key);\\n        keyToNode.put(key, curr.nodes[i]);\\n    }\\n    \\n    // The symmetry is beautiful.\\n    private void removeKey(Node curr, String key) {\\n        curr.keys.remove(key);\\n        if (curr.keys.isEmpty()) {\\n            // Remove the current node from the DS by:\\n            // Set the previous node to connect to the next node\\n            // set the next node to connect to the previous node\\n            curr.nodes[1].nodes[0] = curr.nodes[0];\\n            curr.nodes[0].nodes[1] = curr.nodes[1];\\n        }\\n    }\\n    \\n    /** Returns one of the keys with maximal value. */\\n    public String getMaxKey() {\\n        if (tail.nodes[1] != head) {\\n            return tail.nodes[1].keys.iterator().next();\\n        }\\n        return \"\";\\n    }\\n    \\n    /** Returns one of the keys with Minimal value. */\\n    public String getMinKey() {\\n        if (head.nodes[0] != tail) {\\n            return head.nodes[0].keys.iterator().next();\\n        }\\n        return \"\";\\n    }\\n}\\n\\n// Each Node stores all keys for a certain val.\\n// Nodes are stored in a Double LinkedList, which is also ordered by val.\\nclass Node {\\n    Set<String> keys;\\n    int val;\\n    // 1st element is next, and the 2nd element is prev\\n    // Doing this is not essential, but allows us to use symmetry to achieve beautiful code :)\\n    Node[] nodes;\\n    public Node(int val) {\\n        keys = new HashSet<>();\\n        this.val = val;\\n        nodes = new Node[2];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 880199,
                "title": "clean-python-doubly-linked-list",
                "content": "```\\nclass Node:\\n    def __init__(self, val=None, key=None):\\n        self.val = val\\n        self.key = key\\n        self.next = None\\n        self.prev = None\\n\\n\\ndef remove_node(node):\\n    prev_node = node.prev\\n    next_node = node.next\\n    \\n    prev_node.next = next_node\\n    next_node.prev = prev_node\\n\\n\\ndef insert_after(node, new_node):\\n    next_node = node.next\\n    node.next = new_node\\n    \\n    next_node.prev = new_node\\n    new_node.next = next_node\\n    new_node.prev = node\\n\\n\\nclass AllOne:\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.dict = dict()\\n        self.head = Node()\\n        self.tail = Node()\\n        \\n        self.head.next = self.tail\\n        self.tail.prev = self.head\\n\\n    def inc(self, key: str) -> None:\\n        \"\"\"\\n        Inserts a new key <Key> with value 1. Or increments an existing key by 1.\\n        \"\"\"\\n        if key in self.dict:\\n            node = self.dict[key]\\n            node.val += 1\\n            next = node.next\\n            while next.val and node.val > next.val:\\n                next = next.next\\n            if next != node.next:\\n                remove_node(node)\\n                insert_after(next.prev, node)\\n        else:\\n            node = Node(1, key)\\n            insert_after(self.head, node)\\n            self.dict[key] = node\\n\\n    def dec(self, key: str) -> None:\\n        \"\"\"\\n        Decrements an existing key by 1. If Key\\'s value is 1, remove it from the data structure.\\n        \"\"\"\\n        if key in self.dict:\\n            node = self.dict[key]\\n            node.val -= 1\\n            if node.val == 0:\\n                del self.dict[key]\\n                remove_node(node)\\n            else:\\n                prev = node.prev\\n                while prev.val and node.val < prev.val:\\n                    prev = prev.prev\\n                if node.prev != prev:\\n                    remove_node(node)\\n                    insert_after(prev, node)\\n                    \\n    def getMaxKey(self) -> str:\\n        \"\"\"\\n        Returns one of the keys with maximal value.\\n        \"\"\"\\n        if self.tail.prev.key:\\n            return self.tail.prev.key\\n        else: return \\'\\'\\n\\n    def getMinKey(self) -> str:\\n        \"\"\"\\n        Returns one of the keys with Minimal value.\\n        \"\"\"\\n        if self.head.next.key:\\n            return self.head.next.key\\n        else: return \\'\\'\\n```",
                "solutionTags": [
                    "Doubly-Linked List"
                ],
                "code": "```\\nclass Node:\\n    def __init__(self, val=None, key=None):\\n        self.val = val\\n        self.key = key\\n        self.next = None\\n        self.prev = None\\n\\n\\ndef remove_node(node):\\n    prev_node = node.prev\\n    next_node = node.next\\n    \\n    prev_node.next = next_node\\n    next_node.prev = prev_node\\n\\n\\ndef insert_after(node, new_node):\\n    next_node = node.next\\n    node.next = new_node\\n    \\n    next_node.prev = new_node\\n    new_node.next = next_node\\n    new_node.prev = node\\n\\n\\nclass AllOne:\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.dict = dict()\\n        self.head = Node()\\n        self.tail = Node()\\n        \\n        self.head.next = self.tail\\n        self.tail.prev = self.head\\n\\n    def inc(self, key: str) -> None:\\n        \"\"\"\\n        Inserts a new key <Key> with value 1. Or increments an existing key by 1.\\n        \"\"\"\\n        if key in self.dict:\\n            node = self.dict[key]\\n            node.val += 1\\n            next = node.next\\n            while next.val and node.val > next.val:\\n                next = next.next\\n            if next != node.next:\\n                remove_node(node)\\n                insert_after(next.prev, node)\\n        else:\\n            node = Node(1, key)\\n            insert_after(self.head, node)\\n            self.dict[key] = node\\n\\n    def dec(self, key: str) -> None:\\n        \"\"\"\\n        Decrements an existing key by 1. If Key\\'s value is 1, remove it from the data structure.\\n        \"\"\"\\n        if key in self.dict:\\n            node = self.dict[key]\\n            node.val -= 1\\n            if node.val == 0:\\n                del self.dict[key]\\n                remove_node(node)\\n            else:\\n                prev = node.prev\\n                while prev.val and node.val < prev.val:\\n                    prev = prev.prev\\n                if node.prev != prev:\\n                    remove_node(node)\\n                    insert_after(prev, node)\\n                    \\n    def getMaxKey(self) -> str:\\n        \"\"\"\\n        Returns one of the keys with maximal value.\\n        \"\"\"\\n        if self.tail.prev.key:\\n            return self.tail.prev.key\\n        else: return \\'\\'\\n\\n    def getMinKey(self) -> str:\\n        \"\"\"\\n        Returns one of the keys with Minimal value.\\n        \"\"\"\\n        if self.head.next.key:\\n            return self.head.next.key\\n        else: return \\'\\'\\n```",
                "codeTag": "Java"
            },
            {
                "id": 812384,
                "title": "python-o-1-time-complexity-clean-code",
                "content": "```\\nclass Node:\\n    def __init__(self, val):\\n        self.next = None\\n        self.pre = None\\n        self.val = val\\n        self.data = set()\\n\\n\\nclass AllOne(object):\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.head = Node(0)\\n        self.tail = Node(0)\\n        self.head.next, self.tail.pre = self.tail, self.head\\n        self.memo = {}\\n        \\n    def add(self, node, key):\\n        if node.val+1 != node.next.val:\\n            newNode = Node(node.val+1)\\n            newNode.pre, newNode.next = node, node.next\\n            newNode.pre.next = newNode.next.pre = newNode\\n        else:\\n            newNode = node.next\\n        \\n        newNode.data.add(key)\\n        return newNode\\n    \\n    def add_prev(self, node, key):\\n        if node.val-1 != node.pre.val:\\n            newNode = Node(node.val-1)\\n            newNode.pre, newNode.next = node.pre, node\\n            newNode.pre.next = newNode.next.pre = newNode\\n        else:\\n            newNode = node.pre\\n        newNode.data.add(key)\\n        return newNode\\n        \\n    def inc(self, key):\\n        \"\"\"\\n        Inserts a new key <Key> with value 1. Or increments an existing key by 1.\\n        :type key: str\\n        :rtype: None\\n        \"\"\"\\n        if key not in self.memo:\\n            self.memo[key] = self.add(self.head, key)\\n        else:\\n            node = self.memo[key]\\n            self.memo[key] = self.add(node, key)\\n            node.data.remove(key)\\n            if not node.data:\\n                node.pre.next, node.next.pre = node.next, node.pre\\n                node.next = node.pre = None\\n\\n    def dec(self, key):\\n        \"\"\"\\n        Decrements an existing key by 1. If Key\\'s value is 1, remove it from the data structure.\\n        :type key: str\\n        :rtype: None\\n        \"\"\"\\n        if key in self.memo:\\n            node = self.memo[key]\\n            node.data.remove(key)\\n            del self.memo[key]\\n            if node.val > 1:\\n                self.memo[key] = self.add_prev(node, key)\\n            if not node.data:\\n                node.pre.next, node.next.pre = node.next, node.pre\\n                node.next = node.pre = None\\n                \\n\\n    def getMaxKey(self):\\n        \"\"\"\\n        Returns one of the keys with maximal value.\\n        :rtype: str\\n        \"\"\"\\n        if not self.tail.pre.data:\\n            return \"\"\\n        num = self.tail.pre.data.pop()\\n        self.tail.pre.data.add(num)\\n        return num\\n\\n    def getMinKey(self):\\n        \"\"\"\\n        Returns one of the keys with Minimal value.\\n        :rtype: str\\n        \"\"\"\\n        if not self.head.next.data:\\n            return \"\"\\n        num = self.head.next.data.pop()\\n        self.head.next.data.add(num)\\n        return num\\n\\n\\n# Your AllOne object will be instantiated and called as such:\\n# obj = AllOne()\\n# obj.inc(key)\\n# obj.dec(key)\\n# param_3 = obj.getMaxKey()\\n# param_4 = obj.getMinKey()",
                "solutionTags": [
                    "Python",
                    "Doubly-Linked List"
                ],
                "code": "```\\nclass Node:\\n    def __init__(self, val):\\n        self.next = None\\n        self.pre = None\\n        self.val = val\\n        self.data = set()\\n\\n\\nclass AllOne(object):\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.head = Node(0)\\n        self.tail = Node(0)\\n        self.head.next, self.tail.pre = self.tail, self.head\\n        self.memo = {}\\n        \\n    def add(self, node, key):\\n        if node.val+1 != node.next.val:\\n            newNode = Node(node.val+1)\\n            newNode.pre, newNode.next = node, node.next\\n            newNode.pre.next = newNode.next.pre = newNode\\n        else:\\n            newNode = node.next\\n        \\n        newNode.data.add(key)\\n        return newNode\\n    \\n    def add_prev(self, node, key):\\n        if node.val-1 != node.pre.val:\\n            newNode = Node(node.val-1)\\n            newNode.pre, newNode.next = node.pre, node\\n            newNode.pre.next = newNode.next.pre = newNode\\n        else:\\n            newNode = node.pre\\n        newNode.data.add(key)\\n        return newNode\\n        \\n    def inc(self, key):\\n        \"\"\"\\n        Inserts a new key <Key> with value 1. Or increments an existing key by 1.\\n        :type key: str\\n        :rtype: None\\n        \"\"\"\\n        if key not in self.memo:\\n            self.memo[key] = self.add(self.head, key)\\n        else:\\n            node = self.memo[key]\\n            self.memo[key] = self.add(node, key)\\n            node.data.remove(key)\\n            if not node.data:\\n                node.pre.next, node.next.pre = node.next, node.pre\\n                node.next = node.pre = None\\n\\n    def dec(self, key):\\n        \"\"\"\\n        Decrements an existing key by 1. If Key\\'s value is 1, remove it from the data structure.\\n        :type key: str\\n        :rtype: None\\n        \"\"\"\\n        if key in self.memo:\\n            node = self.memo[key]\\n            node.data.remove(key)\\n            del self.memo[key]\\n            if node.val > 1:\\n                self.memo[key] = self.add_prev(node, key)\\n            if not node.data:\\n                node.pre.next, node.next.pre = node.next, node.pre\\n                node.next = node.pre = None\\n                \\n\\n    def getMaxKey(self):\\n        \"\"\"\\n        Returns one of the keys with maximal value.\\n        :rtype: str\\n        \"\"\"\\n        if not self.tail.pre.data:\\n            return \"\"\\n        num = self.tail.pre.data.pop()\\n        self.tail.pre.data.add(num)\\n        return num\\n\\n    def getMinKey(self):\\n        \"\"\"\\n        Returns one of the keys with Minimal value.\\n        :rtype: str\\n        \"\"\"\\n        if not self.head.next.data:\\n            return \"\"\\n        num = self.head.next.data.pop()\\n        self.head.next.data.add(num)\\n        return num\\n\\n\\n# Your AllOne object will be instantiated and called as such:\\n# obj = AllOne()\\n# obj.inc(key)\\n# obj.dec(key)\\n# param_3 = obj.getMaxKey()\\n# param_4 = obj.getMinKey()",
                "codeTag": "Java"
            },
            {
                "id": 753384,
                "title": "java-dual-linked-hashset",
                "content": "Simply put all keys with the same count to the same DDL Node. \\nDDL Node was sorted by count, use head and tail to mark for min and max.\\nuse a HashMap to find the node with key for updates.\\n\\n```\\nclass AllOne {\\n    Node head, tail;\\n    Map<String, Node> map;\\n    public AllOne() {\\n        head = new Node(0);\\n        tail = new Node(-2);\\n        map = new HashMap<>();\\n        head.next = tail;\\n        tail.prev = head;\\n    }\\n    /** Inserts a new key <Key> with value 1. Or increments an existing key by 1. */\\n    public void inc(String key) {\\n        Node node = map.getOrDefault(key, head), curr = node.next;\\n        if (curr.val != node.val + 1) {  // add first then remove\\n            curr = new Node(node.val + 1);\\n            addNode(curr, node);\\n        }\\n        removeKey(key, node);\\n        insertKey(key, curr);\\n    }\\n    /** Decrements an existing key by 1. If Key\\'s value is 1, remove it from the data structure. */\\n    public void dec(String key) {\\n        if (!map.containsKey(key)) return;\\n        Node node = map.get(key);\\n        Node curr = node.prev;\\n        if (node.val == 1) {\\n            map.remove(key);\\n            removeKey(key, node);\\n            return;\\n        }\\n        else if (curr.val != node.val - 1) {  // add first then remove\\n            curr = new Node(node.val - 1);\\n            addNode(curr, node.prev);\\n        }\\n        removeKey(key, node);\\n        insertKey(key, curr);\\n    }\\n    /** Returns one of the keys with maximal value. */\\n    public String getMaxKey() {\\n        if (tail.prev.equals(head)) return \"\";\\n        return tail.prev.ks.iterator().next();\\n    }\\n    /** Returns one of the keys with Minimal value. */\\n    public String getMinKey() {\\n        if (tail.prev.equals(head)) return \"\";\\n        return head.next.ks.iterator().next();\\n    }\\n    \\n    private void addNode(Node curr, Node prev) {\\n        Node next = prev.next;\\n        prev.next = curr;\\n        curr.next = next;\\n        next.prev = curr;\\n        curr.prev = prev;\\n    }\\n    \\n    private void insertKey(String key, Node curr) {\\n        map.put(key, curr);\\n        curr.ks.add(key);\\n    }\\n    \\n    private void removeKey(String key, Node node) {\\n        if (node.equals(head)) return;\\n        node.ks.remove(key);\\n        map.remove(key);\\n        if (node.ks.size() == 0) {\\n            remove(node);\\n        }\\n    }\\n    \\n    private void remove(Node node) {\\n        Node prev = node.prev, next = node.next;\\n        prev.next = next;\\n        next.prev = prev;\\n    }\\n    \\n    /** Initialize your data structure here. */\\n    public class Node{\\n        Set<String> ks;\\n        Node next, prev;\\n        int val;\\n        public Node(int val) {\\n            this.val = val;\\n            next = null;\\n            prev = null;\\n            ks = new HashSet<>();\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass AllOne {\\n    Node head, tail;\\n    Map<String, Node> map;\\n    public AllOne() {\\n        head = new Node(0);\\n        tail = new Node(-2);\\n        map = new HashMap<>();\\n        head.next = tail;\\n        tail.prev = head;\\n    }\\n    /** Inserts a new key <Key> with value 1. Or increments an existing key by 1. */\\n    public void inc(String key) {\\n        Node node = map.getOrDefault(key, head), curr = node.next;\\n        if (curr.val != node.val + 1) {  // add first then remove\\n            curr = new Node(node.val + 1);\\n            addNode(curr, node);\\n        }\\n        removeKey(key, node);\\n        insertKey(key, curr);\\n    }\\n    /** Decrements an existing key by 1. If Key\\'s value is 1, remove it from the data structure. */\\n    public void dec(String key) {\\n        if (!map.containsKey(key)) return;\\n        Node node = map.get(key);\\n        Node curr = node.prev;\\n        if (node.val == 1) {\\n            map.remove(key);\\n            removeKey(key, node);\\n            return;\\n        }\\n        else if (curr.val != node.val - 1) {  // add first then remove\\n            curr = new Node(node.val - 1);\\n            addNode(curr, node.prev);\\n        }\\n        removeKey(key, node);\\n        insertKey(key, curr);\\n    }\\n    /** Returns one of the keys with maximal value. */\\n    public String getMaxKey() {\\n        if (tail.prev.equals(head)) return \"\";\\n        return tail.prev.ks.iterator().next();\\n    }\\n    /** Returns one of the keys with Minimal value. */\\n    public String getMinKey() {\\n        if (tail.prev.equals(head)) return \"\";\\n        return head.next.ks.iterator().next();\\n    }\\n    \\n    private void addNode(Node curr, Node prev) {\\n        Node next = prev.next;\\n        prev.next = curr;\\n        curr.next = next;\\n        next.prev = curr;\\n        curr.prev = prev;\\n    }\\n    \\n    private void insertKey(String key, Node curr) {\\n        map.put(key, curr);\\n        curr.ks.add(key);\\n    }\\n    \\n    private void removeKey(String key, Node node) {\\n        if (node.equals(head)) return;\\n        node.ks.remove(key);\\n        map.remove(key);\\n        if (node.ks.size() == 0) {\\n            remove(node);\\n        }\\n    }\\n    \\n    private void remove(Node node) {\\n        Node prev = node.prev, next = node.next;\\n        prev.next = next;\\n        next.prev = prev;\\n    }\\n    \\n    /** Initialize your data structure here. */\\n    public class Node{\\n        Set<String> ks;\\n        Node next, prev;\\n        int val;\\n        public Node(int val) {\\n            this.val = val;\\n            next = null;\\n            prev = null;\\n            ks = new HashSet<>();\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 728012,
                "title": "java-beats-95-super-concise-and-understandable-solution-with-comments",
                "content": "\\n```\\nclass AllOne {\\n    HashMap<String,Node> map = new HashMap<>();\\n    class Node{\\n        HashSet<String> set = new HashSet<>();\\n        Integer val;\\n        Node pre;\\n        Node next;\\n    }\\n    Node Head = new Node();\\n    Node Tail = new Node();\\n    public AllOne() {\\n        Head.next = Tail;\\n        Head.val = 1; // head means val = 1, it\\'s easier to initiate\\n        Tail.pre = Head;\\n    }\\n    \\n    public void inc(String key) {\\n        if(!map.containsKey(key)){\\n            Head.set.add(key);\\n            map.put(key,Head);\\n        }else{\\n            Node cur = map.get(key);\\n            int curVal = cur.val;\\n            cur.set.remove(key);\\n            // remove node contains no keys\\n            if(cur.set.size() == 0 && cur != Head){\\n                cur.pre.next = cur.next;\\n                cur.next.pre = cur.pre;\\n                cur = cur.pre;\\n            }\\n            // if node already exist \\n            if(cur.next != Tail && cur.next.val == curVal + 1){\\n                cur.next.set.add(key);\\n                map.put(key,cur.next);\\n            }else{ // insert a new node after it\\n                Node node = new Node();\\n                node.set.add(key);\\n                node.val = curVal + 1;\\n                insert(cur,node);\\n                map.put(key,node);\\n            }\\n        }\\n    }\\n    // symmetric as above\\n    public void dec(String key) {\\n        if(!map.containsKey(key)) return ;\\n        if(map.get(key) == Head){\\n            Head.set.remove(key);\\n            map.remove(key);\\n        }else{\\n            Node cur = map.get(key);\\n            int curVal = cur.val;\\n            cur.set.remove(key);\\n            if(cur.set.size() == 0){\\n                cur.pre.next = cur.next;\\n                cur.next.pre = cur.pre;\\n                cur = cur.next;\\n            }\\n            if(cur.pre.val == curVal - 1){\\n                cur.pre.set.add(key);\\n                map.put(key,cur.pre);\\n            }else{\\n                Node node = new Node();\\n                node.set.add(key);\\n                node.val = curVal - 1;\\n                insert(cur.pre,node);\\n                map.put(key,node);\\n            }\\n        }\\n    }\\n    \\n    private void insert(Node cur,Node node){\\n        cur.next.pre = node;\\n        node.next = cur.next;\\n        cur.next = node;\\n        node.pre = cur;\\n    }\\n    \\n    public String getMaxKey() {\\n        if(Tail.pre.set.size() == 0) return \"\";\\n        return Tail.pre.set.iterator().next();\\n    }\\n    \\n    public String getMinKey() {\\n        if(Head.set.size() != 0) return Head.set.iterator().next();\\n        if(Head.next.set.size() == 0) return \"\";\\n        return Head.next.set.iterator().next();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Doubly-Linked List"
                ],
                "code": "```\\nclass AllOne {\\n    HashMap<String,Node> map = new HashMap<>();\\n    class Node{\\n        HashSet<String> set = new HashSet<>();\\n        Integer val;\\n        Node pre;\\n        Node next;\\n    }\\n    Node Head = new Node();\\n    Node Tail = new Node();\\n    public AllOne() {\\n        Head.next = Tail;\\n        Head.val = 1; // head means val = 1, it\\'s easier to initiate\\n        Tail.pre = Head;\\n    }\\n    \\n    public void inc(String key) {\\n        if(!map.containsKey(key)){\\n            Head.set.add(key);\\n            map.put(key,Head);\\n        }else{\\n            Node cur = map.get(key);\\n            int curVal = cur.val;\\n            cur.set.remove(key);\\n            // remove node contains no keys\\n            if(cur.set.size() == 0 && cur != Head){\\n                cur.pre.next = cur.next;\\n                cur.next.pre = cur.pre;\\n                cur = cur.pre;\\n            }\\n            // if node already exist \\n            if(cur.next != Tail && cur.next.val == curVal + 1){\\n                cur.next.set.add(key);\\n                map.put(key,cur.next);\\n            }else{ // insert a new node after it\\n                Node node = new Node();\\n                node.set.add(key);\\n                node.val = curVal + 1;\\n                insert(cur,node);\\n                map.put(key,node);\\n            }\\n        }\\n    }\\n    // symmetric as above\\n    public void dec(String key) {\\n        if(!map.containsKey(key)) return ;\\n        if(map.get(key) == Head){\\n            Head.set.remove(key);\\n            map.remove(key);\\n        }else{\\n            Node cur = map.get(key);\\n            int curVal = cur.val;\\n            cur.set.remove(key);\\n            if(cur.set.size() == 0){\\n                cur.pre.next = cur.next;\\n                cur.next.pre = cur.pre;\\n                cur = cur.next;\\n            }\\n            if(cur.pre.val == curVal - 1){\\n                cur.pre.set.add(key);\\n                map.put(key,cur.pre);\\n            }else{\\n                Node node = new Node();\\n                node.set.add(key);\\n                node.val = curVal - 1;\\n                insert(cur.pre,node);\\n                map.put(key,node);\\n            }\\n        }\\n    }\\n    \\n    private void insert(Node cur,Node node){\\n        cur.next.pre = node;\\n        node.next = cur.next;\\n        cur.next = node;\\n        node.pre = cur;\\n    }\\n    \\n    public String getMaxKey() {\\n        if(Tail.pre.set.size() == 0) return \"\";\\n        return Tail.pre.set.iterator().next();\\n    }\\n    \\n    public String getMinKey() {\\n        if(Head.set.size() != 0) return Head.set.iterator().next();\\n        if(Head.next.set.size() == 0) return \"\";\\n        return Head.next.set.iterator().next();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 648421,
                "title": "python-most-clean-doubly-linkedlist-bests-89-100",
                "content": "```\\nclass Node:\\n    def __init__(self, val= 0):\\n        self.val = val\\n        self.next = None\\n        self.pre = None\\n        self.arr = set()\\n\\n\\nclass AllOne(object):\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.head = Node()\\n        self.tail = Node()\\n        self.head.next, self.tail.pre = self.tail, self.head\\n        self.d = {}\\n        \\n    def move_forward(self, node, key):\\n        if node.val+1 != node.next.val:\\n            newNode = Node(node.val+1)\\n            newNode.pre, newNode.next = node, node.next\\n            newNode.pre.next = newNode.next.pre = newNode\\n        else:\\n            newNode = node.next\\n        newNode.arr.add(key)\\n        return newNode\\n    \\n    def pre(self, node, key):\\n        if node.val-1 != node.pre.val:\\n            newNode = Node(node.val-1)\\n            newNode.pre, newNode.next = node.pre, node\\n            newNode.pre.next = newNode.next.pre = newNode\\n        else:\\n            newNode = node.pre\\n        newNode.arr.add(key)\\n        return newNode\\n\\n    def inc(self, key):\\n        \"\"\"\\n        Inserts a new key <Key> with value 1. Or increments an existing key by 1.\\n        :type key: str\\n        :rtype: None\\n        \"\"\"\\n        if key not in self.d:\\n            node = self.head\\n        else:\\n            node = self.d[key]\\n            node.arr.discard(key)\\n            \\n        self.d[key] = self.move_forward(node, key)\\n        \\n\\n    def dec(self, key):\\n        \"\"\"\\n        Decrements an existing key by 1. If Key\\'s value is 1, remove it from the data structure.\\n        :type key: str\\n        :rtype: None\\n        \"\"\"\\n        if key in self.d:\\n            node = self.d[key]\\n            node.arr.discard(key)\\n            if node.val != 1:\\n                self.d[key] = self.pre(node, key)\\n            else:\\n                del self.d[key]\\n\\n    def getMaxKey(self):\\n        \"\"\"\\n        Returns one of the keys with maximal value.\\n        :rtype: str\\n        \"\"\"\\n        node = self.tail.pre\\n        while node and len(node.arr) == 0:\\n            node = node.pre\\n        \\n        if not node:\\n            return \"\"\\n        \\n        val = node.arr.pop()\\n        node.arr.add(val)\\n        return val\\n        \\n\\n    def getMinKey(self):\\n        \"\"\"\\n        Returns one of the keys with Minimal value.\\n        :rtype: str\\n        \"\"\"\\n        node = self.head.next\\n        while node and len(node.arr) == 0:\\n            node = node.next\\n        if not node:\\n            return \"\"\\n        \\n        val = node.arr.pop()\\n        node.arr.add(val)\\n        return val\\n",
                "solutionTags": [
                    "Python",
                    "Doubly-Linked List"
                ],
                "code": "```\\nclass Node:\\n    def __init__(self, val= 0):\\n        self.val = val\\n        self.next = None\\n        self.pre = None\\n        self.arr = set()\\n\\n\\nclass AllOne(object):\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.head = Node()\\n        self.tail = Node()\\n        self.head.next, self.tail.pre = self.tail, self.head\\n        self.d = {}\\n        \\n    def move_forward(self, node, key):\\n        if node.val+1 != node.next.val:\\n            newNode = Node(node.val+1)\\n            newNode.pre, newNode.next = node, node.next\\n            newNode.pre.next = newNode.next.pre = newNode\\n        else:\\n            newNode = node.next\\n        newNode.arr.add(key)\\n        return newNode\\n    \\n    def pre(self, node, key):\\n        if node.val-1 != node.pre.val:\\n            newNode = Node(node.val-1)\\n            newNode.pre, newNode.next = node.pre, node\\n            newNode.pre.next = newNode.next.pre = newNode\\n        else:\\n            newNode = node.pre\\n        newNode.arr.add(key)\\n        return newNode\\n\\n    def inc(self, key):\\n        \"\"\"\\n        Inserts a new key <Key> with value 1. Or increments an existing key by 1.\\n        :type key: str\\n        :rtype: None\\n        \"\"\"\\n        if key not in self.d:\\n            node = self.head\\n        else:\\n            node = self.d[key]\\n            node.arr.discard(key)\\n            \\n        self.d[key] = self.move_forward(node, key)\\n        \\n\\n    def dec(self, key):\\n        \"\"\"\\n        Decrements an existing key by 1. If Key\\'s value is 1, remove it from the data structure.\\n        :type key: str\\n        :rtype: None\\n        \"\"\"\\n        if key in self.d:\\n            node = self.d[key]\\n            node.arr.discard(key)\\n            if node.val != 1:\\n                self.d[key] = self.pre(node, key)\\n            else:\\n                del self.d[key]\\n\\n    def getMaxKey(self):\\n        \"\"\"\\n        Returns one of the keys with maximal value.\\n        :rtype: str\\n        \"\"\"\\n        node = self.tail.pre\\n        while node and len(node.arr) == 0:\\n            node = node.pre\\n        \\n        if not node:\\n            return \"\"\\n        \\n        val = node.arr.pop()\\n        node.arr.add(val)\\n        return val\\n        \\n\\n    def getMinKey(self):\\n        \"\"\"\\n        Returns one of the keys with Minimal value.\\n        :rtype: str\\n        \"\"\"\\n        node = self.head.next\\n        while node and len(node.arr) == 0:\\n            node = node.next\\n        if not node:\\n            return \"\"\\n        \\n        val = node.arr.pop()\\n        node.arr.add(val)\\n        return val\\n",
                "codeTag": "Java"
            },
            {
                "id": 368505,
                "title": "swift-dictionary-doubly-linkedlist",
                "content": "```\\npublic class ListNode {\\n    public var val: Int\\n    public var next: ListNode?\\n    public var prev: ListNode?\\n    public var lists: Set<String>\\n    private var size = 0\\n    public init(_ val: Int) {\\n        self.val = val\\n        self.lists = Set<String>()\\n    }\\n}\\n\\nclass AllOne {\\n    var head: ListNode\\n    var tail: ListNode\\n    var map = [String: ListNode]()\\n\\n    /** Initialize your data structure here. */\\n    init() {\\n        head = ListNode(0)\\n        tail = ListNode(0)\\n        head.next = tail\\n        tail.prev = head\\n    }\\n\\n    /** Inserts a new key <Key> with value 1. Or increments an existing key by 1. */\\n    func inc(_ key: String) {\\n        if let curNode = map[key] {\\n            attachToNext(curNode, key)\\n            reset(curNode, key)\\n        } else {\\n            attachToNext(head, key)\\n        }\\n    }\\n\\n    /** Decrements an existing key by 1. If Key\\'s value is 1, remove it from the data structure. */\\n    func dec(_ key: String) {\\n        guard let curNode = map[key] else { return }\\n        attachToPrev(curNode, key)\\n        reset(curNode, key)\\n    }\\n\\n    private func attachToNext(_ curNode: ListNode, _ key: String) {\\n        let nextNode = curNode.next!\\n        let v = curNode.val + 1\\n        if nextNode.val == v {\\n            map[key] = nextNode\\n            nextNode.lists.insert(key)\\n        } else {\\n            let newNode = ListNode(v)\\n            newNode.lists.insert(key)\\n            map[key] = newNode\\n            nextNode.prev = newNode\\n            newNode.next = nextNode\\n            curNode.next = newNode\\n            newNode.prev = curNode\\n        }\\n    }\\n\\n    private func attachToPrev(_ curNode: ListNode, _ key: String) {\\n        let prevNode = curNode.prev!\\n        let v = curNode.val - 1\\n        if prevNode.val == v {\\n            map[key] = prevNode\\n            prevNode.lists.insert(key)\\n        } else {\\n            if v != 0 {\\n                let newNode = ListNode(v)\\n                newNode.lists.insert(key)\\n                map[key] = newNode\\n                prevNode.next = newNode\\n                newNode.prev = prevNode\\n                curNode.prev = newNode\\n                newNode.next = curNode\\n            } else {\\n                map[key] = nil\\n            }\\n        }\\n    }\\n\\n    private func reset(_ curNode: ListNode, _ key: String) {\\n        curNode.lists.remove(key)\\n        if curNode.lists.count == 0 {\\n            if let pre = curNode.prev, let nxt = curNode.next {\\n                pre.next = nxt\\n                nxt.prev = pre\\n            }\\n        }\\n    }\\n\\n    /** Returns one of the keys with maximal value. */\\n    func getMaxKey() -> String {\\n        guard let strs = tail.prev?.lists else { return \"\" }\\n        guard let key = strs.first else { return \"\" }\\n        return key\\n    }\\n\\n    /** Returns one of the keys with Minimal value. */\\n    func getMinKey() -> String {\\n        guard let strs = head.next?.lists else { return \"\" }\\n        guard let key = strs.first else { return \"\" }\\n        return key\\n    }\\n}\\n\\n/**\\n * Your AllOne object will be instantiated and called as such:\\n * let obj = AllOne()\\n * obj.inc(key)\\n * obj.dec(key)\\n * let ret_3: String = obj.getMaxKey()\\n * let ret_4: String = obj.getMinKey()\\n */\\n ```",
                "solutionTags": [
                    "Swift",
                    "Doubly-Linked List"
                ],
                "code": "```\\npublic class ListNode {\\n    public var val: Int\\n    public var next: ListNode?\\n    public var prev: ListNode?\\n    public var lists: Set<String>\\n    private var size = 0\\n    public init(_ val: Int) {\\n        self.val = val\\n        self.lists = Set<String>()\\n    }\\n}\\n\\nclass AllOne {\\n    var head: ListNode\\n    var tail: ListNode\\n    var map = [String: ListNode]()\\n\\n    /** Initialize your data structure here. */\\n    init() {\\n        head = ListNode(0)\\n        tail = ListNode(0)\\n        head.next = tail\\n        tail.prev = head\\n    }\\n\\n    /** Inserts a new key <Key> with value 1. Or increments an existing key by 1. */\\n    func inc(_ key: String) {\\n        if let curNode = map[key] {\\n            attachToNext(curNode, key)\\n            reset(curNode, key)\\n        } else {\\n            attachToNext(head, key)\\n        }\\n    }\\n\\n    /** Decrements an existing key by 1. If Key\\'s value is 1, remove it from the data structure. */\\n    func dec(_ key: String) {\\n        guard let curNode = map[key] else { return }\\n        attachToPrev(curNode, key)\\n        reset(curNode, key)\\n    }\\n\\n    private func attachToNext(_ curNode: ListNode, _ key: String) {\\n        let nextNode = curNode.next!\\n        let v = curNode.val + 1\\n        if nextNode.val == v {\\n            map[key] = nextNode\\n            nextNode.lists.insert(key)\\n        } else {\\n            let newNode = ListNode(v)\\n            newNode.lists.insert(key)\\n            map[key] = newNode\\n            nextNode.prev = newNode\\n            newNode.next = nextNode\\n            curNode.next = newNode\\n            newNode.prev = curNode\\n        }\\n    }\\n\\n    private func attachToPrev(_ curNode: ListNode, _ key: String) {\\n        let prevNode = curNode.prev!\\n        let v = curNode.val - 1\\n        if prevNode.val == v {\\n            map[key] = prevNode\\n            prevNode.lists.insert(key)\\n        } else {\\n            if v != 0 {\\n                let newNode = ListNode(v)\\n                newNode.lists.insert(key)\\n                map[key] = newNode\\n                prevNode.next = newNode\\n                newNode.prev = prevNode\\n                curNode.prev = newNode\\n                newNode.next = curNode\\n            } else {\\n                map[key] = nil\\n            }\\n        }\\n    }\\n\\n    private func reset(_ curNode: ListNode, _ key: String) {\\n        curNode.lists.remove(key)\\n        if curNode.lists.count == 0 {\\n            if let pre = curNode.prev, let nxt = curNode.next {\\n                pre.next = nxt\\n                nxt.prev = pre\\n            }\\n        }\\n    }\\n\\n    /** Returns one of the keys with maximal value. */\\n    func getMaxKey() -> String {\\n        guard let strs = tail.prev?.lists else { return \"\" }\\n        guard let key = strs.first else { return \"\" }\\n        return key\\n    }\\n\\n    /** Returns one of the keys with Minimal value. */\\n    func getMinKey() -> String {\\n        guard let strs = head.next?.lists else { return \"\" }\\n        guard let key = strs.first else { return \"\" }\\n        return key\\n    }\\n}\\n\\n/**\\n * Your AllOne object will be instantiated and called as such:\\n * let obj = AllOne()\\n * obj.inc(key)\\n * obj.dec(key)\\n * let ret_3: String = obj.getMaxKey()\\n * let ret_4: String = obj.getMinKey()\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 310065,
                "title": "c-fast-99-51-o-1",
                "content": "```\\nclass AllOne {\\n\\t//Node class to hold the value and set of keys having that value. We will keep a list of nodes sorted by value.Additionally we will keep a map of key to these nodes in the list, to look up for the node corrospoinding to the key.\\n    class Node{\\n    public:\\n      int value;\\n      unordered_set<string> keys;\\n    };\\n    using lit = list<Node>::iterator;\\n    unordered_map<string,lit> keymap;\\n    list<Node> counts;\\npublic:\\n    /** Initialize your data structure here. */\\n    AllOne() {\\n        keymap.clear();\\n        counts.clear();\\n    }\\n    \\n    /** Inserts a new key <Key> with value 1. Or increments an existing key by 1. */\\n    void inc(string key) {\\n        auto pos = counts.end();\\n        auto newpos = pos;\\n        int newcnt=1;\\n        if(keymap.find(key)!=keymap.end()){\\n            //get pos\\n            pos=keymap[key];\\n            newpos=pos;\\n            newpos--;\\n            \\n            //update keymap\\n            newcnt=pos->value+1;\\n            \\n            if(pos == counts.begin() || newpos->value!=newcnt){\\n            newpos = counts.insert(pos,{newcnt,{key}});\\n            } else{\\n                newpos->keys.insert(key);\\n            }\\n            \\n            //update counts\\n            pos->keys.erase(key);\\n            if(!pos->keys.size())counts.erase(pos);\\n            \\n        }else{\\n            newpos=pos;\\n            newpos--;\\n            if(pos == counts.begin() || newpos->value!=newcnt){\\n                newpos = counts.insert(pos,{newcnt,{key}});\\n            } else{\\n                newpos->keys.insert(key);\\n            }\\n        }\\n        keymap[key]=newpos;\\n        return;\\n    }\\n    \\n    /** Decrements an existing key by 1. If Key\\'s value is 1, remove it from the data structure. */\\n    void dec(string key) {\\n        auto pos = counts.end();\\n        auto newpos = pos;\\n        int newcnt=1;\\n        if(keymap.find(key)!=keymap.end()){\\n            //get pos\\n            pos=keymap[key];\\n            newpos=pos;\\n            newpos++;\\n            \\n            //update keymap\\n            newcnt=pos->value-1;\\n            \\n            if(newcnt){\\n                if(newpos == counts.end()  || newpos->value!=newcnt){\\n                newpos = counts.insert(newpos,{newcnt,{key}});\\n                } else{\\n                    newpos->keys.insert(key);\\n                }\\n                keymap[key]=newpos;\\n            } else{\\n                //remove this key\\n                keymap.erase(key);\\n            }\\n            \\n            //update counts\\n            pos->keys.erase(key);\\n            if(!pos->keys.size())counts.erase(pos);\\n        }\\n        \\n        return;\\n    }\\n    \\n    /** Returns one of the keys with maximal value. */\\n    string getMaxKey() {\\n        return counts.size()?*counts.front().keys.begin():\"\";\\n    }\\n    \\n    /** Returns one of the keys with Minimal value. */\\n    string getMinKey() {\\n        return counts.size()?*counts.back().keys.begin():\"\";\\n    }\\n};\\nstatic auto _ =[](){ios::sync_with_stdio(false);cin.tie(nullptr);return 0;}();\\n```",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "```\\nclass AllOne {\\n\\t//Node class to hold the value and set of keys having that value. We will keep a list of nodes sorted by value.Additionally we will keep a map of key to these nodes in the list, to look up for the node corrospoinding to the key.\\n    class Node{\\n    public:\\n      int value;\\n      unordered_set<string> keys;\\n    };\\n    using lit = list<Node>::iterator;\\n    unordered_map<string,lit> keymap;\\n    list<Node> counts;\\npublic:\\n    /** Initialize your data structure here. */\\n    AllOne() {\\n        keymap.clear();\\n        counts.clear();\\n    }\\n    \\n    /** Inserts a new key <Key> with value 1. Or increments an existing key by 1. */\\n    void inc(string key) {\\n        auto pos = counts.end();\\n        auto newpos = pos;\\n        int newcnt=1;\\n        if(keymap.find(key)!=keymap.end()){\\n            //get pos\\n            pos=keymap[key];\\n            newpos=pos;\\n            newpos--;\\n            \\n            //update keymap\\n            newcnt=pos->value+1;\\n            \\n            if(pos == counts.begin() || newpos->value!=newcnt){\\n            newpos = counts.insert(pos,{newcnt,{key}});\\n            } else{\\n                newpos->keys.insert(key);\\n            }\\n            \\n            //update counts\\n            pos->keys.erase(key);\\n            if(!pos->keys.size())counts.erase(pos);\\n            \\n        }else{\\n            newpos=pos;\\n            newpos--;\\n            if(pos == counts.begin() || newpos->value!=newcnt){\\n                newpos = counts.insert(pos,{newcnt,{key}});\\n            } else{\\n                newpos->keys.insert(key);\\n            }\\n        }\\n        keymap[key]=newpos;\\n        return;\\n    }\\n    \\n    /** Decrements an existing key by 1. If Key\\'s value is 1, remove it from the data structure. */\\n    void dec(string key) {\\n        auto pos = counts.end();\\n        auto newpos = pos;\\n        int newcnt=1;\\n        if(keymap.find(key)!=keymap.end()){\\n            //get pos\\n            pos=keymap[key];\\n            newpos=pos;\\n            newpos++;\\n            \\n            //update keymap\\n            newcnt=pos->value-1;\\n            \\n            if(newcnt){\\n                if(newpos == counts.end()  || newpos->value!=newcnt){\\n                newpos = counts.insert(newpos,{newcnt,{key}});\\n                } else{\\n                    newpos->keys.insert(key);\\n                }\\n                keymap[key]=newpos;\\n            } else{\\n                //remove this key\\n                keymap.erase(key);\\n            }\\n            \\n            //update counts\\n            pos->keys.erase(key);\\n            if(!pos->keys.size())counts.erase(pos);\\n        }\\n        \\n        return;\\n    }\\n    \\n    /** Returns one of the keys with maximal value. */\\n    string getMaxKey() {\\n        return counts.size()?*counts.front().keys.begin():\"\";\\n    }\\n    \\n    /** Returns one of the keys with Minimal value. */\\n    string getMinKey() {\\n        return counts.size()?*counts.back().keys.begin():\"\";\\n    }\\n};\\nstatic auto _ =[](){ios::sync_with_stdio(false);cin.tie(nullptr);return 0;}();\\n```",
                "codeTag": "Java"
            },
            {
                "id": 230153,
                "title": "python-double-linkedlist-dictionary-solution-52ms-beats-100",
                "content": "Python double linkedlist + dictionary\\n\\n```\\nclass Node(object):\\n    def __init__(self, key, val=1):\\n        self.key = key\\n        self.val = val\\n        self.prev = None\\n        self.next = None\\n        \\n    def backward(self):\\n        if self.prev.key is not None:\\n            p_, p__, n_ = self.prev, self.prev.prev, self.next\\n            self.prev, self.next, p_.prev, p_.next, p__.next, n_.prev = p__, p_, self, n_, self, p_\\n            \\n    def forward(self):\\n        if self.next.key is not None:\\n            p_, n_, n__ = self.prev, self.next, self.next.next\\n            self.prev, self.next, n_.prev, n_.next, p_.next, n__.prev = n_, n__, p_, self, n_, self\\n\\n\\nclass AllOne(object):\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.keys = dict()\\n        self.head = Node(key=None, val=None)\\n        self.tail = Node(key=None, val=None)\\n        self.head.next, self.tail.prev = self.tail, self.head\\n\\n    def inc(self, key):\\n        \"\"\"\\n        Inserts a new key <Key> with value 1. Or increments an existing key by 1.\\n        :type key: str\\n        :rtype: void\\n        \"\"\"\\n        if key in self.keys:\\n            node = self.keys[key]\\n            node.val += 1\\n            while node.next.key:\\n                if node.val > node.next.val:\\n                    node.forward()\\n                else:\\n                    break\\n        else:\\n            node = Node(key)\\n            self.keys[key] = node\\n            n_ = self.head.next\\n            self.head.next, n_.prev = node, node\\n            node.prev, node.next = self.head, n_\\n\\n    def dec(self, key):\\n        \"\"\"\\n        Decrements an existing key by 1. If Key\\'s value is 1, remove it from the data structure.\\n        :type key: str\\n        :rtype: void\\n        \"\"\"\\n        if key in self.keys:\\n            node = self.keys[key]\\n            if node.val == 1:\\n                node.prev.next = node.next\\n                node.next.prev = node.prev\\n                node.prev, node.next = None, None\\n                del self.keys[key]\\n            else:\\n                node.val -= 1\\n                while node.prev.key:\\n                    if node.val < node.prev.val:\\n                        node.backward()\\n                    else:\\n                        break\\n        \\n    def getMaxKey(self):\\n        \"\"\"\\n        Returns one of the keys with maximal value.\\n        :rtype: str\\n        \"\"\"\\n        return self.tail.prev.key if self.tail.prev.key else \\'\\'\\n\\n    def getMinKey(self):\\n        \"\"\"\\n        Returns one of the keys with Minimal value.\\n        :rtype: str\\n        \"\"\"\\n        return self.head.next.key if self.head.next.key else \\'\\'\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Node(object):\\n    def __init__(self, key, val=1):\\n        self.key = key\\n        self.val = val\\n        self.prev = None\\n        self.next = None\\n        \\n    def backward(self):\\n        if self.prev.key is not None:\\n            p_, p__, n_ = self.prev, self.prev.prev, self.next\\n            self.prev, self.next, p_.prev, p_.next, p__.next, n_.prev = p__, p_, self, n_, self, p_\\n            \\n    def forward(self):\\n        if self.next.key is not None:\\n            p_, n_, n__ = self.prev, self.next, self.next.next\\n            self.prev, self.next, n_.prev, n_.next, p_.next, n__.prev = n_, n__, p_, self, n_, self\\n\\n\\nclass AllOne(object):\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.keys = dict()\\n        self.head = Node(key=None, val=None)\\n        self.tail = Node(key=None, val=None)\\n        self.head.next, self.tail.prev = self.tail, self.head\\n\\n    def inc(self, key):\\n        \"\"\"\\n        Inserts a new key <Key> with value 1. Or increments an existing key by 1.\\n        :type key: str\\n        :rtype: void\\n        \"\"\"\\n        if key in self.keys:\\n            node = self.keys[key]\\n            node.val += 1\\n            while node.next.key:\\n                if node.val > node.next.val:\\n                    node.forward()\\n                else:\\n                    break\\n        else:\\n            node = Node(key)\\n            self.keys[key] = node\\n            n_ = self.head.next\\n            self.head.next, n_.prev = node, node\\n            node.prev, node.next = self.head, n_\\n\\n    def dec(self, key):\\n        \"\"\"\\n        Decrements an existing key by 1. If Key\\'s value is 1, remove it from the data structure.\\n        :type key: str\\n        :rtype: void\\n        \"\"\"\\n        if key in self.keys:\\n            node = self.keys[key]\\n            if node.val == 1:\\n                node.prev.next = node.next\\n                node.next.prev = node.prev\\n                node.prev, node.next = None, None\\n                del self.keys[key]\\n            else:\\n                node.val -= 1\\n                while node.prev.key:\\n                    if node.val < node.prev.val:\\n                        node.backward()\\n                    else:\\n                        break\\n        \\n    def getMaxKey(self):\\n        \"\"\"\\n        Returns one of the keys with maximal value.\\n        :rtype: str\\n        \"\"\"\\n        return self.tail.prev.key if self.tail.prev.key else \\'\\'\\n\\n    def getMinKey(self):\\n        \"\"\"\\n        Returns one of the keys with Minimal value.\\n        :rtype: str\\n        \"\"\"\\n        return self.head.next.key if self.head.next.key else \\'\\'\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 91414,
                "title": "java-one-hashmap-one-doubly-linked-list-solution",
                "content": "```\\npublic class AllOne {\\n    class ListNode {\\n        int value;\\n        Set<String> keys = new HashSet<>();\\n        ListNode prev;\\n        ListNode next;\\n        public ListNode(int value) {\\n            this.value = value;\\n        }\\n        public void removeself() {\\n            this.prev.next = this.next;\\n            this.next.prev = this.prev;\\n        }\\n        public void insert(ListNode prev, ListNode next) {\\n            this.prev = prev;\\n            prev.next = this;\\n            this.next = next;\\n            next.prev = this;\\n        }\\n    }\\n\\n    private Map<String, ListNode> findkey = new HashMap<>();\\n    private ListNode head;\\n    private ListNode tail;\\n\\n    public AllOne() {\\n        head = new ListNode(0);\\n        tail = new ListNode(Integer.MAX_VALUE);\\n        head.next = tail;\\n        tail.prev = head;\\n    }\\n\\n    public void inc(String key) {\\n        if (findkey.containsKey(key)) {\\n            ListNode curNode = findkey.get(key);\\n            ListNode nextNode = curNode.next;\\n            curNode.keys.remove(key);\\n            findkey.remove(key);\\n            if (nextNode.value > curNode.value + 1) {\\n                ListNode newNode = new ListNode(curNode.value + 1);\\n                newNode.insert(curNode, nextNode);\\n                nextNode = newNode;\\n            }\\n            nextNode.keys.add(key);\\n            findkey.put(key, nextNode);\\n            if (curNode.keys.size() == 0) {\\n                curNode.removeself();\\n            }\\n        } else {\\n            if (head.next.value == 1) {\\n                head.next.keys.add(key);\\n                findkey.put(key, head.next);\\n            } else {\\n                ListNode newNode = new ListNode(1);\\n                newNode.insert(head, head.next);\\n                newNode.keys.add(key);\\n                findkey.put(key, newNode);\\n            }\\n        }\\n    }\\n\\n    public void dec(String key) {\\n        if (!findkey.containsKey(key)) {\\n            return;\\n        }\\n        ListNode curNode = findkey.get(key);\\n        curNode.keys.remove(key);\\n        findkey.remove(key, curNode);\\n        if (curNode.value > 1) {\\n            ListNode prevNode = curNode.prev;\\n            if (prevNode.value == curNode.value - 1) {\\n                prevNode.keys.add(key);\\n                findkey.put(key, prevNode);\\n            } else {\\n                ListNode newNode = new ListNode(curNode.value - 1);\\n                newNode.insert(prevNode, curNode);\\n                newNode.keys.add(key);\\n                findkey.put(key, newNode);\\n            }\\n        }\\n        if (curNode.keys.size() == 0) {\\n            curNode.removeself();\\n        }\\n    }\\n\\n    public String getMaxKey() {\\n        return tail.prev == head ? \"\" : tail.prev.keys.iterator().next();\\n    }\\n\\n    public String getMinKey() {\\n        return head.next == tail ? \"\" : head.next.keys.iterator().next();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class AllOne {\\n    class ListNode {\\n        int value;\\n        Set<String> keys = new HashSet<>();\\n        ListNode prev;\\n        ListNode next;\\n        public ListNode(int value) {\\n            this.value = value;\\n        }\\n        public void removeself() {\\n            this.prev.next = this.next;\\n            this.next.prev = this.prev;\\n        }\\n        public void insert(ListNode prev, ListNode next) {\\n            this.prev = prev;\\n            prev.next = this;\\n            this.next = next;\\n            next.prev = this;\\n        }\\n    }\\n\\n    private Map<String, ListNode> findkey = new HashMap<>();\\n    private ListNode head;\\n    private ListNode tail;\\n\\n    public AllOne() {\\n        head = new ListNode(0);\\n        tail = new ListNode(Integer.MAX_VALUE);\\n        head.next = tail;\\n        tail.prev = head;\\n    }\\n\\n    public void inc(String key) {\\n        if (findkey.containsKey(key)) {\\n            ListNode curNode = findkey.get(key);\\n            ListNode nextNode = curNode.next;\\n            curNode.keys.remove(key);\\n            findkey.remove(key);\\n            if (nextNode.value > curNode.value + 1) {\\n                ListNode newNode = new ListNode(curNode.value + 1);\\n                newNode.insert(curNode, nextNode);\\n                nextNode = newNode;\\n            }\\n            nextNode.keys.add(key);\\n            findkey.put(key, nextNode);\\n            if (curNode.keys.size() == 0) {\\n                curNode.removeself();\\n            }\\n        } else {\\n            if (head.next.value == 1) {\\n                head.next.keys.add(key);\\n                findkey.put(key, head.next);\\n            } else {\\n                ListNode newNode = new ListNode(1);\\n                newNode.insert(head, head.next);\\n                newNode.keys.add(key);\\n                findkey.put(key, newNode);\\n            }\\n        }\\n    }\\n\\n    public void dec(String key) {\\n        if (!findkey.containsKey(key)) {\\n            return;\\n        }\\n        ListNode curNode = findkey.get(key);\\n        curNode.keys.remove(key);\\n        findkey.remove(key, curNode);\\n        if (curNode.value > 1) {\\n            ListNode prevNode = curNode.prev;\\n            if (prevNode.value == curNode.value - 1) {\\n                prevNode.keys.add(key);\\n                findkey.put(key, prevNode);\\n            } else {\\n                ListNode newNode = new ListNode(curNode.value - 1);\\n                newNode.insert(prevNode, curNode);\\n                newNode.keys.add(key);\\n                findkey.put(key, newNode);\\n            }\\n        }\\n        if (curNode.keys.size() == 0) {\\n            curNode.removeself();\\n        }\\n    }\\n\\n    public String getMaxKey() {\\n        return tail.prev == head ? \"\" : tail.prev.keys.iterator().next();\\n    }\\n\\n    public String getMinKey() {\\n        return head.next == tail ? \"\" : head.next.keys.iterator().next();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 91443,
                "title": "java-hashmap-constructed-linkedlist-guarantee-o-1-with-explanation",
                "content": "The idea of this problem is quite similar to the LRU cache:\\n[Java] Hashtable + Double linked list (with a touch of pseudo nodes) https://discuss.leetcode.com/topic/6613/java-hashtable-double-linked-list-with-a-touch-of-pseudo-nodes\\n\\nHere, each Node of the linked list holds a several of information: \\nclass member set stores a set of keys with the same value, and count is current value of the keys in set. The reason why we cost so much to construct a linked list is that we want to maintain the order  of the Node sorted by count.\\nNow that the linked list has been constructed, we use a hashmap to map the key to the Node so that we can access the value of this key.\\n\\nIn detail: let's look at the code:\\n```\\nclass Node{\\n    Node pre;\\n    Node next;\\n    int count;\\n    Set<String> set;\\n    Node(int count, String key){\\n        this.count = count;\\n        set = new HashSet<>();\\n        set.add(key);\\n    }\\n    Node(){\\n        \\n    }\\n}\\n\\nclass nodeList{\\n    Node tail;\\n    Node head;\\n    int len;\\n    \\n    nodeList(){ // we maintain a tail and head Node here so that we don't need to check if the nodeList is empty or not. they help simplify the insert and remove function. the value of head and tail defined below always satisfied the linked list order, and won't has consecutive count with their neighbors;\\n        head = new Node();\\n        head.count = -1; \\n        tail = new Node();\\n        tail.count = Integer.MAX_VALUE;\\n        head.next = tail;\\n        tail.pre = head;\\n    }\\n    \\n    void insert(Node node, Node next){ // insert the node in front of the next;\\n        len++;\\n        Node pre = next.pre;\\n        pre.next = node;\\n        node.pre = pre;\\n        node.next = next;\\n        next.pre = node;\\n    }\\n    \\n    void remove(Node node){\\n        Node pre = node.pre;\\n        Node next = node.next;\\n        pre.next = next;\\n        next.pre = pre;\\n        len--;\\n    }\\n}\\n\\npublic class AllOne {\\n    nodeList list;\\n    Map<String, Node> map;\\n\\n    /** Initialize your data structure here. */\\n    public AllOne() {\\n      list = new nodeList();\\n      map = new HashMap<>();\\n    }\\n    \\n    /** Inserts a new key <Key> with value 1. Or increments an existing key by 1. */\\n    public void inc(String key) {\\n        if(map.containsKey(key)){\\n            Node node = map.get(key);\\n            Node next = node.next;\\n            int count = node.count;\\n            \\n            node.set.remove(key); \\n            if(node.set.isEmpty()){\\n                list.remove(node); // we always delete the node whose set is empty, if not; then when we call getMaxKey() or getMinkey() function, it is possible that the leftmost or rightmost(head and tail are exclusive) Node's set is empty, so we have to use a loop to find the one whose set is not empty and O(1) cannot be guaranteed.\\n            }\\n            \\n            if(count + 1 != next.count){ //as the value of the key increased by 1, there is no Node in the linked list whose count is the new value of the key, so we insert a new Node here;\\n                Node newNode = new Node(count + 1, key);\\n                list.insert(newNode, next);\\n                map.put(key, newNode);\\n            }\\n            else{\\n                next.set.add(key);\\n                map.put(key, next);\\n            }\\n        }\\n        else{\\n            Node first = list.head.next;\\n            // check if we have the Node whose count is 1;\\n            if(first.count == 1){\\n                first.set.add(key);\\n                map.put(key, first);\\n            }\\n            else{\\n                Node newNode = new Node(1, key);\\n                list.insert(newNode, first);\\n                map.put(key, newNode);\\n            }\\n        }\\n    }\\n    \\n    /** Decrements an existing key by 1. If Key's value is 1, remove it from the data structure. */\\n    public void dec(String key) {\\n        if(map.containsKey(key)){\\n            Node node = map.get(key);\\n            Node pre = node.pre;\\n            int count = node.count;\\n            node.set.remove(key);\\n            \\n            if(node.set.isEmpty()){\\n                list.remove(node);\\n            }\\n           \\n            if(pre.count == count - 1){\\n                pre.set.add(key);\\n                map.put(key, pre);\\n            }\\n            else if(count > 1){\\n                Node newNode = new Node(count - 1, key);\\n                list.insert(newNode, pre.next);\\n                map.put(key, newNode);\\n            }\\n            else{\\n                map.remove(key);\\n            }\\n        }\\n    }\\n    \\n    /** Returns one of the keys with maximal value. */\\n    public String getMaxKey() {\\n       if(list.len != 0){\\n           Node node = list.tail.pre;\\n           for(String str : node.set){\\n               return str;\\n           }\\n       }\\n       return \"\";\\n    }\\n    \\n    /** Returns one of the keys with Minimal value. */\\n    public String getMinKey() {\\n        if(list.len != 0){\\n            Node node = list.head.next;\\n            for(String str : node.set){\\n                return str;\\n            }\\n        }\\n        \\n        return \"\";\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Node{\\n    Node pre;\\n    Node next;\\n    int count;\\n    Set<String> set;\\n    Node(int count, String key){\\n        this.count = count;\\n        set = new HashSet<>();\\n        set.add(key);\\n    }\\n    Node(){\\n        \\n    }\\n}\\n\\nclass nodeList{\\n    Node tail;\\n    Node head;\\n    int len;\\n    \\n    nodeList(){ // we maintain a tail and head Node here so that we don't need to check if the nodeList is empty or not. they help simplify the insert and remove function. the value of head and tail defined below always satisfied the linked list order, and won't has consecutive count with their neighbors;\\n        head = new Node();\\n        head.count = -1; \\n        tail = new Node();\\n        tail.count = Integer.MAX_VALUE;\\n        head.next = tail;\\n        tail.pre = head;\\n    }\\n    \\n    void insert(Node node, Node next){ // insert the node in front of the next;\\n        len++;\\n        Node pre = next.pre;\\n        pre.next = node;\\n        node.pre = pre;\\n        node.next = next;\\n        next.pre = node;\\n    }\\n    \\n    void remove(Node node){\\n        Node pre = node.pre;\\n        Node next = node.next;\\n        pre.next = next;\\n        next.pre = pre;\\n        len--;\\n    }\\n}\\n\\npublic class AllOne {\\n    nodeList list;\\n    Map<String, Node> map;\\n\\n    /** Initialize your data structure here. */\\n    public AllOne() {\\n      list = new nodeList();\\n      map = new HashMap<>();\\n    }\\n    \\n    /** Inserts a new key <Key> with value 1. Or increments an existing key by 1. */\\n    public void inc(String key) {\\n        if(map.containsKey(key)){\\n            Node node = map.get(key);\\n            Node next = node.next;\\n            int count = node.count;\\n            \\n            node.set.remove(key); \\n            if(node.set.isEmpty()){\\n                list.remove(node); // we always delete the node whose set is empty, if not; then when we call getMaxKey() or getMinkey() function, it is possible that the leftmost or rightmost(head and tail are exclusive) Node's set is empty, so we have to use a loop to find the one whose set is not empty and O(1) cannot be guaranteed.\\n            }\\n            \\n            if(count + 1 != next.count){ //as the value of the key increased by 1, there is no Node in the linked list whose count is the new value of the key, so we insert a new Node here;\\n                Node newNode = new Node(count + 1, key);\\n                list.insert(newNode, next);\\n                map.put(key, newNode);\\n            }\\n            else{\\n                next.set.add(key);\\n                map.put(key, next);\\n            }\\n        }\\n        else{\\n            Node first = list.head.next;\\n            // check if we have the Node whose count is 1;\\n            if(first.count == 1){\\n                first.set.add(key);\\n                map.put(key, first);\\n            }\\n            else{\\n                Node newNode = new Node(1, key);\\n                list.insert(newNode, first);\\n                map.put(key, newNode);\\n            }\\n        }\\n    }\\n    \\n    /** Decrements an existing key by 1. If Key's value is 1, remove it from the data structure. */\\n    public void dec(String key) {\\n        if(map.containsKey(key)){\\n            Node node = map.get(key);\\n            Node pre = node.pre;\\n            int count = node.count;\\n            node.set.remove(key);\\n            \\n            if(node.set.isEmpty()){\\n                list.remove(node);\\n            }\\n           \\n            if(pre.count == count - 1){\\n                pre.set.add(key);\\n                map.put(key, pre);\\n            }\\n            else if(count > 1){\\n                Node newNode = new Node(count - 1, key);\\n                list.insert(newNode, pre.next);\\n                map.put(key, newNode);\\n            }\\n            else{\\n                map.remove(key);\\n            }\\n        }\\n    }\\n    \\n    /** Returns one of the keys with maximal value. */\\n    public String getMaxKey() {\\n       if(list.len != 0){\\n           Node node = list.tail.pre;\\n           for(String str : node.set){\\n               return str;\\n           }\\n       }\\n       return \"\";\\n    }\\n    \\n    /** Returns one of the keys with Minimal value. */\\n    public String getMinKey() {\\n        if(list.len != 0){\\n            Node node = list.head.next;\\n            for(String str : node.set){\\n                return str;\\n            }\\n        }\\n        \\n        return \"\";\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 91460,
                "title": "java-o-1-doubly-link-list-accepted",
                "content": "```\\nimport java.util.HashMap;\\nimport java.util.Map;\\n\\n/**\\n * Created by debabrata_sharma on 10/17/16.\\n */\\npublic class AllOne {\\n\\n    public class Node {\\n        Node next, prev;\\n        private String key;\\n        private int val;\\n\\n        public Node(String key, int val) {\\n            this.key = key;\\n            this.val = val;\\n        }\\n\\n    }\\n\\n    Node head, tail;\\n    Map<String, Node> map;\\n\\n    /**\\n     * Initialize your data structure here.\\n     */\\n    public AllOne() {\\n\\n        map = new HashMap<String, Node>();\\n        head = new Node(\"\", Integer.MAX_VALUE);\\n        tail = new Node(\"\", Integer.MIN_VALUE);\\n        head.next = tail;\\n        tail.prev = head;\\n\\n    }\\n\\n\\n    /**\\n     * Inserts a new key <Key> with value 1. Or increments an existing key by 1.\\n     */\\n    public void inc(String key) {\\n\\n        if (map.containsKey(key)) {\\n            Node node = map.get(key);\\n            node.val++;\\n            if(node.val>=head.next.val){\\n                removeNode(node);\\n                addToHead(node);\\n            }\\n        } else {\\n            Node node = new Node(key, 1);\\n            map.put(key, node);\\n            addToTail(node);\\n        }\\n    }\\n\\n    /**\\n     * Decrements an existing key by 1. If Key's value is 1, remove it from the data structure.\\n     */\\n    public void dec(String key) {\\n\\n        if (map.containsKey(key)) {\\n            Node node = map.get(key);\\n            if (node.val == 1) {\\n                map.remove(key);\\n                removeNode(node);\\n            } else {\\n\\n                node.val--;\\n\\n                if( node.val<tail.prev.val ){\\n                    removeNode(node);\\n                    addToTail(node);\\n                }\\n                if(node.key==head.next.key){\\n                    if (node.val<=head.next.val) {\\n                        removeNode(node);\\n                        addNextToHead(node);\\n                    }\\n                }\\n\\n            }\\n        } else {\\n            return;\\n        }\\n\\n    }\\n\\n    /**\\n     * Returns one of the keys with maximal value.\\n     */\\n    public String getMaxKey() {\\n\\n        return head.next.key;\\n    }\\n\\n    /**\\n     * Returns one of the keys with Minimal value.\\n     */\\n    public String getMinKey() {\\n        return tail.prev.key;\\n    }\\n\\n    private void removeNode(Node node){\\n\\n        node.prev.next=node.next;\\n        node.next.prev=node.prev;\\n        node.prev=null;\\n        node.next=null;\\n\\n    }\\n\\n    private void addToTail(Node node) {\\n\\n        tail.prev.next = node;\\n        node.prev = tail.prev;\\n\\n        node.next = tail;\\n        tail.prev = node;\\n\\n\\n    }\\n\\n    private void addToHead(Node node) {\\n\\n        head.next.prev = node;\\n        node.next = head.next;\\n        node.prev = head;\\n        head.next = node;\\n\\n\\n    }\\n    private void addNextToHead(Node node) {\\n\\n        head.next.next.prev = node;\\n        node.next = head.next.next;\\n        node.prev = head.next;\\n        head.next.next = node;\\n\\n\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimport java.util.HashMap;\\nimport java.util.Map;\\n\\n/**\\n * Created by debabrata_sharma on 10/17/16.\\n */\\npublic class AllOne {\\n\\n    public class Node {\\n        Node next, prev;\\n        private String key;\\n        private int val;\\n\\n        public Node(String key, int val) {\\n            this.key = key;\\n            this.val = val;\\n        }\\n\\n    }\\n\\n    Node head, tail;\\n    Map<String, Node> map;\\n\\n    /**\\n     * Initialize your data structure here.\\n     */\\n    public AllOne() {\\n\\n        map = new HashMap<String, Node>();\\n        head = new Node(\"\", Integer.MAX_VALUE);\\n        tail = new Node(\"\", Integer.MIN_VALUE);\\n        head.next = tail;\\n        tail.prev = head;\\n\\n    }\\n\\n\\n    /**\\n     * Inserts a new key <Key> with value 1. Or increments an existing key by 1.\\n     */\\n    public void inc(String key) {\\n\\n        if (map.containsKey(key)) {\\n            Node node = map.get(key);\\n            node.val++;\\n            if(node.val>=head.next.val){\\n                removeNode(node);\\n                addToHead(node);\\n            }\\n        } else {\\n            Node node = new Node(key, 1);\\n            map.put(key, node);\\n            addToTail(node);\\n        }\\n    }\\n\\n    /**\\n     * Decrements an existing key by 1. If Key's value is 1, remove it from the data structure.\\n     */\\n    public void dec(String key) {\\n\\n        if (map.containsKey(key)) {\\n            Node node = map.get(key);\\n            if (node.val == 1) {\\n                map.remove(key);\\n                removeNode(node);\\n            } else {\\n\\n                node.val--;\\n\\n                if( node.val<tail.prev.val ){\\n                    removeNode(node);\\n                    addToTail(node);\\n                }\\n                if(node.key==head.next.key){\\n                    if (node.val<=head.next.val) {\\n                        removeNode(node);\\n                        addNextToHead(node);\\n                    }\\n                }\\n\\n            }\\n        } else {\\n            return;\\n        }\\n\\n    }\\n\\n    /**\\n     * Returns one of the keys with maximal value.\\n     */\\n    public String getMaxKey() {\\n\\n        return head.next.key;\\n    }\\n\\n    /**\\n     * Returns one of the keys with Minimal value.\\n     */\\n    public String getMinKey() {\\n        return tail.prev.key;\\n    }\\n\\n    private void removeNode(Node node){\\n\\n        node.prev.next=node.next;\\n        node.next.prev=node.prev;\\n        node.prev=null;\\n        node.next=null;\\n\\n    }\\n\\n    private void addToTail(Node node) {\\n\\n        tail.prev.next = node;\\n        node.prev = tail.prev;\\n\\n        node.next = tail;\\n        tail.prev = node;\\n\\n\\n    }\\n\\n    private void addToHead(Node node) {\\n\\n        head.next.prev = node;\\n        node.next = head.next;\\n        node.prev = head;\\n        head.next = node;\\n\\n\\n    }\\n    private void addNextToHead(Node node) {\\n\\n        head.next.next.prev = node;\\n        node.next = head.next.next;\\n        node.prev = head.next;\\n        head.next.next = node;\\n\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3928088,
                "title": "java-clean-code-treemap-hashmap",
                "content": "# Approach\\n1. Use two maps that will store:\\n    - stringCount<String, Integer> HashMap the count of each string\\n    - bucketMap<Integer, Set<String>> TreeMap stores the string grouped by count\\n2. Increment function\\n    - increment the count of that string inside stringCount\\n    - remove the string from the bucket of old count\\n    - add the string to the bucket of new count\\n3. Decrement\\n    - decrement the count of that string from stringCount\\n    - remove the string from the bucket of old count\\n    - add the string to the bucket of new count\\n4. Min/Max : return one value from the firstEntry/lastEntry set of bucketMap   \\n\\n# Complexity\\n- Time complexity:\\n    - inc/dec: $$O(log(n))$$; \\n    - min/max: $$O(log(n))$$;\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass AllOne {\\n    private final Map<String, Integer> stringCount;\\n    private final TreeMap<Integer, Set<String>> bucketMap;\\n    public AllOne() {\\n        stringCount = new HashMap<>();\\n        bucketMap = new TreeMap<>();\\n    }\\n    \\n    public void inc(String key) {\\n        int newCount = stringCount.merge(key, 1, Integer::sum);\\n        removeFromOldBucket(key, newCount - 1);\\n        addToNewBucket(key, newCount);\\n    }\\n    \\n    public void dec(String key) {\\n        int newCount = stringCount.merge(key, -1, Integer::sum);\\n        if (newCount == 0) {\\n            stringCount.remove(key);\\n        }\\n        removeFromOldBucket(key, newCount + 1);\\n        addToNewBucket(key, newCount);\\n    }\\n\\n    private void removeFromOldBucket(String key, int bucketKey) {\\n        if (bucketKey > 0) {\\n            Set<String> oldBucket = bucketMap.get(bucketKey);\\n            if (oldBucket.size() == 1) {\\n                oldBucket.clear();\\n                bucketMap.remove(bucketKey);\\n            } else {\\n                oldBucket.remove(key);\\n            }\\n        }\\n    }\\n\\n    private void addToNewBucket(String key, int bucketKey) {\\n        if (bucketKey > 0) {\\n            bucketMap.computeIfAbsent(bucketKey, k -> new HashSet<>()).add(key);\\n        }\\n    }\\n\\n    public String getMaxKey() {\\n        return bucketMap.isEmpty() ? \"\" : bucketMap.lastEntry().getValue().iterator().next();\\n    }\\n    \\n    public String getMinKey() {\\n        return bucketMap.isEmpty() ? \"\" : bucketMap.firstEntry().getValue().iterator().next();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass AllOne {\\n    private final Map<String, Integer> stringCount;\\n    private final TreeMap<Integer, Set<String>> bucketMap;\\n    public AllOne() {\\n        stringCount = new HashMap<>();\\n        bucketMap = new TreeMap<>();\\n    }\\n    \\n    public void inc(String key) {\\n        int newCount = stringCount.merge(key, 1, Integer::sum);\\n        removeFromOldBucket(key, newCount - 1);\\n        addToNewBucket(key, newCount);\\n    }\\n    \\n    public void dec(String key) {\\n        int newCount = stringCount.merge(key, -1, Integer::sum);\\n        if (newCount == 0) {\\n            stringCount.remove(key);\\n        }\\n        removeFromOldBucket(key, newCount + 1);\\n        addToNewBucket(key, newCount);\\n    }\\n\\n    private void removeFromOldBucket(String key, int bucketKey) {\\n        if (bucketKey > 0) {\\n            Set<String> oldBucket = bucketMap.get(bucketKey);\\n            if (oldBucket.size() == 1) {\\n                oldBucket.clear();\\n                bucketMap.remove(bucketKey);\\n            } else {\\n                oldBucket.remove(key);\\n            }\\n        }\\n    }\\n\\n    private void addToNewBucket(String key, int bucketKey) {\\n        if (bucketKey > 0) {\\n            bucketMap.computeIfAbsent(bucketKey, k -> new HashSet<>()).add(key);\\n        }\\n    }\\n\\n    public String getMaxKey() {\\n        return bucketMap.isEmpty() ? \"\" : bucketMap.lastEntry().getValue().iterator().next();\\n    }\\n    \\n    public String getMinKey() {\\n        return bucketMap.isEmpty() ? \"\" : bucketMap.firstEntry().getValue().iterator().next();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3899351,
                "title": "solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#include <string>\\n#include <unordered_map>\\n#include <unordered_set>\\n#include <list>\\n\\nclass AllOne {\\n public:\\n  void inc(string key) {\\n    const auto it = keyToIterator.find(key);\\n\\n    if (it == keyToIterator.cend()) {\\n      if (l.empty() || l.front().value > 1)\\n        l.push_front({1, {key}});\\n      else\\n        l.front().keys.insert(key);\\n      keyToIterator[key] = l.begin();\\n      return;\\n    }\\n\\n    const auto lit = it->second;\\n    auto nit = next(lit);\\n\\n    if (nit == l.end() || nit->value > lit->value + 1)\\n      nit = l.insert(nit, {lit->value + 1, {key}});\\n    else\\n      nit->keys.insert(key);\\n    keyToIterator[key] = nit;\\n\\n    lit->keys.erase(key);\\n    if (lit->keys.empty())\\n      l.erase(lit);\\n  }\\n\\n  void dec(string key) {\\n    const auto it = keyToIterator.find(key);\\n\\n    if (it == keyToIterator.cend())\\n      return;\\n\\n    const auto lit = it->second;\\n\\n    if (lit->value == 1) {\\n      keyToIterator.erase(key);\\n      lit->keys.erase(key);\\n      if (lit->keys.empty())\\n        l.erase(lit);\\n      return;\\n    } else {\\n      auto pit = prev(lit);\\n\\n      if (lit == l.begin() || pit->value < lit->value - 1)\\n        pit = l.insert(lit, {lit->value - 1, {key}});\\n      else\\n        pit->keys.insert(key);\\n      keyToIterator[key] = pit;\\n    }\\n\\n    lit->keys.erase(key);\\n    if (lit->keys.empty())\\n      l.erase(lit);\\n  }\\n\\n  string getMaxKey() {\\n    return l.empty() ? \"\" : *l.back().keys.begin();\\n  }\\n\\n  string getMinKey() {\\n    return l.empty() ? \"\" : *l.front().keys.begin();\\n  }\\n\\n private:\\n  struct Node {\\n    int value;\\n    unordered_set<string> keys;\\n  };\\n\\n  list<Node> l;\\n  unordered_map<string, list<Node>::iterator> keyToIterator;\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#include <string>\\n#include <unordered_map>\\n#include <unordered_set>\\n#include <list>\\n\\nclass AllOne {\\n public:\\n  void inc(string key) {\\n    const auto it = keyToIterator.find(key);\\n\\n    if (it == keyToIterator.cend()) {\\n      if (l.empty() || l.front().value > 1)\\n        l.push_front({1, {key}});\\n      else\\n        l.front().keys.insert(key);\\n      keyToIterator[key] = l.begin();\\n      return;\\n    }\\n\\n    const auto lit = it->second;\\n    auto nit = next(lit);\\n\\n    if (nit == l.end() || nit->value > lit->value + 1)\\n      nit = l.insert(nit, {lit->value + 1, {key}});\\n    else\\n      nit->keys.insert(key);\\n    keyToIterator[key] = nit;\\n\\n    lit->keys.erase(key);\\n    if (lit->keys.empty())\\n      l.erase(lit);\\n  }\\n\\n  void dec(string key) {\\n    const auto it = keyToIterator.find(key);\\n\\n    if (it == keyToIterator.cend())\\n      return;\\n\\n    const auto lit = it->second;\\n\\n    if (lit->value == 1) {\\n      keyToIterator.erase(key);\\n      lit->keys.erase(key);\\n      if (lit->keys.empty())\\n        l.erase(lit);\\n      return;\\n    } else {\\n      auto pit = prev(lit);\\n\\n      if (lit == l.begin() || pit->value < lit->value - 1)\\n        pit = l.insert(lit, {lit->value - 1, {key}});\\n      else\\n        pit->keys.insert(key);\\n      keyToIterator[key] = pit;\\n    }\\n\\n    lit->keys.erase(key);\\n    if (lit->keys.empty())\\n      l.erase(lit);\\n  }\\n\\n  string getMaxKey() {\\n    return l.empty() ? \"\" : *l.back().keys.begin();\\n  }\\n\\n  string getMinKey() {\\n    return l.empty() ? \"\" : *l.front().keys.begin();\\n  }\\n\\n private:\\n  struct Node {\\n    int value;\\n    unordered_set<string> keys;\\n  };\\n\\n  list<Node> l;\\n  unordered_map<string, list<Node>::iterator> keyToIterator;\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3658445,
                "title": "java-two-hashmaps-o-1-average",
                "content": "# Intuition\\n# Approach\\nWe can track keys to their frequences and frequences to the keys maintaining min frequency and max frequency.\\n\\n\\n# Complexity\\n- Time complexity: O(1) except the case when the min frequency element gets deleted. Then we have to go up from 0 to the max frequency to find a new minimum.\\n\\n- - Space complexity: O(N)\\n\\n# Code\\n```\\nclass AllOne {\\n    Map<String,Integer> keyToFreq;\\n    Map<Integer,Set<String>> freqToKeys;\\n    int minFreq;\\n    int maxFreq;\\n\\n    public AllOne() {\\n        this.keyToFreq = new HashMap<>();\\n        this.freqToKeys = new HashMap<>();\\n        this.minFreq = Integer.MAX_VALUE;\\n        this.maxFreq = 0;       \\n    }\\n    \\n    public void inc(String key) {\\n        if( keyToFreq.containsKey(key) ){\\n            int freq = keyToFreq.get(key);\\n            keyToFreq.put(key, freq+1);\\n            freqToKeys.computeIfAbsent(freq+1, k->new HashSet<>()).add(key);\\n\\n            freqToKeys.get(freq).remove(key);\\n            if( freqToKeys.get(freq).isEmpty() ){\\n                freqToKeys.remove(freq);\\n\\n                if(freq == minFreq)\\n                    minFreq = freq+1;\\n            }\\n            maxFreq = Math.max(maxFreq, freq+1);\\n        }\\n        else {\\n            keyToFreq.put(key, 1);\\n            freqToKeys.computeIfAbsent(1, k->new HashSet<>()).add(key);\\n            minFreq = Math.min(minFreq, 1);\\n            maxFreq = Math.max(maxFreq, 1);\\n        }\\n    }\\n    \\n    public void dec(String key) {\\n        int freq = keyToFreq.get(key);\\n        if(freq == 1){\\n            keyToFreq.remove(key);\\n\\n            freqToKeys.get(freq).remove(key);\\n            if( freqToKeys.get(freq).isEmpty() ){\\n                freqToKeys.remove(freq);\\n\\n                if(freq == maxFreq)\\n                    maxFreq = freq-1; // 0\\n\\n                if(freq == minFreq){\\n                    for(int i=1; i<=maxFreq; i++){\\n                        if( freqToKeys.containsKey(i) ){\\n                            minFreq = i;\\n                            break;\\n                        }\\n                    }\\n                }\\n            }\\n            // minFreq is not affected\\n        }\\n        else {\\n            keyToFreq.put(key, freq-1);\\n            freqToKeys.computeIfAbsent(freq-1, k->new HashSet<>()).add(key);\\n\\n            freqToKeys.get(freq).remove(key);\\n            if( freqToKeys.get(freq).isEmpty() ){\\n                freqToKeys.remove(freq);\\n\\n                if(freq == maxFreq)\\n                    maxFreq = freq-1;\\n            }\\n            minFreq = Math.min(minFreq, freq-1);\\n        }\\n    }\\n    \\n    public String getMaxKey() {\\n        return !freqToKeys.isEmpty() ? freqToKeys.get(maxFreq).iterator().next() : \"\";\\n    }\\n    \\n    public String getMinKey() {\\n        return !freqToKeys.isEmpty() ? freqToKeys.get(minFreq).iterator().next() : \"\";\\n    }\\n}\\n\\n/**\\n * Your AllOne object will be instantiated and called as such:\\n * AllOne obj = new AllOne();\\n * obj.inc(key);\\n * obj.dec(key);\\n * String param_3 = obj.getMaxKey();\\n * String param_4 = obj.getMinKey();\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass AllOne {\\n    Map<String,Integer> keyToFreq;\\n    Map<Integer,Set<String>> freqToKeys;\\n    int minFreq;\\n    int maxFreq;\\n\\n    public AllOne() {\\n        this.keyToFreq = new HashMap<>();\\n        this.freqToKeys = new HashMap<>();\\n        this.minFreq = Integer.MAX_VALUE;\\n        this.maxFreq = 0;       \\n    }\\n    \\n    public void inc(String key) {\\n        if( keyToFreq.containsKey(key) ){\\n            int freq = keyToFreq.get(key);\\n            keyToFreq.put(key, freq+1);\\n            freqToKeys.computeIfAbsent(freq+1, k->new HashSet<>()).add(key);\\n\\n            freqToKeys.get(freq).remove(key);\\n            if( freqToKeys.get(freq).isEmpty() ){\\n                freqToKeys.remove(freq);\\n\\n                if(freq == minFreq)\\n                    minFreq = freq+1;\\n            }\\n            maxFreq = Math.max(maxFreq, freq+1);\\n        }\\n        else {\\n            keyToFreq.put(key, 1);\\n            freqToKeys.computeIfAbsent(1, k->new HashSet<>()).add(key);\\n            minFreq = Math.min(minFreq, 1);\\n            maxFreq = Math.max(maxFreq, 1);\\n        }\\n    }\\n    \\n    public void dec(String key) {\\n        int freq = keyToFreq.get(key);\\n        if(freq == 1){\\n            keyToFreq.remove(key);\\n\\n            freqToKeys.get(freq).remove(key);\\n            if( freqToKeys.get(freq).isEmpty() ){\\n                freqToKeys.remove(freq);\\n\\n                if(freq == maxFreq)\\n                    maxFreq = freq-1; // 0\\n\\n                if(freq == minFreq){\\n                    for(int i=1; i<=maxFreq; i++){\\n                        if( freqToKeys.containsKey(i) ){\\n                            minFreq = i;\\n                            break;\\n                        }\\n                    }\\n                }\\n            }\\n            // minFreq is not affected\\n        }\\n        else {\\n            keyToFreq.put(key, freq-1);\\n            freqToKeys.computeIfAbsent(freq-1, k->new HashSet<>()).add(key);\\n\\n            freqToKeys.get(freq).remove(key);\\n            if( freqToKeys.get(freq).isEmpty() ){\\n                freqToKeys.remove(freq);\\n\\n                if(freq == maxFreq)\\n                    maxFreq = freq-1;\\n            }\\n            minFreq = Math.min(minFreq, freq-1);\\n        }\\n    }\\n    \\n    public String getMaxKey() {\\n        return !freqToKeys.isEmpty() ? freqToKeys.get(maxFreq).iterator().next() : \"\";\\n    }\\n    \\n    public String getMinKey() {\\n        return !freqToKeys.isEmpty() ? freqToKeys.get(minFreq).iterator().next() : \"\";\\n    }\\n}\\n\\n/**\\n * Your AllOne object will be instantiated and called as such:\\n * AllOne obj = new AllOne();\\n * obj.inc(key);\\n * obj.dec(key);\\n * String param_3 = obj.getMaxKey();\\n * String param_4 = obj.getMinKey();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3320416,
                "title": "o-1-tc-double-linkedlist-hashmap",
                "content": "# Intuition\\nDouble Linked List, Hash Map.\\nTricky to implement at first, but interviewer will be accpeting similar soultion rather than using sorting.\\n\\n# Approach\\nHashMap --> to keep tarck of current node in linkedlist.\\nLinkedList --> to keep track of string with frequency.\\n\\n# Complexity\\n- Time complexity: O(1)\\n- Space complexity: O(1), as per questions auxiliary space will be required to keep the current string with freq >= 1. \\n\\n# Code\\n```\\n// DoubleLinkedList and Map\\nconst dll = function(freq, ele, prev, next) {\\n    this.freq = freq;\\n    this.next = next?next:null;\\n    this.prev = prev?prev:null;\\n    this.ele = new Set();\\n    if(ele) {\\n        this.ele.add(ele)\\n    }\\n}\\nvar AllOne = function() {\\n    this.nodeMap = new Map();\\n    this.head = null;\\n    this.tail = null;\\n};\\n\\n/** \\n * @param {string} key\\n * @return {void}\\n */\\nAllOne.prototype.addtodll = function (key, node) {\\n    let temp;\\n    if(!node) {\\n        if(!this.head) {\\n            temp = new dll(1, key);\\n            this.head = temp;\\n            this.tail = temp;\\n        } else {\\n            if(this.head.freq === 1) {\\n                temp = this.head;\\n                this.head.ele.add(key);\\n            } else {\\n                temp = new dll(1, key, null, this.head);\\n                this.head.prev = temp;\\n                this.head = temp;\\n            }\\n        }\\n    } else {\\n        let c_node = node;\\n        let n_node = node.next;\\n        let n_freq = node.freq + 1;\\n        if(n_node === null) {\\n            temp = new dll(n_freq, key, c_node, null);\\n            this.tail = temp;\\n            c_node.next = temp;\\n        } else if (n_node.freq === n_freq){\\n            temp = n_node;\\n            temp.ele.add(key);\\n        } else {\\n            temp = new dll(n_freq, key, c_node, c_node.next);\\n            c_node.next = temp;\\n            temp.next.prev = temp;\\n        }\\n\\n        c_node.ele.delete(key);\\n        if(c_node.ele.size === 0) {\\n            if(c_node.prev === null) {\\n                this.head = c_node.next;\\n                c_node.next.prev = null\\n            } else {\\n                c_node.prev.next = temp;\\n                temp.prev = c_node.prev;\\n            }\\n        }\\n\\n    }\\n    return temp;\\n}\\nAllOne.prototype.inc = function(key) {\\n    let c_node = this.addtodll(key, this.nodeMap.get(key));\\n    this.nodeMap.set(key, c_node);\\n};\\n\\n/** \\n * @param {string} key\\n * @return {void}\\n */\\nAllOne.prototype.removefromdll = function(key, node) {\\n    let c_freq = node.freq;\\n    let r_freq = c_freq - 1;\\n    let temp;\\n    if(c_freq === 1) {\\n        node.ele.delete(key);\\n        if(node.ele.size === 0) {\\n            if(this.head === this.tail) {\\n                this.head = null;\\n                this.tail = null;\\n            } else {\\n                this.head = node.next;\\n                node.next.prev = null;\\n            }\\n        }\\n        return null;\\n    } else {\\n        if(node.prev === null) {\\n            temp = new dll(r_freq, key, null, node);\\n            this.head = temp;\\n            node.prev = temp;\\n        } else if(node.prev.freq === r_freq) {\\n            temp = node.prev;\\n            temp.ele.add(key);\\n        } else {\\n            temp = new dll(r_freq, key, node.prev, node);\\n            node.prev.next = temp;\\n            node.prev = temp;\\n        }\\n\\n        node.ele.delete(key);\\n        if(node.ele.size === 0) {\\n            if(node.next === null) {\\n                this.tail = node.prev;\\n                temp.next = null;\\n            } else {\\n                node.next.prev = temp;\\n                temp.next = node.next;\\n            }\\n        }\\n    }\\n    return temp;\\n}\\nAllOne.prototype.dec = function(key) {\\n    let c_node = this.removefromdll(key, this.nodeMap.get(key));\\n    if(c_node) {\\n        this.nodeMap.set(key, c_node);\\n    } else {\\n        this.nodeMap.delete(key)\\n    }\\n};\\n\\n/**\\n * @return {string}\\n */\\nAllOne.prototype.getMaxKey = function() {\\n    if(this.tail) {\\n        const [f] = this.tail.ele;\\n        return f\\n    }\\n    return \\'\\';\\n};\\n\\n/**\\n * @return {string}\\n */\\nAllOne.prototype.getMinKey = function() {\\n    if(this.head) {\\n        const [f] = this.head.ele;\\n        return f\\n    }\\n    return \\'\\'\\n};\\n\\n/** \\n * Your AllOne object will be instantiated and called as such:\\n * var obj = new AllOne()\\n * obj.inc(key)\\n * obj.dec(key)\\n * var param_3 = obj.getMaxKey()\\n * var param_4 = obj.getMinKey()\\n */\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Hash Table",
                    "Doubly-Linked List"
                ],
                "code": "```\\n// DoubleLinkedList and Map\\nconst dll = function(freq, ele, prev, next) {\\n    this.freq = freq;\\n    this.next = next?next:null;\\n    this.prev = prev?prev:null;\\n    this.ele = new Set();\\n    if(ele) {\\n        this.ele.add(ele)\\n    }\\n}\\nvar AllOne = function() {\\n    this.nodeMap = new Map();\\n    this.head = null;\\n    this.tail = null;\\n};\\n\\n/** \\n * @param {string} key\\n * @return {void}\\n */\\nAllOne.prototype.addtodll = function (key, node) {\\n    let temp;\\n    if(!node) {\\n        if(!this.head) {\\n            temp = new dll(1, key);\\n            this.head = temp;\\n            this.tail = temp;\\n        } else {\\n            if(this.head.freq === 1) {\\n                temp = this.head;\\n                this.head.ele.add(key);\\n            } else {\\n                temp = new dll(1, key, null, this.head);\\n                this.head.prev = temp;\\n                this.head = temp;\\n            }\\n        }\\n    } else {\\n        let c_node = node;\\n        let n_node = node.next;\\n        let n_freq = node.freq + 1;\\n        if(n_node === null) {\\n            temp = new dll(n_freq, key, c_node, null);\\n            this.tail = temp;\\n            c_node.next = temp;\\n        } else if (n_node.freq === n_freq){\\n            temp = n_node;\\n            temp.ele.add(key);\\n        } else {\\n            temp = new dll(n_freq, key, c_node, c_node.next);\\n            c_node.next = temp;\\n            temp.next.prev = temp;\\n        }\\n\\n        c_node.ele.delete(key);\\n        if(c_node.ele.size === 0) {\\n            if(c_node.prev === null) {\\n                this.head = c_node.next;\\n                c_node.next.prev = null\\n            } else {\\n                c_node.prev.next = temp;\\n                temp.prev = c_node.prev;\\n            }\\n        }\\n\\n    }\\n    return temp;\\n}\\nAllOne.prototype.inc = function(key) {\\n    let c_node = this.addtodll(key, this.nodeMap.get(key));\\n    this.nodeMap.set(key, c_node);\\n};\\n\\n/** \\n * @param {string} key\\n * @return {void}\\n */\\nAllOne.prototype.removefromdll = function(key, node) {\\n    let c_freq = node.freq;\\n    let r_freq = c_freq - 1;\\n    let temp;\\n    if(c_freq === 1) {\\n        node.ele.delete(key);\\n        if(node.ele.size === 0) {\\n            if(this.head === this.tail) {\\n                this.head = null;\\n                this.tail = null;\\n            } else {\\n                this.head = node.next;\\n                node.next.prev = null;\\n            }\\n        }\\n        return null;\\n    } else {\\n        if(node.prev === null) {\\n            temp = new dll(r_freq, key, null, node);\\n            this.head = temp;\\n            node.prev = temp;\\n        } else if(node.prev.freq === r_freq) {\\n            temp = node.prev;\\n            temp.ele.add(key);\\n        } else {\\n            temp = new dll(r_freq, key, node.prev, node);\\n            node.prev.next = temp;\\n            node.prev = temp;\\n        }\\n\\n        node.ele.delete(key);\\n        if(node.ele.size === 0) {\\n            if(node.next === null) {\\n                this.tail = node.prev;\\n                temp.next = null;\\n            } else {\\n                node.next.prev = temp;\\n                temp.next = node.next;\\n            }\\n        }\\n    }\\n    return temp;\\n}\\nAllOne.prototype.dec = function(key) {\\n    let c_node = this.removefromdll(key, this.nodeMap.get(key));\\n    if(c_node) {\\n        this.nodeMap.set(key, c_node);\\n    } else {\\n        this.nodeMap.delete(key)\\n    }\\n};\\n\\n/**\\n * @return {string}\\n */\\nAllOne.prototype.getMaxKey = function() {\\n    if(this.tail) {\\n        const [f] = this.tail.ele;\\n        return f\\n    }\\n    return \\'\\';\\n};\\n\\n/**\\n * @return {string}\\n */\\nAllOne.prototype.getMinKey = function() {\\n    if(this.head) {\\n        const [f] = this.head.ele;\\n        return f\\n    }\\n    return \\'\\'\\n};\\n\\n/** \\n * Your AllOne object will be instantiated and called as such:\\n * var obj = new AllOne()\\n * obj.inc(key)\\n * obj.dec(key)\\n * var param_3 = obj.getMaxKey()\\n * var param_4 = obj.getMinKey()\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3065951,
                "title": "python-o-1-amortized-dictionary-arraylist-only-no-linked-list-or-deque-191-ms-beats-96",
                "content": "\\n```python\\nclass AllOne:\\n\\n    def __init__(self):\\n        self._keys = {}\\n        self._counts = [True]\\n        self._min_count = 1\\n        self._max_count = 0\\n\\n    def inc(self, key: str) -> None:\\n        if key not in self._keys:\\n            self._keys[key] = 1\\n            self._min_count = min(self._min_count, 1)\\n        else:\\n            self._counts[self._keys[key]].remove(key)\\n            self._keys[key] += 1\\n        count = self._keys[key]\\n        if count >= len(self._counts):\\n            self._counts.append(set())\\n        self._counts[count].add(key)\\n        self._max_count = max(self._max_count, count)\\n\\n    def dec(self, key: str) -> None:\\n        if key not in self._keys:\\n            raise Exception()\\n        else:\\n            self._counts[self._keys[key]].remove(key)\\n            self._keys[key] -= 1\\n        count = self._keys[key]\\n        if count > 0:\\n            self._counts[count].add(key)\\n            self._min_count = min(self._min_count, count)\\n        else:\\n            del self._keys[key]\\n\\n    def getMaxKey(self) -> str:\\n        while not self._counts[self._max_count]:\\n            # amortized O(1) across calls to inc and dec\\n            self._max_count -= 1\\n        if self._max_count == 0:\\n            return \"\"\\n        return next(iter(self._counts[self._max_count]))\\n\\n    def getMinKey(self) -> str:\\n        while self._min_count < len(self._counts) and not self._counts[self._min_count]:\\n            # amortized O(1) across calls to inc and dec\\n            self._min_count += 1\\n        if self._min_count == len(self._counts):\\n            return \"\"\\n        return next(iter(self._counts[self._min_count]))\\n```\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\nclass AllOne:\\n\\n    def __init__(self):\\n        self._keys = {}\\n        self._counts = [True]\\n        self._min_count = 1\\n        self._max_count = 0\\n\\n    def inc(self, key: str) -> None:\\n        if key not in self._keys:\\n            self._keys[key] = 1\\n            self._min_count = min(self._min_count, 1)\\n        else:\\n            self._counts[self._keys[key]].remove(key)\\n            self._keys[key] += 1\\n        count = self._keys[key]\\n        if count >= len(self._counts):\\n            self._counts.append(set())\\n        self._counts[count].add(key)\\n        self._max_count = max(self._max_count, count)\\n\\n    def dec(self, key: str) -> None:\\n        if key not in self._keys:\\n            raise Exception()\\n        else:\\n            self._counts[self._keys[key]].remove(key)\\n            self._keys[key] -= 1\\n        count = self._keys[key]\\n        if count > 0:\\n            self._counts[count].add(key)\\n            self._min_count = min(self._min_count, count)\\n        else:\\n            del self._keys[key]\\n\\n    def getMaxKey(self) -> str:\\n        while not self._counts[self._max_count]:\\n            # amortized O(1) across calls to inc and dec\\n            self._max_count -= 1\\n        if self._max_count == 0:\\n            return \"\"\\n        return next(iter(self._counts[self._max_count]))\\n\\n    def getMinKey(self) -> str:\\n        while self._min_count < len(self._counts) and not self._counts[self._min_count]:\\n            # amortized O(1) across calls to inc and dec\\n            self._min_count += 1\\n        if self._min_count == len(self._counts):\\n            return \"\"\\n        return next(iter(self._counts[self._min_count]))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3012816,
                "title": "java-map-linked-list-beats-98",
                "content": "# Intuition\\nUse a map to keep track of key count and a linked list to keep track of the count ranking\\n\\n# Approach\\nWhen a key\\'s count increments or decrements its ranking just move up or down by roughly 1 position. In the case there multiple keys with the same counts it needs move by more than one steps, but the chance is rare.\\n\\n# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nimport java.util.HashMap;\\nimport java.util.Map;\\n\\npublic class AllOne {\\n    static class Node {\\n        String key;\\n        int count;\\n        Node pre;\\n        Node next;\\n\\n        public Node(String key, int count) {\\n            this.key = key;\\n            this.count = count;\\n        }\\n    }\\n\\n    private Node head = null;\\n    private Node tail = null;\\n    private Map<String, Node> map = new HashMap<>();\\n\\n    public AllOne() {\\n\\n    }\\n\\n    public void inc(String key) {\\n        if (map.containsKey(key)) {\\n            Node node = map.get(key);\\n            node.count++;\\n            moveUp(node);\\n        } else {\\n            Node node = new Node(key, 1);\\n            add(node);\\n            map.put(key, node);\\n        }\\n    }\\n\\n    public void dec(String key) {\\n        Node node = map.get(key);\\n        if (node.count == 1) {\\n            map.remove(key);\\n            remove(node);\\n        } else {\\n            node.count--;\\n            moveDown(node);\\n        }\\n    }\\n\\n    public String getMaxKey() {\\n        if (map.isEmpty())\\n            return \"\";\\n        return tail.key;\\n    }\\n\\n    public String getMinKey() {\\n        if (map.isEmpty())\\n            return \"\";\\n        return head.key;\\n    }\\n\\n    void add(Node n) {\\n        assert n.count == 1;\\n        if (head == null) {\\n            head = n;\\n            tail = n;\\n        } else {\\n            n.next = head;\\n            head.pre = n;\\n            head = n;\\n        }\\n    }\\n\\n    void remove(Node n) {\\n        if (n == head && n == tail) {\\n            head = null;\\n            tail = null;\\n            return;\\n        }\\n        Node p = head;\\n        while (p != n) {\\n            p = p.next;\\n        }\\n        if (p == head) {\\n            head = p.next;\\n            head.pre = null;\\n        } else {\\n            if (p == tail) {\\n                tail = tail.pre;\\n                tail.next = null;\\n            } else {\\n                p.pre.next = p.next;\\n                p.next.pre = p.pre;\\n            }\\n        }\\n    }\\n\\n    void moveUp(Node n) {\\n        Node p = n.next;\\n        while (p != null && p.count < n.count) {\\n            p = p.next;\\n        }\\n        if (p != n.next) {\\n            if (n == head) {\\n                head = n.next;\\n            } else {\\n                n.pre.next = n.next;\\n            }\\n            n.next.pre = n.pre;\\n\\n            n.next = p;\\n            if (p == null) {\\n                n.pre = tail;\\n                tail.next = n;\\n                tail = n;\\n            } else {\\n                n.pre = p.pre;\\n                p.pre.next = n;\\n                p.pre = n;\\n            }\\n        }\\n    }\\n\\n    void moveDown(Node n) {\\n        Node p = n.pre;\\n        while (p != null && p.count > n.count) {\\n            p = p.pre;\\n        }\\n        if (p != n.pre) {\\n            if (n == tail) {\\n                tail = n.pre;\\n            } else {\\n                n.next.pre = n.pre;\\n            }\\n            n.pre.next = n.next;\\n\\n            n.pre = p;\\n            if (p == null) {\\n                n.next = head;\\n                head.pre = n;\\n                head = n;\\n            } else {\\n                n.next = p.next;\\n                p.next.pre = n;\\n                p.next = n;\\n            }\\n        }\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.HashMap;\\nimport java.util.Map;\\n\\npublic class AllOne {\\n    static class Node {\\n        String key;\\n        int count;\\n        Node pre;\\n        Node next;\\n\\n        public Node(String key, int count) {\\n            this.key = key;\\n            this.count = count;\\n        }\\n    }\\n\\n    private Node head = null;\\n    private Node tail = null;\\n    private Map<String, Node> map = new HashMap<>();\\n\\n    public AllOne() {\\n\\n    }\\n\\n    public void inc(String key) {\\n        if (map.containsKey(key)) {\\n            Node node = map.get(key);\\n            node.count++;\\n            moveUp(node);\\n        } else {\\n            Node node = new Node(key, 1);\\n            add(node);\\n            map.put(key, node);\\n        }\\n    }\\n\\n    public void dec(String key) {\\n        Node node = map.get(key);\\n        if (node.count == 1) {\\n            map.remove(key);\\n            remove(node);\\n        } else {\\n            node.count--;\\n            moveDown(node);\\n        }\\n    }\\n\\n    public String getMaxKey() {\\n        if (map.isEmpty())\\n            return \"\";\\n        return tail.key;\\n    }\\n\\n    public String getMinKey() {\\n        if (map.isEmpty())\\n            return \"\";\\n        return head.key;\\n    }\\n\\n    void add(Node n) {\\n        assert n.count == 1;\\n        if (head == null) {\\n            head = n;\\n            tail = n;\\n        } else {\\n            n.next = head;\\n            head.pre = n;\\n            head = n;\\n        }\\n    }\\n\\n    void remove(Node n) {\\n        if (n == head && n == tail) {\\n            head = null;\\n            tail = null;\\n            return;\\n        }\\n        Node p = head;\\n        while (p != n) {\\n            p = p.next;\\n        }\\n        if (p == head) {\\n            head = p.next;\\n            head.pre = null;\\n        } else {\\n            if (p == tail) {\\n                tail = tail.pre;\\n                tail.next = null;\\n            } else {\\n                p.pre.next = p.next;\\n                p.next.pre = p.pre;\\n            }\\n        }\\n    }\\n\\n    void moveUp(Node n) {\\n        Node p = n.next;\\n        while (p != null && p.count < n.count) {\\n            p = p.next;\\n        }\\n        if (p != n.next) {\\n            if (n == head) {\\n                head = n.next;\\n            } else {\\n                n.pre.next = n.next;\\n            }\\n            n.next.pre = n.pre;\\n\\n            n.next = p;\\n            if (p == null) {\\n                n.pre = tail;\\n                tail.next = n;\\n                tail = n;\\n            } else {\\n                n.pre = p.pre;\\n                p.pre.next = n;\\n                p.pre = n;\\n            }\\n        }\\n    }\\n\\n    void moveDown(Node n) {\\n        Node p = n.pre;\\n        while (p != null && p.count > n.count) {\\n            p = p.pre;\\n        }\\n        if (p != n.pre) {\\n            if (n == tail) {\\n                tail = n.pre;\\n            } else {\\n                n.next.pre = n.pre;\\n            }\\n            n.pre.next = n.next;\\n\\n            n.pre = p;\\n            if (p == null) {\\n                n.next = head;\\n                head.pre = n;\\n                head = n;\\n            } else {\\n                n.next = p.next;\\n                p.next.pre = n;\\n                p.next = n;\\n            }\\n        }\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2995376,
                "title": "c-doubly-linkedlist",
                "content": "```\\nclass Node{\\n    \\n    public: \\n    Node *front;\\n    Node *back;\\n    int freq;\\n    set<string> st;\\n\\n    Node(){\\n        front = NULL;\\n        back = NULL;\\n        freq = 0;\\n    }\\n};\\n\\n\\nclass AllOne {\\npublic:\\n    \\n    Node *head;\\n    Node *tail;\\n    map<string,Node*> mp;\\n    \\n    AllOne() {\\n        head = new Node();\\n        tail = new Node();\\n        mp.clear();\\n        \\n        head->front = tail;\\n        tail->back = head;    \\n    }\\n    \\n    void inc(string key) {\\n         if(mp.find(key) == mp.end()){\\n            \\n              if(head->front == tail){\\n                Node *temp = new Node();\\n                temp->freq = 1;\\n                temp->st.insert(key);\\n\\n                temp->back  = head;\\n                temp->front = tail;\\n\\n                head->front = temp;\\n                tail->back  = temp;\\n\\n                mp[key] = temp;\\n\\t          }   \\n              else if(head->front->freq != 1){\\n                 Node *temp = new Node();\\n                 temp->freq = 1;\\n                 temp->st.insert(key);\\n                  \\n                 temp->front = head->front;\\n                 temp->back = head;\\n                  \\n                 temp->front->back = temp;\\n                 head->front = temp;\\n                  \\n                  mp[key] = temp;\\n              }\\n              else{\\n                Node *temp = head->front;\\n                temp->st.insert(key);\\n\\n                mp[key] = temp;\\n              }   \\n             \\n             \\n            \\n        }\\n        else{\\n            \\n            Node *temp = mp[key];\\n            int curr_freq = temp->freq;\\n            \\n        \\n\\n            if(temp->front == tail){\\n                \\n                \\n                Node *f = new Node();\\n                f->freq = curr_freq + 1;\\n                f->st.insert(key);\\n\\n                f->back  = temp;\\n                f->front = tail;\\n\\n                temp->front = f;\\n                tail->back  = f;\\n\\n                mp[key] = f;\\n            }\\n            else if((temp->front->freq - curr_freq) > 1){\\n                Node *f = new Node();\\n                f->freq = curr_freq + 1;\\n                f->st.insert(key);\\n\\n                f->back  = temp;\\n                f->front = temp->front;\\n\\n                temp->front = f;\\n                f->front->back = f;\\n\\n                mp[key] = f;\\n            }\\n            else{\\n                temp->front->st.insert(key);\\n\\t            mp[key] = temp->front;\\n\\n            }\\n            \\n            temp->st.erase(key);\\n            if(temp->st.empty()){\\n                temp->front->back = temp->back;\\n                temp->back->front = temp->front;\\n            }\\n              \\n       }\\n    }\\n    \\n    void dec(string key) {\\n        Node *temp = mp[key];\\n        int curr_freq = temp->freq;\\n        \\n        if(curr_freq == 1){\\n            temp->st.erase(key);\\n            mp.erase(key);\\n        }\\n        else if(temp->back == head){\\n            Node *f = new Node();\\n            f->freq = curr_freq - 1;\\n            f->st.insert(key);\\n            \\n            f->front = temp;\\n            f->back = head;\\n            \\n            head->front = f;\\n            temp->back = f;\\n            \\n            mp[key] = f;\\n        }\\n        else if((curr_freq - temp->back->freq) > 1){\\n            Node *f = new Node();\\n            f->freq = curr_freq - 1;\\n            f->st.insert(key);\\n            \\n            \\n            f->front = temp;\\n            f->back  = temp->back;\\n            \\n            f->back->front = f;\\n            temp->back = f;\\n            \\n            mp[key] = f;\\n        }\\n        else{\\n            temp->back->st.insert(key);\\n            mp[key] = temp->back;\\n        }\\n        \\n        temp->st.erase(key);\\n        if(temp->st.empty()){\\n            temp->back->front = temp->front;\\n            temp->front->back = temp->back;\\n        }\\n    }\\n    \\n    string getMaxKey() {\\n        \\n        if(mp.empty()) return \"\";\\n        string s = *(tail->back->st.begin());\\n        return s;\\n    }\\n    \\n    string getMinKey() {\\n        \\n        if(mp.empty()) return \"\";\\n        string s = *(head->front->st.begin());\\n        return s;\\n\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Node{\\n    \\n    public: \\n    Node *front;\\n    Node *back;\\n    int freq;\\n    set<string> st;\\n\\n    Node(){\\n        front = NULL;\\n        back = NULL;\\n        freq = 0;\\n    }\\n};\\n\\n\\nclass AllOne {\\npublic:\\n    \\n    Node *head;\\n    Node *tail;\\n    map<string,Node*> mp;\\n    \\n    AllOne() {\\n        head = new Node();\\n        tail = new Node();\\n        mp.clear();\\n        \\n        head->front = tail;\\n        tail->back = head;    \\n    }\\n    \\n    void inc(string key) {\\n         if(mp.find(key) == mp.end()){\\n            \\n              if(head->front == tail){\\n                Node *temp = new Node();\\n                temp->freq = 1;\\n                temp->st.insert(key);\\n\\n                temp->back  = head;\\n                temp->front = tail;\\n\\n                head->front = temp;\\n                tail->back  = temp;\\n\\n                mp[key] = temp;\\n\\t          }   \\n              else if(head->front->freq != 1){\\n                 Node *temp = new Node();\\n                 temp->freq = 1;\\n                 temp->st.insert(key);\\n                  \\n                 temp->front = head->front;\\n                 temp->back = head;\\n                  \\n                 temp->front->back = temp;\\n                 head->front = temp;\\n                  \\n                  mp[key] = temp;\\n              }\\n              else{\\n                Node *temp = head->front;\\n                temp->st.insert(key);\\n\\n                mp[key] = temp;\\n              }   \\n             \\n             \\n            \\n        }\\n        else{\\n            \\n            Node *temp = mp[key];\\n            int curr_freq = temp->freq;\\n            \\n        \\n\\n            if(temp->front == tail){\\n                \\n                \\n                Node *f = new Node();\\n                f->freq = curr_freq + 1;\\n                f->st.insert(key);\\n\\n                f->back  = temp;\\n                f->front = tail;\\n\\n                temp->front = f;\\n                tail->back  = f;\\n\\n                mp[key] = f;\\n            }\\n            else if((temp->front->freq - curr_freq) > 1){\\n                Node *f = new Node();\\n                f->freq = curr_freq + 1;\\n                f->st.insert(key);\\n\\n                f->back  = temp;\\n                f->front = temp->front;\\n\\n                temp->front = f;\\n                f->front->back = f;\\n\\n                mp[key] = f;\\n            }\\n            else{\\n                temp->front->st.insert(key);\\n\\t            mp[key] = temp->front;\\n\\n            }\\n            \\n            temp->st.erase(key);\\n            if(temp->st.empty()){\\n                temp->front->back = temp->back;\\n                temp->back->front = temp->front;\\n            }\\n              \\n       }\\n    }\\n    \\n    void dec(string key) {\\n        Node *temp = mp[key];\\n        int curr_freq = temp->freq;\\n        \\n        if(curr_freq == 1){\\n            temp->st.erase(key);\\n            mp.erase(key);\\n        }\\n        else if(temp->back == head){\\n            Node *f = new Node();\\n            f->freq = curr_freq - 1;\\n            f->st.insert(key);\\n            \\n            f->front = temp;\\n            f->back = head;\\n            \\n            head->front = f;\\n            temp->back = f;\\n            \\n            mp[key] = f;\\n        }\\n        else if((curr_freq - temp->back->freq) > 1){\\n            Node *f = new Node();\\n            f->freq = curr_freq - 1;\\n            f->st.insert(key);\\n            \\n            \\n            f->front = temp;\\n            f->back  = temp->back;\\n            \\n            f->back->front = f;\\n            temp->back = f;\\n            \\n            mp[key] = f;\\n        }\\n        else{\\n            temp->back->st.insert(key);\\n            mp[key] = temp->back;\\n        }\\n        \\n        temp->st.erase(key);\\n        if(temp->st.empty()){\\n            temp->back->front = temp->front;\\n            temp->front->back = temp->back;\\n        }\\n    }\\n    \\n    string getMaxKey() {\\n        \\n        if(mp.empty()) return \"\";\\n        string s = *(tail->back->st.begin());\\n        return s;\\n    }\\n    \\n    string getMinKey() {\\n        \\n        if(mp.empty()) return \"\";\\n        string s = *(head->front->st.begin());\\n        return s;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2807928,
                "title": "python-sorteddict-simple-easy",
                "content": "\\n\\n\\n# Code\\n```\\nfrom sortedcontainers import SortedDict\\nfrom collections import defaultdict\\n\\nclass AllOne:\\n\\n    def __init__(self):\\n        self.word_to_count = {}\\n        self.count_to_words = SortedDict()\\n        print(self.word_to_count)\\n\\n    def inc(self, key):\\n        if key not in self.word_to_count:\\n            self.word_to_count[key] = 1\\n            if 1 in self.count_to_words:\\n                self.count_to_words[1].add(key)\\n            else:\\n                self.count_to_words[1] = set()\\n                self.count_to_words[1].add(key)\\n        else:\\n            self.adjust_count(key, True)\\n\\n    def dec(self, key):\\n        if key in self.word_to_count:\\n            self.adjust_count(key, False)\\n\\n    def getMinKey(self):\\n        if self.count_to_words:\\n            data = self.count_to_words.peekitem(index=0)[1]\\n            return next(iter(data))\\n        return \"\"\\n\\n    def getMaxKey(self):\\n        if self.count_to_words:\\n            data = self.count_to_words.peekitem()[1]\\n            return next(iter(data))\\n        return \"\"\\n\\n    def adjust_count(self, key, isInc):\\n        prev_count = self.word_to_count[key]\\n        new_count = prev_count + 1 if isInc else prev_count - 1\\n\\n        self.count_to_words[prev_count].remove(key)\\n        if not self.count_to_words[prev_count]:\\n            del self.count_to_words[prev_count]\\n        if new_count == 0:\\n                del self.word_to_count[key]\\n        else:\\n            if new_count in self.count_to_words:\\n                self.count_to_words[new_count].add(key)\\n            else:\\n                self.count_to_words[new_count] = set()\\n                self.count_to_words[new_count].add(key)\\n            self.word_to_count[key] = new_count \\n\\n# Your AllOne object will be instantiated and called as such:\\n# obj = AllOne()\\n# obj.inc(key)\\n# obj.dec(key)\\n# param_3 = obj.getMaxKey()\\n# param_4 = obj.getMinKey()\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom sortedcontainers import SortedDict\\nfrom collections import defaultdict\\n\\nclass AllOne:\\n\\n    def __init__(self):\\n        self.word_to_count = {}\\n        self.count_to_words = SortedDict()\\n        print(self.word_to_count)\\n\\n    def inc(self, key):\\n        if key not in self.word_to_count:\\n            self.word_to_count[key] = 1\\n            if 1 in self.count_to_words:\\n                self.count_to_words[1].add(key)\\n            else:\\n                self.count_to_words[1] = set()\\n                self.count_to_words[1].add(key)\\n        else:\\n            self.adjust_count(key, True)\\n\\n    def dec(self, key):\\n        if key in self.word_to_count:\\n            self.adjust_count(key, False)\\n\\n    def getMinKey(self):\\n        if self.count_to_words:\\n            data = self.count_to_words.peekitem(index=0)[1]\\n            return next(iter(data))\\n        return \"\"\\n\\n    def getMaxKey(self):\\n        if self.count_to_words:\\n            data = self.count_to_words.peekitem()[1]\\n            return next(iter(data))\\n        return \"\"\\n\\n    def adjust_count(self, key, isInc):\\n        prev_count = self.word_to_count[key]\\n        new_count = prev_count + 1 if isInc else prev_count - 1\\n\\n        self.count_to_words[prev_count].remove(key)\\n        if not self.count_to_words[prev_count]:\\n            del self.count_to_words[prev_count]\\n        if new_count == 0:\\n                del self.word_to_count[key]\\n        else:\\n            if new_count in self.count_to_words:\\n                self.count_to_words[new_count].add(key)\\n            else:\\n                self.count_to_words[new_count] = set()\\n                self.count_to_words[new_count].add(key)\\n            self.word_to_count[key] = new_count \\n\\n# Your AllOne object will be instantiated and called as such:\\n# obj = AllOne()\\n# obj.inc(key)\\n# obj.dec(key)\\n# param_3 = obj.getMaxKey()\\n# param_4 = obj.getMinKey()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2310893,
                "title": "my-java-solution-with-details",
                "content": "```\\n//Intuitions get from the top answer by @AaronLin1992\\nclass AllOne {\\n    //Thoughts\\n    //inc() and dec() can be done with a Simple Map, but how do we getMaxKey() and getMinKey() in O(1)?\\n    //in order to get max and/or min on the fly, we need to maintain some kind of ordering so that we can always access max and min\\n    //to maintain some kind of ordering, the first thing we think about is arrays/lists, however, arrays/lists when insert and delete in the middle, it is O(N) operation\\n    //so instead, a linked list might work\\n    //as a result, we considering using Map(s) and LinkedList for our supporting data structures, details below\\n    \\n    private Map<String, Bucket> stringToBucket; //maps a string to bucket\\n    private Map<Integer, Bucket> countToBucket; //maps string count to bucket, note that because when we design this we can have multiple strings in a bucket, that makes it convenient so that for each count, we only need 1 bucket, thus the map data structure\\n    private BucketList bucketList;\\n    \\n    //first, we need to create a class for the LinkedList elements\\n    class Bucket {\\n        private Bucket prev;\\n        private Bucket next;\\n        \\n        private int count; //recording the count of instances\\n        private Set<String> keys; //note that we are using Set of Strings. The reason is because multiple Strings can have the same count and we want to put them in one bucket. This makes the problem easier to solve instead of putting them into different buckets.\\n        \\n        Bucket() {\\n            this.keys = new HashSet<>();\\n        }\\n        \\n        Bucket(String key) {\\n            this();\\n            this.count = 1;\\n            this.keys.add(key);\\n        }\\n        \\n    }\\n    \\n    //second, we need to create a linked list data structure of buckets\\n    class BucketList {\\n        private Bucket dummyHead; //the fake head before the real head //useful for getMinKey()\\n        private Bucket dummyTail; //the fake tail before the real tail //useful for getMaxKey()\\n        \\n        public BucketList() {\\n            dummyHead = new Bucket();\\n            dummyTail = new Bucket();\\n            dummyHead.next = dummyTail;\\n            dummyTail.prev = dummyHead;\\n        }\\n        \\n        public Bucket createNewBucket(String key) {\\n            Bucket bucket = new Bucket(key);\\n            \\n            Bucket nextBucket = dummyHead.next;\\n            dummyHead.next = bucket;\\n            bucket.prev = dummyHead;\\n            nextBucket.prev = bucket;\\n            bucket.next = nextBucket;\\n            \\n            return bucket;\\n        }\\n        \\n        public Bucket createBucketToTheRight(Bucket fromBucket, String key, int count) {\\n            //initialize\\n            Bucket toBucket = new Bucket(key);\\n            toBucket.count = count;\\n            \\n            Bucket nextBucket = fromBucket.next;\\n            fromBucket.next = toBucket;\\n            toBucket.prev = fromBucket;\\n            nextBucket.prev = toBucket;\\n            toBucket.next = nextBucket;\\n            \\n            return toBucket;\\n        }\\n        \\n        public Bucket createBucketToTheLeft(Bucket fromBucket, String key, int count) {\\n            //initialize\\n            Bucket toBucket = new Bucket(key);\\n            toBucket.count = count;\\n            \\n            Bucket prevBucket = fromBucket.prev;\\n            prevBucket.next = toBucket;\\n            toBucket.prev = prevBucket;\\n            fromBucket.prev = toBucket;\\n            toBucket.next = fromBucket;\\n            \\n            return toBucket;\\n        }\\n        \\n        public boolean clean(Bucket oldBucket) {//clean bucket if bucket does not have any keys\\n            if (!oldBucket.keys.isEmpty()) {\\n                return false;\\n            }\\n            \\n            removeBucket(oldBucket);\\n            \\n            return true;\\n        }\\n        \\n        public void removeBucket(Bucket bucket) {\\n            Bucket prevBucket = bucket.prev;\\n            Bucket nextBucket = bucket.next;\\n            \\n            prevBucket.next = nextBucket;\\n            nextBucket.prev = prevBucket;\\n        }\\n    }\\n    \\n\\n    public AllOne() {\\n        this.stringToBucket = new HashMap<>();\\n        this.countToBucket = new HashMap<>();\\n        this.bucketList = new BucketList();\\n    }\\n    \\n    public void inc(String key) {\\n        //first check if the string already present\\n        if (!stringToBucket.containsKey(key)) { //if not present \\n            Bucket bucket = null;\\n            \\n            //check if there is count of 1 bucket already\\n            if (!countToBucket.containsKey(1)) { //if does not contain count of 1\\n                //we need to create a new bucket for count of 1 and add to the head (the minimum). Because count 1 should be the minimum exists in the bucket list\\n                bucket = bucketList.createNewBucket(key);\\n            } else { //if contains count of 1\\n                //then we just need to add the key to the bucket\\n                bucket = countToBucket.get(1);\\n                bucket.keys.add(key);\\n            }\\n            \\n            //don\\'t forget to update the maps\\n            stringToBucket.put(key, bucket);\\n            countToBucket.put(1, bucket);\\n        } else { //if the key alreay present\\n            //first of all we need to get the current count for the key\\n            Bucket oldBucket = stringToBucket.get(key);\\n            Bucket newBucket = null;\\n            \\n            int count = oldBucket.count;\\n            count++; //increment 1\\n            //don\\'t forget that we need to remove the key from existing bucket\\n            oldBucket.keys.remove(key);\\n            \\n            //now let\\'s add the key with new count\\n            if (countToBucket.containsKey(count)) { //if there is already a bucket for this count\\n                //then just add to the set of keys\\n                newBucket = countToBucket.get(count);\\n                newBucket.keys.add(key);\\n            } else { //if there is no bucket for this count, create a new bucket, but where to place it? Ans: to the right of the old bucket\\n                newBucket = bucketList.createBucketToTheRight(oldBucket, key, count);     \\n            }\\n            \\n            //special scenario: if old bucket don\\'t have any keys after removing the last key, then we need to remove the entire old bucket from the bucket list\\n            if (bucketList.clean(oldBucket)) {\\n                countToBucket.remove(oldBucket.count); //remove from map because the old bucket was removed\\n            }\\n            \\n            //don\\'t forget to update the maps\\n            stringToBucket.put(key, newBucket);\\n            countToBucket.putIfAbsent(count, newBucket);\\n        }\\n    }\\n    \\n    public void dec(String key) {\\n        //since it is given that \"It is guaranteed that key exists in the data structure before the decrement.\" we don\\'t do additional validation for key exists here\\n        Bucket oldBucket = stringToBucket.get(key);\\n        Bucket newBucket = null;\\n        \\n        int count = oldBucket.count;\\n        count--; //decrement\\n        oldBucket.keys.remove(key);\\n        \\n        //special scenario - when count == 0\\n        if (count == 0) {\\n            stringToBucket.remove(key);\\n        } else {\\n            //now let\\'s find a new bucket for the decremented count\\n            if (countToBucket.containsKey(count)) {//if there is already a bucket for the count\\n                newBucket = countToBucket.get(count);\\n                newBucket.keys.add(key);\\n            } else {//if there is no bucket for the count, then following similar logic as before, we need to add a bucket to the left of the existing bucket\\n                newBucket = bucketList.createBucketToTheLeft(oldBucket, key, count);\\n            }\\n            \\n            //don\\'t forget to update the maps\\n            stringToBucket.put(key, newBucket);\\n            countToBucket.putIfAbsent(count, newBucket);\\n        }\\n        \\n        //special scenario: if old bucket don\\'t have any keys after removing the last key, then we need to remove the entire old bucket from the bucket list\\n        if (bucketList.clean(oldBucket)) {\\n            countToBucket.remove(oldBucket.count); //remove from map because the old bucket was removed\\n        }\\n    }\\n    \\n    public String getMaxKey() {\\n        Set<String> maxSet = bucketList.dummyTail.prev.keys;\\n        \\n        return maxSet.isEmpty() ? \"\" : maxSet.iterator().next(); //if maxSet is empty, that means the bucketList don\\'t have actual buckets\\n        \\n    }\\n    \\n    public String getMinKey() {\\n        Set<String> minSet = bucketList.dummyHead.next.keys;\\n        \\n        return minSet.isEmpty() ? \"\" : minSet.iterator().next(); //if minSet is empty, that means the bucketList don\\'t have actual buckets\\n    }\\n}\\n\\n/**\\n * Your AllOne object will be instantiated and called as such:\\n * AllOne obj = new AllOne();\\n * obj.inc(key);\\n * obj.dec(key);\\n * String param_3 = obj.getMaxKey();\\n * String param_4 = obj.getMinKey();\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n//Intuitions get from the top answer by @AaronLin1992\\nclass AllOne {\\n    //Thoughts\\n    //inc() and dec() can be done with a Simple Map, but how do we getMaxKey() and getMinKey() in O(1)?\\n    //in order to get max and/or min on the fly, we need to maintain some kind of ordering so that we can always access max and min\\n    //to maintain some kind of ordering, the first thing we think about is arrays/lists, however, arrays/lists when insert and delete in the middle, it is O(N) operation\\n    //so instead, a linked list might work\\n    //as a result, we considering using Map(s) and LinkedList for our supporting data structures, details below\\n    \\n    private Map<String, Bucket> stringToBucket; //maps a string to bucket\\n    private Map<Integer, Bucket> countToBucket; //maps string count to bucket, note that because when we design this we can have multiple strings in a bucket, that makes it convenient so that for each count, we only need 1 bucket, thus the map data structure\\n    private BucketList bucketList;\\n    \\n    //first, we need to create a class for the LinkedList elements\\n    class Bucket {\\n        private Bucket prev;\\n        private Bucket next;\\n        \\n        private int count; //recording the count of instances\\n        private Set<String> keys; //note that we are using Set of Strings. The reason is because multiple Strings can have the same count and we want to put them in one bucket. This makes the problem easier to solve instead of putting them into different buckets.\\n        \\n        Bucket() {\\n            this.keys = new HashSet<>();\\n        }\\n        \\n        Bucket(String key) {\\n            this();\\n            this.count = 1;\\n            this.keys.add(key);\\n        }\\n        \\n    }\\n    \\n    //second, we need to create a linked list data structure of buckets\\n    class BucketList {\\n        private Bucket dummyHead; //the fake head before the real head //useful for getMinKey()\\n        private Bucket dummyTail; //the fake tail before the real tail //useful for getMaxKey()\\n        \\n        public BucketList() {\\n            dummyHead = new Bucket();\\n            dummyTail = new Bucket();\\n            dummyHead.next = dummyTail;\\n            dummyTail.prev = dummyHead;\\n        }\\n        \\n        public Bucket createNewBucket(String key) {\\n            Bucket bucket = new Bucket(key);\\n            \\n            Bucket nextBucket = dummyHead.next;\\n            dummyHead.next = bucket;\\n            bucket.prev = dummyHead;\\n            nextBucket.prev = bucket;\\n            bucket.next = nextBucket;\\n            \\n            return bucket;\\n        }\\n        \\n        public Bucket createBucketToTheRight(Bucket fromBucket, String key, int count) {\\n            //initialize\\n            Bucket toBucket = new Bucket(key);\\n            toBucket.count = count;\\n            \\n            Bucket nextBucket = fromBucket.next;\\n            fromBucket.next = toBucket;\\n            toBucket.prev = fromBucket;\\n            nextBucket.prev = toBucket;\\n            toBucket.next = nextBucket;\\n            \\n            return toBucket;\\n        }\\n        \\n        public Bucket createBucketToTheLeft(Bucket fromBucket, String key, int count) {\\n            //initialize\\n            Bucket toBucket = new Bucket(key);\\n            toBucket.count = count;\\n            \\n            Bucket prevBucket = fromBucket.prev;\\n            prevBucket.next = toBucket;\\n            toBucket.prev = prevBucket;\\n            fromBucket.prev = toBucket;\\n            toBucket.next = fromBucket;\\n            \\n            return toBucket;\\n        }\\n        \\n        public boolean clean(Bucket oldBucket) {//clean bucket if bucket does not have any keys\\n            if (!oldBucket.keys.isEmpty()) {\\n                return false;\\n            }\\n            \\n            removeBucket(oldBucket);\\n            \\n            return true;\\n        }\\n        \\n        public void removeBucket(Bucket bucket) {\\n            Bucket prevBucket = bucket.prev;\\n            Bucket nextBucket = bucket.next;\\n            \\n            prevBucket.next = nextBucket;\\n            nextBucket.prev = prevBucket;\\n        }\\n    }\\n    \\n\\n    public AllOne() {\\n        this.stringToBucket = new HashMap<>();\\n        this.countToBucket = new HashMap<>();\\n        this.bucketList = new BucketList();\\n    }\\n    \\n    public void inc(String key) {\\n        //first check if the string already present\\n        if (!stringToBucket.containsKey(key)) { //if not present \\n            Bucket bucket = null;\\n            \\n            //check if there is count of 1 bucket already\\n            if (!countToBucket.containsKey(1)) { //if does not contain count of 1\\n                //we need to create a new bucket for count of 1 and add to the head (the minimum). Because count 1 should be the minimum exists in the bucket list\\n                bucket = bucketList.createNewBucket(key);\\n            } else { //if contains count of 1\\n                //then we just need to add the key to the bucket\\n                bucket = countToBucket.get(1);\\n                bucket.keys.add(key);\\n            }\\n            \\n            //don\\'t forget to update the maps\\n            stringToBucket.put(key, bucket);\\n            countToBucket.put(1, bucket);\\n        } else { //if the key alreay present\\n            //first of all we need to get the current count for the key\\n            Bucket oldBucket = stringToBucket.get(key);\\n            Bucket newBucket = null;\\n            \\n            int count = oldBucket.count;\\n            count++; //increment 1\\n            //don\\'t forget that we need to remove the key from existing bucket\\n            oldBucket.keys.remove(key);\\n            \\n            //now let\\'s add the key with new count\\n            if (countToBucket.containsKey(count)) { //if there is already a bucket for this count\\n                //then just add to the set of keys\\n                newBucket = countToBucket.get(count);\\n                newBucket.keys.add(key);\\n            } else { //if there is no bucket for this count, create a new bucket, but where to place it? Ans: to the right of the old bucket\\n                newBucket = bucketList.createBucketToTheRight(oldBucket, key, count);     \\n            }\\n            \\n            //special scenario: if old bucket don\\'t have any keys after removing the last key, then we need to remove the entire old bucket from the bucket list\\n            if (bucketList.clean(oldBucket)) {\\n                countToBucket.remove(oldBucket.count); //remove from map because the old bucket was removed\\n            }\\n            \\n            //don\\'t forget to update the maps\\n            stringToBucket.put(key, newBucket);\\n            countToBucket.putIfAbsent(count, newBucket);\\n        }\\n    }\\n    \\n    public void dec(String key) {\\n        //since it is given that \"It is guaranteed that key exists in the data structure before the decrement.\" we don\\'t do additional validation for key exists here\\n        Bucket oldBucket = stringToBucket.get(key);\\n        Bucket newBucket = null;\\n        \\n        int count = oldBucket.count;\\n        count--; //decrement\\n        oldBucket.keys.remove(key);\\n        \\n        //special scenario - when count == 0\\n        if (count == 0) {\\n            stringToBucket.remove(key);\\n        } else {\\n            //now let\\'s find a new bucket for the decremented count\\n            if (countToBucket.containsKey(count)) {//if there is already a bucket for the count\\n                newBucket = countToBucket.get(count);\\n                newBucket.keys.add(key);\\n            } else {//if there is no bucket for the count, then following similar logic as before, we need to add a bucket to the left of the existing bucket\\n                newBucket = bucketList.createBucketToTheLeft(oldBucket, key, count);\\n            }\\n            \\n            //don\\'t forget to update the maps\\n            stringToBucket.put(key, newBucket);\\n            countToBucket.putIfAbsent(count, newBucket);\\n        }\\n        \\n        //special scenario: if old bucket don\\'t have any keys after removing the last key, then we need to remove the entire old bucket from the bucket list\\n        if (bucketList.clean(oldBucket)) {\\n            countToBucket.remove(oldBucket.count); //remove from map because the old bucket was removed\\n        }\\n    }\\n    \\n    public String getMaxKey() {\\n        Set<String> maxSet = bucketList.dummyTail.prev.keys;\\n        \\n        return maxSet.isEmpty() ? \"\" : maxSet.iterator().next(); //if maxSet is empty, that means the bucketList don\\'t have actual buckets\\n        \\n    }\\n    \\n    public String getMinKey() {\\n        Set<String> minSet = bucketList.dummyHead.next.keys;\\n        \\n        return minSet.isEmpty() ? \"\" : minSet.iterator().next(); //if minSet is empty, that means the bucketList don\\'t have actual buckets\\n    }\\n}\\n\\n/**\\n * Your AllOne object will be instantiated and called as such:\\n * AllOne obj = new AllOne();\\n * obj.inc(key);\\n * obj.dec(key);\\n * String param_3 = obj.getMaxKey();\\n * String param_4 = obj.getMinKey();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2285442,
                "title": "java-hashmap-doubly-linked-list",
                "content": "The idea is simply to maintain the key with the highest count in the front of the DLL and the one with the lowest value to the end. If the value being decremented is the one with the current max value and after decrementing, it still is the maximum, we simply update the `maxKey` counter. While incrementing if the new node value is the same as the highest value node, we simply add it next to head.\\n\\n```\\nclass AllOne {\\n    private static class Node {\\n        String key;\\n        int count;\\n        Node previous;\\n        Node next;\\n\\n        public Node(String key, int count) {\\n            this.key = key;\\n            this.count = count;\\n        }\\n\\n        public String toString() {\\n            return key + \"-\" + count;\\n        }\\n    }\\n\\n    public static class DoublyLinkedList {\\n        Node head;\\n        Node tail;\\n\\n        public Node add(String key, int count) {\\n            Node newNode = new Node(key, count);\\n            if (head == null) {\\n                head = tail = newNode;\\n            } else {\\n                newNode.previous = tail;\\n                tail.next = newNode;\\n                tail = newNode;\\n            }\\n            return tail;\\n        }\\n\\n        public Node removeNode(Node nodeToRemove) {\\n            if (nodeToRemove == null)\\n                return null;\\n\\n            if (nodeToRemove == head) {\\n                head = head.next;\\n            } else if (nodeToRemove == tail) {\\n                tail = tail.previous;\\n            } else {\\n                nodeToRemove.previous.next = nodeToRemove.next;\\n                nodeToRemove.next.previous = nodeToRemove.previous;\\n            }\\n            nodeToRemove.previous = null;\\n            nodeToRemove.next = null;\\n            return nodeToRemove;\\n        }\\n\\n        public Node addToHead(Node node) {\\n            if (head == null) {\\n                head = tail = node;\\n            } else {\\n                node.next = head;\\n                head.previous = node;\\n                head = node;\\n            }\\n            return head;\\n        }\\n        \\n        public Node addNextToHead(Node node) {\\n            node.previous = head;\\n            node.next = head.next;\\n            head.next.previous = node;\\n            head.next = node;\\n            return node;\\n        }\\n\\n        public boolean isEmpty() {\\n            return head == null && tail == null;\\n        }\\n    }\\n\\n    private final Map<String, Node> keyToNode;\\n    private final DoublyLinkedList nodes;\\n    private int maxKey;\\n\\n\\n    public AllOne() {\\n        keyToNode = new HashMap<>();\\n        nodes = new DoublyLinkedList();\\n        maxKey = 1;\\n    }\\n\\n    public void inc(String key) {\\n        if (keyToNode.containsKey(key)) {\\n            Node node = keyToNode.get(key);\\n            node.count += 1;\\n            if (node.count > maxKey) {\\n                maxKey = node.count;\\n                keyToNode.put(key, nodes.addToHead(nodes.removeNode(node)));\\n            } else if (node.count == maxKey) {\\n                keyToNode.put(key, nodes.addNextToHead(nodes.removeNode(node)));\\n            }\\n        } else {\\n            Node node = nodes.add(key, 1);\\n            keyToNode.put(key, node);\\n        }\\n    }\\n\\n    public void dec(String key) {\\n        Node node = keyToNode.get(key);\\n        node.count -= 1;\\n        if (node == nodes.head)\\n            maxKey = node.count;\\n        \\n        if (node.count <= nodes.tail.count) {\\n            Node removedNode = nodes.removeNode(node);\\n            if (node.count == 0) {\\n                keyToNode.remove(key);\\n                return;\\n            }\\n            keyToNode.put(key, nodes.add(removedNode.key, removedNode.count));\\n        }\\n    }\\n\\n    public String getMaxKey() {\\n        return nodes.isEmpty() ? \"\" : nodes.head.key;\\n    }\\n\\n    public String getMinKey() {\\n        return nodes.isEmpty() ? \"\" : nodes.tail.key;\\n    }\\n}\\n\\n/**\\n * Your AllOne object will be instantiated and called as such:\\n * AllOne obj = new AllOne();\\n * obj.inc(key);\\n * obj.dec(key);\\n * String param_3 = obj.getMaxKey();\\n * String param_4 = obj.getMinKey();\\n */\\n```",
                "solutionTags": [
                    "Linked List"
                ],
                "code": "```\\nclass AllOne {\\n    private static class Node {\\n        String key;\\n        int count;\\n        Node previous;\\n        Node next;\\n\\n        public Node(String key, int count) {\\n            this.key = key;\\n            this.count = count;\\n        }\\n\\n        public String toString() {\\n            return key + \"-\" + count;\\n        }\\n    }\\n\\n    public static class DoublyLinkedList {\\n        Node head;\\n        Node tail;\\n\\n        public Node add(String key, int count) {\\n            Node newNode = new Node(key, count);\\n            if (head == null) {\\n                head = tail = newNode;\\n            } else {\\n                newNode.previous = tail;\\n                tail.next = newNode;\\n                tail = newNode;\\n            }\\n            return tail;\\n        }\\n\\n        public Node removeNode(Node nodeToRemove) {\\n            if (nodeToRemove == null)\\n                return null;\\n\\n            if (nodeToRemove == head) {\\n                head = head.next;\\n            } else if (nodeToRemove == tail) {\\n                tail = tail.previous;\\n            } else {\\n                nodeToRemove.previous.next = nodeToRemove.next;\\n                nodeToRemove.next.previous = nodeToRemove.previous;\\n            }\\n            nodeToRemove.previous = null;\\n            nodeToRemove.next = null;\\n            return nodeToRemove;\\n        }\\n\\n        public Node addToHead(Node node) {\\n            if (head == null) {\\n                head = tail = node;\\n            } else {\\n                node.next = head;\\n                head.previous = node;\\n                head = node;\\n            }\\n            return head;\\n        }\\n        \\n        public Node addNextToHead(Node node) {\\n            node.previous = head;\\n            node.next = head.next;\\n            head.next.previous = node;\\n            head.next = node;\\n            return node;\\n        }\\n\\n        public boolean isEmpty() {\\n            return head == null && tail == null;\\n        }\\n    }\\n\\n    private final Map<String, Node> keyToNode;\\n    private final DoublyLinkedList nodes;\\n    private int maxKey;\\n\\n\\n    public AllOne() {\\n        keyToNode = new HashMap<>();\\n        nodes = new DoublyLinkedList();\\n        maxKey = 1;\\n    }\\n\\n    public void inc(String key) {\\n        if (keyToNode.containsKey(key)) {\\n            Node node = keyToNode.get(key);\\n            node.count += 1;\\n            if (node.count > maxKey) {\\n                maxKey = node.count;\\n                keyToNode.put(key, nodes.addToHead(nodes.removeNode(node)));\\n            } else if (node.count == maxKey) {\\n                keyToNode.put(key, nodes.addNextToHead(nodes.removeNode(node)));\\n            }\\n        } else {\\n            Node node = nodes.add(key, 1);\\n            keyToNode.put(key, node);\\n        }\\n    }\\n\\n    public void dec(String key) {\\n        Node node = keyToNode.get(key);\\n        node.count -= 1;\\n        if (node == nodes.head)\\n            maxKey = node.count;\\n        \\n        if (node.count <= nodes.tail.count) {\\n            Node removedNode = nodes.removeNode(node);\\n            if (node.count == 0) {\\n                keyToNode.remove(key);\\n                return;\\n            }\\n            keyToNode.put(key, nodes.add(removedNode.key, removedNode.count));\\n        }\\n    }\\n\\n    public String getMaxKey() {\\n        return nodes.isEmpty() ? \"\" : nodes.head.key;\\n    }\\n\\n    public String getMinKey() {\\n        return nodes.isEmpty() ? \"\" : nodes.tail.key;\\n    }\\n}\\n\\n/**\\n * Your AllOne object will be instantiated and called as such:\\n * AllOne obj = new AllOne();\\n * obj.inc(key);\\n * obj.dec(key);\\n * String param_3 = obj.getMaxKey();\\n * String param_4 = obj.getMinKey();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2279615,
                "title": "short-easy-java-solution-all-o-1",
                "content": "Easy to read, not easy to implement :P\\n\\n1. The idea is the same as in many other solutions. Double linked list contains nodes with frequency and set of keys. HashMap keeps mapping between keys and nodes\\n2. Let\\'s introduce 2 dummy nodes which are always there: minNode and maxNode. We can easily use them when we need max,min frequency key\\n3. Now to do \\'inc()\\' or \\'dec()\\', it is easy to realize that in high-level we need just these 2 steps:\\n\\t3.1. Get reference for a new node for a key\\n\\t3.2. Rebind key from old node to new node\\n\\nSurely, last two steps come with a lot of corner cases, but those are +- easy to handle after such decomposition.\\nSo here is the code:\\n\\nclass AllOne {\\n    \\n    Node minNode;\\n    Node maxNode;\\n    Map<String, Node> keyToNode = new HashMap<>();\\n    \\n    public AllOne() {\\n        minNode = new Node(0);\\n        minNode.keys.add(\"\");\\n        maxNode = new Node(Integer.MAX_VALUE);\\n        maxNode.keys.add(\"\");\\n        minNode.next = maxNode;\\n        maxNode.prev = minNode;\\n    }\\n    \\n    public void inc(String key) {\\n        Node node = keyToNode.get(key);\\n        Node newNode = node != null ? node.getNext() : minNode.getNext();\\n        reBind(node, newNode, key);\\n\\n    }\\n    \\n    public void dec(String key) {\\n        Node node = keyToNode.get(key);\\n        Node newNode = node.getPrev();\\n        reBind(node, newNode, key);       \\n    }\\n    \\n    public String getMaxKey() {\\n        return maxNode.prev.keys.iterator().next();\\n    }\\n    \\n    public String getMinKey() {\\n        return minNode.next.keys.iterator().next();\\n    }\\n    \\n    private void reBind(Node a, Node b, String key) {\\n        if (a != null) {\\n            a.unbind(key);\\n            keyToNode.remove(key);\\n        }\\n        if (b != null) {\\n            b.keys.add(key);\\n            keyToNode.put(key, b);              \\n        }\\n    }\\n}\\n\\nclass Node {\\n    int freq;\\n    Set<String> keys = new HashSet<>();\\n    Node next;\\n    Node prev;\\n    \\n    public Node(int freq) {\\n        this.freq = freq;\\n    }\\n    \\n    public void unbind(String key) {\\n        keys.remove(key);\\n        if (keys.isEmpty()) {\\n            prev.next = next;\\n            next.prev = prev;               \\n        }    \\n    }\\n    \\n    public Node getNext() {\\n        if (next.freq == Integer.MAX_VALUE || next.freq > freq + 1) {\\n            Node newNode = new Node(freq + 1);\\n            next.prev = newNode;\\n            newNode.next = next;\\n            newNode.prev = this;\\n            next = newNode;\\n            return newNode;\\n        } \\n        return next;\\n    }\\n    \\n    public Node getPrev() {\\n        if (prev.freq < freq - 1) {\\n            Node newNode = new Node(freq - 1);\\n            prev.next = newNode;\\n            newNode.prev = prev;\\n            newNode.next = this;\\n            prev = newNode;\\n            return newNode;\\n        } \\n        return freq > 1 ? prev : null;\\n    }\\n}",
                "solutionTags": [],
                "code": "Easy to read, not easy to implement :P\\n\\n1. The idea is the same as in many other solutions. Double linked list contains nodes with frequency and set of keys. HashMap keeps mapping between keys and nodes\\n2. Let\\'s introduce 2 dummy nodes which are always there: minNode and maxNode. We can easily use them when we need max,min frequency key\\n3. Now to do \\'inc()\\' or \\'dec()\\', it is easy to realize that in high-level we need just these 2 steps:\\n\\t3.1. Get reference for a new node for a key\\n\\t3.2. Rebind key from old node to new node\\n\\nSurely, last two steps come with a lot of corner cases, but those are +- easy to handle after such decomposition.\\nSo here is the code:\\n\\nclass AllOne {\\n    \\n    Node minNode;\\n    Node maxNode;\\n    Map<String, Node> keyToNode = new HashMap<>();\\n    \\n    public AllOne() {\\n        minNode = new Node(0);\\n        minNode.keys.add(\"\");\\n        maxNode = new Node(Integer.MAX_VALUE);\\n        maxNode.keys.add(\"\");\\n        minNode.next = maxNode;\\n        maxNode.prev = minNode;\\n    }\\n    \\n    public void inc(String key) {\\n        Node node = keyToNode.get(key);\\n        Node newNode = node != null ? node.getNext() : minNode.getNext();\\n        reBind(node, newNode, key);\\n\\n    }\\n    \\n    public void dec(String key) {\\n        Node node = keyToNode.get(key);\\n        Node newNode = node.getPrev();\\n        reBind(node, newNode, key);       \\n    }\\n    \\n    public String getMaxKey() {\\n        return maxNode.prev.keys.iterator().next();\\n    }\\n    \\n    public String getMinKey() {\\n        return minNode.next.keys.iterator().next();\\n    }\\n    \\n    private void reBind(Node a, Node b, String key) {\\n        if (a != null) {\\n            a.unbind(key);\\n            keyToNode.remove(key);\\n        }\\n        if (b != null) {\\n            b.keys.add(key);\\n            keyToNode.put(key, b);              \\n        }\\n    }\\n}\\n\\nclass Node {\\n    int freq;\\n    Set<String> keys = new HashSet<>();\\n    Node next;\\n    Node prev;\\n    \\n    public Node(int freq) {\\n        this.freq = freq;\\n    }\\n    \\n    public void unbind(String key) {\\n        keys.remove(key);\\n        if (keys.isEmpty()) {\\n            prev.next = next;\\n            next.prev = prev;               \\n        }    \\n    }\\n    \\n    public Node getNext() {\\n        if (next.freq == Integer.MAX_VALUE || next.freq > freq + 1) {\\n            Node newNode = new Node(freq + 1);\\n            next.prev = newNode;\\n            newNode.next = next;\\n            newNode.prev = this;\\n            next = newNode;\\n            return newNode;\\n        } \\n        return next;\\n    }\\n    \\n    public Node getPrev() {\\n        if (prev.freq < freq - 1) {\\n            Node newNode = new Node(freq - 1);\\n            prev.next = newNode;\\n            newNode.prev = prev;\\n            newNode.next = this;\\n            prev = newNode;\\n            return newNode;\\n        } \\n        return freq > 1 ? prev : null;\\n    }\\n}",
                "codeTag": "Java"
            },
            {
                "id": 2219591,
                "title": "java-simple-o-1-solution-with-standard-java-collections",
                "content": "class AllOne {\\n\\n    private final Map<String, Integer> keyToCount = new HashMap<>(); // mapping from key to count\\n    private final List<String> keys = new ArrayList<>(); // ordered keys list, first key has max count, last key has min count\\n    private final Map<String, Integer> keyToIndex = new HashMap<>(); // mapping from key to index in ordered keys list\\n    \\n    public AllOne() {\\n        \\n    }\\n    \\n    public void inc(String key) {\\n        int count = keyToCount.merge(key, 1, Integer::sum);\\n        if (count == 1) { // first inc, create\\n            keys.add(key);\\n            keyToIndex.put(key, keys.size() - 1);\\n        } else {\\n            int index = keyToIndex.get(key);\\n            while (index > 0 \\n                   && keyToCount.get(keys.get(index)) > keyToCount.get(keys.get(index - 1))) {\\n                swap(index, index - 1); // move left\\n                index--;\\n            }\\n        }\\n    }\\n    \\n    public void dec(String key) {\\n        int count = keyToCount.merge(key, -1, Integer::sum);\\n        if (count == -1) { // does not exist\\n            return;\\n        } else if (count == 0) { // last dec, remove\\n            int index = keyToIndex.get(key);\\n            while (index < keys.size() - 1) {\\n                swap(index, index + 1);\\n                index++;\\n            }\\n            keys.remove(keys.size() - 1);\\n            keyToIndex.remove(key);\\n            keyToCount.remove(key);\\n        } else {\\n            int index = keyToIndex.get(key);\\n            while (index < keys.size() - 1 \\n                   && keyToCount.get(keys.get(index)) < keyToCount.get(keys.get(index + 1))) {\\n                swap(index, index + 1); // move right\\n                index++;\\n            }\\n        }\\n    }\\n    \\n    public String getMaxKey() {\\n        return keys.isEmpty() ? \"\" : keys.get(0);\\n    }\\n    \\n    public String getMinKey() {\\n        return keys.isEmpty() ? \"\" : keys.get(keys.size() - 1);\\n    }\\n    \\n    private void swap(int i1, int i2) {\\n        final String k1 = keys.get(i1);\\n        final String k2 = keys.get(i2);\\n        keys.set(i1, k2);\\n        keys.set(i2, k1);\\n        keyToIndex.put(k1, i2);\\n        keyToIndex.put(k2, i1);\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class AllOne {\\n\\n    private final Map<String, Integer> keyToCount = new HashMap<>(); // mapping from key to count\\n    private final List<String> keys = new ArrayList<>(); // ordered keys list, first key has max count, last key has min count\\n    private final Map<String, Integer> keyToIndex = new HashMap<>(); // mapping from key to index in ordered keys list\\n    \\n    public AllOne() {\\n        \\n    }\\n    \\n    public void inc(String key) {\\n        int count = keyToCount.merge(key, 1, Integer::sum);\\n        if (count == 1) { // first inc, create\\n            keys.add(key);\\n            keyToIndex.put(key, keys.size() - 1);\\n        } else {\\n            int index = keyToIndex.get(key);\\n            while (index > 0 \\n                   && keyToCount.get(keys.get(index)) > keyToCount.get(keys.get(index - 1))) {\\n                swap(index, index - 1); // move left\\n                index--;\\n            }\\n        }\\n    }\\n    \\n    public void dec(String key) {\\n        int count = keyToCount.merge(key, -1, Integer::sum);\\n        if (count == -1) { // does not exist\\n            return;\\n        } else if (count == 0) { // last dec, remove\\n            int index = keyToIndex.get(key);\\n            while (index < keys.size() - 1) {\\n                swap(index, index + 1);\\n                index++;\\n            }\\n            keys.remove(keys.size() - 1);\\n            keyToIndex.remove(key);\\n            keyToCount.remove(key);\\n        } else {\\n            int index = keyToIndex.get(key);\\n            while (index < keys.size() - 1 \\n                   && keyToCount.get(keys.get(index)) < keyToCount.get(keys.get(index + 1))) {\\n                swap(index, index + 1); // move right\\n                index++;\\n            }\\n        }\\n    }\\n    \\n    public String getMaxKey() {\\n        return keys.isEmpty() ? \"\" : keys.get(0);\\n    }\\n    \\n    public String getMinKey() {\\n        return keys.isEmpty() ? \"\" : keys.get(keys.size() - 1);\\n    }\\n    \\n    private void swap(int i1, int i2) {\\n        final String k1 = keys.get(i1);\\n        final String k2 = keys.get(i2);\\n        keys.set(i1, k2);\\n        keys.set(i2, k1);\\n        keyToIndex.put(k1, i2);\\n        keyToIndex.put(k2, i1);\\n    }\\n}",
                "codeTag": "Java"
            },
            {
                "id": 2211078,
                "title": "python-linked-list-dictionary-clean-code",
                "content": "```\\nfrom collections import defaultdict\\n\\nclass AllOne:\\n\\n    def __init__(self):\\n        self.head = Node(0)\\n        self.tail = Node(0)\\n        self.connect(self.head, self.tail)\\n        self.mapping = defaultdict(lambda: self.head)\\n        \\n    \\n    def connect(self, a, b):\\n        a.next = b\\n        b.prev = a\\n      \\n    \\n    def remove(self, node):\\n        temp = node.next\\n        node.prev.next = node.next\\n        temp.prev = node.prev\\n        \\n        \\n    def inc(self, key: str) -> None:\\n        curr = self.mapping[key]\\n        curr.keys.discard(key)\\n        \\n        newNode = None\\n        if curr.next.val == curr.val + 1:\\n            newNode = curr.next\\n        else:\\n            newNode = Node(curr.val + 1)\\n            self.connect(newNode, curr.next)\\n            self.connect(curr, newNode)\\n            \\n        newNode.keys.add(key)\\n        self.mapping[key] = newNode\\n        \\n        if not curr.keys and curr.val != 0:\\n            self.remove(curr)\\n            \\n            \\n    def dec(self, key: str) -> None:\\n        curr = self.mapping[key]\\n        curr.keys.discard(key)\\n        del self.mapping[key]\\n        \\n        if curr.val > 1:\\n            newNode = None\\n            if curr.prev.val == curr.val - 1:\\n                newNode = curr.prev\\n            else:\\n                newNode = Node(curr.val - 1)\\n                self.connect(curr.prev, newNode)\\n                self.connect(newNode, curr)\\n        \\n            newNode.keys.add(key)\\n            self.mapping[key] = newNode\\n\\n        if not curr.keys and curr.val != 0:\\n            self.remove(curr)\\n            \\n            \\n    def getMaxKey(self) -> str:\\n        if not self.tail.prev.val:\\n            return \\'\\'\\n        return next(iter(self.tail.prev.keys))\\n\\n    \\n    def getMinKey(self) -> str:\\n        if not self.head.next.val:\\n            return \\'\\'\\n        return next(iter(self.head.next.keys))\\n        \\n        \\nclass Node:\\n    def __init__(self, val):\\n        self.val = val\\n        self.prev = None\\n        self.next = None\\n        self.keys = set()\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import defaultdict\\n\\nclass AllOne:\\n\\n    def __init__(self):\\n        self.head = Node(0)\\n        self.tail = Node(0)\\n        self.connect(self.head, self.tail)\\n        self.mapping = defaultdict(lambda: self.head)\\n        \\n    \\n    def connect(self, a, b):\\n        a.next = b\\n        b.prev = a\\n      \\n    \\n    def remove(self, node):\\n        temp = node.next\\n        node.prev.next = node.next\\n        temp.prev = node.prev\\n        \\n        \\n    def inc(self, key: str) -> None:\\n        curr = self.mapping[key]\\n        curr.keys.discard(key)\\n        \\n        newNode = None\\n        if curr.next.val == curr.val + 1:\\n            newNode = curr.next\\n        else:\\n            newNode = Node(curr.val + 1)\\n            self.connect(newNode, curr.next)\\n            self.connect(curr, newNode)\\n            \\n        newNode.keys.add(key)\\n        self.mapping[key] = newNode\\n        \\n        if not curr.keys and curr.val != 0:\\n            self.remove(curr)\\n            \\n            \\n    def dec(self, key: str) -> None:\\n        curr = self.mapping[key]\\n        curr.keys.discard(key)\\n        del self.mapping[key]\\n        \\n        if curr.val > 1:\\n            newNode = None\\n            if curr.prev.val == curr.val - 1:\\n                newNode = curr.prev\\n            else:\\n                newNode = Node(curr.val - 1)\\n                self.connect(curr.prev, newNode)\\n                self.connect(newNode, curr)\\n        \\n            newNode.keys.add(key)\\n            self.mapping[key] = newNode\\n\\n        if not curr.keys and curr.val != 0:\\n            self.remove(curr)\\n            \\n            \\n    def getMaxKey(self) -> str:\\n        if not self.tail.prev.val:\\n            return \\'\\'\\n        return next(iter(self.tail.prev.keys))\\n\\n    \\n    def getMinKey(self) -> str:\\n        if not self.head.next.val:\\n            return \\'\\'\\n        return next(iter(self.head.next.keys))\\n        \\n        \\nclass Node:\\n    def __init__(self, val):\\n        self.val = val\\n        self.prev = None\\n        self.next = None\\n        self.keys = set()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2189443,
                "title": "c-clean-code-83-faster-self-implemented-doubly-linked-list",
                "content": "class Node{\\npublic:\\n\\n    string val;\\n    Node* next;\\n    Node* prev;\\n    \\n    Node(string n){\\n        val = n;\\n        next = NULL;\\n        prev = NULL;\\n    }\\n};\\n\\nclass AllOne {\\nprivate:\\n\\n    Node* head;\\n    Node* tail;\\n    map <string, int> mp;\\n    map <string, Node*> link;\\n    \\n    void insert_at_head(string key){\\n        Node* temp = new Node(key);\\n        link[key] = temp;\\n        \\n        if(head == NULL){\\n            head = temp;\\n            tail = temp;\\n            return;\\n        }\\n        \\n        head -> prev = temp;\\n        temp -> next = head;\\n        head = temp;\\n        return;\\n    }\\n    \\n    void manageInc(string key){\\n        Node* temp = link[key];\\n        \\n        if(temp == tail) return;\\n        \\n        if(mp[temp->val] <= mp[temp->next->val]) return;\\n        \\n        \\n        Node* num = temp -> next;\\n        while(num != NULL && mp[temp->val] > mp[num->val]){\\n            num = num -> next;\\n        }\\n\\n        \\n        if(temp == head){\\n            temp -> next -> prev = NULL;\\n            head = temp -> next;\\n        }\\n        else{\\n            temp -> prev -> next = temp -> next;\\n            temp -> next -> prev = temp -> prev;\\n        }\\n\\n        if(num == NULL){\\n            tail -> next = temp;\\n            temp -> prev = tail;\\n            tail = temp;\\n            tail -> next = NULL;\\n            return;\\n        }\\n        else{\\n            num = num -> prev;\\n            \\n            temp -> next = num -> next;\\n            num -> next -> prev = temp;\\n            \\n            num -> next = temp;\\n            temp -> prev = num;\\n            return;\\n        }\\n    }\\n    \\n    void manageDec(string key){\\n        Node* temp = link[key];\\n        \\n        if(temp == head) return;\\n        \\n        if(mp[temp->val] >= mp[temp->prev->val]) return;\\n        \\n        Node* num = temp -> prev;\\n        while(num != NULL && mp[temp->val] < mp[num->val]){\\n            num = num -> prev;\\n        }\\n        \\n        if(temp == tail){\\n            tail  = temp -> prev;\\n            tail -> next = NULL;\\n        }\\n        else{\\n            temp -> prev -> next = temp -> next;\\n            temp -> next -> prev = temp -> prev;\\n        }\\n        \\n        if(num == NULL){\\n            temp -> next = head;\\n            head -> prev = temp;\\n            head = temp;\\n            head -> prev = NULL;\\n            return;\\n        }\\n        else{\\n            num = num -> next;\\n            \\n            temp -> prev = num -> prev;\\n            temp -> next = num;\\n            \\n            num -> prev = temp;\\n            temp -> prev -> next = temp;\\n            return;\\n        }\\n    }\\n    \\n    void deleteNode(string key){\\n        Node* temp = link[key];\\n        \\n        if(temp == head && temp == tail){\\n            head = NULL;\\n            tail = NULL;\\n            link.erase(key);\\n            return;\\n        }\\n        \\n        if(temp == head){\\n            head = temp -> next;\\n            head -> prev = NULL;\\n            link.erase(key);\\n            return;\\n        }\\n        \\n        if(temp == tail){\\n            tail = temp->prev;\\n            tail -> next = NULL;\\n            link.erase(key);\\n            return;\\n        }\\n        \\n        temp -> prev -> next = temp -> next;\\n        temp -> next -> prev = temp -> prev;\\n        link.erase(key);\\n        return;\\n    }\\n    \\npublic:\\n\\n    AllOne() {\\n        head = NULL;\\n        tail = NULL;\\n    }\\n    \\n    void inc(string key) {\\n        if(mp.find(key) == mp.end()){\\n            mp[key] = 1;\\n            insert_at_head(key);\\n        }\\n        else{\\n            mp[key]++;\\n            manageInc(key);\\n        }\\n    }\\n    \\n    void dec(string key) {\\n        mp[key]--;\\n        \\n        if(mp[key] == 0){\\n            deleteNode(key);\\n            mp.erase(key);\\n        }\\n        else{\\n            manageDec(key);\\n        }\\n    }\\n    \\n    string getMaxKey() {\\n        if(head == NULL) return \"\";\\n        \\n        string ans = tail -> val;\\n        return ans;\\n    }\\n    \\n    string getMinKey() {\\n        if(head == NULL) return \"\";\\n        \\n        string ans = head -> val;\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Node{\\npublic:\\n\\n    string val;\\n    Node* next;\\n    Node* prev;\\n    \\n    Node(string n){\\n        val = n;\\n        next = NULL;\\n        prev = NULL;\\n    }\\n};\\n\\nclass AllOne {\\nprivate:\\n\\n    Node* head;\\n    Node* tail;\\n    map <string, int> mp;\\n    map <string, Node*> link;\\n    \\n    void insert_at_head(string key){\\n        Node* temp = new Node(key);\\n        link[key] = temp;\\n        \\n        if(head == NULL){\\n            head = temp;\\n            tail = temp;\\n            return;\\n        }\\n        \\n        head -> prev = temp;\\n        temp -> next = head;\\n        head = temp;\\n        return;\\n    }\\n    \\n    void manageInc(string key){\\n        Node* temp = link[key];\\n        \\n        if(temp == tail) return;\\n        \\n        if(mp[temp->val] <= mp[temp->next->val]) return;\\n        \\n        \\n        Node* num = temp -> next;\\n        while(num != NULL && mp[temp->val] > mp[num->val]){\\n            num = num -> next;\\n        }\\n\\n        \\n        if(temp == head){\\n            temp -> next -> prev = NULL;\\n            head = temp -> next;\\n        }\\n        else{\\n            temp -> prev -> next = temp -> next;\\n            temp -> next -> prev = temp -> prev;\\n        }\\n\\n        if(num == NULL){\\n            tail -> next = temp;\\n            temp -> prev = tail;\\n            tail = temp;\\n            tail -> next = NULL;\\n            return;\\n        }\\n        else{\\n            num = num -> prev;\\n            \\n            temp -> next = num -> next;\\n            num -> next -> prev = temp;\\n            \\n            num -> next = temp;\\n            temp -> prev = num;\\n            return;\\n        }\\n    }\\n    \\n    void manageDec(string key){\\n        Node* temp = link[key];\\n        \\n        if(temp == head) return;\\n        \\n        if(mp[temp->val] >= mp[temp->prev->val]) return;\\n        \\n        Node* num = temp -> prev;\\n        while(num != NULL && mp[temp->val] < mp[num->val]){\\n            num = num -> prev;\\n        }\\n        \\n        if(temp == tail){\\n            tail  = temp -> prev;\\n            tail -> next = NULL;\\n        }\\n        else{\\n            temp -> prev -> next = temp -> next;\\n            temp -> next -> prev = temp -> prev;\\n        }\\n        \\n        if(num == NULL){\\n            temp -> next = head;\\n            head -> prev = temp;\\n            head = temp;\\n            head -> prev = NULL;\\n            return;\\n        }\\n        else{\\n            num = num -> next;\\n            \\n            temp -> prev = num -> prev;\\n            temp -> next = num;\\n            \\n            num -> prev = temp;\\n            temp -> prev -> next = temp;\\n            return;\\n        }\\n    }\\n    \\n    void deleteNode(string key){\\n        Node* temp = link[key];\\n        \\n        if(temp == head && temp == tail){\\n            head = NULL;\\n            tail = NULL;\\n            link.erase(key);\\n            return;\\n        }\\n        \\n        if(temp == head){\\n            head = temp -> next;\\n            head -> prev = NULL;\\n            link.erase(key);\\n            return;\\n        }\\n        \\n        if(temp == tail){\\n            tail = temp->prev;\\n            tail -> next = NULL;\\n            link.erase(key);\\n            return;\\n        }\\n        \\n        temp -> prev -> next = temp -> next;\\n        temp -> next -> prev = temp -> prev;\\n        link.erase(key);\\n        return;\\n    }\\n    \\npublic:\\n\\n    AllOne() {\\n        head = NULL;\\n        tail = NULL;\\n    }\\n    \\n    void inc(string key) {\\n        if(mp.find(key) == mp.end()){\\n            mp[key] = 1;\\n            insert_at_head(key);\\n        }\\n        else{\\n            mp[key]++;\\n            manageInc(key);\\n        }\\n    }\\n    \\n    void dec(string key) {\\n        mp[key]--;\\n        \\n        if(mp[key] == 0){\\n            deleteNode(key);\\n            mp.erase(key);\\n        }\\n        else{\\n            manageDec(key);\\n        }\\n    }\\n    \\n    string getMaxKey() {\\n        if(head == NULL) return \"\";\\n        \\n        string ans = tail -> val;\\n        return ans;\\n    }\\n    \\n    string getMinKey() {\\n        if(head == NULL) return \"\";\\n        \\n        string ans = head -> val;\\n        return ans;\\n    }\\n};",
                "codeTag": "Java"
            },
            {
                "id": 2141575,
                "title": "java-simple-hashmap-treemap",
                "content": "\\n\\n```\\nclass AllOne {\\n    \\n    Map<String, Integer> map;\\n    TreeMap<Integer, Set<String>> maxMap;\\n\\n    public AllOne() {\\n        map = new HashMap<>();\\n        maxMap = new TreeMap<>();\\n    }\\n    \\n    public void inc(String key) {\\n        int val = map.getOrDefault(key, 0);\\n        Set<String> s = maxMap.getOrDefault(val, new HashSet<>());\\n        s.remove(key);\\n        if (s.isEmpty()) {\\n            maxMap.remove(val);\\n        } else {\\n            maxMap.put(val, s);\\n        }\\n        val++;\\n        Set<String> s1 = maxMap.getOrDefault(val, new HashSet<>());\\n        s1.add(key);\\n        maxMap.put(val, s1);\\n        map.put(key, val);\\n    }\\n    \\n    public void dec(String key) {\\n        int val = map.getOrDefault(key, 0);\\n        Set<String> s = maxMap.getOrDefault(val, new HashSet<>());\\n        s.remove(key);\\n        if (s.isEmpty()) {\\n            maxMap.remove(val);\\n        } else {\\n            maxMap.put(val, s);\\n        }\\n        val--;\\n        if (val < 1) {\\n            map.remove(key);\\n        } else {\\n            map.put(key, val);\\n            Set<String> s1 = maxMap.getOrDefault(val, new HashSet<>());\\n            s1.add(key);\\n            maxMap.put(val, s1);\\n        }\\n    }\\n    \\n    public String getMaxKey() {\\n        if (maxMap.isEmpty()) return \"\";\\n        return maxMap.get(maxMap.lastKey()).iterator().next();\\n    }\\n    \\n    public String getMinKey() {\\n        if (maxMap.isEmpty()) return \"\";\\n        return maxMap.get(maxMap.firstKey()).iterator().next();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass AllOne {\\n    \\n    Map<String, Integer> map;\\n    TreeMap<Integer, Set<String>> maxMap;\\n\\n    public AllOne() {\\n        map = new HashMap<>();\\n        maxMap = new TreeMap<>();\\n    }\\n    \\n    public void inc(String key) {\\n        int val = map.getOrDefault(key, 0);\\n        Set<String> s = maxMap.getOrDefault(val, new HashSet<>());\\n        s.remove(key);\\n        if (s.isEmpty()) {\\n            maxMap.remove(val);\\n        } else {\\n            maxMap.put(val, s);\\n        }\\n        val++;\\n        Set<String> s1 = maxMap.getOrDefault(val, new HashSet<>());\\n        s1.add(key);\\n        maxMap.put(val, s1);\\n        map.put(key, val);\\n    }\\n    \\n    public void dec(String key) {\\n        int val = map.getOrDefault(key, 0);\\n        Set<String> s = maxMap.getOrDefault(val, new HashSet<>());\\n        s.remove(key);\\n        if (s.isEmpty()) {\\n            maxMap.remove(val);\\n        } else {\\n            maxMap.put(val, s);\\n        }\\n        val--;\\n        if (val < 1) {\\n            map.remove(key);\\n        } else {\\n            map.put(key, val);\\n            Set<String> s1 = maxMap.getOrDefault(val, new HashSet<>());\\n            s1.add(key);\\n            maxMap.put(val, s1);\\n        }\\n    }\\n    \\n    public String getMaxKey() {\\n        if (maxMap.isEmpty()) return \"\";\\n        return maxMap.get(maxMap.lastKey()).iterator().next();\\n    }\\n    \\n    public String getMinKey() {\\n        if (maxMap.isEmpty()) return \"\";\\n        return maxMap.get(maxMap.firstKey()).iterator().next();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2111166,
                "title": "java-53ms-95-cpu-memory-efficient-self-explanatory",
                "content": "Key points..\\n1. Maintain sorted frequency list (DLL). \\n2. The list node contains frequency and keySet. \\n3. Use one map to store key -> allocated_node map.\\n4. Code optimized using dummy start and end with frequencies 0 and INT_MAX respectively.\\n\\n```\\nclass AllOne {\\n\\n   public static class Node {\\n        int frequency;\\n        Node prev, next;\\n        Set<String> keys = new HashSet<>();\\n\\n        public Node(int frequency) {\\n            this.frequency = frequency;\\n        }\\n    }\\n\\n    private Node start, end;\\n    private final Map<String, Node> cacheMap = new HashMap<>();\\n\\n    public AllOne() {\\n        start = new Node(0);\\n        end   = new Node(Integer.MAX_VALUE);\\n        start.next=end;\\n        end.prev=start;\\n    }\\n\\n    public void inc(String key) {\\n\\n        Node node = cacheMap.getOrDefault(key, start);\\n        node.keys.remove(key);\\n\\n        if(node.next.frequency!=node.frequency+1){\\n            Node tNode = new Node(node.frequency+1);\\n            tNode.next = node.next;\\n            tNode.prev = node;\\n\\n            node.next.prev = tNode;\\n            node.next = tNode;\\n        }\\n\\n        cacheMap.put(key, node.next);\\n        node.next.keys.add(key);\\n\\n        if(node !=start && node.keys.size()==0) {\\n            node.prev.next = node.next;\\n            node.next.prev = node.prev;\\n        }\\n    }\\n\\n    public void dec(String key) {\\n        if(!cacheMap.containsKey(key)) {\\n            return;\\n        }\\n\\n        Node node = cacheMap.remove(key);\\n        node.keys.remove(key);\\n\\n        if (node.prev.frequency != node.frequency-1) {\\n            Node tNode = new Node(node.frequency - 1);\\n            tNode.next = node;\\n            tNode.prev = node.prev;\\n\\n            node.prev.next = tNode;\\n            node.prev = tNode;\\n        }\\n\\n        if(node.prev!=start) {\\n            node.prev.keys.add(key);\\n            cacheMap.put(key, node.prev);\\n        }\\n\\n        if(node.keys.size()==0) {\\n            node.prev.next = node.next;\\n            node.next.prev = node.prev;\\n        }\\n    }\\n\\n    public String getMinKey(){\\n        return  start.next==end ? \"\" : start.next.keys.iterator().next();\\n    }\\n\\n    public String getMaxKey(){\\n        return  end.prev==start ? \"\" : end.prev.keys.iterator().next();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass AllOne {\\n\\n   public static class Node {\\n        int frequency;\\n        Node prev, next;\\n        Set<String> keys = new HashSet<>();\\n\\n        public Node(int frequency) {\\n            this.frequency = frequency;\\n        }\\n    }\\n\\n    private Node start, end;\\n    private final Map<String, Node> cacheMap = new HashMap<>();\\n\\n    public AllOne() {\\n        start = new Node(0);\\n        end   = new Node(Integer.MAX_VALUE);\\n        start.next=end;\\n        end.prev=start;\\n    }\\n\\n    public void inc(String key) {\\n\\n        Node node = cacheMap.getOrDefault(key, start);\\n        node.keys.remove(key);\\n\\n        if(node.next.frequency!=node.frequency+1){\\n            Node tNode = new Node(node.frequency+1);\\n            tNode.next = node.next;\\n            tNode.prev = node;\\n\\n            node.next.prev = tNode;\\n            node.next = tNode;\\n        }\\n\\n        cacheMap.put(key, node.next);\\n        node.next.keys.add(key);\\n\\n        if(node !=start && node.keys.size()==0) {\\n            node.prev.next = node.next;\\n            node.next.prev = node.prev;\\n        }\\n    }\\n\\n    public void dec(String key) {\\n        if(!cacheMap.containsKey(key)) {\\n            return;\\n        }\\n\\n        Node node = cacheMap.remove(key);\\n        node.keys.remove(key);\\n\\n        if (node.prev.frequency != node.frequency-1) {\\n            Node tNode = new Node(node.frequency - 1);\\n            tNode.next = node;\\n            tNode.prev = node.prev;\\n\\n            node.prev.next = tNode;\\n            node.prev = tNode;\\n        }\\n\\n        if(node.prev!=start) {\\n            node.prev.keys.add(key);\\n            cacheMap.put(key, node.prev);\\n        }\\n\\n        if(node.keys.size()==0) {\\n            node.prev.next = node.next;\\n            node.next.prev = node.prev;\\n        }\\n    }\\n\\n    public String getMinKey(){\\n        return  start.next==end ? \"\" : start.next.keys.iterator().next();\\n    }\\n\\n    public String getMaxKey(){\\n        return  end.prev==start ? \"\" : end.prev.keys.iterator().next();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2096973,
                "title": "java-simple-approach-using-map-double-linked-list-with-comments",
                "content": "//The idea is using map to have instant look up, and using double linked list to maintain the sorted order in the list, from left to right\\n//Each time the node count increase, shift it to the right\\n//And, each time the node count decrease, shift it to the left.\\n//Another trick, init head and tail to some random val, so the list always have head and tail none null, to make insert and delete supper easy, and don\\'t need to handle edges cases.\\n\\n```\\nclass AllOne {\\n    Map<String, DDNode> map;\\n    DDList ddList;\\n    public AllOne() {\\n        map = new HashMap<>();\\n        ddList = new DDList();\\n    }\\n    \\n    public void inc(String key) {\\n        if(map.containsKey(key)) {\\n            DDNode node = map.get(key);\\n            node.count++;\\n            ddList.shiftToRight(node);\\n        } else {\\n            DDNode node = new DDNode(key);\\n            map.put(key, node);\\n            ddList.addToTail(node);\\n        }\\n    }\\n    \\n    public void dec(String key) {\\n        DDNode node = map.get(key);\\n        if(node.count == 1) {\\n            ddList.deleteNode(node);\\n            map.remove(node.val);\\n        } else {\\n            node.count--;\\n            ddList.shiftToLeft(node);\\n        }\\n    }\\n    \\n    public String getMaxKey() {\\n        if(ddList.head.prev != ddList.tail) \\n            return ddList.head.prev.val;\\n        else\\n            return \"\";\\n    }   \\n    \\n    public String getMinKey() {\\n        if(ddList.tail.next != ddList.head)\\n            return ddList.tail.next.val;\\n        else return \"\";\\n    }\\n}\\n\\nclass DDList {\\n    DDNode head; //head maintain max count key\\n    DDNode tail; //tail maaintain min count key\\n    DDList() {\\n        head = new DDNode(\"NULL\");\\n        tail = new DDNode(\"NULL\");\\n        head.prev = tail;\\n        tail.next = head;\\n    }\\n    \\n    public void addToTail(DDNode node) {\\n        insertNode(tail, tail.next, node);\\n    }\\n    \\n    public void shiftToLeft(DDNode node) {\\n        deleteNode(node);\\n        node.next = null; //complete remove node from the linked list\\n        DDNode prev = node.prev;\\n        \\n        while(prev != tail && node.count < prev.count) {\\n            prev = prev.prev; //go to the left\\n        }\\n        \\n        insertNode(prev, prev.next, node);\\n    }\\n    \\n    public void shiftToRight(DDNode node) {\\n        deleteNode(node);\\n        node.prev = null; //complete remove node from the linked list\\n        \\n        DDNode p = node.next;\\n        while(p != head && node.count > p.count) {\\n            p = p.next; //go to right\\n        }\\n        \\n        //at this point p.val > node.val, insert node to the middle\\n        insertNode(p.prev, p, node);\\n    }\\n    \\n    public void insertNode(DDNode prev, DDNode next, DDNode curr) {\\n        //System.out.println(\"prev: \" + prev.toString() + \" - next: \" + next.toString() + \" - curr: \" + curr);\\n        prev.next = curr;\\n        curr.prev = prev;\\n        \\n        curr.next = next;\\n        next.prev = curr;\\n    }\\n    \\n    public void deleteNode(DDNode node) {\\n        node.prev.next = node.next;\\n        node.next.prev = node.prev;\\n    }\\n}\\n\\nclass DDNode {\\n    DDNode next;\\n    DDNode prev;\\n    String val;\\n    int count;\\n    DDNode(String val) {\\n        this.val = val;\\n        this.count = 1;\\n        next = null;\\n        prev = null;\\n    }\\n    \\n    @Override\\n    public String toString() {\\n        return \"(\" + val + \" :\" + count + \")\";\\n    }\\n    \\n    @Override\\n\\tpublic boolean equals(Object o) {\\n\\t\\tif (this == o) {\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t\\tif (!(o instanceof DDNode)) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\tDDNode ddNode = (DDNode) o;\\n\\t\\treturn Objects.equals(val, ddNode.val);\\n\\t}\\n\\n\\t@Override\\n\\tpublic int hashCode() {\\n\\t\\treturn Objects.hash(val);\\n\\t}\\n}\\n/**\\n * Your AllOne object will be instantiated and called as such:\\n * AllOne obj = new AllOne();\\n * obj.inc(key);\\n * obj.dec(key);\\n * String param_3 = obj.getMaxKey();\\n * String param_4 = obj.getMinKey();\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass AllOne {\\n    Map<String, DDNode> map;\\n    DDList ddList;\\n    public AllOne() {\\n        map = new HashMap<>();\\n        ddList = new DDList();\\n    }\\n    \\n    public void inc(String key) {\\n        if(map.containsKey(key)) {\\n            DDNode node = map.get(key);\\n            node.count++;\\n            ddList.shiftToRight(node);\\n        } else {\\n            DDNode node = new DDNode(key);\\n            map.put(key, node);\\n            ddList.addToTail(node);\\n        }\\n    }\\n    \\n    public void dec(String key) {\\n        DDNode node = map.get(key);\\n        if(node.count == 1) {\\n            ddList.deleteNode(node);\\n            map.remove(node.val);\\n        } else {\\n            node.count--;\\n            ddList.shiftToLeft(node);\\n        }\\n    }\\n    \\n    public String getMaxKey() {\\n        if(ddList.head.prev != ddList.tail) \\n            return ddList.head.prev.val;\\n        else\\n            return \"\";\\n    }   \\n    \\n    public String getMinKey() {\\n        if(ddList.tail.next != ddList.head)\\n            return ddList.tail.next.val;\\n        else return \"\";\\n    }\\n}\\n\\nclass DDList {\\n    DDNode head; //head maintain max count key\\n    DDNode tail; //tail maaintain min count key\\n    DDList() {\\n        head = new DDNode(\"NULL\");\\n        tail = new DDNode(\"NULL\");\\n        head.prev = tail;\\n        tail.next = head;\\n    }\\n    \\n    public void addToTail(DDNode node) {\\n        insertNode(tail, tail.next, node);\\n    }\\n    \\n    public void shiftToLeft(DDNode node) {\\n        deleteNode(node);\\n        node.next = null; //complete remove node from the linked list\\n        DDNode prev = node.prev;\\n        \\n        while(prev != tail && node.count < prev.count) {\\n            prev = prev.prev; //go to the left\\n        }\\n        \\n        insertNode(prev, prev.next, node);\\n    }\\n    \\n    public void shiftToRight(DDNode node) {\\n        deleteNode(node);\\n        node.prev = null; //complete remove node from the linked list\\n        \\n        DDNode p = node.next;\\n        while(p != head && node.count > p.count) {\\n            p = p.next; //go to right\\n        }\\n        \\n        //at this point p.val > node.val, insert node to the middle\\n        insertNode(p.prev, p, node);\\n    }\\n    \\n    public void insertNode(DDNode prev, DDNode next, DDNode curr) {\\n        //System.out.println(\"prev: \" + prev.toString() + \" - next: \" + next.toString() + \" - curr: \" + curr);\\n        prev.next = curr;\\n        curr.prev = prev;\\n        \\n        curr.next = next;\\n        next.prev = curr;\\n    }\\n    \\n    public void deleteNode(DDNode node) {\\n        node.prev.next = node.next;\\n        node.next.prev = node.prev;\\n    }\\n}\\n\\nclass DDNode {\\n    DDNode next;\\n    DDNode prev;\\n    String val;\\n    int count;\\n    DDNode(String val) {\\n        this.val = val;\\n        this.count = 1;\\n        next = null;\\n        prev = null;\\n    }\\n    \\n    @Override\\n    public String toString() {\\n        return \"(\" + val + \" :\" + count + \")\";\\n    }\\n    \\n    @Override\\n\\tpublic boolean equals(Object o) {\\n\\t\\tif (this == o) {\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t\\tif (!(o instanceof DDNode)) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\tDDNode ddNode = (DDNode) o;\\n\\t\\treturn Objects.equals(val, ddNode.val);\\n\\t}\\n\\n\\t@Override\\n\\tpublic int hashCode() {\\n\\t\\treturn Objects.hash(val);\\n\\t}\\n}\\n/**\\n * Your AllOne object will be instantiated and called as such:\\n * AllOne obj = new AllOne();\\n * obj.inc(key);\\n * obj.dec(key);\\n * String param_3 = obj.getMaxKey();\\n * String param_4 = obj.getMinKey();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2008055,
                "title": "a-clear-javascript-solution",
                "content": "```\\nvar AllOne = function() {\\n  this.map = new Map();\\n  this.pre = \\'\\';\\n};\\n\\n/** \\n * @param {set} map\\n * @param {function} handler\\n * @return {map}\\n */\\nAllOne.prototype.sort = function(map, handler) {\\n  return new Map([...map].sort(handler));\\n};\\n\\n/** \\n * @param {string} key\\n * @return {void}\\n */\\nAllOne.prototype.inc = function(key) {\\n  this.map.set(key, this.map.get(key) + 1 || 1);\\n  this.pre = \\'inc\\';\\n};\\n\\n/** \\n * @param {string} key\\n * @return {void}\\n */\\nAllOne.prototype.dec = function(key) {\\n  this.map.get(key) == 1 ? this.map.delete(key) : this.map.set(key, this.map.get(key) - 1);\\n  this.pre = \\'dec\\';\\n};\\n\\n/**\\n * @return {string}\\n */\\nAllOne.prototype.getMaxKey = function() {\\n  if (this.pre != \\'max\\') {\\n    this.map = this.sort(this.map, (a, b) => b[1] - a[1]);\\n  }\\n  this.pre = \\'max\\';\\n  return this.map.keys().next().value || \\'\\';\\n};\\n\\n/**\\n * @return {string}\\n */\\nAllOne.prototype.getMinKey = function() {\\n  if (this.pre != \\'min\\') {\\n    this.map = this.sort(this.map, (a, b) => a[1] - b[1]);\\n  }\\n  this.pre = \\'min\\';\\n  return this.map.keys().next().value || \\'\\';\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar AllOne = function() {\\n  this.map = new Map();\\n  this.pre = \\'\\';\\n};\\n\\n/** \\n * @param {set} map\\n * @param {function} handler\\n * @return {map}\\n */\\nAllOne.prototype.sort = function(map, handler) {\\n  return new Map([...map].sort(handler));\\n};\\n\\n/** \\n * @param {string} key\\n * @return {void}\\n */\\nAllOne.prototype.inc = function(key) {\\n  this.map.set(key, this.map.get(key) + 1 || 1);\\n  this.pre = \\'inc\\';\\n};\\n\\n/** \\n * @param {string} key\\n * @return {void}\\n */\\nAllOne.prototype.dec = function(key) {\\n  this.map.get(key) == 1 ? this.map.delete(key) : this.map.set(key, this.map.get(key) - 1);\\n  this.pre = \\'dec\\';\\n};\\n\\n/**\\n * @return {string}\\n */\\nAllOne.prototype.getMaxKey = function() {\\n  if (this.pre != \\'max\\') {\\n    this.map = this.sort(this.map, (a, b) => b[1] - a[1]);\\n  }\\n  this.pre = \\'max\\';\\n  return this.map.keys().next().value || \\'\\';\\n};\\n\\n/**\\n * @return {string}\\n */\\nAllOne.prototype.getMinKey = function() {\\n  if (this.pre != \\'min\\') {\\n    this.map = this.sort(this.map, (a, b) => a[1] - b[1]);\\n  }\\n  this.pre = \\'min\\';\\n  return this.map.keys().next().value || \\'\\';\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1989486,
                "title": "treeset-hashmap-implementation",
                "content": "```\\nclass AllOne {\\n    Map<String, Integer> count;\\n    TreeSet<String> order;\\n\\n    public AllOne() {\\n        count = new HashMap<>();\\n        order = new TreeSet<>((a, b) -> {\\n            int comp = Integer.compare(count.get(a), count.get(b));\\n            if (comp == 0) {\\n                comp = a.compareTo(b);\\n            }\\n            return comp;\\n            });\\n    }\\n    \\n    public void inc(String key) {\\n        if (count.containsKey(key))\\n            order.remove(key);\\n        count.put(key, count.getOrDefault(key, 0) + 1);\\n        order.add(key);\\n    }\\n    \\n    public void dec(String key) {\\n        if (count.get(key) == 1) {\\n            order.remove(key);\\n            count.remove(key);\\n        } else {\\n            if (count.containsKey(key))\\n                order.remove(key);\\n            count.put(key, count.getOrDefault(key, 0) - 1);\\n            order.add(key);\\n        }\\n    }\\n    \\n    public String getMaxKey() {\\n        if (order.size() == 0) return \"\";\\n        return order.last();\\n    }\\n    \\n    public String getMinKey() {\\n        if (order.size() == 0) return \"\";\\n        return order.first();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass AllOne {\\n    Map<String, Integer> count;\\n    TreeSet<String> order;\\n\\n    public AllOne() {\\n        count = new HashMap<>();\\n        order = new TreeSet<>((a, b) -> {\\n            int comp = Integer.compare(count.get(a), count.get(b));\\n            if (comp == 0) {\\n                comp = a.compareTo(b);\\n            }\\n            return comp;\\n            });\\n    }\\n    \\n    public void inc(String key) {\\n        if (count.containsKey(key))\\n            order.remove(key);\\n        count.put(key, count.getOrDefault(key, 0) + 1);\\n        order.add(key);\\n    }\\n    \\n    public void dec(String key) {\\n        if (count.get(key) == 1) {\\n            order.remove(key);\\n            count.remove(key);\\n        } else {\\n            if (count.containsKey(key))\\n                order.remove(key);\\n            count.put(key, count.getOrDefault(key, 0) - 1);\\n            order.add(key);\\n        }\\n    }\\n    \\n    public String getMaxKey() {\\n        if (order.size() == 0) return \"\";\\n        return order.last();\\n    }\\n    \\n    public String getMinKey() {\\n        if (order.size() == 0) return \"\";\\n        return order.first();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1975933,
                "title": "java-solution-using-hashmap-counting-and-treemap-ordering-of-counts",
                "content": "HashMap is used for keeping track of the counts (freqs) of input keys, which should be good for `inc` and `dec` purposes.\\nBut we need to know at any given point the max counts or min counts, so I decided to use a TreeMap to keep a sorted key value pairs, where key is the bucket meaning `count`s, and its value would be \"what are the keys that appeared `count` times\".\\n\\n```\\nclass AllOne {\\n    \\n    Map<String, Integer> map;\\n    TreeMap<Integer, Set<String>> tmap;\\n\\n    public AllOne() {\\n        map = new HashMap<>();\\n        tmap = new TreeMap<>();\\n    }\\n    \\n    public void inc(String key) {\\n        int cur = map.getOrDefault(key, 0);\\n        map.put(key, cur + 1);\\n        // add key to destination bucket\\n        Set<String> strings = tmap.getOrDefault(cur + 1, new HashSet<String>());\\n        strings.add(key);\\n        tmap.put(cur + 1, strings);\\n        // remove key from previous bucket (if applicable)\\n        if (cur > 0) {\\n            removeFromTreeMap(cur, key);\\n        }\\n    }\\n    \\n    public void dec(String key) {\\n        int cur = map.getOrDefault(key, 0);\\n        if (cur == 0) {\\n            // shouldn\\'t happen\\n            throw new IllegalArgumentException();\\n        }\\n        if (cur == 1) {\\n            map.remove(key);\\n            // add key to destination bucket, but no need in this case\\n        } else {\\n            // cur > 1\\n            map.put(key, cur - 1);\\n            // add key to destination bucket\\n            Set<String> strings = tmap.getOrDefault(cur - 1, new HashSet<String>());\\n            strings.add(key);\\n            tmap.put(cur - 1, strings);\\n        }\\n        // remove key from previous bucket (if applicable)\\n        removeFromTreeMap(cur, key);\\n    }\\n    \\n    private void removeFromTreeMap(Integer count, String key) {\\n        if (tmap.get(count).size() == 1) {\\n            tmap.remove(count);\\n        } else {\\n            tmap.get(count).remove(key);\\n        }\\n    }\\n    \\n    public String getMaxKey() {\\n        Map.Entry<Integer, Set<String>> entry = tmap.lastEntry();\\n        if (entry != null) {\\n            for (String ans: entry.getValue()) {\\n                return ans;\\n            }\\n        }\\n        return \"\";\\n    }\\n    \\n    public String getMinKey() {\\n        Map.Entry<Integer, Set<String>> entry = tmap.firstEntry();\\n        if (entry != null) {\\n            for (String ans: entry.getValue()) {\\n                return ans;\\n            }\\n        }\\n        return \"\";\\n    }\\n}\\n\\n/**\\n * Your AllOne object will be instantiated and called as such:\\n * AllOne obj = new AllOne();\\n * obj.inc(key);\\n * obj.dec(key);\\n * String param_3 = obj.getMaxKey();\\n * String param_4 = obj.getMinKey();\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass AllOne {\\n    \\n    Map<String, Integer> map;\\n    TreeMap<Integer, Set<String>> tmap;\\n\\n    public AllOne() {\\n        map = new HashMap<>();\\n        tmap = new TreeMap<>();\\n    }\\n    \\n    public void inc(String key) {\\n        int cur = map.getOrDefault(key, 0);\\n        map.put(key, cur + 1);\\n        // add key to destination bucket\\n        Set<String> strings = tmap.getOrDefault(cur + 1, new HashSet<String>());\\n        strings.add(key);\\n        tmap.put(cur + 1, strings);\\n        // remove key from previous bucket (if applicable)\\n        if (cur > 0) {\\n            removeFromTreeMap(cur, key);\\n        }\\n    }\\n    \\n    public void dec(String key) {\\n        int cur = map.getOrDefault(key, 0);\\n        if (cur == 0) {\\n            // shouldn\\'t happen\\n            throw new IllegalArgumentException();\\n        }\\n        if (cur == 1) {\\n            map.remove(key);\\n            // add key to destination bucket, but no need in this case\\n        } else {\\n            // cur > 1\\n            map.put(key, cur - 1);\\n            // add key to destination bucket\\n            Set<String> strings = tmap.getOrDefault(cur - 1, new HashSet<String>());\\n            strings.add(key);\\n            tmap.put(cur - 1, strings);\\n        }\\n        // remove key from previous bucket (if applicable)\\n        removeFromTreeMap(cur, key);\\n    }\\n    \\n    private void removeFromTreeMap(Integer count, String key) {\\n        if (tmap.get(count).size() == 1) {\\n            tmap.remove(count);\\n        } else {\\n            tmap.get(count).remove(key);\\n        }\\n    }\\n    \\n    public String getMaxKey() {\\n        Map.Entry<Integer, Set<String>> entry = tmap.lastEntry();\\n        if (entry != null) {\\n            for (String ans: entry.getValue()) {\\n                return ans;\\n            }\\n        }\\n        return \"\";\\n    }\\n    \\n    public String getMinKey() {\\n        Map.Entry<Integer, Set<String>> entry = tmap.firstEntry();\\n        if (entry != null) {\\n            for (String ans: entry.getValue()) {\\n                return ans;\\n            }\\n        }\\n        return \"\";\\n    }\\n}\\n\\n/**\\n * Your AllOne object will be instantiated and called as such:\\n * AllOne obj = new AllOne();\\n * obj.inc(key);\\n * obj.dec(key);\\n * String param_3 = obj.getMaxKey();\\n * String param_4 = obj.getMinKey();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1961239,
                "title": "python-double-dictionary-set",
                "content": "```\\nclass AllOne:\\n\\n    \\n    def __init__(self):\\n        self.Dict = defaultdict(str)\\n        self.DictCount = defaultdict(list)\\n        self.table = set()\\n    \\n    def inc(self, key: str) -> None:\\n        if key in self.table:\\n           \\n            self.DictCount[self.Dict[key]].remove(key)\\n            if self.DictCount[self.Dict[key]] == []:\\n                self.DictCount.pop(self.Dict[key],None)\\n            self.Dict[key] += 1\\n            self.DictCount[self.Dict[key]].append(key)\\n          \\n        else:\\n            self.Dict[key] = 1\\n            self.table.add(key)\\n            self.DictCount[self.Dict[key]].append(key)\\n        \\n\\n    def dec(self, key: str) -> None:\\n        self.DictCount[self.Dict[key]].remove(key)\\n        if self.DictCount[self.Dict[key]] == []:\\n            self.DictCount.pop(self.Dict[key],None)\\n        self.Dict[key] -= 1\\n        if self.Dict[key]==0:\\n            self.Dict.pop(key, None)\\n            self.table.remove(key)\\n            \\n        else:\\n            self.DictCount[self.Dict[key]].append(key)\\n     \\n\\n    def getMaxKey(self) -> str:     \\n        if self.Dict == {}:\\n            return \"\"    \\n        return list(self.DictCount[max(list(self.DictCount.keys()))])[0]\\n\\n    def getMinKey(self) -> str:\\n        if self.Dict  == {}:\\n            return \"\"   \\n        return list(self.DictCount[min(list(self.DictCount.keys()))])[0]\\n\\n\\n# Your AllOne object will be instantiated and called as such:\\n# obj = AllOne()\\n# obj.inc(key)\\n# obj.dec(key)\\n# param_3 = obj.getMaxKey()\\n# param_4 = obj.getMinKey()",
                "solutionTags": [],
                "code": "```\\nclass AllOne:\\n\\n    \\n    def __init__(self):\\n        self.Dict = defaultdict(str)\\n        self.DictCount = defaultdict(list)\\n        self.table = set()\\n    \\n    def inc(self, key: str) -> None:\\n        if key in self.table:\\n           \\n            self.DictCount[self.Dict[key]].remove(key)\\n            if self.DictCount[self.Dict[key]] == []:\\n                self.DictCount.pop(self.Dict[key],None)\\n            self.Dict[key] += 1\\n            self.DictCount[self.Dict[key]].append(key)\\n          \\n        else:\\n            self.Dict[key] = 1\\n            self.table.add(key)\\n            self.DictCount[self.Dict[key]].append(key)\\n        \\n\\n    def dec(self, key: str) -> None:\\n        self.DictCount[self.Dict[key]].remove(key)\\n        if self.DictCount[self.Dict[key]] == []:\\n            self.DictCount.pop(self.Dict[key],None)\\n        self.Dict[key] -= 1\\n        if self.Dict[key]==0:\\n            self.Dict.pop(key, None)\\n            self.table.remove(key)\\n            \\n        else:\\n            self.DictCount[self.Dict[key]].append(key)\\n     \\n\\n    def getMaxKey(self) -> str:     \\n        if self.Dict == {}:\\n            return \"\"    \\n        return list(self.DictCount[max(list(self.DictCount.keys()))])[0]\\n\\n    def getMinKey(self) -> str:\\n        if self.Dict  == {}:\\n            return \"\"   \\n        return list(self.DictCount[min(list(self.DictCount.keys()))])[0]\\n\\n\\n# Your AllOne object will be instantiated and called as such:\\n# obj = AllOne()\\n# obj.inc(key)\\n# obj.dec(key)\\n# param_3 = obj.getMaxKey()\\n# param_4 = obj.getMinKey()",
                "codeTag": "Java"
            },
            {
                "id": 1934012,
                "title": "python-double-linked-list-neat-o-1",
                "content": "Fast and neat implementation in python\\n\\n```\\nfrom collections import namedtuple\\n\\nCountedSet = namedtuple(\"CountedSet\", \"set_, count\")\\n\\n\\nclass Node:\\n    def __init__(self, val, next, prev):\\n        self.val = val\\n        self.next = next\\n        self.prev = prev\\n\\n\\ndef _remove_node(node):\\n    prev, next = node.prev, node.next\\n    prev.next = next\\n    next.prev = prev\\n    node.prev, node.next = None, None\\n\\n\\ndef _create_node_next(node, val):\\n    next_node = Node(val, node.next, node)\\n    node.next.prev = next_node\\n    node.next = next_node\\n    return next_node\\n\\n\\nclass AllOne:\\n\\n    def __init__(self):\\n        self.head = Node(CountedSet(None, 0), None, None)\\n        self.head.next = self.head\\n        self.head.prev = self.head\\n\\n        self.key_node = {}\\n\\n    def inc(self, key: str) -> None:\\n        node = self.key_node.pop(key, None)\\n        if node is None:  # New key\\n            node = self.head\\n        current_count = node.val.count\\n        next_count = node.next.val.count\\n        if current_count + 1 != next_count:  # Need to create node for next count\\n            _create_node_next(node, CountedSet(set(), current_count + 1))\\n\\n        node.next.val.set_.add(key)\\n        self.key_node[key] = node.next\\n\\n        if current_count:  # key already exists\\n            node.val.set_.remove(key)\\n            if not node.val.set_:\\n                _remove_node(node)\\n\\n    def dec(self, key: str) -> None:\\n        node = self.key_node.pop(key)\\n        node.val.set_.remove(key)\\n        current_count = node.val.count\\n        prev_count = node.prev.val.count\\n\\n        if prev_count != current_count - 1:\\n            node = _create_node_next(node.prev, CountedSet(set(), current_count - 1)).next\\n        if node.prev.val.set_ is not None:\\n            node.prev.val.set_.add(key)\\n            self.key_node[key] = node.prev\\n\\n        if current_count and not node.val.set_:\\n            _remove_node(node)\\n\\n    def getMaxKey(self) -> str:\\n        return next(iter(self.head.prev.val.set_ or [\"\"]))\\n\\n    def getMinKey(self) -> str:\\n        return next(iter(self.head.next.val.set_ or [\"\"]))\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Doubly-Linked List"
                ],
                "code": "```\\nfrom collections import namedtuple\\n\\nCountedSet = namedtuple(\"CountedSet\", \"set_, count\")\\n\\n\\nclass Node:\\n    def __init__(self, val, next, prev):\\n        self.val = val\\n        self.next = next\\n        self.prev = prev\\n\\n\\ndef _remove_node(node):\\n    prev, next = node.prev, node.next\\n    prev.next = next\\n    next.prev = prev\\n    node.prev, node.next = None, None\\n\\n\\ndef _create_node_next(node, val):\\n    next_node = Node(val, node.next, node)\\n    node.next.prev = next_node\\n    node.next = next_node\\n    return next_node\\n\\n\\nclass AllOne:\\n\\n    def __init__(self):\\n        self.head = Node(CountedSet(None, 0), None, None)\\n        self.head.next = self.head\\n        self.head.prev = self.head\\n\\n        self.key_node = {}\\n\\n    def inc(self, key: str) -> None:\\n        node = self.key_node.pop(key, None)\\n        if node is None:  # New key\\n            node = self.head\\n        current_count = node.val.count\\n        next_count = node.next.val.count\\n        if current_count + 1 != next_count:  # Need to create node for next count\\n            _create_node_next(node, CountedSet(set(), current_count + 1))\\n\\n        node.next.val.set_.add(key)\\n        self.key_node[key] = node.next\\n\\n        if current_count:  # key already exists\\n            node.val.set_.remove(key)\\n            if not node.val.set_:\\n                _remove_node(node)\\n\\n    def dec(self, key: str) -> None:\\n        node = self.key_node.pop(key)\\n        node.val.set_.remove(key)\\n        current_count = node.val.count\\n        prev_count = node.prev.val.count\\n\\n        if prev_count != current_count - 1:\\n            node = _create_node_next(node.prev, CountedSet(set(), current_count - 1)).next\\n        if node.prev.val.set_ is not None:\\n            node.prev.val.set_.add(key)\\n            self.key_node[key] = node.prev\\n\\n        if current_count and not node.val.set_:\\n            _remove_node(node)\\n\\n    def getMaxKey(self) -> str:\\n        return next(iter(self.head.prev.val.set_ or [\"\"]))\\n\\n    def getMinKey(self) -> str:\\n        return next(iter(self.head.next.val.set_ or [\"\"]))\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1884505,
                "title": "simple-o-1-python-solution",
                "content": "```\\nclass Node:\\n    def __init__(self, string, val, prev=None,\\n                 next_ = None):\\n        self.string = string\\n        self.val = val\\n        self.prev = prev\\n        self.next_ = next_\\n        if prev is not None:\\n            prev.next_ = self\\n        if next_ is not None:\\n            next_.prev = self\\n\\n    def inc(self):\\n        self.val += 1\\n        while self.val > self.next_.val:\\n            og_next = self.next_\\n            self.prev.next_ = og_next\\n            og_next.prev = self.prev\\n            self.next_ = og_next.next_\\n            self.prev = og_next\\n            og_next.next_.prev = self\\n            og_next.next_ = self\\n    \\n    def dec(self):\\n        self.val -= 1\\n        while self.val < self.prev.val:\\n            og_prev = self.prev\\n            self.next_.prev = og_prev\\n            og_prev.next_ = self.next_\\n            self.prev = og_prev.prev\\n            self.next_ = og_prev\\n            og_prev.prev.next_ = self\\n            og_prev.prev = self\\n\\n    def pop(self):\\n        self.next_.prev = self.prev\\n        self.prev.next_ = self.next_\\n\\nclass AllOne:\\n\\n    def __init__(self):\\n        self._map = {}\\n        self._head = Node(\"__head\", -sys.maxsize)\\n        self._tail = Node(\"__tail\", sys.maxsize)\\n        self._head.next_ = self._tail\\n        self._tail.prev = self._head\\n\\n    def inc(self, key: str) -> None:\\n        if key not in self._map:\\n            node = Node(key, 1, prev=self._head,\\n                        next_=self._head.next_)\\n            self._map[key] = node\\n        else:\\n            node = self._map[key]\\n            node.inc()\\n        \\n    def dec(self, key: str) -> None:\\n        if key not in self._map:\\n            raise ValueError(f\"key {key} not in map.\")\\n        else:\\n            node = self._map[key]\\n            node.dec()\\n            if node.val == 0:\\n                node.pop()\\n                del self._map[key]\\n\\n    def getMaxKey(self) -> str:\\n        if self._tail.prev == self._head:\\n            return \"\"\\n        return self._tail.prev.string\\n\\n    def getMinKey(self) -> str:\\n        if self._head.next_ == self._tail:\\n            return \"\"\\n        return self._head.next_.string\\n```",
                "solutionTags": [],
                "code": "```\\nclass Node:\\n    def __init__(self, string, val, prev=None,\\n                 next_ = None):\\n        self.string = string\\n        self.val = val\\n        self.prev = prev\\n        self.next_ = next_\\n        if prev is not None:\\n            prev.next_ = self\\n        if next_ is not None:\\n            next_.prev = self\\n\\n    def inc(self):\\n        self.val += 1\\n        while self.val > self.next_.val:\\n            og_next = self.next_\\n            self.prev.next_ = og_next\\n            og_next.prev = self.prev\\n            self.next_ = og_next.next_\\n            self.prev = og_next\\n            og_next.next_.prev = self\\n            og_next.next_ = self\\n    \\n    def dec(self):\\n        self.val -= 1\\n        while self.val < self.prev.val:\\n            og_prev = self.prev\\n            self.next_.prev = og_prev\\n            og_prev.next_ = self.next_\\n            self.prev = og_prev.prev\\n            self.next_ = og_prev\\n            og_prev.prev.next_ = self\\n            og_prev.prev = self\\n\\n    def pop(self):\\n        self.next_.prev = self.prev\\n        self.prev.next_ = self.next_\\n\\nclass AllOne:\\n\\n    def __init__(self):\\n        self._map = {}\\n        self._head = Node(\"__head\", -sys.maxsize)\\n        self._tail = Node(\"__tail\", sys.maxsize)\\n        self._head.next_ = self._tail\\n        self._tail.prev = self._head\\n\\n    def inc(self, key: str) -> None:\\n        if key not in self._map:\\n            node = Node(key, 1, prev=self._head,\\n                        next_=self._head.next_)\\n            self._map[key] = node\\n        else:\\n            node = self._map[key]\\n            node.inc()\\n        \\n    def dec(self, key: str) -> None:\\n        if key not in self._map:\\n            raise ValueError(f\"key {key} not in map.\")\\n        else:\\n            node = self._map[key]\\n            node.dec()\\n            if node.val == 0:\\n                node.pop()\\n                del self._map[key]\\n\\n    def getMaxKey(self) -> str:\\n        if self._tail.prev == self._head:\\n            return \"\"\\n        return self._tail.prev.string\\n\\n    def getMinKey(self) -> str:\\n        if self._head.next_ == self._tail:\\n            return \"\"\\n        return self._head.next_.string\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1871141,
                "title": "python-simplest-possible",
                "content": "```\\nfrom sortedcontainers import SortedList\\n\\nclass AllOne:\\n\\n    def __init__(self):\\n        self.key_freq = defaultdict(int)        \\n        self.list = SortedList()\\n\\n    def inc(self, key: str) -> None:\\n        count = self.key_freq[key]\\n        if count > 0: self.list.remove((count, key))\\n        self.key_freq[key] += 1\\n        count = self.key_freq[key]\\n        self.list.add((count, key))\\n\\n    def dec(self, key: str) -> None:\\n        count = self.key_freq[key]        \\n        if count > 0: self.list.remove((count, key))\\n        else: return\\n            \\n        self.key_freq[key] -= 1\\n        count = self.key_freq[key]  \\n        if count > 0: self.list.add((count, key))        \\n                                                        \\n    def getMaxKey(self) -> str:\\n        if not self.list: return \\'\\'\\n        return self.list[-1][1]\\n        \\n    def getMinKey(self) -> str:\\n        if not self.list: return \\'\\'\\n        return self.list[0][1]\\n```",
                "solutionTags": [],
                "code": "```\\nfrom sortedcontainers import SortedList\\n\\nclass AllOne:\\n\\n    def __init__(self):\\n        self.key_freq = defaultdict(int)        \\n        self.list = SortedList()\\n\\n    def inc(self, key: str) -> None:\\n        count = self.key_freq[key]\\n        if count > 0: self.list.remove((count, key))\\n        self.key_freq[key] += 1\\n        count = self.key_freq[key]\\n        self.list.add((count, key))\\n\\n    def dec(self, key: str) -> None:\\n        count = self.key_freq[key]        \\n        if count > 0: self.list.remove((count, key))\\n        else: return\\n            \\n        self.key_freq[key] -= 1\\n        count = self.key_freq[key]  \\n        if count > 0: self.list.add((count, key))        \\n                                                        \\n    def getMaxKey(self) -> str:\\n        if not self.list: return \\'\\'\\n        return self.list[-1][1]\\n        \\n    def getMinKey(self) -> str:\\n        if not self.list: return \\'\\'\\n        return self.list[0][1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1862346,
                "title": "c-explained-hashmap-well-commented",
                "content": "!!!!Please like and upvote if youy find useful................!!!!!\\n\\nWe have Design a data structure such that we easily  `find max and min occurence of string `\\nSo,I have to `use map  for counting frequency and set for updating max and min of the element.`\\n\\n`Logic:`\\n1. Every time when we encounter a new element w`e create a place in map and also insert in the set.`\\n\\n2. When we the `element already found in map` then `we delete from set and increse the map value and then reinsert the same element in set` with` new increment value this help to update the new count in set.`\\n\\n3. `Same thing can be done` with the `remove function `But one t`hing take care that when map elemt count is zero then we delete from map and aldo delete from set .`\\n\\n4. Now in `get max and get min function `we directly extract data` on O(logn) time `.\\n\\n\\n\\n```\\nclass AllOne {\\npublic:\\n    //Map for updating frequncy of element\\n     unordered_map<string,int>mp;\\n\\t //Set for keep track of max and min element\\n    set<pair<int,string>>s;\\n    \\n    AllOne() {\\n        \\n    }\\n    //In  this function Refer point 2\\n    void inc(string key) {\\n        //If element not found add it to the map and also insert to the set with increment value\\n        if(mp.find(key)==mp.end())\\n        {\\n            mp[key]++;     \\n        }\\n\\t\\t//If elemt already present to the map we first delete  from the set and update map and resinsert the same \\n        else\\n        {\\n\\t\\t//Erasing already present elemt\\n            s.erase({mp[key],key});\\n\\t\\t\\t//increse value\\n            mp[key]++;\\n     \\n        }\\n          s.insert({mp[key],key});\\n        \\n    }\\n    //Refer point->3\\n    void dec(string key) {\\n\\t//Erase the existing elemt in set as we have to delete\\n        s.erase({mp[key],key});\\n\\t\\t//Decrease the map elemt\\n        mp[key]--;\\n\\t\\t//Reinsert the set with updated value\\n        s.insert({mp[key],key});\\n\\t\\t//If elemet is  empty in map we delete the elemt from map and also from set\\n        if(mp[key]==0)\\n        {\\n            mp.erase(key);\\n            s.erase({mp[key],key});\\n        }\\n        \\n    \\n        \\n    }\\n    //Refer point 4\\n    string getMaxKey() {\\n        if(s.size()==0)\\n        {\\n            return \"\";\\n        }\\n        \\n        auto it=s.rbegin();\\n        return it->second;\\n        \\n    }\\n    \\n    string getMinKey() {\\n        if(s.size()==0){\\n            return \"\";\\n        }\\n        \\n        auto it=s.begin();\\n        return it->second;\\n        \\n    }\\n};\\n\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass AllOne {\\npublic:\\n    //Map for updating frequncy of element\\n     unordered_map<string,int>mp;\\n\\t //Set for keep track of max and min element\\n    set<pair<int,string>>s;\\n    \\n    AllOne() {\\n        \\n    }\\n    //In  this function Refer point 2\\n    void inc(string key) {\\n        //If element not found add it to the map and also insert to the set with increment value\\n        if(mp.find(key)==mp.end())\\n        {\\n            mp[key]++;     \\n        }\\n\\t\\t//If elemt already present to the map we first delete  from the set and update map and resinsert the same \\n        else\\n        {\\n\\t\\t//Erasing already present elemt\\n            s.erase({mp[key],key});\\n\\t\\t\\t//increse value\\n            mp[key]++;\\n     \\n        }\\n          s.insert({mp[key],key});\\n        \\n    }\\n    //Refer point->3\\n    void dec(string key) {\\n\\t//Erase the existing elemt in set as we have to delete\\n        s.erase({mp[key],key});\\n\\t\\t//Decrease the map elemt\\n        mp[key]--;\\n\\t\\t//Reinsert the set with updated value\\n        s.insert({mp[key],key});\\n\\t\\t//If elemet is  empty in map we delete the elemt from map and also from set\\n        if(mp[key]==0)\\n        {\\n            mp.erase(key);\\n            s.erase({mp[key],key});\\n        }\\n        \\n    \\n        \\n    }\\n    //Refer point 4\\n    string getMaxKey() {\\n        if(s.size()==0)\\n        {\\n            return \"\";\\n        }\\n        \\n        auto it=s.rbegin();\\n        return it->second;\\n        \\n    }\\n    \\n    string getMinKey() {\\n        if(s.size()==0){\\n            return \"\";\\n        }\\n        \\n        auto it=s.begin();\\n        return it->second;\\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1841767,
                "title": "java-hashmap-doublelinkedlist-all-o-1",
                "content": "```\\nclass AllOne {\\n    HashMap<String, Node> map = new HashMap<>();\\n    DoubleLinkedList list = new DoubleLinkedList();\\n\\n    public AllOne() {\\n        \\n    }\\n    \\n    public void inc(String key) {\\n        if(!map.containsKey(key)) { // new count = 1\\n            Node min = list.getMin();\\n            if(min!= null && min.count == 1) {\\n                min.strings.add(key);\\n                map.put(key, min);\\n            } else { // min count > 1, create new node\\n                Node n = new Node(1);\\n                n.strings.add(key);\\n                list.addNodeAfter(n, list.head);\\n                map.put(key, n);\\n            }  \\n        } else {\\n            Node n = map.get(key);\\n            int count = n.count + 1;\\n            if(n.next != list.tail && n.next.count == count) {// if new count node exists\\n                n.next.strings.add(key);\\n                map.put(key, n.next);\\n            } else { // create new node\\n                Node node = new Node(count);\\n                node.strings.add(key);\\n                list.addNodeAfter(node, n);\\n                map.put(key, node);\\n            }\\n            n.strings.remove(key); // remove the string from the node\\n            if(n.strings.isEmpty()) {\\n                list.deleteNode(n);\\n            }\\n        }\\n        // System.out.println(list.toString());\\n    }\\n    \\n    public void dec(String key) {\\n        Node n = map.get(key);\\n        int count = n.count - 1;\\n        \\n        if(count == 0) { // delete from map\\n            map.remove(key);\\n        } else {\\n            if(n.prev != list.head && n.prev.count == count) {// if new count node exists\\n                n.prev.strings.add(key);\\n                map.put(key, n.prev);\\n            } else { // create new node\\n                Node node = new Node(count);\\n                node.strings.add(key);\\n                list.addNodeBefore(node, n);\\n                map.put(key, node);\\n            }\\n        }\\n        n.strings.remove(key); // remove the string from the node\\n        if(n.strings.isEmpty()) {\\n            list.deleteNode(n);\\n        }\\n        // System.out.println(list.toString());\\n    }\\n    \\n    public String getMaxKey() {\\n        Node max = list.getMax();\\n        if(max!= null) return max.strings.get(0);\\n        return \"\";\\n    }\\n    \\n    public String getMinKey() {\\n        Node min = list.getMin();\\n        if(min!= null) return min.strings.get(0);\\n        return \"\";\\n    }\\n}\\n\\nclass DoubleLinkedList {\\n    Node head;\\n    Node tail;\\n    DoubleLinkedList() {\\n        head = new Node(-1);\\n        tail = new Node(-1);\\n        head.next = tail;\\n        tail.prev = head;\\n    }\\n    \\n    Node getMin() {\\n        if(head.next != tail) {\\n            return head.next;\\n        } else {\\n            return null;\\n        }\\n    }\\n    \\n    Node getMax() {\\n        if(tail.prev != head) {\\n            return tail.prev;\\n        } else {\\n            return null;\\n        }\\n    }\\n    \\n    void addNodeAfter(Node n, Node curNode) {\\n        n.prev = curNode;\\n        n.next = curNode.next;\\n        curNode.next.prev = n;\\n        curNode.next = n;\\n    }\\n    \\n    void addNodeBefore(Node n, Node curNode) {\\n        n.prev = curNode.prev;\\n        n.next = curNode;\\n        curNode.prev.next = n;\\n        curNode.prev = n;\\n    }\\n    \\n    void deleteNode(Node n) {\\n        n.prev.next = n.next;\\n        n.next.prev = n.prev;\\n    }\\n    \\n    @Override\\n    public String toString() {\\n        Node n = head;\\n        StringBuilder sb = new StringBuilder();\\n        while(n!=null) {\\n            sb.append(n.toString());\\n            if(n!=tail)\\n                sb.append(\" -> \");\\n            n = n.next;\\n        }\\n        return sb.toString();\\n    }\\n}\\n\\nclass Node {\\n    int count;\\n    List<String> strings = new ArrayList<>();\\n    Node prev=null;\\n    Node next=null;\\n    \\n    public Node(int count) {\\n        this.count = count;\\n    }\\n    \\n    @Override\\n    public String toString() {\\n        return \"{count:\" + count + \" strings:\" + strings + \"}\";\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass AllOne {\\n    HashMap<String, Node> map = new HashMap<>();\\n    DoubleLinkedList list = new DoubleLinkedList();\\n\\n    public AllOne() {\\n        \\n    }\\n    \\n    public void inc(String key) {\\n        if(!map.containsKey(key)) { // new count = 1\\n            Node min = list.getMin();\\n            if(min!= null && min.count == 1) {\\n                min.strings.add(key);\\n                map.put(key, min);\\n            } else { // min count > 1, create new node\\n                Node n = new Node(1);\\n                n.strings.add(key);\\n                list.addNodeAfter(n, list.head);\\n                map.put(key, n);\\n            }  \\n        } else {\\n            Node n = map.get(key);\\n            int count = n.count + 1;\\n            if(n.next != list.tail && n.next.count == count) {// if new count node exists\\n                n.next.strings.add(key);\\n                map.put(key, n.next);\\n            } else { // create new node\\n                Node node = new Node(count);\\n                node.strings.add(key);\\n                list.addNodeAfter(node, n);\\n                map.put(key, node);\\n            }\\n            n.strings.remove(key); // remove the string from the node\\n            if(n.strings.isEmpty()) {\\n                list.deleteNode(n);\\n            }\\n        }\\n        // System.out.println(list.toString());\\n    }\\n    \\n    public void dec(String key) {\\n        Node n = map.get(key);\\n        int count = n.count - 1;\\n        \\n        if(count == 0) { // delete from map\\n            map.remove(key);\\n        } else {\\n            if(n.prev != list.head && n.prev.count == count) {// if new count node exists\\n                n.prev.strings.add(key);\\n                map.put(key, n.prev);\\n            } else { // create new node\\n                Node node = new Node(count);\\n                node.strings.add(key);\\n                list.addNodeBefore(node, n);\\n                map.put(key, node);\\n            }\\n        }\\n        n.strings.remove(key); // remove the string from the node\\n        if(n.strings.isEmpty()) {\\n            list.deleteNode(n);\\n        }\\n        // System.out.println(list.toString());\\n    }\\n    \\n    public String getMaxKey() {\\n        Node max = list.getMax();\\n        if(max!= null) return max.strings.get(0);\\n        return \"\";\\n    }\\n    \\n    public String getMinKey() {\\n        Node min = list.getMin();\\n        if(min!= null) return min.strings.get(0);\\n        return \"\";\\n    }\\n}\\n\\nclass DoubleLinkedList {\\n    Node head;\\n    Node tail;\\n    DoubleLinkedList() {\\n        head = new Node(-1);\\n        tail = new Node(-1);\\n        head.next = tail;\\n        tail.prev = head;\\n    }\\n    \\n    Node getMin() {\\n        if(head.next != tail) {\\n            return head.next;\\n        } else {\\n            return null;\\n        }\\n    }\\n    \\n    Node getMax() {\\n        if(tail.prev != head) {\\n            return tail.prev;\\n        } else {\\n            return null;\\n        }\\n    }\\n    \\n    void addNodeAfter(Node n, Node curNode) {\\n        n.prev = curNode;\\n        n.next = curNode.next;\\n        curNode.next.prev = n;\\n        curNode.next = n;\\n    }\\n    \\n    void addNodeBefore(Node n, Node curNode) {\\n        n.prev = curNode.prev;\\n        n.next = curNode;\\n        curNode.prev.next = n;\\n        curNode.prev = n;\\n    }\\n    \\n    void deleteNode(Node n) {\\n        n.prev.next = n.next;\\n        n.next.prev = n.prev;\\n    }\\n    \\n    @Override\\n    public String toString() {\\n        Node n = head;\\n        StringBuilder sb = new StringBuilder();\\n        while(n!=null) {\\n            sb.append(n.toString());\\n            if(n!=tail)\\n                sb.append(\" -> \");\\n            n = n.next;\\n        }\\n        return sb.toString();\\n    }\\n}\\n\\nclass Node {\\n    int count;\\n    List<String> strings = new ArrayList<>();\\n    Node prev=null;\\n    Node next=null;\\n    \\n    public Node(int count) {\\n        this.count = count;\\n    }\\n    \\n    @Override\\n    public String toString() {\\n        return \"{count:\" + count + \" strings:\" + strings + \"}\";\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1828607,
                "title": "simple-c-solution-using-sets-and-map",
                "content": "```\\nclass AllOne {\\npublic:\\n    \\n    unordered_map<string, int> keyCountMap;\\n    set<pair<int, string>> countKeySet;\\n    \\n    AllOne() {\\n        keyCountMap.clear();\\n        countKeySet.clear();\\n    }\\n    \\n    void inc(string key) {\\n        int val = keyCountMap[key];\\n        countKeySet.erase({val, key});\\n        countKeySet.insert({val+1, key});\\n        keyCountMap[key]+=1;\\n    }\\n    \\n    void dec(string key) {\\n        int val = keyCountMap[key];\\n        countKeySet.erase({val, key});\\n        if(val - 1 > 0) {\\n            countKeySet.insert({val - 1, key});\\n            keyCountMap[key] -= 1;\\n        } else {\\n            keyCountMap.erase(key);\\n        }\\n    }\\n    \\n    string getMaxKey() {\\n        if(countKeySet.size() == 0) return \"\";\\n        return countKeySet.rbegin()->second;\\n    }\\n    \\n    string getMinKey() {\\n        if(countKeySet.size() == 0) return \"\";\\n        return countKeySet.begin()->second;\\n    }\\n};\\n```\\n\\nIn case there are any questions, comment them and I will try to answer.\\n",
                "solutionTags": [],
                "code": "```\\nclass AllOne {\\npublic:\\n    \\n    unordered_map<string, int> keyCountMap;\\n    set<pair<int, string>> countKeySet;\\n    \\n    AllOne() {\\n        keyCountMap.clear();\\n        countKeySet.clear();\\n    }\\n    \\n    void inc(string key) {\\n        int val = keyCountMap[key];\\n        countKeySet.erase({val, key});\\n        countKeySet.insert({val+1, key});\\n        keyCountMap[key]+=1;\\n    }\\n    \\n    void dec(string key) {\\n        int val = keyCountMap[key];\\n        countKeySet.erase({val, key});\\n        if(val - 1 > 0) {\\n            countKeySet.insert({val - 1, key});\\n            keyCountMap[key] -= 1;\\n        } else {\\n            keyCountMap.erase(key);\\n        }\\n    }\\n    \\n    string getMaxKey() {\\n        if(countKeySet.size() == 0) return \"\";\\n        return countKeySet.rbegin()->second;\\n    }\\n    \\n    string getMinKey() {\\n        if(countKeySet.size() == 0) return \"\";\\n        return countKeySet.begin()->second;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1774491,
                "title": "swift-all-strict-o-1",
                "content": "```\\n\\nclass AllOne {\\n    class Node {\\n        var prev: Node?\\n        var next: Node? \\n        let count: Int\\n        var words: Set<String> = []\\n        \\n        init(_ count: Int) {\\n            self.count = count\\n        }\\n    }\\n    var dict: [String: Node] = [:]\\n    var head: Node\\n    var tail: Node\\n    var firstNode: Node\\n    init() {\\n        head = Node(Int.min)\\n        tail = Node(Int.max)\\n        firstNode = Node(1)\\n        head.next = firstNode\\n        firstNode.prev = head\\n        firstNode.next = tail\\n        tail.prev = firstNode\\n    }\\n    \\n    func remove(node: Node) {\\n        let prev = node.prev\\n        let next = node.next\\n        prev?.next = next\\n        next?.prev = prev\\n    }\\n    \\n    func append(newNode: Node, after node: Node) {\\n        newNode.next = node.next\\n        node.next?.prev = newNode\\n        node.next = newNode \\n        newNode.prev = node\\n    }\\n    \\n    func append(newNode: Node, before node: Node) {\\n        newNode.next = node\\n        newNode.prev = node.prev\\n        node.prev?.next = newNode\\n        node.prev = newNode\\n    }\\n    \\n    func inc(_ key: String) {\\n        if let node = dict[key] {\\n            node.words.remove(key)\\n            if let next = node.next, next.count == node.count + 1 {\\n                next.words.insert(key)\\n                dict[key] = next\\n            } else {\\n                let newNode = Node(node.count + 1)\\n                newNode.words.insert(key)\\n                append(newNode: newNode, after: node)\\n                dict[key] = newNode\\n            }\\n            if node.count != 1 && node.words.isEmpty {\\n                remove(node: node)\\n            }\\n        } else {\\n            firstNode.words.insert(key)\\n            dict[key] = firstNode\\n        }\\n    }\\n    \\n    func dec(_ key: String) {\\n        if let node = dict[key] {\\n            node.words.remove(key)\\n            dict[key] = nil\\n            if node.count != 1 {\\n                if let prev = node.prev, prev.count == node.count - 1 {\\n                    prev.words.insert(key)\\n                    dict[key] = prev\\n                } else {\\n                    let newNode = Node(node.count - 1)\\n                    newNode.words.insert(key)\\n                    append(newNode: newNode, before: node)\\n                    dict[key] = newNode\\n                }\\n                if node.words.isEmpty {\\n                    remove(node: node)\\n                }\\n            }\\n        }\\n    }\\n    \\n    func getMaxKey() -> String {\\n        return tail.prev?.words.first ?? \"\"\\n    }\\n    \\n    func getMinKey() -> String {\\n        return firstNode.words.first ?? firstNode.next?.words.first ?? \"\"\\n    }\\n}\\n\\n/**\\n * Your AllOne object will be instantiated and called as such:\\n * let obj = AllOne()\\n * obj.inc(key)\\n * obj.dec(key)\\n * let ret_3: String = obj.getMaxKey()\\n * let ret_4: String = obj.getMinKey()\\n */\\n```",
                "solutionTags": [
                    "Swift",
                    "Linked List"
                ],
                "code": "```\\n\\nclass AllOne {\\n    class Node {\\n        var prev: Node?\\n        var next: Node? \\n        let count: Int\\n        var words: Set<String> = []\\n        \\n        init(_ count: Int) {\\n            self.count = count\\n        }\\n    }\\n    var dict: [String: Node] = [:]\\n    var head: Node\\n    var tail: Node\\n    var firstNode: Node\\n    init() {\\n        head = Node(Int.min)\\n        tail = Node(Int.max)\\n        firstNode = Node(1)\\n        head.next = firstNode\\n        firstNode.prev = head\\n        firstNode.next = tail\\n        tail.prev = firstNode\\n    }\\n    \\n    func remove(node: Node) {\\n        let prev = node.prev\\n        let next = node.next\\n        prev?.next = next\\n        next?.prev = prev\\n    }\\n    \\n    func append(newNode: Node, after node: Node) {\\n        newNode.next = node.next\\n        node.next?.prev = newNode\\n        node.next = newNode \\n        newNode.prev = node\\n    }\\n    \\n    func append(newNode: Node, before node: Node) {\\n        newNode.next = node\\n        newNode.prev = node.prev\\n        node.prev?.next = newNode\\n        node.prev = newNode\\n    }\\n    \\n    func inc(_ key: String) {\\n        if let node = dict[key] {\\n            node.words.remove(key)\\n            if let next = node.next, next.count == node.count + 1 {\\n                next.words.insert(key)\\n                dict[key] = next\\n            } else {\\n                let newNode = Node(node.count + 1)\\n                newNode.words.insert(key)\\n                append(newNode: newNode, after: node)\\n                dict[key] = newNode\\n            }\\n            if node.count != 1 && node.words.isEmpty {\\n                remove(node: node)\\n            }\\n        } else {\\n            firstNode.words.insert(key)\\n            dict[key] = firstNode\\n        }\\n    }\\n    \\n    func dec(_ key: String) {\\n        if let node = dict[key] {\\n            node.words.remove(key)\\n            dict[key] = nil\\n            if node.count != 1 {\\n                if let prev = node.prev, prev.count == node.count - 1 {\\n                    prev.words.insert(key)\\n                    dict[key] = prev\\n                } else {\\n                    let newNode = Node(node.count - 1)\\n                    newNode.words.insert(key)\\n                    append(newNode: newNode, before: node)\\n                    dict[key] = newNode\\n                }\\n                if node.words.isEmpty {\\n                    remove(node: node)\\n                }\\n            }\\n        }\\n    }\\n    \\n    func getMaxKey() -> String {\\n        return tail.prev?.words.first ?? \"\"\\n    }\\n    \\n    func getMinKey() -> String {\\n        return firstNode.words.first ?? firstNode.next?.words.first ?? \"\"\\n    }\\n}\\n\\n/**\\n * Your AllOne object will be instantiated and called as such:\\n * let obj = AllOne()\\n * obj.inc(key)\\n * obj.dec(key)\\n * let ret_3: String = obj.getMaxKey()\\n * let ret_4: String = obj.getMinKey()\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1757810,
                "title": "java-solution-with-treemap",
                "content": "```\\nclass AllOne {\\n    \\n\\t// countMap: key is key, value is the count of the key\\n    private Map<String, Integer> countMap;\\n\\t// freqMap: key is count, value is keys with same count\\n    private TreeMap<Integer, HashSet<String>> freqMap;\\n\\n    public AllOne() {\\n        countMap = new HashMap<>();\\n        freqMap = new TreeMap<>();\\n    }\\n    \\n    public void inc(String key) {\\n        int count = countMap.getOrDefault(key, 0);\\n        countMap.put(key, count + 1);\\n        if (count > 0) {\\n            freqMap.get(count).remove(key);\\n            if (freqMap.get(count).isEmpty()) {\\n                freqMap.remove(count);\\n            }\\n        }\\n        \\n        HashSet<String> set = freqMap.getOrDefault(count + 1, new HashSet<>());\\n        set.add(key);\\n        freqMap.put(count + 1, set);\\n    }\\n    \\n    public void dec(String key) {\\n        if (!countMap.containsKey(key)) {\\n            return;\\n        }\\n        \\n        int count = countMap.get(key);\\n        if (count == 1) {\\n            countMap.remove(key);\\n            freqMap.get(1).remove(key);\\n            if (freqMap.get(1).isEmpty()) {\\n                freqMap.remove(1);\\n            }\\n        } else {\\n            countMap.put(key, count - 1);\\n            freqMap.get(count).remove(key);\\n            if (freqMap.get(count).isEmpty()) {\\n                freqMap.remove(count);\\n            }\\n            \\n            HashSet<String> set = freqMap.getOrDefault(count - 1, new HashSet<>());\\n            set.add(key);\\n            freqMap.put(count - 1, set);\\n        }\\n    }\\n    \\n    public String getMaxKey() {\\n        if (freqMap.isEmpty()) {\\n            return \"\";\\n        }\\n        \\n        HashSet<String> maxSet = freqMap.lastEntry().getValue();\\n        return maxSet.iterator().next();\\n    }\\n    \\n    public String getMinKey() {\\n        if (freqMap.isEmpty()) {\\n            return \"\";\\n        }\\n        \\n        HashSet<String> minSet = freqMap.firstEntry().getValue();\\n        return minSet.iterator().next();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass AllOne {\\n    \\n\\t// countMap: key is key, value is the count of the key\\n    private Map<String, Integer> countMap;\\n\\t// freqMap: key is count, value is keys with same count\\n    private TreeMap<Integer, HashSet<String>> freqMap;\\n\\n    public AllOne() {\\n        countMap = new HashMap<>();\\n        freqMap = new TreeMap<>();\\n    }\\n    \\n    public void inc(String key) {\\n        int count = countMap.getOrDefault(key, 0);\\n        countMap.put(key, count + 1);\\n        if (count > 0) {\\n            freqMap.get(count).remove(key);\\n            if (freqMap.get(count).isEmpty()) {\\n                freqMap.remove(count);\\n            }\\n        }\\n        \\n        HashSet<String> set = freqMap.getOrDefault(count + 1, new HashSet<>());\\n        set.add(key);\\n        freqMap.put(count + 1, set);\\n    }\\n    \\n    public void dec(String key) {\\n        if (!countMap.containsKey(key)) {\\n            return;\\n        }\\n        \\n        int count = countMap.get(key);\\n        if (count == 1) {\\n            countMap.remove(key);\\n            freqMap.get(1).remove(key);\\n            if (freqMap.get(1).isEmpty()) {\\n                freqMap.remove(1);\\n            }\\n        } else {\\n            countMap.put(key, count - 1);\\n            freqMap.get(count).remove(key);\\n            if (freqMap.get(count).isEmpty()) {\\n                freqMap.remove(count);\\n            }\\n            \\n            HashSet<String> set = freqMap.getOrDefault(count - 1, new HashSet<>());\\n            set.add(key);\\n            freqMap.put(count - 1, set);\\n        }\\n    }\\n    \\n    public String getMaxKey() {\\n        if (freqMap.isEmpty()) {\\n            return \"\";\\n        }\\n        \\n        HashSet<String> maxSet = freqMap.lastEntry().getValue();\\n        return maxSet.iterator().next();\\n    }\\n    \\n    public String getMinKey() {\\n        if (freqMap.isEmpty()) {\\n            return \"\";\\n        }\\n        \\n        HashSet<String> minSet = freqMap.firstEntry().getValue();\\n        return minSet.iterator().next();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1754773,
                "title": "python-o-log-n-solution-using-sorteddict-treemap-hashmap",
                "content": "* We use `SortedDict`  which a sorted HashMap, to store sets of keys with same value, we call these buckets. SortedDict is like TreeMap in java with time complexity O(logN).\\n`from sortedcontainers import SortedDict`\\n* For every `inc` / `dec` operation, you delete key from previous bucket and add to new.\\n* For every getMin() getMax() operation, you pick the min/max bucket index. Pick a random key and return\\n\\n\\n```\\nfrom sortedcontainers import SortedDict\\n\\nclass AllOne:\\n\\n    def __init__(self):\\n        self.keyMap = {}\\n        self.bucketMap = SortedDict()\\n        \\n    def removeFromBucket(self, bucketKey, key):\\n        if bucketKey not in self.bucketMap:\\n            return\\n        \\n        bucket = self.bucketMap[bucketKey]\\n        \\n        bucket.discard(key)\\n        \\n        # bucket empty\\n        if not bucket:\\n            del self.bucketMap[bucketKey]\\n            \\n    \\n    def addToBucket(self, bucketKey, key):\\n        if bucketKey not in self.bucketMap:\\n            self.bucketMap[bucketKey] = set()\\n        \\n        bucket = self.bucketMap[bucketKey]\\n        bucket.add(key)\\n        \\n    def inc(self, key: str) -> None:\\n        if key in self.keyMap:\\n            self.removeFromBucket(self.keyMap[key], key)\\n            self.keyMap[key] += 1\\n        else:\\n            self.keyMap[key] = 1\\n            \\n        self.addToBucket(self.keyMap[key], key)        \\n        \\n\\n    def dec(self, key: str) -> None:\\n        self.removeFromBucket(self.keyMap[key], key)\\n        \\n        if self.keyMap[key] == 1:\\n            del self.keyMap[key]\\n        else:\\n            self.keyMap[key] -= 1\\n            self.addToBucket(self.keyMap[key], key)\\n\\n    def getMaxKey(self) -> str:\\n        if not self.bucketMap:\\n            return \"\"\\n        \\n        size, setVal = self.bucketMap.peekitem()\\n        \\n        for x in setVal:\\n            return x\\n\\n    def getMinKey(self) -> str:\\n        if not self.bucketMap:\\n            return \"\"\\n        \\n        size, setVal = self.bucketMap.peekitem(0)\\n        \\n        for x in setVal:\\n            return x\\n```",
                "solutionTags": [],
                "code": "```\\nfrom sortedcontainers import SortedDict\\n\\nclass AllOne:\\n\\n    def __init__(self):\\n        self.keyMap = {}\\n        self.bucketMap = SortedDict()\\n        \\n    def removeFromBucket(self, bucketKey, key):\\n        if bucketKey not in self.bucketMap:\\n            return\\n        \\n        bucket = self.bucketMap[bucketKey]\\n        \\n        bucket.discard(key)\\n        \\n        # bucket empty\\n        if not bucket:\\n            del self.bucketMap[bucketKey]\\n            \\n    \\n    def addToBucket(self, bucketKey, key):\\n        if bucketKey not in self.bucketMap:\\n            self.bucketMap[bucketKey] = set()\\n        \\n        bucket = self.bucketMap[bucketKey]\\n        bucket.add(key)\\n        \\n    def inc(self, key: str) -> None:\\n        if key in self.keyMap:\\n            self.removeFromBucket(self.keyMap[key], key)\\n            self.keyMap[key] += 1\\n        else:\\n            self.keyMap[key] = 1\\n            \\n        self.addToBucket(self.keyMap[key], key)        \\n        \\n\\n    def dec(self, key: str) -> None:\\n        self.removeFromBucket(self.keyMap[key], key)\\n        \\n        if self.keyMap[key] == 1:\\n            del self.keyMap[key]\\n        else:\\n            self.keyMap[key] -= 1\\n            self.addToBucket(self.keyMap[key], key)\\n\\n    def getMaxKey(self) -> str:\\n        if not self.bucketMap:\\n            return \"\"\\n        \\n        size, setVal = self.bucketMap.peekitem()\\n        \\n        for x in setVal:\\n            return x\\n\\n    def getMinKey(self) -> str:\\n        if not self.bucketMap:\\n            return \"\"\\n        \\n        size, setVal = self.bucketMap.peekitem(0)\\n        \\n        for x in setVal:\\n            return x\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1737651,
                "title": "python-treemap-solution-logn-each",
                "content": "```\\n# 1 hashmap to track the number of counts for each key\\n# 1 treemap to track the max/min counts, {count: set of keys}\\n# when inc, update hashmap and treemap\\n# same procedure for dec\\n\\nfrom sortedcontainers import SortedDict\\nclass AllOne:\\n\\n    def __init__(self):\\n        self.hashmap = {}\\n        self.sd = SortedDict()\\n\\n    def inc(self, key: str) -> None:\\n        if key not in self.hashmap:\\n            self.hashmap[key] = 1\\n            if 1 in self.sd:\\n                self.sd[1].add(key)\\n            else:\\n                self.sd[1] = set([key])\\n        else:\\n            prev_cnt = self.hashmap[key]\\n            self.hashmap[key] += 1\\n            self.sd[prev_cnt].remove(key)\\n            if not self.sd[prev_cnt]:\\n                del self.sd[prev_cnt]\\n            if prev_cnt + 1 not in self.sd:\\n                self.sd[prev_cnt + 1] = set()\\n            self.sd[prev_cnt + 1].add(key)\\n\\n    def dec(self, key: str) -> None:\\n        prev_cnt = self.hashmap[key]\\n        if prev_cnt == 1:\\n            del self.hashmap[key]\\n            self.sd[1].remove(key)\\n            if len(self.sd[1]) == 0:\\n                del self.sd[1]\\n        else:\\n            self.hashmap[key] -= 1\\n            self.sd[prev_cnt].remove(key)\\n            if not self.sd[prev_cnt]:\\n                del self.sd[prev_cnt]\\n            if prev_cnt - 1 not in self.sd:\\n                self.sd[prev_cnt - 1] = set()\\n            self.sd[prev_cnt - 1].add(key)\\n        \\n        \\n\\n    def getMaxKey(self) -> str:\\n        if not self.hashmap:\\n            return \\'\\'\\n        max_set = self.sd.peekitem(-1)[1]\\n        for item in max_set:\\n            return item\\n\\n    def getMinKey(self) -> str:\\n        if not self.hashmap:\\n            return \\'\\'\\n        min_set = self.sd.peekitem(0)[1]\\n        for item in min_set:\\n            return item",
                "solutionTags": [],
                "code": "```\\n# 1 hashmap to track the number of counts for each key\\n# 1 treemap to track the max/min counts, {count: set of keys}\\n# when inc, update hashmap and treemap\\n# same procedure for dec\\n\\nfrom sortedcontainers import SortedDict\\nclass AllOne:\\n\\n    def __init__(self):\\n        self.hashmap = {}\\n        self.sd = SortedDict()\\n\\n    def inc(self, key: str) -> None:\\n        if key not in self.hashmap:\\n            self.hashmap[key] = 1\\n            if 1 in self.sd:\\n                self.sd[1].add(key)\\n            else:\\n                self.sd[1] = set([key])\\n        else:\\n            prev_cnt = self.hashmap[key]\\n            self.hashmap[key] += 1\\n            self.sd[prev_cnt].remove(key)\\n            if not self.sd[prev_cnt]:\\n                del self.sd[prev_cnt]\\n            if prev_cnt + 1 not in self.sd:\\n                self.sd[prev_cnt + 1] = set()\\n            self.sd[prev_cnt + 1].add(key)\\n\\n    def dec(self, key: str) -> None:\\n        prev_cnt = self.hashmap[key]\\n        if prev_cnt == 1:\\n            del self.hashmap[key]\\n            self.sd[1].remove(key)\\n            if len(self.sd[1]) == 0:\\n                del self.sd[1]\\n        else:\\n            self.hashmap[key] -= 1\\n            self.sd[prev_cnt].remove(key)\\n            if not self.sd[prev_cnt]:\\n                del self.sd[prev_cnt]\\n            if prev_cnt - 1 not in self.sd:\\n                self.sd[prev_cnt - 1] = set()\\n            self.sd[prev_cnt - 1].add(key)\\n        \\n        \\n\\n    def getMaxKey(self) -> str:\\n        if not self.hashmap:\\n            return \\'\\'\\n        max_set = self.sd.peekitem(-1)[1]\\n        for item in max_set:\\n            return item\\n\\n    def getMinKey(self) -> str:\\n        if not self.hashmap:\\n            return \\'\\'\\n        min_set = self.sd.peekitem(0)[1]\\n        for item in min_set:\\n            return item",
                "codeTag": "Java"
            },
            {
                "id": 1715972,
                "title": "short-java-treemap-solution-easy-to-understand",
                "content": "```\\nclass AllOne {\\n    Map<String, Integer> ktof = new HashMap<>();\\n    TreeMap<Integer, Set<String>> ftok = new TreeMap<>();\\n    int min, max;\\n    public AllOne() {\\n        min = 0;\\n        max = 0;\\n    }\\n    \\n    public void inc(String k) {\\n        if (!ktof.containsKey(k)) {\\n            min = 1;\\n            if (max == 0) max = 1;\\n            ktof.put(k, 1);\\n            ftok.computeIfAbsent(1, x -> new HashSet<>()).add(k);\\n            return;\\n        }\\n        int freq = ktof.get(k);\\n        ktof.put(k, freq+1);\\n        ftok.get(freq).remove(k);\\n        if (ftok.get(freq).size() == 0) ftok.remove(freq);\\n        ftok.computeIfAbsent(freq+1, x -> new HashSet<>()).add(k);\\n        \\n        if (freq == max) max++;\\n        if (freq == min && ftok.get(freq) == null) min++;\\n    }\\n    \\n    public void dec(String k) {\\n        int freq = ktof.get(k);\\n        if (freq == 1) {\\n            ktof.remove(k);\\n            ftok.get(1).remove(k);\\n            if (ftok.get(1).size() == 0) {\\n                ftok.remove(1);\\n                min = ktof.size() == 0 ? 0 : ftok.higherKey(min);\\n            }\\n            return;\\n        }\\n        ktof.put(k, freq-1);\\n        ftok.get(freq).remove(k);\\n        if (ftok.get(freq).size() == 0) ftok.remove(freq);\\n        ftok.computeIfAbsent(freq-1, x -> new HashSet<>()).add(k);\\n\\n        if (freq == max && ftok.get(freq) == null) max--;\\n        if (freq == min) min--;\\n    }\\n    \\n    public String getMaxKey() {\\n        return max == 0 ? \"\" : ftok.get(max).iterator().next();\\n    }\\n    \\n    public String getMinKey() {\\n        return min == 0 ? \"\" : ftok.get(min).iterator().next();\\n    }\\n    \\n}\\n ```",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```\\nclass AllOne {\\n    Map<String, Integer> ktof = new HashMap<>();\\n    TreeMap<Integer, Set<String>> ftok = new TreeMap<>();\\n    int min, max;\\n    public AllOne() {\\n        min = 0;\\n        max = 0;\\n    }\\n    \\n    public void inc(String k) {\\n        if (!ktof.containsKey(k)) {\\n            min = 1;\\n            if (max == 0) max = 1;\\n            ktof.put(k, 1);\\n            ftok.computeIfAbsent(1, x -> new HashSet<>()).add(k);\\n            return;\\n        }\\n        int freq = ktof.get(k);\\n        ktof.put(k, freq+1);\\n        ftok.get(freq).remove(k);\\n        if (ftok.get(freq).size() == 0) ftok.remove(freq);\\n        ftok.computeIfAbsent(freq+1, x -> new HashSet<>()).add(k);\\n        \\n        if (freq == max) max++;\\n        if (freq == min && ftok.get(freq) == null) min++;\\n    }\\n    \\n    public void dec(String k) {\\n        int freq = ktof.get(k);\\n        if (freq == 1) {\\n            ktof.remove(k);\\n            ftok.get(1).remove(k);\\n            if (ftok.get(1).size() == 0) {\\n                ftok.remove(1);\\n                min = ktof.size() == 0 ? 0 : ftok.higherKey(min);\\n            }\\n            return;\\n        }\\n        ktof.put(k, freq-1);\\n        ftok.get(freq).remove(k);\\n        if (ftok.get(freq).size() == 0) ftok.remove(freq);\\n        ftok.computeIfAbsent(freq-1, x -> new HashSet<>()).add(k);\\n\\n        if (freq == max && ftok.get(freq) == null) max--;\\n        if (freq == min) min--;\\n    }\\n    \\n    public String getMaxKey() {\\n        return max == 0 ? \"\" : ftok.get(max).iterator().next();\\n    }\\n    \\n    public String getMinKey() {\\n        return min == 0 ? \"\" : ftok.get(min).iterator().next();\\n    }\\n    \\n}\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 1645396,
                "title": "java-minimal-simple-solution-using-two-maps-48ms-54-7mb",
                "content": "You have two maps.\\nOne Map is \"string to count\";\\nThe other map is a SortedMap \"count -> group of strings.\"\\n\\nThe SortedMap allows you to grab the min and max key quickly.\\n\\nAfter every altering operation, you just adjust the maps easily by removing the old entry and updating the new entry.\\n\\nezpz.\\n\\n```\\nimport java.util.*;\\n\\nclass AllOne {\\n    \\n    //string -> count\\n    Map<String, Integer> stringCounts;\\n    \\n    //count -> strings\\n    //all counts have strings\\n    SortedMap<Integer, Set<String>> countToStrings;\\n\\n    public AllOne() {\\n        stringCounts = new HashMap<>();\\n        countToStrings = new TreeMap<>();\\n    }\\n    \\n    public void inc(String key) {\\n        int oldCount = stringCounts.getOrDefault(key, 0);\\n        int newCount = oldCount + 1;\\n        \\n        adjustCounts(key, oldCount, newCount);\\n    }\\n    \\n    public void dec(String key) {\\n        int oldCount = stringCounts.getOrDefault(key, 0);\\n        int newCount = oldCount - 1;\\n        \\n        adjustCounts(key, oldCount, newCount);\\n    }\\n    \\n    //adjusts all the maps\\n    private void adjustCounts(String key, int oldCount, int newCount) {\\n        //could put more safety here\\n        \\n        //remove old thing from count -> strings\\n        if(countToStrings.containsKey(oldCount)) {\\n            countToStrings.get(oldCount).remove(key);\\n            if(countToStrings.get(oldCount).size() == 0)\\n                countToStrings.remove(oldCount);\\n        }\\n            \\n        //add new count for count -> strings\\n        if(newCount > 0) {\\n            if(!countToStrings.containsKey(newCount))\\n                countToStrings.put(newCount, new HashSet<>());\\n            \\n            countToStrings.get(newCount).add(key);\\n        }\\n        \\n        //adjust string -> count\\n        if(newCount == 0)\\n            stringCounts.remove(key);\\n        else\\n            stringCounts.put(key, newCount);\\n    }\\n    \\n    public String getMaxKey() {\\n        if(countToStrings.size() == 0)\\n            return \"\";\\n        \\n        for(String str : countToStrings.get(countToStrings.lastKey()))\\n            return str;\\n        \\n        return \"\";\\n    }\\n    \\n    public String getMinKey() {\\n        if(countToStrings.size() == 0)\\n            return \"\";\\n        \\n        for(String str : countToStrings.get(countToStrings.firstKey()))\\n            return str;\\n        \\n        return \"\";\\n    }\\n}\\n ```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.*;\\n\\nclass AllOne {\\n    \\n    //string -> count\\n    Map<String, Integer> stringCounts;\\n    \\n    //count -> strings\\n    //all counts have strings\\n    SortedMap<Integer, Set<String>> countToStrings;\\n\\n    public AllOne() {\\n        stringCounts = new HashMap<>();\\n        countToStrings = new TreeMap<>();\\n    }\\n    \\n    public void inc(String key) {\\n        int oldCount = stringCounts.getOrDefault(key, 0);\\n        int newCount = oldCount + 1;\\n        \\n        adjustCounts(key, oldCount, newCount);\\n    }\\n    \\n    public void dec(String key) {\\n        int oldCount = stringCounts.getOrDefault(key, 0);\\n        int newCount = oldCount - 1;\\n        \\n        adjustCounts(key, oldCount, newCount);\\n    }\\n    \\n    //adjusts all the maps\\n    private void adjustCounts(String key, int oldCount, int newCount) {\\n        //could put more safety here\\n        \\n        //remove old thing from count -> strings\\n        if(countToStrings.containsKey(oldCount)) {\\n            countToStrings.get(oldCount).remove(key);\\n            if(countToStrings.get(oldCount).size() == 0)\\n                countToStrings.remove(oldCount);\\n        }\\n            \\n        //add new count for count -> strings\\n        if(newCount > 0) {\\n            if(!countToStrings.containsKey(newCount))\\n                countToStrings.put(newCount, new HashSet<>());\\n            \\n            countToStrings.get(newCount).add(key);\\n        }\\n        \\n        //adjust string -> count\\n        if(newCount == 0)\\n            stringCounts.remove(key);\\n        else\\n            stringCounts.put(key, newCount);\\n    }\\n    \\n    public String getMaxKey() {\\n        if(countToStrings.size() == 0)\\n            return \"\";\\n        \\n        for(String str : countToStrings.get(countToStrings.lastKey()))\\n            return str;\\n        \\n        return \"\";\\n    }\\n    \\n    public String getMinKey() {\\n        if(countToStrings.size() == 0)\\n            return \"\";\\n        \\n        for(String str : countToStrings.get(countToStrings.firstKey()))\\n            return str;\\n        \\n        return \"\";\\n    }\\n}\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 1632867,
                "title": "golang-verison-with-doublelinkedlist",
                "content": "```golang\\n\\ntype AllOne struct {\\n\\tbuckets *DoubleLinkedList\\n\\tm       map[string]*Bucket\\n}\\n\\nfunc Constructor() AllOne {\\n\\treturn AllOne{\\n\\t\\tbuckets: NewDoubleLinkedList(),\\n\\t\\tm:       make(map[string]*Bucket),\\n\\t}\\n}\\n\\nfunc (this *AllOne) Inc(key string) {\\n\\tif v, ok := this.m[key]; !ok {\\n\\t\\tif this.buckets.Empty() || this.buckets.tail.prev.val != 1 { // no val=1\\n\\t\\t\\tnewBucket := &Bucket{val: 1, keys: map[string]struct{}{key: {}}}\\n\\t\\t\\tthis.buckets.AddAtTail(newBucket)\\n\\t\\t\\tthis.m[key] = newBucket\\n\\t\\t} else {\\n\\t\\t\\tlast := this.buckets.tail.prev\\n\\t\\t\\tlast.keys[key] = struct{}{}\\n\\t\\t\\tthis.m[key] = last\\n\\t\\t}\\n\\t} else {\\n\\t\\tlast := v.prev\\n\\t\\tif last == this.buckets.head || last.val != v.val+1 { // highest\\n\\t\\t\\tnewBucket := &Bucket{val: v.val + 1, keys: map[string]struct{}{key: {}}}\\n\\t\\t\\tthis.buckets.AddBefore(newBucket, v)\\n\\t\\t\\tthis.m[key] = newBucket\\n\\t\\t} else {\\n\\t\\t\\tlast.keys[key] = struct{}{}\\n\\t\\t\\tthis.m[key] = last\\n\\t\\t}\\n\\t\\tdelete(v.keys, key)\\n\\t\\tif len(v.keys) == 0 {\\n\\t\\t\\tthis.buckets.Delete(v)\\n\\t\\t}\\n\\t}\\n}\\n\\nfunc (this *AllOne) Dec(key string) {\\n\\tv, ok := this.m[key]\\n\\tif !ok {\\n\\t\\treturn\\n\\t}\\n\\n\\tif v.val == 1 {\\n\\t\\tdelete(v.keys, key)\\n\\t\\tif len(v.keys) == 0 {\\n\\t\\t\\tthis.buckets.Delete(v)\\n\\t\\t}\\n\\t\\tdelete(this.m, key)\\n\\t\\treturn\\n\\t}\\n\\n\\tnext := v.next\\n\\tif v.next == this.buckets.tail || next.val != v.val-1 {\\n\\t\\tnewBucket := &Bucket{val: v.val - 1, keys: map[string]struct{}{key: {}}}\\n\\t\\tthis.buckets.AddAfter(newBucket, v)\\n\\t\\tthis.m[key] = newBucket\\n\\t} else {\\n\\t\\tnext.keys[key] = struct{}{}\\n\\t\\tthis.m[key] = next\\n\\t}\\n\\n\\tdelete(v.keys, key)\\n\\tif len(v.keys) == 0 {\\n\\t\\tthis.buckets.Delete(v)\\n\\t}\\n}\\n\\nfunc (this *AllOne) GetMaxKey() string {\\n\\tif this.buckets.Empty() {\\n\\t\\treturn \"\"\\n\\t}\\n\\tfor key, _ := range this.buckets.head.next.keys {\\n\\t\\treturn key\\n\\t}\\n\\treturn \"\"\\n}\\n\\nfunc (this *AllOne) GetMinKey() string {\\n\\tif this.buckets.Empty() {\\n\\t\\treturn \"\"\\n\\t}\\n\\tfor key, _ := range this.buckets.tail.prev.keys {\\n\\t\\treturn key\\n\\t}\\n\\treturn \"\"\\n}\\n\\n// func main() {\\n// \\tobj := Constructor()\\n// \\tobj.Inc(\"hello\")\\n// \\tobj.Inc(\"hello\")\\n// \\tfmt.Println(obj.GetMaxKey())\\n// \\tfmt.Println(obj.GetMinKey())\\n// \\tobj.Inc(\"leet\")\\n// \\tfmt.Println(obj.GetMaxKey())\\n// \\tfmt.Println(obj.GetMinKey())\\n// }\\n\\ntype DoubleLinkedList struct {\\n\\thead *Bucket\\n\\ttail *Bucket\\n}\\n\\nfunc NewDoubleLinkedList() *DoubleLinkedList {\\n\\thead, tail := &Bucket{}, &Bucket{}\\n\\thead.next, tail.prev = tail, head\\n\\treturn &DoubleLinkedList{\\n\\t\\thead: head,\\n\\t\\ttail: tail,\\n\\t}\\n}\\n\\ntype Bucket struct {\\n\\tprev *Bucket\\n\\tnext *Bucket\\n\\tval  int\\n\\tkeys map[string]struct{}\\n}\\n\\nfunc (l *DoubleLinkedList) AddBefore(node *Bucket, before *Bucket) {\\n\\tif before == l.head {\\n\\t\\treturn\\n\\t}\\n\\tprevBefore := before.prev\\n\\tnode.prev, prevBefore.next = prevBefore, node\\n\\tnode.next, before.prev = before, node\\n}\\n\\nfunc (l *DoubleLinkedList) AddAfter(node *Bucket, after *Bucket) {\\n\\tif after == l.tail {\\n\\t\\treturn\\n\\t}\\n\\tnextAfter := after.next\\n\\tnode.next, nextAfter.prev = nextAfter, node\\n\\tnode.prev, after.next = after, node\\n}\\n\\nfunc (l *DoubleLinkedList) AddAtHead(node *Bucket) {\\n\\tl.AddAfter(node, l.head)\\n}\\nfunc (l *DoubleLinkedList) AddAtTail(node *Bucket) {\\n\\tl.AddBefore(node, l.tail)\\n}\\n\\nfunc (l *DoubleLinkedList) Delete(node *Bucket) {\\n\\tnode.prev.next, node.next.prev = node.next, node.prev\\n}\\n\\nfunc (l *DoubleLinkedList) DeleteTail() {\\n\\tl.Delete(l.tail.prev)\\n}\\n\\nfunc (l *DoubleLinkedList) Empty() bool {\\n\\tif l.head.next == l.tail {\\n\\t\\treturn true\\n\\t}\\n\\treturn false\\n}\\n\\n```",
                "solutionTags": [
                    "Go",
                    "Linked List"
                ],
                "code": "```golang\\n\\ntype AllOne struct {\\n\\tbuckets *DoubleLinkedList\\n\\tm       map[string]*Bucket\\n}\\n\\nfunc Constructor() AllOne {\\n\\treturn AllOne{\\n\\t\\tbuckets: NewDoubleLinkedList(),\\n\\t\\tm:       make(map[string]*Bucket),\\n\\t}\\n}\\n\\nfunc (this *AllOne) Inc(key string) {\\n\\tif v, ok := this.m[key]; !ok {\\n\\t\\tif this.buckets.Empty() || this.buckets.tail.prev.val != 1 { // no val=1\\n\\t\\t\\tnewBucket := &Bucket{val: 1, keys: map[string]struct{}{key: {}}}\\n\\t\\t\\tthis.buckets.AddAtTail(newBucket)\\n\\t\\t\\tthis.m[key] = newBucket\\n\\t\\t} else {\\n\\t\\t\\tlast := this.buckets.tail.prev\\n\\t\\t\\tlast.keys[key] = struct{}{}\\n\\t\\t\\tthis.m[key] = last\\n\\t\\t}\\n\\t} else {\\n\\t\\tlast := v.prev\\n\\t\\tif last == this.buckets.head || last.val != v.val+1 { // highest\\n\\t\\t\\tnewBucket := &Bucket{val: v.val + 1, keys: map[string]struct{}{key: {}}}\\n\\t\\t\\tthis.buckets.AddBefore(newBucket, v)\\n\\t\\t\\tthis.m[key] = newBucket\\n\\t\\t} else {\\n\\t\\t\\tlast.keys[key] = struct{}{}\\n\\t\\t\\tthis.m[key] = last\\n\\t\\t}\\n\\t\\tdelete(v.keys, key)\\n\\t\\tif len(v.keys) == 0 {\\n\\t\\t\\tthis.buckets.Delete(v)\\n\\t\\t}\\n\\t}\\n}\\n\\nfunc (this *AllOne) Dec(key string) {\\n\\tv, ok := this.m[key]\\n\\tif !ok {\\n\\t\\treturn\\n\\t}\\n\\n\\tif v.val == 1 {\\n\\t\\tdelete(v.keys, key)\\n\\t\\tif len(v.keys) == 0 {\\n\\t\\t\\tthis.buckets.Delete(v)\\n\\t\\t}\\n\\t\\tdelete(this.m, key)\\n\\t\\treturn\\n\\t}\\n\\n\\tnext := v.next\\n\\tif v.next == this.buckets.tail || next.val != v.val-1 {\\n\\t\\tnewBucket := &Bucket{val: v.val - 1, keys: map[string]struct{}{key: {}}}\\n\\t\\tthis.buckets.AddAfter(newBucket, v)\\n\\t\\tthis.m[key] = newBucket\\n\\t} else {\\n\\t\\tnext.keys[key] = struct{}{}\\n\\t\\tthis.m[key] = next\\n\\t}\\n\\n\\tdelete(v.keys, key)\\n\\tif len(v.keys) == 0 {\\n\\t\\tthis.buckets.Delete(v)\\n\\t}\\n}\\n\\nfunc (this *AllOne) GetMaxKey() string {\\n\\tif this.buckets.Empty() {\\n\\t\\treturn \"\"\\n\\t}\\n\\tfor key, _ := range this.buckets.head.next.keys {\\n\\t\\treturn key\\n\\t}\\n\\treturn \"\"\\n}\\n\\nfunc (this *AllOne) GetMinKey() string {\\n\\tif this.buckets.Empty() {\\n\\t\\treturn \"\"\\n\\t}\\n\\tfor key, _ := range this.buckets.tail.prev.keys {\\n\\t\\treturn key\\n\\t}\\n\\treturn \"\"\\n}\\n\\n// func main() {\\n// \\tobj := Constructor()\\n// \\tobj.Inc(\"hello\")\\n// \\tobj.Inc(\"hello\")\\n// \\tfmt.Println(obj.GetMaxKey())\\n// \\tfmt.Println(obj.GetMinKey())\\n// \\tobj.Inc(\"leet\")\\n// \\tfmt.Println(obj.GetMaxKey())\\n// \\tfmt.Println(obj.GetMinKey())\\n// }\\n\\ntype DoubleLinkedList struct {\\n\\thead *Bucket\\n\\ttail *Bucket\\n}\\n\\nfunc NewDoubleLinkedList() *DoubleLinkedList {\\n\\thead, tail := &Bucket{}, &Bucket{}\\n\\thead.next, tail.prev = tail, head\\n\\treturn &DoubleLinkedList{\\n\\t\\thead: head,\\n\\t\\ttail: tail,\\n\\t}\\n}\\n\\ntype Bucket struct {\\n\\tprev *Bucket\\n\\tnext *Bucket\\n\\tval  int\\n\\tkeys map[string]struct{}\\n}\\n\\nfunc (l *DoubleLinkedList) AddBefore(node *Bucket, before *Bucket) {\\n\\tif before == l.head {\\n\\t\\treturn\\n\\t}\\n\\tprevBefore := before.prev\\n\\tnode.prev, prevBefore.next = prevBefore, node\\n\\tnode.next, before.prev = before, node\\n}\\n\\nfunc (l *DoubleLinkedList) AddAfter(node *Bucket, after *Bucket) {\\n\\tif after == l.tail {\\n\\t\\treturn\\n\\t}\\n\\tnextAfter := after.next\\n\\tnode.next, nextAfter.prev = nextAfter, node\\n\\tnode.prev, after.next = after, node\\n}\\n\\nfunc (l *DoubleLinkedList) AddAtHead(node *Bucket) {\\n\\tl.AddAfter(node, l.head)\\n}\\nfunc (l *DoubleLinkedList) AddAtTail(node *Bucket) {\\n\\tl.AddBefore(node, l.tail)\\n}\\n\\nfunc (l *DoubleLinkedList) Delete(node *Bucket) {\\n\\tnode.prev.next, node.next.prev = node.next, node.prev\\n}\\n\\nfunc (l *DoubleLinkedList) DeleteTail() {\\n\\tl.Delete(l.tail.prev)\\n}\\n\\nfunc (l *DoubleLinkedList) Empty() bool {\\n\\tif l.head.next == l.tail {\\n\\t\\treturn true\\n\\t}\\n\\treturn false\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1591622,
                "title": "java-double-linked-list-hashmap-clean-code",
                "content": "```\\nclass AllOne {\\n    class DLNode{\\n        DLNode prev;\\n        DLNode next;\\n        Set<String> keys;\\n        int count;\\n        DLNode(){}\\n        DLNode(int val){\\n            this.count = val;\\n            this.keys = new HashSet();\\n        }\\n        DLNode(int val, String key){\\n            this.count = val;\\n            this.keys = new HashSet();\\n            keys.add(key);\\n        }\\n    }\\n    \\n    Map<String, DLNode> keyNodeMap;\\n    DLNode head;\\n    DLNode tail;\\n    public AllOne() {\\n        this.keyNodeMap = new HashMap();\\n        this.head = new DLNode();\\n        this.tail = new DLNode();\\n        head.next = tail;\\n        tail.prev = head;\\n    }\\n    \\n    public void removeNode(DLNode node){\\n        node.prev.next = node.next;\\n        node.next.prev = node.prev;\\n    }\\n    \\n    public DLNode removeKey(String key){\\n        DLNode oldNode = keyNodeMap.get(key);\\n        oldNode.keys.remove(key);\\n        if(oldNode.keys.isEmpty()) removeNode(oldNode);\\n        keyNodeMap.remove(key);\\n        return oldNode;\\n    }\\n    \\n    public void addKey(String key, int count, DLNode prev, DLNode next){\\n        if(prev.count == count){\\n            prev.keys.add(key);\\n            keyNodeMap.put(key, prev);\\n        }else if(next.count == count){\\n            next.keys.add(key);\\n            keyNodeMap.put(key, next);\\n        }else{\\n            DLNode newNode = new DLNode(count, key);\\n            newNode.next = next;\\n            newNode.prev = prev;\\n            prev.next = newNode;\\n            next.prev = newNode;\\n            keyNodeMap.put(key, newNode);\\n        }\\n    }\\n    \\n    public void inc(String key) {\\n        if(keyNodeMap.containsKey(key)){\\n            DLNode oldNode = removeKey(key);\\n            if(oldNode.keys.isEmpty()){\\n                addKey(key, oldNode.count + 1, oldNode.prev, oldNode.next);\\n            }else{\\n                addKey(key, oldNode.count + 1, oldNode.prev, oldNode);\\n            }\\n        }else{\\n            addKey(key, 1, tail.prev, tail);\\n        }\\n    }\\n    \\n    public void dec(String key) {\\n        DLNode oldNode = removeKey(key);\\n        if(oldNode.count != 1){\\n            if(oldNode.keys.isEmpty()){\\n                addKey(key, oldNode.count - 1, oldNode.prev, oldNode.next);\\n            }else{\\n                addKey(key, oldNode.count - 1, oldNode, oldNode.next);\\n            }\\n        }\\n    }\\n    \\n    public String getMaxKey() {\\n        return head.next == tail? \"\" : head.next.keys.iterator().next();\\n    }\\n    \\n    public String getMinKey() {\\n        return tail.prev == head? \"\" : tail.prev.keys.iterator().next();\\n    }\\n}\\n\\n/**\\n * Your AllOne object will be instantiated and called as such:\\n * AllOne obj = new AllOne();\\n * obj.inc(key);\\n * obj.dec(key);\\n * String param_3 = obj.getMaxKey();\\n * String param_4 = obj.getMinKey();\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\nclass AllOne {\\n    class DLNode{\\n        DLNode prev;\\n        DLNode next;\\n        Set<String> keys;\\n        int count;\\n        DLNode(){}\\n        DLNode(int val){\\n            this.count = val;\\n            this.keys = new HashSet();\\n        }\\n        DLNode(int val, String key){\\n            this.count = val;\\n            this.keys = new HashSet();\\n            keys.add(key);\\n        }\\n    }\\n    \\n    Map<String, DLNode> keyNodeMap;\\n    DLNode head;\\n    DLNode tail;\\n    public AllOne() {\\n        this.keyNodeMap = new HashMap();\\n        this.head = new DLNode();\\n        this.tail = new DLNode();\\n        head.next = tail;\\n        tail.prev = head;\\n    }\\n    \\n    public void removeNode(DLNode node){\\n        node.prev.next = node.next;\\n        node.next.prev = node.prev;\\n    }\\n    \\n    public DLNode removeKey(String key){\\n        DLNode oldNode = keyNodeMap.get(key);\\n        oldNode.keys.remove(key);\\n        if(oldNode.keys.isEmpty()) removeNode(oldNode);\\n        keyNodeMap.remove(key);\\n        return oldNode;\\n    }\\n    \\n    public void addKey(String key, int count, DLNode prev, DLNode next){\\n        if(prev.count == count){\\n            prev.keys.add(key);\\n            keyNodeMap.put(key, prev);\\n        }else if(next.count == count){\\n            next.keys.add(key);\\n            keyNodeMap.put(key, next);\\n        }else{\\n            DLNode newNode = new DLNode(count, key);\\n            newNode.next = next;\\n            newNode.prev = prev;\\n            prev.next = newNode;\\n            next.prev = newNode;\\n            keyNodeMap.put(key, newNode);\\n        }\\n    }\\n    \\n    public void inc(String key) {\\n        if(keyNodeMap.containsKey(key)){\\n            DLNode oldNode = removeKey(key);\\n            if(oldNode.keys.isEmpty()){\\n                addKey(key, oldNode.count + 1, oldNode.prev, oldNode.next);\\n            }else{\\n                addKey(key, oldNode.count + 1, oldNode.prev, oldNode);\\n            }\\n        }else{\\n            addKey(key, 1, tail.prev, tail);\\n        }\\n    }\\n    \\n    public void dec(String key) {\\n        DLNode oldNode = removeKey(key);\\n        if(oldNode.count != 1){\\n            if(oldNode.keys.isEmpty()){\\n                addKey(key, oldNode.count - 1, oldNode.prev, oldNode.next);\\n            }else{\\n                addKey(key, oldNode.count - 1, oldNode, oldNode.next);\\n            }\\n        }\\n    }\\n    \\n    public String getMaxKey() {\\n        return head.next == tail? \"\" : head.next.keys.iterator().next();\\n    }\\n    \\n    public String getMinKey() {\\n        return tail.prev == head? \"\" : tail.prev.keys.iterator().next();\\n    }\\n}\\n\\n/**\\n * Your AllOne object will be instantiated and called as such:\\n * AllOne obj = new AllOne();\\n * obj.inc(key);\\n * obj.dec(key);\\n * String param_3 = obj.getMaxKey();\\n * String param_4 = obj.getMinKey();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1511697,
                "title": "java-doubly-linked-list-and-map-for-o-1-on-all-operations",
                "content": "Use `Map<String, Integer>` to map each key to its count and `Map<Integer, Node>` to map each count to a `Node` storing a `Set<String>` containing all `Strings` which have that count. We can create a doubly linked list using `Node` and we can use each key\\'s count/new count after incrementing/decrementing to access `Nodes` and move key between `Nodes` as appropriate. Since we only ever increment/decrement a key\\'s count by 1, we can easily ensure that our doubly linked list will remain in sorted order by count by moving keys to the right when incrementing and moving keys to the left by decrementing. After our doubly linked list is created, the keys with min count will be in the head of our list and the keys with max count will be in the tail of our list.\\n\\n```\\npublic class AllOne {\\n    private class CountNode {\\n        private int count;\\n        private Set<String> keys;\\n        private CountNode prev;\\n        private CountNode next;\\n        \\n        private CountNode(int count, CountNode prev, CountNode next) {\\n            this.prev = prev;\\n            this.next = next;\\n            this.keys = new HashSet<>();\\n            this.count = count;\\n        }\\n        \\n        private void addKey(String key) {\\n            this.keys.add(key);\\n        }\\n        \\n        private void removeKey(String key) {\\n            this.keys.remove(key);\\n        }\\n        \\n        private boolean hasKeys() {\\n            return this.keys.size() > 0;\\n        }\\n    }\\n    \\n    private static final int DUMMY_VALUE = -1;\\n    \\n    private Map<String, Integer> keyToCounts;\\n    private Map<Integer, CountNode> countToNodes;\\n    private CountNode dummyHead;\\n    private CountNode dummyTail;\\n  \\n    public AllOne() {\\n        this.keyToCounts = new HashMap<>();\\n        this.countToNodes = new HashMap<>();\\n        this.dummyHead = new CountNode(this.DUMMY_VALUE, null, null);\\n        this.dummyTail = new CountNode(this.DUMMY_VALUE, this.dummyHead, null);\\n        this.dummyHead.next = this.dummyTail;\\n    }\\n  \\n    public void inc(String key) {\\n        // Update key count\\n        int count = this.keyToCounts.getOrDefault(key, 0);\\n        this.keyToCounts.put(key, count + 1);\\n        \\n        // Get CountNodes corresponding to count and count + 1. Use dummyHead or insert new CountNode to right\\n        // of oldNode if there are no corresponding CountNodes for count or count + 1 respectively\\n        CountNode oldNode = this.countToNodes.getOrDefault(count, this.dummyHead);\\n        CountNode newNode =\\n            this.countToNodes.getOrDefault(count + 1, new CountNode(count + 1, oldNode, oldNode.next));\\n        oldNode.next = newNode;\\n        newNode.next.prev = newNode;\\n        \\n        // Add key to newNode and add mapping from count + 1 to newNode\\n        newNode.addKey(key);\\n        this.countToNodes.put(count + 1, newNode);\\n\\n        // If oldNode is not dummyHead\\n        if (oldNode != this.dummyHead) {\\n            // Remove key from oldNode and remove oldNode if it has no remaining keys\\n            oldNode.removeKey(key);\\n            if (!oldNode.hasKeys()) {\\n                this.removeNode(oldNode);\\n            }\\n        }\\n    }\\n  \\n    public void dec(String key) {\\n        int count = this.keyToCounts.getOrDefault(key, 0);\\n        // If key is not in list, return\\n        if (count == 0) {\\n            return;\\n        // If key has count of 1, remove key\\n        } else if (count == 1) {\\n            this.keyToCounts.remove(key);\\n        // Else, update key count\\n        } else {\\n            this.keyToCounts.put(key, count - 1);\\n        }\\n        \\n        // Get CountNode corresponding to count\\n        CountNode oldNode = this.countToNodes.get(count);\\n        \\n        // If key has count > 1\\n        if (count > 1) {\\n            // Insert new CountNode to left of oldNode\\n            CountNode newNode =\\n                this.countToNodes.getOrDefault(\\n                    count - 1,\\n                    new CountNode(count - 1, oldNode.prev, oldNode));\\n            oldNode.prev = newNode;\\n            newNode.prev.next = newNode;\\n            \\n            // Add key to newNode and add mapping from count - 1 to newNode\\n            newNode.addKey(key);\\n            this.countToNodes.put(count - 1, newNode);\\n        }\\n        \\n        // Remove key from oldNode and remove oldNode if it has no remaining keys\\n        oldNode.removeKey(key);\\n        if (!oldNode.hasKeys()) {\\n            this.removeNode(oldNode);\\n        }\\n    }\\n    \\n    private void removeNode(CountNode node) {\\n        this.countToNodes.remove(node.count);\\n        node.next.prev = node.prev;\\n        node.prev.next = node.next;\\n        node.prev = null;\\n        node.next = null;\\n    }\\n    \\n    public String getMaxKey() {\\n        return this.isEmpty() ? \"\" : this.dummyTail.prev.keys.iterator().next();\\n    }\\n   \\n    public String getMinKey() {\\n        return this.isEmpty() ? \"\" : this.dummyHead.next.keys.iterator().next();\\n    }\\n    \\n    public boolean isEmpty() {\\n        return this.dummyHead.next == this.dummyTail;\\n    }\\n}\\n```\\n\\n* Time Complexity: ***O(1)*** for all operations since we can access counts and nodes in  ***O(1)*** time using the hashmaps and we can delete/insert nodes in  ***O(1)*** time as well. Getting min and max key is returning a key in the head or tail of our list\\n* Space Complexity:  ***O(N)*** where *N* is the number of keys. Our key to counts hashmap can contain at most *N* elements. Our count to nodes hashmap can contain at most *c* elements where *c* is the number of unique counts for keys. Note *c <= N*. The doubly linked list can contain at most *N* nodes (each node only stores one key).",
                "solutionTags": [
                    "Doubly-Linked List"
                ],
                "code": "```\\npublic class AllOne {\\n    private class CountNode {\\n        private int count;\\n        private Set<String> keys;\\n        private CountNode prev;\\n        private CountNode next;\\n        \\n        private CountNode(int count, CountNode prev, CountNode next) {\\n            this.prev = prev;\\n            this.next = next;\\n            this.keys = new HashSet<>();\\n            this.count = count;\\n        }\\n        \\n        private void addKey(String key) {\\n            this.keys.add(key);\\n        }\\n        \\n        private void removeKey(String key) {\\n            this.keys.remove(key);\\n        }\\n        \\n        private boolean hasKeys() {\\n            return this.keys.size() > 0;\\n        }\\n    }\\n    \\n    private static final int DUMMY_VALUE = -1;\\n    \\n    private Map<String, Integer> keyToCounts;\\n    private Map<Integer, CountNode> countToNodes;\\n    private CountNode dummyHead;\\n    private CountNode dummyTail;\\n  \\n    public AllOne() {\\n        this.keyToCounts = new HashMap<>();\\n        this.countToNodes = new HashMap<>();\\n        this.dummyHead = new CountNode(this.DUMMY_VALUE, null, null);\\n        this.dummyTail = new CountNode(this.DUMMY_VALUE, this.dummyHead, null);\\n        this.dummyHead.next = this.dummyTail;\\n    }\\n  \\n    public void inc(String key) {\\n        // Update key count\\n        int count = this.keyToCounts.getOrDefault(key, 0);\\n        this.keyToCounts.put(key, count + 1);\\n        \\n        // Get CountNodes corresponding to count and count + 1. Use dummyHead or insert new CountNode to right\\n        // of oldNode if there are no corresponding CountNodes for count or count + 1 respectively\\n        CountNode oldNode = this.countToNodes.getOrDefault(count, this.dummyHead);\\n        CountNode newNode =\\n            this.countToNodes.getOrDefault(count + 1, new CountNode(count + 1, oldNode, oldNode.next));\\n        oldNode.next = newNode;\\n        newNode.next.prev = newNode;\\n        \\n        // Add key to newNode and add mapping from count + 1 to newNode\\n        newNode.addKey(key);\\n        this.countToNodes.put(count + 1, newNode);\\n\\n        // If oldNode is not dummyHead\\n        if (oldNode != this.dummyHead) {\\n            // Remove key from oldNode and remove oldNode if it has no remaining keys\\n            oldNode.removeKey(key);\\n            if (!oldNode.hasKeys()) {\\n                this.removeNode(oldNode);\\n            }\\n        }\\n    }\\n  \\n    public void dec(String key) {\\n        int count = this.keyToCounts.getOrDefault(key, 0);\\n        // If key is not in list, return\\n        if (count == 0) {\\n            return;\\n        // If key has count of 1, remove key\\n        } else if (count == 1) {\\n            this.keyToCounts.remove(key);\\n        // Else, update key count\\n        } else {\\n            this.keyToCounts.put(key, count - 1);\\n        }\\n        \\n        // Get CountNode corresponding to count\\n        CountNode oldNode = this.countToNodes.get(count);\\n        \\n        // If key has count > 1\\n        if (count > 1) {\\n            // Insert new CountNode to left of oldNode\\n            CountNode newNode =\\n                this.countToNodes.getOrDefault(\\n                    count - 1,\\n                    new CountNode(count - 1, oldNode.prev, oldNode));\\n            oldNode.prev = newNode;\\n            newNode.prev.next = newNode;\\n            \\n            // Add key to newNode and add mapping from count - 1 to newNode\\n            newNode.addKey(key);\\n            this.countToNodes.put(count - 1, newNode);\\n        }\\n        \\n        // Remove key from oldNode and remove oldNode if it has no remaining keys\\n        oldNode.removeKey(key);\\n        if (!oldNode.hasKeys()) {\\n            this.removeNode(oldNode);\\n        }\\n    }\\n    \\n    private void removeNode(CountNode node) {\\n        this.countToNodes.remove(node.count);\\n        node.next.prev = node.prev;\\n        node.prev.next = node.next;\\n        node.prev = null;\\n        node.next = null;\\n    }\\n    \\n    public String getMaxKey() {\\n        return this.isEmpty() ? \"\" : this.dummyTail.prev.keys.iterator().next();\\n    }\\n   \\n    public String getMinKey() {\\n        return this.isEmpty() ? \"\" : this.dummyHead.next.keys.iterator().next();\\n    }\\n    \\n    public boolean isEmpty() {\\n        return this.dummyHead.next == this.dummyTail;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1403555,
                "title": "python-doublelinkednode-dict",
                "content": "```\\nclass DoubleLinkedNode:\\n    def __init__(self, key_set = {}, count = 0, prev = None, next = None):\\n        self.key_set = key_set\\n        self.count = count\\n        self.prev = prev\\n        self.next = next\\n    \\n    def connect(self, other):\\n        self.next = other\\n        other.prev = self\\n    \\n    def insertNewNode(self, new_node):\\n        next_node = self.next\\n        self.connect(new_node)\\n        new_node.connect(next_node)\\n    \\n    def removeNode(self):\\n        prev_node, next_node = self.prev, self.next\\n        prev_node.connect(next_node)\\n\\nclass AllOne:\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.key2node = dict()\\n        self.head, self.tail = DoubleLinkedNode(), DoubleLinkedNode()\\n        self.head.connect(self.tail)\\n\\n    def inc(self, key: str) -> None:\\n        \"\"\"\\n        Inserts a new key <Key> with value 1. Or increments an existing key by 1.\\n        \"\"\"\\n        # not exist\\n        if key not in self.key2node:\\n            cur_node = self.head # with 0 count\\n        # exist\\n        else:\\n            cur_node = self.key2node[key]\\n        \\n        # block 1: add/update the key in new node\\n        # does not have the next node with the count+1\\n        if cur_node.count + 1 != cur_node.next.count:\\n            # create a new node\\n            next_node = DoubleLinkedNode({key}, cur_node.count + 1)\\n            cur_node.insertNewNode(next_node)\\n        # has the next node with the count+1\\n        else:\\n            next_node = cur_node.next\\n            next_node.key_set.add(key)\\n        \\n        # block 2: remove the current key_set/node if necessary\\n        # if exist: remove key in the key_set of the current node\\n        if cur_node != self.head:\\n            cur_node.key_set.remove(key)\\n            # if key_set of the current node is empty, delete the current node\\n            if not cur_node.key_set:\\n                cur_node.removeNode()\\n        \\n        # block 3: update the hashmap\\n        self.key2node[key] = next_node\\n\\n    def dec(self, key: str) -> None:\\n        \"\"\"\\n        Decrements an existing key by 1. If Key\\'s value is 1, remove it from the data structure.\\n        \"\"\"\\n        # it is guaranteed that key exists\\n        cur_node = self.key2node[key]\\n        \\n        # key\\'s count is 1: directly remove it\\n        if cur_node.count == 1:\\n            cur_node.key_set.remove(key)\\n            if not cur_node.key_set:\\n                cur_node.removeNode()\\n            del self.key2node[key]\\n        else:\\n            # block 1: add/update the key in new node\\n            # does not have the previous node with the count-1\\n            if cur_node.count - 1 != cur_node.prev.count:\\n                # create a new node\\n                prev_node = DoubleLinkedNode({key}, cur_node.count - 1)\\n                cur_node.prev.insertNewNode(prev_node)\\n            # has the previous node with the count-1\\n            else:\\n                prev_node = cur_node.prev\\n                prev_node.key_set.add(key)\\n\\n            # block 2: remove the current key_set/node if necessary\\n            cur_node.key_set.remove(key)\\n            if not cur_node.key_set:\\n                cur_node.removeNode()\\n            \\n            # block 3: update the hashmap\\n            self.key2node[key] = prev_node\\n\\n    def getMaxKey(self) -> str:\\n        \"\"\"\\n        Returns one of the keys with maximal value.\\n        \"\"\"\\n        # no elementes\\n        if not self.key2node:\\n            return \"\"\\n        \\n        # has at least one element\\n        node_with_max = self.tail.prev\\n        # randomly get one key from the key_set\\n        random_key = node_with_max.key_set.pop()\\n        node_with_max.key_set.add(random_key)\\n        \\n        return random_key\\n\\n    def getMinKey(self) -> str:\\n        \"\"\"\\n        Returns one of the keys with Minimal value.\\n        \"\"\"\\n        if not self.key2node:\\n            return \"\"\\n        \\n        node_with_min = self.head.next\\n        random_key = node_with_min.key_set.pop()\\n        node_with_min.key_set.add(random_key)\\n        \\n        return random_key\\n```",
                "solutionTags": [
                    "Python",
                    "Linked List"
                ],
                "code": "```\\nclass DoubleLinkedNode:\\n    def __init__(self, key_set = {}, count = 0, prev = None, next = None):\\n        self.key_set = key_set\\n        self.count = count\\n        self.prev = prev\\n        self.next = next\\n    \\n    def connect(self, other):\\n        self.next = other\\n        other.prev = self\\n    \\n    def insertNewNode(self, new_node):\\n        next_node = self.next\\n        self.connect(new_node)\\n        new_node.connect(next_node)\\n    \\n    def removeNode(self):\\n        prev_node, next_node = self.prev, self.next\\n        prev_node.connect(next_node)\\n\\nclass AllOne:\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.key2node = dict()\\n        self.head, self.tail = DoubleLinkedNode(), DoubleLinkedNode()\\n        self.head.connect(self.tail)\\n\\n    def inc(self, key: str) -> None:\\n        \"\"\"\\n        Inserts a new key <Key> with value 1. Or increments an existing key by 1.\\n        \"\"\"\\n        # not exist\\n        if key not in self.key2node:\\n            cur_node = self.head # with 0 count\\n        # exist\\n        else:\\n            cur_node = self.key2node[key]\\n        \\n        # block 1: add/update the key in new node\\n        # does not have the next node with the count+1\\n        if cur_node.count + 1 != cur_node.next.count:\\n            # create a new node\\n            next_node = DoubleLinkedNode({key}, cur_node.count + 1)\\n            cur_node.insertNewNode(next_node)\\n        # has the next node with the count+1\\n        else:\\n            next_node = cur_node.next\\n            next_node.key_set.add(key)\\n        \\n        # block 2: remove the current key_set/node if necessary\\n        # if exist: remove key in the key_set of the current node\\n        if cur_node != self.head:\\n            cur_node.key_set.remove(key)\\n            # if key_set of the current node is empty, delete the current node\\n            if not cur_node.key_set:\\n                cur_node.removeNode()\\n        \\n        # block 3: update the hashmap\\n        self.key2node[key] = next_node\\n\\n    def dec(self, key: str) -> None:\\n        \"\"\"\\n        Decrements an existing key by 1. If Key\\'s value is 1, remove it from the data structure.\\n        \"\"\"\\n        # it is guaranteed that key exists\\n        cur_node = self.key2node[key]\\n        \\n        # key\\'s count is 1: directly remove it\\n        if cur_node.count == 1:\\n            cur_node.key_set.remove(key)\\n            if not cur_node.key_set:\\n                cur_node.removeNode()\\n            del self.key2node[key]\\n        else:\\n            # block 1: add/update the key in new node\\n            # does not have the previous node with the count-1\\n            if cur_node.count - 1 != cur_node.prev.count:\\n                # create a new node\\n                prev_node = DoubleLinkedNode({key}, cur_node.count - 1)\\n                cur_node.prev.insertNewNode(prev_node)\\n            # has the previous node with the count-1\\n            else:\\n                prev_node = cur_node.prev\\n                prev_node.key_set.add(key)\\n\\n            # block 2: remove the current key_set/node if necessary\\n            cur_node.key_set.remove(key)\\n            if not cur_node.key_set:\\n                cur_node.removeNode()\\n            \\n            # block 3: update the hashmap\\n            self.key2node[key] = prev_node\\n\\n    def getMaxKey(self) -> str:\\n        \"\"\"\\n        Returns one of the keys with maximal value.\\n        \"\"\"\\n        # no elementes\\n        if not self.key2node:\\n            return \"\"\\n        \\n        # has at least one element\\n        node_with_max = self.tail.prev\\n        # randomly get one key from the key_set\\n        random_key = node_with_max.key_set.pop()\\n        node_with_max.key_set.add(random_key)\\n        \\n        return random_key\\n\\n    def getMinKey(self) -> str:\\n        \"\"\"\\n        Returns one of the keys with Minimal value.\\n        \"\"\"\\n        if not self.key2node:\\n            return \"\"\\n        \\n        node_with_min = self.head.next\\n        random_key = node_with_min.key_set.pop()\\n        node_with_min.key_set.add(random_key)\\n        \\n        return random_key\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1390689,
                "title": "simple-java-solution-with-1-hashmap-and-1-sortedset",
                "content": "Two tricks:\\n* Comparator of `ordering` should take care of equalvence of two different keys\\'s frequency\\n* Update `frequency` won\\'t trigger a re-sort of `ordering`, thus need to remove key and add it back\\n\\n```\\nclass AllOne {\\n    \\n    private final Map<String, Integer> frequency;\\n    private final SortedSet<String> ordering;\\n\\n    /** Initialize your data structure here. */\\n    public AllOne() {\\n        this.frequency = new HashMap<>();\\n        this.ordering = new TreeSet<>((x, y) -> {\\n            int fx = frequency.getOrDefault(x, 0);\\n            int fy = frequency.getOrDefault(y, 0);\\n            return fx == fy ? x.compareTo(y) : fx - fy;\\n        });\\n    }\\n    \\n    /** Inserts a new key <Key> with value 1. Or increments an existing key by 1. */\\n    public void inc(String key) {\\n        ordering.remove(key);\\n        frequency.put(key, frequency.getOrDefault(key, 0) + 1);\\n        ordering.add(key);\\n    }\\n    \\n    /** Decrements an existing key by 1. If Key\\'s value is 1, remove it from the data structure. */\\n    public void dec(String key) {\\n        if (!frequency.containsKey(key)) {\\n            return;\\n        } \\n        int f = frequency.get(key);\\n        ordering.remove(key);\\n        if (f == 1) {\\n            frequency.remove(key);\\n        } else {\\n            frequency.put(key, f - 1);\\n            ordering.add(key);\\n        }\\n    }\\n    \\n    /** Returns one of the keys with maximal value. */\\n    public String getMaxKey() {\\n        return frequency.isEmpty() ? \"\" : ordering.last();\\n    }\\n    \\n    /** Returns one of the keys with Minimal value. */\\n    public String getMinKey() {\\n        return frequency.isEmpty() ? \"\" : ordering.first();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass AllOne {\\n    \\n    private final Map<String, Integer> frequency;\\n    private final SortedSet<String> ordering;\\n\\n    /** Initialize your data structure here. */\\n    public AllOne() {\\n        this.frequency = new HashMap<>();\\n        this.ordering = new TreeSet<>((x, y) -> {\\n            int fx = frequency.getOrDefault(x, 0);\\n            int fy = frequency.getOrDefault(y, 0);\\n            return fx == fy ? x.compareTo(y) : fx - fy;\\n        });\\n    }\\n    \\n    /** Inserts a new key <Key> with value 1. Or increments an existing key by 1. */\\n    public void inc(String key) {\\n        ordering.remove(key);\\n        frequency.put(key, frequency.getOrDefault(key, 0) + 1);\\n        ordering.add(key);\\n    }\\n    \\n    /** Decrements an existing key by 1. If Key\\'s value is 1, remove it from the data structure. */\\n    public void dec(String key) {\\n        if (!frequency.containsKey(key)) {\\n            return;\\n        } \\n        int f = frequency.get(key);\\n        ordering.remove(key);\\n        if (f == 1) {\\n            frequency.remove(key);\\n        } else {\\n            frequency.put(key, f - 1);\\n            ordering.add(key);\\n        }\\n    }\\n    \\n    /** Returns one of the keys with maximal value. */\\n    public String getMaxKey() {\\n        return frequency.isEmpty() ? \"\" : ordering.last();\\n    }\\n    \\n    /** Returns one of the keys with Minimal value. */\\n    public String getMinKey() {\\n        return frequency.isEmpty() ? \"\" : ordering.first();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1385794,
                "title": "java-simple-treemap-solution",
                "content": "```\\nclass AllOne {\\n    Map<String, Integer> map = new HashMap<>();\\n    TreeMap<Integer, Set<String>> bucket = new TreeMap<>();\\n    public AllOne() {\\n        \\n    }\\n    \\n    public void inc(String key) {\\n        if(map.containsKey(key)) {\\n            int count = map.get(key);\\n            bucket.get(count).remove(key);\\n            if(bucket.get(count).isEmpty()) {\\n                bucket.remove(count);\\n            }\\n            Set<String> set = bucket.getOrDefault(count+1, new HashSet<>());\\n            set.add(key);\\n            map.put(key, count+1);\\n            bucket.put(count+1, set);\\n        } else {\\n            Set<String> set = bucket.getOrDefault(1, new HashSet<>());\\n            set.add(key);\\n            map.put(key, 1);\\n            bucket.put(1, set);            \\n        }        \\n    }\\n    \\n    public void dec(String key) {\\n        int count = map.get(key);\\n        if(count == 1) {\\n            map.remove(key);\\n            Set<String> set = bucket.get(1);\\n            set.remove(key);\\n            if(set.isEmpty()) {\\n                bucket.remove(1);\\n            }\\n        } else {\\n            map.put(key, count-1);\\n            Set<String> set = bucket.get(count);\\n            set.remove(key);\\n            if(set.isEmpty()) {\\n                bucket.remove(count);\\n            }\\n            set = bucket.getOrDefault(count-1, new HashSet<>());\\n            set.add(key);\\n            bucket.put(count-1, set);\\n        }\\n    }\\n    \\n    \\n    public String getMaxKey() {\\n        if(bucket.isEmpty()) {\\n            return \"\";\\n        }\\n        int last = bucket.lastKey();\\n        return bucket.get(last).iterator().next();\\n    }\\n    \\n    public String getMinKey() {\\n        if(bucket.isEmpty()) {\\n            return \"\";\\n        }\\n        int first = bucket.firstKey();\\n        return bucket.get(first).iterator().next();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass AllOne {\\n    Map<String, Integer> map = new HashMap<>();\\n    TreeMap<Integer, Set<String>> bucket = new TreeMap<>();\\n    public AllOne() {\\n        \\n    }\\n    \\n    public void inc(String key) {\\n        if(map.containsKey(key)) {\\n            int count = map.get(key);\\n            bucket.get(count).remove(key);\\n            if(bucket.get(count).isEmpty()) {\\n                bucket.remove(count);\\n            }\\n            Set<String> set = bucket.getOrDefault(count+1, new HashSet<>());\\n            set.add(key);\\n            map.put(key, count+1);\\n            bucket.put(count+1, set);\\n        } else {\\n            Set<String> set = bucket.getOrDefault(1, new HashSet<>());\\n            set.add(key);\\n            map.put(key, 1);\\n            bucket.put(1, set);            \\n        }        \\n    }\\n    \\n    public void dec(String key) {\\n        int count = map.get(key);\\n        if(count == 1) {\\n            map.remove(key);\\n            Set<String> set = bucket.get(1);\\n            set.remove(key);\\n            if(set.isEmpty()) {\\n                bucket.remove(1);\\n            }\\n        } else {\\n            map.put(key, count-1);\\n            Set<String> set = bucket.get(count);\\n            set.remove(key);\\n            if(set.isEmpty()) {\\n                bucket.remove(count);\\n            }\\n            set = bucket.getOrDefault(count-1, new HashSet<>());\\n            set.add(key);\\n            bucket.put(count-1, set);\\n        }\\n    }\\n    \\n    \\n    public String getMaxKey() {\\n        if(bucket.isEmpty()) {\\n            return \"\";\\n        }\\n        int last = bucket.lastKey();\\n        return bucket.get(last).iterator().next();\\n    }\\n    \\n    public String getMinKey() {\\n        if(bucket.isEmpty()) {\\n            return \"\";\\n        }\\n        int first = bucket.firstKey();\\n        return bucket.get(first).iterator().next();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1351652,
                "title": "my-intuitive-java-solution-using-2-maps",
                "content": "```\\nclass AllOne {\\n    Map<String, Integer> map;\\n    TreeMap<Integer, HashSet<String>> reverseMap;\\n    /** Initialize your data structure here. */\\n    public AllOne() {\\n        map = new HashMap<>();\\n        reverseMap = new TreeMap<>();\\n    }\\n    \\n    /** Inserts a new key <Key> with value 1. Or increments an existing key by 1. */\\n    public void inc(String key) {\\n        map.put(key, map.getOrDefault(key, 0) + 1);\\n        int freq = map.get(key);\\n        removeStringReverseMap(freq - 1, key);\\n        addStringReverseMap(freq, key);\\n    }\\n    \\n    /** Decrements an existing key by 1. If Key\\'s value is 1, remove it from the data structure. */\\n    public void dec(String key) {\\n        int freq = map.get(key);\\n        if(freq - 1 == 0){\\n            map.remove(key);\\n        }else{\\n           map.put(key, freq - 1); \\n        }\\n        removeStringReverseMap(freq, key);\\n        if(freq - 1 > 0){\\n           addStringReverseMap(freq - 1, key); \\n        }\\n    }\\n    \\n    private void removeStringReverseMap(int freq, String string){\\n        if(reverseMap.containsKey(freq)){\\n            HashSet<String> set = reverseMap.get(freq);\\n            if(set.contains(string)){\\n                set.remove(string);\\n            }\\n            if(set.size() == 0){\\n                reverseMap.remove(freq);\\n            }\\n            \\n        }\\n    }\\n    private void addStringReverseMap(int freq, String string){\\n        HashSet<String> set = reverseMap.getOrDefault(freq, new HashSet<>());\\n        set.add(string);\\n        reverseMap.put(freq, set);\\n    }\\n    /** Returns one of the keys with maximal value. */\\n    public String getMaxKey() {\\n        if(reverseMap.isEmpty()){\\n            return \"\";\\n        }\\n        return reverseMap.get(reverseMap. lastKey()).iterator().next();\\n    }\\n    \\n    /** Returns one of the keys with Minimal value. */\\n    public String getMinKey() {\\n      if(reverseMap.isEmpty()){\\n            return \"\";\\n        }\\n         return reverseMap.get(reverseMap. firstKey()).iterator().next();\\n    }\\n}\\n\\n/**\\n * Your AllOne object will be instantiated and called as such:\\n * AllOne obj = new AllOne();\\n * obj.inc(key);\\n * obj.dec(key);\\n * String param_3 = obj.getMaxKey();\\n * String param_4 = obj.getMinKey();\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass AllOne {\\n    Map<String, Integer> map;\\n    TreeMap<Integer, HashSet<String>> reverseMap;\\n    /** Initialize your data structure here. */\\n    public AllOne() {\\n        map = new HashMap<>();\\n        reverseMap = new TreeMap<>();\\n    }\\n    \\n    /** Inserts a new key <Key> with value 1. Or increments an existing key by 1. */\\n    public void inc(String key) {\\n        map.put(key, map.getOrDefault(key, 0) + 1);\\n        int freq = map.get(key);\\n        removeStringReverseMap(freq - 1, key);\\n        addStringReverseMap(freq, key);\\n    }\\n    \\n    /** Decrements an existing key by 1. If Key\\'s value is 1, remove it from the data structure. */\\n    public void dec(String key) {\\n        int freq = map.get(key);\\n        if(freq - 1 == 0){\\n            map.remove(key);\\n        }else{\\n           map.put(key, freq - 1); \\n        }\\n        removeStringReverseMap(freq, key);\\n        if(freq - 1 > 0){\\n           addStringReverseMap(freq - 1, key); \\n        }\\n    }\\n    \\n    private void removeStringReverseMap(int freq, String string){\\n        if(reverseMap.containsKey(freq)){\\n            HashSet<String> set = reverseMap.get(freq);\\n            if(set.contains(string)){\\n                set.remove(string);\\n            }\\n            if(set.size() == 0){\\n                reverseMap.remove(freq);\\n            }\\n            \\n        }\\n    }\\n    private void addStringReverseMap(int freq, String string){\\n        HashSet<String> set = reverseMap.getOrDefault(freq, new HashSet<>());\\n        set.add(string);\\n        reverseMap.put(freq, set);\\n    }\\n    /** Returns one of the keys with maximal value. */\\n    public String getMaxKey() {\\n        if(reverseMap.isEmpty()){\\n            return \"\";\\n        }\\n        return reverseMap.get(reverseMap. lastKey()).iterator().next();\\n    }\\n    \\n    /** Returns one of the keys with Minimal value. */\\n    public String getMinKey() {\\n      if(reverseMap.isEmpty()){\\n            return \"\";\\n        }\\n         return reverseMap.get(reverseMap. firstKey()).iterator().next();\\n    }\\n}\\n\\n/**\\n * Your AllOne object will be instantiated and called as such:\\n * AllOne obj = new AllOne();\\n * obj.inc(key);\\n * obj.dec(key);\\n * String param_3 = obj.getMaxKey();\\n * String param_4 = obj.getMinKey();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1340420,
                "title": "python-solution-constant-time",
                "content": "```\\nclass Node:\\n    def __init__(self, count):\\n        self.count = count\\n        self.words = set()\\n        self.next = None\\n        self.prev = None\\n    \\nclass AllOne:\\n    def __init__(self):\\n        self.hm = {}\\n        self.head = Node(0)\\n        self.tail = self.head\\n    \\n    def remove(self, node):\\n        if node == self.head: return\\n        node.prev.next = node.next \\n        if node == self.tail:\\n            self.tail = node.prev \\n        else:\\n            node.next.prev = node.prev \\n    \\n    def inc(self, key: str) -> None:\\n        if key not in self.hm:\\n            self.head.words.add(key)\\n            self.hm[key] = self.head\\n        node = self.hm[key]\\n        if not node.next:\\n            #add new node and remove key from current node word set and add to next\\n            #update hashmap\\n            node.next = Node(node.count + 1)\\n            node.next.prev = node\\n            node.words.remove(key)\\n            self.tail = node.next \\n            self.tail.words.add(key)\\n            self.hm[key] = self.tail\\n        else:\\n            if node.next.count == node.count + 1:\\n                # add new node and remove key from current node word set and add to next\\n                # update hashmap\\n                node.words.remove(key)\\n                node.next.words.add(key)\\n                self.hm[key] = node.next \\n            else:\\n                #add in middle of 2 nodes\\n                #remove from current node word set and add to next\\n                #update hashmap\\n                next_node = node.next \\n                node.next = Node(node.count+1)\\n                node.next.prev = node\\n                node.next.next = next_node\\n                next_node.prev = node.next \\n                node.next.words.add(key)\\n                node.words.remove(key)\\n                self.hm[key] = node.next \\n        if not node.words:\\n            self.remove(node)\\n\\n    def dec(self, key: str) -> None:\\n        node = self.hm[key]\\n        node.words.remove(key)\\n        if node.count == 1:\\n            del self.hm[key]\\n        else:\\n            prev_node = node.prev \\n            if prev_node.count == node.count - 1:\\n                # add new node and remove key from current node word set and add to next\\n                # update hashmap\\n                prev_node.words.add(key)\\n                self.hm[key] = prev_node\\n            else:\\n                #add in middle of 2 nodes\\n                #remove from current node word set and add to next\\n                #update hashmap\\n                node.prev = Node(node.count-1)\\n                node.prev.next = node\\n                node.prev.prev = prev_node\\n                prev_node.next = node.prev\\n                node.prev.words.add(key)\\n                self.hm[key] = node.prev\\n            \\n        if not node.words:\\n            self.remove(node)\\n\\n    def getMaxKey(self) -> str:\\n        if len(self.hm) == 0: return \"\"\\n        el = self.tail.words.pop()\\n        self.tail.words.add(el)\\n        return el\\n\\n    def getMinKey(self) -> str:\\n        if len(self.hm) == 0: return \"\"\\n        first_node = self.head.next \\n        el = first_node.words.pop()\\n        first_node.words.add(el)\\n        return el\\n```",
                "solutionTags": [],
                "code": "```\\nclass Node:\\n    def __init__(self, count):\\n        self.count = count\\n        self.words = set()\\n        self.next = None\\n        self.prev = None\\n    \\nclass AllOne:\\n    def __init__(self):\\n        self.hm = {}\\n        self.head = Node(0)\\n        self.tail = self.head\\n    \\n    def remove(self, node):\\n        if node == self.head: return\\n        node.prev.next = node.next \\n        if node == self.tail:\\n            self.tail = node.prev \\n        else:\\n            node.next.prev = node.prev \\n    \\n    def inc(self, key: str) -> None:\\n        if key not in self.hm:\\n            self.head.words.add(key)\\n            self.hm[key] = self.head\\n        node = self.hm[key]\\n        if not node.next:\\n            #add new node and remove key from current node word set and add to next\\n            #update hashmap\\n            node.next = Node(node.count + 1)\\n            node.next.prev = node\\n            node.words.remove(key)\\n            self.tail = node.next \\n            self.tail.words.add(key)\\n            self.hm[key] = self.tail\\n        else:\\n            if node.next.count == node.count + 1:\\n                # add new node and remove key from current node word set and add to next\\n                # update hashmap\\n                node.words.remove(key)\\n                node.next.words.add(key)\\n                self.hm[key] = node.next \\n            else:\\n                #add in middle of 2 nodes\\n                #remove from current node word set and add to next\\n                #update hashmap\\n                next_node = node.next \\n                node.next = Node(node.count+1)\\n                node.next.prev = node\\n                node.next.next = next_node\\n                next_node.prev = node.next \\n                node.next.words.add(key)\\n                node.words.remove(key)\\n                self.hm[key] = node.next \\n        if not node.words:\\n            self.remove(node)\\n\\n    def dec(self, key: str) -> None:\\n        node = self.hm[key]\\n        node.words.remove(key)\\n        if node.count == 1:\\n            del self.hm[key]\\n        else:\\n            prev_node = node.prev \\n            if prev_node.count == node.count - 1:\\n                # add new node and remove key from current node word set and add to next\\n                # update hashmap\\n                prev_node.words.add(key)\\n                self.hm[key] = prev_node\\n            else:\\n                #add in middle of 2 nodes\\n                #remove from current node word set and add to next\\n                #update hashmap\\n                node.prev = Node(node.count-1)\\n                node.prev.next = node\\n                node.prev.prev = prev_node\\n                prev_node.next = node.prev\\n                node.prev.words.add(key)\\n                self.hm[key] = node.prev\\n            \\n        if not node.words:\\n            self.remove(node)\\n\\n    def getMaxKey(self) -> str:\\n        if len(self.hm) == 0: return \"\"\\n        el = self.tail.words.pop()\\n        self.tail.words.add(el)\\n        return el\\n\\n    def getMinKey(self) -> str:\\n        if len(self.hm) == 0: return \"\"\\n        first_node = self.head.next \\n        el = first_node.words.pop()\\n        first_node.words.add(el)\\n        return el\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1316748,
                "title": "c-o-1-with-treemap-and-hashmap",
                "content": "```\\nclass AllOne {\\npublic:\\n    /** Initialize your data structure here. */\\n    map<int,list<string>> countMap;   // count -> list of keys\\n    unordered_map<string,list<string>::iterator> kv;   // key -> iterator in countMap\\n    unordered_map<string,int> count;  // key -> current count\\n    AllOne() {\\n        \\n    }\\n    \\n    /** Inserts a new key <Key> with value 1. Or increments an existing key by 1. */\\n    void inc(string key) {\\n        if(!count[key]){\\n            countMap[1].push_back(key);\\n            kv[key] = prev(countMap[1].end());\\n            count[key] = 1;\\n        }else{\\n            update(key,count[key],count[key]+1);\\n        }\\n    }\\n    \\n    /** Decrements an existing key by 1. If Key\\'s value is 1, remove it from the data structure. */\\n    void dec(string key) {\\n        if(!count[key])\\n            return;\\n        update(key,count[key],count[key]-1);\\n    }\\n    \\n    void update(string key, int oldC, int newC){\\n        count[key] = newC;\\n        auto it = kv[key];\\n        countMap[oldC].erase(it);\\n        if(countMap[oldC].size()==0)\\n            countMap.erase(oldC);\\n        if(newC > 0){\\n            countMap[newC].push_back(key);\\n            kv[key] = prev(countMap[newC].end());\\n        }\\n    }\\n    \\n    /** Returns one of the keys with maximal value. */\\n    string getMaxKey() {\\n        if(countMap.empty())\\n            return \"\";\\n        return *(countMap.rbegin()->second.begin());\\n    }\\n    \\n    /** Returns one of the keys with Minimal value. */\\n    string getMinKey() {\\n        if(countMap.empty())\\n            return \"\";\\n        return *(countMap.begin()->second.begin());\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass AllOne {\\npublic:\\n    /** Initialize your data structure here. */\\n    map<int,list<string>> countMap;   // count -> list of keys\\n    unordered_map<string,list<string>::iterator> kv;   // key -> iterator in countMap\\n    unordered_map<string,int> count;  // key -> current count\\n    AllOne() {\\n        \\n    }\\n    \\n    /** Inserts a new key <Key> with value 1. Or increments an existing key by 1. */\\n    void inc(string key) {\\n        if(!count[key]){\\n            countMap[1].push_back(key);\\n            kv[key] = prev(countMap[1].end());\\n            count[key] = 1;\\n        }else{\\n            update(key,count[key],count[key]+1);\\n        }\\n    }\\n    \\n    /** Decrements an existing key by 1. If Key\\'s value is 1, remove it from the data structure. */\\n    void dec(string key) {\\n        if(!count[key])\\n            return;\\n        update(key,count[key],count[key]-1);\\n    }\\n    \\n    void update(string key, int oldC, int newC){\\n        count[key] = newC;\\n        auto it = kv[key];\\n        countMap[oldC].erase(it);\\n        if(countMap[oldC].size()==0)\\n            countMap.erase(oldC);\\n        if(newC > 0){\\n            countMap[newC].push_back(key);\\n            kv[key] = prev(countMap[newC].end());\\n        }\\n    }\\n    \\n    /** Returns one of the keys with maximal value. */\\n    string getMaxKey() {\\n        if(countMap.empty())\\n            return \"\";\\n        return *(countMap.rbegin()->second.begin());\\n    }\\n    \\n    /** Returns one of the keys with Minimal value. */\\n    string getMinKey() {\\n        if(countMap.empty())\\n            return \"\";\\n        return *(countMap.begin()->second.begin());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1316717,
                "title": "c-solution-using-set-and-map",
                "content": "```\\nclass DS{\\n    public:\\n    set<pair<int,string> >st_min;\\n    set<pair<int,string> ,greater<pair<int,string> > >st_max;\\n    unordered_map<string,int>mp;\\n    DS()\\n    {\\n        st_max.clear();\\n        st_min.clear();\\n        mp.clear();\\n    }\\n};\\nclass AllOne {\\npublic:\\n    /** Initialize your data structure here. */\\n    DS ds;\\n    AllOne() \\n    {\\n        ds= DS();\\n    }\\n    \\n    /** Inserts a new key <Key> with value 1. Or increments an existing key by 1. */\\n    void inc(string key)\\n    {\\n         if(ds.mp.find(key)!=ds.mp.end())\\n         {\\n             ds.st_max.erase(ds.st_max.find({ds.mp[key],key}));\\n             ds.st_min.erase(ds.st_min.find({ds.mp[key],key}));\\n         }\\n        ds.mp[key]++;\\n        ds.st_max.insert({ds.mp[key],key});\\n        ds.st_min.insert({ds.mp[key],key});\\n         \\n    }\\n    \\n    /** Decrements an existing key by 1. If Key\\'s value is 1, remove it from the data structure. */\\n    void dec(string key)\\n    {\\n         if(ds.mp.find(key)!=ds.mp.end())\\n         {\\n             ds.st_max.erase(ds.st_max.find({ds.mp[key],key}));\\n              ds.st_min.erase(ds.st_min.find({ds.mp[key],key}));\\n         }\\n        ds.mp[key]--;\\n       if(ds.mp[key]>0)ds.st_max.insert({ds.mp[key],key});\\n        if(ds.mp[key]>0)ds.st_min.insert({ds.mp[key],key});\\n       if(ds.mp[key]==0)ds.mp.erase(key);\\n    }\\n    \\n    /** Returns one of the keys with maximal value. */\\n    string getMaxKey()\\n    {\\n        for(auto x:ds.st_max)\\n        {\\n            return x.second;\\n        }\\n        return \"\";\\n    }\\n    \\n    /** Returns one of the keys with Minimal value. */\\n    string getMinKey() \\n    {\\n        for(auto x:ds.st_min)\\n        {\\n            return x.second;\\n        }\\n        return \"\";\\n    }\\n};\\n\\n/**\\n * Your AllOne object will be instantiated and called as such:\\n * AllOne* obj = new AllOne();\\n * obj->inc(key);\\n * obj->dec(key);\\n * string param_3 = obj->getMaxKey();\\n * string param_4 = obj->getMinKey();\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass DS{\\n    public:\\n    set<pair<int,string> >st_min;\\n    set<pair<int,string> ,greater<pair<int,string> > >st_max;\\n    unordered_map<string,int>mp;\\n    DS()\\n    {\\n        st_max.clear();\\n        st_min.clear();\\n        mp.clear();\\n    }\\n};\\nclass AllOne {\\npublic:\\n    /** Initialize your data structure here. */\\n    DS ds;\\n    AllOne() \\n    {\\n        ds= DS();\\n    }\\n    \\n    /** Inserts a new key <Key> with value 1. Or increments an existing key by 1. */\\n    void inc(string key)\\n    {\\n         if(ds.mp.find(key)!=ds.mp.end())\\n         {\\n             ds.st_max.erase(ds.st_max.find({ds.mp[key],key}));\\n             ds.st_min.erase(ds.st_min.find({ds.mp[key],key}));\\n         }\\n        ds.mp[key]++;\\n        ds.st_max.insert({ds.mp[key],key});\\n        ds.st_min.insert({ds.mp[key],key});\\n         \\n    }\\n    \\n    /** Decrements an existing key by 1. If Key\\'s value is 1, remove it from the data structure. */\\n    void dec(string key)\\n    {\\n         if(ds.mp.find(key)!=ds.mp.end())\\n         {\\n             ds.st_max.erase(ds.st_max.find({ds.mp[key],key}));\\n              ds.st_min.erase(ds.st_min.find({ds.mp[key],key}));\\n         }\\n        ds.mp[key]--;\\n       if(ds.mp[key]>0)ds.st_max.insert({ds.mp[key],key});\\n        if(ds.mp[key]>0)ds.st_min.insert({ds.mp[key],key});\\n       if(ds.mp[key]==0)ds.mp.erase(key);\\n    }\\n    \\n    /** Returns one of the keys with maximal value. */\\n    string getMaxKey()\\n    {\\n        for(auto x:ds.st_max)\\n        {\\n            return x.second;\\n        }\\n        return \"\";\\n    }\\n    \\n    /** Returns one of the keys with Minimal value. */\\n    string getMinKey() \\n    {\\n        for(auto x:ds.st_min)\\n        {\\n            return x.second;\\n        }\\n        return \"\";\\n    }\\n};\\n\\n/**\\n * Your AllOne object will be instantiated and called as such:\\n * AllOne* obj = new AllOne();\\n * obj->inc(key);\\n * obj->dec(key);\\n * string param_3 = obj->getMaxKey();\\n * string param_4 = obj->getMinKey();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1288910,
                "title": "python3-dll-hash-table",
                "content": "\\n```\\nclass ListNode: \\n    \\n    def __init__(self, keys, freq=0, next=None, prev=None):\\n        self.keys = keys\\n        self.freq = freq\\n        self.next = next\\n        self.prev = prev \\n        \\n\\nclass AllOne:\\n\\n    def __init__(self):\\n        self.mp = {}\\n        self.head = ListNode(set())\\n        self.tail = ListNode(set())\\n        self.head.next = self.tail\\n        self.tail.prev = self.head \\n\\n    def inc(self, key: str) -> None:\\n        if key in self.mp: \\n            node = self.mp[key]\\n            node.keys.remove(key)\\n        else: node = self.head \\n        if node.next.freq == node.freq + 1: \\n            self.mp[key] = node.next \\n            node.next.keys.add(key)\\n        else: \\n            newn = ListNode({key}, node.freq+1, next=node.next, prev=node)\\n            node.next.prev = node.next = newn\\n            self.mp[key] = newn\\n        if node != self.head and not node.keys: \\n            node.prev.next = node.next\\n            node.next.prev = node.prev\\n\\n    def dec(self, key: str) -> None:\\n        node = self.mp[key] \\n        node.keys.remove(key)\\n        if node.freq == 1: self.mp.pop(key)\\n        elif node.prev.freq + 1 == node.freq: \\n            node.prev.keys.add(key)\\n            self.mp[key] = node.prev \\n        else: \\n            newn = ListNode({key}, node.freq-1, next=node, prev=node.prev)\\n            node.prev.next = node.prev = newn\\n            self.mp[key] = newn\\n        if not node.keys: \\n            node.prev.next = node.next\\n            node.next.prev = node.prev \\n\\n    def getMaxKey(self) -> str:\\n        if self.tail.prev == self.head: return \"\"\\n        ans = self.tail.prev.keys.pop()\\n        self.tail.prev.keys.add(ans)\\n        return ans \\n\\n    def getMinKey(self) -> str:\\n        if self.head.next == self.tail: return \"\"\\n        ans = self.head.next.keys.pop()\\n        self.head.next.keys.add(ans)\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass ListNode: \\n    \\n    def __init__(self, keys, freq=0, next=None, prev=None):\\n        self.keys = keys\\n        self.freq = freq\\n        self.next = next\\n        self.prev = prev \\n        \\n\\nclass AllOne:\\n\\n    def __init__(self):\\n        self.mp = {}\\n        self.head = ListNode(set())\\n        self.tail = ListNode(set())\\n        self.head.next = self.tail\\n        self.tail.prev = self.head \\n\\n    def inc(self, key: str) -> None:\\n        if key in self.mp: \\n            node = self.mp[key]\\n            node.keys.remove(key)\\n        else: node = self.head \\n        if node.next.freq == node.freq + 1: \\n            self.mp[key] = node.next \\n            node.next.keys.add(key)\\n        else: \\n            newn = ListNode({key}, node.freq+1, next=node.next, prev=node)\\n            node.next.prev = node.next = newn\\n            self.mp[key] = newn\\n        if node != self.head and not node.keys: \\n            node.prev.next = node.next\\n            node.next.prev = node.prev\\n\\n    def dec(self, key: str) -> None:\\n        node = self.mp[key] \\n        node.keys.remove(key)\\n        if node.freq == 1: self.mp.pop(key)\\n        elif node.prev.freq + 1 == node.freq: \\n            node.prev.keys.add(key)\\n            self.mp[key] = node.prev \\n        else: \\n            newn = ListNode({key}, node.freq-1, next=node, prev=node.prev)\\n            node.prev.next = node.prev = newn\\n            self.mp[key] = newn\\n        if not node.keys: \\n            node.prev.next = node.next\\n            node.next.prev = node.prev \\n\\n    def getMaxKey(self) -> str:\\n        if self.tail.prev == self.head: return \"\"\\n        ans = self.tail.prev.keys.pop()\\n        self.tail.prev.keys.add(ans)\\n        return ans \\n\\n    def getMinKey(self) -> str:\\n        if self.head.next == self.tail: return \"\"\\n        ans = self.head.next.keys.pop()\\n        self.head.next.keys.add(ans)\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1238121,
                "title": "python-solution-faster-than-89",
                "content": "* This solution is not O(1) because of using MAX and MIN function. You can add self.min and self.max to record the max and min, and update them when calling \"inc\" and \"dec\", to make this solution O(1).\\n* Since the number of count is usually much smaller than the number of keys, using MAX and MIN function is efficient enough.\\n\\nfrom collections import defaultdict\\nclass AllOne:\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.count = {} # record the count based on the key\\n        self.record = defaultdict(set) # record the key based on the count\\n        return \\n\\n    def inc(self, key: str) -> None:\\n        \"\"\"\\n        Inserts a new key <Key> with value 1. Or increments an existing key by 1.\\n        \"\"\"\\n        self.count[key] = self.count[key]+1 if key in  self.count else 1\\n        self.record[self.count[key]].add(key)\\n        if self.count[key]>1: \\n            self.record[self.count[key]-1].remove(key)\\n            if not self.record[self.count[key]-1]: # delete the count if no key inside \\n                del self.record[self.count[key]-1]\\n        return\\n\\n    def dec(self, key: str) -> None:\\n        \"\"\"\\n        Decrements an existing key by 1. If Key\\'s value is 1, remove it from the data structure.\\n        \"\"\"\\n        self.count[key] = self.count[key]-1\\n        if self.count[key]:\\n            self.record[self.count[key]].add(key)\\n        self.record[self.count[key]+1].remove(key)\\n        \\n        if not self.record[self.count[key]+1]:\\n            del self.record[self.count[key]+1]\\n            \\n        return\\n\\n    def getMaxKey(self) -> str:\\n        \"\"\"\\n        Returns one of the keys with maximal value.\\n        \"\"\"\\n        ma = max(self.record.keys()) if self.record.keys() else 0\\n        return next(iter(self.record[ma])) if ma else \"\"\\n\\n    def getMinKey(self) -> str:\\n        \"\"\"\\n        Returns one of the keys with Minimal value.\\n        \"\"\"\\n        mi = min(self.record.keys()) if self.record.keys() else 0\\n        return next(iter(self.record[mi])) if mi else \"\"",
                "solutionTags": [
                    "Python"
                ],
                "code": "* This solution is not O(1) because of using MAX and MIN function. You can add self.min and self.max to record the max and min, and update them when calling \"inc\" and \"dec\", to make this solution O(1).\\n* Since the number of count is usually much smaller than the number of keys, using MAX and MIN function is efficient enough.\\n\\nfrom collections import defaultdict\\nclass AllOne:\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.count = {} # record the count based on the key\\n        self.record = defaultdict(set) # record the key based on the count\\n        return \\n\\n    def inc(self, key: str) -> None:\\n        \"\"\"\\n        Inserts a new key <Key> with value 1. Or increments an existing key by 1.\\n        \"\"\"\\n        self.count[key] = self.count[key]+1 if key in  self.count else 1\\n        self.record[self.count[key]].add(key)\\n        if self.count[key]>1: \\n            self.record[self.count[key]-1].remove(key)\\n            if not self.record[self.count[key]-1]: # delete the count if no key inside \\n                del self.record[self.count[key]-1]\\n        return\\n\\n    def dec(self, key: str) -> None:\\n        \"\"\"\\n        Decrements an existing key by 1. If Key\\'s value is 1, remove it from the data structure.\\n        \"\"\"\\n        self.count[key] = self.count[key]-1\\n        if self.count[key]:\\n            self.record[self.count[key]].add(key)\\n        self.record[self.count[key]+1].remove(key)\\n        \\n        if not self.record[self.count[key]+1]:\\n            del self.record[self.count[key]+1]\\n            \\n        return\\n\\n    def getMaxKey(self) -> str:\\n        \"\"\"\\n        Returns one of the keys with maximal value.\\n        \"\"\"\\n        ma = max(self.record.keys()) if self.record.keys() else 0\\n        return next(iter(self.record[ma])) if ma else \"\"\\n\\n    def getMinKey(self) -> str:\\n        \"\"\"\\n        Returns one of the keys with Minimal value.\\n        \"\"\"\\n        mi = min(self.record.keys()) if self.record.keys() else 0\\n        return next(iter(self.record[mi])) if mi else \"\"",
                "codeTag": "Java"
            },
            {
                "id": 1176997,
                "title": "typescript-o-1-solution",
                "content": "```\\nclass DNode {\\n    freq: number; // Used as ID for the node. Can\\'t directly compare 2 DNodes\\n    keys: Set<string>;\\n    prev: DNode;\\n    next: DNode;\\n\\n    constructor(freq) {\\n        this.freq = freq;\\n        this.keys = new Set<string>();\\n        this.prev = null;\\n        this.next = null;\\n    }\\n}\\n\\nclass AllOne {\\n    head: DNode;\\n    tail: DNode;\\n    map: Map<string, DNode>;\\n\\n    constructor() {\\n        this.head = null;\\n        this.tail = null;\\n        this.map = new Map<string, DNode>();\\n    }\\n\\n    inc(key: string): void {\\n        if (this.map.has(key)) {\\n            const cur: DNode = this.map.get(key);\\n            cur.keys.delete(key);\\n            if (cur.next) {\\n                if (cur.next.freq === cur.freq + 1) {\\n                    cur.next.keys.add(key);\\n                }\\n                else {\\n                    const tempNext: DNode = cur.next;\\n                    const newNext: DNode = new DNode(cur.freq + 1);\\n                    newNext.keys.add(key);\\n                    cur.next = newNext;\\n                    newNext.prev = cur;\\n                    newNext.next = tempNext;\\n                    tempNext.prev = newNext;\\n                }\\n            }\\n            else {\\n                const next: DNode = new DNode(cur.freq + 1);\\n                next.keys.add(key);\\n                next.prev = cur;\\n                cur.next = next;\\n                if (this.tail.freq === cur.freq) {\\n                    this.tail = next;\\n                }\\n            }\\n            this.map.set(key, cur.next);\\n            if (!cur.keys.size) {\\n                this.removeNode(cur);\\n            }\\n        }\\n        else {\\n            if (this.head) {\\n                if (this.head.freq === 1) {\\n                    this.head.keys.add(key);\\n                }\\n                else {\\n                    const tempHead: DNode = this.head;\\n                    const newHead: DNode = new DNode(1);\\n                    newHead.keys.add(key);\\n                    this.head = newHead;\\n                    newHead.next = tempHead;\\n                    tempHead.prev = newHead;\\n                }\\n            }\\n            else {\\n                this.head = new DNode(1);\\n                this.head.keys.add(key);\\n                this.tail = this.head;\\n            }\\n            this.map.set(key, this.head);\\n        }\\n    }\\n\\n    dec(key: string): void {\\n        // Empty or doesn\\'t exist\\n        if (!this.head || !this.map.has(key)) {\\n            return;\\n        }\\n        const cur: DNode = this.map.get(key);\\n        cur.keys.delete(key);\\n        if (cur.prev) {\\n            if (cur.prev.freq === cur.freq - 1) {\\n                cur.prev.keys.add(key);\\n            }\\n            else {\\n                const tempPrev: DNode = cur.prev;\\n                const newPrev: DNode = new DNode(cur.freq - 1);\\n                newPrev.keys.add(key);\\n                cur.prev = newPrev;\\n                newPrev.next = cur;\\n                newPrev.prev = tempPrev;\\n                tempPrev.prev = newPrev;\\n            }\\n            this.map.set(key, cur.prev);\\n        }\\n        else {\\n            if (cur.freq === 1) {\\n                this.map.delete(key);\\n            }\\n            else {\\n                const newHead: DNode = new DNode(cur.freq - 1);\\n                newHead.keys.add(key);\\n                cur.prev = newHead;\\n                newHead.next = cur;\\n                this.head = newHead;\\n                this.map.set(key, cur.prev);\\n            }\\n        }\\n        if (!cur.keys.size) {\\n            this.removeNode(cur);\\n        }\\n    }\\n\\n    private removeNode(n: DNode): void {\\n        if (n.prev) {\\n            n.prev.next = n.next;\\n        }\\n        if (n.next) {\\n            n.next.prev = n.prev;\\n        }\\n        if (n.freq === this.head.freq) {\\n            this.head = n.next;\\n        }\\n        if (n.freq === this.tail.freq) {\\n            this.tail = n.prev;\\n        }\\n    }\\n\\n    getMaxKey(): string {\\n        if (!this.tail) {\\n            return \\'\\';\\n        }\\n        return this.tail.keys.values().next().value;\\n    }\\n\\n    getMinKey(): string {\\n        if (!this.head) {\\n            return \\'\\';\\n        }\\n        return this.head.keys.values().next().value;\\n    }\\n}\\n```",
                "solutionTags": [
                    "TypeScript",
                    "Doubly-Linked List"
                ],
                "code": "```\\nclass DNode {\\n    freq: number; // Used as ID for the node. Can\\'t directly compare 2 DNodes\\n    keys: Set<string>;\\n    prev: DNode;\\n    next: DNode;\\n\\n    constructor(freq) {\\n        this.freq = freq;\\n        this.keys = new Set<string>();\\n        this.prev = null;\\n        this.next = null;\\n    }\\n}\\n\\nclass AllOne {\\n    head: DNode;\\n    tail: DNode;\\n    map: Map<string, DNode>;\\n\\n    constructor() {\\n        this.head = null;\\n        this.tail = null;\\n        this.map = new Map<string, DNode>();\\n    }\\n\\n    inc(key: string): void {\\n        if (this.map.has(key)) {\\n            const cur: DNode = this.map.get(key);\\n            cur.keys.delete(key);\\n            if (cur.next) {\\n                if (cur.next.freq === cur.freq + 1) {\\n                    cur.next.keys.add(key);\\n                }\\n                else {\\n                    const tempNext: DNode = cur.next;\\n                    const newNext: DNode = new DNode(cur.freq + 1);\\n                    newNext.keys.add(key);\\n                    cur.next = newNext;\\n                    newNext.prev = cur;\\n                    newNext.next = tempNext;\\n                    tempNext.prev = newNext;\\n                }\\n            }\\n            else {\\n                const next: DNode = new DNode(cur.freq + 1);\\n                next.keys.add(key);\\n                next.prev = cur;\\n                cur.next = next;\\n                if (this.tail.freq === cur.freq) {\\n                    this.tail = next;\\n                }\\n            }\\n            this.map.set(key, cur.next);\\n            if (!cur.keys.size) {\\n                this.removeNode(cur);\\n            }\\n        }\\n        else {\\n            if (this.head) {\\n                if (this.head.freq === 1) {\\n                    this.head.keys.add(key);\\n                }\\n                else {\\n                    const tempHead: DNode = this.head;\\n                    const newHead: DNode = new DNode(1);\\n                    newHead.keys.add(key);\\n                    this.head = newHead;\\n                    newHead.next = tempHead;\\n                    tempHead.prev = newHead;\\n                }\\n            }\\n            else {\\n                this.head = new DNode(1);\\n                this.head.keys.add(key);\\n                this.tail = this.head;\\n            }\\n            this.map.set(key, this.head);\\n        }\\n    }\\n\\n    dec(key: string): void {\\n        // Empty or doesn\\'t exist\\n        if (!this.head || !this.map.has(key)) {\\n            return;\\n        }\\n        const cur: DNode = this.map.get(key);\\n        cur.keys.delete(key);\\n        if (cur.prev) {\\n            if (cur.prev.freq === cur.freq - 1) {\\n                cur.prev.keys.add(key);\\n            }\\n            else {\\n                const tempPrev: DNode = cur.prev;\\n                const newPrev: DNode = new DNode(cur.freq - 1);\\n                newPrev.keys.add(key);\\n                cur.prev = newPrev;\\n                newPrev.next = cur;\\n                newPrev.prev = tempPrev;\\n                tempPrev.prev = newPrev;\\n            }\\n            this.map.set(key, cur.prev);\\n        }\\n        else {\\n            if (cur.freq === 1) {\\n                this.map.delete(key);\\n            }\\n            else {\\n                const newHead: DNode = new DNode(cur.freq - 1);\\n                newHead.keys.add(key);\\n                cur.prev = newHead;\\n                newHead.next = cur;\\n                this.head = newHead;\\n                this.map.set(key, cur.prev);\\n            }\\n        }\\n        if (!cur.keys.size) {\\n            this.removeNode(cur);\\n        }\\n    }\\n\\n    private removeNode(n: DNode): void {\\n        if (n.prev) {\\n            n.prev.next = n.next;\\n        }\\n        if (n.next) {\\n            n.next.prev = n.prev;\\n        }\\n        if (n.freq === this.head.freq) {\\n            this.head = n.next;\\n        }\\n        if (n.freq === this.tail.freq) {\\n            this.tail = n.prev;\\n        }\\n    }\\n\\n    getMaxKey(): string {\\n        if (!this.tail) {\\n            return \\'\\';\\n        }\\n        return this.tail.keys.values().next().value;\\n    }\\n\\n    getMinKey(): string {\\n        if (!this.head) {\\n            return \\'\\';\\n        }\\n        return this.head.keys.values().next().value;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1142603,
                "title": "java-o-1-get-o-logn-inc-dec-solution-treemap-hashmap",
                "content": "I prefer more straight forward method, haven\\'t got a chance to review the all O(1) version, below is my solution.\\n```\\nclass AllOne {\\n    Map<String, Integer> map;\\n    TreeMap<Integer, Set<String>> incMap;\\n    TreeMap<Integer, Set<String>> decMap;\\n    /** Initialize your data structure here. */\\n    public AllOne() {\\n        map = new HashMap<>();\\n        incMap = new TreeMap<>();\\n        decMap = new TreeMap<>();\\n    }\\n    \\n    /** Inserts a new key <Key> with value 1. Or increments an existing key by 1. */\\n    public void inc(String key) {\\n        if (!map.containsKey(key)) {\\n            if (!incMap.containsKey(1)) incMap.put(1, new HashSet<>());\\n            if (!decMap.containsKey(-1)) decMap.put(-1, new HashSet<>());\\n            incMap.get(1).add(key);\\n            decMap.get(-1).add(key);\\n            map.put(key, 1);\\n        } else {\\n            int prevFreq = map.get(key);\\n            incMap.get(prevFreq).remove(key);\\n            decMap.get(-prevFreq).remove(key);\\n            if (incMap.get(prevFreq).size() == 0) incMap.remove(prevFreq);\\n            if (decMap.get(-prevFreq).size() == 0) decMap.remove(-prevFreq);\\n            map.put(key, prevFreq + 1);\\n            if (!incMap.containsKey(prevFreq + 1)) incMap.put(prevFreq + 1, new HashSet<>());\\n            if (!decMap.containsKey(-(prevFreq + 1))) decMap.put(-(prevFreq + 1), new HashSet<>());\\n            incMap.get(prevFreq + 1).add(key);\\n            decMap.get(-(prevFreq + 1)).add(key);\\n        }\\n    }\\n    \\n    /** Decrements an existing key by 1. If Key\\'s value is 1, remove it from the data structure. */\\n    public void dec(String key) {\\n        if (!map.containsKey(key)) return;\\n        int prevFreq = map.get(key);\\n        if (prevFreq == 1) {\\n            map.remove(key);\\n            incMap.get(1).remove(key);\\n            decMap.get(-1).remove(key);\\n            if (incMap.get(1).size() == 0) incMap.remove(1);\\n            if (decMap.get(-1).size() == 0) decMap.remove(-1);\\n        } else {\\n            map.put(key, prevFreq - 1);\\n            incMap.get(prevFreq).remove(key);\\n            decMap.get(-prevFreq).remove(key);\\n            if (incMap.get(prevFreq).size() == 0) incMap.remove(prevFreq);\\n            if (decMap.get(-prevFreq).size() == 0) decMap.remove(-prevFreq);\\n            if (!incMap.containsKey(prevFreq - 1)) incMap.put(prevFreq - 1, new HashSet<>());\\n            if (!decMap.containsKey(-prevFreq + 1)) decMap.put(-prevFreq + 1, new HashSet<>());\\n            incMap.get(prevFreq - 1).add(key);\\n            decMap.get(-prevFreq + 1).add(key);\\n        }\\n    }\\n    \\n    /** Returns one of the keys with maximal value. */\\n    public String getMaxKey() {\\n        if (map.size() == 0) return \"\";\\n        return decMap.firstEntry().getValue().iterator().next();\\n    }\\n    \\n    /** Returns one of the keys with Minimal value. */\\n    public String getMinKey() {\\n        if (map.size() == 0) return \"\";\\n        return incMap.firstEntry().getValue().iterator().next();\\n    }\\n}\\n\\n/**\\n * Your AllOne object will be instantiated and called as such:\\n * AllOne obj = new AllOne();\\n * obj.inc(key);\\n * obj.dec(key);\\n * String param_3 = obj.getMaxKey();\\n * String param_4 = obj.getMinKey();\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass AllOne {\\n    Map<String, Integer> map;\\n    TreeMap<Integer, Set<String>> incMap;\\n    TreeMap<Integer, Set<String>> decMap;\\n    /** Initialize your data structure here. */\\n    public AllOne() {\\n        map = new HashMap<>();\\n        incMap = new TreeMap<>();\\n        decMap = new TreeMap<>();\\n    }\\n    \\n    /** Inserts a new key <Key> with value 1. Or increments an existing key by 1. */\\n    public void inc(String key) {\\n        if (!map.containsKey(key)) {\\n            if (!incMap.containsKey(1)) incMap.put(1, new HashSet<>());\\n            if (!decMap.containsKey(-1)) decMap.put(-1, new HashSet<>());\\n            incMap.get(1).add(key);\\n            decMap.get(-1).add(key);\\n            map.put(key, 1);\\n        } else {\\n            int prevFreq = map.get(key);\\n            incMap.get(prevFreq).remove(key);\\n            decMap.get(-prevFreq).remove(key);\\n            if (incMap.get(prevFreq).size() == 0) incMap.remove(prevFreq);\\n            if (decMap.get(-prevFreq).size() == 0) decMap.remove(-prevFreq);\\n            map.put(key, prevFreq + 1);\\n            if (!incMap.containsKey(prevFreq + 1)) incMap.put(prevFreq + 1, new HashSet<>());\\n            if (!decMap.containsKey(-(prevFreq + 1))) decMap.put(-(prevFreq + 1), new HashSet<>());\\n            incMap.get(prevFreq + 1).add(key);\\n            decMap.get(-(prevFreq + 1)).add(key);\\n        }\\n    }\\n    \\n    /** Decrements an existing key by 1. If Key\\'s value is 1, remove it from the data structure. */\\n    public void dec(String key) {\\n        if (!map.containsKey(key)) return;\\n        int prevFreq = map.get(key);\\n        if (prevFreq == 1) {\\n            map.remove(key);\\n            incMap.get(1).remove(key);\\n            decMap.get(-1).remove(key);\\n            if (incMap.get(1).size() == 0) incMap.remove(1);\\n            if (decMap.get(-1).size() == 0) decMap.remove(-1);\\n        } else {\\n            map.put(key, prevFreq - 1);\\n            incMap.get(prevFreq).remove(key);\\n            decMap.get(-prevFreq).remove(key);\\n            if (incMap.get(prevFreq).size() == 0) incMap.remove(prevFreq);\\n            if (decMap.get(-prevFreq).size() == 0) decMap.remove(-prevFreq);\\n            if (!incMap.containsKey(prevFreq - 1)) incMap.put(prevFreq - 1, new HashSet<>());\\n            if (!decMap.containsKey(-prevFreq + 1)) decMap.put(-prevFreq + 1, new HashSet<>());\\n            incMap.get(prevFreq - 1).add(key);\\n            decMap.get(-prevFreq + 1).add(key);\\n        }\\n    }\\n    \\n    /** Returns one of the keys with maximal value. */\\n    public String getMaxKey() {\\n        if (map.size() == 0) return \"\";\\n        return decMap.firstEntry().getValue().iterator().next();\\n    }\\n    \\n    /** Returns one of the keys with Minimal value. */\\n    public String getMinKey() {\\n        if (map.size() == 0) return \"\";\\n        return incMap.firstEntry().getValue().iterator().next();\\n    }\\n}\\n\\n/**\\n * Your AllOne object will be instantiated and called as such:\\n * AllOne obj = new AllOne();\\n * obj.inc(key);\\n * obj.dec(key);\\n * String param_3 = obj.getMaxKey();\\n * String param_4 = obj.getMinKey();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1126436,
                "title": "python-solution",
                "content": "```\\n\\nclass DoublyLinkedList(object):\\n    def __init__(self):\\n        self.set = set()\\n        self.prev = None\\n        self.next = None\\n\\nclass AllOne(object):\\n\\n    def __init__(self):\\n        self.key_counter = {}\\n        self.freq_counter = {}\\n        self.head = DoublyLinkedList()\\n        self.head.set.add(0)\\n        self.tail = DoublyLinkedList()\\n        self.head.next = self.tail\\n        self.tail.prev = self.head\\n        self.freq_counter[0] = self.head\\n        \\n    def insert_after(self, prev_node, key):\\n        node = DoublyLinkedList()\\n        node.set.add(key)\\n        node.next = prev_node.next\\n        prev_node.next = node\\n        node.prev = prev_node\\n        node.next.prev = node\\n        return node\\n    \\n    def insert_before(self, next_node, key):\\n        node= DoublyLinkedList()\\n        node.set.add(key)\\n        node.prev = next_node.prev\\n        node.next = next_node\\n        next_node.prev = node\\n        node.prev.next = node\\n        return node\\n    \\n    def remove(self, node, previous_freq, key):\\n        # print(key, node.set)\\n        node.set.remove(key)\\n        if len(node.set) == 0:\\n            self.freq_counter.pop(previous_freq)\\n            prev_node = node.prev\\n            next_node = node.next\\n            prev_node.next = next_node\\n            next_node.prev = prev_node\\n            \\n    \\n    \\n    def inc(self, key):\\n        if key in self.key_counter:\\n            self.key_counter[key]+=1\\n        else:\\n            self.key_counter[key] = 1\\n        previous_freq = self.key_counter[key] - 1\\n        current_freq = self.key_counter[key]\\n        if current_freq in self.freq_counter:\\n            node = self.freq_counter[current_freq]\\n            node.set.add(key)\\n        else:\\n            node = self.insert_after(self.freq_counter[previous_freq], key)\\n            self.freq_counter[current_freq] = node\\n        if previous_freq > 0:\\n            self.remove(self.freq_counter[previous_freq], previous_freq, key)\\n\\n    def dec(self, key):\\n        if key in self.key_counter:\\n            self.key_counter[key]-=1\\n        else:\\n            return \\n        previous_freq = self.key_counter[key] + 1\\n        current_freq = self.key_counter[key]\\n        \\n        if current_freq == 0:\\n            del self.key_counter[key]\\n        else:\\n            if current_freq in self.freq_counter:\\n                node = self.freq_counter[current_freq]\\n                node.set.add(key)\\n            else:\\n                print(self.freq_counter, previous_freq, key)\\n                node = self.insert_before(self.freq_counter[previous_freq], key)\\n                self.freq_counter[current_freq] = node\\n        self.remove(self.freq_counter[previous_freq], previous_freq, key)\\n            \\n            \\n    def getMaxKey(self):\\n        if self.tail.prev == self.head:\\n            return \"\"\\n        ele = self.tail.prev.set.pop()\\n        self.tail.prev.set.add(ele)\\n        return ele\\n\\n    def getMinKey(self):\\n        if self.head.next == self.tail:\\n            return \"\"\\n        ele = self.head.next.set.pop()\\n        self.head.next.set.add(ele)\\n        return ele\\n\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n\\nclass DoublyLinkedList(object):\\n    def __init__(self):\\n        self.set = set()\\n        self.prev = None\\n        self.next = None\\n\\nclass AllOne(object):\\n\\n    def __init__(self):\\n        self.key_counter = {}\\n        self.freq_counter = {}\\n        self.head = DoublyLinkedList()\\n        self.head.set.add(0)\\n        self.tail = DoublyLinkedList()\\n        self.head.next = self.tail\\n        self.tail.prev = self.head\\n        self.freq_counter[0] = self.head\\n        \\n    def insert_after(self, prev_node, key):\\n        node = DoublyLinkedList()\\n        node.set.add(key)\\n        node.next = prev_node.next\\n        prev_node.next = node\\n        node.prev = prev_node\\n        node.next.prev = node\\n        return node\\n    \\n    def insert_before(self, next_node, key):\\n        node= DoublyLinkedList()\\n        node.set.add(key)\\n        node.prev = next_node.prev\\n        node.next = next_node\\n        next_node.prev = node\\n        node.prev.next = node\\n        return node\\n    \\n    def remove(self, node, previous_freq, key):\\n        # print(key, node.set)\\n        node.set.remove(key)\\n        if len(node.set) == 0:\\n            self.freq_counter.pop(previous_freq)\\n            prev_node = node.prev\\n            next_node = node.next\\n            prev_node.next = next_node\\n            next_node.prev = prev_node\\n            \\n    \\n    \\n    def inc(self, key):\\n        if key in self.key_counter:\\n            self.key_counter[key]+=1\\n        else:\\n            self.key_counter[key] = 1\\n        previous_freq = self.key_counter[key] - 1\\n        current_freq = self.key_counter[key]\\n        if current_freq in self.freq_counter:\\n            node = self.freq_counter[current_freq]\\n            node.set.add(key)\\n        else:\\n            node = self.insert_after(self.freq_counter[previous_freq], key)\\n            self.freq_counter[current_freq] = node\\n        if previous_freq > 0:\\n            self.remove(self.freq_counter[previous_freq], previous_freq, key)\\n\\n    def dec(self, key):\\n        if key in self.key_counter:\\n            self.key_counter[key]-=1\\n        else:\\n            return \\n        previous_freq = self.key_counter[key] + 1\\n        current_freq = self.key_counter[key]\\n        \\n        if current_freq == 0:\\n            del self.key_counter[key]\\n        else:\\n            if current_freq in self.freq_counter:\\n                node = self.freq_counter[current_freq]\\n                node.set.add(key)\\n            else:\\n                print(self.freq_counter, previous_freq, key)\\n                node = self.insert_before(self.freq_counter[previous_freq], key)\\n                self.freq_counter[current_freq] = node\\n        self.remove(self.freq_counter[previous_freq], previous_freq, key)\\n            \\n            \\n    def getMaxKey(self):\\n        if self.tail.prev == self.head:\\n            return \"\"\\n        ele = self.tail.prev.set.pop()\\n        self.tail.prev.set.add(ele)\\n        return ele\\n\\n    def getMinKey(self):\\n        if self.head.next == self.tail:\\n            return \"\"\\n        ele = self.head.next.set.pop()\\n        self.head.next.set.add(ele)\\n        return ele\\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 1103949,
                "title": "java-o1-solution",
                "content": "```java\\nclass AllOne {\\n    \\n    private final static int LEFT = -1, RIGHT = 1;\\n    \\n    private Map<String, Integer> keyToCount;\\n    private Map<Integer, Bucket> countToBucket;\\n    private Bucket head;\\n    private Bucket tail;\\n\\n    /** Initialize your data structure here. */\\n    public AllOne() {\\n        this.keyToCount    = new HashMap<>();\\n        this.countToBucket = new HashMap<>();\\n        this.head = new Bucket(0);\\n        this.tail = new Bucket(-1);\\n        head.next = tail;\\n        tail.prev = head;\\n        this.countToBucket.put(0, head);\\n    }\\n    \\n    /** Inserts a new key <Key> with value 1. Or increments an existing key by 1. */\\n    public void inc(String key) {\\n        if (!keyToCount.containsKey(key)) {\\n            head.addKey(key);\\n            keyToCount.put(key, 0);\\n        }\\n        moveBucket(key, 1);\\n    }\\n    \\n    /** Decrements an existing key by 1. If Key\\'s value is 1, remove it from the data structure. */\\n    public void dec(String key) {\\n        Integer count = keyToCount.get(key);\\n        if (count == null) { // \\u8FD9\\u91CC\\u4E5F\\u53EF\\u4EE5\\u4E0Ddelete\\uFF0C \\u76F4\\u63A5\\u628A\\u6240\\u6709\\u7684\\u90FD\\u7559\\u57280bucket\\u91CC\\u9762 \\uFF0C\\u8FD9\\u6837\\u5C31\\u4E0D\\u9700\\u8981\\u540E\\u9762\\u7684count == 1\\u5224\\u65AD\\u91CC\\u9762\\u4E86\\n            return;\\n        }\\n        if (count == 1) {\\n            keyToCount.remove(key);\\n            Bucket bucket = countToBucket.get(count);\\n            bucket.removeKey(key);\\n            if (bucket.isEmpty()) {\\n                removeBucket(bucket);\\n                countToBucket.remove(count);\\n            }\\n            return;\\n        }\\n        moveBucket(key, -1);\\n    }\\n    \\n    /** Returns one of the keys with maximal value. */\\n    public String getMaxKey() {\\n        if (tail.prev == head) {\\n            return \"\";\\n        }\\n        return tail.prev.peek();\\n    }\\n    \\n    /** Returns one of the keys with Minimal value. */\\n    public String getMinKey() {\\n        if (head.next == tail) {\\n            return \"\";\\n        }\\n        return head.next.peek();\\n    }\\n    \\n    private void moveBucket(String key, int offset) {\\n        int count = keyToCount.get(key);\\n        keyToCount.put(key, count + offset);\\n        Bucket currBucket = countToBucket.get(count);\\n        Bucket nextBucket = countToBucket.get(count + offset);\\n        if (nextBucket == null) {\\n            if (offset == 1) {\\n                nextBucket = appendBucket(currBucket);\\n            } else {\\n                nextBucket = prependBucket(currBucket);\\n            }\\n            countToBucket.put(count + offset, nextBucket);\\n        }\\n        nextBucket.addKey(key);\\n        currBucket.removeKey(key);\\n        if (currBucket.count != 0 && currBucket.isEmpty()) {\\n            removeBucket(currBucket);\\n            countToBucket.remove(count);\\n        }\\n    }\\n    \\n    private Bucket appendBucket(Bucket bucket) {\\n        Bucket curr = new Bucket(bucket.count + 1);\\n        curr.prev = bucket;\\n        curr.next = bucket.next;\\n        bucket.next.prev = curr;\\n        bucket.next = curr;\\n        return curr;\\n    }\\n    \\n    private Bucket prependBucket(Bucket bucket) {\\n        Bucket curr = new Bucket(bucket.count - 1);\\n        curr.prev = bucket.prev;\\n        curr.next = bucket;\\n        bucket.prev.next = curr;\\n        bucket.prev = curr;\\n        return curr;\\n    }\\n    \\n    private void removeBucket(Bucket bucket) {\\n        bucket.prev.next = bucket.next;\\n        bucket.next.prev = bucket.prev;\\n    }\\n    \\n}\\n\\n\\nclass Bucket {\\n    \\n    public Set<String> keys;\\n    public Bucket prev;\\n    public Bucket next;\\n    public int count;\\n    \\n    public Bucket(int count) {\\n        this.count = count;\\n        this.keys = new HashSet<>();\\n    }\\n    \\n    public String peek() {\\n        if (keys.isEmpty()) {\\n            return \"\";\\n        }\\n        return keys.iterator().next();\\n    }\\n    \\n    public void removeKey(String key) {\\n        keys.remove(key);\\n    }\\n    \\n    public void addKey(String key) {\\n        keys.add(key);\\n    }\\n    \\n    public boolean isEmpty() {\\n        return keys.isEmpty();\\n    }\\n}\\n\\n/**\\n * Your AllOne object will be instantiated and called as such:\\n * AllOne obj = new AllOne();\\n * obj.inc(key);\\n * obj.dec(key);\\n * String param_3 = obj.getMaxKey();\\n * String param_4 = obj.getMinKey();\\n */\\n\\n//  a+ a+ b+      d+ d+ i+ s+ i+  d-  a- s+ d-\\n//  i\\n\\n// {a:a$2  d:d$1  i:i$1}\\n//  ^  min\\n//   ^  max\\n//  0    1   2    3     4 5 6 7 8 9\\n// [    b    a        a    ]   arrary of buckte -> array of list ,  (array index, key, prev, next)\\n//          min\\n//          max\\n\\n// (Node) get(key)  -> hashMap\\n// cutDown(Node)\\n// prepend(Node, List)\\n\\n```",
                "solutionTags": [],
                "code": "```java\\nclass AllOne {\\n    \\n    private final static int LEFT = -1, RIGHT = 1;\\n    \\n    private Map<String, Integer> keyToCount;\\n    private Map<Integer, Bucket> countToBucket;\\n    private Bucket head;\\n    private Bucket tail;\\n\\n    /** Initialize your data structure here. */\\n    public AllOne() {\\n        this.keyToCount    = new HashMap<>();\\n        this.countToBucket = new HashMap<>();\\n        this.head = new Bucket(0);\\n        this.tail = new Bucket(-1);\\n        head.next = tail;\\n        tail.prev = head;\\n        this.countToBucket.put(0, head);\\n    }\\n    \\n    /** Inserts a new key <Key> with value 1. Or increments an existing key by 1. */\\n    public void inc(String key) {\\n        if (!keyToCount.containsKey(key)) {\\n            head.addKey(key);\\n            keyToCount.put(key, 0);\\n        }\\n        moveBucket(key, 1);\\n    }\\n    \\n    /** Decrements an existing key by 1. If Key\\'s value is 1, remove it from the data structure. */\\n    public void dec(String key) {\\n        Integer count = keyToCount.get(key);\\n        if (count == null) { // \\u8FD9\\u91CC\\u4E5F\\u53EF\\u4EE5\\u4E0Ddelete\\uFF0C \\u76F4\\u63A5\\u628A\\u6240\\u6709\\u7684\\u90FD\\u7559\\u57280bucket\\u91CC\\u9762 \\uFF0C\\u8FD9\\u6837\\u5C31\\u4E0D\\u9700\\u8981\\u540E\\u9762\\u7684count == 1\\u5224\\u65AD\\u91CC\\u9762\\u4E86\\n            return;\\n        }\\n        if (count == 1) {\\n            keyToCount.remove(key);\\n            Bucket bucket = countToBucket.get(count);\\n            bucket.removeKey(key);\\n            if (bucket.isEmpty()) {\\n                removeBucket(bucket);\\n                countToBucket.remove(count);\\n            }\\n            return;\\n        }\\n        moveBucket(key, -1);\\n    }\\n    \\n    /** Returns one of the keys with maximal value. */\\n    public String getMaxKey() {\\n        if (tail.prev == head) {\\n            return \"\";\\n        }\\n        return tail.prev.peek();\\n    }\\n    \\n    /** Returns one of the keys with Minimal value. */\\n    public String getMinKey() {\\n        if (head.next == tail) {\\n            return \"\";\\n        }\\n        return head.next.peek();\\n    }\\n    \\n    private void moveBucket(String key, int offset) {\\n        int count = keyToCount.get(key);\\n        keyToCount.put(key, count + offset);\\n        Bucket currBucket = countToBucket.get(count);\\n        Bucket nextBucket = countToBucket.get(count + offset);\\n        if (nextBucket == null) {\\n            if (offset == 1) {\\n                nextBucket = appendBucket(currBucket);\\n            } else {\\n                nextBucket = prependBucket(currBucket);\\n            }\\n            countToBucket.put(count + offset, nextBucket);\\n        }\\n        nextBucket.addKey(key);\\n        currBucket.removeKey(key);\\n        if (currBucket.count != 0 && currBucket.isEmpty()) {\\n            removeBucket(currBucket);\\n            countToBucket.remove(count);\\n        }\\n    }\\n    \\n    private Bucket appendBucket(Bucket bucket) {\\n        Bucket curr = new Bucket(bucket.count + 1);\\n        curr.prev = bucket;\\n        curr.next = bucket.next;\\n        bucket.next.prev = curr;\\n        bucket.next = curr;\\n        return curr;\\n    }\\n    \\n    private Bucket prependBucket(Bucket bucket) {\\n        Bucket curr = new Bucket(bucket.count - 1);\\n        curr.prev = bucket.prev;\\n        curr.next = bucket;\\n        bucket.prev.next = curr;\\n        bucket.prev = curr;\\n        return curr;\\n    }\\n    \\n    private void removeBucket(Bucket bucket) {\\n        bucket.prev.next = bucket.next;\\n        bucket.next.prev = bucket.prev;\\n    }\\n    \\n}\\n\\n\\nclass Bucket {\\n    \\n    public Set<String> keys;\\n    public Bucket prev;\\n    public Bucket next;\\n    public int count;\\n    \\n    public Bucket(int count) {\\n        this.count = count;\\n        this.keys = new HashSet<>();\\n    }\\n    \\n    public String peek() {\\n        if (keys.isEmpty()) {\\n            return \"\";\\n        }\\n        return keys.iterator().next();\\n    }\\n    \\n    public void removeKey(String key) {\\n        keys.remove(key);\\n    }\\n    \\n    public void addKey(String key) {\\n        keys.add(key);\\n    }\\n    \\n    public boolean isEmpty() {\\n        return keys.isEmpty();\\n    }\\n}\\n\\n/**\\n * Your AllOne object will be instantiated and called as such:\\n * AllOne obj = new AllOne();\\n * obj.inc(key);\\n * obj.dec(key);\\n * String param_3 = obj.getMaxKey();\\n * String param_4 = obj.getMinKey();\\n */\\n\\n//  a+ a+ b+      d+ d+ i+ s+ i+  d-  a- s+ d-\\n//  i\\n\\n// {a:a$2  d:d$1  i:i$1}\\n//  ^  min\\n//   ^  max\\n//  0    1   2    3     4 5 6 7 8 9\\n// [    b    a        a    ]   arrary of buckte -> array of list ,  (array index, key, prev, next)\\n//          min\\n//          max\\n\\n// (Node) get(key)  -> hashMap\\n// cutDown(Node)\\n// prepend(Node, List)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1100288,
                "title": "c-hashmap-doubly-linked-list",
                "content": "\\nThree key components:\\n\\n1. `keyToVal`: hash map from key to its value.\\n2. `valToKeys`: hash map from value to its associated keys, which are maintained in hash sets.\\n3. `valToList`: hash map from value to a node in a doubly linked list. Items in the list are in ascending order, i.e., tail will be the max value, and head will be the min value. We use a hash map for O(1) find in the list.\\n\\n\\n```\\nclass AllOne {\\npublic:\\n    struct ListNode {\\n        ListNode *prev, *next;\\n        int val;\\n        \\n        ListNode() {}\\n        ListNode(int val): val(val) {}\\n    };\\n    \\n    /** Initialize your data structure here. */\\n    AllOne() {\\n        head = new ListNode();\\n        tail = new ListNode();\\n        connect(head, tail);\\n        // head and tail will always be there.\\n    }\\n    \\n    void remove(ListNode *node) {\\n        assert(node != nullptr);\\n        \\n        ListNode *prev = node->prev;\\n        ListNode *next = node->next;\\n        \\n        connect(prev, next);\\n        \\n        assert(valToList.count(node->val));\\n        assert(valToList[node->val] == node);\\n        assert(valToList.erase(node->val) == 1);\\n        \\n        delete node;\\n    }\\n    \\n    void connect(ListNode *n1, ListNode *n2) {\\n        assert(n1 != nullptr);\\n        assert(n2 != nullptr);\\n        n1->next = n2;\\n        n2->prev = n1;\\n    }\\n    \\n    ListNode *insertAfter(ListNode *node, int val) {\\n        ListNode *curr = new ListNode(val);\\n        ListNode *next = node->next;\\n        \\n        connect(curr, next);\\n        connect(node, curr);\\n        \\n        // We should not replace node.\\n        assert(!valToList.count(val));\\n        valToList[val] = curr;\\n        \\n        return curr;\\n    }\\n    \\n    /** Inserts a new key <Key> with value 1. Or increments an existing key by 1. */\\n    void inc(string key) {\\n        if (keyToVal.count(key)) {\\n            int oldVal = keyToVal[key];\\n            int newVal = oldVal + 1;\\n            // UPDATE: keyToVal\\n            keyToVal[key] ++;\\n            \\n            assert(valToKeys.count(oldVal));\\n            assert(valToKeys[oldVal].count(key));\\n\\n            // UPDATE: valToKeys\\n            valToKeys[oldVal].erase(key);\\n            if (valToKeys[oldVal].empty())\\n                valToKeys.erase(oldVal);\\n            valToKeys[newVal].insert(key);\\n            \\n            // UPDATE: valToList\\n            bool toDeleteOldNode = !valToKeys.count(oldVal);\\n            bool toInsertNewNode = valToKeys[newVal].size() == 1;\\n            \\n            assert(valToList.count(oldVal));\\n            ListNode *oldNode = valToList[oldVal];\\n            \\n            if (toInsertNewNode) insertAfter(oldNode, newVal);\\n            if (toDeleteOldNode) remove(oldNode);\\n        } else {\\n            // UPDATE: keyToVal\\n            keyToVal[key] = 1;\\n            \\n            // UPDATE: valToKeys\\n            valToKeys[1].insert(key);\\n            \\n            // UPDATE: valToList;\\n            if (valToKeys[1].size() == 1)\\n                insertAfter(head, 1);\\n        }\\n    }\\n    \\n    /** Decrements an existing key by 1. If Key\\'s value is 1, remove it from the data structure. */\\n    void dec(string key) {\\n        if (!keyToVal.count(key))\\n            return;\\n        \\n        int oldVal = keyToVal[key];\\n        if (oldVal == 1) {\\n            // UPDATE: keyToVal\\n            assert(keyToVal.erase(key) == 1);\\n            \\n            // UPDATE: valToKeys\\n            assert(valToKeys[1].erase(key) == 1);\\n            if (valToKeys[1].empty())\\n                valToKeys.erase(1);\\n            \\n            // UPDATE: valToLists\\n            if (!valToKeys.count(1))\\n                remove(valToList[1]);\\n        } else {\\n            // UPDATE: keyToVal\\n            keyToVal[key] --;\\n            \\n            // UPDATE: valToKeys\\n            assert(valToKeys[oldVal].erase(key) == 1);\\n            if (valToKeys[oldVal].empty())\\n                valToKeys.erase(oldVal);\\n            valToKeys[keyToVal[key]].insert(key);\\n        \\n            // UPDATE: valToList\\n            int newVal = keyToVal[key];\\n            if (valToKeys[newVal].size() == 1) insertAfter(valToList[oldVal]->prev, newVal);\\n            if (!valToKeys.count(oldVal)) remove(valToList[oldVal]);\\n        }   \\n    }\\n    \\n    /** Returns one of the keys with maximal value. */\\n    string getMaxKey() {\\n        if (keyToVal.empty())\\n            return \"\";\\n        return *valToKeys[tail->prev->val].begin();\\n    }\\n    \\n    /** Returns one of the keys with Minimal value. */\\n    string getMinKey() {\\n        if (keyToVal.empty())\\n            return \"\";\\n        return *valToKeys[head->next->val].begin();\\n    }\\n    \\n    unordered_map<string, int> keyToVal;\\n    unordered_map<int, unordered_set<string>> valToKeys;\\n    unordered_map<int, ListNode *> valToList;\\n    ListNode *head, *tail;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass AllOne {\\npublic:\\n    struct ListNode {\\n        ListNode *prev, *next;\\n        int val;\\n        \\n        ListNode() {}\\n        ListNode(int val): val(val) {}\\n    };\\n    \\n    /** Initialize your data structure here. */\\n    AllOne() {\\n        head = new ListNode();\\n        tail = new ListNode();\\n        connect(head, tail);\\n        // head and tail will always be there.\\n    }\\n    \\n    void remove(ListNode *node) {\\n        assert(node != nullptr);\\n        \\n        ListNode *prev = node->prev;\\n        ListNode *next = node->next;\\n        \\n        connect(prev, next);\\n        \\n        assert(valToList.count(node->val));\\n        assert(valToList[node->val] == node);\\n        assert(valToList.erase(node->val) == 1);\\n        \\n        delete node;\\n    }\\n    \\n    void connect(ListNode *n1, ListNode *n2) {\\n        assert(n1 != nullptr);\\n        assert(n2 != nullptr);\\n        n1->next = n2;\\n        n2->prev = n1;\\n    }\\n    \\n    ListNode *insertAfter(ListNode *node, int val) {\\n        ListNode *curr = new ListNode(val);\\n        ListNode *next = node->next;\\n        \\n        connect(curr, next);\\n        connect(node, curr);\\n        \\n        // We should not replace node.\\n        assert(!valToList.count(val));\\n        valToList[val] = curr;\\n        \\n        return curr;\\n    }\\n    \\n    /** Inserts a new key <Key> with value 1. Or increments an existing key by 1. */\\n    void inc(string key) {\\n        if (keyToVal.count(key)) {\\n            int oldVal = keyToVal[key];\\n            int newVal = oldVal + 1;\\n            // UPDATE: keyToVal\\n            keyToVal[key] ++;\\n            \\n            assert(valToKeys.count(oldVal));\\n            assert(valToKeys[oldVal].count(key));\\n\\n            // UPDATE: valToKeys\\n            valToKeys[oldVal].erase(key);\\n            if (valToKeys[oldVal].empty())\\n                valToKeys.erase(oldVal);\\n            valToKeys[newVal].insert(key);\\n            \\n            // UPDATE: valToList\\n            bool toDeleteOldNode = !valToKeys.count(oldVal);\\n            bool toInsertNewNode = valToKeys[newVal].size() == 1;\\n            \\n            assert(valToList.count(oldVal));\\n            ListNode *oldNode = valToList[oldVal];\\n            \\n            if (toInsertNewNode) insertAfter(oldNode, newVal);\\n            if (toDeleteOldNode) remove(oldNode);\\n        } else {\\n            // UPDATE: keyToVal\\n            keyToVal[key] = 1;\\n            \\n            // UPDATE: valToKeys\\n            valToKeys[1].insert(key);\\n            \\n            // UPDATE: valToList;\\n            if (valToKeys[1].size() == 1)\\n                insertAfter(head, 1);\\n        }\\n    }\\n    \\n    /** Decrements an existing key by 1. If Key\\'s value is 1, remove it from the data structure. */\\n    void dec(string key) {\\n        if (!keyToVal.count(key))\\n            return;\\n        \\n        int oldVal = keyToVal[key];\\n        if (oldVal == 1) {\\n            // UPDATE: keyToVal\\n            assert(keyToVal.erase(key) == 1);\\n            \\n            // UPDATE: valToKeys\\n            assert(valToKeys[1].erase(key) == 1);\\n            if (valToKeys[1].empty())\\n                valToKeys.erase(1);\\n            \\n            // UPDATE: valToLists\\n            if (!valToKeys.count(1))\\n                remove(valToList[1]);\\n        } else {\\n            // UPDATE: keyToVal\\n            keyToVal[key] --;\\n            \\n            // UPDATE: valToKeys\\n            assert(valToKeys[oldVal].erase(key) == 1);\\n            if (valToKeys[oldVal].empty())\\n                valToKeys.erase(oldVal);\\n            valToKeys[keyToVal[key]].insert(key);\\n        \\n            // UPDATE: valToList\\n            int newVal = keyToVal[key];\\n            if (valToKeys[newVal].size() == 1) insertAfter(valToList[oldVal]->prev, newVal);\\n            if (!valToKeys.count(oldVal)) remove(valToList[oldVal]);\\n        }   \\n    }\\n    \\n    /** Returns one of the keys with maximal value. */\\n    string getMaxKey() {\\n        if (keyToVal.empty())\\n            return \"\";\\n        return *valToKeys[tail->prev->val].begin();\\n    }\\n    \\n    /** Returns one of the keys with Minimal value. */\\n    string getMinKey() {\\n        if (keyToVal.empty())\\n            return \"\";\\n        return *valToKeys[head->next->val].begin();\\n    }\\n    \\n    unordered_map<string, int> keyToVal;\\n    unordered_map<int, unordered_set<string>> valToKeys;\\n    unordered_map<int, ListNode *> valToList;\\n    ListNode *head, *tail;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1083338,
                "title": "c-o-1-hard-to-understand-but-structure-is-easy",
                "content": "```\\nclass AllOne {\\npublic:\\n    /** Initialize your data structure here. */\\n    AllOne() {\\n\\n    }\\n    \\n    /** Inserts a new key <Key> with value 1. Or increments an existing key by 1. */\\n    void inc(string key) {\\n        if (!key_to_node.count(key)) {\\n            Bucket new_bucket;\\n            new_bucket.val = 0;\\n            new_bucket.keys.insert(key);\\n            buckets.push_front(new_bucket);\\n            key_to_node[key] = buckets.begin();\\n        }\\n        auto bucket = key_to_node[key];\\n        auto next = std::next(bucket);\\n        int val = bucket->val;\\n        if (next == buckets.end() || next->val > val + 1) {\\n            Bucket new_bucket;\\n            new_bucket.val = val + 1;\\n            new_bucket.keys.insert(key);\\n            buckets.insert(next, new_bucket);\\n        } else {\\n            next->keys.insert(key);\\n        }\\n        key_to_node[key] = std::next(bucket);\\n        bucket->keys.erase(key);\\n        if (bucket->keys.empty()) {\\n            buckets.erase(bucket);\\n        }\\n    }\\n    \\n    /** Decrements an existing key by 1. If Key\\'s value is 1, remove it from the data structure. */\\n    void dec(string key) {\\n        if (!key_to_node.count(key)) return;\\n        auto bucket = key_to_node[key];\\n        auto pre = prev(bucket);\\n        int val = bucket->val;\\n        if (val == 1) {  \\n            key_to_node.erase(key);\\n            bucket->keys.erase(key);\\n            if (bucket->keys.empty()) {\\n                buckets.erase(bucket);\\n            }\\n            return;\\n        } else if (bucket == buckets.begin() || pre->val < val - 1) {\\n            Bucket new_bucket;\\n            new_bucket.val = val - 1;\\n            new_bucket.keys.insert(key);\\n            buckets.insert(bucket, new_bucket);\\n        } else {\\n            pre->keys.insert(key);\\n        }\\n        key_to_node[key] = prev(bucket);\\n        bucket->keys.erase(key);\\n        if (bucket->keys.empty()) {\\n            buckets.erase(bucket);\\n        }\\n    }\\n    \\n    /** Returns one of the keys with maximal value. */\\n    string getMaxKey() {\\n        if (buckets.empty()) return \"\";\\n        return *buckets.back().keys.begin();\\n    }\\n    \\n    /** Returns one of the keys with Minimal value. */\\n    string getMinKey() {\\n        if (buckets.empty()) return \"\";\\n        return *buckets.front().keys.begin();\\n    }\\n    struct Bucket {\\n        int val;\\n        unordered_set<string> keys;\\n    };\\n    list<Bucket> buckets;  // increasing order\\n    unordered_map<string, list<Bucket>::iterator> key_to_node;\\n};\\n ```",
                "solutionTags": [],
                "code": "```\\nclass AllOne {\\npublic:\\n    /** Initialize your data structure here. */\\n    AllOne() {\\n\\n    }\\n    \\n    /** Inserts a new key <Key> with value 1. Or increments an existing key by 1. */\\n    void inc(string key) {\\n        if (!key_to_node.count(key)) {\\n            Bucket new_bucket;\\n            new_bucket.val = 0;\\n            new_bucket.keys.insert(key);\\n            buckets.push_front(new_bucket);\\n            key_to_node[key] = buckets.begin();\\n        }\\n        auto bucket = key_to_node[key];\\n        auto next = std::next(bucket);\\n        int val = bucket->val;\\n        if (next == buckets.end() || next->val > val + 1) {\\n            Bucket new_bucket;\\n            new_bucket.val = val + 1;\\n            new_bucket.keys.insert(key);\\n            buckets.insert(next, new_bucket);\\n        } else {\\n            next->keys.insert(key);\\n        }\\n        key_to_node[key] = std::next(bucket);\\n        bucket->keys.erase(key);\\n        if (bucket->keys.empty()) {\\n            buckets.erase(bucket);\\n        }\\n    }\\n    \\n    /** Decrements an existing key by 1. If Key\\'s value is 1, remove it from the data structure. */\\n    void dec(string key) {\\n        if (!key_to_node.count(key)) return;\\n        auto bucket = key_to_node[key];\\n        auto pre = prev(bucket);\\n        int val = bucket->val;\\n        if (val == 1) {  \\n            key_to_node.erase(key);\\n            bucket->keys.erase(key);\\n            if (bucket->keys.empty()) {\\n                buckets.erase(bucket);\\n            }\\n            return;\\n        } else if (bucket == buckets.begin() || pre->val < val - 1) {\\n            Bucket new_bucket;\\n            new_bucket.val = val - 1;\\n            new_bucket.keys.insert(key);\\n            buckets.insert(bucket, new_bucket);\\n        } else {\\n            pre->keys.insert(key);\\n        }\\n        key_to_node[key] = prev(bucket);\\n        bucket->keys.erase(key);\\n        if (bucket->keys.empty()) {\\n            buckets.erase(bucket);\\n        }\\n    }\\n    \\n    /** Returns one of the keys with maximal value. */\\n    string getMaxKey() {\\n        if (buckets.empty()) return \"\";\\n        return *buckets.back().keys.begin();\\n    }\\n    \\n    /** Returns one of the keys with Minimal value. */\\n    string getMinKey() {\\n        if (buckets.empty()) return \"\";\\n        return *buckets.front().keys.begin();\\n    }\\n    struct Bucket {\\n        int val;\\n        unordered_set<string> keys;\\n    };\\n    list<Bucket> buckets;  // increasing order\\n    unordered_map<string, list<Bucket>::iterator> key_to_node;\\n};\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 1075768,
                "title": "java-hashmap-dll-all-o-1",
                "content": "**Idea -**\\n* Use HashMap to keep track of Node for each key \\n* Node contains set of *keys* and *val* - representing value for the keys \\n* Dummy Head and Tail with *val = -1* \\n* Remember to remove node if it have empty set of *keys*\\n* Or Add a new node if its *val* is not present in DLL\\n\\n``` \\nclass AllOne {\\n    Map<String, Node> map = new HashMap<>();\\n    \\n    class Node {\\n        Set<String> keys = new HashSet<>();\\n        Node prev = null, next = null;\\n        int val;\\n        public Node(int val) {\\n            this.val = val;\\n        }\\n    }\\n    \\n    Node head = new Node(-1), tail = new Node(-1);\\n    /** Initialize your data structure here. */\\n    public AllOne() {\\n        head.next = tail;\\n        tail.prev = head;\\n    }\\n    \\n    /** Inserts a new key <Key> with value 1. Or increments an existing key by 1. */\\n    public void inc(String key) {\\n        if(!map.containsKey(key)) {\\n            if(head.next.val != 1) addNextNode(head, 1);  /// Node Not Present\\n            map.put(key, head.next);\\n            head.next.keys.add(key);\\n        } else { // contains key\\n            Node curr = map.get(key);\\n            if(curr.next.val != curr.val + 1) addNextNode(curr, curr.val + 1); /// Node not present\\n            Node currNext = curr.next;\\n            currNext.keys.add(key);\\n            map.put(key, currNext);\\n            \\n            /// Remove old ones\\n            curr.keys.remove(key);\\n            if(curr.keys.isEmpty()) removeNode(curr);\\n        }\\n    }\\n    \\n    /** Decrements an existing key by 1. If Key\\'s value is 1, remove it from the data structure. */\\n    public void dec(String key) {\\n        if(map.containsKey(key)) {\\n            Node oldVal = map.get(key);\\n            oldVal.keys.remove(key);\\n            if(oldVal.val == 1) {\\n                map.remove(key);\\n            } else {\\n                Node oldPrev = oldVal.prev;\\n                if(oldPrev.val != oldVal.val - 1) addNextNode(oldPrev, oldVal.val - 1); /// Node Not Present\\n                oldVal.prev.keys.add(key);\\n                map.put(key, oldVal.prev);\\n            }\\n            /// Remove if Empty Keys\\n            if(oldVal.keys.isEmpty()) removeNode(oldVal);\\n        }\\n    }\\n    \\n    /** Returns one of the keys with maximal value. */\\n    public String getMaxKey() {\\n        Node tailPrev = tail.prev;\\n        if(tailPrev.keys.size() == 0) return \"\";\\n        return tailPrev.keys.iterator().next();\\n    }\\n    \\n    /** Returns one of the keys with Minimal value. */\\n    public String getMinKey() {\\n        Node headNext = head.next;\\n        if(headNext.keys.size() == 0) return \"\";\\n        return headNext.keys.iterator().next();\\n    }\\n    \\n    /// Remove this curr node\\n    private void removeNode(Node curr) {\\n        Node pre = curr.prev;\\n        Node next = curr.next;\\n        pre.next = next;\\n        next.prev = pre;\\n    }\\n    \\n\\t/// Add the Node next to curr node passed as an argument\\n    private void addNextNode(Node curr, int val) {\\n        Node currNext = curr.next;\\n        Node node = new Node(val);\\n        node.next = currNext;\\n        currNext.prev = node;\\n        node.prev = curr;\\n        curr.next = node;\\n    }\\n}",
                "solutionTags": [],
                "code": "**Idea -**\\n* Use HashMap to keep track of Node for each key \\n* Node contains set of *keys* and *val* - representing value for the keys \\n* Dummy Head and Tail with *val = -1* \\n* Remember to remove node if it have empty set of *keys*\\n* Or Add a new node if its *val* is not present in DLL\\n\\n``` \\nclass AllOne {\\n    Map<String, Node> map = new HashMap<>();\\n    \\n    class Node {\\n        Set<String> keys = new HashSet<>();\\n        Node prev = null, next = null;\\n        int val;\\n        public Node(int val) {\\n            this.val = val;\\n        }\\n    }\\n    \\n    Node head = new Node(-1), tail = new Node(-1);\\n    /** Initialize your data structure here. */\\n    public AllOne() {\\n        head.next = tail;\\n        tail.prev = head;\\n    }\\n    \\n    /** Inserts a new key <Key> with value 1. Or increments an existing key by 1. */\\n    public void inc(String key) {\\n        if(!map.containsKey(key)) {\\n            if(head.next.val != 1) addNextNode(head, 1);  /// Node Not Present\\n            map.put(key, head.next);\\n            head.next.keys.add(key);\\n        } else { // contains key\\n            Node curr = map.get(key);\\n            if(curr.next.val != curr.val + 1) addNextNode(curr, curr.val + 1); /// Node not present\\n            Node currNext = curr.next;\\n            currNext.keys.add(key);\\n            map.put(key, currNext);\\n            \\n            /// Remove old ones\\n            curr.keys.remove(key);\\n            if(curr.keys.isEmpty()) removeNode(curr);\\n        }\\n    }\\n    \\n    /** Decrements an existing key by 1. If Key\\'s value is 1, remove it from the data structure. */\\n    public void dec(String key) {\\n        if(map.containsKey(key)) {\\n            Node oldVal = map.get(key);\\n            oldVal.keys.remove(key);\\n            if(oldVal.val == 1) {\\n                map.remove(key);\\n            } else {\\n                Node oldPrev = oldVal.prev;\\n                if(oldPrev.val != oldVal.val - 1) addNextNode(oldPrev, oldVal.val - 1); /// Node Not Present\\n                oldVal.prev.keys.add(key);\\n                map.put(key, oldVal.prev);\\n            }\\n            /// Remove if Empty Keys\\n            if(oldVal.keys.isEmpty()) removeNode(oldVal);\\n        }\\n    }\\n    \\n    /** Returns one of the keys with maximal value. */\\n    public String getMaxKey() {\\n        Node tailPrev = tail.prev;\\n        if(tailPrev.keys.size() == 0) return \"\";\\n        return tailPrev.keys.iterator().next();\\n    }\\n    \\n    /** Returns one of the keys with Minimal value. */\\n    public String getMinKey() {\\n        Node headNext = head.next;\\n        if(headNext.keys.size() == 0) return \"\";\\n        return headNext.keys.iterator().next();\\n    }\\n    \\n    /// Remove this curr node\\n    private void removeNode(Node curr) {\\n        Node pre = curr.prev;\\n        Node next = curr.next;\\n        pre.next = next;\\n        next.prev = pre;\\n    }\\n    \\n\\t/// Add the Node next to curr node passed as an argument\\n    private void addNextNode(Node curr, int val) {\\n        Node currNext = curr.next;\\n        Node node = new Node(val);\\n        node.next = currNext;\\n        currNext.prev = node;\\n        node.prev = curr;\\n        curr.next = node;\\n    }\\n}",
                "codeTag": "Java"
            },
            {
                "id": 1034347,
                "title": "c-solution-using-doubly-linked-list-and-hashmap",
                "content": "```\\nclass AllOne {\\npublic:\\n    /** Initialize your data structure here. */\\n    struct Node{\\n        int val;\\n        unordered_set<string>keys;\\n    };\\n    list<Node>l;\\n    unordered_map<string,list<Node>::iterator>m;\\n    // Remove from old node.\\n    void remove(list<Node>::iterator it, const string& key) {\\n        it->keys.erase(key);\\n        if (it->keys.empty())\\n          l.erase(it);\\n    }\\n    AllOne() {\\n        \\n    }\\n    \\n    /** Inserts a new key <Key> with value 1. Or increments an existing key by 1. */\\n    void inc(string key) {\\n        auto it = m.find(key);\\n        if(it==m.end()){\\n            if(l.empty() || l.front().val!=1)\\n                l.push_front({1,{key}});\\n            else\\n                l.front().keys.insert(key);\\n            m[key] = l.begin();\\n        }\\n        else{\\n            auto lit = it->second;\\n            auto nit = next(lit);\\n            int value = lit->val;\\n            if(nit==l.end() || nit->val!=value+1)\\n                nit = l.insert(nit,{value+1,{}});\\n            nit->keys.insert(key);\\n            m[key] = nit;\\n            remove(lit,key);\\n        }\\n    }\\n    \\n    /** Decrements an existing key by 1. If Key\\'s value is 1, remove it from the data structure. */\\n    void dec(string key) {\\n        auto it = m.find(key);\\n        if(it==m.end())return;\\n        auto lit = it->second;\\n        int value = lit->val;\\n        if(value>1){\\n            auto pit = prev(lit);\\n            if(lit==l.begin() || pit->val!=value-1)\\n                pit= l.insert(lit,{value-1,{key}});\\n            pit->keys.insert(key);\\n            m[key] = pit;\\n        }\\n        else{\\n            m.erase(key);\\n        }\\n        remove(lit,key);\\n    }\\n    \\n    \\n    /** Returns one of the keys with maximal value. */\\n    string getMaxKey() {\\n        return l.empty() ? \"\" : *l.back().keys.cbegin();\\n    }\\n    \\n    /** Returns one of the keys with Minimal value. */\\n    string getMinKey() {\\n        return l.empty() ? \"\" : *l.front().keys.cbegin();\\n    }\\n};\\n\\n/**\\n * Your AllOne object will be instantiated and called as such:\\n * AllOne* obj = new AllOne();\\n * obj->inc(key);\\n * obj->dec(key);\\n * string param_3 = obj->getMaxKey();\\n * string param_4 = obj->getMinKey();\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass AllOne {\\npublic:\\n    /** Initialize your data structure here. */\\n    struct Node{\\n        int val;\\n        unordered_set<string>keys;\\n    };\\n    list<Node>l;\\n    unordered_map<string,list<Node>::iterator>m;\\n    // Remove from old node.\\n    void remove(list<Node>::iterator it, const string& key) {\\n        it->keys.erase(key);\\n        if (it->keys.empty())\\n          l.erase(it);\\n    }\\n    AllOne() {\\n        \\n    }\\n    \\n    /** Inserts a new key <Key> with value 1. Or increments an existing key by 1. */\\n    void inc(string key) {\\n        auto it = m.find(key);\\n        if(it==m.end()){\\n            if(l.empty() || l.front().val!=1)\\n                l.push_front({1,{key}});\\n            else\\n                l.front().keys.insert(key);\\n            m[key] = l.begin();\\n        }\\n        else{\\n            auto lit = it->second;\\n            auto nit = next(lit);\\n            int value = lit->val;\\n            if(nit==l.end() || nit->val!=value+1)\\n                nit = l.insert(nit,{value+1,{}});\\n            nit->keys.insert(key);\\n            m[key] = nit;\\n            remove(lit,key);\\n        }\\n    }\\n    \\n    /** Decrements an existing key by 1. If Key\\'s value is 1, remove it from the data structure. */\\n    void dec(string key) {\\n        auto it = m.find(key);\\n        if(it==m.end())return;\\n        auto lit = it->second;\\n        int value = lit->val;\\n        if(value>1){\\n            auto pit = prev(lit);\\n            if(lit==l.begin() || pit->val!=value-1)\\n                pit= l.insert(lit,{value-1,{key}});\\n            pit->keys.insert(key);\\n            m[key] = pit;\\n        }\\n        else{\\n            m.erase(key);\\n        }\\n        remove(lit,key);\\n    }\\n    \\n    \\n    /** Returns one of the keys with maximal value. */\\n    string getMaxKey() {\\n        return l.empty() ? \"\" : *l.back().keys.cbegin();\\n    }\\n    \\n    /** Returns one of the keys with Minimal value. */\\n    string getMinKey() {\\n        return l.empty() ? \"\" : *l.front().keys.cbegin();\\n    }\\n};\\n\\n/**\\n * Your AllOne object will be instantiated and called as such:\\n * AllOne* obj = new AllOne();\\n * obj->inc(key);\\n * obj->dec(key);\\n * string param_3 = obj->getMaxKey();\\n * string param_4 = obj->getMinKey();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 965715,
                "title": "python-hashmap-deque-short-and-easy-to-understand",
                "content": "Use a Counter `counts` to record the counts of keys. `{key : v}`.\\nA dictionay of set to `vals`  record `{v : set(key)}`.\\nA deque `dq` to record `counts`.\\nMax value and Min value will only be changed when we do `dec` or `inc`.\\nso just update `vals` and `dq` we do the call `dec` or `inc` with the function `_insert` and `_delete`\\n\\n```python\\nfrom collections import Counter, defaultdict, deque\\nclass AllOne:\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.counts = Counter()\\n        self.vals = defaultdict(set)\\n        self.dq = deque([])\\n\\n    def _insert(self, key, val):\\n        if val > 0:\\n            self.vals[val].add(key)\\n            if not self.dq:\\n                self.dq.append(val)\\n            elif val > self.dq[-1]:\\n                self.dq.append(val)\\n            elif val < self.dq[0]:\\n                self.dq.appendleft(val)\\n\\n    def _delete(self, key, val):\\n        if val in self.vals and key in self.vals[val]:\\n            self.vals[val].remove(key)\\n        while self.dq and not self.vals[self.dq[-1]]:\\n            self.dq.pop()\\n        while self.dq and not self.vals[self.dq[0]]:\\n            self.dq.popleft()\\n\\n    def inc(self, key: str) -> None:\\n        \"\"\"\\n        Inserts a new key <Key> with value 1. Or increments an existing key by 1.\\n        \"\"\"\\n        pre_v = self.counts[key]\\n        v = pre_v + 1\\n        self.counts[key] = v\\n        self._delete(key, pre_v)\\n        self._insert(key, v)\\n\\n    def dec(self, key: str) -> None:\\n        \"\"\"\\n        Decrements an existing key by 1. If Key\\'s value is 1, remove it from the data structure.\\n        \"\"\"\\n        if key in self.counts:\\n            pre_v = self.counts[key]\\n            v = pre_v - 1\\n            self.counts[key] = v\\n            self._delete(key, pre_v)\\n            self._insert(key, v)\\n\\n    def getMaxKey(self) -> str:\\n        \"\"\"\\n        Returns one of the keys with maximal value.\\n        \"\"\"\\n        if not self.dq:\\n            return \\'\\'\\n        v = self.dq[-1]\\n        key = self.vals[v].pop()\\n        self.vals[v].add(key)\\n        return key\\n\\n    def getMinKey(self) -> str:\\n        \"\"\"\\n        Returns one of the keys with Minimal value.\\n        \"\"\"\\n        if not self.dq:\\n            return \\'\\'\\n        v = self.dq[0]\\n        key = self.vals[v].pop()\\n        self.vals[v].add(key)\\n        return key\\n```",
                "solutionTags": [],
                "code": "```python\\nfrom collections import Counter, defaultdict, deque\\nclass AllOne:\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.counts = Counter()\\n        self.vals = defaultdict(set)\\n        self.dq = deque([])\\n\\n    def _insert(self, key, val):\\n        if val > 0:\\n            self.vals[val].add(key)\\n            if not self.dq:\\n                self.dq.append(val)\\n            elif val > self.dq[-1]:\\n                self.dq.append(val)\\n            elif val < self.dq[0]:\\n                self.dq.appendleft(val)\\n\\n    def _delete(self, key, val):\\n        if val in self.vals and key in self.vals[val]:\\n            self.vals[val].remove(key)\\n        while self.dq and not self.vals[self.dq[-1]]:\\n            self.dq.pop()\\n        while self.dq and not self.vals[self.dq[0]]:\\n            self.dq.popleft()\\n\\n    def inc(self, key: str) -> None:\\n        \"\"\"\\n        Inserts a new key <Key> with value 1. Or increments an existing key by 1.\\n        \"\"\"\\n        pre_v = self.counts[key]\\n        v = pre_v + 1\\n        self.counts[key] = v\\n        self._delete(key, pre_v)\\n        self._insert(key, v)\\n\\n    def dec(self, key: str) -> None:\\n        \"\"\"\\n        Decrements an existing key by 1. If Key\\'s value is 1, remove it from the data structure.\\n        \"\"\"\\n        if key in self.counts:\\n            pre_v = self.counts[key]\\n            v = pre_v - 1\\n            self.counts[key] = v\\n            self._delete(key, pre_v)\\n            self._insert(key, v)\\n\\n    def getMaxKey(self) -> str:\\n        \"\"\"\\n        Returns one of the keys with maximal value.\\n        \"\"\"\\n        if not self.dq:\\n            return \\'\\'\\n        v = self.dq[-1]\\n        key = self.vals[v].pop()\\n        self.vals[v].add(key)\\n        return key\\n\\n    def getMinKey(self) -> str:\\n        \"\"\"\\n        Returns one of the keys with Minimal value.\\n        \"\"\"\\n        if not self.dq:\\n            return \\'\\'\\n        v = self.dq[0]\\n        key = self.vals[v].pop()\\n        self.vals[v].add(key)\\n        return key\\n```",
                "codeTag": "Java"
            },
            {
                "id": 945372,
                "title": "simple-java-solution-with-set-and-map",
                "content": "```\\nclass AllOne {\\n    Map<Integer, Set<String>> map = new HashMap<>();\\n    Map<String, Integer> counts = new HashMap<>();\\n    /** Initialize your data structure here. */\\n    int max =1;\\n    public AllOne() {\\n        map.put(0, new HashSet<>());\\n        map.get(0).add(\"\");\\n    }\\n    \\n    /** Inserts a new key <Key> with value 1. Or increments an existing key by 1. */\\n    public void inc(String key) {\\n        int lev = counts.getOrDefault(key, 0)+1;\\n        map.putIfAbsent(lev, new HashSet<>());\\n        map.get(lev).add(key);\\n        map.get(lev-1).remove(key);\\n        counts.put(key, lev);\\n        if(lev>max) max= lev;\\n    }\\n    \\n    /** Decrements an existing key by 1. If Key\\'s value is 1, remove it from the data structure. */\\n    public void dec(String key) {\\n        int lev = counts.getOrDefault(key, 0);\\n        if(lev==0) return;\\n        if(lev==1) {\\n            counts.remove(key);\\n            map.get(lev).remove(key);\\n        } else {\\n            counts.put(key, lev-1);\\n            map.get(lev).remove(key);\\n            map.get(lev-1).add(key);\\n            if(lev==max && map.get(lev).isEmpty()) max--;\\n        }\\n    }\\n    \\n    /** Returns one of the keys with maximal value. */\\n\\t//This is linear time in the worst case\\n    public String getMaxKey() {\\n        while(max >=1 && map.getOrDefault(max, new HashSet<>()).isEmpty()) max--;\\n        return map.get(max).stream().findFirst().get();\\n    }\\n    \\n    /** Returns one of the keys with Minimal value. */\\n\\t//This is linear time in the worst case\\n    public String getMinKey() {\\n        int min=1;\\n        while(min<max && map.get(min).isEmpty()) min++;\\n        if(min>max) min=0;\\n        return map.get(min).stream().findFirst().get();\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass AllOne {\\n    Map<Integer, Set<String>> map = new HashMap<>();\\n    Map<String, Integer> counts = new HashMap<>();\\n    /** Initialize your data structure here. */\\n    int max =1;\\n    public AllOne() {\\n        map.put(0, new HashSet<>());\\n        map.get(0).add(\"\");\\n    }\\n    \\n    /** Inserts a new key <Key> with value 1. Or increments an existing key by 1. */\\n    public void inc(String key) {\\n        int lev = counts.getOrDefault(key, 0)+1;\\n        map.putIfAbsent(lev, new HashSet<>());\\n        map.get(lev).add(key);\\n        map.get(lev-1).remove(key);\\n        counts.put(key, lev);\\n        if(lev>max) max= lev;\\n    }\\n    \\n    /** Decrements an existing key by 1. If Key\\'s value is 1, remove it from the data structure. */\\n    public void dec(String key) {\\n        int lev = counts.getOrDefault(key, 0);\\n        if(lev==0) return;\\n        if(lev==1) {\\n            counts.remove(key);\\n            map.get(lev).remove(key);\\n        } else {\\n            counts.put(key, lev-1);\\n            map.get(lev).remove(key);\\n            map.get(lev-1).add(key);\\n            if(lev==max && map.get(lev).isEmpty()) max--;\\n        }\\n    }\\n    \\n    /** Returns one of the keys with maximal value. */\\n\\t//This is linear time in the worst case\\n    public String getMaxKey() {\\n        while(max >=1 && map.getOrDefault(max, new HashSet<>()).isEmpty()) max--;\\n        return map.get(max).stream().findFirst().get();\\n    }\\n    \\n    /** Returns one of the keys with Minimal value. */\\n\\t//This is linear time in the worst case\\n    public String getMinKey() {\\n        int min=1;\\n        while(min<max && map.get(min).isEmpty()) min++;\\n        if(min>max) min=0;\\n        return map.get(min).stream().findFirst().get();\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 933535,
                "title": "python-3-use-defaultdict-set-and-defaultdict-int",
                "content": "```\\nclass AllOne:\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.val2key=collections.defaultdict(set)\\n        self.key2val=collections.defaultdict(int)\\n        self.max=1\\n        self.min=1\\n        \\n    def inc(self, key: str) -> None:\\n        \"\"\"\\n        Inserts a new key <Key> with value 1. Or increments an existing key by 1.\\n        \"\"\"\\n        if key in self.key2val:\\n            nowV=self.key2val[key]\\n            #modify key2val\\n            self.key2val[key]=nowV+1 \\n            #modify val2key\\n            self.val2key[nowV+1].add(key)\\n            if len(self.val2key[nowV])==1:\\n                del self.val2key[nowV]\\n            else:\\n                self.val2key[nowV].remove(key)\\n            #modify self.max,self.min\\n            self.max=max(self.max, nowV+1)\\n            if self.min==nowV:\\n                if nowV not in self.val2key:\\n                    self.min+=1\\n                        \\n        else:\\n            self.key2val[key]=1\\n            self.val2key[1].add(key)\\n            self.min=1\\n                           \\n    def dec(self, key: str) -> None:\\n        \"\"\"\\n        Decrements an existing key by 1. If Key\\'s value is 1, remove it from the data structure.\\n        \"\"\"\\n        if key not in self.key2val: return \\n        if self.key2val[key]==1:\\n            nowV=self.key2val[key]\\n            del self.key2val[key]\\n            if len(self.val2key[nowV])==1:\\n                del self.val2key[nowV]\\n                self.min=self.max\\n                for v in self.val2key.keys():\\n                    self.min=min(self.min,v)\\n            else:\\n                self.val2key[nowV].remove(key)            \\n        else:\\n            nowV=self.key2val[key]\\n            self.key2val[key]=nowV-1\\n            if len(self.val2key[nowV])==1:\\n                del self.val2key[nowV]\\n            else:\\n                self.val2key[nowV].remove(key)\\n            self.val2key[nowV-1].add(key)\\n            if self.max not in self.val2key:\\n                self.max-=1\\n            if self.min==nowV:\\n                self.min-=1\\n            \\n    def getMaxKey(self) -> str:\\n        \"\"\"\\n        Returns one of the keys with maximal value.\\n        \"\"\"\\n        if not self.key2val: return \"\"\\n        return list(self.val2key[self.max])[0]\\n\\n    def getMinKey(self) -> str:\\n        \"\"\"\\n        Returns one of the keys with Minimal value.\\n        \"\"\"\\n        if not self.key2val: return \"\"\\n        return list(self.val2key[self.min])[0]\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass AllOne:\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.val2key=collections.defaultdict(set)\\n        self.key2val=collections.defaultdict(int)\\n        self.max=1\\n        self.min=1\\n        \\n    def inc(self, key: str) -> None:\\n        \"\"\"\\n        Inserts a new key <Key> with value 1. Or increments an existing key by 1.\\n        \"\"\"\\n        if key in self.key2val:\\n            nowV=self.key2val[key]\\n            #modify key2val\\n            self.key2val[key]=nowV+1 \\n            #modify val2key\\n            self.val2key[nowV+1].add(key)\\n            if len(self.val2key[nowV])==1:\\n                del self.val2key[nowV]\\n            else:\\n                self.val2key[nowV].remove(key)\\n            #modify self.max,self.min\\n            self.max=max(self.max, nowV+1)\\n            if self.min==nowV:\\n                if nowV not in self.val2key:\\n                    self.min+=1\\n                        \\n        else:\\n            self.key2val[key]=1\\n            self.val2key[1].add(key)\\n            self.min=1\\n                           \\n    def dec(self, key: str) -> None:\\n        \"\"\"\\n        Decrements an existing key by 1. If Key\\'s value is 1, remove it from the data structure.\\n        \"\"\"\\n        if key not in self.key2val: return \\n        if self.key2val[key]==1:\\n            nowV=self.key2val[key]\\n            del self.key2val[key]\\n            if len(self.val2key[nowV])==1:\\n                del self.val2key[nowV]\\n                self.min=self.max\\n                for v in self.val2key.keys():\\n                    self.min=min(self.min,v)\\n            else:\\n                self.val2key[nowV].remove(key)            \\n        else:\\n            nowV=self.key2val[key]\\n            self.key2val[key]=nowV-1\\n            if len(self.val2key[nowV])==1:\\n                del self.val2key[nowV]\\n            else:\\n                self.val2key[nowV].remove(key)\\n            self.val2key[nowV-1].add(key)\\n            if self.max not in self.val2key:\\n                self.max-=1\\n            if self.min==nowV:\\n                self.min-=1\\n            \\n    def getMaxKey(self) -> str:\\n        \"\"\"\\n        Returns one of the keys with maximal value.\\n        \"\"\"\\n        if not self.key2val: return \"\"\\n        return list(self.val2key[self.max])[0]\\n\\n    def getMinKey(self) -> str:\\n        \"\"\"\\n        Returns one of the keys with Minimal value.\\n        \"\"\"\\n        if not self.key2val: return \"\"\\n        return list(self.val2key[self.min])[0]\\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 837799,
                "title": "javascript-strict-o-1-solution-hope-you-help-me-to-refine-the-code",
                "content": "\\t/**\\n\\t * Initialize your data structure here.\\n\\t */\\n\\tfunction DoubleLinkedListNode(number) {\\n\\t\\tthis.number = number;\\n\\t\\tthis.vals = new Set();\\n\\t\\tthis.prev = this.next = null;\\n\\t}\\n\\n\\tvar AllOne = function() {\\n\\t\\tthis.head = new DoubleLinkedListNode();\\n\\t\\tthis.tail = new DoubleLinkedListNode();\\n\\t\\tthis.head.next = this.tail;\\n\\t\\tthis.tail.prev = this.head;\\n\\t\\tthis.hash = {};\\n\\t};\\n\\n\\t/**\\n\\t * Inserts a new key <Key> with value 1. Or increments an existing key by 1. \\n\\t * @param {string} key\\n\\t * @return {void}\\n\\t */\\n\\tAllOne.prototype.inc = function(key) {\\n\\t\\tif (!key || this.hash[key] === undefined) {\\n\\t\\t\\tconst nextNode = this.head.next;\\n\\t\\t\\tif (nextNode.number === 1) {\\n\\t\\t\\t\\tnextNode.vals.add(key); \\n\\t\\t\\t\\tthis.hash[key] = nextNode;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tconst node = new DoubleLinkedListNode(1);\\n\\t\\t\\t\\tnode.vals.add(key);\\n\\t\\t\\t\\tthis.hash[key] = node;\\n\\t\\t\\t\\t//connect\\n\\t\\t\\t\\tnode.next = nextNode;\\n\\t\\t\\t\\tnextNode.prev = node;\\n\\t\\t\\t\\tthis.head.next = node;\\n\\t\\t\\t\\tnode.prev = this.head;\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\tconst currNode = this.hash[key];\\n\\t\\t\\tcurrNode.vals.delete(key);\\n\\t\\t\\tlet nextNumber = currNode.number+1;\\n\\t\\t\\tconst nextNode = currNode.next;\\n\\t\\t\\tif (nextNode.number !== nextNumber) {\\n\\t\\t\\t\\tconst node = new DoubleLinkedListNode(nextNumber);\\n\\t\\t\\t\\tnode.next = nextNode;\\n\\t\\t\\t\\tnextNode.prev = node;\\n\\t\\t\\t\\tcurrNode.next = node;\\n\\t\\t\\t\\tnode.prev = currNode;\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.hash[key] = currNode.next;\\n\\t\\t\\tcurrNode.next.vals.add(key);\\n\\n\\t\\t\\tif (!currNode.vals.size) {\\n\\t\\t\\t\\tcurrNode.prev.next = currNode.next;\\n\\t\\t\\t\\tcurrNode.next.prev = currNode.prev;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t};\\n\\n\\t/**\\n\\t * Decrements an existing key by 1. If Key\\'s value is 1, remove it from the data structure. \\n\\t * @param {string} key\\n\\t * @return {void}\\n\\t */\\n\\tAllOne.prototype.dec = function(key) {\\n\\t\\tif (!key || this.hash[key] === undefined) {\\n\\t\\t\\treturn;\\n\\t\\t} else {\\n\\t\\t\\tconst currNode = this.hash[key];\\n\\t\\t\\tcurrNode.vals.delete(key);\\n\\t\\t\\tlet prevNumber = currNode.number-1;\\n\\t\\t\\tconst prevNode = currNode.prev;\\n\\t\\t\\tif (prevNumber && prevNode.number !== prevNumber) {\\n\\t\\t\\t\\tconst node = new DoubleLinkedListNode(prevNumber);\\n\\t\\t\\t\\tprevNode.next = node;\\n\\t\\t\\t\\tnode.prev = prevNode;\\n\\t\\t\\t\\tnode.next = currNode;\\n\\t\\t\\t\\tcurrNode.prev = node;;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (prevNumber) {\\n\\t\\t\\t\\tcurrNode.prev.vals.add(key);\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.hash[key] = currNode.prev;\\n\\t\\t\\tif (!prevNumber) delete(this.hash[key])\\n\\n\\t\\t\\tif (!currNode.vals.size) {\\n\\t\\t\\t\\tcurrNode.prev.next = currNode.next;\\n\\t\\t\\t\\tcurrNode.next.prev = currNode.prev;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t};\\n\\n\\t/**\\n\\t * Returns one of the keys with maximal value.\\n\\t * @return {string}\\n\\t */\\n\\tAllOne.prototype.getMaxKey = function() {\\n\\t\\tconst node = this.tail.prev;\\n\\t\\tif (node === this.head) return \\'\\';\\n\\n\\t\\tfor (let v of node.vals) {\\n\\t\\t\\treturn v;\\n\\t\\t}\\n\\n\\t\\treturn \\'\\';\\n\\t};\\n\\n\\t/**\\n\\t * Returns one of the keys with Minimal value.\\n\\t * @return {string}\\n\\t */\\n\\tAllOne.prototype.getMinKey = function() {\\n\\t\\tconst node = this.head.next;\\n\\t\\tif (node === this.tail) return \\'\\';\\n\\n\\t\\tfor (let v of node.vals) {\\n\\t\\t\\treturn v;\\n\\t\\t}\\n\\n\\t\\treturn \\'\\';\\n\\t};\\n\\t//a b c\\n\\t//1 1 3\\n\\t/** \\n\\t * Your AllOne object will be instantiated and called as such:\\n\\t * var obj = new AllOne()\\n\\t * obj.inc(key)\\n\\t * obj.dec(key)\\n\\t * var param_3 = obj.getMaxKey()\\n\\t * var param_4 = obj.getMinKey()\\n\\t */",
                "solutionTags": [],
                "code": "\\t/**\\n\\t * Initialize your data structure here.\\n\\t */\\n\\tfunction DoubleLinkedListNode(number) {\\n\\t\\tthis.number = number;\\n\\t\\tthis.vals = new Set();\\n\\t\\tthis.prev = this.next = null;\\n\\t}\\n\\n\\tvar AllOne = function() {\\n\\t\\tthis.head = new DoubleLinkedListNode();\\n\\t\\tthis.tail = new DoubleLinkedListNode();\\n\\t\\tthis.head.next = this.tail;\\n\\t\\tthis.tail.prev = this.head;\\n\\t\\tthis.hash = {};\\n\\t};\\n\\n\\t/**\\n\\t * Inserts a new key <Key> with value 1. Or increments an existing key by 1. \\n\\t * @param {string} key\\n\\t * @return {void}\\n\\t */\\n\\tAllOne.prototype.inc = function(key) {\\n\\t\\tif (!key || this.hash[key] === undefined) {\\n\\t\\t\\tconst nextNode = this.head.next;\\n\\t\\t\\tif (nextNode.number === 1) {\\n\\t\\t\\t\\tnextNode.vals.add(key); \\n\\t\\t\\t\\tthis.hash[key] = nextNode;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tconst node = new DoubleLinkedListNode(1);\\n\\t\\t\\t\\tnode.vals.add(key);\\n\\t\\t\\t\\tthis.hash[key] = node;\\n\\t\\t\\t\\t//connect\\n\\t\\t\\t\\tnode.next = nextNode;\\n\\t\\t\\t\\tnextNode.prev = node;\\n\\t\\t\\t\\tthis.head.next = node;\\n\\t\\t\\t\\tnode.prev = this.head;\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\tconst currNode = this.hash[key];\\n\\t\\t\\tcurrNode.vals.delete(key);\\n\\t\\t\\tlet nextNumber = currNode.number+1;\\n\\t\\t\\tconst nextNode = currNode.next;\\n\\t\\t\\tif (nextNode.number !== nextNumber) {\\n\\t\\t\\t\\tconst node = new DoubleLinkedListNode(nextNumber);\\n\\t\\t\\t\\tnode.next = nextNode;\\n\\t\\t\\t\\tnextNode.prev = node;\\n\\t\\t\\t\\tcurrNode.next = node;\\n\\t\\t\\t\\tnode.prev = currNode;\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.hash[key] = currNode.next;\\n\\t\\t\\tcurrNode.next.vals.add(key);\\n\\n\\t\\t\\tif (!currNode.vals.size) {\\n\\t\\t\\t\\tcurrNode.prev.next = currNode.next;\\n\\t\\t\\t\\tcurrNode.next.prev = currNode.prev;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t};\\n\\n\\t/**\\n\\t * Decrements an existing key by 1. If Key\\'s value is 1, remove it from the data structure. \\n\\t * @param {string} key\\n\\t * @return {void}\\n\\t */\\n\\tAllOne.prototype.dec = function(key) {\\n\\t\\tif (!key || this.hash[key] === undefined) {\\n\\t\\t\\treturn;\\n\\t\\t} else {\\n\\t\\t\\tconst currNode = this.hash[key];\\n\\t\\t\\tcurrNode.vals.delete(key);\\n\\t\\t\\tlet prevNumber = currNode.number-1;\\n\\t\\t\\tconst prevNode = currNode.prev;\\n\\t\\t\\tif (prevNumber && prevNode.number !== prevNumber) {\\n\\t\\t\\t\\tconst node = new DoubleLinkedListNode(prevNumber);\\n\\t\\t\\t\\tprevNode.next = node;\\n\\t\\t\\t\\tnode.prev = prevNode;\\n\\t\\t\\t\\tnode.next = currNode;\\n\\t\\t\\t\\tcurrNode.prev = node;;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (prevNumber) {\\n\\t\\t\\t\\tcurrNode.prev.vals.add(key);\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.hash[key] = currNode.prev;\\n\\t\\t\\tif (!prevNumber) delete(this.hash[key])\\n\\n\\t\\t\\tif (!currNode.vals.size) {\\n\\t\\t\\t\\tcurrNode.prev.next = currNode.next;\\n\\t\\t\\t\\tcurrNode.next.prev = currNode.prev;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t};\\n\\n\\t/**\\n\\t * Returns one of the keys with maximal value.\\n\\t * @return {string}\\n\\t */\\n\\tAllOne.prototype.getMaxKey = function() {\\n\\t\\tconst node = this.tail.prev;\\n\\t\\tif (node === this.head) return \\'\\';\\n\\n\\t\\tfor (let v of node.vals) {\\n\\t\\t\\treturn v;\\n\\t\\t}\\n\\n\\t\\treturn \\'\\';\\n\\t};\\n\\n\\t/**\\n\\t * Returns one of the keys with Minimal value.\\n\\t * @return {string}\\n\\t */\\n\\tAllOne.prototype.getMinKey = function() {\\n\\t\\tconst node = this.head.next;\\n\\t\\tif (node === this.tail) return \\'\\';\\n\\n\\t\\tfor (let v of node.vals) {\\n\\t\\t\\treturn v;\\n\\t\\t}\\n\\n\\t\\treturn \\'\\';\\n\\t};\\n\\t//a b c\\n\\t//1 1 3\\n\\t/** \\n\\t * Your AllOne object will be instantiated and called as such:\\n\\t * var obj = new AllOne()\\n\\t * obj.inc(key)\\n\\t * obj.dec(key)\\n\\t * var param_3 = obj.getMaxKey()\\n\\t * var param_4 = obj.getMinKey()\\n\\t */",
                "codeTag": "Unknown"
            },
            {
                "id": 820174,
                "title": "java-o-1",
                "content": "unpolished code, idea is to use a double linked list to maintain max and min frequency, plus a map of key to node, similar to LRU cache\\n```\\nclass AllOne {\\n    class Node{\\n        Node pre;\\n        Node next;\\n        Integer nums;\\n        Set<String> vals;\\n        public Node(Node pre, Node next, Integer nums){\\n            this.pre = pre;\\n            this.next = next;\\n            this.nums = nums;\\n            this.vals = new HashSet();\\n        }\\n    }\\n    Map<String, Node> map;\\n    Node head, tail;\\n    /** Initialize your data structure here. */\\n    public AllOne() {\\n        map = new HashMap();\\n        head = new Node(null, null, null);\\n        tail = new Node(head, null, null);\\n        head.next = tail;\\n    }\\n    \\n    /** Inserts a new key <Key> with value 1. Or increments an existing key by 1. */\\n    public void inc(String key) {\\n        if(map.containsKey(key)){\\n            Node cur = map.get(key);\\n            Node curnext = cur.next;\\n            if(curnext == tail || curnext.nums > cur.nums+1){\\n                Node newNode = new Node(cur, curnext, cur.nums+1);\\n                cur.next = newNode;\\n                curnext.pre = newNode;\\n            }\\n            cur.vals.remove(key);\\n            cur.next.vals.add(key);\\n            if(cur.vals.isEmpty()){\\n                Node pre = cur.pre;\\n                Node next = cur.next;\\n                pre.next = next;\\n                next.pre = pre;\\n            }\\n            map.put(key, cur.next);\\n        }else{\\n            Node cur = head.next;\\n            if(cur == tail || cur.nums > 1){\\n                cur = new Node(head, cur, 1);\\n                head.next.pre = cur;\\n                head.next = cur;\\n            }\\n            cur.vals.add(key);\\n            map.put(key, cur);\\n        }\\n    }\\n    \\n    /** Decrements an existing key by 1. If Key\\'s value is 1, remove it from the data structure. */\\n    public void dec(String key) {\\n        if(map.containsKey(key)){\\n            Node node = map.get(key);\\n            if(node.nums == 1){\\n                node.vals.remove(key);\\n                if(node.vals.isEmpty()){\\n                    Node next = node.next;\\n                    head.next = next;\\n                    next.pre = head;\\n                }\\n                map.remove(key);\\n            }else{\\n                node.vals.remove(key);\\n                if(node.pre==head || node.pre.nums < node.nums-1){\\n                    Node pre = node.pre;\\n                    Node newNode = new Node(pre, node, node.nums-1);\\n                    newNode.vals.add(key);\\n                    pre.next = newNode;\\n                    node.pre = newNode;\\n                    map.put(key, newNode);\\n                }else{\\n                    node.pre.vals.add(key);\\n                    map.put(key, node.pre);\\n                }\\n                if(node.vals.isEmpty()){\\n                    Node pre = node.pre;\\n                    Node next = node.next;\\n                    pre.next = next;\\n                    next.pre = pre;\\n                }\\n            }\\n        }\\n    }\\n    \\n    /** Returns one of the keys with maximal value. */\\n    public String getMaxKey() {\\n        return tail.pre != head ? max.vals.iterator().next() : \"\";\\n    }\\n    \\n    /** Returns one of the keys with Minimal value. */\\n    public String getMinKey() {\\n        return head.next != tail ? min.vals.iterator().next() : \"\";\\n    }\\n}\\n\\n/**\\n * Your AllOne object will be instantiated and called as such:\\n * AllOne obj = new AllOne();\\n * obj.inc(key);\\n * obj.dec(key);\\n * String param_3 = obj.getMaxKey();\\n * String param_4 = obj.getMinKey();\\n */",
                "solutionTags": [],
                "code": "unpolished code, idea is to use a double linked list to maintain max and min frequency, plus a map of key to node, similar to LRU cache\\n```\\nclass AllOne {\\n    class Node{\\n        Node pre;\\n        Node next;\\n        Integer nums;\\n        Set<String> vals;\\n        public Node(Node pre, Node next, Integer nums){\\n            this.pre = pre;\\n            this.next = next;\\n            this.nums = nums;\\n            this.vals = new HashSet();\\n        }\\n    }\\n    Map<String, Node> map;\\n    Node head, tail;\\n    /** Initialize your data structure here. */\\n    public AllOne() {\\n        map = new HashMap();\\n        head = new Node(null, null, null);\\n        tail = new Node(head, null, null);\\n        head.next = tail;\\n    }\\n    \\n    /** Inserts a new key <Key> with value 1. Or increments an existing key by 1. */\\n    public void inc(String key) {\\n        if(map.containsKey(key)){\\n            Node cur = map.get(key);\\n            Node curnext = cur.next;\\n            if(curnext == tail || curnext.nums > cur.nums+1){\\n                Node newNode = new Node(cur, curnext, cur.nums+1);\\n                cur.next = newNode;\\n                curnext.pre = newNode;\\n            }\\n            cur.vals.remove(key);\\n            cur.next.vals.add(key);\\n            if(cur.vals.isEmpty()){\\n                Node pre = cur.pre;\\n                Node next = cur.next;\\n                pre.next = next;\\n                next.pre = pre;\\n            }\\n            map.put(key, cur.next);\\n        }else{\\n            Node cur = head.next;\\n            if(cur == tail || cur.nums > 1){\\n                cur = new Node(head, cur, 1);\\n                head.next.pre = cur;\\n                head.next = cur;\\n            }\\n            cur.vals.add(key);\\n            map.put(key, cur);\\n        }\\n    }\\n    \\n    /** Decrements an existing key by 1. If Key\\'s value is 1, remove it from the data structure. */\\n    public void dec(String key) {\\n        if(map.containsKey(key)){\\n            Node node = map.get(key);\\n            if(node.nums == 1){\\n                node.vals.remove(key);\\n                if(node.vals.isEmpty()){\\n                    Node next = node.next;\\n                    head.next = next;\\n                    next.pre = head;\\n                }\\n                map.remove(key);\\n            }else{\\n                node.vals.remove(key);\\n                if(node.pre==head || node.pre.nums < node.nums-1){\\n                    Node pre = node.pre;\\n                    Node newNode = new Node(pre, node, node.nums-1);\\n                    newNode.vals.add(key);\\n                    pre.next = newNode;\\n                    node.pre = newNode;\\n                    map.put(key, newNode);\\n                }else{\\n                    node.pre.vals.add(key);\\n                    map.put(key, node.pre);\\n                }\\n                if(node.vals.isEmpty()){\\n                    Node pre = node.pre;\\n                    Node next = node.next;\\n                    pre.next = next;\\n                    next.pre = pre;\\n                }\\n            }\\n        }\\n    }\\n    \\n    /** Returns one of the keys with maximal value. */\\n    public String getMaxKey() {\\n        return tail.pre != head ? max.vals.iterator().next() : \"\";\\n    }\\n    \\n    /** Returns one of the keys with Minimal value. */\\n    public String getMinKey() {\\n        return head.next != tail ? min.vals.iterator().next() : \"\";\\n    }\\n}\\n\\n/**\\n * Your AllOne object will be instantiated and called as such:\\n * AllOne obj = new AllOne();\\n * obj.inc(key);\\n * obj.dec(key);\\n * String param_3 = obj.getMaxKey();\\n * String param_4 = obj.getMinKey();\\n */",
                "codeTag": "Java"
            },
            {
                "id": 778493,
                "title": "clean-java-all-o-1",
                "content": "```\\nclass AllOne {\\n    class Bucket {\\n        int val;\\n        Set<String> keys = new HashSet<>();\\n        Bucket next = null;\\n        Bucket prev = null;\\n        \\n        public Bucket(int val) {\\n            this.val = val;\\n        }\\n        \\n        public String toString() {\\n            return String.format(\"<%d: %s> -> %s\", val, keys, next);\\n        }\\n    }\\n    \\n    Bucket head = null, tail = null;\\n    Map<Integer, Bucket> cntmap = new HashMap<>();\\n    Map<String, Integer> valmap = new HashMap<>();\\n    \\n    /** Initialize your data structure here. */\\n    public AllOne() {\\n        Bucket b = new Bucket(0);\\n        head = b;\\n        tail = b;\\n        cntmap.put(0, b);\\n    }\\n    \\n    /** Inserts a new key <Key> with value 1. Or increments an existing key by 1. */\\n    public void inc(String key) {\\n        int val = valmap.getOrDefault(key, 0);\\n        if(!cntmap.containsKey(val+1)) createNext(val); // if there\\'s no target bucket, create it\\n        if(val != 0) delete(key, val);   // remove key from old bucket. If old bucket is empty, delete it\\n        cntmap.get(val+1).keys.add(key); // add key to new bucket\\n        valmap.put(key, val+1);          // update value\\n    }\\n    \\n    /** Decrements an existing key by 1. If Key\\'s value is 1, remove it from the data structure. */\\n    public void dec(String key) {\\n        if(!valmap.containsKey(key)) return;\\n        int val = valmap.get(key);\\n        if(val > 1 && !cntmap.containsKey(val-1)) createBefore(val); // if there\\'s no target bucket, create it\\n        delete(key, val);\\n        valmap.remove(key);\\n        if(val > 1) {\\n            cntmap.get(val-1).keys.add(key);\\n            valmap.put(key, val-1);\\n        }\\n    }\\n    \\n    private void createNext(int bucket) {\\n        Bucket target = cntmap.get(bucket);\\n        Bucket nb = new Bucket(bucket+1);\\n        nb.next = target.next;\\n        nb.prev = target;\\n        if(target.next != null) target.next.prev = nb;\\n        target.next = nb;\\n        cntmap.put(bucket+1, nb);\\n        if(nb.val > tail.val) tail = nb;\\n    }\\n    \\n    private void createBefore(int bucket) {\\n        Bucket target = cntmap.get(bucket);\\n        Bucket nb = new Bucket(bucket-1);\\n        nb.next = target;\\n        nb.prev = target.prev;\\n        target.prev.next = nb;\\n        target.prev = nb;\\n        cntmap.put(bucket-1, nb);\\n    }\\n    \\n    private void delete(String key, int bucket) {\\n        Bucket target = cntmap.get(bucket);\\n        target.keys.remove(key);\\n        if(target.keys.isEmpty()) {\\n            if(tail == target) tail = target.prev;\\n            target.prev.next = target.next;\\n            if(target.next != null) target.next.prev = target.prev;\\n            cntmap.remove(bucket);\\n        }\\n    }\\n    \\n    /** Returns one of the keys with maximal value. */\\n    public String getMaxKey() {\\n        if(tail.val == 0) return \"\";\\n        return tail.keys.iterator().next();\\n    }\\n    \\n    /** Returns one of the keys with Minimal value. */\\n    public String getMinKey() {\\n        if(head.next == null) return \"\";\\n        return head.next.keys.iterator().next();\\n    }\\n}\\n\\n/**\\n * Your AllOne object will be instantiated and called as such:\\n * AllOne obj = new AllOne();\\n * obj.inc(key);\\n * obj.dec(key);\\n * String param_3 = obj.getMaxKey();\\n * String param_4 = obj.getMinKey();\\n */\\n ```",
                "solutionTags": [],
                "code": "```\\nclass AllOne {\\n    class Bucket {\\n        int val;\\n        Set<String> keys = new HashSet<>();\\n        Bucket next = null;\\n        Bucket prev = null;\\n        \\n        public Bucket(int val) {\\n            this.val = val;\\n        }\\n        \\n        public String toString() {\\n            return String.format(\"<%d: %s> -> %s\", val, keys, next);\\n        }\\n    }\\n    \\n    Bucket head = null, tail = null;\\n    Map<Integer, Bucket> cntmap = new HashMap<>();\\n    Map<String, Integer> valmap = new HashMap<>();\\n    \\n    /** Initialize your data structure here. */\\n    public AllOne() {\\n        Bucket b = new Bucket(0);\\n        head = b;\\n        tail = b;\\n        cntmap.put(0, b);\\n    }\\n    \\n    /** Inserts a new key <Key> with value 1. Or increments an existing key by 1. */\\n    public void inc(String key) {\\n        int val = valmap.getOrDefault(key, 0);\\n        if(!cntmap.containsKey(val+1)) createNext(val); // if there\\'s no target bucket, create it\\n        if(val != 0) delete(key, val);   // remove key from old bucket. If old bucket is empty, delete it\\n        cntmap.get(val+1).keys.add(key); // add key to new bucket\\n        valmap.put(key, val+1);          // update value\\n    }\\n    \\n    /** Decrements an existing key by 1. If Key\\'s value is 1, remove it from the data structure. */\\n    public void dec(String key) {\\n        if(!valmap.containsKey(key)) return;\\n        int val = valmap.get(key);\\n        if(val > 1 && !cntmap.containsKey(val-1)) createBefore(val); // if there\\'s no target bucket, create it\\n        delete(key, val);\\n        valmap.remove(key);\\n        if(val > 1) {\\n            cntmap.get(val-1).keys.add(key);\\n            valmap.put(key, val-1);\\n        }\\n    }\\n    \\n    private void createNext(int bucket) {\\n        Bucket target = cntmap.get(bucket);\\n        Bucket nb = new Bucket(bucket+1);\\n        nb.next = target.next;\\n        nb.prev = target;\\n        if(target.next != null) target.next.prev = nb;\\n        target.next = nb;\\n        cntmap.put(bucket+1, nb);\\n        if(nb.val > tail.val) tail = nb;\\n    }\\n    \\n    private void createBefore(int bucket) {\\n        Bucket target = cntmap.get(bucket);\\n        Bucket nb = new Bucket(bucket-1);\\n        nb.next = target;\\n        nb.prev = target.prev;\\n        target.prev.next = nb;\\n        target.prev = nb;\\n        cntmap.put(bucket-1, nb);\\n    }\\n    \\n    private void delete(String key, int bucket) {\\n        Bucket target = cntmap.get(bucket);\\n        target.keys.remove(key);\\n        if(target.keys.isEmpty()) {\\n            if(tail == target) tail = target.prev;\\n            target.prev.next = target.next;\\n            if(target.next != null) target.next.prev = target.prev;\\n            cntmap.remove(bucket);\\n        }\\n    }\\n    \\n    /** Returns one of the keys with maximal value. */\\n    public String getMaxKey() {\\n        if(tail.val == 0) return \"\";\\n        return tail.keys.iterator().next();\\n    }\\n    \\n    /** Returns one of the keys with Minimal value. */\\n    public String getMinKey() {\\n        if(head.next == null) return \"\";\\n        return head.next.keys.iterator().next();\\n    }\\n}\\n\\n/**\\n * Your AllOne object will be instantiated and called as such:\\n * AllOne obj = new AllOne();\\n * obj.inc(key);\\n * obj.dec(key);\\n * String param_3 = obj.getMaxKey();\\n * String param_4 = obj.getMinKey();\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 773853,
                "title": "swift-map-doubly-linked-list",
                "content": "I think the idea is similar to LRU cache problem in leetcode\\n```\\nclass Node<T>{\\n    var prev: Node<T>?\\n    var next: Node<T>?\\n    var val: T?\\n    var key: String?\\n    \\n    init(){}\\n    \\n    init(_ key: String, _ val: T?){\\n        self.key = key\\n        self.val = val\\n    }\\n}\\n\\nclass AllOne {\\n    private var map: [String : Node<Int>]\\n    private var head: Node<Int>\\n    private var tail: Node<Int>\\n    \\n    /** Initialize your data structure here. */\\n    init() {\\n        head = Node()\\n        tail = Node()\\n        \\n        map = [:]\\n        head.next = tail\\n        tail.prev = head\\n    }\\n    \\n    /** Inserts a new key <Key> with value 1. Or increments an existing key by 1. */\\n    func inc(_ key: String) {\\n        if let node = map[key]{\\n            node.val! += 1\\n            sortOrder(for: key)\\n        }else{\\n            enqueue(key)\\n        }\\n    }\\n    \\n    /** Decrements an existing key by 1. If Key\\'s value is 1, remove it from the data structure. */\\n    func dec(_ key: String) {\\n        if let node = map[key]{\\n            node.val! -= 1\\n            sortOrder(for: key)\\n            trimZeroes()\\n        }\\n    }\\n    \\n    /** Returns one of the keys with maximal value. */\\n    func getMaxKey() -> String {\\n        if head.next !== tail{\\n            return head.next!.key!\\n        }\\n        \\n        return \"\"\\n    }\\n    \\n    /** Returns one of the keys with Minimal value. */\\n    func getMinKey() -> String {\\n        if tail.prev !== head{\\n            return tail.prev!.key!\\n        }\\n        \\n        return \"\"\\n    }\\n    \\n    fileprivate func enqueue(_ key: String){\\n        map[key] = Node<Int>(key, 1)\\n        \\n        if tail.prev === head{\\n            head.next = map[key]!\\n            tail.prev = map[key]!\\n            map[key]!.next = tail\\n            map[key]!.prev = head\\n        }else{\\n            let tailPrev = tail.prev\\n            \\n            tailPrev?.next = map[key]!\\n            tail.prev = map[key]!\\n            map[key]!.next = tail\\n            map[key]!.prev = tailPrev\\n        }\\n        \\n    }\\n    \\n    // Trim all the nodes of which values are 0\\n    fileprivate func trimZeroes(){\\n        while tail.prev !== head && tail.prev!.val! == 0{\\n            let tailPrev = tail.prev\\n            tailPrev?.prev?.next = tail\\n            tail.prev = tailPrev?.prev\\n        }\\n    }\\n    \\n    // For given key, compare key\\'s node with its prev and next nodes to locate itself at the right location\\n    fileprivate func sortOrder(for key: String){\\n        if let prevVal = map[key]?.prev?.val, let keyVal = map[key]?.val, prevVal < keyVal{\\n            let prevPrev = map[key]?.prev?.prev\\n            let next = map[key]?.next\\n            \\n            prevPrev?.next = map[key]\\n            next?.prev = map[key]?.prev\\n            \\n            map[key]?.prev = prevPrev\\n            map[key]?.next = next?.prev\\n            \\n            next?.prev?.next = next\\n            next?.prev?.prev = map[key]\\n            \\n            sortOrder(for: key)\\n        }else if let nextVal = map[key]?.next?.val, let keyVal = map[key]?.val, nextVal > keyVal{\\n            let nextNext = map[key]?.next?.next\\n            let prev = map[key]?.prev\\n            \\n            nextNext?.prev = map[key]\\n            prev?.next = map[key]?.next\\n            \\n            map[key]?.prev = prev?.next\\n            map[key]?.next = nextNext\\n            \\n            prev?.next?.prev = prev\\n            prev?.next?.next = map[key]\\n            \\n            sortOrder(for: key)\\n        }\\n    }\\n    \\n}\\n\\n```\\n",
                "solutionTags": [
                    "Swift",
                    "Linked List"
                ],
                "code": "```\\nclass Node<T>{\\n    var prev: Node<T>?\\n    var next: Node<T>?\\n    var val: T?\\n    var key: String?\\n    \\n    init(){}\\n    \\n    init(_ key: String, _ val: T?){\\n        self.key = key\\n        self.val = val\\n    }\\n}\\n\\nclass AllOne {\\n    private var map: [String : Node<Int>]\\n    private var head: Node<Int>\\n    private var tail: Node<Int>\\n    \\n    /** Initialize your data structure here. */\\n    init() {\\n        head = Node()\\n        tail = Node()\\n        \\n        map = [:]\\n        head.next = tail\\n        tail.prev = head\\n    }\\n    \\n    /** Inserts a new key <Key> with value 1. Or increments an existing key by 1. */\\n    func inc(_ key: String) {\\n        if let node = map[key]{\\n            node.val! += 1\\n            sortOrder(for: key)\\n        }else{\\n            enqueue(key)\\n        }\\n    }\\n    \\n    /** Decrements an existing key by 1. If Key\\'s value is 1, remove it from the data structure. */\\n    func dec(_ key: String) {\\n        if let node = map[key]{\\n            node.val! -= 1\\n            sortOrder(for: key)\\n            trimZeroes()\\n        }\\n    }\\n    \\n    /** Returns one of the keys with maximal value. */\\n    func getMaxKey() -> String {\\n        if head.next !== tail{\\n            return head.next!.key!\\n        }\\n        \\n        return \"\"\\n    }\\n    \\n    /** Returns one of the keys with Minimal value. */\\n    func getMinKey() -> String {\\n        if tail.prev !== head{\\n            return tail.prev!.key!\\n        }\\n        \\n        return \"\"\\n    }\\n    \\n    fileprivate func enqueue(_ key: String){\\n        map[key] = Node<Int>(key, 1)\\n        \\n        if tail.prev === head{\\n            head.next = map[key]!\\n            tail.prev = map[key]!\\n            map[key]!.next = tail\\n            map[key]!.prev = head\\n        }else{\\n            let tailPrev = tail.prev\\n            \\n            tailPrev?.next = map[key]!\\n            tail.prev = map[key]!\\n            map[key]!.next = tail\\n            map[key]!.prev = tailPrev\\n        }\\n        \\n    }\\n    \\n    // Trim all the nodes of which values are 0\\n    fileprivate func trimZeroes(){\\n        while tail.prev !== head && tail.prev!.val! == 0{\\n            let tailPrev = tail.prev\\n            tailPrev?.prev?.next = tail\\n            tail.prev = tailPrev?.prev\\n        }\\n    }\\n    \\n    // For given key, compare key\\'s node with its prev and next nodes to locate itself at the right location\\n    fileprivate func sortOrder(for key: String){\\n        if let prevVal = map[key]?.prev?.val, let keyVal = map[key]?.val, prevVal < keyVal{\\n            let prevPrev = map[key]?.prev?.prev\\n            let next = map[key]?.next\\n            \\n            prevPrev?.next = map[key]\\n            next?.prev = map[key]?.prev\\n            \\n            map[key]?.prev = prevPrev\\n            map[key]?.next = next?.prev\\n            \\n            next?.prev?.next = next\\n            next?.prev?.prev = map[key]\\n            \\n            sortOrder(for: key)\\n        }else if let nextVal = map[key]?.next?.val, let keyVal = map[key]?.val, nextVal > keyVal{\\n            let nextNext = map[key]?.next?.next\\n            let prev = map[key]?.prev\\n            \\n            nextNext?.prev = map[key]\\n            prev?.next = map[key]?.next\\n            \\n            map[key]?.prev = prev?.next\\n            map[key]?.next = nextNext\\n            \\n            prev?.next?.prev = prev\\n            prev?.next?.next = map[key]\\n            \\n            sortOrder(for: key)\\n        }\\n    }\\n    \\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 763716,
                "title": "two-python-solutions-double-linked-list-heap",
                "content": "I initially did not get that all operations need to be O(1) so went for a heap solution (which is O(logn) for 2 operations: inc and dec:\\n\\n```\\nclass AllOne:\\n\\n    def __init__(self):\\n        self.c, self.ma, self.mi, self.i = {}, [], [], itertools.count()\\n\\n    def inc(self, key: str) -> None:\\n        if key in self.c and self.c[key][0][3]: \\n            self.c[key][0][3],self.c[key][1][3] = 0,0\\n            self.c[key] = [[self.c[key][0][0] + 1, key, next(self.i), 1],[self.c[key][1][0] - 1, key, next(self.i), 1]]\\n            heapq.heappush(self.ma, self.c[key][1])\\n            heapq.heappush(self.mi, self.c[key][0])            \\n        else: \\n            self.c[key] = [[1, key, next(self.i), 1],[-1, key, next(self.i), 1]]\\n            heapq.heappush(self.ma, self.c[key][1])\\n            heapq.heappush(self.mi, self.c[key][0])\\n\\n    def dec(self, key: str) -> None:\\n        if key in self.c and self.c[key][0][3] == 1:\\n            if self.c[key][0][0] == 1: \\n                self.c[key][0][3],self.c[key][1][3] = 0,0\\n                del self.c[key]\\n            else:\\n                self.c[key][0][3],self.c[key][1][3] = 0,0\\n                self.c[key] = [[self.c[key][0][0] - 1, key, next(self.i), 1],[self.c[key][1][0] + 1, key, next(self.i), 1]]\\n                heapq.heappush(self.ma, self.c[key][1])\\n                heapq.heappush(self.mi, self.c[key][0])\\n                \\n    def getMaxKey(self) -> str:\\n        while self.ma:\\n            if self.ma[0][3]: return self.ma[0][1]\\n            heapq.heappop(self.ma)\\n        return \\'\\'\\n\\n    def getMinKey(self) -> str:\\n        while self.mi:\\n            if self.mi[0][3]: return self.mi[0][1]\\n            heapq.heappop(self.mi)\\n        return \\'\\'\\n```\\n\\nThen I realised that I need to go for O(1) on all operations so I went for a double linked list:\\n\\n```\\nclass Node:\\n    def __init__(self):\\n        self.prev, self.next, self.kset = None, None, set()\\n\\nclass dlList:\\n    def __init__(self):\\n        self.head, self.tail = Node(), Node()\\n        self.head.next, self.tail.prev = self.tail.prev, self.head.next\\n    \\n    def insertAfter(self, node1, node2):\\n        n = node1.next\\n        if n: n.prev, node2.next = node2, n\\n        else: self.tail = node2\\n        node1.next, node2.prev = node2, node1\\n\\n    def insertBefore(self, node1, node2):\\n        n = node1.prev\\n        if n: n.next, node2.prev = node2, n\\n        else: self.head = node2\\n        node1.prev, node2.next = node2, node1\\n\\nclass AllOne:\\n\\n    def __init__(self):\\n        self.dll, self.d, self.c = dlList(), {}, {}\\n\\n    def inc(self, key: str) -> None:\\n        if key in self.d:\\n            cnode = self.c[self.d[key]]\\n            cnode.kset.discard(key)\\n            if (self.d[key] + 1) in self.c: self.c[self.d[key] + 1].kset.add(key)\\n            else:\\n                nnode = Node()\\n                nnode.kset.add(key)\\n                self.dll.insertAfter(cnode, nnode)\\n                self.c[self.d[key] + 1] = nnode\\n            self.d[key] += 1\\n        else:\\n            self.d[key] = 1\\n            if 1 in self.c: self.c[1].kset.add(key)\\n            else:\\n                nnode = Node()\\n                nnode.kset.add(key)\\n                self.dll.insertAfter(self.dll.head, nnode)\\n                self.c[1] = nnode\\n                \\n    def dec(self, key: str) -> None:\\n        if key in self.d:\\n            cnode,ncount = self.c[self.d[key]], self.d[key] - 1\\n            cnode.kset.discard(key)\\n            if self.d[key] == 1: del self.d[key]\\n            else:\\n                if ncount in self.c: self.c[ncount].kset.add(key)\\n                else:\\n                    nnode = Node()\\n                    nnode.kset.add(key)\\n                    self.dll.insertBefore(cnode, nnode)\\n                    self.c[ncount] = nnode\\n                self.d[key] -= 1\\n                \\n    def getMaxKey(self) -> str:\\n        curr = self.dll.tail\\n        while curr:\\n            if curr.kset: return next(iter(curr.kset))\\n            curr = curr.prev\\n        return \\'\\'\\n\\n    def getMinKey(self) -> str:\\n        curr = self.dll.head\\n        while curr:\\n            if curr.kset: return next(iter(curr.kset))\\n            curr = curr.next\\n        return \\'\\'\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass AllOne:\\n\\n    def __init__(self):\\n        self.c, self.ma, self.mi, self.i = {}, [], [], itertools.count()\\n\\n    def inc(self, key: str) -> None:\\n        if key in self.c and self.c[key][0][3]: \\n            self.c[key][0][3],self.c[key][1][3] = 0,0\\n            self.c[key] = [[self.c[key][0][0] + 1, key, next(self.i), 1],[self.c[key][1][0] - 1, key, next(self.i), 1]]\\n            heapq.heappush(self.ma, self.c[key][1])\\n            heapq.heappush(self.mi, self.c[key][0])            \\n        else: \\n            self.c[key] = [[1, key, next(self.i), 1],[-1, key, next(self.i), 1]]\\n            heapq.heappush(self.ma, self.c[key][1])\\n            heapq.heappush(self.mi, self.c[key][0])\\n\\n    def dec(self, key: str) -> None:\\n        if key in self.c and self.c[key][0][3] == 1:\\n            if self.c[key][0][0] == 1: \\n                self.c[key][0][3],self.c[key][1][3] = 0,0\\n                del self.c[key]\\n            else:\\n                self.c[key][0][3],self.c[key][1][3] = 0,0\\n                self.c[key] = [[self.c[key][0][0] - 1, key, next(self.i), 1],[self.c[key][1][0] + 1, key, next(self.i), 1]]\\n                heapq.heappush(self.ma, self.c[key][1])\\n                heapq.heappush(self.mi, self.c[key][0])\\n                \\n    def getMaxKey(self) -> str:\\n        while self.ma:\\n            if self.ma[0][3]: return self.ma[0][1]\\n            heapq.heappop(self.ma)\\n        return \\'\\'\\n\\n    def getMinKey(self) -> str:\\n        while self.mi:\\n            if self.mi[0][3]: return self.mi[0][1]\\n            heapq.heappop(self.mi)\\n        return \\'\\'\\n```\n```\\nclass Node:\\n    def __init__(self):\\n        self.prev, self.next, self.kset = None, None, set()\\n\\nclass dlList:\\n    def __init__(self):\\n        self.head, self.tail = Node(), Node()\\n        self.head.next, self.tail.prev = self.tail.prev, self.head.next\\n    \\n    def insertAfter(self, node1, node2):\\n        n = node1.next\\n        if n: n.prev, node2.next = node2, n\\n        else: self.tail = node2\\n        node1.next, node2.prev = node2, node1\\n\\n    def insertBefore(self, node1, node2):\\n        n = node1.prev\\n        if n: n.next, node2.prev = node2, n\\n        else: self.head = node2\\n        node1.prev, node2.next = node2, node1\\n\\nclass AllOne:\\n\\n    def __init__(self):\\n        self.dll, self.d, self.c = dlList(), {}, {}\\n\\n    def inc(self, key: str) -> None:\\n        if key in self.d:\\n            cnode = self.c[self.d[key]]\\n            cnode.kset.discard(key)\\n            if (self.d[key] + 1) in self.c: self.c[self.d[key] + 1].kset.add(key)\\n            else:\\n                nnode = Node()\\n                nnode.kset.add(key)\\n                self.dll.insertAfter(cnode, nnode)\\n                self.c[self.d[key] + 1] = nnode\\n            self.d[key] += 1\\n        else:\\n            self.d[key] = 1\\n            if 1 in self.c: self.c[1].kset.add(key)\\n            else:\\n                nnode = Node()\\n                nnode.kset.add(key)\\n                self.dll.insertAfter(self.dll.head, nnode)\\n                self.c[1] = nnode\\n                \\n    def dec(self, key: str) -> None:\\n        if key in self.d:\\n            cnode,ncount = self.c[self.d[key]], self.d[key] - 1\\n            cnode.kset.discard(key)\\n            if self.d[key] == 1: del self.d[key]\\n            else:\\n                if ncount in self.c: self.c[ncount].kset.add(key)\\n                else:\\n                    nnode = Node()\\n                    nnode.kset.add(key)\\n                    self.dll.insertBefore(cnode, nnode)\\n                    self.c[ncount] = nnode\\n                self.d[key] -= 1\\n                \\n    def getMaxKey(self) -> str:\\n        curr = self.dll.tail\\n        while curr:\\n            if curr.kset: return next(iter(curr.kset))\\n            curr = curr.prev\\n        return \\'\\'\\n\\n    def getMinKey(self) -> str:\\n        curr = self.dll.head\\n        while curr:\\n            if curr.kset: return next(iter(curr.kset))\\n            curr = curr.next\\n        return \\'\\'\\n```",
                "codeTag": "Java"
            },
            {
                "id": 750831,
                "title": "swift-map-doublylinkedlist",
                "content": "```\\nimport Foundation\\n// Source: https://tinyurl.com/y2ame7dc\\npublic class DoublyLinkedListNode {\\n    public var counterValKeySet = Set<String>()\\n    public var next: DoublyLinkedListNode?\\n    public var prev: DoublyLinkedListNode?\\n}\\n\\npublic class DoublyLinkedList {\\n    public var dummyHead = DoublyLinkedListNode()\\n    public var dummyTail = DoublyLinkedListNode()\\n    public init() {\\n        dummyHead.next = dummyTail\\n        dummyTail.prev = dummyHead\\n    }\\n    \\n    public func insertAfter(_ node: DoublyLinkedListNode) -> DoublyLinkedListNode {\\n        var (nodeToReturn, tempNode) = (DoublyLinkedListNode(), node.next)\\n        node.next = nodeToReturn\\n        nodeToReturn.prev = node\\n        nodeToReturn.next = tempNode\\n        tempNode?.prev = nodeToReturn\\n        return nodeToReturn\\n    }\\n    \\n    public func insertBefore(_ node: DoublyLinkedListNode) -> DoublyLinkedListNode {\\n        return insertAfter(node.prev!)\\n    }\\n    \\n    public func removeNode(_ node: DoublyLinkedListNode) {\\n        node.prev?.next = node.next\\n        node.next?.prev = node.prev\\n    }\\n}\\n\\nclass AllOne {\\n    var keyCounterToNodeMap = [Int: DoublyLinkedListNode]()\\n    var keyToCounterMap = [String: Int]()\\n    var dll = DoublyLinkedList()\\n    \\n    /** Initialize your data structure here. */\\n    init() {\\n        keyCounterToNodeMap[0] = dll.dummyHead\\n    }\\n    \\n    \\n    private func removePreviousKeyAndNode(_ previousCount: Int, _ key: String) {\\n        if var previousNode = keyCounterToNodeMap[previousCount] {\\n            previousNode.counterValKeySet.remove(key)\\n            if previousNode.counterValKeySet.isEmpty {\\n                dll.removeNode(previousNode)\\n                keyCounterToNodeMap.removeValue(forKey: previousCount)\\n            }\\n        }\\n    }\\n    \\n    /** Inserts a new key <Key> with value 1. Or increments an existing key by 1. */\\n    func inc(_ key: String) {\\n        keyToCounterMap[key, default:0] += 1\\n        let (currentCount, previousCount) = (keyToCounterMap[key]!, keyToCounterMap[key]! - 1)\\n        if keyCounterToNodeMap[currentCount] == nil {\\n            keyCounterToNodeMap[currentCount] = dll.insertAfter(keyCounterToNodeMap[previousCount]!)\\n        }\\n        keyCounterToNodeMap[currentCount]?.counterValKeySet.insert(key)\\n        if previousCount > 0 {\\n            removePreviousKeyAndNode(previousCount, key)\\n        }\\n    }\\n    \\n    /** Decrements an existing key by 1. If Key\\'s value is 1, remove it from the data structure. */\\n    func dec(_ key: String) {\\n        if let previousCount = keyToCounterMap[key] {\\n            keyToCounterMap[key] = previousCount - 1\\n            if let currentCounter = keyToCounterMap[key] {\\n                if currentCounter == 0 {\\n                    keyToCounterMap.removeValue(forKey: key)\\n                } else {\\n                    if keyCounterToNodeMap[currentCounter] == nil {\\n                        keyCounterToNodeMap[currentCounter] = dll.insertBefore(keyCounterToNodeMap[previousCount]!)\\n                    }\\n                    keyCounterToNodeMap[currentCounter]?.counterValKeySet.insert(key)\\n                }\\n            }\\n            removePreviousKeyAndNode(previousCount, key)\\n        }\\n    }\\n    \\n    /** Returns one of the keys with maximal value. */\\n    func getMaxKey() -> String {\\n        if dll.dummyTail.prev!.counterValKeySet.count > 0 {\\n            return dll.dummyTail.prev!.counterValKeySet.first ?? \"\"\\n        } else {\\n            return \"\"\\n        }\\n    }\\n    \\n    /** Returns one of the keys with Minimal value. */\\n    func getMinKey() -> String {\\n        if dll.dummyHead.next!.counterValKeySet.count > 0 {\\n            return dll.dummyHead.next!.counterValKeySet.first ?? \"\"\\n        } else {\\n            return \"\"\\n        }\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Doubly-Linked List"
                ],
                "code": "```\\nimport Foundation\\n// Source: https://tinyurl.com/y2ame7dc\\npublic class DoublyLinkedListNode {\\n    public var counterValKeySet = Set<String>()\\n    public var next: DoublyLinkedListNode?\\n    public var prev: DoublyLinkedListNode?\\n}\\n\\npublic class DoublyLinkedList {\\n    public var dummyHead = DoublyLinkedListNode()\\n    public var dummyTail = DoublyLinkedListNode()\\n    public init() {\\n        dummyHead.next = dummyTail\\n        dummyTail.prev = dummyHead\\n    }\\n    \\n    public func insertAfter(_ node: DoublyLinkedListNode) -> DoublyLinkedListNode {\\n        var (nodeToReturn, tempNode) = (DoublyLinkedListNode(), node.next)\\n        node.next = nodeToReturn\\n        nodeToReturn.prev = node\\n        nodeToReturn.next = tempNode\\n        tempNode?.prev = nodeToReturn\\n        return nodeToReturn\\n    }\\n    \\n    public func insertBefore(_ node: DoublyLinkedListNode) -> DoublyLinkedListNode {\\n        return insertAfter(node.prev!)\\n    }\\n    \\n    public func removeNode(_ node: DoublyLinkedListNode) {\\n        node.prev?.next = node.next\\n        node.next?.prev = node.prev\\n    }\\n}\\n\\nclass AllOne {\\n    var keyCounterToNodeMap = [Int: DoublyLinkedListNode]()\\n    var keyToCounterMap = [String: Int]()\\n    var dll = DoublyLinkedList()\\n    \\n    /** Initialize your data structure here. */\\n    init() {\\n        keyCounterToNodeMap[0] = dll.dummyHead\\n    }\\n    \\n    \\n    private func removePreviousKeyAndNode(_ previousCount: Int, _ key: String) {\\n        if var previousNode = keyCounterToNodeMap[previousCount] {\\n            previousNode.counterValKeySet.remove(key)\\n            if previousNode.counterValKeySet.isEmpty {\\n                dll.removeNode(previousNode)\\n                keyCounterToNodeMap.removeValue(forKey: previousCount)\\n            }\\n        }\\n    }\\n    \\n    /** Inserts a new key <Key> with value 1. Or increments an existing key by 1. */\\n    func inc(_ key: String) {\\n        keyToCounterMap[key, default:0] += 1\\n        let (currentCount, previousCount) = (keyToCounterMap[key]!, keyToCounterMap[key]! - 1)\\n        if keyCounterToNodeMap[currentCount] == nil {\\n            keyCounterToNodeMap[currentCount] = dll.insertAfter(keyCounterToNodeMap[previousCount]!)\\n        }\\n        keyCounterToNodeMap[currentCount]?.counterValKeySet.insert(key)\\n        if previousCount > 0 {\\n            removePreviousKeyAndNode(previousCount, key)\\n        }\\n    }\\n    \\n    /** Decrements an existing key by 1. If Key\\'s value is 1, remove it from the data structure. */\\n    func dec(_ key: String) {\\n        if let previousCount = keyToCounterMap[key] {\\n            keyToCounterMap[key] = previousCount - 1\\n            if let currentCounter = keyToCounterMap[key] {\\n                if currentCounter == 0 {\\n                    keyToCounterMap.removeValue(forKey: key)\\n                } else {\\n                    if keyCounterToNodeMap[currentCounter] == nil {\\n                        keyCounterToNodeMap[currentCounter] = dll.insertBefore(keyCounterToNodeMap[previousCount]!)\\n                    }\\n                    keyCounterToNodeMap[currentCounter]?.counterValKeySet.insert(key)\\n                }\\n            }\\n            removePreviousKeyAndNode(previousCount, key)\\n        }\\n    }\\n    \\n    /** Returns one of the keys with maximal value. */\\n    func getMaxKey() -> String {\\n        if dll.dummyTail.prev!.counterValKeySet.count > 0 {\\n            return dll.dummyTail.prev!.counterValKeySet.first ?? \"\"\\n        } else {\\n            return \"\"\\n        }\\n    }\\n    \\n    /** Returns one of the keys with Minimal value. */\\n    func getMinKey() -> String {\\n        if dll.dummyHead.next!.counterValKeySet.count > 0 {\\n            return dll.dummyHead.next!.counterValKeySet.first ?? \"\"\\n        } else {\\n            return \"\"\\n        }\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 688017,
                "title": "very-straightforward-c-solution",
                "content": "```\\nclass AllOne {\\npublic:\\n    /** Initialize your data structure here. */\\n    AllOne() {\\n\\n    }\\n\\n    /** Inserts a new key <Key> with value 1. Or increments an existing key by 1. */\\n    void inc(string key) {\\n        auto it = lookUp.find(key);\\n        if (it == lookUp.end()) {//if not exist\\n            if (myList.empty() || myList.front().val != 1) {\\n                myList.emplace_front(1, key);\\n            }\\n            else if (myList.front().val == 1) {\\n                myList.front().keys.insert(key);\\n            }\\n            lookUp[key] = myList.begin();\\n            return;\\n        }\\n\\n        auto cit = it->second;\\n\\n        auto nit = next(cit);\\n\\n        if (nit == myList.end() || nit->val > cit->val + 1) {\\n            auto tmpit = myList.emplace(nit, cit->val + 1, key);\\n            lookUp[key] = tmpit;\\n            cit->keys.erase(key);\\n        }\\n        else if (nit->val == cit->val + 1) {\\n            nit->keys.insert(key);\\n            cit->keys.erase(key);\\n            lookUp.at(key) = nit;\\n        }\\n\\n        if (cit->keys.empty()) {\\n            myList.erase(cit);\\n        }\\n    }\\n\\n    /** Decrements an existing key by 1. If Key\\'s value is 1, remove it from the data structure. */\\n    void dec(string key) {\\n        auto it = lookUp.find(key);\\n        if (it == lookUp.end()) {\\n            return;\\n        }\\n\\n        auto cit = it->second;\\n\\n        if (cit->val == 1) {\\n            cit->keys.erase(key);\\n            lookUp.erase(key);\\n        }\\n        else {\\n            if (cit == myList.begin()) {\\n                cit->keys.erase(key);\\n                myList.emplace_front(cit->val - 1, key);\\n                lookUp[key] = myList.begin();\\n            }\\n            else {\\n                auto pit = prev(cit);\\n                if (pit->val == cit->val - 1) {\\n                    cit->keys.erase(key);\\n                    pit->keys.insert(key);\\n                    lookUp[key] = pit;\\n                }\\n                else {\\n                    cit->keys.erase(key);\\n                    auto tmpit = myList.emplace(cit, cit->val - 1, key);\\n                    lookUp[key] = tmpit;\\n                }\\n            }\\n        }\\n        if (cit->keys.empty()) {\\n            myList.erase(cit);\\n        }\\n    }\\n\\n    /** Returns one of the keys with maximal value. */\\n    string getMaxKey() {\\n        if (myList.empty()) { return \"\"; }\\n        return *myList.back().keys.begin();\\n    }\\n\\n    /** Returns one of the keys with Minimal value. */\\n    string getMinKey() {\\n        if (myList.empty()) { return \"\"; }\\n        return *myList.front().keys.begin();\\n    }\\nprivate:\\n    struct node {\\n        node(int val, string key) :val(val) {\\n            this->keys.insert(key);\\n        }\\n        int val;\\n        unordered_set<string> keys;\\n    };\\n    unordered_map<string, list<node>::iterator> lookUp;\\n    list<node> myList;\\n};",
                "solutionTags": [],
                "code": "```\\nclass AllOne {\\npublic:\\n    /** Initialize your data structure here. */\\n    AllOne() {\\n\\n    }\\n\\n    /** Inserts a new key <Key> with value 1. Or increments an existing key by 1. */\\n    void inc(string key) {\\n        auto it = lookUp.find(key);\\n        if (it == lookUp.end()) {//if not exist\\n            if (myList.empty() || myList.front().val != 1) {\\n                myList.emplace_front(1, key);\\n            }\\n            else if (myList.front().val == 1) {\\n                myList.front().keys.insert(key);\\n            }\\n            lookUp[key] = myList.begin();\\n            return;\\n        }\\n\\n        auto cit = it->second;\\n\\n        auto nit = next(cit);\\n\\n        if (nit == myList.end() || nit->val > cit->val + 1) {\\n            auto tmpit = myList.emplace(nit, cit->val + 1, key);\\n            lookUp[key] = tmpit;\\n            cit->keys.erase(key);\\n        }\\n        else if (nit->val == cit->val + 1) {\\n            nit->keys.insert(key);\\n            cit->keys.erase(key);\\n            lookUp.at(key) = nit;\\n        }\\n\\n        if (cit->keys.empty()) {\\n            myList.erase(cit);\\n        }\\n    }\\n\\n    /** Decrements an existing key by 1. If Key\\'s value is 1, remove it from the data structure. */\\n    void dec(string key) {\\n        auto it = lookUp.find(key);\\n        if (it == lookUp.end()) {\\n            return;\\n        }\\n\\n        auto cit = it->second;\\n\\n        if (cit->val == 1) {\\n            cit->keys.erase(key);\\n            lookUp.erase(key);\\n        }\\n        else {\\n            if (cit == myList.begin()) {\\n                cit->keys.erase(key);\\n                myList.emplace_front(cit->val - 1, key);\\n                lookUp[key] = myList.begin();\\n            }\\n            else {\\n                auto pit = prev(cit);\\n                if (pit->val == cit->val - 1) {\\n                    cit->keys.erase(key);\\n                    pit->keys.insert(key);\\n                    lookUp[key] = pit;\\n                }\\n                else {\\n                    cit->keys.erase(key);\\n                    auto tmpit = myList.emplace(cit, cit->val - 1, key);\\n                    lookUp[key] = tmpit;\\n                }\\n            }\\n        }\\n        if (cit->keys.empty()) {\\n            myList.erase(cit);\\n        }\\n    }\\n\\n    /** Returns one of the keys with maximal value. */\\n    string getMaxKey() {\\n        if (myList.empty()) { return \"\"; }\\n        return *myList.back().keys.begin();\\n    }\\n\\n    /** Returns one of the keys with Minimal value. */\\n    string getMinKey() {\\n        if (myList.empty()) { return \"\"; }\\n        return *myList.front().keys.begin();\\n    }\\nprivate:\\n    struct node {\\n        node(int val, string key) :val(val) {\\n            this->keys.insert(key);\\n        }\\n        int val;\\n        unordered_set<string> keys;\\n    };\\n    unordered_map<string, list<node>::iterator> lookUp;\\n    list<node> myList;\\n};",
                "codeTag": "Java"
            },
            {
                "id": 594988,
                "title": "hasmap-and-treemap-not-great-to-iterate-on-a-set-though",
                "content": "Have a map which stores key and their value\\nhave a treemap which stores value -> set of keys();\\n```\\nclass AllOne {\\n     TreeMap<Integer, Set<String>> countToKey;\\n    Map<String,Integer> map;\\n    /** Initialize your data structure here. */\\n    public AllOne() {\\n        map = new HashMap<>();\\n        countToKey = new TreeMap<>(Comparator.reverseOrder());\\n    }\\n    \\n    /** Inserts a new key <Key> with value 1. Or increments an existing key by 1. */\\n    public void inc(String key) {\\n\\n        int currCount = map.getOrDefault(key,0);\\n        Set<String>keys = countToKey.get(currCount);\\n        if(keys!=null) {\\n            keys.remove(key);\\n            if(keys.isEmpty()){\\n                countToKey.remove(currCount);\\n            }\\n        }\\n\\n        countToKey.computeIfAbsent(currCount+1, ka-> new HashSet<>()).add(key);\\n        map.put(key, currCount+1);\\n\\n        \\n    }\\n    \\n    /** Decrements an existing key by 1. If Key\\'s value is 1, remove it from the data structure. */\\n    public void dec(String key) {\\n        if(map.containsKey(key)){\\n            int currCount = map.get(key);\\n            if(currCount == 1){\\n                map.remove(key);\\n                countToKey.get(1).remove(key);\\n                 if(countToKey.get(1).isEmpty()){\\n                    countToKey.remove(currCount);\\n                }\\n            }else{\\n                map.put(key, currCount-1);\\n                countToKey.get(currCount).remove(key);\\n                if(countToKey.get(currCount).isEmpty()){\\n                    countToKey.remove(currCount);\\n                }\\n                countToKey.computeIfAbsent(currCount-1, k-> new HashSet<>()).add(key);\\n            }   \\n        }\\n    }\\n    \\n    /** Returns one of the keys with maximal value. */\\n    public String getMaxKey() {\\n        // System.out.println(countToKey);\\n        if(countToKey.firstEntry() != null)\\n            return countToKey.firstEntry().getValue().iterator().next();\\n        else{\\n            return \"\";\\n        }\\n    }\\n    \\n    /** Returns one of the keys with Minimal value. */\\n    public String getMinKey() {\\n        if(countToKey.lastEntry()!=null)\\n            return countToKey.lastEntry().getValue().iterator().next();\\n        else\\n            return \"\";\\n    }\\n}\\n\\n/**\\n * Your AllOne object will be instantiated and called as such:\\n * AllOne obj = new AllOne();\\n * obj.inc(key);\\n * obj.dec(key);\\n * String param_3 = obj.getMaxKey();\\n * String param_4 = obj.getMinKey();\\n */\\n \\n ```",
                "solutionTags": [],
                "code": "```\\nclass AllOne {\\n     TreeMap<Integer, Set<String>> countToKey;\\n    Map<String,Integer> map;\\n    /** Initialize your data structure here. */\\n    public AllOne() {\\n        map = new HashMap<>();\\n        countToKey = new TreeMap<>(Comparator.reverseOrder());\\n    }\\n    \\n    /** Inserts a new key <Key> with value 1. Or increments an existing key by 1. */\\n    public void inc(String key) {\\n\\n        int currCount = map.getOrDefault(key,0);\\n        Set<String>keys = countToKey.get(currCount);\\n        if(keys!=null) {\\n            keys.remove(key);\\n            if(keys.isEmpty()){\\n                countToKey.remove(currCount);\\n            }\\n        }\\n\\n        countToKey.computeIfAbsent(currCount+1, ka-> new HashSet<>()).add(key);\\n        map.put(key, currCount+1);\\n\\n        \\n    }\\n    \\n    /** Decrements an existing key by 1. If Key\\'s value is 1, remove it from the data structure. */\\n    public void dec(String key) {\\n        if(map.containsKey(key)){\\n            int currCount = map.get(key);\\n            if(currCount == 1){\\n                map.remove(key);\\n                countToKey.get(1).remove(key);\\n                 if(countToKey.get(1).isEmpty()){\\n                    countToKey.remove(currCount);\\n                }\\n            }else{\\n                map.put(key, currCount-1);\\n                countToKey.get(currCount).remove(key);\\n                if(countToKey.get(currCount).isEmpty()){\\n                    countToKey.remove(currCount);\\n                }\\n                countToKey.computeIfAbsent(currCount-1, k-> new HashSet<>()).add(key);\\n            }   \\n        }\\n    }\\n    \\n    /** Returns one of the keys with maximal value. */\\n    public String getMaxKey() {\\n        // System.out.println(countToKey);\\n        if(countToKey.firstEntry() != null)\\n            return countToKey.firstEntry().getValue().iterator().next();\\n        else{\\n            return \"\";\\n        }\\n    }\\n    \\n    /** Returns one of the keys with Minimal value. */\\n    public String getMinKey() {\\n        if(countToKey.lastEntry()!=null)\\n            return countToKey.lastEntry().getValue().iterator().next();\\n        else\\n            return \"\";\\n    }\\n}\\n\\n/**\\n * Your AllOne object will be instantiated and called as such:\\n * AllOne obj = new AllOne();\\n * obj.inc(key);\\n * obj.dec(key);\\n * String param_3 = obj.getMaxKey();\\n * String param_4 = obj.getMinKey();\\n */\\n \\n ```",
                "codeTag": "Java"
            },
            {
                "id": 577935,
                "title": "python-hashmap-double-linkedlist-o-1",
                "content": "```\\nclass AllOne:\\n    class Fnode:\\n        def __init__(self, val):\\n            self.val = val\\n            self.next = None\\n            self.prev = None\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.key_val = dict()\\n        self.val_key = collections.defaultdict(set)\\n        self.val_node = dict()\\n        self.head = self.Fnode(-1)\\n        self.tail = self.Fnode(-1)\\n        self.head.next = self.tail\\n        self.tail.prev = self.head\\n\\n        \\n    def inc(self, key: str) -> None:\\n        \"\"\"\\n        Inserts a new key <Key> with value 1. Or increments an existing key by 1.\\n        \"\"\"\\n        if key in self.key_val:\\n            val = self.key_val[key]\\n            self.key_val[key] = val + 1\\n            self.val_key[val].remove(key)\\n            self.val_key[val+1].add(key)\\n            node = self.val_node[val]\\n            # node management\\n            if val+1 not in self.val_node:\\n                self.insert(node, val+1, True)\\n            \\n            # if node is empty, get rid of it\\n            if len(self.val_key[val]) == 0:\\n                self.delete(node)\\n        else:\\n            self.key_val[key] = 1\\n            self.val_key[1].add(key)\\n            if 1 not in self.val_node:\\n                self.insert(self.head, 1, True)\\n    \\n    \\n    def insert(self, node, val, front):\\n        new_node = self.Fnode(val)\\n        self.val_node[val] = new_node\\n        if front:\\n            new_node.next = node.next\\n            new_node.prev = node\\n            node.next.prev = new_node\\n            node.next = new_node\\n        else:\\n            new_node.prev = node.prev\\n            new_node.next = node\\n            node.prev.next = new_node\\n            node.prev = new_node\\n        \\n        \\n    def delete(self, node):\\n        self.val_node.pop(node.val)\\n        node.prev.next = node.next\\n        node.next.prev = node.prev\\n        node.next = node.prev = None\\n        \\n        \\n    def dec(self, key: str) -> None:\\n        \"\"\"\\n        Decrements an existing key by 1. If Key\\'s value is 1, remove it from the data structure.\\n        \"\"\"\\n        if key in self.key_val:\\n            val = self.key_val[key]\\n            self.val_key[val].remove(key)\\n            node = self.val_node[val]\\n\\n            if val > 1:\\n                self.key_val[key] = val - 1\\n                self.val_key[val-1].add(key)\\n                # node management\\n                if val-1 not in self.val_node:\\n                    self.insert(node, val-1, False)\\n            else:\\n                self.key_val.pop(key)\\n            \\n            # if node is empty, get rid of it\\n            if len(self.val_key[val]) == 0:\\n                self.delete(node)\\n        \\n\\n    def getMaxKey(self) -> str:\\n        \"\"\"\\n        Returns one of the keys with maximal value.\\n        \"\"\"\\n        if self.tail.prev != self.head:\\n            keys = self.val_key[self.tail.prev.val]\\n            for key in keys:\\n                return key\\n        else:\\n            return \\'\\'\\n\\n    def getMinKey(self) -> str:\\n        \"\"\"\\n        Returns one of the keys with Minimal value.\\n        \"\"\"\\n        if self.head.next != self.tail:\\n            keys = self.val_key[self.head.next.val]\\n            for key in keys:\\n                return key\\n        else:\\n            return \\'\\'\\n        \\n\\n\\n# Your AllOne object will be instantiated and called as such:\\n# obj = AllOne()\\n# obj.inc(key)\\n# obj.dec(key)\\n# param_3 = obj.getMaxKey()\\n# param_4 = obj.getMinKey()\\n```",
                "solutionTags": [],
                "code": "```\\nclass AllOne:\\n    class Fnode:\\n        def __init__(self, val):\\n            self.val = val\\n            self.next = None\\n            self.prev = None\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.key_val = dict()\\n        self.val_key = collections.defaultdict(set)\\n        self.val_node = dict()\\n        self.head = self.Fnode(-1)\\n        self.tail = self.Fnode(-1)\\n        self.head.next = self.tail\\n        self.tail.prev = self.head\\n\\n        \\n    def inc(self, key: str) -> None:\\n        \"\"\"\\n        Inserts a new key <Key> with value 1. Or increments an existing key by 1.\\n        \"\"\"\\n        if key in self.key_val:\\n            val = self.key_val[key]\\n            self.key_val[key] = val + 1\\n            self.val_key[val].remove(key)\\n            self.val_key[val+1].add(key)\\n            node = self.val_node[val]\\n            # node management\\n            if val+1 not in self.val_node:\\n                self.insert(node, val+1, True)\\n            \\n            # if node is empty, get rid of it\\n            if len(self.val_key[val]) == 0:\\n                self.delete(node)\\n        else:\\n            self.key_val[key] = 1\\n            self.val_key[1].add(key)\\n            if 1 not in self.val_node:\\n                self.insert(self.head, 1, True)\\n    \\n    \\n    def insert(self, node, val, front):\\n        new_node = self.Fnode(val)\\n        self.val_node[val] = new_node\\n        if front:\\n            new_node.next = node.next\\n            new_node.prev = node\\n            node.next.prev = new_node\\n            node.next = new_node\\n        else:\\n            new_node.prev = node.prev\\n            new_node.next = node\\n            node.prev.next = new_node\\n            node.prev = new_node\\n        \\n        \\n    def delete(self, node):\\n        self.val_node.pop(node.val)\\n        node.prev.next = node.next\\n        node.next.prev = node.prev\\n        node.next = node.prev = None\\n        \\n        \\n    def dec(self, key: str) -> None:\\n        \"\"\"\\n        Decrements an existing key by 1. If Key\\'s value is 1, remove it from the data structure.\\n        \"\"\"\\n        if key in self.key_val:\\n            val = self.key_val[key]\\n            self.val_key[val].remove(key)\\n            node = self.val_node[val]\\n\\n            if val > 1:\\n                self.key_val[key] = val - 1\\n                self.val_key[val-1].add(key)\\n                # node management\\n                if val-1 not in self.val_node:\\n                    self.insert(node, val-1, False)\\n            else:\\n                self.key_val.pop(key)\\n            \\n            # if node is empty, get rid of it\\n            if len(self.val_key[val]) == 0:\\n                self.delete(node)\\n        \\n\\n    def getMaxKey(self) -> str:\\n        \"\"\"\\n        Returns one of the keys with maximal value.\\n        \"\"\"\\n        if self.tail.prev != self.head:\\n            keys = self.val_key[self.tail.prev.val]\\n            for key in keys:\\n                return key\\n        else:\\n            return \\'\\'\\n\\n    def getMinKey(self) -> str:\\n        \"\"\"\\n        Returns one of the keys with Minimal value.\\n        \"\"\"\\n        if self.head.next != self.tail:\\n            keys = self.val_key[self.head.next.val]\\n            for key in keys:\\n                return key\\n        else:\\n            return \\'\\'\\n        \\n\\n\\n# Your AllOne object will be instantiated and called as such:\\n# obj = AllOne()\\n# obj.inc(key)\\n# obj.dec(key)\\n# param_3 = obj.getMaxKey()\\n# param_4 = obj.getMinKey()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 574416,
                "title": "python-very-easy-double-hashmap-o-1-solution-92ms",
                "content": "\\n```\\nclass AllOne:\\n\\n    def __init__(self):\\n        self.value_key=collections.defaultdict(set) #value: set(keys)\\n        self.key_value=collections.defaultdict(int) #key:value\\n        self.max_values=collections.deque()\\n    def inc(self, key: str) -> None:\\n        v=self.key_value[key]\\n        self.key_value[key]=v+1\\n        if v>0:\\n            self.value_key[v].remove(key)\\n        self.value_key[v+1].add(key)\\n        if (not self.max_values) or v+1>self.max_values[-1]:\\n            self.max_values.append(v+1)\\n        elif v+1<self.max_values[0]:\\n            self.max_values.appendleft(v+1)\\n    def dec(self, key: str) -> None:\\n        if key not in self.key_value:\\n            return\\n        v=self.key_value[key]\\n        self.key_value[key]=v-1\\n        self.value_key[v].remove(key)\\n        if v>1:\\n            self.value_key[v-1].add(key)\\n            if (not self.max_values) or v-1<self.max_values[0]:\\n                self.max_values.appendleft(v+1)\\n            \\n    def getMaxKey(self) -> str:\\n        while(self.max_values and len(self.value_key[self.max_values[-1]])==0):\\n            self.max_values.pop()\\n        if not self.max_values:\\n            return \"\"\\n        for i in self.value_key[self.max_values[-1]]:\\n            return i\\n\\n    def getMinKey(self) -> str:\\n        while(self.max_values and len(self.value_key[self.max_values[0]])==0):\\n            self.max_values.popleft()\\n        if not self.max_values:\\n            return \"\"\\n        for i in self.value_key[self.max_values[0]]:\\n            return i\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass AllOne:\\n\\n    def __init__(self):\\n        self.value_key=collections.defaultdict(set) #value: set(keys)\\n        self.key_value=collections.defaultdict(int) #key:value\\n        self.max_values=collections.deque()\\n    def inc(self, key: str) -> None:\\n        v=self.key_value[key]\\n        self.key_value[key]=v+1\\n        if v>0:\\n            self.value_key[v].remove(key)\\n        self.value_key[v+1].add(key)\\n        if (not self.max_values) or v+1>self.max_values[-1]:\\n            self.max_values.append(v+1)\\n        elif v+1<self.max_values[0]:\\n            self.max_values.appendleft(v+1)\\n    def dec(self, key: str) -> None:\\n        if key not in self.key_value:\\n            return\\n        v=self.key_value[key]\\n        self.key_value[key]=v-1\\n        self.value_key[v].remove(key)\\n        if v>1:\\n            self.value_key[v-1].add(key)\\n            if (not self.max_values) or v-1<self.max_values[0]:\\n                self.max_values.appendleft(v+1)\\n            \\n    def getMaxKey(self) -> str:\\n        while(self.max_values and len(self.value_key[self.max_values[-1]])==0):\\n            self.max_values.pop()\\n        if not self.max_values:\\n            return \"\"\\n        for i in self.value_key[self.max_values[-1]]:\\n            return i\\n\\n    def getMinKey(self) -> str:\\n        while(self.max_values and len(self.value_key[self.max_values[0]])==0):\\n            self.max_values.popleft()\\n        if not self.max_values:\\n            return \"\"\\n        for i in self.value_key[self.max_values[0]]:\\n            return i\\n```",
                "codeTag": "Java"
            },
            {
                "id": 540978,
                "title": "clear-python-solution-double-linked-list-with-dummy-head-tail",
                "content": "432. All O`one Data Structure\\n\\n```python\\nclass Node(object):\\n    def __init__(self, key, val):\\n        self.key = key\\n        self.val = val\\n        self.prev = None\\n        self.next = None\\n        \\nclass AllOne:\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.mapping = {}\\n        self.head = Node(\"max\", float(\"inf\")) # maximum\\n        self.tail = Node(\"min\", float(\"-inf\")) # minimum\\n        self.head.next = self.tail\\n        self.tail.prev = self.head\\n\\n    def inc(self, key: str) -> None:\\n        \"\"\"\\n        Inserts a new key <Key> with value 1. Or increments an existing key by 1.\\n        \"\"\"\\n        if key in self.mapping:\\n            node = self.mapping[key]\\n            node.val += 1\\n            while node.prev.val < node.val:\\n                self._swap(node.prev, node)\\n        else:\\n            node = Node(key, 1)\\n            self.mapping[key] = node\\n            self._add(node)\\n            \\n    def dec(self, key: str) -> None:\\n        \"\"\"\\n        Decrements an existing key by 1. If Key\\'s value is 1, remove it from the data structure.\\n        \"\"\"\\n        if key in self.mapping:\\n            node = self.mapping[key]\\n            node.val -= 1\\n            if node.val == 0:\\n                self._remove(node)\\n            else:\\n                while node.val < node.next.val:\\n                    self._swap(node, node.next)\\n        else:\\n            return\\n\\n    def getMaxKey(self) -> str:\\n        \"\"\"\\n        Returns one of the keys with maximal value.\\n        \"\"\"\\n        first = self.head.next\\n        if first != self.tail:\\n            return first.key\\n        else:\\n            return \"\"\\n        \\n    def getMinKey(self) -> str:\\n        \"\"\"\\n        Returns one of the keys with Minimal value.\\n        \"\"\"\\n        last = self.tail.prev\\n        if last != self.head:\\n            return last.key\\n        else:\\n            return \"\"\\n    \\n    def _swap(self, node1, node2):\\n        # prev node1 node2 next => prev node2 node1 next\\n        pre = node1.prev\\n        nxt = node2.next\\n        \\n        node1.prev = node2\\n        node1.next = nxt\\n        \\n        node2.prev = pre\\n        node2.next = node1\\n        \\n        pre.next = node2\\n        nxt.prev = node1\\n        \\n    def _add(self, node):\\n        # add node between last and tail\\n        last = self.tail.prev\\n        last.next = node\\n        node.prev = last\\n        node.next = self.tail\\n        self.tail.prev = node\\n       \\n    def _remove(self, node):\\n        # link pre and node.next\\n        pre = node.prev\\n        pre.next = node.next\\n        node.next.prev = pre\\n    \\n# Your AllOne object will be instantiated and called as such:\\n# obj = AllOne()\\n# obj.inc(key)\\n# obj.dec(key)\\n# param_3 = obj.getMaxKey()\\n# param_4 = obj.getMinKey()\\n```\\n\\n146. LRU cache\\n\\n```python\\nclass Node(object):\\n    def __init__(self, key, value):\\n        self.key = key\\n        self.val = value\\n        self.prev = None\\n        self.next = None\\n        \\nclass LRUCache(object):\\n\\n    def __init__(self, capacity):\\n        \"\"\"\\n        :type capacity: int\\n        \"\"\"\\n        self.capacity = capacity\\n        self.cache = {}\\n        self.head = Node(-1, -1)\\n        self.tail = Node(-1, -1)\\n        self.head.next = self.tail\\n        self.tail.prev = self.head\\n\\n    def get(self, key):\\n        \"\"\"\\n        :type key: int\\n        :rtype: int\\n        \"\"\"\\n        if key in self.cache:\\n            node = self.cache[key]\\n            self._remove(node)\\n            self._add(node)\\n            return node.val\\n        else:\\n            return -1\\n\\n    def put(self, key, value):\\n        \"\"\"\\n        :type key: int\\n        :type value: int\\n        :rtype: None\\n        \"\"\"\\n        if key in self.cache:\\n            self._remove(self.cache[key])\\n        node = Node(key, value)\\n        self._add(node)\\n        self.cache[key] = node\\n        if len(self.cache) > self.capacity:\\n            node = self.head.next\\n            self._remove(node)\\n            self.cache.pop(node.key)\\n            \\n    def _remove(self, node):\\n        # link pre and node.next\\n        pre = node.prev\\n        pre.next = node.next\\n        node.next.prev = pre\\n    \\n    def _add(self, node):\\n        # add node between last and tail\\n        last = self.tail.prev\\n        last.next = node\\n        node.prev = last\\n        node.next = self.tail\\n        self.tail.prev = node\\n        \\n# Your LRUCache object will be instantiated and called as such:\\n# obj = LRUCache(capacity)\\n# param_1 = obj.get(key)\\n# obj.put(key,value)\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Node(object):\\n    def __init__(self, key, val):\\n        self.key = key\\n        self.val = val\\n        self.prev = None\\n        self.next = None\\n        \\nclass AllOne:\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.mapping = {}\\n        self.head = Node(\"max\", float(\"inf\")) # maximum\\n        self.tail = Node(\"min\", float(\"-inf\")) # minimum\\n        self.head.next = self.tail\\n        self.tail.prev = self.head\\n\\n    def inc(self, key: str) -> None:\\n        \"\"\"\\n        Inserts a new key <Key> with value 1. Or increments an existing key by 1.\\n        \"\"\"\\n        if key in self.mapping:\\n            node = self.mapping[key]\\n            node.val += 1\\n            while node.prev.val < node.val:\\n                self._swap(node.prev, node)\\n        else:\\n            node = Node(key, 1)\\n            self.mapping[key] = node\\n            self._add(node)\\n            \\n    def dec(self, key: str) -> None:\\n        \"\"\"\\n        Decrements an existing key by 1. If Key\\'s value is 1, remove it from the data structure.\\n        \"\"\"\\n        if key in self.mapping:\\n            node = self.mapping[key]\\n            node.val -= 1\\n            if node.val == 0:\\n                self._remove(node)\\n            else:\\n                while node.val < node.next.val:\\n                    self._swap(node, node.next)\\n        else:\\n            return\\n\\n    def getMaxKey(self) -> str:\\n        \"\"\"\\n        Returns one of the keys with maximal value.\\n        \"\"\"\\n        first = self.head.next\\n        if first != self.tail:\\n            return first.key\\n        else:\\n            return \"\"\\n        \\n    def getMinKey(self) -> str:\\n        \"\"\"\\n        Returns one of the keys with Minimal value.\\n        \"\"\"\\n        last = self.tail.prev\\n        if last != self.head:\\n            return last.key\\n        else:\\n            return \"\"\\n    \\n    def _swap(self, node1, node2):\\n        # prev node1 node2 next => prev node2 node1 next\\n        pre = node1.prev\\n        nxt = node2.next\\n        \\n        node1.prev = node2\\n        node1.next = nxt\\n        \\n        node2.prev = pre\\n        node2.next = node1\\n        \\n        pre.next = node2\\n        nxt.prev = node1\\n        \\n    def _add(self, node):\\n        # add node between last and tail\\n        last = self.tail.prev\\n        last.next = node\\n        node.prev = last\\n        node.next = self.tail\\n        self.tail.prev = node\\n       \\n    def _remove(self, node):\\n        # link pre and node.next\\n        pre = node.prev\\n        pre.next = node.next\\n        node.next.prev = pre\\n    \\n# Your AllOne object will be instantiated and called as such:\\n# obj = AllOne()\\n# obj.inc(key)\\n# obj.dec(key)\\n# param_3 = obj.getMaxKey()\\n# param_4 = obj.getMinKey()\\n```\n```python\\nclass Node(object):\\n    def __init__(self, key, value):\\n        self.key = key\\n        self.val = value\\n        self.prev = None\\n        self.next = None\\n        \\nclass LRUCache(object):\\n\\n    def __init__(self, capacity):\\n        \"\"\"\\n        :type capacity: int\\n        \"\"\"\\n        self.capacity = capacity\\n        self.cache = {}\\n        self.head = Node(-1, -1)\\n        self.tail = Node(-1, -1)\\n        self.head.next = self.tail\\n        self.tail.prev = self.head\\n\\n    def get(self, key):\\n        \"\"\"\\n        :type key: int\\n        :rtype: int\\n        \"\"\"\\n        if key in self.cache:\\n            node = self.cache[key]\\n            self._remove(node)\\n            self._add(node)\\n            return node.val\\n        else:\\n            return -1\\n\\n    def put(self, key, value):\\n        \"\"\"\\n        :type key: int\\n        :type value: int\\n        :rtype: None\\n        \"\"\"\\n        if key in self.cache:\\n            self._remove(self.cache[key])\\n        node = Node(key, value)\\n        self._add(node)\\n        self.cache[key] = node\\n        if len(self.cache) > self.capacity:\\n            node = self.head.next\\n            self._remove(node)\\n            self.cache.pop(node.key)\\n            \\n    def _remove(self, node):\\n        # link pre and node.next\\n        pre = node.prev\\n        pre.next = node.next\\n        node.next.prev = pre\\n    \\n    def _add(self, node):\\n        # add node between last and tail\\n        last = self.tail.prev\\n        last.next = node\\n        node.prev = last\\n        node.next = self.tail\\n        self.tail.prev = node\\n        \\n# Your LRUCache object will be instantiated and called as such:\\n# obj = LRUCache(capacity)\\n# param_1 = obj.get(key)\\n# obj.put(key,value)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 530454,
                "title": "java-o-1-hashmap-double-linked-list-hashset-self-explanatory-clean-code-super-concise",
                "content": "All O(1) operation with one HashMap and DoubleLinkedList.\\n\\n```\\n    public void inc(String key) {\\n        Node curBucket = keyMap.getOrDefault(key, head);\\n        addIntoNewBucket(prepareNextBucket(curBucket), key);\\n        cleanCurrentBucket(curBucket, key);\\n    }\\n\\t\\n    public void dec(String key) {\\n        if(!keyMap.containsKey(key)) return;\\n        Node curBucket = keyMap.get(key);\\n        addIntoNewBucket(preparePrevBucket(curBucket), key);\\n        cleanCurrentBucket(curBucket, key);\\n    }\\n    \\n    public String getMaxKey() {\\n        return tail.prev == head ? \"\" : tail.prev.keys.iterator().next();\\n    }\\n    \\n    public String getMinKey() {\\n        return head.next == tail ? \"\" : head.next.keys.iterator().next();\\n    }\\n    \\n    private void addIntoNewBucket(Node newBucket, String key) {\\n        newBucket.keys.add(key);\\n        if(newBucket.cnt == 0) keyMap.remove(key);\\n        else keyMap.put(key, newBucket);\\n    }\\n    \\n    private void cleanCurrentBucket(Node curBucket, String key) {\\n        if(curBucket != head) curBucket.keys.remove(key);\\n        if(curBucket.keys.isEmpty()) remove(curBucket);\\n    }\\n    \\n    private Node prepareNextBucket(Node curBucket) {\\n        return curBucket.next.cnt == curBucket.cnt + 1 ? curBucket.next : insertNext(curBucket, new Node(curBucket.cnt + 1));\\n    }\\n\\n    private Node preparePrevBucket(Node curBucket) {\\n        return curBucket.prev.cnt == curBucket.cnt - 1 ? curBucket.prev : insertBefore(curBucket, new Node(curBucket.cnt - 1));\\n    }\\n        \\n    private Node insertNext(Node cur, Node node) {\\n        cur.next.prev = node;\\n        node.next = cur.next;\\n        cur.next = node;\\n        node.prev = cur;\\n        return node;\\n    }\\n    \\n    private Node insertBefore(Node cur, Node node) {\\n        cur.prev.next = node;\\n        node.prev = cur.prev;\\n        cur.prev = node;\\n        node.next = cur;\\n        return node;\\n    }\\n    \\n    private void remove(Node node) {\\n        if(node == head || node == tail) return;\\n        node.prev.next = node.next;\\n        node.next.prev = node.prev;\\n        node.next = null;\\n        node.prev = null;\\n    }\\n\\n    public AllOne() {\\n        head = new Node(0);\\n        tail = new Node(Integer.MAX_VALUE);\\n        \\n        head.next = tail;\\n        tail.prev = head;\\n        \\n        keyMap = new HashMap<>();\\n    }\\n\\t\\n\\tclass Node {\\n        int cnt;\\n        Node prev; \\n        Node next;\\n        Set<String> keys;\\n        Node(int cnt) {\\n            this.cnt = cnt;\\n            keys = new HashSet<>();\\n        }\\n    }\\n    \\n    Node head;\\n    Node tail;\\n    Map<String, Node> keyMap;\\n```",
                "solutionTags": [],
                "code": "```\\n    public void inc(String key) {\\n        Node curBucket = keyMap.getOrDefault(key, head);\\n        addIntoNewBucket(prepareNextBucket(curBucket), key);\\n        cleanCurrentBucket(curBucket, key);\\n    }\\n\\t\\n    public void dec(String key) {\\n        if(!keyMap.containsKey(key)) return;\\n        Node curBucket = keyMap.get(key);\\n        addIntoNewBucket(preparePrevBucket(curBucket), key);\\n        cleanCurrentBucket(curBucket, key);\\n    }\\n    \\n    public String getMaxKey() {\\n        return tail.prev == head ? \"\" : tail.prev.keys.iterator().next();\\n    }\\n    \\n    public String getMinKey() {\\n        return head.next == tail ? \"\" : head.next.keys.iterator().next();\\n    }\\n    \\n    private void addIntoNewBucket(Node newBucket, String key) {\\n        newBucket.keys.add(key);\\n        if(newBucket.cnt == 0) keyMap.remove(key);\\n        else keyMap.put(key, newBucket);\\n    }\\n    \\n    private void cleanCurrentBucket(Node curBucket, String key) {\\n        if(curBucket != head) curBucket.keys.remove(key);\\n        if(curBucket.keys.isEmpty()) remove(curBucket);\\n    }\\n    \\n    private Node prepareNextBucket(Node curBucket) {\\n        return curBucket.next.cnt == curBucket.cnt + 1 ? curBucket.next : insertNext(curBucket, new Node(curBucket.cnt + 1));\\n    }\\n\\n    private Node preparePrevBucket(Node curBucket) {\\n        return curBucket.prev.cnt == curBucket.cnt - 1 ? curBucket.prev : insertBefore(curBucket, new Node(curBucket.cnt - 1));\\n    }\\n        \\n    private Node insertNext(Node cur, Node node) {\\n        cur.next.prev = node;\\n        node.next = cur.next;\\n        cur.next = node;\\n        node.prev = cur;\\n        return node;\\n    }\\n    \\n    private Node insertBefore(Node cur, Node node) {\\n        cur.prev.next = node;\\n        node.prev = cur.prev;\\n        cur.prev = node;\\n        node.next = cur;\\n        return node;\\n    }\\n    \\n    private void remove(Node node) {\\n        if(node == head || node == tail) return;\\n        node.prev.next = node.next;\\n        node.next.prev = node.prev;\\n        node.next = null;\\n        node.prev = null;\\n    }\\n\\n    public AllOne() {\\n        head = new Node(0);\\n        tail = new Node(Integer.MAX_VALUE);\\n        \\n        head.next = tail;\\n        tail.prev = head;\\n        \\n        keyMap = new HashMap<>();\\n    }\\n\\t\\n\\tclass Node {\\n        int cnt;\\n        Node prev; \\n        Node next;\\n        Set<String> keys;\\n        Node(int cnt) {\\n            this.cnt = cnt;\\n            keys = new HashSet<>();\\n        }\\n    }\\n    \\n    Node head;\\n    Node tail;\\n    Map<String, Node> keyMap;\\n```",
                "codeTag": "Java"
            },
            {
                "id": 521209,
                "title": "accepted-c-solution-o-1-operations-linkedlist-dictionary",
                "content": "```\\n    public class AllOne\\n    {\\n        private readonly LinkedList<(ISet<string> keys, int value)> _ll;\\n        private readonly IDictionary<string, LinkedListNode<(ISet<string> keys, int value)>> _map;\\n        \\n        public AllOne()\\n        {\\n            _ll = new LinkedList<(ISet<string> keys, int value)>();\\n            _map = new Dictionary<string, LinkedListNode<(ISet<string> keys, int value)>>();\\n        }\\n\\n        /** Inserts a new key <Key> with value 1. Or increments an existing key by 1. */\\n        public void Inc(string key)\\n        {\\n            if (!_map.ContainsKey(key))\\n            {\\n                LinkedListNode<(ISet<string> keys, int value)> node = null;\\n                if (_ll.Count == 0)\\n                {\\n                    node = _ll.AddFirst((new HashSet<string>(), 1));\\n                }\\n                else\\n                {\\n                    if(_ll.First.Value.value == 1)\\n                    {\\n                        node = _ll.First;\\n                    }\\n                    else\\n                    {\\n                        node = _ll.AddFirst((new HashSet<string>(), 1));\\n                    }\\n                }\\n\\n                node.Value.keys.Add(key);\\n                _map[key] = node;\\n                return;\\n            }\\n\\n            var currentNode = _map[key];\\n            var next = currentNode.Next;\\n            currentNode.Value.keys.Remove(key);\\n\\n            if (next == null)\\n            {\\n                next = _ll.AddAfter(currentNode, (new HashSet<string>(), currentNode.Value.value + 1));\\n            }\\n            else\\n            {\\n                if (next.Value.value > currentNode.Value.value + 1)\\n                {\\n                    next = _ll.AddAfter(currentNode, (new HashSet<string>(), currentNode.Value.value + 1));\\n                }\\n            }\\n\\n            next.Value.keys.Add(key);\\n            _map[key] = next;\\n\\n            if (currentNode.Value.keys.Count == 0)\\n            {\\n                _ll.Remove(currentNode);\\n            }\\n        }\\n\\n        /** Decrements an existing key by 1. If Key\\'s value is 1, remove it from the data structure. */\\n        public void Dec(string key)\\n        {\\n            if (!_map.ContainsKey(key))\\n            {\\n                return;\\n            }\\n\\n            var currentNode = _map[key];\\n            var prevNode = currentNode.Previous;\\n\\n            currentNode.Value.keys.Remove(key);\\n\\n            if (currentNode.Value.value != 1)\\n            {\\n                if (prevNode == null)\\n                {\\n                    prevNode = _ll.AddBefore(currentNode, (new HashSet<string>(), currentNode.Value.value - 1));\\n                }\\n                else\\n                {\\n                    if (prevNode.Value.value < currentNode.Value.value - 1)\\n                    {\\n                        prevNode = _ll.AddBefore(currentNode, (new HashSet<string>(), currentNode.Value.value - 1));\\n                    }\\n                }\\n\\n                prevNode.Value.keys.Add(key);\\n                _map[key] = prevNode;\\n            }\\n            else\\n            {\\n                _map.Remove(key);\\n            }\\n\\n            if (currentNode.Value.keys.Count == 0)\\n            {\\n                _ll.Remove(currentNode);\\n            }\\n        }\\n\\n        /** Returns one of the keys with maximal value. */\\n        public string GetMaxKey()\\n        {\\n            if (_ll.Count > 0)\\n            {\\n                return _ll.Last.Value.keys.First();\\n            }\\n\\n            return string.Empty;\\n        }\\n\\n        /** Returns one of the keys with Minimal value. */\\n        public string GetMinKey()\\n        {\\n            if (_ll.Count > 0)\\n            {\\n                return _ll.First.Value.keys.First();\\n            }\\n\\n            return string.Empty;\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Linked List"
                ],
                "code": "```\\n    public class AllOne\\n    {\\n        private readonly LinkedList<(ISet<string> keys, int value)> _ll;\\n        private readonly IDictionary<string, LinkedListNode<(ISet<string> keys, int value)>> _map;\\n        \\n        public AllOne()\\n        {\\n            _ll = new LinkedList<(ISet<string> keys, int value)>();\\n            _map = new Dictionary<string, LinkedListNode<(ISet<string> keys, int value)>>();\\n        }\\n\\n        /** Inserts a new key <Key> with value 1. Or increments an existing key by 1. */\\n        public void Inc(string key)\\n        {\\n            if (!_map.ContainsKey(key))\\n            {\\n                LinkedListNode<(ISet<string> keys, int value)> node = null;\\n                if (_ll.Count == 0)\\n                {\\n                    node = _ll.AddFirst((new HashSet<string>(), 1));\\n                }\\n                else\\n                {\\n                    if(_ll.First.Value.value == 1)\\n                    {\\n                        node = _ll.First;\\n                    }\\n                    else\\n                    {\\n                        node = _ll.AddFirst((new HashSet<string>(), 1));\\n                    }\\n                }\\n\\n                node.Value.keys.Add(key);\\n                _map[key] = node;\\n                return;\\n            }\\n\\n            var currentNode = _map[key];\\n            var next = currentNode.Next;\\n            currentNode.Value.keys.Remove(key);\\n\\n            if (next == null)\\n            {\\n                next = _ll.AddAfter(currentNode, (new HashSet<string>(), currentNode.Value.value + 1));\\n            }\\n            else\\n            {\\n                if (next.Value.value > currentNode.Value.value + 1)\\n                {\\n                    next = _ll.AddAfter(currentNode, (new HashSet<string>(), currentNode.Value.value + 1));\\n                }\\n            }\\n\\n            next.Value.keys.Add(key);\\n            _map[key] = next;\\n\\n            if (currentNode.Value.keys.Count == 0)\\n            {\\n                _ll.Remove(currentNode);\\n            }\\n        }\\n\\n        /** Decrements an existing key by 1. If Key\\'s value is 1, remove it from the data structure. */\\n        public void Dec(string key)\\n        {\\n            if (!_map.ContainsKey(key))\\n            {\\n                return;\\n            }\\n\\n            var currentNode = _map[key];\\n            var prevNode = currentNode.Previous;\\n\\n            currentNode.Value.keys.Remove(key);\\n\\n            if (currentNode.Value.value != 1)\\n            {\\n                if (prevNode == null)\\n                {\\n                    prevNode = _ll.AddBefore(currentNode, (new HashSet<string>(), currentNode.Value.value - 1));\\n                }\\n                else\\n                {\\n                    if (prevNode.Value.value < currentNode.Value.value - 1)\\n                    {\\n                        prevNode = _ll.AddBefore(currentNode, (new HashSet<string>(), currentNode.Value.value - 1));\\n                    }\\n                }\\n\\n                prevNode.Value.keys.Add(key);\\n                _map[key] = prevNode;\\n            }\\n            else\\n            {\\n                _map.Remove(key);\\n            }\\n\\n            if (currentNode.Value.keys.Count == 0)\\n            {\\n                _ll.Remove(currentNode);\\n            }\\n        }\\n\\n        /** Returns one of the keys with maximal value. */\\n        public string GetMaxKey()\\n        {\\n            if (_ll.Count > 0)\\n            {\\n                return _ll.Last.Value.keys.First();\\n            }\\n\\n            return string.Empty;\\n        }\\n\\n        /** Returns one of the keys with Minimal value. */\\n        public string GetMinKey()\\n        {\\n            if (_ll.Count > 0)\\n            {\\n                return _ll.First.Value.keys.First();\\n            }\\n\\n            return string.Empty;\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 428338,
                "title": "works-96-speed-o-n-on-max-min",
                "content": "[ I know we are striving for O(1). However, this completes withing time limit and performs well. I\\'d consider it my \"first take\" in an interview. I would follow it up with an improved solution if time permits. ]\\n\\n```\\nconst max = Math.max;\\nconst min = Math.min;\\n/**\\n * Initialize your data structure here.\\n */\\nvar AllOne = function() {\\n    this.data = {};\\n};\\n\\n/**\\n * Inserts a new key <Key> with value 1. Or increments an existing key by 1.\\n * @param {string} key\\n * @return {void}\\n */\\nAllOne.prototype.inc = function(key) {\\n    if(!(key in this.data)) {\\n        this.data[key] = 1;\\n        return;\\n    }\\n    this.data[key] += 1;\\n};\\n\\n/**\\n * Decrements an existing key by 1. If Key\\'s value is 1, remove it from the data structure.\\n * @param {string} key\\n * @return {void}\\n */\\nAllOne.prototype.dec = function(key) {\\n    if(!(key in this.data)) {\\n        return;\\n    }\\n    if(this.data[key] === 1){\\n        delete this.data[key];\\n        return;\\n    }\\n    this.data[key] -= 1;\\n};\\n\\n/**\\n * Returns one of the keys with maximal value.\\n * @return {string}\\n */\\nAllOne.prototype.getMaxKey = function() {\\n    let max = 0;\\n    let maxKey = \\'\\';\\n    for(let [key, value] of Object.entries(this.data)) {\\n        if(value > max) {\\n            max = value;\\n            maxKey = key;\\n        }\\n    }\\n    return maxKey;\\n};\\n\\n/**\\n * Returns one of the keys with Minimal value.\\n * @return {string}\\n */\\nAllOne.prototype.getMinKey = function() {\\n    let minKey = \\'\\';\\n    let min = Infinity;\\n    for(let [key, value] of Object.entries(this.data)) {\\n        if(value === 1) return key; // minimum possible\\n        if(value < min) {\\n            min = value;\\n            minKey = key;\\n        }\\n    }\\n    return minKey;\\n};\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nconst max = Math.max;\\nconst min = Math.min;\\n/**\\n * Initialize your data structure here.\\n */\\nvar AllOne = function() {\\n    this.data = {};\\n};\\n\\n/**\\n * Inserts a new key <Key> with value 1. Or increments an existing key by 1.\\n * @param {string} key\\n * @return {void}\\n */\\nAllOne.prototype.inc = function(key) {\\n    if(!(key in this.data)) {\\n        this.data[key] = 1;\\n        return;\\n    }\\n    this.data[key] += 1;\\n};\\n\\n/**\\n * Decrements an existing key by 1. If Key\\'s value is 1, remove it from the data structure.\\n * @param {string} key\\n * @return {void}\\n */\\nAllOne.prototype.dec = function(key) {\\n    if(!(key in this.data)) {\\n        return;\\n    }\\n    if(this.data[key] === 1){\\n        delete this.data[key];\\n        return;\\n    }\\n    this.data[key] -= 1;\\n};\\n\\n/**\\n * Returns one of the keys with maximal value.\\n * @return {string}\\n */\\nAllOne.prototype.getMaxKey = function() {\\n    let max = 0;\\n    let maxKey = \\'\\';\\n    for(let [key, value] of Object.entries(this.data)) {\\n        if(value > max) {\\n            max = value;\\n            maxKey = key;\\n        }\\n    }\\n    return maxKey;\\n};\\n\\n/**\\n * Returns one of the keys with Minimal value.\\n * @return {string}\\n */\\nAllOne.prototype.getMinKey = function() {\\n    let minKey = \\'\\';\\n    let min = Infinity;\\n    for(let [key, value] of Object.entries(this.data)) {\\n        if(value === 1) return key; // minimum possible\\n        if(value < min) {\\n            min = value;\\n            minKey = key;\\n        }\\n    }\\n    return minKey;\\n};\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 414648,
                "title": "python-3-simple-o-1-amortized",
                "content": "Time complexity is amortized `O(1)` \\n\\nThere are two maps, one keeps `(key, count)` other keeps `(count, set of keys)`\\n\\n```\\nclass AllOne:\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.cnts, self.keys = collections.defaultdict(set), collections.defaultdict(int)\\n        self.min, self.max = 0, 0\\n\\n    def inc(self, key: str) -> None:\\n        \"\"\"\\n        Inserts a new key <Key> with value 1. Or increments an existing key by 1.\\n        \"\"\"\\n        self.keys[key] = self.keys.get(key, 0) + 1\\n        self.cnts[self.keys[key]].add(key)\\n        if key in self.cnts[self.keys[key]-1]:\\n            self.cnts[self.keys[key]-1].remove(key)\\n\\n        # update max variable\\n        if self.max == self.keys[key]-1:\\n            self.max += 1\\n        # update min variable\\n        if self.keys[key] == 1:\\n            self.min = 1\\n        else:\\n            if self.min == self.keys[key]-1 and len(self.cnts[self.min]) == 0:\\n                self.min += 1\\n\\n    def dec(self, key: str) -> None:\\n        \"\"\"\\n        Decrements an existing key by 1. If Key\\'s value is 1, remove it from the data structure.\\n        \"\"\"\\n        if key in self.keys:\\n            self.cnts[self.keys[key]].remove(key)\\n            if self.keys[key] == 1:\\n                del self.keys[key]\\n            else:\\n                self.keys[key] -= 1\\n                self.cnts[self.keys[key]].add(key)\\n                \\n            if len(self.cnts[self.min]) == 0:\\n                if key in self.keys:\\n                    self.min = self.keys[key]\\n                else:\\n                    # find min key\\n                    self.min = float(\\'inf\\')\\n                    for k in self.keys:\\n                        self.min = min(self.keys[k], self.min)\\n                    self.min = 0 if self.min == float(\\'inf\\') else self.min\\n            if len(self.cnts[self.max]) == 0:\\n                if key in self.keys:\\n                    self.max = self.keys[key]\\n                else:\\n                    # find max key\\n                    self.max = float(\\'-inf\\')\\n                    for k in self.keys:\\n                        self.min = max(self.keys[k], self.min)\\n                    self.max = 0 if self.max == float(\\'-inf\\') else self.max\\n                \\n                \\n    def getMaxKey(self) -> str:\\n        \"\"\"\\n        Returns one of the keys with maximal value.\\n        \"\"\"\\n        if self.max > 0:\\n            for e in self.cnts[self.max]:\\n                return e\\n        return \\'\\'\\n\\n    def getMinKey(self) -> str:\\n        \"\"\"\\n        Returns one of the keys with Minimal value.\\n        \"\"\"\\n        if self.min > 0:\\n            for e in self.cnts[self.min]:\\n                return e\\n        return \\'\\'\\n\\n\\n# Your AllOne object will be instantiated and called as such:\\n# obj = AllOne()\\n# obj.inc(key)\\n# obj.dec(key)\\n# param_3 = obj.getMaxKey()\\n# param_4 = obj.getMinKey()\\n```",
                "solutionTags": [],
                "code": "```\\nclass AllOne:\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.cnts, self.keys = collections.defaultdict(set), collections.defaultdict(int)\\n        self.min, self.max = 0, 0\\n\\n    def inc(self, key: str) -> None:\\n        \"\"\"\\n        Inserts a new key <Key> with value 1. Or increments an existing key by 1.\\n        \"\"\"\\n        self.keys[key] = self.keys.get(key, 0) + 1\\n        self.cnts[self.keys[key]].add(key)\\n        if key in self.cnts[self.keys[key]-1]:\\n            self.cnts[self.keys[key]-1].remove(key)\\n\\n        # update max variable\\n        if self.max == self.keys[key]-1:\\n            self.max += 1\\n        # update min variable\\n        if self.keys[key] == 1:\\n            self.min = 1\\n        else:\\n            if self.min == self.keys[key]-1 and len(self.cnts[self.min]) == 0:\\n                self.min += 1\\n\\n    def dec(self, key: str) -> None:\\n        \"\"\"\\n        Decrements an existing key by 1. If Key\\'s value is 1, remove it from the data structure.\\n        \"\"\"\\n        if key in self.keys:\\n            self.cnts[self.keys[key]].remove(key)\\n            if self.keys[key] == 1:\\n                del self.keys[key]\\n            else:\\n                self.keys[key] -= 1\\n                self.cnts[self.keys[key]].add(key)\\n                \\n            if len(self.cnts[self.min]) == 0:\\n                if key in self.keys:\\n                    self.min = self.keys[key]\\n                else:\\n                    # find min key\\n                    self.min = float(\\'inf\\')\\n                    for k in self.keys:\\n                        self.min = min(self.keys[k], self.min)\\n                    self.min = 0 if self.min == float(\\'inf\\') else self.min\\n            if len(self.cnts[self.max]) == 0:\\n                if key in self.keys:\\n                    self.max = self.keys[key]\\n                else:\\n                    # find max key\\n                    self.max = float(\\'-inf\\')\\n                    for k in self.keys:\\n                        self.min = max(self.keys[k], self.min)\\n                    self.max = 0 if self.max == float(\\'-inf\\') else self.max\\n                \\n                \\n    def getMaxKey(self) -> str:\\n        \"\"\"\\n        Returns one of the keys with maximal value.\\n        \"\"\"\\n        if self.max > 0:\\n            for e in self.cnts[self.max]:\\n                return e\\n        return \\'\\'\\n\\n    def getMinKey(self) -> str:\\n        \"\"\"\\n        Returns one of the keys with Minimal value.\\n        \"\"\"\\n        if self.min > 0:\\n            for e in self.cnts[self.min]:\\n                return e\\n        return \\'\\'\\n\\n\\n# Your AllOne object will be instantiated and called as such:\\n# obj = AllOne()\\n# obj.inc(key)\\n# obj.dec(key)\\n# param_3 = obj.getMaxKey()\\n# param_4 = obj.getMinKey()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 402603,
                "title": "c-44-ms-92-solution-w-map-and-list",
                "content": "The idea is to achieve `O(1)` operations for all required functions by using a linked list and hash map. Reasoning for these two data structures:\\n\\n1. To get inc/dec key in `O(1)`, we need to first be able to access that key in `O(1)`, so we must use a hash map. \\n2. To get min/max key in `O(1)`, we need an \"ordered\" sequence of the keys by their current values, and thus a list comes to mind. \\n3. Because we need to know \"any\" key that is min/max, and there could be multiple keys, and we need to be able to move them to any other location in inc/dec, they need to be referenced/deleted in `O(1)`. That means we need a (unordered) set. \\n\\nThus, if we combine these ideas together, we can come up with the following schema for achieving `O(1)` in all operations:\\n\\n1. inc key; We use hashmap to find the node in the list which contains the key. If key does not exist, we assume the key has value of 1, and then resolve the list. If key does exist, we remove it from its current node, increment its value, and then resolve the list/map. Resolve basically means connecting/deleting updating previous, current, and next node for the new key, update map, which are all `O(1)` operation. This makes `inc` `O(1)`.\\n2.  dec key: We use hashmap to find the node, and if it exists, we decrement its key, remove it from current node, and resolve the list/map. This makes the operation also `O(1)`.\\n3.  get max key: We return a random element (basically first element in set) of the last node in the list. This is `O(1)`.\\n4.  get min key: We return a random element (basically first element in set) of the first node in the list. This is `O(1)`.\\n\\nThe tricky part is implementing the \"resolve list\" portion. This is because we have to make sure empty list nodes are deleted, links are properly updated, keys are inserted in the right sets, head/tail pointers updated, etc. Thus there are a lot of corner cases. It is too complicated to write here, so I will just comment in my code on what I am doing to resolve the list. Please comment if there is something that you don\\'t understand, and I\\'ll try my best to explain.\\n\\n```\\nstruct List {\\n    List(int v): prev(nullptr), next(nullptr), val(v) {} \\n    List *prev;\\n    List *next;\\n    int val;\\n    unordered_set<string> strings;\\n};\\n\\nclass AllOne {\\npublic:\\n\\n    AllOne() {\\n        head = nullptr;\\n        tail = nullptr;\\n    }\\n    \\n    static inline void link(List *a, List *b) { // Connect two nodes in list\\n        a->next = b;\\n        b->prev = a;\\n    }\\n    \\n    inline void deleteFromList(List *a) { // Delete an empty list node from the list, and update head/tail if required.\\n        if(!a->next && !a->prev) {\\n            head = tail = nullptr;\\n        }\\n        else if(!a->next) {\\n            tail = a->prev;\\n            tail->next = nullptr;\\n            \\n        }\\n        else if(!a->prev) {\\n            head = a->next;\\n            head->prev = nullptr;\\n        }\\n        else {\\n            link(a->prev, a->next);\\n        }\\n        delete a;\\n    }\\n    \\n    void inc(string key) {\\n        auto it = map.find(key);\\n        if(it == map.end()) { // key does not exist\\n            if(head && head->val == 1) { // if we already have a head with value 1, we simply insert into that node\\'s set\\n                head->strings.insert(key);\\n            }\\n\\t\\t\\t// head does not exist or is not value 1, we create new node with value 1,\\n\\t\\t\\t// set that to head, add key to it, and connect it to previous head.\\n\\t\\t\\t// We also update tails if tails is nullptr (there is only 1 node, so head = tail)\\n            else { \\n                auto l = new List(1);\\n                l->strings.insert(key);\\n                if(head) link(l, head);\\n                head = l;\\n                if(!tail) tail = l;\\n            }\\n            map[key] = head; // Update map\\n        }\\n        else { // key exists\\n            auto l = it->second;\\n\\t\\t\\tl->strings.erase(key); // remove key from the current node\\n            int nextVal = l->val+1; // find its incremented value\\n            auto next = l->next; // get current node\\'s next node\\n\\t\\t\\t// if next node exists and it has the exact value, we add the key to that node\\n\\t\\t\\t// if not, we make a new node, insert the key into that node, and insert this node between previous and next node.\\n            if(next) {\\n                if(next->val == nextVal) {\\n                    next->strings.insert(key);\\n                    map[key] = next;\\n                }\\n                else {\\n                    auto nextL = new List(nextVal);\\n                    nextL->strings.insert(key);\\n                    link(l, nextL);\\n                    link(nextL, next);\\n                    map[key] = nextL;\\n                }\\n            }\\n\\t\\t\\t// If next node does not exist, we need to add a new node to end of list, insert key into it, and use that as new tail.\\n            else {\\n                auto nextL = new List(nextVal);\\n                nextL->strings.insert(key);\\n                link(l, nextL);\\n                tail = nextL;\\n                map[key] = nextL;\\n            }\\n            if(l->strings.empty()) deleteFromList(l); // If the list node from which we moved the key is empty, we delete it.\\n        }\\n    }\\n    \\n    void dec(string key) {\\n        auto it = map.find(key);\\n        if(it != map.end()) { // key exists\\n            auto l = it->second;\\n            int prevVal = l->val-1;\\n            l->strings.erase(key); // delete from current node\\n            auto prev = l->prev;\\n\\t\\t\\t// if there is a previous and it has the exact decremented value, we move the key to this node.\\n\\t\\t\\t// otherwise, we need to make a new node, put key in that node, and insert it between prev and current node.\\n            if(prev) {\\n                if(prev->val == prevVal) {\\n                    prev->strings.insert(key);\\n                    map[key] = prev;\\n                }\\n                else {\\n                    auto prevL = new List(prevVal);\\n                    prevL->strings.insert(key);\\n                    link(prev, prevL);\\n                    link(prevL, l);\\n                    map[key] = prevL;\\n                }\\n            }\\n\\t\\t\\t// If no previous, we need to create a new node, with the decremented value, only if the value >= 1.\\n\\t\\t\\t// If decremented value less than 1, we know its previous value is 1, so we should just remove this key\\n\\t\\t\\t// Otherwise, we make a new node with the decremented value, link it to current node, and move head to this new node.\\n            else {\\n                if(prevVal < 1) {\\n                    map.erase(key);\\n                }\\n                else {\\n                    auto prevL = new List(prevVal);\\n                    prevL->strings.insert(key);\\n                    link(prevL, l);\\n                    head = prevL;\\n                    map[key] = prevL;\\n                }\\n            }\\n            if(l->strings.empty()) deleteFromList(l); // Delete current node if after moving key it is empty\\n        }\\n    }\\n    \\n    string getMaxKey() { // Return first element in set of tail node\\n        return tail ? *(tail->strings.begin()) : \"\";\\n    }\\n    \\n    string getMinKey() { // Return first element in set of head node\\n        return head ? *(head->strings.begin()) : \"\";\\n    }\\n    \\n    unordered_map<string, List*> map;\\n    List* head;\\n    List* tail;\\n};\\n\\nauto gucciGang = []() {std::ios::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);return 0;}();\\n```",
                "solutionTags": [],
                "code": "```\\nstruct List {\\n    List(int v): prev(nullptr), next(nullptr), val(v) {} \\n    List *prev;\\n    List *next;\\n    int val;\\n    unordered_set<string> strings;\\n};\\n\\nclass AllOne {\\npublic:\\n\\n    AllOne() {\\n        head = nullptr;\\n        tail = nullptr;\\n    }\\n    \\n    static inline void link(List *a, List *b) { // Connect two nodes in list\\n        a->next = b;\\n        b->prev = a;\\n    }\\n    \\n    inline void deleteFromList(List *a) { // Delete an empty list node from the list, and update head/tail if required.\\n        if(!a->next && !a->prev) {\\n            head = tail = nullptr;\\n        }\\n        else if(!a->next) {\\n            tail = a->prev;\\n            tail->next = nullptr;\\n            \\n        }\\n        else if(!a->prev) {\\n            head = a->next;\\n            head->prev = nullptr;\\n        }\\n        else {\\n            link(a->prev, a->next);\\n        }\\n        delete a;\\n    }\\n    \\n    void inc(string key) {\\n        auto it = map.find(key);\\n        if(it == map.end()) { // key does not exist\\n            if(head && head->val == 1) { // if we already have a head with value 1, we simply insert into that node\\'s set\\n                head->strings.insert(key);\\n            }\\n\\t\\t\\t// head does not exist or is not value 1, we create new node with value 1,\\n\\t\\t\\t// set that to head, add key to it, and connect it to previous head.\\n\\t\\t\\t// We also update tails if tails is nullptr (there is only 1 node, so head = tail)\\n            else { \\n                auto l = new List(1);\\n                l->strings.insert(key);\\n                if(head) link(l, head);\\n                head = l;\\n                if(!tail) tail = l;\\n            }\\n            map[key] = head; // Update map\\n        }\\n        else { // key exists\\n            auto l = it->second;\\n\\t\\t\\tl->strings.erase(key); // remove key from the current node\\n            int nextVal = l->val+1; // find its incremented value\\n            auto next = l->next; // get current node\\'s next node\\n\\t\\t\\t// if next node exists and it has the exact value, we add the key to that node\\n\\t\\t\\t// if not, we make a new node, insert the key into that node, and insert this node between previous and next node.\\n            if(next) {\\n                if(next->val == nextVal) {\\n                    next->strings.insert(key);\\n                    map[key] = next;\\n                }\\n                else {\\n                    auto nextL = new List(nextVal);\\n                    nextL->strings.insert(key);\\n                    link(l, nextL);\\n                    link(nextL, next);\\n                    map[key] = nextL;\\n                }\\n            }\\n\\t\\t\\t// If next node does not exist, we need to add a new node to end of list, insert key into it, and use that as new tail.\\n            else {\\n                auto nextL = new List(nextVal);\\n                nextL->strings.insert(key);\\n                link(l, nextL);\\n                tail = nextL;\\n                map[key] = nextL;\\n            }\\n            if(l->strings.empty()) deleteFromList(l); // If the list node from which we moved the key is empty, we delete it.\\n        }\\n    }\\n    \\n    void dec(string key) {\\n        auto it = map.find(key);\\n        if(it != map.end()) { // key exists\\n            auto l = it->second;\\n            int prevVal = l->val-1;\\n            l->strings.erase(key); // delete from current node\\n            auto prev = l->prev;\\n\\t\\t\\t// if there is a previous and it has the exact decremented value, we move the key to this node.\\n\\t\\t\\t// otherwise, we need to make a new node, put key in that node, and insert it between prev and current node.\\n            if(prev) {\\n                if(prev->val == prevVal) {\\n                    prev->strings.insert(key);\\n                    map[key] = prev;\\n                }\\n                else {\\n                    auto prevL = new List(prevVal);\\n                    prevL->strings.insert(key);\\n                    link(prev, prevL);\\n                    link(prevL, l);\\n                    map[key] = prevL;\\n                }\\n            }\\n\\t\\t\\t// If no previous, we need to create a new node, with the decremented value, only if the value >= 1.\\n\\t\\t\\t// If decremented value less than 1, we know its previous value is 1, so we should just remove this key\\n\\t\\t\\t// Otherwise, we make a new node with the decremented value, link it to current node, and move head to this new node.\\n            else {\\n                if(prevVal < 1) {\\n                    map.erase(key);\\n                }\\n                else {\\n                    auto prevL = new List(prevVal);\\n                    prevL->strings.insert(key);\\n                    link(prevL, l);\\n                    head = prevL;\\n                    map[key] = prevL;\\n                }\\n            }\\n            if(l->strings.empty()) deleteFromList(l); // Delete current node if after moving key it is empty\\n        }\\n    }\\n    \\n    string getMaxKey() { // Return first element in set of tail node\\n        return tail ? *(tail->strings.begin()) : \"\";\\n    }\\n    \\n    string getMinKey() { // Return first element in set of head node\\n        return head ? *(head->strings.begin()) : \"\";\\n    }\\n    \\n    unordered_map<string, List*> map;\\n    List* head;\\n    List* tail;\\n};\\n\\nauto gucciGang = []() {std::ios::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);return 0;}();\\n```",
                "codeTag": "C++"
            },
            {
                "id": 341270,
                "title": "python-easy-to-understand-hash-map-arraylist-not-double-linklist-beats-94",
                "content": "\\nWe can use **ArrayList** instead of **double linklist** to simplify the code.\\nThe basic idea is, we can use **bubble sort** to easily maintain a **sorting key list**.\\nThe dictionary will save the **key /value** pairs. Please notice that the value would include two part: **[count,index_in_queue]**\\n\\nThus, for each time, when we inc/dec a key, we first update the keys\\' count in the dictionary, and then use bubble sort to update sorting list/queue:\\n```\\npseudo code\\nWhile not reach head/tail in the queue:\\n    Compare its previous/latter key\\u2019count, if target key larger/smaller than previous/latter one:\\n        Update their index in the queue\\n        Update their index in dictionary\\n    Else:\\n        break \\n```\\nTo get max/min is easy, just the the count of key in the queue\\'s head/tail\\n\\n```\\nclass AllOne(object):\\n\\n    def __init__(self):\\n        \"\"\"\\n        self.dict-> key/value pair, value have two part [count,index_in_queue]\\n        self.queue -> store key, sorted by count \\n        self.size -> count the distinct key\\n        \"\"\"\\n        \\n        self.dict = {}\\n        self.queue = []\\n        self.size = 0\\n    def inc(self, key):\\n        \"\"\"\\n        1. update the count of key in dict\\n        2. update key index in queue by bubble sort\\n            2.1 compare the count value between the target key and the key before target key in queue\\n            2.2 update the queue\\'s index between two keys base on step 2.1\\n            2.2. looping previous step, until previous key\\'s count larger than target key, or reach head\\n        \"\"\"\\n        # key not exist: append new key\\n        if key not in self.dict:\\n            self.dict[key]  = [1,self.size]\\n            self.queue.append(key)\\n            self.size +=1\\n            \\n        else:\\n            self.dict[key][0] +=1         #update key count\\n            idx = self.dict[key][1]       #get key\\'s index in queue\\n            \\n            # keep step 2\\n            while idx >0  and  self.dict[self.queue[idx]][0] > self.dict[self.queue[idx-1]][0]:\\n                self.dict[self.queue[idx]][1] -=1\\n                self.dict[self.queue[idx-1]][1] +=1\\n                self.queue[idx],self.queue[idx-1] = self.queue[idx-1],self.queue[idx]\\n                idx -=1\\n        \\n    def dec(self, key):\\n        \"\"\"\\n        1. update the count of key in dict\\n        2. update key index in queue by bubble sort\\n            2.1 compare the count value between the target key and the key after target key in queue\\n            2.2 update the queue\\'s index between two keys base on step 2.1\\n            2.2. looping previous step, until previous key\\'s count smaller than target key, or reach tail\\n        3. if count of key = 0, pop the key from dict and queue\\n        \"\"\"\\n        if key in self.dict:\\n            self.dict[key][0] -=1\\n            idx = self.dict[key][1]\\n            \\n            while idx <self.size-1 and self.dict[self.queue[idx]][0] < self.dict[self.queue[idx+1]][0]:\\n                self.dict[self.queue[idx]][1] +=1\\n                self.dict[self.queue[idx+1]][1] -=1\\n                self.queue[idx],self.queue[idx+1] = self.queue[idx+1],self.queue[idx]\\n                idx += 1\\n                \\n            if self.dict[key][0] == 0:\\n                self.size -= 1\\n                self.queue.pop()\\n                self.dict.pop(key)\\n    def getMaxKey(self):\\n        \"\"\"\\n        if queue size >0. return the head of queue\\n        \"\"\"\\n        if self.size ==0:\\n            return \\'\\'\\n        return self.queue[0]\\n\\n    def getMinKey(self):\\n        \"\"\"\\n        if queue size >0. return the tail of queue\\n        \"\"\"\\n        if self.size ==0:\\n            return \\'\\'\\n        return self.queue[-1]\\n```",
                "solutionTags": [],
                "code": "```\\npseudo code\\nWhile not reach head/tail in the queue:\\n    Compare its previous/latter key\\u2019count, if target key larger/smaller than previous/latter one:\\n        Update their index in the queue\\n        Update their index in dictionary\\n    Else:\\n        break \\n```\n```\\nclass AllOne(object):\\n\\n    def __init__(self):\\n        \"\"\"\\n        self.dict-> key/value pair, value have two part [count,index_in_queue]\\n        self.queue -> store key, sorted by count \\n        self.size -> count the distinct key\\n        \"\"\"\\n        \\n        self.dict = {}\\n        self.queue = []\\n        self.size = 0\\n    def inc(self, key):\\n        \"\"\"\\n        1. update the count of key in dict\\n        2. update key index in queue by bubble sort\\n            2.1 compare the count value between the target key and the key before target key in queue\\n            2.2 update the queue\\'s index between two keys base on step 2.1\\n            2.2. looping previous step, until previous key\\'s count larger than target key, or reach head\\n        \"\"\"\\n        # key not exist: append new key\\n        if key not in self.dict:\\n            self.dict[key]  = [1,self.size]\\n            self.queue.append(key)\\n            self.size +=1\\n            \\n        else:\\n            self.dict[key][0] +=1         #update key count\\n            idx = self.dict[key][1]       #get key\\'s index in queue\\n            \\n            # keep step 2\\n            while idx >0  and  self.dict[self.queue[idx]][0] > self.dict[self.queue[idx-1]][0]:\\n                self.dict[self.queue[idx]][1] -=1\\n                self.dict[self.queue[idx-1]][1] +=1\\n                self.queue[idx],self.queue[idx-1] = self.queue[idx-1],self.queue[idx]\\n                idx -=1\\n        \\n    def dec(self, key):\\n        \"\"\"\\n        1. update the count of key in dict\\n        2. update key index in queue by bubble sort\\n            2.1 compare the count value between the target key and the key after target key in queue\\n            2.2 update the queue\\'s index between two keys base on step 2.1\\n            2.2. looping previous step, until previous key\\'s count smaller than target key, or reach tail\\n        3. if count of key = 0, pop the key from dict and queue\\n        \"\"\"\\n        if key in self.dict:\\n            self.dict[key][0] -=1\\n            idx = self.dict[key][1]\\n            \\n            while idx <self.size-1 and self.dict[self.queue[idx]][0] < self.dict[self.queue[idx+1]][0]:\\n                self.dict[self.queue[idx]][1] +=1\\n                self.dict[self.queue[idx+1]][1] -=1\\n                self.queue[idx],self.queue[idx+1] = self.queue[idx+1],self.queue[idx]\\n                idx += 1\\n                \\n            if self.dict[key][0] == 0:\\n                self.size -= 1\\n                self.queue.pop()\\n                self.dict.pop(key)\\n    def getMaxKey(self):\\n        \"\"\"\\n        if queue size >0. return the head of queue\\n        \"\"\"\\n        if self.size ==0:\\n            return \\'\\'\\n        return self.queue[0]\\n\\n    def getMinKey(self):\\n        \"\"\"\\n        if queue size >0. return the tail of queue\\n        \"\"\"\\n        if self.size ==0:\\n            return \\'\\'\\n        return self.queue[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 332287,
                "title": "simple-java-solution-based-on-treemap-and-hashmap",
                "content": "```\\nclass AllOne {\\n\\n    /** Initialize your data structure here. */\\n    private HashMap<String, Integer> stringToCount;\\n    private TreeMap<Integer, HashSet<String>> countToStringSet;\\n         \\n    public AllOne() {\\n        this.stringToCount = new HashMap<>();\\n        this.countToStringSet = new TreeMap<>();\\n    }\\n    \\n    /** Inserts a new key <Key> with value 1. Or increments an existing key by 1. */\\n    public void inc(String key) {\\n        int count = 1;\\n        if(this.stringToCount.containsKey(key)) {\\n            count = this.stringToCount.get(key);\\n            this.countToStringSet.get(count).remove(key);\\n            if(this.countToStringSet.get(count).size() == 0) {\\n                this.countToStringSet.remove(count);\\n            }\\n            \\n            ++count;\\n        }\\n        \\n        if(!this.countToStringSet.containsKey(count)) {\\n           this.countToStringSet.put(count, new HashSet<String>());\\n        }\\n           \\n        this.stringToCount.put(key, count);\\n        this.countToStringSet.get(count).add(key);\\n    }\\n    \\n    /** Decrements an existing key by 1. If Key\\'s value is 1, remove it from the data structure. */\\n    public void dec(String key) {\\n        if(this.stringToCount.containsKey(key)) {\\n            int count = this.stringToCount.get(key);\\n            if(count == 1) {\\n                this.stringToCount.remove(key);\\n                \\n            } else {\\n                if(!this.countToStringSet.containsKey(count-1)) {\\n                    this.countToStringSet.put(count-1, new HashSet<String>());\\n                }\\n                \\n                this.countToStringSet.get(count-1).add(key);\\n                this.stringToCount.put(key, count-1);\\n            }\\n            \\n            this.countToStringSet.get(count).remove(key);\\n            if(this.countToStringSet.get(count).size() == 0) {\\n                this.countToStringSet.remove(count);\\n            }\\n        }\\n    }\\n    \\n    /** Returns one of the keys with maximal value. */\\n    public String getMaxKey() {\\n        if( this.countToStringSet.size() == 0) {\\n            return \"\";\\n        }\\n        \\n        return this.countToStringSet.get(this.countToStringSet.lastKey()).iterator().next();\\n    }\\n    \\n    /** Returns one of the keys with Minimal value. */\\n    public String getMinKey() {\\n        if( this.countToStringSet.size() == 0) {\\n            return \"\";\\n        }\\n        \\n        return this.countToStringSet.get(this.countToStringSet.firstKey()).iterator().next();\\n    }\\n}\\n\\n/**\\n * Your AllOne object will be instantiated and called as such:\\n * AllOne obj = new AllOne();\\n * obj.inc(key);\\n * obj.dec(key);\\n * String param_3 = obj.getMaxKey();\\n * String param_4 = obj.getMinKey();\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass AllOne {\\n\\n    /** Initialize your data structure here. */\\n    private HashMap<String, Integer> stringToCount;\\n    private TreeMap<Integer, HashSet<String>> countToStringSet;\\n         \\n    public AllOne() {\\n        this.stringToCount = new HashMap<>();\\n        this.countToStringSet = new TreeMap<>();\\n    }\\n    \\n    /** Inserts a new key <Key> with value 1. Or increments an existing key by 1. */\\n    public void inc(String key) {\\n        int count = 1;\\n        if(this.stringToCount.containsKey(key)) {\\n            count = this.stringToCount.get(key);\\n            this.countToStringSet.get(count).remove(key);\\n            if(this.countToStringSet.get(count).size() == 0) {\\n                this.countToStringSet.remove(count);\\n            }\\n            \\n            ++count;\\n        }\\n        \\n        if(!this.countToStringSet.containsKey(count)) {\\n           this.countToStringSet.put(count, new HashSet<String>());\\n        }\\n           \\n        this.stringToCount.put(key, count);\\n        this.countToStringSet.get(count).add(key);\\n    }\\n    \\n    /** Decrements an existing key by 1. If Key\\'s value is 1, remove it from the data structure. */\\n    public void dec(String key) {\\n        if(this.stringToCount.containsKey(key)) {\\n            int count = this.stringToCount.get(key);\\n            if(count == 1) {\\n                this.stringToCount.remove(key);\\n                \\n            } else {\\n                if(!this.countToStringSet.containsKey(count-1)) {\\n                    this.countToStringSet.put(count-1, new HashSet<String>());\\n                }\\n                \\n                this.countToStringSet.get(count-1).add(key);\\n                this.stringToCount.put(key, count-1);\\n            }\\n            \\n            this.countToStringSet.get(count).remove(key);\\n            if(this.countToStringSet.get(count).size() == 0) {\\n                this.countToStringSet.remove(count);\\n            }\\n        }\\n    }\\n    \\n    /** Returns one of the keys with maximal value. */\\n    public String getMaxKey() {\\n        if( this.countToStringSet.size() == 0) {\\n            return \"\";\\n        }\\n        \\n        return this.countToStringSet.get(this.countToStringSet.lastKey()).iterator().next();\\n    }\\n    \\n    /** Returns one of the keys with Minimal value. */\\n    public String getMinKey() {\\n        if( this.countToStringSet.size() == 0) {\\n            return \"\";\\n        }\\n        \\n        return this.countToStringSet.get(this.countToStringSet.firstKey()).iterator().next();\\n    }\\n}\\n\\n/**\\n * Your AllOne object will be instantiated and called as such:\\n * AllOne obj = new AllOne();\\n * obj.inc(key);\\n * obj.dec(key);\\n * String param_3 = obj.getMaxKey();\\n * String param_4 = obj.getMinKey();\\n */\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1565438,
                "content": [
                    {
                        "username": "ajak6",
                        "content": "What does the following mean? Increment a string by 1 (integer)?\\n>increments an existing key by 1\\n\\nI think it means the value of the key : can be clearly written in the question."
                    },
                    {
                        "username": "rishihho",
                        "content": "O(1) makes no sense"
                    },
                    {
                        "username": "skywalker94",
                        "content": "It\\'s hard but possible to get O(1) time complexity (some operation may have to be amortized O(1))!"
                    },
                    {
                        "username": "mang11",
                        "content": "Can some one explain to me how you can write the solution to this problem in 35 mins in the interview? If you get asked this question, I just interpret as the interviewer not wanting to hire you."
                    },
                    {
                        "username": "StefanelStan",
                        "content": "It is very intuitive to use HashMap<String, Integer> to count the string AND a TreeMap<Integer, Set<String>> to hold the strings grouped by their count. With each inc/dec you increment/decrement the count from first map and move the string across buckets from the 2nd map."
                    },
                    {
                        "username": "Django_Developer",
                        "content": "This one is very similar to LRU Cache Problem"
                    },
                    {
                        "username": "sarathecoder",
                        "content": "why not just use orderedDict in python? It supports dict + linkedlist functions .\\nWe also use orderedDict for the LRU cache problem, so why not here?"
                    },
                    {
                        "username": "skywalker94",
                        "content": "The issue is that you\\'re supposed to do each operation in O(1). orderedDict uses a binary search tree implementation, and has O(logn) time complexity"
                    },
                    {
                        "username": "kesarwaniankit48",
                        "content": "Can there be a scenario where conflict is possible? Say for below example wherein at the end the count for both hello and leet will be same, what will be the min and max key output? Correct me if I am missing something.\\n\\n[\"AllOne\", \"inc\", \"inc\", \"getMaxKey\", \"getMinKey\", \"inc\", \"getMaxKey\", \"getMinKey\",\"dec\",\"getMaxKey\", \"getMinKey\"]\\n[[], [\"hello\"], [\"hello\"], [], [], [\"leet\"], [], [], [\"hello\"],[],[]]"
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "How is this hard? This is basic hash mapping. I don\\'t get why people find this difficult, and not DP questions where I die.\\n\\nOne hash map to count the key, one hash map to map the count back to the key. Update and delete keys from both hash maps as needed. Everything is O(1).\\n\\nAm I missing some requirement? I don\\'t see the description mentioning anything about not using hash maps."
                    },
                    {
                        "username": "KeshavJha2002",
                        "content": "Well you are expected to design a data structure... not use some already existing ones"
                    },
                    {
                        "username": "Baymurat",
                        "content": "How it can be \"Everything is O(1)\"? Let\\'s assume we did 100 \"inc\" and now we have in first map (mapKeyToCount) 100 keys with value 1 each of them and in the second map (mapCountToKey) 1 key with value of List with length of 100 elements. Now we do next \"inc\" of existing element, it means we have to find it in mapCountToKey and remove. And it\\'s O(N). Isn\\'t it so?!"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Lol big relate on the \"DP questions where i die\" part. "
                    },
                    {
                        "username": "a74705745",
                        "content": "There are many solution that use \"Doubly Linked List\" and they use Linear Search for find specific node, I think it is not match condition that is described by Problem \"  Note that each function must run in O(1) average time complexity \". Because Linear Search cost O(n) time complexity. "
                    },
                    {
                        "username": "Akash221991",
                        "content": "\\nkeyCountMap: This hash map is used to store the counts associated with each key. \\nFor example, if you have a key \"hello\" with a count of 3, the keyCountMap would have an entry like (\"hello\", 3).\\nThis map is used to efficiently update and access the counts of individual keys when performing the inc and dec operations. It allows you to quickly determine the current count of a key in O(1) time.\\n\\ncountKeyMap: This hash map is used to maintain a collection of keys for each count value. For instance, if you have multiple keys with a count of 3, the countKeyMap would have an entry like (3, {\"key1\", \"key2\", \"key3\"}).\\n\\nThis map is important for implementing the getMaxKey and getMinKey operations efficiently. Instead of searching through all keys to find the maximum and minimum counts, you can directly access the keys associated with the maximum and minimum counts in O(1) time."
                    },
                    {
                        "username": "StefanelStan",
                        "content": "A simple \"hard\" problem that requires some concentration.\\n1. Use a HashMap<String, Integer> to keep track of the count of each String\\n2. Use a TreeMap<Integer, Set<String>> to keep track of the buckets of each count to return the min/max.\\n3. As enhancement, you don\\'t really need to store a Set<String> in the 2nd map, but a Node(String, next, previous) of a manual doubly linked list. Each time you move buckets, you disconnect the nodes from old bucket and connect to the new bucket."
                    }
                ]
            },
            {
                "id": 1569812,
                "content": [
                    {
                        "username": "ajak6",
                        "content": "What does the following mean? Increment a string by 1 (integer)?\\n>increments an existing key by 1\\n\\nI think it means the value of the key : can be clearly written in the question."
                    },
                    {
                        "username": "rishihho",
                        "content": "O(1) makes no sense"
                    },
                    {
                        "username": "skywalker94",
                        "content": "It\\'s hard but possible to get O(1) time complexity (some operation may have to be amortized O(1))!"
                    },
                    {
                        "username": "mang11",
                        "content": "Can some one explain to me how you can write the solution to this problem in 35 mins in the interview? If you get asked this question, I just interpret as the interviewer not wanting to hire you."
                    },
                    {
                        "username": "StefanelStan",
                        "content": "It is very intuitive to use HashMap<String, Integer> to count the string AND a TreeMap<Integer, Set<String>> to hold the strings grouped by their count. With each inc/dec you increment/decrement the count from first map and move the string across buckets from the 2nd map."
                    },
                    {
                        "username": "Django_Developer",
                        "content": "This one is very similar to LRU Cache Problem"
                    },
                    {
                        "username": "sarathecoder",
                        "content": "why not just use orderedDict in python? It supports dict + linkedlist functions .\\nWe also use orderedDict for the LRU cache problem, so why not here?"
                    },
                    {
                        "username": "skywalker94",
                        "content": "The issue is that you\\'re supposed to do each operation in O(1). orderedDict uses a binary search tree implementation, and has O(logn) time complexity"
                    },
                    {
                        "username": "kesarwaniankit48",
                        "content": "Can there be a scenario where conflict is possible? Say for below example wherein at the end the count for both hello and leet will be same, what will be the min and max key output? Correct me if I am missing something.\\n\\n[\"AllOne\", \"inc\", \"inc\", \"getMaxKey\", \"getMinKey\", \"inc\", \"getMaxKey\", \"getMinKey\",\"dec\",\"getMaxKey\", \"getMinKey\"]\\n[[], [\"hello\"], [\"hello\"], [], [], [\"leet\"], [], [], [\"hello\"],[],[]]"
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "How is this hard? This is basic hash mapping. I don\\'t get why people find this difficult, and not DP questions where I die.\\n\\nOne hash map to count the key, one hash map to map the count back to the key. Update and delete keys from both hash maps as needed. Everything is O(1).\\n\\nAm I missing some requirement? I don\\'t see the description mentioning anything about not using hash maps."
                    },
                    {
                        "username": "KeshavJha2002",
                        "content": "Well you are expected to design a data structure... not use some already existing ones"
                    },
                    {
                        "username": "Baymurat",
                        "content": "How it can be \"Everything is O(1)\"? Let\\'s assume we did 100 \"inc\" and now we have in first map (mapKeyToCount) 100 keys with value 1 each of them and in the second map (mapCountToKey) 1 key with value of List with length of 100 elements. Now we do next \"inc\" of existing element, it means we have to find it in mapCountToKey and remove. And it\\'s O(N). Isn\\'t it so?!"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Lol big relate on the \"DP questions where i die\" part. "
                    },
                    {
                        "username": "a74705745",
                        "content": "There are many solution that use \"Doubly Linked List\" and they use Linear Search for find specific node, I think it is not match condition that is described by Problem \"  Note that each function must run in O(1) average time complexity \". Because Linear Search cost O(n) time complexity. "
                    },
                    {
                        "username": "Akash221991",
                        "content": "\\nkeyCountMap: This hash map is used to store the counts associated with each key. \\nFor example, if you have a key \"hello\" with a count of 3, the keyCountMap would have an entry like (\"hello\", 3).\\nThis map is used to efficiently update and access the counts of individual keys when performing the inc and dec operations. It allows you to quickly determine the current count of a key in O(1) time.\\n\\ncountKeyMap: This hash map is used to maintain a collection of keys for each count value. For instance, if you have multiple keys with a count of 3, the countKeyMap would have an entry like (3, {\"key1\", \"key2\", \"key3\"}).\\n\\nThis map is important for implementing the getMaxKey and getMinKey operations efficiently. Instead of searching through all keys to find the maximum and minimum counts, you can directly access the keys associated with the maximum and minimum counts in O(1) time."
                    },
                    {
                        "username": "StefanelStan",
                        "content": "A simple \"hard\" problem that requires some concentration.\\n1. Use a HashMap<String, Integer> to keep track of the count of each String\\n2. Use a TreeMap<Integer, Set<String>> to keep track of the buckets of each count to return the min/max.\\n3. As enhancement, you don\\'t really need to store a Set<String> in the 2nd map, but a Node(String, next, previous) of a manual doubly linked list. Each time you move buckets, you disconnect the nodes from old bucket and connect to the new bucket."
                    }
                ]
            },
            {
                "id": 1575766,
                "content": [
                    {
                        "username": "ajak6",
                        "content": "What does the following mean? Increment a string by 1 (integer)?\\n>increments an existing key by 1\\n\\nI think it means the value of the key : can be clearly written in the question."
                    },
                    {
                        "username": "rishihho",
                        "content": "O(1) makes no sense"
                    },
                    {
                        "username": "skywalker94",
                        "content": "It\\'s hard but possible to get O(1) time complexity (some operation may have to be amortized O(1))!"
                    },
                    {
                        "username": "mang11",
                        "content": "Can some one explain to me how you can write the solution to this problem in 35 mins in the interview? If you get asked this question, I just interpret as the interviewer not wanting to hire you."
                    },
                    {
                        "username": "StefanelStan",
                        "content": "It is very intuitive to use HashMap<String, Integer> to count the string AND a TreeMap<Integer, Set<String>> to hold the strings grouped by their count. With each inc/dec you increment/decrement the count from first map and move the string across buckets from the 2nd map."
                    },
                    {
                        "username": "Django_Developer",
                        "content": "This one is very similar to LRU Cache Problem"
                    },
                    {
                        "username": "sarathecoder",
                        "content": "why not just use orderedDict in python? It supports dict + linkedlist functions .\\nWe also use orderedDict for the LRU cache problem, so why not here?"
                    },
                    {
                        "username": "skywalker94",
                        "content": "The issue is that you\\'re supposed to do each operation in O(1). orderedDict uses a binary search tree implementation, and has O(logn) time complexity"
                    },
                    {
                        "username": "kesarwaniankit48",
                        "content": "Can there be a scenario where conflict is possible? Say for below example wherein at the end the count for both hello and leet will be same, what will be the min and max key output? Correct me if I am missing something.\\n\\n[\"AllOne\", \"inc\", \"inc\", \"getMaxKey\", \"getMinKey\", \"inc\", \"getMaxKey\", \"getMinKey\",\"dec\",\"getMaxKey\", \"getMinKey\"]\\n[[], [\"hello\"], [\"hello\"], [], [], [\"leet\"], [], [], [\"hello\"],[],[]]"
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "How is this hard? This is basic hash mapping. I don\\'t get why people find this difficult, and not DP questions where I die.\\n\\nOne hash map to count the key, one hash map to map the count back to the key. Update and delete keys from both hash maps as needed. Everything is O(1).\\n\\nAm I missing some requirement? I don\\'t see the description mentioning anything about not using hash maps."
                    },
                    {
                        "username": "KeshavJha2002",
                        "content": "Well you are expected to design a data structure... not use some already existing ones"
                    },
                    {
                        "username": "Baymurat",
                        "content": "How it can be \"Everything is O(1)\"? Let\\'s assume we did 100 \"inc\" and now we have in first map (mapKeyToCount) 100 keys with value 1 each of them and in the second map (mapCountToKey) 1 key with value of List with length of 100 elements. Now we do next \"inc\" of existing element, it means we have to find it in mapCountToKey and remove. And it\\'s O(N). Isn\\'t it so?!"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Lol big relate on the \"DP questions where i die\" part. "
                    },
                    {
                        "username": "a74705745",
                        "content": "There are many solution that use \"Doubly Linked List\" and they use Linear Search for find specific node, I think it is not match condition that is described by Problem \"  Note that each function must run in O(1) average time complexity \". Because Linear Search cost O(n) time complexity. "
                    },
                    {
                        "username": "Akash221991",
                        "content": "\\nkeyCountMap: This hash map is used to store the counts associated with each key. \\nFor example, if you have a key \"hello\" with a count of 3, the keyCountMap would have an entry like (\"hello\", 3).\\nThis map is used to efficiently update and access the counts of individual keys when performing the inc and dec operations. It allows you to quickly determine the current count of a key in O(1) time.\\n\\ncountKeyMap: This hash map is used to maintain a collection of keys for each count value. For instance, if you have multiple keys with a count of 3, the countKeyMap would have an entry like (3, {\"key1\", \"key2\", \"key3\"}).\\n\\nThis map is important for implementing the getMaxKey and getMinKey operations efficiently. Instead of searching through all keys to find the maximum and minimum counts, you can directly access the keys associated with the maximum and minimum counts in O(1) time."
                    },
                    {
                        "username": "StefanelStan",
                        "content": "A simple \"hard\" problem that requires some concentration.\\n1. Use a HashMap<String, Integer> to keep track of the count of each String\\n2. Use a TreeMap<Integer, Set<String>> to keep track of the buckets of each count to return the min/max.\\n3. As enhancement, you don\\'t really need to store a Set<String> in the 2nd map, but a Node(String, next, previous) of a manual doubly linked list. Each time you move buckets, you disconnect the nodes from old bucket and connect to the new bucket."
                    }
                ]
            },
            {
                "id": 1865811,
                "content": [
                    {
                        "username": "ajak6",
                        "content": "What does the following mean? Increment a string by 1 (integer)?\\n>increments an existing key by 1\\n\\nI think it means the value of the key : can be clearly written in the question."
                    },
                    {
                        "username": "rishihho",
                        "content": "O(1) makes no sense"
                    },
                    {
                        "username": "skywalker94",
                        "content": "It\\'s hard but possible to get O(1) time complexity (some operation may have to be amortized O(1))!"
                    },
                    {
                        "username": "mang11",
                        "content": "Can some one explain to me how you can write the solution to this problem in 35 mins in the interview? If you get asked this question, I just interpret as the interviewer not wanting to hire you."
                    },
                    {
                        "username": "StefanelStan",
                        "content": "It is very intuitive to use HashMap<String, Integer> to count the string AND a TreeMap<Integer, Set<String>> to hold the strings grouped by their count. With each inc/dec you increment/decrement the count from first map and move the string across buckets from the 2nd map."
                    },
                    {
                        "username": "Django_Developer",
                        "content": "This one is very similar to LRU Cache Problem"
                    },
                    {
                        "username": "sarathecoder",
                        "content": "why not just use orderedDict in python? It supports dict + linkedlist functions .\\nWe also use orderedDict for the LRU cache problem, so why not here?"
                    },
                    {
                        "username": "skywalker94",
                        "content": "The issue is that you\\'re supposed to do each operation in O(1). orderedDict uses a binary search tree implementation, and has O(logn) time complexity"
                    },
                    {
                        "username": "kesarwaniankit48",
                        "content": "Can there be a scenario where conflict is possible? Say for below example wherein at the end the count for both hello and leet will be same, what will be the min and max key output? Correct me if I am missing something.\\n\\n[\"AllOne\", \"inc\", \"inc\", \"getMaxKey\", \"getMinKey\", \"inc\", \"getMaxKey\", \"getMinKey\",\"dec\",\"getMaxKey\", \"getMinKey\"]\\n[[], [\"hello\"], [\"hello\"], [], [], [\"leet\"], [], [], [\"hello\"],[],[]]"
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "How is this hard? This is basic hash mapping. I don\\'t get why people find this difficult, and not DP questions where I die.\\n\\nOne hash map to count the key, one hash map to map the count back to the key. Update and delete keys from both hash maps as needed. Everything is O(1).\\n\\nAm I missing some requirement? I don\\'t see the description mentioning anything about not using hash maps."
                    },
                    {
                        "username": "KeshavJha2002",
                        "content": "Well you are expected to design a data structure... not use some already existing ones"
                    },
                    {
                        "username": "Baymurat",
                        "content": "How it can be \"Everything is O(1)\"? Let\\'s assume we did 100 \"inc\" and now we have in first map (mapKeyToCount) 100 keys with value 1 each of them and in the second map (mapCountToKey) 1 key with value of List with length of 100 elements. Now we do next \"inc\" of existing element, it means we have to find it in mapCountToKey and remove. And it\\'s O(N). Isn\\'t it so?!"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Lol big relate on the \"DP questions where i die\" part. "
                    },
                    {
                        "username": "a74705745",
                        "content": "There are many solution that use \"Doubly Linked List\" and they use Linear Search for find specific node, I think it is not match condition that is described by Problem \"  Note that each function must run in O(1) average time complexity \". Because Linear Search cost O(n) time complexity. "
                    },
                    {
                        "username": "Akash221991",
                        "content": "\\nkeyCountMap: This hash map is used to store the counts associated with each key. \\nFor example, if you have a key \"hello\" with a count of 3, the keyCountMap would have an entry like (\"hello\", 3).\\nThis map is used to efficiently update and access the counts of individual keys when performing the inc and dec operations. It allows you to quickly determine the current count of a key in O(1) time.\\n\\ncountKeyMap: This hash map is used to maintain a collection of keys for each count value. For instance, if you have multiple keys with a count of 3, the countKeyMap would have an entry like (3, {\"key1\", \"key2\", \"key3\"}).\\n\\nThis map is important for implementing the getMaxKey and getMinKey operations efficiently. Instead of searching through all keys to find the maximum and minimum counts, you can directly access the keys associated with the maximum and minimum counts in O(1) time."
                    },
                    {
                        "username": "StefanelStan",
                        "content": "A simple \"hard\" problem that requires some concentration.\\n1. Use a HashMap<String, Integer> to keep track of the count of each String\\n2. Use a TreeMap<Integer, Set<String>> to keep track of the buckets of each count to return the min/max.\\n3. As enhancement, you don\\'t really need to store a Set<String> in the 2nd map, but a Node(String, next, previous) of a manual doubly linked list. Each time you move buckets, you disconnect the nodes from old bucket and connect to the new bucket."
                    }
                ]
            },
            {
                "id": 1576049,
                "content": [
                    {
                        "username": "ajak6",
                        "content": "What does the following mean? Increment a string by 1 (integer)?\\n>increments an existing key by 1\\n\\nI think it means the value of the key : can be clearly written in the question."
                    },
                    {
                        "username": "rishihho",
                        "content": "O(1) makes no sense"
                    },
                    {
                        "username": "skywalker94",
                        "content": "It\\'s hard but possible to get O(1) time complexity (some operation may have to be amortized O(1))!"
                    },
                    {
                        "username": "mang11",
                        "content": "Can some one explain to me how you can write the solution to this problem in 35 mins in the interview? If you get asked this question, I just interpret as the interviewer not wanting to hire you."
                    },
                    {
                        "username": "StefanelStan",
                        "content": "It is very intuitive to use HashMap<String, Integer> to count the string AND a TreeMap<Integer, Set<String>> to hold the strings grouped by their count. With each inc/dec you increment/decrement the count from first map and move the string across buckets from the 2nd map."
                    },
                    {
                        "username": "Django_Developer",
                        "content": "This one is very similar to LRU Cache Problem"
                    },
                    {
                        "username": "sarathecoder",
                        "content": "why not just use orderedDict in python? It supports dict + linkedlist functions .\\nWe also use orderedDict for the LRU cache problem, so why not here?"
                    },
                    {
                        "username": "skywalker94",
                        "content": "The issue is that you\\'re supposed to do each operation in O(1). orderedDict uses a binary search tree implementation, and has O(logn) time complexity"
                    },
                    {
                        "username": "kesarwaniankit48",
                        "content": "Can there be a scenario where conflict is possible? Say for below example wherein at the end the count for both hello and leet will be same, what will be the min and max key output? Correct me if I am missing something.\\n\\n[\"AllOne\", \"inc\", \"inc\", \"getMaxKey\", \"getMinKey\", \"inc\", \"getMaxKey\", \"getMinKey\",\"dec\",\"getMaxKey\", \"getMinKey\"]\\n[[], [\"hello\"], [\"hello\"], [], [], [\"leet\"], [], [], [\"hello\"],[],[]]"
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "How is this hard? This is basic hash mapping. I don\\'t get why people find this difficult, and not DP questions where I die.\\n\\nOne hash map to count the key, one hash map to map the count back to the key. Update and delete keys from both hash maps as needed. Everything is O(1).\\n\\nAm I missing some requirement? I don\\'t see the description mentioning anything about not using hash maps."
                    },
                    {
                        "username": "KeshavJha2002",
                        "content": "Well you are expected to design a data structure... not use some already existing ones"
                    },
                    {
                        "username": "Baymurat",
                        "content": "How it can be \"Everything is O(1)\"? Let\\'s assume we did 100 \"inc\" and now we have in first map (mapKeyToCount) 100 keys with value 1 each of them and in the second map (mapCountToKey) 1 key with value of List with length of 100 elements. Now we do next \"inc\" of existing element, it means we have to find it in mapCountToKey and remove. And it\\'s O(N). Isn\\'t it so?!"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Lol big relate on the \"DP questions where i die\" part. "
                    },
                    {
                        "username": "a74705745",
                        "content": "There are many solution that use \"Doubly Linked List\" and they use Linear Search for find specific node, I think it is not match condition that is described by Problem \"  Note that each function must run in O(1) average time complexity \". Because Linear Search cost O(n) time complexity. "
                    },
                    {
                        "username": "Akash221991",
                        "content": "\\nkeyCountMap: This hash map is used to store the counts associated with each key. \\nFor example, if you have a key \"hello\" with a count of 3, the keyCountMap would have an entry like (\"hello\", 3).\\nThis map is used to efficiently update and access the counts of individual keys when performing the inc and dec operations. It allows you to quickly determine the current count of a key in O(1) time.\\n\\ncountKeyMap: This hash map is used to maintain a collection of keys for each count value. For instance, if you have multiple keys with a count of 3, the countKeyMap would have an entry like (3, {\"key1\", \"key2\", \"key3\"}).\\n\\nThis map is important for implementing the getMaxKey and getMinKey operations efficiently. Instead of searching through all keys to find the maximum and minimum counts, you can directly access the keys associated with the maximum and minimum counts in O(1) time."
                    },
                    {
                        "username": "StefanelStan",
                        "content": "A simple \"hard\" problem that requires some concentration.\\n1. Use a HashMap<String, Integer> to keep track of the count of each String\\n2. Use a TreeMap<Integer, Set<String>> to keep track of the buckets of each count to return the min/max.\\n3. As enhancement, you don\\'t really need to store a Set<String> in the 2nd map, but a Node(String, next, previous) of a manual doubly linked list. Each time you move buckets, you disconnect the nodes from old bucket and connect to the new bucket."
                    }
                ]
            },
            {
                "id": 2016952,
                "content": [
                    {
                        "username": "ajak6",
                        "content": "What does the following mean? Increment a string by 1 (integer)?\\n>increments an existing key by 1\\n\\nI think it means the value of the key : can be clearly written in the question."
                    },
                    {
                        "username": "rishihho",
                        "content": "O(1) makes no sense"
                    },
                    {
                        "username": "skywalker94",
                        "content": "It\\'s hard but possible to get O(1) time complexity (some operation may have to be amortized O(1))!"
                    },
                    {
                        "username": "mang11",
                        "content": "Can some one explain to me how you can write the solution to this problem in 35 mins in the interview? If you get asked this question, I just interpret as the interviewer not wanting to hire you."
                    },
                    {
                        "username": "StefanelStan",
                        "content": "It is very intuitive to use HashMap<String, Integer> to count the string AND a TreeMap<Integer, Set<String>> to hold the strings grouped by their count. With each inc/dec you increment/decrement the count from first map and move the string across buckets from the 2nd map."
                    },
                    {
                        "username": "Django_Developer",
                        "content": "This one is very similar to LRU Cache Problem"
                    },
                    {
                        "username": "sarathecoder",
                        "content": "why not just use orderedDict in python? It supports dict + linkedlist functions .\\nWe also use orderedDict for the LRU cache problem, so why not here?"
                    },
                    {
                        "username": "skywalker94",
                        "content": "The issue is that you\\'re supposed to do each operation in O(1). orderedDict uses a binary search tree implementation, and has O(logn) time complexity"
                    },
                    {
                        "username": "kesarwaniankit48",
                        "content": "Can there be a scenario where conflict is possible? Say for below example wherein at the end the count for both hello and leet will be same, what will be the min and max key output? Correct me if I am missing something.\\n\\n[\"AllOne\", \"inc\", \"inc\", \"getMaxKey\", \"getMinKey\", \"inc\", \"getMaxKey\", \"getMinKey\",\"dec\",\"getMaxKey\", \"getMinKey\"]\\n[[], [\"hello\"], [\"hello\"], [], [], [\"leet\"], [], [], [\"hello\"],[],[]]"
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "How is this hard? This is basic hash mapping. I don\\'t get why people find this difficult, and not DP questions where I die.\\n\\nOne hash map to count the key, one hash map to map the count back to the key. Update and delete keys from both hash maps as needed. Everything is O(1).\\n\\nAm I missing some requirement? I don\\'t see the description mentioning anything about not using hash maps."
                    },
                    {
                        "username": "KeshavJha2002",
                        "content": "Well you are expected to design a data structure... not use some already existing ones"
                    },
                    {
                        "username": "Baymurat",
                        "content": "How it can be \"Everything is O(1)\"? Let\\'s assume we did 100 \"inc\" and now we have in first map (mapKeyToCount) 100 keys with value 1 each of them and in the second map (mapCountToKey) 1 key with value of List with length of 100 elements. Now we do next \"inc\" of existing element, it means we have to find it in mapCountToKey and remove. And it\\'s O(N). Isn\\'t it so?!"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Lol big relate on the \"DP questions where i die\" part. "
                    },
                    {
                        "username": "a74705745",
                        "content": "There are many solution that use \"Doubly Linked List\" and they use Linear Search for find specific node, I think it is not match condition that is described by Problem \"  Note that each function must run in O(1) average time complexity \". Because Linear Search cost O(n) time complexity. "
                    },
                    {
                        "username": "Akash221991",
                        "content": "\\nkeyCountMap: This hash map is used to store the counts associated with each key. \\nFor example, if you have a key \"hello\" with a count of 3, the keyCountMap would have an entry like (\"hello\", 3).\\nThis map is used to efficiently update and access the counts of individual keys when performing the inc and dec operations. It allows you to quickly determine the current count of a key in O(1) time.\\n\\ncountKeyMap: This hash map is used to maintain a collection of keys for each count value. For instance, if you have multiple keys with a count of 3, the countKeyMap would have an entry like (3, {\"key1\", \"key2\", \"key3\"}).\\n\\nThis map is important for implementing the getMaxKey and getMinKey operations efficiently. Instead of searching through all keys to find the maximum and minimum counts, you can directly access the keys associated with the maximum and minimum counts in O(1) time."
                    },
                    {
                        "username": "StefanelStan",
                        "content": "A simple \"hard\" problem that requires some concentration.\\n1. Use a HashMap<String, Integer> to keep track of the count of each String\\n2. Use a TreeMap<Integer, Set<String>> to keep track of the buckets of each count to return the min/max.\\n3. As enhancement, you don\\'t really need to store a Set<String> in the 2nd map, but a Node(String, next, previous) of a manual doubly linked list. Each time you move buckets, you disconnect the nodes from old bucket and connect to the new bucket."
                    }
                ]
            },
            {
                "id": 1983437,
                "content": [
                    {
                        "username": "ajak6",
                        "content": "What does the following mean? Increment a string by 1 (integer)?\\n>increments an existing key by 1\\n\\nI think it means the value of the key : can be clearly written in the question."
                    },
                    {
                        "username": "rishihho",
                        "content": "O(1) makes no sense"
                    },
                    {
                        "username": "skywalker94",
                        "content": "It\\'s hard but possible to get O(1) time complexity (some operation may have to be amortized O(1))!"
                    },
                    {
                        "username": "mang11",
                        "content": "Can some one explain to me how you can write the solution to this problem in 35 mins in the interview? If you get asked this question, I just interpret as the interviewer not wanting to hire you."
                    },
                    {
                        "username": "StefanelStan",
                        "content": "It is very intuitive to use HashMap<String, Integer> to count the string AND a TreeMap<Integer, Set<String>> to hold the strings grouped by their count. With each inc/dec you increment/decrement the count from first map and move the string across buckets from the 2nd map."
                    },
                    {
                        "username": "Django_Developer",
                        "content": "This one is very similar to LRU Cache Problem"
                    },
                    {
                        "username": "sarathecoder",
                        "content": "why not just use orderedDict in python? It supports dict + linkedlist functions .\\nWe also use orderedDict for the LRU cache problem, so why not here?"
                    },
                    {
                        "username": "skywalker94",
                        "content": "The issue is that you\\'re supposed to do each operation in O(1). orderedDict uses a binary search tree implementation, and has O(logn) time complexity"
                    },
                    {
                        "username": "kesarwaniankit48",
                        "content": "Can there be a scenario where conflict is possible? Say for below example wherein at the end the count for both hello and leet will be same, what will be the min and max key output? Correct me if I am missing something.\\n\\n[\"AllOne\", \"inc\", \"inc\", \"getMaxKey\", \"getMinKey\", \"inc\", \"getMaxKey\", \"getMinKey\",\"dec\",\"getMaxKey\", \"getMinKey\"]\\n[[], [\"hello\"], [\"hello\"], [], [], [\"leet\"], [], [], [\"hello\"],[],[]]"
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "How is this hard? This is basic hash mapping. I don\\'t get why people find this difficult, and not DP questions where I die.\\n\\nOne hash map to count the key, one hash map to map the count back to the key. Update and delete keys from both hash maps as needed. Everything is O(1).\\n\\nAm I missing some requirement? I don\\'t see the description mentioning anything about not using hash maps."
                    },
                    {
                        "username": "KeshavJha2002",
                        "content": "Well you are expected to design a data structure... not use some already existing ones"
                    },
                    {
                        "username": "Baymurat",
                        "content": "How it can be \"Everything is O(1)\"? Let\\'s assume we did 100 \"inc\" and now we have in first map (mapKeyToCount) 100 keys with value 1 each of them and in the second map (mapCountToKey) 1 key with value of List with length of 100 elements. Now we do next \"inc\" of existing element, it means we have to find it in mapCountToKey and remove. And it\\'s O(N). Isn\\'t it so?!"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Lol big relate on the \"DP questions where i die\" part. "
                    },
                    {
                        "username": "a74705745",
                        "content": "There are many solution that use \"Doubly Linked List\" and they use Linear Search for find specific node, I think it is not match condition that is described by Problem \"  Note that each function must run in O(1) average time complexity \". Because Linear Search cost O(n) time complexity. "
                    },
                    {
                        "username": "Akash221991",
                        "content": "\\nkeyCountMap: This hash map is used to store the counts associated with each key. \\nFor example, if you have a key \"hello\" with a count of 3, the keyCountMap would have an entry like (\"hello\", 3).\\nThis map is used to efficiently update and access the counts of individual keys when performing the inc and dec operations. It allows you to quickly determine the current count of a key in O(1) time.\\n\\ncountKeyMap: This hash map is used to maintain a collection of keys for each count value. For instance, if you have multiple keys with a count of 3, the countKeyMap would have an entry like (3, {\"key1\", \"key2\", \"key3\"}).\\n\\nThis map is important for implementing the getMaxKey and getMinKey operations efficiently. Instead of searching through all keys to find the maximum and minimum counts, you can directly access the keys associated with the maximum and minimum counts in O(1) time."
                    },
                    {
                        "username": "StefanelStan",
                        "content": "A simple \"hard\" problem that requires some concentration.\\n1. Use a HashMap<String, Integer> to keep track of the count of each String\\n2. Use a TreeMap<Integer, Set<String>> to keep track of the buckets of each count to return the min/max.\\n3. As enhancement, you don\\'t really need to store a Set<String> in the 2nd map, but a Node(String, next, previous) of a manual doubly linked list. Each time you move buckets, you disconnect the nodes from old bucket and connect to the new bucket."
                    }
                ]
            },
            {
                "id": 2047822,
                "content": [
                    {
                        "username": "ajak6",
                        "content": "What does the following mean? Increment a string by 1 (integer)?\\n>increments an existing key by 1\\n\\nI think it means the value of the key : can be clearly written in the question."
                    },
                    {
                        "username": "rishihho",
                        "content": "O(1) makes no sense"
                    },
                    {
                        "username": "skywalker94",
                        "content": "It\\'s hard but possible to get O(1) time complexity (some operation may have to be amortized O(1))!"
                    },
                    {
                        "username": "mang11",
                        "content": "Can some one explain to me how you can write the solution to this problem in 35 mins in the interview? If you get asked this question, I just interpret as the interviewer not wanting to hire you."
                    },
                    {
                        "username": "StefanelStan",
                        "content": "It is very intuitive to use HashMap<String, Integer> to count the string AND a TreeMap<Integer, Set<String>> to hold the strings grouped by their count. With each inc/dec you increment/decrement the count from first map and move the string across buckets from the 2nd map."
                    },
                    {
                        "username": "Django_Developer",
                        "content": "This one is very similar to LRU Cache Problem"
                    },
                    {
                        "username": "sarathecoder",
                        "content": "why not just use orderedDict in python? It supports dict + linkedlist functions .\\nWe also use orderedDict for the LRU cache problem, so why not here?"
                    },
                    {
                        "username": "skywalker94",
                        "content": "The issue is that you\\'re supposed to do each operation in O(1). orderedDict uses a binary search tree implementation, and has O(logn) time complexity"
                    },
                    {
                        "username": "kesarwaniankit48",
                        "content": "Can there be a scenario where conflict is possible? Say for below example wherein at the end the count for both hello and leet will be same, what will be the min and max key output? Correct me if I am missing something.\\n\\n[\"AllOne\", \"inc\", \"inc\", \"getMaxKey\", \"getMinKey\", \"inc\", \"getMaxKey\", \"getMinKey\",\"dec\",\"getMaxKey\", \"getMinKey\"]\\n[[], [\"hello\"], [\"hello\"], [], [], [\"leet\"], [], [], [\"hello\"],[],[]]"
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "How is this hard? This is basic hash mapping. I don\\'t get why people find this difficult, and not DP questions where I die.\\n\\nOne hash map to count the key, one hash map to map the count back to the key. Update and delete keys from both hash maps as needed. Everything is O(1).\\n\\nAm I missing some requirement? I don\\'t see the description mentioning anything about not using hash maps."
                    },
                    {
                        "username": "KeshavJha2002",
                        "content": "Well you are expected to design a data structure... not use some already existing ones"
                    },
                    {
                        "username": "Baymurat",
                        "content": "How it can be \"Everything is O(1)\"? Let\\'s assume we did 100 \"inc\" and now we have in first map (mapKeyToCount) 100 keys with value 1 each of them and in the second map (mapCountToKey) 1 key with value of List with length of 100 elements. Now we do next \"inc\" of existing element, it means we have to find it in mapCountToKey and remove. And it\\'s O(N). Isn\\'t it so?!"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Lol big relate on the \"DP questions where i die\" part. "
                    },
                    {
                        "username": "a74705745",
                        "content": "There are many solution that use \"Doubly Linked List\" and they use Linear Search for find specific node, I think it is not match condition that is described by Problem \"  Note that each function must run in O(1) average time complexity \". Because Linear Search cost O(n) time complexity. "
                    },
                    {
                        "username": "Akash221991",
                        "content": "\\nkeyCountMap: This hash map is used to store the counts associated with each key. \\nFor example, if you have a key \"hello\" with a count of 3, the keyCountMap would have an entry like (\"hello\", 3).\\nThis map is used to efficiently update and access the counts of individual keys when performing the inc and dec operations. It allows you to quickly determine the current count of a key in O(1) time.\\n\\ncountKeyMap: This hash map is used to maintain a collection of keys for each count value. For instance, if you have multiple keys with a count of 3, the countKeyMap would have an entry like (3, {\"key1\", \"key2\", \"key3\"}).\\n\\nThis map is important for implementing the getMaxKey and getMinKey operations efficiently. Instead of searching through all keys to find the maximum and minimum counts, you can directly access the keys associated with the maximum and minimum counts in O(1) time."
                    },
                    {
                        "username": "StefanelStan",
                        "content": "A simple \"hard\" problem that requires some concentration.\\n1. Use a HashMap<String, Integer> to keep track of the count of each String\\n2. Use a TreeMap<Integer, Set<String>> to keep track of the buckets of each count to return the min/max.\\n3. As enhancement, you don\\'t really need to store a Set<String> in the 2nd map, but a Node(String, next, previous) of a manual doubly linked list. Each time you move buckets, you disconnect the nodes from old bucket and connect to the new bucket."
                    }
                ]
            },
            {
                "id": 2023264,
                "content": [
                    {
                        "username": "ajak6",
                        "content": "What does the following mean? Increment a string by 1 (integer)?\\n>increments an existing key by 1\\n\\nI think it means the value of the key : can be clearly written in the question."
                    },
                    {
                        "username": "rishihho",
                        "content": "O(1) makes no sense"
                    },
                    {
                        "username": "skywalker94",
                        "content": "It\\'s hard but possible to get O(1) time complexity (some operation may have to be amortized O(1))!"
                    },
                    {
                        "username": "mang11",
                        "content": "Can some one explain to me how you can write the solution to this problem in 35 mins in the interview? If you get asked this question, I just interpret as the interviewer not wanting to hire you."
                    },
                    {
                        "username": "StefanelStan",
                        "content": "It is very intuitive to use HashMap<String, Integer> to count the string AND a TreeMap<Integer, Set<String>> to hold the strings grouped by their count. With each inc/dec you increment/decrement the count from first map and move the string across buckets from the 2nd map."
                    },
                    {
                        "username": "Django_Developer",
                        "content": "This one is very similar to LRU Cache Problem"
                    },
                    {
                        "username": "sarathecoder",
                        "content": "why not just use orderedDict in python? It supports dict + linkedlist functions .\\nWe also use orderedDict for the LRU cache problem, so why not here?"
                    },
                    {
                        "username": "skywalker94",
                        "content": "The issue is that you\\'re supposed to do each operation in O(1). orderedDict uses a binary search tree implementation, and has O(logn) time complexity"
                    },
                    {
                        "username": "kesarwaniankit48",
                        "content": "Can there be a scenario where conflict is possible? Say for below example wherein at the end the count for both hello and leet will be same, what will be the min and max key output? Correct me if I am missing something.\\n\\n[\"AllOne\", \"inc\", \"inc\", \"getMaxKey\", \"getMinKey\", \"inc\", \"getMaxKey\", \"getMinKey\",\"dec\",\"getMaxKey\", \"getMinKey\"]\\n[[], [\"hello\"], [\"hello\"], [], [], [\"leet\"], [], [], [\"hello\"],[],[]]"
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "How is this hard? This is basic hash mapping. I don\\'t get why people find this difficult, and not DP questions where I die.\\n\\nOne hash map to count the key, one hash map to map the count back to the key. Update and delete keys from both hash maps as needed. Everything is O(1).\\n\\nAm I missing some requirement? I don\\'t see the description mentioning anything about not using hash maps."
                    },
                    {
                        "username": "KeshavJha2002",
                        "content": "Well you are expected to design a data structure... not use some already existing ones"
                    },
                    {
                        "username": "Baymurat",
                        "content": "How it can be \"Everything is O(1)\"? Let\\'s assume we did 100 \"inc\" and now we have in first map (mapKeyToCount) 100 keys with value 1 each of them and in the second map (mapCountToKey) 1 key with value of List with length of 100 elements. Now we do next \"inc\" of existing element, it means we have to find it in mapCountToKey and remove. And it\\'s O(N). Isn\\'t it so?!"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Lol big relate on the \"DP questions where i die\" part. "
                    },
                    {
                        "username": "a74705745",
                        "content": "There are many solution that use \"Doubly Linked List\" and they use Linear Search for find specific node, I think it is not match condition that is described by Problem \"  Note that each function must run in O(1) average time complexity \". Because Linear Search cost O(n) time complexity. "
                    },
                    {
                        "username": "Akash221991",
                        "content": "\\nkeyCountMap: This hash map is used to store the counts associated with each key. \\nFor example, if you have a key \"hello\" with a count of 3, the keyCountMap would have an entry like (\"hello\", 3).\\nThis map is used to efficiently update and access the counts of individual keys when performing the inc and dec operations. It allows you to quickly determine the current count of a key in O(1) time.\\n\\ncountKeyMap: This hash map is used to maintain a collection of keys for each count value. For instance, if you have multiple keys with a count of 3, the countKeyMap would have an entry like (3, {\"key1\", \"key2\", \"key3\"}).\\n\\nThis map is important for implementing the getMaxKey and getMinKey operations efficiently. Instead of searching through all keys to find the maximum and minimum counts, you can directly access the keys associated with the maximum and minimum counts in O(1) time."
                    },
                    {
                        "username": "StefanelStan",
                        "content": "A simple \"hard\" problem that requires some concentration.\\n1. Use a HashMap<String, Integer> to keep track of the count of each String\\n2. Use a TreeMap<Integer, Set<String>> to keep track of the buckets of each count to return the min/max.\\n3. As enhancement, you don\\'t really need to store a Set<String> in the 2nd map, but a Node(String, next, previous) of a manual doubly linked list. Each time you move buckets, you disconnect the nodes from old bucket and connect to the new bucket."
                    }
                ]
            },
            {
                "id": 2019676,
                "content": [
                    {
                        "username": "ajak6",
                        "content": "What does the following mean? Increment a string by 1 (integer)?\\n>increments an existing key by 1\\n\\nI think it means the value of the key : can be clearly written in the question."
                    },
                    {
                        "username": "rishihho",
                        "content": "O(1) makes no sense"
                    },
                    {
                        "username": "skywalker94",
                        "content": "It\\'s hard but possible to get O(1) time complexity (some operation may have to be amortized O(1))!"
                    },
                    {
                        "username": "mang11",
                        "content": "Can some one explain to me how you can write the solution to this problem in 35 mins in the interview? If you get asked this question, I just interpret as the interviewer not wanting to hire you."
                    },
                    {
                        "username": "StefanelStan",
                        "content": "It is very intuitive to use HashMap<String, Integer> to count the string AND a TreeMap<Integer, Set<String>> to hold the strings grouped by their count. With each inc/dec you increment/decrement the count from first map and move the string across buckets from the 2nd map."
                    },
                    {
                        "username": "Django_Developer",
                        "content": "This one is very similar to LRU Cache Problem"
                    },
                    {
                        "username": "sarathecoder",
                        "content": "why not just use orderedDict in python? It supports dict + linkedlist functions .\\nWe also use orderedDict for the LRU cache problem, so why not here?"
                    },
                    {
                        "username": "skywalker94",
                        "content": "The issue is that you\\'re supposed to do each operation in O(1). orderedDict uses a binary search tree implementation, and has O(logn) time complexity"
                    },
                    {
                        "username": "kesarwaniankit48",
                        "content": "Can there be a scenario where conflict is possible? Say for below example wherein at the end the count for both hello and leet will be same, what will be the min and max key output? Correct me if I am missing something.\\n\\n[\"AllOne\", \"inc\", \"inc\", \"getMaxKey\", \"getMinKey\", \"inc\", \"getMaxKey\", \"getMinKey\",\"dec\",\"getMaxKey\", \"getMinKey\"]\\n[[], [\"hello\"], [\"hello\"], [], [], [\"leet\"], [], [], [\"hello\"],[],[]]"
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "How is this hard? This is basic hash mapping. I don\\'t get why people find this difficult, and not DP questions where I die.\\n\\nOne hash map to count the key, one hash map to map the count back to the key. Update and delete keys from both hash maps as needed. Everything is O(1).\\n\\nAm I missing some requirement? I don\\'t see the description mentioning anything about not using hash maps."
                    },
                    {
                        "username": "KeshavJha2002",
                        "content": "Well you are expected to design a data structure... not use some already existing ones"
                    },
                    {
                        "username": "Baymurat",
                        "content": "How it can be \"Everything is O(1)\"? Let\\'s assume we did 100 \"inc\" and now we have in first map (mapKeyToCount) 100 keys with value 1 each of them and in the second map (mapCountToKey) 1 key with value of List with length of 100 elements. Now we do next \"inc\" of existing element, it means we have to find it in mapCountToKey and remove. And it\\'s O(N). Isn\\'t it so?!"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Lol big relate on the \"DP questions where i die\" part. "
                    },
                    {
                        "username": "a74705745",
                        "content": "There are many solution that use \"Doubly Linked List\" and they use Linear Search for find specific node, I think it is not match condition that is described by Problem \"  Note that each function must run in O(1) average time complexity \". Because Linear Search cost O(n) time complexity. "
                    },
                    {
                        "username": "Akash221991",
                        "content": "\\nkeyCountMap: This hash map is used to store the counts associated with each key. \\nFor example, if you have a key \"hello\" with a count of 3, the keyCountMap would have an entry like (\"hello\", 3).\\nThis map is used to efficiently update and access the counts of individual keys when performing the inc and dec operations. It allows you to quickly determine the current count of a key in O(1) time.\\n\\ncountKeyMap: This hash map is used to maintain a collection of keys for each count value. For instance, if you have multiple keys with a count of 3, the countKeyMap would have an entry like (3, {\"key1\", \"key2\", \"key3\"}).\\n\\nThis map is important for implementing the getMaxKey and getMinKey operations efficiently. Instead of searching through all keys to find the maximum and minimum counts, you can directly access the keys associated with the maximum and minimum counts in O(1) time."
                    },
                    {
                        "username": "StefanelStan",
                        "content": "A simple \"hard\" problem that requires some concentration.\\n1. Use a HashMap<String, Integer> to keep track of the count of each String\\n2. Use a TreeMap<Integer, Set<String>> to keep track of the buckets of each count to return the min/max.\\n3. As enhancement, you don\\'t really need to store a Set<String> in the 2nd map, but a Node(String, next, previous) of a manual doubly linked list. Each time you move buckets, you disconnect the nodes from old bucket and connect to the new bucket."
                    }
                ]
            },
            {
                "id": 1565438,
                "content": [
                    {
                        "username": "ajak6",
                        "content": "What does the following mean? Increment a string by 1 (integer)?\\n>increments an existing key by 1\\n\\nI think it means the value of the key : can be clearly written in the question."
                    },
                    {
                        "username": "rishihho",
                        "content": "O(1) makes no sense"
                    },
                    {
                        "username": "skywalker94",
                        "content": "It\\'s hard but possible to get O(1) time complexity (some operation may have to be amortized O(1))!"
                    },
                    {
                        "username": "mang11",
                        "content": "Can some one explain to me how you can write the solution to this problem in 35 mins in the interview? If you get asked this question, I just interpret as the interviewer not wanting to hire you."
                    },
                    {
                        "username": "StefanelStan",
                        "content": "It is very intuitive to use HashMap<String, Integer> to count the string AND a TreeMap<Integer, Set<String>> to hold the strings grouped by their count. With each inc/dec you increment/decrement the count from first map and move the string across buckets from the 2nd map."
                    },
                    {
                        "username": "Django_Developer",
                        "content": "This one is very similar to LRU Cache Problem"
                    },
                    {
                        "username": "sarathecoder",
                        "content": "why not just use orderedDict in python? It supports dict + linkedlist functions .\\nWe also use orderedDict for the LRU cache problem, so why not here?"
                    },
                    {
                        "username": "skywalker94",
                        "content": "The issue is that you\\'re supposed to do each operation in O(1). orderedDict uses a binary search tree implementation, and has O(logn) time complexity"
                    },
                    {
                        "username": "kesarwaniankit48",
                        "content": "Can there be a scenario where conflict is possible? Say for below example wherein at the end the count for both hello and leet will be same, what will be the min and max key output? Correct me if I am missing something.\\n\\n[\"AllOne\", \"inc\", \"inc\", \"getMaxKey\", \"getMinKey\", \"inc\", \"getMaxKey\", \"getMinKey\",\"dec\",\"getMaxKey\", \"getMinKey\"]\\n[[], [\"hello\"], [\"hello\"], [], [], [\"leet\"], [], [], [\"hello\"],[],[]]"
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "How is this hard? This is basic hash mapping. I don\\'t get why people find this difficult, and not DP questions where I die.\\n\\nOne hash map to count the key, one hash map to map the count back to the key. Update and delete keys from both hash maps as needed. Everything is O(1).\\n\\nAm I missing some requirement? I don\\'t see the description mentioning anything about not using hash maps."
                    },
                    {
                        "username": "KeshavJha2002",
                        "content": "Well you are expected to design a data structure... not use some already existing ones"
                    },
                    {
                        "username": "Baymurat",
                        "content": "How it can be \"Everything is O(1)\"? Let\\'s assume we did 100 \"inc\" and now we have in first map (mapKeyToCount) 100 keys with value 1 each of them and in the second map (mapCountToKey) 1 key with value of List with length of 100 elements. Now we do next \"inc\" of existing element, it means we have to find it in mapCountToKey and remove. And it\\'s O(N). Isn\\'t it so?!"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Lol big relate on the \"DP questions where i die\" part. "
                    },
                    {
                        "username": "a74705745",
                        "content": "There are many solution that use \"Doubly Linked List\" and they use Linear Search for find specific node, I think it is not match condition that is described by Problem \"  Note that each function must run in O(1) average time complexity \". Because Linear Search cost O(n) time complexity. "
                    },
                    {
                        "username": "Akash221991",
                        "content": "\\nkeyCountMap: This hash map is used to store the counts associated with each key. \\nFor example, if you have a key \"hello\" with a count of 3, the keyCountMap would have an entry like (\"hello\", 3).\\nThis map is used to efficiently update and access the counts of individual keys when performing the inc and dec operations. It allows you to quickly determine the current count of a key in O(1) time.\\n\\ncountKeyMap: This hash map is used to maintain a collection of keys for each count value. For instance, if you have multiple keys with a count of 3, the countKeyMap would have an entry like (3, {\"key1\", \"key2\", \"key3\"}).\\n\\nThis map is important for implementing the getMaxKey and getMinKey operations efficiently. Instead of searching through all keys to find the maximum and minimum counts, you can directly access the keys associated with the maximum and minimum counts in O(1) time."
                    },
                    {
                        "username": "StefanelStan",
                        "content": "A simple \"hard\" problem that requires some concentration.\\n1. Use a HashMap<String, Integer> to keep track of the count of each String\\n2. Use a TreeMap<Integer, Set<String>> to keep track of the buckets of each count to return the min/max.\\n3. As enhancement, you don\\'t really need to store a Set<String> in the 2nd map, but a Node(String, next, previous) of a manual doubly linked list. Each time you move buckets, you disconnect the nodes from old bucket and connect to the new bucket."
                    }
                ]
            },
            {
                "id": 1569812,
                "content": [
                    {
                        "username": "ajak6",
                        "content": "What does the following mean? Increment a string by 1 (integer)?\\n>increments an existing key by 1\\n\\nI think it means the value of the key : can be clearly written in the question."
                    },
                    {
                        "username": "rishihho",
                        "content": "O(1) makes no sense"
                    },
                    {
                        "username": "skywalker94",
                        "content": "It\\'s hard but possible to get O(1) time complexity (some operation may have to be amortized O(1))!"
                    },
                    {
                        "username": "mang11",
                        "content": "Can some one explain to me how you can write the solution to this problem in 35 mins in the interview? If you get asked this question, I just interpret as the interviewer not wanting to hire you."
                    },
                    {
                        "username": "StefanelStan",
                        "content": "It is very intuitive to use HashMap<String, Integer> to count the string AND a TreeMap<Integer, Set<String>> to hold the strings grouped by their count. With each inc/dec you increment/decrement the count from first map and move the string across buckets from the 2nd map."
                    },
                    {
                        "username": "Django_Developer",
                        "content": "This one is very similar to LRU Cache Problem"
                    },
                    {
                        "username": "sarathecoder",
                        "content": "why not just use orderedDict in python? It supports dict + linkedlist functions .\\nWe also use orderedDict for the LRU cache problem, so why not here?"
                    },
                    {
                        "username": "skywalker94",
                        "content": "The issue is that you\\'re supposed to do each operation in O(1). orderedDict uses a binary search tree implementation, and has O(logn) time complexity"
                    },
                    {
                        "username": "kesarwaniankit48",
                        "content": "Can there be a scenario where conflict is possible? Say for below example wherein at the end the count for both hello and leet will be same, what will be the min and max key output? Correct me if I am missing something.\\n\\n[\"AllOne\", \"inc\", \"inc\", \"getMaxKey\", \"getMinKey\", \"inc\", \"getMaxKey\", \"getMinKey\",\"dec\",\"getMaxKey\", \"getMinKey\"]\\n[[], [\"hello\"], [\"hello\"], [], [], [\"leet\"], [], [], [\"hello\"],[],[]]"
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "How is this hard? This is basic hash mapping. I don\\'t get why people find this difficult, and not DP questions where I die.\\n\\nOne hash map to count the key, one hash map to map the count back to the key. Update and delete keys from both hash maps as needed. Everything is O(1).\\n\\nAm I missing some requirement? I don\\'t see the description mentioning anything about not using hash maps."
                    },
                    {
                        "username": "KeshavJha2002",
                        "content": "Well you are expected to design a data structure... not use some already existing ones"
                    },
                    {
                        "username": "Baymurat",
                        "content": "How it can be \"Everything is O(1)\"? Let\\'s assume we did 100 \"inc\" and now we have in first map (mapKeyToCount) 100 keys with value 1 each of them and in the second map (mapCountToKey) 1 key with value of List with length of 100 elements. Now we do next \"inc\" of existing element, it means we have to find it in mapCountToKey and remove. And it\\'s O(N). Isn\\'t it so?!"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Lol big relate on the \"DP questions where i die\" part. "
                    },
                    {
                        "username": "a74705745",
                        "content": "There are many solution that use \"Doubly Linked List\" and they use Linear Search for find specific node, I think it is not match condition that is described by Problem \"  Note that each function must run in O(1) average time complexity \". Because Linear Search cost O(n) time complexity. "
                    },
                    {
                        "username": "Akash221991",
                        "content": "\\nkeyCountMap: This hash map is used to store the counts associated with each key. \\nFor example, if you have a key \"hello\" with a count of 3, the keyCountMap would have an entry like (\"hello\", 3).\\nThis map is used to efficiently update and access the counts of individual keys when performing the inc and dec operations. It allows you to quickly determine the current count of a key in O(1) time.\\n\\ncountKeyMap: This hash map is used to maintain a collection of keys for each count value. For instance, if you have multiple keys with a count of 3, the countKeyMap would have an entry like (3, {\"key1\", \"key2\", \"key3\"}).\\n\\nThis map is important for implementing the getMaxKey and getMinKey operations efficiently. Instead of searching through all keys to find the maximum and minimum counts, you can directly access the keys associated with the maximum and minimum counts in O(1) time."
                    },
                    {
                        "username": "StefanelStan",
                        "content": "A simple \"hard\" problem that requires some concentration.\\n1. Use a HashMap<String, Integer> to keep track of the count of each String\\n2. Use a TreeMap<Integer, Set<String>> to keep track of the buckets of each count to return the min/max.\\n3. As enhancement, you don\\'t really need to store a Set<String> in the 2nd map, but a Node(String, next, previous) of a manual doubly linked list. Each time you move buckets, you disconnect the nodes from old bucket and connect to the new bucket."
                    }
                ]
            },
            {
                "id": 1575766,
                "content": [
                    {
                        "username": "ajak6",
                        "content": "What does the following mean? Increment a string by 1 (integer)?\\n>increments an existing key by 1\\n\\nI think it means the value of the key : can be clearly written in the question."
                    },
                    {
                        "username": "rishihho",
                        "content": "O(1) makes no sense"
                    },
                    {
                        "username": "skywalker94",
                        "content": "It\\'s hard but possible to get O(1) time complexity (some operation may have to be amortized O(1))!"
                    },
                    {
                        "username": "mang11",
                        "content": "Can some one explain to me how you can write the solution to this problem in 35 mins in the interview? If you get asked this question, I just interpret as the interviewer not wanting to hire you."
                    },
                    {
                        "username": "StefanelStan",
                        "content": "It is very intuitive to use HashMap<String, Integer> to count the string AND a TreeMap<Integer, Set<String>> to hold the strings grouped by their count. With each inc/dec you increment/decrement the count from first map and move the string across buckets from the 2nd map."
                    },
                    {
                        "username": "Django_Developer",
                        "content": "This one is very similar to LRU Cache Problem"
                    },
                    {
                        "username": "sarathecoder",
                        "content": "why not just use orderedDict in python? It supports dict + linkedlist functions .\\nWe also use orderedDict for the LRU cache problem, so why not here?"
                    },
                    {
                        "username": "skywalker94",
                        "content": "The issue is that you\\'re supposed to do each operation in O(1). orderedDict uses a binary search tree implementation, and has O(logn) time complexity"
                    },
                    {
                        "username": "kesarwaniankit48",
                        "content": "Can there be a scenario where conflict is possible? Say for below example wherein at the end the count for both hello and leet will be same, what will be the min and max key output? Correct me if I am missing something.\\n\\n[\"AllOne\", \"inc\", \"inc\", \"getMaxKey\", \"getMinKey\", \"inc\", \"getMaxKey\", \"getMinKey\",\"dec\",\"getMaxKey\", \"getMinKey\"]\\n[[], [\"hello\"], [\"hello\"], [], [], [\"leet\"], [], [], [\"hello\"],[],[]]"
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "How is this hard? This is basic hash mapping. I don\\'t get why people find this difficult, and not DP questions where I die.\\n\\nOne hash map to count the key, one hash map to map the count back to the key. Update and delete keys from both hash maps as needed. Everything is O(1).\\n\\nAm I missing some requirement? I don\\'t see the description mentioning anything about not using hash maps."
                    },
                    {
                        "username": "KeshavJha2002",
                        "content": "Well you are expected to design a data structure... not use some already existing ones"
                    },
                    {
                        "username": "Baymurat",
                        "content": "How it can be \"Everything is O(1)\"? Let\\'s assume we did 100 \"inc\" and now we have in first map (mapKeyToCount) 100 keys with value 1 each of them and in the second map (mapCountToKey) 1 key with value of List with length of 100 elements. Now we do next \"inc\" of existing element, it means we have to find it in mapCountToKey and remove. And it\\'s O(N). Isn\\'t it so?!"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Lol big relate on the \"DP questions where i die\" part. "
                    },
                    {
                        "username": "a74705745",
                        "content": "There are many solution that use \"Doubly Linked List\" and they use Linear Search for find specific node, I think it is not match condition that is described by Problem \"  Note that each function must run in O(1) average time complexity \". Because Linear Search cost O(n) time complexity. "
                    },
                    {
                        "username": "Akash221991",
                        "content": "\\nkeyCountMap: This hash map is used to store the counts associated with each key. \\nFor example, if you have a key \"hello\" with a count of 3, the keyCountMap would have an entry like (\"hello\", 3).\\nThis map is used to efficiently update and access the counts of individual keys when performing the inc and dec operations. It allows you to quickly determine the current count of a key in O(1) time.\\n\\ncountKeyMap: This hash map is used to maintain a collection of keys for each count value. For instance, if you have multiple keys with a count of 3, the countKeyMap would have an entry like (3, {\"key1\", \"key2\", \"key3\"}).\\n\\nThis map is important for implementing the getMaxKey and getMinKey operations efficiently. Instead of searching through all keys to find the maximum and minimum counts, you can directly access the keys associated with the maximum and minimum counts in O(1) time."
                    },
                    {
                        "username": "StefanelStan",
                        "content": "A simple \"hard\" problem that requires some concentration.\\n1. Use a HashMap<String, Integer> to keep track of the count of each String\\n2. Use a TreeMap<Integer, Set<String>> to keep track of the buckets of each count to return the min/max.\\n3. As enhancement, you don\\'t really need to store a Set<String> in the 2nd map, but a Node(String, next, previous) of a manual doubly linked list. Each time you move buckets, you disconnect the nodes from old bucket and connect to the new bucket."
                    }
                ]
            },
            {
                "id": 1865811,
                "content": [
                    {
                        "username": "ajak6",
                        "content": "What does the following mean? Increment a string by 1 (integer)?\\n>increments an existing key by 1\\n\\nI think it means the value of the key : can be clearly written in the question."
                    },
                    {
                        "username": "rishihho",
                        "content": "O(1) makes no sense"
                    },
                    {
                        "username": "skywalker94",
                        "content": "It\\'s hard but possible to get O(1) time complexity (some operation may have to be amortized O(1))!"
                    },
                    {
                        "username": "mang11",
                        "content": "Can some one explain to me how you can write the solution to this problem in 35 mins in the interview? If you get asked this question, I just interpret as the interviewer not wanting to hire you."
                    },
                    {
                        "username": "StefanelStan",
                        "content": "It is very intuitive to use HashMap<String, Integer> to count the string AND a TreeMap<Integer, Set<String>> to hold the strings grouped by their count. With each inc/dec you increment/decrement the count from first map and move the string across buckets from the 2nd map."
                    },
                    {
                        "username": "Django_Developer",
                        "content": "This one is very similar to LRU Cache Problem"
                    },
                    {
                        "username": "sarathecoder",
                        "content": "why not just use orderedDict in python? It supports dict + linkedlist functions .\\nWe also use orderedDict for the LRU cache problem, so why not here?"
                    },
                    {
                        "username": "skywalker94",
                        "content": "The issue is that you\\'re supposed to do each operation in O(1). orderedDict uses a binary search tree implementation, and has O(logn) time complexity"
                    },
                    {
                        "username": "kesarwaniankit48",
                        "content": "Can there be a scenario where conflict is possible? Say for below example wherein at the end the count for both hello and leet will be same, what will be the min and max key output? Correct me if I am missing something.\\n\\n[\"AllOne\", \"inc\", \"inc\", \"getMaxKey\", \"getMinKey\", \"inc\", \"getMaxKey\", \"getMinKey\",\"dec\",\"getMaxKey\", \"getMinKey\"]\\n[[], [\"hello\"], [\"hello\"], [], [], [\"leet\"], [], [], [\"hello\"],[],[]]"
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "How is this hard? This is basic hash mapping. I don\\'t get why people find this difficult, and not DP questions where I die.\\n\\nOne hash map to count the key, one hash map to map the count back to the key. Update and delete keys from both hash maps as needed. Everything is O(1).\\n\\nAm I missing some requirement? I don\\'t see the description mentioning anything about not using hash maps."
                    },
                    {
                        "username": "KeshavJha2002",
                        "content": "Well you are expected to design a data structure... not use some already existing ones"
                    },
                    {
                        "username": "Baymurat",
                        "content": "How it can be \"Everything is O(1)\"? Let\\'s assume we did 100 \"inc\" and now we have in first map (mapKeyToCount) 100 keys with value 1 each of them and in the second map (mapCountToKey) 1 key with value of List with length of 100 elements. Now we do next \"inc\" of existing element, it means we have to find it in mapCountToKey and remove. And it\\'s O(N). Isn\\'t it so?!"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Lol big relate on the \"DP questions where i die\" part. "
                    },
                    {
                        "username": "a74705745",
                        "content": "There are many solution that use \"Doubly Linked List\" and they use Linear Search for find specific node, I think it is not match condition that is described by Problem \"  Note that each function must run in O(1) average time complexity \". Because Linear Search cost O(n) time complexity. "
                    },
                    {
                        "username": "Akash221991",
                        "content": "\\nkeyCountMap: This hash map is used to store the counts associated with each key. \\nFor example, if you have a key \"hello\" with a count of 3, the keyCountMap would have an entry like (\"hello\", 3).\\nThis map is used to efficiently update and access the counts of individual keys when performing the inc and dec operations. It allows you to quickly determine the current count of a key in O(1) time.\\n\\ncountKeyMap: This hash map is used to maintain a collection of keys for each count value. For instance, if you have multiple keys with a count of 3, the countKeyMap would have an entry like (3, {\"key1\", \"key2\", \"key3\"}).\\n\\nThis map is important for implementing the getMaxKey and getMinKey operations efficiently. Instead of searching through all keys to find the maximum and minimum counts, you can directly access the keys associated with the maximum and minimum counts in O(1) time."
                    },
                    {
                        "username": "StefanelStan",
                        "content": "A simple \"hard\" problem that requires some concentration.\\n1. Use a HashMap<String, Integer> to keep track of the count of each String\\n2. Use a TreeMap<Integer, Set<String>> to keep track of the buckets of each count to return the min/max.\\n3. As enhancement, you don\\'t really need to store a Set<String> in the 2nd map, but a Node(String, next, previous) of a manual doubly linked list. Each time you move buckets, you disconnect the nodes from old bucket and connect to the new bucket."
                    }
                ]
            },
            {
                "id": 1576049,
                "content": [
                    {
                        "username": "ajak6",
                        "content": "What does the following mean? Increment a string by 1 (integer)?\\n>increments an existing key by 1\\n\\nI think it means the value of the key : can be clearly written in the question."
                    },
                    {
                        "username": "rishihho",
                        "content": "O(1) makes no sense"
                    },
                    {
                        "username": "skywalker94",
                        "content": "It\\'s hard but possible to get O(1) time complexity (some operation may have to be amortized O(1))!"
                    },
                    {
                        "username": "mang11",
                        "content": "Can some one explain to me how you can write the solution to this problem in 35 mins in the interview? If you get asked this question, I just interpret as the interviewer not wanting to hire you."
                    },
                    {
                        "username": "StefanelStan",
                        "content": "It is very intuitive to use HashMap<String, Integer> to count the string AND a TreeMap<Integer, Set<String>> to hold the strings grouped by their count. With each inc/dec you increment/decrement the count from first map and move the string across buckets from the 2nd map."
                    },
                    {
                        "username": "Django_Developer",
                        "content": "This one is very similar to LRU Cache Problem"
                    },
                    {
                        "username": "sarathecoder",
                        "content": "why not just use orderedDict in python? It supports dict + linkedlist functions .\\nWe also use orderedDict for the LRU cache problem, so why not here?"
                    },
                    {
                        "username": "skywalker94",
                        "content": "The issue is that you\\'re supposed to do each operation in O(1). orderedDict uses a binary search tree implementation, and has O(logn) time complexity"
                    },
                    {
                        "username": "kesarwaniankit48",
                        "content": "Can there be a scenario where conflict is possible? Say for below example wherein at the end the count for both hello and leet will be same, what will be the min and max key output? Correct me if I am missing something.\\n\\n[\"AllOne\", \"inc\", \"inc\", \"getMaxKey\", \"getMinKey\", \"inc\", \"getMaxKey\", \"getMinKey\",\"dec\",\"getMaxKey\", \"getMinKey\"]\\n[[], [\"hello\"], [\"hello\"], [], [], [\"leet\"], [], [], [\"hello\"],[],[]]"
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "How is this hard? This is basic hash mapping. I don\\'t get why people find this difficult, and not DP questions where I die.\\n\\nOne hash map to count the key, one hash map to map the count back to the key. Update and delete keys from both hash maps as needed. Everything is O(1).\\n\\nAm I missing some requirement? I don\\'t see the description mentioning anything about not using hash maps."
                    },
                    {
                        "username": "KeshavJha2002",
                        "content": "Well you are expected to design a data structure... not use some already existing ones"
                    },
                    {
                        "username": "Baymurat",
                        "content": "How it can be \"Everything is O(1)\"? Let\\'s assume we did 100 \"inc\" and now we have in first map (mapKeyToCount) 100 keys with value 1 each of them and in the second map (mapCountToKey) 1 key with value of List with length of 100 elements. Now we do next \"inc\" of existing element, it means we have to find it in mapCountToKey and remove. And it\\'s O(N). Isn\\'t it so?!"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Lol big relate on the \"DP questions where i die\" part. "
                    },
                    {
                        "username": "a74705745",
                        "content": "There are many solution that use \"Doubly Linked List\" and they use Linear Search for find specific node, I think it is not match condition that is described by Problem \"  Note that each function must run in O(1) average time complexity \". Because Linear Search cost O(n) time complexity. "
                    },
                    {
                        "username": "Akash221991",
                        "content": "\\nkeyCountMap: This hash map is used to store the counts associated with each key. \\nFor example, if you have a key \"hello\" with a count of 3, the keyCountMap would have an entry like (\"hello\", 3).\\nThis map is used to efficiently update and access the counts of individual keys when performing the inc and dec operations. It allows you to quickly determine the current count of a key in O(1) time.\\n\\ncountKeyMap: This hash map is used to maintain a collection of keys for each count value. For instance, if you have multiple keys with a count of 3, the countKeyMap would have an entry like (3, {\"key1\", \"key2\", \"key3\"}).\\n\\nThis map is important for implementing the getMaxKey and getMinKey operations efficiently. Instead of searching through all keys to find the maximum and minimum counts, you can directly access the keys associated with the maximum and minimum counts in O(1) time."
                    },
                    {
                        "username": "StefanelStan",
                        "content": "A simple \"hard\" problem that requires some concentration.\\n1. Use a HashMap<String, Integer> to keep track of the count of each String\\n2. Use a TreeMap<Integer, Set<String>> to keep track of the buckets of each count to return the min/max.\\n3. As enhancement, you don\\'t really need to store a Set<String> in the 2nd map, but a Node(String, next, previous) of a manual doubly linked list. Each time you move buckets, you disconnect the nodes from old bucket and connect to the new bucket."
                    }
                ]
            },
            {
                "id": 2016952,
                "content": [
                    {
                        "username": "ajak6",
                        "content": "What does the following mean? Increment a string by 1 (integer)?\\n>increments an existing key by 1\\n\\nI think it means the value of the key : can be clearly written in the question."
                    },
                    {
                        "username": "rishihho",
                        "content": "O(1) makes no sense"
                    },
                    {
                        "username": "skywalker94",
                        "content": "It\\'s hard but possible to get O(1) time complexity (some operation may have to be amortized O(1))!"
                    },
                    {
                        "username": "mang11",
                        "content": "Can some one explain to me how you can write the solution to this problem in 35 mins in the interview? If you get asked this question, I just interpret as the interviewer not wanting to hire you."
                    },
                    {
                        "username": "StefanelStan",
                        "content": "It is very intuitive to use HashMap<String, Integer> to count the string AND a TreeMap<Integer, Set<String>> to hold the strings grouped by their count. With each inc/dec you increment/decrement the count from first map and move the string across buckets from the 2nd map."
                    },
                    {
                        "username": "Django_Developer",
                        "content": "This one is very similar to LRU Cache Problem"
                    },
                    {
                        "username": "sarathecoder",
                        "content": "why not just use orderedDict in python? It supports dict + linkedlist functions .\\nWe also use orderedDict for the LRU cache problem, so why not here?"
                    },
                    {
                        "username": "skywalker94",
                        "content": "The issue is that you\\'re supposed to do each operation in O(1). orderedDict uses a binary search tree implementation, and has O(logn) time complexity"
                    },
                    {
                        "username": "kesarwaniankit48",
                        "content": "Can there be a scenario where conflict is possible? Say for below example wherein at the end the count for both hello and leet will be same, what will be the min and max key output? Correct me if I am missing something.\\n\\n[\"AllOne\", \"inc\", \"inc\", \"getMaxKey\", \"getMinKey\", \"inc\", \"getMaxKey\", \"getMinKey\",\"dec\",\"getMaxKey\", \"getMinKey\"]\\n[[], [\"hello\"], [\"hello\"], [], [], [\"leet\"], [], [], [\"hello\"],[],[]]"
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "How is this hard? This is basic hash mapping. I don\\'t get why people find this difficult, and not DP questions where I die.\\n\\nOne hash map to count the key, one hash map to map the count back to the key. Update and delete keys from both hash maps as needed. Everything is O(1).\\n\\nAm I missing some requirement? I don\\'t see the description mentioning anything about not using hash maps."
                    },
                    {
                        "username": "KeshavJha2002",
                        "content": "Well you are expected to design a data structure... not use some already existing ones"
                    },
                    {
                        "username": "Baymurat",
                        "content": "How it can be \"Everything is O(1)\"? Let\\'s assume we did 100 \"inc\" and now we have in first map (mapKeyToCount) 100 keys with value 1 each of them and in the second map (mapCountToKey) 1 key with value of List with length of 100 elements. Now we do next \"inc\" of existing element, it means we have to find it in mapCountToKey and remove. And it\\'s O(N). Isn\\'t it so?!"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Lol big relate on the \"DP questions where i die\" part. "
                    },
                    {
                        "username": "a74705745",
                        "content": "There are many solution that use \"Doubly Linked List\" and they use Linear Search for find specific node, I think it is not match condition that is described by Problem \"  Note that each function must run in O(1) average time complexity \". Because Linear Search cost O(n) time complexity. "
                    },
                    {
                        "username": "Akash221991",
                        "content": "\\nkeyCountMap: This hash map is used to store the counts associated with each key. \\nFor example, if you have a key \"hello\" with a count of 3, the keyCountMap would have an entry like (\"hello\", 3).\\nThis map is used to efficiently update and access the counts of individual keys when performing the inc and dec operations. It allows you to quickly determine the current count of a key in O(1) time.\\n\\ncountKeyMap: This hash map is used to maintain a collection of keys for each count value. For instance, if you have multiple keys with a count of 3, the countKeyMap would have an entry like (3, {\"key1\", \"key2\", \"key3\"}).\\n\\nThis map is important for implementing the getMaxKey and getMinKey operations efficiently. Instead of searching through all keys to find the maximum and minimum counts, you can directly access the keys associated with the maximum and minimum counts in O(1) time."
                    },
                    {
                        "username": "StefanelStan",
                        "content": "A simple \"hard\" problem that requires some concentration.\\n1. Use a HashMap<String, Integer> to keep track of the count of each String\\n2. Use a TreeMap<Integer, Set<String>> to keep track of the buckets of each count to return the min/max.\\n3. As enhancement, you don\\'t really need to store a Set<String> in the 2nd map, but a Node(String, next, previous) of a manual doubly linked list. Each time you move buckets, you disconnect the nodes from old bucket and connect to the new bucket."
                    }
                ]
            },
            {
                "id": 1983437,
                "content": [
                    {
                        "username": "ajak6",
                        "content": "What does the following mean? Increment a string by 1 (integer)?\\n>increments an existing key by 1\\n\\nI think it means the value of the key : can be clearly written in the question."
                    },
                    {
                        "username": "rishihho",
                        "content": "O(1) makes no sense"
                    },
                    {
                        "username": "skywalker94",
                        "content": "It\\'s hard but possible to get O(1) time complexity (some operation may have to be amortized O(1))!"
                    },
                    {
                        "username": "mang11",
                        "content": "Can some one explain to me how you can write the solution to this problem in 35 mins in the interview? If you get asked this question, I just interpret as the interviewer not wanting to hire you."
                    },
                    {
                        "username": "StefanelStan",
                        "content": "It is very intuitive to use HashMap<String, Integer> to count the string AND a TreeMap<Integer, Set<String>> to hold the strings grouped by their count. With each inc/dec you increment/decrement the count from first map and move the string across buckets from the 2nd map."
                    },
                    {
                        "username": "Django_Developer",
                        "content": "This one is very similar to LRU Cache Problem"
                    },
                    {
                        "username": "sarathecoder",
                        "content": "why not just use orderedDict in python? It supports dict + linkedlist functions .\\nWe also use orderedDict for the LRU cache problem, so why not here?"
                    },
                    {
                        "username": "skywalker94",
                        "content": "The issue is that you\\'re supposed to do each operation in O(1). orderedDict uses a binary search tree implementation, and has O(logn) time complexity"
                    },
                    {
                        "username": "kesarwaniankit48",
                        "content": "Can there be a scenario where conflict is possible? Say for below example wherein at the end the count for both hello and leet will be same, what will be the min and max key output? Correct me if I am missing something.\\n\\n[\"AllOne\", \"inc\", \"inc\", \"getMaxKey\", \"getMinKey\", \"inc\", \"getMaxKey\", \"getMinKey\",\"dec\",\"getMaxKey\", \"getMinKey\"]\\n[[], [\"hello\"], [\"hello\"], [], [], [\"leet\"], [], [], [\"hello\"],[],[]]"
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "How is this hard? This is basic hash mapping. I don\\'t get why people find this difficult, and not DP questions where I die.\\n\\nOne hash map to count the key, one hash map to map the count back to the key. Update and delete keys from both hash maps as needed. Everything is O(1).\\n\\nAm I missing some requirement? I don\\'t see the description mentioning anything about not using hash maps."
                    },
                    {
                        "username": "KeshavJha2002",
                        "content": "Well you are expected to design a data structure... not use some already existing ones"
                    },
                    {
                        "username": "Baymurat",
                        "content": "How it can be \"Everything is O(1)\"? Let\\'s assume we did 100 \"inc\" and now we have in first map (mapKeyToCount) 100 keys with value 1 each of them and in the second map (mapCountToKey) 1 key with value of List with length of 100 elements. Now we do next \"inc\" of existing element, it means we have to find it in mapCountToKey and remove. And it\\'s O(N). Isn\\'t it so?!"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Lol big relate on the \"DP questions where i die\" part. "
                    },
                    {
                        "username": "a74705745",
                        "content": "There are many solution that use \"Doubly Linked List\" and they use Linear Search for find specific node, I think it is not match condition that is described by Problem \"  Note that each function must run in O(1) average time complexity \". Because Linear Search cost O(n) time complexity. "
                    },
                    {
                        "username": "Akash221991",
                        "content": "\\nkeyCountMap: This hash map is used to store the counts associated with each key. \\nFor example, if you have a key \"hello\" with a count of 3, the keyCountMap would have an entry like (\"hello\", 3).\\nThis map is used to efficiently update and access the counts of individual keys when performing the inc and dec operations. It allows you to quickly determine the current count of a key in O(1) time.\\n\\ncountKeyMap: This hash map is used to maintain a collection of keys for each count value. For instance, if you have multiple keys with a count of 3, the countKeyMap would have an entry like (3, {\"key1\", \"key2\", \"key3\"}).\\n\\nThis map is important for implementing the getMaxKey and getMinKey operations efficiently. Instead of searching through all keys to find the maximum and minimum counts, you can directly access the keys associated with the maximum and minimum counts in O(1) time."
                    },
                    {
                        "username": "StefanelStan",
                        "content": "A simple \"hard\" problem that requires some concentration.\\n1. Use a HashMap<String, Integer> to keep track of the count of each String\\n2. Use a TreeMap<Integer, Set<String>> to keep track of the buckets of each count to return the min/max.\\n3. As enhancement, you don\\'t really need to store a Set<String> in the 2nd map, but a Node(String, next, previous) of a manual doubly linked list. Each time you move buckets, you disconnect the nodes from old bucket and connect to the new bucket."
                    }
                ]
            },
            {
                "id": 2047822,
                "content": [
                    {
                        "username": "ajak6",
                        "content": "What does the following mean? Increment a string by 1 (integer)?\\n>increments an existing key by 1\\n\\nI think it means the value of the key : can be clearly written in the question."
                    },
                    {
                        "username": "rishihho",
                        "content": "O(1) makes no sense"
                    },
                    {
                        "username": "skywalker94",
                        "content": "It\\'s hard but possible to get O(1) time complexity (some operation may have to be amortized O(1))!"
                    },
                    {
                        "username": "mang11",
                        "content": "Can some one explain to me how you can write the solution to this problem in 35 mins in the interview? If you get asked this question, I just interpret as the interviewer not wanting to hire you."
                    },
                    {
                        "username": "StefanelStan",
                        "content": "It is very intuitive to use HashMap<String, Integer> to count the string AND a TreeMap<Integer, Set<String>> to hold the strings grouped by their count. With each inc/dec you increment/decrement the count from first map and move the string across buckets from the 2nd map."
                    },
                    {
                        "username": "Django_Developer",
                        "content": "This one is very similar to LRU Cache Problem"
                    },
                    {
                        "username": "sarathecoder",
                        "content": "why not just use orderedDict in python? It supports dict + linkedlist functions .\\nWe also use orderedDict for the LRU cache problem, so why not here?"
                    },
                    {
                        "username": "skywalker94",
                        "content": "The issue is that you\\'re supposed to do each operation in O(1). orderedDict uses a binary search tree implementation, and has O(logn) time complexity"
                    },
                    {
                        "username": "kesarwaniankit48",
                        "content": "Can there be a scenario where conflict is possible? Say for below example wherein at the end the count for both hello and leet will be same, what will be the min and max key output? Correct me if I am missing something.\\n\\n[\"AllOne\", \"inc\", \"inc\", \"getMaxKey\", \"getMinKey\", \"inc\", \"getMaxKey\", \"getMinKey\",\"dec\",\"getMaxKey\", \"getMinKey\"]\\n[[], [\"hello\"], [\"hello\"], [], [], [\"leet\"], [], [], [\"hello\"],[],[]]"
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "How is this hard? This is basic hash mapping. I don\\'t get why people find this difficult, and not DP questions where I die.\\n\\nOne hash map to count the key, one hash map to map the count back to the key. Update and delete keys from both hash maps as needed. Everything is O(1).\\n\\nAm I missing some requirement? I don\\'t see the description mentioning anything about not using hash maps."
                    },
                    {
                        "username": "KeshavJha2002",
                        "content": "Well you are expected to design a data structure... not use some already existing ones"
                    },
                    {
                        "username": "Baymurat",
                        "content": "How it can be \"Everything is O(1)\"? Let\\'s assume we did 100 \"inc\" and now we have in first map (mapKeyToCount) 100 keys with value 1 each of them and in the second map (mapCountToKey) 1 key with value of List with length of 100 elements. Now we do next \"inc\" of existing element, it means we have to find it in mapCountToKey and remove. And it\\'s O(N). Isn\\'t it so?!"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Lol big relate on the \"DP questions where i die\" part. "
                    },
                    {
                        "username": "a74705745",
                        "content": "There are many solution that use \"Doubly Linked List\" and they use Linear Search for find specific node, I think it is not match condition that is described by Problem \"  Note that each function must run in O(1) average time complexity \". Because Linear Search cost O(n) time complexity. "
                    },
                    {
                        "username": "Akash221991",
                        "content": "\\nkeyCountMap: This hash map is used to store the counts associated with each key. \\nFor example, if you have a key \"hello\" with a count of 3, the keyCountMap would have an entry like (\"hello\", 3).\\nThis map is used to efficiently update and access the counts of individual keys when performing the inc and dec operations. It allows you to quickly determine the current count of a key in O(1) time.\\n\\ncountKeyMap: This hash map is used to maintain a collection of keys for each count value. For instance, if you have multiple keys with a count of 3, the countKeyMap would have an entry like (3, {\"key1\", \"key2\", \"key3\"}).\\n\\nThis map is important for implementing the getMaxKey and getMinKey operations efficiently. Instead of searching through all keys to find the maximum and minimum counts, you can directly access the keys associated with the maximum and minimum counts in O(1) time."
                    },
                    {
                        "username": "StefanelStan",
                        "content": "A simple \"hard\" problem that requires some concentration.\\n1. Use a HashMap<String, Integer> to keep track of the count of each String\\n2. Use a TreeMap<Integer, Set<String>> to keep track of the buckets of each count to return the min/max.\\n3. As enhancement, you don\\'t really need to store a Set<String> in the 2nd map, but a Node(String, next, previous) of a manual doubly linked list. Each time you move buckets, you disconnect the nodes from old bucket and connect to the new bucket."
                    }
                ]
            },
            {
                "id": 2023264,
                "content": [
                    {
                        "username": "ajak6",
                        "content": "What does the following mean? Increment a string by 1 (integer)?\\n>increments an existing key by 1\\n\\nI think it means the value of the key : can be clearly written in the question."
                    },
                    {
                        "username": "rishihho",
                        "content": "O(1) makes no sense"
                    },
                    {
                        "username": "skywalker94",
                        "content": "It\\'s hard but possible to get O(1) time complexity (some operation may have to be amortized O(1))!"
                    },
                    {
                        "username": "mang11",
                        "content": "Can some one explain to me how you can write the solution to this problem in 35 mins in the interview? If you get asked this question, I just interpret as the interviewer not wanting to hire you."
                    },
                    {
                        "username": "StefanelStan",
                        "content": "It is very intuitive to use HashMap<String, Integer> to count the string AND a TreeMap<Integer, Set<String>> to hold the strings grouped by their count. With each inc/dec you increment/decrement the count from first map and move the string across buckets from the 2nd map."
                    },
                    {
                        "username": "Django_Developer",
                        "content": "This one is very similar to LRU Cache Problem"
                    },
                    {
                        "username": "sarathecoder",
                        "content": "why not just use orderedDict in python? It supports dict + linkedlist functions .\\nWe also use orderedDict for the LRU cache problem, so why not here?"
                    },
                    {
                        "username": "skywalker94",
                        "content": "The issue is that you\\'re supposed to do each operation in O(1). orderedDict uses a binary search tree implementation, and has O(logn) time complexity"
                    },
                    {
                        "username": "kesarwaniankit48",
                        "content": "Can there be a scenario where conflict is possible? Say for below example wherein at the end the count for both hello and leet will be same, what will be the min and max key output? Correct me if I am missing something.\\n\\n[\"AllOne\", \"inc\", \"inc\", \"getMaxKey\", \"getMinKey\", \"inc\", \"getMaxKey\", \"getMinKey\",\"dec\",\"getMaxKey\", \"getMinKey\"]\\n[[], [\"hello\"], [\"hello\"], [], [], [\"leet\"], [], [], [\"hello\"],[],[]]"
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "How is this hard? This is basic hash mapping. I don\\'t get why people find this difficult, and not DP questions where I die.\\n\\nOne hash map to count the key, one hash map to map the count back to the key. Update and delete keys from both hash maps as needed. Everything is O(1).\\n\\nAm I missing some requirement? I don\\'t see the description mentioning anything about not using hash maps."
                    },
                    {
                        "username": "KeshavJha2002",
                        "content": "Well you are expected to design a data structure... not use some already existing ones"
                    },
                    {
                        "username": "Baymurat",
                        "content": "How it can be \"Everything is O(1)\"? Let\\'s assume we did 100 \"inc\" and now we have in first map (mapKeyToCount) 100 keys with value 1 each of them and in the second map (mapCountToKey) 1 key with value of List with length of 100 elements. Now we do next \"inc\" of existing element, it means we have to find it in mapCountToKey and remove. And it\\'s O(N). Isn\\'t it so?!"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Lol big relate on the \"DP questions where i die\" part. "
                    },
                    {
                        "username": "a74705745",
                        "content": "There are many solution that use \"Doubly Linked List\" and they use Linear Search for find specific node, I think it is not match condition that is described by Problem \"  Note that each function must run in O(1) average time complexity \". Because Linear Search cost O(n) time complexity. "
                    },
                    {
                        "username": "Akash221991",
                        "content": "\\nkeyCountMap: This hash map is used to store the counts associated with each key. \\nFor example, if you have a key \"hello\" with a count of 3, the keyCountMap would have an entry like (\"hello\", 3).\\nThis map is used to efficiently update and access the counts of individual keys when performing the inc and dec operations. It allows you to quickly determine the current count of a key in O(1) time.\\n\\ncountKeyMap: This hash map is used to maintain a collection of keys for each count value. For instance, if you have multiple keys with a count of 3, the countKeyMap would have an entry like (3, {\"key1\", \"key2\", \"key3\"}).\\n\\nThis map is important for implementing the getMaxKey and getMinKey operations efficiently. Instead of searching through all keys to find the maximum and minimum counts, you can directly access the keys associated with the maximum and minimum counts in O(1) time."
                    },
                    {
                        "username": "StefanelStan",
                        "content": "A simple \"hard\" problem that requires some concentration.\\n1. Use a HashMap<String, Integer> to keep track of the count of each String\\n2. Use a TreeMap<Integer, Set<String>> to keep track of the buckets of each count to return the min/max.\\n3. As enhancement, you don\\'t really need to store a Set<String> in the 2nd map, but a Node(String, next, previous) of a manual doubly linked list. Each time you move buckets, you disconnect the nodes from old bucket and connect to the new bucket."
                    }
                ]
            },
            {
                "id": 2019676,
                "content": [
                    {
                        "username": "ajak6",
                        "content": "What does the following mean? Increment a string by 1 (integer)?\\n>increments an existing key by 1\\n\\nI think it means the value of the key : can be clearly written in the question."
                    },
                    {
                        "username": "rishihho",
                        "content": "O(1) makes no sense"
                    },
                    {
                        "username": "skywalker94",
                        "content": "It\\'s hard but possible to get O(1) time complexity (some operation may have to be amortized O(1))!"
                    },
                    {
                        "username": "mang11",
                        "content": "Can some one explain to me how you can write the solution to this problem in 35 mins in the interview? If you get asked this question, I just interpret as the interviewer not wanting to hire you."
                    },
                    {
                        "username": "StefanelStan",
                        "content": "It is very intuitive to use HashMap<String, Integer> to count the string AND a TreeMap<Integer, Set<String>> to hold the strings grouped by their count. With each inc/dec you increment/decrement the count from first map and move the string across buckets from the 2nd map."
                    },
                    {
                        "username": "Django_Developer",
                        "content": "This one is very similar to LRU Cache Problem"
                    },
                    {
                        "username": "sarathecoder",
                        "content": "why not just use orderedDict in python? It supports dict + linkedlist functions .\\nWe also use orderedDict for the LRU cache problem, so why not here?"
                    },
                    {
                        "username": "skywalker94",
                        "content": "The issue is that you\\'re supposed to do each operation in O(1). orderedDict uses a binary search tree implementation, and has O(logn) time complexity"
                    },
                    {
                        "username": "kesarwaniankit48",
                        "content": "Can there be a scenario where conflict is possible? Say for below example wherein at the end the count for both hello and leet will be same, what will be the min and max key output? Correct me if I am missing something.\\n\\n[\"AllOne\", \"inc\", \"inc\", \"getMaxKey\", \"getMinKey\", \"inc\", \"getMaxKey\", \"getMinKey\",\"dec\",\"getMaxKey\", \"getMinKey\"]\\n[[], [\"hello\"], [\"hello\"], [], [], [\"leet\"], [], [], [\"hello\"],[],[]]"
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "How is this hard? This is basic hash mapping. I don\\'t get why people find this difficult, and not DP questions where I die.\\n\\nOne hash map to count the key, one hash map to map the count back to the key. Update and delete keys from both hash maps as needed. Everything is O(1).\\n\\nAm I missing some requirement? I don\\'t see the description mentioning anything about not using hash maps."
                    },
                    {
                        "username": "KeshavJha2002",
                        "content": "Well you are expected to design a data structure... not use some already existing ones"
                    },
                    {
                        "username": "Baymurat",
                        "content": "How it can be \"Everything is O(1)\"? Let\\'s assume we did 100 \"inc\" and now we have in first map (mapKeyToCount) 100 keys with value 1 each of them and in the second map (mapCountToKey) 1 key with value of List with length of 100 elements. Now we do next \"inc\" of existing element, it means we have to find it in mapCountToKey and remove. And it\\'s O(N). Isn\\'t it so?!"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Lol big relate on the \"DP questions where i die\" part. "
                    },
                    {
                        "username": "a74705745",
                        "content": "There are many solution that use \"Doubly Linked List\" and they use Linear Search for find specific node, I think it is not match condition that is described by Problem \"  Note that each function must run in O(1) average time complexity \". Because Linear Search cost O(n) time complexity. "
                    },
                    {
                        "username": "Akash221991",
                        "content": "\\nkeyCountMap: This hash map is used to store the counts associated with each key. \\nFor example, if you have a key \"hello\" with a count of 3, the keyCountMap would have an entry like (\"hello\", 3).\\nThis map is used to efficiently update and access the counts of individual keys when performing the inc and dec operations. It allows you to quickly determine the current count of a key in O(1) time.\\n\\ncountKeyMap: This hash map is used to maintain a collection of keys for each count value. For instance, if you have multiple keys with a count of 3, the countKeyMap would have an entry like (3, {\"key1\", \"key2\", \"key3\"}).\\n\\nThis map is important for implementing the getMaxKey and getMinKey operations efficiently. Instead of searching through all keys to find the maximum and minimum counts, you can directly access the keys associated with the maximum and minimum counts in O(1) time."
                    },
                    {
                        "username": "StefanelStan",
                        "content": "A simple \"hard\" problem that requires some concentration.\\n1. Use a HashMap<String, Integer> to keep track of the count of each String\\n2. Use a TreeMap<Integer, Set<String>> to keep track of the buckets of each count to return the min/max.\\n3. As enhancement, you don\\'t really need to store a Set<String> in the 2nd map, but a Node(String, next, previous) of a manual doubly linked list. Each time you move buckets, you disconnect the nodes from old bucket and connect to the new bucket."
                    }
                ]
            }
        ]
    }
]