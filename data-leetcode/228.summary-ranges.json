[
    {
        "title": "Find the Index of the First Occurrence in a String",
        "question_content": "Given two strings needle and haystack, return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.\n&nbsp;\nExample 1:\n\nInput: haystack = \"sadbutsad\", needle = \"sad\"\nOutput: 0\nExplanation: \"sad\" occurs at index 0 and 6.\nThe first occurrence is at index 0, so we return 0.\n\nExample 2:\n\nInput: haystack = \"leetcode\", needle = \"leeto\"\nOutput: -1\nExplanation: \"leeto\" did not occur in \"leetcode\", so we return -1.\n\n&nbsp;\nConstraints:\n\n\t1 <= haystack.length, needle.length <= 104\n\thaystack and needle consist of only lowercase English characters.",
        "solutions": [
            {
                "id": 12807,
                "title": "elegant-java-solution",
                "content": "    public int strStr(String haystack, String needle) {\\n      for (int i = 0; ; i++) {\\n        for (int j = 0; ; j++) {\\n          if (j == needle.length()) return i;\\n          if (i + j == haystack.length()) return -1;\\n          if (needle.charAt(j) != haystack.charAt(i + j)) break;\\n        }\\n      }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public int strStr(String haystack, String needle) {\\n      for (int i = 0; ; i++) {\\n        for (int j = 0; ; j++) {\\n          if (j == needle.length()) return i;\\n          if (i + j == haystack.length()) return -1;\\n          if (needle.charAt(j) != haystack.charAt(i + j)) break;\\n        }\\n      }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 12956,
                "title": "c-brute-force-and-kmp",
                "content": "Traverse all the possible starting points of `haystack` (from `0` to `haystack.length() - needle.length()`) and see if the following characters in `haystack` match those of `needle`.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        int m = haystack.size(), n = needle.size();\\n        for (int i = 0; i <= m - n; i++) {\\n            int j = 0;\\n            for (; j < n; j++) {\\n                if (haystack[i + j] != needle[j]) {\\n                    break;\\n                }\\n            }\\n            if (j == n) {\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\\n\\nThe following is another implementation, shorter but harder to understand.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        int m = haystack.size(), n = needle.size(), p = 0;\\n        while (p + n - 1 < m) {\\n            if (haystack.substr(p, n) == needle) {\\n                return p;\\n            }\\n            while (p++ + n - 1 < m && haystack[p] != needle[0]);\\n        }\\n        return -1;\\n    }\\n};\\n```\\n\\nFinally comes the KMP algorithm. You may refer to [KMP on jBoxer\\'s blog](http://jakeboxer.com/blog/2009/12/13/the-knuth-morris-pratt-algorithm-in-my-own-words/) and [KMP on geeksforgeeks](http://www.geeksforgeeks.org/searching-for-patterns-set-2-kmp-algorithm/) for some explanations. I rewrote the code from the second link.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        int m = haystack.size(), n = needle.size();\\n        if (!n) {\\n            return 0;\\n        }\\n        vector<int> lps = kmpProcess(needle);\\n        for (int i = 0, j = 0; i < m;) {\\n            if (haystack[i] == needle[j]) { \\n                i++, j++;\\n            }\\n            if (j == n) {\\n                return i - j;\\n            }\\n            if (i < m && haystack[i] != needle[j]) {\\n                j ? j = lps[j - 1] : i++;\\n            }\\n        }\\n        return -1;\\n    }\\nprivate:\\n    vector<int> kmpProcess(string needle) {\\n        int n = needle.size();\\n        vector<int> lps(n, 0);\\n        for (int i = 1, len = 0; i < n;) {\\n            if (needle[i] == needle[len]) {\\n                lps[i++] = ++len;\\n            } else if (len) {\\n                len = lps[len - 1];\\n            } else {\\n                lps[i++] = 0;\\n            }\\n        }\\n        return lps;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        int m = haystack.size(), n = needle.size();\\n        for (int i = 0; i <= m - n; i++) {\\n            int j = 0;\\n            for (; j < n; j++) {\\n                if (haystack[i + j] != needle[j]) {\\n                    break;\\n                }\\n            }\\n            if (j == n) {\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        int m = haystack.size(), n = needle.size(), p = 0;\\n        while (p + n - 1 < m) {\\n            if (haystack.substr(p, n) == needle) {\\n                return p;\\n            }\\n            while (p++ + n - 1 < m && haystack[p] != needle[0]);\\n        }\\n        return -1;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        int m = haystack.size(), n = needle.size();\\n        if (!n) {\\n            return 0;\\n        }\\n        vector<int> lps = kmpProcess(needle);\\n        for (int i = 0, j = 0; i < m;) {\\n            if (haystack[i] == needle[j]) { \\n                i++, j++;\\n            }\\n            if (j == n) {\\n                return i - j;\\n            }\\n            if (i < m && haystack[i] != needle[j]) {\\n                j ? j = lps[j - 1] : i++;\\n            }\\n        }\\n        return -1;\\n    }\\nprivate:\\n    vector<int> kmpProcess(string needle) {\\n        int n = needle.size();\\n        vector<int> lps(n, 0);\\n        for (int i = 1, len = 0; i < n;) {\\n            if (needle[i] == needle[len]) {\\n                lps[i++] = ++len;\\n            } else if (len) {\\n                len = lps[len - 1];\\n            } else {\\n                lps[i++] = 0;\\n            }\\n        }\\n        return lps;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3249783,
                "title": "java-easy-with-explanation",
                "content": "**If we observe a bit the number of substrings of size needle length is length of haystack minus length of needle+1 so using two pointer we just used a for loop till (length of haystack-length of needle) and then checked if the character in needle is equal to character of haystack. If its equal we just kept on incrementing j. If the j is equal to needle length then we found our first substring that is equal to needle and we return the index of first character of that substring. If we dont find the substring in the haystack then we simply return -1.**\\n```\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n        int haylength=haystack.length();\\n        int needlelength=needle.length();\\n        if(haylength<needlelength)\\n            return -1;\\n        for(int i=0;i<=haystack.length()-needle.length();i++){\\n            int j=0;\\n            while(j<needle.length() && haystack.charAt(i+j)==needle.charAt(j))\\n                j++;\\n            if(j==needle.length()){\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```\\n![image](https://assets.leetcode.com/users/images/f9e51783-3660-4252-933c-ec2c42b2d57d_1677809905.0379472.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n        int haylength=haystack.length();\\n        int needlelength=needle.length();\\n        if(haylength<needlelength)\\n            return -1;\\n        for(int i=0;i<=haystack.length()-needle.length();i++){\\n            int j=0;\\n            while(j<needle.length() && haystack.charAt(i+j)==needle.charAt(j))\\n                j++;\\n            if(j==needle.length()){\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3250360,
                "title": "think-as-a-sliding-window-code-like-a-pro-beats-100",
                "content": "# Approach\\n**I can solve it using substrings. But can I do it without using substrings? Just by iterating the loop manually?**\\nThis thinking introduced me to use some kind of sliding window approach.\\nWhen, the characters are equal, increase the window. When they are not, reinitialize the window from the immediate next index of the previous window\\'s start.\\n\\n`haystack = \"mississippi\", needle = \"issip\"`\\n\\nThe window matching will start from first \"i\". Then it will proceed.\\nMatching:\\n```\\n-> m\\n-> i\\nnot match, reinitialize window start to next index of m. \\nThat is \"i\" from the word \"mississipi\"\\n\\n-> i s s i s\\n-> i s s i p\\ns and p mismatch\\n\\nso, reinitialize the window\\'s start\\n-> s\\n-> i\\nnot match\\n\\nreinitialize\\n-> s\\n-> i\\nnot match\\n\\nreinitialize\\n-> i s s i p\\n-> i s s i p\\nthis time it was a match!\\n```\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(N*M)$$\\nN is the length of haystack, M is the length of needle. In worst case, the `haystack.charAt(i)==needle.charAt(nIndex)` comparison runs for **M-1** times. Where the last character of the **needle** mismatch.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\nWell, guess what! We haven\\'t performed `substring.equals()` or any other operation. The space complexity is really good in a sense.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code \\n\\n``` java []\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n        int hLen = haystack.length();\\n        int nLen = needle.length();\\n        int nIndex = 0;\\n        for(int i=0; i<hLen; i++){\\n            // as long as the characters are equal, increment needleIndex\\n            if(haystack.charAt(i)==needle.charAt(nIndex)){\\n                nIndex++;\\n            }\\n            else{\\n                // start from the next index of previous start index\\n                i=i-nIndex;\\n                // needle should start from index 0\\n                nIndex=0;\\n            }\\n            // check if needleIndex reached needle length\\n            if(nIndex==nLen){\\n                // return the first index\\n                return i-nLen+1;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```\\n``` C++ []\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        int hLen = haystack.length();\\n        int nLen = needle.length();\\n        int nIndex = 0;\\n        for(int i=0; i<hLen; i++){\\n            // as long as the characters are equal, increment needleIndex\\n            if(haystack[i]==needle[nIndex]){\\n                nIndex++;\\n            }\\n            else{\\n                // start from the next index of previous start index\\n                i=i-nIndex;\\n                // needle should start from index 0\\n                nIndex=0;\\n            }\\n            // check if needleIndex reached needle length\\n            if(nIndex==nLen){\\n                // return the first index\\n                return i-nLen+1;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\\n\\n![image.png](https://assets.leetcode.com/users/images/80f4636f-20d1-49a8-9ae1-06e036003183_1677820370.907445.png)\\n\\n\\n![No Upvotes, Have a Good Day.png](https://assets.leetcode.com/users/images/e9d15172-c989-4baa-b2e0-d92379f925b5_1677818866.229168.png)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n-> m\\n-> i\\nnot match, reinitialize window start to next index of m. \\nThat is \"i\" from the word \"mississipi\"\\n\\n-> i s s i s\\n-> i s s i p\\ns and p mismatch\\n\\nso, reinitialize the window\\'s start\\n-> s\\n-> i\\nnot match\\n\\nreinitialize\\n-> s\\n-> i\\nnot match\\n\\nreinitialize\\n-> i s s i p\\n-> i s s i p\\nthis time it was a match!\\n```\n``` java []\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n        int hLen = haystack.length();\\n        int nLen = needle.length();\\n        int nIndex = 0;\\n        for(int i=0; i<hLen; i++){\\n            // as long as the characters are equal, increment needleIndex\\n            if(haystack.charAt(i)==needle.charAt(nIndex)){\\n                nIndex++;\\n            }\\n            else{\\n                // start from the next index of previous start index\\n                i=i-nIndex;\\n                // needle should start from index 0\\n                nIndex=0;\\n            }\\n            // check if needleIndex reached needle length\\n            if(nIndex==nLen){\\n                // return the first index\\n                return i-nLen+1;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```\n``` C++ []\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        int hLen = haystack.length();\\n        int nLen = needle.length();\\n        int nIndex = 0;\\n        for(int i=0; i<hLen; i++){\\n            // as long as the characters are equal, increment needleIndex\\n            if(haystack[i]==needle[nIndex]){\\n                nIndex++;\\n            }\\n            else{\\n                // start from the next index of previous start index\\n                i=i-nIndex;\\n                // needle should start from index 0\\n                nIndex=0;\\n            }\\n            // check if needleIndex reached needle length\\n            if(nIndex==nLen){\\n                // return the first index\\n                return i-nLen+1;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 12814,
                "title": "my-answer-by-python",
                "content": "    class Solution(object):\\n    def strStr(self, haystack, needle):\\n        \"\"\"\\n        :type haystack: str\\n        :type needle: str\\n        :rtype: int\\n        \"\"\"\\n        for i in range(len(haystack) - len(needle)+1):\\n            if haystack[i:i+len(needle)] == needle:\\n                return i\\n        return -1",
                "solutionTags": [],
                "code": "    class Solution(object):\\n    def strStr(self, haystack, needle):\\n        \"\"\"\\n        :type haystack: str\\n        :type needle: str\\n        :rtype: int\\n        \"\"\"\\n        for i in range(len(haystack) - len(needle)+1):\\n            if haystack[i:i+len(needle)] == needle:\\n                return i\\n        return -1",
                "codeTag": "Java"
            },
            {
                "id": 12811,
                "title": "share-my-accepted-java-solution",
                "content": "    public class Solution {\\n        public int strStr(String haystack, String needle) {\\n            int l1 = haystack.length(), l2 = needle.length();\\n            if (l1 < l2) {\\n                return -1;\\n            } else if (l2 == 0) {\\n                return 0;\\n            }\\n            int threshold = l1 - l2;\\n            for (int i = 0; i <= threshold; ++i) {\\n                if (haystack.substring(i,i+l2).equals(needle)) {\\n                    return i;\\n                }\\n            }\\n            return -1;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public int strStr(String haystack, String needle) {\\n            int l1 = haystack.length(), l2 = needle.length();\\n            if (l1 < l2) {\\n                return -1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 13024,
                "title": "o-m-n-and-o-mn-solutions",
                "content": "**Solution 1: O(m+n) KMP pattern matching**\\n```\\n public int strStr(String haystack, String needle) {\\n        if(haystack == null || needle == null || needle.length() > haystack.length()) return -1;\\n        \\n        int[] parr = kmpPreprocess(needle);\\n        int i = 0, j = 0;\\n        while(i < haystack.length() && j < needle.length()) {\\n            if(haystack.charAt(i) == needle.charAt(j)) {\\n                i++; j++;\\n            } else if(j > 0) {\\n                j = parr[j - 1];\\n            } else {\\n                i++;\\n            }\\n        }\\n        return j == needle.length() ? i - j : -1;\\n    }\\n\\n    private int[] kmpPreprocess(String pattern) {\\n        int i = 1, j = 0;\\n        int[] res = new int[pattern.length()];\\n        while(i < pattern.length()) {\\n            if(pattern.charAt(i) == pattern.charAt(j)) {\\n                res[i] = j+1;\\n                i++; j++;\\n            } else if (j > 0) {\\n                j = res[j-1];\\n            } else {\\n                res[i] = 0;\\n                i++;\\n            }\\n        }\\n        return res;\\n    }\\n```\\n\\n* If you want to understand KMP, watch the [video](https://www.youtube.com/watch?v=GTJr8OvyEVQ).\\n\\n* KMP finds the pattern in a most efficient way. If the use cases require running multiple patterns then [Rabin Karp](https://www.youtube.com/watch?v=H4VrKHVG5qI) algorithm may be useful.\\n\\n**Solution 2: O(mn) Brute Force**\\n\\n```\\n public int strStr(String haystack, String needle) {\\n        if(haystack == null || needle == null || needle.length() > haystack.length()) return -1;\\n\\n        int len = haystack.length(), i = 0, j = 0, pos = 0;\\n        while(i < len && j < needle.length()) {\\n            if(haystack.charAt(i++) == needle.charAt(j)) {\\n                j++;\\n            } else {\\n                i = i - j;\\n                j = 0;\\n                pos = i;\\n            }\\n        }\\n        return j == needle.length()? pos : -1;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n public int strStr(String haystack, String needle) {\\n        if(haystack == null || needle == null || needle.length() > haystack.length()) return -1;\\n        \\n        int[] parr = kmpPreprocess(needle);\\n        int i = 0, j = 0;\\n        while(i < haystack.length() && j < needle.length()) {\\n            if(haystack.charAt(i) == needle.charAt(j)) {\\n                i++; j++;\\n            } else if(j > 0) {\\n                j = parr[j - 1];\\n            } else {\\n                i++;\\n            }\\n        }\\n        return j == needle.length() ? i - j : -1;\\n    }\\n\\n    private int[] kmpPreprocess(String pattern) {\\n        int i = 1, j = 0;\\n        int[] res = new int[pattern.length()];\\n        while(i < pattern.length()) {\\n            if(pattern.charAt(i) == pattern.charAt(j)) {\\n                res[i] = j+1;\\n                i++; j++;\\n            } else if (j > 0) {\\n                j = res[j-1];\\n            } else {\\n                res[i] = 0;\\n                i++;\\n            }\\n        }\\n        return res;\\n    }\\n```\n```\\n public int strStr(String haystack, String needle) {\\n        if(haystack == null || needle == null || needle.length() > haystack.length()) return -1;\\n\\n        int len = haystack.length(), i = 0, j = 0, pos = 0;\\n        while(i < len && j < needle.length()) {\\n            if(haystack.charAt(i++) == needle.charAt(j)) {\\n                j++;\\n            } else {\\n                i = i - j;\\n                j = 0;\\n                pos = i;\\n            }\\n        }\\n        return j == needle.length()? pos : -1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 535326,
                "title": "java-python-kmp-solution-o-m-n-clean-code",
                "content": "**Compute KMP Table:** LPS which is Longest Prefix also Suffix\\nExample 1:\\n![image.png](https://assets.leetcode.com/users/images/971cb45f-661e-43b3-a55c-209f465baff9_1689541412.9111822.png)\\n\\n\\nExample 2:\\n![image](https://assets.leetcode.com/users/images/cae657d7-9566-43e2-9ebd-dc45fad3864e_1624351502.9443958.png)\\n\\n\\n<iframe src=\"https://leetcode.com/playground/MYVTzF4h/shared\" frameBorder=\"0\" width=\"100%\" height=\"550\"></iframe>\\n\\nComplexity:\\n- Time: `O(m+n)`, where `m` is needle.length, `n` is haystack.length\\n- Space: `O(m)`\\n\\nMore detail about KMP: https://en.wikipedia.org/wiki/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm",
                "solutionTags": [
                    "String Matching"
                ],
                "code": "**Compute KMP Table:** LPS which is Longest Prefix also Suffix\\nExample 1:\\n![image.png](https://assets.leetcode.com/users/images/971cb45f-661e-43b3-a55c-209f465baff9_1689541412.9111822.png)\\n\\n\\nExample 2:\\n![image](https://assets.leetcode.com/users/images/cae657d7-9566-43e2-9ebd-dc45fad3864e_1624351502.9443958.png)\\n\\n\\n<iframe src=\"https://leetcode.com/playground/MYVTzF4h/shared\" frameBorder=\"0\" width=\"100%\" height=\"550\"></iframe>\\n\\nComplexity:\\n- Time: `O(m+n)`, where `m` is needle.length, `n` is haystack.length\\n- Space: `O(m)`\\n\\nMore detail about KMP: https://en.wikipedia.org/wiki/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm",
                "codeTag": "Unknown"
            },
            {
                "id": 590911,
                "title": "javascript-solution-no-built-in-methods",
                "content": "I think the point of this exercise is to write your own algorithm without using any built-in methods. \\nThis is my take. The runtime is 52 ms (faster than 86.06%), and the memory usage is 35 MB (less than 57.14%).\\nIn contrast, ```return haystack.indexOf(needle);``` is faster than 86% and memory usage is less than 75%.\\n\\n```\\nconst strStr = (haystack, needle) => {\\n  if (needle === \\'\\' || needle === haystack) return 0;    // the only mandatory check here is (needle === \\'\\')\\n  if (haystack.length < needle.length) return -1;        // the other ones are for efficiency\\n  \\n  for (let i = 0; i < haystack.length - needle.length + 1; i++) {    // start looping through haystack until the remaining substring is shorter than needle\\n    if (haystack[i] === needle[0]) {                // as soon as we see a character that matches the first character of needle\\n      for (let j = 0; j < needle.length; j++) {     // start looping through both needle and haystack\\n        if (needle[j] !== haystack[i + j]) {        // as soon as the characters don\\'t match\\n          break;                                    // break out of the loop and return to looping through haystack\\n        } else if (j === needle.length - 1){        // otherwise, if we looped through the entire needle and all of the characters matched\\n          return i;                                 // return the index of the first character of haystack with which we started the loop\\n        }\\n      }\\n    }\\n  }\\n  \\n  return -1;                                        // return -1 if there wasn\\'t a match\\n};\\n```\\n\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```return haystack.indexOf(needle);```\n```\\nconst strStr = (haystack, needle) => {\\n  if (needle === \\'\\' || needle === haystack) return 0;    // the only mandatory check here is (needle === \\'\\')\\n  if (haystack.length < needle.length) return -1;        // the other ones are for efficiency\\n  \\n  for (let i = 0; i < haystack.length - needle.length + 1; i++) {    // start looping through haystack until the remaining substring is shorter than needle\\n    if (haystack[i] === needle[0]) {                // as soon as we see a character that matches the first character of needle\\n      for (let j = 0; j < needle.length; j++) {     // start looping through both needle and haystack\\n        if (needle[j] !== haystack[i + j]) {        // as soon as the characters don\\'t match\\n          break;                                    // break out of the loop and return to looping through haystack\\n        } else if (j === needle.length - 1){        // otherwise, if we looped through the entire needle and all of the characters matched\\n          return i;                                 // return the index of the first character of haystack with which we started the loop\\n        }\\n      }\\n    }\\n  }\\n  \\n  return -1;                                        // return -1 if there wasn\\'t a match\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 12931,
                "title": "a-very-clean-solution-brute-force",
                "content": "    int strStr(char *haystack, char *needle) {\\n            if (!haystack || !needle) return -1;\\n            for (int i = 0; ; ++i) {\\n                for (int j = 0; ; ++j) {\\n                    if (needle[j] == 0) return i;\\n                    if (haystack[i + j] == 0) return -1;\\n                    if (haystack[i + j] != needle[j]) break;\\n                }\\n            }\\n        }",
                "solutionTags": [],
                "code": "    int strStr(char *haystack, char *needle) {\\n            if (!haystack || !needle) return -1;\\n            for (int i = 0; ; ++i) {\\n                for (int j = 0; ; ++j) {\\n                    if (needle[j] == 0) return i;\\n                    if (haystack[i + j] == 0) return -1;\\n                    if (haystack[i + j] != needle[j]) break;\\n                }\\n            }\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 13255,
                "title": "python-56-ms-time-o-n-m-space-o-1",
                "content": "Do we need to really use KMP in the interview? I just had a few interviews but personally I really can not remember those fantastic algorithms in that short period of time in pressure. Maybe I was nervous and needed more programming practice..\\n\\n\\n    def strStr(self, haystack, needle):\\n        if needle == \"\":\\n            return 0\\n        for i in range(len(haystack)-len(needle)+1):\\n            for j in range(len(needle)):\\n                if haystack[i+j] != needle[j]:\\n                    break\\n                if j == len(needle)-1:\\n                    return i\\n        return -1",
                "solutionTags": [
                    "Python"
                ],
                "code": "Do we need to really use KMP in the interview? I just had a few interviews but personally I really can not remember those fantastic algorithms in that short period of time in pressure. Maybe I was nervous and needed more programming practice..\\n\\n\\n    def strStr(self, haystack, needle):\\n        if needle == \"\":\\n            return 0\\n        for i in range(len(haystack)-len(needle)+1):\\n            for j in range(len(needle)):\\n                if haystack[i+j] != needle[j]:\\n                    break\\n                if j == len(needle)-1:\\n                    return i\\n        return -1",
                "codeTag": "Python3"
            },
            {
                "id": 12883,
                "title": "kmp-in-c-explanation-included",
                "content": "    int strStr(string haystack, string needle) {\\n            int nsize = needle.size();\\n        \\tint hsize = haystack.size();\\n        \\tif (nsize == 0) return 0;\\n        \\tint *table = new int[nsize];\\n        \\tmemset(table, 0, sizeof(int)*nsize);\\n        \\t//building match table\\n        \\tfor (int i = 1, j = 0; i < nsize - 1;){\\n        \\t\\tif (needle[i] != needle[j]){\\n        \\t\\t\\tif (j>0){\\n        \\t\\t\\t\\tj = table[j - 1];\\n        \\t\\t\\t}\\n        \\t\\t\\telse{\\n        \\t\\t\\t\\ti++;\\n        \\t\\t\\t}\\n        \\t\\t}\\n        \\t\\telse{\\n        \\t\\t\\ttable[i] = j + 1;\\n        \\t\\t\\ti++;\\n        \\t\\t\\tj++;\\n        \\t\\t}\\n        \\t}\\n        \\t//matching\\n        \\tfor (int i = 0, match_pos = 0; i < hsize;){\\n        \\t\\tif (haystack[i] == needle[match_pos]){\\n        \\t\\t\\tif (match_pos == nsize - 1){\\n        \\t\\t\\t\\treturn i - (nsize - 1);\\n        \\t\\t\\t}\\n        \\t\\t\\telse{\\n        \\t\\t\\t\\ti++;\\n        \\t\\t\\t\\tmatch_pos++;\\n        \\t\\t\\t}\\n        \\t\\t}\\n        \\t\\telse{\\n        \\t\\t\\tif (match_pos == 0){\\n        \\t\\t\\t\\ti++;\\n        \\t\\t\\t}\\n        \\t\\t\\telse{\\n        \\t\\t\\t\\tmatch_pos = table[match_pos - 1];\\n        \\t\\t\\t}\\n        \\t\\t}\\n        \\t}\\n        \\tdelete[]table;\\n        \\treturn -1;\\n        }\\n\\nI'll talk about the basic idea behind KMP algorithm.\\n\\nFirst, some notations:\\n\\n - Denote the pattern string as ps and the match table as table, ps and\\n   table use 0 based index. \\n - Denote substring of ps from index i to index\\n   j (i and j included) as substr(ps,i,j). \\n - Denote string1 is the same as\\n   string2 as string1==string2\\n\\n------------------------------------------------------------------------\\n\\n\\nThe definition of my match table:\\n\\ntable[i] when i>0 means the max length of prefix of ps(0,i) which is the same as the suffix of ps(0,i).\\n\\nOr `table[i]=max{k| substr(substr(ps,0,i),0,k-1) == substr(substr(ps,0,i),i-k+1,i), k<=i}.`\\n\\nAlso, we define table[i]=0.\\n\\nSo, for string \"aba\", table={0,0,1}.\\n\\ntable[1]=0 is because no prefix equals suffix of \"ab\".\\n\\ntable[2]=1 is because prefix \"a\" equals suffix \"a\" of \"aba\".\\n\\nfor string \"abcabce\", table={0,0,0,1,2,3,0}.\\n\\ntable[4]=2 is because prefix \"ab\" equals suffix \"ab\" of \"abcab\"\\n\\ntable[5]=3 is because prefix \"abc\" equals suffix \"abc\" of \"abcabc\"\\n\\nfor string \"aabaabaaa\", table={0,1,0,1,2,3,4,5,2}.\\n\\n------------------------------------------------------------------------\\n\\n\\nHow would this match table be helpful to string matching?\\n\\nSuppose we have a target string \"abcabcdxxxxx\" and a pattern \"abcabce\".\\nIn the first round of matching, we start at first character and have\\n\\n    abcabcdxxxxx\\n    abcabce\\n\\nWe discover that 'd' and 'e' are different and string before that is the same, which is \"abcabc\".\\nif we move \"abcabce\" forward one character, we would be comparing\\n\\n    abcabcdxxxxx\\n     abcabce\\n\\nlet's focus on the parts which are same in the previous round:\\n\\n    abcabc\\n     abcabc\\n\\nwe are actually comparing the suffix of length 5 of \"abcabc\", which is \"bcabc\" and the prefix of length 5 of \"abcabc\", which is \"abcab\".\\n\\nHowever, table[5]==3 tells us the max length of suffix and prefix of \"abcabc\" which are same is 3, so suffix and prefix \\nof length 5 can't be the same. Thus, we can skip this round of comparing.\\nNext, we move \"abcabce\" forward by another one character, we would be comparing\\n\\n    abcabc\\n      abcabc\\n\\nNow, we are comparing suffix and prefix of length 4, since table[5]==3, we can skip this round.\\nNext, we move \"abcabce\" forward by another one character, we would be comparing\\n\\n    abcabc\\n       abcabc\\n\\nNow, we are comparing suffix and prefix of length 3, since table[5]==3, this is valid.\\nAnother property we can use to simply the matching process is that we already know the prefix and suffix of length 3 are the same, so we can start by comparing from the 4th charater in pattern, which is 'a', with the target string.\\n\\nTo sum up, when the ps(pattern string) at index i(i>0) failed to match ts(target string) at index j, which means substr(ps,0,i-1) matches, we start by comparing ps[table[i-1]] with ts[j].",
                "solutionTags": [],
                "code": "    int strStr(string haystack, string needle) {\\n            int nsize = needle.size();\\n        \\tint hsize = haystack.size();\\n        \\tif (nsize == 0) return 0;\\n        \\tint *table = new int[nsize];\\n        \\tmemset(table, 0, sizeof(int)*nsize);\\n        \\t//building match table\\n        \\tfor (int i = 1, j = 0; i < nsize - 1;){\\n        \\t\\tif (needle[i] != needle[j]){\\n        \\t\\t\\tif (j>0){\\n        \\t\\t\\t\\tj = table[j - 1];\\n        \\t\\t\\t}\\n        \\t\\t\\telse{\\n        \\t\\t\\t\\ti++;\\n        \\t\\t\\t}\\n        \\t\\t}\\n        \\t\\telse{\\n        \\t\\t\\ttable[i] = j + 1;\\n        \\t\\t\\ti++;\\n        \\t\\t\\tj++;\\n        \\t\\t}\\n        \\t}\\n        \\t//matching\\n        \\tfor (int i = 0, match_pos = 0; i < hsize;){\\n        \\t\\tif (haystack[i] == needle[match_pos]){\\n        \\t\\t\\tif (match_pos == nsize - 1){\\n        \\t\\t\\t\\treturn i - (nsize - 1);\\n        \\t\\t\\t}\\n        \\t\\t\\telse{\\n        \\t\\t\\t\\ti++;\\n        \\t\\t\\t\\tmatch_pos++;\\n        \\t\\t\\t}\\n        \\t\\t}\\n        \\t\\telse{\\n        \\t\\t\\tif (match_pos == 0){\\n        \\t\\t\\t\\ti++;\\n        \\t\\t\\t}\\n        \\t\\t\\telse{\\n        \\t\\t\\t\\tmatch_pos = table[match_pos - 1];\\n        \\t\\t\\t}\\n        \\t\\t}\\n        \\t}\\n        \\tdelete[]table;\\n        \\treturn -1;\\n        }\\n\\nI'll talk about the basic idea behind KMP algorithm.\\n\\nFirst, some notations:\\n\\n - Denote the pattern string as ps and the match table as table, ps and\\n   table use 0 based index. \\n - Denote substring of ps from index i to index\\n   j (i and j included) as substr(ps,i,j). \\n - Denote string1 is the same as\\n   string2 as string1==string2\\n\\n------------------------------------------------------------------------\\n\\n\\nThe definition of my match table:\\n\\ntable[i] when i>0 means the max length of prefix of ps(0,i) which is the same as the suffix of ps(0,i).\\n\\nOr `table[i]=max{k| substr(substr(ps,0,i),0,k-1) == substr(substr(ps,0,i),i-k+1,i), k<=i}.`\\n\\nAlso, we define table[i]=0.\\n\\nSo, for string \"aba\", table={0,0,1}.\\n\\ntable[1]=0 is because no prefix equals suffix of \"ab\".\\n\\ntable[2]=1 is because prefix \"a\" equals suffix \"a\" of \"aba\".\\n\\nfor string \"abcabce\", table={0,0,0,1,2,3,0}.\\n\\ntable[4]=2 is because prefix \"ab\" equals suffix \"ab\" of \"abcab\"\\n\\ntable[5]=3 is because prefix \"abc\" equals suffix \"abc\" of \"abcabc\"\\n\\nfor string \"aabaabaaa\", table={0,1,0,1,2,3,4,5,2}.\\n\\n------------------------------------------------------------------------\\n\\n\\nHow would this match table be helpful to string matching?\\n\\nSuppose we have a target string \"abcabcdxxxxx\" and a pattern \"abcabce\".\\nIn the first round of matching, we start at first character and have\\n\\n    abcabcdxxxxx\\n    abcabce\\n\\nWe discover that 'd' and 'e' are different and string before that is the same, which is \"abcabc\".\\nif we move \"abcabce\" forward one character, we would be comparing\\n\\n    abcabcdxxxxx\\n     abcabce\\n\\nlet's focus on the parts which are same in the previous round:\\n\\n    abcabc\\n     abcabc\\n\\nwe are actually comparing the suffix of length 5 of \"abcabc\", which is \"bcabc\" and the prefix of length 5 of \"abcabc\", which is \"abcab\".\\n\\nHowever, table[5]==3 tells us the max length of suffix and prefix of \"abcabc\" which are same is 3, so suffix and prefix \\nof length 5 can't be the same. Thus, we can skip this round of comparing.\\nNext, we move \"abcabce\" forward by another one character, we would be comparing\\n\\n    abcabc\\n      abcabc\\n\\nNow, we are comparing suffix and prefix of length 4, since table[5]==3, we can skip this round.\\nNext, we move \"abcabce\" forward by another one character, we would be comparing\\n\\n    abcabc\\n       abcabc\\n\\nNow, we are comparing suffix and prefix of length 3, since table[5]==3, this is valid.\\nAnother property we can use to simply the matching process is that we already know the prefix and suffix of length 3 are the same, so we can start by comparing from the 4th charater in pattern, which is 'a', with the target string.\\n\\nTo sum up, when the ps(pattern string) at index i(i>0) failed to match ts(target string) at index j, which means substr(ps,0,i-1) matches, we start by comparing ps[table[i-1]] with ts[j].",
                "codeTag": "Unknown"
            },
            {
                "id": 665448,
                "title": "ac-simply-readable-python-kmp-rabin-karp",
                "content": "```\\ndef strStr(self, haystack, needle):\\n\\treturn haystack.find(needle)\\n```\\nRabin Karp, built-in hash, constant time (tested)\\n```\\ndef strStr(self, haystack, needle):\\n\\tn, h = len(needle), len(haystack)\\n\\thash_n = hash(needle)\\n\\tfor i in range(h-n+1):\\n\\t\\tif hash(haystack[i:i+n]) == hash_n:\\n\\t\\t\\treturn i\\n\\treturn -1\\n```\\nRabin Karp, numeral base for both uppercase and lowercase letters, constant time\\n```\\ndef strStr(self, haystack, needle):\\n\\tdef f(c):\\n\\t\\treturn ord(c)-ord(\\'A\\')\\n\\n\\tn, h, d, m = len(needle), len(haystack), ord(\\'z\\')-ord(\\'A\\')+1, sys.maxint \\n\\tif n > h: return -1\\n\\tnd, hash_n, hash_h = d**(n-1), 0, 0   \\n\\tfor i in range(n):\\n\\t\\thash_n = (d*hash_n+f(needle[i]))%m\\n\\t\\thash_h = (d*hash_h+f(haystack[i]))%m            \\n\\tif hash_n == hash_h: return 0        \\n\\tfor i in range(1, h-n+1):\\n\\t\\thash_h = (d*(hash_h-f(haystack[i-1])*nd)+f(haystack[i+n-1]))%m    # e.g. 10*(1234-1*10**3)+5=2345\\n\\t\\tif hash_n == hash_h: return i\\n\\treturn -1\\n```\\nKMP\\n```\\ndef strStr(self, haystack, needle):\\n\\tn, h = len(needle), len(haystack)\\n\\ti, j, nxt = 1, 0, [-1]+[0]*n\\n\\twhile i < n:                                # calculate next array\\n\\t\\tif j == -1 or needle[i] == needle[j]:   \\n\\t\\t\\ti += 1\\n\\t\\t\\tj += 1\\n\\t\\t\\tnxt[i] = j\\n\\t\\telse:\\n\\t\\t\\tj = nxt[j]\\n\\ti = j = 0\\n\\twhile i < h and j < n:\\n\\t\\tif j == -1 or haystack[i] == needle[j]:\\n\\t\\t\\ti += 1\\n\\t\\t\\tj += 1\\n\\t\\telse:\\n\\t\\t\\tj = nxt[j]\\n\\treturn i-j if j == n else -1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String"
                ],
                "code": "```\\ndef strStr(self, haystack, needle):\\n\\treturn haystack.find(needle)\\n```\n```\\ndef strStr(self, haystack, needle):\\n\\tn, h = len(needle), len(haystack)\\n\\thash_n = hash(needle)\\n\\tfor i in range(h-n+1):\\n\\t\\tif hash(haystack[i:i+n]) == hash_n:\\n\\t\\t\\treturn i\\n\\treturn -1\\n```\n```\\ndef strStr(self, haystack, needle):\\n\\tdef f(c):\\n\\t\\treturn ord(c)-ord(\\'A\\')\\n\\n\\tn, h, d, m = len(needle), len(haystack), ord(\\'z\\')-ord(\\'A\\')+1, sys.maxint \\n\\tif n > h: return -1\\n\\tnd, hash_n, hash_h = d**(n-1), 0, 0   \\n\\tfor i in range(n):\\n\\t\\thash_n = (d*hash_n+f(needle[i]))%m\\n\\t\\thash_h = (d*hash_h+f(haystack[i]))%m            \\n\\tif hash_n == hash_h: return 0        \\n\\tfor i in range(1, h-n+1):\\n\\t\\thash_h = (d*(hash_h-f(haystack[i-1])*nd)+f(haystack[i+n-1]))%m    # e.g. 10*(1234-1*10**3)+5=2345\\n\\t\\tif hash_n == hash_h: return i\\n\\treturn -1\\n```\n```\\ndef strStr(self, haystack, needle):\\n\\tn, h = len(needle), len(haystack)\\n\\ti, j, nxt = 1, 0, [-1]+[0]*n\\n\\twhile i < n:                                # calculate next array\\n\\t\\tif j == -1 or needle[i] == needle[j]:   \\n\\t\\t\\ti += 1\\n\\t\\t\\tj += 1\\n\\t\\t\\tnxt[i] = j\\n\\t\\telse:\\n\\t\\t\\tj = nxt[j]\\n\\ti = j = 0\\n\\twhile i < h and j < n:\\n\\t\\tif j == -1 or haystack[i] == needle[j]:\\n\\t\\t\\ti += 1\\n\\t\\t\\tj += 1\\n\\t\\telse:\\n\\t\\t\\tj = nxt[j]\\n\\treturn i-j if j == n else -1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 242103,
                "title": "100-time-python-solution",
                "content": "\\'\\'\\'\\nclass Solution:\\n    def strStr(self, haystack: \\'str\\', needle: \\'str\\') -> \\'int\\':\\n           \\n        for i in range(0, len(haystack) - len(needle) + 1):\\n            if haystack[i:i+len(needle)] == needle:\\n                return i\\n        \\n        return -1\\n\\'\\'\\'",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\'\\'\\'\\nclass Solution:\\n    def strStr(self, haystack: \\'str\\', needle: \\'str\\') -> \\'int\\':\\n           \\n        for i in range(0, len(haystack) - len(needle) + 1):\\n            if haystack[i:i+len(needle)] == needle:\\n                return i\\n        \\n        return -1\\n\\'\\'\\'",
                "codeTag": "Java"
            },
            {
                "id": 12886,
                "title": "accepted-kmp-solution-in-java-for-reference",
                "content": "\\n    public String strStr(String haystack, String needle) {\\n    \\t//KMP algorithms\\n    \\tif(needle.equals(\"\")) return haystack;\\n    \\tif(haystack.equals(\"\")) return null;\\n    \\tchar[] arr = needle.toCharArray();\\n    \\tint[] next = makeNext(arr);\\n\\n    \\tfor(int i = 0, j = 0, end = haystack.length(); i < end;){\\n    \\t\\tif(j == -1 || haystack.charAt(i) == arr[j]){\\n    \\t\\t\\tj++;\\n    \\t\\t\\ti++;\\n    \\t\\t\\tif(j == arr.length) return haystack.substring(i - arr.length);\\n    \\t\\t}\\n    \\t\\tif(i < end && haystack.charAt(i) != arr[j]) j = next[j];\\n    \\t}\\n        return null;\\n    }\\n\\n    private int[] makeNext(char[] arr){\\n    \\tint len = arr.length;\\n    \\tint[] next = new int[len];\\n\\n    \\tnext[0] = -1;\\n    \\tfor(int i = 0, j = -1; i + 1 < len;){\\n    \\t\\tif(j == -1 || arr[i] == arr[j]){\\n    \\t\\t\\tnext[i+1] = j+1;\\n    \\t\\t\\tif(arr[i+1] == arr[j+1]) next[i+1] = next[j+1];\\n    \\t\\t\\ti++;\\n    \\t\\t\\tj++;\\n    \\t\\t}\\n    \\t\\tif(arr[i] != arr[j]) j = next[j];\\n    \\t}\\n\\n    \\treturn next;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "\\n    public String strStr(String haystack, String needle) {\\n    \\t//KMP algorithms\\n    \\tif(needle.equals(\"\")) return haystack;\\n    \\tif(haystack.equals(\"\")) return null;\\n    \\tchar[] arr = needle.toCharArray();\\n    \\tint[] next = makeNext(arr);\\n\\n    \\tfor(int i = 0, j = 0, end = haystack.length(); i < end;){\\n    \\t\\tif(j == -1 || haystack.charAt(i) == arr[j]){\\n    \\t\\t\\tj++;\\n    \\t\\t\\ti++;\\n    \\t\\t\\tif(j == arr.length) return haystack.substring(i - arr.length);\\n    \\t\\t}\\n    \\t\\tif(i < end && haystack.charAt(i) != arr[j]) j = next[j];\\n    \\t}\\n        return null;\\n    }\\n\\n    private int[] makeNext(char[] arr){\\n    \\tint len = arr.length;\\n    \\tint[] next = new int[len];\\n\\n    \\tnext[0] = -1;\\n    \\tfor(int i = 0, j = -1; i + 1 < len;){\\n    \\t\\tif(j == -1 || arr[i] == arr[j]){\\n    \\t\\t\\tnext[i+1] = j+1;\\n    \\t\\t\\tif(arr[i+1] == arr[j+1]) next[i+1] = next[j+1];\\n    \\t\\t\\ti++;\\n    \\t\\t\\tj++;\\n    \\t\\t}\\n    \\t\\tif(arr[i] != arr[j]) j = next[j];\\n    \\t}\\n\\n    \\treturn next;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 13160,
                "title": "detailed-explanation-on-building-up-lps-for-kmp-algorithm",
                "content": "At first special thanks to @jianchao.li.fighter's introduction to KMP algorithm and 2 helpful links in his answer to this problem. Here is his answer: [https://leetcode.com/discuss/38998/explained-4ms-easy-c-solution][1] and below are the 2 links to refer to. \\n\\n 1. [http://jakeboxer.com/blog/2009/12/13/the-knuth-morris-pratt-algorithm-in-my-own-words/][2]\\n 2. [http://www.geeksforgeeks.org/searching-for-patterns-set-2-kmp-algorithm/][3]\\n\\n**For those who don't know what KMP is please read the content in the 2 links first**. And here I just add some detailed supplementary comments on how to build up the lps[] based on the original code and comments from the 2nd link. Hope this will help those who are still confused how the lps[] is built (especially for the tricky part) after read the content in the 2 links above.\\n\\n    void computeLPSArray(char *pat, int M, int *lps)\\n      {\\n          int len = 0;  // lenght of the previous longest prefix suffix\\n          int i;\\n    \\n          lps[0] = 0; // lps[0] is always 0\\n          i = 1;\\n    \\n          // the loop calculates lps[i] for i = 1 to M-1\\n          while (i < M)\\n          {\\n             //example \"abababca\" and i==5, len==3. The longest prefix suffix is \"aba\", when pat[i]==pat[len],\\n             //we get new prefix \"abab\" and new suffix \"abab\", so increase length of  current lps by 1 and go to next iteration. \\n             if (pat[i] == pat[len])\\n             {\\n               len++;\\n               lps[i] = len;\\n               i++;\\n             }\\n             else // (pat[i] != pat[len])\\n             {\\n               if (len != 0)\\n               {\\n                 len = lps[len-1];\\n                 //This is tricky. Consider the example \"ababe......ababc\", i is index of 'c', len==4. The longest prefix suffix is \"abab\",\\n                 //when pat[i]!=pat[len], we get new prefix \"ababe\" and suffix \"ababc\", which are not equal. \\n                 //This means we can't increment length of lps based on current lps \"abab\" with len==4. We may want to increment it based on\\n                 //the longest prefix suffix with length < len==4, which by definition is lps of \"abab\". So we set len to lps[len-1],\\n                 //which is 2, now the lps is \"ab\". Then check pat[i]==pat[len] again due to the while loop, which is also the reason\\n                 //why we do not increment i here. The iteration of i terminate until len==0 (didn't find lps ends with pat[i]) or found\\n                 //a lps ends with pat[i].\\n               }\\n               else // if (len == 0)\\n               { // there isn't any lps ends with pat[i], so set lps[i] = 0 and go to next iteration.\\n                 lps[i] = 0;\\n                 i++;\\n               }\\n             }\\n          }\\n      }  \\n\\n\\n  [1]: https://leetcode.com/discuss/38998/explained-4ms-easy-c-solution\\n  [2]: http://jakeboxer.com/blog/2009/12/13/the-knuth-morris-pratt-algorithm-in-my-own-words/\\n  [3]: http://www.geeksforgeeks.org/searching-for-patterns-set-2-kmp-algorithm/",
                "solutionTags": [],
                "code": "At first special thanks to @jianchao.li.fighter's introduction to KMP algorithm and 2 helpful links in his answer to this problem. Here is his answer: [https://leetcode.com/discuss/38998/explained-4ms-easy-c-solution][1] and below are the 2 links to refer to. \\n\\n 1. [http://jakeboxer.com/blog/2009/12/13/the-knuth-morris-pratt-algorithm-in-my-own-words/][2]\\n 2. [http://www.geeksforgeeks.org/searching-for-patterns-set-2-kmp-algorithm/][3]\\n\\n**For those who don't know what KMP is please read the content in the 2 links first**. And here I just add some detailed supplementary comments on how to build up the lps[] based on the original code and comments from the 2nd link. Hope this will help those who are still confused how the lps[] is built (especially for the tricky part) after read the content in the 2 links above.\\n\\n    void computeLPSArray(char *pat, int M, int *lps)\\n      {\\n          int len = 0;  // lenght of the previous longest prefix suffix\\n          int i;\\n    \\n          lps[0] = 0; // lps[0] is always 0\\n          i = 1;\\n    \\n          // the loop calculates lps[i] for i = 1 to M-1\\n          while (i < M)\\n          {\\n             //example \"abababca\" and i==5, len==3. The longest prefix suffix is \"aba\", when pat[i]==pat[len],\\n             //we get new prefix \"abab\" and new suffix \"abab\", so increase length of  current lps by 1 and go to next iteration. \\n             if (pat[i] == pat[len])\\n             {\\n               len++;\\n               lps[i] = len;\\n               i++;\\n             }\\n             else // (pat[i] != pat[len])\\n             {\\n               if (len != 0)\\n               {\\n                 len = lps[len-1];\\n                 //This is tricky. Consider the example \"ababe......ababc\", i is index of 'c', len==4. The longest prefix suffix is \"abab\",\\n                 //when pat[i]!=pat[len], we get new prefix \"ababe\" and suffix \"ababc\", which are not equal. \\n                 //This means we can't increment length of lps based on current lps \"abab\" with len==4. We may want to increment it based on\\n                 //the longest prefix suffix with length < len==4, which by definition is lps of \"abab\". So we set len to lps[len-1],\\n                 //which is 2, now the lps is \"ab\". Then check pat[i]==pat[len] again due to the while loop, which is also the reason\\n                 //why we do not increment i here. The iteration of i terminate until len==0 (didn't find lps ends with pat[i]) or found\\n                 //a lps ends with pat[i].\\n               }\\n               else // if (len == 0)\\n               { // there isn't any lps ends with pat[i], so set lps[i] = 0 and go to next iteration.\\n                 lps[i] = 0;\\n                 i++;\\n               }\\n             }\\n          }\\n      }  \\n\\n\\n  [1]: https://leetcode.com/discuss/38998/explained-4ms-easy-c-solution\\n  [2]: http://jakeboxer.com/blog/2009/12/13/the-knuth-morris-pratt-algorithm-in-my-own-words/\\n  [3]: http://www.geeksforgeeks.org/searching-for-patterns-set-2-kmp-algorithm/",
                "codeTag": "Unknown"
            },
            {
                "id": 3677775,
                "title": "one-line-code-using-python-tc-o-n-sc-o-1",
                "content": "# Intuition\\nThe intuition behind this approach is to use the built-in find() function in Python to find the index of the first occurrence of the needle string within the haystack string. If the needle is not found, it returns -1.\\n# Approach\\nThe approach is simple and straightforward. We can directly use the find() function on the haystack string and pass the needle string as the argument. The find() function returns the index of the first occurrence of the needle string in the haystack string, or -1 if it is not found.\\n\\n\\n# Complexity\\n- Time complexity:\\nThe find() function has a time complexity of O(n), where n is the length of the haystack string.\\n- Space complexity:\\nThe space complexity is O(1) since no extra space is used.\\n\\n# Code\\n```\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        return haystack.find(needle)\\n```\\n##### reach me to discuss any problems - https://www.linkedin.com/in/naveen-kumar-g-500469210/\\n#\\n#\\n\\n![image.png](https://assets.leetcode.com/users/images/1671e9d0-2b0a-4c38-b1c3-f5a1211a9145_1687624629.314786.png)\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        return haystack.find(needle)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1313426,
                "title": "pattern-searching-2-pointer-approach-comments-explanation",
                "content": "```\\nint strStr(string haystack, string needle) \\n    {\\n        if(needle==\"\")\\n            return 0;\\n        \\n        int i=0,j=0;\\n        while(i<haystack.size() && j<needle.size())\\n        {\\n            if(haystack[i]==needle[j])\\n            { // when there is a match then increase both the pointers\\n                i++;\\n                j++;\\n                if(j==needle.size()) // if the whole pattern has been matched then return\\n                    return i-needle.size();  // the value by going needle size steps backwards from the current index in array\\n            }\\n            else\\n            { // when there is no match then start checking from the haystack index\\n                i=i-j+1;  // such that it goes backwards till whatever length has been matched \\n                j=0; // and checks from next index and start checking from pattern\\'s beginning\\n            }            \\n        }        \\n        return -1;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nint strStr(string haystack, string needle) \\n    {\\n        if(needle==\"\")\\n            return 0;\\n        \\n        int i=0,j=0;\\n        while(i<haystack.size() && j<needle.size())\\n        {\\n            if(haystack[i]==needle[j])\\n            { // when there is a match then increase both the pointers\\n                i++;\\n                j++;\\n                if(j==needle.size()) // if the whole pattern has been matched then return\\n                    return i-needle.size();  // the value by going needle size steps backwards from the current index in array\\n            }\\n            else\\n            { // when there is no match then start checking from the haystack index\\n                i=i-j+1;  // such that it goes backwards till whatever length has been matched \\n                j=0; // and checks from next index and start checking from pattern\\'s beginning\\n            }            \\n        }        \\n        return -1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3253654,
                "title": "javascript-php-6-solutions-with-explanation-understandable",
                "content": "# Approach\\n#### Solution #1 - Built-in function strpos()\\nUse the strpos() Built-in function to find the position of the substring in the string. If the substring is not found, return -1.\\n#### Solution #2 - Find Substring Position with Regex\\nCreate a pattern based on the needle and use preg_match() function to compare the haystack and needle and return the index position. If the substring is not found, return -1.\\n#### Solution #3 - Brute Force\\nLoop through the haystack. For each character, loop through the needle and compare. If they are all equal, return the index of the haystack\\n#### Solution #4 - Brute Force Substring Search\\nCreate a loop to iterate through the haystack and compare the substrings of the haystack and needle using the substr() function. Return the index position of the needle or -1 if not found.\\n#### Solution #5 - Tracking Loop Search - Time: O(N), Space: O(1)\\nLoop through the haystack string and compare each character of the substring to the corresponding character in the haystack. If all characters match, the index is returned. If the substring is not found, return -1.\\n#### Solution #6 - KMP - Time: O(N+M) | KMP - Knuth-Morris-Pratt String Matching Algorithm\\nPreprocess the needle to form an array to store the occurs before.\\nLoop through the haystack and compare with needle. If mismatch occurs, move the haystack index by the occurs before array. \\n\\n# Complexity\\n- Time complexity: O(n)\\n- Space complexity: O(1)\\n\\n\\n# Solution #1 - Built-in function\\n```javascript []\\n/**\\n * Solution #1 - Built-in function\\n *\\n * @param {string} haystack\\n * @param {string} needle\\n * @return {number}\\n */\\nvar strStr = function (haystack, needle) {\\n    return haystack.indexOf(needle);\\n};\\n```\\n```php []\\nclass Solution\\n{\\n    /**\\n     * Solution 1 - Built-in function strpos()\\n     * \\n     * @param String $haystack\\n     * @param String $needle\\n     * @return Integer\\n     */\\n    function strStr(string $haystack, string $needle): int {\\n        $pos = strpos($haystack, $needle);\\n        return $pos === false ? -1 : $pos;\\n    }\\n}\\n```\\n# Solution #2 - Find Position with Regex\\n```javascript []\\n/**\\n * Solution #2 - RegExp\\n *\\n * @param {string} haystack\\n * @param {string} needle\\n * @return {number}\\n */\\nvar strStr = function (haystack, needle) {\\n    const regex = new RegExp(needle);\\n    return haystack.search(regex);\\n};\\n```\\n```php []\\nclass Solution\\n{\\n    /**\\n     * Solution #2 - Regular Expression\\n     * \\n     * @param String $haystack\\n     * @param String $needle\\n     * @return Integer\\n     */\\n    function strStr(string $haystack, string $needle): int {\\n        $pattern = \\'/\\' . $needle . \\'/\\';\\n        $result = preg_match($pattern, $haystack, $matches, PREG_OFFSET_CAPTURE);\\n        return $result ? $matches[0][1] : -1;\\n    }\\n}\\n```\\n\\n\\n\\n\\n# Solution #3 - Brute Force Time: O(N*M)\\n```javascript []\\n/**\\n * Solution #3 - Brute Force - Time: O(N*M), Space: O(1)\\n * Loop through the haystack. For each character, loop through the needle and compare.\\n * If they are all equal, return the index of the haystack\\n *\\n * @param {string} haystack\\n * @param {string} needle\\n * @return {number}\\n */\\nvar strStr = function (haystack, needle) {\\n    if (!needle) return 0;\\n    for (let i = 0; i < haystack.length; i++) {\\n        let isMatch = true;\\n        for (let j = 0; j < needle.length; j++) {\\n            if (haystack[i + j] !== needle[j]) {\\n                isMatch = false;\\n                break;\\n            }\\n        }\\n        if (isMatch) return i;\\n    }\\n    return -1;\\n};\\n```\\n\\n\\n# Solution #4 - Loop through haystack and compare substrings\\n```javascript []\\n/**\\n * Solution #4 - Loop through haystack and compare substrings - Time: O(N), Space: O(1)\\n * Loop through the haystack. For each character, loop through the needle and compare.\\n * If they are all equal, return the index of the haystack\\n *\\n * @param {string} haystack\\n * @param {string} needle\\n * @return {number}\\n */\\nvar strStr = function (haystack, needle) {\\n    let haystackLength = haystack.length;\\n    let needleLength = needle.length;\\n    if (haystackLength < needleLength) return -1;\\n\\n    for (let i = 0; i <= haystackLength - needleLength; i++) {\\n        if (haystack.substr(i, needleLength) === needle) return i;\\n    }\\n    return -1;\\n};\\n```\\n```php []\\nclass Solution\\n{\\n    /**\\n     * Solution #4 - Loop through haystack and compare substrings\\n     * \\n     * @param String $haystack\\n     * @param String $needle\\n     * @return Integer\\n     */\\n    function strStr(string $haystack, string $needle): int {\\n        $haystackLength = strlen($haystack);\\n        $needleLength = strlen($needle);\\n        if ($haystackLength < $needleLength) return -1;\\n\\n        for ($i = 0; $i <= $haystackLength - $needleLength; $i++) {\\n            if (substr($haystack, $i, $needleLength) == $needle) return $i;\\n        }\\n        return -1;\\n    }\\n}\\n```\\n\\n\\n\\n# Solution #5 - Tracking Loop Search\\n```javascript []\\n/**\\n * Solution #5 - Loop through haystack and compare characters one by one - Time: O(N), Space: O(1)\\n * Loop through the haystack string and compare each character of the substring to the corresponding character in the haystack. If all characters match, the index is returned. If the substring is not found, return -1.\\n *\\n * @param {string} haystack\\n * @param {string} needle\\n * @return {number}\\n */\\nvar strStr = function (haystack, needle) {\\n    let haystackLength = haystack.length;\\n    let needleLength = needle.length;\\n    if (haystackLength < needleLength) return -1;\\n\\n    let matchingIndex = 0;\\n    for (let i = 0; i < haystackLength; i++) {\\n        if (needle[i - matchingIndex] !== haystack[i]) {\\n            i = matchingIndex;\\n            matchingIndex = i + 1;\\n        } else if (i - matchingIndex == needleLength - 1) {\\n            return matchingIndex;\\n        }\\n    }\\n    return -1;\\n};\\n```\\n```php []\\nclass Solution\\n{\\n    /**\\n     * Solution #5 - Loop through haystack and compare characters one by one - no substr or strpos used\\n     * \\n     * @param String $haystack\\n     * @param String $needle\\n     * @return Integer\\n     */\\n    function strStr(string $haystack, string $needle): int {\\n        $haystackLength = strlen($haystack);\\n        $needleLength = strlen($needle);\\n        if ($haystackLength < $needleLength) return -1;\\n\\n        $matchingIndex = 0;\\n        for ($i = 0; $i < $haystackLength; $i++) {\\n            if ($needle[$i - $matchingIndex] != $haystack[$i]) {\\n                $i = $matchingIndex;\\n                $matchingIndex = $i + 1;\\n            } elseif (($i - $matchingIndex) == ($needleLength - 1)) {\\n                return $matchingIndex;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```\\n\\n# Solution #6 - KMP - Time: O(N+M) | KMP - Knuth-Morris-Pratt String Matching Algorithm\\n\\n```javascript []\\n/**\\n * Solution #6 - KMP - Time: O(N+M) | KMP - Knuth-Morris-Pratt String Matching Algorithm\\n * Preprocess the needle to form an array to store the occurs before.\\n * Loop through the haystack and compare with needle.\\n * If mismatch occurs, move the haystack index by the occurs before array.\\n *\\n * @param {string} haystack\\n * @param {string} needle\\n * @return {number}\\n */\\nvar strStr = function (haystack, needle) {\\n    const needleLength = needle.length;\\n    let i = 0, j = -1;\\n\\n    // LPS - Longest Prefix Suffix / Prefix table \\n    const lps = [-1];\\n    while (i < needleLength - 1) {\\n        if (j === -1 || needle[i] === needle[j]) {\\n            i++;\\n            j++;\\n            lps[i] = j;\\n        } else {\\n            j = lps[j];\\n        }\\n    }\\n\\n    i = 0, j = 0;\\n    while (i < haystack.length && j < needleLength) {\\n        if (haystack[i] === needle[j]) {\\n            i++;\\n            j++;\\n        } else {\\n            j = lps[j];\\n            if (j < 0) {\\n                i++;\\n                j++;\\n            }\\n        }\\n    }\\n    if (j === needleLength) {\\n        return i - j;\\n    }\\n    return -1;\\n}\\n```\\n```php []\\nclass Solution\\n{\\n    /**\\n     * Solution #6 -- KMP - Knuth-Morris-Pratt String Matching Algorithm\\n     * \\n     * @param String $haystack\\n     * @param String $needle\\n     * @return Integer\\n     */\\n    $haystackLength = strlen($haystack);\\n    $needleLength = strlen($needle);\\n    if ($needleLength == 0) return 0;\\n    if ($haystackLength < $needleLength) return -1;\\n\\n    // LPS - Longest Prefix Suffix / Prefix table \\n    $lps = array_fill(0, $needleLength, 0);\\n    $prevLPS = 0;\\n    $i = 1;\\n    while ($i < $needleLength) {\\n        if ($needle[$i] == $needle[$prevLPS]) {\\n            $lps[$i] = $prevLPS + 1;\\n            $prevLPS++;\\n            $i++;\\n        } elseif ($prevLPS == 0) {\\n            $lps[$i] = 0;\\n            $i++;\\n        } else {\\n            $prevLPS = $lps[$prevLPS - 1];\\n        }\\n    }\\n\\n    $i = 0; // for haystack\\n    $j = 0; // for needle\\n    while ($i < $haystackLength) {\\n        if ($haystack[$i] == $needle[$j]) {\\n            $i++;\\n            $j++;\\n        } else {\\n            if ($j == 0) {\\n                $i++;\\n            } else {\\n                $j = $lps[$j - 1];\\n            }\\n        }\\n        if ($j == $needleLength) {\\n            return $i - $needleLength;\\n        }\\n    }\\n    return -1;\\n    }\\n}\\n```\\n\\n**If my work was useful for you, please upvote!**\\n\\n\\uD83D\\uDC4D\\uD83D\\uDC4D\\uD83D\\uDC4D",
                "solutionTags": [
                    "JavaScript",
                    "PHP",
                    "String",
                    "String Matching"
                ],
                "code": "```javascript []\\n/**\\n * Solution #1 - Built-in function\\n *\\n * @param {string} haystack\\n * @param {string} needle\\n * @return {number}\\n */\\nvar strStr = function (haystack, needle) {\\n    return haystack.indexOf(needle);\\n};\\n```\n```php []\\nclass Solution\\n{\\n    /**\\n     * Solution 1 - Built-in function strpos()\\n     * \\n     * @param String $haystack\\n     * @param String $needle\\n     * @return Integer\\n     */\\n    function strStr(string $haystack, string $needle): int {\\n        $pos = strpos($haystack, $needle);\\n        return $pos === false ? -1 : $pos;\\n    }\\n}\\n```\n```javascript []\\n/**\\n * Solution #2 - RegExp\\n *\\n * @param {string} haystack\\n * @param {string} needle\\n * @return {number}\\n */\\nvar strStr = function (haystack, needle) {\\n    const regex = new RegExp(needle);\\n    return haystack.search(regex);\\n};\\n```\n```php []\\nclass Solution\\n{\\n    /**\\n     * Solution #2 - Regular Expression\\n     * \\n     * @param String $haystack\\n     * @param String $needle\\n     * @return Integer\\n     */\\n    function strStr(string $haystack, string $needle): int {\\n        $pattern = \\'/\\' . $needle . \\'/\\';\\n        $result = preg_match($pattern, $haystack, $matches, PREG_OFFSET_CAPTURE);\\n        return $result ? $matches[0][1] : -1;\\n    }\\n}\\n```\n```javascript []\\n/**\\n * Solution #3 - Brute Force - Time: O(N*M), Space: O(1)\\n * Loop through the haystack. For each character, loop through the needle and compare.\\n * If they are all equal, return the index of the haystack\\n *\\n * @param {string} haystack\\n * @param {string} needle\\n * @return {number}\\n */\\nvar strStr = function (haystack, needle) {\\n    if (!needle) return 0;\\n    for (let i = 0; i < haystack.length; i++) {\\n        let isMatch = true;\\n        for (let j = 0; j < needle.length; j++) {\\n            if (haystack[i + j] !== needle[j]) {\\n                isMatch = false;\\n                break;\\n            }\\n        }\\n        if (isMatch) return i;\\n    }\\n    return -1;\\n};\\n```\n```javascript []\\n/**\\n * Solution #4 - Loop through haystack and compare substrings - Time: O(N), Space: O(1)\\n * Loop through the haystack. For each character, loop through the needle and compare.\\n * If they are all equal, return the index of the haystack\\n *\\n * @param {string} haystack\\n * @param {string} needle\\n * @return {number}\\n */\\nvar strStr = function (haystack, needle) {\\n    let haystackLength = haystack.length;\\n    let needleLength = needle.length;\\n    if (haystackLength < needleLength) return -1;\\n\\n    for (let i = 0; i <= haystackLength - needleLength; i++) {\\n        if (haystack.substr(i, needleLength) === needle) return i;\\n    }\\n    return -1;\\n};\\n```\n```php []\\nclass Solution\\n{\\n    /**\\n     * Solution #4 - Loop through haystack and compare substrings\\n     * \\n     * @param String $haystack\\n     * @param String $needle\\n     * @return Integer\\n     */\\n    function strStr(string $haystack, string $needle): int {\\n        $haystackLength = strlen($haystack);\\n        $needleLength = strlen($needle);\\n        if ($haystackLength < $needleLength) return -1;\\n\\n        for ($i = 0; $i <= $haystackLength - $needleLength; $i++) {\\n            if (substr($haystack, $i, $needleLength) == $needle) return $i;\\n        }\\n        return -1;\\n    }\\n}\\n```\n```javascript []\\n/**\\n * Solution #5 - Loop through haystack and compare characters one by one - Time: O(N), Space: O(1)\\n * Loop through the haystack string and compare each character of the substring to the corresponding character in the haystack. If all characters match, the index is returned. If the substring is not found, return -1.\\n *\\n * @param {string} haystack\\n * @param {string} needle\\n * @return {number}\\n */\\nvar strStr = function (haystack, needle) {\\n    let haystackLength = haystack.length;\\n    let needleLength = needle.length;\\n    if (haystackLength < needleLength) return -1;\\n\\n    let matchingIndex = 0;\\n    for (let i = 0; i < haystackLength; i++) {\\n        if (needle[i - matchingIndex] !== haystack[i]) {\\n            i = matchingIndex;\\n            matchingIndex = i + 1;\\n        } else if (i - matchingIndex == needleLength - 1) {\\n            return matchingIndex;\\n        }\\n    }\\n    return -1;\\n};\\n```\n```php []\\nclass Solution\\n{\\n    /**\\n     * Solution #5 - Loop through haystack and compare characters one by one - no substr or strpos used\\n     * \\n     * @param String $haystack\\n     * @param String $needle\\n     * @return Integer\\n     */\\n    function strStr(string $haystack, string $needle): int {\\n        $haystackLength = strlen($haystack);\\n        $needleLength = strlen($needle);\\n        if ($haystackLength < $needleLength) return -1;\\n\\n        $matchingIndex = 0;\\n        for ($i = 0; $i < $haystackLength; $i++) {\\n            if ($needle[$i - $matchingIndex] != $haystack[$i]) {\\n                $i = $matchingIndex;\\n                $matchingIndex = $i + 1;\\n            } elseif (($i - $matchingIndex) == ($needleLength - 1)) {\\n                return $matchingIndex;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```\n```javascript []\\n/**\\n * Solution #6 - KMP - Time: O(N+M) | KMP - Knuth-Morris-Pratt String Matching Algorithm\\n * Preprocess the needle to form an array to store the occurs before.\\n * Loop through the haystack and compare with needle.\\n * If mismatch occurs, move the haystack index by the occurs before array.\\n *\\n * @param {string} haystack\\n * @param {string} needle\\n * @return {number}\\n */\\nvar strStr = function (haystack, needle) {\\n    const needleLength = needle.length;\\n    let i = 0, j = -1;\\n\\n    // LPS - Longest Prefix Suffix / Prefix table \\n    const lps = [-1];\\n    while (i < needleLength - 1) {\\n        if (j === -1 || needle[i] === needle[j]) {\\n            i++;\\n            j++;\\n            lps[i] = j;\\n        } else {\\n            j = lps[j];\\n        }\\n    }\\n\\n    i = 0, j = 0;\\n    while (i < haystack.length && j < needleLength) {\\n        if (haystack[i] === needle[j]) {\\n            i++;\\n            j++;\\n        } else {\\n            j = lps[j];\\n            if (j < 0) {\\n                i++;\\n                j++;\\n            }\\n        }\\n    }\\n    if (j === needleLength) {\\n        return i - j;\\n    }\\n    return -1;\\n}\\n```\n```php []\\nclass Solution\\n{\\n    /**\\n     * Solution #6 -- KMP - Knuth-Morris-Pratt String Matching Algorithm\\n     * \\n     * @param String $haystack\\n     * @param String $needle\\n     * @return Integer\\n     */\\n    $haystackLength = strlen($haystack);\\n    $needleLength = strlen($needle);\\n    if ($needleLength == 0) return 0;\\n    if ($haystackLength < $needleLength) return -1;\\n\\n    // LPS - Longest Prefix Suffix / Prefix table \\n    $lps = array_fill(0, $needleLength, 0);\\n    $prevLPS = 0;\\n    $i = 1;\\n    while ($i < $needleLength) {\\n        if ($needle[$i] == $needle[$prevLPS]) {\\n            $lps[$i] = $prevLPS + 1;\\n            $prevLPS++;\\n            $i++;\\n        } elseif ($prevLPS == 0) {\\n            $lps[$i] = 0;\\n            $i++;\\n        } else {\\n            $prevLPS = $lps[$prevLPS - 1];\\n        }\\n    }\\n\\n    $i = 0; // for haystack\\n    $j = 0; // for needle\\n    while ($i < $haystackLength) {\\n        if ($haystack[$i] == $needle[$j]) {\\n            $i++;\\n            $j++;\\n        } else {\\n            if ($j == 0) {\\n                $i++;\\n            } else {\\n                $j = $lps[$j - 1];\\n            }\\n        }\\n        if ($j == $needleLength) {\\n            return $i - $needleLength;\\n        }\\n    }\\n    return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 12952,
                "title": "java-easy-to-understand-solutions",
                "content": "       \\n    public int strStr1(String haystack, String needle) {\\n        return haystack.indexOf(needle);\\n    }\\n    \\n    public int strStr(String haystack, String needle) {\\n        if (haystack == null || needle == null)\\n            return -1;\\n        int l1 = haystack.length();\\n        int l2 = needle.length();\\n        for (int i = 0; i < l1-l2+1; i++) {\\n            int count = 0;\\n            while (count < l2 && haystack.charAt(i+count) == needle.charAt(count))\\n                count++;\\n            if (count == l2)\\n                return i;\\n        }\\n        return -1;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "       \\n    public int strStr1(String haystack, String needle) {\\n        return haystack.indexOf(needle);\\n    }\\n    \\n    public int strStr(String haystack, String needle) {\\n        if (haystack == null || needle == null)\\n            return -1;\\n        int l1 = haystack.length();\\n        int l2 = needle.length();\\n        for (int i = 0; i < l1-l2+1; i++) {\\n            int count = 0;\\n            while (count < l2 && haystack.charAt(i+count) == needle.charAt(count))\\n                count++;\\n            if (count == l2)\\n                return i;\\n        }\\n        return -1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3062925,
                "title": "easy-c-solution-two-line-code-easy-approach",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. I declared a variable \\'index\\' which is initialized to the value returned by the \\'find()\\' function. The \\'find()\\' function is called on the \\'haystack\\' string and the \\'needle\\' string is passed as an argument.\\n2. The \\'find()\\' function returns the index of the first occurrence of the \\'needle\\' string within the \\'haystack\\' string. If the \\'needle\\' string is not found within the \\'haystack\\' string, the function returns a special constant \\'string::npos\\'.\\n3. If \\'index\\' is not equal to \\'string::npos\\', it means that the \\'needle\\' is found, so the \\'index\\' is returned.\\n4. Else, -1 is returned, indicating that the \\'needle\\' is not found in the \\'haystack\\' string.\\n5. The \\'strStr()\\' function returns the index of the first occurrence of the \\'needle\\' string within the \\'haystack\\' string.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of this code is O(n) where n is the length of the haystack string. This is because the find function in the C++ STL library has an average time complexity of O(n).\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity is O(1) as it only uses a constant amount of additional memory.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        int index = haystack.find(needle);\\n        if(index != string::npos) return index;\\n        else return -1;\\n    }\\n};\\n```\\n\\n\\n\\n![Your paragraph text (1).png](https://assets.leetcode.com/users/images/ba810d33-7b2b-42d1-a6d4-b61e9f4d670c_1673947392.3588023.png)\\n",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        int index = haystack.find(needle);\\n        if(index != string::npos) return index;\\n        else return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 971852,
                "title": "python",
                "content": "Python, faster than 99.7%\\n\\n```\\nclass Solution(object):\\n    def strStr(self, haystack, needle):\\n        nl, ml = len(needle), len(haystack)\\n        if nl == 0:\\n            return nl\\n        if ml < nl:\\n            return -1\\n        for i in range(ml - nl + 1):\\n            if haystack[i:i+nl] == needle:\\n                return i\\n        return -1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def strStr(self, haystack, needle):\\n        nl, ml = len(needle), len(haystack)\\n        if nl == 0:\\n            return nl\\n        if ml < nl:\\n            return -1\\n        for i in range(ml - nl + 1):\\n            if haystack[i:i+nl] == needle:\\n                return i\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2724335,
                "title": "0ms-100-faster-java-solution",
                "content": "```\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n        return haystack.indexOf(needle);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n        return haystack.indexOf(needle);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 287974,
                "title": "go-0-ms-100-00-easy-code-3-ways",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# 1. Fast Code\\n```golang\\nfunc strStr(haystack string, needle string) int {\\n\\tif needle == \"\" {\\n\\t\\treturn 0\\n\\t}\\n\\th := len(haystack)\\n\\tn := len(needle)\\n\\tfor i := 0; i < h-n+1; i++ {\\n\\t\\tif haystack[i:i+n] == needle {\\n\\t\\t\\treturn i\\n\\t\\t}\\n\\t}\\n\\treturn -1\\n}\\n```\\n\\n# 2. Sample Code\\n\\n```golang\\nfunc strStrSample(haystack string, needle string) int {\\n\\treturn strings.Index(haystack, needle)\\n}\\n```\\n\\n# 3. Optimization Code\\n```golang\\nfunc strStrOptimize(haystack string, needle string) int {\\n\\th := len(haystack)\\n\\tn := len(needle)\\n\\tswitch {\\n\\tcase n == 0:\\n\\t\\treturn 0\\n\\tcase n == 1:\\n\\t\\tfor i := 0; i < h; i++ {\\n\\t\\t\\tif string(haystack[i]) == needle {\\n\\t\\t\\t\\treturn i\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn -1\\n\\tcase n == h:\\n\\t\\tif haystack == needle {\\n\\t\\t\\treturn 0\\n\\t\\t}\\n\\t\\treturn -1\\n\\tcase n > h:\\n\\t\\treturn -1\\n\\tdefault:\\n\\t\\tfor i := 0; i < h-n+1; i++ {\\n\\t\\t\\tif haystack[i:i+n] == needle {\\n\\t\\t\\t\\treturn i\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn -1\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```golang\\nfunc strStr(haystack string, needle string) int {\\n\\tif needle == \"\" {\\n\\t\\treturn 0\\n\\t}\\n\\th := len(haystack)\\n\\tn := len(needle)\\n\\tfor i := 0; i < h-n+1; i++ {\\n\\t\\tif haystack[i:i+n] == needle {\\n\\t\\t\\treturn i\\n\\t\\t}\\n\\t}\\n\\treturn -1\\n}\\n```\n```golang\\nfunc strStrSample(haystack string, needle string) int {\\n\\treturn strings.Index(haystack, needle)\\n}\\n```\n```golang\\nfunc strStrOptimize(haystack string, needle string) int {\\n\\th := len(haystack)\\n\\tn := len(needle)\\n\\tswitch {\\n\\tcase n == 0:\\n\\t\\treturn 0\\n\\tcase n == 1:\\n\\t\\tfor i := 0; i < h; i++ {\\n\\t\\t\\tif string(haystack[i]) == needle {\\n\\t\\t\\t\\treturn i\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn -1\\n\\tcase n == h:\\n\\t\\tif haystack == needle {\\n\\t\\t\\treturn 0\\n\\t\\t}\\n\\t\\treturn -1\\n\\tcase n > h:\\n\\t\\treturn -1\\n\\tdefault:\\n\\t\\tfor i := 0; i < h-n+1; i++ {\\n\\t\\t\\tif haystack[i:i+n] == needle {\\n\\t\\t\\t\\treturn i\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn -1\\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1216780,
                "title": "easy-95-47-faster-using-built-in-method",
                "content": "``` \\nvar strStr = function(haystack, needle) {\\n    if(!needle.length) return 0;\\n    if(!haystack.includes(needle)) return -1;\\n    return haystack.split(`${needle}`)[0].length;\\n};\\n```\\nFirst two lines use base cases, last line works as follows\\n\\n\\'dinosaur\\', \\'saur\\'\\n\\n\\'dinosaur\\'.split(\\'saur\\') returns [\\'dino\\']\\n\\nIndex 0 will always occur right before the first instance of the needle.\\n\\nReturning the length will provide us with the proper index of the first occurance since arrays and strings are 0 indexed.\\n\\nAnother example with repeated needles\\n\\n\\'bonobonobono\\', \\'ono\\'\\n\\'bonobonobono\\'.split(\\'ono\\') returns [\\'b\\',\\'b\\',\\'b\\']\\n[\\'b\\',\\'b\\',\\'b\\'][0].length returns index of 1",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "``` \\nvar strStr = function(haystack, needle) {\\n    if(!needle.length) return 0;\\n    if(!haystack.includes(needle)) return -1;\\n    return haystack.split(`${needle}`)[0].length;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 791914,
                "title": "simple-python-solution-using-split",
                "content": "def strStr(self, haystack: str, needle: str) -> int:\\n        if len(needle) == 0:\\n            return 0\\n        elif needle not in haystack:\\n            return -1\\n        else:\\n            return len(haystack.split(needle)[0])\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "def strStr(self, haystack: str, needle: str) -> int:\\n        if len(needle) == 0:\\n            return 0\\n        elif needle not in haystack:\\n            return -1\\n        else:\\n            return len(haystack.split(needle)[0])\\n",
                "codeTag": "Python3"
            },
            {
                "id": 3968304,
                "title": "java-runtime-0-ms-beats-100-00",
                "content": "# Intuition\\nMy approach to solving the problem involves implementing a simple string search algorithm, specifically a brute force method, to find the first occurrence of the \\'needle\\' string within the \\'haystack\\' string.\\n\\n# Approach\\nI will use a brute force approach to search for the \\'needle\\' string within the \\'haystack\\' string. The algorithm iterates through the \\'haystack\\' string, checking at each position if a substring of the same length as the \\'needle\\' matches the \\'needle\\' string. It does so by comparing the characters of the \\'haystack\\' substring with the corresponding characters of the \\'needle\\' string. If a match is found, the index of the starting position of the match is returned. If no match is found after iterating through the entire \\'haystack\\', -1 is returned.\\n\\nTo optimize the algorithm, if the remaining length of the \\'haystack\\' string is less than the length of the \\'needle\\', it is concluded that no match can be found. In this case, the loop terminates.\\n\\n\\n**!! For relatively small data sets, the chosen brute force approach is appropriate and straightforward for searching the \\'needle\\' string within the \\'haystack\\'. However, it\\'s important to note that as the size of your data set increases, this approach may become less efficient in terms of both time and performance. In scenarios where you are working with larger data sets, it\\'s advisable to explore more optimized string searching algorithms such as the Knuth-Morris-Pratt (KMP) or Boyer-Moore algorithms.**\\n\\n# Complexity\\n- Time complexity: O((hayLen - needleLen + 1) * needleLen)\\n  The algorithm iterates through the \\'haystack\\' string, and for each position, it performs a comparison between a substring of length \\'needleLen\\' and the \\'needle\\' string. The maximum number of iterations depends on the difference in lengths between \\'haystack\\' and \\'needle\\', and each substring comparison requires \\'needleLen\\' time.\\n\\n- Space complexity: O(1)\\n  The algorithm employs a fixed amount of additional memory space for variables, ensuring that the space complexity remains constant.\\n\\n# Code\\n```java\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n        int hayLen = haystack.length();\\n        int needleLen = needle.length();\\n\\n        if (hayLen < needleLen) {\\n            return -1;\\n        }\\n\\n        for (int i = 0; i <= hayLen - needleLen; i++) {\\n            if (haystack.charAt(i) == needle.charAt(0)) {\\n                boolean found = true;\\n                for (int j = 1; j < needleLen; j++) {\\n                    if (haystack.charAt(i + j) != needle.charAt(j)) {\\n                        found = false;\\n                        break;\\n                    }\\n                }\\n                if (found) {\\n                    return i;\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n}\\n```\\n\\n![c0504eaf-5fb8-4a1d-a769-833262d1b86e_1674433591.3836212.webp](https://assets.leetcode.com/users/images/8a3b41d1-f0ca-472f-a9f7-8346b34a824e_1693297402.2918687.webp)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n        int hayLen = haystack.length();\\n        int needleLen = needle.length();\\n\\n        if (hayLen < needleLen) {\\n            return -1;\\n        }\\n\\n        for (int i = 0; i <= hayLen - needleLen; i++) {\\n            if (haystack.charAt(i) == needle.charAt(0)) {\\n                boolean found = true;\\n                for (int j = 1; j < needleLen; j++) {\\n                    if (haystack.charAt(i + j) != needle.charAt(j)) {\\n                        found = false;\\n                        break;\\n                    }\\n                }\\n                if (found) {\\n                    return i;\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1656830,
                "title": "solution-swift-implement-strstr",
                "content": "```swift\\nclass Solution {\\n    func strStr(_ haystack: String, _ needle: String) -> Int {\\n        let lnH = haystack.count, lnN = needle.count\\n        if lnN == 0 || haystack == needle { return 0 }\\n        guard lnH >= lnN else { return -1 }\\n        \\n        var idxH = haystack.startIndex\\n\\n        for i in 0...(lnH - lnN) {\\n            let idx = haystack.index(idxH, offsetBy: lnN)\\n            if haystack[idxH..<idx] == needle { return i }\\n            idxH = haystack.index(idxH, offsetBy: 1)\\n        }\\n        return -1\\n    }\\n}\\n```\\n\\n---\\n\\n<details>\\n<summary>\\n<img src=\"https://git.io/JDblm\" height=\"24\">\\n<b>TEST CASES</b>\\n</summary>\\n\\n<p><pre>\\n<b>Result:</b> Executed 3 tests, with 0 failures (0 unexpected) in 0.006 (0.007) seconds\\n</pre></p>\\n\\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.strStr(\"hello\", \"ll\")\\n        XCTAssertEqual(value, 2)\\n    }\\n    \\n    func test1() {\\n        let value = solution.strStr(\"aaaaa\", \"bba\")\\n        XCTAssertEqual(value, -1)\\n    }\\n    \\n    func test2() {\\n        let value = solution.strStr(\"\", \"\")\\n        XCTAssertEqual(value, 0)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n</details>",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func strStr(_ haystack: String, _ needle: String) -> Int {\\n        let lnH = haystack.count, lnN = needle.count\\n        if lnN == 0 || haystack == needle { return 0 }\\n        guard lnH >= lnN else { return -1 }\\n        \\n        var idxH = haystack.startIndex\\n\\n        for i in 0...(lnH - lnN) {\\n            let idx = haystack.index(idxH, offsetBy: lnN)\\n            if haystack[idxH..<idx] == needle { return i }\\n            idxH = haystack.index(idxH, offsetBy: 1)\\n        }\\n        return -1\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.strStr(\"hello\", \"ll\")\\n        XCTAssertEqual(value, 2)\\n    }\\n    \\n    func test1() {\\n        let value = solution.strStr(\"aaaaa\", \"bba\")\\n        XCTAssertEqual(value, -1)\\n    }\\n    \\n    func test2() {\\n        let value = solution.strStr(\"\", \"\")\\n        XCTAssertEqual(value, 0)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1317129,
                "title": "easy-c-solution-using-kmp-algorithm",
                "content": "**Time complexity :- O(n+m) where n=haystack length, m=needle length**\\n**Space complexity :- O(m)**\\n```\\nclass Solution\\n{\\npublic:\\n    // function to generate the LPS array\\n    vector<int>lpsGenerator(string &s)\\n    {\\n        int n=s.length(),i=1,j=0;\\n        vector<int>lps(n);\\n        lps[0]=0;\\n        while(i<n)\\n        {\\n            if(s[i]==s[j])\\n            {\\n                lps[i]=j+1;\\n                i++;\\n                j++;\\n            }\\n            else\\n            {\\n                if(j>0)\\n                {\\n                    j=lps[j-1];\\n                }\\n                else\\n                {\\n                    lps[i++]=0;\\n                }\\n            }\\n        }\\n        return lps;\\n    }\\n    int strStr(string haystack, string needle)\\n    {\\n        if(needle.length()==0)\\n        {\\n            return 0;\\n        }\\n        vector<int>lps=lpsGenerator(needle);\\n        int i=0,j=0,n=haystack.length(),m=needle.length();\\n        // i is pointing to haystack\\n        // j is pointing to needle\\n        while(i<n)\\n        {\\n            if(needle[j]==haystack[i])\\n            {\\n                i++;\\n                j++;\\n            }\\n            if(j==m)\\n            {\\n                return i-j;\\n            }\\n            else if(i<n && needle[j]!=haystack[i])\\n            {\\n                if(j>0)\\n                {\\n                    j=lps[j-1];\\n                }\\n                else\\n                {\\n                    i++;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\\n***Please upvote if you have got any help from my code. Thank you.***",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    // function to generate the LPS array\\n    vector<int>lpsGenerator(string &s)\\n    {\\n        int n=s.length(),i=1,j=0;\\n        vector<int>lps(n);\\n        lps[0]=0;\\n        while(i<n)\\n        {\\n            if(s[i]==s[j])\\n            {\\n                lps[i]=j+1;\\n                i++;\\n                j++;\\n            }\\n            else\\n            {\\n                if(j>0)\\n                {\\n                    j=lps[j-1];\\n                }\\n                else\\n                {\\n                    lps[i++]=0;\\n                }\\n            }\\n        }\\n        return lps;\\n    }\\n    int strStr(string haystack, string needle)\\n    {\\n        if(needle.length()==0)\\n        {\\n            return 0;\\n        }\\n        vector<int>lps=lpsGenerator(needle);\\n        int i=0,j=0,n=haystack.length(),m=needle.length();\\n        // i is pointing to haystack\\n        // j is pointing to needle\\n        while(i<n)\\n        {\\n            if(needle[j]==haystack[i])\\n            {\\n                i++;\\n                j++;\\n            }\\n            if(j==m)\\n            {\\n                return i-j;\\n            }\\n            else if(i<n && needle[j]!=haystack[i])\\n            {\\n                if(j>0)\\n                {\\n                    j=lps[j-1];\\n                }\\n                else\\n                {\\n                    i++;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 978984,
                "title": "python-rabin-karp",
                "content": "The value of using Rabin-Karp is in having a rolling hash whose value we can update in `O(1)` time. Instead of comparing `needle` char-by-char with all of the substrings of `haystack`, we compute the hash of each next substring and compare to the hash of the `needle`. If the hashes match, we do the char-by-char comparison to make sure that there\\'s no hash collision happening (two strings having the same hash while being actually different). If we don\\'t have any collisions (or have a few) then runtime will be ~`O(N)`. Worst case, if we have collisions at each iteration and needle is the last substring of haystack, then the runtime will be `O(NM)`. Where `N` is the lenght of the `haystack` and `M` is the length of `needle`.\\n\\n```\\ndef strStr(self, haystack: str, needle: str) -> int:\\n\\tif needle == \\'\\': return 0\\n\\tN = len(needle)\\n\\tbase = 26  # base of the polynomial hash\\n\\tprime_mod = 101  # to avoid hash overflow, doesn\\'t have to be prime number\\n\\n\\tdef charcode(ch):\\n\\t\\treturn ord(ch) - ord(\\'a\\')\\n\\n\\tdef myhash(s):\\n\\t\\t\\'\\'\\'polynomial hash of a string\\'\\'\\'\\n\\t\\tmy_hash = 0\\n\\t\\tfor ch in s:\\n\\t\\t\\tmy_hash = (charcode(ch) + my_hash * base) % prime_mod\\n\\t\\treturn my_hash\\n\\n\\tneedle_hash = myhash(needle)\\n\\trolling_hash = myhash(haystack[:N-1])\\n\\n\\tfirst_pow = base ** (N-1)  # the first digit\\'s base as a const, to avoid recomputation\\n\\n\\tfor i in range(N-1, len(haystack)):\\n\\t\\trolling_hash = (rolling_hash * base + charcode(haystack[i])) % prime_mod\\n\\t\\tif rolling_hash == needle_hash and needle == haystack[i+1-N:i+1]: return i+1-N\\n\\t\\trolling_hash = (rolling_hash - charcode(haystack[i+1-N]) * first_pow) % prime_mod\\n\\n\\treturn -1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef strStr(self, haystack: str, needle: str) -> int:\\n\\tif needle == \\'\\': return 0\\n\\tN = len(needle)\\n\\tbase = 26  # base of the polynomial hash\\n\\tprime_mod = 101  # to avoid hash overflow, doesn\\'t have to be prime number\\n\\n\\tdef charcode(ch):\\n\\t\\treturn ord(ch) - ord(\\'a\\')\\n\\n\\tdef myhash(s):\\n\\t\\t\\'\\'\\'polynomial hash of a string\\'\\'\\'\\n\\t\\tmy_hash = 0\\n\\t\\tfor ch in s:\\n\\t\\t\\tmy_hash = (charcode(ch) + my_hash * base) % prime_mod\\n\\t\\treturn my_hash\\n\\n\\tneedle_hash = myhash(needle)\\n\\trolling_hash = myhash(haystack[:N-1])\\n\\n\\tfirst_pow = base ** (N-1)  # the first digit\\'s base as a const, to avoid recomputation\\n\\n\\tfor i in range(N-1, len(haystack)):\\n\\t\\trolling_hash = (rolling_hash * base + charcode(haystack[i])) % prime_mod\\n\\t\\tif rolling_hash == needle_hash and needle == haystack[i+1-N:i+1]: return i+1-N\\n\\t\\trolling_hash = (rolling_hash - charcode(haystack[i+1-N]) * first_pow) % prime_mod\\n\\n\\treturn -1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1545167,
                "title": "java-bruteforce-tc-o-m-n-sc-o-1-kmp-tc-o-m-n-sc-o-n-two-solutions",
                "content": "**Brute Force string matching**\\n\\n```java\\n/**\\n * Brute Force string matching.\\n *\\n * Time Complexity: O(M * N)\\n *\\n * Space Complexity: O(1)\\n *\\n * M = Length of haystack string. N = length of needle string.\\n */\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n        if (haystack == null || needle == null) {\\n            throw new IllegalArgumentException(\"Input strings are null\");\\n        }\\n\\n        int hLen = haystack.length();\\n        int nLen = needle.length();\\n        if (nLen == 0) {\\n            return 0;\\n        }\\n        if (hLen < nLen) {\\n            return -1;\\n        }\\n\\n        for (int i = 0; i <= hLen - nLen; i++) {\\n            int j = 0;\\n            while (j < nLen && haystack.charAt(i + j) == needle.charAt(j)) {\\n                j++;\\n            }\\n            if (j == nLen) {\\n                return i;\\n            }\\n        }\\n\\n        return -1;\\n    }\\n}\\n```\\n\\n---\\n**Using KMP Algorithm**\\n\\n```java\\n/**\\n * Using KMP Algorithm\\n *\\n * Time Complexity: O(M + N). O(N) to create lookup table. O(M) to find the\\n * needle in haystack.\\n *\\n * Space Complexity: O(N). This is required to save the lookup table.\\n *\\n * M = Length of haystack string. N = length of needle string.\\n */\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n        if (haystack == null || needle == null) {\\n            return -1;\\n        }\\n\\n        int nLen = needle.length();\\n        int hLen = haystack.length();\\n        if (nLen == 0) {\\n            return 0;\\n        }\\n        if (hLen == 0) {\\n            return -1;\\n        }\\n\\n        int[] table = kmpLookupTable(needle);\\n        int i = 0;\\n        int j = 0;\\n        while (i < hLen && j < nLen) {\\n            if (haystack.charAt(i) == needle.charAt(j)) {\\n                i++;\\n                j++;\\n            } else {\\n                if (j > 0) {\\n                    j = table[j - 1];\\n                } else {\\n                    i++;\\n                }\\n            }\\n        }\\n\\n        if (j == nLen) {\\n            return i - j;\\n        }\\n        return -1;\\n    }\\n\\n    private int[] kmpLookupTable(String s) {\\n        int[] table = new int[s.length()];\\n        int i = 1;\\n        int index = 0;\\n        while (i < s.length()) {\\n            if (s.charAt(i) == s.charAt(index)) {\\n                table[i] = index + 1;\\n                index++;\\n                i++;\\n            } else {\\n                if (index > 0) {\\n                    index = table[index - 1];\\n                } else {\\n                    table[i] = 0;\\n                    i++;\\n                }\\n            }\\n        }\\n        return table;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\n/**\\n * Brute Force string matching.\\n *\\n * Time Complexity: O(M * N)\\n *\\n * Space Complexity: O(1)\\n *\\n * M = Length of haystack string. N = length of needle string.\\n */\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n        if (haystack == null || needle == null) {\\n            throw new IllegalArgumentException(\"Input strings are null\");\\n        }\\n\\n        int hLen = haystack.length();\\n        int nLen = needle.length();\\n        if (nLen == 0) {\\n            return 0;\\n        }\\n        if (hLen < nLen) {\\n            return -1;\\n        }\\n\\n        for (int i = 0; i <= hLen - nLen; i++) {\\n            int j = 0;\\n            while (j < nLen && haystack.charAt(i + j) == needle.charAt(j)) {\\n                j++;\\n            }\\n            if (j == nLen) {\\n                return i;\\n            }\\n        }\\n\\n        return -1;\\n    }\\n}\\n```\n```java\\n/**\\n * Using KMP Algorithm\\n *\\n * Time Complexity: O(M + N). O(N) to create lookup table. O(M) to find the\\n * needle in haystack.\\n *\\n * Space Complexity: O(N). This is required to save the lookup table.\\n *\\n * M = Length of haystack string. N = length of needle string.\\n */\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n        if (haystack == null || needle == null) {\\n            return -1;\\n        }\\n\\n        int nLen = needle.length();\\n        int hLen = haystack.length();\\n        if (nLen == 0) {\\n            return 0;\\n        }\\n        if (hLen == 0) {\\n            return -1;\\n        }\\n\\n        int[] table = kmpLookupTable(needle);\\n        int i = 0;\\n        int j = 0;\\n        while (i < hLen && j < nLen) {\\n            if (haystack.charAt(i) == needle.charAt(j)) {\\n                i++;\\n                j++;\\n            } else {\\n                if (j > 0) {\\n                    j = table[j - 1];\\n                } else {\\n                    i++;\\n                }\\n            }\\n        }\\n\\n        if (j == nLen) {\\n            return i - j;\\n        }\\n        return -1;\\n    }\\n\\n    private int[] kmpLookupTable(String s) {\\n        int[] table = new int[s.length()];\\n        int i = 1;\\n        int index = 0;\\n        while (i < s.length()) {\\n            if (s.charAt(i) == s.charAt(index)) {\\n                table[i] = index + 1;\\n                index++;\\n                i++;\\n            } else {\\n                if (index > 0) {\\n                    index = table[index - 1];\\n                } else {\\n                    table[i] = 0;\\n                    i++;\\n                }\\n            }\\n        }\\n        return table;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 595243,
                "title": "c-3-solutions-naive-kmp-and-z-algorithm",
                "content": "I will be providing with 3 solutions. The first one is a naive one, which actually runs quite good. Then I will be providing the linear time kmp and z-algorithm ones.\\n\\n**Solution One**\\n\\nThis is a `Naive` implementation. Just check all substrings of length `m` in the haystack. If you get a substring, then just return the first index of the substring. I think the code is quite self explanatory.\\n\\n```\\nint strStr(string haystack, string needle) {\\n\\tint n=haystack.length(), m=needle.length();\\n\\tfor(int i=0;i<n-m+1;i++){\\n\\t\\tint j=0;\\n\\t\\twhile(j<m){\\n\\t\\t\\tif(haystack[i+j]==needle[j]) j++;\\n\\t\\t\\telse break;\\n\\t\\t}\\n\\t\\tif(j==m) return i;\\n\\t}\\n\\treturn -1;\\n}\\n```\\n\\n*Time Complexity* - `O(m*(n-m+1))`\\n*Space Complexity* - `O(1)`\\n\\n**Solution Two**\\n\\nWe use the famous KMP string matching algorithm, which does this in linear time. We have to pre-process and construct a `lps` array, where `lps[i]` denotes longest proper prefix which is also a suffix.\\nFor more understanding of the KMP algo, follow these 3 links -\\n\\n1. [Geeks for Geeks KMP Algo](https://www.***.org/kmp-algorithm-for-pattern-searching/)\\n2. [A blog describing KMP](https://blogarithms.github.io/articles/2018-06/kmp-algorithm)\\n3. Tushar Roy\\'s video about KMP.\\n\\n```\\nclass Solution {\\npublic:\\n    // calculate the lps function\\n    vector<int> calc(string pat, int m)\\n    {\\n        vector<int> lps(m,0);\\n        int i=1, j=0;\\n        while(i<m){\\n            if(pat[i]==pat[j]){\\n                j++;\\n                lps[i++]=j;\\n            }\\n            else{\\n                if(j) j=lps[j-1];\\n                else lps[i++]=0;\\n            }\\n        }\\n        return lps;\\n    }\\n    int strStr(string haystack, string needle) {\\n        int n=haystack.length(), m=needle.length();\\n        if(m==0) return 0;\\n        vector<int> lps = calc(needle, m);\\n        int i=0,j=0;\\n        while(i<n && j<m){\\n            if(haystack[i]==needle[j]){\\n                i++;\\n                j++;\\n            }\\n            if(j==m) return i-j; // since we are returning the first valid index, we just return i-j. If we had to return all valid indices, then we would have to do j=lps[j-1] after this step, since pattern can repeat, and the new pattern may already have started.\\n            else if(i<n && j<m && haystack[i]!=needle[j]){\\n                if(j) j=lps[j-1];\\n                else i++;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\\n\\n*Time Complexity* - `O(m+n)`\\n*Space Complexity* - `O(m)`\\n\\n**Solution Three**\\n\\nWe use the famous `Z Algorithm`, which is also a linear pattern matching algorithm. For this we have to construct a `Z-array` where `Z[i]` is equal to the longest substring starting from `S[i]`, which is also a prefix of the original string. We have to concatenate the pattern and the string together, along with a \\'$\\'.\\nFor more info, follow these three links -\\n\\n1. [Geeks for Geeks Z Algo](https://www.***.org/z-algorithm-linear-time-pattern-searching-algorithm/)\\n2. [HackerEarth Tutorial Z Algo](https://www.hackerearth.com/practice/algorithms/string-algorithm/z-algorithm/tutorial/)\\n3. Tushar Roy\\'s video about Z Algo.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> calc(string pat) // calculates the Z-array\\n    {\\n        int n=pat.length();\\n        vector<int> z(n,0);\\n        int L=0, R=0, i=1;\\n        for(;i<n;i++){\\n            if(i>R){  // i is not in the Z-box.\\n                L=R=i;\\n                while(R<n && pat[R-L]==pat[R]) R++;\\n                z[i]=R-L;\\n                R--;\\n            }\\n            else{\\n                int k=i-L;\\n                if(z[k]<R-i+1) z[i]=z[k];\\n                else{\\n                    L=i;\\n                    while(R<n && pat[R-L]==pat[R]) R++;\\n                    z[i]=R-L;\\n                    R--;\\n                }\\n            }\\n        }\\n        return z;\\n    }\\n    \\n    int strStr(string haystack, string needle) {\\n        int n=haystack.length(), m=needle.length();\\n        if(m==0) return 0;\\n        string res=needle+\"$\"+haystack;   // we find the z array for [pat + \\'$\\' + text]\\n        vector<int> z=calc(res);\\n        for(int i=0;i<res.length();i++){\\n            if(z[i]==m) return i-m-1;\\n        }\\n        return -1;\\n    }\\n};\\n```\\n\\n*Time Complexity* - `O(m+n)`\\n*Space Complexity* - `O(m+n)`\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nint strStr(string haystack, string needle) {\\n\\tint n=haystack.length(), m=needle.length();\\n\\tfor(int i=0;i<n-m+1;i++){\\n\\t\\tint j=0;\\n\\t\\twhile(j<m){\\n\\t\\t\\tif(haystack[i+j]==needle[j]) j++;\\n\\t\\t\\telse break;\\n\\t\\t}\\n\\t\\tif(j==m) return i;\\n\\t}\\n\\treturn -1;\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    // calculate the lps function\\n    vector<int> calc(string pat, int m)\\n    {\\n        vector<int> lps(m,0);\\n        int i=1, j=0;\\n        while(i<m){\\n            if(pat[i]==pat[j]){\\n                j++;\\n                lps[i++]=j;\\n            }\\n            else{\\n                if(j) j=lps[j-1];\\n                else lps[i++]=0;\\n            }\\n        }\\n        return lps;\\n    }\\n    int strStr(string haystack, string needle) {\\n        int n=haystack.length(), m=needle.length();\\n        if(m==0) return 0;\\n        vector<int> lps = calc(needle, m);\\n        int i=0,j=0;\\n        while(i<n && j<m){\\n            if(haystack[i]==needle[j]){\\n                i++;\\n                j++;\\n            }\\n            if(j==m) return i-j; // since we are returning the first valid index, we just return i-j. If we had to return all valid indices, then we would have to do j=lps[j-1] after this step, since pattern can repeat, and the new pattern may already have started.\\n            else if(i<n && j<m && haystack[i]!=needle[j]){\\n                if(j) j=lps[j-1];\\n                else i++;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> calc(string pat) // calculates the Z-array\\n    {\\n        int n=pat.length();\\n        vector<int> z(n,0);\\n        int L=0, R=0, i=1;\\n        for(;i<n;i++){\\n            if(i>R){  // i is not in the Z-box.\\n                L=R=i;\\n                while(R<n && pat[R-L]==pat[R]) R++;\\n                z[i]=R-L;\\n                R--;\\n            }\\n            else{\\n                int k=i-L;\\n                if(z[k]<R-i+1) z[i]=z[k];\\n                else{\\n                    L=i;\\n                    while(R<n && pat[R-L]==pat[R]) R++;\\n                    z[i]=R-L;\\n                    R--;\\n                }\\n            }\\n        }\\n        return z;\\n    }\\n    \\n    int strStr(string haystack, string needle) {\\n        int n=haystack.length(), m=needle.length();\\n        if(m==0) return 0;\\n        string res=needle+\"$\"+haystack;   // we find the z array for [pat + \\'$\\' + text]\\n        vector<int> z=calc(res);\\n        for(int i=0;i<res.length();i++){\\n            if(z[i]==m) return i-m-1;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3456653,
                "title": "beats-97-46-7-145-top-interview-question",
                "content": "# Intuition\\n*If we can find the length of the needle then we can use that as the window size and use the sliding windows approach to solve this problem*\\n\\n# Approach\\nThis is a Python function that implements the \"strstr\" function, which searches for a substring within a larger string. The function takes two string arguments, `haystack` and `needle`, and returns the index of the first occurrence of the `needle` in the `haystack`, or `-1` if the `needle` is not found.\\n\\nHere\\'s a step-by-step explanation of how the code works:\\n\\n1. The function starts by checking if `needle` is equal to `haystack`. If it is, then `needle` is a substring of `haystack` and its starting index is 0. In this case, the function returns 0.\\n\\n2. If `needle` is not equal to `haystack`, the function initializes two variables: `i`, which represents the starting index of a substring of `haystack`, and `j`, which represents the ending index of that substring. Initially, `i` is set to 0 and `j` is set to the length of `needle`.\\n\\n3. The function then enters a loop that continues until `j` is greater than the length of `haystack`. In each iteration of the loop, the function extracts a substring of `haystack` that starts at index `i` and ends at index `j - 1`. This substring is stored in a variable called `currentNeedle`.\\n\\n4. The function then compares `currentNeedle` with `needle`. If they are equal, it means that `needle` is a substring of `haystack` starting at index `i`. The function returns `i`.\\n\\n5. If `currentNeedle` is not equal to `needle`, the function increments `i` and `j` by 1 and continues with the next iteration of the loop.\\n\\n6. If the loop completes without finding a match for `needle`, the function returns -1.\\n\\nOverall, this function provides a simple and efficient way to search for substrings within a larger string in Python.\\n\\n# Complexity\\n- Time complexity:\\nO(mn)\\n\\n- Space complexity:\\nO(n)\\n\\n\\n\\nThe `time complexity of this function is O(mn)`, where `m` is the length of `haystack` and `n` is the length of `needle`. This is because in the worst case scenario, we need to compare every substring of `haystack` of length `n` with `needle`.\\n\\nThe space complexity of this function is O(n), because we are using a slicing operation `haystack[i:j]` which return a copy of substring, Which can be of size `n`.\\n\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        if needle == haystack:\\n            return 0\\n        i = 0\\n        j = len(needle)\\n        while j <= len(haystack):\\n            currentNeedle = haystack[i:j]\\n            if currentNeedle == needle:\\n                return i\\n            i += 1\\n            j += 1\\n        return -1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        if needle == haystack:\\n            return 0\\n        i = 0\\n        j = len(needle)\\n        while j <= len(haystack):\\n            currentNeedle = haystack[i:j]\\n            if currentNeedle == needle:\\n                return i\\n            i += 1\\n            j += 1\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2920522,
                "title": "solution",
                "content": "```\\ndef strStr(self, haystack: str, needle: str) -> int:\\n    needle_len = len(needle)\\n    for i in range(len(haystack)):\\n        if haystack[i:i+needle_len] == needle:\\n            return i\\n    return -1\\n```",
                "solutionTags": [],
                "code": "```\\ndef strStr(self, haystack: str, needle: str) -> int:\\n    needle_len = len(needle)\\n    for i in range(len(haystack)):\\n        if haystack[i:i+needle_len] == needle:\\n            return i\\n    return -1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2498948,
                "title": "c-easy-solution-beginner-friendly",
                "content": "```\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        int m = haystack.size(), n = needle.size();\\n        for (int i = 0; i <= m - n; i++) {\\n            int j = 0;\\n            for (; j < n; j++) {\\n                if (haystack[i + j] != needle[j]) {\\n                    break;\\n                }\\n            }\\n            if (j == n) {\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\\n**Please upvote if it was helpful for you, thank you!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        int m = haystack.size(), n = needle.size();\\n        for (int i = 0; i <= m - n; i++) {\\n            int j = 0;\\n            for (; j < n; j++) {\\n                if (haystack[i + j] != needle[j]) {\\n                    break;\\n                }\\n            }\\n            if (j == n) {\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 550965,
                "title": "easy-o-m-n-js-solution",
                "content": "```\\nvar strStr = function(haystack, needle) {\\n    if (needle.length == 0) return 0;\\n    for (let i = 0; i < haystack.length; i++) {\\n        let k = i, j = 0;\\n        while (haystack[k] == needle[j] && j < needle.length) {\\n            k++, j++;\\n        }\\n        if (j == needle.length) return i;\\n    }\\n    return -1; // couldn\\'t find needle in haystack\\n    // Time Complexity: O(m*n)\\n    // Space Complexity: O(1)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar strStr = function(haystack, needle) {\\n    if (needle.length == 0) return 0;\\n    for (let i = 0; i < haystack.length; i++) {\\n        let k = i, j = 0;\\n        while (haystack[k] == needle[j] && j < needle.length) {\\n            k++, j++;\\n        }\\n        if (j == needle.length) return i;\\n    }\\n    return -1; // couldn\\'t find needle in haystack\\n    // Time Complexity: O(m*n)\\n    // Space Complexity: O(1)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 116860,
                "title": "javascript-solution-beats-100",
                "content": "I used substring to replace the comparision letter by letter.\n![image](https://s3-lc-upload.s3.amazonaws.com/users/ruinan/image_1519696100.png)\n\n```javascript\nvar strStr = function(haystack, needle) {\n    if (haystack === needle || needle === \"\") {\n        return 0;\n    }\n    for (let i = 0; i < haystack.length; i++) {\n        if (haystack[i] === needle[0]) {\n            let temp = haystack.substring(i, i + needle.length);\n            if (temp === needle) {\n                return i;\n            }\n        }\n    }\n    return -1;\n};\n```",
                "solutionTags": [],
                "code": "```javascript\nvar strStr = function(haystack, needle) {\n    if (haystack === needle || needle === \"\") {\n        return 0;\n    }\n    for (let i = 0; i < haystack.length; i++) {\n        if (haystack[i] === needle[0]) {\n            let temp = haystack.substring(i, i + needle.length);\n            if (temp === needle) {\n                return i;\n            }\n        }\n    }\n    return -1;\n};\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 12982,
                "title": "3-different-solutions-15-8-1-lines-c",
                "content": "**Solution 1**\\n\\nBrute force, simple and easy. \\n\\nTime complexity: O(n*m)\\nSpace comlexity: O(1)\\nRun time: 109 ms\\n```\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        if(needle.size() == 0) return 0;\\n        for(int i = 0; i < haystack.size(); i++)\\n            if(haystack[i] == needle[0] && isEqual(haystack.substr(i), needle)) return i;\\n        return -1;\\n    }\\n    \\n    bool isEqual(string s1, string s2){\\n        if(s1.size() < s2.size()) return false;\\n        for(int i = 0; i < s2.size(); i++)\\n            if(s1[i] != s2[i]) return false;\\n        return true;\\n    }\\n};\\n```\\nOr move isEqual() function inside.\\n```\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        if(needle.size() == 0) return 0;\\n        for(int i = 0; i < haystack.size(); i++){\\n            int j = 0;\\n            for(;j < needle.size(); j++){\\n                if(i + j == haystack.size()) return -1;\\n                if(haystack[i + j] != needle[j]) break;\\n            }\\n            if(j == needle.size()) return i;\\n        }\\n        return -1;\\n    }\\n};\\n```\\n***\\n**Solution 2** \\n\\nIn BF solution, we compare two strings everytime we meet the charactor `needle[0]`, which can cause a lot of unnecessary calculations. Is there a way to \"shrink\" the candidate substrings?\\n\\nWe can use a hash table to count the number of occurrence of `char`s in **needle**, and only jump to comparison when substring in **haystack** has the same `char`s and occurrence with needle.\\n\\nIf you are still not clear in what I explained, here is a post may help you understand the idea - [Here is a 10-line template that can solve most 'substring' problems](https://discuss.leetcode.com/topic/30941/here-is-a-10-line-template-that-can-solve-most-substring-problems).\\n\\nTime complexity: O(n)\\nSpace complexity: O(n)\\nRun time: 6 ms\\n```\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        if(needle.size() == 0) return 0;\\n        unordered_map<char, int>m;\\n        for(auto x: needle) m[x]++;\\n        int count = needle.size();\\n        int begin = 0, end = 0;\\n        while(end < haystack.size()){\\n            if(m[haystack[end++]]-- > 0) count--;\\n            if(count == 0){\\n                int i = begin, j = 0;\\n                while(j < needle.size() && haystack[i] == needle[j]) i++, j++;\\n                if(j == needle.size()) return begin;\\n            }\\n            if(end - begin == needle.size() && m[haystack[begin++]]++ >= 0) count++;\\n        }\\n        return -1;\\n    }\\n};\\n```\\n***\\n**Solution 3** \\n\\nFinally, a \"cheat\" solution.\\n\\nTime complexity: O(n)\\nSpace complexity: O(1)  (not sure about that, correct me if I'm wrong)\\nRun time: 6 ms\\n```\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        return haystack.find(needle);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        if(needle.size() == 0) return 0;\\n        for(int i = 0; i < haystack.size(); i++)\\n            if(haystack[i] == needle[0] && isEqual(haystack.substr(i), needle)) return i;\\n        return -1;\\n    }\\n    \\n    bool isEqual(string s1, string s2){\\n        if(s1.size() < s2.size()) return false;\\n        for(int i = 0; i < s2.size(); i++)\\n            if(s1[i] != s2[i]) return false;\\n        return true;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        if(needle.size() == 0) return 0;\\n        for(int i = 0; i < haystack.size(); i++){\\n            int j = 0;\\n            for(;j < needle.size(); j++){\\n                if(i + j == haystack.size()) return -1;\\n                if(haystack[i + j] != needle[j]) break;\\n            }\\n            if(j == needle.size()) return i;\\n        }\\n        return -1;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        if(needle.size() == 0) return 0;\\n        unordered_map<char, int>m;\\n        for(auto x: needle) m[x]++;\\n        int count = needle.size();\\n        int begin = 0, end = 0;\\n        while(end < haystack.size()){\\n            if(m[haystack[end++]]-- > 0) count--;\\n            if(count == 0){\\n                int i = begin, j = 0;\\n                while(j < needle.size() && haystack[i] == needle[j]) i++, j++;\\n                if(j == needle.size()) return begin;\\n            }\\n            if(end - begin == needle.size() && m[haystack[begin++]]++ >= 0) count++;\\n        }\\n        return -1;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        return haystack.find(needle);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3512825,
                "title": "c-java-python-javascript-easy-with-explanation",
                "content": "# Intuition:\\nThe problem requires us to find the index of the first occurrence of the needle string in the haystack string. We can solve this problem by checking each substring of the haystack that has the same length as the needle, and compare it with the needle to see if they match. If a match is found, return the starting index of the substring, otherwise continue checking the next substring. If no match is found, return -1.\\n\\n# Approach:\\n1. Calculate the length of the haystack and needle strings.\\n2. If the length of the needle is 0, return 0.\\n3. Use a loop to check each substring of the haystack that has the same length as the needle, starting from the first character of the haystack.\\n4. Inside the loop, use another loop to compare each character of the substring with the corresponding character of the needle. If a character doesn\\'t match, break the loop and move to the next substring.\\n5. If all characters match, return the starting index of the substring.\\n6. If no match is found, return -1.\\n\\n# Complexity\\n- Time Complexity: O((n-m+1)*m) = O(n*m)\\n\\n     - Note - In the worst-case scenario, we would have to check all possible substrings of the haystack string that have the same length as the needle string. There are (n-m+1) such substrings. For each substring, we need to compare each character with the corresponding character in the needle string, which takes O(m) time. Therefore, the total time complexity would be (n-m+1)m, which can be simplified to O(nm) since n and m are both variables that can change.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space Complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n---\\n# C++\\n```\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        int n = haystack.length();\\n        int m = needle.length();\\n        \\n        if (m == 0) return 0; // empty needle\\n        \\n        for (int i = 0; i <= n - m; i++) {\\n            bool found = true;\\n            for (int j = 0; j < m; j++) {\\n                if (haystack[i+j] != needle[j]) {\\n                    found = false;\\n                    break;\\n                }\\n            }\\n            if (found) return i;\\n        }\\n        return -1; // needle not found\\n    }\\n};\\n```\\n\\n---\\n# Java\\n```\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n        int n = haystack.length();\\n        int m = needle.length();\\n        \\n        if (m == 0) return 0; // empty needle\\n        \\n        for (int i = 0; i <= n - m; i++) {\\n            boolean found = true;\\n            for (int j = 0; j < m; j++) {\\n                if (haystack.charAt(i + j) != needle.charAt(j)) {\\n                    found = false;\\n                    break;\\n                }\\n            }\\n            if (found) return i;\\n        }\\n        return -1; // needle not found\\n    }\\n}\\n\\n```\\n\\n---\\n# Python\\n```\\nclass Solution(object):\\n    def strStr(self, haystack, needle):\\n        n = len(haystack)\\n        m = len(needle)\\n        \\n        if m == 0:\\n            return 0  # empty needle\\n        \\n        for i in range(n - m + 1):\\n            found = True\\n            for j in range(m):\\n                if haystack[i + j] != needle[j]:\\n                    found = False\\n                    break\\n            if found:\\n                return i\\n        return -1  # needle not found\\n\\n\\n```\\n\\n---\\n\\n# JavaScript\\n```\\nvar strStr = function(haystack, needle) {\\n    let n = haystack.length;\\n    let m = needle.length;\\n    \\n    if (m === 0) return 0; // empty needle\\n    \\n    for (let i = 0; i <= n - m; i++) {\\n        let found = true;\\n        for (let j = 0; j < m; j++) {\\n            if (haystack[i + j] !== needle[j]) {\\n                found = false;\\n                break;\\n            }\\n        }\\n        if (found) return i;\\n    }\\n    return -1; // needle not found\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        int n = haystack.length();\\n        int m = needle.length();\\n        \\n        if (m == 0) return 0; // empty needle\\n        \\n        for (int i = 0; i <= n - m; i++) {\\n            bool found = true;\\n            for (int j = 0; j < m; j++) {\\n                if (haystack[i+j] != needle[j]) {\\n                    found = false;\\n                    break;\\n                }\\n            }\\n            if (found) return i;\\n        }\\n        return -1; // needle not found\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n        int n = haystack.length();\\n        int m = needle.length();\\n        \\n        if (m == 0) return 0; // empty needle\\n        \\n        for (int i = 0; i <= n - m; i++) {\\n            boolean found = true;\\n            for (int j = 0; j < m; j++) {\\n                if (haystack.charAt(i + j) != needle.charAt(j)) {\\n                    found = false;\\n                    break;\\n                }\\n            }\\n            if (found) return i;\\n        }\\n        return -1; // needle not found\\n    }\\n}\\n\\n```\n```\\nclass Solution(object):\\n    def strStr(self, haystack, needle):\\n        n = len(haystack)\\n        m = len(needle)\\n        \\n        if m == 0:\\n            return 0  # empty needle\\n        \\n        for i in range(n - m + 1):\\n            found = True\\n            for j in range(m):\\n                if haystack[i + j] != needle[j]:\\n                    found = False\\n                    break\\n            if found:\\n                return i\\n        return -1  # needle not found\\n\\n\\n```\n```\\nvar strStr = function(haystack, needle) {\\n    let n = haystack.length;\\n    let m = needle.length;\\n    \\n    if (m === 0) return 0; // empty needle\\n    \\n    for (let i = 0; i <= n - m; i++) {\\n        let found = true;\\n        for (let j = 0; j < m; j++) {\\n            if (haystack[i + j] !== needle[j]) {\\n                found = false;\\n                break;\\n            }\\n        }\\n        if (found) return i;\\n    }\\n    return -1; // needle not found\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1022670,
                "title": "c-faster-than-100-with-single-loop",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint strStr(string haystack, string needle) {\\n\\t\\t\\tint needle_len = needle.length();\\n\\t\\t\\tint haystack_len = haystack.length();\\n\\t\\t\\tif(needle_len==0){\\n\\t\\t\\t\\treturn 0;\\n\\t\\t\\t}\\n\\t\\t\\tint j = 0;\\n\\t\\t\\tfor(int i = 0 ; i < haystack_len ; i++){\\n\\n\\t\\t\\t\\tif(haystack[i] == needle[j]){\\n\\t\\t\\t\\t\\tj++;\\n\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\ti = i-j;\\n\\t\\t\\t\\t\\tj = 0;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(j==needle_len){\\n\\t\\t\\t\\t\\treturn i - j +1 ;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\t\\t\\treturn -1;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint strStr(string haystack, string needle) {\\n\\t\\t\\tint needle_len = needle.length();\\n\\t\\t\\tint haystack_len = haystack.length();\\n\\t\\t\\tif(needle_len==0){\\n\\t\\t\\t\\treturn 0;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3647846,
                "title": "javascript-easy-solution-no-built-in-methods",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {string} haystack\\n * @param {string} needle\\n * @return {number}\\n */\\nvar strStr = function(haystack, needle) {\\n    let k=0\\n    for(let i=0;i<haystack.length;i++){\\n        if(haystack[i]==needle[k]){\\n            k++;\\n            if(k==needle.length){\\n                return i-(k-1)\\n            }\\n        }else{\\n            i=i-(k)\\n            k=0;\\n        }\\n    }\\n    return -1\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} haystack\\n * @param {string} needle\\n * @return {number}\\n */\\nvar strStr = function(haystack, needle) {\\n    let k=0\\n    for(let i=0;i<haystack.length;i++){\\n        if(haystack[i]==needle[k]){\\n            k++;\\n            if(k==needle.length){\\n                return i-(k-1)\\n            }\\n        }else{\\n            i=i-(k)\\n            k=0;\\n        }\\n    }\\n    return -1\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1498029,
                "title": "rabin-karp-o-n-q-m-extension-to-find-all-occurances-python",
                "content": "Code is explained in comments below...\\n```\\nimport functools\\nimport random\\n\\n\\nclass Solution(object):\\n    \\n    # Pick a random hash function from a universal family with a small collision probability |pattern| / p.\\n    p = 1000000007\\n    x = random.randint(1, p - 1)\\n    \\n    def strStr(self, haystack, needle):\\n        \\n        # Empty pattern edge case.\\n        if needle == \"\":\\n            return 0\\n        \\n        # Find all occurances of pattern and return 1st (extended to \"find all\" by dropping [0]).\\n        positions = self.rabin_karp(pattern=needle, text=haystack)\\n        return -1 if not positions else positions[0]\\n    \\n    @classmethod\\n    def rabin_karp(cls, pattern, text):\\n        \"\"\"Find all occurances of pattern in text in O(|text| + (num_occurances + 1)*|pattern|).\"\"\"\\n        positions = []\\n        \\n        # Precompute hash of pattern and x^|pattern| in O(|pattern|).\\n        x_p = functools.reduce(lambda aggregate, _: (aggregate * cls.x) % cls.p, range(len(pattern)), 1)\\n        pattern_hash = cls.poly_hash(s=pattern)\\n        \\n        # Compute rolling_hash once and check edge case for position = 0 in O(|pattern|).\\n        rolling_hash = cls.poly_hash(s=text[:len(pattern)])\\n        if rolling_hash == pattern_hash and text[:len(pattern)] == pattern:\\n            positions.append(0)\\n        \\n        # Iterate over O(|text|) positions, in each update rolling hash in O(1) using: H[k + 1] = H[k] * x + s[k + P] - s[k] * x^P (P = len(pattern)).\\n        for position in range(1, 1 + len(text) - len(pattern)):\\n            rolling_hash = (rolling_hash * cls.x + ord(text[position + len(pattern) - 1]) - ord(text[position - 1]) * x_p) % cls.p\\n            if rolling_hash == pattern_hash and text[position:position + len(pattern)] == pattern:  # O(1) unless hash match/collision, in which case O(|pattern|).\\n                positions.append(position)\\n        \\n        # Return positions of all occurances.\\n        return positions\\n        \\n    @classmethod\\n    def poly_hash(cls, s):\\n        \"\"\"Compute the polynomial hash H = sum(s[0] * x^n + ... + s[n] * x^0) % p where n = len(s) - 1.\"\"\"\\n        return functools.reduce(lambda aggregate, char: (aggregate * cls.x + ord(char)) % cls.p, s, 0)\\n\\n```",
                "solutionTags": [
                    "Python",
                    "String",
                    "Hash Function"
                ],
                "code": "```\\nimport functools\\nimport random\\n\\n\\nclass Solution(object):\\n    \\n    # Pick a random hash function from a universal family with a small collision probability |pattern| / p.\\n    p = 1000000007\\n    x = random.randint(1, p - 1)\\n    \\n    def strStr(self, haystack, needle):\\n        \\n        # Empty pattern edge case.\\n        if needle == \"\":\\n            return 0\\n        \\n        # Find all occurances of pattern and return 1st (extended to \"find all\" by dropping [0]).\\n        positions = self.rabin_karp(pattern=needle, text=haystack)\\n        return -1 if not positions else positions[0]\\n    \\n    @classmethod\\n    def rabin_karp(cls, pattern, text):\\n        \"\"\"Find all occurances of pattern in text in O(|text| + (num_occurances + 1)*|pattern|).\"\"\"\\n        positions = []\\n        \\n        # Precompute hash of pattern and x^|pattern| in O(|pattern|).\\n        x_p = functools.reduce(lambda aggregate, _: (aggregate * cls.x) % cls.p, range(len(pattern)), 1)\\n        pattern_hash = cls.poly_hash(s=pattern)\\n        \\n        # Compute rolling_hash once and check edge case for position = 0 in O(|pattern|).\\n        rolling_hash = cls.poly_hash(s=text[:len(pattern)])\\n        if rolling_hash == pattern_hash and text[:len(pattern)] == pattern:\\n            positions.append(0)\\n        \\n        # Iterate over O(|text|) positions, in each update rolling hash in O(1) using: H[k + 1] = H[k] * x + s[k + P] - s[k] * x^P (P = len(pattern)).\\n        for position in range(1, 1 + len(text) - len(pattern)):\\n            rolling_hash = (rolling_hash * cls.x + ord(text[position + len(pattern) - 1]) - ord(text[position - 1]) * x_p) % cls.p\\n            if rolling_hash == pattern_hash and text[position:position + len(pattern)] == pattern:  # O(1) unless hash match/collision, in which case O(|pattern|).\\n                positions.append(position)\\n        \\n        # Return positions of all occurances.\\n        return positions\\n        \\n    @classmethod\\n    def poly_hash(cls, s):\\n        \"\"\"Compute the polynomial hash H = sum(s[0] * x^n + ... + s[n] * x^0) % p where n = len(s) - 1.\"\"\"\\n        return functools.reduce(lambda aggregate, char: (aggregate * cls.x + ord(char)) % cls.p, s, 0)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 12936,
                "title": "javascript-solution",
                "content": "```\\nvar strStr = function(haystack, needle) {\\n  var needleLength = needle.length\\n  var haystackLength = haystack.length\\n\\n  if(needle === '' && haystack === '' ){\\n    return 0\\n  }\\n\\n  for(var i=0; i < haystack.length; i++){\\n    if (haystack.substr(i, needleLength) === needle){\\n      return i\\n    }\\n  }\\n  return -1\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvar strStr = function(haystack, needle) {\\n  var needleLength = needle.length\\n  var haystackLength = haystack.length\\n\\n  if(needle === '' && haystack === '' ){\\n    return 0\\n  }\\n\\n  for(var i=0; i < haystack.length; i++){\\n    if (haystack.substr(i, needleLength) === needle){\\n      return i\\n    }\\n  }\\n  return -1\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 13237,
                "title": "java-and-python-solution-using-kmp-with-o-m-n-time-complexity",
                "content": "The time complexity for this solution should be O(m + n). First of all, we generate the \"next\" array to show any possible duplicates of prefix and postfix within needle. Then we go through haystack. Every time we see a bad match, move j to next[j] and keep i in current position; otherwise, move both of them to next position.\\nPython version:\\n\\n    def strStr(self, haystack, needle):\\n        if haystack == None or needle == None:\\n            return -1\\n        #generate next array, need O(n) time\\n        i, j, m, n = -1, 0, len(haystack), len(needle)\\n        next = [-1] * n\\n        while j < n - 1:  \\n            #needle[k] stands for prefix, neelde[j] stands for postfix\\n            if i == -1 or needle[i] == needle[j]:   \\n                i, j = i + 1, j + 1\\n                next[j] = i\\n            else:\\n                i = next[i]\\n            print i,j,next[i],next[j]\\n        #check through the haystack using next, need O(m) time\\n        i = j = 0\\n        while i < m and j < n:\\n            if j == -1 or haystack[i] == needle[j]:\\n                i, j = i + 1, j + 1\\n            else:\\n                j = next[j]\\n        if j == n:\\n            return i - j\\n        return -1\\n\\nJava version:\\n\\n    public int strStr(String haystack, String needle){\\n        if (haystack == null || needle == null)\\n            return -1;\\n        //generate next array, need O(n) time\\n        int i = -1, j = 0, m = haystack.length(), n = needle.length();\\n        int[] next = new int[n];\\n        if (next.length > 0) \\n            next[0] = -1;\\n        while (j < n - 1) {\\n            if (i == -1 || needle.charAt(i) == needle.charAt(j))\\n                next[++j] = ++i;\\n            else \\n                i = next[i];\\n        }\\n        //check through the haystack using next, need O(m) time\\n        i = 0; j = 0;\\n        while (i < m && j < n) {\\n            if (j == -1 || haystack.charAt(i) == needle.charAt(j)) {\\n                i++;\\n                j++;\\n            }\\n            else \\n                j = next[j];\\n        }\\n        if (j == n)\\n            return i - j;\\n        return -1;\\n    }",
                "solutionTags": [
                    "Java",
                    "Python"
                ],
                "code": "The time complexity for this solution should be O(m + n). First of all, we generate the \"next\" array to show any possible duplicates of prefix and postfix within needle. Then we go through haystack. Every time we see a bad match, move j to next[j] and keep i in current position; otherwise, move both of them to next position.\\nPython version:\\n\\n    def strStr(self, haystack, needle):\\n        if haystack == None or needle == None:\\n            return -1\\n        #generate next array, need O(n) time\\n        i, j, m, n = -1, 0, len(haystack), len(needle)\\n        next = [-1] * n\\n        while j < n - 1:  \\n            #needle[k] stands for prefix, neelde[j] stands for postfix\\n            if i == -1 or needle[i] == needle[j]:   \\n                i, j = i + 1, j + 1\\n                next[j] = i\\n            else:\\n                i = next[i]\\n            print i,j,next[i],next[j]\\n        #check through the haystack using next, need O(m) time\\n        i = j = 0\\n        while i < m and j < n:\\n            if j == -1 or haystack[i] == needle[j]:\\n                i, j = i + 1, j + 1\\n            else:\\n                j = next[j]\\n        if j == n:\\n            return i - j\\n        return -1\\n\\nJava version:\\n\\n    public int strStr(String haystack, String needle){\\n        if (haystack == null || needle == null)\\n            return -1;\\n        //generate next array, need O(n) time\\n        int i = -1, j = 0, m = haystack.length(), n = needle.length();\\n        int[] next = new int[n];\\n        if (next.length > 0) \\n            next[0] = -1;\\n        while (j < n - 1) {\\n            if (i == -1 || needle.charAt(i) == needle.charAt(j))\\n                next[++j] = ++i;\\n            else \\n                i = next[i];\\n        }\\n        //check through the haystack using next, need O(m) time\\n        i = 0; j = 0;\\n        while (i < m && j < n) {\\n            if (j == -1 || haystack.charAt(i) == needle.charAt(j)) {\\n                i++;\\n                j++;\\n            }\\n            else \\n                j = next[j];\\n        }\\n        if (j == n)\\n            return i - j;\\n        return -1;\\n    }",
                "codeTag": "Python3"
            },
            {
                "id": 3249674,
                "title": "one-line-solution-java-100-0ms-2023",
                "content": "\\t  class Solution {\\n\\t\\t\\t public int strStr(String haystack, String needle) {\\n\\t\\t\\t\\t\\treturn  haystack.indexOf(needle);\\n\\t\\t\\t}\\n\\t\\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\t\\t\\t public int strStr(String haystack, String needle) {\\n\\t\\t\\t\\t\\treturn  haystack.indexOf(needle);\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2920525,
                "title": "solution",
                "content": "```\\n/**\\n * @param {string} haystack\\n * @param {string} needle\\n * @return {number}\\n */\\nvar strStr = function(haystack, needle) {\\n    let length = haystack.length;\\n    let targetLength = needle.length;\\n    \\n    // Loop through haystack\\n    for (let i = 0; i < length; i++) {\\n        \\n        // If the first character of both haystack and needle match, compare\\n        if (haystack.charAt(i) === needle.charAt(0)) {\\n            // Compares haystacks substring from i to needles length and compares\\n            if (haystack.substring(i,i+targetLength) === needle) return i;\\n        }\\n    }\\n    \\n    return -1;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {string} haystack\\n * @param {string} needle\\n * @return {number}\\n */\\nvar strStr = function(haystack, needle) {\\n    let length = haystack.length;\\n    let targetLength = needle.length;\\n    \\n    // Loop through haystack\\n    for (let i = 0; i < length; i++) {\\n        \\n        // If the first character of both haystack and needle match, compare\\n        if (haystack.charAt(i) === needle.charAt(0)) {\\n            // Compares haystacks substring from i to needles length and compares\\n            if (haystack.substring(i,i+targetLength) === needle) return i;\\n        }\\n    }\\n    \\n    return -1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1976007,
                "title": "a-clean-c-solution-using-substr-beats-100-runtime",
                "content": "```\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        if (needle.size() == 0 || \\n            haystack.size() == 0)\\n                return 0;\\n        \\n        if (needle.size() > haystack.size())\\n            return -1;\\n\\n        for (int i = 0; i < haystack.size(); ++i)\\n        {\\n            if (haystack[i] == needle[0])\\n            {\\n                if (haystack.substr(i, needle.size()) == needle)\\n                {\\n                    return i;\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        if (needle.size() == 0 || \\n            haystack.size() == 0)\\n                return 0;\\n        \\n        if (needle.size() > haystack.size())\\n            return -1;\\n\\n        for (int i = 0; i < haystack.size(); ++i)\\n        {\\n            if (haystack[i] == needle[0])\\n            {\\n                if (haystack.substr(i, needle.size()) == needle)\\n                {\\n                    return i;\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 119566,
                "title": "python-knuth-morris-pratt-algorithm",
                "content": "Knuth\\u2013Morris\\u2013Pratt algorithm implemented in Python.\\n```\\nclass Solution:\\n    def build_lps(self, pattern):\\n        \"\"\" Helper function for strStr.\\n        Returns longest proper suffix array for string pattern.\\n        Each lps_array[i] is the length of the longest proper prefix\\n        which is equal to suffix for pattern ending at character i.\\n        Proper means that whole string cannot be prefix or suffix.\\n\\n        Time complexity: O(m). Space complexity: O(1), where\\n        m is the length of the pattern, space used for lps array isn\\'t included.\\n        \"\"\"\\n        m = len(pattern)\\n        lps_array = [0] * m\\n        i, j = 1, 0  # start from the 2nd character in pattern\\n        while i < m:\\n            if pattern[i] == pattern[j]:\\n                lps_array[i] = j + 1\\n                j += 1\\n                i += 1\\n            else:\\n                if j > 0:\\n                    j = lps_array[j - 1]\\n                else:\\n                    lps_array[i] = 0\\n                    i += 1\\n        return lps_array\\n\\n    def strStr(self, text, pattern):\\n        \"\"\" Returns index of 1st occurence of pattern in text.\\n        Returns -1 if pattern is not in the text.\\n        Knuth\\u2013Morris\\u2013Pratt algorithm.\\n        Time complexity: O(n + m). Space complexity: O(m).\\n        \"\"\"\\n        # special cases\\n        if not text and not pattern:\\n            return 0\\n        elif not pattern:\\n            return 0\\n\\n        # build longest proper suffix array for pattern\\n        lps_array = self.build_lps(pattern)\\n\\n        n, m = len(text), len(pattern)\\n        i, j = 0, 0\\n        while i < n:\\n            # current characters match, move to the next characters\\n            if text[i] == pattern[j]:\\n                i += 1\\n                j += 1\\n            # current characters don\\'t match\\n            else:\\n                if j > 0:  # try start with previous longest prefix\\n                    j = lps_array[j - 1]\\n                # 1st character of pattern doesn\\'t match character in text\\n                # go to the next character in text\\n                else:\\n                    i += 1\\n\\n            # whole pattern matches text, match is found\\n            if j == m:\\n                return i - m\\n\\n        # no match was found\\n        return -1\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def build_lps(self, pattern):\\n        \"\"\" Helper function for strStr.\\n        Returns longest proper suffix array for string pattern.\\n        Each lps_array[i] is the length of the longest proper prefix\\n        which is equal to suffix for pattern ending at character i.\\n        Proper means that whole string cannot be prefix or suffix.\\n\\n        Time complexity: O(m). Space complexity: O(1), where\\n        m is the length of the pattern, space used for lps array isn\\'t included.\\n        \"\"\"\\n        m = len(pattern)\\n        lps_array = [0] * m\\n        i, j = 1, 0  # start from the 2nd character in pattern\\n        while i < m:\\n            if pattern[i] == pattern[j]:\\n                lps_array[i] = j + 1\\n                j += 1\\n                i += 1\\n            else:\\n                if j > 0:\\n                    j = lps_array[j - 1]\\n                else:\\n                    lps_array[i] = 0\\n                    i += 1\\n        return lps_array\\n\\n    def strStr(self, text, pattern):\\n        \"\"\" Returns index of 1st occurence of pattern in text.\\n        Returns -1 if pattern is not in the text.\\n        Knuth\\u2013Morris\\u2013Pratt algorithm.\\n        Time complexity: O(n + m). Space complexity: O(m).\\n        \"\"\"\\n        # special cases\\n        if not text and not pattern:\\n            return 0\\n        elif not pattern:\\n            return 0\\n\\n        # build longest proper suffix array for pattern\\n        lps_array = self.build_lps(pattern)\\n\\n        n, m = len(text), len(pattern)\\n        i, j = 0, 0\\n        while i < n:\\n            # current characters match, move to the next characters\\n            if text[i] == pattern[j]:\\n                i += 1\\n                j += 1\\n            # current characters don\\'t match\\n            else:\\n                if j > 0:  # try start with previous longest prefix\\n                    j = lps_array[j - 1]\\n                # 1st character of pattern doesn\\'t match character in text\\n                # go to the next character in text\\n                else:\\n                    i += 1\\n\\n            # whole pattern matches text, match is found\\n            if j == m:\\n                return i - m\\n\\n        # no match was found\\n        return -1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1338346,
                "title": "c-easy-to-understand-straight-forward-solution",
                "content": "**Please upvote to motivate me in my quest of documenting all leetcode solutions. HAPPY CODING:)\\nAny suggestions and improvements are always welcome**\\n```\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        if(needle.size()==0)\\n         return 0;\\n        if(haystack.size()<needle.size())\\n          return -1;  \\n        int n=needle.size();\\n        string str;\\n        for(int i=0;i<=haystack.size()-n;i++)\\n        {\\n            str=haystack.substr(i,n);\\n            if(str==needle)\\n             return i;   \\n        }\\n        return -1;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        if(needle.size()==0)\\n         return 0;\\n        if(haystack.size()<needle.size())\\n          return -1;  \\n        int n=needle.size();\\n        string str;\\n        for(int i=0;i<=haystack.size()-n;i++)\\n        {\\n            str=haystack.substr(i,n);\\n            if(str==needle)\\n             return i;   \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 455126,
                "title": "python-by-sliding-the-needle-over-haystack",
                "content": "```\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        \\n        stride = len(needle)\\n        haystack_length = len(haystack)\\n        total_step = haystack_length-stride+1\\n        if stride == 0: return 0\\n        for i in range(total_step):\\n            if haystack[i:i+stride] == needle:\\n                return i\\n        return -1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        \\n        stride = len(needle)\\n        haystack_length = len(haystack)\\n        total_step = haystack_length-stride+1\\n        if stride == 0: return 0\\n        for i in range(total_step):\\n            if haystack[i:i+stride] == needle:\\n                return i\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3249819,
                "title": "easy-approach-fully-explained-with-img-fastest-solution-beats-100-cpp-solution",
                "content": "Feel free to ask any doubt. you cana contact me on linkdin- https://linkedin.com/in/bhaskar-agrawal-a01069219. please upvote.\\n# INTUITION \\nHere, we have to find the first occurance of needle string in haystack string. if needle is present, return first occuring index else return -1. In this we have to check if first character of needle is equal to which index character of haystack and then proceed further for rest of the characters.\\n# APPROACH WITH EXAMPLE.\\n1. Since we have to find the needle in haystack, iterate over haystack from 0 till length.\\n2. check if the haystack[i] is equal to first character of needle. if equal enter inside the loop else just simply come to next iteration, that is, i++.\\n3. if equal, we have to check for the rest of the index\\'s of hYSTACK and NEEEDLE.  For this, **declare i1 = i+1, and j= 1**. j is 1 so that we can check for next character in needle string.\\n4. in a while loop iterate till **haystack[i1] is equal to needle[j].** that is both character are equal or not.. \\n5. if they are equal, increase i1 and j by 1. \\n6. if they are not equal, break the  while loop.\\n7. at the end of for loop check, if j is equal to needle\\'s length or not. if equal return i which is the first occuring index of needle in haystack.\\n8. if we have terminated all loop, it means, beedle is absent, return -1.\\n\\n# EXAMPLE\\n**haystack** = \"sadbutsad\"\\n**needle** = \"sad\"\\n![image](https://assets.leetcode.com/users/images/b3947158-de4a-42a1-a15c-9ee1c79c5ba5_1677810854.0025146.jpeg)\\nwe have to return the first occuring index, we need not to check for whole string. as soon as we find the needle in haystack, we get our mininum index.\\nfeel free to contact me.\\n\\n# COMPLEXITY.\\n**TIME** O(N)- linear. in worst case in reaches upto O(N^2).\\n**SPACE** - O(!)- constant\\n\\n# CODE\\n```\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        \\n        for (int i = 0; i < haystack.length(); i++) {\\n            if (haystack[i] == needle[0]) {\\n                int i1 = i + 1;\\n                int j = 1;\\n                while (haystack[i1] && needle[j]) {\\n                    if (haystack[i1] != needle[j]) break;\\n                    i1++;\\n                    j++;\\n                }\\n                if (j == needle.length()) return i;\\n            }\\n        }\\n        return -1;        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        \\n        for (int i = 0; i < haystack.length(); i++) {\\n            if (haystack[i] == needle[0]) {\\n                int i1 = i + 1;\\n                int j = 1;\\n                while (haystack[i1] && needle[j]) {\\n                    if (haystack[i1] != needle[j]) break;\\n                    i1++;\\n                    j++;\\n                }\\n                if (j == needle.length()) return i;\\n            }\\n        }\\n        return -1;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 478750,
                "title": "java-elegant-rolling-hash",
                "content": "```\\nclass Solution {\\n    int BASE = 31;\\n    int MOD = 10000007;\\n    public int strStr(String h, String t) {\\n        if (t.length() == 0) {\\n            return 0;\\n        }\\n        if (h.length() == 0) {\\n            return -1;\\n        }\\n        int n = h.length();\\n        int m = t.length();\\n        long target = 0;\\n        long pow = 1;\\n        for (int i = 0; i < m; i++) {\\n            target = (target * BASE + t.charAt(i)) % MOD;\\n            pow = pow * BASE % MOD;\\n        }\\n        long code = 0;\\n        for (int i = 0; i < n; i++) {\\n            code = (code * BASE+ h.charAt(i)) % MOD;\\n            if (i >= m) {\\n                code = ((code - h.charAt(i - m) * pow % MOD) + MOD) % MOD;\\n            }\\n            if (code == target) {\\n                return i - m + 1;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int BASE = 31;\\n    int MOD = 10000007;\\n    public int strStr(String h, String t) {\\n        if (t.length() == 0) {\\n            return 0;\\n        }\\n        if (h.length() == 0) {\\n            return -1;\\n        }\\n        int n = h.length();\\n        int m = t.length();\\n        long target = 0;\\n        long pow = 1;\\n        for (int i = 0; i < m; i++) {\\n            target = (target * BASE + t.charAt(i)) % MOD;\\n            pow = pow * BASE % MOD;\\n        }\\n        long code = 0;\\n        for (int i = 0; i < n; i++) {\\n            code = (code * BASE+ h.charAt(i)) % MOD;\\n            if (i >= m) {\\n                code = ((code - h.charAt(i - m) * pow % MOD) + MOD) % MOD;\\n            }\\n            if (code == target) {\\n                return i - m + 1;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3792168,
                "title": "python-3-simple-brute-force-beats-98",
                "content": "```python3 []\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        N, H = len(needle), len(haystack)\\n\\n        for i in range(H - N + 1):\\n            for j in range(N):\\n                if needle[j] != haystack[i + j]:\\n                    break\\n                if j == N - 1:\\n                    return i\\n\\n        return -1       \\n```\\n![Screenshot 2023-07-20 at 14.38.05.png](https://assets.leetcode.com/users/images/a689d9b0-5d4f-4f89-a6c1-77418a2794ec_1689853237.382581.png)\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sliding Window"
                ],
                "code": "```python3 []\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        N, H = len(needle), len(haystack)\\n\\n        for i in range(H - N + 1):\\n            for j in range(N):\\n                if needle[j] != haystack[i + j]:\\n                    break\\n                if j == N - 1:\\n                    return i\\n\\n        return -1       \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3251954,
                "title": "easy-to-understand-c-solution",
                "content": "# Code\\n```\\npublic class Solution \\n{\\n    public int StrStr(string haystack, string needle)\\n    {\\n        for (var i = 0; i < haystack.Length - needle.Length + 1; i++)\\n        {\\n            if (haystack.Substring(i, needle.Length) == needle)\\n            {\\n                return i;\\n            }\\n        }\\n\\n        return -1;\\n    }\\n}\\n```\\n\\n![pleaseupvote.jpg](https://assets.leetcode.com/users/images/e5c1bc7a-bacb-4930-a388-55046dd7ee20_1677848724.0278893.jpeg)\\n",
                "solutionTags": [
                    "C#",
                    "String",
                    "String Matching"
                ],
                "code": "```\\npublic class Solution \\n{\\n    public int StrStr(string haystack, string needle)\\n    {\\n        for (var i = 0; i < haystack.Length - needle.Length + 1; i++)\\n        {\\n            if (haystack.Substring(i, needle.Length) == needle)\\n            {\\n                return i;\\n            }\\n        }\\n\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2595592,
                "title": "solution",
                "content": "```\\n/**\\n * @param {string} haystack\\n * @param {string} needle\\n * @return {number}\\n */\\nvar strStr = function(haystack, needle) {\\n    let length = haystack.length;\\n    let targetLength = needle.length;\\n    \\n    // Loop through haystack\\n    for (let i = 0; i < length; i++) {\\n        \\n        // If the first character of both haystack and needle match, compare\\n        if (haystack.charAt(i) === needle.charAt(0)) {\\n            // Compares haystacks substring from i to needles length and compares\\n            if (haystack.substring(i,i+targetLength) === needle) return i;\\n        }\\n    }\\n    \\n    return -1;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {string} haystack\\n * @param {string} needle\\n * @return {number}\\n */\\nvar strStr = function(haystack, needle) {\\n    let length = haystack.length;\\n    let targetLength = needle.length;\\n    \\n    // Loop through haystack\\n    for (let i = 0; i < length; i++) {\\n        \\n        // If the first character of both haystack and needle match, compare\\n        if (haystack.charAt(i) === needle.charAt(0)) {\\n            // Compares haystacks substring from i to needles length and compares\\n            if (haystack.substring(i,i+targetLength) === needle) return i;\\n        }\\n    }\\n    \\n    return -1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2595589,
                "title": "solution",
                "content": "```\\ndef strStr(self, haystack: str, needle: str) -> int:\\n    needle_len = len(needle)\\n    for i in range(len(haystack)):\\n        if haystack[i:i+needle_len] == needle:\\n            return i\\n    return -1\\n```",
                "solutionTags": [],
                "code": "```\\ndef strStr(self, haystack: str, needle: str) -> int:\\n    needle_len = len(needle)\\n    for i in range(len(haystack)):\\n        if haystack[i:i+needle_len] == needle:\\n            return i\\n    return -1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1902475,
                "title": "100-fastest-swift-solution",
                "content": "```\\nclass Solution {\\n    func strStr(_ haystack: String, _ needle: String) -> Int {\\n\\t\\tguard haystack.count >= needle.count else { return -1 }\\n\\t\\tlet chars1 = Array(haystack)\\n\\t\\tlet chars2 = Array(needle)\\n\\t\\t\\n        for i in 0..<chars1.count - chars2.count + 1 {\\n\\t\\t\\tvar count = 0\\n\\t\\t\\tfor j in 0..<chars2.count {\\n\\t\\t\\t\\tif chars1[i + j] != chars2[j] { break }\\n\\t\\t\\t\\tcount += 1\\n\\t\\t\\t}\\n\\t\\t\\tif count == chars2.count {\\n\\t\\t\\t\\treturn i\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t}\\n\\t\\t}\\n        return -1\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func strStr(_ haystack: String, _ needle: String) -> Int {\\n\\t\\tguard haystack.count >= needle.count else { return -1 }\\n\\t\\tlet chars1 = Array(haystack)\\n\\t\\tlet chars2 = Array(needle)\\n\\t\\t\\n        for i in 0..<chars1.count - chars2.count + 1 {\\n\\t\\t\\tvar count = 0\\n\\t\\t\\tfor j in 0..<chars2.count {\\n\\t\\t\\t\\tif chars1[i + j] != chars2[j] { break }\\n\\t\\t\\t\\tcount += 1\\n\\t\\t\\t}\\n\\t\\t\\tif count == chars2.count {\\n\\t\\t\\t\\treturn i\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t}\\n\\t\\t}\\n        return -1\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1293585,
                "title": "easy-python-solution-faster-than-89",
                "content": "```\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        if len(needle)==0:\\n            return 0 \\n        elif len(haystack) < len(needle) or needle not in haystack:\\n            return -1\\n        else:\\n            x = len(needle)\\n            for i in range(len(haystack)):\\n                if haystack[i:i+x]==needle:\\n                    return i\\n            return -1\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        if len(needle)==0:\\n            return 0 \\n        elif len(haystack) < len(needle) or needle not in haystack:\\n            return -1\\n        else:\\n            x = len(needle)\\n            for i in range(len(haystack)):\\n                if haystack[i:i+x]==needle:\\n                    return i\\n            return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 248916,
                "title": "python-1-linear",
                "content": "Concise of Straightforward Solution\\n```\\ndef strStr(self, haystack, needle):\\n\\treturn haystack.find(needle)\\n```",
                "solutionTags": [],
                "code": "```\\ndef strStr(self, haystack, needle):\\n\\treturn haystack.find(needle)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 13143,
                "title": "rabin-karp-solution",
                "content": "This is my Rabin-Karp implementation. It beats only 44% However, as I see how fast the naive approaches are I get the impression that the test cases for this problem are all quite simple.\\n\\n    public class Solution {\\n        private static final int R = 31;\\n        private static final int Q = 997;\\n    //    private static final int Q = java.math.BigInteger.probablePrime(16, new java.util.Random(System.currentTimeMillis())).intValue();\\n        \\n        public int strStr(String haystack, String needle) {\\n            if ( needle.length() > haystack.length() ) { return -1; }\\n            if ( needle.length() == 0 ) { return 0; }\\n            int m = needle.length();\\n            int n = haystack.length();\\n            int mf = 1;\\n            for ( int i = 1; i < m; i++ ) { mf = ( mf * R ) % Q; }\\n            int needleHash = hash(needle, 0, m);\\n            int hash = hash(haystack, 0, m);\\n            \\n            for ( int i = m; i <= n; i++ ) {\\n                if ( hash == needleHash && haystack.substring(i - m, i).equals(needle) ) {\\n                    return i - m;\\n                }\\n                if ( i < n ) {\\n                    hash = ( hash + Q - ( mf * haystack.charAt(i - m) % Q ) ) % Q;\\n                    hash = ( hash * R + haystack.charAt(i) ) % Q;\\n                }\\n            }\\n            return -1;\\n        }\\n        \\n        private static int hash(String s, int from, int to) {\\n            int hash = 0;\\n            for ( int i = from; i < to; i++ ) {\\n                hash = ( ( hash * R ) % Q + s.charAt(i) ) % Q;\\n            }\\n            return hash;\\n        }\\n    }",
                "solutionTags": [
                    "String"
                ],
                "code": "class Solution {\\n        private static final int R = 31;\\n        private static final int Q = 997;\\n    //    private static final int Q = java.math.BigInteger.probablePrime(16, new java.util.Random(System.currentTimeMillis())).intValue();\\n        \\n        public int strStr(String haystack, String needle) {\\n            if ( needle.length() > haystack.length() ) { return -1; }",
                "codeTag": "Java"
            },
            {
                "id": 13324,
                "title": "my-c-code-that-implements-boyer-moore-string-search-got-accepted-in-12ms",
                "content": "I implements Boyer-Moore string search algorithm and it turns out to be very efficient (accepted in 12ms). Boyer-Moore uses information gained by preprocessing the pattern string to skip as many alignments as possible. A shift is calculated by applying both rules: the bad character rule and the good suffix rule. The actual shifting offset is the maximum of the shifts calculated by these rules.\\n\\n\\tchar *strStr(char *haystack, char *needle) {\\n\\t\\tif(NULL==haystack||NULL==needle)\\n\\t\\t\\treturn NULL;\\n\\t\\tint plen = strlen(needle);\\n\\t\\tint slen = strlen(haystack);\\n\\t\\tif(0==plen)\\n\\t\\t\\treturn haystack;\\n\\t\\telse if(plen>slen)\\n\\t\\t\\treturn NULL;\\n\\t\\tint badChar[256];\\n\\t\\tint np = 0;\\n\\t\\tint i,j,k;\\n\\n\\t\\tfor(i=0;i<256;i++)\\n\\t\\t\\tbadChar[i] = plen;\\n    \\n\\t\\twhile(np<plen)\\n\\t\\t{\\n\\t\\t\\tbadChar[*(needle+np)] = plen-np-1;\\n\\t\\t\\tnp++;\\n\\t\\t}\\n\\n\\t\\tint* goodSuffix = new int[plen];\\n\\n\\t\\tint prefix_index = plen;\\n\\t\\tfor(i=plen-1;i>=0;i--)\\n\\t\\t{\\n\\t\\t\\tgoodSuffix[i] = prefix_index;\\n\\t\\t\\tif(*(needle+i)==*(needle+plen-1-i)&&prefix_index==i+1)\\n\\t\\t\\t\\tprefix_index = i;\\n\\t\\t}\\n\\t\\n\\t\\tfor(i=0;i<plen-1;i++)\\n\\t\\t{\\n\\t\\t\\tj = plen-1, k = 0;\\n\\t\\t\\twhile(k<i&&*(needle+j)==*(needle+i-k))\\n\\t\\t\\t{j--;k++;}\\n\\t\\t\\tif(*(needle+plen-1)==*(needle+i))\\n\\t\\t\\t\\tgoodSuffix[j] = plen-1-i;\\n\\t\\t}\\n\\t\\tgoodSuffix[plen-1] = 0;\\n\\n\\t\\tint sp = 0;\\n\\t\\twhile(sp<slen)\\n\\t\\t{\\n\\t\\t\\ti = plen-1;\\n\\t\\t\\twhile(i>=0&&*(haystack+sp+i)==*(needle+i))\\n\\t\\t\\t\\ti--;\\n\\t\\t\\tif(i<0)\\n\\t\\t\\t\\treturn haystack+sp;\\n\\t\\t\\tint bj = badChar[*(haystack+sp+i)] - plen + i + 1;\\n\\t\\t\\tsp += (bj>goodSuffix[i]?bj:goodSuffix[i]);\\n\\t\\t}\\n\\n\\t\\tdelete goodSuffix;\\n\\t\\treturn NULL;\\n\\t}",
                "solutionTags": [],
                "code": "I implements Boyer-Moore string search algorithm and it turns out to be very efficient (accepted in 12ms). Boyer-Moore uses information gained by preprocessing the pattern string to skip as many alignments as possible. A shift is calculated by applying both rules: the bad character rule and the good suffix rule. The actual shifting offset is the maximum of the shifts calculated by these rules.\\n\\n\\tchar *strStr(char *haystack, char *needle) {\\n\\t\\tif(NULL==haystack||NULL==needle)\\n\\t\\t\\treturn NULL;\\n\\t\\tint plen = strlen(needle);\\n\\t\\tint slen = strlen(haystack);\\n\\t\\tif(0==plen)\\n\\t\\t\\treturn haystack;\\n\\t\\telse if(plen>slen)\\n\\t\\t\\treturn NULL;\\n\\t\\tint badChar[256];\\n\\t\\tint np = 0;\\n\\t\\tint i,j,k;\\n\\n\\t\\tfor(i=0;i<256;i++)\\n\\t\\t\\tbadChar[i] = plen;\\n    \\n\\t\\twhile(np<plen)\\n\\t\\t{\\n\\t\\t\\tbadChar[*(needle+np)] = plen-np-1;\\n\\t\\t\\tnp++;\\n\\t\\t}\\n\\n\\t\\tint* goodSuffix = new int[plen];\\n\\n\\t\\tint prefix_index = plen;\\n\\t\\tfor(i=plen-1;i>=0;i--)\\n\\t\\t{\\n\\t\\t\\tgoodSuffix[i] = prefix_index;\\n\\t\\t\\tif(*(needle+i)==*(needle+plen-1-i)&&prefix_index==i+1)\\n\\t\\t\\t\\tprefix_index = i;\\n\\t\\t}\\n\\t\\n\\t\\tfor(i=0;i<plen-1;i++)\\n\\t\\t{\\n\\t\\t\\tj = plen-1, k = 0;\\n\\t\\t\\twhile(k<i&&*(needle+j)==*(needle+i-k))\\n\\t\\t\\t{j--;k++;}\\n\\t\\t\\tif(*(needle+plen-1)==*(needle+i))\\n\\t\\t\\t\\tgoodSuffix[j] = plen-1-i;\\n\\t\\t}\\n\\t\\tgoodSuffix[plen-1] = 0;\\n\\n\\t\\tint sp = 0;\\n\\t\\twhile(sp<slen)\\n\\t\\t{\\n\\t\\t\\ti = plen-1;\\n\\t\\t\\twhile(i>=0&&*(haystack+sp+i)==*(needle+i))\\n\\t\\t\\t\\ti--;\\n\\t\\t\\tif(i<0)\\n\\t\\t\\t\\treturn haystack+sp;\\n\\t\\t\\tint bj = badChar[*(haystack+sp+i)] - plen + i + 1;\\n\\t\\t\\tsp += (bj>goodSuffix[i]?bj:goodSuffix[i]);\\n\\t\\t}\\n\\n\\t\\tdelete goodSuffix;\\n\\t\\treturn NULL;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 2471084,
                "title": "javascript-the-answer-interviewers-are-looking-for-also-a-one-liner",
                "content": "For those who want some humor, you can submit this as a valid solution, but that\\'s not the point of this problem. Just note that we are implementing `strStr` (in C) or `indexOf` in Java and JavaScript.\\n```\\nvar strStr = (haystack, needle) => haystack.indexOf(needle);\\n```\\nAlso, it\\'s not `O(1)`, it depends on the implementation of `indexOf` which is basically the function we are recreating.\\n\\nThe point of the problem is to implement it without using any String functions. While you\\'re just implementing something that\\'s already implemented, this is to show case your fundamentals of programming with strings and arrays using their bare structures.\\n```\\nvar strStr = function(haystack, needle) {\\n  if (haystack.length >= needle.length) {\\n    let j;\\n    for (let i = 0; i < haystack.length; i++) {\\n      for (j = 0; j < needle.length; j++) {\\n        if (needle[j] !== haystack[i + j]) break;\\n      }\\n      if (j === needle.length) return i;\\n    }\\n  }\\n  return -1;\\n};\\n```\\n\\n### Possible test cases\\nIt would be a bonus if you recognize the use case where the size of `needle` were bigger than `haystack`. \\n\\nThe description mentions asking about the case for an empty string. You could do that as well.\\n\\n### The solution\\nWe also want to reduce the need for `if` checks so leave the function as soon as we find a match.\\n\\nI put the `let j;` declaration outside of the loops because I did not want to redeclare the same variable that we can simply just reuse. This is a minor optimization, but good to note.\\n\\nI didn\\'t use any string functions. I could have also used the `substring` method to extract a `needle` sized string out of `haystack`, but I didn\\'t. If you do use a string function, you would have to consider the Big O that the function uses. But again, it\\'s not the point of the question, so comparing the strings at each index is likely how it should be if you want to implement it into an optimized function in a given library or code-base.\\n\\n### Big-O TC (Time Complexity)\\n\\n`n` = length of haystack\\n`m` = length of needle\\n\\n`O(n*m)` or `O(n2)` is the worst case scenario (where the needle is not found).\\n\\n`O(n)` in the best case scenario.\\n\\n### Big-O SC (Space Complexity)\\n\\n`O(1)` since we\\'re not using any data structure to store values and reusing others.\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar strStr = (haystack, needle) => haystack.indexOf(needle);\\n```\n```\\nvar strStr = function(haystack, needle) {\\n  if (haystack.length >= needle.length) {\\n    let j;\\n    for (let i = 0; i < haystack.length; i++) {\\n      for (j = 0; j < needle.length; j++) {\\n        if (needle[j] !== haystack[i + j]) break;\\n      }\\n      if (j === needle.length) return i;\\n    }\\n  }\\n  return -1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1089672,
                "title": "javascript-97-72ms",
                "content": "```\\n/**\\n * @param {string} haystack\\n * @param {string} needle\\n * @return {number}\\n */\\nvar strStr = function(haystack, needle) {\\n  if (!needle) return 0\\n  let idx = 0\\n  for (let i = 0; i < haystack.length; i++) {\\n    if (haystack[i] != needle[idx]) {\\n      i = i-idx\\n      idx = 0\\n    } else {\\n      if (idx == needle.length-1) return i-idx\\n      idx++\\n    }\\n  }\\n  return -1\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} haystack\\n * @param {string} needle\\n * @return {number}\\n */\\nvar strStr = function(haystack, needle) {\\n  if (!needle) return 0\\n  let idx = 0\\n  for (let i = 0; i < haystack.length; i++) {\\n    if (haystack[i] != needle[idx]) {\\n      i = i-idx\\n      idx = 0\\n    } else {\\n      if (idx == needle.length-1) return i-idx\\n      idx++\\n    }\\n  }\\n  return -1\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 497180,
                "title": "c-rabin-karp-rolling-hash-100",
                "content": "Adapted from CLRS\\n\\n```\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        // Base cases\\n        auto n = haystack.length(); auto m = needle.length();\\n        if (m == 0) return 0;\\n        if (n == 0 || n < m) return -1;\\n \\n        // Hashing:\\n        // or using fast integer power algo: \\n        // radix^(m - 1) % prime: int h = pow(d, m - 1) % q;                                            \\n        int d = 31;                                                     // radix - beneficial to make smaller      \\n        int q = 15486703;                                               // some big prime\\n        long p = 0; long t = 0; long h = 1;\\n       \\n        for (auto i = 0; i < m; ++i) {                                  // preprocessing hashes for pattern and text\\n            if (i != m - 1) \\n                h = (d * h) % q;\\n            p = (d * p + needle[i]) % q;\\n            t = (d * t + haystack[i]) % q;\\n        }\\n        \\n        for (auto s = 0; s < n - m + 1; ++s) {\\n            if (t < 0) t += q;                                           // fix negative hash\\n            if (p == t)                                                  // hash matched\\n                if (needle == haystack.substr(s, m))                     // collision handling\\n                    return s;\\n            if (s < n - m)                                               // updating hash: pop front char, push new\\n                t = (d * (t - haystack[s] * h) + haystack[s + m]) % q;\\n        }\\n        \\n        return -1;   \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Rolling Hash"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        // Base cases\\n        auto n = haystack.length(); auto m = needle.length();\\n        if (m == 0) return 0;\\n        if (n == 0 || n < m) return -1;\\n \\n        // Hashing:\\n        // or using fast integer power algo: \\n        // radix^(m - 1) % prime: int h = pow(d, m - 1) % q;                                            \\n        int d = 31;                                                     // radix - beneficial to make smaller      \\n        int q = 15486703;                                               // some big prime\\n        long p = 0; long t = 0; long h = 1;\\n       \\n        for (auto i = 0; i < m; ++i) {                                  // preprocessing hashes for pattern and text\\n            if (i != m - 1) \\n                h = (d * h) % q;\\n            p = (d * p + needle[i]) % q;\\n            t = (d * t + haystack[i]) % q;\\n        }\\n        \\n        for (auto s = 0; s < n - m + 1; ++s) {\\n            if (t < 0) t += q;                                           // fix negative hash\\n            if (p == t)                                                  // hash matched\\n                if (needle == haystack.substr(s, m))                     // collision handling\\n                    return s;\\n            if (s < n - m)                                               // updating hash: pop front char, push new\\n                t = (d * (t - haystack[s] * h) + haystack[s + m]) % q;\\n        }\\n        \\n        return -1;   \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 294148,
                "title": "javascript-solution",
                "content": "JavaScript:\\n\\n```\\nvar strStr = function(haystack, needle) {\\n    if(!needle) return 0;\\n    if(!haystack) return -1;\\n    if(haystack.length<needle.length) return -1;\\n\\n    \\n    let i=0;\\n    let j=0;\\n    \\n    while(i<haystack.length && j<needle.length){\\n        \\n        if (haystack[i]===needle[j]){\\n            ++i;\\n            ++j;\\n        } else {\\n            i = (++i) - j;\\n            j = 0;\\n        }\\n    }\\n    if(j===needle.length) return i-j;\\n\\n    return -1;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar strStr = function(haystack, needle) {\\n    if(!needle) return 0;\\n    if(!haystack) return -1;\\n    if(haystack.length<needle.length) return -1;\\n\\n    \\n    let i=0;\\n    let j=0;\\n    \\n    while(i<haystack.length && j<needle.length){\\n        \\n        if (haystack[i]===needle[j]){\\n            ++i;\\n            ++j;\\n        } else {\\n            i = (++i) - j;\\n            j = 0;\\n        }\\n    }\\n    if(j===needle.length) return i-j;\\n\\n    return -1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 13311,
                "title": "kmp-solution-in-java",
                "content": "Hi guys!\\n\\nHere is a pretty concise implementation of a Knuth-Morris-Pratt algorithm in Java.\\nInstead of commenting and explaining the approach I want to give a really-really useful link to [TopCoder tutorial on the topic][1]. The code is just a slightly modified version of the code from the tutorial and an explanation there is perfect.\\n\\n----\\n\\n    public class Solution {\\n        \\n        private int[] failureFunction(char[] str) {\\n            int[] f = new int[str.length+1];\\n            for (int i = 2; i < f.length; i++) {\\n                int j = f[i-1];\\n                while (j > 0 && str[j] != str[i-1]) j = f[j];\\n                if (j > 0 || str[j] == str[i-1]) f[i] = j+1;\\n            }\\n            return f;\\n        }\\n    \\n        public int strStr(String haystack, String needle) {\\n            if (needle.length() == 0) return 0;\\n            if (needle.length() <= haystack.length()) {\\n                int[] f = failureFunction(needle.toCharArray());\\n                int i = 0, j = 0;\\n                while (i < haystack.length()) {\\n                    if (haystack.charAt(i) == needle.charAt(j)) {\\n                        i++; j++;\\n                        if (j == needle.length()) return i-j;\\n                    } else if (j > 0) j = f[j];\\n                    else i++;\\n                }\\n            }\\n            return -1;\\n        }\\n    }\\n\\n\\n  [1]: https://www.topcoder.com/community/data-science/data-science-tutorials/introduction-to-string-searching-algorithms/",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        \\n        private int[] failureFunction(char[] str) {\\n            int[] f = new int[str.length+1];\\n            for (int i = 2; i < f.length; i++) {\\n                int j = f[i-1];\\n                while (j > 0 && str[j] != str[i-1]) j = f[j];\\n                if (j > 0 || str[j] == str[i-1]) f[i] = j+1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 13338,
                "title": "1ms-runtime-solution-in-c",
                "content": "    int strStr(char *haystack, char *needle) {\\n    \\tchar *p, *q;\\n    \\tint i, len = strlen(haystack) - strlen(needle);\\n    \\n    \\tfor (i = 0; i <= len; i++) {\\n    \\t\\tp = haystack + i;\\n    \\t\\tq = needle;\\n    \\t\\twhile (*q && *p == *q) {\\n    \\t\\t\\t++p;\\n    \\t\\t\\t++q;\\n    \\t\\t}\\n    \\t\\tif (*q == 0)\\n    \\t\\t\\treturn i;\\n    \\t}\\n    \\treturn -1;\\n    }",
                "solutionTags": [],
                "code": "    int strStr(char *haystack, char *needle) {\\n    \\tchar *p, *q;\\n    \\tint i, len = strlen(haystack) - strlen(needle);\\n    \\n    \\tfor (i = 0; i <= len; i++) {\\n    \\t\\tp = haystack + i;\\n    \\t\\tq = needle;\\n    \\t\\twhile (*q && *p == *q) {\\n    \\t\\t\\t++p;\\n    \\t\\t\\t++q;\\n    \\t\\t}\\n    \\t\\tif (*q == 0)\\n    \\t\\t\\treturn i;\\n    \\t}\\n    \\treturn -1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3627068,
                "title": "novel-approach-with-detailed-explanation-python3",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSince the question says **haystack and needle consist of only lowercase English characters**, I replace needle into \"A\" inside haystack. If there is no needle in the haystack, nothing changes so \"new\" will be the same as haystack. However, if there is needle in haystack it will replace needle into \"A\" and we just need to return first \"A\" from \"new\".\\n\\n# Code\\n```\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        new = haystack.replace(needle,\\'A\\')\\n        if (new == haystack): return -1\\n        else: return new.index(\\'A\\')\\n        \\n        \\n        \\n        \\n    \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        new = haystack.replace(needle,\\'A\\')\\n        if (new == haystack): return -1\\n        else: return new.index(\\'A\\')\\n        \\n        \\n        \\n        \\n    \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3410567,
                "title": "best-solution-by-java-in-one-line-runtime-in-0ms-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n         return haystack.indexOf(needle);\\n    }\\n}\\n```\\n\\n![image.png](https://assets.leetcode.com/users/images/d9059796-da65-4784-9096-19339350bcb9_1681342328.2017047.png)\\n\\n### please upvote if you liked the solution.\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n         return haystack.indexOf(needle);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3251838,
                "title": "c-shortest-solution-pretty-easy-100-beast",
                "content": "# Complexity\\n- Time complexity: O(n)\\n \\nhttps://leetcode.com/problems/find-the-index-of-the-first-occurrence-in-a-string/submissions/908325998/\\n     this is the real shortest solution in one line\\n-  \\n# Code\\n```\\nclass Solution {\\npublic:\\n    int strStr(string ha, string needle) {\\n        // if needle doesn\\'t exist in haystack\\n        if(ha.find(needle) == string :: npos) return -1;\\n        \\n        int n = ha.size() , m = needle.size() ;\\n\\n        for(int i = 0 ; i < n - m + 1 ; i++ )\\n            // if any substring in haystack with size m == needle \\n            if(needle == ha.substr(i,m) )\\n                return i;\\n        return -1;\\n    }\\n};\\n```\\n# don\\'t miss UPVOTE <3",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int strStr(string ha, string needle) {\\n        // if needle doesn\\'t exist in haystack\\n        if(ha.find(needle) == string :: npos) return -1;\\n        \\n        int n = ha.size() , m = needle.size() ;\\n\\n        for(int i = 0 ; i < n - m + 1 ; i++ )\\n            // if any substring in haystack with size m == needle \\n            if(needle == ha.substr(i,m) )\\n                return i;\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3251338,
                "title": "beats-100-0ms-sliding-window-two-pointers-easiest-c-code-beginner-friendly",
                "content": "# Intuition\\nWe have to find a window string(needle) in a haystack string. So we create two pointers which are used to traverse through string checking for first appearance of string.\\n\\n# Approach\\nFor loop for traversing through haystack. Create two pointers (j and ptr). j gets intialized as beginning of needle. create a count.\\nCreate a while loop with conditon that, char at both pointers is equal, and ptr is less than needle length(so that we don\\'t corss above our window)\\nAfter while loop ends if count==needle length, then voila! we have found our needle in our haystack. \\n\\n# Complexity\\n- Time complexity:\\nO(m*n)\\n\\n\\nPlease Upvote!\\nP.S:-Trying out posting solution for first time.\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        for(int i=0;i<haystack.length();i++)\\n        {\\n            int j=i;\\n            int ptr=0;\\n            int count=0;\\n            while(haystack[j]==needle[ptr] && ptr<needle.length())\\n            {\\n                j++;\\n                ptr++;\\n                count++;\\n            }\\n            if(count==needle.length()) return i;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        for(int i=0;i<haystack.length();i++)\\n        {\\n            int j=i;\\n            int ptr=0;\\n            int count=0;\\n            while(haystack[j]==needle[ptr] && ptr<needle.length())\\n            {\\n                j++;\\n                ptr++;\\n                count++;\\n            }\\n            if(count==needle.length()) return i;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2818661,
                "title": "python-97-52-faster-4-lines-o-n-solution",
                "content": "```\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        m,n=len(haystack),len(needle)\\n        for i in range(m):\\n            if haystack[i:i+n]==needle: return i\\n        return -1\\n```\\n\\n**Upvote if you like the solution or ask if there is any query**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        m,n=len(haystack),len(needle)\\n        for i in range(m):\\n            if haystack[i:i+n]==needle: return i\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2491091,
                "title": "python-easy-solution",
                "content": "Solution 1:\\n```\\ndef strStr(self, haystack: str, needle: str) -> int:\\n        if not needle:\\n            return 0\\n        if needle not in haystack:\\n            return -1\\n        return haystack.index(needle)\\n```\\nSolution 2:\\n```\\ndef strStr(self, haystack: str, needle: str) -> int:\\n        if not needle:\\n            return 0\\n        index = 0\\n        while (index <= len(haystack)-len(needle)):                \\n            if haystack[index:index+len(needle)] == needle:\\n                return index\\n            index += 1\\n        return -1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef strStr(self, haystack: str, needle: str) -> int:\\n        if not needle:\\n            return 0\\n        if needle not in haystack:\\n            return -1\\n        return haystack.index(needle)\\n```\n```\\ndef strStr(self, haystack: str, needle: str) -> int:\\n        if not needle:\\n            return 0\\n        index = 0\\n        while (index <= len(haystack)-len(needle)):                \\n            if haystack[index:index+len(needle)] == needle:\\n                return index\\n            index += 1\\n        return -1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1431678,
                "title": "java-rabin-karp-explained-line-by-line-i-struggled-with-it-too",
                "content": "Hi everyone,\\n\\nI have seen many Rabin-Karp solutions here, but all of them left me confused to some degree (I guess I\\'m not as smart as other folks, or I failed to find the best solution for me in the haystack of so many solutions). So I wrote my own, and I hope my explanation works better for some people.\\n\\nThis solution when submitted runs in about 4ms (at least in August 2021... these things change apparently). The solution is linear in time, it should run in worst case O(n+m), n being the length of haystack and m being the length of needle. Memory is O(1), we just use a few integer variables to hold the hashes, indexes, prime, etc. I had originally written this to process the char[] version of the Strings (by calling toCharArray() on them at the beginning), but this duplicates the memory used to store each string, as can be seen in [the code for toCharArray()](https://hg.openjdk.java.net/jdk7u/jdk7u6/jdk/file/8c2c5d63a17e/src/share/classes/java/lang/String.java#l2751). That version was a bit faster on most runs.\\n\\nWhen stripped of comments, this implementation has fewer than 50 lines.\\n\\nFor more information, please check [Wikipedia\\'s article on Rabin-Karp](https://en.wikipedia.org/wiki/Rabin%E2%80%93Karp_algorithm) and the explanation in Sedgewick and Wayne\\'s \"Algorithms\" book, where this problem is specifically addressed (their code is [here](https://algs4.cs.princeton.edu/53substring/RabinKarp.java.html)). I also found these slides explaining this and the other linear string matching algorithms: [Substring search](https://algs4.cs.princeton.edu/lectures/keynote/53SubstringSearch-2x2.pdf).\\n\\n\\n```\\nclass Solution {\\n    // Returns the index of the first occurrence of needle in haystack, using an \\n    // implementation of the Rabin\\u2013Karp algorithm\\n    public int strStr(String haystack, String needle) {\\n        // We need a prime to minimize the chance of collisions, as in a HashMap.\\n        // The reason a prime is better is that when we generate hashcodes that are\\n        // multiples of each other, they don\\'t land on the same bucket when we calculate\\n        // their mod (num_buckets) (unless they are multiples of the chosen prime).\\n        // As of where I got this from, I just searched for primes on Wikipedia ;)\\n        final int prime = 9999991;\\n        // Most people use a base here representative of the base the data is encoded in.\\n        // I have found 10 to be more intuitive and to work as fast as others,\\n        // at least for the leetcode test dataset.\\n\\t\\t// Sedgewick uses 256, so feel free to switch to that, or to 26 if you restrict your values\\n\\t\\t// to a-z.\\n        final int base = 10;\\n        \\n        // Handle cornercase: needle is empty\\n        if (needle.length() == 0) return 0;\\n        // Handle cornercase: needle is longer than haystack\\n        if (haystack.length() < needle.length()) return -1;\\n        \\n        // Since we are expressing the string in the hashcode as \\n        // char[i]*base^N + char[i-1] * base^N-1....+char[window.length()-1],\\n        // when we remove the most significant digit in each step a few lines down from here,\\n        // we need to multiply the letter we are removing from the window by the base elevated\\n        // to the number of digits in the window (char[i]*base^N) mod prime.\\n        // Needle (and the window) can have up to 50,000 characters as per requirements,\\n        // so this can go up to Math.pow(10, 50,000), which in Java just returns \"Infinity\" - it\\'s a huge number.\\n        // To mitigate this, since we are going to be using this number to calculate a hash mod prime,\\n        // we can multiply the base n times and calculate its mod prime factor by factor.\\n        // This works because (a*b)%p = ((a%p)*(b%p))%p \\n        // (https://en.wikipedia.org/wiki/Modulo_operation#Properties_(identities))\\n        // Here we pre-calculate this number so we can reuse it, as we must do it iteratively \\n        // and it would consume cycles character by character otherwise.\\n        int maxBase = 1;\\n        for (int i = 1; i < needle.length(); i++) {\\n            maxBase = (maxBase * base) % prime;\\n        }\\n\\n        int needlehash = hash(needle, needle.length(), base, prime);\\n        int haystackhash = hash(haystack, needle.length(), base, prime);\\n        \\n        // Did we get lucky with the first (needle.length()) characters?\\n        if (needlehash == haystackhash) return 0;\\n        \\n\\t\\t// This loop slides the window of size needle.length() along the haystack.\\n\\t\\t// For example for [a,b,c,d,...] and a needle of size 3,\\n\\t\\t// it goes from [a,b,c] to [b,c,d] and so on.\\n\\t\\t// At each step, it recalculates the window\\'s hashcode in O(1), by reusing the previous result. This is the key of the algorithm.\\n\\t\\t// For more info, please check https://en.wikipedia.org/wiki/Rolling_hash\\n        for (int i = needle.length(); i < haystack.length(); i++) {\\n            // Take first char out of the hash. You may note here that instead of subtracting the value for the most significant\\n\\t\\t\\t// character directly from haystackhash, I\\'m subtracting it from haystackhash+prime. The reason is that, since I\\'m\\n\\t\\t\\t// subtracting 2 numbers mod prime, the result could easily become negative. To prevent this, we add prime as the result \\n\\t\\t\\t// should be the same (a%p = (a+p)%p) https://en.wikipedia.org/wiki/Modulo_operation#Properties_(identities)\\n\\t\\t\\t// since now the number on the left of the subtraction is larger than the number on the right, the result\\n\\t\\t\\t// cannot be negative.\\n            haystackhash = (haystackhash+prime - (maxBase*haystack.charAt(i-needle.length())%prime))%prime;\\n            \\n            // Shift to the left, add new char\\n            haystackhash = (haystackhash*base + haystack.charAt(i))%prime;\\n            \\n            // hashes matching can mean a match or a collision. Only way to tell one from the other\\n            // is to linearly verify if the match on hash is also a match character by character.\\n            if (needlehash == haystackhash && checkSolution(haystack, needle, i-needle.length()+1)) return i-needle.length()+1;\\n        }\\n        \\n        return -1;\\n    }\\n    \\n    // Calculates a hashcode similar to how java.lang.String does it.\\n    // We reimplement it here because we need control over what the prime and the base is.\\n    // Java uses base=31 and prime=Integer.MAX_VALUE (implicitly)\\n    private int hash(String chars, int count, int base, int prime) {\\n        int hash = 0;\\n        for (int i = 0; i < count; i++) {\\n            char c = chars.charAt(i);\\n            hash = (hash * base + c) % prime;\\n        }\\n        \\n        return hash;\\n    }\\n    \\n    // Check solution linearly, fail fast on first character not matching\\n    private boolean checkSolution(String haystack, String needle, int i) {\\n        // Many strings have the same hashcode, we need to check whether this is a collision\\n        for (int j = 0; j < needle.length(); j++) {\\n            if (haystack.charAt(j+i) != needle.charAt(j)) return false;\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    // Returns the index of the first occurrence of needle in haystack, using an \\n    // implementation of the Rabin\\u2013Karp algorithm\\n    public int strStr(String haystack, String needle) {\\n        // We need a prime to minimize the chance of collisions, as in a HashMap.\\n        // The reason a prime is better is that when we generate hashcodes that are\\n        // multiples of each other, they don\\'t land on the same bucket when we calculate\\n        // their mod (num_buckets) (unless they are multiples of the chosen prime).\\n        // As of where I got this from, I just searched for primes on Wikipedia ;)\\n        final int prime = 9999991;\\n        // Most people use a base here representative of the base the data is encoded in.\\n        // I have found 10 to be more intuitive and to work as fast as others,\\n        // at least for the leetcode test dataset.\\n\\t\\t// Sedgewick uses 256, so feel free to switch to that, or to 26 if you restrict your values\\n\\t\\t// to a-z.\\n        final int base = 10;\\n        \\n        // Handle cornercase: needle is empty\\n        if (needle.length() == 0) return 0;\\n        // Handle cornercase: needle is longer than haystack\\n        if (haystack.length() < needle.length()) return -1;\\n        \\n        // Since we are expressing the string in the hashcode as \\n        // char[i]*base^N + char[i-1] * base^N-1....+char[window.length()-1],\\n        // when we remove the most significant digit in each step a few lines down from here,\\n        // we need to multiply the letter we are removing from the window by the base elevated\\n        // to the number of digits in the window (char[i]*base^N) mod prime.\\n        // Needle (and the window) can have up to 50,000 characters as per requirements,\\n        // so this can go up to Math.pow(10, 50,000), which in Java just returns \"Infinity\" - it\\'s a huge number.\\n        // To mitigate this, since we are going to be using this number to calculate a hash mod prime,\\n        // we can multiply the base n times and calculate its mod prime factor by factor.\\n        // This works because (a*b)%p = ((a%p)*(b%p))%p \\n        // (https://en.wikipedia.org/wiki/Modulo_operation#Properties_(identities))\\n        // Here we pre-calculate this number so we can reuse it, as we must do it iteratively \\n        // and it would consume cycles character by character otherwise.\\n        int maxBase = 1;\\n        for (int i = 1; i < needle.length(); i++) {\\n            maxBase = (maxBase * base) % prime;\\n        }\\n\\n        int needlehash = hash(needle, needle.length(), base, prime);\\n        int haystackhash = hash(haystack, needle.length(), base, prime);\\n        \\n        // Did we get lucky with the first (needle.length()) characters?\\n        if (needlehash == haystackhash) return 0;\\n        \\n\\t\\t// This loop slides the window of size needle.length() along the haystack.\\n\\t\\t// For example for [a,b,c,d,...] and a needle of size 3,\\n\\t\\t// it goes from [a,b,c] to [b,c,d] and so on.\\n\\t\\t// At each step, it recalculates the window\\'s hashcode in O(1), by reusing the previous result. This is the key of the algorithm.\\n\\t\\t// For more info, please check https://en.wikipedia.org/wiki/Rolling_hash\\n        for (int i = needle.length(); i < haystack.length(); i++) {\\n            // Take first char out of the hash. You may note here that instead of subtracting the value for the most significant\\n\\t\\t\\t// character directly from haystackhash, I\\'m subtracting it from haystackhash+prime. The reason is that, since I\\'m\\n\\t\\t\\t// subtracting 2 numbers mod prime, the result could easily become negative. To prevent this, we add prime as the result \\n\\t\\t\\t// should be the same (a%p = (a+p)%p) https://en.wikipedia.org/wiki/Modulo_operation#Properties_(identities)\\n\\t\\t\\t// since now the number on the left of the subtraction is larger than the number on the right, the result\\n\\t\\t\\t// cannot be negative.\\n            haystackhash = (haystackhash+prime - (maxBase*haystack.charAt(i-needle.length())%prime))%prime;\\n            \\n            // Shift to the left, add new char\\n            haystackhash = (haystackhash*base + haystack.charAt(i))%prime;\\n            \\n            // hashes matching can mean a match or a collision. Only way to tell one from the other\\n            // is to linearly verify if the match on hash is also a match character by character.\\n            if (needlehash == haystackhash && checkSolution(haystack, needle, i-needle.length()+1)) return i-needle.length()+1;\\n        }\\n        \\n        return -1;\\n    }\\n    \\n    // Calculates a hashcode similar to how java.lang.String does it.\\n    // We reimplement it here because we need control over what the prime and the base is.\\n    // Java uses base=31 and prime=Integer.MAX_VALUE (implicitly)\\n    private int hash(String chars, int count, int base, int prime) {\\n        int hash = 0;\\n        for (int i = 0; i < count; i++) {\\n            char c = chars.charAt(i);\\n            hash = (hash * base + c) % prime;\\n        }\\n        \\n        return hash;\\n    }\\n    \\n    // Check solution linearly, fail fast on first character not matching\\n    private boolean checkSolution(String haystack, String needle, int i) {\\n        // Many strings have the same hashcode, we need to check whether this is a collision\\n        for (int j = 0; j < needle.length(); j++) {\\n            if (haystack.charAt(j+i) != needle.charAt(j)) return false;\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1015275,
                "title": "java-faster-than-100-brute-force",
                "content": "```\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n        if (\"\".equals(needle)) {\\n            return 0;\\n        }\\n        \\n        for (int i = 0; i <= haystack.length() - needle.length(); i++) {\\n            if (matches(i, haystack, needle)) {\\n                return i;\\n            }\\n        }\\n\\n        return -1;\\n    }\\n    \\n    private static boolean matches(int startIdx, String haystack, String needle) {\\n        for (int i = 0; i < needle.length(); i++) {\\n            if (haystack.charAt(startIdx + i) != needle.charAt(i)) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n        if (\"\".equals(needle)) {\\n            return 0;\\n        }\\n        \\n        for (int i = 0; i <= haystack.length() - needle.length(); i++) {\\n            if (matches(i, haystack, needle)) {\\n                return i;\\n            }\\n        }\\n\\n        return -1;\\n    }\\n    \\n    private static boolean matches(int startIdx, String haystack, String needle) {\\n        for (int i = 0; i < needle.length(); i++) {\\n            if (haystack.charAt(startIdx + i) != needle.charAt(i)) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 867375,
                "title": "simple-solution-faster-than-100",
                "content": "Runtime: **0 ms**, faster than **100.00%** of Java online submissions for Implement strStr().\\nMemory Usage: 39.2 MB, less than **39.51%** of Java online submissions for Implement strStr().\\n```\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n        if (needle.isEmpty() || haystack.equals(needle)) return 0;       \\n        \\n        for (int i = 0; i <= haystack.length() - needle.length(); i++) {\\n            String evalString = haystack.substring(i, i + needle.length());\\n            if (evalString.equals(needle)) return i;\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n        if (needle.isEmpty() || haystack.equals(needle)) return 0;       \\n        \\n        for (int i = 0; i <= haystack.length() - needle.length(); i++) {\\n            String evalString = haystack.substring(i, i + needle.length());\\n            if (evalString.equals(needle)) return i;\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 420127,
                "title": "faster-than-95-runtime-48-ms-memory-usage-36-mb-javascript",
                "content": "```\\nvar strStr = function(haystack, needle) {\\n    const needleLength = needle.length;\\n    if(needleLength===0) return 0;\\n    for(let i=0;i<haystack.length;i++){\\n        if(haystack.substring(i,i+needleLength)===needle){\\n            return i;\\n        }\\n    }\\n    return -1;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar strStr = function(haystack, needle) {\\n    const needleLength = needle.length;\\n    if(needleLength===0) return 0;\\n    for(let i=0;i<haystack.length;i++){\\n        if(haystack.substring(i,i+needleLength)===needle){\\n            return i;\\n        }\\n    }\\n    return -1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 13034,
                "title": "javascript-kmp-beats-95",
                "content": "```\\nvar strStr = function(haystack, needle) {\\n    var m = haystack.length, n = needle.length;\\n    if(!n) return 0;\\n    var lps = kmpProcess(needle);\\n    for(var i = 0, j = 0; i < m;) {\\n        if(haystack[i] == needle[j]) {\\n            i++, j++;\\n        }\\n        if(j == n) return i - j;\\n        if(i < m && haystack[i] != needle[j]) {\\n            if(j) j = lps[j - 1];\\n            else i++;\\n        }\\n        \\n    }\\n    return -1;\\n};\\n\\nvar kmpProcess = function(needle) {\\n    var n = needle.length;\\n    var lps = new Array(n).fill(0);\\n    for (var i = 1, length = 0; i < n;) {\\n        if(needle[i] === needle[length]) {\\n            length++;\\n            lps[i] = length;\\n            i++;\\n        } else if (length) length = lps[length - 1];\\n        else {\\n            lps[i] = 0; \\n            i++;\\n        }\\n    }\\n    return lps;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar strStr = function(haystack, needle) {\\n    var m = haystack.length, n = needle.length;\\n    if(!n) return 0;\\n    var lps = kmpProcess(needle);\\n    for(var i = 0, j = 0; i < m;) {\\n        if(haystack[i] == needle[j]) {\\n            i++, j++;\\n        }\\n        if(j == n) return i - j;\\n        if(i < m && haystack[i] != needle[j]) {\\n            if(j) j = lps[j - 1];\\n            else i++;\\n        }\\n        \\n    }\\n    return -1;\\n};\\n\\nvar kmpProcess = function(needle) {\\n    var n = needle.length;\\n    var lps = new Array(n).fill(0);\\n    for (var i = 1, length = 0; i < n;) {\\n        if(needle[i] === needle[length]) {\\n            length++;\\n            lps[i] = length;\\n            i++;\\n        } else if (length) length = lps[length - 1];\\n        else {\\n            lps[i] = 0; \\n            i++;\\n        }\\n    }\\n    return lps;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 13163,
                "title": "my-solution-c-4ms",
                "content": "        int strStr(string haystack, string needle) {\\n\\n            if(haystack.size() < needle.size())\\n                return -1;\\n            \\n            int index = 0;\\n            int i,j;\\n            for(i = 0, j = 0;i < haystack.size() && j < needle.size();){\\n                if(haystack[i] == needle[j]){\\n                    i++; j++;\\n                }else{\\n                   index++;\\n                   i = index;\\n                   j = 0;\\n                }\\n            }\\n        \\n            if(j == needle.size())\\n                return index;\\n            return -1;\\n       }",
                "solutionTags": [
                    "C++"
                ],
                "code": "        int strStr(string haystack, string needle) {\\n\\n            if(haystack.size() < needle.size())\\n                return -1;\\n            \\n            int index = 0;\\n            int i,j;\\n            for(i = 0, j = 0;i < haystack.size() && j < needle.size();){\\n                if(haystack[i] == needle[j]){\\n                    i++; j++;\\n                }else{\\n                   index++;\\n                   i = index;\\n                   j = 0;\\n                }\\n            }\\n        \\n            if(j == needle.size())\\n                return index;\\n            return -1;\\n       }",
                "codeTag": "Unknown"
            },
            {
                "id": 3368173,
                "title": "go-solution",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunc strStr(haystack string, needle string) int {\\n    for i:= 0; i <= len(haystack) - len(needle); i++ {\\n        if haystack[i:len(needle)+i] == needle {\\n            return i\\n        }\\n    }\\n    return -1\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc strStr(haystack string, needle string) int {\\n    for i:= 0; i <= len(haystack) - len(needle); i++ {\\n        if haystack[i:len(needle)+i] == needle {\\n            return i\\n        }\\n    }\\n    return -1\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3250894,
                "title": "4-lines-of-code-and-magic-pointer-logic",
                "content": "# 4 Lines of code:---->TC:O(N)\\n```\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        n=len(needle)\\n        for i in range(len(haystack)):\\n            if haystack[i:i+n]==needle:\\n                return i\\n        return -1\\n```\\n# Pointers Approach:TC----->O(N)\\n```\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        if needle not in haystack:return -1\\n        a,b=0,0\\n        while a<len(haystack) and b<len(needle):\\n            if haystack[a]==needle[b]:\\n                a+=1\\n                b+=1\\n            else:\\n                a=a-b+1\\n                b=0\\n        return a-b\\n```\\n# please upvote me it would encourage me alot\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        n=len(needle)\\n        for i in range(len(haystack)):\\n            if haystack[i:i+n]==needle:\\n                return i\\n        return -1\\n```\n```\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        if needle not in haystack:return -1\\n        a,b=0,0\\n        while a<len(haystack) and b<len(needle):\\n            if haystack[a]==needle[b]:\\n                a+=1\\n                b+=1\\n            else:\\n                a=a-b+1\\n                b=0\\n        return a-b\\n```",
                "codeTag": "Java"
            },
            {
                "id": 998941,
                "title": "javascript-short-fast-and-simple",
                "content": "```\\nvar strStr = function(h, n) {\\n    if (!n) return 0\\n    for (let j = 0, i = 0; i < h.length; i++) {\\n        if (h[i] === n[j]) j++\\n        else (i -= j, j = 0)\\n        if (j === n.length) return i - j + 1\\n    }\\n    return -1\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar strStr = function(h, n) {\\n    if (!n) return 0\\n    for (let j = 0, i = 0; i < h.length; i++) {\\n        if (h[i] === n[j]) j++\\n        else (i -= j, j = 0)\\n        if (j === n.length) return i - j + 1\\n    }\\n    return -1\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 744624,
                "title": "boyer-moore-substring-search-using-both-bad-character-and-good-suffix-heuristics-explained",
                "content": "This problem may not really be asking for advanced substring search algorithms like KMP and Boyer-Moore etc, but it certainly provides scope for exploring them and testing their implementations here.\\n\\nI was able to understand Rabin Karp and KMP algorithms relatively easily but had a very hard time understanding the dynamics and implementation of Boyer-Moore algorithm. \\nIt is important because it is an efficient string-searching algorithm that is the standard benchmark for practical string-search literature. Many real life file system searches are implemented using this (eg: used in GNU\\'s grep)\\n\\nThe Boyer-Moore algorithm uses two different heuristics for determining the maximum possible shift distance in case of a mismatch: the \"bad character\" and the \"good suffix\" heuristics. \\n**The preprocessing for the good suffix heuristics is rather difficult to understand and to implement. Therefore, sometimes versions of the Boyer-Moore algorithm are found in which the good suffix heuristics is left away**. The argument is that the bad character heuristics would be sufficient and the good suffix heuristics would not save many comparisons. However, this is not true for small alphabets.\\n\\nIf **for simplicity one wants to restrict oneself to the bad character heuristics**, the [Horspool algorithm](https://www.inf.hs-flensburg.de/lang/algorithmen/pattern/horsen.htm)  or the [Sunday algorithm](https://www.inf.hs-flensburg.de/lang/algorithmen/pattern/sundayen.htm) are suited better.\\n\\nBecause of very rare references available for implementation of complete algorithm, I would like to explain java implementation.\\nAs a beginner, I personlly found [this video](https://www.youtube.com/watch?v=4Xyhb72LCX4) very helpful to grasp the overall working of the algorithm. Part 2 of [video is here](https://www.youtube.com/watch?v=Wj606N0IAsw)\\n\\nUnderstanding code directly could still be difficult. So you could better first try to understand the implementational details from [this webpage](https://www.inf.hs-flensburg.de/lang/algorithmen/pattern/bmen.htm). \\nRefer [this wonderful SO answer](https://stackoverflow.com/questions/19345263/boyer-moore-good-suffix-heuristics) for more detailed explaination on good-suffix preprocessing code.\\n\\nFinally here goes the most awaited yet apparently frightening code:\\n```\\n//Boyer-Moore substring search using both bad-character and good-suffix heuristics simultaneously\\n\\tpublic int strStr(String haystack, String needle) {\\n\\t\\tif (haystack == null || needle == null || haystack.length() < needle.length()) {\\n\\t\\t\\treturn -1;\\n\\t\\t} else if (needle.isEmpty()) {\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\t\\t\\n\\t\\tchar[] text = haystack.toCharArray();\\n\\t\\tchar[] pattern = needle.toCharArray();\\n\\t\\t\\n\\t\\tint[] borderPosition = new int[pattern.length+1]; /* referred as f in academic literatures;\\n\\t\\tf[i] contains the starting position of the widest border of the suffix of the pattern beginning at position i */\\n\\t\\tint[] shift = new int[pattern.length+1]; /* referred as s in academic literatures; \\n\\t\\tEach entry s[i] contains the shift distance of the pattern if a mismatch at position i \\u2013 1 occurs, \\n\\t\\ti.e. if the suffix of the pattern starting at position i has matched */\\n\\t\\tint alphabetSize = 256;\\n\\t\\t\\n\\t\\tint[] lastOccurence = preprocessBadCharacters(pattern, alphabetSize); // bad characters heuristic\\n\\t\\tpreprocessStrongSuffix(pattern, borderPosition, shift); //good suffix heuristic case 1\\n\\t\\tpreprocessPartialSuffix(borderPosition, shift, pattern.length); //good suffix heuristic case 2\\n\\t\\t// good-suffix reference: https://stackoverflow.com/questions/19345263/boyer-moore-good-suffix-heuristics\\n\\t\\t\\n\\t\\tint i=0, j; // i is start index of current window in text \\n\\t\\twhile(i<=text.length-pattern.length) {\\n\\t\\t\\tj = pattern.length-1; // we process pattern from right to left backwards\\n\\t\\t\\twhile(j>=0 && pattern[j]==text[i+j]) { // go left backwards till characters are matching in current window\\n\\t\\t\\t\\tj--;\\n\\t\\t\\t}\\n\\t\\t\\tif(j<0) { // will be true only when there was a complete match found for pattern in text\\n\\t\\t\\t\\treturn i; //report match found\\n\\t\\t\\t\\t//use i=i+shift[0] if we want to find starting indices for all multiple matches\\n\\t\\t\\t} else { // mismatch found in current window comparison\\n\\t\\t\\t\\t/*  After a mismatch the pattern is shifted by the maximum of the values \\n\\t\\t\\t\\t    given by the good-suffix and the bad-character heuristics */\\n\\t\\t\\t\\ti = i + Math.max(shift[j+1], j-lastOccurence[text[i+j]]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn -1;\\n\\t}\\n\\t\\n\\tpublic int[] preprocessBadCharacters(char[] pattern, int alphabetSize) {\\n\\t\\tint[] lastOccurence = new int[alphabetSize]; //contains last occurrence index of each character in pattern\\n\\t\\tArrays.fill(lastOccurence, -1);\\n\\n\\t\\tfor (int i = 0; i < pattern.length; i++) {\\n\\t\\t\\tlastOccurence[pattern[i]] = i;\\n\\t\\t}\\n\\n\\t\\treturn lastOccurence;\\n\\t}\\n\\t\\n\\tpublic int[] preprocessStrongSuffix(char[] pattern, int[] borderPosition, int[] shift) {\\n\\t\\tint m = pattern.length;\\n\\t\\t\\n\\t\\tint i = m, j = m + 1;\\n\\t\\tborderPosition[i] = j; // The suffix \\u03B5 beginning at position m has no border, therefore f[m] is set to m+1\\n\\t\\twhile (i > 0) {\\n\\t\\t\\t/* at this line, we know f[i], f[i+1], ... f[m]; If character at position i-1 is not  \\n               equal to character at j-1, then continue searching to right of the pattern for border */\\n\\t\\t\\twhile (j <= m && pattern[i - 1] != pattern[j - 1]) {\\n\\t\\t\\t\\t/* the character preceding the occurrence of t in pattern P is different than the mismatching  \\n\\t               character in P, we stop skipping the occurrences and shift the pattern from i to j */\\n\\t\\t\\t\\tif (shift[j] == 0) {\\n\\t\\t\\t\\t\\tshift[j] = j - i;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tj = borderPosition[j]; // get the start position of the border of suffix pattern[j] ... pattern[m-1]\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\t// pattern[i-1] matched with pattern[j-1], border is found. store the beginning position of border \\n\\t\\t\\ti--;\\n\\t\\t\\tj--;\\n\\t\\t\\tborderPosition[i] = j;\\n\\t\\t}\\n\\t\\treturn shift;\\n\\t}\\n\\t\\n\\tpublic void preprocessPartialSuffix(int[] borderPosition, int[] shift, int m) {\\n\\t\\tint i, j;\\n\\t\\tj = borderPosition[0];\\n\\t\\tfor (i = 0; i <= m; i++) {\\n\\t\\t\\t/* set the border position of the first character of the pattern to all indices \\n\\t\\t\\t   in array shift having shift[i] = 0 */\\n\\t\\t\\tif (shift[i] == 0) {\\n\\t\\t\\t\\tshift[i] = j;\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\t/* suffix becomes shorter than borderPosition[0], use the position of next widest border as value of j */\\n\\t\\t\\tif (i == j) {\\n\\t\\t\\t\\tj = borderPosition[j];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n```\\n\\nThe Boyer\\u2013Moore algorithm as presented in the original paper has worst-case running time of O(n+m) only if the pattern does not appear in the text. When the pattern does occur in the text, running time of the original algorithm is O(nm) in the worst case. \\nIf the alphabet is large compared to the length of the pattern, the algorithm performs O(n/m) comparisons on the average. So Boyer-Moore algorithm is **extremely fast on large texts** (relative to the length of the pattern)\\nFor the very shortest patterns, the naive algorithm may be better.\\n\\nAny suggestions/feedbacks/improvements are welcome.\\n\\nHappy searching!",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n//Boyer-Moore substring search using both bad-character and good-suffix heuristics simultaneously\\n\\tpublic int strStr(String haystack, String needle) {\\n\\t\\tif (haystack == null || needle == null || haystack.length() < needle.length()) {\\n\\t\\t\\treturn -1;\\n\\t\\t} else if (needle.isEmpty()) {\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\t\\t\\n\\t\\tchar[] text = haystack.toCharArray();\\n\\t\\tchar[] pattern = needle.toCharArray();\\n\\t\\t\\n\\t\\tint[] borderPosition = new int[pattern.length+1]; /* referred as f in academic literatures;\\n\\t\\tf[i] contains the starting position of the widest border of the suffix of the pattern beginning at position i */\\n\\t\\tint[] shift = new int[pattern.length+1]; /* referred as s in academic literatures; \\n\\t\\tEach entry s[i] contains the shift distance of the pattern if a mismatch at position i \\u2013 1 occurs, \\n\\t\\ti.e. if the suffix of the pattern starting at position i has matched */\\n\\t\\tint alphabetSize = 256;\\n\\t\\t\\n\\t\\tint[] lastOccurence = preprocessBadCharacters(pattern, alphabetSize); // bad characters heuristic\\n\\t\\tpreprocessStrongSuffix(pattern, borderPosition, shift); //good suffix heuristic case 1\\n\\t\\tpreprocessPartialSuffix(borderPosition, shift, pattern.length); //good suffix heuristic case 2\\n\\t\\t// good-suffix reference: https://stackoverflow.com/questions/19345263/boyer-moore-good-suffix-heuristics\\n\\t\\t\\n\\t\\tint i=0, j; // i is start index of current window in text \\n\\t\\twhile(i<=text.length-pattern.length) {\\n\\t\\t\\tj = pattern.length-1; // we process pattern from right to left backwards\\n\\t\\t\\twhile(j>=0 && pattern[j]==text[i+j]) { // go left backwards till characters are matching in current window\\n\\t\\t\\t\\tj--;\\n\\t\\t\\t}\\n\\t\\t\\tif(j<0) { // will be true only when there was a complete match found for pattern in text\\n\\t\\t\\t\\treturn i; //report match found\\n\\t\\t\\t\\t//use i=i+shift[0] if we want to find starting indices for all multiple matches\\n\\t\\t\\t} else { // mismatch found in current window comparison\\n\\t\\t\\t\\t/*  After a mismatch the pattern is shifted by the maximum of the values \\n\\t\\t\\t\\t    given by the good-suffix and the bad-character heuristics */\\n\\t\\t\\t\\ti = i + Math.max(shift[j+1], j-lastOccurence[text[i+j]]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn -1;\\n\\t}\\n\\t\\n\\tpublic int[] preprocessBadCharacters(char[] pattern, int alphabetSize) {\\n\\t\\tint[] lastOccurence = new int[alphabetSize]; //contains last occurrence index of each character in pattern\\n\\t\\tArrays.fill(lastOccurence, -1);\\n\\n\\t\\tfor (int i = 0; i < pattern.length; i++) {\\n\\t\\t\\tlastOccurence[pattern[i]] = i;\\n\\t\\t}\\n\\n\\t\\treturn lastOccurence;\\n\\t}\\n\\t\\n\\tpublic int[] preprocessStrongSuffix(char[] pattern, int[] borderPosition, int[] shift) {\\n\\t\\tint m = pattern.length;\\n\\t\\t\\n\\t\\tint i = m, j = m + 1;\\n\\t\\tborderPosition[i] = j; // The suffix \\u03B5 beginning at position m has no border, therefore f[m] is set to m+1\\n\\t\\twhile (i > 0) {\\n\\t\\t\\t/* at this line, we know f[i], f[i+1], ... f[m]; If character at position i-1 is not  \\n               equal to character at j-1, then continue searching to right of the pattern for border */\\n\\t\\t\\twhile (j <= m && pattern[i - 1] != pattern[j - 1]) {\\n\\t\\t\\t\\t/* the character preceding the occurrence of t in pattern P is different than the mismatching  \\n\\t               character in P, we stop skipping the occurrences and shift the pattern from i to j */\\n\\t\\t\\t\\tif (shift[j] == 0) {\\n\\t\\t\\t\\t\\tshift[j] = j - i;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tj = borderPosition[j]; // get the start position of the border of suffix pattern[j] ... pattern[m-1]\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\t// pattern[i-1] matched with pattern[j-1], border is found. store the beginning position of border \\n\\t\\t\\ti--;\\n\\t\\t\\tj--;\\n\\t\\t\\tborderPosition[i] = j;\\n\\t\\t}\\n\\t\\treturn shift;\\n\\t}\\n\\t\\n\\tpublic void preprocessPartialSuffix(int[] borderPosition, int[] shift, int m) {\\n\\t\\tint i, j;\\n\\t\\tj = borderPosition[0];\\n\\t\\tfor (i = 0; i <= m; i++) {\\n\\t\\t\\t/* set the border position of the first character of the pattern to all indices \\n\\t\\t\\t   in array shift having shift[i] = 0 */\\n\\t\\t\\tif (shift[i] == 0) {\\n\\t\\t\\t\\tshift[i] = j;\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\t/* suffix becomes shorter than borderPosition[0], use the position of next widest border as value of j */\\n\\t\\t\\tif (i == j) {\\n\\t\\t\\t\\tj = borderPosition[j];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 471856,
                "title": "python-very-easy-solution",
                "content": "```\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        if needle in haystack:\\n            return haystack.index(needle)\\n        return -1\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        if needle in haystack:\\n            return haystack.index(needle)\\n        return -1\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 262799,
                "title": "python-kmp-solution-with-comments",
                "content": "```python\\nclass Solution:\\n    \\n    ################################\\n    # The simpler pythonic method: #\\n    ################################\\n    # if not needle:\\n    #     return 0    \\n    # return haystack.index(needle) if (needle in haystack) else -1\\n\\n    \\n    ########################\\n    # Create the KMP array #\\n    ########################\\n    def kmp_partial(self, pat):\\n        ret = [0]\\n        for i in range(1, len(pat)):\\n            j = ret[i-1]\\n            while j > 0 and pat[i] != pat[j]:\\n                j = ret[j-1]\\n            ret.append(j+1 if pat[i] == pat[j] else j)\\n        return ret\\n    # End of kmp_partial(...)\\n    \\n    \\n    ##################################\\n    # Find the pattern in the string #\\n    ##################################\\n    def strStr(self, string: str, pattern: str) -> int:\\n        \\n        if not pattern: \\n            return 0\\n        \\n        KMP = self.kmp_partial(pattern)\\n        j = 0\\n        \\n        for i in range(len(string)):\\n            \\n            # While \"j\" is larger than zero (coz we may call \"j-1\") and string[i] != pattern[j]...\\n            # \"j\" is updated/decremented (recall that \"j\" is a pointer to the KMP array)\\n            # \\n            # When the while loop ends, either \"j\" becomes zero.. or\\n            # string[i] == pattern[j]\\n            while j > 0 and string[i] != pattern[j]:\\n                j = KMP[j-1]\\n            \\n            # Next, we check if the characters in string and pattern match. \\n            # If they do, increment \"j\" (note that \"i\" is always incremented automatically by the outer for loop).\\n            if string[i] == pattern[j]:\\n                j += 1\\n                \\n            # Check if pointer \"j\" is out of the pattern, if it is, it means we\\'ve found the pattern in the string.\\n            if j == len(pattern):\\n                return (i - j + 1)\\n\\t\\t\\t\\t\\n        # End of for loop.\\n        return -1\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    \\n    ################################\\n    # The simpler pythonic method: #\\n    ################################\\n    # if not needle:\\n    #     return 0    \\n    # return haystack.index(needle) if (needle in haystack) else -1\\n\\n    \\n    ########################\\n    # Create the KMP array #\\n    ########################\\n    def kmp_partial(self, pat):\\n        ret = [0]\\n        for i in range(1, len(pat)):\\n            j = ret[i-1]\\n            while j > 0 and pat[i] != pat[j]:\\n                j = ret[j-1]\\n            ret.append(j+1 if pat[i] == pat[j] else j)\\n        return ret\\n    # End of kmp_partial(...)\\n    \\n    \\n    ##################################\\n    # Find the pattern in the string #\\n    ##################################\\n    def strStr(self, string: str, pattern: str) -> int:\\n        \\n        if not pattern: \\n            return 0\\n        \\n        KMP = self.kmp_partial(pattern)\\n        j = 0\\n        \\n        for i in range(len(string)):\\n            \\n            # While \"j\" is larger than zero (coz we may call \"j-1\") and string[i] != pattern[j]...\\n            # \"j\" is updated/decremented (recall that \"j\" is a pointer to the KMP array)\\n            # \\n            # When the while loop ends, either \"j\" becomes zero.. or\\n            # string[i] == pattern[j]\\n            while j > 0 and string[i] != pattern[j]:\\n                j = KMP[j-1]\\n            \\n            # Next, we check if the characters in string and pattern match. \\n            # If they do, increment \"j\" (note that \"i\" is always incremented automatically by the outer for loop).\\n            if string[i] == pattern[j]:\\n                j += 1\\n                \\n            # Check if pointer \"j\" is out of the pattern, if it is, it means we\\'ve found the pattern in the string.\\n            if j == len(pattern):\\n                return (i - j + 1)\\n\\t\\t\\t\\t\\n        # End of for loop.\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 12817,
                "title": "straight-forward-c-solution-3-to-6ms",
                "content": "I felt like this was the obvious answer yet I didn't see it posted, so I decided to do so myself.\\n```\\n    int strStr(string haystack, string needle) \\n    {\\n        for (int i = 0; i <= (int)(haystack.length() - needle.length()); i++)\\n        {\\n            if (haystack.substr(i, needle.length()) == needle)\\n                return i;\\n        }\\n        return -1;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n    int strStr(string haystack, string needle) \\n    {\\n        for (int i = 0; i <= (int)(haystack.length() - needle.length()); i++)\\n        {\\n            if (haystack.substr(i, needle.length()) == needle)\\n                return i;\\n        }\\n        return -1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 13323,
                "title": "a-simple-python-solution",
                "content": "    class Solution:\\n        # @param haystack, a string\\n        # @param needle, a string\\n        # @return an integer\\n        def strStr(self, haystack, needle):\\n            if haystack == needle == '':\\n                return 0\\n    \\n            n = len(needle)\\n            \\n            for i in range(len(haystack) - n + 1):\\n                if haystack[i:i+n] == needle:\\n                    return i\\n    \\n            return -1",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution:\\n        # @param haystack, a string\\n        # @param needle, a string\\n        # @return an integer\\n        def strStr(self, haystack, needle):\\n            if haystack == needle == '':\\n                return 0\\n    \\n            n = len(needle)\\n            \\n            for i in range(len(haystack) - n + 1):\\n                if haystack[i:i+n] == needle:\\n                    return i\\n    \\n            return -1",
                "codeTag": "Java"
            },
            {
                "id": 4083931,
                "title": "one-line-of-code-beats-100-of-users",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n*m)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        return haystack.find(needle);\\n    }\\n};\\n```\\n\\n\\n![leet.jpeg](https://assets.leetcode.com/users/images/93e583bc-f206-4267-a4ec-f2e5c1d7ba4f_1695616472.7812035.jpeg)",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        return haystack.find(needle);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3494587,
                "title": "simple-js-ts-hack",
                "content": "# Code\\n```\\nfunction strStr(haystack: string, needle: string): number {\\n    return haystack.indexOf(needle)\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction strStr(haystack: string, needle: string): number {\\n    return haystack.indexOf(needle)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2701316,
                "title": "java-100-faster-in-just-1-line",
                "content": "# Code\\n```\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n        return haystack.indexOf(needle);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n        return haystack.indexOf(needle);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2636449,
                "title": "python-85-faster-try-except",
                "content": "simple enough to return the index  in the try and if it errors return the -1 in the except block.\\n\\n```\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        try:\\n            return(haystack.index(needle))\\n        except:\\n            return(-1)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        try:\\n            return(haystack.index(needle))\\n        except:\\n            return(-1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2291527,
                "title": "c-0ms-rabin-karp-detailed-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    int rabinKarp(string &text, string &pattern){\\n        long BASE = 26, MOD = 1e9+7;\\n        long power = 1;\\n        \\n        for(int i=1; i<pattern.size(); i++){\\n            power = (power*BASE) % MOD;\\n        }\\n\\t\\t\\n         // Find the hash value of the pattern and text\\n        long pattern_hash = 0;\\n        long text_hash = 0;\\n\\t\\t\\n        for(int i=0; i<pattern.size(); i++){\\n            pattern_hash = (pattern_hash*BASE + (pattern[i]-\\'a\\'+1)) % MOD;\\n            text_hash = (text_hash*BASE + (text[i]-\\'a\\'+1)) % MOD;\\n        }\\n        \\n        if(pattern_hash == text_hash){\\n            return 0;\\n        }\\n        \\n        // While moving the window, perform two steps: \\n        // 1) Remove the left most character from the window\\n        // 2) Add the new character to the window\\n\\n        int start = 0;\\n        for(int i=pattern.size(); i<text.size(); i++){\\n            // Step1: Removing left character\\n            int ch = text[start++]-\\'a\\'+1;\\n            text_hash = text_hash-(ch*power);\\n            \\n            // Step2: Adding new character\\n            text_hash = (text_hash*BASE + (text[i]-\\'a\\'+1))%MOD;\\n\\t\\t\\t\\n\\t\\t\\t// To avoid negative hash values\\n            if(text_hash < 0){\\n                text_hash += MOD;\\n            }\\n\\t\\t\\t\\n\\t\\t\\t// Hash values of the pattern and text match\\n            if(text_hash == pattern_hash){\\n                return start;\\n            }\\n        }\\n\\t\\treturn -1;\\n    }\\n    \\n    int strStr(string haystack, string needle) {\\n        if(needle.size() == 0)\\n            return 0;\\n        return rabinKarp(haystack, needle);\\n    }\\n};\\n```\\n```\\ncout << \"Upvote the solution if you like it !!\" << endl;\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int rabinKarp(string &text, string &pattern){\\n        long BASE = 26, MOD = 1e9+7;\\n        long power = 1;\\n        \\n        for(int i=1; i<pattern.size(); i++){\\n            power = (power*BASE) % MOD;\\n        }\\n\\t\\t\\n         // Find the hash value of the pattern and text\\n        long pattern_hash = 0;\\n        long text_hash = 0;\\n\\t\\t\\n        for(int i=0; i<pattern.size(); i++){\\n            pattern_hash = (pattern_hash*BASE + (pattern[i]-\\'a\\'+1)) % MOD;\\n            text_hash = (text_hash*BASE + (text[i]-\\'a\\'+1)) % MOD;\\n        }\\n        \\n        if(pattern_hash == text_hash){\\n            return 0;\\n        }\\n        \\n        // While moving the window, perform two steps: \\n        // 1) Remove the left most character from the window\\n        // 2) Add the new character to the window\\n\\n        int start = 0;\\n        for(int i=pattern.size(); i<text.size(); i++){\\n            // Step1: Removing left character\\n            int ch = text[start++]-\\'a\\'+1;\\n            text_hash = text_hash-(ch*power);\\n            \\n            // Step2: Adding new character\\n            text_hash = (text_hash*BASE + (text[i]-\\'a\\'+1))%MOD;\\n\\t\\t\\t\\n\\t\\t\\t// To avoid negative hash values\\n            if(text_hash < 0){\\n                text_hash += MOD;\\n            }\\n\\t\\t\\t\\n\\t\\t\\t// Hash values of the pattern and text match\\n            if(text_hash == pattern_hash){\\n                return start;\\n            }\\n        }\\n\\t\\treturn -1;\\n    }\\n    \\n    int strStr(string haystack, string needle) {\\n        if(needle.size() == 0)\\n            return 0;\\n        return rabinKarp(haystack, needle);\\n    }\\n};\\n```\n```\\ncout << \"Upvote the solution if you like it !!\" << endl;\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2205390,
                "title": "rust-one-liner",
                "content": "```\\nimpl Solution {\\n    pub fn str_str(haystack: String, needle: String) -> i32 {\\n        haystack.find(&needle).map(|i| i as i32).unwrap_or(-1)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn str_str(haystack: String, needle: String) -> i32 {\\n        haystack.find(&needle).map(|i| i as i32).unwrap_or(-1)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1686108,
                "title": "most-pythonic-solution",
                "content": "```\\nclass Solution(object):\\n    def strStr(self, haystack, needle):\\n        \"\"\"\\n        :type haystack: str\\n        :type needle: str\\n        :rtype: int\\n        \"\"\"\\n        return haystack.find(needle)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def strStr(self, haystack, needle):\\n        \"\"\"\\n        :type haystack: str\\n        :type needle: str\\n        :rtype: int\\n        \"\"\"\\n        return haystack.find(needle)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1378970,
                "title": "annotated-java-solution-3ms-o-m-n",
                "content": "You can think of the needle as sliding along underneath the haystack.\\n\\n<table>\\n  <tr>\\n    <td>A</td>\\n    <td>B</td>\\n    <td>C</td>\\n\\t<td>D</td>\\n\\t<td>E</td>\\n\\n  </tr>\\n    <tr>\\n    <td>C</td>\\n    <td>D</td>\\n    <td>E</td>\\n\\t<td></td>\\n\\t<td></td>\\n  </tr>\\n</table>\\n \\n \\n <table>\\n  <tr>\\n    <td>A</td>\\n    <td>B</td>\\n    <td>C</td>\\n\\t<td>D</td>\\n\\t<td>E</td>\\n  </tr>\\n    <tr>\\n    <td></td>\\n    <td>C</td>\\n    <td>D</td>\\n\\t<td>E</td>\\n\\t<td></td>\\n  </tr>\\n</table>\\n\\n <table>\\n  <tr>\\n    <td>A</td>\\n    <td>B</td>\\n    <td>C</td>\\n\\t<td>D</td>\\n\\t<td>E</td>\\n  </tr>\\n    <tr>\\n    <td></td>\\n    <td></td>\\n    <td>C</td>\\n\\t<td>D </td>\\n\\t<td>E </td>\\n  </tr>\\n</table>\\n \\n\\nAs you slide the needle along you compare the chars of the needle to its counterpart in the haystack, but start\\nfrom the back. This helps tremendously due to the nature of the tests. It appears that there are many instances where the needle resembles a substring from the haystack up until the last char.\\n\\n```java\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n        \\n        if (needle.isEmpty())\\n            return 0;\\n\\n        // start iterating over the haystack (starting from 0 but end early to leave room for the tail end of the needle)\\n        for (int i = 0; i <= haystack.length() - needle.length(); i++) {\\n\\n            // start comparing the characters in the needle to the current view of the haystack\\n            // going in reverse allows you to exit early\\n            for (int j = needle.length() - 1; j >= 0; j--) {\\n\\n                if (haystack.charAt(i+j) != needle.charAt(j)) // if at any point they dont equal we can break\\n                    break;\\n\\n                if (j == 0) // if we reached the first/last char comparison without a break they must be equal\\n                    return i;\\n            }\\n\\n        }\\n        return - 1; // iterated over the whole haystack, breaking every time on the inner loop\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int strStr(String haystack, String needle) {\\n        \\n        if (needle.isEmpty())\\n            return 0;\\n\\n        // start iterating over the haystack (starting from 0 but end early to leave room for the tail end of the needle)\\n        for (int i = 0; i <= haystack.length() - needle.length(); i++) {\\n\\n            // start comparing the characters in the needle to the current view of the haystack\\n            // going in reverse allows you to exit early\\n            for (int j = needle.length() - 1; j >= 0; j--) {\\n\\n                if (haystack.charAt(i+j) != needle.charAt(j)) // if at any point they dont equal we can break\\n                    break;\\n\\n                if (j == 0) // if we reached the first/last char comparison without a break they must be equal\\n                    return i;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1263703,
                "title": "simple-c-solution-2-pointer-approach-without-using-pre-defined-functions",
                "content": "**Please upvote this post to motivate me in my quest of documenting leetcode solutions.**\\n```\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        if(needle == \"\") return 0;\\n        int n1 = haystack.size();\\n        int n2 = needle.size();\\n        int i = 0, j = 0;\\n        while(i < n1 && j < n2)\\n        {\\n            if(haystack[i] == needle[j])\\n            {\\n                j++;\\n            }\\n            else\\n            {\\n                i -= j;\\n                j = 0;\\n            }  \\n            i++;\\n        }\\n        if(j == n2) return (i - j);\\n        else return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        if(needle == \"\") return 0;\\n        int n1 = haystack.size();\\n        int n2 = needle.size();\\n        int i = 0, j = 0;\\n        while(i < n1 && j < n2)\\n        {\\n            if(haystack[i] == needle[j])\\n            {\\n                j++;\\n            }\\n            else\\n            {\\n                i -= j;\\n                j = 0;\\n            }  \\n            i++;\\n        }\\n        if(j == n2) return (i - j);\\n        else return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 722936,
                "title": "rust-0ms",
                "content": "```\\nimpl Solution {\\n    pub fn str_str(haystack: String, needle: String) -> i32 {\\n        let (hlen, nlen) = (haystack.len(), needle.len());\\n\\n        if nlen == 0 { return 0; }\\n        else if hlen < nlen { return -1; }\\n\\n        for i in 0..=(hlen - nlen) {\\n            if &haystack[i..i+nlen] == needle {\\n                return i as i32\\n            }\\n        }\\n\\n        -1\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimpl Solution {\\n    pub fn str_str(haystack: String, needle: String) -> i32 {\\n        let (hlen, nlen) = (haystack.len(), needle.len());\\n\\n        if nlen == 0 { return 0; }\\n        else if hlen < nlen { return -1; }\\n\\n        for i in 0..=(hlen - nlen) {\\n            if &haystack[i..i+nlen] == needle {\\n                return i as i32\\n            }\\n        }\\n\\n        -1\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 164206,
                "title": "python-solution",
                "content": "```\\nclass Solution(object):\\n    def strStr(self, haystack, needle):\\n        \"\"\"\\n        :type haystack: str\\n        :type needle: str\\n        :rtype: int\\n        \"\"\"\\n        if needle == \"\":\\n            return 0\\n        n = len(needle)\\n        m = len(haystack)\\n        if m < n:\\n            return -1\\n        else:\\n            for i in range(m-n+1):\\n                if haystack[i:i+n] == needle:\\n                    return i\\n            return -1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def strStr(self, haystack, needle):\\n        \"\"\"\\n        :type haystack: str\\n        :type needle: str\\n        :rtype: int\\n        \"\"\"\\n        if needle == \"\":\\n            return 0\\n        n = len(needle)\\n        m = len(haystack)\\n        if m < n:\\n            return -1\\n        else:\\n            for i in range(m-n+1):\\n                if haystack[i:i+n] == needle:\\n                    return i\\n            return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 13216,
                "title": "c-brute-force-solution",
                "content": "        \\n    int strStr(string haystack, string needle) {\\n        for (int i = 0; i < (int)(haystack.size()-needle.size()+1); i++) {\\n            int j = 0;\\n            while (j < needle.size() && haystack[i+j] == needle[j])\\n                j++;\\n            if (j == needle.size()) \\n                return i;\\n        }\\n        return -1;\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "        \\n    int strStr(string haystack, string needle) {\\n        for (int i = 0; i < (int)(haystack.size()-needle.size()+1); i++) {\\n            int j = 0;\\n            while (j < needle.size() && haystack[i+j] == needle[j])\\n                j++;\\n            if (j == needle.size()) \\n                return i;\\n        }\\n        return -1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 13281,
                "title": "shortest-4ms-c-solution",
                "content": "    class Solution {\\n    public:\\n        int strStr(string haystack, string needle) {\\n        int i = 0, j = 0, count = 0;\\n    \\tif (haystack.size() == 0 && needle.size() == 0 || needle.size() == 0) return 0;\\n    \\n    \\twhile (i < haystack.size())\\n    \\t{\\n    \\t\\tcount++;\\n    \\t\\tif (haystack[i++] != needle[j++]) { j = 0; i=i-count+1;count = 0; }\\n    \\t\\tif (j == needle.size()) return i - count;\\n    \\t}\\n    \\treturn -1;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int strStr(string haystack, string needle) {\\n        int i = 0, j = 0, count = 0;\\n    \\tif (haystack.size() == 0 && needle.size() == 0 || needle.size() == 0) return 0;\\n    \\n    \\twhile (i < haystack.size())\\n    \\t{\\n    \\t\\tcount++;\\n    \\t\\tif (haystack[i++] != needle[j++]) { j = 0; i=i-count+1;count = 0; }",
                "codeTag": "Java"
            },
            {
                "id": 3611999,
                "title": "c-two-pointers-beginner-friendly",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n    \\n        \\n           int n = needle.size();\\n           int m = haystack.size();\\n        \\n            if(n==0) \\n            return 0;\\n        \\n        if(haystack.size() < needle.size())\\n            return -1;\\n        \\n      for(int i = 0; i<=(m-n);i++)\\n      {\\n          bool isBool = true;\\n          int indx;\\n          \\n         for(int j = 0; j<n; j++)\\n         {\\n             if(needle[j] !=haystack[j+i])\\n             {\\n                 isBool = false;\\n                 break;\\n             }\\n             \\n             indx = i;\\n         }\\n          \\n           if(isBool)\\n               return indx;\\n      }\\n       \\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n    \\n        \\n           int n = needle.size();\\n           int m = haystack.size();\\n        \\n            if(n==0) \\n            return 0;\\n        \\n        if(haystack.size() < needle.size())\\n            return -1;\\n        \\n      for(int i = 0; i<=(m-n);i++)\\n      {\\n          bool isBool = true;\\n          int indx;\\n          \\n         for(int j = 0; j<n; j++)\\n         {\\n             if(needle[j] !=haystack[j+i])\\n             {\\n                 isBool = false;\\n                 break;\\n             }\\n             \\n             indx = i;\\n         }\\n          \\n           if(isBool)\\n               return indx;\\n      }\\n       \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3361717,
                "title": "c-solution-beats-100",
                "content": "# Code\\n```\\nint strStr(char * haystack, char * needle){\\n    if (strlen(needle) > strlen(haystack))\\n        return -1;\\n\\n    for (int i = 0; i < strlen(haystack); i++) {\\n        if (!strncmp(haystack + i, needle, strlen(needle))) \\n            return i;\\n    }\\n\\n    return -1;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String",
                    "String Matching"
                ],
                "code": "```\\nint strStr(char * haystack, char * needle){\\n    if (strlen(needle) > strlen(haystack))\\n        return -1;\\n\\n    for (int i = 0; i < strlen(haystack); i++) {\\n        if (!strncmp(haystack + i, needle, strlen(needle))) \\n            return i;\\n    }\\n\\n    return -1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3288858,
                "title": "simple-brute-force-method",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nwe need to check all substring of haystack \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ndivide substring same length as needle length then compare with the needle\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n**2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\n/**\\n * @param {string} haystack\\n * @param {string} needle\\n * @return {number}\\n */\\nvar strStr = function(haystack, needle) {\\n    \\n\\n    for(let i=0;i<=haystack.length-needle.length;i++){\\n        let str=\"\"\\n       for(let j=i;j<i+needle.length;j++){\\n            str+=haystack[j]\\n        }\\n        if(str==needle){\\n            return i\\n        }\\n\\n    }\\n    return -1\\n  \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} haystack\\n * @param {string} needle\\n * @return {number}\\n */\\nvar strStr = function(haystack, needle) {\\n    \\n\\n    for(let i=0;i<=haystack.length-needle.length;i++){\\n        let str=\"\"\\n       for(let j=i;j<i+needle.length;j++){\\n            str+=haystack[j]\\n        }\\n        if(str==needle){\\n            return i\\n        }\\n\\n    }\\n    return -1\\n  \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3257529,
                "title": "python-short-and-clean-5-different-solutions-functional-programming",
                "content": "# Approach 1: Two pointers\\nThis is the standard brute force with two pointer approach.\\nUsually `haystack` is so long that it doesn\\'t fit in memory. These are called `online` input problems.\\nThe rest of the solutions assume this to be the case, and solve for generic cases.\\n\\n# Complexity\\n- Time complexity: $$O(n * m)$$\\n\\n- Space complexity: $$O(1)$$\\n\\nwhere,\\n`n is length of haystack`,\\n`m is length of needle`.\\n\\n# Code\\n```python\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        for i in range(len(haystack) - len(needle) + 1):\\n            if all(haystack[i + j] == needle[j] for j in range(len(needle))):\\n                return i\\n        return -1\\n\\n\\n```\\n\\n---\\n\\n# Approach 2: Brute Force, Sliding Window\\n\\n# Complexity\\n- Time complexity: $$O(n * m)$$\\n\\n- Space complexity: $$O(m)$$\\n\\nwhere,\\n`n is length of haystack`,\\n`m is length of needle`.\\n\\n# Code\\n```python\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        return next(substring_brute_force(haystack, needle), -1)\\n\\n\\nT = Hashable\\ndef substring_brute_force(haystack: Iterable[T], needle: Sequence[T]) -> Iterable[int]:\\n    haystack = iter(haystack)\\n    window = deque(islice(haystack, len(needle) - 1), maxlen=len(needle))\\n    for i, x in enumerate(haystack):\\n        window.append(x)\\n        if all(starmap(eq, zip_longest(window, needle, fillvalue=\"\"))):\\n            yield i\\n\\n\\n```\\n\\n---\\n\\n# Approach 3: [Knuth-Morris-Pratt](https://en.wikipedia.org/wiki/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm)\\n\\n# Complexity\\n- Time complexity: $$O(n + m)$$\\n\\n- Space complexity: $$O(m)$$\\n\\nwhere,\\n`n is length of haystack`,\\n`m is length of needle`.\\n\\n# Code\\n```python\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        return next(substring_knuth_morris_pratt(haystack, needle), -1)\\n\\n\\nT = Hashable\\ndef substring_knuth_morris_pratt(haystack: Iterable[T], needle: Iterable[T]) -> Iterable[int]:\\n    DFA = Sequence[Mapping[T, int]]\\n\\n    def dfa(xs: Iterable[T]) -> DFA:\\n        transitions = []\\n\\n        t = defaultdict(int)\\n        for i, x in enumerate(xs):\\n            transitions.append(t | {x: i + 1})\\n            t = transitions[t[x]]\\n\\n        return transitions\\n\\n    needle_dfa = dfa(needle)\\n    end_state = len(needle_dfa)\\n\\n    states = accumulate(haystack, lambda st, x: needle_dfa[st][x], initial=0)\\n    return (i - end_state for i, st in enumerate(states) if st == end_state)\\n\\n\\n```\\n\\n---\\n\\n# Approach 4: [Boyer-Moore](https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_string-search_algorithm)\\n\\n# Complexity\\n- Time complexity: $$O(n + m)$$\\n\\n- Space complexity: $$O(m)$$\\n\\nwhere,\\n`n is length of haystack`,\\n`m is length of needle`.\\n\\n# Code\\n```python\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        return next(substring_boyer_moore(haystack, needle), -1)\\n\\n\\nT = Hashable\\ndef substring_boyer_moore(haystack: Iterable[T], needle: Sequence[T]) -> Iterable[int]:\\n    SkipTable = Mapping[T, int]\\n\\n    def skip_table(xs: Iterable[T]) -> SkipTable:\\n        return defaultdict(lambda: -1, {ch: i for i, ch in enumerate(xs)})\\n\\n    n = len(needle)\\n    skip_t = skip_table(needle)\\n    \\n    haystack = iter(haystack)\\n    xs = tuple(islice(haystack, n))\\n    if len(xs) < n: return\\n    window = deque(xs, maxlen=n)\\n\\n    i = 0\\n    while xs:\\n        j = next((j for j in range(n - 1, -1, -1) if window[j] != needle[j]), -1)\\n        if j < 0: yield i\\n        steps = max(1, j - skip_t[window[j]])\\n        xs = tuple(islice(haystack, steps))\\n        window.extend(xs)\\n        i += steps\\n\\n\\n```\\n\\n---\\n\\n# Approach 5: [Rabin-Karp](https://en.wikipedia.org/wiki/Rabin%E2%80%93Karp_algorithm)\\n\\n# Complexity\\n- Time complexity: $$O(n + m)$$\\n\\n- Space complexity: $$O(1)$$\\n\\nwhere,\\n`n is length of haystack`,\\n`m is length of needle`.\\n\\n# Code\\n```python\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        hash_fn = {ch: i for i, ch in enumerate(ascii_lowercase, 1)}.__getitem__\\n        return next(substring_rabin_karp(haystack, needle, h_fn=hash_fn), -1)\\n\\n\\nT = Hashable\\nHashFn = Callable[[T], int]\\ndef substring_rabin_karp(haystack: Iterable[T], needle: Iterable[T], * h_fn: HashFn = hash, R: int = 256, Q: int = 1_000_000_007) -> Iterable[int]:\\n    HashValue = int\\n\\n    def hash_(xs: Iterable[T]) -> HashValue:\\n        return reduce(lambda h, x: (h * R + h_fn(x)) % Q, xs, 0)\\n\\n    def rolling_hashes(xs: Iterable[T], k: int) -> Iterable[HashValue]:\\n        xs1, xs2 = iter(xs), iter(xs)\\n        xs_hash = hash_(islice(xs2, k))\\n        RM = pow(R, len(needle), Q)\\n\\n        roll = lambda h, x1x2: ((h * R + h_fn(x1x2[1])) % Q - (h_fn(x1x2[0]) * RM) % Q) % Q\\n\\n        return accumulate(zip(xs1, xs2), roll, initial=xs_hash)\\n\\n    haystack_hashes = rolling_hashes(haystack, len(needle))\\n    needle_hash = hash_(needle)\\n\\n    return (i for i, h in enumerate(haystack_hashes) if h == needle_hash)\\n\\n\\n```\\n\\n---",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String",
                    "String Matching"
                ],
                "code": "```python\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        for i in range(len(haystack) - len(needle) + 1):\\n            if all(haystack[i + j] == needle[j] for j in range(len(needle))):\\n                return i\\n        return -1\\n\\n\\n```\n```python\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        return next(substring_brute_force(haystack, needle), -1)\\n\\n\\nT = Hashable\\ndef substring_brute_force(haystack: Iterable[T], needle: Sequence[T]) -> Iterable[int]:\\n    haystack = iter(haystack)\\n    window = deque(islice(haystack, len(needle) - 1), maxlen=len(needle))\\n    for i, x in enumerate(haystack):\\n        window.append(x)\\n        if all(starmap(eq, zip_longest(window, needle, fillvalue=\"\"))):\\n            yield i\\n\\n\\n```\n```python\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        return next(substring_knuth_morris_pratt(haystack, needle), -1)\\n\\n\\nT = Hashable\\ndef substring_knuth_morris_pratt(haystack: Iterable[T], needle: Iterable[T]) -> Iterable[int]:\\n    DFA = Sequence[Mapping[T, int]]\\n\\n    def dfa(xs: Iterable[T]) -> DFA:\\n        transitions = []\\n\\n        t = defaultdict(int)\\n        for i, x in enumerate(xs):\\n            transitions.append(t | {x: i + 1})\\n            t = transitions[t[x]]\\n\\n        return transitions\\n\\n    needle_dfa = dfa(needle)\\n    end_state = len(needle_dfa)\\n\\n    states = accumulate(haystack, lambda st, x: needle_dfa[st][x], initial=0)\\n    return (i - end_state for i, st in enumerate(states) if st == end_state)\\n\\n\\n```\n```python\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        return next(substring_boyer_moore(haystack, needle), -1)\\n\\n\\nT = Hashable\\ndef substring_boyer_moore(haystack: Iterable[T], needle: Sequence[T]) -> Iterable[int]:\\n    SkipTable = Mapping[T, int]\\n\\n    def skip_table(xs: Iterable[T]) -> SkipTable:\\n        return defaultdict(lambda: -1, {ch: i for i, ch in enumerate(xs)})\\n\\n    n = len(needle)\\n    skip_t = skip_table(needle)\\n    \\n    haystack = iter(haystack)\\n    xs = tuple(islice(haystack, n))\\n    if len(xs) < n: return\\n    window = deque(xs, maxlen=n)\\n\\n    i = 0\\n    while xs:\\n        j = next((j for j in range(n - 1, -1, -1) if window[j] != needle[j]), -1)\\n        if j < 0: yield i\\n        steps = max(1, j - skip_t[window[j]])\\n        xs = tuple(islice(haystack, steps))\\n        window.extend(xs)\\n        i += steps\\n\\n\\n```\n```python\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        hash_fn = {ch: i for i, ch in enumerate(ascii_lowercase, 1)}.__getitem__\\n        return next(substring_rabin_karp(haystack, needle, h_fn=hash_fn), -1)\\n\\n\\nT = Hashable\\nHashFn = Callable[[T], int]\\ndef substring_rabin_karp(haystack: Iterable[T], needle: Iterable[T], * h_fn: HashFn = hash, R: int = 256, Q: int = 1_000_000_007) -> Iterable[int]:\\n    HashValue = int\\n\\n    def hash_(xs: Iterable[T]) -> HashValue:\\n        return reduce(lambda h, x: (h * R + h_fn(x)) % Q, xs, 0)\\n\\n    def rolling_hashes(xs: Iterable[T], k: int) -> Iterable[HashValue]:\\n        xs1, xs2 = iter(xs), iter(xs)\\n        xs_hash = hash_(islice(xs2, k))\\n        RM = pow(R, len(needle), Q)\\n\\n        roll = lambda h, x1x2: ((h * R + h_fn(x1x2[1])) % Q - (h_fn(x1x2[0]) * RM) % Q) % Q\\n\\n        return accumulate(zip(xs1, xs2), roll, initial=xs_hash)\\n\\n    haystack_hashes = rolling_hashes(haystack, len(needle))\\n    needle_hash = hash_(needle)\\n\\n    return (i for i, h in enumerate(haystack_hashes) if h == needle_hash)\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3251442,
                "title": "443-string-compression-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        int ans=-1;\\n        int k=0;  \\n        int niddilesize=needle.size();\\n        while(k<haystack.size()){\\n        auto itr=find(haystack.begin()+k,haystack.end(),needle[0]);\\n        int n=itr-haystack.begin();\\n        string str=haystack.substr(n,niddilesize);\\n        if(str==needle){\\n           ans=n; \\n            break;\\n        }\\n       else \\n           k=k+1;\\n           continue;\\n         }\\n        \\n        if(ans==-1)\\n            return -1;\\n        else\\n            return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        int ans=-1;\\n        int k=0;  \\n        int niddilesize=needle.size();\\n        while(k<haystack.size()){\\n        auto itr=find(haystack.begin()+k,haystack.end(),needle[0]);\\n        int n=itr-haystack.begin();\\n        string str=haystack.substr(n,niddilesize);\\n        if(str==needle){\\n           ans=n; \\n            break;\\n        }\\n       else \\n           k=k+1;\\n           continue;\\n         }\\n        \\n        if(ans==-1)\\n            return -1;\\n        else\\n            return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3250089,
                "title": "find-the-index-of-the-first-occurrence-in-a-string-solving-the-leetcode-challenge-march-3-2023",
                "content": "![image.png](https://assets.leetcode.com/users/images/d5bd5c46-5f44-4fa7-820f-dd165a96fb91_1677816522.0925934.png)\\n\\n# Full explaination at : [Solution](https://yoichiisagi.hashnode.dev/find-the-index-of-the-first-occurrence-in-a-string-solving-the-leetcode-challenge-march-3-2023)\\n\\n![image.png](https://assets.leetcode.com/users/images/6907ce4f-a766-4668-bd51-1cedade65e46_1677816533.0083919.png)\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n    int n = needle.length();\\n    if (n == 0) {\\n        return 0;\\n    }\\n    int m = haystack.length();\\n    if (m < n) {\\n        return -1;\\n    }\\n    for (int i = 0; i <= m - n; i++) {\\n        if (haystack.substring(i, i + n).equals(needle)) {\\n            return i;\\n        }\\n    }\\n    return -1;\\n}\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n    int n = needle.length();\\n    if (n == 0) {\\n        return 0;\\n    }\\n    int m = haystack.length();\\n    if (m < n) {\\n        return -1;\\n    }\\n    for (int i = 0; i <= m - n; i++) {\\n        if (haystack.substring(i, i + n).equals(needle)) {\\n            return i;\\n        }\\n    }\\n    return -1;\\n}\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3249866,
                "title": "leetcode-the-hard-way-z-algorithm",
                "content": "\\uD83D\\uDD34 Check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. \\n\\uD83D\\uDFE0 Check out our [Discord Study Group](https://discord.gg/Nqm4jJcyBf) for live discussion.\\n\\uD83D\\uDFE2 Give a star on [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way) and upvote this post if you like it.\\n\\uD83D\\uDD35 Check out [YouTube Channel](https://www.youtube.com/@leetcodethehardway) if you are interested.\\n\\n---\\n\\n```cpp\\nclass Solution {\\npublic:\\n    // z-algorithm\\n    vector<int> z_function(string s) {\\n        int n = (int) s.length();\\n        vector<int> z(n);\\n        for (int i = 1, l = 0, r = 0; i < n; ++i) {\\n            if (i <= r)\\n                z[i] = min (r - i + 1, z[i - l]);\\n            while (i + z[i] < n && s[z[i]] == s[i + z[i]])\\n                ++z[i];\\n            if (i + z[i] - 1 > r)\\n                l = i, r = i + z[i] - 1;\\n        }\\n        return z;\\n    }\\n    \\n    int strStr(string haystack, string needle) {\\n        int k = (int) needle.size();\\n        if(haystack == needle || k == 0) return 0;\\n        string s = needle + \"$\" + haystack;\\n        vector<int> z = z_function(s);\\n        int n = (int) s.size();\\n        for(int i = 0; i < n; i++) {\\n            if(z[i] == k) {\\n                return i - k - 1;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    // z-algorithm\\n    vector<int> z_function(string s) {\\n        int n = (int) s.length();\\n        vector<int> z(n);\\n        for (int i = 1, l = 0, r = 0; i < n; ++i) {\\n            if (i <= r)\\n                z[i] = min (r - i + 1, z[i - l]);\\n            while (i + z[i] < n && s[z[i]] == s[i + z[i]])\\n                ++z[i];\\n            if (i + z[i] - 1 > r)\\n                l = i, r = i + z[i] - 1;\\n        }\\n        return z;\\n    }\\n    \\n    int strStr(string haystack, string needle) {\\n        int k = (int) needle.size();\\n        if(haystack == needle || k == 0) return 0;\\n        string s = needle + \"$\" + haystack;\\n        vector<int> z = z_function(s);\\n        int n = (int) s.size();\\n        for(int i = 0; i < n; i++) {\\n            if(z[i] == k) {\\n                return i - k - 1;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3249810,
                "title": "1-liner-code-in-java-simplest-code-ever",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(log n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n        return haystack.indexOf(needle);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n        return haystack.indexOf(needle);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3249778,
                "title": "python3-two-pointers-27-ms-faster-than-90-82",
                "content": "Time complexity: O(mn)  \\nhttps://leetcode.com/submissions/detail/908052808/  \\nRuntime: **27 ms, faster than 90.82%** of Python3 online submissions for Find the Index of the First Occurrence in a String.\\nMemory Usage: 13.9 MB, less than 54.52% of Python3 online submissions for Find the Index of the First Occurrence in a String.\\n```\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        l1, l2, p1, p2 = len(haystack), len(needle), 0, 0\\n        while p1<l1:\\n            if p2==l2:\\n                return p1-l2\\n            if haystack[p1]==needle[p2]:\\n                p2 += 1\\n            else:\\n                p1 = p1 - p2\\n                p2 = 0\\n            p1 += 1\\n        if p2==l2:\\n            return l1-l2\\n        return -1\\n```\\nSame solution with variant code  \\n```\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        l1, l2, p1, p2 = len(haystack), len(needle), 0, 0\\n        while p1<=l1:\\n            if p2==l2:\\n                return p1-l2\\n            elif p1==l1:\\n                return -1\\n            if haystack[p1]==needle[p2]:\\n                p2 += 1\\n            else:\\n                p1 = p1 - p2\\n                p2 = 0\\n            p1 += 1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        l1, l2, p1, p2 = len(haystack), len(needle), 0, 0\\n        while p1<l1:\\n            if p2==l2:\\n                return p1-l2\\n            if haystack[p1]==needle[p2]:\\n                p2 += 1\\n            else:\\n                p1 = p1 - p2\\n                p2 = 0\\n            p1 += 1\\n        if p2==l2:\\n            return l1-l2\\n        return -1\\n```\n```\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        l1, l2, p1, p2 = len(haystack), len(needle), 0, 0\\n        while p1<=l1:\\n            if p2==l2:\\n                return p1-l2\\n            elif p1==l1:\\n                return -1\\n            if haystack[p1]==needle[p2]:\\n                p2 += 1\\n            else:\\n                p1 = p1 - p2\\n                p2 = 0\\n            p1 += 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3249587,
                "title": "very-easy-100-easiest-logic-ever-fully-explained-step-by-step-c-javascript-java-python",
                "content": "\\n# Approach\\n**let result = haystack.indexOf(needle);** calls the **indexOf()** method on the needle param to find the index of the first occurrence of the needle variable within haystack. The resulting index is stored in a variable named result.\\n\\nThe **indexOf()** method returns the index of the first occurrence of the specified substring within the input string. If the substring is not found, it returns -1.\\n\\n# Complexity\\n### Time complexity:\\nThe time complexity of finding the index of the first occurrence of a substring in a string using the **indexOf()** method in JavaScript is **O(n)**, where n is the length of the input string.\\n\\nThe **indexOf()** method searches the input string character by character to find the first occurrence of the specified substring. In the worst case scenario, where the substring is not found in the string, the **indexOf()** method has to examine every character in the string before determining that the substring is not present. Therefore, the time complexity of this operation is proportional to the length of the input string, which is **O(n)**.\\n\\nNote that if the substring is found in the input string, the **indexOf()** method will return the index of the first occurrence of the substring, which may be less than n. However, in the worst case scenario, where the substring is not found, the time complexity is **O(n)**.\\n\\n# Code in Javascript\\n```\\n/**\\n * @param {string} haystack\\n * @param {string} needle\\n * @return {number}\\n */\\nvar strStr = function(haystack, needle) {\\n    let result = haystack.indexOf(needle);\\n    return result\\n};\\n```\\n# Code in Python\\n```\\n    // Call the find method on the input string to find the index of the first occurrence of the substring\\n    index = haystack.find(needle)\\n\\n    // Print the index to the console\\n    print(index)\\n```\\n\\n**I am working hard for you guys...\\nPlease upvote if you found any help with this code...**",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} haystack\\n * @param {string} needle\\n * @return {number}\\n */\\nvar strStr = function(haystack, needle) {\\n    let result = haystack.indexOf(needle);\\n    return result\\n};\\n```\n```\\n    // Call the find method on the input string to find the index of the first occurrence of the substring\\n    index = haystack.find(needle)\\n\\n    // Print the index to the console\\n    print(index)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3049597,
                "title": "c-simplified-rabin-karp-o-n-amortised",
                "content": "- If `haystack.substr == needle`, `xor(haystack.substr) == xor(needle)`\\n- If `haystack.substr` contain pairs of duplicate characters, they will cancel each other out (e.g. `xor(\"abb\") == xor(\"aaa\")`)\\n- Therefore we need to double check\\n\\n### C++\\n```\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        if (haystack.size() < needle.size()) return -1;\\n        \\n        int lock = 0, key = 0;\\n        for (int i=0; i<needle.size(); ++i) {\\n            lock ^= needle[i];\\n            key ^= haystack[i];\\n        }\\n\\n        for (int i=0; i<=haystack.size()-needle.size(); ++i) {\\n            if (key == lock && haystack.substr(i, needle.size()) == needle) return i;\\n            key ^= haystack[i] ^ haystack[i+needle.size()];\\n        }\\n\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        if (haystack.size() < needle.size()) return -1;\\n        \\n        int lock = 0, key = 0;\\n        for (int i=0; i<needle.size(); ++i) {\\n            lock ^= needle[i];\\n            key ^= haystack[i];\\n        }\\n\\n        for (int i=0; i<=haystack.size()-needle.size(); ++i) {\\n            if (key == lock && haystack.substr(i, needle.size()) == needle) return i;\\n            key ^= haystack[i] ^ haystack[i+needle.size()];\\n        }\\n\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3046505,
                "title": "two-pointer-cpp-easy",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        int ans=-1;\\n        int n=needle.size();\\n\\n        for(int i=0;i<haystack.size();i++)\\n        {\\n            if(haystack[i]==needle[0])\\n            {\\n                int flag=0;\\n                int index=1;\\n                \\n                while(index!=n)\\n                {\\n                    if((i+index)<haystack.size() && haystack[i+index]==needle[index])\\n                    {\\n                        index++;\\n                    }\\n                    else{\\n                        flag=1;\\n                        break;\\n                    }\\n                }\\n\\n                if(flag==0) \\n                {\\n                    ans=i;\\n                    return ans;\\n                }\\n            }\\n        }\\n\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        int ans=-1;\\n        int n=needle.size();\\n\\n        for(int i=0;i<haystack.size();i++)\\n        {\\n            if(haystack[i]==needle[0])\\n            {\\n                int flag=0;\\n                int index=1;\\n                \\n                while(index!=n)\\n                {\\n                    if((i+index)<haystack.size() && haystack[i+index]==needle[index])\\n                    {\\n                        index++;\\n                    }\\n                    else{\\n                        flag=1;\\n                        break;\\n                    }\\n                }\\n\\n                if(flag==0) \\n                {\\n                    ans=i;\\n                    return ans;\\n                }\\n            }\\n        }\\n\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2886099,
                "title": "c-0ms-faster-beats-100-o-n-tc-o-k-sc",
                "content": "\\n- Time complexity:O(n) where n is the size of haystack string\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(k) where k is the size of needle string\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        int m=haystack.size(),n=needle.size();\\n        int i=0;\\n        while(i<m){\\n            string str;\\n            if(haystack[i]==needle[0])  str=haystack.substr(i,n);\\n            if(str==needle) return i;\\n            i++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        int m=haystack.size(),n=needle.size();\\n        int i=0;\\n        while(i<m){\\n            string str;\\n            if(haystack[i]==needle[0])  str=haystack.substr(i,n);\\n            if(str==needle) return i;\\n            i++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2768073,
                "title": "100-faster-c-java-python-c-javascript-php-go-ruby-typescript-dart",
                "content": "**C++ Solution:**\\n\\n```\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        \\n        return haystack.find(needle);\\n    }\\n};\\n```\\n\\n**Java Solution:**\\n\\n```\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n        \\n        return haystack.indexOf(needle);\\n    }\\n}\\n```\\n\\n **Python Solution:**\\n \\n```\\nclass Solution(object):\\n    def strStr(self, haystack, needle):\\n        \"\"\"\\n        :type haystack: str\\n        :type needle: str\\n        :rtype: int\\n        \"\"\"\\n        return haystack.find(needle)\\n```\\n\\n **Javascript Solution:**\\n \\n```\\nvar strStr = function(haystack, needle) {\\n    return haystack.indexOf(needle);\\n};\\n```\\n\\n **Go Solution:** \\n \\n```\\nfunc strStr(haystack string, needle string) int {\\n    \\n    return strings.Index(haystack, needle);\\n}\\n```\\n\\n**C# Solution:**\\n```\\npublic class Solution {\\n    public int StrStr(string haystack, string needle) {\\n        return haystack.IndexOf(needle);\\n    }\\n}\\n```\\n\\n **Typescript Solution:**\\n \\n```\\nfunction strStr(haystack: string, needle: string): number {\\n    return haystack.indexOf(needle);\\n};\\n```\\n\\n **Ruby Solution:**\\n \\n```\\ndef str_str(haystack, needle)\\n\\n    return haystack.index(needle) != nil ? haystack.index(needle) : -1\\n        \\nend\\n```\\n\\n **Dart Solution:**\\n\\n```\\nclass Solution {\\n  int strStr(String haystack, String needle) {\\n      return haystack.indexOf(needle);\\n  }\\n}\\n```\\n\\n**PHP Solution:** \\n```\\nclass Solution {\\n\\n    /**\\n     * @param String $haystack\\n     * @param String $needle\\n     * @return Integer\\n     */\\n    function strStr($haystack, $needle) {\\n        echo strpos($haystack, $needle);\\n        if (strpos($haystack, $needle) !== false) {\\n            return strpos($haystack, $needle);\\n        } else {\\n            return -1;\\n        }\\n    }\\n}\\n```\\n\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "JavaScript",
                    "Ruby",
                    "Go",
                    "PHP",
                    "TypeScript"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        \\n        return haystack.find(needle);\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n        \\n        return haystack.indexOf(needle);\\n    }\\n}\\n```\n```\\nclass Solution(object):\\n    def strStr(self, haystack, needle):\\n        \"\"\"\\n        :type haystack: str\\n        :type needle: str\\n        :rtype: int\\n        \"\"\"\\n        return haystack.find(needle)\\n```\n```\\nvar strStr = function(haystack, needle) {\\n    return haystack.indexOf(needle);\\n};\\n```\n```\\nfunc strStr(haystack string, needle string) int {\\n    \\n    return strings.Index(haystack, needle);\\n}\\n```\n```\\npublic class Solution {\\n    public int StrStr(string haystack, string needle) {\\n        return haystack.IndexOf(needle);\\n    }\\n}\\n```\n```\\nfunction strStr(haystack: string, needle: string): number {\\n    return haystack.indexOf(needle);\\n};\\n```\n```\\ndef str_str(haystack, needle)\\n\\n    return haystack.index(needle) != nil ? haystack.index(needle) : -1\\n        \\nend\\n```\n```\\nclass Solution {\\n  int strStr(String haystack, String needle) {\\n      return haystack.indexOf(needle);\\n  }\\n}\\n```\n```\\nclass Solution {\\n\\n    /**\\n     * @param String $haystack\\n     * @param String $needle\\n     * @return Integer\\n     */\\n    function strStr($haystack, $needle) {\\n        echo strpos($haystack, $needle);\\n        if (strpos($haystack, $needle) !== false) {\\n            return strpos($haystack, $needle);\\n        } else {\\n            return -1;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2618444,
                "title": "kotlin-one-liner",
                "content": "```kotlin\\nclass Solution {\\n    fun strStr(haystack: String, needle: String): Int = haystack.indexOf(needle)\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```kotlin\\nclass Solution {\\n    fun strStr(haystack: String, needle: String): Int = haystack.indexOf(needle)\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2225081,
                "title": "c-0ms-faster-than-100-best-easiest-solution",
                "content": "**Note:** This is an updated version of a previous post I wrote, just changed some formatting.\\n\\n---\\nRelatively straightforward problem, just brute-forcing works marvelously. \\n\\nIn my taste, this should be an ```easy``` problem, but even if it is placed ```medium```, it is definitely in the easy portion of all the mediums on Leetcode.\\n\\nLet\\'s get in our problem.\\n\\nWe simply search for a possible substring with the first character of ```needle```. If it occurs, check if the other characters match with each other. If it works, return the ```index```. Or else, forget about it and continue.\\n\\nIf anything is **unclear**, feel free to **comment** below.\\n\\nHere is the code for reference. The **second tab** contains **detailed explanations line-by-line.**\\n\\n```C++ []\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        if (needle.size() > haystack.size()) return -1;\\n        for (int i = 0; i <= haystack.size() - needle.size(); i++) {\\n            if (needle[0] == haystack[i]) {\\n                bool flag = true;\\n                for (int j = 1; j < needle.size(); j++) if (needle[j] != haystack[i + j]) flag = false;\\n                if (flag) return i;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        // if the needle size is bigger than the haystack\\'s size, the needle would obviously be too big\\n        if (needle.size() > haystack.size()) return -1; \\n        for (int i = 0; i <= haystack.size() - needle.size(); i++) {\\n            // if first chars match each other, or if it is a possible candidate\\n            if (needle[0] == haystack[i]) { \\n                bool flag = true;\\n                // if any other letters don\\'t match, forget about it (flag = false)\\n                for (int j = 1; j < needle.size(); j++) if (needle[j] != haystack[i + j]) flag = false;\\n                // if the whole needle matches, with the haystack substring, return da answer!\\n                if (flag) return i; \\n            }\\n        }\\n        // else, simply return -1 because none can be found\\n        return -1;\\n    }\\n};\\n```\\n\\nYou do not need to upvote or whatever. Feel free to do it at your own will. At least, if you saw my solution, you are already supporting me deep in my heart.\\n\\nHappy coding!\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```easy```\n```medium```\n```needle```\n```index```\n```C++ []\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        if (needle.size() > haystack.size()) return -1;\\n        for (int i = 0; i <= haystack.size() - needle.size(); i++) {\\n            if (needle[0] == haystack[i]) {\\n                bool flag = true;\\n                for (int j = 1; j < needle.size(); j++) if (needle[j] != haystack[i + j]) flag = false;\\n                if (flag) return i;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        // if the needle size is bigger than the haystack\\'s size, the needle would obviously be too big\\n        if (needle.size() > haystack.size()) return -1; \\n        for (int i = 0; i <= haystack.size() - needle.size(); i++) {\\n            // if first chars match each other, or if it is a possible candidate\\n            if (needle[0] == haystack[i]) { \\n                bool flag = true;\\n                // if any other letters don\\'t match, forget about it (flag = false)\\n                for (int j = 1; j < needle.size(); j++) if (needle[j] != haystack[i + j]) flag = false;\\n                // if the whole needle matches, with the haystack substring, return da answer!\\n                if (flag) return i; \\n            }\\n        }\\n        // else, simply return -1 because none can be found\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1963567,
                "title": "explained-java-code-with-comments-rabin-karp-algo-rolling-hash",
                "content": "**How Rabin-Karp Algorithm Works?**\\n- Calculate the hashCode of pattern to be searched\\n- Calculate the hashCode of  every susbtring of length same as pattern from given text (Sliding window)\\n- Check which window\\'s hashCode matches pattern\\'s hashCode\\n- Compare characters of both strings\\n\\n**What is Rolling Hash?**\\nRolling hash is used to prevent rehashing the whole string while calculating hash values of the substrings of a given string. In rolling hash,the new hash value is rapidly calculated given only the old hash value. Using it, two strings can be compared in constant time.\\n\\n```\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n        int M = needle.length(); \\n        int N = haystack.length();\\n\\t\\t\\n\\t\\t if(M>N)return -1;\\n\\t\\t\\n        int i, j; \\n        int p = 0; // hash value for needle \\n        int t = 0; // hash value for haystack \\n        int h = 1;\\n        int d= 256; // number of characters in the input alphabet \\n        int q= 31; //a prime number\\n\\n        char[] pat=needle.toCharArray();\\n        char[] txt=haystack.toCharArray();\\n        // The value of h would be \"pow(d, M-1)%q\" \\n        for (i = 0; i < M - 1; i++) \\n            h = (h * d) % q; \\n\\n        // Calculate the hash value of pattern and first \\n        // window of text \\n        for (i = 0; i < M; i++) { \\n            p = (d * p + pat[i]) % q; \\n            t = (d * t + txt[i]) % q; \\n        } \\n\\n        // Slide the pattern over text one by one \\n        for (i = 0; i <= N - M; i++) { \\n\\n            // Check the hash values of current window of text \\n            // and pattern. If the hash values match then only \\n            // check for characters on by one \\n            if ( p == t ) { \\n                /* Check for characters one by one */\\n                for (j = 0; j < M; j++) { \\n                    if (txt[i+j] != pat[j]) \\n                        break; \\n                } \\n\\n                // if p == t and pat[0...M-1] = txt[i, i+1, ...i+M-1] \\n                if (j == M) \\n                    return i;\\n            } \\n\\n            // Calculate hash value for next window of text: Remove \\n            // leading digit, add trailing digit \\n            if ( i < N-M ) { \\n                t = (d*(t - txt[i]*h) + txt[i+M])%q; \\n\\n                // We might get negative value of t, converting it \\n                // to positive \\n                if (t < 0) \\n                t = (t + q); \\n            } \\n        }\\n        return -1;\\n    }\\n}\\n```\\nTime `O(N+M)`\\nSpace `O(1)`\\nAlthough i used two char array. They can be avoided.\\n\\n**Why use a prime number in hashCode?**\\nPrime numbers are chosen to best distribute data among hash buckets. If the distribution of inputs is random and evenly spread, then the choice of the hash code/modulus does not matter. It only has an impact when there is a certain pattern to the inputs.\\n\\nDo upvote if you liked the solution.",
                "solutionTags": [
                    "Java",
                    "String",
                    "Rolling Hash"
                ],
                "code": "```\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n        int M = needle.length(); \\n        int N = haystack.length();\\n\\t\\t\\n\\t\\t if(M>N)return -1;\\n\\t\\t\\n        int i, j; \\n        int p = 0; // hash value for needle \\n        int t = 0; // hash value for haystack \\n        int h = 1;\\n        int d= 256; // number of characters in the input alphabet \\n        int q= 31; //a prime number\\n\\n        char[] pat=needle.toCharArray();\\n        char[] txt=haystack.toCharArray();\\n        // The value of h would be \"pow(d, M-1)%q\" \\n        for (i = 0; i < M - 1; i++) \\n            h = (h * d) % q; \\n\\n        // Calculate the hash value of pattern and first \\n        // window of text \\n        for (i = 0; i < M; i++) { \\n            p = (d * p + pat[i]) % q; \\n            t = (d * t + txt[i]) % q; \\n        } \\n\\n        // Slide the pattern over text one by one \\n        for (i = 0; i <= N - M; i++) { \\n\\n            // Check the hash values of current window of text \\n            // and pattern. If the hash values match then only \\n            // check for characters on by one \\n            if ( p == t ) { \\n                /* Check for characters one by one */\\n                for (j = 0; j < M; j++) { \\n                    if (txt[i+j] != pat[j]) \\n                        break; \\n                } \\n\\n                // if p == t and pat[0...M-1] = txt[i, i+1, ...i+M-1] \\n                if (j == M) \\n                    return i;\\n            } \\n\\n            // Calculate hash value for next window of text: Remove \\n            // leading digit, add trailing digit \\n            if ( i < N-M ) { \\n                t = (d*(t - txt[i]*h) + txt[i+M])%q; \\n\\n                // We might get negative value of t, converting it \\n                // to positive \\n                if (t < 0) \\n                t = (t + q); \\n            } \\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1854661,
                "title": "string-c-very-easyy",
                "content": "```\\nclass Solution {\\npublic:\\n    bool check(string a,string b){\\n        // cout << a << \" \";\\n        return a==b;\\n    }\\n    int strStr(string haystack, string needle) {\\n        if(haystack==needle) return 0;\\n        int n = needle.size();\\n        int m = haystack.size();\\n        for(int i=0;i<=m-n;i++){\\n            if(check(haystack.substr(i,n),needle)) return i;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(string a,string b){\\n        // cout << a << \" \";\\n        return a==b;\\n    }\\n    int strStr(string haystack, string needle) {\\n        if(haystack==needle) return 0;\\n        int n = needle.size();\\n        int m = haystack.size();\\n        for(int i=0;i<=m-n;i++){\\n            if(check(haystack.substr(i,n),needle)) return i;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1338800,
                "title": "short-and-easy-solutuon-java",
                "content": "```\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n        if (needle.length() == 0) return 0;\\n        char[] n = needle.toCharArray();\\n        char[] h = haystack.toCharArray();\\n\\n        int cur = 0;\\n        while(cur < h.length) {\\n            if (h[cur] == n[0]) {\\n                if (n.length <= (h.length - cur)) {\\n                    int i = cur, j = 0;\\n                    for (; j < n.length && h[i] == n[j]; i++, j++) {\\n\\n                    }\\n                    if (j == n.length) {\\n                        // all chars in needle found in haystack\\n                        return cur; // first index of match\\n                    }\\n                }\\n            }\\n            cur++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n        if (needle.length() == 0) return 0;\\n        char[] n = needle.toCharArray();\\n        char[] h = haystack.toCharArray();\\n\\n        int cur = 0;\\n        while(cur < h.length) {\\n            if (h[cur] == n[0]) {\\n                if (n.length <= (h.length - cur)) {\\n                    int i = cur, j = 0;\\n                    for (; j < n.length && h[i] == n[j]; i++, j++) {\\n\\n                    }\\n                    if (j == n.length) {\\n                        // all chars in needle found in haystack\\n                        return cur; // first index of match\\n                    }\\n                }\\n            }\\n            cur++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1316041,
                "title": "c-rabin-karp-algorithm",
                "content": "```\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        if(!haystack.size() && !needle.size()) return 0;\\n        int base =  256;\\n        int moduloPrime = 101;\\n        \\n        int n = haystack.size();\\n        int m = needle.size();\\n        \\n        int i, j; // iterator\\n        int h = 1;\\n        int pHash = 0;\\n        int sHash = 0;\\n        // hash function\\n        for(i = 0; i < m-1; ++i) {\\n            h = (h *base) % moduloPrime; \\n        }\\n        \\n        // calculate the hash for pattern and first window of the string\\n        for(i = 0; i < m; ++i) {\\n            pHash = (base * pHash + needle[i]) % moduloPrime;\\n            sHash = (base * sHash + haystack[i]) % moduloPrime;\\n        }\\n        \\n        for(i = 0; i <= n-m; ++i) {\\n            if(pHash == sHash) {\\n                // do character by character comparison\\n                for(j =0 ; j < m; ++j) {\\n                    if(haystack[i+j]!=needle[j]) break;\\n                }\\n            }\\n            if(j == m) return i; // first occurence is found\\n            // else compute the hash for next window\\n            if ( i < n-m ) {\\n                sHash = (base * (sHash - haystack[i]*h) + haystack[i+m])%moduloPrime;\\n                if(sHash < 0) sHash += moduloPrime;\\n            }\\n            \\n        }\\n        \\n        \\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        if(!haystack.size() && !needle.size()) return 0;\\n        int base =  256;\\n        int moduloPrime = 101;\\n        \\n        int n = haystack.size();\\n        int m = needle.size();\\n        \\n        int i, j; // iterator\\n        int h = 1;\\n        int pHash = 0;\\n        int sHash = 0;\\n        // hash function\\n        for(i = 0; i < m-1; ++i) {\\n            h = (h *base) % moduloPrime; \\n        }\\n        \\n        // calculate the hash for pattern and first window of the string\\n        for(i = 0; i < m; ++i) {\\n            pHash = (base * pHash + needle[i]) % moduloPrime;\\n            sHash = (base * sHash + haystack[i]) % moduloPrime;\\n        }\\n        \\n        for(i = 0; i <= n-m; ++i) {\\n            if(pHash == sHash) {\\n                // do character by character comparison\\n                for(j =0 ; j < m; ++j) {\\n                    if(haystack[i+j]!=needle[j]) break;\\n                }\\n            }\\n            if(j == m) return i; // first occurence is found\\n            // else compute the hash for next window\\n            if ( i < n-m ) {\\n                sHash = (base * (sHash - haystack[i]*h) + haystack[i+m])%moduloPrime;\\n                if(sHash < 0) sHash += moduloPrime;\\n            }\\n            \\n        }\\n        \\n        \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 956652,
                "title": "python-two-pointer",
                "content": "```\\n# Two pointer\\n\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        if not needle:\\n            return 0\\n        \\n        if len(needle) > len(haystack):\\n            return -1\\n        \\n        for p_haystack in range(len(haystack) - len(needle) + 1):\\n            if self.start_comparision(haystack, needle, p_haystack, 0):\\n                return p_haystack\\n        return -1\\n    \\n    def start_comparision(self, haystack, needle, p_haystack, p_needle):\\n        L = len(needle)\\n        while p_needle < L and haystack[p_haystack] == needle[p_needle]:\\n            p_haystack += 1\\n            p_needle += 1\\n        return True if p_needle == len(needle) else False\\n```",
                "solutionTags": [],
                "code": "```\\n# Two pointer\\n\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        if not needle:\\n            return 0\\n        \\n        if len(needle) > len(haystack):\\n            return -1\\n        \\n        for p_haystack in range(len(haystack) - len(needle) + 1):\\n            if self.start_comparision(haystack, needle, p_haystack, 0):\\n                return p_haystack\\n        return -1\\n    \\n    def start_comparision(self, haystack, needle, p_haystack, p_needle):\\n        L = len(needle)\\n        while p_needle < L and haystack[p_haystack] == needle[p_needle]:\\n            p_haystack += 1\\n            p_needle += 1\\n        return True if p_needle == len(needle) else False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 763754,
                "title": "java-three-versions-of-kmp",
                "content": "First, the KMP with DFA(Deterministic Finite Automaton).\\n```\\nclass Solution {\\n    public int strStr(String t, String p) {\\n        int n = t.length(), m = p.length();\\n        if (m == 0) return 0;\\n        int[][] dfa = new int[m][26];\\n        int x = 0;\\n        dfa[0][p.charAt(0) - \\'a\\'] = 1;\\n        for (int i = 1; i < m; ++i) {\\n            for (int j = 0; j < 26; ++j) {\\n                    dfa[i][j] = dfa[x][j];\\n            }\\n\\t\\t\\tdfa[i][p.charAt(i) - \\'a\\'] = i + 1;\\n            x = dfa[x][p.charAt(i) - \\'a\\'];\\n        }\\n        for (int i = 0, j = 0; i < n && j < m; ++i) {\\n            j = dfa[j][t.charAt(i) - \\'a\\'];\\n            if (j == m) return i - m + 1;\\n        }\\n        return -1;\\n    }\\n}\\n```\\nThe time complexity of this algorithm can be divided into two parts. First, the cost to build DFA table is ```O(Rm)``` where R is the number of characters. And in this case, ```R = 26```. The matching process cost O(n), we just loop once. Total complexity is ``` O(Rm + n) ```The bottleneck of this problem is the size of R. If it is too large, then the preprocess costs too much.\\n\\nSecond version: KMP with NFA(Nondeterministic Finite Automata). \\n```\\nclass Solution {\\n    public int strStr(String s, String p) {\\n        int m = p.length(), n = s.length();\\n        if (m == 0) return 0;\\n        int[] next = new int[m];\\n        next[0] = -1;\\n        for (int i = -1, j = 0; j < m - 1;) {\\n            if (i < 0 || p.charAt(i) == p.charAt(j)) {\\n                next[++j] = ++i;\\n            } else {\\n                i = next[i];\\n            }\\n        }\\n        int i = 0, j = 0;\\n        while (i < n && j < m) {\\n            if (j < 0 || s.charAt(i) == p.charAt(j)) {\\n                ++i;\\n                ++j;\\n            } else \\n                j = next[j];\\n        }\\n        return j == m ? i - m : -1;\\n    }\\n}\\n```\\nIn this case, NFA is used. And the time complexity is ```O(m + n)```.\\nSimilar to path compression in Union Find, this can be further improved,\\nThird version is NFA with path compression.\\nThe intuition is that if we move to next position and find that it is still the same as current, there is no need to do this comparison again. \\n\\n```\\nclass Solution {\\n    public int strStr(String s, String p) {\\n        int m = p.length(), n = s.length();\\n        if (m == 0) return 0;\\n        int[] next = new int[m];\\n        next[0] = -1;\\n        for (int i = -1, j = 0; j < m - 1;) {\\n            if (i < 0 || p.charAt(i) == p.charAt(j)) {\\n                ++j; ++i;\\n                // path compression\\n                next[j] = p.charAt(i) != p.charAt(j) ? i : next[i];\\n            } else {\\n                i = next[i];\\n            }\\n        }\\n        int i = 0, j = 0;\\n        while (i < n && j < m) {\\n            if (j < 0 || s.charAt(i) == p.charAt(j)) {\\n                ++i;\\n                ++j;\\n            } else \\n                j = next[j];\\n        }\\n        return j == m ? i - m : -1;\\n    }\\n}\\n```\\nThis version improve the performance but it doesn\\'t change the ```Big - O``` time and space complexity. \\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int strStr(String t, String p) {\\n        int n = t.length(), m = p.length();\\n        if (m == 0) return 0;\\n        int[][] dfa = new int[m][26];\\n        int x = 0;\\n        dfa[0][p.charAt(0) - \\'a\\'] = 1;\\n        for (int i = 1; i < m; ++i) {\\n            for (int j = 0; j < 26; ++j) {\\n                    dfa[i][j] = dfa[x][j];\\n            }\\n\\t\\t\\tdfa[i][p.charAt(i) - \\'a\\'] = i + 1;\\n            x = dfa[x][p.charAt(i) - \\'a\\'];\\n        }\\n        for (int i = 0, j = 0; i < n && j < m; ++i) {\\n            j = dfa[j][t.charAt(i) - \\'a\\'];\\n            if (j == m) return i - m + 1;\\n        }\\n        return -1;\\n    }\\n}\\n```\n```O(Rm)```\n```R = 26```\n``` O(Rm + n) ```\n```\\nclass Solution {\\n    public int strStr(String s, String p) {\\n        int m = p.length(), n = s.length();\\n        if (m == 0) return 0;\\n        int[] next = new int[m];\\n        next[0] = -1;\\n        for (int i = -1, j = 0; j < m - 1;) {\\n            if (i < 0 || p.charAt(i) == p.charAt(j)) {\\n                next[++j] = ++i;\\n            } else {\\n                i = next[i];\\n            }\\n        }\\n        int i = 0, j = 0;\\n        while (i < n && j < m) {\\n            if (j < 0 || s.charAt(i) == p.charAt(j)) {\\n                ++i;\\n                ++j;\\n            } else \\n                j = next[j];\\n        }\\n        return j == m ? i - m : -1;\\n    }\\n}\\n```\n```O(m + n)```\n```\\nclass Solution {\\n    public int strStr(String s, String p) {\\n        int m = p.length(), n = s.length();\\n        if (m == 0) return 0;\\n        int[] next = new int[m];\\n        next[0] = -1;\\n        for (int i = -1, j = 0; j < m - 1;) {\\n            if (i < 0 || p.charAt(i) == p.charAt(j)) {\\n                ++j; ++i;\\n                // path compression\\n                next[j] = p.charAt(i) != p.charAt(j) ? i : next[i];\\n            } else {\\n                i = next[i];\\n            }\\n        }\\n        int i = 0, j = 0;\\n        while (i < n && j < m) {\\n            if (j < 0 || s.charAt(i) == p.charAt(j)) {\\n                ++i;\\n                ++j;\\n            } else \\n                j = next[j];\\n        }\\n        return j == m ? i - m : -1;\\n    }\\n}\\n```\n```Big - O```",
                "codeTag": "Java"
            },
            {
                "id": 762113,
                "title": "python-28ms-faster-than-90",
                "content": "```\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n\\t\\n        x = len(haystack)\\n        l = len(needle)\\n        if haystack==needle:\\n            return 0\\n        if x==0 and l==0:\\n            return 0\\n        for i in range(0,x-l+1):\\n            if haystack[i:i+l]==needle:\\n                return i\\n        return -1\\n\\t```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n\\t\\n        x = len(haystack)\\n        l = len(needle)\\n        if haystack==needle:\\n            return 0\\n        if x==0 and l==0:\\n            return 0\\n        for i in range(0,x-l+1):\\n            if haystack[i:i+l]==needle:\\n                return i\\n        return -1\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 644663,
                "title": "don-t-call-find-fucntion-algorithms-discussed-briefly-and-cpp-code-given",
                "content": "You may get the correct result by calling find function, but it is not as easy as its surface. If you are interviewed, calling find() function will dissppoint interviewer, at least you will not impress people. \\n\\nIt is classical string mathching problem. You will find detailed dicssion from algorithm books or simply search google with keyword. SO, no need for me to be teacher here. My intention is to give some link or reference for your self-learning.\\n\\n\\nLet us start from a straight-foward solution. A outter loop shifts one character of haystack as the starting character of haystack for the next round of matching (stops if finding a matching). A inner loop compare the character-by-character between needle and sub-string of haystack with starting point determined by the outter loop. It might be easier to get the idea by checking the code below. And the time complxity is O((n-m+1)m) , where m, n are the lengths of needle and haystack, respectively. Memory complexity is O(m+n).\\n\\n\\n\\'\\'\\'\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        int sn = needle.size();\\n            if(sn==0) \\n        return 0;\\n        \\n        int cnt=0;\\n        int sh=haystack.size();\\n        int i=0, j,x;\\n        int search = sh-sn+1;\\n\\n            for(j=0;j<search;j++){\\n                x=j;\\n                while(haystack[x]==needle[i] && x<sh&&i<sn){\\n                    ++i;\\n                    ++cnt;\\n                    ++x;\\n                }\\n                if(cnt==sn) return j;\\n                else {\\n                    i=0;\\n                    cnt=0;\\n                }\\n            }   \\n        return -1;\\n    }\\n};\\n\\'\\'\\'\\n\\nSometimes, learnt from past partitial matching on needle, we may skip duplicated matching in a next mathicng round. With this idea, there are many ways to optimize the above native algorithm. And KMP (Knuth-Morris-Pratt) algorithm is one of most efficient one. KMP needs O(m) time complexity to pre-compute a array recording how many characters can be skiped if a substring of needle is matched, and O(n) time complexity for the real matching procedure. I only give my code as bleow and you need to survey the details by yourself. The runtime of this code only beat 90.46% of CPP submissions. If you know better implementation (without calling find()), please reply to me. Many Thanks. \\n\\n\\n\\n\\'\\'\\'\\n//KMP\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        int sn = needle.size();\\n        if(sn==0) \\n            return 0;\\n        \\n        int sh=haystack.size();\\n        \\n        //pre-compute how many characters can be skipped when a sub-string of needle was matched previously.\\n        //For the pattern \\u201CAAAA\\u201D, skip[] is [0, 1, 2, 3]\\n        //For the pattern \\u201CABCDE\\u201D, is [0, 0, 0, 0, 0]\\n        //For the pattern \\u201CAABAACAABAA\\u201D, is [0, 1, 0, 1, 2, 0, 1, 2, 3, 4, 5]\\n        //For the pattern \\u201CAAACAAAAAC\\u201D, is [0, 1, 2, 0, 1, 2, 3, 3, 3, 4]         \\n        \\n        int skip[sn];\\n        skip[0] = 0;\\n        int i = 1, len = 0; \\n        while (i < sn) { \\n            if (needle[i] == needle[len]) { \\n                len++; \\n                skip[i] = len; \\n                i++; \\n            } \\n            else{ // (needle[i] != needle[len]) \\n                if (len != 0) { \\n                    len = skip[len - 1]; \\n                } \\n                else{ // if (len == 0)  \\n                    skip[i] = 0; \\n                    i++; \\n                } \\n            } \\n        } \\n        \\n        //matching \\n                \\n        i=0;\\n        len =0;\\n        for(len=0;len<sh;){\\n            while(haystack[len]==needle[i] ){\\n                ++i;\\n                ++len;\\n                if(i==sn) return (len-sn);\\n             }\\n             \\n            if(i==0){\\n                ++len;\\n                continue;\\n            }\\n            else{\\n                i=skip[i-1];\\n            }\\n        }\\n        return -1;\\n\\t\\t\\'\\'\\'",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        int sn = needle.size();\\n            if(sn==0) \\n        return 0;\\n        \\n        int cnt=0;\\n        int sh=haystack.size();\\n        int i=0, j,x;\\n        int search = sh-sn+1;\\n\\n            for(j=0;j<search;j++){\\n                x=j;\\n                while(haystack[x]==needle[i] && x<sh&&i<sn){\\n                    ++i;\\n                    ++cnt;\\n                    ++x;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 601859,
                "title": "javascript-o-n-m-two-pointers",
                "content": "```\\nconst strStr = (haystack, needle) => {\\n  if (needle === \\'\\') {\\n    return 0;\\n  }\\n\\n  if (haystack.length < needle.length) {\\n    return -1;\\n  }\\n\\n  let i = 0;\\n  let j = 0;\\n\\n  for (; i < haystack.length; i += 1) {\\n    if (haystack[i] === needle[j]) {\\n      if (j === needle.length - 1) {\\n        return i - j;\\n      }\\n\\n      j += 1;\\n    } else {\\n      i -= j;\\n      j = 0;\\n    }\\n  }\\n\\n  return -1;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers"
                ],
                "code": "```\\nconst strStr = (haystack, needle) => {\\n  if (needle === \\'\\') {\\n    return 0;\\n  }\\n\\n  if (haystack.length < needle.length) {\\n    return -1;\\n  }\\n\\n  let i = 0;\\n  let j = 0;\\n\\n  for (; i < haystack.length; i += 1) {\\n    if (haystack[i] === needle[j]) {\\n      if (j === needle.length - 1) {\\n        return i - j;\\n      }\\n\\n      j += 1;\\n    } else {\\n      i -= j;\\n      j = 0;\\n    }\\n  }\\n\\n  return -1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 401540,
                "title": "python-solution-using-kmp-string-matching-algorithm",
                "content": "Algorithm overview:\\n1. Generate the prefixes table. The prefixes table is a table with the same length as the needle. Each element `prefixes[i] ` represents the length of the longest prefix which is also a suffix from index 0 to i\\n2. Begin comparing the letters in `haystack` to the letters in `needle`. If it\\'s a match, increment both pointers. Otherwise, consult the prefixes table to find the value at `n-1` where n is the index pointer for `needle`. We want to move `n` to the position at `prefixes[n-1]` because it represents the last character of an already matched prefix.\\n\\n[This guy does a better job explaining. I know that sounded kind of convoluted.](http://https://www.youtube.com/watch?v=BXCEFAzhxGY)\\n\\n```\\ndef strStr(self, haystack: str, needle: str) -> int:\\n\\tprefixes = [0] * len(needle) \\n\\ti, j = 0, 1\\n\\twhile j < len(needle):\\n\\t\\tif needle[i] == needle[j]:\\n\\t\\t\\tprefixes[j] = i+1\\n\\t\\t\\ti += 1\\n\\t\\t\\tj += 1\\n\\t\\telse:\\n\\t\\t\\ti = 0 if i == 0 else prefixes[i-1]\\n\\t\\t\\tif needle[i] != needle[j]:\\n\\t\\t\\t\\tprefixes[j] = 0\\n\\t\\t\\t\\tj += 1\\n\\n\\th, n = 0, 0\\n\\twhile h < len(haystack) and n < len(needle):\\n\\t\\tif haystack[h] == needle[n]:\\n\\t\\t\\th += 1\\n\\t\\t\\tn += 1\\n\\t\\telse:\\n\\t\\t\\tif n == 0:\\n\\t\\t\\t\\th += 1\\n\\t\\t\\telse:\\n\\t\\t\\t\\tn = prefixes[n-1]\\n\\n\\treturn h - len(needle) if n == len(needle) else -1\\n```",
                "solutionTags": [],
                "code": "```\\ndef strStr(self, haystack: str, needle: str) -> int:\\n\\tprefixes = [0] * len(needle) \\n\\ti, j = 0, 1\\n\\twhile j < len(needle):\\n\\t\\tif needle[i] == needle[j]:\\n\\t\\t\\tprefixes[j] = i+1\\n\\t\\t\\ti += 1\\n\\t\\t\\tj += 1\\n\\t\\telse:\\n\\t\\t\\ti = 0 if i == 0 else prefixes[i-1]\\n\\t\\t\\tif needle[i] != needle[j]:\\n\\t\\t\\t\\tprefixes[j] = 0\\n\\t\\t\\t\\tj += 1\\n\\n\\th, n = 0, 0\\n\\twhile h < len(haystack) and n < len(needle):\\n\\t\\tif haystack[h] == needle[n]:\\n\\t\\t\\th += 1\\n\\t\\t\\tn += 1\\n\\t\\telse:\\n\\t\\t\\tif n == 0:\\n\\t\\t\\t\\th += 1\\n\\t\\t\\telse:\\n\\t\\t\\t\\tn = prefixes[n-1]\\n\\n\\treturn h - len(needle) if n == len(needle) else -1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 279941,
                "title": "rabin-karp-with-comments",
                "content": "```java\\nclass Solution {\\n    public int strStr(String source, String target) {\\n        int M = source.length();\\n        int N = target.length();\\n        if (M < N)\\n            return -1;\\n        long preCompute = 1;\\n        // to compute the mod of remove digits, base^(N-1) % q\\n        long hSource = 0;\\n        long hTarget = 0;\\n        long d = 31; // base\\n        long q = 1000000000000000003L; // hash table size\\n\\n        for (int i = 0; i < N - 1; i++) {\\n            preCompute = (preCompute * d) % q; // (a%n * b%n)%n\\n        }\\n\\n        for (int j = 0; j < N; j++) {\\n            hSource = (hSource * d + source.charAt(j)) % q;\\n            hTarget = (hTarget * d + target.charAt(j)) % q;\\n        }\\n        if (hSource == hTarget)\\n            return 0;\\n        for (int j = 1; j < M - N + 1; j++) {\\n            hSource = (hSource - source.charAt(j - 1) * preCompute) % q;\\n            // remove first digit\\n            hSource = (hSource * d + source.charAt(j + N - 1)) % q;\\n            // add new last digit\\n            if (hSource == hTarget) {\\n                if (source.substring(j, j + N).equals(target))\\n                    return j;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```\\n\\nThe main idea is to build a hash table for all substring in the source string with equal length with target string. As for how to build the hashtable, divide the substring by a very large prime. We can compute hash for substring based on the substring before it with O(1) time.\\nhttps://www.geeksforgeeks.org/rabin-karp-algorithm-for-pattern-searching/\\n\\n",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public int strStr(String source, String target) {\\n        int M = source.length();\\n        int N = target.length();\\n        if (M < N)\\n            return -1;\\n        long preCompute = 1;\\n        // to compute the mod of remove digits, base^(N-1) % q\\n        long hSource = 0;\\n        long hTarget = 0;\\n        long d = 31; // base\\n        long q = 1000000000000000003L; // hash table size\\n\\n        for (int i = 0; i < N - 1; i++) {\\n            preCompute = (preCompute * d) % q; // (a%n * b%n)%n\\n        }\\n\\n        for (int j = 0; j < N; j++) {\\n            hSource = (hSource * d + source.charAt(j)) % q;\\n            hTarget = (hTarget * d + target.charAt(j)) % q;\\n        }\\n        if (hSource == hTarget)\\n            return 0;\\n        for (int j = 1; j < M - N + 1; j++) {\\n            hSource = (hSource - source.charAt(j - 1) * preCompute) % q;\\n            // remove first digit\\n            hSource = (hSource * d + source.charAt(j + N - 1)) % q;\\n            // add new last digit\\n            if (hSource == hTarget) {\\n                if (source.substring(j, j + N).equals(target))\\n                    return j;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 202076,
                "title": "0ms-in-go",
                "content": "```\\nfunc strStr(haystack string, needle string) int {\\n    if haystack == needle {\\n        return 0\\n    }\\n    for i := 0; i <= len(haystack) - len(needle); i++ {\\n        if haystack[i:len(needle) + i] == needle {\\n            return i\\n        }\\n    }\\n\\n    return -1\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc strStr(haystack string, needle string) int {\\n    if haystack == needle {\\n        return 0\\n    }\\n    for i := 0; i <= len(haystack) - len(needle); i++ {\\n        if haystack[i:len(needle) + i] == needle {\\n            return i\\n        }\\n    }\\n\\n    return -1\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 200800,
                "title": "c",
                "content": "```\\npublic class Solution {\\n    public int StrStr(string haystack, string needle) {\\n        for(var i = 0; i <= haystack.Length - needle.Length; i++){\\n            int j = 0;\\n            for(j = 0; j < needle.Length; j++){\\n                if(haystack[i + j] == needle[j]) continue;\\n                break;\\n            }\\n            if(j == needle.Length) return i;\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int StrStr(string haystack, string needle) {\\n        for(var i = 0; i <= haystack.Length - needle.Length; i++){\\n            int j = 0;\\n            for(j = 0; j < needle.Length; j++){\\n                if(haystack[i + j] == needle[j]) continue;\\n                break;\\n            }\\n            if(j == needle.Length) return i;\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4102698,
                "title": "video-step-by-step-visualization-of-o-n-kmp-algorithm",
                "content": "https://youtu.be/0iDiUuHZE_g\\n\\nThe KMP algorithm improves the brute force algorithm from O(m*n) to O(m+n) and consists of two parts.  The first part is the preprocessing step, where we find the length of \"the longest proper prefix that is also a suffix\" for every prefix in `needle`.\\n\\nThe second part is the main algorithm, where we compare `needle` and `haystack` letter-by-letter.  If two characters match, we move both pointers up and see how far we can keep going.  If they don\\'t match, then we use the array created in the preprocessing step to determine how far to move up `needle` to compare the next characters.  For a detailed explanation, please see the video - it\\'s very difficult to explain without visuals.  But the idea is that when traversing `needle` and hitting a mismatch, we know that any proper prefixes that are also a suffix will overlap, so we can skip those characters.\\n```\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        lps = [0] * len(needle)\\n\\n        # Preprocessing\\n        pre = 0\\n        for i in range(1, len(needle)):\\n            while pre > 0 and needle[i] != needle[pre]:\\n                pre = lps[pre-1]\\n            if needle[pre] == needle[i]:\\n                pre += 1\\n                lps[i] = pre\\n\\n        # Main algorithm\\n        n = 0 #needle index\\n        for h in range(len(haystack)):\\n            while n > 0 and needle[n] != haystack[h]:\\n                n = lps[n-1]\\n            if needle[n] == haystack[h]:\\n                n += 1\\n            if n == len(needle):\\n                return h - n + 1\\n\\n        return -1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers",
                    "String",
                    "String Matching"
                ],
                "code": "```\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        lps = [0] * len(needle)\\n\\n        # Preprocessing\\n        pre = 0\\n        for i in range(1, len(needle)):\\n            while pre > 0 and needle[i] != needle[pre]:\\n                pre = lps[pre-1]\\n            if needle[pre] == needle[i]:\\n                pre += 1\\n                lps[i] = pre\\n\\n        # Main algorithm\\n        n = 0 #needle index\\n        for h in range(len(haystack)):\\n            while n > 0 and needle[n] != haystack[h]:\\n                n = lps[n-1]\\n            if needle[n] == haystack[h]:\\n                n += 1\\n            if n == len(needle):\\n                return h - n + 1\\n\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3992591,
                "title": "python3-one-line-faster-than-95",
                "content": "```\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n       return haystack.index(needle) if needle in haystack else -1    \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n       return haystack.index(needle) if needle in haystack else -1    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3346193,
                "title": "c-1-line",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int StrStr(string haystack, string needle) \\n    {\\n        return haystack.IndexOf(needle);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int StrStr(string haystack, string needle) \\n    {\\n        return haystack.IndexOf(needle);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3252679,
                "title": "python3-23-ms-faster-than-97-85-of-python3",
                "content": "![image](https://assets.leetcode.com/users/images/3aa44090-1865-4a2c-a87b-324d98c5e33d_1677859735.583661.png)\\n```\\ndef strStr(self, haystack: str, needle: str) -> int:\\n        h=len(haystack)\\n        n=len(needle)\\n        first_element_of_needle=needle[0]\\n        for i in range(h-n+1):\\n            if haystack[i]==first_element_of_needle and haystack[i:i+n]==needle:\\n                return i\\n        return -1\\n```\\nThe given code implements the strStr() function which returns the index of the first occurrence of a needle string in a haystack string. Here\\'s a step-by-step explanation of the code:\\n1. Define a function named \\'strStr\\' that takes two input strings \\'haystack\\' and \\'needle\\' and returns an integer.\\n1. Calculate the length of the \\'haystack\\' and \\'needle\\' strings and store them in the \\'h\\' and \\'n\\' variables, respectively.\\n1. Extract the first character of the \\'needle\\' string and store it in the \\'first_element_of_needle\\' variable.\\n1. Loop through each index \\'i\\' in the range 0 to \\'h-n+1\\':\\n\\t1. \\tCheck if the \\'i\\'th character of \\'haystack\\' is equal to the first character of \\'needle\\' and if the next \\'n\\' characters of \\'haystack\\' are equal to \\'needle\\'.\\n\\t1. \\tIf both the conditions are satisfied, return the current index \\'i\\'.\\n1. If no matching substring is found, return -1.\\n\\nNote that the time complexity of the strStr() function is O(nm), where n and m are the lengths of the \\'haystack\\' and \\'needle\\' strings, respectively. In the worst case, the algorithm has to compare all possible substrings of length \\'m\\' in the \\'haystack\\' string with the \\'needle\\' string. However, in the best case, where the first character of the \\'needle\\' string does not appear in the \\'haystack\\' string, the algorithm has a time complexity of O(n).",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String"
                ],
                "code": "```\\ndef strStr(self, haystack: str, needle: str) -> int:\\n        h=len(haystack)\\n        n=len(needle)\\n        first_element_of_needle=needle[0]\\n        for i in range(h-n+1):\\n            if haystack[i]==first_element_of_needle and haystack[i:i+n]==needle:\\n                return i\\n        return -1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3251744,
                "title": "c-commented-tutorial-video-referenced",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nproblem is on pattern searching algorithm\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nRabin Karp algorithm\\nFor tutorial video: [Rabin Karp Algorithm](https://www.youtube.com/watch?v=-WdkLyTeZ3Q)\\nConcept of [String Hashing](https://www.youtube.com/watch?v=JEOj8U54Cek) used in tutorial\\n\\n# Complexity\\nn = length of the needle \\nh = length of the haystack\\n- Time complexity: O(n+h)\\n\\n\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int strStr(string h, string n) {\\n        // here n =needle and h=haystack\\n\\n        long long int q=31, m=1e9+7; \\n        long long int P=n.length();\\n        long long int S=h.length();\\n        if(S<P) return -1;   // example: needle=\\'aaaa\\' and haystack = \"aaa\"\\n        vector<long long int> power(S, 1);\\n        \\n        for(int i=1;i<S;i++)  //precomputation of powers with base q\\n        {\\n            power[i]=(power[i-1]*q)%m;\\n        }\\n\\n        long long int hash_n=0;  \\n        for(int i=0;i<P;i++)  // precompute the hash value of needle\\n        {\\n            hash_n=(hash_n+((n[i]-\\'a\\'+1)*power[i])%m)%m;\\n        }\\n        vector<long long int> hash(S+1, 0);\\n        for(int i=0;i<S;i++)   // precompute the hash value of haystack substring from 0 till ith index \\n        {\\n            hash[i+1]=(hash[i]+((h[i]-\\'a\\'+1)*power[i])%m)%m;\\n        }\\n        for(int i=0;i+P-1<S;i++)  \\n        {\\n            long long int cur_h=(hash[i+P]-hash[i]+m)%m;   // hash value of the window whose length is equal to the length of the needle string \\n            if(cur_h==(hash_n*power[i])%m)  // basic concept of Hashing => value matches with a substing in haystack => return the index\\n            {\\n                return i;\\n            }\\n        }\\n        return -1;  //needle is not found \\n    }\\n};\\n```\\n*Please consider upvoting my solution if it was truly helpful to you, as it motivates me to continue contributing to the coding community. If you have any questions or suggestions for improvement, don\\'t hesitate to leave a comment and share your thoughts.*",
                "solutionTags": [
                    "C++",
                    "String",
                    "String Matching"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int strStr(string h, string n) {\\n        // here n =needle and h=haystack\\n\\n        long long int q=31, m=1e9+7; \\n        long long int P=n.length();\\n        long long int S=h.length();\\n        if(S<P) return -1;   // example: needle=\\'aaaa\\' and haystack = \"aaa\"\\n        vector<long long int> power(S, 1);\\n        \\n        for(int i=1;i<S;i++)  //precomputation of powers with base q\\n        {\\n            power[i]=(power[i-1]*q)%m;\\n        }\\n\\n        long long int hash_n=0;  \\n        for(int i=0;i<P;i++)  // precompute the hash value of needle\\n        {\\n            hash_n=(hash_n+((n[i]-\\'a\\'+1)*power[i])%m)%m;\\n        }\\n        vector<long long int> hash(S+1, 0);\\n        for(int i=0;i<S;i++)   // precompute the hash value of haystack substring from 0 till ith index \\n        {\\n            hash[i+1]=(hash[i]+((h[i]-\\'a\\'+1)*power[i])%m)%m;\\n        }\\n        for(int i=0;i+P-1<S;i++)  \\n        {\\n            long long int cur_h=(hash[i+P]-hash[i]+m)%m;   // hash value of the window whose length is equal to the length of the needle string \\n            if(cur_h==(hash_n*power[i])%m)  // basic concept of Hashing => value matches with a substing in haystack => return the index\\n            {\\n                return i;\\n            }\\n        }\\n        return -1;  //needle is not found \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3250871,
                "title": "python-simple-solution-for-noobs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n\\nVery simple approach I have taken here just took a pointer to have location of the end named end which depicts the ending of needle string\\n\\nhere needle = \"sad\" and haystack=\"sadbutsad\"\\n=> **end=len(needle)** which is equal to 3\\n\\nNow we run the for loop to transverse from start till the length of haystack.\\n\\n=> **for start in range(*len(haystack)*)**\\n\\nhere start will have values from 0 till 9\\n\\nFurther we have provided with if condition to check whether the string in between the start and end pointer is equal to needle if yes then **return start** otherwise continue with the loop and increament the end by 1\\n\\nAt last if we do not find the required string that is needle we will **return -1**\\n\\n \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def strStr(self, haystack, needle):\\n        \"\"\"\\n        :type haystack: str\\n        :type needle: str\\n        :rtype: int\\n        \"\"\"\\n        end=len(needle)\\n        for start in range(len(haystack)):\\n            if haystack[start:end]==needle:\\n                return start\\n            end+=1\\n        return -1 \\n```",
                "solutionTags": [
                    "Python",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution(object):\\n    def strStr(self, haystack, needle):\\n        \"\"\"\\n        :type haystack: str\\n        :type needle: str\\n        :rtype: int\\n        \"\"\"\\n        end=len(needle)\\n        for start in range(len(haystack)):\\n            if haystack[start:end]==needle:\\n                return start\\n            end+=1\\n        return -1 \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3250746,
                "title": "clean-100-faster-c-solution-brute-optimal-solution-c-kmp-algorithm",
                "content": "# Brute-Force Solution (100% Faster)\\n\\n```c++ []\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        int n = haystack.length();\\n        int l = needle.length();\\n        for(int i=0;i<=n-l;i++)\\n        {\\n            int j=0;\\n            for(;j<l;j++)\\n            {\\n                if(haystack[i+j]!=needle[j])\\n                {\\n                    break;\\n                }\\n            }\\n            if(j==l){return i;}\\n        }\\n        return -1;\\n    }\\n};\\n```\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$\\nThe time complexity of the Brute-Force Approach is $$O(n*m)$$ where $$n$$ is the length of haystack & $$m$$ is the length of needle.\\n- Space Complexity: $$O(1)$$\\n\\n\\n# Optimal Approach (100% Faster)\\nWe will be using Sliding windows to implement the famous KMP(Knuth-Morris-Patt) Algorithm for string matching.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        int n=haystack.size();\\n        int m=needle.size();\\n        int x=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(haystack[i]==needle[x])x++;\\n            else\\n            {\\n                i=i-x;\\n                x=0;\\n            }\\n            if(x==m)return i-x+1;\\n        }\\n        return -1;\\n    }\\n};\\n```\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\nThe optimal approach uses Linear Time Complexity of $$O(n+m)$$ where nis the length of haystack & m is the length of needle\\n\\n- Space complexity: $$O(1)$$\\nNo extra Space utilized\\n\\n\\n# Please Upvote if you find these solutions and Algorithms helpful !",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "String",
                    "Sliding Window",
                    "String Matching"
                ],
                "code": "```c++ []\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        int n = haystack.length();\\n        int l = needle.length();\\n        for(int i=0;i<=n-l;i++)\\n        {\\n            int j=0;\\n            for(;j<l;j++)\\n            {\\n                if(haystack[i+j]!=needle[j])\\n                {\\n                    break;\\n                }\\n            }\\n            if(j==l){return i;}\\n        }\\n        return -1;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        int n=haystack.size();\\n        int m=needle.size();\\n        int x=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(haystack[i]==needle[x])x++;\\n            else\\n            {\\n                i=i-x;\\n                x=0;\\n            }\\n            if(x==m)return i-x+1;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3249528,
                "title": "daily-leetcoding-challenge-march-day-3",
                "content": "This problem is the Daily LeetCoding Challenge for March, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/find-the-index-of-the-first-occurrence-in-a-string/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 0 approach in the official solution</summary>\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/find-the-index-of-the-first-occurrence-in-a-string/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 3228201,
                "title": "100-0ms-java-two-pointer",
                "content": "# Approach\\nTwo Pointer Approach.\\nTake 2 pointers Left and Right, left poining to start of the string(index 0) and Right poining to the length of needle (needle.length) :\\n\\n1. If the length of needle and haystack is same (they are either the same string or not)\\n    1.(a) If they are same string, return 0;\\n    1.(b) Else, return -1 \\n2. If length of needle is greater than haystack, then you definitely won\\'t find the needle in haysack. Hence return -1\\n3. Iterate the loop till the Right reaches the end of the the haystack. Create a substring of Haystack from Left to Right and compare it with needle, \\n    3.(a) If both are same return Left index \\n    3.(b) Else Increment Left and Right both by 1\\n\\nIf at the end of the loop, you still haven\\'t found the needle in the Haystack, return -1  \\n<!-- Describe your approac\\nh to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n        int nl=needle.length();\\n        int i=0,j=i+nl;\\n        if (nl==haystack.length())\\n        {\\n            if(needle.equals(haystack))\\n                return 0;\\n            return -1;\\n        }\\n        else if(nl>haystack.length())\\n            return -1;\\n\\n        while(j<=haystack.length())\\n        {\\n            if(needle.equals(haystack.substring(i,j)))\\n                return i;\\n            i++;\\n            j++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n        int nl=needle.length();\\n        int i=0,j=i+nl;\\n        if (nl==haystack.length())\\n        {\\n            if(needle.equals(haystack))\\n                return 0;\\n            return -1;\\n        }\\n        else if(nl>haystack.length())\\n            return -1;\\n\\n        while(j<=haystack.length())\\n        {\\n            if(needle.equals(haystack.substring(i,j)))\\n                return i;\\n            i++;\\n            j++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3169122,
                "title": "python3-4-lines-solution",
                "content": "# Complexity\\n- Time complexity: O(n*m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        for i, char in enumerate(haystack):\\n            if char == needle[0] and (i+ len(needle)-1) < len(haystack) and haystack[i:i+len(needle)] == needle:\\n                return i\\n        return -1\\n                \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        for i, char in enumerate(haystack):\\n            if char == needle[0] and (i+ len(needle)-1) < len(haystack) and haystack[i:i+len(needle)] == needle:\\n                return i\\n        return -1\\n                \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3021950,
                "title": "typescript-1-simple-solution-3-liners-90",
                "content": "\\uD83D\\uDC40 About the rules of this post [here](https://leetcode.com/problems/single-number/solutions/2973298/rules-v1-221231/).\\n\\n# Code (3 Liners, 90%)\\n- Here N is the length of `haystack` and M the length of `needle`\\n    - \\u2605 Time Complexity O(N - M + 1)\\n    - \\u2606 Space Complexity O(1)\\n    - Explanation\\n        - Loop through each strings built with the needle length\\n        - If it is the same as the needle, return the index\\n        - If nothing returned during the loop, return -1\\n```\\n// \\u2705 1 <= haystack.length, needle.length <= 104\\n// \\u2705 haystack and needle consist of only lowercase English characters.\\n\\nfunction strStr(haystack: string, needle: string): number {\\n    for (let i = 0; i < haystack.length - needle.length + 1; i++) {\\n        if (haystack.slice(i, i + needle.length) === needle) return i\\n    }\\n\\n    return -1\\n};\\n```\\n\\n# Thank you\\n\\nUpvote if you like \\u2B06\\uFE0F\\nLet me know if you have any questions on the comment section.\\n",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\n// \\u2705 1 <= haystack.length, needle.length <= 104\\n// \\u2705 haystack and needle consist of only lowercase English characters.\\n\\nfunction strStr(haystack: string, needle: string): number {\\n    for (let i = 0; i < haystack.length - needle.length + 1; i++) {\\n        if (haystack.slice(i, i + needle.length) === needle) return i\\n    }\\n\\n    return -1\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2968366,
                "title": "beats-100-easy-to-understand-problem-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        int i,j;\\n        int len1=haystack.size(), len2=needle.size();\\n        for (i = 0; i <= len1-len2; i++) {\\n            for (j = 0; j <len2; j++) {\\n                if (haystack[i + j] != needle[j]) {\\n                    break;\\n                }\\n            }\\n            if (j == len2) {\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        int i,j;\\n        int len1=haystack.size(), len2=needle.size();\\n        for (i = 0; i <= len1-len2; i++) {\\n            for (j = 0; j <len2; j++) {\\n                if (haystack[i + j] != needle[j]) {\\n                    break;\\n                }\\n            }\\n            if (j == len2) {\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2729132,
                "title": "easy-to-understand-java-solution",
                "content": "*Please Upvote...if u found it to be somewhat useful... : )*\\n\\n**Runtime:** 1 ms, faster than 69.03% of Java online submissions for Find the Index of the First Occurrence in a String.\\n**Memory Usage:** 41.8 MB, less than 63.10% of Java online submissions for Find the Index of the First Occurrence in a String.\\n\\n```\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n        if(haystack.length()<needle.length()) return -1;\\n        char n=needle.charAt(0);\\n        for(int i=0; i<haystack.length(); i++){\\n            if(haystack.charAt(i)==n){\\n                if(i+needle.length()<=haystack.length()){\\n                    if(haystack.substring(i,i+needle.length()).equals(needle)){\\n                        return i;\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```\\n\\n**Please Upvote... : )**",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n        if(haystack.length()<needle.length()) return -1;\\n        char n=needle.charAt(0);\\n        for(int i=0; i<haystack.length(); i++){\\n            if(haystack.charAt(i)==n){\\n                if(i+needle.length()<=haystack.length()){\\n                    if(haystack.substring(i,i+needle.length()).equals(needle)){\\n                        return i;\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2671360,
                "title": "java-0ms-100-easy-understanding",
                "content": "![image](https://assets.leetcode.com/users/images/e6b7473c-bebc-401e-82f6-b688898f7060_1665125100.6460817.png)\\n**METHOD-1**\\n```\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n        int result = -1;                                //intialize result to -1\\n        if(haystack.contains(needle)) {                 //check haystack contains needle or not\\n            int index = haystack.indexOf(needle);       // get the index of haystack\\n            result = index;                             // if \"YES\" , assign the index of needle to result\\n        }\\n    return result;                                      //if \"NO\", return -1\\n    }\\n}\\n```\\n**METHOD-2**\\n```\\nclass Solution {\\n\\tpublic int strStr(String haystack, String needle) {\\n\\t\\t\\treturn haystack.indexOf(needle);\\n    }\\n}\\n```\\n**PLEASE UPVOTE**",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n        int result = -1;                                //intialize result to -1\\n        if(haystack.contains(needle)) {                 //check haystack contains needle or not\\n            int index = haystack.indexOf(needle);       // get the index of haystack\\n            result = index;                             // if \"YES\" , assign the index of needle to result\\n        }\\n    return result;                                      //if \"NO\", return -1\\n    }\\n}\\n```\n```\\nclass Solution {\\n\\tpublic int strStr(String haystack, String needle) {\\n\\t\\t\\treturn haystack.indexOf(needle);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2534828,
                "title": "c-100-faster-0-ms-runtime-easy-method-explained",
                "content": "```\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n\\nint n = needle.size(); \\nint m = haystack.size();\\n\\n//we will iterate till this size as after this size it\\'s not possible to search \\nint search_space = m-n+1;\\n\\n//using substring and finding dummy_ans of size n and if it is equal to needle we return its index as we found our answer else if not found return -1\\n\\nfor(int i=0;i<search_space;i++){\\n\\tstring dummy_ans = haystack.substr(i,n);\\n\\tif(dummy_ans == needle){\\n\\treturn i;\\t\\n\\t\\t\\t}\\t\\t\\t\\t\\n}\\nreturn -1;        \\n    }\\n}; \\n``` \\n\\n```\\nIf you find this solutions to be helpful do upvote..It keeps me motivated :)\\n```",
                "solutionTags": [
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n\\nint n = needle.size(); \\nint m = haystack.size();\\n\\n//we will iterate till this size as after this size it\\'s not possible to search \\nint search_space = m-n+1;\\n\\n//using substring and finding dummy_ans of size n and if it is equal to needle we return its index as we found our answer else if not found return -1\\n\\nfor(int i=0;i<search_space;i++){\\n\\tstring dummy_ans = haystack.substr(i,n);\\n\\tif(dummy_ans == needle){\\n\\treturn i;\\t\\n\\t\\t\\t}\\t\\t\\t\\t\\n}\\nreturn -1;        \\n    }\\n}; \\n```\n```\\nIf you find this solutions to be helpful do upvote..It keeps me motivated :)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2339886,
                "title": "c-100-faster-easy-solution",
                "content": "**C++ Solution**\\n```\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        int haystackL=haystack.length(),needleL=needle.length();\\n        for(int i=0;i<haystackL-needleL+1;i++)\\n        {\\n            if(needle[0]==haystack[i] && needle==haystack.substr(i,needleL))\\n\\t\\t\\t\\treturn i;\\n        }\\n        return -1;\\n    }\\n};\\n```\\n**If You Find it Hepful Kindly UPVOTE**",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        int haystackL=haystack.length(),needleL=needle.length();\\n        for(int i=0;i<haystackL-needleL+1;i++)\\n        {\\n            if(needle[0]==haystack[i] && needle==haystack.substr(i,needleL))\\n\\t\\t\\t\\treturn i;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2268020,
                "title": "very-easy-c-java-c-javascript-solution-fully-explained-100",
                "content": "# **JAVA SOLUTION**\\n```\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n        \\n        // Base condition\\n        if (haystack == null || needle == null) {\\n            return -1;\\n        }\\n        // Special case\\n        if (haystack.equals(needle)) {\\n            return 0;\\n        }\\n        // Loop through the haystack and slide the window\\n        for (int i = 0; i < haystack.length() - needle.length() + 1; i++) {\\n            // Check if the substring equals to the needle\\n            if (haystack.substring(i, i + needle.length()).equals(needle)) {\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```\\n\\n# **C++ SOLUTION**\\n```\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        \\n        if (!needle.size()) {\\n            return 0;\\n        }\\n        \\n        for (int i = 0; i < haystack.size(); i++) {\\n            if (haystack[i] == needle[0]) {\\n                for (int j = 0; j < needle.size(); j++) {\\n                    if (haystack[i+j] != needle[j])\\n                        break;\\n                }                \\n                if (j == needle.size())\\n                    return i;\\n            }            \\n        }        \\n        return -1;\\n    }\\n};\\n```\\n\\n# **JAVASCRIPT SOLUTION**\\n```\\nvar strStr = function (haystack, needle) {\\n    \\n    // Base condition\\n    if (haystack == null || needle == null) {\\n        return -1;\\n    }\\n    // Special case\\n    if (haystack === needle) {\\n        return 0;\\n    }\\n    // Loop through the haystack and slide the window\\n    for (let i = 0; i < haystack.length - needle.length + 1; i++) {\\n        // Check if the substring equals to the needle\\n        if (haystack.substring(i, i + needle.length) === needle) {\\n            return i;\\n        }\\n    }\\n    return -1;\\n};\\n```\\n\\n# **C LANGUAGE**\\n```\\nint strStr(char * haystack, char * needle){\\n    \\n    if (strlen(needle) > strlen(haystack))\\n        return -1;  \\n    if (strlen(needle) == 0)\\n        return 0;  \\n    for (int i = 0; i < (strlen(haystack) - strlen(needle) + 1); i++) {\\n        if (strncmp(&haystack[i], needle, strlen(needle)) == 0)\\n            return i;\\n    }\\n    return -1;\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "C",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n        \\n        // Base condition\\n        if (haystack == null || needle == null) {\\n            return -1;\\n        }\\n        // Special case\\n        if (haystack.equals(needle)) {\\n            return 0;\\n        }\\n        // Loop through the haystack and slide the window\\n        for (int i = 0; i < haystack.length() - needle.length() + 1; i++) {\\n            // Check if the substring equals to the needle\\n            if (haystack.substring(i, i + needle.length()).equals(needle)) {\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        \\n        if (!needle.size()) {\\n            return 0;\\n        }\\n        \\n        for (int i = 0; i < haystack.size(); i++) {\\n            if (haystack[i] == needle[0]) {\\n                for (int j = 0; j < needle.size(); j++) {\\n                    if (haystack[i+j] != needle[j])\\n                        break;\\n                }                \\n                if (j == needle.size())\\n                    return i;\\n            }            \\n        }        \\n        return -1;\\n    }\\n};\\n```\n```\\nvar strStr = function (haystack, needle) {\\n    \\n    // Base condition\\n    if (haystack == null || needle == null) {\\n        return -1;\\n    }\\n    // Special case\\n    if (haystack === needle) {\\n        return 0;\\n    }\\n    // Loop through the haystack and slide the window\\n    for (let i = 0; i < haystack.length - needle.length + 1; i++) {\\n        // Check if the substring equals to the needle\\n        if (haystack.substring(i, i + needle.length) === needle) {\\n            return i;\\n        }\\n    }\\n    return -1;\\n};\\n```\n```\\nint strStr(char * haystack, char * needle){\\n    \\n    if (strlen(needle) > strlen(haystack))\\n        return -1;  \\n    if (strlen(needle) == 0)\\n        return 0;  \\n    for (int i = 0; i < (strlen(haystack) - strlen(needle) + 1); i++) {\\n        if (strncmp(&haystack[i], needle, strlen(needle)) == 0)\\n            return i;\\n    }\\n    return -1;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2194130,
                "title": "python-simple-and-short-code-sliding-window",
                "content": "```\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        if (len(needle)==0):\\n            return []\\n        else :\\n            for i in range(0,len(haystack) - len(needle) + 1):\\n                if haystack[i:i+len(needle)]==needle :\\n                    return i\\n        return -1\\n                \\n```\\n***Pls upvote if you find it helpful***",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        if (len(needle)==0):\\n            return []\\n        else :\\n            for i in range(0,len(haystack) - len(needle) + 1):\\n                if haystack[i:i+len(needle)]==needle :\\n                    return i\\n        return -1\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1683002,
                "title": "best-and-well-optimized-solution-same-as-find-pattern-problem",
                "content": "```\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        int m = haystack.size(), n = needle.size();\\n        for (int i = 0; i <= m - n; i++) {\\n            int j = 0;\\n            for (; j < n; j++) {\\n                if (haystack[i + j] != needle[j]) break;\\n            }\\n            if (j == n) return i;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        int m = haystack.size(), n = needle.size();\\n        for (int i = 0; i <= m - n; i++) {\\n            int j = 0;\\n            for (; j < n; j++) {\\n                if (haystack[i + j] != needle[j]) break;\\n            }\\n            if (j == n) return i;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 579951,
                "title": "simple-java-solution-no-cheating",
                "content": "Runtime: 1 ms, faster than 62.37% of Java online submissions for Implement strStr().\\nMemory Usage: 37.9 MB, less than 67.17% of Java online submissions for Implement strStr().\\n\\nRuntime: O(n * m).\\n\\nNaive solution (without use of KMP algorithm). Many solutions use `indexOf` and `substring` but I think that\\'s too easy - it defeats the point of the problem. Note converting to a character arrary is faster than using `charAt` to index the string.\\n\\n```\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n        if (needle.length() == 0) return 0;\\n        \\n        char[] haystackCharArray = haystack.toCharArray();\\n        char[] needleCharArrary = needle.toCharArray();\\n        int i = 0, j = 0;\\n        while (i < haystackCharArray.length) { // traverse haystack\\n            if (haystackCharArray[i] == needleCharArrary[j]) {\\n                j++; // the current characters are equal, increment the needle\\n            } else { // if not equal, reset needle progress, go backwards in haystack\\n                i -= j;\\n                j = 0;\\n            }\\n            i++; // increment the haystack, be careful of off by 1 erors here\\n            if (j == needleCharArrary.length) {\\n                return i - j; // return the current index minus the length of the needle (start of the needle in haystack) if we\\'ve found a match for evey character in needle in the haystack\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n        if (needle.length() == 0) return 0;\\n        \\n        char[] haystackCharArray = haystack.toCharArray();\\n        char[] needleCharArrary = needle.toCharArray();\\n        int i = 0, j = 0;\\n        while (i < haystackCharArray.length) { // traverse haystack\\n            if (haystackCharArray[i] == needleCharArrary[j]) {\\n                j++; // the current characters are equal, increment the needle\\n            } else { // if not equal, reset needle progress, go backwards in haystack\\n                i -= j;\\n                j = 0;\\n            }\\n            i++; // increment the haystack, be careful of off by 1 erors here\\n            if (j == needleCharArrary.length) {\\n                return i - j; // return the current index minus the length of the needle (start of the needle in haystack) if we\\'ve found a match for evey character in needle in the haystack\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 445697,
                "title": "python-kmp-boyer-moore-rabin-karp",
                "content": "### KMP\\n\\n```python\\nclass Solution: \\n    def strStr(self, haystack: str, needle: str) -> int:\\n        \\n        def get_dfa(p):\\n            n = len(p)\\n            res = [0] * n\\n            for i in range(1,n):\\n                j = res[i-1]\\n                while j > 0 and p[i] != p[j]:\\n                    j = res[j-1]\\n                res[i] = j + 1 if p[i] == p[j] else j\\n            return res\\n        \\n        j, n = 0, len(needle)\\n        if n == 0:\\n            return 0\\n        dfa = get_dfa(needle)\\n        for i, c in enumerate(haystack):\\n            while j > 0 and needle[j] != c:\\n                j = dfa[j-1]\\n                \\n            if c == needle[j]:\\n                j += 1\\n                \\n            if j == n:\\n                return i - j + 1\\n            \\n        return -1\\n```\\n\\n### Boyer-Moore\\n\\n```python\\nclass Solution: \\n\\tdef strStr(self, haystack: str, needle: str) -> int:\\n\\tm, n = len(haystack), len(needle)\\n\\tright = {c: i for i, c in enumerate(needle)}\\n\\n\\ti = 0\\n\\twhile i <= m - n:\\n\\t\\tskip = 0\\n\\t\\tfor j in range(n-1, -1, -1):\\n\\t\\t\\tc = haystack[i+j]\\n\\t\\t\\tif c != needle[j]:\\n\\t\\t\\t\\tskip = max(j - right.get(c, -1), 1)\\n\\t\\tif skip == 0:\\n\\t\\t\\treturn i\\n\\t\\ti += skip\\n\\treturn -1\\n```\\n\\n### Rabin-Karp\\n\\n```python\\nclass Solution:    \\n    def strStr(self, haystack: str, needle: str) -> int:\\n        B, Q = 256, 101\\n        m, n = len(haystack), len(needle)\\n        \\n        rm = 1\\n        for _ in range(len(needle) - 1):\\n            rm = (rm * B) % Q\\n        \\n        def hash(txt):\\n            h = 0\\n            for c in txt:\\n                h = (h * B + ord(c)) % Q\\n            return h\\n        \\n        t_hash, p_hash = hash(haystack[:n]), hash(needle)\\n        if t_hash == p_hash and haystack[:n] == needle:\\n            return 0\\n\\n        for i in range(n,m):\\n            t_hash = (t_hash + Q - ord(haystack[i - n]) * rm % Q) % Q\\n            t_hash = (t_hash * B + ord(haystack[i])) % Q\\n\\n            if t_hash == p_hash and haystack[i-n+1:i+1] == needle:\\n                return i - n + 1\\n        return -1\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution: \\n    def strStr(self, haystack: str, needle: str) -> int:\\n        \\n        def get_dfa(p):\\n            n = len(p)\\n            res = [0] * n\\n            for i in range(1,n):\\n                j = res[i-1]\\n                while j > 0 and p[i] != p[j]:\\n                    j = res[j-1]\\n                res[i] = j + 1 if p[i] == p[j] else j\\n            return res\\n        \\n        j, n = 0, len(needle)\\n        if n == 0:\\n            return 0\\n        dfa = get_dfa(needle)\\n        for i, c in enumerate(haystack):\\n            while j > 0 and needle[j] != c:\\n                j = dfa[j-1]\\n                \\n            if c == needle[j]:\\n                j += 1\\n                \\n            if j == n:\\n                return i - j + 1\\n            \\n        return -1\\n```\n```python\\nclass Solution: \\n\\tdef strStr(self, haystack: str, needle: str) -> int:\\n\\tm, n = len(haystack), len(needle)\\n\\tright = {c: i for i, c in enumerate(needle)}\\n\\n\\ti = 0\\n\\twhile i <= m - n:\\n\\t\\tskip = 0\\n\\t\\tfor j in range(n-1, -1, -1):\\n\\t\\t\\tc = haystack[i+j]\\n\\t\\t\\tif c != needle[j]:\\n\\t\\t\\t\\tskip = max(j - right.get(c, -1), 1)\\n\\t\\tif skip == 0:\\n\\t\\t\\treturn i\\n\\t\\ti += skip\\n\\treturn -1\\n```\n```python\\nclass Solution:    \\n    def strStr(self, haystack: str, needle: str) -> int:\\n        B, Q = 256, 101\\n        m, n = len(haystack), len(needle)\\n        \\n        rm = 1\\n        for _ in range(len(needle) - 1):\\n            rm = (rm * B) % Q\\n        \\n        def hash(txt):\\n            h = 0\\n            for c in txt:\\n                h = (h * B + ord(c)) % Q\\n            return h\\n        \\n        t_hash, p_hash = hash(haystack[:n]), hash(needle)\\n        if t_hash == p_hash and haystack[:n] == needle:\\n            return 0\\n\\n        for i in range(n,m):\\n            t_hash = (t_hash + Q - ord(haystack[i - n]) * rm % Q) % Q\\n            t_hash = (t_hash * B + ord(haystack[i])) % Q\\n\\n            if t_hash == p_hash and haystack[i-n+1:i+1] == needle:\\n                return i - n + 1\\n        return -1\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1565202,
                "content": [
                    {
                        "username": "Siddharth2k007",
                        "content": "Who marked this as `Easy`? It\\'s not easy at all. Though you can easily produce O(mn) solution, it is not accepted for python. You need KMP algorithm to produce O(m + n) solution!"
                    },
                    {
                        "username": "countdankula",
                        "content": "[@chazwinter](/chazwinter) Lol. The interviewer will just kick you out if you use indexof() to solve this problem."
                    },
                    {
                        "username": "chazwinter",
                        "content": "It\\'s marked easy because the point is to teach you how to use indexOf.\\nIt\\'s only difficult when you fail to learn it lol"
                    },
                    {
                        "username": "Tulsyan_25",
                        "content": "Use sliding window, its that easy\\n"
                    },
                    {
                        "username": "dezann1990",
                        "content": "dude, it is oneliner"
                    },
                    {
                        "username": "Singh_uday99",
                        "content": "[@Anshmehta380](/Anshmehta380) But that is not the thing Leetcode trying to test;\\nIt wants us to study the working of indexOf () method"
                    },
                    {
                        "username": "Anshmehta380",
                        "content": "[@howardcho](/howardcho) Same for me in java"
                    },
                    {
                        "username": "Anshmehta380",
                        "content": "Bro just use indexOf() method i solved it in a one line code lol"
                    },
                    {
                        "username": "charonme",
                        "content": "tha naive O(n^2) solution is now being accepted, but if the testcases contained enough tests with long enough strings it would give a TLE"
                    },
                    {
                        "username": "aalmos",
                        "content": "[@Mister_CK](/Mister_CK) good luck with doing that on an interview bro. "
                    },
                    {
                        "username": "howardcho",
                        "content": "I\\'m not sure if there\\'s a better way, but this was a one-line solution for me in python."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "?! This is one of the easiest problems on the site, a.indexOf(b) satisfies all requirements (O(mn) time complexity I believe), at least in JS. took me 37 seconds, beats 87%"
                    },
                    {
                        "username": "gurpreetsingh8",
                        "content": "[@jdipirro](/jdipirro) exactly, this is just solved in O(N). I am wondering why it is medium"
                    },
                    {
                        "username": "calm27",
                        "content": "Python3 `O(mn)` is acceptable. "
                    },
                    {
                        "username": "pieceofpie",
                        "content": "It is now a ```Medium``` problem."
                    },
                    {
                        "username": "jdipirro",
                        "content": "Is this answer not valid for some reason?  They remarked it medium, but it can be solved with the super easy method below\\n\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n\\n        for x in range(len(haystack)):\\n            if haystack[lx : x + len(needle)] == needle:\\n                return x\\n        else:\\n            return -1"
                    },
                    {
                        "username": "narayan48",
                        "content": "class Solution {\\n    public int strStr(String haystack, String needle) {\\n          int indexOfSubStr = haystack.indexOf(needle);\\n          return indexOfSubStr;\\n\\n    }\\n    //return -1;\\n}"
                    },
                    {
                        "username": "sayedHANEEF",
                        "content": "dude it is a one line solution in java and it takes 0ms to run"
                    },
                    {
                        "username": "SugerSu",
                        "content": "Maybe sometimes we do not need to think too much!\\n\\npublic int strStr(String haystack, String needle) {\\n\\n\\t\\t\\n\\t\\treturn haystack.indexOf(needle);\\n\\t}"
                    },
                    {
                        "username": "coveyjorjet",
                        "content": "similarly you can use find() function in c++\\n```\\nreturn haystack.find(needle);\\n```"
                    },
                    {
                        "username": "enkil2003",
                        "content": "and that is how you never get a job."
                    },
                    {
                        "username": "hippofaris",
                        "content": "giga chad"
                    },
                    {
                        "username": "qAxP4Mw",
                        "content": "[@Meerkats1999](/Meerkats1999) however if your coworker reimplemented indexOf on a project everyone would be pretty annoyed so I think interviewer should accept this answer. Otherwise they should be more clear about what they\\'re looking for."
                    },
                    {
                        "username": "yuangaonyc",
                        "content": "Maybe you should think more"
                    },
                    {
                        "username": "chazwinter",
                        "content": "Don\\'t provide solutions, no matter how easy you think they are.\\nThis answer uses built in Java functionality without imports, so it\\'s fair game. If they wanted you to design your own indexOf method, they would have said so. \\n\\nThere are other problems that specifically say to avoid certain methods, or ask a follow to challenge you to try it another way. This one does not have that, so I see it as an attempt to expose new people to indexOf."
                    },
                    {
                        "username": "dantruongdo3",
                        "content": "[@Meerkats1999](/Meerkats1999) i use the exact same way and feel kinda guilty."
                    },
                    {
                        "username": "Meerkats1999",
                        "content": "I don\\'t think the interviewer will like this answer."
                    },
                    {
                        "username": "emcc1990",
                        "content": "I also submitted this but having doubts of whether the whole point is not to use it and implement something raw. "
                    },
                    {
                        "username": "user0566A",
                        "content": "It\\'s interesting that java indexOf do not use KMP (because of memory I think) or Rabin-Karp (don\\'t know why)\\nhttps://github.com/AdoptOpenJDK/openjdk-jdk11/blob/master/src/java.base/share/classes/java/lang/StringLatin1.java#L233-L253"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@therishuraj](/therishuraj) My indexOf solution beats 91%... It\\'s definitely fast enough and thus I strongly feel this should be easy. Otherwise LeetCode should drastically limit the time-constraints in my opinion"
                    },
                    {
                        "username": "user0743xF",
                        "content": "[@mohan9814](/mohan9814) because here people are coming to learn algorithms i think :)"
                    },
                    {
                        "username": "therishuraj",
                        "content": "[@mohan9814](/mohan9814)  Because time complexity of the KMP algorithm is O(m+n) And time complexity of the indexOf method is O(nm). "
                    },
                    {
                        "username": "mohan9814",
                        "content": "yes same logic in c++ is working fine why do i need to get into kmp and all this"
                    },
                    {
                        "username": "mgoldenbe",
                        "content": "I don\\'t think they meant that I can call a library function. Also, I get \"Time Limit Exceeded\" on brute-force. So, this means I should use an advanced algorithm, like Rabin-Karp or KMP. Why then is this problem marked \"easy\"?"
                    },
                    {
                        "username": "chazwinter",
                        "content": "It\\'s easy because the point is to teach you to 1) stop overthinking things, and 2) learn one single function that solves the problem in one line."
                    },
                    {
                        "username": "C0de_bumstead",
                        "content": "Can be easily solved using sliding window duhh...."
                    },
                    {
                        "username": "mikael6767",
                        "content": "Why should it be marked ```Medium```. This is literally 1line of code or 28 symbols(I\\'m counting the ```return``` function). You don\\'t need any algorithm. You need one function (if you use python3). And that function starts of the letter \"f\""
                    },
                    {
                        "username": "2020uch0017",
                        "content": "it is medium now and yes it is a KMP  problem"
                    },
                    {
                        "username": "jarc",
                        "content": " Is it the standard string matching problem? Am I wrong?"
                    },
                    {
                        "username": "chickooo",
                        "content": "Yeah, this is the standard string matching problem.\\nYour function should perform same as **.find()** function in python OR **.indexOf()** function in javascript"
                    },
                    {
                        "username": "tlong1299",
                        "content": "**USE FIND**\\nAs a Python programmer, refusing to use core language features is akin to using a hammer instead of nail-gun because it makes you a \"better\" carpenter. Remember that this is Python not C. Python\\'s PEP 20 states, \"There should be one-- and preferably only one --obvious way to do it.\" I would call a string operation built into python designed to solve this particular problem the obvious way to do it.\\n\\n**DON\\'T USE FIND**\\nIf you go into an interview and solve this problem with the find() function, you better know how it works underneath, and you should be prepared to defend your use of it. After all nothing is \"free\" in your code, and even \"magic\" functions have a time and memory cost associated with them. Knowing what this cost is, and why it is the way it is will make you a better programmer. Implementing the function yourself, at least once, can really help you develop a better appreciation for the language."
                    },
                    {
                        "username": "chazwinter",
                        "content": "Finally, a Python programmer that isn\\'t an idiot. It\\'s wild how people overthink this problem."
                    },
                    {
                        "username": "marten2",
                        "content": "Hey,\\n\\nI wouldn't say that coming up with the KMP algorithm from scratch is easy ~1 hour time. Did companies that asked this question expect applicants to know KMP by heart? Did they expect the applicant to show a naive implementation? Any opinion on this?\\n\\nBest,\\n\\nMarten"
                    },
                    {
                        "username": "syfo_dias",
                        "content": "[@chazwinter](/chazwinter) is it Python specific task? Or what is indexOf in C++? "
                    },
                    {
                        "username": "chazwinter",
                        "content": "No, they expected you to know indexOf. Don\\'t overthink it."
                    },
                    {
                        "username": "zijianz",
                        "content": "Input: \\t\"\", \"\"\\nOutput: \\t-1\\nExpected: \\t0\\n\\nBasically there is nothing in the string, how do you get the index.\\n\\nIf this test case is valid, then needle =\"\", haystack=\"anything\" could return any value. since empty is everywhere."
                    },
                    {
                        "username": "chazwinter",
                        "content": "Read the constraints. If you had to deal with an empty string, you would simply write an edge case for it."
                    },
                    {
                        "username": "mansourcodes",
                        "content": "1 <= haystack.length, needle.length <= 104\\n"
                    },
                    {
                        "username": "cxaviousb",
                        "content": "> In a string, the last element is null character. In the first case, where it is \"\",\"\" both of them has same character that is null character, while in \"\",\"anything\" the first string has null character at 0 index while the next one has 'a' at 0 index.\n\n[@AvniGoyal22](/AvniGoyal22) That's programming language specific logic.  Let's try applying logic from JavaScript to this problem~\n\n```javascript\n> 'anything'.indexOf('')\n< 0\n> ''.charAt(0)\n< \"\"\n> ''.charAt(9001)\n< \"\"\n> 'anything'.lastIndexOf('')\n< 8\n< \"anything\"\n> 'anything'.substr(0,9)\n< \"anything\"\n> 'anything'.substr(9001,9)\n< \"\"\n```"
                    },
                    {
                        "username": "shaan__0w0",
                        "content": "i think you have to make the case of if the string is empty"
                    },
                    {
                        "username": "AvniGoyal22",
                        "content": "In a string, the last element is null character. In the first case, where it is \"\",\"\" both of them has same character that is null character, while in \"\",\"anything\" the first string has null character at 0 index while the next one has \\'a\\' at 0 index. "
                    },
                    {
                        "username": "SarK97",
                        "content": "Why this test case is returning -1? Shouldn\\'t it be 4 since it is a substring?\\n\"mississippi\"\\n\"issip\""
                    },
                    {
                        "username": "impatientcat07",
                        "content": "Here comes the Overlapping case while comparing \"issis\" -> \"issip\" it rejects and reinitializes and starts from \"sippi\" & \\n comparing \"issip\", which in turns return -1; "
                    },
                    {
                        "username": "flyingfist",
                        "content": "its because it is taking issis (index 1 to 5) as index 5 is not matching it goes further and doesnt get issip "
                    },
                    {
                        "username": "MaheshPatil19",
                        "content": "here needle =\"issipi\""
                    },
                    {
                        "username": "chickooo",
                        "content": "If you add this test case ( I just did ), the output is 4 as expected.\\nDon\\'t know why you are getting -1. \\nMaybe there were unwanted spaces in your input. Can you try that again?"
                    },
                    {
                        "username": "trpaslik",
                        "content": "Most of python submissions are based on cheating (s.index() or s.find()).\\nIt is a pitty that when implementing it in pure python (the naive `O(n*m)` way) it results in timeout.\\nIt should either be accepted for `O(n*m)` or if some better approach is expected like with a rolling hash then it should be marked as medium IMHO."
                    },
                    {
                        "username": "ryo-kozin",
                        "content": "I believe  an interviewer would be fine with ussing indexOf(). In real-world programming situations, it is often advisable to take full advantage of available built-in functions and libraries. "
                    },
                    {
                        "username": "labule",
                        "content": "[@Deecodes25](/Deecodes25)  Time Complexity is O(n*m). `haystack[i:j] == needle` touches `m` chars and you do this approximately `n` times."
                    },
                    {
                        "username": "youttsu",
                        "content": "true dude. it works on JS with O(m*n) time complexity though "
                    },
                    {
                        "username": "Deecodes25",
                        "content": "I solved with this approach, can anyone explain what is the Time Complexity for this - \\n```\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        i=0\\n        j=len(needle)\\n        while j<=len(haystack):\\n            if haystack[i:j] == needle:\\n                return i\\n            i+=1\\n            j+=1\\n        return -1\\n```"
                    },
                    {
                        "username": "veerashah1",
                        "content": "[@chickooo](/chickooo) Wouldn\\'t an interviewer be fine with .indexOf(), because there\\'s no reason to re-invent the wheel when there are built in functions? If they specifically ask to avoid it then I guess, but in this case they didn\\'t."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Why is using indexOf cheating? Nowhere is it stated that you shouldn\\'t use that. If they don\\'t want you to use that they should say so, or limit the time constraints to only allow O(N+M)"
                    },
                    {
                        "username": "shaan__0w0",
                        "content": "but it gets submitted by using .indexOf() in java \\n"
                    },
                    {
                        "username": "chickooo",
                        "content": "Agreed with your opinion.\\nIf you were to use just built in function like .find() or .indexOf(), then the problem wouldn\\'t be labeled **Medium**. And if you were in an interview, the interviewer would not be pleased."
                    },
                    {
                        "username": "chehsunliu",
                        "content": "I have solved this problem. However, I think it may be controversial to return index 0 when the inputs are \"A\" and \"\". In my opinion, one of the inputs is \"A\\\\0\" and the other is \"\\\\0\". Perhaps it should return index 1."
                    }
                ]
            },
            {
                "id": 1568123,
                "content": [
                    {
                        "username": "Siddharth2k007",
                        "content": "Who marked this as `Easy`? It\\'s not easy at all. Though you can easily produce O(mn) solution, it is not accepted for python. You need KMP algorithm to produce O(m + n) solution!"
                    },
                    {
                        "username": "countdankula",
                        "content": "[@chazwinter](/chazwinter) Lol. The interviewer will just kick you out if you use indexof() to solve this problem."
                    },
                    {
                        "username": "chazwinter",
                        "content": "It\\'s marked easy because the point is to teach you how to use indexOf.\\nIt\\'s only difficult when you fail to learn it lol"
                    },
                    {
                        "username": "Tulsyan_25",
                        "content": "Use sliding window, its that easy\\n"
                    },
                    {
                        "username": "dezann1990",
                        "content": "dude, it is oneliner"
                    },
                    {
                        "username": "Singh_uday99",
                        "content": "[@Anshmehta380](/Anshmehta380) But that is not the thing Leetcode trying to test;\\nIt wants us to study the working of indexOf () method"
                    },
                    {
                        "username": "Anshmehta380",
                        "content": "[@howardcho](/howardcho) Same for me in java"
                    },
                    {
                        "username": "Anshmehta380",
                        "content": "Bro just use indexOf() method i solved it in a one line code lol"
                    },
                    {
                        "username": "charonme",
                        "content": "tha naive O(n^2) solution is now being accepted, but if the testcases contained enough tests with long enough strings it would give a TLE"
                    },
                    {
                        "username": "aalmos",
                        "content": "[@Mister_CK](/Mister_CK) good luck with doing that on an interview bro. "
                    },
                    {
                        "username": "howardcho",
                        "content": "I\\'m not sure if there\\'s a better way, but this was a one-line solution for me in python."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "?! This is one of the easiest problems on the site, a.indexOf(b) satisfies all requirements (O(mn) time complexity I believe), at least in JS. took me 37 seconds, beats 87%"
                    },
                    {
                        "username": "gurpreetsingh8",
                        "content": "[@jdipirro](/jdipirro) exactly, this is just solved in O(N). I am wondering why it is medium"
                    },
                    {
                        "username": "calm27",
                        "content": "Python3 `O(mn)` is acceptable. "
                    },
                    {
                        "username": "pieceofpie",
                        "content": "It is now a ```Medium``` problem."
                    },
                    {
                        "username": "jdipirro",
                        "content": "Is this answer not valid for some reason?  They remarked it medium, but it can be solved with the super easy method below\\n\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n\\n        for x in range(len(haystack)):\\n            if haystack[lx : x + len(needle)] == needle:\\n                return x\\n        else:\\n            return -1"
                    },
                    {
                        "username": "narayan48",
                        "content": "class Solution {\\n    public int strStr(String haystack, String needle) {\\n          int indexOfSubStr = haystack.indexOf(needle);\\n          return indexOfSubStr;\\n\\n    }\\n    //return -1;\\n}"
                    },
                    {
                        "username": "sayedHANEEF",
                        "content": "dude it is a one line solution in java and it takes 0ms to run"
                    },
                    {
                        "username": "SugerSu",
                        "content": "Maybe sometimes we do not need to think too much!\\n\\npublic int strStr(String haystack, String needle) {\\n\\n\\t\\t\\n\\t\\treturn haystack.indexOf(needle);\\n\\t}"
                    },
                    {
                        "username": "coveyjorjet",
                        "content": "similarly you can use find() function in c++\\n```\\nreturn haystack.find(needle);\\n```"
                    },
                    {
                        "username": "enkil2003",
                        "content": "and that is how you never get a job."
                    },
                    {
                        "username": "hippofaris",
                        "content": "giga chad"
                    },
                    {
                        "username": "qAxP4Mw",
                        "content": "[@Meerkats1999](/Meerkats1999) however if your coworker reimplemented indexOf on a project everyone would be pretty annoyed so I think interviewer should accept this answer. Otherwise they should be more clear about what they\\'re looking for."
                    },
                    {
                        "username": "yuangaonyc",
                        "content": "Maybe you should think more"
                    },
                    {
                        "username": "chazwinter",
                        "content": "Don\\'t provide solutions, no matter how easy you think they are.\\nThis answer uses built in Java functionality without imports, so it\\'s fair game. If they wanted you to design your own indexOf method, they would have said so. \\n\\nThere are other problems that specifically say to avoid certain methods, or ask a follow to challenge you to try it another way. This one does not have that, so I see it as an attempt to expose new people to indexOf."
                    },
                    {
                        "username": "dantruongdo3",
                        "content": "[@Meerkats1999](/Meerkats1999) i use the exact same way and feel kinda guilty."
                    },
                    {
                        "username": "Meerkats1999",
                        "content": "I don\\'t think the interviewer will like this answer."
                    },
                    {
                        "username": "emcc1990",
                        "content": "I also submitted this but having doubts of whether the whole point is not to use it and implement something raw. "
                    },
                    {
                        "username": "user0566A",
                        "content": "It\\'s interesting that java indexOf do not use KMP (because of memory I think) or Rabin-Karp (don\\'t know why)\\nhttps://github.com/AdoptOpenJDK/openjdk-jdk11/blob/master/src/java.base/share/classes/java/lang/StringLatin1.java#L233-L253"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@therishuraj](/therishuraj) My indexOf solution beats 91%... It\\'s definitely fast enough and thus I strongly feel this should be easy. Otherwise LeetCode should drastically limit the time-constraints in my opinion"
                    },
                    {
                        "username": "user0743xF",
                        "content": "[@mohan9814](/mohan9814) because here people are coming to learn algorithms i think :)"
                    },
                    {
                        "username": "therishuraj",
                        "content": "[@mohan9814](/mohan9814)  Because time complexity of the KMP algorithm is O(m+n) And time complexity of the indexOf method is O(nm). "
                    },
                    {
                        "username": "mohan9814",
                        "content": "yes same logic in c++ is working fine why do i need to get into kmp and all this"
                    },
                    {
                        "username": "mgoldenbe",
                        "content": "I don\\'t think they meant that I can call a library function. Also, I get \"Time Limit Exceeded\" on brute-force. So, this means I should use an advanced algorithm, like Rabin-Karp or KMP. Why then is this problem marked \"easy\"?"
                    },
                    {
                        "username": "chazwinter",
                        "content": "It\\'s easy because the point is to teach you to 1) stop overthinking things, and 2) learn one single function that solves the problem in one line."
                    },
                    {
                        "username": "C0de_bumstead",
                        "content": "Can be easily solved using sliding window duhh...."
                    },
                    {
                        "username": "mikael6767",
                        "content": "Why should it be marked ```Medium```. This is literally 1line of code or 28 symbols(I\\'m counting the ```return``` function). You don\\'t need any algorithm. You need one function (if you use python3). And that function starts of the letter \"f\""
                    },
                    {
                        "username": "2020uch0017",
                        "content": "it is medium now and yes it is a KMP  problem"
                    },
                    {
                        "username": "jarc",
                        "content": " Is it the standard string matching problem? Am I wrong?"
                    },
                    {
                        "username": "chickooo",
                        "content": "Yeah, this is the standard string matching problem.\\nYour function should perform same as **.find()** function in python OR **.indexOf()** function in javascript"
                    },
                    {
                        "username": "tlong1299",
                        "content": "**USE FIND**\\nAs a Python programmer, refusing to use core language features is akin to using a hammer instead of nail-gun because it makes you a \"better\" carpenter. Remember that this is Python not C. Python\\'s PEP 20 states, \"There should be one-- and preferably only one --obvious way to do it.\" I would call a string operation built into python designed to solve this particular problem the obvious way to do it.\\n\\n**DON\\'T USE FIND**\\nIf you go into an interview and solve this problem with the find() function, you better know how it works underneath, and you should be prepared to defend your use of it. After all nothing is \"free\" in your code, and even \"magic\" functions have a time and memory cost associated with them. Knowing what this cost is, and why it is the way it is will make you a better programmer. Implementing the function yourself, at least once, can really help you develop a better appreciation for the language."
                    },
                    {
                        "username": "chazwinter",
                        "content": "Finally, a Python programmer that isn\\'t an idiot. It\\'s wild how people overthink this problem."
                    },
                    {
                        "username": "marten2",
                        "content": "Hey,\\n\\nI wouldn't say that coming up with the KMP algorithm from scratch is easy ~1 hour time. Did companies that asked this question expect applicants to know KMP by heart? Did they expect the applicant to show a naive implementation? Any opinion on this?\\n\\nBest,\\n\\nMarten"
                    },
                    {
                        "username": "syfo_dias",
                        "content": "[@chazwinter](/chazwinter) is it Python specific task? Or what is indexOf in C++? "
                    },
                    {
                        "username": "chazwinter",
                        "content": "No, they expected you to know indexOf. Don\\'t overthink it."
                    },
                    {
                        "username": "zijianz",
                        "content": "Input: \\t\"\", \"\"\\nOutput: \\t-1\\nExpected: \\t0\\n\\nBasically there is nothing in the string, how do you get the index.\\n\\nIf this test case is valid, then needle =\"\", haystack=\"anything\" could return any value. since empty is everywhere."
                    },
                    {
                        "username": "chazwinter",
                        "content": "Read the constraints. If you had to deal with an empty string, you would simply write an edge case for it."
                    },
                    {
                        "username": "mansourcodes",
                        "content": "1 <= haystack.length, needle.length <= 104\\n"
                    },
                    {
                        "username": "cxaviousb",
                        "content": "> In a string, the last element is null character. In the first case, where it is \"\",\"\" both of them has same character that is null character, while in \"\",\"anything\" the first string has null character at 0 index while the next one has 'a' at 0 index.\n\n[@AvniGoyal22](/AvniGoyal22) That's programming language specific logic.  Let's try applying logic from JavaScript to this problem~\n\n```javascript\n> 'anything'.indexOf('')\n< 0\n> ''.charAt(0)\n< \"\"\n> ''.charAt(9001)\n< \"\"\n> 'anything'.lastIndexOf('')\n< 8\n< \"anything\"\n> 'anything'.substr(0,9)\n< \"anything\"\n> 'anything'.substr(9001,9)\n< \"\"\n```"
                    },
                    {
                        "username": "shaan__0w0",
                        "content": "i think you have to make the case of if the string is empty"
                    },
                    {
                        "username": "AvniGoyal22",
                        "content": "In a string, the last element is null character. In the first case, where it is \"\",\"\" both of them has same character that is null character, while in \"\",\"anything\" the first string has null character at 0 index while the next one has \\'a\\' at 0 index. "
                    },
                    {
                        "username": "SarK97",
                        "content": "Why this test case is returning -1? Shouldn\\'t it be 4 since it is a substring?\\n\"mississippi\"\\n\"issip\""
                    },
                    {
                        "username": "impatientcat07",
                        "content": "Here comes the Overlapping case while comparing \"issis\" -> \"issip\" it rejects and reinitializes and starts from \"sippi\" & \\n comparing \"issip\", which in turns return -1; "
                    },
                    {
                        "username": "flyingfist",
                        "content": "its because it is taking issis (index 1 to 5) as index 5 is not matching it goes further and doesnt get issip "
                    },
                    {
                        "username": "MaheshPatil19",
                        "content": "here needle =\"issipi\""
                    },
                    {
                        "username": "chickooo",
                        "content": "If you add this test case ( I just did ), the output is 4 as expected.\\nDon\\'t know why you are getting -1. \\nMaybe there were unwanted spaces in your input. Can you try that again?"
                    },
                    {
                        "username": "trpaslik",
                        "content": "Most of python submissions are based on cheating (s.index() or s.find()).\\nIt is a pitty that when implementing it in pure python (the naive `O(n*m)` way) it results in timeout.\\nIt should either be accepted for `O(n*m)` or if some better approach is expected like with a rolling hash then it should be marked as medium IMHO."
                    },
                    {
                        "username": "ryo-kozin",
                        "content": "I believe  an interviewer would be fine with ussing indexOf(). In real-world programming situations, it is often advisable to take full advantage of available built-in functions and libraries. "
                    },
                    {
                        "username": "labule",
                        "content": "[@Deecodes25](/Deecodes25)  Time Complexity is O(n*m). `haystack[i:j] == needle` touches `m` chars and you do this approximately `n` times."
                    },
                    {
                        "username": "youttsu",
                        "content": "true dude. it works on JS with O(m*n) time complexity though "
                    },
                    {
                        "username": "Deecodes25",
                        "content": "I solved with this approach, can anyone explain what is the Time Complexity for this - \\n```\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        i=0\\n        j=len(needle)\\n        while j<=len(haystack):\\n            if haystack[i:j] == needle:\\n                return i\\n            i+=1\\n            j+=1\\n        return -1\\n```"
                    },
                    {
                        "username": "veerashah1",
                        "content": "[@chickooo](/chickooo) Wouldn\\'t an interviewer be fine with .indexOf(), because there\\'s no reason to re-invent the wheel when there are built in functions? If they specifically ask to avoid it then I guess, but in this case they didn\\'t."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Why is using indexOf cheating? Nowhere is it stated that you shouldn\\'t use that. If they don\\'t want you to use that they should say so, or limit the time constraints to only allow O(N+M)"
                    },
                    {
                        "username": "shaan__0w0",
                        "content": "but it gets submitted by using .indexOf() in java \\n"
                    },
                    {
                        "username": "chickooo",
                        "content": "Agreed with your opinion.\\nIf you were to use just built in function like .find() or .indexOf(), then the problem wouldn\\'t be labeled **Medium**. And if you were in an interview, the interviewer would not be pleased."
                    },
                    {
                        "username": "chehsunliu",
                        "content": "I have solved this problem. However, I think it may be controversial to return index 0 when the inputs are \"A\" and \"\". In my opinion, one of the inputs is \"A\\\\0\" and the other is \"\\\\0\". Perhaps it should return index 1."
                    }
                ]
            },
            {
                "id": 1566418,
                "content": [
                    {
                        "username": "Siddharth2k007",
                        "content": "Who marked this as `Easy`? It\\'s not easy at all. Though you can easily produce O(mn) solution, it is not accepted for python. You need KMP algorithm to produce O(m + n) solution!"
                    },
                    {
                        "username": "countdankula",
                        "content": "[@chazwinter](/chazwinter) Lol. The interviewer will just kick you out if you use indexof() to solve this problem."
                    },
                    {
                        "username": "chazwinter",
                        "content": "It\\'s marked easy because the point is to teach you how to use indexOf.\\nIt\\'s only difficult when you fail to learn it lol"
                    },
                    {
                        "username": "Tulsyan_25",
                        "content": "Use sliding window, its that easy\\n"
                    },
                    {
                        "username": "dezann1990",
                        "content": "dude, it is oneliner"
                    },
                    {
                        "username": "Singh_uday99",
                        "content": "[@Anshmehta380](/Anshmehta380) But that is not the thing Leetcode trying to test;\\nIt wants us to study the working of indexOf () method"
                    },
                    {
                        "username": "Anshmehta380",
                        "content": "[@howardcho](/howardcho) Same for me in java"
                    },
                    {
                        "username": "Anshmehta380",
                        "content": "Bro just use indexOf() method i solved it in a one line code lol"
                    },
                    {
                        "username": "charonme",
                        "content": "tha naive O(n^2) solution is now being accepted, but if the testcases contained enough tests with long enough strings it would give a TLE"
                    },
                    {
                        "username": "aalmos",
                        "content": "[@Mister_CK](/Mister_CK) good luck with doing that on an interview bro. "
                    },
                    {
                        "username": "howardcho",
                        "content": "I\\'m not sure if there\\'s a better way, but this was a one-line solution for me in python."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "?! This is one of the easiest problems on the site, a.indexOf(b) satisfies all requirements (O(mn) time complexity I believe), at least in JS. took me 37 seconds, beats 87%"
                    },
                    {
                        "username": "gurpreetsingh8",
                        "content": "[@jdipirro](/jdipirro) exactly, this is just solved in O(N). I am wondering why it is medium"
                    },
                    {
                        "username": "calm27",
                        "content": "Python3 `O(mn)` is acceptable. "
                    },
                    {
                        "username": "pieceofpie",
                        "content": "It is now a ```Medium``` problem."
                    },
                    {
                        "username": "jdipirro",
                        "content": "Is this answer not valid for some reason?  They remarked it medium, but it can be solved with the super easy method below\\n\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n\\n        for x in range(len(haystack)):\\n            if haystack[lx : x + len(needle)] == needle:\\n                return x\\n        else:\\n            return -1"
                    },
                    {
                        "username": "narayan48",
                        "content": "class Solution {\\n    public int strStr(String haystack, String needle) {\\n          int indexOfSubStr = haystack.indexOf(needle);\\n          return indexOfSubStr;\\n\\n    }\\n    //return -1;\\n}"
                    },
                    {
                        "username": "sayedHANEEF",
                        "content": "dude it is a one line solution in java and it takes 0ms to run"
                    },
                    {
                        "username": "SugerSu",
                        "content": "Maybe sometimes we do not need to think too much!\\n\\npublic int strStr(String haystack, String needle) {\\n\\n\\t\\t\\n\\t\\treturn haystack.indexOf(needle);\\n\\t}"
                    },
                    {
                        "username": "coveyjorjet",
                        "content": "similarly you can use find() function in c++\\n```\\nreturn haystack.find(needle);\\n```"
                    },
                    {
                        "username": "enkil2003",
                        "content": "and that is how you never get a job."
                    },
                    {
                        "username": "hippofaris",
                        "content": "giga chad"
                    },
                    {
                        "username": "qAxP4Mw",
                        "content": "[@Meerkats1999](/Meerkats1999) however if your coworker reimplemented indexOf on a project everyone would be pretty annoyed so I think interviewer should accept this answer. Otherwise they should be more clear about what they\\'re looking for."
                    },
                    {
                        "username": "yuangaonyc",
                        "content": "Maybe you should think more"
                    },
                    {
                        "username": "chazwinter",
                        "content": "Don\\'t provide solutions, no matter how easy you think they are.\\nThis answer uses built in Java functionality without imports, so it\\'s fair game. If they wanted you to design your own indexOf method, they would have said so. \\n\\nThere are other problems that specifically say to avoid certain methods, or ask a follow to challenge you to try it another way. This one does not have that, so I see it as an attempt to expose new people to indexOf."
                    },
                    {
                        "username": "dantruongdo3",
                        "content": "[@Meerkats1999](/Meerkats1999) i use the exact same way and feel kinda guilty."
                    },
                    {
                        "username": "Meerkats1999",
                        "content": "I don\\'t think the interviewer will like this answer."
                    },
                    {
                        "username": "emcc1990",
                        "content": "I also submitted this but having doubts of whether the whole point is not to use it and implement something raw. "
                    },
                    {
                        "username": "user0566A",
                        "content": "It\\'s interesting that java indexOf do not use KMP (because of memory I think) or Rabin-Karp (don\\'t know why)\\nhttps://github.com/AdoptOpenJDK/openjdk-jdk11/blob/master/src/java.base/share/classes/java/lang/StringLatin1.java#L233-L253"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@therishuraj](/therishuraj) My indexOf solution beats 91%... It\\'s definitely fast enough and thus I strongly feel this should be easy. Otherwise LeetCode should drastically limit the time-constraints in my opinion"
                    },
                    {
                        "username": "user0743xF",
                        "content": "[@mohan9814](/mohan9814) because here people are coming to learn algorithms i think :)"
                    },
                    {
                        "username": "therishuraj",
                        "content": "[@mohan9814](/mohan9814)  Because time complexity of the KMP algorithm is O(m+n) And time complexity of the indexOf method is O(nm). "
                    },
                    {
                        "username": "mohan9814",
                        "content": "yes same logic in c++ is working fine why do i need to get into kmp and all this"
                    },
                    {
                        "username": "mgoldenbe",
                        "content": "I don\\'t think they meant that I can call a library function. Also, I get \"Time Limit Exceeded\" on brute-force. So, this means I should use an advanced algorithm, like Rabin-Karp or KMP. Why then is this problem marked \"easy\"?"
                    },
                    {
                        "username": "chazwinter",
                        "content": "It\\'s easy because the point is to teach you to 1) stop overthinking things, and 2) learn one single function that solves the problem in one line."
                    },
                    {
                        "username": "C0de_bumstead",
                        "content": "Can be easily solved using sliding window duhh...."
                    },
                    {
                        "username": "mikael6767",
                        "content": "Why should it be marked ```Medium```. This is literally 1line of code or 28 symbols(I\\'m counting the ```return``` function). You don\\'t need any algorithm. You need one function (if you use python3). And that function starts of the letter \"f\""
                    },
                    {
                        "username": "2020uch0017",
                        "content": "it is medium now and yes it is a KMP  problem"
                    },
                    {
                        "username": "jarc",
                        "content": " Is it the standard string matching problem? Am I wrong?"
                    },
                    {
                        "username": "chickooo",
                        "content": "Yeah, this is the standard string matching problem.\\nYour function should perform same as **.find()** function in python OR **.indexOf()** function in javascript"
                    },
                    {
                        "username": "tlong1299",
                        "content": "**USE FIND**\\nAs a Python programmer, refusing to use core language features is akin to using a hammer instead of nail-gun because it makes you a \"better\" carpenter. Remember that this is Python not C. Python\\'s PEP 20 states, \"There should be one-- and preferably only one --obvious way to do it.\" I would call a string operation built into python designed to solve this particular problem the obvious way to do it.\\n\\n**DON\\'T USE FIND**\\nIf you go into an interview and solve this problem with the find() function, you better know how it works underneath, and you should be prepared to defend your use of it. After all nothing is \"free\" in your code, and even \"magic\" functions have a time and memory cost associated with them. Knowing what this cost is, and why it is the way it is will make you a better programmer. Implementing the function yourself, at least once, can really help you develop a better appreciation for the language."
                    },
                    {
                        "username": "chazwinter",
                        "content": "Finally, a Python programmer that isn\\'t an idiot. It\\'s wild how people overthink this problem."
                    },
                    {
                        "username": "marten2",
                        "content": "Hey,\\n\\nI wouldn't say that coming up with the KMP algorithm from scratch is easy ~1 hour time. Did companies that asked this question expect applicants to know KMP by heart? Did they expect the applicant to show a naive implementation? Any opinion on this?\\n\\nBest,\\n\\nMarten"
                    },
                    {
                        "username": "syfo_dias",
                        "content": "[@chazwinter](/chazwinter) is it Python specific task? Or what is indexOf in C++? "
                    },
                    {
                        "username": "chazwinter",
                        "content": "No, they expected you to know indexOf. Don\\'t overthink it."
                    },
                    {
                        "username": "zijianz",
                        "content": "Input: \\t\"\", \"\"\\nOutput: \\t-1\\nExpected: \\t0\\n\\nBasically there is nothing in the string, how do you get the index.\\n\\nIf this test case is valid, then needle =\"\", haystack=\"anything\" could return any value. since empty is everywhere."
                    },
                    {
                        "username": "chazwinter",
                        "content": "Read the constraints. If you had to deal with an empty string, you would simply write an edge case for it."
                    },
                    {
                        "username": "mansourcodes",
                        "content": "1 <= haystack.length, needle.length <= 104\\n"
                    },
                    {
                        "username": "cxaviousb",
                        "content": "> In a string, the last element is null character. In the first case, where it is \"\",\"\" both of them has same character that is null character, while in \"\",\"anything\" the first string has null character at 0 index while the next one has 'a' at 0 index.\n\n[@AvniGoyal22](/AvniGoyal22) That's programming language specific logic.  Let's try applying logic from JavaScript to this problem~\n\n```javascript\n> 'anything'.indexOf('')\n< 0\n> ''.charAt(0)\n< \"\"\n> ''.charAt(9001)\n< \"\"\n> 'anything'.lastIndexOf('')\n< 8\n< \"anything\"\n> 'anything'.substr(0,9)\n< \"anything\"\n> 'anything'.substr(9001,9)\n< \"\"\n```"
                    },
                    {
                        "username": "shaan__0w0",
                        "content": "i think you have to make the case of if the string is empty"
                    },
                    {
                        "username": "AvniGoyal22",
                        "content": "In a string, the last element is null character. In the first case, where it is \"\",\"\" both of them has same character that is null character, while in \"\",\"anything\" the first string has null character at 0 index while the next one has \\'a\\' at 0 index. "
                    },
                    {
                        "username": "SarK97",
                        "content": "Why this test case is returning -1? Shouldn\\'t it be 4 since it is a substring?\\n\"mississippi\"\\n\"issip\""
                    },
                    {
                        "username": "impatientcat07",
                        "content": "Here comes the Overlapping case while comparing \"issis\" -> \"issip\" it rejects and reinitializes and starts from \"sippi\" & \\n comparing \"issip\", which in turns return -1; "
                    },
                    {
                        "username": "flyingfist",
                        "content": "its because it is taking issis (index 1 to 5) as index 5 is not matching it goes further and doesnt get issip "
                    },
                    {
                        "username": "MaheshPatil19",
                        "content": "here needle =\"issipi\""
                    },
                    {
                        "username": "chickooo",
                        "content": "If you add this test case ( I just did ), the output is 4 as expected.\\nDon\\'t know why you are getting -1. \\nMaybe there were unwanted spaces in your input. Can you try that again?"
                    },
                    {
                        "username": "trpaslik",
                        "content": "Most of python submissions are based on cheating (s.index() or s.find()).\\nIt is a pitty that when implementing it in pure python (the naive `O(n*m)` way) it results in timeout.\\nIt should either be accepted for `O(n*m)` or if some better approach is expected like with a rolling hash then it should be marked as medium IMHO."
                    },
                    {
                        "username": "ryo-kozin",
                        "content": "I believe  an interviewer would be fine with ussing indexOf(). In real-world programming situations, it is often advisable to take full advantage of available built-in functions and libraries. "
                    },
                    {
                        "username": "labule",
                        "content": "[@Deecodes25](/Deecodes25)  Time Complexity is O(n*m). `haystack[i:j] == needle` touches `m` chars and you do this approximately `n` times."
                    },
                    {
                        "username": "youttsu",
                        "content": "true dude. it works on JS with O(m*n) time complexity though "
                    },
                    {
                        "username": "Deecodes25",
                        "content": "I solved with this approach, can anyone explain what is the Time Complexity for this - \\n```\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        i=0\\n        j=len(needle)\\n        while j<=len(haystack):\\n            if haystack[i:j] == needle:\\n                return i\\n            i+=1\\n            j+=1\\n        return -1\\n```"
                    },
                    {
                        "username": "veerashah1",
                        "content": "[@chickooo](/chickooo) Wouldn\\'t an interviewer be fine with .indexOf(), because there\\'s no reason to re-invent the wheel when there are built in functions? If they specifically ask to avoid it then I guess, but in this case they didn\\'t."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Why is using indexOf cheating? Nowhere is it stated that you shouldn\\'t use that. If they don\\'t want you to use that they should say so, or limit the time constraints to only allow O(N+M)"
                    },
                    {
                        "username": "shaan__0w0",
                        "content": "but it gets submitted by using .indexOf() in java \\n"
                    },
                    {
                        "username": "chickooo",
                        "content": "Agreed with your opinion.\\nIf you were to use just built in function like .find() or .indexOf(), then the problem wouldn\\'t be labeled **Medium**. And if you were in an interview, the interviewer would not be pleased."
                    },
                    {
                        "username": "chehsunliu",
                        "content": "I have solved this problem. However, I think it may be controversial to return index 0 when the inputs are \"A\" and \"\". In my opinion, one of the inputs is \"A\\\\0\" and the other is \"\\\\0\". Perhaps it should return index 1."
                    }
                ]
            },
            {
                "id": 1565342,
                "content": [
                    {
                        "username": "Siddharth2k007",
                        "content": "Who marked this as `Easy`? It\\'s not easy at all. Though you can easily produce O(mn) solution, it is not accepted for python. You need KMP algorithm to produce O(m + n) solution!"
                    },
                    {
                        "username": "countdankula",
                        "content": "[@chazwinter](/chazwinter) Lol. The interviewer will just kick you out if you use indexof() to solve this problem."
                    },
                    {
                        "username": "chazwinter",
                        "content": "It\\'s marked easy because the point is to teach you how to use indexOf.\\nIt\\'s only difficult when you fail to learn it lol"
                    },
                    {
                        "username": "Tulsyan_25",
                        "content": "Use sliding window, its that easy\\n"
                    },
                    {
                        "username": "dezann1990",
                        "content": "dude, it is oneliner"
                    },
                    {
                        "username": "Singh_uday99",
                        "content": "[@Anshmehta380](/Anshmehta380) But that is not the thing Leetcode trying to test;\\nIt wants us to study the working of indexOf () method"
                    },
                    {
                        "username": "Anshmehta380",
                        "content": "[@howardcho](/howardcho) Same for me in java"
                    },
                    {
                        "username": "Anshmehta380",
                        "content": "Bro just use indexOf() method i solved it in a one line code lol"
                    },
                    {
                        "username": "charonme",
                        "content": "tha naive O(n^2) solution is now being accepted, but if the testcases contained enough tests with long enough strings it would give a TLE"
                    },
                    {
                        "username": "aalmos",
                        "content": "[@Mister_CK](/Mister_CK) good luck with doing that on an interview bro. "
                    },
                    {
                        "username": "howardcho",
                        "content": "I\\'m not sure if there\\'s a better way, but this was a one-line solution for me in python."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "?! This is one of the easiest problems on the site, a.indexOf(b) satisfies all requirements (O(mn) time complexity I believe), at least in JS. took me 37 seconds, beats 87%"
                    },
                    {
                        "username": "gurpreetsingh8",
                        "content": "[@jdipirro](/jdipirro) exactly, this is just solved in O(N). I am wondering why it is medium"
                    },
                    {
                        "username": "calm27",
                        "content": "Python3 `O(mn)` is acceptable. "
                    },
                    {
                        "username": "pieceofpie",
                        "content": "It is now a ```Medium``` problem."
                    },
                    {
                        "username": "jdipirro",
                        "content": "Is this answer not valid for some reason?  They remarked it medium, but it can be solved with the super easy method below\\n\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n\\n        for x in range(len(haystack)):\\n            if haystack[lx : x + len(needle)] == needle:\\n                return x\\n        else:\\n            return -1"
                    },
                    {
                        "username": "narayan48",
                        "content": "class Solution {\\n    public int strStr(String haystack, String needle) {\\n          int indexOfSubStr = haystack.indexOf(needle);\\n          return indexOfSubStr;\\n\\n    }\\n    //return -1;\\n}"
                    },
                    {
                        "username": "sayedHANEEF",
                        "content": "dude it is a one line solution in java and it takes 0ms to run"
                    },
                    {
                        "username": "SugerSu",
                        "content": "Maybe sometimes we do not need to think too much!\\n\\npublic int strStr(String haystack, String needle) {\\n\\n\\t\\t\\n\\t\\treturn haystack.indexOf(needle);\\n\\t}"
                    },
                    {
                        "username": "coveyjorjet",
                        "content": "similarly you can use find() function in c++\\n```\\nreturn haystack.find(needle);\\n```"
                    },
                    {
                        "username": "enkil2003",
                        "content": "and that is how you never get a job."
                    },
                    {
                        "username": "hippofaris",
                        "content": "giga chad"
                    },
                    {
                        "username": "qAxP4Mw",
                        "content": "[@Meerkats1999](/Meerkats1999) however if your coworker reimplemented indexOf on a project everyone would be pretty annoyed so I think interviewer should accept this answer. Otherwise they should be more clear about what they\\'re looking for."
                    },
                    {
                        "username": "yuangaonyc",
                        "content": "Maybe you should think more"
                    },
                    {
                        "username": "chazwinter",
                        "content": "Don\\'t provide solutions, no matter how easy you think they are.\\nThis answer uses built in Java functionality without imports, so it\\'s fair game. If they wanted you to design your own indexOf method, they would have said so. \\n\\nThere are other problems that specifically say to avoid certain methods, or ask a follow to challenge you to try it another way. This one does not have that, so I see it as an attempt to expose new people to indexOf."
                    },
                    {
                        "username": "dantruongdo3",
                        "content": "[@Meerkats1999](/Meerkats1999) i use the exact same way and feel kinda guilty."
                    },
                    {
                        "username": "Meerkats1999",
                        "content": "I don\\'t think the interviewer will like this answer."
                    },
                    {
                        "username": "emcc1990",
                        "content": "I also submitted this but having doubts of whether the whole point is not to use it and implement something raw. "
                    },
                    {
                        "username": "user0566A",
                        "content": "It\\'s interesting that java indexOf do not use KMP (because of memory I think) or Rabin-Karp (don\\'t know why)\\nhttps://github.com/AdoptOpenJDK/openjdk-jdk11/blob/master/src/java.base/share/classes/java/lang/StringLatin1.java#L233-L253"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@therishuraj](/therishuraj) My indexOf solution beats 91%... It\\'s definitely fast enough and thus I strongly feel this should be easy. Otherwise LeetCode should drastically limit the time-constraints in my opinion"
                    },
                    {
                        "username": "user0743xF",
                        "content": "[@mohan9814](/mohan9814) because here people are coming to learn algorithms i think :)"
                    },
                    {
                        "username": "therishuraj",
                        "content": "[@mohan9814](/mohan9814)  Because time complexity of the KMP algorithm is O(m+n) And time complexity of the indexOf method is O(nm). "
                    },
                    {
                        "username": "mohan9814",
                        "content": "yes same logic in c++ is working fine why do i need to get into kmp and all this"
                    },
                    {
                        "username": "mgoldenbe",
                        "content": "I don\\'t think they meant that I can call a library function. Also, I get \"Time Limit Exceeded\" on brute-force. So, this means I should use an advanced algorithm, like Rabin-Karp or KMP. Why then is this problem marked \"easy\"?"
                    },
                    {
                        "username": "chazwinter",
                        "content": "It\\'s easy because the point is to teach you to 1) stop overthinking things, and 2) learn one single function that solves the problem in one line."
                    },
                    {
                        "username": "C0de_bumstead",
                        "content": "Can be easily solved using sliding window duhh...."
                    },
                    {
                        "username": "mikael6767",
                        "content": "Why should it be marked ```Medium```. This is literally 1line of code or 28 symbols(I\\'m counting the ```return``` function). You don\\'t need any algorithm. You need one function (if you use python3). And that function starts of the letter \"f\""
                    },
                    {
                        "username": "2020uch0017",
                        "content": "it is medium now and yes it is a KMP  problem"
                    },
                    {
                        "username": "jarc",
                        "content": " Is it the standard string matching problem? Am I wrong?"
                    },
                    {
                        "username": "chickooo",
                        "content": "Yeah, this is the standard string matching problem.\\nYour function should perform same as **.find()** function in python OR **.indexOf()** function in javascript"
                    },
                    {
                        "username": "tlong1299",
                        "content": "**USE FIND**\\nAs a Python programmer, refusing to use core language features is akin to using a hammer instead of nail-gun because it makes you a \"better\" carpenter. Remember that this is Python not C. Python\\'s PEP 20 states, \"There should be one-- and preferably only one --obvious way to do it.\" I would call a string operation built into python designed to solve this particular problem the obvious way to do it.\\n\\n**DON\\'T USE FIND**\\nIf you go into an interview and solve this problem with the find() function, you better know how it works underneath, and you should be prepared to defend your use of it. After all nothing is \"free\" in your code, and even \"magic\" functions have a time and memory cost associated with them. Knowing what this cost is, and why it is the way it is will make you a better programmer. Implementing the function yourself, at least once, can really help you develop a better appreciation for the language."
                    },
                    {
                        "username": "chazwinter",
                        "content": "Finally, a Python programmer that isn\\'t an idiot. It\\'s wild how people overthink this problem."
                    },
                    {
                        "username": "marten2",
                        "content": "Hey,\\n\\nI wouldn't say that coming up with the KMP algorithm from scratch is easy ~1 hour time. Did companies that asked this question expect applicants to know KMP by heart? Did they expect the applicant to show a naive implementation? Any opinion on this?\\n\\nBest,\\n\\nMarten"
                    },
                    {
                        "username": "syfo_dias",
                        "content": "[@chazwinter](/chazwinter) is it Python specific task? Or what is indexOf in C++? "
                    },
                    {
                        "username": "chazwinter",
                        "content": "No, they expected you to know indexOf. Don\\'t overthink it."
                    },
                    {
                        "username": "zijianz",
                        "content": "Input: \\t\"\", \"\"\\nOutput: \\t-1\\nExpected: \\t0\\n\\nBasically there is nothing in the string, how do you get the index.\\n\\nIf this test case is valid, then needle =\"\", haystack=\"anything\" could return any value. since empty is everywhere."
                    },
                    {
                        "username": "chazwinter",
                        "content": "Read the constraints. If you had to deal with an empty string, you would simply write an edge case for it."
                    },
                    {
                        "username": "mansourcodes",
                        "content": "1 <= haystack.length, needle.length <= 104\\n"
                    },
                    {
                        "username": "cxaviousb",
                        "content": "> In a string, the last element is null character. In the first case, where it is \"\",\"\" both of them has same character that is null character, while in \"\",\"anything\" the first string has null character at 0 index while the next one has 'a' at 0 index.\n\n[@AvniGoyal22](/AvniGoyal22) That's programming language specific logic.  Let's try applying logic from JavaScript to this problem~\n\n```javascript\n> 'anything'.indexOf('')\n< 0\n> ''.charAt(0)\n< \"\"\n> ''.charAt(9001)\n< \"\"\n> 'anything'.lastIndexOf('')\n< 8\n< \"anything\"\n> 'anything'.substr(0,9)\n< \"anything\"\n> 'anything'.substr(9001,9)\n< \"\"\n```"
                    },
                    {
                        "username": "shaan__0w0",
                        "content": "i think you have to make the case of if the string is empty"
                    },
                    {
                        "username": "AvniGoyal22",
                        "content": "In a string, the last element is null character. In the first case, where it is \"\",\"\" both of them has same character that is null character, while in \"\",\"anything\" the first string has null character at 0 index while the next one has \\'a\\' at 0 index. "
                    },
                    {
                        "username": "SarK97",
                        "content": "Why this test case is returning -1? Shouldn\\'t it be 4 since it is a substring?\\n\"mississippi\"\\n\"issip\""
                    },
                    {
                        "username": "impatientcat07",
                        "content": "Here comes the Overlapping case while comparing \"issis\" -> \"issip\" it rejects and reinitializes and starts from \"sippi\" & \\n comparing \"issip\", which in turns return -1; "
                    },
                    {
                        "username": "flyingfist",
                        "content": "its because it is taking issis (index 1 to 5) as index 5 is not matching it goes further and doesnt get issip "
                    },
                    {
                        "username": "MaheshPatil19",
                        "content": "here needle =\"issipi\""
                    },
                    {
                        "username": "chickooo",
                        "content": "If you add this test case ( I just did ), the output is 4 as expected.\\nDon\\'t know why you are getting -1. \\nMaybe there were unwanted spaces in your input. Can you try that again?"
                    },
                    {
                        "username": "trpaslik",
                        "content": "Most of python submissions are based on cheating (s.index() or s.find()).\\nIt is a pitty that when implementing it in pure python (the naive `O(n*m)` way) it results in timeout.\\nIt should either be accepted for `O(n*m)` or if some better approach is expected like with a rolling hash then it should be marked as medium IMHO."
                    },
                    {
                        "username": "ryo-kozin",
                        "content": "I believe  an interviewer would be fine with ussing indexOf(). In real-world programming situations, it is often advisable to take full advantage of available built-in functions and libraries. "
                    },
                    {
                        "username": "labule",
                        "content": "[@Deecodes25](/Deecodes25)  Time Complexity is O(n*m). `haystack[i:j] == needle` touches `m` chars and you do this approximately `n` times."
                    },
                    {
                        "username": "youttsu",
                        "content": "true dude. it works on JS with O(m*n) time complexity though "
                    },
                    {
                        "username": "Deecodes25",
                        "content": "I solved with this approach, can anyone explain what is the Time Complexity for this - \\n```\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        i=0\\n        j=len(needle)\\n        while j<=len(haystack):\\n            if haystack[i:j] == needle:\\n                return i\\n            i+=1\\n            j+=1\\n        return -1\\n```"
                    },
                    {
                        "username": "veerashah1",
                        "content": "[@chickooo](/chickooo) Wouldn\\'t an interviewer be fine with .indexOf(), because there\\'s no reason to re-invent the wheel when there are built in functions? If they specifically ask to avoid it then I guess, but in this case they didn\\'t."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Why is using indexOf cheating? Nowhere is it stated that you shouldn\\'t use that. If they don\\'t want you to use that they should say so, or limit the time constraints to only allow O(N+M)"
                    },
                    {
                        "username": "shaan__0w0",
                        "content": "but it gets submitted by using .indexOf() in java \\n"
                    },
                    {
                        "username": "chickooo",
                        "content": "Agreed with your opinion.\\nIf you were to use just built in function like .find() or .indexOf(), then the problem wouldn\\'t be labeled **Medium**. And if you were in an interview, the interviewer would not be pleased."
                    },
                    {
                        "username": "chehsunliu",
                        "content": "I have solved this problem. However, I think it may be controversial to return index 0 when the inputs are \"A\" and \"\". In my opinion, one of the inputs is \"A\\\\0\" and the other is \"\\\\0\". Perhaps it should return index 1."
                    }
                ]
            },
            {
                "id": 1570759,
                "content": [
                    {
                        "username": "Siddharth2k007",
                        "content": "Who marked this as `Easy`? It\\'s not easy at all. Though you can easily produce O(mn) solution, it is not accepted for python. You need KMP algorithm to produce O(m + n) solution!"
                    },
                    {
                        "username": "countdankula",
                        "content": "[@chazwinter](/chazwinter) Lol. The interviewer will just kick you out if you use indexof() to solve this problem."
                    },
                    {
                        "username": "chazwinter",
                        "content": "It\\'s marked easy because the point is to teach you how to use indexOf.\\nIt\\'s only difficult when you fail to learn it lol"
                    },
                    {
                        "username": "Tulsyan_25",
                        "content": "Use sliding window, its that easy\\n"
                    },
                    {
                        "username": "dezann1990",
                        "content": "dude, it is oneliner"
                    },
                    {
                        "username": "Singh_uday99",
                        "content": "[@Anshmehta380](/Anshmehta380) But that is not the thing Leetcode trying to test;\\nIt wants us to study the working of indexOf () method"
                    },
                    {
                        "username": "Anshmehta380",
                        "content": "[@howardcho](/howardcho) Same for me in java"
                    },
                    {
                        "username": "Anshmehta380",
                        "content": "Bro just use indexOf() method i solved it in a one line code lol"
                    },
                    {
                        "username": "charonme",
                        "content": "tha naive O(n^2) solution is now being accepted, but if the testcases contained enough tests with long enough strings it would give a TLE"
                    },
                    {
                        "username": "aalmos",
                        "content": "[@Mister_CK](/Mister_CK) good luck with doing that on an interview bro. "
                    },
                    {
                        "username": "howardcho",
                        "content": "I\\'m not sure if there\\'s a better way, but this was a one-line solution for me in python."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "?! This is one of the easiest problems on the site, a.indexOf(b) satisfies all requirements (O(mn) time complexity I believe), at least in JS. took me 37 seconds, beats 87%"
                    },
                    {
                        "username": "gurpreetsingh8",
                        "content": "[@jdipirro](/jdipirro) exactly, this is just solved in O(N). I am wondering why it is medium"
                    },
                    {
                        "username": "calm27",
                        "content": "Python3 `O(mn)` is acceptable. "
                    },
                    {
                        "username": "pieceofpie",
                        "content": "It is now a ```Medium``` problem."
                    },
                    {
                        "username": "jdipirro",
                        "content": "Is this answer not valid for some reason?  They remarked it medium, but it can be solved with the super easy method below\\n\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n\\n        for x in range(len(haystack)):\\n            if haystack[lx : x + len(needle)] == needle:\\n                return x\\n        else:\\n            return -1"
                    },
                    {
                        "username": "narayan48",
                        "content": "class Solution {\\n    public int strStr(String haystack, String needle) {\\n          int indexOfSubStr = haystack.indexOf(needle);\\n          return indexOfSubStr;\\n\\n    }\\n    //return -1;\\n}"
                    },
                    {
                        "username": "sayedHANEEF",
                        "content": "dude it is a one line solution in java and it takes 0ms to run"
                    },
                    {
                        "username": "SugerSu",
                        "content": "Maybe sometimes we do not need to think too much!\\n\\npublic int strStr(String haystack, String needle) {\\n\\n\\t\\t\\n\\t\\treturn haystack.indexOf(needle);\\n\\t}"
                    },
                    {
                        "username": "coveyjorjet",
                        "content": "similarly you can use find() function in c++\\n```\\nreturn haystack.find(needle);\\n```"
                    },
                    {
                        "username": "enkil2003",
                        "content": "and that is how you never get a job."
                    },
                    {
                        "username": "hippofaris",
                        "content": "giga chad"
                    },
                    {
                        "username": "qAxP4Mw",
                        "content": "[@Meerkats1999](/Meerkats1999) however if your coworker reimplemented indexOf on a project everyone would be pretty annoyed so I think interviewer should accept this answer. Otherwise they should be more clear about what they\\'re looking for."
                    },
                    {
                        "username": "yuangaonyc",
                        "content": "Maybe you should think more"
                    },
                    {
                        "username": "chazwinter",
                        "content": "Don\\'t provide solutions, no matter how easy you think they are.\\nThis answer uses built in Java functionality without imports, so it\\'s fair game. If they wanted you to design your own indexOf method, they would have said so. \\n\\nThere are other problems that specifically say to avoid certain methods, or ask a follow to challenge you to try it another way. This one does not have that, so I see it as an attempt to expose new people to indexOf."
                    },
                    {
                        "username": "dantruongdo3",
                        "content": "[@Meerkats1999](/Meerkats1999) i use the exact same way and feel kinda guilty."
                    },
                    {
                        "username": "Meerkats1999",
                        "content": "I don\\'t think the interviewer will like this answer."
                    },
                    {
                        "username": "emcc1990",
                        "content": "I also submitted this but having doubts of whether the whole point is not to use it and implement something raw. "
                    },
                    {
                        "username": "user0566A",
                        "content": "It\\'s interesting that java indexOf do not use KMP (because of memory I think) or Rabin-Karp (don\\'t know why)\\nhttps://github.com/AdoptOpenJDK/openjdk-jdk11/blob/master/src/java.base/share/classes/java/lang/StringLatin1.java#L233-L253"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@therishuraj](/therishuraj) My indexOf solution beats 91%... It\\'s definitely fast enough and thus I strongly feel this should be easy. Otherwise LeetCode should drastically limit the time-constraints in my opinion"
                    },
                    {
                        "username": "user0743xF",
                        "content": "[@mohan9814](/mohan9814) because here people are coming to learn algorithms i think :)"
                    },
                    {
                        "username": "therishuraj",
                        "content": "[@mohan9814](/mohan9814)  Because time complexity of the KMP algorithm is O(m+n) And time complexity of the indexOf method is O(nm). "
                    },
                    {
                        "username": "mohan9814",
                        "content": "yes same logic in c++ is working fine why do i need to get into kmp and all this"
                    },
                    {
                        "username": "mgoldenbe",
                        "content": "I don\\'t think they meant that I can call a library function. Also, I get \"Time Limit Exceeded\" on brute-force. So, this means I should use an advanced algorithm, like Rabin-Karp or KMP. Why then is this problem marked \"easy\"?"
                    },
                    {
                        "username": "chazwinter",
                        "content": "It\\'s easy because the point is to teach you to 1) stop overthinking things, and 2) learn one single function that solves the problem in one line."
                    },
                    {
                        "username": "C0de_bumstead",
                        "content": "Can be easily solved using sliding window duhh...."
                    },
                    {
                        "username": "mikael6767",
                        "content": "Why should it be marked ```Medium```. This is literally 1line of code or 28 symbols(I\\'m counting the ```return``` function). You don\\'t need any algorithm. You need one function (if you use python3). And that function starts of the letter \"f\""
                    },
                    {
                        "username": "2020uch0017",
                        "content": "it is medium now and yes it is a KMP  problem"
                    },
                    {
                        "username": "jarc",
                        "content": " Is it the standard string matching problem? Am I wrong?"
                    },
                    {
                        "username": "chickooo",
                        "content": "Yeah, this is the standard string matching problem.\\nYour function should perform same as **.find()** function in python OR **.indexOf()** function in javascript"
                    },
                    {
                        "username": "tlong1299",
                        "content": "**USE FIND**\\nAs a Python programmer, refusing to use core language features is akin to using a hammer instead of nail-gun because it makes you a \"better\" carpenter. Remember that this is Python not C. Python\\'s PEP 20 states, \"There should be one-- and preferably only one --obvious way to do it.\" I would call a string operation built into python designed to solve this particular problem the obvious way to do it.\\n\\n**DON\\'T USE FIND**\\nIf you go into an interview and solve this problem with the find() function, you better know how it works underneath, and you should be prepared to defend your use of it. After all nothing is \"free\" in your code, and even \"magic\" functions have a time and memory cost associated with them. Knowing what this cost is, and why it is the way it is will make you a better programmer. Implementing the function yourself, at least once, can really help you develop a better appreciation for the language."
                    },
                    {
                        "username": "chazwinter",
                        "content": "Finally, a Python programmer that isn\\'t an idiot. It\\'s wild how people overthink this problem."
                    },
                    {
                        "username": "marten2",
                        "content": "Hey,\\n\\nI wouldn't say that coming up with the KMP algorithm from scratch is easy ~1 hour time. Did companies that asked this question expect applicants to know KMP by heart? Did they expect the applicant to show a naive implementation? Any opinion on this?\\n\\nBest,\\n\\nMarten"
                    },
                    {
                        "username": "syfo_dias",
                        "content": "[@chazwinter](/chazwinter) is it Python specific task? Or what is indexOf in C++? "
                    },
                    {
                        "username": "chazwinter",
                        "content": "No, they expected you to know indexOf. Don\\'t overthink it."
                    },
                    {
                        "username": "zijianz",
                        "content": "Input: \\t\"\", \"\"\\nOutput: \\t-1\\nExpected: \\t0\\n\\nBasically there is nothing in the string, how do you get the index.\\n\\nIf this test case is valid, then needle =\"\", haystack=\"anything\" could return any value. since empty is everywhere."
                    },
                    {
                        "username": "chazwinter",
                        "content": "Read the constraints. If you had to deal with an empty string, you would simply write an edge case for it."
                    },
                    {
                        "username": "mansourcodes",
                        "content": "1 <= haystack.length, needle.length <= 104\\n"
                    },
                    {
                        "username": "cxaviousb",
                        "content": "> In a string, the last element is null character. In the first case, where it is \"\",\"\" both of them has same character that is null character, while in \"\",\"anything\" the first string has null character at 0 index while the next one has 'a' at 0 index.\n\n[@AvniGoyal22](/AvniGoyal22) That's programming language specific logic.  Let's try applying logic from JavaScript to this problem~\n\n```javascript\n> 'anything'.indexOf('')\n< 0\n> ''.charAt(0)\n< \"\"\n> ''.charAt(9001)\n< \"\"\n> 'anything'.lastIndexOf('')\n< 8\n< \"anything\"\n> 'anything'.substr(0,9)\n< \"anything\"\n> 'anything'.substr(9001,9)\n< \"\"\n```"
                    },
                    {
                        "username": "shaan__0w0",
                        "content": "i think you have to make the case of if the string is empty"
                    },
                    {
                        "username": "AvniGoyal22",
                        "content": "In a string, the last element is null character. In the first case, where it is \"\",\"\" both of them has same character that is null character, while in \"\",\"anything\" the first string has null character at 0 index while the next one has \\'a\\' at 0 index. "
                    },
                    {
                        "username": "SarK97",
                        "content": "Why this test case is returning -1? Shouldn\\'t it be 4 since it is a substring?\\n\"mississippi\"\\n\"issip\""
                    },
                    {
                        "username": "impatientcat07",
                        "content": "Here comes the Overlapping case while comparing \"issis\" -> \"issip\" it rejects and reinitializes and starts from \"sippi\" & \\n comparing \"issip\", which in turns return -1; "
                    },
                    {
                        "username": "flyingfist",
                        "content": "its because it is taking issis (index 1 to 5) as index 5 is not matching it goes further and doesnt get issip "
                    },
                    {
                        "username": "MaheshPatil19",
                        "content": "here needle =\"issipi\""
                    },
                    {
                        "username": "chickooo",
                        "content": "If you add this test case ( I just did ), the output is 4 as expected.\\nDon\\'t know why you are getting -1. \\nMaybe there were unwanted spaces in your input. Can you try that again?"
                    },
                    {
                        "username": "trpaslik",
                        "content": "Most of python submissions are based on cheating (s.index() or s.find()).\\nIt is a pitty that when implementing it in pure python (the naive `O(n*m)` way) it results in timeout.\\nIt should either be accepted for `O(n*m)` or if some better approach is expected like with a rolling hash then it should be marked as medium IMHO."
                    },
                    {
                        "username": "ryo-kozin",
                        "content": "I believe  an interviewer would be fine with ussing indexOf(). In real-world programming situations, it is often advisable to take full advantage of available built-in functions and libraries. "
                    },
                    {
                        "username": "labule",
                        "content": "[@Deecodes25](/Deecodes25)  Time Complexity is O(n*m). `haystack[i:j] == needle` touches `m` chars and you do this approximately `n` times."
                    },
                    {
                        "username": "youttsu",
                        "content": "true dude. it works on JS with O(m*n) time complexity though "
                    },
                    {
                        "username": "Deecodes25",
                        "content": "I solved with this approach, can anyone explain what is the Time Complexity for this - \\n```\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        i=0\\n        j=len(needle)\\n        while j<=len(haystack):\\n            if haystack[i:j] == needle:\\n                return i\\n            i+=1\\n            j+=1\\n        return -1\\n```"
                    },
                    {
                        "username": "veerashah1",
                        "content": "[@chickooo](/chickooo) Wouldn\\'t an interviewer be fine with .indexOf(), because there\\'s no reason to re-invent the wheel when there are built in functions? If they specifically ask to avoid it then I guess, but in this case they didn\\'t."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Why is using indexOf cheating? Nowhere is it stated that you shouldn\\'t use that. If they don\\'t want you to use that they should say so, or limit the time constraints to only allow O(N+M)"
                    },
                    {
                        "username": "shaan__0w0",
                        "content": "but it gets submitted by using .indexOf() in java \\n"
                    },
                    {
                        "username": "chickooo",
                        "content": "Agreed with your opinion.\\nIf you were to use just built in function like .find() or .indexOf(), then the problem wouldn\\'t be labeled **Medium**. And if you were in an interview, the interviewer would not be pleased."
                    },
                    {
                        "username": "chehsunliu",
                        "content": "I have solved this problem. However, I think it may be controversial to return index 0 when the inputs are \"A\" and \"\". In my opinion, one of the inputs is \"A\\\\0\" and the other is \"\\\\0\". Perhaps it should return index 1."
                    }
                ]
            },
            {
                "id": 1567172,
                "content": [
                    {
                        "username": "Siddharth2k007",
                        "content": "Who marked this as `Easy`? It\\'s not easy at all. Though you can easily produce O(mn) solution, it is not accepted for python. You need KMP algorithm to produce O(m + n) solution!"
                    },
                    {
                        "username": "countdankula",
                        "content": "[@chazwinter](/chazwinter) Lol. The interviewer will just kick you out if you use indexof() to solve this problem."
                    },
                    {
                        "username": "chazwinter",
                        "content": "It\\'s marked easy because the point is to teach you how to use indexOf.\\nIt\\'s only difficult when you fail to learn it lol"
                    },
                    {
                        "username": "Tulsyan_25",
                        "content": "Use sliding window, its that easy\\n"
                    },
                    {
                        "username": "dezann1990",
                        "content": "dude, it is oneliner"
                    },
                    {
                        "username": "Singh_uday99",
                        "content": "[@Anshmehta380](/Anshmehta380) But that is not the thing Leetcode trying to test;\\nIt wants us to study the working of indexOf () method"
                    },
                    {
                        "username": "Anshmehta380",
                        "content": "[@howardcho](/howardcho) Same for me in java"
                    },
                    {
                        "username": "Anshmehta380",
                        "content": "Bro just use indexOf() method i solved it in a one line code lol"
                    },
                    {
                        "username": "charonme",
                        "content": "tha naive O(n^2) solution is now being accepted, but if the testcases contained enough tests with long enough strings it would give a TLE"
                    },
                    {
                        "username": "aalmos",
                        "content": "[@Mister_CK](/Mister_CK) good luck with doing that on an interview bro. "
                    },
                    {
                        "username": "howardcho",
                        "content": "I\\'m not sure if there\\'s a better way, but this was a one-line solution for me in python."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "?! This is one of the easiest problems on the site, a.indexOf(b) satisfies all requirements (O(mn) time complexity I believe), at least in JS. took me 37 seconds, beats 87%"
                    },
                    {
                        "username": "gurpreetsingh8",
                        "content": "[@jdipirro](/jdipirro) exactly, this is just solved in O(N). I am wondering why it is medium"
                    },
                    {
                        "username": "calm27",
                        "content": "Python3 `O(mn)` is acceptable. "
                    },
                    {
                        "username": "pieceofpie",
                        "content": "It is now a ```Medium``` problem."
                    },
                    {
                        "username": "jdipirro",
                        "content": "Is this answer not valid for some reason?  They remarked it medium, but it can be solved with the super easy method below\\n\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n\\n        for x in range(len(haystack)):\\n            if haystack[lx : x + len(needle)] == needle:\\n                return x\\n        else:\\n            return -1"
                    },
                    {
                        "username": "narayan48",
                        "content": "class Solution {\\n    public int strStr(String haystack, String needle) {\\n          int indexOfSubStr = haystack.indexOf(needle);\\n          return indexOfSubStr;\\n\\n    }\\n    //return -1;\\n}"
                    },
                    {
                        "username": "sayedHANEEF",
                        "content": "dude it is a one line solution in java and it takes 0ms to run"
                    },
                    {
                        "username": "SugerSu",
                        "content": "Maybe sometimes we do not need to think too much!\\n\\npublic int strStr(String haystack, String needle) {\\n\\n\\t\\t\\n\\t\\treturn haystack.indexOf(needle);\\n\\t}"
                    },
                    {
                        "username": "coveyjorjet",
                        "content": "similarly you can use find() function in c++\\n```\\nreturn haystack.find(needle);\\n```"
                    },
                    {
                        "username": "enkil2003",
                        "content": "and that is how you never get a job."
                    },
                    {
                        "username": "hippofaris",
                        "content": "giga chad"
                    },
                    {
                        "username": "qAxP4Mw",
                        "content": "[@Meerkats1999](/Meerkats1999) however if your coworker reimplemented indexOf on a project everyone would be pretty annoyed so I think interviewer should accept this answer. Otherwise they should be more clear about what they\\'re looking for."
                    },
                    {
                        "username": "yuangaonyc",
                        "content": "Maybe you should think more"
                    },
                    {
                        "username": "chazwinter",
                        "content": "Don\\'t provide solutions, no matter how easy you think they are.\\nThis answer uses built in Java functionality without imports, so it\\'s fair game. If they wanted you to design your own indexOf method, they would have said so. \\n\\nThere are other problems that specifically say to avoid certain methods, or ask a follow to challenge you to try it another way. This one does not have that, so I see it as an attempt to expose new people to indexOf."
                    },
                    {
                        "username": "dantruongdo3",
                        "content": "[@Meerkats1999](/Meerkats1999) i use the exact same way and feel kinda guilty."
                    },
                    {
                        "username": "Meerkats1999",
                        "content": "I don\\'t think the interviewer will like this answer."
                    },
                    {
                        "username": "emcc1990",
                        "content": "I also submitted this but having doubts of whether the whole point is not to use it and implement something raw. "
                    },
                    {
                        "username": "user0566A",
                        "content": "It\\'s interesting that java indexOf do not use KMP (because of memory I think) or Rabin-Karp (don\\'t know why)\\nhttps://github.com/AdoptOpenJDK/openjdk-jdk11/blob/master/src/java.base/share/classes/java/lang/StringLatin1.java#L233-L253"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@therishuraj](/therishuraj) My indexOf solution beats 91%... It\\'s definitely fast enough and thus I strongly feel this should be easy. Otherwise LeetCode should drastically limit the time-constraints in my opinion"
                    },
                    {
                        "username": "user0743xF",
                        "content": "[@mohan9814](/mohan9814) because here people are coming to learn algorithms i think :)"
                    },
                    {
                        "username": "therishuraj",
                        "content": "[@mohan9814](/mohan9814)  Because time complexity of the KMP algorithm is O(m+n) And time complexity of the indexOf method is O(nm). "
                    },
                    {
                        "username": "mohan9814",
                        "content": "yes same logic in c++ is working fine why do i need to get into kmp and all this"
                    },
                    {
                        "username": "mgoldenbe",
                        "content": "I don\\'t think they meant that I can call a library function. Also, I get \"Time Limit Exceeded\" on brute-force. So, this means I should use an advanced algorithm, like Rabin-Karp or KMP. Why then is this problem marked \"easy\"?"
                    },
                    {
                        "username": "chazwinter",
                        "content": "It\\'s easy because the point is to teach you to 1) stop overthinking things, and 2) learn one single function that solves the problem in one line."
                    },
                    {
                        "username": "C0de_bumstead",
                        "content": "Can be easily solved using sliding window duhh...."
                    },
                    {
                        "username": "mikael6767",
                        "content": "Why should it be marked ```Medium```. This is literally 1line of code or 28 symbols(I\\'m counting the ```return``` function). You don\\'t need any algorithm. You need one function (if you use python3). And that function starts of the letter \"f\""
                    },
                    {
                        "username": "2020uch0017",
                        "content": "it is medium now and yes it is a KMP  problem"
                    },
                    {
                        "username": "jarc",
                        "content": " Is it the standard string matching problem? Am I wrong?"
                    },
                    {
                        "username": "chickooo",
                        "content": "Yeah, this is the standard string matching problem.\\nYour function should perform same as **.find()** function in python OR **.indexOf()** function in javascript"
                    },
                    {
                        "username": "tlong1299",
                        "content": "**USE FIND**\\nAs a Python programmer, refusing to use core language features is akin to using a hammer instead of nail-gun because it makes you a \"better\" carpenter. Remember that this is Python not C. Python\\'s PEP 20 states, \"There should be one-- and preferably only one --obvious way to do it.\" I would call a string operation built into python designed to solve this particular problem the obvious way to do it.\\n\\n**DON\\'T USE FIND**\\nIf you go into an interview and solve this problem with the find() function, you better know how it works underneath, and you should be prepared to defend your use of it. After all nothing is \"free\" in your code, and even \"magic\" functions have a time and memory cost associated with them. Knowing what this cost is, and why it is the way it is will make you a better programmer. Implementing the function yourself, at least once, can really help you develop a better appreciation for the language."
                    },
                    {
                        "username": "chazwinter",
                        "content": "Finally, a Python programmer that isn\\'t an idiot. It\\'s wild how people overthink this problem."
                    },
                    {
                        "username": "marten2",
                        "content": "Hey,\\n\\nI wouldn't say that coming up with the KMP algorithm from scratch is easy ~1 hour time. Did companies that asked this question expect applicants to know KMP by heart? Did they expect the applicant to show a naive implementation? Any opinion on this?\\n\\nBest,\\n\\nMarten"
                    },
                    {
                        "username": "syfo_dias",
                        "content": "[@chazwinter](/chazwinter) is it Python specific task? Or what is indexOf in C++? "
                    },
                    {
                        "username": "chazwinter",
                        "content": "No, they expected you to know indexOf. Don\\'t overthink it."
                    },
                    {
                        "username": "zijianz",
                        "content": "Input: \\t\"\", \"\"\\nOutput: \\t-1\\nExpected: \\t0\\n\\nBasically there is nothing in the string, how do you get the index.\\n\\nIf this test case is valid, then needle =\"\", haystack=\"anything\" could return any value. since empty is everywhere."
                    },
                    {
                        "username": "chazwinter",
                        "content": "Read the constraints. If you had to deal with an empty string, you would simply write an edge case for it."
                    },
                    {
                        "username": "mansourcodes",
                        "content": "1 <= haystack.length, needle.length <= 104\\n"
                    },
                    {
                        "username": "cxaviousb",
                        "content": "> In a string, the last element is null character. In the first case, where it is \"\",\"\" both of them has same character that is null character, while in \"\",\"anything\" the first string has null character at 0 index while the next one has 'a' at 0 index.\n\n[@AvniGoyal22](/AvniGoyal22) That's programming language specific logic.  Let's try applying logic from JavaScript to this problem~\n\n```javascript\n> 'anything'.indexOf('')\n< 0\n> ''.charAt(0)\n< \"\"\n> ''.charAt(9001)\n< \"\"\n> 'anything'.lastIndexOf('')\n< 8\n< \"anything\"\n> 'anything'.substr(0,9)\n< \"anything\"\n> 'anything'.substr(9001,9)\n< \"\"\n```"
                    },
                    {
                        "username": "shaan__0w0",
                        "content": "i think you have to make the case of if the string is empty"
                    },
                    {
                        "username": "AvniGoyal22",
                        "content": "In a string, the last element is null character. In the first case, where it is \"\",\"\" both of them has same character that is null character, while in \"\",\"anything\" the first string has null character at 0 index while the next one has \\'a\\' at 0 index. "
                    },
                    {
                        "username": "SarK97",
                        "content": "Why this test case is returning -1? Shouldn\\'t it be 4 since it is a substring?\\n\"mississippi\"\\n\"issip\""
                    },
                    {
                        "username": "impatientcat07",
                        "content": "Here comes the Overlapping case while comparing \"issis\" -> \"issip\" it rejects and reinitializes and starts from \"sippi\" & \\n comparing \"issip\", which in turns return -1; "
                    },
                    {
                        "username": "flyingfist",
                        "content": "its because it is taking issis (index 1 to 5) as index 5 is not matching it goes further and doesnt get issip "
                    },
                    {
                        "username": "MaheshPatil19",
                        "content": "here needle =\"issipi\""
                    },
                    {
                        "username": "chickooo",
                        "content": "If you add this test case ( I just did ), the output is 4 as expected.\\nDon\\'t know why you are getting -1. \\nMaybe there were unwanted spaces in your input. Can you try that again?"
                    },
                    {
                        "username": "trpaslik",
                        "content": "Most of python submissions are based on cheating (s.index() or s.find()).\\nIt is a pitty that when implementing it in pure python (the naive `O(n*m)` way) it results in timeout.\\nIt should either be accepted for `O(n*m)` or if some better approach is expected like with a rolling hash then it should be marked as medium IMHO."
                    },
                    {
                        "username": "ryo-kozin",
                        "content": "I believe  an interviewer would be fine with ussing indexOf(). In real-world programming situations, it is often advisable to take full advantage of available built-in functions and libraries. "
                    },
                    {
                        "username": "labule",
                        "content": "[@Deecodes25](/Deecodes25)  Time Complexity is O(n*m). `haystack[i:j] == needle` touches `m` chars and you do this approximately `n` times."
                    },
                    {
                        "username": "youttsu",
                        "content": "true dude. it works on JS with O(m*n) time complexity though "
                    },
                    {
                        "username": "Deecodes25",
                        "content": "I solved with this approach, can anyone explain what is the Time Complexity for this - \\n```\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        i=0\\n        j=len(needle)\\n        while j<=len(haystack):\\n            if haystack[i:j] == needle:\\n                return i\\n            i+=1\\n            j+=1\\n        return -1\\n```"
                    },
                    {
                        "username": "veerashah1",
                        "content": "[@chickooo](/chickooo) Wouldn\\'t an interviewer be fine with .indexOf(), because there\\'s no reason to re-invent the wheel when there are built in functions? If they specifically ask to avoid it then I guess, but in this case they didn\\'t."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Why is using indexOf cheating? Nowhere is it stated that you shouldn\\'t use that. If they don\\'t want you to use that they should say so, or limit the time constraints to only allow O(N+M)"
                    },
                    {
                        "username": "shaan__0w0",
                        "content": "but it gets submitted by using .indexOf() in java \\n"
                    },
                    {
                        "username": "chickooo",
                        "content": "Agreed with your opinion.\\nIf you were to use just built in function like .find() or .indexOf(), then the problem wouldn\\'t be labeled **Medium**. And if you were in an interview, the interviewer would not be pleased."
                    },
                    {
                        "username": "chehsunliu",
                        "content": "I have solved this problem. However, I think it may be controversial to return index 0 when the inputs are \"A\" and \"\". In my opinion, one of the inputs is \"A\\\\0\" and the other is \"\\\\0\". Perhaps it should return index 1."
                    }
                ]
            },
            {
                "id": 1564985,
                "content": [
                    {
                        "username": "Siddharth2k007",
                        "content": "Who marked this as `Easy`? It\\'s not easy at all. Though you can easily produce O(mn) solution, it is not accepted for python. You need KMP algorithm to produce O(m + n) solution!"
                    },
                    {
                        "username": "countdankula",
                        "content": "[@chazwinter](/chazwinter) Lol. The interviewer will just kick you out if you use indexof() to solve this problem."
                    },
                    {
                        "username": "chazwinter",
                        "content": "It\\'s marked easy because the point is to teach you how to use indexOf.\\nIt\\'s only difficult when you fail to learn it lol"
                    },
                    {
                        "username": "Tulsyan_25",
                        "content": "Use sliding window, its that easy\\n"
                    },
                    {
                        "username": "dezann1990",
                        "content": "dude, it is oneliner"
                    },
                    {
                        "username": "Singh_uday99",
                        "content": "[@Anshmehta380](/Anshmehta380) But that is not the thing Leetcode trying to test;\\nIt wants us to study the working of indexOf () method"
                    },
                    {
                        "username": "Anshmehta380",
                        "content": "[@howardcho](/howardcho) Same for me in java"
                    },
                    {
                        "username": "Anshmehta380",
                        "content": "Bro just use indexOf() method i solved it in a one line code lol"
                    },
                    {
                        "username": "charonme",
                        "content": "tha naive O(n^2) solution is now being accepted, but if the testcases contained enough tests with long enough strings it would give a TLE"
                    },
                    {
                        "username": "aalmos",
                        "content": "[@Mister_CK](/Mister_CK) good luck with doing that on an interview bro. "
                    },
                    {
                        "username": "howardcho",
                        "content": "I\\'m not sure if there\\'s a better way, but this was a one-line solution for me in python."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "?! This is one of the easiest problems on the site, a.indexOf(b) satisfies all requirements (O(mn) time complexity I believe), at least in JS. took me 37 seconds, beats 87%"
                    },
                    {
                        "username": "gurpreetsingh8",
                        "content": "[@jdipirro](/jdipirro) exactly, this is just solved in O(N). I am wondering why it is medium"
                    },
                    {
                        "username": "calm27",
                        "content": "Python3 `O(mn)` is acceptable. "
                    },
                    {
                        "username": "pieceofpie",
                        "content": "It is now a ```Medium``` problem."
                    },
                    {
                        "username": "jdipirro",
                        "content": "Is this answer not valid for some reason?  They remarked it medium, but it can be solved with the super easy method below\\n\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n\\n        for x in range(len(haystack)):\\n            if haystack[lx : x + len(needle)] == needle:\\n                return x\\n        else:\\n            return -1"
                    },
                    {
                        "username": "narayan48",
                        "content": "class Solution {\\n    public int strStr(String haystack, String needle) {\\n          int indexOfSubStr = haystack.indexOf(needle);\\n          return indexOfSubStr;\\n\\n    }\\n    //return -1;\\n}"
                    },
                    {
                        "username": "sayedHANEEF",
                        "content": "dude it is a one line solution in java and it takes 0ms to run"
                    },
                    {
                        "username": "SugerSu",
                        "content": "Maybe sometimes we do not need to think too much!\\n\\npublic int strStr(String haystack, String needle) {\\n\\n\\t\\t\\n\\t\\treturn haystack.indexOf(needle);\\n\\t}"
                    },
                    {
                        "username": "coveyjorjet",
                        "content": "similarly you can use find() function in c++\\n```\\nreturn haystack.find(needle);\\n```"
                    },
                    {
                        "username": "enkil2003",
                        "content": "and that is how you never get a job."
                    },
                    {
                        "username": "hippofaris",
                        "content": "giga chad"
                    },
                    {
                        "username": "qAxP4Mw",
                        "content": "[@Meerkats1999](/Meerkats1999) however if your coworker reimplemented indexOf on a project everyone would be pretty annoyed so I think interviewer should accept this answer. Otherwise they should be more clear about what they\\'re looking for."
                    },
                    {
                        "username": "yuangaonyc",
                        "content": "Maybe you should think more"
                    },
                    {
                        "username": "chazwinter",
                        "content": "Don\\'t provide solutions, no matter how easy you think they are.\\nThis answer uses built in Java functionality without imports, so it\\'s fair game. If they wanted you to design your own indexOf method, they would have said so. \\n\\nThere are other problems that specifically say to avoid certain methods, or ask a follow to challenge you to try it another way. This one does not have that, so I see it as an attempt to expose new people to indexOf."
                    },
                    {
                        "username": "dantruongdo3",
                        "content": "[@Meerkats1999](/Meerkats1999) i use the exact same way and feel kinda guilty."
                    },
                    {
                        "username": "Meerkats1999",
                        "content": "I don\\'t think the interviewer will like this answer."
                    },
                    {
                        "username": "emcc1990",
                        "content": "I also submitted this but having doubts of whether the whole point is not to use it and implement something raw. "
                    },
                    {
                        "username": "user0566A",
                        "content": "It\\'s interesting that java indexOf do not use KMP (because of memory I think) or Rabin-Karp (don\\'t know why)\\nhttps://github.com/AdoptOpenJDK/openjdk-jdk11/blob/master/src/java.base/share/classes/java/lang/StringLatin1.java#L233-L253"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@therishuraj](/therishuraj) My indexOf solution beats 91%... It\\'s definitely fast enough and thus I strongly feel this should be easy. Otherwise LeetCode should drastically limit the time-constraints in my opinion"
                    },
                    {
                        "username": "user0743xF",
                        "content": "[@mohan9814](/mohan9814) because here people are coming to learn algorithms i think :)"
                    },
                    {
                        "username": "therishuraj",
                        "content": "[@mohan9814](/mohan9814)  Because time complexity of the KMP algorithm is O(m+n) And time complexity of the indexOf method is O(nm). "
                    },
                    {
                        "username": "mohan9814",
                        "content": "yes same logic in c++ is working fine why do i need to get into kmp and all this"
                    },
                    {
                        "username": "mgoldenbe",
                        "content": "I don\\'t think they meant that I can call a library function. Also, I get \"Time Limit Exceeded\" on brute-force. So, this means I should use an advanced algorithm, like Rabin-Karp or KMP. Why then is this problem marked \"easy\"?"
                    },
                    {
                        "username": "chazwinter",
                        "content": "It\\'s easy because the point is to teach you to 1) stop overthinking things, and 2) learn one single function that solves the problem in one line."
                    },
                    {
                        "username": "C0de_bumstead",
                        "content": "Can be easily solved using sliding window duhh...."
                    },
                    {
                        "username": "mikael6767",
                        "content": "Why should it be marked ```Medium```. This is literally 1line of code or 28 symbols(I\\'m counting the ```return``` function). You don\\'t need any algorithm. You need one function (if you use python3). And that function starts of the letter \"f\""
                    },
                    {
                        "username": "2020uch0017",
                        "content": "it is medium now and yes it is a KMP  problem"
                    },
                    {
                        "username": "jarc",
                        "content": " Is it the standard string matching problem? Am I wrong?"
                    },
                    {
                        "username": "chickooo",
                        "content": "Yeah, this is the standard string matching problem.\\nYour function should perform same as **.find()** function in python OR **.indexOf()** function in javascript"
                    },
                    {
                        "username": "tlong1299",
                        "content": "**USE FIND**\\nAs a Python programmer, refusing to use core language features is akin to using a hammer instead of nail-gun because it makes you a \"better\" carpenter. Remember that this is Python not C. Python\\'s PEP 20 states, \"There should be one-- and preferably only one --obvious way to do it.\" I would call a string operation built into python designed to solve this particular problem the obvious way to do it.\\n\\n**DON\\'T USE FIND**\\nIf you go into an interview and solve this problem with the find() function, you better know how it works underneath, and you should be prepared to defend your use of it. After all nothing is \"free\" in your code, and even \"magic\" functions have a time and memory cost associated with them. Knowing what this cost is, and why it is the way it is will make you a better programmer. Implementing the function yourself, at least once, can really help you develop a better appreciation for the language."
                    },
                    {
                        "username": "chazwinter",
                        "content": "Finally, a Python programmer that isn\\'t an idiot. It\\'s wild how people overthink this problem."
                    },
                    {
                        "username": "marten2",
                        "content": "Hey,\\n\\nI wouldn't say that coming up with the KMP algorithm from scratch is easy ~1 hour time. Did companies that asked this question expect applicants to know KMP by heart? Did they expect the applicant to show a naive implementation? Any opinion on this?\\n\\nBest,\\n\\nMarten"
                    },
                    {
                        "username": "syfo_dias",
                        "content": "[@chazwinter](/chazwinter) is it Python specific task? Or what is indexOf in C++? "
                    },
                    {
                        "username": "chazwinter",
                        "content": "No, they expected you to know indexOf. Don\\'t overthink it."
                    },
                    {
                        "username": "zijianz",
                        "content": "Input: \\t\"\", \"\"\\nOutput: \\t-1\\nExpected: \\t0\\n\\nBasically there is nothing in the string, how do you get the index.\\n\\nIf this test case is valid, then needle =\"\", haystack=\"anything\" could return any value. since empty is everywhere."
                    },
                    {
                        "username": "chazwinter",
                        "content": "Read the constraints. If you had to deal with an empty string, you would simply write an edge case for it."
                    },
                    {
                        "username": "mansourcodes",
                        "content": "1 <= haystack.length, needle.length <= 104\\n"
                    },
                    {
                        "username": "cxaviousb",
                        "content": "> In a string, the last element is null character. In the first case, where it is \"\",\"\" both of them has same character that is null character, while in \"\",\"anything\" the first string has null character at 0 index while the next one has 'a' at 0 index.\n\n[@AvniGoyal22](/AvniGoyal22) That's programming language specific logic.  Let's try applying logic from JavaScript to this problem~\n\n```javascript\n> 'anything'.indexOf('')\n< 0\n> ''.charAt(0)\n< \"\"\n> ''.charAt(9001)\n< \"\"\n> 'anything'.lastIndexOf('')\n< 8\n< \"anything\"\n> 'anything'.substr(0,9)\n< \"anything\"\n> 'anything'.substr(9001,9)\n< \"\"\n```"
                    },
                    {
                        "username": "shaan__0w0",
                        "content": "i think you have to make the case of if the string is empty"
                    },
                    {
                        "username": "AvniGoyal22",
                        "content": "In a string, the last element is null character. In the first case, where it is \"\",\"\" both of them has same character that is null character, while in \"\",\"anything\" the first string has null character at 0 index while the next one has \\'a\\' at 0 index. "
                    },
                    {
                        "username": "SarK97",
                        "content": "Why this test case is returning -1? Shouldn\\'t it be 4 since it is a substring?\\n\"mississippi\"\\n\"issip\""
                    },
                    {
                        "username": "impatientcat07",
                        "content": "Here comes the Overlapping case while comparing \"issis\" -> \"issip\" it rejects and reinitializes and starts from \"sippi\" & \\n comparing \"issip\", which in turns return -1; "
                    },
                    {
                        "username": "flyingfist",
                        "content": "its because it is taking issis (index 1 to 5) as index 5 is not matching it goes further and doesnt get issip "
                    },
                    {
                        "username": "MaheshPatil19",
                        "content": "here needle =\"issipi\""
                    },
                    {
                        "username": "chickooo",
                        "content": "If you add this test case ( I just did ), the output is 4 as expected.\\nDon\\'t know why you are getting -1. \\nMaybe there were unwanted spaces in your input. Can you try that again?"
                    },
                    {
                        "username": "trpaslik",
                        "content": "Most of python submissions are based on cheating (s.index() or s.find()).\\nIt is a pitty that when implementing it in pure python (the naive `O(n*m)` way) it results in timeout.\\nIt should either be accepted for `O(n*m)` or if some better approach is expected like with a rolling hash then it should be marked as medium IMHO."
                    },
                    {
                        "username": "ryo-kozin",
                        "content": "I believe  an interviewer would be fine with ussing indexOf(). In real-world programming situations, it is often advisable to take full advantage of available built-in functions and libraries. "
                    },
                    {
                        "username": "labule",
                        "content": "[@Deecodes25](/Deecodes25)  Time Complexity is O(n*m). `haystack[i:j] == needle` touches `m` chars and you do this approximately `n` times."
                    },
                    {
                        "username": "youttsu",
                        "content": "true dude. it works on JS with O(m*n) time complexity though "
                    },
                    {
                        "username": "Deecodes25",
                        "content": "I solved with this approach, can anyone explain what is the Time Complexity for this - \\n```\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        i=0\\n        j=len(needle)\\n        while j<=len(haystack):\\n            if haystack[i:j] == needle:\\n                return i\\n            i+=1\\n            j+=1\\n        return -1\\n```"
                    },
                    {
                        "username": "veerashah1",
                        "content": "[@chickooo](/chickooo) Wouldn\\'t an interviewer be fine with .indexOf(), because there\\'s no reason to re-invent the wheel when there are built in functions? If they specifically ask to avoid it then I guess, but in this case they didn\\'t."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Why is using indexOf cheating? Nowhere is it stated that you shouldn\\'t use that. If they don\\'t want you to use that they should say so, or limit the time constraints to only allow O(N+M)"
                    },
                    {
                        "username": "shaan__0w0",
                        "content": "but it gets submitted by using .indexOf() in java \\n"
                    },
                    {
                        "username": "chickooo",
                        "content": "Agreed with your opinion.\\nIf you were to use just built in function like .find() or .indexOf(), then the problem wouldn\\'t be labeled **Medium**. And if you were in an interview, the interviewer would not be pleased."
                    },
                    {
                        "username": "chehsunliu",
                        "content": "I have solved this problem. However, I think it may be controversial to return index 0 when the inputs are \"A\" and \"\". In my opinion, one of the inputs is \"A\\\\0\" and the other is \"\\\\0\". Perhaps it should return index 1."
                    }
                ]
            },
            {
                "id": 1575815,
                "content": [
                    {
                        "username": "Siddharth2k007",
                        "content": "Who marked this as `Easy`? It\\'s not easy at all. Though you can easily produce O(mn) solution, it is not accepted for python. You need KMP algorithm to produce O(m + n) solution!"
                    },
                    {
                        "username": "countdankula",
                        "content": "[@chazwinter](/chazwinter) Lol. The interviewer will just kick you out if you use indexof() to solve this problem."
                    },
                    {
                        "username": "chazwinter",
                        "content": "It\\'s marked easy because the point is to teach you how to use indexOf.\\nIt\\'s only difficult when you fail to learn it lol"
                    },
                    {
                        "username": "Tulsyan_25",
                        "content": "Use sliding window, its that easy\\n"
                    },
                    {
                        "username": "dezann1990",
                        "content": "dude, it is oneliner"
                    },
                    {
                        "username": "Singh_uday99",
                        "content": "[@Anshmehta380](/Anshmehta380) But that is not the thing Leetcode trying to test;\\nIt wants us to study the working of indexOf () method"
                    },
                    {
                        "username": "Anshmehta380",
                        "content": "[@howardcho](/howardcho) Same for me in java"
                    },
                    {
                        "username": "Anshmehta380",
                        "content": "Bro just use indexOf() method i solved it in a one line code lol"
                    },
                    {
                        "username": "charonme",
                        "content": "tha naive O(n^2) solution is now being accepted, but if the testcases contained enough tests with long enough strings it would give a TLE"
                    },
                    {
                        "username": "aalmos",
                        "content": "[@Mister_CK](/Mister_CK) good luck with doing that on an interview bro. "
                    },
                    {
                        "username": "howardcho",
                        "content": "I\\'m not sure if there\\'s a better way, but this was a one-line solution for me in python."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "?! This is one of the easiest problems on the site, a.indexOf(b) satisfies all requirements (O(mn) time complexity I believe), at least in JS. took me 37 seconds, beats 87%"
                    },
                    {
                        "username": "gurpreetsingh8",
                        "content": "[@jdipirro](/jdipirro) exactly, this is just solved in O(N). I am wondering why it is medium"
                    },
                    {
                        "username": "calm27",
                        "content": "Python3 `O(mn)` is acceptable. "
                    },
                    {
                        "username": "pieceofpie",
                        "content": "It is now a ```Medium``` problem."
                    },
                    {
                        "username": "jdipirro",
                        "content": "Is this answer not valid for some reason?  They remarked it medium, but it can be solved with the super easy method below\\n\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n\\n        for x in range(len(haystack)):\\n            if haystack[lx : x + len(needle)] == needle:\\n                return x\\n        else:\\n            return -1"
                    },
                    {
                        "username": "narayan48",
                        "content": "class Solution {\\n    public int strStr(String haystack, String needle) {\\n          int indexOfSubStr = haystack.indexOf(needle);\\n          return indexOfSubStr;\\n\\n    }\\n    //return -1;\\n}"
                    },
                    {
                        "username": "sayedHANEEF",
                        "content": "dude it is a one line solution in java and it takes 0ms to run"
                    },
                    {
                        "username": "SugerSu",
                        "content": "Maybe sometimes we do not need to think too much!\\n\\npublic int strStr(String haystack, String needle) {\\n\\n\\t\\t\\n\\t\\treturn haystack.indexOf(needle);\\n\\t}"
                    },
                    {
                        "username": "coveyjorjet",
                        "content": "similarly you can use find() function in c++\\n```\\nreturn haystack.find(needle);\\n```"
                    },
                    {
                        "username": "enkil2003",
                        "content": "and that is how you never get a job."
                    },
                    {
                        "username": "hippofaris",
                        "content": "giga chad"
                    },
                    {
                        "username": "qAxP4Mw",
                        "content": "[@Meerkats1999](/Meerkats1999) however if your coworker reimplemented indexOf on a project everyone would be pretty annoyed so I think interviewer should accept this answer. Otherwise they should be more clear about what they\\'re looking for."
                    },
                    {
                        "username": "yuangaonyc",
                        "content": "Maybe you should think more"
                    },
                    {
                        "username": "chazwinter",
                        "content": "Don\\'t provide solutions, no matter how easy you think they are.\\nThis answer uses built in Java functionality without imports, so it\\'s fair game. If they wanted you to design your own indexOf method, they would have said so. \\n\\nThere are other problems that specifically say to avoid certain methods, or ask a follow to challenge you to try it another way. This one does not have that, so I see it as an attempt to expose new people to indexOf."
                    },
                    {
                        "username": "dantruongdo3",
                        "content": "[@Meerkats1999](/Meerkats1999) i use the exact same way and feel kinda guilty."
                    },
                    {
                        "username": "Meerkats1999",
                        "content": "I don\\'t think the interviewer will like this answer."
                    },
                    {
                        "username": "emcc1990",
                        "content": "I also submitted this but having doubts of whether the whole point is not to use it and implement something raw. "
                    },
                    {
                        "username": "user0566A",
                        "content": "It\\'s interesting that java indexOf do not use KMP (because of memory I think) or Rabin-Karp (don\\'t know why)\\nhttps://github.com/AdoptOpenJDK/openjdk-jdk11/blob/master/src/java.base/share/classes/java/lang/StringLatin1.java#L233-L253"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@therishuraj](/therishuraj) My indexOf solution beats 91%... It\\'s definitely fast enough and thus I strongly feel this should be easy. Otherwise LeetCode should drastically limit the time-constraints in my opinion"
                    },
                    {
                        "username": "user0743xF",
                        "content": "[@mohan9814](/mohan9814) because here people are coming to learn algorithms i think :)"
                    },
                    {
                        "username": "therishuraj",
                        "content": "[@mohan9814](/mohan9814)  Because time complexity of the KMP algorithm is O(m+n) And time complexity of the indexOf method is O(nm). "
                    },
                    {
                        "username": "mohan9814",
                        "content": "yes same logic in c++ is working fine why do i need to get into kmp and all this"
                    },
                    {
                        "username": "mgoldenbe",
                        "content": "I don\\'t think they meant that I can call a library function. Also, I get \"Time Limit Exceeded\" on brute-force. So, this means I should use an advanced algorithm, like Rabin-Karp or KMP. Why then is this problem marked \"easy\"?"
                    },
                    {
                        "username": "chazwinter",
                        "content": "It\\'s easy because the point is to teach you to 1) stop overthinking things, and 2) learn one single function that solves the problem in one line."
                    },
                    {
                        "username": "C0de_bumstead",
                        "content": "Can be easily solved using sliding window duhh...."
                    },
                    {
                        "username": "mikael6767",
                        "content": "Why should it be marked ```Medium```. This is literally 1line of code or 28 symbols(I\\'m counting the ```return``` function). You don\\'t need any algorithm. You need one function (if you use python3). And that function starts of the letter \"f\""
                    },
                    {
                        "username": "2020uch0017",
                        "content": "it is medium now and yes it is a KMP  problem"
                    },
                    {
                        "username": "jarc",
                        "content": " Is it the standard string matching problem? Am I wrong?"
                    },
                    {
                        "username": "chickooo",
                        "content": "Yeah, this is the standard string matching problem.\\nYour function should perform same as **.find()** function in python OR **.indexOf()** function in javascript"
                    },
                    {
                        "username": "tlong1299",
                        "content": "**USE FIND**\\nAs a Python programmer, refusing to use core language features is akin to using a hammer instead of nail-gun because it makes you a \"better\" carpenter. Remember that this is Python not C. Python\\'s PEP 20 states, \"There should be one-- and preferably only one --obvious way to do it.\" I would call a string operation built into python designed to solve this particular problem the obvious way to do it.\\n\\n**DON\\'T USE FIND**\\nIf you go into an interview and solve this problem with the find() function, you better know how it works underneath, and you should be prepared to defend your use of it. After all nothing is \"free\" in your code, and even \"magic\" functions have a time and memory cost associated with them. Knowing what this cost is, and why it is the way it is will make you a better programmer. Implementing the function yourself, at least once, can really help you develop a better appreciation for the language."
                    },
                    {
                        "username": "chazwinter",
                        "content": "Finally, a Python programmer that isn\\'t an idiot. It\\'s wild how people overthink this problem."
                    },
                    {
                        "username": "marten2",
                        "content": "Hey,\\n\\nI wouldn't say that coming up with the KMP algorithm from scratch is easy ~1 hour time. Did companies that asked this question expect applicants to know KMP by heart? Did they expect the applicant to show a naive implementation? Any opinion on this?\\n\\nBest,\\n\\nMarten"
                    },
                    {
                        "username": "syfo_dias",
                        "content": "[@chazwinter](/chazwinter) is it Python specific task? Or what is indexOf in C++? "
                    },
                    {
                        "username": "chazwinter",
                        "content": "No, they expected you to know indexOf. Don\\'t overthink it."
                    },
                    {
                        "username": "zijianz",
                        "content": "Input: \\t\"\", \"\"\\nOutput: \\t-1\\nExpected: \\t0\\n\\nBasically there is nothing in the string, how do you get the index.\\n\\nIf this test case is valid, then needle =\"\", haystack=\"anything\" could return any value. since empty is everywhere."
                    },
                    {
                        "username": "chazwinter",
                        "content": "Read the constraints. If you had to deal with an empty string, you would simply write an edge case for it."
                    },
                    {
                        "username": "mansourcodes",
                        "content": "1 <= haystack.length, needle.length <= 104\\n"
                    },
                    {
                        "username": "cxaviousb",
                        "content": "> In a string, the last element is null character. In the first case, where it is \"\",\"\" both of them has same character that is null character, while in \"\",\"anything\" the first string has null character at 0 index while the next one has 'a' at 0 index.\n\n[@AvniGoyal22](/AvniGoyal22) That's programming language specific logic.  Let's try applying logic from JavaScript to this problem~\n\n```javascript\n> 'anything'.indexOf('')\n< 0\n> ''.charAt(0)\n< \"\"\n> ''.charAt(9001)\n< \"\"\n> 'anything'.lastIndexOf('')\n< 8\n< \"anything\"\n> 'anything'.substr(0,9)\n< \"anything\"\n> 'anything'.substr(9001,9)\n< \"\"\n```"
                    },
                    {
                        "username": "shaan__0w0",
                        "content": "i think you have to make the case of if the string is empty"
                    },
                    {
                        "username": "AvniGoyal22",
                        "content": "In a string, the last element is null character. In the first case, where it is \"\",\"\" both of them has same character that is null character, while in \"\",\"anything\" the first string has null character at 0 index while the next one has \\'a\\' at 0 index. "
                    },
                    {
                        "username": "SarK97",
                        "content": "Why this test case is returning -1? Shouldn\\'t it be 4 since it is a substring?\\n\"mississippi\"\\n\"issip\""
                    },
                    {
                        "username": "impatientcat07",
                        "content": "Here comes the Overlapping case while comparing \"issis\" -> \"issip\" it rejects and reinitializes and starts from \"sippi\" & \\n comparing \"issip\", which in turns return -1; "
                    },
                    {
                        "username": "flyingfist",
                        "content": "its because it is taking issis (index 1 to 5) as index 5 is not matching it goes further and doesnt get issip "
                    },
                    {
                        "username": "MaheshPatil19",
                        "content": "here needle =\"issipi\""
                    },
                    {
                        "username": "chickooo",
                        "content": "If you add this test case ( I just did ), the output is 4 as expected.\\nDon\\'t know why you are getting -1. \\nMaybe there were unwanted spaces in your input. Can you try that again?"
                    },
                    {
                        "username": "trpaslik",
                        "content": "Most of python submissions are based on cheating (s.index() or s.find()).\\nIt is a pitty that when implementing it in pure python (the naive `O(n*m)` way) it results in timeout.\\nIt should either be accepted for `O(n*m)` or if some better approach is expected like with a rolling hash then it should be marked as medium IMHO."
                    },
                    {
                        "username": "ryo-kozin",
                        "content": "I believe  an interviewer would be fine with ussing indexOf(). In real-world programming situations, it is often advisable to take full advantage of available built-in functions and libraries. "
                    },
                    {
                        "username": "labule",
                        "content": "[@Deecodes25](/Deecodes25)  Time Complexity is O(n*m). `haystack[i:j] == needle` touches `m` chars and you do this approximately `n` times."
                    },
                    {
                        "username": "youttsu",
                        "content": "true dude. it works on JS with O(m*n) time complexity though "
                    },
                    {
                        "username": "Deecodes25",
                        "content": "I solved with this approach, can anyone explain what is the Time Complexity for this - \\n```\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        i=0\\n        j=len(needle)\\n        while j<=len(haystack):\\n            if haystack[i:j] == needle:\\n                return i\\n            i+=1\\n            j+=1\\n        return -1\\n```"
                    },
                    {
                        "username": "veerashah1",
                        "content": "[@chickooo](/chickooo) Wouldn\\'t an interviewer be fine with .indexOf(), because there\\'s no reason to re-invent the wheel when there are built in functions? If they specifically ask to avoid it then I guess, but in this case they didn\\'t."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Why is using indexOf cheating? Nowhere is it stated that you shouldn\\'t use that. If they don\\'t want you to use that they should say so, or limit the time constraints to only allow O(N+M)"
                    },
                    {
                        "username": "shaan__0w0",
                        "content": "but it gets submitted by using .indexOf() in java \\n"
                    },
                    {
                        "username": "chickooo",
                        "content": "Agreed with your opinion.\\nIf you were to use just built in function like .find() or .indexOf(), then the problem wouldn\\'t be labeled **Medium**. And if you were in an interview, the interviewer would not be pleased."
                    },
                    {
                        "username": "chehsunliu",
                        "content": "I have solved this problem. However, I think it may be controversial to return index 0 when the inputs are \"A\" and \"\". In my opinion, one of the inputs is \"A\\\\0\" and the other is \"\\\\0\". Perhaps it should return index 1."
                    }
                ]
            },
            {
                "id": 1566693,
                "content": [
                    {
                        "username": "Siddharth2k007",
                        "content": "Who marked this as `Easy`? It\\'s not easy at all. Though you can easily produce O(mn) solution, it is not accepted for python. You need KMP algorithm to produce O(m + n) solution!"
                    },
                    {
                        "username": "countdankula",
                        "content": "[@chazwinter](/chazwinter) Lol. The interviewer will just kick you out if you use indexof() to solve this problem."
                    },
                    {
                        "username": "chazwinter",
                        "content": "It\\'s marked easy because the point is to teach you how to use indexOf.\\nIt\\'s only difficult when you fail to learn it lol"
                    },
                    {
                        "username": "Tulsyan_25",
                        "content": "Use sliding window, its that easy\\n"
                    },
                    {
                        "username": "dezann1990",
                        "content": "dude, it is oneliner"
                    },
                    {
                        "username": "Singh_uday99",
                        "content": "[@Anshmehta380](/Anshmehta380) But that is not the thing Leetcode trying to test;\\nIt wants us to study the working of indexOf () method"
                    },
                    {
                        "username": "Anshmehta380",
                        "content": "[@howardcho](/howardcho) Same for me in java"
                    },
                    {
                        "username": "Anshmehta380",
                        "content": "Bro just use indexOf() method i solved it in a one line code lol"
                    },
                    {
                        "username": "charonme",
                        "content": "tha naive O(n^2) solution is now being accepted, but if the testcases contained enough tests with long enough strings it would give a TLE"
                    },
                    {
                        "username": "aalmos",
                        "content": "[@Mister_CK](/Mister_CK) good luck with doing that on an interview bro. "
                    },
                    {
                        "username": "howardcho",
                        "content": "I\\'m not sure if there\\'s a better way, but this was a one-line solution for me in python."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "?! This is one of the easiest problems on the site, a.indexOf(b) satisfies all requirements (O(mn) time complexity I believe), at least in JS. took me 37 seconds, beats 87%"
                    },
                    {
                        "username": "gurpreetsingh8",
                        "content": "[@jdipirro](/jdipirro) exactly, this is just solved in O(N). I am wondering why it is medium"
                    },
                    {
                        "username": "calm27",
                        "content": "Python3 `O(mn)` is acceptable. "
                    },
                    {
                        "username": "pieceofpie",
                        "content": "It is now a ```Medium``` problem."
                    },
                    {
                        "username": "jdipirro",
                        "content": "Is this answer not valid for some reason?  They remarked it medium, but it can be solved with the super easy method below\\n\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n\\n        for x in range(len(haystack)):\\n            if haystack[lx : x + len(needle)] == needle:\\n                return x\\n        else:\\n            return -1"
                    },
                    {
                        "username": "narayan48",
                        "content": "class Solution {\\n    public int strStr(String haystack, String needle) {\\n          int indexOfSubStr = haystack.indexOf(needle);\\n          return indexOfSubStr;\\n\\n    }\\n    //return -1;\\n}"
                    },
                    {
                        "username": "sayedHANEEF",
                        "content": "dude it is a one line solution in java and it takes 0ms to run"
                    },
                    {
                        "username": "SugerSu",
                        "content": "Maybe sometimes we do not need to think too much!\\n\\npublic int strStr(String haystack, String needle) {\\n\\n\\t\\t\\n\\t\\treturn haystack.indexOf(needle);\\n\\t}"
                    },
                    {
                        "username": "coveyjorjet",
                        "content": "similarly you can use find() function in c++\\n```\\nreturn haystack.find(needle);\\n```"
                    },
                    {
                        "username": "enkil2003",
                        "content": "and that is how you never get a job."
                    },
                    {
                        "username": "hippofaris",
                        "content": "giga chad"
                    },
                    {
                        "username": "qAxP4Mw",
                        "content": "[@Meerkats1999](/Meerkats1999) however if your coworker reimplemented indexOf on a project everyone would be pretty annoyed so I think interviewer should accept this answer. Otherwise they should be more clear about what they\\'re looking for."
                    },
                    {
                        "username": "yuangaonyc",
                        "content": "Maybe you should think more"
                    },
                    {
                        "username": "chazwinter",
                        "content": "Don\\'t provide solutions, no matter how easy you think they are.\\nThis answer uses built in Java functionality without imports, so it\\'s fair game. If they wanted you to design your own indexOf method, they would have said so. \\n\\nThere are other problems that specifically say to avoid certain methods, or ask a follow to challenge you to try it another way. This one does not have that, so I see it as an attempt to expose new people to indexOf."
                    },
                    {
                        "username": "dantruongdo3",
                        "content": "[@Meerkats1999](/Meerkats1999) i use the exact same way and feel kinda guilty."
                    },
                    {
                        "username": "Meerkats1999",
                        "content": "I don\\'t think the interviewer will like this answer."
                    },
                    {
                        "username": "emcc1990",
                        "content": "I also submitted this but having doubts of whether the whole point is not to use it and implement something raw. "
                    },
                    {
                        "username": "user0566A",
                        "content": "It\\'s interesting that java indexOf do not use KMP (because of memory I think) or Rabin-Karp (don\\'t know why)\\nhttps://github.com/AdoptOpenJDK/openjdk-jdk11/blob/master/src/java.base/share/classes/java/lang/StringLatin1.java#L233-L253"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@therishuraj](/therishuraj) My indexOf solution beats 91%... It\\'s definitely fast enough and thus I strongly feel this should be easy. Otherwise LeetCode should drastically limit the time-constraints in my opinion"
                    },
                    {
                        "username": "user0743xF",
                        "content": "[@mohan9814](/mohan9814) because here people are coming to learn algorithms i think :)"
                    },
                    {
                        "username": "therishuraj",
                        "content": "[@mohan9814](/mohan9814)  Because time complexity of the KMP algorithm is O(m+n) And time complexity of the indexOf method is O(nm). "
                    },
                    {
                        "username": "mohan9814",
                        "content": "yes same logic in c++ is working fine why do i need to get into kmp and all this"
                    },
                    {
                        "username": "mgoldenbe",
                        "content": "I don\\'t think they meant that I can call a library function. Also, I get \"Time Limit Exceeded\" on brute-force. So, this means I should use an advanced algorithm, like Rabin-Karp or KMP. Why then is this problem marked \"easy\"?"
                    },
                    {
                        "username": "chazwinter",
                        "content": "It\\'s easy because the point is to teach you to 1) stop overthinking things, and 2) learn one single function that solves the problem in one line."
                    },
                    {
                        "username": "C0de_bumstead",
                        "content": "Can be easily solved using sliding window duhh...."
                    },
                    {
                        "username": "mikael6767",
                        "content": "Why should it be marked ```Medium```. This is literally 1line of code or 28 symbols(I\\'m counting the ```return``` function). You don\\'t need any algorithm. You need one function (if you use python3). And that function starts of the letter \"f\""
                    },
                    {
                        "username": "2020uch0017",
                        "content": "it is medium now and yes it is a KMP  problem"
                    },
                    {
                        "username": "jarc",
                        "content": " Is it the standard string matching problem? Am I wrong?"
                    },
                    {
                        "username": "chickooo",
                        "content": "Yeah, this is the standard string matching problem.\\nYour function should perform same as **.find()** function in python OR **.indexOf()** function in javascript"
                    },
                    {
                        "username": "tlong1299",
                        "content": "**USE FIND**\\nAs a Python programmer, refusing to use core language features is akin to using a hammer instead of nail-gun because it makes you a \"better\" carpenter. Remember that this is Python not C. Python\\'s PEP 20 states, \"There should be one-- and preferably only one --obvious way to do it.\" I would call a string operation built into python designed to solve this particular problem the obvious way to do it.\\n\\n**DON\\'T USE FIND**\\nIf you go into an interview and solve this problem with the find() function, you better know how it works underneath, and you should be prepared to defend your use of it. After all nothing is \"free\" in your code, and even \"magic\" functions have a time and memory cost associated with them. Knowing what this cost is, and why it is the way it is will make you a better programmer. Implementing the function yourself, at least once, can really help you develop a better appreciation for the language."
                    },
                    {
                        "username": "chazwinter",
                        "content": "Finally, a Python programmer that isn\\'t an idiot. It\\'s wild how people overthink this problem."
                    },
                    {
                        "username": "marten2",
                        "content": "Hey,\\n\\nI wouldn't say that coming up with the KMP algorithm from scratch is easy ~1 hour time. Did companies that asked this question expect applicants to know KMP by heart? Did they expect the applicant to show a naive implementation? Any opinion on this?\\n\\nBest,\\n\\nMarten"
                    },
                    {
                        "username": "syfo_dias",
                        "content": "[@chazwinter](/chazwinter) is it Python specific task? Or what is indexOf in C++? "
                    },
                    {
                        "username": "chazwinter",
                        "content": "No, they expected you to know indexOf. Don\\'t overthink it."
                    },
                    {
                        "username": "zijianz",
                        "content": "Input: \\t\"\", \"\"\\nOutput: \\t-1\\nExpected: \\t0\\n\\nBasically there is nothing in the string, how do you get the index.\\n\\nIf this test case is valid, then needle =\"\", haystack=\"anything\" could return any value. since empty is everywhere."
                    },
                    {
                        "username": "chazwinter",
                        "content": "Read the constraints. If you had to deal with an empty string, you would simply write an edge case for it."
                    },
                    {
                        "username": "mansourcodes",
                        "content": "1 <= haystack.length, needle.length <= 104\\n"
                    },
                    {
                        "username": "cxaviousb",
                        "content": "> In a string, the last element is null character. In the first case, where it is \"\",\"\" both of them has same character that is null character, while in \"\",\"anything\" the first string has null character at 0 index while the next one has 'a' at 0 index.\n\n[@AvniGoyal22](/AvniGoyal22) That's programming language specific logic.  Let's try applying logic from JavaScript to this problem~\n\n```javascript\n> 'anything'.indexOf('')\n< 0\n> ''.charAt(0)\n< \"\"\n> ''.charAt(9001)\n< \"\"\n> 'anything'.lastIndexOf('')\n< 8\n< \"anything\"\n> 'anything'.substr(0,9)\n< \"anything\"\n> 'anything'.substr(9001,9)\n< \"\"\n```"
                    },
                    {
                        "username": "shaan__0w0",
                        "content": "i think you have to make the case of if the string is empty"
                    },
                    {
                        "username": "AvniGoyal22",
                        "content": "In a string, the last element is null character. In the first case, where it is \"\",\"\" both of them has same character that is null character, while in \"\",\"anything\" the first string has null character at 0 index while the next one has \\'a\\' at 0 index. "
                    },
                    {
                        "username": "SarK97",
                        "content": "Why this test case is returning -1? Shouldn\\'t it be 4 since it is a substring?\\n\"mississippi\"\\n\"issip\""
                    },
                    {
                        "username": "impatientcat07",
                        "content": "Here comes the Overlapping case while comparing \"issis\" -> \"issip\" it rejects and reinitializes and starts from \"sippi\" & \\n comparing \"issip\", which in turns return -1; "
                    },
                    {
                        "username": "flyingfist",
                        "content": "its because it is taking issis (index 1 to 5) as index 5 is not matching it goes further and doesnt get issip "
                    },
                    {
                        "username": "MaheshPatil19",
                        "content": "here needle =\"issipi\""
                    },
                    {
                        "username": "chickooo",
                        "content": "If you add this test case ( I just did ), the output is 4 as expected.\\nDon\\'t know why you are getting -1. \\nMaybe there were unwanted spaces in your input. Can you try that again?"
                    },
                    {
                        "username": "trpaslik",
                        "content": "Most of python submissions are based on cheating (s.index() or s.find()).\\nIt is a pitty that when implementing it in pure python (the naive `O(n*m)` way) it results in timeout.\\nIt should either be accepted for `O(n*m)` or if some better approach is expected like with a rolling hash then it should be marked as medium IMHO."
                    },
                    {
                        "username": "ryo-kozin",
                        "content": "I believe  an interviewer would be fine with ussing indexOf(). In real-world programming situations, it is often advisable to take full advantage of available built-in functions and libraries. "
                    },
                    {
                        "username": "labule",
                        "content": "[@Deecodes25](/Deecodes25)  Time Complexity is O(n*m). `haystack[i:j] == needle` touches `m` chars and you do this approximately `n` times."
                    },
                    {
                        "username": "youttsu",
                        "content": "true dude. it works on JS with O(m*n) time complexity though "
                    },
                    {
                        "username": "Deecodes25",
                        "content": "I solved with this approach, can anyone explain what is the Time Complexity for this - \\n```\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        i=0\\n        j=len(needle)\\n        while j<=len(haystack):\\n            if haystack[i:j] == needle:\\n                return i\\n            i+=1\\n            j+=1\\n        return -1\\n```"
                    },
                    {
                        "username": "veerashah1",
                        "content": "[@chickooo](/chickooo) Wouldn\\'t an interviewer be fine with .indexOf(), because there\\'s no reason to re-invent the wheel when there are built in functions? If they specifically ask to avoid it then I guess, but in this case they didn\\'t."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Why is using indexOf cheating? Nowhere is it stated that you shouldn\\'t use that. If they don\\'t want you to use that they should say so, or limit the time constraints to only allow O(N+M)"
                    },
                    {
                        "username": "shaan__0w0",
                        "content": "but it gets submitted by using .indexOf() in java \\n"
                    },
                    {
                        "username": "chickooo",
                        "content": "Agreed with your opinion.\\nIf you were to use just built in function like .find() or .indexOf(), then the problem wouldn\\'t be labeled **Medium**. And if you were in an interview, the interviewer would not be pleased."
                    },
                    {
                        "username": "chehsunliu",
                        "content": "I have solved this problem. However, I think it may be controversial to return index 0 when the inputs are \"A\" and \"\". In my opinion, one of the inputs is \"A\\\\0\" and the other is \"\\\\0\". Perhaps it should return index 1."
                    }
                ]
            },
            {
                "id": 1566235,
                "content": [
                    {
                        "username": "Siddharth2k007",
                        "content": "Who marked this as `Easy`? It\\'s not easy at all. Though you can easily produce O(mn) solution, it is not accepted for python. You need KMP algorithm to produce O(m + n) solution!"
                    },
                    {
                        "username": "countdankula",
                        "content": "[@chazwinter](/chazwinter) Lol. The interviewer will just kick you out if you use indexof() to solve this problem."
                    },
                    {
                        "username": "chazwinter",
                        "content": "It\\'s marked easy because the point is to teach you how to use indexOf.\\nIt\\'s only difficult when you fail to learn it lol"
                    },
                    {
                        "username": "Tulsyan_25",
                        "content": "Use sliding window, its that easy\\n"
                    },
                    {
                        "username": "dezann1990",
                        "content": "dude, it is oneliner"
                    },
                    {
                        "username": "Singh_uday99",
                        "content": "[@Anshmehta380](/Anshmehta380) But that is not the thing Leetcode trying to test;\\nIt wants us to study the working of indexOf () method"
                    },
                    {
                        "username": "Anshmehta380",
                        "content": "[@howardcho](/howardcho) Same for me in java"
                    },
                    {
                        "username": "Anshmehta380",
                        "content": "Bro just use indexOf() method i solved it in a one line code lol"
                    },
                    {
                        "username": "charonme",
                        "content": "tha naive O(n^2) solution is now being accepted, but if the testcases contained enough tests with long enough strings it would give a TLE"
                    },
                    {
                        "username": "aalmos",
                        "content": "[@Mister_CK](/Mister_CK) good luck with doing that on an interview bro. "
                    },
                    {
                        "username": "howardcho",
                        "content": "I\\'m not sure if there\\'s a better way, but this was a one-line solution for me in python."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "?! This is one of the easiest problems on the site, a.indexOf(b) satisfies all requirements (O(mn) time complexity I believe), at least in JS. took me 37 seconds, beats 87%"
                    },
                    {
                        "username": "gurpreetsingh8",
                        "content": "[@jdipirro](/jdipirro) exactly, this is just solved in O(N). I am wondering why it is medium"
                    },
                    {
                        "username": "calm27",
                        "content": "Python3 `O(mn)` is acceptable. "
                    },
                    {
                        "username": "pieceofpie",
                        "content": "It is now a ```Medium``` problem."
                    },
                    {
                        "username": "jdipirro",
                        "content": "Is this answer not valid for some reason?  They remarked it medium, but it can be solved with the super easy method below\\n\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n\\n        for x in range(len(haystack)):\\n            if haystack[lx : x + len(needle)] == needle:\\n                return x\\n        else:\\n            return -1"
                    },
                    {
                        "username": "narayan48",
                        "content": "class Solution {\\n    public int strStr(String haystack, String needle) {\\n          int indexOfSubStr = haystack.indexOf(needle);\\n          return indexOfSubStr;\\n\\n    }\\n    //return -1;\\n}"
                    },
                    {
                        "username": "sayedHANEEF",
                        "content": "dude it is a one line solution in java and it takes 0ms to run"
                    },
                    {
                        "username": "SugerSu",
                        "content": "Maybe sometimes we do not need to think too much!\\n\\npublic int strStr(String haystack, String needle) {\\n\\n\\t\\t\\n\\t\\treturn haystack.indexOf(needle);\\n\\t}"
                    },
                    {
                        "username": "coveyjorjet",
                        "content": "similarly you can use find() function in c++\\n```\\nreturn haystack.find(needle);\\n```"
                    },
                    {
                        "username": "enkil2003",
                        "content": "and that is how you never get a job."
                    },
                    {
                        "username": "hippofaris",
                        "content": "giga chad"
                    },
                    {
                        "username": "qAxP4Mw",
                        "content": "[@Meerkats1999](/Meerkats1999) however if your coworker reimplemented indexOf on a project everyone would be pretty annoyed so I think interviewer should accept this answer. Otherwise they should be more clear about what they\\'re looking for."
                    },
                    {
                        "username": "yuangaonyc",
                        "content": "Maybe you should think more"
                    },
                    {
                        "username": "chazwinter",
                        "content": "Don\\'t provide solutions, no matter how easy you think they are.\\nThis answer uses built in Java functionality without imports, so it\\'s fair game. If they wanted you to design your own indexOf method, they would have said so. \\n\\nThere are other problems that specifically say to avoid certain methods, or ask a follow to challenge you to try it another way. This one does not have that, so I see it as an attempt to expose new people to indexOf."
                    },
                    {
                        "username": "dantruongdo3",
                        "content": "[@Meerkats1999](/Meerkats1999) i use the exact same way and feel kinda guilty."
                    },
                    {
                        "username": "Meerkats1999",
                        "content": "I don\\'t think the interviewer will like this answer."
                    },
                    {
                        "username": "emcc1990",
                        "content": "I also submitted this but having doubts of whether the whole point is not to use it and implement something raw. "
                    },
                    {
                        "username": "user0566A",
                        "content": "It\\'s interesting that java indexOf do not use KMP (because of memory I think) or Rabin-Karp (don\\'t know why)\\nhttps://github.com/AdoptOpenJDK/openjdk-jdk11/blob/master/src/java.base/share/classes/java/lang/StringLatin1.java#L233-L253"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@therishuraj](/therishuraj) My indexOf solution beats 91%... It\\'s definitely fast enough and thus I strongly feel this should be easy. Otherwise LeetCode should drastically limit the time-constraints in my opinion"
                    },
                    {
                        "username": "user0743xF",
                        "content": "[@mohan9814](/mohan9814) because here people are coming to learn algorithms i think :)"
                    },
                    {
                        "username": "therishuraj",
                        "content": "[@mohan9814](/mohan9814)  Because time complexity of the KMP algorithm is O(m+n) And time complexity of the indexOf method is O(nm). "
                    },
                    {
                        "username": "mohan9814",
                        "content": "yes same logic in c++ is working fine why do i need to get into kmp and all this"
                    },
                    {
                        "username": "mgoldenbe",
                        "content": "I don\\'t think they meant that I can call a library function. Also, I get \"Time Limit Exceeded\" on brute-force. So, this means I should use an advanced algorithm, like Rabin-Karp or KMP. Why then is this problem marked \"easy\"?"
                    },
                    {
                        "username": "chazwinter",
                        "content": "It\\'s easy because the point is to teach you to 1) stop overthinking things, and 2) learn one single function that solves the problem in one line."
                    },
                    {
                        "username": "C0de_bumstead",
                        "content": "Can be easily solved using sliding window duhh...."
                    },
                    {
                        "username": "mikael6767",
                        "content": "Why should it be marked ```Medium```. This is literally 1line of code or 28 symbols(I\\'m counting the ```return``` function). You don\\'t need any algorithm. You need one function (if you use python3). And that function starts of the letter \"f\""
                    },
                    {
                        "username": "2020uch0017",
                        "content": "it is medium now and yes it is a KMP  problem"
                    },
                    {
                        "username": "jarc",
                        "content": " Is it the standard string matching problem? Am I wrong?"
                    },
                    {
                        "username": "chickooo",
                        "content": "Yeah, this is the standard string matching problem.\\nYour function should perform same as **.find()** function in python OR **.indexOf()** function in javascript"
                    },
                    {
                        "username": "tlong1299",
                        "content": "**USE FIND**\\nAs a Python programmer, refusing to use core language features is akin to using a hammer instead of nail-gun because it makes you a \"better\" carpenter. Remember that this is Python not C. Python\\'s PEP 20 states, \"There should be one-- and preferably only one --obvious way to do it.\" I would call a string operation built into python designed to solve this particular problem the obvious way to do it.\\n\\n**DON\\'T USE FIND**\\nIf you go into an interview and solve this problem with the find() function, you better know how it works underneath, and you should be prepared to defend your use of it. After all nothing is \"free\" in your code, and even \"magic\" functions have a time and memory cost associated with them. Knowing what this cost is, and why it is the way it is will make you a better programmer. Implementing the function yourself, at least once, can really help you develop a better appreciation for the language."
                    },
                    {
                        "username": "chazwinter",
                        "content": "Finally, a Python programmer that isn\\'t an idiot. It\\'s wild how people overthink this problem."
                    },
                    {
                        "username": "marten2",
                        "content": "Hey,\\n\\nI wouldn't say that coming up with the KMP algorithm from scratch is easy ~1 hour time. Did companies that asked this question expect applicants to know KMP by heart? Did they expect the applicant to show a naive implementation? Any opinion on this?\\n\\nBest,\\n\\nMarten"
                    },
                    {
                        "username": "syfo_dias",
                        "content": "[@chazwinter](/chazwinter) is it Python specific task? Or what is indexOf in C++? "
                    },
                    {
                        "username": "chazwinter",
                        "content": "No, they expected you to know indexOf. Don\\'t overthink it."
                    },
                    {
                        "username": "zijianz",
                        "content": "Input: \\t\"\", \"\"\\nOutput: \\t-1\\nExpected: \\t0\\n\\nBasically there is nothing in the string, how do you get the index.\\n\\nIf this test case is valid, then needle =\"\", haystack=\"anything\" could return any value. since empty is everywhere."
                    },
                    {
                        "username": "chazwinter",
                        "content": "Read the constraints. If you had to deal with an empty string, you would simply write an edge case for it."
                    },
                    {
                        "username": "mansourcodes",
                        "content": "1 <= haystack.length, needle.length <= 104\\n"
                    },
                    {
                        "username": "cxaviousb",
                        "content": "> In a string, the last element is null character. In the first case, where it is \"\",\"\" both of them has same character that is null character, while in \"\",\"anything\" the first string has null character at 0 index while the next one has 'a' at 0 index.\n\n[@AvniGoyal22](/AvniGoyal22) That's programming language specific logic.  Let's try applying logic from JavaScript to this problem~\n\n```javascript\n> 'anything'.indexOf('')\n< 0\n> ''.charAt(0)\n< \"\"\n> ''.charAt(9001)\n< \"\"\n> 'anything'.lastIndexOf('')\n< 8\n< \"anything\"\n> 'anything'.substr(0,9)\n< \"anything\"\n> 'anything'.substr(9001,9)\n< \"\"\n```"
                    },
                    {
                        "username": "shaan__0w0",
                        "content": "i think you have to make the case of if the string is empty"
                    },
                    {
                        "username": "AvniGoyal22",
                        "content": "In a string, the last element is null character. In the first case, where it is \"\",\"\" both of them has same character that is null character, while in \"\",\"anything\" the first string has null character at 0 index while the next one has \\'a\\' at 0 index. "
                    },
                    {
                        "username": "SarK97",
                        "content": "Why this test case is returning -1? Shouldn\\'t it be 4 since it is a substring?\\n\"mississippi\"\\n\"issip\""
                    },
                    {
                        "username": "impatientcat07",
                        "content": "Here comes the Overlapping case while comparing \"issis\" -> \"issip\" it rejects and reinitializes and starts from \"sippi\" & \\n comparing \"issip\", which in turns return -1; "
                    },
                    {
                        "username": "flyingfist",
                        "content": "its because it is taking issis (index 1 to 5) as index 5 is not matching it goes further and doesnt get issip "
                    },
                    {
                        "username": "MaheshPatil19",
                        "content": "here needle =\"issipi\""
                    },
                    {
                        "username": "chickooo",
                        "content": "If you add this test case ( I just did ), the output is 4 as expected.\\nDon\\'t know why you are getting -1. \\nMaybe there were unwanted spaces in your input. Can you try that again?"
                    },
                    {
                        "username": "trpaslik",
                        "content": "Most of python submissions are based on cheating (s.index() or s.find()).\\nIt is a pitty that when implementing it in pure python (the naive `O(n*m)` way) it results in timeout.\\nIt should either be accepted for `O(n*m)` or if some better approach is expected like with a rolling hash then it should be marked as medium IMHO."
                    },
                    {
                        "username": "ryo-kozin",
                        "content": "I believe  an interviewer would be fine with ussing indexOf(). In real-world programming situations, it is often advisable to take full advantage of available built-in functions and libraries. "
                    },
                    {
                        "username": "labule",
                        "content": "[@Deecodes25](/Deecodes25)  Time Complexity is O(n*m). `haystack[i:j] == needle` touches `m` chars and you do this approximately `n` times."
                    },
                    {
                        "username": "youttsu",
                        "content": "true dude. it works on JS with O(m*n) time complexity though "
                    },
                    {
                        "username": "Deecodes25",
                        "content": "I solved with this approach, can anyone explain what is the Time Complexity for this - \\n```\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        i=0\\n        j=len(needle)\\n        while j<=len(haystack):\\n            if haystack[i:j] == needle:\\n                return i\\n            i+=1\\n            j+=1\\n        return -1\\n```"
                    },
                    {
                        "username": "veerashah1",
                        "content": "[@chickooo](/chickooo) Wouldn\\'t an interviewer be fine with .indexOf(), because there\\'s no reason to re-invent the wheel when there are built in functions? If they specifically ask to avoid it then I guess, but in this case they didn\\'t."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Why is using indexOf cheating? Nowhere is it stated that you shouldn\\'t use that. If they don\\'t want you to use that they should say so, or limit the time constraints to only allow O(N+M)"
                    },
                    {
                        "username": "shaan__0w0",
                        "content": "but it gets submitted by using .indexOf() in java \\n"
                    },
                    {
                        "username": "chickooo",
                        "content": "Agreed with your opinion.\\nIf you were to use just built in function like .find() or .indexOf(), then the problem wouldn\\'t be labeled **Medium**. And if you were in an interview, the interviewer would not be pleased."
                    },
                    {
                        "username": "chehsunliu",
                        "content": "I have solved this problem. However, I think it may be controversial to return index 0 when the inputs are \"A\" and \"\". In my opinion, one of the inputs is \"A\\\\0\" and the other is \"\\\\0\". Perhaps it should return index 1."
                    }
                ]
            },
            {
                "id": 1565202,
                "content": [
                    {
                        "username": "Siddharth2k007",
                        "content": "Who marked this as `Easy`? It\\'s not easy at all. Though you can easily produce O(mn) solution, it is not accepted for python. You need KMP algorithm to produce O(m + n) solution!"
                    },
                    {
                        "username": "countdankula",
                        "content": "[@chazwinter](/chazwinter) Lol. The interviewer will just kick you out if you use indexof() to solve this problem."
                    },
                    {
                        "username": "chazwinter",
                        "content": "It\\'s marked easy because the point is to teach you how to use indexOf.\\nIt\\'s only difficult when you fail to learn it lol"
                    },
                    {
                        "username": "Tulsyan_25",
                        "content": "Use sliding window, its that easy\\n"
                    },
                    {
                        "username": "dezann1990",
                        "content": "dude, it is oneliner"
                    },
                    {
                        "username": "Singh_uday99",
                        "content": "[@Anshmehta380](/Anshmehta380) But that is not the thing Leetcode trying to test;\\nIt wants us to study the working of indexOf () method"
                    },
                    {
                        "username": "Anshmehta380",
                        "content": "[@howardcho](/howardcho) Same for me in java"
                    },
                    {
                        "username": "Anshmehta380",
                        "content": "Bro just use indexOf() method i solved it in a one line code lol"
                    },
                    {
                        "username": "charonme",
                        "content": "tha naive O(n^2) solution is now being accepted, but if the testcases contained enough tests with long enough strings it would give a TLE"
                    },
                    {
                        "username": "aalmos",
                        "content": "[@Mister_CK](/Mister_CK) good luck with doing that on an interview bro. "
                    },
                    {
                        "username": "howardcho",
                        "content": "I\\'m not sure if there\\'s a better way, but this was a one-line solution for me in python."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "?! This is one of the easiest problems on the site, a.indexOf(b) satisfies all requirements (O(mn) time complexity I believe), at least in JS. took me 37 seconds, beats 87%"
                    },
                    {
                        "username": "gurpreetsingh8",
                        "content": "[@jdipirro](/jdipirro) exactly, this is just solved in O(N). I am wondering why it is medium"
                    },
                    {
                        "username": "calm27",
                        "content": "Python3 `O(mn)` is acceptable. "
                    },
                    {
                        "username": "pieceofpie",
                        "content": "It is now a ```Medium``` problem."
                    },
                    {
                        "username": "jdipirro",
                        "content": "Is this answer not valid for some reason?  They remarked it medium, but it can be solved with the super easy method below\\n\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n\\n        for x in range(len(haystack)):\\n            if haystack[lx : x + len(needle)] == needle:\\n                return x\\n        else:\\n            return -1"
                    },
                    {
                        "username": "narayan48",
                        "content": "class Solution {\\n    public int strStr(String haystack, String needle) {\\n          int indexOfSubStr = haystack.indexOf(needle);\\n          return indexOfSubStr;\\n\\n    }\\n    //return -1;\\n}"
                    },
                    {
                        "username": "sayedHANEEF",
                        "content": "dude it is a one line solution in java and it takes 0ms to run"
                    },
                    {
                        "username": "SugerSu",
                        "content": "Maybe sometimes we do not need to think too much!\\n\\npublic int strStr(String haystack, String needle) {\\n\\n\\t\\t\\n\\t\\treturn haystack.indexOf(needle);\\n\\t}"
                    },
                    {
                        "username": "coveyjorjet",
                        "content": "similarly you can use find() function in c++\\n```\\nreturn haystack.find(needle);\\n```"
                    },
                    {
                        "username": "enkil2003",
                        "content": "and that is how you never get a job."
                    },
                    {
                        "username": "hippofaris",
                        "content": "giga chad"
                    },
                    {
                        "username": "qAxP4Mw",
                        "content": "[@Meerkats1999](/Meerkats1999) however if your coworker reimplemented indexOf on a project everyone would be pretty annoyed so I think interviewer should accept this answer. Otherwise they should be more clear about what they\\'re looking for."
                    },
                    {
                        "username": "yuangaonyc",
                        "content": "Maybe you should think more"
                    },
                    {
                        "username": "chazwinter",
                        "content": "Don\\'t provide solutions, no matter how easy you think they are.\\nThis answer uses built in Java functionality without imports, so it\\'s fair game. If they wanted you to design your own indexOf method, they would have said so. \\n\\nThere are other problems that specifically say to avoid certain methods, or ask a follow to challenge you to try it another way. This one does not have that, so I see it as an attempt to expose new people to indexOf."
                    },
                    {
                        "username": "dantruongdo3",
                        "content": "[@Meerkats1999](/Meerkats1999) i use the exact same way and feel kinda guilty."
                    },
                    {
                        "username": "Meerkats1999",
                        "content": "I don\\'t think the interviewer will like this answer."
                    },
                    {
                        "username": "emcc1990",
                        "content": "I also submitted this but having doubts of whether the whole point is not to use it and implement something raw. "
                    },
                    {
                        "username": "user0566A",
                        "content": "It\\'s interesting that java indexOf do not use KMP (because of memory I think) or Rabin-Karp (don\\'t know why)\\nhttps://github.com/AdoptOpenJDK/openjdk-jdk11/blob/master/src/java.base/share/classes/java/lang/StringLatin1.java#L233-L253"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@therishuraj](/therishuraj) My indexOf solution beats 91%... It\\'s definitely fast enough and thus I strongly feel this should be easy. Otherwise LeetCode should drastically limit the time-constraints in my opinion"
                    },
                    {
                        "username": "user0743xF",
                        "content": "[@mohan9814](/mohan9814) because here people are coming to learn algorithms i think :)"
                    },
                    {
                        "username": "therishuraj",
                        "content": "[@mohan9814](/mohan9814)  Because time complexity of the KMP algorithm is O(m+n) And time complexity of the indexOf method is O(nm). "
                    },
                    {
                        "username": "mohan9814",
                        "content": "yes same logic in c++ is working fine why do i need to get into kmp and all this"
                    },
                    {
                        "username": "mgoldenbe",
                        "content": "I don\\'t think they meant that I can call a library function. Also, I get \"Time Limit Exceeded\" on brute-force. So, this means I should use an advanced algorithm, like Rabin-Karp or KMP. Why then is this problem marked \"easy\"?"
                    },
                    {
                        "username": "chazwinter",
                        "content": "It\\'s easy because the point is to teach you to 1) stop overthinking things, and 2) learn one single function that solves the problem in one line."
                    },
                    {
                        "username": "C0de_bumstead",
                        "content": "Can be easily solved using sliding window duhh...."
                    },
                    {
                        "username": "mikael6767",
                        "content": "Why should it be marked ```Medium```. This is literally 1line of code or 28 symbols(I\\'m counting the ```return``` function). You don\\'t need any algorithm. You need one function (if you use python3). And that function starts of the letter \"f\""
                    },
                    {
                        "username": "2020uch0017",
                        "content": "it is medium now and yes it is a KMP  problem"
                    },
                    {
                        "username": "jarc",
                        "content": " Is it the standard string matching problem? Am I wrong?"
                    },
                    {
                        "username": "chickooo",
                        "content": "Yeah, this is the standard string matching problem.\\nYour function should perform same as **.find()** function in python OR **.indexOf()** function in javascript"
                    },
                    {
                        "username": "tlong1299",
                        "content": "**USE FIND**\\nAs a Python programmer, refusing to use core language features is akin to using a hammer instead of nail-gun because it makes you a \"better\" carpenter. Remember that this is Python not C. Python\\'s PEP 20 states, \"There should be one-- and preferably only one --obvious way to do it.\" I would call a string operation built into python designed to solve this particular problem the obvious way to do it.\\n\\n**DON\\'T USE FIND**\\nIf you go into an interview and solve this problem with the find() function, you better know how it works underneath, and you should be prepared to defend your use of it. After all nothing is \"free\" in your code, and even \"magic\" functions have a time and memory cost associated with them. Knowing what this cost is, and why it is the way it is will make you a better programmer. Implementing the function yourself, at least once, can really help you develop a better appreciation for the language."
                    },
                    {
                        "username": "chazwinter",
                        "content": "Finally, a Python programmer that isn\\'t an idiot. It\\'s wild how people overthink this problem."
                    },
                    {
                        "username": "marten2",
                        "content": "Hey,\\n\\nI wouldn't say that coming up with the KMP algorithm from scratch is easy ~1 hour time. Did companies that asked this question expect applicants to know KMP by heart? Did they expect the applicant to show a naive implementation? Any opinion on this?\\n\\nBest,\\n\\nMarten"
                    },
                    {
                        "username": "syfo_dias",
                        "content": "[@chazwinter](/chazwinter) is it Python specific task? Or what is indexOf in C++? "
                    },
                    {
                        "username": "chazwinter",
                        "content": "No, they expected you to know indexOf. Don\\'t overthink it."
                    },
                    {
                        "username": "zijianz",
                        "content": "Input: \\t\"\", \"\"\\nOutput: \\t-1\\nExpected: \\t0\\n\\nBasically there is nothing in the string, how do you get the index.\\n\\nIf this test case is valid, then needle =\"\", haystack=\"anything\" could return any value. since empty is everywhere."
                    },
                    {
                        "username": "chazwinter",
                        "content": "Read the constraints. If you had to deal with an empty string, you would simply write an edge case for it."
                    },
                    {
                        "username": "mansourcodes",
                        "content": "1 <= haystack.length, needle.length <= 104\\n"
                    },
                    {
                        "username": "cxaviousb",
                        "content": "> In a string, the last element is null character. In the first case, where it is \"\",\"\" both of them has same character that is null character, while in \"\",\"anything\" the first string has null character at 0 index while the next one has 'a' at 0 index.\n\n[@AvniGoyal22](/AvniGoyal22) That's programming language specific logic.  Let's try applying logic from JavaScript to this problem~\n\n```javascript\n> 'anything'.indexOf('')\n< 0\n> ''.charAt(0)\n< \"\"\n> ''.charAt(9001)\n< \"\"\n> 'anything'.lastIndexOf('')\n< 8\n< \"anything\"\n> 'anything'.substr(0,9)\n< \"anything\"\n> 'anything'.substr(9001,9)\n< \"\"\n```"
                    },
                    {
                        "username": "shaan__0w0",
                        "content": "i think you have to make the case of if the string is empty"
                    },
                    {
                        "username": "AvniGoyal22",
                        "content": "In a string, the last element is null character. In the first case, where it is \"\",\"\" both of them has same character that is null character, while in \"\",\"anything\" the first string has null character at 0 index while the next one has \\'a\\' at 0 index. "
                    },
                    {
                        "username": "SarK97",
                        "content": "Why this test case is returning -1? Shouldn\\'t it be 4 since it is a substring?\\n\"mississippi\"\\n\"issip\""
                    },
                    {
                        "username": "impatientcat07",
                        "content": "Here comes the Overlapping case while comparing \"issis\" -> \"issip\" it rejects and reinitializes and starts from \"sippi\" & \\n comparing \"issip\", which in turns return -1; "
                    },
                    {
                        "username": "flyingfist",
                        "content": "its because it is taking issis (index 1 to 5) as index 5 is not matching it goes further and doesnt get issip "
                    },
                    {
                        "username": "MaheshPatil19",
                        "content": "here needle =\"issipi\""
                    },
                    {
                        "username": "chickooo",
                        "content": "If you add this test case ( I just did ), the output is 4 as expected.\\nDon\\'t know why you are getting -1. \\nMaybe there were unwanted spaces in your input. Can you try that again?"
                    },
                    {
                        "username": "trpaslik",
                        "content": "Most of python submissions are based on cheating (s.index() or s.find()).\\nIt is a pitty that when implementing it in pure python (the naive `O(n*m)` way) it results in timeout.\\nIt should either be accepted for `O(n*m)` or if some better approach is expected like with a rolling hash then it should be marked as medium IMHO."
                    },
                    {
                        "username": "ryo-kozin",
                        "content": "I believe  an interviewer would be fine with ussing indexOf(). In real-world programming situations, it is often advisable to take full advantage of available built-in functions and libraries. "
                    },
                    {
                        "username": "labule",
                        "content": "[@Deecodes25](/Deecodes25)  Time Complexity is O(n*m). `haystack[i:j] == needle` touches `m` chars and you do this approximately `n` times."
                    },
                    {
                        "username": "youttsu",
                        "content": "true dude. it works on JS with O(m*n) time complexity though "
                    },
                    {
                        "username": "Deecodes25",
                        "content": "I solved with this approach, can anyone explain what is the Time Complexity for this - \\n```\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        i=0\\n        j=len(needle)\\n        while j<=len(haystack):\\n            if haystack[i:j] == needle:\\n                return i\\n            i+=1\\n            j+=1\\n        return -1\\n```"
                    },
                    {
                        "username": "veerashah1",
                        "content": "[@chickooo](/chickooo) Wouldn\\'t an interviewer be fine with .indexOf(), because there\\'s no reason to re-invent the wheel when there are built in functions? If they specifically ask to avoid it then I guess, but in this case they didn\\'t."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Why is using indexOf cheating? Nowhere is it stated that you shouldn\\'t use that. If they don\\'t want you to use that they should say so, or limit the time constraints to only allow O(N+M)"
                    },
                    {
                        "username": "shaan__0w0",
                        "content": "but it gets submitted by using .indexOf() in java \\n"
                    },
                    {
                        "username": "chickooo",
                        "content": "Agreed with your opinion.\\nIf you were to use just built in function like .find() or .indexOf(), then the problem wouldn\\'t be labeled **Medium**. And if you were in an interview, the interviewer would not be pleased."
                    },
                    {
                        "username": "chehsunliu",
                        "content": "I have solved this problem. However, I think it may be controversial to return index 0 when the inputs are \"A\" and \"\". In my opinion, one of the inputs is \"A\\\\0\" and the other is \"\\\\0\". Perhaps it should return index 1."
                    }
                ]
            },
            {
                "id": 1568123,
                "content": [
                    {
                        "username": "Siddharth2k007",
                        "content": "Who marked this as `Easy`? It\\'s not easy at all. Though you can easily produce O(mn) solution, it is not accepted for python. You need KMP algorithm to produce O(m + n) solution!"
                    },
                    {
                        "username": "countdankula",
                        "content": "[@chazwinter](/chazwinter) Lol. The interviewer will just kick you out if you use indexof() to solve this problem."
                    },
                    {
                        "username": "chazwinter",
                        "content": "It\\'s marked easy because the point is to teach you how to use indexOf.\\nIt\\'s only difficult when you fail to learn it lol"
                    },
                    {
                        "username": "Tulsyan_25",
                        "content": "Use sliding window, its that easy\\n"
                    },
                    {
                        "username": "dezann1990",
                        "content": "dude, it is oneliner"
                    },
                    {
                        "username": "Singh_uday99",
                        "content": "[@Anshmehta380](/Anshmehta380) But that is not the thing Leetcode trying to test;\\nIt wants us to study the working of indexOf () method"
                    },
                    {
                        "username": "Anshmehta380",
                        "content": "[@howardcho](/howardcho) Same for me in java"
                    },
                    {
                        "username": "Anshmehta380",
                        "content": "Bro just use indexOf() method i solved it in a one line code lol"
                    },
                    {
                        "username": "charonme",
                        "content": "tha naive O(n^2) solution is now being accepted, but if the testcases contained enough tests with long enough strings it would give a TLE"
                    },
                    {
                        "username": "aalmos",
                        "content": "[@Mister_CK](/Mister_CK) good luck with doing that on an interview bro. "
                    },
                    {
                        "username": "howardcho",
                        "content": "I\\'m not sure if there\\'s a better way, but this was a one-line solution for me in python."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "?! This is one of the easiest problems on the site, a.indexOf(b) satisfies all requirements (O(mn) time complexity I believe), at least in JS. took me 37 seconds, beats 87%"
                    },
                    {
                        "username": "gurpreetsingh8",
                        "content": "[@jdipirro](/jdipirro) exactly, this is just solved in O(N). I am wondering why it is medium"
                    },
                    {
                        "username": "calm27",
                        "content": "Python3 `O(mn)` is acceptable. "
                    },
                    {
                        "username": "pieceofpie",
                        "content": "It is now a ```Medium``` problem."
                    },
                    {
                        "username": "jdipirro",
                        "content": "Is this answer not valid for some reason?  They remarked it medium, but it can be solved with the super easy method below\\n\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n\\n        for x in range(len(haystack)):\\n            if haystack[lx : x + len(needle)] == needle:\\n                return x\\n        else:\\n            return -1"
                    },
                    {
                        "username": "narayan48",
                        "content": "class Solution {\\n    public int strStr(String haystack, String needle) {\\n          int indexOfSubStr = haystack.indexOf(needle);\\n          return indexOfSubStr;\\n\\n    }\\n    //return -1;\\n}"
                    },
                    {
                        "username": "sayedHANEEF",
                        "content": "dude it is a one line solution in java and it takes 0ms to run"
                    },
                    {
                        "username": "SugerSu",
                        "content": "Maybe sometimes we do not need to think too much!\\n\\npublic int strStr(String haystack, String needle) {\\n\\n\\t\\t\\n\\t\\treturn haystack.indexOf(needle);\\n\\t}"
                    },
                    {
                        "username": "coveyjorjet",
                        "content": "similarly you can use find() function in c++\\n```\\nreturn haystack.find(needle);\\n```"
                    },
                    {
                        "username": "enkil2003",
                        "content": "and that is how you never get a job."
                    },
                    {
                        "username": "hippofaris",
                        "content": "giga chad"
                    },
                    {
                        "username": "qAxP4Mw",
                        "content": "[@Meerkats1999](/Meerkats1999) however if your coworker reimplemented indexOf on a project everyone would be pretty annoyed so I think interviewer should accept this answer. Otherwise they should be more clear about what they\\'re looking for."
                    },
                    {
                        "username": "yuangaonyc",
                        "content": "Maybe you should think more"
                    },
                    {
                        "username": "chazwinter",
                        "content": "Don\\'t provide solutions, no matter how easy you think they are.\\nThis answer uses built in Java functionality without imports, so it\\'s fair game. If they wanted you to design your own indexOf method, they would have said so. \\n\\nThere are other problems that specifically say to avoid certain methods, or ask a follow to challenge you to try it another way. This one does not have that, so I see it as an attempt to expose new people to indexOf."
                    },
                    {
                        "username": "dantruongdo3",
                        "content": "[@Meerkats1999](/Meerkats1999) i use the exact same way and feel kinda guilty."
                    },
                    {
                        "username": "Meerkats1999",
                        "content": "I don\\'t think the interviewer will like this answer."
                    },
                    {
                        "username": "emcc1990",
                        "content": "I also submitted this but having doubts of whether the whole point is not to use it and implement something raw. "
                    },
                    {
                        "username": "user0566A",
                        "content": "It\\'s interesting that java indexOf do not use KMP (because of memory I think) or Rabin-Karp (don\\'t know why)\\nhttps://github.com/AdoptOpenJDK/openjdk-jdk11/blob/master/src/java.base/share/classes/java/lang/StringLatin1.java#L233-L253"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@therishuraj](/therishuraj) My indexOf solution beats 91%... It\\'s definitely fast enough and thus I strongly feel this should be easy. Otherwise LeetCode should drastically limit the time-constraints in my opinion"
                    },
                    {
                        "username": "user0743xF",
                        "content": "[@mohan9814](/mohan9814) because here people are coming to learn algorithms i think :)"
                    },
                    {
                        "username": "therishuraj",
                        "content": "[@mohan9814](/mohan9814)  Because time complexity of the KMP algorithm is O(m+n) And time complexity of the indexOf method is O(nm). "
                    },
                    {
                        "username": "mohan9814",
                        "content": "yes same logic in c++ is working fine why do i need to get into kmp and all this"
                    },
                    {
                        "username": "mgoldenbe",
                        "content": "I don\\'t think they meant that I can call a library function. Also, I get \"Time Limit Exceeded\" on brute-force. So, this means I should use an advanced algorithm, like Rabin-Karp or KMP. Why then is this problem marked \"easy\"?"
                    },
                    {
                        "username": "chazwinter",
                        "content": "It\\'s easy because the point is to teach you to 1) stop overthinking things, and 2) learn one single function that solves the problem in one line."
                    },
                    {
                        "username": "C0de_bumstead",
                        "content": "Can be easily solved using sliding window duhh...."
                    },
                    {
                        "username": "mikael6767",
                        "content": "Why should it be marked ```Medium```. This is literally 1line of code or 28 symbols(I\\'m counting the ```return``` function). You don\\'t need any algorithm. You need one function (if you use python3). And that function starts of the letter \"f\""
                    },
                    {
                        "username": "2020uch0017",
                        "content": "it is medium now and yes it is a KMP  problem"
                    },
                    {
                        "username": "jarc",
                        "content": " Is it the standard string matching problem? Am I wrong?"
                    },
                    {
                        "username": "chickooo",
                        "content": "Yeah, this is the standard string matching problem.\\nYour function should perform same as **.find()** function in python OR **.indexOf()** function in javascript"
                    },
                    {
                        "username": "tlong1299",
                        "content": "**USE FIND**\\nAs a Python programmer, refusing to use core language features is akin to using a hammer instead of nail-gun because it makes you a \"better\" carpenter. Remember that this is Python not C. Python\\'s PEP 20 states, \"There should be one-- and preferably only one --obvious way to do it.\" I would call a string operation built into python designed to solve this particular problem the obvious way to do it.\\n\\n**DON\\'T USE FIND**\\nIf you go into an interview and solve this problem with the find() function, you better know how it works underneath, and you should be prepared to defend your use of it. After all nothing is \"free\" in your code, and even \"magic\" functions have a time and memory cost associated with them. Knowing what this cost is, and why it is the way it is will make you a better programmer. Implementing the function yourself, at least once, can really help you develop a better appreciation for the language."
                    },
                    {
                        "username": "chazwinter",
                        "content": "Finally, a Python programmer that isn\\'t an idiot. It\\'s wild how people overthink this problem."
                    },
                    {
                        "username": "marten2",
                        "content": "Hey,\\n\\nI wouldn't say that coming up with the KMP algorithm from scratch is easy ~1 hour time. Did companies that asked this question expect applicants to know KMP by heart? Did they expect the applicant to show a naive implementation? Any opinion on this?\\n\\nBest,\\n\\nMarten"
                    },
                    {
                        "username": "syfo_dias",
                        "content": "[@chazwinter](/chazwinter) is it Python specific task? Or what is indexOf in C++? "
                    },
                    {
                        "username": "chazwinter",
                        "content": "No, they expected you to know indexOf. Don\\'t overthink it."
                    },
                    {
                        "username": "zijianz",
                        "content": "Input: \\t\"\", \"\"\\nOutput: \\t-1\\nExpected: \\t0\\n\\nBasically there is nothing in the string, how do you get the index.\\n\\nIf this test case is valid, then needle =\"\", haystack=\"anything\" could return any value. since empty is everywhere."
                    },
                    {
                        "username": "chazwinter",
                        "content": "Read the constraints. If you had to deal with an empty string, you would simply write an edge case for it."
                    },
                    {
                        "username": "mansourcodes",
                        "content": "1 <= haystack.length, needle.length <= 104\\n"
                    },
                    {
                        "username": "cxaviousb",
                        "content": "> In a string, the last element is null character. In the first case, where it is \"\",\"\" both of them has same character that is null character, while in \"\",\"anything\" the first string has null character at 0 index while the next one has 'a' at 0 index.\n\n[@AvniGoyal22](/AvniGoyal22) That's programming language specific logic.  Let's try applying logic from JavaScript to this problem~\n\n```javascript\n> 'anything'.indexOf('')\n< 0\n> ''.charAt(0)\n< \"\"\n> ''.charAt(9001)\n< \"\"\n> 'anything'.lastIndexOf('')\n< 8\n< \"anything\"\n> 'anything'.substr(0,9)\n< \"anything\"\n> 'anything'.substr(9001,9)\n< \"\"\n```"
                    },
                    {
                        "username": "shaan__0w0",
                        "content": "i think you have to make the case of if the string is empty"
                    },
                    {
                        "username": "AvniGoyal22",
                        "content": "In a string, the last element is null character. In the first case, where it is \"\",\"\" both of them has same character that is null character, while in \"\",\"anything\" the first string has null character at 0 index while the next one has \\'a\\' at 0 index. "
                    },
                    {
                        "username": "SarK97",
                        "content": "Why this test case is returning -1? Shouldn\\'t it be 4 since it is a substring?\\n\"mississippi\"\\n\"issip\""
                    },
                    {
                        "username": "impatientcat07",
                        "content": "Here comes the Overlapping case while comparing \"issis\" -> \"issip\" it rejects and reinitializes and starts from \"sippi\" & \\n comparing \"issip\", which in turns return -1; "
                    },
                    {
                        "username": "flyingfist",
                        "content": "its because it is taking issis (index 1 to 5) as index 5 is not matching it goes further and doesnt get issip "
                    },
                    {
                        "username": "MaheshPatil19",
                        "content": "here needle =\"issipi\""
                    },
                    {
                        "username": "chickooo",
                        "content": "If you add this test case ( I just did ), the output is 4 as expected.\\nDon\\'t know why you are getting -1. \\nMaybe there were unwanted spaces in your input. Can you try that again?"
                    },
                    {
                        "username": "trpaslik",
                        "content": "Most of python submissions are based on cheating (s.index() or s.find()).\\nIt is a pitty that when implementing it in pure python (the naive `O(n*m)` way) it results in timeout.\\nIt should either be accepted for `O(n*m)` or if some better approach is expected like with a rolling hash then it should be marked as medium IMHO."
                    },
                    {
                        "username": "ryo-kozin",
                        "content": "I believe  an interviewer would be fine with ussing indexOf(). In real-world programming situations, it is often advisable to take full advantage of available built-in functions and libraries. "
                    },
                    {
                        "username": "labule",
                        "content": "[@Deecodes25](/Deecodes25)  Time Complexity is O(n*m). `haystack[i:j] == needle` touches `m` chars and you do this approximately `n` times."
                    },
                    {
                        "username": "youttsu",
                        "content": "true dude. it works on JS with O(m*n) time complexity though "
                    },
                    {
                        "username": "Deecodes25",
                        "content": "I solved with this approach, can anyone explain what is the Time Complexity for this - \\n```\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        i=0\\n        j=len(needle)\\n        while j<=len(haystack):\\n            if haystack[i:j] == needle:\\n                return i\\n            i+=1\\n            j+=1\\n        return -1\\n```"
                    },
                    {
                        "username": "veerashah1",
                        "content": "[@chickooo](/chickooo) Wouldn\\'t an interviewer be fine with .indexOf(), because there\\'s no reason to re-invent the wheel when there are built in functions? If they specifically ask to avoid it then I guess, but in this case they didn\\'t."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Why is using indexOf cheating? Nowhere is it stated that you shouldn\\'t use that. If they don\\'t want you to use that they should say so, or limit the time constraints to only allow O(N+M)"
                    },
                    {
                        "username": "shaan__0w0",
                        "content": "but it gets submitted by using .indexOf() in java \\n"
                    },
                    {
                        "username": "chickooo",
                        "content": "Agreed with your opinion.\\nIf you were to use just built in function like .find() or .indexOf(), then the problem wouldn\\'t be labeled **Medium**. And if you were in an interview, the interviewer would not be pleased."
                    },
                    {
                        "username": "chehsunliu",
                        "content": "I have solved this problem. However, I think it may be controversial to return index 0 when the inputs are \"A\" and \"\". In my opinion, one of the inputs is \"A\\\\0\" and the other is \"\\\\0\". Perhaps it should return index 1."
                    }
                ]
            },
            {
                "id": 1566418,
                "content": [
                    {
                        "username": "Siddharth2k007",
                        "content": "Who marked this as `Easy`? It\\'s not easy at all. Though you can easily produce O(mn) solution, it is not accepted for python. You need KMP algorithm to produce O(m + n) solution!"
                    },
                    {
                        "username": "countdankula",
                        "content": "[@chazwinter](/chazwinter) Lol. The interviewer will just kick you out if you use indexof() to solve this problem."
                    },
                    {
                        "username": "chazwinter",
                        "content": "It\\'s marked easy because the point is to teach you how to use indexOf.\\nIt\\'s only difficult when you fail to learn it lol"
                    },
                    {
                        "username": "Tulsyan_25",
                        "content": "Use sliding window, its that easy\\n"
                    },
                    {
                        "username": "dezann1990",
                        "content": "dude, it is oneliner"
                    },
                    {
                        "username": "Singh_uday99",
                        "content": "[@Anshmehta380](/Anshmehta380) But that is not the thing Leetcode trying to test;\\nIt wants us to study the working of indexOf () method"
                    },
                    {
                        "username": "Anshmehta380",
                        "content": "[@howardcho](/howardcho) Same for me in java"
                    },
                    {
                        "username": "Anshmehta380",
                        "content": "Bro just use indexOf() method i solved it in a one line code lol"
                    },
                    {
                        "username": "charonme",
                        "content": "tha naive O(n^2) solution is now being accepted, but if the testcases contained enough tests with long enough strings it would give a TLE"
                    },
                    {
                        "username": "aalmos",
                        "content": "[@Mister_CK](/Mister_CK) good luck with doing that on an interview bro. "
                    },
                    {
                        "username": "howardcho",
                        "content": "I\\'m not sure if there\\'s a better way, but this was a one-line solution for me in python."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "?! This is one of the easiest problems on the site, a.indexOf(b) satisfies all requirements (O(mn) time complexity I believe), at least in JS. took me 37 seconds, beats 87%"
                    },
                    {
                        "username": "gurpreetsingh8",
                        "content": "[@jdipirro](/jdipirro) exactly, this is just solved in O(N). I am wondering why it is medium"
                    },
                    {
                        "username": "calm27",
                        "content": "Python3 `O(mn)` is acceptable. "
                    },
                    {
                        "username": "pieceofpie",
                        "content": "It is now a ```Medium``` problem."
                    },
                    {
                        "username": "jdipirro",
                        "content": "Is this answer not valid for some reason?  They remarked it medium, but it can be solved with the super easy method below\\n\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n\\n        for x in range(len(haystack)):\\n            if haystack[lx : x + len(needle)] == needle:\\n                return x\\n        else:\\n            return -1"
                    },
                    {
                        "username": "narayan48",
                        "content": "class Solution {\\n    public int strStr(String haystack, String needle) {\\n          int indexOfSubStr = haystack.indexOf(needle);\\n          return indexOfSubStr;\\n\\n    }\\n    //return -1;\\n}"
                    },
                    {
                        "username": "sayedHANEEF",
                        "content": "dude it is a one line solution in java and it takes 0ms to run"
                    },
                    {
                        "username": "SugerSu",
                        "content": "Maybe sometimes we do not need to think too much!\\n\\npublic int strStr(String haystack, String needle) {\\n\\n\\t\\t\\n\\t\\treturn haystack.indexOf(needle);\\n\\t}"
                    },
                    {
                        "username": "coveyjorjet",
                        "content": "similarly you can use find() function in c++\\n```\\nreturn haystack.find(needle);\\n```"
                    },
                    {
                        "username": "enkil2003",
                        "content": "and that is how you never get a job."
                    },
                    {
                        "username": "hippofaris",
                        "content": "giga chad"
                    },
                    {
                        "username": "qAxP4Mw",
                        "content": "[@Meerkats1999](/Meerkats1999) however if your coworker reimplemented indexOf on a project everyone would be pretty annoyed so I think interviewer should accept this answer. Otherwise they should be more clear about what they\\'re looking for."
                    },
                    {
                        "username": "yuangaonyc",
                        "content": "Maybe you should think more"
                    },
                    {
                        "username": "chazwinter",
                        "content": "Don\\'t provide solutions, no matter how easy you think they are.\\nThis answer uses built in Java functionality without imports, so it\\'s fair game. If they wanted you to design your own indexOf method, they would have said so. \\n\\nThere are other problems that specifically say to avoid certain methods, or ask a follow to challenge you to try it another way. This one does not have that, so I see it as an attempt to expose new people to indexOf."
                    },
                    {
                        "username": "dantruongdo3",
                        "content": "[@Meerkats1999](/Meerkats1999) i use the exact same way and feel kinda guilty."
                    },
                    {
                        "username": "Meerkats1999",
                        "content": "I don\\'t think the interviewer will like this answer."
                    },
                    {
                        "username": "emcc1990",
                        "content": "I also submitted this but having doubts of whether the whole point is not to use it and implement something raw. "
                    },
                    {
                        "username": "user0566A",
                        "content": "It\\'s interesting that java indexOf do not use KMP (because of memory I think) or Rabin-Karp (don\\'t know why)\\nhttps://github.com/AdoptOpenJDK/openjdk-jdk11/blob/master/src/java.base/share/classes/java/lang/StringLatin1.java#L233-L253"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@therishuraj](/therishuraj) My indexOf solution beats 91%... It\\'s definitely fast enough and thus I strongly feel this should be easy. Otherwise LeetCode should drastically limit the time-constraints in my opinion"
                    },
                    {
                        "username": "user0743xF",
                        "content": "[@mohan9814](/mohan9814) because here people are coming to learn algorithms i think :)"
                    },
                    {
                        "username": "therishuraj",
                        "content": "[@mohan9814](/mohan9814)  Because time complexity of the KMP algorithm is O(m+n) And time complexity of the indexOf method is O(nm). "
                    },
                    {
                        "username": "mohan9814",
                        "content": "yes same logic in c++ is working fine why do i need to get into kmp and all this"
                    },
                    {
                        "username": "mgoldenbe",
                        "content": "I don\\'t think they meant that I can call a library function. Also, I get \"Time Limit Exceeded\" on brute-force. So, this means I should use an advanced algorithm, like Rabin-Karp or KMP. Why then is this problem marked \"easy\"?"
                    },
                    {
                        "username": "chazwinter",
                        "content": "It\\'s easy because the point is to teach you to 1) stop overthinking things, and 2) learn one single function that solves the problem in one line."
                    },
                    {
                        "username": "C0de_bumstead",
                        "content": "Can be easily solved using sliding window duhh...."
                    },
                    {
                        "username": "mikael6767",
                        "content": "Why should it be marked ```Medium```. This is literally 1line of code or 28 symbols(I\\'m counting the ```return``` function). You don\\'t need any algorithm. You need one function (if you use python3). And that function starts of the letter \"f\""
                    },
                    {
                        "username": "2020uch0017",
                        "content": "it is medium now and yes it is a KMP  problem"
                    },
                    {
                        "username": "jarc",
                        "content": " Is it the standard string matching problem? Am I wrong?"
                    },
                    {
                        "username": "chickooo",
                        "content": "Yeah, this is the standard string matching problem.\\nYour function should perform same as **.find()** function in python OR **.indexOf()** function in javascript"
                    },
                    {
                        "username": "tlong1299",
                        "content": "**USE FIND**\\nAs a Python programmer, refusing to use core language features is akin to using a hammer instead of nail-gun because it makes you a \"better\" carpenter. Remember that this is Python not C. Python\\'s PEP 20 states, \"There should be one-- and preferably only one --obvious way to do it.\" I would call a string operation built into python designed to solve this particular problem the obvious way to do it.\\n\\n**DON\\'T USE FIND**\\nIf you go into an interview and solve this problem with the find() function, you better know how it works underneath, and you should be prepared to defend your use of it. After all nothing is \"free\" in your code, and even \"magic\" functions have a time and memory cost associated with them. Knowing what this cost is, and why it is the way it is will make you a better programmer. Implementing the function yourself, at least once, can really help you develop a better appreciation for the language."
                    },
                    {
                        "username": "chazwinter",
                        "content": "Finally, a Python programmer that isn\\'t an idiot. It\\'s wild how people overthink this problem."
                    },
                    {
                        "username": "marten2",
                        "content": "Hey,\\n\\nI wouldn't say that coming up with the KMP algorithm from scratch is easy ~1 hour time. Did companies that asked this question expect applicants to know KMP by heart? Did they expect the applicant to show a naive implementation? Any opinion on this?\\n\\nBest,\\n\\nMarten"
                    },
                    {
                        "username": "syfo_dias",
                        "content": "[@chazwinter](/chazwinter) is it Python specific task? Or what is indexOf in C++? "
                    },
                    {
                        "username": "chazwinter",
                        "content": "No, they expected you to know indexOf. Don\\'t overthink it."
                    },
                    {
                        "username": "zijianz",
                        "content": "Input: \\t\"\", \"\"\\nOutput: \\t-1\\nExpected: \\t0\\n\\nBasically there is nothing in the string, how do you get the index.\\n\\nIf this test case is valid, then needle =\"\", haystack=\"anything\" could return any value. since empty is everywhere."
                    },
                    {
                        "username": "chazwinter",
                        "content": "Read the constraints. If you had to deal with an empty string, you would simply write an edge case for it."
                    },
                    {
                        "username": "mansourcodes",
                        "content": "1 <= haystack.length, needle.length <= 104\\n"
                    },
                    {
                        "username": "cxaviousb",
                        "content": "> In a string, the last element is null character. In the first case, where it is \"\",\"\" both of them has same character that is null character, while in \"\",\"anything\" the first string has null character at 0 index while the next one has 'a' at 0 index.\n\n[@AvniGoyal22](/AvniGoyal22) That's programming language specific logic.  Let's try applying logic from JavaScript to this problem~\n\n```javascript\n> 'anything'.indexOf('')\n< 0\n> ''.charAt(0)\n< \"\"\n> ''.charAt(9001)\n< \"\"\n> 'anything'.lastIndexOf('')\n< 8\n< \"anything\"\n> 'anything'.substr(0,9)\n< \"anything\"\n> 'anything'.substr(9001,9)\n< \"\"\n```"
                    },
                    {
                        "username": "shaan__0w0",
                        "content": "i think you have to make the case of if the string is empty"
                    },
                    {
                        "username": "AvniGoyal22",
                        "content": "In a string, the last element is null character. In the first case, where it is \"\",\"\" both of them has same character that is null character, while in \"\",\"anything\" the first string has null character at 0 index while the next one has \\'a\\' at 0 index. "
                    },
                    {
                        "username": "SarK97",
                        "content": "Why this test case is returning -1? Shouldn\\'t it be 4 since it is a substring?\\n\"mississippi\"\\n\"issip\""
                    },
                    {
                        "username": "impatientcat07",
                        "content": "Here comes the Overlapping case while comparing \"issis\" -> \"issip\" it rejects and reinitializes and starts from \"sippi\" & \\n comparing \"issip\", which in turns return -1; "
                    },
                    {
                        "username": "flyingfist",
                        "content": "its because it is taking issis (index 1 to 5) as index 5 is not matching it goes further and doesnt get issip "
                    },
                    {
                        "username": "MaheshPatil19",
                        "content": "here needle =\"issipi\""
                    },
                    {
                        "username": "chickooo",
                        "content": "If you add this test case ( I just did ), the output is 4 as expected.\\nDon\\'t know why you are getting -1. \\nMaybe there were unwanted spaces in your input. Can you try that again?"
                    },
                    {
                        "username": "trpaslik",
                        "content": "Most of python submissions are based on cheating (s.index() or s.find()).\\nIt is a pitty that when implementing it in pure python (the naive `O(n*m)` way) it results in timeout.\\nIt should either be accepted for `O(n*m)` or if some better approach is expected like with a rolling hash then it should be marked as medium IMHO."
                    },
                    {
                        "username": "ryo-kozin",
                        "content": "I believe  an interviewer would be fine with ussing indexOf(). In real-world programming situations, it is often advisable to take full advantage of available built-in functions and libraries. "
                    },
                    {
                        "username": "labule",
                        "content": "[@Deecodes25](/Deecodes25)  Time Complexity is O(n*m). `haystack[i:j] == needle` touches `m` chars and you do this approximately `n` times."
                    },
                    {
                        "username": "youttsu",
                        "content": "true dude. it works on JS with O(m*n) time complexity though "
                    },
                    {
                        "username": "Deecodes25",
                        "content": "I solved with this approach, can anyone explain what is the Time Complexity for this - \\n```\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        i=0\\n        j=len(needle)\\n        while j<=len(haystack):\\n            if haystack[i:j] == needle:\\n                return i\\n            i+=1\\n            j+=1\\n        return -1\\n```"
                    },
                    {
                        "username": "veerashah1",
                        "content": "[@chickooo](/chickooo) Wouldn\\'t an interviewer be fine with .indexOf(), because there\\'s no reason to re-invent the wheel when there are built in functions? If they specifically ask to avoid it then I guess, but in this case they didn\\'t."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Why is using indexOf cheating? Nowhere is it stated that you shouldn\\'t use that. If they don\\'t want you to use that they should say so, or limit the time constraints to only allow O(N+M)"
                    },
                    {
                        "username": "shaan__0w0",
                        "content": "but it gets submitted by using .indexOf() in java \\n"
                    },
                    {
                        "username": "chickooo",
                        "content": "Agreed with your opinion.\\nIf you were to use just built in function like .find() or .indexOf(), then the problem wouldn\\'t be labeled **Medium**. And if you were in an interview, the interviewer would not be pleased."
                    },
                    {
                        "username": "chehsunliu",
                        "content": "I have solved this problem. However, I think it may be controversial to return index 0 when the inputs are \"A\" and \"\". In my opinion, one of the inputs is \"A\\\\0\" and the other is \"\\\\0\". Perhaps it should return index 1."
                    }
                ]
            },
            {
                "id": 1565342,
                "content": [
                    {
                        "username": "Siddharth2k007",
                        "content": "Who marked this as `Easy`? It\\'s not easy at all. Though you can easily produce O(mn) solution, it is not accepted for python. You need KMP algorithm to produce O(m + n) solution!"
                    },
                    {
                        "username": "countdankula",
                        "content": "[@chazwinter](/chazwinter) Lol. The interviewer will just kick you out if you use indexof() to solve this problem."
                    },
                    {
                        "username": "chazwinter",
                        "content": "It\\'s marked easy because the point is to teach you how to use indexOf.\\nIt\\'s only difficult when you fail to learn it lol"
                    },
                    {
                        "username": "Tulsyan_25",
                        "content": "Use sliding window, its that easy\\n"
                    },
                    {
                        "username": "dezann1990",
                        "content": "dude, it is oneliner"
                    },
                    {
                        "username": "Singh_uday99",
                        "content": "[@Anshmehta380](/Anshmehta380) But that is not the thing Leetcode trying to test;\\nIt wants us to study the working of indexOf () method"
                    },
                    {
                        "username": "Anshmehta380",
                        "content": "[@howardcho](/howardcho) Same for me in java"
                    },
                    {
                        "username": "Anshmehta380",
                        "content": "Bro just use indexOf() method i solved it in a one line code lol"
                    },
                    {
                        "username": "charonme",
                        "content": "tha naive O(n^2) solution is now being accepted, but if the testcases contained enough tests with long enough strings it would give a TLE"
                    },
                    {
                        "username": "aalmos",
                        "content": "[@Mister_CK](/Mister_CK) good luck with doing that on an interview bro. "
                    },
                    {
                        "username": "howardcho",
                        "content": "I\\'m not sure if there\\'s a better way, but this was a one-line solution for me in python."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "?! This is one of the easiest problems on the site, a.indexOf(b) satisfies all requirements (O(mn) time complexity I believe), at least in JS. took me 37 seconds, beats 87%"
                    },
                    {
                        "username": "gurpreetsingh8",
                        "content": "[@jdipirro](/jdipirro) exactly, this is just solved in O(N). I am wondering why it is medium"
                    },
                    {
                        "username": "calm27",
                        "content": "Python3 `O(mn)` is acceptable. "
                    },
                    {
                        "username": "pieceofpie",
                        "content": "It is now a ```Medium``` problem."
                    },
                    {
                        "username": "jdipirro",
                        "content": "Is this answer not valid for some reason?  They remarked it medium, but it can be solved with the super easy method below\\n\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n\\n        for x in range(len(haystack)):\\n            if haystack[lx : x + len(needle)] == needle:\\n                return x\\n        else:\\n            return -1"
                    },
                    {
                        "username": "narayan48",
                        "content": "class Solution {\\n    public int strStr(String haystack, String needle) {\\n          int indexOfSubStr = haystack.indexOf(needle);\\n          return indexOfSubStr;\\n\\n    }\\n    //return -1;\\n}"
                    },
                    {
                        "username": "sayedHANEEF",
                        "content": "dude it is a one line solution in java and it takes 0ms to run"
                    },
                    {
                        "username": "SugerSu",
                        "content": "Maybe sometimes we do not need to think too much!\\n\\npublic int strStr(String haystack, String needle) {\\n\\n\\t\\t\\n\\t\\treturn haystack.indexOf(needle);\\n\\t}"
                    },
                    {
                        "username": "coveyjorjet",
                        "content": "similarly you can use find() function in c++\\n```\\nreturn haystack.find(needle);\\n```"
                    },
                    {
                        "username": "enkil2003",
                        "content": "and that is how you never get a job."
                    },
                    {
                        "username": "hippofaris",
                        "content": "giga chad"
                    },
                    {
                        "username": "qAxP4Mw",
                        "content": "[@Meerkats1999](/Meerkats1999) however if your coworker reimplemented indexOf on a project everyone would be pretty annoyed so I think interviewer should accept this answer. Otherwise they should be more clear about what they\\'re looking for."
                    },
                    {
                        "username": "yuangaonyc",
                        "content": "Maybe you should think more"
                    },
                    {
                        "username": "chazwinter",
                        "content": "Don\\'t provide solutions, no matter how easy you think they are.\\nThis answer uses built in Java functionality without imports, so it\\'s fair game. If they wanted you to design your own indexOf method, they would have said so. \\n\\nThere are other problems that specifically say to avoid certain methods, or ask a follow to challenge you to try it another way. This one does not have that, so I see it as an attempt to expose new people to indexOf."
                    },
                    {
                        "username": "dantruongdo3",
                        "content": "[@Meerkats1999](/Meerkats1999) i use the exact same way and feel kinda guilty."
                    },
                    {
                        "username": "Meerkats1999",
                        "content": "I don\\'t think the interviewer will like this answer."
                    },
                    {
                        "username": "emcc1990",
                        "content": "I also submitted this but having doubts of whether the whole point is not to use it and implement something raw. "
                    },
                    {
                        "username": "user0566A",
                        "content": "It\\'s interesting that java indexOf do not use KMP (because of memory I think) or Rabin-Karp (don\\'t know why)\\nhttps://github.com/AdoptOpenJDK/openjdk-jdk11/blob/master/src/java.base/share/classes/java/lang/StringLatin1.java#L233-L253"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@therishuraj](/therishuraj) My indexOf solution beats 91%... It\\'s definitely fast enough and thus I strongly feel this should be easy. Otherwise LeetCode should drastically limit the time-constraints in my opinion"
                    },
                    {
                        "username": "user0743xF",
                        "content": "[@mohan9814](/mohan9814) because here people are coming to learn algorithms i think :)"
                    },
                    {
                        "username": "therishuraj",
                        "content": "[@mohan9814](/mohan9814)  Because time complexity of the KMP algorithm is O(m+n) And time complexity of the indexOf method is O(nm). "
                    },
                    {
                        "username": "mohan9814",
                        "content": "yes same logic in c++ is working fine why do i need to get into kmp and all this"
                    },
                    {
                        "username": "mgoldenbe",
                        "content": "I don\\'t think they meant that I can call a library function. Also, I get \"Time Limit Exceeded\" on brute-force. So, this means I should use an advanced algorithm, like Rabin-Karp or KMP. Why then is this problem marked \"easy\"?"
                    },
                    {
                        "username": "chazwinter",
                        "content": "It\\'s easy because the point is to teach you to 1) stop overthinking things, and 2) learn one single function that solves the problem in one line."
                    },
                    {
                        "username": "C0de_bumstead",
                        "content": "Can be easily solved using sliding window duhh...."
                    },
                    {
                        "username": "mikael6767",
                        "content": "Why should it be marked ```Medium```. This is literally 1line of code or 28 symbols(I\\'m counting the ```return``` function). You don\\'t need any algorithm. You need one function (if you use python3). And that function starts of the letter \"f\""
                    },
                    {
                        "username": "2020uch0017",
                        "content": "it is medium now and yes it is a KMP  problem"
                    },
                    {
                        "username": "jarc",
                        "content": " Is it the standard string matching problem? Am I wrong?"
                    },
                    {
                        "username": "chickooo",
                        "content": "Yeah, this is the standard string matching problem.\\nYour function should perform same as **.find()** function in python OR **.indexOf()** function in javascript"
                    },
                    {
                        "username": "tlong1299",
                        "content": "**USE FIND**\\nAs a Python programmer, refusing to use core language features is akin to using a hammer instead of nail-gun because it makes you a \"better\" carpenter. Remember that this is Python not C. Python\\'s PEP 20 states, \"There should be one-- and preferably only one --obvious way to do it.\" I would call a string operation built into python designed to solve this particular problem the obvious way to do it.\\n\\n**DON\\'T USE FIND**\\nIf you go into an interview and solve this problem with the find() function, you better know how it works underneath, and you should be prepared to defend your use of it. After all nothing is \"free\" in your code, and even \"magic\" functions have a time and memory cost associated with them. Knowing what this cost is, and why it is the way it is will make you a better programmer. Implementing the function yourself, at least once, can really help you develop a better appreciation for the language."
                    },
                    {
                        "username": "chazwinter",
                        "content": "Finally, a Python programmer that isn\\'t an idiot. It\\'s wild how people overthink this problem."
                    },
                    {
                        "username": "marten2",
                        "content": "Hey,\\n\\nI wouldn't say that coming up with the KMP algorithm from scratch is easy ~1 hour time. Did companies that asked this question expect applicants to know KMP by heart? Did they expect the applicant to show a naive implementation? Any opinion on this?\\n\\nBest,\\n\\nMarten"
                    },
                    {
                        "username": "syfo_dias",
                        "content": "[@chazwinter](/chazwinter) is it Python specific task? Or what is indexOf in C++? "
                    },
                    {
                        "username": "chazwinter",
                        "content": "No, they expected you to know indexOf. Don\\'t overthink it."
                    },
                    {
                        "username": "zijianz",
                        "content": "Input: \\t\"\", \"\"\\nOutput: \\t-1\\nExpected: \\t0\\n\\nBasically there is nothing in the string, how do you get the index.\\n\\nIf this test case is valid, then needle =\"\", haystack=\"anything\" could return any value. since empty is everywhere."
                    },
                    {
                        "username": "chazwinter",
                        "content": "Read the constraints. If you had to deal with an empty string, you would simply write an edge case for it."
                    },
                    {
                        "username": "mansourcodes",
                        "content": "1 <= haystack.length, needle.length <= 104\\n"
                    },
                    {
                        "username": "cxaviousb",
                        "content": "> In a string, the last element is null character. In the first case, where it is \"\",\"\" both of them has same character that is null character, while in \"\",\"anything\" the first string has null character at 0 index while the next one has 'a' at 0 index.\n\n[@AvniGoyal22](/AvniGoyal22) That's programming language specific logic.  Let's try applying logic from JavaScript to this problem~\n\n```javascript\n> 'anything'.indexOf('')\n< 0\n> ''.charAt(0)\n< \"\"\n> ''.charAt(9001)\n< \"\"\n> 'anything'.lastIndexOf('')\n< 8\n< \"anything\"\n> 'anything'.substr(0,9)\n< \"anything\"\n> 'anything'.substr(9001,9)\n< \"\"\n```"
                    },
                    {
                        "username": "shaan__0w0",
                        "content": "i think you have to make the case of if the string is empty"
                    },
                    {
                        "username": "AvniGoyal22",
                        "content": "In a string, the last element is null character. In the first case, where it is \"\",\"\" both of them has same character that is null character, while in \"\",\"anything\" the first string has null character at 0 index while the next one has \\'a\\' at 0 index. "
                    },
                    {
                        "username": "SarK97",
                        "content": "Why this test case is returning -1? Shouldn\\'t it be 4 since it is a substring?\\n\"mississippi\"\\n\"issip\""
                    },
                    {
                        "username": "impatientcat07",
                        "content": "Here comes the Overlapping case while comparing \"issis\" -> \"issip\" it rejects and reinitializes and starts from \"sippi\" & \\n comparing \"issip\", which in turns return -1; "
                    },
                    {
                        "username": "flyingfist",
                        "content": "its because it is taking issis (index 1 to 5) as index 5 is not matching it goes further and doesnt get issip "
                    },
                    {
                        "username": "MaheshPatil19",
                        "content": "here needle =\"issipi\""
                    },
                    {
                        "username": "chickooo",
                        "content": "If you add this test case ( I just did ), the output is 4 as expected.\\nDon\\'t know why you are getting -1. \\nMaybe there were unwanted spaces in your input. Can you try that again?"
                    },
                    {
                        "username": "trpaslik",
                        "content": "Most of python submissions are based on cheating (s.index() or s.find()).\\nIt is a pitty that when implementing it in pure python (the naive `O(n*m)` way) it results in timeout.\\nIt should either be accepted for `O(n*m)` or if some better approach is expected like with a rolling hash then it should be marked as medium IMHO."
                    },
                    {
                        "username": "ryo-kozin",
                        "content": "I believe  an interviewer would be fine with ussing indexOf(). In real-world programming situations, it is often advisable to take full advantage of available built-in functions and libraries. "
                    },
                    {
                        "username": "labule",
                        "content": "[@Deecodes25](/Deecodes25)  Time Complexity is O(n*m). `haystack[i:j] == needle` touches `m` chars and you do this approximately `n` times."
                    },
                    {
                        "username": "youttsu",
                        "content": "true dude. it works on JS with O(m*n) time complexity though "
                    },
                    {
                        "username": "Deecodes25",
                        "content": "I solved with this approach, can anyone explain what is the Time Complexity for this - \\n```\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        i=0\\n        j=len(needle)\\n        while j<=len(haystack):\\n            if haystack[i:j] == needle:\\n                return i\\n            i+=1\\n            j+=1\\n        return -1\\n```"
                    },
                    {
                        "username": "veerashah1",
                        "content": "[@chickooo](/chickooo) Wouldn\\'t an interviewer be fine with .indexOf(), because there\\'s no reason to re-invent the wheel when there are built in functions? If they specifically ask to avoid it then I guess, but in this case they didn\\'t."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Why is using indexOf cheating? Nowhere is it stated that you shouldn\\'t use that. If they don\\'t want you to use that they should say so, or limit the time constraints to only allow O(N+M)"
                    },
                    {
                        "username": "shaan__0w0",
                        "content": "but it gets submitted by using .indexOf() in java \\n"
                    },
                    {
                        "username": "chickooo",
                        "content": "Agreed with your opinion.\\nIf you were to use just built in function like .find() or .indexOf(), then the problem wouldn\\'t be labeled **Medium**. And if you were in an interview, the interviewer would not be pleased."
                    },
                    {
                        "username": "chehsunliu",
                        "content": "I have solved this problem. However, I think it may be controversial to return index 0 when the inputs are \"A\" and \"\". In my opinion, one of the inputs is \"A\\\\0\" and the other is \"\\\\0\". Perhaps it should return index 1."
                    }
                ]
            },
            {
                "id": 1570759,
                "content": [
                    {
                        "username": "Siddharth2k007",
                        "content": "Who marked this as `Easy`? It\\'s not easy at all. Though you can easily produce O(mn) solution, it is not accepted for python. You need KMP algorithm to produce O(m + n) solution!"
                    },
                    {
                        "username": "countdankula",
                        "content": "[@chazwinter](/chazwinter) Lol. The interviewer will just kick you out if you use indexof() to solve this problem."
                    },
                    {
                        "username": "chazwinter",
                        "content": "It\\'s marked easy because the point is to teach you how to use indexOf.\\nIt\\'s only difficult when you fail to learn it lol"
                    },
                    {
                        "username": "Tulsyan_25",
                        "content": "Use sliding window, its that easy\\n"
                    },
                    {
                        "username": "dezann1990",
                        "content": "dude, it is oneliner"
                    },
                    {
                        "username": "Singh_uday99",
                        "content": "[@Anshmehta380](/Anshmehta380) But that is not the thing Leetcode trying to test;\\nIt wants us to study the working of indexOf () method"
                    },
                    {
                        "username": "Anshmehta380",
                        "content": "[@howardcho](/howardcho) Same for me in java"
                    },
                    {
                        "username": "Anshmehta380",
                        "content": "Bro just use indexOf() method i solved it in a one line code lol"
                    },
                    {
                        "username": "charonme",
                        "content": "tha naive O(n^2) solution is now being accepted, but if the testcases contained enough tests with long enough strings it would give a TLE"
                    },
                    {
                        "username": "aalmos",
                        "content": "[@Mister_CK](/Mister_CK) good luck with doing that on an interview bro. "
                    },
                    {
                        "username": "howardcho",
                        "content": "I\\'m not sure if there\\'s a better way, but this was a one-line solution for me in python."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "?! This is one of the easiest problems on the site, a.indexOf(b) satisfies all requirements (O(mn) time complexity I believe), at least in JS. took me 37 seconds, beats 87%"
                    },
                    {
                        "username": "gurpreetsingh8",
                        "content": "[@jdipirro](/jdipirro) exactly, this is just solved in O(N). I am wondering why it is medium"
                    },
                    {
                        "username": "calm27",
                        "content": "Python3 `O(mn)` is acceptable. "
                    },
                    {
                        "username": "pieceofpie",
                        "content": "It is now a ```Medium``` problem."
                    },
                    {
                        "username": "jdipirro",
                        "content": "Is this answer not valid for some reason?  They remarked it medium, but it can be solved with the super easy method below\\n\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n\\n        for x in range(len(haystack)):\\n            if haystack[lx : x + len(needle)] == needle:\\n                return x\\n        else:\\n            return -1"
                    },
                    {
                        "username": "narayan48",
                        "content": "class Solution {\\n    public int strStr(String haystack, String needle) {\\n          int indexOfSubStr = haystack.indexOf(needle);\\n          return indexOfSubStr;\\n\\n    }\\n    //return -1;\\n}"
                    },
                    {
                        "username": "sayedHANEEF",
                        "content": "dude it is a one line solution in java and it takes 0ms to run"
                    },
                    {
                        "username": "SugerSu",
                        "content": "Maybe sometimes we do not need to think too much!\\n\\npublic int strStr(String haystack, String needle) {\\n\\n\\t\\t\\n\\t\\treturn haystack.indexOf(needle);\\n\\t}"
                    },
                    {
                        "username": "coveyjorjet",
                        "content": "similarly you can use find() function in c++\\n```\\nreturn haystack.find(needle);\\n```"
                    },
                    {
                        "username": "enkil2003",
                        "content": "and that is how you never get a job."
                    },
                    {
                        "username": "hippofaris",
                        "content": "giga chad"
                    },
                    {
                        "username": "qAxP4Mw",
                        "content": "[@Meerkats1999](/Meerkats1999) however if your coworker reimplemented indexOf on a project everyone would be pretty annoyed so I think interviewer should accept this answer. Otherwise they should be more clear about what they\\'re looking for."
                    },
                    {
                        "username": "yuangaonyc",
                        "content": "Maybe you should think more"
                    },
                    {
                        "username": "chazwinter",
                        "content": "Don\\'t provide solutions, no matter how easy you think they are.\\nThis answer uses built in Java functionality without imports, so it\\'s fair game. If they wanted you to design your own indexOf method, they would have said so. \\n\\nThere are other problems that specifically say to avoid certain methods, or ask a follow to challenge you to try it another way. This one does not have that, so I see it as an attempt to expose new people to indexOf."
                    },
                    {
                        "username": "dantruongdo3",
                        "content": "[@Meerkats1999](/Meerkats1999) i use the exact same way and feel kinda guilty."
                    },
                    {
                        "username": "Meerkats1999",
                        "content": "I don\\'t think the interviewer will like this answer."
                    },
                    {
                        "username": "emcc1990",
                        "content": "I also submitted this but having doubts of whether the whole point is not to use it and implement something raw. "
                    },
                    {
                        "username": "user0566A",
                        "content": "It\\'s interesting that java indexOf do not use KMP (because of memory I think) or Rabin-Karp (don\\'t know why)\\nhttps://github.com/AdoptOpenJDK/openjdk-jdk11/blob/master/src/java.base/share/classes/java/lang/StringLatin1.java#L233-L253"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@therishuraj](/therishuraj) My indexOf solution beats 91%... It\\'s definitely fast enough and thus I strongly feel this should be easy. Otherwise LeetCode should drastically limit the time-constraints in my opinion"
                    },
                    {
                        "username": "user0743xF",
                        "content": "[@mohan9814](/mohan9814) because here people are coming to learn algorithms i think :)"
                    },
                    {
                        "username": "therishuraj",
                        "content": "[@mohan9814](/mohan9814)  Because time complexity of the KMP algorithm is O(m+n) And time complexity of the indexOf method is O(nm). "
                    },
                    {
                        "username": "mohan9814",
                        "content": "yes same logic in c++ is working fine why do i need to get into kmp and all this"
                    },
                    {
                        "username": "mgoldenbe",
                        "content": "I don\\'t think they meant that I can call a library function. Also, I get \"Time Limit Exceeded\" on brute-force. So, this means I should use an advanced algorithm, like Rabin-Karp or KMP. Why then is this problem marked \"easy\"?"
                    },
                    {
                        "username": "chazwinter",
                        "content": "It\\'s easy because the point is to teach you to 1) stop overthinking things, and 2) learn one single function that solves the problem in one line."
                    },
                    {
                        "username": "C0de_bumstead",
                        "content": "Can be easily solved using sliding window duhh...."
                    },
                    {
                        "username": "mikael6767",
                        "content": "Why should it be marked ```Medium```. This is literally 1line of code or 28 symbols(I\\'m counting the ```return``` function). You don\\'t need any algorithm. You need one function (if you use python3). And that function starts of the letter \"f\""
                    },
                    {
                        "username": "2020uch0017",
                        "content": "it is medium now and yes it is a KMP  problem"
                    },
                    {
                        "username": "jarc",
                        "content": " Is it the standard string matching problem? Am I wrong?"
                    },
                    {
                        "username": "chickooo",
                        "content": "Yeah, this is the standard string matching problem.\\nYour function should perform same as **.find()** function in python OR **.indexOf()** function in javascript"
                    },
                    {
                        "username": "tlong1299",
                        "content": "**USE FIND**\\nAs a Python programmer, refusing to use core language features is akin to using a hammer instead of nail-gun because it makes you a \"better\" carpenter. Remember that this is Python not C. Python\\'s PEP 20 states, \"There should be one-- and preferably only one --obvious way to do it.\" I would call a string operation built into python designed to solve this particular problem the obvious way to do it.\\n\\n**DON\\'T USE FIND**\\nIf you go into an interview and solve this problem with the find() function, you better know how it works underneath, and you should be prepared to defend your use of it. After all nothing is \"free\" in your code, and even \"magic\" functions have a time and memory cost associated with them. Knowing what this cost is, and why it is the way it is will make you a better programmer. Implementing the function yourself, at least once, can really help you develop a better appreciation for the language."
                    },
                    {
                        "username": "chazwinter",
                        "content": "Finally, a Python programmer that isn\\'t an idiot. It\\'s wild how people overthink this problem."
                    },
                    {
                        "username": "marten2",
                        "content": "Hey,\\n\\nI wouldn't say that coming up with the KMP algorithm from scratch is easy ~1 hour time. Did companies that asked this question expect applicants to know KMP by heart? Did they expect the applicant to show a naive implementation? Any opinion on this?\\n\\nBest,\\n\\nMarten"
                    },
                    {
                        "username": "syfo_dias",
                        "content": "[@chazwinter](/chazwinter) is it Python specific task? Or what is indexOf in C++? "
                    },
                    {
                        "username": "chazwinter",
                        "content": "No, they expected you to know indexOf. Don\\'t overthink it."
                    },
                    {
                        "username": "zijianz",
                        "content": "Input: \\t\"\", \"\"\\nOutput: \\t-1\\nExpected: \\t0\\n\\nBasically there is nothing in the string, how do you get the index.\\n\\nIf this test case is valid, then needle =\"\", haystack=\"anything\" could return any value. since empty is everywhere."
                    },
                    {
                        "username": "chazwinter",
                        "content": "Read the constraints. If you had to deal with an empty string, you would simply write an edge case for it."
                    },
                    {
                        "username": "mansourcodes",
                        "content": "1 <= haystack.length, needle.length <= 104\\n"
                    },
                    {
                        "username": "cxaviousb",
                        "content": "> In a string, the last element is null character. In the first case, where it is \"\",\"\" both of them has same character that is null character, while in \"\",\"anything\" the first string has null character at 0 index while the next one has 'a' at 0 index.\n\n[@AvniGoyal22](/AvniGoyal22) That's programming language specific logic.  Let's try applying logic from JavaScript to this problem~\n\n```javascript\n> 'anything'.indexOf('')\n< 0\n> ''.charAt(0)\n< \"\"\n> ''.charAt(9001)\n< \"\"\n> 'anything'.lastIndexOf('')\n< 8\n< \"anything\"\n> 'anything'.substr(0,9)\n< \"anything\"\n> 'anything'.substr(9001,9)\n< \"\"\n```"
                    },
                    {
                        "username": "shaan__0w0",
                        "content": "i think you have to make the case of if the string is empty"
                    },
                    {
                        "username": "AvniGoyal22",
                        "content": "In a string, the last element is null character. In the first case, where it is \"\",\"\" both of them has same character that is null character, while in \"\",\"anything\" the first string has null character at 0 index while the next one has \\'a\\' at 0 index. "
                    },
                    {
                        "username": "SarK97",
                        "content": "Why this test case is returning -1? Shouldn\\'t it be 4 since it is a substring?\\n\"mississippi\"\\n\"issip\""
                    },
                    {
                        "username": "impatientcat07",
                        "content": "Here comes the Overlapping case while comparing \"issis\" -> \"issip\" it rejects and reinitializes and starts from \"sippi\" & \\n comparing \"issip\", which in turns return -1; "
                    },
                    {
                        "username": "flyingfist",
                        "content": "its because it is taking issis (index 1 to 5) as index 5 is not matching it goes further and doesnt get issip "
                    },
                    {
                        "username": "MaheshPatil19",
                        "content": "here needle =\"issipi\""
                    },
                    {
                        "username": "chickooo",
                        "content": "If you add this test case ( I just did ), the output is 4 as expected.\\nDon\\'t know why you are getting -1. \\nMaybe there were unwanted spaces in your input. Can you try that again?"
                    },
                    {
                        "username": "trpaslik",
                        "content": "Most of python submissions are based on cheating (s.index() or s.find()).\\nIt is a pitty that when implementing it in pure python (the naive `O(n*m)` way) it results in timeout.\\nIt should either be accepted for `O(n*m)` or if some better approach is expected like with a rolling hash then it should be marked as medium IMHO."
                    },
                    {
                        "username": "ryo-kozin",
                        "content": "I believe  an interviewer would be fine with ussing indexOf(). In real-world programming situations, it is often advisable to take full advantage of available built-in functions and libraries. "
                    },
                    {
                        "username": "labule",
                        "content": "[@Deecodes25](/Deecodes25)  Time Complexity is O(n*m). `haystack[i:j] == needle` touches `m` chars and you do this approximately `n` times."
                    },
                    {
                        "username": "youttsu",
                        "content": "true dude. it works on JS with O(m*n) time complexity though "
                    },
                    {
                        "username": "Deecodes25",
                        "content": "I solved with this approach, can anyone explain what is the Time Complexity for this - \\n```\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        i=0\\n        j=len(needle)\\n        while j<=len(haystack):\\n            if haystack[i:j] == needle:\\n                return i\\n            i+=1\\n            j+=1\\n        return -1\\n```"
                    },
                    {
                        "username": "veerashah1",
                        "content": "[@chickooo](/chickooo) Wouldn\\'t an interviewer be fine with .indexOf(), because there\\'s no reason to re-invent the wheel when there are built in functions? If they specifically ask to avoid it then I guess, but in this case they didn\\'t."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Why is using indexOf cheating? Nowhere is it stated that you shouldn\\'t use that. If they don\\'t want you to use that they should say so, or limit the time constraints to only allow O(N+M)"
                    },
                    {
                        "username": "shaan__0w0",
                        "content": "but it gets submitted by using .indexOf() in java \\n"
                    },
                    {
                        "username": "chickooo",
                        "content": "Agreed with your opinion.\\nIf you were to use just built in function like .find() or .indexOf(), then the problem wouldn\\'t be labeled **Medium**. And if you were in an interview, the interviewer would not be pleased."
                    },
                    {
                        "username": "chehsunliu",
                        "content": "I have solved this problem. However, I think it may be controversial to return index 0 when the inputs are \"A\" and \"\". In my opinion, one of the inputs is \"A\\\\0\" and the other is \"\\\\0\". Perhaps it should return index 1."
                    }
                ]
            },
            {
                "id": 1567172,
                "content": [
                    {
                        "username": "Siddharth2k007",
                        "content": "Who marked this as `Easy`? It\\'s not easy at all. Though you can easily produce O(mn) solution, it is not accepted for python. You need KMP algorithm to produce O(m + n) solution!"
                    },
                    {
                        "username": "countdankula",
                        "content": "[@chazwinter](/chazwinter) Lol. The interviewer will just kick you out if you use indexof() to solve this problem."
                    },
                    {
                        "username": "chazwinter",
                        "content": "It\\'s marked easy because the point is to teach you how to use indexOf.\\nIt\\'s only difficult when you fail to learn it lol"
                    },
                    {
                        "username": "Tulsyan_25",
                        "content": "Use sliding window, its that easy\\n"
                    },
                    {
                        "username": "dezann1990",
                        "content": "dude, it is oneliner"
                    },
                    {
                        "username": "Singh_uday99",
                        "content": "[@Anshmehta380](/Anshmehta380) But that is not the thing Leetcode trying to test;\\nIt wants us to study the working of indexOf () method"
                    },
                    {
                        "username": "Anshmehta380",
                        "content": "[@howardcho](/howardcho) Same for me in java"
                    },
                    {
                        "username": "Anshmehta380",
                        "content": "Bro just use indexOf() method i solved it in a one line code lol"
                    },
                    {
                        "username": "charonme",
                        "content": "tha naive O(n^2) solution is now being accepted, but if the testcases contained enough tests with long enough strings it would give a TLE"
                    },
                    {
                        "username": "aalmos",
                        "content": "[@Mister_CK](/Mister_CK) good luck with doing that on an interview bro. "
                    },
                    {
                        "username": "howardcho",
                        "content": "I\\'m not sure if there\\'s a better way, but this was a one-line solution for me in python."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "?! This is one of the easiest problems on the site, a.indexOf(b) satisfies all requirements (O(mn) time complexity I believe), at least in JS. took me 37 seconds, beats 87%"
                    },
                    {
                        "username": "gurpreetsingh8",
                        "content": "[@jdipirro](/jdipirro) exactly, this is just solved in O(N). I am wondering why it is medium"
                    },
                    {
                        "username": "calm27",
                        "content": "Python3 `O(mn)` is acceptable. "
                    },
                    {
                        "username": "pieceofpie",
                        "content": "It is now a ```Medium``` problem."
                    },
                    {
                        "username": "jdipirro",
                        "content": "Is this answer not valid for some reason?  They remarked it medium, but it can be solved with the super easy method below\\n\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n\\n        for x in range(len(haystack)):\\n            if haystack[lx : x + len(needle)] == needle:\\n                return x\\n        else:\\n            return -1"
                    },
                    {
                        "username": "narayan48",
                        "content": "class Solution {\\n    public int strStr(String haystack, String needle) {\\n          int indexOfSubStr = haystack.indexOf(needle);\\n          return indexOfSubStr;\\n\\n    }\\n    //return -1;\\n}"
                    },
                    {
                        "username": "sayedHANEEF",
                        "content": "dude it is a one line solution in java and it takes 0ms to run"
                    },
                    {
                        "username": "SugerSu",
                        "content": "Maybe sometimes we do not need to think too much!\\n\\npublic int strStr(String haystack, String needle) {\\n\\n\\t\\t\\n\\t\\treturn haystack.indexOf(needle);\\n\\t}"
                    },
                    {
                        "username": "coveyjorjet",
                        "content": "similarly you can use find() function in c++\\n```\\nreturn haystack.find(needle);\\n```"
                    },
                    {
                        "username": "enkil2003",
                        "content": "and that is how you never get a job."
                    },
                    {
                        "username": "hippofaris",
                        "content": "giga chad"
                    },
                    {
                        "username": "qAxP4Mw",
                        "content": "[@Meerkats1999](/Meerkats1999) however if your coworker reimplemented indexOf on a project everyone would be pretty annoyed so I think interviewer should accept this answer. Otherwise they should be more clear about what they\\'re looking for."
                    },
                    {
                        "username": "yuangaonyc",
                        "content": "Maybe you should think more"
                    },
                    {
                        "username": "chazwinter",
                        "content": "Don\\'t provide solutions, no matter how easy you think they are.\\nThis answer uses built in Java functionality without imports, so it\\'s fair game. If they wanted you to design your own indexOf method, they would have said so. \\n\\nThere are other problems that specifically say to avoid certain methods, or ask a follow to challenge you to try it another way. This one does not have that, so I see it as an attempt to expose new people to indexOf."
                    },
                    {
                        "username": "dantruongdo3",
                        "content": "[@Meerkats1999](/Meerkats1999) i use the exact same way and feel kinda guilty."
                    },
                    {
                        "username": "Meerkats1999",
                        "content": "I don\\'t think the interviewer will like this answer."
                    },
                    {
                        "username": "emcc1990",
                        "content": "I also submitted this but having doubts of whether the whole point is not to use it and implement something raw. "
                    },
                    {
                        "username": "user0566A",
                        "content": "It\\'s interesting that java indexOf do not use KMP (because of memory I think) or Rabin-Karp (don\\'t know why)\\nhttps://github.com/AdoptOpenJDK/openjdk-jdk11/blob/master/src/java.base/share/classes/java/lang/StringLatin1.java#L233-L253"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@therishuraj](/therishuraj) My indexOf solution beats 91%... It\\'s definitely fast enough and thus I strongly feel this should be easy. Otherwise LeetCode should drastically limit the time-constraints in my opinion"
                    },
                    {
                        "username": "user0743xF",
                        "content": "[@mohan9814](/mohan9814) because here people are coming to learn algorithms i think :)"
                    },
                    {
                        "username": "therishuraj",
                        "content": "[@mohan9814](/mohan9814)  Because time complexity of the KMP algorithm is O(m+n) And time complexity of the indexOf method is O(nm). "
                    },
                    {
                        "username": "mohan9814",
                        "content": "yes same logic in c++ is working fine why do i need to get into kmp and all this"
                    },
                    {
                        "username": "mgoldenbe",
                        "content": "I don\\'t think they meant that I can call a library function. Also, I get \"Time Limit Exceeded\" on brute-force. So, this means I should use an advanced algorithm, like Rabin-Karp or KMP. Why then is this problem marked \"easy\"?"
                    },
                    {
                        "username": "chazwinter",
                        "content": "It\\'s easy because the point is to teach you to 1) stop overthinking things, and 2) learn one single function that solves the problem in one line."
                    },
                    {
                        "username": "C0de_bumstead",
                        "content": "Can be easily solved using sliding window duhh...."
                    },
                    {
                        "username": "mikael6767",
                        "content": "Why should it be marked ```Medium```. This is literally 1line of code or 28 symbols(I\\'m counting the ```return``` function). You don\\'t need any algorithm. You need one function (if you use python3). And that function starts of the letter \"f\""
                    },
                    {
                        "username": "2020uch0017",
                        "content": "it is medium now and yes it is a KMP  problem"
                    },
                    {
                        "username": "jarc",
                        "content": " Is it the standard string matching problem? Am I wrong?"
                    },
                    {
                        "username": "chickooo",
                        "content": "Yeah, this is the standard string matching problem.\\nYour function should perform same as **.find()** function in python OR **.indexOf()** function in javascript"
                    },
                    {
                        "username": "tlong1299",
                        "content": "**USE FIND**\\nAs a Python programmer, refusing to use core language features is akin to using a hammer instead of nail-gun because it makes you a \"better\" carpenter. Remember that this is Python not C. Python\\'s PEP 20 states, \"There should be one-- and preferably only one --obvious way to do it.\" I would call a string operation built into python designed to solve this particular problem the obvious way to do it.\\n\\n**DON\\'T USE FIND**\\nIf you go into an interview and solve this problem with the find() function, you better know how it works underneath, and you should be prepared to defend your use of it. After all nothing is \"free\" in your code, and even \"magic\" functions have a time and memory cost associated with them. Knowing what this cost is, and why it is the way it is will make you a better programmer. Implementing the function yourself, at least once, can really help you develop a better appreciation for the language."
                    },
                    {
                        "username": "chazwinter",
                        "content": "Finally, a Python programmer that isn\\'t an idiot. It\\'s wild how people overthink this problem."
                    },
                    {
                        "username": "marten2",
                        "content": "Hey,\\n\\nI wouldn't say that coming up with the KMP algorithm from scratch is easy ~1 hour time. Did companies that asked this question expect applicants to know KMP by heart? Did they expect the applicant to show a naive implementation? Any opinion on this?\\n\\nBest,\\n\\nMarten"
                    },
                    {
                        "username": "syfo_dias",
                        "content": "[@chazwinter](/chazwinter) is it Python specific task? Or what is indexOf in C++? "
                    },
                    {
                        "username": "chazwinter",
                        "content": "No, they expected you to know indexOf. Don\\'t overthink it."
                    },
                    {
                        "username": "zijianz",
                        "content": "Input: \\t\"\", \"\"\\nOutput: \\t-1\\nExpected: \\t0\\n\\nBasically there is nothing in the string, how do you get the index.\\n\\nIf this test case is valid, then needle =\"\", haystack=\"anything\" could return any value. since empty is everywhere."
                    },
                    {
                        "username": "chazwinter",
                        "content": "Read the constraints. If you had to deal with an empty string, you would simply write an edge case for it."
                    },
                    {
                        "username": "mansourcodes",
                        "content": "1 <= haystack.length, needle.length <= 104\\n"
                    },
                    {
                        "username": "cxaviousb",
                        "content": "> In a string, the last element is null character. In the first case, where it is \"\",\"\" both of them has same character that is null character, while in \"\",\"anything\" the first string has null character at 0 index while the next one has 'a' at 0 index.\n\n[@AvniGoyal22](/AvniGoyal22) That's programming language specific logic.  Let's try applying logic from JavaScript to this problem~\n\n```javascript\n> 'anything'.indexOf('')\n< 0\n> ''.charAt(0)\n< \"\"\n> ''.charAt(9001)\n< \"\"\n> 'anything'.lastIndexOf('')\n< 8\n< \"anything\"\n> 'anything'.substr(0,9)\n< \"anything\"\n> 'anything'.substr(9001,9)\n< \"\"\n```"
                    },
                    {
                        "username": "shaan__0w0",
                        "content": "i think you have to make the case of if the string is empty"
                    },
                    {
                        "username": "AvniGoyal22",
                        "content": "In a string, the last element is null character. In the first case, where it is \"\",\"\" both of them has same character that is null character, while in \"\",\"anything\" the first string has null character at 0 index while the next one has \\'a\\' at 0 index. "
                    },
                    {
                        "username": "SarK97",
                        "content": "Why this test case is returning -1? Shouldn\\'t it be 4 since it is a substring?\\n\"mississippi\"\\n\"issip\""
                    },
                    {
                        "username": "impatientcat07",
                        "content": "Here comes the Overlapping case while comparing \"issis\" -> \"issip\" it rejects and reinitializes and starts from \"sippi\" & \\n comparing \"issip\", which in turns return -1; "
                    },
                    {
                        "username": "flyingfist",
                        "content": "its because it is taking issis (index 1 to 5) as index 5 is not matching it goes further and doesnt get issip "
                    },
                    {
                        "username": "MaheshPatil19",
                        "content": "here needle =\"issipi\""
                    },
                    {
                        "username": "chickooo",
                        "content": "If you add this test case ( I just did ), the output is 4 as expected.\\nDon\\'t know why you are getting -1. \\nMaybe there were unwanted spaces in your input. Can you try that again?"
                    },
                    {
                        "username": "trpaslik",
                        "content": "Most of python submissions are based on cheating (s.index() or s.find()).\\nIt is a pitty that when implementing it in pure python (the naive `O(n*m)` way) it results in timeout.\\nIt should either be accepted for `O(n*m)` or if some better approach is expected like with a rolling hash then it should be marked as medium IMHO."
                    },
                    {
                        "username": "ryo-kozin",
                        "content": "I believe  an interviewer would be fine with ussing indexOf(). In real-world programming situations, it is often advisable to take full advantage of available built-in functions and libraries. "
                    },
                    {
                        "username": "labule",
                        "content": "[@Deecodes25](/Deecodes25)  Time Complexity is O(n*m). `haystack[i:j] == needle` touches `m` chars and you do this approximately `n` times."
                    },
                    {
                        "username": "youttsu",
                        "content": "true dude. it works on JS with O(m*n) time complexity though "
                    },
                    {
                        "username": "Deecodes25",
                        "content": "I solved with this approach, can anyone explain what is the Time Complexity for this - \\n```\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        i=0\\n        j=len(needle)\\n        while j<=len(haystack):\\n            if haystack[i:j] == needle:\\n                return i\\n            i+=1\\n            j+=1\\n        return -1\\n```"
                    },
                    {
                        "username": "veerashah1",
                        "content": "[@chickooo](/chickooo) Wouldn\\'t an interviewer be fine with .indexOf(), because there\\'s no reason to re-invent the wheel when there are built in functions? If they specifically ask to avoid it then I guess, but in this case they didn\\'t."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Why is using indexOf cheating? Nowhere is it stated that you shouldn\\'t use that. If they don\\'t want you to use that they should say so, or limit the time constraints to only allow O(N+M)"
                    },
                    {
                        "username": "shaan__0w0",
                        "content": "but it gets submitted by using .indexOf() in java \\n"
                    },
                    {
                        "username": "chickooo",
                        "content": "Agreed with your opinion.\\nIf you were to use just built in function like .find() or .indexOf(), then the problem wouldn\\'t be labeled **Medium**. And if you were in an interview, the interviewer would not be pleased."
                    },
                    {
                        "username": "chehsunliu",
                        "content": "I have solved this problem. However, I think it may be controversial to return index 0 when the inputs are \"A\" and \"\". In my opinion, one of the inputs is \"A\\\\0\" and the other is \"\\\\0\". Perhaps it should return index 1."
                    }
                ]
            },
            {
                "id": 1564985,
                "content": [
                    {
                        "username": "Siddharth2k007",
                        "content": "Who marked this as `Easy`? It\\'s not easy at all. Though you can easily produce O(mn) solution, it is not accepted for python. You need KMP algorithm to produce O(m + n) solution!"
                    },
                    {
                        "username": "countdankula",
                        "content": "[@chazwinter](/chazwinter) Lol. The interviewer will just kick you out if you use indexof() to solve this problem."
                    },
                    {
                        "username": "chazwinter",
                        "content": "It\\'s marked easy because the point is to teach you how to use indexOf.\\nIt\\'s only difficult when you fail to learn it lol"
                    },
                    {
                        "username": "Tulsyan_25",
                        "content": "Use sliding window, its that easy\\n"
                    },
                    {
                        "username": "dezann1990",
                        "content": "dude, it is oneliner"
                    },
                    {
                        "username": "Singh_uday99",
                        "content": "[@Anshmehta380](/Anshmehta380) But that is not the thing Leetcode trying to test;\\nIt wants us to study the working of indexOf () method"
                    },
                    {
                        "username": "Anshmehta380",
                        "content": "[@howardcho](/howardcho) Same for me in java"
                    },
                    {
                        "username": "Anshmehta380",
                        "content": "Bro just use indexOf() method i solved it in a one line code lol"
                    },
                    {
                        "username": "charonme",
                        "content": "tha naive O(n^2) solution is now being accepted, but if the testcases contained enough tests with long enough strings it would give a TLE"
                    },
                    {
                        "username": "aalmos",
                        "content": "[@Mister_CK](/Mister_CK) good luck with doing that on an interview bro. "
                    },
                    {
                        "username": "howardcho",
                        "content": "I\\'m not sure if there\\'s a better way, but this was a one-line solution for me in python."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "?! This is one of the easiest problems on the site, a.indexOf(b) satisfies all requirements (O(mn) time complexity I believe), at least in JS. took me 37 seconds, beats 87%"
                    },
                    {
                        "username": "gurpreetsingh8",
                        "content": "[@jdipirro](/jdipirro) exactly, this is just solved in O(N). I am wondering why it is medium"
                    },
                    {
                        "username": "calm27",
                        "content": "Python3 `O(mn)` is acceptable. "
                    },
                    {
                        "username": "pieceofpie",
                        "content": "It is now a ```Medium``` problem."
                    },
                    {
                        "username": "jdipirro",
                        "content": "Is this answer not valid for some reason?  They remarked it medium, but it can be solved with the super easy method below\\n\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n\\n        for x in range(len(haystack)):\\n            if haystack[lx : x + len(needle)] == needle:\\n                return x\\n        else:\\n            return -1"
                    },
                    {
                        "username": "narayan48",
                        "content": "class Solution {\\n    public int strStr(String haystack, String needle) {\\n          int indexOfSubStr = haystack.indexOf(needle);\\n          return indexOfSubStr;\\n\\n    }\\n    //return -1;\\n}"
                    },
                    {
                        "username": "sayedHANEEF",
                        "content": "dude it is a one line solution in java and it takes 0ms to run"
                    },
                    {
                        "username": "SugerSu",
                        "content": "Maybe sometimes we do not need to think too much!\\n\\npublic int strStr(String haystack, String needle) {\\n\\n\\t\\t\\n\\t\\treturn haystack.indexOf(needle);\\n\\t}"
                    },
                    {
                        "username": "coveyjorjet",
                        "content": "similarly you can use find() function in c++\\n```\\nreturn haystack.find(needle);\\n```"
                    },
                    {
                        "username": "enkil2003",
                        "content": "and that is how you never get a job."
                    },
                    {
                        "username": "hippofaris",
                        "content": "giga chad"
                    },
                    {
                        "username": "qAxP4Mw",
                        "content": "[@Meerkats1999](/Meerkats1999) however if your coworker reimplemented indexOf on a project everyone would be pretty annoyed so I think interviewer should accept this answer. Otherwise they should be more clear about what they\\'re looking for."
                    },
                    {
                        "username": "yuangaonyc",
                        "content": "Maybe you should think more"
                    },
                    {
                        "username": "chazwinter",
                        "content": "Don\\'t provide solutions, no matter how easy you think they are.\\nThis answer uses built in Java functionality without imports, so it\\'s fair game. If they wanted you to design your own indexOf method, they would have said so. \\n\\nThere are other problems that specifically say to avoid certain methods, or ask a follow to challenge you to try it another way. This one does not have that, so I see it as an attempt to expose new people to indexOf."
                    },
                    {
                        "username": "dantruongdo3",
                        "content": "[@Meerkats1999](/Meerkats1999) i use the exact same way and feel kinda guilty."
                    },
                    {
                        "username": "Meerkats1999",
                        "content": "I don\\'t think the interviewer will like this answer."
                    },
                    {
                        "username": "emcc1990",
                        "content": "I also submitted this but having doubts of whether the whole point is not to use it and implement something raw. "
                    },
                    {
                        "username": "user0566A",
                        "content": "It\\'s interesting that java indexOf do not use KMP (because of memory I think) or Rabin-Karp (don\\'t know why)\\nhttps://github.com/AdoptOpenJDK/openjdk-jdk11/blob/master/src/java.base/share/classes/java/lang/StringLatin1.java#L233-L253"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@therishuraj](/therishuraj) My indexOf solution beats 91%... It\\'s definitely fast enough and thus I strongly feel this should be easy. Otherwise LeetCode should drastically limit the time-constraints in my opinion"
                    },
                    {
                        "username": "user0743xF",
                        "content": "[@mohan9814](/mohan9814) because here people are coming to learn algorithms i think :)"
                    },
                    {
                        "username": "therishuraj",
                        "content": "[@mohan9814](/mohan9814)  Because time complexity of the KMP algorithm is O(m+n) And time complexity of the indexOf method is O(nm). "
                    },
                    {
                        "username": "mohan9814",
                        "content": "yes same logic in c++ is working fine why do i need to get into kmp and all this"
                    },
                    {
                        "username": "mgoldenbe",
                        "content": "I don\\'t think they meant that I can call a library function. Also, I get \"Time Limit Exceeded\" on brute-force. So, this means I should use an advanced algorithm, like Rabin-Karp or KMP. Why then is this problem marked \"easy\"?"
                    },
                    {
                        "username": "chazwinter",
                        "content": "It\\'s easy because the point is to teach you to 1) stop overthinking things, and 2) learn one single function that solves the problem in one line."
                    },
                    {
                        "username": "C0de_bumstead",
                        "content": "Can be easily solved using sliding window duhh...."
                    },
                    {
                        "username": "mikael6767",
                        "content": "Why should it be marked ```Medium```. This is literally 1line of code or 28 symbols(I\\'m counting the ```return``` function). You don\\'t need any algorithm. You need one function (if you use python3). And that function starts of the letter \"f\""
                    },
                    {
                        "username": "2020uch0017",
                        "content": "it is medium now and yes it is a KMP  problem"
                    },
                    {
                        "username": "jarc",
                        "content": " Is it the standard string matching problem? Am I wrong?"
                    },
                    {
                        "username": "chickooo",
                        "content": "Yeah, this is the standard string matching problem.\\nYour function should perform same as **.find()** function in python OR **.indexOf()** function in javascript"
                    },
                    {
                        "username": "tlong1299",
                        "content": "**USE FIND**\\nAs a Python programmer, refusing to use core language features is akin to using a hammer instead of nail-gun because it makes you a \"better\" carpenter. Remember that this is Python not C. Python\\'s PEP 20 states, \"There should be one-- and preferably only one --obvious way to do it.\" I would call a string operation built into python designed to solve this particular problem the obvious way to do it.\\n\\n**DON\\'T USE FIND**\\nIf you go into an interview and solve this problem with the find() function, you better know how it works underneath, and you should be prepared to defend your use of it. After all nothing is \"free\" in your code, and even \"magic\" functions have a time and memory cost associated with them. Knowing what this cost is, and why it is the way it is will make you a better programmer. Implementing the function yourself, at least once, can really help you develop a better appreciation for the language."
                    },
                    {
                        "username": "chazwinter",
                        "content": "Finally, a Python programmer that isn\\'t an idiot. It\\'s wild how people overthink this problem."
                    },
                    {
                        "username": "marten2",
                        "content": "Hey,\\n\\nI wouldn't say that coming up with the KMP algorithm from scratch is easy ~1 hour time. Did companies that asked this question expect applicants to know KMP by heart? Did they expect the applicant to show a naive implementation? Any opinion on this?\\n\\nBest,\\n\\nMarten"
                    },
                    {
                        "username": "syfo_dias",
                        "content": "[@chazwinter](/chazwinter) is it Python specific task? Or what is indexOf in C++? "
                    },
                    {
                        "username": "chazwinter",
                        "content": "No, they expected you to know indexOf. Don\\'t overthink it."
                    },
                    {
                        "username": "zijianz",
                        "content": "Input: \\t\"\", \"\"\\nOutput: \\t-1\\nExpected: \\t0\\n\\nBasically there is nothing in the string, how do you get the index.\\n\\nIf this test case is valid, then needle =\"\", haystack=\"anything\" could return any value. since empty is everywhere."
                    },
                    {
                        "username": "chazwinter",
                        "content": "Read the constraints. If you had to deal with an empty string, you would simply write an edge case for it."
                    },
                    {
                        "username": "mansourcodes",
                        "content": "1 <= haystack.length, needle.length <= 104\\n"
                    },
                    {
                        "username": "cxaviousb",
                        "content": "> In a string, the last element is null character. In the first case, where it is \"\",\"\" both of them has same character that is null character, while in \"\",\"anything\" the first string has null character at 0 index while the next one has 'a' at 0 index.\n\n[@AvniGoyal22](/AvniGoyal22) That's programming language specific logic.  Let's try applying logic from JavaScript to this problem~\n\n```javascript\n> 'anything'.indexOf('')\n< 0\n> ''.charAt(0)\n< \"\"\n> ''.charAt(9001)\n< \"\"\n> 'anything'.lastIndexOf('')\n< 8\n< \"anything\"\n> 'anything'.substr(0,9)\n< \"anything\"\n> 'anything'.substr(9001,9)\n< \"\"\n```"
                    },
                    {
                        "username": "shaan__0w0",
                        "content": "i think you have to make the case of if the string is empty"
                    },
                    {
                        "username": "AvniGoyal22",
                        "content": "In a string, the last element is null character. In the first case, where it is \"\",\"\" both of them has same character that is null character, while in \"\",\"anything\" the first string has null character at 0 index while the next one has \\'a\\' at 0 index. "
                    },
                    {
                        "username": "SarK97",
                        "content": "Why this test case is returning -1? Shouldn\\'t it be 4 since it is a substring?\\n\"mississippi\"\\n\"issip\""
                    },
                    {
                        "username": "impatientcat07",
                        "content": "Here comes the Overlapping case while comparing \"issis\" -> \"issip\" it rejects and reinitializes and starts from \"sippi\" & \\n comparing \"issip\", which in turns return -1; "
                    },
                    {
                        "username": "flyingfist",
                        "content": "its because it is taking issis (index 1 to 5) as index 5 is not matching it goes further and doesnt get issip "
                    },
                    {
                        "username": "MaheshPatil19",
                        "content": "here needle =\"issipi\""
                    },
                    {
                        "username": "chickooo",
                        "content": "If you add this test case ( I just did ), the output is 4 as expected.\\nDon\\'t know why you are getting -1. \\nMaybe there were unwanted spaces in your input. Can you try that again?"
                    },
                    {
                        "username": "trpaslik",
                        "content": "Most of python submissions are based on cheating (s.index() or s.find()).\\nIt is a pitty that when implementing it in pure python (the naive `O(n*m)` way) it results in timeout.\\nIt should either be accepted for `O(n*m)` or if some better approach is expected like with a rolling hash then it should be marked as medium IMHO."
                    },
                    {
                        "username": "ryo-kozin",
                        "content": "I believe  an interviewer would be fine with ussing indexOf(). In real-world programming situations, it is often advisable to take full advantage of available built-in functions and libraries. "
                    },
                    {
                        "username": "labule",
                        "content": "[@Deecodes25](/Deecodes25)  Time Complexity is O(n*m). `haystack[i:j] == needle` touches `m` chars and you do this approximately `n` times."
                    },
                    {
                        "username": "youttsu",
                        "content": "true dude. it works on JS with O(m*n) time complexity though "
                    },
                    {
                        "username": "Deecodes25",
                        "content": "I solved with this approach, can anyone explain what is the Time Complexity for this - \\n```\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        i=0\\n        j=len(needle)\\n        while j<=len(haystack):\\n            if haystack[i:j] == needle:\\n                return i\\n            i+=1\\n            j+=1\\n        return -1\\n```"
                    },
                    {
                        "username": "veerashah1",
                        "content": "[@chickooo](/chickooo) Wouldn\\'t an interviewer be fine with .indexOf(), because there\\'s no reason to re-invent the wheel when there are built in functions? If they specifically ask to avoid it then I guess, but in this case they didn\\'t."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Why is using indexOf cheating? Nowhere is it stated that you shouldn\\'t use that. If they don\\'t want you to use that they should say so, or limit the time constraints to only allow O(N+M)"
                    },
                    {
                        "username": "shaan__0w0",
                        "content": "but it gets submitted by using .indexOf() in java \\n"
                    },
                    {
                        "username": "chickooo",
                        "content": "Agreed with your opinion.\\nIf you were to use just built in function like .find() or .indexOf(), then the problem wouldn\\'t be labeled **Medium**. And if you were in an interview, the interviewer would not be pleased."
                    },
                    {
                        "username": "chehsunliu",
                        "content": "I have solved this problem. However, I think it may be controversial to return index 0 when the inputs are \"A\" and \"\". In my opinion, one of the inputs is \"A\\\\0\" and the other is \"\\\\0\". Perhaps it should return index 1."
                    }
                ]
            },
            {
                "id": 1575815,
                "content": [
                    {
                        "username": "Siddharth2k007",
                        "content": "Who marked this as `Easy`? It\\'s not easy at all. Though you can easily produce O(mn) solution, it is not accepted for python. You need KMP algorithm to produce O(m + n) solution!"
                    },
                    {
                        "username": "countdankula",
                        "content": "[@chazwinter](/chazwinter) Lol. The interviewer will just kick you out if you use indexof() to solve this problem."
                    },
                    {
                        "username": "chazwinter",
                        "content": "It\\'s marked easy because the point is to teach you how to use indexOf.\\nIt\\'s only difficult when you fail to learn it lol"
                    },
                    {
                        "username": "Tulsyan_25",
                        "content": "Use sliding window, its that easy\\n"
                    },
                    {
                        "username": "dezann1990",
                        "content": "dude, it is oneliner"
                    },
                    {
                        "username": "Singh_uday99",
                        "content": "[@Anshmehta380](/Anshmehta380) But that is not the thing Leetcode trying to test;\\nIt wants us to study the working of indexOf () method"
                    },
                    {
                        "username": "Anshmehta380",
                        "content": "[@howardcho](/howardcho) Same for me in java"
                    },
                    {
                        "username": "Anshmehta380",
                        "content": "Bro just use indexOf() method i solved it in a one line code lol"
                    },
                    {
                        "username": "charonme",
                        "content": "tha naive O(n^2) solution is now being accepted, but if the testcases contained enough tests with long enough strings it would give a TLE"
                    },
                    {
                        "username": "aalmos",
                        "content": "[@Mister_CK](/Mister_CK) good luck with doing that on an interview bro. "
                    },
                    {
                        "username": "howardcho",
                        "content": "I\\'m not sure if there\\'s a better way, but this was a one-line solution for me in python."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "?! This is one of the easiest problems on the site, a.indexOf(b) satisfies all requirements (O(mn) time complexity I believe), at least in JS. took me 37 seconds, beats 87%"
                    },
                    {
                        "username": "gurpreetsingh8",
                        "content": "[@jdipirro](/jdipirro) exactly, this is just solved in O(N). I am wondering why it is medium"
                    },
                    {
                        "username": "calm27",
                        "content": "Python3 `O(mn)` is acceptable. "
                    },
                    {
                        "username": "pieceofpie",
                        "content": "It is now a ```Medium``` problem."
                    },
                    {
                        "username": "jdipirro",
                        "content": "Is this answer not valid for some reason?  They remarked it medium, but it can be solved with the super easy method below\\n\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n\\n        for x in range(len(haystack)):\\n            if haystack[lx : x + len(needle)] == needle:\\n                return x\\n        else:\\n            return -1"
                    },
                    {
                        "username": "narayan48",
                        "content": "class Solution {\\n    public int strStr(String haystack, String needle) {\\n          int indexOfSubStr = haystack.indexOf(needle);\\n          return indexOfSubStr;\\n\\n    }\\n    //return -1;\\n}"
                    },
                    {
                        "username": "sayedHANEEF",
                        "content": "dude it is a one line solution in java and it takes 0ms to run"
                    },
                    {
                        "username": "SugerSu",
                        "content": "Maybe sometimes we do not need to think too much!\\n\\npublic int strStr(String haystack, String needle) {\\n\\n\\t\\t\\n\\t\\treturn haystack.indexOf(needle);\\n\\t}"
                    },
                    {
                        "username": "coveyjorjet",
                        "content": "similarly you can use find() function in c++\\n```\\nreturn haystack.find(needle);\\n```"
                    },
                    {
                        "username": "enkil2003",
                        "content": "and that is how you never get a job."
                    },
                    {
                        "username": "hippofaris",
                        "content": "giga chad"
                    },
                    {
                        "username": "qAxP4Mw",
                        "content": "[@Meerkats1999](/Meerkats1999) however if your coworker reimplemented indexOf on a project everyone would be pretty annoyed so I think interviewer should accept this answer. Otherwise they should be more clear about what they\\'re looking for."
                    },
                    {
                        "username": "yuangaonyc",
                        "content": "Maybe you should think more"
                    },
                    {
                        "username": "chazwinter",
                        "content": "Don\\'t provide solutions, no matter how easy you think they are.\\nThis answer uses built in Java functionality without imports, so it\\'s fair game. If they wanted you to design your own indexOf method, they would have said so. \\n\\nThere are other problems that specifically say to avoid certain methods, or ask a follow to challenge you to try it another way. This one does not have that, so I see it as an attempt to expose new people to indexOf."
                    },
                    {
                        "username": "dantruongdo3",
                        "content": "[@Meerkats1999](/Meerkats1999) i use the exact same way and feel kinda guilty."
                    },
                    {
                        "username": "Meerkats1999",
                        "content": "I don\\'t think the interviewer will like this answer."
                    },
                    {
                        "username": "emcc1990",
                        "content": "I also submitted this but having doubts of whether the whole point is not to use it and implement something raw. "
                    },
                    {
                        "username": "user0566A",
                        "content": "It\\'s interesting that java indexOf do not use KMP (because of memory I think) or Rabin-Karp (don\\'t know why)\\nhttps://github.com/AdoptOpenJDK/openjdk-jdk11/blob/master/src/java.base/share/classes/java/lang/StringLatin1.java#L233-L253"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@therishuraj](/therishuraj) My indexOf solution beats 91%... It\\'s definitely fast enough and thus I strongly feel this should be easy. Otherwise LeetCode should drastically limit the time-constraints in my opinion"
                    },
                    {
                        "username": "user0743xF",
                        "content": "[@mohan9814](/mohan9814) because here people are coming to learn algorithms i think :)"
                    },
                    {
                        "username": "therishuraj",
                        "content": "[@mohan9814](/mohan9814)  Because time complexity of the KMP algorithm is O(m+n) And time complexity of the indexOf method is O(nm). "
                    },
                    {
                        "username": "mohan9814",
                        "content": "yes same logic in c++ is working fine why do i need to get into kmp and all this"
                    },
                    {
                        "username": "mgoldenbe",
                        "content": "I don\\'t think they meant that I can call a library function. Also, I get \"Time Limit Exceeded\" on brute-force. So, this means I should use an advanced algorithm, like Rabin-Karp or KMP. Why then is this problem marked \"easy\"?"
                    },
                    {
                        "username": "chazwinter",
                        "content": "It\\'s easy because the point is to teach you to 1) stop overthinking things, and 2) learn one single function that solves the problem in one line."
                    },
                    {
                        "username": "C0de_bumstead",
                        "content": "Can be easily solved using sliding window duhh...."
                    },
                    {
                        "username": "mikael6767",
                        "content": "Why should it be marked ```Medium```. This is literally 1line of code or 28 symbols(I\\'m counting the ```return``` function). You don\\'t need any algorithm. You need one function (if you use python3). And that function starts of the letter \"f\""
                    },
                    {
                        "username": "2020uch0017",
                        "content": "it is medium now and yes it is a KMP  problem"
                    },
                    {
                        "username": "jarc",
                        "content": " Is it the standard string matching problem? Am I wrong?"
                    },
                    {
                        "username": "chickooo",
                        "content": "Yeah, this is the standard string matching problem.\\nYour function should perform same as **.find()** function in python OR **.indexOf()** function in javascript"
                    },
                    {
                        "username": "tlong1299",
                        "content": "**USE FIND**\\nAs a Python programmer, refusing to use core language features is akin to using a hammer instead of nail-gun because it makes you a \"better\" carpenter. Remember that this is Python not C. Python\\'s PEP 20 states, \"There should be one-- and preferably only one --obvious way to do it.\" I would call a string operation built into python designed to solve this particular problem the obvious way to do it.\\n\\n**DON\\'T USE FIND**\\nIf you go into an interview and solve this problem with the find() function, you better know how it works underneath, and you should be prepared to defend your use of it. After all nothing is \"free\" in your code, and even \"magic\" functions have a time and memory cost associated with them. Knowing what this cost is, and why it is the way it is will make you a better programmer. Implementing the function yourself, at least once, can really help you develop a better appreciation for the language."
                    },
                    {
                        "username": "chazwinter",
                        "content": "Finally, a Python programmer that isn\\'t an idiot. It\\'s wild how people overthink this problem."
                    },
                    {
                        "username": "marten2",
                        "content": "Hey,\\n\\nI wouldn't say that coming up with the KMP algorithm from scratch is easy ~1 hour time. Did companies that asked this question expect applicants to know KMP by heart? Did they expect the applicant to show a naive implementation? Any opinion on this?\\n\\nBest,\\n\\nMarten"
                    },
                    {
                        "username": "syfo_dias",
                        "content": "[@chazwinter](/chazwinter) is it Python specific task? Or what is indexOf in C++? "
                    },
                    {
                        "username": "chazwinter",
                        "content": "No, they expected you to know indexOf. Don\\'t overthink it."
                    },
                    {
                        "username": "zijianz",
                        "content": "Input: \\t\"\", \"\"\\nOutput: \\t-1\\nExpected: \\t0\\n\\nBasically there is nothing in the string, how do you get the index.\\n\\nIf this test case is valid, then needle =\"\", haystack=\"anything\" could return any value. since empty is everywhere."
                    },
                    {
                        "username": "chazwinter",
                        "content": "Read the constraints. If you had to deal with an empty string, you would simply write an edge case for it."
                    },
                    {
                        "username": "mansourcodes",
                        "content": "1 <= haystack.length, needle.length <= 104\\n"
                    },
                    {
                        "username": "cxaviousb",
                        "content": "> In a string, the last element is null character. In the first case, where it is \"\",\"\" both of them has same character that is null character, while in \"\",\"anything\" the first string has null character at 0 index while the next one has 'a' at 0 index.\n\n[@AvniGoyal22](/AvniGoyal22) That's programming language specific logic.  Let's try applying logic from JavaScript to this problem~\n\n```javascript\n> 'anything'.indexOf('')\n< 0\n> ''.charAt(0)\n< \"\"\n> ''.charAt(9001)\n< \"\"\n> 'anything'.lastIndexOf('')\n< 8\n< \"anything\"\n> 'anything'.substr(0,9)\n< \"anything\"\n> 'anything'.substr(9001,9)\n< \"\"\n```"
                    },
                    {
                        "username": "shaan__0w0",
                        "content": "i think you have to make the case of if the string is empty"
                    },
                    {
                        "username": "AvniGoyal22",
                        "content": "In a string, the last element is null character. In the first case, where it is \"\",\"\" both of them has same character that is null character, while in \"\",\"anything\" the first string has null character at 0 index while the next one has \\'a\\' at 0 index. "
                    },
                    {
                        "username": "SarK97",
                        "content": "Why this test case is returning -1? Shouldn\\'t it be 4 since it is a substring?\\n\"mississippi\"\\n\"issip\""
                    },
                    {
                        "username": "impatientcat07",
                        "content": "Here comes the Overlapping case while comparing \"issis\" -> \"issip\" it rejects and reinitializes and starts from \"sippi\" & \\n comparing \"issip\", which in turns return -1; "
                    },
                    {
                        "username": "flyingfist",
                        "content": "its because it is taking issis (index 1 to 5) as index 5 is not matching it goes further and doesnt get issip "
                    },
                    {
                        "username": "MaheshPatil19",
                        "content": "here needle =\"issipi\""
                    },
                    {
                        "username": "chickooo",
                        "content": "If you add this test case ( I just did ), the output is 4 as expected.\\nDon\\'t know why you are getting -1. \\nMaybe there were unwanted spaces in your input. Can you try that again?"
                    },
                    {
                        "username": "trpaslik",
                        "content": "Most of python submissions are based on cheating (s.index() or s.find()).\\nIt is a pitty that when implementing it in pure python (the naive `O(n*m)` way) it results in timeout.\\nIt should either be accepted for `O(n*m)` or if some better approach is expected like with a rolling hash then it should be marked as medium IMHO."
                    },
                    {
                        "username": "ryo-kozin",
                        "content": "I believe  an interviewer would be fine with ussing indexOf(). In real-world programming situations, it is often advisable to take full advantage of available built-in functions and libraries. "
                    },
                    {
                        "username": "labule",
                        "content": "[@Deecodes25](/Deecodes25)  Time Complexity is O(n*m). `haystack[i:j] == needle` touches `m` chars and you do this approximately `n` times."
                    },
                    {
                        "username": "youttsu",
                        "content": "true dude. it works on JS with O(m*n) time complexity though "
                    },
                    {
                        "username": "Deecodes25",
                        "content": "I solved with this approach, can anyone explain what is the Time Complexity for this - \\n```\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        i=0\\n        j=len(needle)\\n        while j<=len(haystack):\\n            if haystack[i:j] == needle:\\n                return i\\n            i+=1\\n            j+=1\\n        return -1\\n```"
                    },
                    {
                        "username": "veerashah1",
                        "content": "[@chickooo](/chickooo) Wouldn\\'t an interviewer be fine with .indexOf(), because there\\'s no reason to re-invent the wheel when there are built in functions? If they specifically ask to avoid it then I guess, but in this case they didn\\'t."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Why is using indexOf cheating? Nowhere is it stated that you shouldn\\'t use that. If they don\\'t want you to use that they should say so, or limit the time constraints to only allow O(N+M)"
                    },
                    {
                        "username": "shaan__0w0",
                        "content": "but it gets submitted by using .indexOf() in java \\n"
                    },
                    {
                        "username": "chickooo",
                        "content": "Agreed with your opinion.\\nIf you were to use just built in function like .find() or .indexOf(), then the problem wouldn\\'t be labeled **Medium**. And if you were in an interview, the interviewer would not be pleased."
                    },
                    {
                        "username": "chehsunliu",
                        "content": "I have solved this problem. However, I think it may be controversial to return index 0 when the inputs are \"A\" and \"\". In my opinion, one of the inputs is \"A\\\\0\" and the other is \"\\\\0\". Perhaps it should return index 1."
                    }
                ]
            },
            {
                "id": 1566693,
                "content": [
                    {
                        "username": "Siddharth2k007",
                        "content": "Who marked this as `Easy`? It\\'s not easy at all. Though you can easily produce O(mn) solution, it is not accepted for python. You need KMP algorithm to produce O(m + n) solution!"
                    },
                    {
                        "username": "countdankula",
                        "content": "[@chazwinter](/chazwinter) Lol. The interviewer will just kick you out if you use indexof() to solve this problem."
                    },
                    {
                        "username": "chazwinter",
                        "content": "It\\'s marked easy because the point is to teach you how to use indexOf.\\nIt\\'s only difficult when you fail to learn it lol"
                    },
                    {
                        "username": "Tulsyan_25",
                        "content": "Use sliding window, its that easy\\n"
                    },
                    {
                        "username": "dezann1990",
                        "content": "dude, it is oneliner"
                    },
                    {
                        "username": "Singh_uday99",
                        "content": "[@Anshmehta380](/Anshmehta380) But that is not the thing Leetcode trying to test;\\nIt wants us to study the working of indexOf () method"
                    },
                    {
                        "username": "Anshmehta380",
                        "content": "[@howardcho](/howardcho) Same for me in java"
                    },
                    {
                        "username": "Anshmehta380",
                        "content": "Bro just use indexOf() method i solved it in a one line code lol"
                    },
                    {
                        "username": "charonme",
                        "content": "tha naive O(n^2) solution is now being accepted, but if the testcases contained enough tests with long enough strings it would give a TLE"
                    },
                    {
                        "username": "aalmos",
                        "content": "[@Mister_CK](/Mister_CK) good luck with doing that on an interview bro. "
                    },
                    {
                        "username": "howardcho",
                        "content": "I\\'m not sure if there\\'s a better way, but this was a one-line solution for me in python."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "?! This is one of the easiest problems on the site, a.indexOf(b) satisfies all requirements (O(mn) time complexity I believe), at least in JS. took me 37 seconds, beats 87%"
                    },
                    {
                        "username": "gurpreetsingh8",
                        "content": "[@jdipirro](/jdipirro) exactly, this is just solved in O(N). I am wondering why it is medium"
                    },
                    {
                        "username": "calm27",
                        "content": "Python3 `O(mn)` is acceptable. "
                    },
                    {
                        "username": "pieceofpie",
                        "content": "It is now a ```Medium``` problem."
                    },
                    {
                        "username": "jdipirro",
                        "content": "Is this answer not valid for some reason?  They remarked it medium, but it can be solved with the super easy method below\\n\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n\\n        for x in range(len(haystack)):\\n            if haystack[lx : x + len(needle)] == needle:\\n                return x\\n        else:\\n            return -1"
                    },
                    {
                        "username": "narayan48",
                        "content": "class Solution {\\n    public int strStr(String haystack, String needle) {\\n          int indexOfSubStr = haystack.indexOf(needle);\\n          return indexOfSubStr;\\n\\n    }\\n    //return -1;\\n}"
                    },
                    {
                        "username": "sayedHANEEF",
                        "content": "dude it is a one line solution in java and it takes 0ms to run"
                    },
                    {
                        "username": "SugerSu",
                        "content": "Maybe sometimes we do not need to think too much!\\n\\npublic int strStr(String haystack, String needle) {\\n\\n\\t\\t\\n\\t\\treturn haystack.indexOf(needle);\\n\\t}"
                    },
                    {
                        "username": "coveyjorjet",
                        "content": "similarly you can use find() function in c++\\n```\\nreturn haystack.find(needle);\\n```"
                    },
                    {
                        "username": "enkil2003",
                        "content": "and that is how you never get a job."
                    },
                    {
                        "username": "hippofaris",
                        "content": "giga chad"
                    },
                    {
                        "username": "qAxP4Mw",
                        "content": "[@Meerkats1999](/Meerkats1999) however if your coworker reimplemented indexOf on a project everyone would be pretty annoyed so I think interviewer should accept this answer. Otherwise they should be more clear about what they\\'re looking for."
                    },
                    {
                        "username": "yuangaonyc",
                        "content": "Maybe you should think more"
                    },
                    {
                        "username": "chazwinter",
                        "content": "Don\\'t provide solutions, no matter how easy you think they are.\\nThis answer uses built in Java functionality without imports, so it\\'s fair game. If they wanted you to design your own indexOf method, they would have said so. \\n\\nThere are other problems that specifically say to avoid certain methods, or ask a follow to challenge you to try it another way. This one does not have that, so I see it as an attempt to expose new people to indexOf."
                    },
                    {
                        "username": "dantruongdo3",
                        "content": "[@Meerkats1999](/Meerkats1999) i use the exact same way and feel kinda guilty."
                    },
                    {
                        "username": "Meerkats1999",
                        "content": "I don\\'t think the interviewer will like this answer."
                    },
                    {
                        "username": "emcc1990",
                        "content": "I also submitted this but having doubts of whether the whole point is not to use it and implement something raw. "
                    },
                    {
                        "username": "user0566A",
                        "content": "It\\'s interesting that java indexOf do not use KMP (because of memory I think) or Rabin-Karp (don\\'t know why)\\nhttps://github.com/AdoptOpenJDK/openjdk-jdk11/blob/master/src/java.base/share/classes/java/lang/StringLatin1.java#L233-L253"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@therishuraj](/therishuraj) My indexOf solution beats 91%... It\\'s definitely fast enough and thus I strongly feel this should be easy. Otherwise LeetCode should drastically limit the time-constraints in my opinion"
                    },
                    {
                        "username": "user0743xF",
                        "content": "[@mohan9814](/mohan9814) because here people are coming to learn algorithms i think :)"
                    },
                    {
                        "username": "therishuraj",
                        "content": "[@mohan9814](/mohan9814)  Because time complexity of the KMP algorithm is O(m+n) And time complexity of the indexOf method is O(nm). "
                    },
                    {
                        "username": "mohan9814",
                        "content": "yes same logic in c++ is working fine why do i need to get into kmp and all this"
                    },
                    {
                        "username": "mgoldenbe",
                        "content": "I don\\'t think they meant that I can call a library function. Also, I get \"Time Limit Exceeded\" on brute-force. So, this means I should use an advanced algorithm, like Rabin-Karp or KMP. Why then is this problem marked \"easy\"?"
                    },
                    {
                        "username": "chazwinter",
                        "content": "It\\'s easy because the point is to teach you to 1) stop overthinking things, and 2) learn one single function that solves the problem in one line."
                    },
                    {
                        "username": "C0de_bumstead",
                        "content": "Can be easily solved using sliding window duhh...."
                    },
                    {
                        "username": "mikael6767",
                        "content": "Why should it be marked ```Medium```. This is literally 1line of code or 28 symbols(I\\'m counting the ```return``` function). You don\\'t need any algorithm. You need one function (if you use python3). And that function starts of the letter \"f\""
                    },
                    {
                        "username": "2020uch0017",
                        "content": "it is medium now and yes it is a KMP  problem"
                    },
                    {
                        "username": "jarc",
                        "content": " Is it the standard string matching problem? Am I wrong?"
                    },
                    {
                        "username": "chickooo",
                        "content": "Yeah, this is the standard string matching problem.\\nYour function should perform same as **.find()** function in python OR **.indexOf()** function in javascript"
                    },
                    {
                        "username": "tlong1299",
                        "content": "**USE FIND**\\nAs a Python programmer, refusing to use core language features is akin to using a hammer instead of nail-gun because it makes you a \"better\" carpenter. Remember that this is Python not C. Python\\'s PEP 20 states, \"There should be one-- and preferably only one --obvious way to do it.\" I would call a string operation built into python designed to solve this particular problem the obvious way to do it.\\n\\n**DON\\'T USE FIND**\\nIf you go into an interview and solve this problem with the find() function, you better know how it works underneath, and you should be prepared to defend your use of it. After all nothing is \"free\" in your code, and even \"magic\" functions have a time and memory cost associated with them. Knowing what this cost is, and why it is the way it is will make you a better programmer. Implementing the function yourself, at least once, can really help you develop a better appreciation for the language."
                    },
                    {
                        "username": "chazwinter",
                        "content": "Finally, a Python programmer that isn\\'t an idiot. It\\'s wild how people overthink this problem."
                    },
                    {
                        "username": "marten2",
                        "content": "Hey,\\n\\nI wouldn't say that coming up with the KMP algorithm from scratch is easy ~1 hour time. Did companies that asked this question expect applicants to know KMP by heart? Did they expect the applicant to show a naive implementation? Any opinion on this?\\n\\nBest,\\n\\nMarten"
                    },
                    {
                        "username": "syfo_dias",
                        "content": "[@chazwinter](/chazwinter) is it Python specific task? Or what is indexOf in C++? "
                    },
                    {
                        "username": "chazwinter",
                        "content": "No, they expected you to know indexOf. Don\\'t overthink it."
                    },
                    {
                        "username": "zijianz",
                        "content": "Input: \\t\"\", \"\"\\nOutput: \\t-1\\nExpected: \\t0\\n\\nBasically there is nothing in the string, how do you get the index.\\n\\nIf this test case is valid, then needle =\"\", haystack=\"anything\" could return any value. since empty is everywhere."
                    },
                    {
                        "username": "chazwinter",
                        "content": "Read the constraints. If you had to deal with an empty string, you would simply write an edge case for it."
                    },
                    {
                        "username": "mansourcodes",
                        "content": "1 <= haystack.length, needle.length <= 104\\n"
                    },
                    {
                        "username": "cxaviousb",
                        "content": "> In a string, the last element is null character. In the first case, where it is \"\",\"\" both of them has same character that is null character, while in \"\",\"anything\" the first string has null character at 0 index while the next one has 'a' at 0 index.\n\n[@AvniGoyal22](/AvniGoyal22) That's programming language specific logic.  Let's try applying logic from JavaScript to this problem~\n\n```javascript\n> 'anything'.indexOf('')\n< 0\n> ''.charAt(0)\n< \"\"\n> ''.charAt(9001)\n< \"\"\n> 'anything'.lastIndexOf('')\n< 8\n< \"anything\"\n> 'anything'.substr(0,9)\n< \"anything\"\n> 'anything'.substr(9001,9)\n< \"\"\n```"
                    },
                    {
                        "username": "shaan__0w0",
                        "content": "i think you have to make the case of if the string is empty"
                    },
                    {
                        "username": "AvniGoyal22",
                        "content": "In a string, the last element is null character. In the first case, where it is \"\",\"\" both of them has same character that is null character, while in \"\",\"anything\" the first string has null character at 0 index while the next one has \\'a\\' at 0 index. "
                    },
                    {
                        "username": "SarK97",
                        "content": "Why this test case is returning -1? Shouldn\\'t it be 4 since it is a substring?\\n\"mississippi\"\\n\"issip\""
                    },
                    {
                        "username": "impatientcat07",
                        "content": "Here comes the Overlapping case while comparing \"issis\" -> \"issip\" it rejects and reinitializes and starts from \"sippi\" & \\n comparing \"issip\", which in turns return -1; "
                    },
                    {
                        "username": "flyingfist",
                        "content": "its because it is taking issis (index 1 to 5) as index 5 is not matching it goes further and doesnt get issip "
                    },
                    {
                        "username": "MaheshPatil19",
                        "content": "here needle =\"issipi\""
                    },
                    {
                        "username": "chickooo",
                        "content": "If you add this test case ( I just did ), the output is 4 as expected.\\nDon\\'t know why you are getting -1. \\nMaybe there were unwanted spaces in your input. Can you try that again?"
                    },
                    {
                        "username": "trpaslik",
                        "content": "Most of python submissions are based on cheating (s.index() or s.find()).\\nIt is a pitty that when implementing it in pure python (the naive `O(n*m)` way) it results in timeout.\\nIt should either be accepted for `O(n*m)` or if some better approach is expected like with a rolling hash then it should be marked as medium IMHO."
                    },
                    {
                        "username": "ryo-kozin",
                        "content": "I believe  an interviewer would be fine with ussing indexOf(). In real-world programming situations, it is often advisable to take full advantage of available built-in functions and libraries. "
                    },
                    {
                        "username": "labule",
                        "content": "[@Deecodes25](/Deecodes25)  Time Complexity is O(n*m). `haystack[i:j] == needle` touches `m` chars and you do this approximately `n` times."
                    },
                    {
                        "username": "youttsu",
                        "content": "true dude. it works on JS with O(m*n) time complexity though "
                    },
                    {
                        "username": "Deecodes25",
                        "content": "I solved with this approach, can anyone explain what is the Time Complexity for this - \\n```\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        i=0\\n        j=len(needle)\\n        while j<=len(haystack):\\n            if haystack[i:j] == needle:\\n                return i\\n            i+=1\\n            j+=1\\n        return -1\\n```"
                    },
                    {
                        "username": "veerashah1",
                        "content": "[@chickooo](/chickooo) Wouldn\\'t an interviewer be fine with .indexOf(), because there\\'s no reason to re-invent the wheel when there are built in functions? If they specifically ask to avoid it then I guess, but in this case they didn\\'t."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Why is using indexOf cheating? Nowhere is it stated that you shouldn\\'t use that. If they don\\'t want you to use that they should say so, or limit the time constraints to only allow O(N+M)"
                    },
                    {
                        "username": "shaan__0w0",
                        "content": "but it gets submitted by using .indexOf() in java \\n"
                    },
                    {
                        "username": "chickooo",
                        "content": "Agreed with your opinion.\\nIf you were to use just built in function like .find() or .indexOf(), then the problem wouldn\\'t be labeled **Medium**. And if you were in an interview, the interviewer would not be pleased."
                    },
                    {
                        "username": "chehsunliu",
                        "content": "I have solved this problem. However, I think it may be controversial to return index 0 when the inputs are \"A\" and \"\". In my opinion, one of the inputs is \"A\\\\0\" and the other is \"\\\\0\". Perhaps it should return index 1."
                    }
                ]
            },
            {
                "id": 1566235,
                "content": [
                    {
                        "username": "Siddharth2k007",
                        "content": "Who marked this as `Easy`? It\\'s not easy at all. Though you can easily produce O(mn) solution, it is not accepted for python. You need KMP algorithm to produce O(m + n) solution!"
                    },
                    {
                        "username": "countdankula",
                        "content": "[@chazwinter](/chazwinter) Lol. The interviewer will just kick you out if you use indexof() to solve this problem."
                    },
                    {
                        "username": "chazwinter",
                        "content": "It\\'s marked easy because the point is to teach you how to use indexOf.\\nIt\\'s only difficult when you fail to learn it lol"
                    },
                    {
                        "username": "Tulsyan_25",
                        "content": "Use sliding window, its that easy\\n"
                    },
                    {
                        "username": "dezann1990",
                        "content": "dude, it is oneliner"
                    },
                    {
                        "username": "Singh_uday99",
                        "content": "[@Anshmehta380](/Anshmehta380) But that is not the thing Leetcode trying to test;\\nIt wants us to study the working of indexOf () method"
                    },
                    {
                        "username": "Anshmehta380",
                        "content": "[@howardcho](/howardcho) Same for me in java"
                    },
                    {
                        "username": "Anshmehta380",
                        "content": "Bro just use indexOf() method i solved it in a one line code lol"
                    },
                    {
                        "username": "charonme",
                        "content": "tha naive O(n^2) solution is now being accepted, but if the testcases contained enough tests with long enough strings it would give a TLE"
                    },
                    {
                        "username": "aalmos",
                        "content": "[@Mister_CK](/Mister_CK) good luck with doing that on an interview bro. "
                    },
                    {
                        "username": "howardcho",
                        "content": "I\\'m not sure if there\\'s a better way, but this was a one-line solution for me in python."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "?! This is one of the easiest problems on the site, a.indexOf(b) satisfies all requirements (O(mn) time complexity I believe), at least in JS. took me 37 seconds, beats 87%"
                    },
                    {
                        "username": "gurpreetsingh8",
                        "content": "[@jdipirro](/jdipirro) exactly, this is just solved in O(N). I am wondering why it is medium"
                    },
                    {
                        "username": "calm27",
                        "content": "Python3 `O(mn)` is acceptable. "
                    },
                    {
                        "username": "pieceofpie",
                        "content": "It is now a ```Medium``` problem."
                    },
                    {
                        "username": "jdipirro",
                        "content": "Is this answer not valid for some reason?  They remarked it medium, but it can be solved with the super easy method below\\n\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n\\n        for x in range(len(haystack)):\\n            if haystack[lx : x + len(needle)] == needle:\\n                return x\\n        else:\\n            return -1"
                    },
                    {
                        "username": "narayan48",
                        "content": "class Solution {\\n    public int strStr(String haystack, String needle) {\\n          int indexOfSubStr = haystack.indexOf(needle);\\n          return indexOfSubStr;\\n\\n    }\\n    //return -1;\\n}"
                    },
                    {
                        "username": "sayedHANEEF",
                        "content": "dude it is a one line solution in java and it takes 0ms to run"
                    },
                    {
                        "username": "SugerSu",
                        "content": "Maybe sometimes we do not need to think too much!\\n\\npublic int strStr(String haystack, String needle) {\\n\\n\\t\\t\\n\\t\\treturn haystack.indexOf(needle);\\n\\t}"
                    },
                    {
                        "username": "coveyjorjet",
                        "content": "similarly you can use find() function in c++\\n```\\nreturn haystack.find(needle);\\n```"
                    },
                    {
                        "username": "enkil2003",
                        "content": "and that is how you never get a job."
                    },
                    {
                        "username": "hippofaris",
                        "content": "giga chad"
                    },
                    {
                        "username": "qAxP4Mw",
                        "content": "[@Meerkats1999](/Meerkats1999) however if your coworker reimplemented indexOf on a project everyone would be pretty annoyed so I think interviewer should accept this answer. Otherwise they should be more clear about what they\\'re looking for."
                    },
                    {
                        "username": "yuangaonyc",
                        "content": "Maybe you should think more"
                    },
                    {
                        "username": "chazwinter",
                        "content": "Don\\'t provide solutions, no matter how easy you think they are.\\nThis answer uses built in Java functionality without imports, so it\\'s fair game. If they wanted you to design your own indexOf method, they would have said so. \\n\\nThere are other problems that specifically say to avoid certain methods, or ask a follow to challenge you to try it another way. This one does not have that, so I see it as an attempt to expose new people to indexOf."
                    },
                    {
                        "username": "dantruongdo3",
                        "content": "[@Meerkats1999](/Meerkats1999) i use the exact same way and feel kinda guilty."
                    },
                    {
                        "username": "Meerkats1999",
                        "content": "I don\\'t think the interviewer will like this answer."
                    },
                    {
                        "username": "emcc1990",
                        "content": "I also submitted this but having doubts of whether the whole point is not to use it and implement something raw. "
                    },
                    {
                        "username": "user0566A",
                        "content": "It\\'s interesting that java indexOf do not use KMP (because of memory I think) or Rabin-Karp (don\\'t know why)\\nhttps://github.com/AdoptOpenJDK/openjdk-jdk11/blob/master/src/java.base/share/classes/java/lang/StringLatin1.java#L233-L253"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@therishuraj](/therishuraj) My indexOf solution beats 91%... It\\'s definitely fast enough and thus I strongly feel this should be easy. Otherwise LeetCode should drastically limit the time-constraints in my opinion"
                    },
                    {
                        "username": "user0743xF",
                        "content": "[@mohan9814](/mohan9814) because here people are coming to learn algorithms i think :)"
                    },
                    {
                        "username": "therishuraj",
                        "content": "[@mohan9814](/mohan9814)  Because time complexity of the KMP algorithm is O(m+n) And time complexity of the indexOf method is O(nm). "
                    },
                    {
                        "username": "mohan9814",
                        "content": "yes same logic in c++ is working fine why do i need to get into kmp and all this"
                    },
                    {
                        "username": "mgoldenbe",
                        "content": "I don\\'t think they meant that I can call a library function. Also, I get \"Time Limit Exceeded\" on brute-force. So, this means I should use an advanced algorithm, like Rabin-Karp or KMP. Why then is this problem marked \"easy\"?"
                    },
                    {
                        "username": "chazwinter",
                        "content": "It\\'s easy because the point is to teach you to 1) stop overthinking things, and 2) learn one single function that solves the problem in one line."
                    },
                    {
                        "username": "C0de_bumstead",
                        "content": "Can be easily solved using sliding window duhh...."
                    },
                    {
                        "username": "mikael6767",
                        "content": "Why should it be marked ```Medium```. This is literally 1line of code or 28 symbols(I\\'m counting the ```return``` function). You don\\'t need any algorithm. You need one function (if you use python3). And that function starts of the letter \"f\""
                    },
                    {
                        "username": "2020uch0017",
                        "content": "it is medium now and yes it is a KMP  problem"
                    },
                    {
                        "username": "jarc",
                        "content": " Is it the standard string matching problem? Am I wrong?"
                    },
                    {
                        "username": "chickooo",
                        "content": "Yeah, this is the standard string matching problem.\\nYour function should perform same as **.find()** function in python OR **.indexOf()** function in javascript"
                    },
                    {
                        "username": "tlong1299",
                        "content": "**USE FIND**\\nAs a Python programmer, refusing to use core language features is akin to using a hammer instead of nail-gun because it makes you a \"better\" carpenter. Remember that this is Python not C. Python\\'s PEP 20 states, \"There should be one-- and preferably only one --obvious way to do it.\" I would call a string operation built into python designed to solve this particular problem the obvious way to do it.\\n\\n**DON\\'T USE FIND**\\nIf you go into an interview and solve this problem with the find() function, you better know how it works underneath, and you should be prepared to defend your use of it. After all nothing is \"free\" in your code, and even \"magic\" functions have a time and memory cost associated with them. Knowing what this cost is, and why it is the way it is will make you a better programmer. Implementing the function yourself, at least once, can really help you develop a better appreciation for the language."
                    },
                    {
                        "username": "chazwinter",
                        "content": "Finally, a Python programmer that isn\\'t an idiot. It\\'s wild how people overthink this problem."
                    },
                    {
                        "username": "marten2",
                        "content": "Hey,\\n\\nI wouldn't say that coming up with the KMP algorithm from scratch is easy ~1 hour time. Did companies that asked this question expect applicants to know KMP by heart? Did they expect the applicant to show a naive implementation? Any opinion on this?\\n\\nBest,\\n\\nMarten"
                    },
                    {
                        "username": "syfo_dias",
                        "content": "[@chazwinter](/chazwinter) is it Python specific task? Or what is indexOf in C++? "
                    },
                    {
                        "username": "chazwinter",
                        "content": "No, they expected you to know indexOf. Don\\'t overthink it."
                    },
                    {
                        "username": "zijianz",
                        "content": "Input: \\t\"\", \"\"\\nOutput: \\t-1\\nExpected: \\t0\\n\\nBasically there is nothing in the string, how do you get the index.\\n\\nIf this test case is valid, then needle =\"\", haystack=\"anything\" could return any value. since empty is everywhere."
                    },
                    {
                        "username": "chazwinter",
                        "content": "Read the constraints. If you had to deal with an empty string, you would simply write an edge case for it."
                    },
                    {
                        "username": "mansourcodes",
                        "content": "1 <= haystack.length, needle.length <= 104\\n"
                    },
                    {
                        "username": "cxaviousb",
                        "content": "> In a string, the last element is null character. In the first case, where it is \"\",\"\" both of them has same character that is null character, while in \"\",\"anything\" the first string has null character at 0 index while the next one has 'a' at 0 index.\n\n[@AvniGoyal22](/AvniGoyal22) That's programming language specific logic.  Let's try applying logic from JavaScript to this problem~\n\n```javascript\n> 'anything'.indexOf('')\n< 0\n> ''.charAt(0)\n< \"\"\n> ''.charAt(9001)\n< \"\"\n> 'anything'.lastIndexOf('')\n< 8\n< \"anything\"\n> 'anything'.substr(0,9)\n< \"anything\"\n> 'anything'.substr(9001,9)\n< \"\"\n```"
                    },
                    {
                        "username": "shaan__0w0",
                        "content": "i think you have to make the case of if the string is empty"
                    },
                    {
                        "username": "AvniGoyal22",
                        "content": "In a string, the last element is null character. In the first case, where it is \"\",\"\" both of them has same character that is null character, while in \"\",\"anything\" the first string has null character at 0 index while the next one has \\'a\\' at 0 index. "
                    },
                    {
                        "username": "SarK97",
                        "content": "Why this test case is returning -1? Shouldn\\'t it be 4 since it is a substring?\\n\"mississippi\"\\n\"issip\""
                    },
                    {
                        "username": "impatientcat07",
                        "content": "Here comes the Overlapping case while comparing \"issis\" -> \"issip\" it rejects and reinitializes and starts from \"sippi\" & \\n comparing \"issip\", which in turns return -1; "
                    },
                    {
                        "username": "flyingfist",
                        "content": "its because it is taking issis (index 1 to 5) as index 5 is not matching it goes further and doesnt get issip "
                    },
                    {
                        "username": "MaheshPatil19",
                        "content": "here needle =\"issipi\""
                    },
                    {
                        "username": "chickooo",
                        "content": "If you add this test case ( I just did ), the output is 4 as expected.\\nDon\\'t know why you are getting -1. \\nMaybe there were unwanted spaces in your input. Can you try that again?"
                    },
                    {
                        "username": "trpaslik",
                        "content": "Most of python submissions are based on cheating (s.index() or s.find()).\\nIt is a pitty that when implementing it in pure python (the naive `O(n*m)` way) it results in timeout.\\nIt should either be accepted for `O(n*m)` or if some better approach is expected like with a rolling hash then it should be marked as medium IMHO."
                    },
                    {
                        "username": "ryo-kozin",
                        "content": "I believe  an interviewer would be fine with ussing indexOf(). In real-world programming situations, it is often advisable to take full advantage of available built-in functions and libraries. "
                    },
                    {
                        "username": "labule",
                        "content": "[@Deecodes25](/Deecodes25)  Time Complexity is O(n*m). `haystack[i:j] == needle` touches `m` chars and you do this approximately `n` times."
                    },
                    {
                        "username": "youttsu",
                        "content": "true dude. it works on JS with O(m*n) time complexity though "
                    },
                    {
                        "username": "Deecodes25",
                        "content": "I solved with this approach, can anyone explain what is the Time Complexity for this - \\n```\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        i=0\\n        j=len(needle)\\n        while j<=len(haystack):\\n            if haystack[i:j] == needle:\\n                return i\\n            i+=1\\n            j+=1\\n        return -1\\n```"
                    },
                    {
                        "username": "veerashah1",
                        "content": "[@chickooo](/chickooo) Wouldn\\'t an interviewer be fine with .indexOf(), because there\\'s no reason to re-invent the wheel when there are built in functions? If they specifically ask to avoid it then I guess, but in this case they didn\\'t."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Why is using indexOf cheating? Nowhere is it stated that you shouldn\\'t use that. If they don\\'t want you to use that they should say so, or limit the time constraints to only allow O(N+M)"
                    },
                    {
                        "username": "shaan__0w0",
                        "content": "but it gets submitted by using .indexOf() in java \\n"
                    },
                    {
                        "username": "chickooo",
                        "content": "Agreed with your opinion.\\nIf you were to use just built in function like .find() or .indexOf(), then the problem wouldn\\'t be labeled **Medium**. And if you were in an interview, the interviewer would not be pleased."
                    },
                    {
                        "username": "chehsunliu",
                        "content": "I have solved this problem. However, I think it may be controversial to return index 0 when the inputs are \"A\" and \"\". In my opinion, one of the inputs is \"A\\\\0\" and the other is \"\\\\0\". Perhaps it should return index 1."
                    }
                ]
            },
            {
                "id": 1971779,
                "content": [
                    {
                        "username": "AlgoEngine",
                        "content": "Visualization of the KMP Algorithm\\n\\nhttps://youtu.be/0iDiUuHZE_g"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "I think Leetcode needs to implement a few testcases where O(n*m) solutions should not be accepted."
                    },
                    {
                        "username": "maratichts",
                        "content": "for java this is for sure an easy problem"
                    },
                    {
                        "username": "shiva97",
                        "content": "I find the KMP algorithm not easy to understand. Wondering why this question is categorized into easy. If the O(m* n) is the expected solution then I agree its easy. I dont think that O(m* n) solution will be accepted in an interview."
                    },
                    {
                        "username": "sachinsharma_11",
                        "content": "![image](https://assets.leetcode.com/users/images/925e6af3-3919-40f2-99b9-742b0df69e22_1656404905.2271748.png)\\n\\n\\n\\n"
                    },
                    {
                        "username": "tabrejalamreh",
                        "content": "return haystack.find(needle)"
                    },
                    {
                        "username": "yagniktalaviya4122002",
                        "content": "![image](https://assets.leetcode.com/users/images/8af38d85-0eeb-4f1f-9c30-ac7cc6d6579d_1652076284.6094553.png)\\n"
                    },
                    {
                        "username": "sophie0217nz",
                        "content": "I saw your answer and figured it out. but I changed( i<haystack.length()-needle.length()+1); (haystack.substring(i,i+needle.length()).equals(needle)), thank you for giving me the clue. I hope my change would also give you a clue."
                    },
                    {
                        "username": "woodyinho",
                        "content": "Is it okay  to use substring method in a problem like this in the interviews ?"
                    },
                    {
                        "username": "rivanrmail",
                        "content": "too late, but it is not, if anyone is reading this in future."
                    },
                    {
                        "username": "Chuck1991",
                        "content": "Input:\\n\"a\"\\n\"\"\\n\\nOutput:\\n-1\\n\\nExpected:\\n0"
                    },
                    {
                        "username": "sayedHANEEF",
                        "content": "It\\'s a invalid testcase,see the constraints"
                    },
                    {
                        "username": "XOFJO",
                        "content": "Do not use built-in function!"
                    }
                ]
            },
            {
                "id": 1820134,
                "content": [
                    {
                        "username": "AlgoEngine",
                        "content": "Visualization of the KMP Algorithm\\n\\nhttps://youtu.be/0iDiUuHZE_g"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "I think Leetcode needs to implement a few testcases where O(n*m) solutions should not be accepted."
                    },
                    {
                        "username": "maratichts",
                        "content": "for java this is for sure an easy problem"
                    },
                    {
                        "username": "shiva97",
                        "content": "I find the KMP algorithm not easy to understand. Wondering why this question is categorized into easy. If the O(m* n) is the expected solution then I agree its easy. I dont think that O(m* n) solution will be accepted in an interview."
                    },
                    {
                        "username": "sachinsharma_11",
                        "content": "![image](https://assets.leetcode.com/users/images/925e6af3-3919-40f2-99b9-742b0df69e22_1656404905.2271748.png)\\n\\n\\n\\n"
                    },
                    {
                        "username": "tabrejalamreh",
                        "content": "return haystack.find(needle)"
                    },
                    {
                        "username": "yagniktalaviya4122002",
                        "content": "![image](https://assets.leetcode.com/users/images/8af38d85-0eeb-4f1f-9c30-ac7cc6d6579d_1652076284.6094553.png)\\n"
                    },
                    {
                        "username": "sophie0217nz",
                        "content": "I saw your answer and figured it out. but I changed( i<haystack.length()-needle.length()+1); (haystack.substring(i,i+needle.length()).equals(needle)), thank you for giving me the clue. I hope my change would also give you a clue."
                    },
                    {
                        "username": "woodyinho",
                        "content": "Is it okay  to use substring method in a problem like this in the interviews ?"
                    },
                    {
                        "username": "rivanrmail",
                        "content": "too late, but it is not, if anyone is reading this in future."
                    },
                    {
                        "username": "Chuck1991",
                        "content": "Input:\\n\"a\"\\n\"\"\\n\\nOutput:\\n-1\\n\\nExpected:\\n0"
                    },
                    {
                        "username": "sayedHANEEF",
                        "content": "It\\'s a invalid testcase,see the constraints"
                    },
                    {
                        "username": "XOFJO",
                        "content": "Do not use built-in function!"
                    }
                ]
            },
            {
                "id": 1715310,
                "content": [
                    {
                        "username": "AlgoEngine",
                        "content": "Visualization of the KMP Algorithm\\n\\nhttps://youtu.be/0iDiUuHZE_g"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "I think Leetcode needs to implement a few testcases where O(n*m) solutions should not be accepted."
                    },
                    {
                        "username": "maratichts",
                        "content": "for java this is for sure an easy problem"
                    },
                    {
                        "username": "shiva97",
                        "content": "I find the KMP algorithm not easy to understand. Wondering why this question is categorized into easy. If the O(m* n) is the expected solution then I agree its easy. I dont think that O(m* n) solution will be accepted in an interview."
                    },
                    {
                        "username": "sachinsharma_11",
                        "content": "![image](https://assets.leetcode.com/users/images/925e6af3-3919-40f2-99b9-742b0df69e22_1656404905.2271748.png)\\n\\n\\n\\n"
                    },
                    {
                        "username": "tabrejalamreh",
                        "content": "return haystack.find(needle)"
                    },
                    {
                        "username": "yagniktalaviya4122002",
                        "content": "![image](https://assets.leetcode.com/users/images/8af38d85-0eeb-4f1f-9c30-ac7cc6d6579d_1652076284.6094553.png)\\n"
                    },
                    {
                        "username": "sophie0217nz",
                        "content": "I saw your answer and figured it out. but I changed( i<haystack.length()-needle.length()+1); (haystack.substring(i,i+needle.length()).equals(needle)), thank you for giving me the clue. I hope my change would also give you a clue."
                    },
                    {
                        "username": "woodyinho",
                        "content": "Is it okay  to use substring method in a problem like this in the interviews ?"
                    },
                    {
                        "username": "rivanrmail",
                        "content": "too late, but it is not, if anyone is reading this in future."
                    },
                    {
                        "username": "Chuck1991",
                        "content": "Input:\\n\"a\"\\n\"\"\\n\\nOutput:\\n-1\\n\\nExpected:\\n0"
                    },
                    {
                        "username": "sayedHANEEF",
                        "content": "It\\'s a invalid testcase,see the constraints"
                    },
                    {
                        "username": "XOFJO",
                        "content": "Do not use built-in function!"
                    }
                ]
            },
            {
                "id": 1567049,
                "content": [
                    {
                        "username": "AlgoEngine",
                        "content": "Visualization of the KMP Algorithm\\n\\nhttps://youtu.be/0iDiUuHZE_g"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "I think Leetcode needs to implement a few testcases where O(n*m) solutions should not be accepted."
                    },
                    {
                        "username": "maratichts",
                        "content": "for java this is for sure an easy problem"
                    },
                    {
                        "username": "shiva97",
                        "content": "I find the KMP algorithm not easy to understand. Wondering why this question is categorized into easy. If the O(m* n) is the expected solution then I agree its easy. I dont think that O(m* n) solution will be accepted in an interview."
                    },
                    {
                        "username": "sachinsharma_11",
                        "content": "![image](https://assets.leetcode.com/users/images/925e6af3-3919-40f2-99b9-742b0df69e22_1656404905.2271748.png)\\n\\n\\n\\n"
                    },
                    {
                        "username": "tabrejalamreh",
                        "content": "return haystack.find(needle)"
                    },
                    {
                        "username": "yagniktalaviya4122002",
                        "content": "![image](https://assets.leetcode.com/users/images/8af38d85-0eeb-4f1f-9c30-ac7cc6d6579d_1652076284.6094553.png)\\n"
                    },
                    {
                        "username": "sophie0217nz",
                        "content": "I saw your answer and figured it out. but I changed( i<haystack.length()-needle.length()+1); (haystack.substring(i,i+needle.length()).equals(needle)), thank you for giving me the clue. I hope my change would also give you a clue."
                    },
                    {
                        "username": "woodyinho",
                        "content": "Is it okay  to use substring method in a problem like this in the interviews ?"
                    },
                    {
                        "username": "rivanrmail",
                        "content": "too late, but it is not, if anyone is reading this in future."
                    },
                    {
                        "username": "Chuck1991",
                        "content": "Input:\\n\"a\"\\n\"\"\\n\\nOutput:\\n-1\\n\\nExpected:\\n0"
                    },
                    {
                        "username": "sayedHANEEF",
                        "content": "It\\'s a invalid testcase,see the constraints"
                    },
                    {
                        "username": "XOFJO",
                        "content": "Do not use built-in function!"
                    }
                ]
            },
            {
                "id": 1570935,
                "content": [
                    {
                        "username": "AlgoEngine",
                        "content": "Visualization of the KMP Algorithm\\n\\nhttps://youtu.be/0iDiUuHZE_g"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "I think Leetcode needs to implement a few testcases where O(n*m) solutions should not be accepted."
                    },
                    {
                        "username": "maratichts",
                        "content": "for java this is for sure an easy problem"
                    },
                    {
                        "username": "shiva97",
                        "content": "I find the KMP algorithm not easy to understand. Wondering why this question is categorized into easy. If the O(m* n) is the expected solution then I agree its easy. I dont think that O(m* n) solution will be accepted in an interview."
                    },
                    {
                        "username": "sachinsharma_11",
                        "content": "![image](https://assets.leetcode.com/users/images/925e6af3-3919-40f2-99b9-742b0df69e22_1656404905.2271748.png)\\n\\n\\n\\n"
                    },
                    {
                        "username": "tabrejalamreh",
                        "content": "return haystack.find(needle)"
                    },
                    {
                        "username": "yagniktalaviya4122002",
                        "content": "![image](https://assets.leetcode.com/users/images/8af38d85-0eeb-4f1f-9c30-ac7cc6d6579d_1652076284.6094553.png)\\n"
                    },
                    {
                        "username": "sophie0217nz",
                        "content": "I saw your answer and figured it out. but I changed( i<haystack.length()-needle.length()+1); (haystack.substring(i,i+needle.length()).equals(needle)), thank you for giving me the clue. I hope my change would also give you a clue."
                    },
                    {
                        "username": "woodyinho",
                        "content": "Is it okay  to use substring method in a problem like this in the interviews ?"
                    },
                    {
                        "username": "rivanrmail",
                        "content": "too late, but it is not, if anyone is reading this in future."
                    },
                    {
                        "username": "Chuck1991",
                        "content": "Input:\\n\"a\"\\n\"\"\\n\\nOutput:\\n-1\\n\\nExpected:\\n0"
                    },
                    {
                        "username": "sayedHANEEF",
                        "content": "It\\'s a invalid testcase,see the constraints"
                    },
                    {
                        "username": "XOFJO",
                        "content": "Do not use built-in function!"
                    }
                ]
            },
            {
                "id": 1570927,
                "content": [
                    {
                        "username": "AlgoEngine",
                        "content": "Visualization of the KMP Algorithm\\n\\nhttps://youtu.be/0iDiUuHZE_g"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "I think Leetcode needs to implement a few testcases where O(n*m) solutions should not be accepted."
                    },
                    {
                        "username": "maratichts",
                        "content": "for java this is for sure an easy problem"
                    },
                    {
                        "username": "shiva97",
                        "content": "I find the KMP algorithm not easy to understand. Wondering why this question is categorized into easy. If the O(m* n) is the expected solution then I agree its easy. I dont think that O(m* n) solution will be accepted in an interview."
                    },
                    {
                        "username": "sachinsharma_11",
                        "content": "![image](https://assets.leetcode.com/users/images/925e6af3-3919-40f2-99b9-742b0df69e22_1656404905.2271748.png)\\n\\n\\n\\n"
                    },
                    {
                        "username": "tabrejalamreh",
                        "content": "return haystack.find(needle)"
                    },
                    {
                        "username": "yagniktalaviya4122002",
                        "content": "![image](https://assets.leetcode.com/users/images/8af38d85-0eeb-4f1f-9c30-ac7cc6d6579d_1652076284.6094553.png)\\n"
                    },
                    {
                        "username": "sophie0217nz",
                        "content": "I saw your answer and figured it out. but I changed( i<haystack.length()-needle.length()+1); (haystack.substring(i,i+needle.length()).equals(needle)), thank you for giving me the clue. I hope my change would also give you a clue."
                    },
                    {
                        "username": "woodyinho",
                        "content": "Is it okay  to use substring method in a problem like this in the interviews ?"
                    },
                    {
                        "username": "rivanrmail",
                        "content": "too late, but it is not, if anyone is reading this in future."
                    },
                    {
                        "username": "Chuck1991",
                        "content": "Input:\\n\"a\"\\n\"\"\\n\\nOutput:\\n-1\\n\\nExpected:\\n0"
                    },
                    {
                        "username": "sayedHANEEF",
                        "content": "It\\'s a invalid testcase,see the constraints"
                    },
                    {
                        "username": "XOFJO",
                        "content": "Do not use built-in function!"
                    }
                ]
            },
            {
                "id": 1576731,
                "content": [
                    {
                        "username": "AlgoEngine",
                        "content": "Visualization of the KMP Algorithm\\n\\nhttps://youtu.be/0iDiUuHZE_g"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "I think Leetcode needs to implement a few testcases where O(n*m) solutions should not be accepted."
                    },
                    {
                        "username": "maratichts",
                        "content": "for java this is for sure an easy problem"
                    },
                    {
                        "username": "shiva97",
                        "content": "I find the KMP algorithm not easy to understand. Wondering why this question is categorized into easy. If the O(m* n) is the expected solution then I agree its easy. I dont think that O(m* n) solution will be accepted in an interview."
                    },
                    {
                        "username": "sachinsharma_11",
                        "content": "![image](https://assets.leetcode.com/users/images/925e6af3-3919-40f2-99b9-742b0df69e22_1656404905.2271748.png)\\n\\n\\n\\n"
                    },
                    {
                        "username": "tabrejalamreh",
                        "content": "return haystack.find(needle)"
                    },
                    {
                        "username": "yagniktalaviya4122002",
                        "content": "![image](https://assets.leetcode.com/users/images/8af38d85-0eeb-4f1f-9c30-ac7cc6d6579d_1652076284.6094553.png)\\n"
                    },
                    {
                        "username": "sophie0217nz",
                        "content": "I saw your answer and figured it out. but I changed( i<haystack.length()-needle.length()+1); (haystack.substring(i,i+needle.length()).equals(needle)), thank you for giving me the clue. I hope my change would also give you a clue."
                    },
                    {
                        "username": "woodyinho",
                        "content": "Is it okay  to use substring method in a problem like this in the interviews ?"
                    },
                    {
                        "username": "rivanrmail",
                        "content": "too late, but it is not, if anyone is reading this in future."
                    },
                    {
                        "username": "Chuck1991",
                        "content": "Input:\\n\"a\"\\n\"\"\\n\\nOutput:\\n-1\\n\\nExpected:\\n0"
                    },
                    {
                        "username": "sayedHANEEF",
                        "content": "It\\'s a invalid testcase,see the constraints"
                    },
                    {
                        "username": "XOFJO",
                        "content": "Do not use built-in function!"
                    }
                ]
            },
            {
                "id": 1569487,
                "content": [
                    {
                        "username": "AlgoEngine",
                        "content": "Visualization of the KMP Algorithm\\n\\nhttps://youtu.be/0iDiUuHZE_g"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "I think Leetcode needs to implement a few testcases where O(n*m) solutions should not be accepted."
                    },
                    {
                        "username": "maratichts",
                        "content": "for java this is for sure an easy problem"
                    },
                    {
                        "username": "shiva97",
                        "content": "I find the KMP algorithm not easy to understand. Wondering why this question is categorized into easy. If the O(m* n) is the expected solution then I agree its easy. I dont think that O(m* n) solution will be accepted in an interview."
                    },
                    {
                        "username": "sachinsharma_11",
                        "content": "![image](https://assets.leetcode.com/users/images/925e6af3-3919-40f2-99b9-742b0df69e22_1656404905.2271748.png)\\n\\n\\n\\n"
                    },
                    {
                        "username": "tabrejalamreh",
                        "content": "return haystack.find(needle)"
                    },
                    {
                        "username": "yagniktalaviya4122002",
                        "content": "![image](https://assets.leetcode.com/users/images/8af38d85-0eeb-4f1f-9c30-ac7cc6d6579d_1652076284.6094553.png)\\n"
                    },
                    {
                        "username": "sophie0217nz",
                        "content": "I saw your answer and figured it out. but I changed( i<haystack.length()-needle.length()+1); (haystack.substring(i,i+needle.length()).equals(needle)), thank you for giving me the clue. I hope my change would also give you a clue."
                    },
                    {
                        "username": "woodyinho",
                        "content": "Is it okay  to use substring method in a problem like this in the interviews ?"
                    },
                    {
                        "username": "rivanrmail",
                        "content": "too late, but it is not, if anyone is reading this in future."
                    },
                    {
                        "username": "Chuck1991",
                        "content": "Input:\\n\"a\"\\n\"\"\\n\\nOutput:\\n-1\\n\\nExpected:\\n0"
                    },
                    {
                        "username": "sayedHANEEF",
                        "content": "It\\'s a invalid testcase,see the constraints"
                    },
                    {
                        "username": "XOFJO",
                        "content": "Do not use built-in function!"
                    }
                ]
            },
            {
                "id": 1567173,
                "content": [
                    {
                        "username": "AlgoEngine",
                        "content": "Visualization of the KMP Algorithm\\n\\nhttps://youtu.be/0iDiUuHZE_g"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "I think Leetcode needs to implement a few testcases where O(n*m) solutions should not be accepted."
                    },
                    {
                        "username": "maratichts",
                        "content": "for java this is for sure an easy problem"
                    },
                    {
                        "username": "shiva97",
                        "content": "I find the KMP algorithm not easy to understand. Wondering why this question is categorized into easy. If the O(m* n) is the expected solution then I agree its easy. I dont think that O(m* n) solution will be accepted in an interview."
                    },
                    {
                        "username": "sachinsharma_11",
                        "content": "![image](https://assets.leetcode.com/users/images/925e6af3-3919-40f2-99b9-742b0df69e22_1656404905.2271748.png)\\n\\n\\n\\n"
                    },
                    {
                        "username": "tabrejalamreh",
                        "content": "return haystack.find(needle)"
                    },
                    {
                        "username": "yagniktalaviya4122002",
                        "content": "![image](https://assets.leetcode.com/users/images/8af38d85-0eeb-4f1f-9c30-ac7cc6d6579d_1652076284.6094553.png)\\n"
                    },
                    {
                        "username": "sophie0217nz",
                        "content": "I saw your answer and figured it out. but I changed( i<haystack.length()-needle.length()+1); (haystack.substring(i,i+needle.length()).equals(needle)), thank you for giving me the clue. I hope my change would also give you a clue."
                    },
                    {
                        "username": "woodyinho",
                        "content": "Is it okay  to use substring method in a problem like this in the interviews ?"
                    },
                    {
                        "username": "rivanrmail",
                        "content": "too late, but it is not, if anyone is reading this in future."
                    },
                    {
                        "username": "Chuck1991",
                        "content": "Input:\\n\"a\"\\n\"\"\\n\\nOutput:\\n-1\\n\\nExpected:\\n0"
                    },
                    {
                        "username": "sayedHANEEF",
                        "content": "It\\'s a invalid testcase,see the constraints"
                    },
                    {
                        "username": "XOFJO",
                        "content": "Do not use built-in function!"
                    }
                ]
            },
            {
                "id": 1819969,
                "content": [
                    {
                        "username": "AlgoEngine",
                        "content": "Visualization of the KMP Algorithm\\n\\nhttps://youtu.be/0iDiUuHZE_g"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "I think Leetcode needs to implement a few testcases where O(n*m) solutions should not be accepted."
                    },
                    {
                        "username": "maratichts",
                        "content": "for java this is for sure an easy problem"
                    },
                    {
                        "username": "shiva97",
                        "content": "I find the KMP algorithm not easy to understand. Wondering why this question is categorized into easy. If the O(m* n) is the expected solution then I agree its easy. I dont think that O(m* n) solution will be accepted in an interview."
                    },
                    {
                        "username": "sachinsharma_11",
                        "content": "![image](https://assets.leetcode.com/users/images/925e6af3-3919-40f2-99b9-742b0df69e22_1656404905.2271748.png)\\n\\n\\n\\n"
                    },
                    {
                        "username": "tabrejalamreh",
                        "content": "return haystack.find(needle)"
                    },
                    {
                        "username": "yagniktalaviya4122002",
                        "content": "![image](https://assets.leetcode.com/users/images/8af38d85-0eeb-4f1f-9c30-ac7cc6d6579d_1652076284.6094553.png)\\n"
                    },
                    {
                        "username": "sophie0217nz",
                        "content": "I saw your answer and figured it out. but I changed( i<haystack.length()-needle.length()+1); (haystack.substring(i,i+needle.length()).equals(needle)), thank you for giving me the clue. I hope my change would also give you a clue."
                    },
                    {
                        "username": "woodyinho",
                        "content": "Is it okay  to use substring method in a problem like this in the interviews ?"
                    },
                    {
                        "username": "rivanrmail",
                        "content": "too late, but it is not, if anyone is reading this in future."
                    },
                    {
                        "username": "Chuck1991",
                        "content": "Input:\\n\"a\"\\n\"\"\\n\\nOutput:\\n-1\\n\\nExpected:\\n0"
                    },
                    {
                        "username": "sayedHANEEF",
                        "content": "It\\'s a invalid testcase,see the constraints"
                    },
                    {
                        "username": "XOFJO",
                        "content": "Do not use built-in function!"
                    }
                ]
            },
            {
                "id": 1567814,
                "content": [
                    {
                        "username": "lzhao",
                        "content": "The problem states that it should return the first occurrence. Is it the same as needle?"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "People who are using built in functions do you think ur solution will be accepted in an interview?"
                    },
                    {
                        "username": "atifhu",
                        "content": "Those who are using in built functions are the ones who will say after their interview \"kya pta interviewer kch KMP aur Z- algo k bare me bol rha tha\" :D"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Is it right to use sliding window approach here with string library function...\\nAs I have used to get correct answer"
                    },
                    {
                        "username": "rexhu100",
                        "content": "This is not a easy problem. I know using built-in hashing function is easy, and probably passible. But the intent for the problem is obviously to use Karp-Rabin, which is not easy at all to implement from scratch."
                    },
                    {
                        "username": "pratikjain227",
                        "content": "\\ttry:\\n\\t\\treturn haystack.index(needle)\\n\\texcept:\\n\\t\\treturn -1\\n\\n"
                    },
                    {
                        "username": "minh-nguyen-mqn",
                        "content": "or just return haystack.find(needle)"
                    },
                    {
                        "username": "Wasant_from_asia",
                        "content": "return haystack.indexOf(needle);"
                    },
                    {
                        "username": "czkudo",
                        "content": "see title. what's the meaning of this problem if we can just use indexOf()"
                    },
                    {
                        "username": "Robin_Rathore",
                        "content": "Although This (return haystack.find(needle); ) beats 100% of CPP users, but to practice problems genuinely not just to increase the no. we should do it with our own logic not with any lib fun.\n"
                    },
                    {
                        "username": "syfo_dias",
                        "content": "exactly. Because it doesn't make any sense otherwise. It's like solving a sorting problem by using std::sort"
                    },
                    {
                        "username": "MehtaParth",
                        "content": "class Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        if (needle.empty()) {\\n            return 0;\\n        }\\n        \\n        int j = 0;\\n        int x = -1;\\n        for (int i = 0; i < haystack.size(); i++) {\\n            if (haystack[i] == needle[j]) {\\n                if (j == 0) {\\n                    x = i;  \\n                }\\n                j++;\\n                if (j == needle.size()) {\\n                    return x;  \\n                }\\n            } else {\\n                j = 0;  \\n                x = -1;\\n            }\\n        }\\n        \\n        return -1;  \\n    }\\n};\\n\\n\\nThis code fails to find \"issip\" in \"mississippi\".\\nCan someone find the error"
                    },
                    {
                        "username": "Izaki11",
                        "content": "After failing the check at \\'p\\', the loop continues past the previous \\'i\\', which is where the \"needle\" starts."
                    },
                    {
                        "username": "cheesebread",
                        "content": "...why is this is a medium? Seems pretty straightforward to me"
                    }
                ]
            },
            {
                "id": 1820146,
                "content": [
                    {
                        "username": "lzhao",
                        "content": "The problem states that it should return the first occurrence. Is it the same as needle?"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "People who are using built in functions do you think ur solution will be accepted in an interview?"
                    },
                    {
                        "username": "atifhu",
                        "content": "Those who are using in built functions are the ones who will say after their interview \"kya pta interviewer kch KMP aur Z- algo k bare me bol rha tha\" :D"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Is it right to use sliding window approach here with string library function...\\nAs I have used to get correct answer"
                    },
                    {
                        "username": "rexhu100",
                        "content": "This is not a easy problem. I know using built-in hashing function is easy, and probably passible. But the intent for the problem is obviously to use Karp-Rabin, which is not easy at all to implement from scratch."
                    },
                    {
                        "username": "pratikjain227",
                        "content": "\\ttry:\\n\\t\\treturn haystack.index(needle)\\n\\texcept:\\n\\t\\treturn -1\\n\\n"
                    },
                    {
                        "username": "minh-nguyen-mqn",
                        "content": "or just return haystack.find(needle)"
                    },
                    {
                        "username": "Wasant_from_asia",
                        "content": "return haystack.indexOf(needle);"
                    },
                    {
                        "username": "czkudo",
                        "content": "see title. what's the meaning of this problem if we can just use indexOf()"
                    },
                    {
                        "username": "Robin_Rathore",
                        "content": "Although This (return haystack.find(needle); ) beats 100% of CPP users, but to practice problems genuinely not just to increase the no. we should do it with our own logic not with any lib fun.\n"
                    },
                    {
                        "username": "syfo_dias",
                        "content": "exactly. Because it doesn't make any sense otherwise. It's like solving a sorting problem by using std::sort"
                    },
                    {
                        "username": "MehtaParth",
                        "content": "class Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        if (needle.empty()) {\\n            return 0;\\n        }\\n        \\n        int j = 0;\\n        int x = -1;\\n        for (int i = 0; i < haystack.size(); i++) {\\n            if (haystack[i] == needle[j]) {\\n                if (j == 0) {\\n                    x = i;  \\n                }\\n                j++;\\n                if (j == needle.size()) {\\n                    return x;  \\n                }\\n            } else {\\n                j = 0;  \\n                x = -1;\\n            }\\n        }\\n        \\n        return -1;  \\n    }\\n};\\n\\n\\nThis code fails to find \"issip\" in \"mississippi\".\\nCan someone find the error"
                    },
                    {
                        "username": "Izaki11",
                        "content": "After failing the check at \\'p\\', the loop continues past the previous \\'i\\', which is where the \"needle\" starts."
                    },
                    {
                        "username": "cheesebread",
                        "content": "...why is this is a medium? Seems pretty straightforward to me"
                    }
                ]
            },
            {
                "id": 1678692,
                "content": [
                    {
                        "username": "lzhao",
                        "content": "The problem states that it should return the first occurrence. Is it the same as needle?"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "People who are using built in functions do you think ur solution will be accepted in an interview?"
                    },
                    {
                        "username": "atifhu",
                        "content": "Those who are using in built functions are the ones who will say after their interview \"kya pta interviewer kch KMP aur Z- algo k bare me bol rha tha\" :D"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Is it right to use sliding window approach here with string library function...\\nAs I have used to get correct answer"
                    },
                    {
                        "username": "rexhu100",
                        "content": "This is not a easy problem. I know using built-in hashing function is easy, and probably passible. But the intent for the problem is obviously to use Karp-Rabin, which is not easy at all to implement from scratch."
                    },
                    {
                        "username": "pratikjain227",
                        "content": "\\ttry:\\n\\t\\treturn haystack.index(needle)\\n\\texcept:\\n\\t\\treturn -1\\n\\n"
                    },
                    {
                        "username": "minh-nguyen-mqn",
                        "content": "or just return haystack.find(needle)"
                    },
                    {
                        "username": "Wasant_from_asia",
                        "content": "return haystack.indexOf(needle);"
                    },
                    {
                        "username": "czkudo",
                        "content": "see title. what's the meaning of this problem if we can just use indexOf()"
                    },
                    {
                        "username": "Robin_Rathore",
                        "content": "Although This (return haystack.find(needle); ) beats 100% of CPP users, but to practice problems genuinely not just to increase the no. we should do it with our own logic not with any lib fun.\n"
                    },
                    {
                        "username": "syfo_dias",
                        "content": "exactly. Because it doesn't make any sense otherwise. It's like solving a sorting problem by using std::sort"
                    },
                    {
                        "username": "MehtaParth",
                        "content": "class Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        if (needle.empty()) {\\n            return 0;\\n        }\\n        \\n        int j = 0;\\n        int x = -1;\\n        for (int i = 0; i < haystack.size(); i++) {\\n            if (haystack[i] == needle[j]) {\\n                if (j == 0) {\\n                    x = i;  \\n                }\\n                j++;\\n                if (j == needle.size()) {\\n                    return x;  \\n                }\\n            } else {\\n                j = 0;  \\n                x = -1;\\n            }\\n        }\\n        \\n        return -1;  \\n    }\\n};\\n\\n\\nThis code fails to find \"issip\" in \"mississippi\".\\nCan someone find the error"
                    },
                    {
                        "username": "Izaki11",
                        "content": "After failing the check at \\'p\\', the loop continues past the previous \\'i\\', which is where the \"needle\" starts."
                    },
                    {
                        "username": "cheesebread",
                        "content": "...why is this is a medium? Seems pretty straightforward to me"
                    }
                ]
            },
            {
                "id": 1574132,
                "content": [
                    {
                        "username": "lzhao",
                        "content": "The problem states that it should return the first occurrence. Is it the same as needle?"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "People who are using built in functions do you think ur solution will be accepted in an interview?"
                    },
                    {
                        "username": "atifhu",
                        "content": "Those who are using in built functions are the ones who will say after their interview \"kya pta interviewer kch KMP aur Z- algo k bare me bol rha tha\" :D"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Is it right to use sliding window approach here with string library function...\\nAs I have used to get correct answer"
                    },
                    {
                        "username": "rexhu100",
                        "content": "This is not a easy problem. I know using built-in hashing function is easy, and probably passible. But the intent for the problem is obviously to use Karp-Rabin, which is not easy at all to implement from scratch."
                    },
                    {
                        "username": "pratikjain227",
                        "content": "\\ttry:\\n\\t\\treturn haystack.index(needle)\\n\\texcept:\\n\\t\\treturn -1\\n\\n"
                    },
                    {
                        "username": "minh-nguyen-mqn",
                        "content": "or just return haystack.find(needle)"
                    },
                    {
                        "username": "Wasant_from_asia",
                        "content": "return haystack.indexOf(needle);"
                    },
                    {
                        "username": "czkudo",
                        "content": "see title. what's the meaning of this problem if we can just use indexOf()"
                    },
                    {
                        "username": "Robin_Rathore",
                        "content": "Although This (return haystack.find(needle); ) beats 100% of CPP users, but to practice problems genuinely not just to increase the no. we should do it with our own logic not with any lib fun.\n"
                    },
                    {
                        "username": "syfo_dias",
                        "content": "exactly. Because it doesn't make any sense otherwise. It's like solving a sorting problem by using std::sort"
                    },
                    {
                        "username": "MehtaParth",
                        "content": "class Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        if (needle.empty()) {\\n            return 0;\\n        }\\n        \\n        int j = 0;\\n        int x = -1;\\n        for (int i = 0; i < haystack.size(); i++) {\\n            if (haystack[i] == needle[j]) {\\n                if (j == 0) {\\n                    x = i;  \\n                }\\n                j++;\\n                if (j == needle.size()) {\\n                    return x;  \\n                }\\n            } else {\\n                j = 0;  \\n                x = -1;\\n            }\\n        }\\n        \\n        return -1;  \\n    }\\n};\\n\\n\\nThis code fails to find \"issip\" in \"mississippi\".\\nCan someone find the error"
                    },
                    {
                        "username": "Izaki11",
                        "content": "After failing the check at \\'p\\', the loop continues past the previous \\'i\\', which is where the \"needle\" starts."
                    },
                    {
                        "username": "cheesebread",
                        "content": "...why is this is a medium? Seems pretty straightforward to me"
                    }
                ]
            },
            {
                "id": 1573363,
                "content": [
                    {
                        "username": "lzhao",
                        "content": "The problem states that it should return the first occurrence. Is it the same as needle?"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "People who are using built in functions do you think ur solution will be accepted in an interview?"
                    },
                    {
                        "username": "atifhu",
                        "content": "Those who are using in built functions are the ones who will say after their interview \"kya pta interviewer kch KMP aur Z- algo k bare me bol rha tha\" :D"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Is it right to use sliding window approach here with string library function...\\nAs I have used to get correct answer"
                    },
                    {
                        "username": "rexhu100",
                        "content": "This is not a easy problem. I know using built-in hashing function is easy, and probably passible. But the intent for the problem is obviously to use Karp-Rabin, which is not easy at all to implement from scratch."
                    },
                    {
                        "username": "pratikjain227",
                        "content": "\\ttry:\\n\\t\\treturn haystack.index(needle)\\n\\texcept:\\n\\t\\treturn -1\\n\\n"
                    },
                    {
                        "username": "minh-nguyen-mqn",
                        "content": "or just return haystack.find(needle)"
                    },
                    {
                        "username": "Wasant_from_asia",
                        "content": "return haystack.indexOf(needle);"
                    },
                    {
                        "username": "czkudo",
                        "content": "see title. what's the meaning of this problem if we can just use indexOf()"
                    },
                    {
                        "username": "Robin_Rathore",
                        "content": "Although This (return haystack.find(needle); ) beats 100% of CPP users, but to practice problems genuinely not just to increase the no. we should do it with our own logic not with any lib fun.\n"
                    },
                    {
                        "username": "syfo_dias",
                        "content": "exactly. Because it doesn't make any sense otherwise. It's like solving a sorting problem by using std::sort"
                    },
                    {
                        "username": "MehtaParth",
                        "content": "class Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        if (needle.empty()) {\\n            return 0;\\n        }\\n        \\n        int j = 0;\\n        int x = -1;\\n        for (int i = 0; i < haystack.size(); i++) {\\n            if (haystack[i] == needle[j]) {\\n                if (j == 0) {\\n                    x = i;  \\n                }\\n                j++;\\n                if (j == needle.size()) {\\n                    return x;  \\n                }\\n            } else {\\n                j = 0;  \\n                x = -1;\\n            }\\n        }\\n        \\n        return -1;  \\n    }\\n};\\n\\n\\nThis code fails to find \"issip\" in \"mississippi\".\\nCan someone find the error"
                    },
                    {
                        "username": "Izaki11",
                        "content": "After failing the check at \\'p\\', the loop continues past the previous \\'i\\', which is where the \"needle\" starts."
                    },
                    {
                        "username": "cheesebread",
                        "content": "...why is this is a medium? Seems pretty straightforward to me"
                    }
                ]
            },
            {
                "id": 1569522,
                "content": [
                    {
                        "username": "lzhao",
                        "content": "The problem states that it should return the first occurrence. Is it the same as needle?"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "People who are using built in functions do you think ur solution will be accepted in an interview?"
                    },
                    {
                        "username": "atifhu",
                        "content": "Those who are using in built functions are the ones who will say after their interview \"kya pta interviewer kch KMP aur Z- algo k bare me bol rha tha\" :D"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Is it right to use sliding window approach here with string library function...\\nAs I have used to get correct answer"
                    },
                    {
                        "username": "rexhu100",
                        "content": "This is not a easy problem. I know using built-in hashing function is easy, and probably passible. But the intent for the problem is obviously to use Karp-Rabin, which is not easy at all to implement from scratch."
                    },
                    {
                        "username": "pratikjain227",
                        "content": "\\ttry:\\n\\t\\treturn haystack.index(needle)\\n\\texcept:\\n\\t\\treturn -1\\n\\n"
                    },
                    {
                        "username": "minh-nguyen-mqn",
                        "content": "or just return haystack.find(needle)"
                    },
                    {
                        "username": "Wasant_from_asia",
                        "content": "return haystack.indexOf(needle);"
                    },
                    {
                        "username": "czkudo",
                        "content": "see title. what's the meaning of this problem if we can just use indexOf()"
                    },
                    {
                        "username": "Robin_Rathore",
                        "content": "Although This (return haystack.find(needle); ) beats 100% of CPP users, but to practice problems genuinely not just to increase the no. we should do it with our own logic not with any lib fun.\n"
                    },
                    {
                        "username": "syfo_dias",
                        "content": "exactly. Because it doesn't make any sense otherwise. It's like solving a sorting problem by using std::sort"
                    },
                    {
                        "username": "MehtaParth",
                        "content": "class Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        if (needle.empty()) {\\n            return 0;\\n        }\\n        \\n        int j = 0;\\n        int x = -1;\\n        for (int i = 0; i < haystack.size(); i++) {\\n            if (haystack[i] == needle[j]) {\\n                if (j == 0) {\\n                    x = i;  \\n                }\\n                j++;\\n                if (j == needle.size()) {\\n                    return x;  \\n                }\\n            } else {\\n                j = 0;  \\n                x = -1;\\n            }\\n        }\\n        \\n        return -1;  \\n    }\\n};\\n\\n\\nThis code fails to find \"issip\" in \"mississippi\".\\nCan someone find the error"
                    },
                    {
                        "username": "Izaki11",
                        "content": "After failing the check at \\'p\\', the loop continues past the previous \\'i\\', which is where the \"needle\" starts."
                    },
                    {
                        "username": "cheesebread",
                        "content": "...why is this is a medium? Seems pretty straightforward to me"
                    }
                ]
            },
            {
                "id": 1568847,
                "content": [
                    {
                        "username": "lzhao",
                        "content": "The problem states that it should return the first occurrence. Is it the same as needle?"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "People who are using built in functions do you think ur solution will be accepted in an interview?"
                    },
                    {
                        "username": "atifhu",
                        "content": "Those who are using in built functions are the ones who will say after their interview \"kya pta interviewer kch KMP aur Z- algo k bare me bol rha tha\" :D"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Is it right to use sliding window approach here with string library function...\\nAs I have used to get correct answer"
                    },
                    {
                        "username": "rexhu100",
                        "content": "This is not a easy problem. I know using built-in hashing function is easy, and probably passible. But the intent for the problem is obviously to use Karp-Rabin, which is not easy at all to implement from scratch."
                    },
                    {
                        "username": "pratikjain227",
                        "content": "\\ttry:\\n\\t\\treturn haystack.index(needle)\\n\\texcept:\\n\\t\\treturn -1\\n\\n"
                    },
                    {
                        "username": "minh-nguyen-mqn",
                        "content": "or just return haystack.find(needle)"
                    },
                    {
                        "username": "Wasant_from_asia",
                        "content": "return haystack.indexOf(needle);"
                    },
                    {
                        "username": "czkudo",
                        "content": "see title. what's the meaning of this problem if we can just use indexOf()"
                    },
                    {
                        "username": "Robin_Rathore",
                        "content": "Although This (return haystack.find(needle); ) beats 100% of CPP users, but to practice problems genuinely not just to increase the no. we should do it with our own logic not with any lib fun.\n"
                    },
                    {
                        "username": "syfo_dias",
                        "content": "exactly. Because it doesn't make any sense otherwise. It's like solving a sorting problem by using std::sort"
                    },
                    {
                        "username": "MehtaParth",
                        "content": "class Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        if (needle.empty()) {\\n            return 0;\\n        }\\n        \\n        int j = 0;\\n        int x = -1;\\n        for (int i = 0; i < haystack.size(); i++) {\\n            if (haystack[i] == needle[j]) {\\n                if (j == 0) {\\n                    x = i;  \\n                }\\n                j++;\\n                if (j == needle.size()) {\\n                    return x;  \\n                }\\n            } else {\\n                j = 0;  \\n                x = -1;\\n            }\\n        }\\n        \\n        return -1;  \\n    }\\n};\\n\\n\\nThis code fails to find \"issip\" in \"mississippi\".\\nCan someone find the error"
                    },
                    {
                        "username": "Izaki11",
                        "content": "After failing the check at \\'p\\', the loop continues past the previous \\'i\\', which is where the \"needle\" starts."
                    },
                    {
                        "username": "cheesebread",
                        "content": "...why is this is a medium? Seems pretty straightforward to me"
                    }
                ]
            },
            {
                "id": 2036478,
                "content": [
                    {
                        "username": "lzhao",
                        "content": "The problem states that it should return the first occurrence. Is it the same as needle?"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "People who are using built in functions do you think ur solution will be accepted in an interview?"
                    },
                    {
                        "username": "atifhu",
                        "content": "Those who are using in built functions are the ones who will say after their interview \"kya pta interviewer kch KMP aur Z- algo k bare me bol rha tha\" :D"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Is it right to use sliding window approach here with string library function...\\nAs I have used to get correct answer"
                    },
                    {
                        "username": "rexhu100",
                        "content": "This is not a easy problem. I know using built-in hashing function is easy, and probably passible. But the intent for the problem is obviously to use Karp-Rabin, which is not easy at all to implement from scratch."
                    },
                    {
                        "username": "pratikjain227",
                        "content": "\\ttry:\\n\\t\\treturn haystack.index(needle)\\n\\texcept:\\n\\t\\treturn -1\\n\\n"
                    },
                    {
                        "username": "minh-nguyen-mqn",
                        "content": "or just return haystack.find(needle)"
                    },
                    {
                        "username": "Wasant_from_asia",
                        "content": "return haystack.indexOf(needle);"
                    },
                    {
                        "username": "czkudo",
                        "content": "see title. what's the meaning of this problem if we can just use indexOf()"
                    },
                    {
                        "username": "Robin_Rathore",
                        "content": "Although This (return haystack.find(needle); ) beats 100% of CPP users, but to practice problems genuinely not just to increase the no. we should do it with our own logic not with any lib fun.\n"
                    },
                    {
                        "username": "syfo_dias",
                        "content": "exactly. Because it doesn't make any sense otherwise. It's like solving a sorting problem by using std::sort"
                    },
                    {
                        "username": "MehtaParth",
                        "content": "class Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        if (needle.empty()) {\\n            return 0;\\n        }\\n        \\n        int j = 0;\\n        int x = -1;\\n        for (int i = 0; i < haystack.size(); i++) {\\n            if (haystack[i] == needle[j]) {\\n                if (j == 0) {\\n                    x = i;  \\n                }\\n                j++;\\n                if (j == needle.size()) {\\n                    return x;  \\n                }\\n            } else {\\n                j = 0;  \\n                x = -1;\\n            }\\n        }\\n        \\n        return -1;  \\n    }\\n};\\n\\n\\nThis code fails to find \"issip\" in \"mississippi\".\\nCan someone find the error"
                    },
                    {
                        "username": "Izaki11",
                        "content": "After failing the check at \\'p\\', the loop continues past the previous \\'i\\', which is where the \"needle\" starts."
                    },
                    {
                        "username": "cheesebread",
                        "content": "...why is this is a medium? Seems pretty straightforward to me"
                    }
                ]
            },
            {
                "id": 1923412,
                "content": [
                    {
                        "username": "lzhao",
                        "content": "The problem states that it should return the first occurrence. Is it the same as needle?"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "People who are using built in functions do you think ur solution will be accepted in an interview?"
                    },
                    {
                        "username": "atifhu",
                        "content": "Those who are using in built functions are the ones who will say after their interview \"kya pta interviewer kch KMP aur Z- algo k bare me bol rha tha\" :D"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Is it right to use sliding window approach here with string library function...\\nAs I have used to get correct answer"
                    },
                    {
                        "username": "rexhu100",
                        "content": "This is not a easy problem. I know using built-in hashing function is easy, and probably passible. But the intent for the problem is obviously to use Karp-Rabin, which is not easy at all to implement from scratch."
                    },
                    {
                        "username": "pratikjain227",
                        "content": "\\ttry:\\n\\t\\treturn haystack.index(needle)\\n\\texcept:\\n\\t\\treturn -1\\n\\n"
                    },
                    {
                        "username": "minh-nguyen-mqn",
                        "content": "or just return haystack.find(needle)"
                    },
                    {
                        "username": "Wasant_from_asia",
                        "content": "return haystack.indexOf(needle);"
                    },
                    {
                        "username": "czkudo",
                        "content": "see title. what's the meaning of this problem if we can just use indexOf()"
                    },
                    {
                        "username": "Robin_Rathore",
                        "content": "Although This (return haystack.find(needle); ) beats 100% of CPP users, but to practice problems genuinely not just to increase the no. we should do it with our own logic not with any lib fun.\n"
                    },
                    {
                        "username": "syfo_dias",
                        "content": "exactly. Because it doesn't make any sense otherwise. It's like solving a sorting problem by using std::sort"
                    },
                    {
                        "username": "MehtaParth",
                        "content": "class Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        if (needle.empty()) {\\n            return 0;\\n        }\\n        \\n        int j = 0;\\n        int x = -1;\\n        for (int i = 0; i < haystack.size(); i++) {\\n            if (haystack[i] == needle[j]) {\\n                if (j == 0) {\\n                    x = i;  \\n                }\\n                j++;\\n                if (j == needle.size()) {\\n                    return x;  \\n                }\\n            } else {\\n                j = 0;  \\n                x = -1;\\n            }\\n        }\\n        \\n        return -1;  \\n    }\\n};\\n\\n\\nThis code fails to find \"issip\" in \"mississippi\".\\nCan someone find the error"
                    },
                    {
                        "username": "Izaki11",
                        "content": "After failing the check at \\'p\\', the loop continues past the previous \\'i\\', which is where the \"needle\" starts."
                    },
                    {
                        "username": "cheesebread",
                        "content": "...why is this is a medium? Seems pretty straightforward to me"
                    }
                ]
            },
            {
                "id": 1820037,
                "content": [
                    {
                        "username": "lzhao",
                        "content": "The problem states that it should return the first occurrence. Is it the same as needle?"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "People who are using built in functions do you think ur solution will be accepted in an interview?"
                    },
                    {
                        "username": "atifhu",
                        "content": "Those who are using in built functions are the ones who will say after their interview \"kya pta interviewer kch KMP aur Z- algo k bare me bol rha tha\" :D"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Is it right to use sliding window approach here with string library function...\\nAs I have used to get correct answer"
                    },
                    {
                        "username": "rexhu100",
                        "content": "This is not a easy problem. I know using built-in hashing function is easy, and probably passible. But the intent for the problem is obviously to use Karp-Rabin, which is not easy at all to implement from scratch."
                    },
                    {
                        "username": "pratikjain227",
                        "content": "\\ttry:\\n\\t\\treturn haystack.index(needle)\\n\\texcept:\\n\\t\\treturn -1\\n\\n"
                    },
                    {
                        "username": "minh-nguyen-mqn",
                        "content": "or just return haystack.find(needle)"
                    },
                    {
                        "username": "Wasant_from_asia",
                        "content": "return haystack.indexOf(needle);"
                    },
                    {
                        "username": "czkudo",
                        "content": "see title. what's the meaning of this problem if we can just use indexOf()"
                    },
                    {
                        "username": "Robin_Rathore",
                        "content": "Although This (return haystack.find(needle); ) beats 100% of CPP users, but to practice problems genuinely not just to increase the no. we should do it with our own logic not with any lib fun.\n"
                    },
                    {
                        "username": "syfo_dias",
                        "content": "exactly. Because it doesn't make any sense otherwise. It's like solving a sorting problem by using std::sort"
                    },
                    {
                        "username": "MehtaParth",
                        "content": "class Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        if (needle.empty()) {\\n            return 0;\\n        }\\n        \\n        int j = 0;\\n        int x = -1;\\n        for (int i = 0; i < haystack.size(); i++) {\\n            if (haystack[i] == needle[j]) {\\n                if (j == 0) {\\n                    x = i;  \\n                }\\n                j++;\\n                if (j == needle.size()) {\\n                    return x;  \\n                }\\n            } else {\\n                j = 0;  \\n                x = -1;\\n            }\\n        }\\n        \\n        return -1;  \\n    }\\n};\\n\\n\\nThis code fails to find \"issip\" in \"mississippi\".\\nCan someone find the error"
                    },
                    {
                        "username": "Izaki11",
                        "content": "After failing the check at \\'p\\', the loop continues past the previous \\'i\\', which is where the \"needle\" starts."
                    },
                    {
                        "username": "cheesebread",
                        "content": "...why is this is a medium? Seems pretty straightforward to me"
                    }
                ]
            },
            {
                "id": 1819992,
                "content": [
                    {
                        "username": "dunglee30",
                        "content": "Move to submission to find how can they solve this in O(n+m) and 0ms just to see \n```haystack.indexOf(needle)``` =)))))"
                    },
                    {
                        "username": "dunglee30",
                        "content": "[@Swapnil07072000](/Swapnil07072000) I did solve it without built-in function bro :)) It just funny story that some of the best solutions were built-in function and got accepted."
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Try using Two-pointer approach and not built-in function."
                    },
                    {
                        "username": "c4tdog",
                        "content": "you think leetcode wants you to use builtin function? think again"
                    },
                    {
                        "username": "NatureSon22",
                        "content": "Is it okay to use data structure in solving this?"
                    },
                    {
                        "username": "NatureSon22",
                        "content": "I want to use one but it makes me feel illegal\\n"
                    },
                    {
                        "username": "prasadnr606",
                        "content": "The solution is in the subject-line."
                    },
                    {
                        "username": "rayray0706",
                        "content": "![image](https://assets.leetcode.com/users/images/87152572-92da-491b-84df-2b9ab40e7c5a_1635980565.4132447.png)\\n\\n\\nHopefully, theres not a simple reason for this I\\'m missing, but I\\'m not understanding why I\\'m getting this error on this test case and on this line of code. There was another LeetCode problem that was giving me the same error, and I\\'m afraid its my browser or something."
                    },
                    {
                        "username": "tirupati",
                        "content": "Not sure there are so many posts titled with n complexcity but its not.\\n\\nIf you are not using KMP and using two pointers then complexcity would be n * m because we have two loops. One of iterating main string(outer-loop complexcity n-m) and other for checking in the sub string (inner-loop complexcity m).\\ncomplexcity: (n - m) * m = O(nm)\\n\\nReference: https://leetcode.com/problems/implement-strstr/"
                    },
                    {
                        "username": "ChenYehChien001",
                        "content": "![image](https://assets.leetcode.com/users/images/c7ddb51f-f40c-43c3-b10a-6072341a7681_1621912158.6232688.png)\\n"
                    },
                    {
                        "username": "adrianyang2012",
                        "content": "\\'\\'\\'\\nreturn haystack.find(needle)\\n\\'\\'\\'"
                    },
                    {
                        "username": "sknavin369",
                        "content": "The best way to get the position of the first Occurence of needle in haystack is to go with **strstr in-built String Function**, which returns the pointer of the first occurence of needle. Else it returns NULL.\\n\\n\\tint strStr(char * haystack, char * needle){\\n\\t\\t\\n\\t\\tchar *pos = strstr(haystack, needle);\\n\\t\\treturn pos ? pos-haystack : -1;\\n\\t}"
                    },
                    {
                        "username": "jeetrainer",
                        "content": "Link of solution: https://youtu.be/4yT8mpJxHks"
                    },
                    {
                        "username": "BroCode01",
                        "content": "https://youtu.be/TsxFvVy_5m0"
                    }
                ]
            },
            {
                "id": 1631521,
                "content": [
                    {
                        "username": "dunglee30",
                        "content": "Move to submission to find how can they solve this in O(n+m) and 0ms just to see \n```haystack.indexOf(needle)``` =)))))"
                    },
                    {
                        "username": "dunglee30",
                        "content": "[@Swapnil07072000](/Swapnil07072000) I did solve it without built-in function bro :)) It just funny story that some of the best solutions were built-in function and got accepted."
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Try using Two-pointer approach and not built-in function."
                    },
                    {
                        "username": "c4tdog",
                        "content": "you think leetcode wants you to use builtin function? think again"
                    },
                    {
                        "username": "NatureSon22",
                        "content": "Is it okay to use data structure in solving this?"
                    },
                    {
                        "username": "NatureSon22",
                        "content": "I want to use one but it makes me feel illegal\\n"
                    },
                    {
                        "username": "prasadnr606",
                        "content": "The solution is in the subject-line."
                    },
                    {
                        "username": "rayray0706",
                        "content": "![image](https://assets.leetcode.com/users/images/87152572-92da-491b-84df-2b9ab40e7c5a_1635980565.4132447.png)\\n\\n\\nHopefully, theres not a simple reason for this I\\'m missing, but I\\'m not understanding why I\\'m getting this error on this test case and on this line of code. There was another LeetCode problem that was giving me the same error, and I\\'m afraid its my browser or something."
                    },
                    {
                        "username": "tirupati",
                        "content": "Not sure there are so many posts titled with n complexcity but its not.\\n\\nIf you are not using KMP and using two pointers then complexcity would be n * m because we have two loops. One of iterating main string(outer-loop complexcity n-m) and other for checking in the sub string (inner-loop complexcity m).\\ncomplexcity: (n - m) * m = O(nm)\\n\\nReference: https://leetcode.com/problems/implement-strstr/"
                    },
                    {
                        "username": "ChenYehChien001",
                        "content": "![image](https://assets.leetcode.com/users/images/c7ddb51f-f40c-43c3-b10a-6072341a7681_1621912158.6232688.png)\\n"
                    },
                    {
                        "username": "adrianyang2012",
                        "content": "\\'\\'\\'\\nreturn haystack.find(needle)\\n\\'\\'\\'"
                    },
                    {
                        "username": "sknavin369",
                        "content": "The best way to get the position of the first Occurence of needle in haystack is to go with **strstr in-built String Function**, which returns the pointer of the first occurence of needle. Else it returns NULL.\\n\\n\\tint strStr(char * haystack, char * needle){\\n\\t\\t\\n\\t\\tchar *pos = strstr(haystack, needle);\\n\\t\\treturn pos ? pos-haystack : -1;\\n\\t}"
                    },
                    {
                        "username": "jeetrainer",
                        "content": "Link of solution: https://youtu.be/4yT8mpJxHks"
                    },
                    {
                        "username": "BroCode01",
                        "content": "https://youtu.be/TsxFvVy_5m0"
                    }
                ]
            },
            {
                "id": 1576975,
                "content": [
                    {
                        "username": "dunglee30",
                        "content": "Move to submission to find how can they solve this in O(n+m) and 0ms just to see \n```haystack.indexOf(needle)``` =)))))"
                    },
                    {
                        "username": "dunglee30",
                        "content": "[@Swapnil07072000](/Swapnil07072000) I did solve it without built-in function bro :)) It just funny story that some of the best solutions were built-in function and got accepted."
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Try using Two-pointer approach and not built-in function."
                    },
                    {
                        "username": "c4tdog",
                        "content": "you think leetcode wants you to use builtin function? think again"
                    },
                    {
                        "username": "NatureSon22",
                        "content": "Is it okay to use data structure in solving this?"
                    },
                    {
                        "username": "NatureSon22",
                        "content": "I want to use one but it makes me feel illegal\\n"
                    },
                    {
                        "username": "prasadnr606",
                        "content": "The solution is in the subject-line."
                    },
                    {
                        "username": "rayray0706",
                        "content": "![image](https://assets.leetcode.com/users/images/87152572-92da-491b-84df-2b9ab40e7c5a_1635980565.4132447.png)\\n\\n\\nHopefully, theres not a simple reason for this I\\'m missing, but I\\'m not understanding why I\\'m getting this error on this test case and on this line of code. There was another LeetCode problem that was giving me the same error, and I\\'m afraid its my browser or something."
                    },
                    {
                        "username": "tirupati",
                        "content": "Not sure there are so many posts titled with n complexcity but its not.\\n\\nIf you are not using KMP and using two pointers then complexcity would be n * m because we have two loops. One of iterating main string(outer-loop complexcity n-m) and other for checking in the sub string (inner-loop complexcity m).\\ncomplexcity: (n - m) * m = O(nm)\\n\\nReference: https://leetcode.com/problems/implement-strstr/"
                    },
                    {
                        "username": "ChenYehChien001",
                        "content": "![image](https://assets.leetcode.com/users/images/c7ddb51f-f40c-43c3-b10a-6072341a7681_1621912158.6232688.png)\\n"
                    },
                    {
                        "username": "adrianyang2012",
                        "content": "\\'\\'\\'\\nreturn haystack.find(needle)\\n\\'\\'\\'"
                    },
                    {
                        "username": "sknavin369",
                        "content": "The best way to get the position of the first Occurence of needle in haystack is to go with **strstr in-built String Function**, which returns the pointer of the first occurence of needle. Else it returns NULL.\\n\\n\\tint strStr(char * haystack, char * needle){\\n\\t\\t\\n\\t\\tchar *pos = strstr(haystack, needle);\\n\\t\\treturn pos ? pos-haystack : -1;\\n\\t}"
                    },
                    {
                        "username": "jeetrainer",
                        "content": "Link of solution: https://youtu.be/4yT8mpJxHks"
                    },
                    {
                        "username": "BroCode01",
                        "content": "https://youtu.be/TsxFvVy_5m0"
                    }
                ]
            },
            {
                "id": 1575928,
                "content": [
                    {
                        "username": "dunglee30",
                        "content": "Move to submission to find how can they solve this in O(n+m) and 0ms just to see \n```haystack.indexOf(needle)``` =)))))"
                    },
                    {
                        "username": "dunglee30",
                        "content": "[@Swapnil07072000](/Swapnil07072000) I did solve it without built-in function bro :)) It just funny story that some of the best solutions were built-in function and got accepted."
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Try using Two-pointer approach and not built-in function."
                    },
                    {
                        "username": "c4tdog",
                        "content": "you think leetcode wants you to use builtin function? think again"
                    },
                    {
                        "username": "NatureSon22",
                        "content": "Is it okay to use data structure in solving this?"
                    },
                    {
                        "username": "NatureSon22",
                        "content": "I want to use one but it makes me feel illegal\\n"
                    },
                    {
                        "username": "prasadnr606",
                        "content": "The solution is in the subject-line."
                    },
                    {
                        "username": "rayray0706",
                        "content": "![image](https://assets.leetcode.com/users/images/87152572-92da-491b-84df-2b9ab40e7c5a_1635980565.4132447.png)\\n\\n\\nHopefully, theres not a simple reason for this I\\'m missing, but I\\'m not understanding why I\\'m getting this error on this test case and on this line of code. There was another LeetCode problem that was giving me the same error, and I\\'m afraid its my browser or something."
                    },
                    {
                        "username": "tirupati",
                        "content": "Not sure there are so many posts titled with n complexcity but its not.\\n\\nIf you are not using KMP and using two pointers then complexcity would be n * m because we have two loops. One of iterating main string(outer-loop complexcity n-m) and other for checking in the sub string (inner-loop complexcity m).\\ncomplexcity: (n - m) * m = O(nm)\\n\\nReference: https://leetcode.com/problems/implement-strstr/"
                    },
                    {
                        "username": "ChenYehChien001",
                        "content": "![image](https://assets.leetcode.com/users/images/c7ddb51f-f40c-43c3-b10a-6072341a7681_1621912158.6232688.png)\\n"
                    },
                    {
                        "username": "adrianyang2012",
                        "content": "\\'\\'\\'\\nreturn haystack.find(needle)\\n\\'\\'\\'"
                    },
                    {
                        "username": "sknavin369",
                        "content": "The best way to get the position of the first Occurence of needle in haystack is to go with **strstr in-built String Function**, which returns the pointer of the first occurence of needle. Else it returns NULL.\\n\\n\\tint strStr(char * haystack, char * needle){\\n\\t\\t\\n\\t\\tchar *pos = strstr(haystack, needle);\\n\\t\\treturn pos ? pos-haystack : -1;\\n\\t}"
                    },
                    {
                        "username": "jeetrainer",
                        "content": "Link of solution: https://youtu.be/4yT8mpJxHks"
                    },
                    {
                        "username": "BroCode01",
                        "content": "https://youtu.be/TsxFvVy_5m0"
                    }
                ]
            },
            {
                "id": 1575336,
                "content": [
                    {
                        "username": "dunglee30",
                        "content": "Move to submission to find how can they solve this in O(n+m) and 0ms just to see \n```haystack.indexOf(needle)``` =)))))"
                    },
                    {
                        "username": "dunglee30",
                        "content": "[@Swapnil07072000](/Swapnil07072000) I did solve it without built-in function bro :)) It just funny story that some of the best solutions were built-in function and got accepted."
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Try using Two-pointer approach and not built-in function."
                    },
                    {
                        "username": "c4tdog",
                        "content": "you think leetcode wants you to use builtin function? think again"
                    },
                    {
                        "username": "NatureSon22",
                        "content": "Is it okay to use data structure in solving this?"
                    },
                    {
                        "username": "NatureSon22",
                        "content": "I want to use one but it makes me feel illegal\\n"
                    },
                    {
                        "username": "prasadnr606",
                        "content": "The solution is in the subject-line."
                    },
                    {
                        "username": "rayray0706",
                        "content": "![image](https://assets.leetcode.com/users/images/87152572-92da-491b-84df-2b9ab40e7c5a_1635980565.4132447.png)\\n\\n\\nHopefully, theres not a simple reason for this I\\'m missing, but I\\'m not understanding why I\\'m getting this error on this test case and on this line of code. There was another LeetCode problem that was giving me the same error, and I\\'m afraid its my browser or something."
                    },
                    {
                        "username": "tirupati",
                        "content": "Not sure there are so many posts titled with n complexcity but its not.\\n\\nIf you are not using KMP and using two pointers then complexcity would be n * m because we have two loops. One of iterating main string(outer-loop complexcity n-m) and other for checking in the sub string (inner-loop complexcity m).\\ncomplexcity: (n - m) * m = O(nm)\\n\\nReference: https://leetcode.com/problems/implement-strstr/"
                    },
                    {
                        "username": "ChenYehChien001",
                        "content": "![image](https://assets.leetcode.com/users/images/c7ddb51f-f40c-43c3-b10a-6072341a7681_1621912158.6232688.png)\\n"
                    },
                    {
                        "username": "adrianyang2012",
                        "content": "\\'\\'\\'\\nreturn haystack.find(needle)\\n\\'\\'\\'"
                    },
                    {
                        "username": "sknavin369",
                        "content": "The best way to get the position of the first Occurence of needle in haystack is to go with **strstr in-built String Function**, which returns the pointer of the first occurence of needle. Else it returns NULL.\\n\\n\\tint strStr(char * haystack, char * needle){\\n\\t\\t\\n\\t\\tchar *pos = strstr(haystack, needle);\\n\\t\\treturn pos ? pos-haystack : -1;\\n\\t}"
                    },
                    {
                        "username": "jeetrainer",
                        "content": "Link of solution: https://youtu.be/4yT8mpJxHks"
                    },
                    {
                        "username": "BroCode01",
                        "content": "https://youtu.be/TsxFvVy_5m0"
                    }
                ]
            },
            {
                "id": 1575306,
                "content": [
                    {
                        "username": "dunglee30",
                        "content": "Move to submission to find how can they solve this in O(n+m) and 0ms just to see \n```haystack.indexOf(needle)``` =)))))"
                    },
                    {
                        "username": "dunglee30",
                        "content": "[@Swapnil07072000](/Swapnil07072000) I did solve it without built-in function bro :)) It just funny story that some of the best solutions were built-in function and got accepted."
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Try using Two-pointer approach and not built-in function."
                    },
                    {
                        "username": "c4tdog",
                        "content": "you think leetcode wants you to use builtin function? think again"
                    },
                    {
                        "username": "NatureSon22",
                        "content": "Is it okay to use data structure in solving this?"
                    },
                    {
                        "username": "NatureSon22",
                        "content": "I want to use one but it makes me feel illegal\\n"
                    },
                    {
                        "username": "prasadnr606",
                        "content": "The solution is in the subject-line."
                    },
                    {
                        "username": "rayray0706",
                        "content": "![image](https://assets.leetcode.com/users/images/87152572-92da-491b-84df-2b9ab40e7c5a_1635980565.4132447.png)\\n\\n\\nHopefully, theres not a simple reason for this I\\'m missing, but I\\'m not understanding why I\\'m getting this error on this test case and on this line of code. There was another LeetCode problem that was giving me the same error, and I\\'m afraid its my browser or something."
                    },
                    {
                        "username": "tirupati",
                        "content": "Not sure there are so many posts titled with n complexcity but its not.\\n\\nIf you are not using KMP and using two pointers then complexcity would be n * m because we have two loops. One of iterating main string(outer-loop complexcity n-m) and other for checking in the sub string (inner-loop complexcity m).\\ncomplexcity: (n - m) * m = O(nm)\\n\\nReference: https://leetcode.com/problems/implement-strstr/"
                    },
                    {
                        "username": "ChenYehChien001",
                        "content": "![image](https://assets.leetcode.com/users/images/c7ddb51f-f40c-43c3-b10a-6072341a7681_1621912158.6232688.png)\\n"
                    },
                    {
                        "username": "adrianyang2012",
                        "content": "\\'\\'\\'\\nreturn haystack.find(needle)\\n\\'\\'\\'"
                    },
                    {
                        "username": "sknavin369",
                        "content": "The best way to get the position of the first Occurence of needle in haystack is to go with **strstr in-built String Function**, which returns the pointer of the first occurence of needle. Else it returns NULL.\\n\\n\\tint strStr(char * haystack, char * needle){\\n\\t\\t\\n\\t\\tchar *pos = strstr(haystack, needle);\\n\\t\\treturn pos ? pos-haystack : -1;\\n\\t}"
                    },
                    {
                        "username": "jeetrainer",
                        "content": "Link of solution: https://youtu.be/4yT8mpJxHks"
                    },
                    {
                        "username": "BroCode01",
                        "content": "https://youtu.be/TsxFvVy_5m0"
                    }
                ]
            },
            {
                "id": 1575135,
                "content": [
                    {
                        "username": "dunglee30",
                        "content": "Move to submission to find how can they solve this in O(n+m) and 0ms just to see \n```haystack.indexOf(needle)``` =)))))"
                    },
                    {
                        "username": "dunglee30",
                        "content": "[@Swapnil07072000](/Swapnil07072000) I did solve it without built-in function bro :)) It just funny story that some of the best solutions were built-in function and got accepted."
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Try using Two-pointer approach and not built-in function."
                    },
                    {
                        "username": "c4tdog",
                        "content": "you think leetcode wants you to use builtin function? think again"
                    },
                    {
                        "username": "NatureSon22",
                        "content": "Is it okay to use data structure in solving this?"
                    },
                    {
                        "username": "NatureSon22",
                        "content": "I want to use one but it makes me feel illegal\\n"
                    },
                    {
                        "username": "prasadnr606",
                        "content": "The solution is in the subject-line."
                    },
                    {
                        "username": "rayray0706",
                        "content": "![image](https://assets.leetcode.com/users/images/87152572-92da-491b-84df-2b9ab40e7c5a_1635980565.4132447.png)\\n\\n\\nHopefully, theres not a simple reason for this I\\'m missing, but I\\'m not understanding why I\\'m getting this error on this test case and on this line of code. There was another LeetCode problem that was giving me the same error, and I\\'m afraid its my browser or something."
                    },
                    {
                        "username": "tirupati",
                        "content": "Not sure there are so many posts titled with n complexcity but its not.\\n\\nIf you are not using KMP and using two pointers then complexcity would be n * m because we have two loops. One of iterating main string(outer-loop complexcity n-m) and other for checking in the sub string (inner-loop complexcity m).\\ncomplexcity: (n - m) * m = O(nm)\\n\\nReference: https://leetcode.com/problems/implement-strstr/"
                    },
                    {
                        "username": "ChenYehChien001",
                        "content": "![image](https://assets.leetcode.com/users/images/c7ddb51f-f40c-43c3-b10a-6072341a7681_1621912158.6232688.png)\\n"
                    },
                    {
                        "username": "adrianyang2012",
                        "content": "\\'\\'\\'\\nreturn haystack.find(needle)\\n\\'\\'\\'"
                    },
                    {
                        "username": "sknavin369",
                        "content": "The best way to get the position of the first Occurence of needle in haystack is to go with **strstr in-built String Function**, which returns the pointer of the first occurence of needle. Else it returns NULL.\\n\\n\\tint strStr(char * haystack, char * needle){\\n\\t\\t\\n\\t\\tchar *pos = strstr(haystack, needle);\\n\\t\\treturn pos ? pos-haystack : -1;\\n\\t}"
                    },
                    {
                        "username": "jeetrainer",
                        "content": "Link of solution: https://youtu.be/4yT8mpJxHks"
                    },
                    {
                        "username": "BroCode01",
                        "content": "https://youtu.be/TsxFvVy_5m0"
                    }
                ]
            },
            {
                "id": 1574277,
                "content": [
                    {
                        "username": "dunglee30",
                        "content": "Move to submission to find how can they solve this in O(n+m) and 0ms just to see \n```haystack.indexOf(needle)``` =)))))"
                    },
                    {
                        "username": "dunglee30",
                        "content": "[@Swapnil07072000](/Swapnil07072000) I did solve it without built-in function bro :)) It just funny story that some of the best solutions were built-in function and got accepted."
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Try using Two-pointer approach and not built-in function."
                    },
                    {
                        "username": "c4tdog",
                        "content": "you think leetcode wants you to use builtin function? think again"
                    },
                    {
                        "username": "NatureSon22",
                        "content": "Is it okay to use data structure in solving this?"
                    },
                    {
                        "username": "NatureSon22",
                        "content": "I want to use one but it makes me feel illegal\\n"
                    },
                    {
                        "username": "prasadnr606",
                        "content": "The solution is in the subject-line."
                    },
                    {
                        "username": "rayray0706",
                        "content": "![image](https://assets.leetcode.com/users/images/87152572-92da-491b-84df-2b9ab40e7c5a_1635980565.4132447.png)\\n\\n\\nHopefully, theres not a simple reason for this I\\'m missing, but I\\'m not understanding why I\\'m getting this error on this test case and on this line of code. There was another LeetCode problem that was giving me the same error, and I\\'m afraid its my browser or something."
                    },
                    {
                        "username": "tirupati",
                        "content": "Not sure there are so many posts titled with n complexcity but its not.\\n\\nIf you are not using KMP and using two pointers then complexcity would be n * m because we have two loops. One of iterating main string(outer-loop complexcity n-m) and other for checking in the sub string (inner-loop complexcity m).\\ncomplexcity: (n - m) * m = O(nm)\\n\\nReference: https://leetcode.com/problems/implement-strstr/"
                    },
                    {
                        "username": "ChenYehChien001",
                        "content": "![image](https://assets.leetcode.com/users/images/c7ddb51f-f40c-43c3-b10a-6072341a7681_1621912158.6232688.png)\\n"
                    },
                    {
                        "username": "adrianyang2012",
                        "content": "\\'\\'\\'\\nreturn haystack.find(needle)\\n\\'\\'\\'"
                    },
                    {
                        "username": "sknavin369",
                        "content": "The best way to get the position of the first Occurence of needle in haystack is to go with **strstr in-built String Function**, which returns the pointer of the first occurence of needle. Else it returns NULL.\\n\\n\\tint strStr(char * haystack, char * needle){\\n\\t\\t\\n\\t\\tchar *pos = strstr(haystack, needle);\\n\\t\\treturn pos ? pos-haystack : -1;\\n\\t}"
                    },
                    {
                        "username": "jeetrainer",
                        "content": "Link of solution: https://youtu.be/4yT8mpJxHks"
                    },
                    {
                        "username": "BroCode01",
                        "content": "https://youtu.be/TsxFvVy_5m0"
                    }
                ]
            },
            {
                "id": 1574187,
                "content": [
                    {
                        "username": "dunglee30",
                        "content": "Move to submission to find how can they solve this in O(n+m) and 0ms just to see \n```haystack.indexOf(needle)``` =)))))"
                    },
                    {
                        "username": "dunglee30",
                        "content": "[@Swapnil07072000](/Swapnil07072000) I did solve it without built-in function bro :)) It just funny story that some of the best solutions were built-in function and got accepted."
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Try using Two-pointer approach and not built-in function."
                    },
                    {
                        "username": "c4tdog",
                        "content": "you think leetcode wants you to use builtin function? think again"
                    },
                    {
                        "username": "NatureSon22",
                        "content": "Is it okay to use data structure in solving this?"
                    },
                    {
                        "username": "NatureSon22",
                        "content": "I want to use one but it makes me feel illegal\\n"
                    },
                    {
                        "username": "prasadnr606",
                        "content": "The solution is in the subject-line."
                    },
                    {
                        "username": "rayray0706",
                        "content": "![image](https://assets.leetcode.com/users/images/87152572-92da-491b-84df-2b9ab40e7c5a_1635980565.4132447.png)\\n\\n\\nHopefully, theres not a simple reason for this I\\'m missing, but I\\'m not understanding why I\\'m getting this error on this test case and on this line of code. There was another LeetCode problem that was giving me the same error, and I\\'m afraid its my browser or something."
                    },
                    {
                        "username": "tirupati",
                        "content": "Not sure there are so many posts titled with n complexcity but its not.\\n\\nIf you are not using KMP and using two pointers then complexcity would be n * m because we have two loops. One of iterating main string(outer-loop complexcity n-m) and other for checking in the sub string (inner-loop complexcity m).\\ncomplexcity: (n - m) * m = O(nm)\\n\\nReference: https://leetcode.com/problems/implement-strstr/"
                    },
                    {
                        "username": "ChenYehChien001",
                        "content": "![image](https://assets.leetcode.com/users/images/c7ddb51f-f40c-43c3-b10a-6072341a7681_1621912158.6232688.png)\\n"
                    },
                    {
                        "username": "adrianyang2012",
                        "content": "\\'\\'\\'\\nreturn haystack.find(needle)\\n\\'\\'\\'"
                    },
                    {
                        "username": "sknavin369",
                        "content": "The best way to get the position of the first Occurence of needle in haystack is to go with **strstr in-built String Function**, which returns the pointer of the first occurence of needle. Else it returns NULL.\\n\\n\\tint strStr(char * haystack, char * needle){\\n\\t\\t\\n\\t\\tchar *pos = strstr(haystack, needle);\\n\\t\\treturn pos ? pos-haystack : -1;\\n\\t}"
                    },
                    {
                        "username": "jeetrainer",
                        "content": "Link of solution: https://youtu.be/4yT8mpJxHks"
                    },
                    {
                        "username": "BroCode01",
                        "content": "https://youtu.be/TsxFvVy_5m0"
                    }
                ]
            },
            {
                "id": 1574116,
                "content": [
                    {
                        "username": "dunglee30",
                        "content": "Move to submission to find how can they solve this in O(n+m) and 0ms just to see \n```haystack.indexOf(needle)``` =)))))"
                    },
                    {
                        "username": "dunglee30",
                        "content": "[@Swapnil07072000](/Swapnil07072000) I did solve it without built-in function bro :)) It just funny story that some of the best solutions were built-in function and got accepted."
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Try using Two-pointer approach and not built-in function."
                    },
                    {
                        "username": "c4tdog",
                        "content": "you think leetcode wants you to use builtin function? think again"
                    },
                    {
                        "username": "NatureSon22",
                        "content": "Is it okay to use data structure in solving this?"
                    },
                    {
                        "username": "NatureSon22",
                        "content": "I want to use one but it makes me feel illegal\\n"
                    },
                    {
                        "username": "prasadnr606",
                        "content": "The solution is in the subject-line."
                    },
                    {
                        "username": "rayray0706",
                        "content": "![image](https://assets.leetcode.com/users/images/87152572-92da-491b-84df-2b9ab40e7c5a_1635980565.4132447.png)\\n\\n\\nHopefully, theres not a simple reason for this I\\'m missing, but I\\'m not understanding why I\\'m getting this error on this test case and on this line of code. There was another LeetCode problem that was giving me the same error, and I\\'m afraid its my browser or something."
                    },
                    {
                        "username": "tirupati",
                        "content": "Not sure there are so many posts titled with n complexcity but its not.\\n\\nIf you are not using KMP and using two pointers then complexcity would be n * m because we have two loops. One of iterating main string(outer-loop complexcity n-m) and other for checking in the sub string (inner-loop complexcity m).\\ncomplexcity: (n - m) * m = O(nm)\\n\\nReference: https://leetcode.com/problems/implement-strstr/"
                    },
                    {
                        "username": "ChenYehChien001",
                        "content": "![image](https://assets.leetcode.com/users/images/c7ddb51f-f40c-43c3-b10a-6072341a7681_1621912158.6232688.png)\\n"
                    },
                    {
                        "username": "adrianyang2012",
                        "content": "\\'\\'\\'\\nreturn haystack.find(needle)\\n\\'\\'\\'"
                    },
                    {
                        "username": "sknavin369",
                        "content": "The best way to get the position of the first Occurence of needle in haystack is to go with **strstr in-built String Function**, which returns the pointer of the first occurence of needle. Else it returns NULL.\\n\\n\\tint strStr(char * haystack, char * needle){\\n\\t\\t\\n\\t\\tchar *pos = strstr(haystack, needle);\\n\\t\\treturn pos ? pos-haystack : -1;\\n\\t}"
                    },
                    {
                        "username": "jeetrainer",
                        "content": "Link of solution: https://youtu.be/4yT8mpJxHks"
                    },
                    {
                        "username": "BroCode01",
                        "content": "https://youtu.be/TsxFvVy_5m0"
                    }
                ]
            },
            {
                "id": 1573794,
                "content": [
                    {
                        "username": "vijayabaskar",
                        "content": "I see everyone is using language builtin function.  Just wanted to say, the efficient solution is some string search algorithm.  One such algorithm is KMP search.\\n\\nJust want to say it here."
                    },
                    {
                        "username": "nandinisrivastava29",
                        "content": "return haystack.indexOf(needle);\\n"
                    },
                    {
                        "username": "dmb17",
                        "content": "return  haystack.indexOf(needle);"
                    },
                    {
                        "username": "kitmanwork",
                        "content": "![image](https://assets.leetcode.com/users/kitmanwork/image_1569031883.png)\\n"
                    },
                    {
                        "username": "CNife",
                        "content": "You library function guys great."
                    },
                    {
                        "username": "sunxiong90",
                        "content": "return haystack.find(needle)"
                    },
                    {
                        "username": "bazilione",
                        "content": "My comment: The problem description asks to return 0 when needle is an empty string, but the match also can have index 0 if string is not empty. This will make the output confusing. -2 if empty string would solve a problem."
                    },
                    {
                        "username": "vogelkaka",
                        "content": "The expected results are both 0 , Isn't it a bit weird ?"
                    },
                    {
                        "username": "Lets1112D",
                        "content": "func strStr(haystack string, needle string) int {\\n\\tvar ind int\\n\\n\\tind = strings.Index(haystack, needle)\\n\\tfmt.Println(ind)\\n\\n\\treturn ind\\n}"
                    },
                    {
                        "username": "young_stone",
                        "content": "if i use the bruth-force method, not the KMP algorithm, the best time is O(m), the worst time is O(mn). (m is length of longer string, n is the length of another string). What's the average time complexity and why?"
                    },
                    {
                        "username": "bl4z1ng",
                        "content": "[@young_stone](/young_stone) There's no such thing as average time complexity 'cause time complexity itself shows the **worst** possible situtaion and shows, how time of computing your algorithm will grow up on increasing of elements number. So it's not about time, it's about speed of growing, so your answer is O(mn)"
                    },
                    {
                        "username": "charonme",
                        "content": "best case is actually O(1) - it\\'s when the haystack and needle have the same length and different first characters"
                    }
                ]
            },
            {
                "id": 1573741,
                "content": [
                    {
                        "username": "vijayabaskar",
                        "content": "I see everyone is using language builtin function.  Just wanted to say, the efficient solution is some string search algorithm.  One such algorithm is KMP search.\\n\\nJust want to say it here."
                    },
                    {
                        "username": "nandinisrivastava29",
                        "content": "return haystack.indexOf(needle);\\n"
                    },
                    {
                        "username": "dmb17",
                        "content": "return  haystack.indexOf(needle);"
                    },
                    {
                        "username": "kitmanwork",
                        "content": "![image](https://assets.leetcode.com/users/kitmanwork/image_1569031883.png)\\n"
                    },
                    {
                        "username": "CNife",
                        "content": "You library function guys great."
                    },
                    {
                        "username": "sunxiong90",
                        "content": "return haystack.find(needle)"
                    },
                    {
                        "username": "bazilione",
                        "content": "My comment: The problem description asks to return 0 when needle is an empty string, but the match also can have index 0 if string is not empty. This will make the output confusing. -2 if empty string would solve a problem."
                    },
                    {
                        "username": "vogelkaka",
                        "content": "The expected results are both 0 , Isn't it a bit weird ?"
                    },
                    {
                        "username": "Lets1112D",
                        "content": "func strStr(haystack string, needle string) int {\\n\\tvar ind int\\n\\n\\tind = strings.Index(haystack, needle)\\n\\tfmt.Println(ind)\\n\\n\\treturn ind\\n}"
                    },
                    {
                        "username": "young_stone",
                        "content": "if i use the bruth-force method, not the KMP algorithm, the best time is O(m), the worst time is O(mn). (m is length of longer string, n is the length of another string). What's the average time complexity and why?"
                    },
                    {
                        "username": "bl4z1ng",
                        "content": "[@young_stone](/young_stone) There's no such thing as average time complexity 'cause time complexity itself shows the **worst** possible situtaion and shows, how time of computing your algorithm will grow up on increasing of elements number. So it's not about time, it's about speed of growing, so your answer is O(mn)"
                    },
                    {
                        "username": "charonme",
                        "content": "best case is actually O(1) - it\\'s when the haystack and needle have the same length and different first characters"
                    }
                ]
            },
            {
                "id": 1573649,
                "content": [
                    {
                        "username": "vijayabaskar",
                        "content": "I see everyone is using language builtin function.  Just wanted to say, the efficient solution is some string search algorithm.  One such algorithm is KMP search.\\n\\nJust want to say it here."
                    },
                    {
                        "username": "nandinisrivastava29",
                        "content": "return haystack.indexOf(needle);\\n"
                    },
                    {
                        "username": "dmb17",
                        "content": "return  haystack.indexOf(needle);"
                    },
                    {
                        "username": "kitmanwork",
                        "content": "![image](https://assets.leetcode.com/users/kitmanwork/image_1569031883.png)\\n"
                    },
                    {
                        "username": "CNife",
                        "content": "You library function guys great."
                    },
                    {
                        "username": "sunxiong90",
                        "content": "return haystack.find(needle)"
                    },
                    {
                        "username": "bazilione",
                        "content": "My comment: The problem description asks to return 0 when needle is an empty string, but the match also can have index 0 if string is not empty. This will make the output confusing. -2 if empty string would solve a problem."
                    },
                    {
                        "username": "vogelkaka",
                        "content": "The expected results are both 0 , Isn't it a bit weird ?"
                    },
                    {
                        "username": "Lets1112D",
                        "content": "func strStr(haystack string, needle string) int {\\n\\tvar ind int\\n\\n\\tind = strings.Index(haystack, needle)\\n\\tfmt.Println(ind)\\n\\n\\treturn ind\\n}"
                    },
                    {
                        "username": "young_stone",
                        "content": "if i use the bruth-force method, not the KMP algorithm, the best time is O(m), the worst time is O(mn). (m is length of longer string, n is the length of another string). What's the average time complexity and why?"
                    },
                    {
                        "username": "bl4z1ng",
                        "content": "[@young_stone](/young_stone) There's no such thing as average time complexity 'cause time complexity itself shows the **worst** possible situtaion and shows, how time of computing your algorithm will grow up on increasing of elements number. So it's not about time, it's about speed of growing, so your answer is O(mn)"
                    },
                    {
                        "username": "charonme",
                        "content": "best case is actually O(1) - it\\'s when the haystack and needle have the same length and different first characters"
                    }
                ]
            },
            {
                "id": 1573027,
                "content": [
                    {
                        "username": "vijayabaskar",
                        "content": "I see everyone is using language builtin function.  Just wanted to say, the efficient solution is some string search algorithm.  One such algorithm is KMP search.\\n\\nJust want to say it here."
                    },
                    {
                        "username": "nandinisrivastava29",
                        "content": "return haystack.indexOf(needle);\\n"
                    },
                    {
                        "username": "dmb17",
                        "content": "return  haystack.indexOf(needle);"
                    },
                    {
                        "username": "kitmanwork",
                        "content": "![image](https://assets.leetcode.com/users/kitmanwork/image_1569031883.png)\\n"
                    },
                    {
                        "username": "CNife",
                        "content": "You library function guys great."
                    },
                    {
                        "username": "sunxiong90",
                        "content": "return haystack.find(needle)"
                    },
                    {
                        "username": "bazilione",
                        "content": "My comment: The problem description asks to return 0 when needle is an empty string, but the match also can have index 0 if string is not empty. This will make the output confusing. -2 if empty string would solve a problem."
                    },
                    {
                        "username": "vogelkaka",
                        "content": "The expected results are both 0 , Isn't it a bit weird ?"
                    },
                    {
                        "username": "Lets1112D",
                        "content": "func strStr(haystack string, needle string) int {\\n\\tvar ind int\\n\\n\\tind = strings.Index(haystack, needle)\\n\\tfmt.Println(ind)\\n\\n\\treturn ind\\n}"
                    },
                    {
                        "username": "young_stone",
                        "content": "if i use the bruth-force method, not the KMP algorithm, the best time is O(m), the worst time is O(mn). (m is length of longer string, n is the length of another string). What's the average time complexity and why?"
                    },
                    {
                        "username": "bl4z1ng",
                        "content": "[@young_stone](/young_stone) There's no such thing as average time complexity 'cause time complexity itself shows the **worst** possible situtaion and shows, how time of computing your algorithm will grow up on increasing of elements number. So it's not about time, it's about speed of growing, so your answer is O(mn)"
                    },
                    {
                        "username": "charonme",
                        "content": "best case is actually O(1) - it\\'s when the haystack and needle have the same length and different first characters"
                    }
                ]
            },
            {
                "id": 1572330,
                "content": [
                    {
                        "username": "vijayabaskar",
                        "content": "I see everyone is using language builtin function.  Just wanted to say, the efficient solution is some string search algorithm.  One such algorithm is KMP search.\\n\\nJust want to say it here."
                    },
                    {
                        "username": "nandinisrivastava29",
                        "content": "return haystack.indexOf(needle);\\n"
                    },
                    {
                        "username": "dmb17",
                        "content": "return  haystack.indexOf(needle);"
                    },
                    {
                        "username": "kitmanwork",
                        "content": "![image](https://assets.leetcode.com/users/kitmanwork/image_1569031883.png)\\n"
                    },
                    {
                        "username": "CNife",
                        "content": "You library function guys great."
                    },
                    {
                        "username": "sunxiong90",
                        "content": "return haystack.find(needle)"
                    },
                    {
                        "username": "bazilione",
                        "content": "My comment: The problem description asks to return 0 when needle is an empty string, but the match also can have index 0 if string is not empty. This will make the output confusing. -2 if empty string would solve a problem."
                    },
                    {
                        "username": "vogelkaka",
                        "content": "The expected results are both 0 , Isn't it a bit weird ?"
                    },
                    {
                        "username": "Lets1112D",
                        "content": "func strStr(haystack string, needle string) int {\\n\\tvar ind int\\n\\n\\tind = strings.Index(haystack, needle)\\n\\tfmt.Println(ind)\\n\\n\\treturn ind\\n}"
                    },
                    {
                        "username": "young_stone",
                        "content": "if i use the bruth-force method, not the KMP algorithm, the best time is O(m), the worst time is O(mn). (m is length of longer string, n is the length of another string). What's the average time complexity and why?"
                    },
                    {
                        "username": "bl4z1ng",
                        "content": "[@young_stone](/young_stone) There's no such thing as average time complexity 'cause time complexity itself shows the **worst** possible situtaion and shows, how time of computing your algorithm will grow up on increasing of elements number. So it's not about time, it's about speed of growing, so your answer is O(mn)"
                    },
                    {
                        "username": "charonme",
                        "content": "best case is actually O(1) - it\\'s when the haystack and needle have the same length and different first characters"
                    }
                ]
            },
            {
                "id": 1572232,
                "content": [
                    {
                        "username": "vijayabaskar",
                        "content": "I see everyone is using language builtin function.  Just wanted to say, the efficient solution is some string search algorithm.  One such algorithm is KMP search.\\n\\nJust want to say it here."
                    },
                    {
                        "username": "nandinisrivastava29",
                        "content": "return haystack.indexOf(needle);\\n"
                    },
                    {
                        "username": "dmb17",
                        "content": "return  haystack.indexOf(needle);"
                    },
                    {
                        "username": "kitmanwork",
                        "content": "![image](https://assets.leetcode.com/users/kitmanwork/image_1569031883.png)\\n"
                    },
                    {
                        "username": "CNife",
                        "content": "You library function guys great."
                    },
                    {
                        "username": "sunxiong90",
                        "content": "return haystack.find(needle)"
                    },
                    {
                        "username": "bazilione",
                        "content": "My comment: The problem description asks to return 0 when needle is an empty string, but the match also can have index 0 if string is not empty. This will make the output confusing. -2 if empty string would solve a problem."
                    },
                    {
                        "username": "vogelkaka",
                        "content": "The expected results are both 0 , Isn't it a bit weird ?"
                    },
                    {
                        "username": "Lets1112D",
                        "content": "func strStr(haystack string, needle string) int {\\n\\tvar ind int\\n\\n\\tind = strings.Index(haystack, needle)\\n\\tfmt.Println(ind)\\n\\n\\treturn ind\\n}"
                    },
                    {
                        "username": "young_stone",
                        "content": "if i use the bruth-force method, not the KMP algorithm, the best time is O(m), the worst time is O(mn). (m is length of longer string, n is the length of another string). What's the average time complexity and why?"
                    },
                    {
                        "username": "bl4z1ng",
                        "content": "[@young_stone](/young_stone) There's no such thing as average time complexity 'cause time complexity itself shows the **worst** possible situtaion and shows, how time of computing your algorithm will grow up on increasing of elements number. So it's not about time, it's about speed of growing, so your answer is O(mn)"
                    },
                    {
                        "username": "charonme",
                        "content": "best case is actually O(1) - it\\'s when the haystack and needle have the same length and different first characters"
                    }
                ]
            },
            {
                "id": 1571933,
                "content": [
                    {
                        "username": "vijayabaskar",
                        "content": "I see everyone is using language builtin function.  Just wanted to say, the efficient solution is some string search algorithm.  One such algorithm is KMP search.\\n\\nJust want to say it here."
                    },
                    {
                        "username": "nandinisrivastava29",
                        "content": "return haystack.indexOf(needle);\\n"
                    },
                    {
                        "username": "dmb17",
                        "content": "return  haystack.indexOf(needle);"
                    },
                    {
                        "username": "kitmanwork",
                        "content": "![image](https://assets.leetcode.com/users/kitmanwork/image_1569031883.png)\\n"
                    },
                    {
                        "username": "CNife",
                        "content": "You library function guys great."
                    },
                    {
                        "username": "sunxiong90",
                        "content": "return haystack.find(needle)"
                    },
                    {
                        "username": "bazilione",
                        "content": "My comment: The problem description asks to return 0 when needle is an empty string, but the match also can have index 0 if string is not empty. This will make the output confusing. -2 if empty string would solve a problem."
                    },
                    {
                        "username": "vogelkaka",
                        "content": "The expected results are both 0 , Isn't it a bit weird ?"
                    },
                    {
                        "username": "Lets1112D",
                        "content": "func strStr(haystack string, needle string) int {\\n\\tvar ind int\\n\\n\\tind = strings.Index(haystack, needle)\\n\\tfmt.Println(ind)\\n\\n\\treturn ind\\n}"
                    },
                    {
                        "username": "young_stone",
                        "content": "if i use the bruth-force method, not the KMP algorithm, the best time is O(m), the worst time is O(mn). (m is length of longer string, n is the length of another string). What's the average time complexity and why?"
                    },
                    {
                        "username": "bl4z1ng",
                        "content": "[@young_stone](/young_stone) There's no such thing as average time complexity 'cause time complexity itself shows the **worst** possible situtaion and shows, how time of computing your algorithm will grow up on increasing of elements number. So it's not about time, it's about speed of growing, so your answer is O(mn)"
                    },
                    {
                        "username": "charonme",
                        "content": "best case is actually O(1) - it\\'s when the haystack and needle have the same length and different first characters"
                    }
                ]
            },
            {
                "id": 1571070,
                "content": [
                    {
                        "username": "vijayabaskar",
                        "content": "I see everyone is using language builtin function.  Just wanted to say, the efficient solution is some string search algorithm.  One such algorithm is KMP search.\\n\\nJust want to say it here."
                    },
                    {
                        "username": "nandinisrivastava29",
                        "content": "return haystack.indexOf(needle);\\n"
                    },
                    {
                        "username": "dmb17",
                        "content": "return  haystack.indexOf(needle);"
                    },
                    {
                        "username": "kitmanwork",
                        "content": "![image](https://assets.leetcode.com/users/kitmanwork/image_1569031883.png)\\n"
                    },
                    {
                        "username": "CNife",
                        "content": "You library function guys great."
                    },
                    {
                        "username": "sunxiong90",
                        "content": "return haystack.find(needle)"
                    },
                    {
                        "username": "bazilione",
                        "content": "My comment: The problem description asks to return 0 when needle is an empty string, but the match also can have index 0 if string is not empty. This will make the output confusing. -2 if empty string would solve a problem."
                    },
                    {
                        "username": "vogelkaka",
                        "content": "The expected results are both 0 , Isn't it a bit weird ?"
                    },
                    {
                        "username": "Lets1112D",
                        "content": "func strStr(haystack string, needle string) int {\\n\\tvar ind int\\n\\n\\tind = strings.Index(haystack, needle)\\n\\tfmt.Println(ind)\\n\\n\\treturn ind\\n}"
                    },
                    {
                        "username": "young_stone",
                        "content": "if i use the bruth-force method, not the KMP algorithm, the best time is O(m), the worst time is O(mn). (m is length of longer string, n is the length of another string). What's the average time complexity and why?"
                    },
                    {
                        "username": "bl4z1ng",
                        "content": "[@young_stone](/young_stone) There's no such thing as average time complexity 'cause time complexity itself shows the **worst** possible situtaion and shows, how time of computing your algorithm will grow up on increasing of elements number. So it's not about time, it's about speed of growing, so your answer is O(mn)"
                    },
                    {
                        "username": "charonme",
                        "content": "best case is actually O(1) - it\\'s when the haystack and needle have the same length and different first characters"
                    }
                ]
            },
            {
                "id": 1570563,
                "content": [
                    {
                        "username": "vijayabaskar",
                        "content": "I see everyone is using language builtin function.  Just wanted to say, the efficient solution is some string search algorithm.  One such algorithm is KMP search.\\n\\nJust want to say it here."
                    },
                    {
                        "username": "nandinisrivastava29",
                        "content": "return haystack.indexOf(needle);\\n"
                    },
                    {
                        "username": "dmb17",
                        "content": "return  haystack.indexOf(needle);"
                    },
                    {
                        "username": "kitmanwork",
                        "content": "![image](https://assets.leetcode.com/users/kitmanwork/image_1569031883.png)\\n"
                    },
                    {
                        "username": "CNife",
                        "content": "You library function guys great."
                    },
                    {
                        "username": "sunxiong90",
                        "content": "return haystack.find(needle)"
                    },
                    {
                        "username": "bazilione",
                        "content": "My comment: The problem description asks to return 0 when needle is an empty string, but the match also can have index 0 if string is not empty. This will make the output confusing. -2 if empty string would solve a problem."
                    },
                    {
                        "username": "vogelkaka",
                        "content": "The expected results are both 0 , Isn't it a bit weird ?"
                    },
                    {
                        "username": "Lets1112D",
                        "content": "func strStr(haystack string, needle string) int {\\n\\tvar ind int\\n\\n\\tind = strings.Index(haystack, needle)\\n\\tfmt.Println(ind)\\n\\n\\treturn ind\\n}"
                    },
                    {
                        "username": "young_stone",
                        "content": "if i use the bruth-force method, not the KMP algorithm, the best time is O(m), the worst time is O(mn). (m is length of longer string, n is the length of another string). What's the average time complexity and why?"
                    },
                    {
                        "username": "bl4z1ng",
                        "content": "[@young_stone](/young_stone) There's no such thing as average time complexity 'cause time complexity itself shows the **worst** possible situtaion and shows, how time of computing your algorithm will grow up on increasing of elements number. So it's not about time, it's about speed of growing, so your answer is O(mn)"
                    },
                    {
                        "username": "charonme",
                        "content": "best case is actually O(1) - it\\'s when the haystack and needle have the same length and different first characters"
                    }
                ]
            },
            {
                "id": 1568848,
                "content": [
                    {
                        "username": "vijayabaskar",
                        "content": "I see everyone is using language builtin function.  Just wanted to say, the efficient solution is some string search algorithm.  One such algorithm is KMP search.\\n\\nJust want to say it here."
                    },
                    {
                        "username": "nandinisrivastava29",
                        "content": "return haystack.indexOf(needle);\\n"
                    },
                    {
                        "username": "dmb17",
                        "content": "return  haystack.indexOf(needle);"
                    },
                    {
                        "username": "kitmanwork",
                        "content": "![image](https://assets.leetcode.com/users/kitmanwork/image_1569031883.png)\\n"
                    },
                    {
                        "username": "CNife",
                        "content": "You library function guys great."
                    },
                    {
                        "username": "sunxiong90",
                        "content": "return haystack.find(needle)"
                    },
                    {
                        "username": "bazilione",
                        "content": "My comment: The problem description asks to return 0 when needle is an empty string, but the match also can have index 0 if string is not empty. This will make the output confusing. -2 if empty string would solve a problem."
                    },
                    {
                        "username": "vogelkaka",
                        "content": "The expected results are both 0 , Isn't it a bit weird ?"
                    },
                    {
                        "username": "Lets1112D",
                        "content": "func strStr(haystack string, needle string) int {\\n\\tvar ind int\\n\\n\\tind = strings.Index(haystack, needle)\\n\\tfmt.Println(ind)\\n\\n\\treturn ind\\n}"
                    },
                    {
                        "username": "young_stone",
                        "content": "if i use the bruth-force method, not the KMP algorithm, the best time is O(m), the worst time is O(mn). (m is length of longer string, n is the length of another string). What's the average time complexity and why?"
                    },
                    {
                        "username": "bl4z1ng",
                        "content": "[@young_stone](/young_stone) There's no such thing as average time complexity 'cause time complexity itself shows the **worst** possible situtaion and shows, how time of computing your algorithm will grow up on increasing of elements number. So it's not about time, it's about speed of growing, so your answer is O(mn)"
                    },
                    {
                        "username": "charonme",
                        "content": "best case is actually O(1) - it\\'s when the haystack and needle have the same length and different first characters"
                    }
                ]
            },
            {
                "id": 1568665,
                "content": [
                    {
                        "username": "girinatarajan",
                        "content": "return haystack.find(needle)"
                    },
                    {
                        "username": "sankarees",
                        "content": "I have updated the code in my github. Please refer the below link to check the source code and time complexity to run this code.\\n\\nhttps://github.com/sankarees/program-interview-job-learning/upload/main/myplayground/src/myplayground\\n\\n\\n![image](https://assets.leetcode.com/users/images/a10f90bf-98d0-4b5d-8e80-870face53c8f_1642430181.1675096.jpeg)\\n\\n\\n"
                    },
                    {
                        "username": "charan_rs_guru",
                        "content": "return haystack.indexOf(needle);"
                    },
                    {
                        "username": "bosserbosser",
                        "content": "\\tWe commonly use String::charAt to get a char from String, and that function do more things than just get an element from the inner char array instance. Unless making a copy of the inner char array first, it will be unfair for us to compete with the sdandard library. The best way to acess the inner char array is to call String::toCharArray, which actually makes a copy instead of returning the original array Object."
                    },
                    {
                        "username": "SuvenduGhosh",
                        "content": "\\'\\'\\'\\nreturn haystack.find(needle)\\n\\'\\'\\'"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "![image](https://assets.leetcode.com/users/images/db642348-ec38-44ee-934e-3a5074438185_1597595613.9781873.png)\\n\\n![image](https://assets.leetcode.com/users/images/733c099d-3b1d-4339-a93b-89068aa96d35_1597595620.1702633.png)\\n\\n* see why hash function selection is important\\n![image](https://assets.leetcode.com/users/images/76661a64-e6d5-4231-bf1d-013748456c8c_1597595850.0052273.png)\\n\\n"
                    },
                    {
                        "username": "babayagaaaa",
                        "content": "Its like a swamp, the more you try, the more you drown. \\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "Elsone",
                        "content": "My solution is accepted but the run time is not that good. Time complexity O(n-len(needle)). shift one char at a time and i check if needle is include in the current substring"
                    },
                    {
                        "username": "vinay_jain_61787",
                        "content": "In c++ we could use the built in function find() to find the occurence of the word. \\nWith which we could beat 100% of the users\\n"
                    },
                    {
                        "username": "Anshul29",
                        "content": "Anyone getting wrong answer on test case:\\nhaystack: \"ababcaababcaabc\"\\nneedle: \"ababcaabc\"\\nany advice how to tackle it"
                    }
                ]
            },
            {
                "id": 1576249,
                "content": [
                    {
                        "username": "girinatarajan",
                        "content": "return haystack.find(needle)"
                    },
                    {
                        "username": "sankarees",
                        "content": "I have updated the code in my github. Please refer the below link to check the source code and time complexity to run this code.\\n\\nhttps://github.com/sankarees/program-interview-job-learning/upload/main/myplayground/src/myplayground\\n\\n\\n![image](https://assets.leetcode.com/users/images/a10f90bf-98d0-4b5d-8e80-870face53c8f_1642430181.1675096.jpeg)\\n\\n\\n"
                    },
                    {
                        "username": "charan_rs_guru",
                        "content": "return haystack.indexOf(needle);"
                    },
                    {
                        "username": "bosserbosser",
                        "content": "\\tWe commonly use String::charAt to get a char from String, and that function do more things than just get an element from the inner char array instance. Unless making a copy of the inner char array first, it will be unfair for us to compete with the sdandard library. The best way to acess the inner char array is to call String::toCharArray, which actually makes a copy instead of returning the original array Object."
                    },
                    {
                        "username": "SuvenduGhosh",
                        "content": "\\'\\'\\'\\nreturn haystack.find(needle)\\n\\'\\'\\'"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "![image](https://assets.leetcode.com/users/images/db642348-ec38-44ee-934e-3a5074438185_1597595613.9781873.png)\\n\\n![image](https://assets.leetcode.com/users/images/733c099d-3b1d-4339-a93b-89068aa96d35_1597595620.1702633.png)\\n\\n* see why hash function selection is important\\n![image](https://assets.leetcode.com/users/images/76661a64-e6d5-4231-bf1d-013748456c8c_1597595850.0052273.png)\\n\\n"
                    },
                    {
                        "username": "babayagaaaa",
                        "content": "Its like a swamp, the more you try, the more you drown. \\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "Elsone",
                        "content": "My solution is accepted but the run time is not that good. Time complexity O(n-len(needle)). shift one char at a time and i check if needle is include in the current substring"
                    },
                    {
                        "username": "vinay_jain_61787",
                        "content": "In c++ we could use the built in function find() to find the occurence of the word. \\nWith which we could beat 100% of the users\\n"
                    },
                    {
                        "username": "Anshul29",
                        "content": "Anyone getting wrong answer on test case:\\nhaystack: \"ababcaababcaabc\"\\nneedle: \"ababcaabc\"\\nany advice how to tackle it"
                    }
                ]
            },
            {
                "id": 1576145,
                "content": [
                    {
                        "username": "girinatarajan",
                        "content": "return haystack.find(needle)"
                    },
                    {
                        "username": "sankarees",
                        "content": "I have updated the code in my github. Please refer the below link to check the source code and time complexity to run this code.\\n\\nhttps://github.com/sankarees/program-interview-job-learning/upload/main/myplayground/src/myplayground\\n\\n\\n![image](https://assets.leetcode.com/users/images/a10f90bf-98d0-4b5d-8e80-870face53c8f_1642430181.1675096.jpeg)\\n\\n\\n"
                    },
                    {
                        "username": "charan_rs_guru",
                        "content": "return haystack.indexOf(needle);"
                    },
                    {
                        "username": "bosserbosser",
                        "content": "\\tWe commonly use String::charAt to get a char from String, and that function do more things than just get an element from the inner char array instance. Unless making a copy of the inner char array first, it will be unfair for us to compete with the sdandard library. The best way to acess the inner char array is to call String::toCharArray, which actually makes a copy instead of returning the original array Object."
                    },
                    {
                        "username": "SuvenduGhosh",
                        "content": "\\'\\'\\'\\nreturn haystack.find(needle)\\n\\'\\'\\'"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "![image](https://assets.leetcode.com/users/images/db642348-ec38-44ee-934e-3a5074438185_1597595613.9781873.png)\\n\\n![image](https://assets.leetcode.com/users/images/733c099d-3b1d-4339-a93b-89068aa96d35_1597595620.1702633.png)\\n\\n* see why hash function selection is important\\n![image](https://assets.leetcode.com/users/images/76661a64-e6d5-4231-bf1d-013748456c8c_1597595850.0052273.png)\\n\\n"
                    },
                    {
                        "username": "babayagaaaa",
                        "content": "Its like a swamp, the more you try, the more you drown. \\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "Elsone",
                        "content": "My solution is accepted but the run time is not that good. Time complexity O(n-len(needle)). shift one char at a time and i check if needle is include in the current substring"
                    },
                    {
                        "username": "vinay_jain_61787",
                        "content": "In c++ we could use the built in function find() to find the occurence of the word. \\nWith which we could beat 100% of the users\\n"
                    },
                    {
                        "username": "Anshul29",
                        "content": "Anyone getting wrong answer on test case:\\nhaystack: \"ababcaababcaabc\"\\nneedle: \"ababcaabc\"\\nany advice how to tackle it"
                    }
                ]
            },
            {
                "id": 1576056,
                "content": [
                    {
                        "username": "girinatarajan",
                        "content": "return haystack.find(needle)"
                    },
                    {
                        "username": "sankarees",
                        "content": "I have updated the code in my github. Please refer the below link to check the source code and time complexity to run this code.\\n\\nhttps://github.com/sankarees/program-interview-job-learning/upload/main/myplayground/src/myplayground\\n\\n\\n![image](https://assets.leetcode.com/users/images/a10f90bf-98d0-4b5d-8e80-870face53c8f_1642430181.1675096.jpeg)\\n\\n\\n"
                    },
                    {
                        "username": "charan_rs_guru",
                        "content": "return haystack.indexOf(needle);"
                    },
                    {
                        "username": "bosserbosser",
                        "content": "\\tWe commonly use String::charAt to get a char from String, and that function do more things than just get an element from the inner char array instance. Unless making a copy of the inner char array first, it will be unfair for us to compete with the sdandard library. The best way to acess the inner char array is to call String::toCharArray, which actually makes a copy instead of returning the original array Object."
                    },
                    {
                        "username": "SuvenduGhosh",
                        "content": "\\'\\'\\'\\nreturn haystack.find(needle)\\n\\'\\'\\'"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "![image](https://assets.leetcode.com/users/images/db642348-ec38-44ee-934e-3a5074438185_1597595613.9781873.png)\\n\\n![image](https://assets.leetcode.com/users/images/733c099d-3b1d-4339-a93b-89068aa96d35_1597595620.1702633.png)\\n\\n* see why hash function selection is important\\n![image](https://assets.leetcode.com/users/images/76661a64-e6d5-4231-bf1d-013748456c8c_1597595850.0052273.png)\\n\\n"
                    },
                    {
                        "username": "babayagaaaa",
                        "content": "Its like a swamp, the more you try, the more you drown. \\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "Elsone",
                        "content": "My solution is accepted but the run time is not that good. Time complexity O(n-len(needle)). shift one char at a time and i check if needle is include in the current substring"
                    },
                    {
                        "username": "vinay_jain_61787",
                        "content": "In c++ we could use the built in function find() to find the occurence of the word. \\nWith which we could beat 100% of the users\\n"
                    },
                    {
                        "username": "Anshul29",
                        "content": "Anyone getting wrong answer on test case:\\nhaystack: \"ababcaababcaabc\"\\nneedle: \"ababcaabc\"\\nany advice how to tackle it"
                    }
                ]
            },
            {
                "id": 1575895,
                "content": [
                    {
                        "username": "girinatarajan",
                        "content": "return haystack.find(needle)"
                    },
                    {
                        "username": "sankarees",
                        "content": "I have updated the code in my github. Please refer the below link to check the source code and time complexity to run this code.\\n\\nhttps://github.com/sankarees/program-interview-job-learning/upload/main/myplayground/src/myplayground\\n\\n\\n![image](https://assets.leetcode.com/users/images/a10f90bf-98d0-4b5d-8e80-870face53c8f_1642430181.1675096.jpeg)\\n\\n\\n"
                    },
                    {
                        "username": "charan_rs_guru",
                        "content": "return haystack.indexOf(needle);"
                    },
                    {
                        "username": "bosserbosser",
                        "content": "\\tWe commonly use String::charAt to get a char from String, and that function do more things than just get an element from the inner char array instance. Unless making a copy of the inner char array first, it will be unfair for us to compete with the sdandard library. The best way to acess the inner char array is to call String::toCharArray, which actually makes a copy instead of returning the original array Object."
                    },
                    {
                        "username": "SuvenduGhosh",
                        "content": "\\'\\'\\'\\nreturn haystack.find(needle)\\n\\'\\'\\'"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "![image](https://assets.leetcode.com/users/images/db642348-ec38-44ee-934e-3a5074438185_1597595613.9781873.png)\\n\\n![image](https://assets.leetcode.com/users/images/733c099d-3b1d-4339-a93b-89068aa96d35_1597595620.1702633.png)\\n\\n* see why hash function selection is important\\n![image](https://assets.leetcode.com/users/images/76661a64-e6d5-4231-bf1d-013748456c8c_1597595850.0052273.png)\\n\\n"
                    },
                    {
                        "username": "babayagaaaa",
                        "content": "Its like a swamp, the more you try, the more you drown. \\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "Elsone",
                        "content": "My solution is accepted but the run time is not that good. Time complexity O(n-len(needle)). shift one char at a time and i check if needle is include in the current substring"
                    },
                    {
                        "username": "vinay_jain_61787",
                        "content": "In c++ we could use the built in function find() to find the occurence of the word. \\nWith which we could beat 100% of the users\\n"
                    },
                    {
                        "username": "Anshul29",
                        "content": "Anyone getting wrong answer on test case:\\nhaystack: \"ababcaababcaabc\"\\nneedle: \"ababcaabc\"\\nany advice how to tackle it"
                    }
                ]
            },
            {
                "id": 1574225,
                "content": [
                    {
                        "username": "girinatarajan",
                        "content": "return haystack.find(needle)"
                    },
                    {
                        "username": "sankarees",
                        "content": "I have updated the code in my github. Please refer the below link to check the source code and time complexity to run this code.\\n\\nhttps://github.com/sankarees/program-interview-job-learning/upload/main/myplayground/src/myplayground\\n\\n\\n![image](https://assets.leetcode.com/users/images/a10f90bf-98d0-4b5d-8e80-870face53c8f_1642430181.1675096.jpeg)\\n\\n\\n"
                    },
                    {
                        "username": "charan_rs_guru",
                        "content": "return haystack.indexOf(needle);"
                    },
                    {
                        "username": "bosserbosser",
                        "content": "\\tWe commonly use String::charAt to get a char from String, and that function do more things than just get an element from the inner char array instance. Unless making a copy of the inner char array first, it will be unfair for us to compete with the sdandard library. The best way to acess the inner char array is to call String::toCharArray, which actually makes a copy instead of returning the original array Object."
                    },
                    {
                        "username": "SuvenduGhosh",
                        "content": "\\'\\'\\'\\nreturn haystack.find(needle)\\n\\'\\'\\'"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "![image](https://assets.leetcode.com/users/images/db642348-ec38-44ee-934e-3a5074438185_1597595613.9781873.png)\\n\\n![image](https://assets.leetcode.com/users/images/733c099d-3b1d-4339-a93b-89068aa96d35_1597595620.1702633.png)\\n\\n* see why hash function selection is important\\n![image](https://assets.leetcode.com/users/images/76661a64-e6d5-4231-bf1d-013748456c8c_1597595850.0052273.png)\\n\\n"
                    },
                    {
                        "username": "babayagaaaa",
                        "content": "Its like a swamp, the more you try, the more you drown. \\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "Elsone",
                        "content": "My solution is accepted but the run time is not that good. Time complexity O(n-len(needle)). shift one char at a time and i check if needle is include in the current substring"
                    },
                    {
                        "username": "vinay_jain_61787",
                        "content": "In c++ we could use the built in function find() to find the occurence of the word. \\nWith which we could beat 100% of the users\\n"
                    },
                    {
                        "username": "Anshul29",
                        "content": "Anyone getting wrong answer on test case:\\nhaystack: \"ababcaababcaabc\"\\nneedle: \"ababcaabc\"\\nany advice how to tackle it"
                    }
                ]
            },
            {
                "id": 2075727,
                "content": [
                    {
                        "username": "girinatarajan",
                        "content": "return haystack.find(needle)"
                    },
                    {
                        "username": "sankarees",
                        "content": "I have updated the code in my github. Please refer the below link to check the source code and time complexity to run this code.\\n\\nhttps://github.com/sankarees/program-interview-job-learning/upload/main/myplayground/src/myplayground\\n\\n\\n![image](https://assets.leetcode.com/users/images/a10f90bf-98d0-4b5d-8e80-870face53c8f_1642430181.1675096.jpeg)\\n\\n\\n"
                    },
                    {
                        "username": "charan_rs_guru",
                        "content": "return haystack.indexOf(needle);"
                    },
                    {
                        "username": "bosserbosser",
                        "content": "\\tWe commonly use String::charAt to get a char from String, and that function do more things than just get an element from the inner char array instance. Unless making a copy of the inner char array first, it will be unfair for us to compete with the sdandard library. The best way to acess the inner char array is to call String::toCharArray, which actually makes a copy instead of returning the original array Object."
                    },
                    {
                        "username": "SuvenduGhosh",
                        "content": "\\'\\'\\'\\nreturn haystack.find(needle)\\n\\'\\'\\'"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "![image](https://assets.leetcode.com/users/images/db642348-ec38-44ee-934e-3a5074438185_1597595613.9781873.png)\\n\\n![image](https://assets.leetcode.com/users/images/733c099d-3b1d-4339-a93b-89068aa96d35_1597595620.1702633.png)\\n\\n* see why hash function selection is important\\n![image](https://assets.leetcode.com/users/images/76661a64-e6d5-4231-bf1d-013748456c8c_1597595850.0052273.png)\\n\\n"
                    },
                    {
                        "username": "babayagaaaa",
                        "content": "Its like a swamp, the more you try, the more you drown. \\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "Elsone",
                        "content": "My solution is accepted but the run time is not that good. Time complexity O(n-len(needle)). shift one char at a time and i check if needle is include in the current substring"
                    },
                    {
                        "username": "vinay_jain_61787",
                        "content": "In c++ we could use the built in function find() to find the occurence of the word. \\nWith which we could beat 100% of the users\\n"
                    },
                    {
                        "username": "Anshul29",
                        "content": "Anyone getting wrong answer on test case:\\nhaystack: \"ababcaababcaabc\"\\nneedle: \"ababcaabc\"\\nany advice how to tackle it"
                    }
                ]
            },
            {
                "id": 2074692,
                "content": [
                    {
                        "username": "girinatarajan",
                        "content": "return haystack.find(needle)"
                    },
                    {
                        "username": "sankarees",
                        "content": "I have updated the code in my github. Please refer the below link to check the source code and time complexity to run this code.\\n\\nhttps://github.com/sankarees/program-interview-job-learning/upload/main/myplayground/src/myplayground\\n\\n\\n![image](https://assets.leetcode.com/users/images/a10f90bf-98d0-4b5d-8e80-870face53c8f_1642430181.1675096.jpeg)\\n\\n\\n"
                    },
                    {
                        "username": "charan_rs_guru",
                        "content": "return haystack.indexOf(needle);"
                    },
                    {
                        "username": "bosserbosser",
                        "content": "\\tWe commonly use String::charAt to get a char from String, and that function do more things than just get an element from the inner char array instance. Unless making a copy of the inner char array first, it will be unfair for us to compete with the sdandard library. The best way to acess the inner char array is to call String::toCharArray, which actually makes a copy instead of returning the original array Object."
                    },
                    {
                        "username": "SuvenduGhosh",
                        "content": "\\'\\'\\'\\nreturn haystack.find(needle)\\n\\'\\'\\'"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "![image](https://assets.leetcode.com/users/images/db642348-ec38-44ee-934e-3a5074438185_1597595613.9781873.png)\\n\\n![image](https://assets.leetcode.com/users/images/733c099d-3b1d-4339-a93b-89068aa96d35_1597595620.1702633.png)\\n\\n* see why hash function selection is important\\n![image](https://assets.leetcode.com/users/images/76661a64-e6d5-4231-bf1d-013748456c8c_1597595850.0052273.png)\\n\\n"
                    },
                    {
                        "username": "babayagaaaa",
                        "content": "Its like a swamp, the more you try, the more you drown. \\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "Elsone",
                        "content": "My solution is accepted but the run time is not that good. Time complexity O(n-len(needle)). shift one char at a time and i check if needle is include in the current substring"
                    },
                    {
                        "username": "vinay_jain_61787",
                        "content": "In c++ we could use the built in function find() to find the occurence of the word. \\nWith which we could beat 100% of the users\\n"
                    },
                    {
                        "username": "Anshul29",
                        "content": "Anyone getting wrong answer on test case:\\nhaystack: \"ababcaababcaabc\"\\nneedle: \"ababcaabc\"\\nany advice how to tackle it"
                    }
                ]
            },
            {
                "id": 2059899,
                "content": [
                    {
                        "username": "girinatarajan",
                        "content": "return haystack.find(needle)"
                    },
                    {
                        "username": "sankarees",
                        "content": "I have updated the code in my github. Please refer the below link to check the source code and time complexity to run this code.\\n\\nhttps://github.com/sankarees/program-interview-job-learning/upload/main/myplayground/src/myplayground\\n\\n\\n![image](https://assets.leetcode.com/users/images/a10f90bf-98d0-4b5d-8e80-870face53c8f_1642430181.1675096.jpeg)\\n\\n\\n"
                    },
                    {
                        "username": "charan_rs_guru",
                        "content": "return haystack.indexOf(needle);"
                    },
                    {
                        "username": "bosserbosser",
                        "content": "\\tWe commonly use String::charAt to get a char from String, and that function do more things than just get an element from the inner char array instance. Unless making a copy of the inner char array first, it will be unfair for us to compete with the sdandard library. The best way to acess the inner char array is to call String::toCharArray, which actually makes a copy instead of returning the original array Object."
                    },
                    {
                        "username": "SuvenduGhosh",
                        "content": "\\'\\'\\'\\nreturn haystack.find(needle)\\n\\'\\'\\'"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "![image](https://assets.leetcode.com/users/images/db642348-ec38-44ee-934e-3a5074438185_1597595613.9781873.png)\\n\\n![image](https://assets.leetcode.com/users/images/733c099d-3b1d-4339-a93b-89068aa96d35_1597595620.1702633.png)\\n\\n* see why hash function selection is important\\n![image](https://assets.leetcode.com/users/images/76661a64-e6d5-4231-bf1d-013748456c8c_1597595850.0052273.png)\\n\\n"
                    },
                    {
                        "username": "babayagaaaa",
                        "content": "Its like a swamp, the more you try, the more you drown. \\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "Elsone",
                        "content": "My solution is accepted but the run time is not that good. Time complexity O(n-len(needle)). shift one char at a time and i check if needle is include in the current substring"
                    },
                    {
                        "username": "vinay_jain_61787",
                        "content": "In c++ we could use the built in function find() to find the occurence of the word. \\nWith which we could beat 100% of the users\\n"
                    },
                    {
                        "username": "Anshul29",
                        "content": "Anyone getting wrong answer on test case:\\nhaystack: \"ababcaababcaabc\"\\nneedle: \"ababcaabc\"\\nany advice how to tackle it"
                    }
                ]
            },
            {
                "id": 2059046,
                "content": [
                    {
                        "username": "girinatarajan",
                        "content": "return haystack.find(needle)"
                    },
                    {
                        "username": "sankarees",
                        "content": "I have updated the code in my github. Please refer the below link to check the source code and time complexity to run this code.\\n\\nhttps://github.com/sankarees/program-interview-job-learning/upload/main/myplayground/src/myplayground\\n\\n\\n![image](https://assets.leetcode.com/users/images/a10f90bf-98d0-4b5d-8e80-870face53c8f_1642430181.1675096.jpeg)\\n\\n\\n"
                    },
                    {
                        "username": "charan_rs_guru",
                        "content": "return haystack.indexOf(needle);"
                    },
                    {
                        "username": "bosserbosser",
                        "content": "\\tWe commonly use String::charAt to get a char from String, and that function do more things than just get an element from the inner char array instance. Unless making a copy of the inner char array first, it will be unfair for us to compete with the sdandard library. The best way to acess the inner char array is to call String::toCharArray, which actually makes a copy instead of returning the original array Object."
                    },
                    {
                        "username": "SuvenduGhosh",
                        "content": "\\'\\'\\'\\nreturn haystack.find(needle)\\n\\'\\'\\'"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "![image](https://assets.leetcode.com/users/images/db642348-ec38-44ee-934e-3a5074438185_1597595613.9781873.png)\\n\\n![image](https://assets.leetcode.com/users/images/733c099d-3b1d-4339-a93b-89068aa96d35_1597595620.1702633.png)\\n\\n* see why hash function selection is important\\n![image](https://assets.leetcode.com/users/images/76661a64-e6d5-4231-bf1d-013748456c8c_1597595850.0052273.png)\\n\\n"
                    },
                    {
                        "username": "babayagaaaa",
                        "content": "Its like a swamp, the more you try, the more you drown. \\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "Elsone",
                        "content": "My solution is accepted but the run time is not that good. Time complexity O(n-len(needle)). shift one char at a time and i check if needle is include in the current substring"
                    },
                    {
                        "username": "vinay_jain_61787",
                        "content": "In c++ we could use the built in function find() to find the occurence of the word. \\nWith which we could beat 100% of the users\\n"
                    },
                    {
                        "username": "Anshul29",
                        "content": "Anyone getting wrong answer on test case:\\nhaystack: \"ababcaababcaabc\"\\nneedle: \"ababcaabc\"\\nany advice how to tackle it"
                    }
                ]
            },
            {
                "id": 2057646,
                "content": [
                    {
                        "username": "greensignal",
                        "content": "Why people are using KMP Algo and noone talking of Rabin Karp Algo, timme complexity of both being O(m+n), O(n-m+1) respectively..."
                    },
                    {
                        "username": "buli03",
                        "content": "c# brute force go brrrrrrrrrrr"
                    },
                    {
                        "username": "ashishr0301",
                        "content": "KISS.\\n:) "
                    },
                    {
                        "username": "GouravSingh1729",
                        "content": "Use substring wiht try catch "
                    },
                    {
                        "username": "tanvith_shen0y",
                        "content": "problem on O(mn)  : \nproblem on O(m+n) : "
                    },
                    {
                        "username": "psionl0",
                        "content": "# MSD vs Rabin-Karp\\nI coded this problem using both the MSD algorithm (https://leetcode.com/submissions/detail/1027485142/) and the Rabin-Karp algorithm (https://leetcode.com/submissions/detail/1028159652/). Both algorithms ran in 0 ms and took 5.5 MB.\\nAlthough I understand what the MSD algorithm is doing, I found the coding a little unintuitive meaning that I probably wouldn\\'t be able to  duplicate the code in an interview without using a cheat sheet.\\nHowever, a rolling hash function is easy to compute and I found the whole Rabin-Karp algorithm quite intuitive. Although a character count comparison isn\\'t revealing, it seems that Rabin-Karp requires slightly less coding than MSD but you need to test for more edge cases (for example, if the needle is longer than the haystack then MSD appears to cope but Rabin-Karp fails).\\nMy vote: Rabin-Karp"
                    },
                    {
                        "username": "rastogi31",
                        "content": "here in C++ inbuilt substring function\\n `class Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n         size_t found = haystack.find(needle);\\n  if (found != string::npos)\\n    return (found);   //first occur\\n  else \\n    return -1;\\n    }\\n};`"
                    },
                    {
                        "username": "selmun13",
                        "content": "hey guys I\\'ve encountered a problem when I try to submit a Runtime Error occurred because of heap buffer overflow, however the two test cases passed with no problems. \\nPS: Im using C"
                    },
                    {
                        "username": "Venota",
                        "content": "idk why my code is wrong..  i use python3, in this web terminal it doesn\\'t accept, but in PyCharm it\\'s correct\\nMy code:\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        if needle not in haystack:\\n            print(-1)\\n        else:\\n            a = len(haystack)\\n            b = len(needle)\\n            for i in range(a):\\n                if str(needle[0:(b - 1)]) == str(haystack[i:(i + b - 1)]):\\n                    print(i)\\n                    break"
                    },
                    {
                        "username": "HarshSaini07",
                        "content": " class Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        auto it = haystack.find(needle);\\n        if(it != haystack.end()){  // in this condition an error generates , what should i do ?\\n \\n            return it;\\n        }\\n        else{\\n            return -1;\\n        }\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 2049472,
                "content": [
                    {
                        "username": "greensignal",
                        "content": "Why people are using KMP Algo and noone talking of Rabin Karp Algo, timme complexity of both being O(m+n), O(n-m+1) respectively..."
                    },
                    {
                        "username": "buli03",
                        "content": "c# brute force go brrrrrrrrrrr"
                    },
                    {
                        "username": "ashishr0301",
                        "content": "KISS.\\n:) "
                    },
                    {
                        "username": "GouravSingh1729",
                        "content": "Use substring wiht try catch "
                    },
                    {
                        "username": "tanvith_shen0y",
                        "content": "problem on O(mn)  : \nproblem on O(m+n) : "
                    },
                    {
                        "username": "psionl0",
                        "content": "# MSD vs Rabin-Karp\\nI coded this problem using both the MSD algorithm (https://leetcode.com/submissions/detail/1027485142/) and the Rabin-Karp algorithm (https://leetcode.com/submissions/detail/1028159652/). Both algorithms ran in 0 ms and took 5.5 MB.\\nAlthough I understand what the MSD algorithm is doing, I found the coding a little unintuitive meaning that I probably wouldn\\'t be able to  duplicate the code in an interview without using a cheat sheet.\\nHowever, a rolling hash function is easy to compute and I found the whole Rabin-Karp algorithm quite intuitive. Although a character count comparison isn\\'t revealing, it seems that Rabin-Karp requires slightly less coding than MSD but you need to test for more edge cases (for example, if the needle is longer than the haystack then MSD appears to cope but Rabin-Karp fails).\\nMy vote: Rabin-Karp"
                    },
                    {
                        "username": "rastogi31",
                        "content": "here in C++ inbuilt substring function\\n `class Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n         size_t found = haystack.find(needle);\\n  if (found != string::npos)\\n    return (found);   //first occur\\n  else \\n    return -1;\\n    }\\n};`"
                    },
                    {
                        "username": "selmun13",
                        "content": "hey guys I\\'ve encountered a problem when I try to submit a Runtime Error occurred because of heap buffer overflow, however the two test cases passed with no problems. \\nPS: Im using C"
                    },
                    {
                        "username": "Venota",
                        "content": "idk why my code is wrong..  i use python3, in this web terminal it doesn\\'t accept, but in PyCharm it\\'s correct\\nMy code:\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        if needle not in haystack:\\n            print(-1)\\n        else:\\n            a = len(haystack)\\n            b = len(needle)\\n            for i in range(a):\\n                if str(needle[0:(b - 1)]) == str(haystack[i:(i + b - 1)]):\\n                    print(i)\\n                    break"
                    },
                    {
                        "username": "HarshSaini07",
                        "content": " class Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        auto it = haystack.find(needle);\\n        if(it != haystack.end()){  // in this condition an error generates , what should i do ?\\n \\n            return it;\\n        }\\n        else{\\n            return -1;\\n        }\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 2033026,
                "content": [
                    {
                        "username": "greensignal",
                        "content": "Why people are using KMP Algo and noone talking of Rabin Karp Algo, timme complexity of both being O(m+n), O(n-m+1) respectively..."
                    },
                    {
                        "username": "buli03",
                        "content": "c# brute force go brrrrrrrrrrr"
                    },
                    {
                        "username": "ashishr0301",
                        "content": "KISS.\\n:) "
                    },
                    {
                        "username": "GouravSingh1729",
                        "content": "Use substring wiht try catch "
                    },
                    {
                        "username": "tanvith_shen0y",
                        "content": "problem on O(mn)  : \nproblem on O(m+n) : "
                    },
                    {
                        "username": "psionl0",
                        "content": "# MSD vs Rabin-Karp\\nI coded this problem using both the MSD algorithm (https://leetcode.com/submissions/detail/1027485142/) and the Rabin-Karp algorithm (https://leetcode.com/submissions/detail/1028159652/). Both algorithms ran in 0 ms and took 5.5 MB.\\nAlthough I understand what the MSD algorithm is doing, I found the coding a little unintuitive meaning that I probably wouldn\\'t be able to  duplicate the code in an interview without using a cheat sheet.\\nHowever, a rolling hash function is easy to compute and I found the whole Rabin-Karp algorithm quite intuitive. Although a character count comparison isn\\'t revealing, it seems that Rabin-Karp requires slightly less coding than MSD but you need to test for more edge cases (for example, if the needle is longer than the haystack then MSD appears to cope but Rabin-Karp fails).\\nMy vote: Rabin-Karp"
                    },
                    {
                        "username": "rastogi31",
                        "content": "here in C++ inbuilt substring function\\n `class Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n         size_t found = haystack.find(needle);\\n  if (found != string::npos)\\n    return (found);   //first occur\\n  else \\n    return -1;\\n    }\\n};`"
                    },
                    {
                        "username": "selmun13",
                        "content": "hey guys I\\'ve encountered a problem when I try to submit a Runtime Error occurred because of heap buffer overflow, however the two test cases passed with no problems. \\nPS: Im using C"
                    },
                    {
                        "username": "Venota",
                        "content": "idk why my code is wrong..  i use python3, in this web terminal it doesn\\'t accept, but in PyCharm it\\'s correct\\nMy code:\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        if needle not in haystack:\\n            print(-1)\\n        else:\\n            a = len(haystack)\\n            b = len(needle)\\n            for i in range(a):\\n                if str(needle[0:(b - 1)]) == str(haystack[i:(i + b - 1)]):\\n                    print(i)\\n                    break"
                    },
                    {
                        "username": "HarshSaini07",
                        "content": " class Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        auto it = haystack.find(needle);\\n        if(it != haystack.end()){  // in this condition an error generates , what should i do ?\\n \\n            return it;\\n        }\\n        else{\\n            return -1;\\n        }\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 2026596,
                "content": [
                    {
                        "username": "greensignal",
                        "content": "Why people are using KMP Algo and noone talking of Rabin Karp Algo, timme complexity of both being O(m+n), O(n-m+1) respectively..."
                    },
                    {
                        "username": "buli03",
                        "content": "c# brute force go brrrrrrrrrrr"
                    },
                    {
                        "username": "ashishr0301",
                        "content": "KISS.\\n:) "
                    },
                    {
                        "username": "GouravSingh1729",
                        "content": "Use substring wiht try catch "
                    },
                    {
                        "username": "tanvith_shen0y",
                        "content": "problem on O(mn)  : \nproblem on O(m+n) : "
                    },
                    {
                        "username": "psionl0",
                        "content": "# MSD vs Rabin-Karp\\nI coded this problem using both the MSD algorithm (https://leetcode.com/submissions/detail/1027485142/) and the Rabin-Karp algorithm (https://leetcode.com/submissions/detail/1028159652/). Both algorithms ran in 0 ms and took 5.5 MB.\\nAlthough I understand what the MSD algorithm is doing, I found the coding a little unintuitive meaning that I probably wouldn\\'t be able to  duplicate the code in an interview without using a cheat sheet.\\nHowever, a rolling hash function is easy to compute and I found the whole Rabin-Karp algorithm quite intuitive. Although a character count comparison isn\\'t revealing, it seems that Rabin-Karp requires slightly less coding than MSD but you need to test for more edge cases (for example, if the needle is longer than the haystack then MSD appears to cope but Rabin-Karp fails).\\nMy vote: Rabin-Karp"
                    },
                    {
                        "username": "rastogi31",
                        "content": "here in C++ inbuilt substring function\\n `class Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n         size_t found = haystack.find(needle);\\n  if (found != string::npos)\\n    return (found);   //first occur\\n  else \\n    return -1;\\n    }\\n};`"
                    },
                    {
                        "username": "selmun13",
                        "content": "hey guys I\\'ve encountered a problem when I try to submit a Runtime Error occurred because of heap buffer overflow, however the two test cases passed with no problems. \\nPS: Im using C"
                    },
                    {
                        "username": "Venota",
                        "content": "idk why my code is wrong..  i use python3, in this web terminal it doesn\\'t accept, but in PyCharm it\\'s correct\\nMy code:\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        if needle not in haystack:\\n            print(-1)\\n        else:\\n            a = len(haystack)\\n            b = len(needle)\\n            for i in range(a):\\n                if str(needle[0:(b - 1)]) == str(haystack[i:(i + b - 1)]):\\n                    print(i)\\n                    break"
                    },
                    {
                        "username": "HarshSaini07",
                        "content": " class Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        auto it = haystack.find(needle);\\n        if(it != haystack.end()){  // in this condition an error generates , what should i do ?\\n \\n            return it;\\n        }\\n        else{\\n            return -1;\\n        }\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 2025851,
                "content": [
                    {
                        "username": "greensignal",
                        "content": "Why people are using KMP Algo and noone talking of Rabin Karp Algo, timme complexity of both being O(m+n), O(n-m+1) respectively..."
                    },
                    {
                        "username": "buli03",
                        "content": "c# brute force go brrrrrrrrrrr"
                    },
                    {
                        "username": "ashishr0301",
                        "content": "KISS.\\n:) "
                    },
                    {
                        "username": "GouravSingh1729",
                        "content": "Use substring wiht try catch "
                    },
                    {
                        "username": "tanvith_shen0y",
                        "content": "problem on O(mn)  : \nproblem on O(m+n) : "
                    },
                    {
                        "username": "psionl0",
                        "content": "# MSD vs Rabin-Karp\\nI coded this problem using both the MSD algorithm (https://leetcode.com/submissions/detail/1027485142/) and the Rabin-Karp algorithm (https://leetcode.com/submissions/detail/1028159652/). Both algorithms ran in 0 ms and took 5.5 MB.\\nAlthough I understand what the MSD algorithm is doing, I found the coding a little unintuitive meaning that I probably wouldn\\'t be able to  duplicate the code in an interview without using a cheat sheet.\\nHowever, a rolling hash function is easy to compute and I found the whole Rabin-Karp algorithm quite intuitive. Although a character count comparison isn\\'t revealing, it seems that Rabin-Karp requires slightly less coding than MSD but you need to test for more edge cases (for example, if the needle is longer than the haystack then MSD appears to cope but Rabin-Karp fails).\\nMy vote: Rabin-Karp"
                    },
                    {
                        "username": "rastogi31",
                        "content": "here in C++ inbuilt substring function\\n `class Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n         size_t found = haystack.find(needle);\\n  if (found != string::npos)\\n    return (found);   //first occur\\n  else \\n    return -1;\\n    }\\n};`"
                    },
                    {
                        "username": "selmun13",
                        "content": "hey guys I\\'ve encountered a problem when I try to submit a Runtime Error occurred because of heap buffer overflow, however the two test cases passed with no problems. \\nPS: Im using C"
                    },
                    {
                        "username": "Venota",
                        "content": "idk why my code is wrong..  i use python3, in this web terminal it doesn\\'t accept, but in PyCharm it\\'s correct\\nMy code:\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        if needle not in haystack:\\n            print(-1)\\n        else:\\n            a = len(haystack)\\n            b = len(needle)\\n            for i in range(a):\\n                if str(needle[0:(b - 1)]) == str(haystack[i:(i + b - 1)]):\\n                    print(i)\\n                    break"
                    },
                    {
                        "username": "HarshSaini07",
                        "content": " class Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        auto it = haystack.find(needle);\\n        if(it != haystack.end()){  // in this condition an error generates , what should i do ?\\n \\n            return it;\\n        }\\n        else{\\n            return -1;\\n        }\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 2024838,
                "content": [
                    {
                        "username": "greensignal",
                        "content": "Why people are using KMP Algo and noone talking of Rabin Karp Algo, timme complexity of both being O(m+n), O(n-m+1) respectively..."
                    },
                    {
                        "username": "buli03",
                        "content": "c# brute force go brrrrrrrrrrr"
                    },
                    {
                        "username": "ashishr0301",
                        "content": "KISS.\\n:) "
                    },
                    {
                        "username": "GouravSingh1729",
                        "content": "Use substring wiht try catch "
                    },
                    {
                        "username": "tanvith_shen0y",
                        "content": "problem on O(mn)  : \nproblem on O(m+n) : "
                    },
                    {
                        "username": "psionl0",
                        "content": "# MSD vs Rabin-Karp\\nI coded this problem using both the MSD algorithm (https://leetcode.com/submissions/detail/1027485142/) and the Rabin-Karp algorithm (https://leetcode.com/submissions/detail/1028159652/). Both algorithms ran in 0 ms and took 5.5 MB.\\nAlthough I understand what the MSD algorithm is doing, I found the coding a little unintuitive meaning that I probably wouldn\\'t be able to  duplicate the code in an interview without using a cheat sheet.\\nHowever, a rolling hash function is easy to compute and I found the whole Rabin-Karp algorithm quite intuitive. Although a character count comparison isn\\'t revealing, it seems that Rabin-Karp requires slightly less coding than MSD but you need to test for more edge cases (for example, if the needle is longer than the haystack then MSD appears to cope but Rabin-Karp fails).\\nMy vote: Rabin-Karp"
                    },
                    {
                        "username": "rastogi31",
                        "content": "here in C++ inbuilt substring function\\n `class Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n         size_t found = haystack.find(needle);\\n  if (found != string::npos)\\n    return (found);   //first occur\\n  else \\n    return -1;\\n    }\\n};`"
                    },
                    {
                        "username": "selmun13",
                        "content": "hey guys I\\'ve encountered a problem when I try to submit a Runtime Error occurred because of heap buffer overflow, however the two test cases passed with no problems. \\nPS: Im using C"
                    },
                    {
                        "username": "Venota",
                        "content": "idk why my code is wrong..  i use python3, in this web terminal it doesn\\'t accept, but in PyCharm it\\'s correct\\nMy code:\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        if needle not in haystack:\\n            print(-1)\\n        else:\\n            a = len(haystack)\\n            b = len(needle)\\n            for i in range(a):\\n                if str(needle[0:(b - 1)]) == str(haystack[i:(i + b - 1)]):\\n                    print(i)\\n                    break"
                    },
                    {
                        "username": "HarshSaini07",
                        "content": " class Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        auto it = haystack.find(needle);\\n        if(it != haystack.end()){  // in this condition an error generates , what should i do ?\\n \\n            return it;\\n        }\\n        else{\\n            return -1;\\n        }\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 2023865,
                "content": [
                    {
                        "username": "greensignal",
                        "content": "Why people are using KMP Algo and noone talking of Rabin Karp Algo, timme complexity of both being O(m+n), O(n-m+1) respectively..."
                    },
                    {
                        "username": "buli03",
                        "content": "c# brute force go brrrrrrrrrrr"
                    },
                    {
                        "username": "ashishr0301",
                        "content": "KISS.\\n:) "
                    },
                    {
                        "username": "GouravSingh1729",
                        "content": "Use substring wiht try catch "
                    },
                    {
                        "username": "tanvith_shen0y",
                        "content": "problem on O(mn)  : \nproblem on O(m+n) : "
                    },
                    {
                        "username": "psionl0",
                        "content": "# MSD vs Rabin-Karp\\nI coded this problem using both the MSD algorithm (https://leetcode.com/submissions/detail/1027485142/) and the Rabin-Karp algorithm (https://leetcode.com/submissions/detail/1028159652/). Both algorithms ran in 0 ms and took 5.5 MB.\\nAlthough I understand what the MSD algorithm is doing, I found the coding a little unintuitive meaning that I probably wouldn\\'t be able to  duplicate the code in an interview without using a cheat sheet.\\nHowever, a rolling hash function is easy to compute and I found the whole Rabin-Karp algorithm quite intuitive. Although a character count comparison isn\\'t revealing, it seems that Rabin-Karp requires slightly less coding than MSD but you need to test for more edge cases (for example, if the needle is longer than the haystack then MSD appears to cope but Rabin-Karp fails).\\nMy vote: Rabin-Karp"
                    },
                    {
                        "username": "rastogi31",
                        "content": "here in C++ inbuilt substring function\\n `class Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n         size_t found = haystack.find(needle);\\n  if (found != string::npos)\\n    return (found);   //first occur\\n  else \\n    return -1;\\n    }\\n};`"
                    },
                    {
                        "username": "selmun13",
                        "content": "hey guys I\\'ve encountered a problem when I try to submit a Runtime Error occurred because of heap buffer overflow, however the two test cases passed with no problems. \\nPS: Im using C"
                    },
                    {
                        "username": "Venota",
                        "content": "idk why my code is wrong..  i use python3, in this web terminal it doesn\\'t accept, but in PyCharm it\\'s correct\\nMy code:\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        if needle not in haystack:\\n            print(-1)\\n        else:\\n            a = len(haystack)\\n            b = len(needle)\\n            for i in range(a):\\n                if str(needle[0:(b - 1)]) == str(haystack[i:(i + b - 1)]):\\n                    print(i)\\n                    break"
                    },
                    {
                        "username": "HarshSaini07",
                        "content": " class Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        auto it = haystack.find(needle);\\n        if(it != haystack.end()){  // in this condition an error generates , what should i do ?\\n \\n            return it;\\n        }\\n        else{\\n            return -1;\\n        }\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 2023694,
                "content": [
                    {
                        "username": "greensignal",
                        "content": "Why people are using KMP Algo and noone talking of Rabin Karp Algo, timme complexity of both being O(m+n), O(n-m+1) respectively..."
                    },
                    {
                        "username": "buli03",
                        "content": "c# brute force go brrrrrrrrrrr"
                    },
                    {
                        "username": "ashishr0301",
                        "content": "KISS.\\n:) "
                    },
                    {
                        "username": "GouravSingh1729",
                        "content": "Use substring wiht try catch "
                    },
                    {
                        "username": "tanvith_shen0y",
                        "content": "problem on O(mn)  : \nproblem on O(m+n) : "
                    },
                    {
                        "username": "psionl0",
                        "content": "# MSD vs Rabin-Karp\\nI coded this problem using both the MSD algorithm (https://leetcode.com/submissions/detail/1027485142/) and the Rabin-Karp algorithm (https://leetcode.com/submissions/detail/1028159652/). Both algorithms ran in 0 ms and took 5.5 MB.\\nAlthough I understand what the MSD algorithm is doing, I found the coding a little unintuitive meaning that I probably wouldn\\'t be able to  duplicate the code in an interview without using a cheat sheet.\\nHowever, a rolling hash function is easy to compute and I found the whole Rabin-Karp algorithm quite intuitive. Although a character count comparison isn\\'t revealing, it seems that Rabin-Karp requires slightly less coding than MSD but you need to test for more edge cases (for example, if the needle is longer than the haystack then MSD appears to cope but Rabin-Karp fails).\\nMy vote: Rabin-Karp"
                    },
                    {
                        "username": "rastogi31",
                        "content": "here in C++ inbuilt substring function\\n `class Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n         size_t found = haystack.find(needle);\\n  if (found != string::npos)\\n    return (found);   //first occur\\n  else \\n    return -1;\\n    }\\n};`"
                    },
                    {
                        "username": "selmun13",
                        "content": "hey guys I\\'ve encountered a problem when I try to submit a Runtime Error occurred because of heap buffer overflow, however the two test cases passed with no problems. \\nPS: Im using C"
                    },
                    {
                        "username": "Venota",
                        "content": "idk why my code is wrong..  i use python3, in this web terminal it doesn\\'t accept, but in PyCharm it\\'s correct\\nMy code:\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        if needle not in haystack:\\n            print(-1)\\n        else:\\n            a = len(haystack)\\n            b = len(needle)\\n            for i in range(a):\\n                if str(needle[0:(b - 1)]) == str(haystack[i:(i + b - 1)]):\\n                    print(i)\\n                    break"
                    },
                    {
                        "username": "HarshSaini07",
                        "content": " class Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        auto it = haystack.find(needle);\\n        if(it != haystack.end()){  // in this condition an error generates , what should i do ?\\n \\n            return it;\\n        }\\n        else{\\n            return -1;\\n        }\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 2017561,
                "content": [
                    {
                        "username": "greensignal",
                        "content": "Why people are using KMP Algo and noone talking of Rabin Karp Algo, timme complexity of both being O(m+n), O(n-m+1) respectively..."
                    },
                    {
                        "username": "buli03",
                        "content": "c# brute force go brrrrrrrrrrr"
                    },
                    {
                        "username": "ashishr0301",
                        "content": "KISS.\\n:) "
                    },
                    {
                        "username": "GouravSingh1729",
                        "content": "Use substring wiht try catch "
                    },
                    {
                        "username": "tanvith_shen0y",
                        "content": "problem on O(mn)  : \nproblem on O(m+n) : "
                    },
                    {
                        "username": "psionl0",
                        "content": "# MSD vs Rabin-Karp\\nI coded this problem using both the MSD algorithm (https://leetcode.com/submissions/detail/1027485142/) and the Rabin-Karp algorithm (https://leetcode.com/submissions/detail/1028159652/). Both algorithms ran in 0 ms and took 5.5 MB.\\nAlthough I understand what the MSD algorithm is doing, I found the coding a little unintuitive meaning that I probably wouldn\\'t be able to  duplicate the code in an interview without using a cheat sheet.\\nHowever, a rolling hash function is easy to compute and I found the whole Rabin-Karp algorithm quite intuitive. Although a character count comparison isn\\'t revealing, it seems that Rabin-Karp requires slightly less coding than MSD but you need to test for more edge cases (for example, if the needle is longer than the haystack then MSD appears to cope but Rabin-Karp fails).\\nMy vote: Rabin-Karp"
                    },
                    {
                        "username": "rastogi31",
                        "content": "here in C++ inbuilt substring function\\n `class Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n         size_t found = haystack.find(needle);\\n  if (found != string::npos)\\n    return (found);   //first occur\\n  else \\n    return -1;\\n    }\\n};`"
                    },
                    {
                        "username": "selmun13",
                        "content": "hey guys I\\'ve encountered a problem when I try to submit a Runtime Error occurred because of heap buffer overflow, however the two test cases passed with no problems. \\nPS: Im using C"
                    },
                    {
                        "username": "Venota",
                        "content": "idk why my code is wrong..  i use python3, in this web terminal it doesn\\'t accept, but in PyCharm it\\'s correct\\nMy code:\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        if needle not in haystack:\\n            print(-1)\\n        else:\\n            a = len(haystack)\\n            b = len(needle)\\n            for i in range(a):\\n                if str(needle[0:(b - 1)]) == str(haystack[i:(i + b - 1)]):\\n                    print(i)\\n                    break"
                    },
                    {
                        "username": "HarshSaini07",
                        "content": " class Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        auto it = haystack.find(needle);\\n        if(it != haystack.end()){  // in this condition an error generates , what should i do ?\\n \\n            return it;\\n        }\\n        else{\\n            return -1;\\n        }\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 2015002,
                "content": [
                    {
                        "username": "greensignal",
                        "content": "Why people are using KMP Algo and noone talking of Rabin Karp Algo, timme complexity of both being O(m+n), O(n-m+1) respectively..."
                    },
                    {
                        "username": "buli03",
                        "content": "c# brute force go brrrrrrrrrrr"
                    },
                    {
                        "username": "ashishr0301",
                        "content": "KISS.\\n:) "
                    },
                    {
                        "username": "GouravSingh1729",
                        "content": "Use substring wiht try catch "
                    },
                    {
                        "username": "tanvith_shen0y",
                        "content": "problem on O(mn)  : \nproblem on O(m+n) : "
                    },
                    {
                        "username": "psionl0",
                        "content": "# MSD vs Rabin-Karp\\nI coded this problem using both the MSD algorithm (https://leetcode.com/submissions/detail/1027485142/) and the Rabin-Karp algorithm (https://leetcode.com/submissions/detail/1028159652/). Both algorithms ran in 0 ms and took 5.5 MB.\\nAlthough I understand what the MSD algorithm is doing, I found the coding a little unintuitive meaning that I probably wouldn\\'t be able to  duplicate the code in an interview without using a cheat sheet.\\nHowever, a rolling hash function is easy to compute and I found the whole Rabin-Karp algorithm quite intuitive. Although a character count comparison isn\\'t revealing, it seems that Rabin-Karp requires slightly less coding than MSD but you need to test for more edge cases (for example, if the needle is longer than the haystack then MSD appears to cope but Rabin-Karp fails).\\nMy vote: Rabin-Karp"
                    },
                    {
                        "username": "rastogi31",
                        "content": "here in C++ inbuilt substring function\\n `class Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n         size_t found = haystack.find(needle);\\n  if (found != string::npos)\\n    return (found);   //first occur\\n  else \\n    return -1;\\n    }\\n};`"
                    },
                    {
                        "username": "selmun13",
                        "content": "hey guys I\\'ve encountered a problem when I try to submit a Runtime Error occurred because of heap buffer overflow, however the two test cases passed with no problems. \\nPS: Im using C"
                    },
                    {
                        "username": "Venota",
                        "content": "idk why my code is wrong..  i use python3, in this web terminal it doesn\\'t accept, but in PyCharm it\\'s correct\\nMy code:\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        if needle not in haystack:\\n            print(-1)\\n        else:\\n            a = len(haystack)\\n            b = len(needle)\\n            for i in range(a):\\n                if str(needle[0:(b - 1)]) == str(haystack[i:(i + b - 1)]):\\n                    print(i)\\n                    break"
                    },
                    {
                        "username": "HarshSaini07",
                        "content": " class Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        auto it = haystack.find(needle);\\n        if(it != haystack.end()){  // in this condition an error generates , what should i do ?\\n \\n            return it;\\n        }\\n        else{\\n            return -1;\\n        }\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 2014837,
                "content": [
                    {
                        "username": "Squirrel848",
                        "content": "I somehow feel like this can linked with problem 14. If you decide to use String.StartsWith()"
                    },
                    {
                        "username": "shivx_444",
                        "content": "Here\\'s a concise algorithm to solve the \"Implement strStr()\" problem using a sliding window approach:\\n\\n1. Initialize haystackLen as the length of the haystack string and needleLen as the length of the needle string.\\n\\n2. Check for the special case where needleLen is 0. If true, return 0.\\n\\n3. Loop through the haystack string from index 0 to haystackLen - needleLen:\\n\\n- If the character at the current index i in the haystack matches the first character of the needle:\\n- Use the substring method to extract a substring of length needleLen starting from index i.\\n- Compare the extracted substring with the needle string using the equals method.\\n- If they match, return the index i.\\n4. If no match is found in the loop, return -1 to indicate that the needle is not found in the haystack.\\n\\n"
                    },
                    {
                        "username": "shivx_444",
                        "content": "Certainly! Here\\'s a concise algorithm for solving the string searching problem without using the built-in `indexOf` method:\\n\\n1. If the `needle` is an empty string, return 0, as an empty string matches at the beginning of any string.\\n\\n2. Iterate through the `haystack` using a loop with the index `i` ranging from 0 to `haystack.length() - needle.length()`.\\n\\n3. For each character in `haystack` at index `i` that matches the first character of `needle`:\\n   - Initialize a variable `j` to 0.\\n   - While `j` is less than `needle.length()` and characters at indices `i + j` in `haystack` and `j` in `needle` are equal:\\n     - Increment `j`.\\n   - If `j` becomes equal to `needle.length()`, a complete match is found.\\n     - Return the index `i`.\\n\\n4. If no match is found during the loop, return -1.\\n\\nThis algorithm efficiently searches for the first occurrence of `needle` within `haystack` without using the built-in `indexOf` method."
                    },
                    {
                        "username": "user2342ZB",
                        "content": "LOL I wrote this code and it got accepted because it passed the testcases XD This is cheating, leetcode should look into this.\\n\\n` class Solution:\\n\\n    def strStr(self, haystack: str, needle: str) -> int:\\n\\n        if needle not in haystack:\\n            return -1\\n\\n        return 0`"
                    },
                    {
                        "username": "gaurav_dadwal",
                        "content": "class Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        int ans=-1;\\n        for(int i=0;i<haystack.length();i++){\\n            if(haystack.substr(i,needle.size())==needle){\\n                ans=i;\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "sangram72",
                        "content": "Easy CPP Solution for beginners           \\n\\n\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n         size_t found = haystack.find(needle);\\n  if (found != string::npos){\\n   return found;\\n  }\\n  return -1;\\n\\n    }\\n};"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "This problem serves as a perfect chance to understand and implement one of the most efficient techniques, the Knuth-Morris-Pratt (KMP) algorithm. The problem pushes you to move beyond a naive approach, which could have a time complexity of `O(n*m)` in the worst-case scenario, and use a more efficient KMP algorithm that has a time complexity of `O(n+m)`. This highlights the importance of efficient algorithms in programming. As it\\'s a string-based problem, it gives you practice with string manipulation techniques, you\\'re also required to handle edge cases (like when the needle is an empty string), reinforcing the concept of comprehensive testing."
                    },
                    {
                        "username": "psionl0",
                        "content": "Don\\'t forget about the Rabin-Karp algorithm. This is just as efficient as KMP."
                    },
                    {
                        "username": "ankitparashar700",
                        "content": "Easiest and one liner code if you know string methods"
                    },
                    {
                        "username": "mzuathotmaildotcom",
                        "content": "Can we change example from \"sadbutsad\" to \"happyandhappy\" ?"
                    },
                    {
                        "username": "psionl0",
                        "content": "You can input any customized test case you want."
                    },
                    {
                        "username": "Malay107",
                        "content": "Once this problem was marked \"medium\"...now its easy."
                    },
                    {
                        "username": "psionl0",
                        "content": "Probably because you can use brute force or just use a library function to find the substring."
                    }
                ]
            },
            {
                "id": 2011323,
                "content": [
                    {
                        "username": "Squirrel848",
                        "content": "I somehow feel like this can linked with problem 14. If you decide to use String.StartsWith()"
                    },
                    {
                        "username": "shivx_444",
                        "content": "Here\\'s a concise algorithm to solve the \"Implement strStr()\" problem using a sliding window approach:\\n\\n1. Initialize haystackLen as the length of the haystack string and needleLen as the length of the needle string.\\n\\n2. Check for the special case where needleLen is 0. If true, return 0.\\n\\n3. Loop through the haystack string from index 0 to haystackLen - needleLen:\\n\\n- If the character at the current index i in the haystack matches the first character of the needle:\\n- Use the substring method to extract a substring of length needleLen starting from index i.\\n- Compare the extracted substring with the needle string using the equals method.\\n- If they match, return the index i.\\n4. If no match is found in the loop, return -1 to indicate that the needle is not found in the haystack.\\n\\n"
                    },
                    {
                        "username": "shivx_444",
                        "content": "Certainly! Here\\'s a concise algorithm for solving the string searching problem without using the built-in `indexOf` method:\\n\\n1. If the `needle` is an empty string, return 0, as an empty string matches at the beginning of any string.\\n\\n2. Iterate through the `haystack` using a loop with the index `i` ranging from 0 to `haystack.length() - needle.length()`.\\n\\n3. For each character in `haystack` at index `i` that matches the first character of `needle`:\\n   - Initialize a variable `j` to 0.\\n   - While `j` is less than `needle.length()` and characters at indices `i + j` in `haystack` and `j` in `needle` are equal:\\n     - Increment `j`.\\n   - If `j` becomes equal to `needle.length()`, a complete match is found.\\n     - Return the index `i`.\\n\\n4. If no match is found during the loop, return -1.\\n\\nThis algorithm efficiently searches for the first occurrence of `needle` within `haystack` without using the built-in `indexOf` method."
                    },
                    {
                        "username": "user2342ZB",
                        "content": "LOL I wrote this code and it got accepted because it passed the testcases XD This is cheating, leetcode should look into this.\\n\\n` class Solution:\\n\\n    def strStr(self, haystack: str, needle: str) -> int:\\n\\n        if needle not in haystack:\\n            return -1\\n\\n        return 0`"
                    },
                    {
                        "username": "gaurav_dadwal",
                        "content": "class Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        int ans=-1;\\n        for(int i=0;i<haystack.length();i++){\\n            if(haystack.substr(i,needle.size())==needle){\\n                ans=i;\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "sangram72",
                        "content": "Easy CPP Solution for beginners           \\n\\n\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n         size_t found = haystack.find(needle);\\n  if (found != string::npos){\\n   return found;\\n  }\\n  return -1;\\n\\n    }\\n};"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "This problem serves as a perfect chance to understand and implement one of the most efficient techniques, the Knuth-Morris-Pratt (KMP) algorithm. The problem pushes you to move beyond a naive approach, which could have a time complexity of `O(n*m)` in the worst-case scenario, and use a more efficient KMP algorithm that has a time complexity of `O(n+m)`. This highlights the importance of efficient algorithms in programming. As it\\'s a string-based problem, it gives you practice with string manipulation techniques, you\\'re also required to handle edge cases (like when the needle is an empty string), reinforcing the concept of comprehensive testing."
                    },
                    {
                        "username": "psionl0",
                        "content": "Don\\'t forget about the Rabin-Karp algorithm. This is just as efficient as KMP."
                    },
                    {
                        "username": "ankitparashar700",
                        "content": "Easiest and one liner code if you know string methods"
                    },
                    {
                        "username": "mzuathotmaildotcom",
                        "content": "Can we change example from \"sadbutsad\" to \"happyandhappy\" ?"
                    },
                    {
                        "username": "psionl0",
                        "content": "You can input any customized test case you want."
                    },
                    {
                        "username": "Malay107",
                        "content": "Once this problem was marked \"medium\"...now its easy."
                    },
                    {
                        "username": "psionl0",
                        "content": "Probably because you can use brute force or just use a library function to find the substring."
                    }
                ]
            },
            {
                "id": 2011317,
                "content": [
                    {
                        "username": "Squirrel848",
                        "content": "I somehow feel like this can linked with problem 14. If you decide to use String.StartsWith()"
                    },
                    {
                        "username": "shivx_444",
                        "content": "Here\\'s a concise algorithm to solve the \"Implement strStr()\" problem using a sliding window approach:\\n\\n1. Initialize haystackLen as the length of the haystack string and needleLen as the length of the needle string.\\n\\n2. Check for the special case where needleLen is 0. If true, return 0.\\n\\n3. Loop through the haystack string from index 0 to haystackLen - needleLen:\\n\\n- If the character at the current index i in the haystack matches the first character of the needle:\\n- Use the substring method to extract a substring of length needleLen starting from index i.\\n- Compare the extracted substring with the needle string using the equals method.\\n- If they match, return the index i.\\n4. If no match is found in the loop, return -1 to indicate that the needle is not found in the haystack.\\n\\n"
                    },
                    {
                        "username": "shivx_444",
                        "content": "Certainly! Here\\'s a concise algorithm for solving the string searching problem without using the built-in `indexOf` method:\\n\\n1. If the `needle` is an empty string, return 0, as an empty string matches at the beginning of any string.\\n\\n2. Iterate through the `haystack` using a loop with the index `i` ranging from 0 to `haystack.length() - needle.length()`.\\n\\n3. For each character in `haystack` at index `i` that matches the first character of `needle`:\\n   - Initialize a variable `j` to 0.\\n   - While `j` is less than `needle.length()` and characters at indices `i + j` in `haystack` and `j` in `needle` are equal:\\n     - Increment `j`.\\n   - If `j` becomes equal to `needle.length()`, a complete match is found.\\n     - Return the index `i`.\\n\\n4. If no match is found during the loop, return -1.\\n\\nThis algorithm efficiently searches for the first occurrence of `needle` within `haystack` without using the built-in `indexOf` method."
                    },
                    {
                        "username": "user2342ZB",
                        "content": "LOL I wrote this code and it got accepted because it passed the testcases XD This is cheating, leetcode should look into this.\\n\\n` class Solution:\\n\\n    def strStr(self, haystack: str, needle: str) -> int:\\n\\n        if needle not in haystack:\\n            return -1\\n\\n        return 0`"
                    },
                    {
                        "username": "gaurav_dadwal",
                        "content": "class Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        int ans=-1;\\n        for(int i=0;i<haystack.length();i++){\\n            if(haystack.substr(i,needle.size())==needle){\\n                ans=i;\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "sangram72",
                        "content": "Easy CPP Solution for beginners           \\n\\n\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n         size_t found = haystack.find(needle);\\n  if (found != string::npos){\\n   return found;\\n  }\\n  return -1;\\n\\n    }\\n};"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "This problem serves as a perfect chance to understand and implement one of the most efficient techniques, the Knuth-Morris-Pratt (KMP) algorithm. The problem pushes you to move beyond a naive approach, which could have a time complexity of `O(n*m)` in the worst-case scenario, and use a more efficient KMP algorithm that has a time complexity of `O(n+m)`. This highlights the importance of efficient algorithms in programming. As it\\'s a string-based problem, it gives you practice with string manipulation techniques, you\\'re also required to handle edge cases (like when the needle is an empty string), reinforcing the concept of comprehensive testing."
                    },
                    {
                        "username": "psionl0",
                        "content": "Don\\'t forget about the Rabin-Karp algorithm. This is just as efficient as KMP."
                    },
                    {
                        "username": "ankitparashar700",
                        "content": "Easiest and one liner code if you know string methods"
                    },
                    {
                        "username": "mzuathotmaildotcom",
                        "content": "Can we change example from \"sadbutsad\" to \"happyandhappy\" ?"
                    },
                    {
                        "username": "psionl0",
                        "content": "You can input any customized test case you want."
                    },
                    {
                        "username": "Malay107",
                        "content": "Once this problem was marked \"medium\"...now its easy."
                    },
                    {
                        "username": "psionl0",
                        "content": "Probably because you can use brute force or just use a library function to find the substring."
                    }
                ]
            },
            {
                "id": 2001913,
                "content": [
                    {
                        "username": "Squirrel848",
                        "content": "I somehow feel like this can linked with problem 14. If you decide to use String.StartsWith()"
                    },
                    {
                        "username": "shivx_444",
                        "content": "Here\\'s a concise algorithm to solve the \"Implement strStr()\" problem using a sliding window approach:\\n\\n1. Initialize haystackLen as the length of the haystack string and needleLen as the length of the needle string.\\n\\n2. Check for the special case where needleLen is 0. If true, return 0.\\n\\n3. Loop through the haystack string from index 0 to haystackLen - needleLen:\\n\\n- If the character at the current index i in the haystack matches the first character of the needle:\\n- Use the substring method to extract a substring of length needleLen starting from index i.\\n- Compare the extracted substring with the needle string using the equals method.\\n- If they match, return the index i.\\n4. If no match is found in the loop, return -1 to indicate that the needle is not found in the haystack.\\n\\n"
                    },
                    {
                        "username": "shivx_444",
                        "content": "Certainly! Here\\'s a concise algorithm for solving the string searching problem without using the built-in `indexOf` method:\\n\\n1. If the `needle` is an empty string, return 0, as an empty string matches at the beginning of any string.\\n\\n2. Iterate through the `haystack` using a loop with the index `i` ranging from 0 to `haystack.length() - needle.length()`.\\n\\n3. For each character in `haystack` at index `i` that matches the first character of `needle`:\\n   - Initialize a variable `j` to 0.\\n   - While `j` is less than `needle.length()` and characters at indices `i + j` in `haystack` and `j` in `needle` are equal:\\n     - Increment `j`.\\n   - If `j` becomes equal to `needle.length()`, a complete match is found.\\n     - Return the index `i`.\\n\\n4. If no match is found during the loop, return -1.\\n\\nThis algorithm efficiently searches for the first occurrence of `needle` within `haystack` without using the built-in `indexOf` method."
                    },
                    {
                        "username": "user2342ZB",
                        "content": "LOL I wrote this code and it got accepted because it passed the testcases XD This is cheating, leetcode should look into this.\\n\\n` class Solution:\\n\\n    def strStr(self, haystack: str, needle: str) -> int:\\n\\n        if needle not in haystack:\\n            return -1\\n\\n        return 0`"
                    },
                    {
                        "username": "gaurav_dadwal",
                        "content": "class Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        int ans=-1;\\n        for(int i=0;i<haystack.length();i++){\\n            if(haystack.substr(i,needle.size())==needle){\\n                ans=i;\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "sangram72",
                        "content": "Easy CPP Solution for beginners           \\n\\n\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n         size_t found = haystack.find(needle);\\n  if (found != string::npos){\\n   return found;\\n  }\\n  return -1;\\n\\n    }\\n};"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "This problem serves as a perfect chance to understand and implement one of the most efficient techniques, the Knuth-Morris-Pratt (KMP) algorithm. The problem pushes you to move beyond a naive approach, which could have a time complexity of `O(n*m)` in the worst-case scenario, and use a more efficient KMP algorithm that has a time complexity of `O(n+m)`. This highlights the importance of efficient algorithms in programming. As it\\'s a string-based problem, it gives you practice with string manipulation techniques, you\\'re also required to handle edge cases (like when the needle is an empty string), reinforcing the concept of comprehensive testing."
                    },
                    {
                        "username": "psionl0",
                        "content": "Don\\'t forget about the Rabin-Karp algorithm. This is just as efficient as KMP."
                    },
                    {
                        "username": "ankitparashar700",
                        "content": "Easiest and one liner code if you know string methods"
                    },
                    {
                        "username": "mzuathotmaildotcom",
                        "content": "Can we change example from \"sadbutsad\" to \"happyandhappy\" ?"
                    },
                    {
                        "username": "psionl0",
                        "content": "You can input any customized test case you want."
                    },
                    {
                        "username": "Malay107",
                        "content": "Once this problem was marked \"medium\"...now its easy."
                    },
                    {
                        "username": "psionl0",
                        "content": "Probably because you can use brute force or just use a library function to find the substring."
                    }
                ]
            },
            {
                "id": 2000794,
                "content": [
                    {
                        "username": "Squirrel848",
                        "content": "I somehow feel like this can linked with problem 14. If you decide to use String.StartsWith()"
                    },
                    {
                        "username": "shivx_444",
                        "content": "Here\\'s a concise algorithm to solve the \"Implement strStr()\" problem using a sliding window approach:\\n\\n1. Initialize haystackLen as the length of the haystack string and needleLen as the length of the needle string.\\n\\n2. Check for the special case where needleLen is 0. If true, return 0.\\n\\n3. Loop through the haystack string from index 0 to haystackLen - needleLen:\\n\\n- If the character at the current index i in the haystack matches the first character of the needle:\\n- Use the substring method to extract a substring of length needleLen starting from index i.\\n- Compare the extracted substring with the needle string using the equals method.\\n- If they match, return the index i.\\n4. If no match is found in the loop, return -1 to indicate that the needle is not found in the haystack.\\n\\n"
                    },
                    {
                        "username": "shivx_444",
                        "content": "Certainly! Here\\'s a concise algorithm for solving the string searching problem without using the built-in `indexOf` method:\\n\\n1. If the `needle` is an empty string, return 0, as an empty string matches at the beginning of any string.\\n\\n2. Iterate through the `haystack` using a loop with the index `i` ranging from 0 to `haystack.length() - needle.length()`.\\n\\n3. For each character in `haystack` at index `i` that matches the first character of `needle`:\\n   - Initialize a variable `j` to 0.\\n   - While `j` is less than `needle.length()` and characters at indices `i + j` in `haystack` and `j` in `needle` are equal:\\n     - Increment `j`.\\n   - If `j` becomes equal to `needle.length()`, a complete match is found.\\n     - Return the index `i`.\\n\\n4. If no match is found during the loop, return -1.\\n\\nThis algorithm efficiently searches for the first occurrence of `needle` within `haystack` without using the built-in `indexOf` method."
                    },
                    {
                        "username": "user2342ZB",
                        "content": "LOL I wrote this code and it got accepted because it passed the testcases XD This is cheating, leetcode should look into this.\\n\\n` class Solution:\\n\\n    def strStr(self, haystack: str, needle: str) -> int:\\n\\n        if needle not in haystack:\\n            return -1\\n\\n        return 0`"
                    },
                    {
                        "username": "gaurav_dadwal",
                        "content": "class Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        int ans=-1;\\n        for(int i=0;i<haystack.length();i++){\\n            if(haystack.substr(i,needle.size())==needle){\\n                ans=i;\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "sangram72",
                        "content": "Easy CPP Solution for beginners           \\n\\n\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n         size_t found = haystack.find(needle);\\n  if (found != string::npos){\\n   return found;\\n  }\\n  return -1;\\n\\n    }\\n};"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "This problem serves as a perfect chance to understand and implement one of the most efficient techniques, the Knuth-Morris-Pratt (KMP) algorithm. The problem pushes you to move beyond a naive approach, which could have a time complexity of `O(n*m)` in the worst-case scenario, and use a more efficient KMP algorithm that has a time complexity of `O(n+m)`. This highlights the importance of efficient algorithms in programming. As it\\'s a string-based problem, it gives you practice with string manipulation techniques, you\\'re also required to handle edge cases (like when the needle is an empty string), reinforcing the concept of comprehensive testing."
                    },
                    {
                        "username": "psionl0",
                        "content": "Don\\'t forget about the Rabin-Karp algorithm. This is just as efficient as KMP."
                    },
                    {
                        "username": "ankitparashar700",
                        "content": "Easiest and one liner code if you know string methods"
                    },
                    {
                        "username": "mzuathotmaildotcom",
                        "content": "Can we change example from \"sadbutsad\" to \"happyandhappy\" ?"
                    },
                    {
                        "username": "psionl0",
                        "content": "You can input any customized test case you want."
                    },
                    {
                        "username": "Malay107",
                        "content": "Once this problem was marked \"medium\"...now its easy."
                    },
                    {
                        "username": "psionl0",
                        "content": "Probably because you can use brute force or just use a library function to find the substring."
                    }
                ]
            },
            {
                "id": 1995771,
                "content": [
                    {
                        "username": "Squirrel848",
                        "content": "I somehow feel like this can linked with problem 14. If you decide to use String.StartsWith()"
                    },
                    {
                        "username": "shivx_444",
                        "content": "Here\\'s a concise algorithm to solve the \"Implement strStr()\" problem using a sliding window approach:\\n\\n1. Initialize haystackLen as the length of the haystack string and needleLen as the length of the needle string.\\n\\n2. Check for the special case where needleLen is 0. If true, return 0.\\n\\n3. Loop through the haystack string from index 0 to haystackLen - needleLen:\\n\\n- If the character at the current index i in the haystack matches the first character of the needle:\\n- Use the substring method to extract a substring of length needleLen starting from index i.\\n- Compare the extracted substring with the needle string using the equals method.\\n- If they match, return the index i.\\n4. If no match is found in the loop, return -1 to indicate that the needle is not found in the haystack.\\n\\n"
                    },
                    {
                        "username": "shivx_444",
                        "content": "Certainly! Here\\'s a concise algorithm for solving the string searching problem without using the built-in `indexOf` method:\\n\\n1. If the `needle` is an empty string, return 0, as an empty string matches at the beginning of any string.\\n\\n2. Iterate through the `haystack` using a loop with the index `i` ranging from 0 to `haystack.length() - needle.length()`.\\n\\n3. For each character in `haystack` at index `i` that matches the first character of `needle`:\\n   - Initialize a variable `j` to 0.\\n   - While `j` is less than `needle.length()` and characters at indices `i + j` in `haystack` and `j` in `needle` are equal:\\n     - Increment `j`.\\n   - If `j` becomes equal to `needle.length()`, a complete match is found.\\n     - Return the index `i`.\\n\\n4. If no match is found during the loop, return -1.\\n\\nThis algorithm efficiently searches for the first occurrence of `needle` within `haystack` without using the built-in `indexOf` method."
                    },
                    {
                        "username": "user2342ZB",
                        "content": "LOL I wrote this code and it got accepted because it passed the testcases XD This is cheating, leetcode should look into this.\\n\\n` class Solution:\\n\\n    def strStr(self, haystack: str, needle: str) -> int:\\n\\n        if needle not in haystack:\\n            return -1\\n\\n        return 0`"
                    },
                    {
                        "username": "gaurav_dadwal",
                        "content": "class Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        int ans=-1;\\n        for(int i=0;i<haystack.length();i++){\\n            if(haystack.substr(i,needle.size())==needle){\\n                ans=i;\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "sangram72",
                        "content": "Easy CPP Solution for beginners           \\n\\n\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n         size_t found = haystack.find(needle);\\n  if (found != string::npos){\\n   return found;\\n  }\\n  return -1;\\n\\n    }\\n};"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "This problem serves as a perfect chance to understand and implement one of the most efficient techniques, the Knuth-Morris-Pratt (KMP) algorithm. The problem pushes you to move beyond a naive approach, which could have a time complexity of `O(n*m)` in the worst-case scenario, and use a more efficient KMP algorithm that has a time complexity of `O(n+m)`. This highlights the importance of efficient algorithms in programming. As it\\'s a string-based problem, it gives you practice with string manipulation techniques, you\\'re also required to handle edge cases (like when the needle is an empty string), reinforcing the concept of comprehensive testing."
                    },
                    {
                        "username": "psionl0",
                        "content": "Don\\'t forget about the Rabin-Karp algorithm. This is just as efficient as KMP."
                    },
                    {
                        "username": "ankitparashar700",
                        "content": "Easiest and one liner code if you know string methods"
                    },
                    {
                        "username": "mzuathotmaildotcom",
                        "content": "Can we change example from \"sadbutsad\" to \"happyandhappy\" ?"
                    },
                    {
                        "username": "psionl0",
                        "content": "You can input any customized test case you want."
                    },
                    {
                        "username": "Malay107",
                        "content": "Once this problem was marked \"medium\"...now its easy."
                    },
                    {
                        "username": "psionl0",
                        "content": "Probably because you can use brute force or just use a library function to find the substring."
                    }
                ]
            },
            {
                "id": 1994905,
                "content": [
                    {
                        "username": "Squirrel848",
                        "content": "I somehow feel like this can linked with problem 14. If you decide to use String.StartsWith()"
                    },
                    {
                        "username": "shivx_444",
                        "content": "Here\\'s a concise algorithm to solve the \"Implement strStr()\" problem using a sliding window approach:\\n\\n1. Initialize haystackLen as the length of the haystack string and needleLen as the length of the needle string.\\n\\n2. Check for the special case where needleLen is 0. If true, return 0.\\n\\n3. Loop through the haystack string from index 0 to haystackLen - needleLen:\\n\\n- If the character at the current index i in the haystack matches the first character of the needle:\\n- Use the substring method to extract a substring of length needleLen starting from index i.\\n- Compare the extracted substring with the needle string using the equals method.\\n- If they match, return the index i.\\n4. If no match is found in the loop, return -1 to indicate that the needle is not found in the haystack.\\n\\n"
                    },
                    {
                        "username": "shivx_444",
                        "content": "Certainly! Here\\'s a concise algorithm for solving the string searching problem without using the built-in `indexOf` method:\\n\\n1. If the `needle` is an empty string, return 0, as an empty string matches at the beginning of any string.\\n\\n2. Iterate through the `haystack` using a loop with the index `i` ranging from 0 to `haystack.length() - needle.length()`.\\n\\n3. For each character in `haystack` at index `i` that matches the first character of `needle`:\\n   - Initialize a variable `j` to 0.\\n   - While `j` is less than `needle.length()` and characters at indices `i + j` in `haystack` and `j` in `needle` are equal:\\n     - Increment `j`.\\n   - If `j` becomes equal to `needle.length()`, a complete match is found.\\n     - Return the index `i`.\\n\\n4. If no match is found during the loop, return -1.\\n\\nThis algorithm efficiently searches for the first occurrence of `needle` within `haystack` without using the built-in `indexOf` method."
                    },
                    {
                        "username": "user2342ZB",
                        "content": "LOL I wrote this code and it got accepted because it passed the testcases XD This is cheating, leetcode should look into this.\\n\\n` class Solution:\\n\\n    def strStr(self, haystack: str, needle: str) -> int:\\n\\n        if needle not in haystack:\\n            return -1\\n\\n        return 0`"
                    },
                    {
                        "username": "gaurav_dadwal",
                        "content": "class Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        int ans=-1;\\n        for(int i=0;i<haystack.length();i++){\\n            if(haystack.substr(i,needle.size())==needle){\\n                ans=i;\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "sangram72",
                        "content": "Easy CPP Solution for beginners           \\n\\n\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n         size_t found = haystack.find(needle);\\n  if (found != string::npos){\\n   return found;\\n  }\\n  return -1;\\n\\n    }\\n};"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "This problem serves as a perfect chance to understand and implement one of the most efficient techniques, the Knuth-Morris-Pratt (KMP) algorithm. The problem pushes you to move beyond a naive approach, which could have a time complexity of `O(n*m)` in the worst-case scenario, and use a more efficient KMP algorithm that has a time complexity of `O(n+m)`. This highlights the importance of efficient algorithms in programming. As it\\'s a string-based problem, it gives you practice with string manipulation techniques, you\\'re also required to handle edge cases (like when the needle is an empty string), reinforcing the concept of comprehensive testing."
                    },
                    {
                        "username": "psionl0",
                        "content": "Don\\'t forget about the Rabin-Karp algorithm. This is just as efficient as KMP."
                    },
                    {
                        "username": "ankitparashar700",
                        "content": "Easiest and one liner code if you know string methods"
                    },
                    {
                        "username": "mzuathotmaildotcom",
                        "content": "Can we change example from \"sadbutsad\" to \"happyandhappy\" ?"
                    },
                    {
                        "username": "psionl0",
                        "content": "You can input any customized test case you want."
                    },
                    {
                        "username": "Malay107",
                        "content": "Once this problem was marked \"medium\"...now its easy."
                    },
                    {
                        "username": "psionl0",
                        "content": "Probably because you can use brute force or just use a library function to find the substring."
                    }
                ]
            },
            {
                "id": 1990691,
                "content": [
                    {
                        "username": "Squirrel848",
                        "content": "I somehow feel like this can linked with problem 14. If you decide to use String.StartsWith()"
                    },
                    {
                        "username": "shivx_444",
                        "content": "Here\\'s a concise algorithm to solve the \"Implement strStr()\" problem using a sliding window approach:\\n\\n1. Initialize haystackLen as the length of the haystack string and needleLen as the length of the needle string.\\n\\n2. Check for the special case where needleLen is 0. If true, return 0.\\n\\n3. Loop through the haystack string from index 0 to haystackLen - needleLen:\\n\\n- If the character at the current index i in the haystack matches the first character of the needle:\\n- Use the substring method to extract a substring of length needleLen starting from index i.\\n- Compare the extracted substring with the needle string using the equals method.\\n- If they match, return the index i.\\n4. If no match is found in the loop, return -1 to indicate that the needle is not found in the haystack.\\n\\n"
                    },
                    {
                        "username": "shivx_444",
                        "content": "Certainly! Here\\'s a concise algorithm for solving the string searching problem without using the built-in `indexOf` method:\\n\\n1. If the `needle` is an empty string, return 0, as an empty string matches at the beginning of any string.\\n\\n2. Iterate through the `haystack` using a loop with the index `i` ranging from 0 to `haystack.length() - needle.length()`.\\n\\n3. For each character in `haystack` at index `i` that matches the first character of `needle`:\\n   - Initialize a variable `j` to 0.\\n   - While `j` is less than `needle.length()` and characters at indices `i + j` in `haystack` and `j` in `needle` are equal:\\n     - Increment `j`.\\n   - If `j` becomes equal to `needle.length()`, a complete match is found.\\n     - Return the index `i`.\\n\\n4. If no match is found during the loop, return -1.\\n\\nThis algorithm efficiently searches for the first occurrence of `needle` within `haystack` without using the built-in `indexOf` method."
                    },
                    {
                        "username": "user2342ZB",
                        "content": "LOL I wrote this code and it got accepted because it passed the testcases XD This is cheating, leetcode should look into this.\\n\\n` class Solution:\\n\\n    def strStr(self, haystack: str, needle: str) -> int:\\n\\n        if needle not in haystack:\\n            return -1\\n\\n        return 0`"
                    },
                    {
                        "username": "gaurav_dadwal",
                        "content": "class Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        int ans=-1;\\n        for(int i=0;i<haystack.length();i++){\\n            if(haystack.substr(i,needle.size())==needle){\\n                ans=i;\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "sangram72",
                        "content": "Easy CPP Solution for beginners           \\n\\n\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n         size_t found = haystack.find(needle);\\n  if (found != string::npos){\\n   return found;\\n  }\\n  return -1;\\n\\n    }\\n};"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "This problem serves as a perfect chance to understand and implement one of the most efficient techniques, the Knuth-Morris-Pratt (KMP) algorithm. The problem pushes you to move beyond a naive approach, which could have a time complexity of `O(n*m)` in the worst-case scenario, and use a more efficient KMP algorithm that has a time complexity of `O(n+m)`. This highlights the importance of efficient algorithms in programming. As it\\'s a string-based problem, it gives you practice with string manipulation techniques, you\\'re also required to handle edge cases (like when the needle is an empty string), reinforcing the concept of comprehensive testing."
                    },
                    {
                        "username": "psionl0",
                        "content": "Don\\'t forget about the Rabin-Karp algorithm. This is just as efficient as KMP."
                    },
                    {
                        "username": "ankitparashar700",
                        "content": "Easiest and one liner code if you know string methods"
                    },
                    {
                        "username": "mzuathotmaildotcom",
                        "content": "Can we change example from \"sadbutsad\" to \"happyandhappy\" ?"
                    },
                    {
                        "username": "psionl0",
                        "content": "You can input any customized test case you want."
                    },
                    {
                        "username": "Malay107",
                        "content": "Once this problem was marked \"medium\"...now its easy."
                    },
                    {
                        "username": "psionl0",
                        "content": "Probably because you can use brute force or just use a library function to find the substring."
                    }
                ]
            },
            {
                "id": 1986252,
                "content": [
                    {
                        "username": "Squirrel848",
                        "content": "I somehow feel like this can linked with problem 14. If you decide to use String.StartsWith()"
                    },
                    {
                        "username": "shivx_444",
                        "content": "Here\\'s a concise algorithm to solve the \"Implement strStr()\" problem using a sliding window approach:\\n\\n1. Initialize haystackLen as the length of the haystack string and needleLen as the length of the needle string.\\n\\n2. Check for the special case where needleLen is 0. If true, return 0.\\n\\n3. Loop through the haystack string from index 0 to haystackLen - needleLen:\\n\\n- If the character at the current index i in the haystack matches the first character of the needle:\\n- Use the substring method to extract a substring of length needleLen starting from index i.\\n- Compare the extracted substring with the needle string using the equals method.\\n- If they match, return the index i.\\n4. If no match is found in the loop, return -1 to indicate that the needle is not found in the haystack.\\n\\n"
                    },
                    {
                        "username": "shivx_444",
                        "content": "Certainly! Here\\'s a concise algorithm for solving the string searching problem without using the built-in `indexOf` method:\\n\\n1. If the `needle` is an empty string, return 0, as an empty string matches at the beginning of any string.\\n\\n2. Iterate through the `haystack` using a loop with the index `i` ranging from 0 to `haystack.length() - needle.length()`.\\n\\n3. For each character in `haystack` at index `i` that matches the first character of `needle`:\\n   - Initialize a variable `j` to 0.\\n   - While `j` is less than `needle.length()` and characters at indices `i + j` in `haystack` and `j` in `needle` are equal:\\n     - Increment `j`.\\n   - If `j` becomes equal to `needle.length()`, a complete match is found.\\n     - Return the index `i`.\\n\\n4. If no match is found during the loop, return -1.\\n\\nThis algorithm efficiently searches for the first occurrence of `needle` within `haystack` without using the built-in `indexOf` method."
                    },
                    {
                        "username": "user2342ZB",
                        "content": "LOL I wrote this code and it got accepted because it passed the testcases XD This is cheating, leetcode should look into this.\\n\\n` class Solution:\\n\\n    def strStr(self, haystack: str, needle: str) -> int:\\n\\n        if needle not in haystack:\\n            return -1\\n\\n        return 0`"
                    },
                    {
                        "username": "gaurav_dadwal",
                        "content": "class Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        int ans=-1;\\n        for(int i=0;i<haystack.length();i++){\\n            if(haystack.substr(i,needle.size())==needle){\\n                ans=i;\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "sangram72",
                        "content": "Easy CPP Solution for beginners           \\n\\n\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n         size_t found = haystack.find(needle);\\n  if (found != string::npos){\\n   return found;\\n  }\\n  return -1;\\n\\n    }\\n};"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "This problem serves as a perfect chance to understand and implement one of the most efficient techniques, the Knuth-Morris-Pratt (KMP) algorithm. The problem pushes you to move beyond a naive approach, which could have a time complexity of `O(n*m)` in the worst-case scenario, and use a more efficient KMP algorithm that has a time complexity of `O(n+m)`. This highlights the importance of efficient algorithms in programming. As it\\'s a string-based problem, it gives you practice with string manipulation techniques, you\\'re also required to handle edge cases (like when the needle is an empty string), reinforcing the concept of comprehensive testing."
                    },
                    {
                        "username": "psionl0",
                        "content": "Don\\'t forget about the Rabin-Karp algorithm. This is just as efficient as KMP."
                    },
                    {
                        "username": "ankitparashar700",
                        "content": "Easiest and one liner code if you know string methods"
                    },
                    {
                        "username": "mzuathotmaildotcom",
                        "content": "Can we change example from \"sadbutsad\" to \"happyandhappy\" ?"
                    },
                    {
                        "username": "psionl0",
                        "content": "You can input any customized test case you want."
                    },
                    {
                        "username": "Malay107",
                        "content": "Once this problem was marked \"medium\"...now its easy."
                    },
                    {
                        "username": "psionl0",
                        "content": "Probably because you can use brute force or just use a library function to find the substring."
                    }
                ]
            },
            {
                "id": 1981863,
                "content": [
                    {
                        "username": "Squirrel848",
                        "content": "I somehow feel like this can linked with problem 14. If you decide to use String.StartsWith()"
                    },
                    {
                        "username": "shivx_444",
                        "content": "Here\\'s a concise algorithm to solve the \"Implement strStr()\" problem using a sliding window approach:\\n\\n1. Initialize haystackLen as the length of the haystack string and needleLen as the length of the needle string.\\n\\n2. Check for the special case where needleLen is 0. If true, return 0.\\n\\n3. Loop through the haystack string from index 0 to haystackLen - needleLen:\\n\\n- If the character at the current index i in the haystack matches the first character of the needle:\\n- Use the substring method to extract a substring of length needleLen starting from index i.\\n- Compare the extracted substring with the needle string using the equals method.\\n- If they match, return the index i.\\n4. If no match is found in the loop, return -1 to indicate that the needle is not found in the haystack.\\n\\n"
                    },
                    {
                        "username": "shivx_444",
                        "content": "Certainly! Here\\'s a concise algorithm for solving the string searching problem without using the built-in `indexOf` method:\\n\\n1. If the `needle` is an empty string, return 0, as an empty string matches at the beginning of any string.\\n\\n2. Iterate through the `haystack` using a loop with the index `i` ranging from 0 to `haystack.length() - needle.length()`.\\n\\n3. For each character in `haystack` at index `i` that matches the first character of `needle`:\\n   - Initialize a variable `j` to 0.\\n   - While `j` is less than `needle.length()` and characters at indices `i + j` in `haystack` and `j` in `needle` are equal:\\n     - Increment `j`.\\n   - If `j` becomes equal to `needle.length()`, a complete match is found.\\n     - Return the index `i`.\\n\\n4. If no match is found during the loop, return -1.\\n\\nThis algorithm efficiently searches for the first occurrence of `needle` within `haystack` without using the built-in `indexOf` method."
                    },
                    {
                        "username": "user2342ZB",
                        "content": "LOL I wrote this code and it got accepted because it passed the testcases XD This is cheating, leetcode should look into this.\\n\\n` class Solution:\\n\\n    def strStr(self, haystack: str, needle: str) -> int:\\n\\n        if needle not in haystack:\\n            return -1\\n\\n        return 0`"
                    },
                    {
                        "username": "gaurav_dadwal",
                        "content": "class Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        int ans=-1;\\n        for(int i=0;i<haystack.length();i++){\\n            if(haystack.substr(i,needle.size())==needle){\\n                ans=i;\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "sangram72",
                        "content": "Easy CPP Solution for beginners           \\n\\n\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n         size_t found = haystack.find(needle);\\n  if (found != string::npos){\\n   return found;\\n  }\\n  return -1;\\n\\n    }\\n};"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "This problem serves as a perfect chance to understand and implement one of the most efficient techniques, the Knuth-Morris-Pratt (KMP) algorithm. The problem pushes you to move beyond a naive approach, which could have a time complexity of `O(n*m)` in the worst-case scenario, and use a more efficient KMP algorithm that has a time complexity of `O(n+m)`. This highlights the importance of efficient algorithms in programming. As it\\'s a string-based problem, it gives you practice with string manipulation techniques, you\\'re also required to handle edge cases (like when the needle is an empty string), reinforcing the concept of comprehensive testing."
                    },
                    {
                        "username": "psionl0",
                        "content": "Don\\'t forget about the Rabin-Karp algorithm. This is just as efficient as KMP."
                    },
                    {
                        "username": "ankitparashar700",
                        "content": "Easiest and one liner code if you know string methods"
                    },
                    {
                        "username": "mzuathotmaildotcom",
                        "content": "Can we change example from \"sadbutsad\" to \"happyandhappy\" ?"
                    },
                    {
                        "username": "psionl0",
                        "content": "You can input any customized test case you want."
                    },
                    {
                        "username": "Malay107",
                        "content": "Once this problem was marked \"medium\"...now its easy."
                    },
                    {
                        "username": "psionl0",
                        "content": "Probably because you can use brute force or just use a library function to find the substring."
                    }
                ]
            },
            {
                "id": 1980956,
                "content": [
                    {
                        "username": "asemre99",
                        "content": "Brute force approach accepted so  tagging easy for this problem seems accurate"
                    },
                    {
                        "username": "rohan5",
                        "content": "Not Easy at all, even the O(n2) method is a Medium level problem."
                    },
                    {
                        "username": "Charmi_Kalyani",
                        "content": "if the needle is a substring of haystack then the it will return the index of the first occurence or simply 0 for substring and -1 for not a substring\\n"
                    },
                    {
                        "username": "Prince--",
                        "content": "very basic solution!!"
                    },
                    {
                        "username": "jincanchamber",
                        "content": "woahhh time complexity of O(n) when you use strncmp() in C !!!!"
                    },
                    {
                        "username": "user1825F",
                        "content": "why can\\'t we use directly\\nreturn haystack.index(needle)\\nwhy it is showing error while in my ide it is ruuning perfectly"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Think simple guy: class Solution {\\n    public int strStr(String haystack, String needle) {\\n        return haystack.indexOf(needle);\\n    }\\n}"
                    },
                    {
                        "username": "CT-7567",
                        "content": "I think this is cheating, you need to develop an algorithm that finds the index."
                    },
                    {
                        "username": "im-naime",
                        "content": "It\\'s an easy problem but so many corner case have to be considered, which makes it medium!"
                    },
                    {
                        "username": "WalterDark",
                        "content": "Its not easy, but I am  working on it"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "class Solution {\\n    public int strStr(String haystack, String needle) {\\n        int p1 = 0;\\n        int p2 = 0;\\n        int n1 = haystack.length();\\n        int n2 = needle.length();\\n        \\n        while (p1 < n1 && p2 < n2) {\\n            char ch1 = haystack.charAt(p1);\\n            char ch2 = needle.charAt(p2);            \\n            if (ch1 == ch2) {\\n                p1++;\\n                p2++;\\n            }\\n              else {\\n                p1 = p1 - p2 + 1;  // Reset p1 to the next character in haystack\\n                p2 = 0;\\n            }\\n        }\\n\\n        if (p2 == n2) {\\n            return p1 - p2;  // Return the index of the first occurrence of needle\\n        } else {\\n            return -1;  // Needle not found\\n        }\\n    }\\n}\\n i saw this solution but did not understand why p1 = p1-p2 + 1;instead of p1 = p1 + 1;"
                    }
                ]
            },
            {
                "id": 1977619,
                "content": [
                    {
                        "username": "asemre99",
                        "content": "Brute force approach accepted so  tagging easy for this problem seems accurate"
                    },
                    {
                        "username": "rohan5",
                        "content": "Not Easy at all, even the O(n2) method is a Medium level problem."
                    },
                    {
                        "username": "Charmi_Kalyani",
                        "content": "if the needle is a substring of haystack then the it will return the index of the first occurence or simply 0 for substring and -1 for not a substring\\n"
                    },
                    {
                        "username": "Prince--",
                        "content": "very basic solution!!"
                    },
                    {
                        "username": "jincanchamber",
                        "content": "woahhh time complexity of O(n) when you use strncmp() in C !!!!"
                    },
                    {
                        "username": "user1825F",
                        "content": "why can\\'t we use directly\\nreturn haystack.index(needle)\\nwhy it is showing error while in my ide it is ruuning perfectly"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Think simple guy: class Solution {\\n    public int strStr(String haystack, String needle) {\\n        return haystack.indexOf(needle);\\n    }\\n}"
                    },
                    {
                        "username": "CT-7567",
                        "content": "I think this is cheating, you need to develop an algorithm that finds the index."
                    },
                    {
                        "username": "im-naime",
                        "content": "It\\'s an easy problem but so many corner case have to be considered, which makes it medium!"
                    },
                    {
                        "username": "WalterDark",
                        "content": "Its not easy, but I am  working on it"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "class Solution {\\n    public int strStr(String haystack, String needle) {\\n        int p1 = 0;\\n        int p2 = 0;\\n        int n1 = haystack.length();\\n        int n2 = needle.length();\\n        \\n        while (p1 < n1 && p2 < n2) {\\n            char ch1 = haystack.charAt(p1);\\n            char ch2 = needle.charAt(p2);            \\n            if (ch1 == ch2) {\\n                p1++;\\n                p2++;\\n            }\\n              else {\\n                p1 = p1 - p2 + 1;  // Reset p1 to the next character in haystack\\n                p2 = 0;\\n            }\\n        }\\n\\n        if (p2 == n2) {\\n            return p1 - p2;  // Return the index of the first occurrence of needle\\n        } else {\\n            return -1;  // Needle not found\\n        }\\n    }\\n}\\n i saw this solution but did not understand why p1 = p1-p2 + 1;instead of p1 = p1 + 1;"
                    }
                ]
            },
            {
                "id": 1962916,
                "content": [
                    {
                        "username": "asemre99",
                        "content": "Brute force approach accepted so  tagging easy for this problem seems accurate"
                    },
                    {
                        "username": "rohan5",
                        "content": "Not Easy at all, even the O(n2) method is a Medium level problem."
                    },
                    {
                        "username": "Charmi_Kalyani",
                        "content": "if the needle is a substring of haystack then the it will return the index of the first occurence or simply 0 for substring and -1 for not a substring\\n"
                    },
                    {
                        "username": "Prince--",
                        "content": "very basic solution!!"
                    },
                    {
                        "username": "jincanchamber",
                        "content": "woahhh time complexity of O(n) when you use strncmp() in C !!!!"
                    },
                    {
                        "username": "user1825F",
                        "content": "why can\\'t we use directly\\nreturn haystack.index(needle)\\nwhy it is showing error while in my ide it is ruuning perfectly"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Think simple guy: class Solution {\\n    public int strStr(String haystack, String needle) {\\n        return haystack.indexOf(needle);\\n    }\\n}"
                    },
                    {
                        "username": "CT-7567",
                        "content": "I think this is cheating, you need to develop an algorithm that finds the index."
                    },
                    {
                        "username": "im-naime",
                        "content": "It\\'s an easy problem but so many corner case have to be considered, which makes it medium!"
                    },
                    {
                        "username": "WalterDark",
                        "content": "Its not easy, but I am  working on it"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "class Solution {\\n    public int strStr(String haystack, String needle) {\\n        int p1 = 0;\\n        int p2 = 0;\\n        int n1 = haystack.length();\\n        int n2 = needle.length();\\n        \\n        while (p1 < n1 && p2 < n2) {\\n            char ch1 = haystack.charAt(p1);\\n            char ch2 = needle.charAt(p2);            \\n            if (ch1 == ch2) {\\n                p1++;\\n                p2++;\\n            }\\n              else {\\n                p1 = p1 - p2 + 1;  // Reset p1 to the next character in haystack\\n                p2 = 0;\\n            }\\n        }\\n\\n        if (p2 == n2) {\\n            return p1 - p2;  // Return the index of the first occurrence of needle\\n        } else {\\n            return -1;  // Needle not found\\n        }\\n    }\\n}\\n i saw this solution but did not understand why p1 = p1-p2 + 1;instead of p1 = p1 + 1;"
                    }
                ]
            },
            {
                "id": 1948061,
                "content": [
                    {
                        "username": "asemre99",
                        "content": "Brute force approach accepted so  tagging easy for this problem seems accurate"
                    },
                    {
                        "username": "rohan5",
                        "content": "Not Easy at all, even the O(n2) method is a Medium level problem."
                    },
                    {
                        "username": "Charmi_Kalyani",
                        "content": "if the needle is a substring of haystack then the it will return the index of the first occurence or simply 0 for substring and -1 for not a substring\\n"
                    },
                    {
                        "username": "Prince--",
                        "content": "very basic solution!!"
                    },
                    {
                        "username": "jincanchamber",
                        "content": "woahhh time complexity of O(n) when you use strncmp() in C !!!!"
                    },
                    {
                        "username": "user1825F",
                        "content": "why can\\'t we use directly\\nreturn haystack.index(needle)\\nwhy it is showing error while in my ide it is ruuning perfectly"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Think simple guy: class Solution {\\n    public int strStr(String haystack, String needle) {\\n        return haystack.indexOf(needle);\\n    }\\n}"
                    },
                    {
                        "username": "CT-7567",
                        "content": "I think this is cheating, you need to develop an algorithm that finds the index."
                    },
                    {
                        "username": "im-naime",
                        "content": "It\\'s an easy problem but so many corner case have to be considered, which makes it medium!"
                    },
                    {
                        "username": "WalterDark",
                        "content": "Its not easy, but I am  working on it"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "class Solution {\\n    public int strStr(String haystack, String needle) {\\n        int p1 = 0;\\n        int p2 = 0;\\n        int n1 = haystack.length();\\n        int n2 = needle.length();\\n        \\n        while (p1 < n1 && p2 < n2) {\\n            char ch1 = haystack.charAt(p1);\\n            char ch2 = needle.charAt(p2);            \\n            if (ch1 == ch2) {\\n                p1++;\\n                p2++;\\n            }\\n              else {\\n                p1 = p1 - p2 + 1;  // Reset p1 to the next character in haystack\\n                p2 = 0;\\n            }\\n        }\\n\\n        if (p2 == n2) {\\n            return p1 - p2;  // Return the index of the first occurrence of needle\\n        } else {\\n            return -1;  // Needle not found\\n        }\\n    }\\n}\\n i saw this solution but did not understand why p1 = p1-p2 + 1;instead of p1 = p1 + 1;"
                    }
                ]
            },
            {
                "id": 1946854,
                "content": [
                    {
                        "username": "asemre99",
                        "content": "Brute force approach accepted so  tagging easy for this problem seems accurate"
                    },
                    {
                        "username": "rohan5",
                        "content": "Not Easy at all, even the O(n2) method is a Medium level problem."
                    },
                    {
                        "username": "Charmi_Kalyani",
                        "content": "if the needle is a substring of haystack then the it will return the index of the first occurence or simply 0 for substring and -1 for not a substring\\n"
                    },
                    {
                        "username": "Prince--",
                        "content": "very basic solution!!"
                    },
                    {
                        "username": "jincanchamber",
                        "content": "woahhh time complexity of O(n) when you use strncmp() in C !!!!"
                    },
                    {
                        "username": "user1825F",
                        "content": "why can\\'t we use directly\\nreturn haystack.index(needle)\\nwhy it is showing error while in my ide it is ruuning perfectly"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Think simple guy: class Solution {\\n    public int strStr(String haystack, String needle) {\\n        return haystack.indexOf(needle);\\n    }\\n}"
                    },
                    {
                        "username": "CT-7567",
                        "content": "I think this is cheating, you need to develop an algorithm that finds the index."
                    },
                    {
                        "username": "im-naime",
                        "content": "It\\'s an easy problem but so many corner case have to be considered, which makes it medium!"
                    },
                    {
                        "username": "WalterDark",
                        "content": "Its not easy, but I am  working on it"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "class Solution {\\n    public int strStr(String haystack, String needle) {\\n        int p1 = 0;\\n        int p2 = 0;\\n        int n1 = haystack.length();\\n        int n2 = needle.length();\\n        \\n        while (p1 < n1 && p2 < n2) {\\n            char ch1 = haystack.charAt(p1);\\n            char ch2 = needle.charAt(p2);            \\n            if (ch1 == ch2) {\\n                p1++;\\n                p2++;\\n            }\\n              else {\\n                p1 = p1 - p2 + 1;  // Reset p1 to the next character in haystack\\n                p2 = 0;\\n            }\\n        }\\n\\n        if (p2 == n2) {\\n            return p1 - p2;  // Return the index of the first occurrence of needle\\n        } else {\\n            return -1;  // Needle not found\\n        }\\n    }\\n}\\n i saw this solution but did not understand why p1 = p1-p2 + 1;instead of p1 = p1 + 1;"
                    }
                ]
            },
            {
                "id": 1943923,
                "content": [
                    {
                        "username": "asemre99",
                        "content": "Brute force approach accepted so  tagging easy for this problem seems accurate"
                    },
                    {
                        "username": "rohan5",
                        "content": "Not Easy at all, even the O(n2) method is a Medium level problem."
                    },
                    {
                        "username": "Charmi_Kalyani",
                        "content": "if the needle is a substring of haystack then the it will return the index of the first occurence or simply 0 for substring and -1 for not a substring\\n"
                    },
                    {
                        "username": "Prince--",
                        "content": "very basic solution!!"
                    },
                    {
                        "username": "jincanchamber",
                        "content": "woahhh time complexity of O(n) when you use strncmp() in C !!!!"
                    },
                    {
                        "username": "user1825F",
                        "content": "why can\\'t we use directly\\nreturn haystack.index(needle)\\nwhy it is showing error while in my ide it is ruuning perfectly"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Think simple guy: class Solution {\\n    public int strStr(String haystack, String needle) {\\n        return haystack.indexOf(needle);\\n    }\\n}"
                    },
                    {
                        "username": "CT-7567",
                        "content": "I think this is cheating, you need to develop an algorithm that finds the index."
                    },
                    {
                        "username": "im-naime",
                        "content": "It\\'s an easy problem but so many corner case have to be considered, which makes it medium!"
                    },
                    {
                        "username": "WalterDark",
                        "content": "Its not easy, but I am  working on it"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "class Solution {\\n    public int strStr(String haystack, String needle) {\\n        int p1 = 0;\\n        int p2 = 0;\\n        int n1 = haystack.length();\\n        int n2 = needle.length();\\n        \\n        while (p1 < n1 && p2 < n2) {\\n            char ch1 = haystack.charAt(p1);\\n            char ch2 = needle.charAt(p2);            \\n            if (ch1 == ch2) {\\n                p1++;\\n                p2++;\\n            }\\n              else {\\n                p1 = p1 - p2 + 1;  // Reset p1 to the next character in haystack\\n                p2 = 0;\\n            }\\n        }\\n\\n        if (p2 == n2) {\\n            return p1 - p2;  // Return the index of the first occurrence of needle\\n        } else {\\n            return -1;  // Needle not found\\n        }\\n    }\\n}\\n i saw this solution but did not understand why p1 = p1-p2 + 1;instead of p1 = p1 + 1;"
                    }
                ]
            },
            {
                "id": 1940070,
                "content": [
                    {
                        "username": "asemre99",
                        "content": "Brute force approach accepted so  tagging easy for this problem seems accurate"
                    },
                    {
                        "username": "rohan5",
                        "content": "Not Easy at all, even the O(n2) method is a Medium level problem."
                    },
                    {
                        "username": "Charmi_Kalyani",
                        "content": "if the needle is a substring of haystack then the it will return the index of the first occurence or simply 0 for substring and -1 for not a substring\\n"
                    },
                    {
                        "username": "Prince--",
                        "content": "very basic solution!!"
                    },
                    {
                        "username": "jincanchamber",
                        "content": "woahhh time complexity of O(n) when you use strncmp() in C !!!!"
                    },
                    {
                        "username": "user1825F",
                        "content": "why can\\'t we use directly\\nreturn haystack.index(needle)\\nwhy it is showing error while in my ide it is ruuning perfectly"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Think simple guy: class Solution {\\n    public int strStr(String haystack, String needle) {\\n        return haystack.indexOf(needle);\\n    }\\n}"
                    },
                    {
                        "username": "CT-7567",
                        "content": "I think this is cheating, you need to develop an algorithm that finds the index."
                    },
                    {
                        "username": "im-naime",
                        "content": "It\\'s an easy problem but so many corner case have to be considered, which makes it medium!"
                    },
                    {
                        "username": "WalterDark",
                        "content": "Its not easy, but I am  working on it"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "class Solution {\\n    public int strStr(String haystack, String needle) {\\n        int p1 = 0;\\n        int p2 = 0;\\n        int n1 = haystack.length();\\n        int n2 = needle.length();\\n        \\n        while (p1 < n1 && p2 < n2) {\\n            char ch1 = haystack.charAt(p1);\\n            char ch2 = needle.charAt(p2);            \\n            if (ch1 == ch2) {\\n                p1++;\\n                p2++;\\n            }\\n              else {\\n                p1 = p1 - p2 + 1;  // Reset p1 to the next character in haystack\\n                p2 = 0;\\n            }\\n        }\\n\\n        if (p2 == n2) {\\n            return p1 - p2;  // Return the index of the first occurrence of needle\\n        } else {\\n            return -1;  // Needle not found\\n        }\\n    }\\n}\\n i saw this solution but did not understand why p1 = p1-p2 + 1;instead of p1 = p1 + 1;"
                    }
                ]
            },
            {
                "id": 1931437,
                "content": [
                    {
                        "username": "asemre99",
                        "content": "Brute force approach accepted so  tagging easy for this problem seems accurate"
                    },
                    {
                        "username": "rohan5",
                        "content": "Not Easy at all, even the O(n2) method is a Medium level problem."
                    },
                    {
                        "username": "Charmi_Kalyani",
                        "content": "if the needle is a substring of haystack then the it will return the index of the first occurence or simply 0 for substring and -1 for not a substring\\n"
                    },
                    {
                        "username": "Prince--",
                        "content": "very basic solution!!"
                    },
                    {
                        "username": "jincanchamber",
                        "content": "woahhh time complexity of O(n) when you use strncmp() in C !!!!"
                    },
                    {
                        "username": "user1825F",
                        "content": "why can\\'t we use directly\\nreturn haystack.index(needle)\\nwhy it is showing error while in my ide it is ruuning perfectly"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Think simple guy: class Solution {\\n    public int strStr(String haystack, String needle) {\\n        return haystack.indexOf(needle);\\n    }\\n}"
                    },
                    {
                        "username": "CT-7567",
                        "content": "I think this is cheating, you need to develop an algorithm that finds the index."
                    },
                    {
                        "username": "im-naime",
                        "content": "It\\'s an easy problem but so many corner case have to be considered, which makes it medium!"
                    },
                    {
                        "username": "WalterDark",
                        "content": "Its not easy, but I am  working on it"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "class Solution {\\n    public int strStr(String haystack, String needle) {\\n        int p1 = 0;\\n        int p2 = 0;\\n        int n1 = haystack.length();\\n        int n2 = needle.length();\\n        \\n        while (p1 < n1 && p2 < n2) {\\n            char ch1 = haystack.charAt(p1);\\n            char ch2 = needle.charAt(p2);            \\n            if (ch1 == ch2) {\\n                p1++;\\n                p2++;\\n            }\\n              else {\\n                p1 = p1 - p2 + 1;  // Reset p1 to the next character in haystack\\n                p2 = 0;\\n            }\\n        }\\n\\n        if (p2 == n2) {\\n            return p1 - p2;  // Return the index of the first occurrence of needle\\n        } else {\\n            return -1;  // Needle not found\\n        }\\n    }\\n}\\n i saw this solution but did not understand why p1 = p1-p2 + 1;instead of p1 = p1 + 1;"
                    }
                ]
            },
            {
                "id": 1929400,
                "content": [
                    {
                        "username": "asemre99",
                        "content": "Brute force approach accepted so  tagging easy for this problem seems accurate"
                    },
                    {
                        "username": "rohan5",
                        "content": "Not Easy at all, even the O(n2) method is a Medium level problem."
                    },
                    {
                        "username": "Charmi_Kalyani",
                        "content": "if the needle is a substring of haystack then the it will return the index of the first occurence or simply 0 for substring and -1 for not a substring\\n"
                    },
                    {
                        "username": "Prince--",
                        "content": "very basic solution!!"
                    },
                    {
                        "username": "jincanchamber",
                        "content": "woahhh time complexity of O(n) when you use strncmp() in C !!!!"
                    },
                    {
                        "username": "user1825F",
                        "content": "why can\\'t we use directly\\nreturn haystack.index(needle)\\nwhy it is showing error while in my ide it is ruuning perfectly"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Think simple guy: class Solution {\\n    public int strStr(String haystack, String needle) {\\n        return haystack.indexOf(needle);\\n    }\\n}"
                    },
                    {
                        "username": "CT-7567",
                        "content": "I think this is cheating, you need to develop an algorithm that finds the index."
                    },
                    {
                        "username": "im-naime",
                        "content": "It\\'s an easy problem but so many corner case have to be considered, which makes it medium!"
                    },
                    {
                        "username": "WalterDark",
                        "content": "Its not easy, but I am  working on it"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "class Solution {\\n    public int strStr(String haystack, String needle) {\\n        int p1 = 0;\\n        int p2 = 0;\\n        int n1 = haystack.length();\\n        int n2 = needle.length();\\n        \\n        while (p1 < n1 && p2 < n2) {\\n            char ch1 = haystack.charAt(p1);\\n            char ch2 = needle.charAt(p2);            \\n            if (ch1 == ch2) {\\n                p1++;\\n                p2++;\\n            }\\n              else {\\n                p1 = p1 - p2 + 1;  // Reset p1 to the next character in haystack\\n                p2 = 0;\\n            }\\n        }\\n\\n        if (p2 == n2) {\\n            return p1 - p2;  // Return the index of the first occurrence of needle\\n        } else {\\n            return -1;  // Needle not found\\n        }\\n    }\\n}\\n i saw this solution but did not understand why p1 = p1-p2 + 1;instead of p1 = p1 + 1;"
                    }
                ]
            },
            {
                "id": 1909827,
                "content": [
                    {
                        "username": "asemre99",
                        "content": "Brute force approach accepted so  tagging easy for this problem seems accurate"
                    },
                    {
                        "username": "rohan5",
                        "content": "Not Easy at all, even the O(n2) method is a Medium level problem."
                    },
                    {
                        "username": "Charmi_Kalyani",
                        "content": "if the needle is a substring of haystack then the it will return the index of the first occurence or simply 0 for substring and -1 for not a substring\\n"
                    },
                    {
                        "username": "Prince--",
                        "content": "very basic solution!!"
                    },
                    {
                        "username": "jincanchamber",
                        "content": "woahhh time complexity of O(n) when you use strncmp() in C !!!!"
                    },
                    {
                        "username": "user1825F",
                        "content": "why can\\'t we use directly\\nreturn haystack.index(needle)\\nwhy it is showing error while in my ide it is ruuning perfectly"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Think simple guy: class Solution {\\n    public int strStr(String haystack, String needle) {\\n        return haystack.indexOf(needle);\\n    }\\n}"
                    },
                    {
                        "username": "CT-7567",
                        "content": "I think this is cheating, you need to develop an algorithm that finds the index."
                    },
                    {
                        "username": "im-naime",
                        "content": "It\\'s an easy problem but so many corner case have to be considered, which makes it medium!"
                    },
                    {
                        "username": "WalterDark",
                        "content": "Its not easy, but I am  working on it"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "class Solution {\\n    public int strStr(String haystack, String needle) {\\n        int p1 = 0;\\n        int p2 = 0;\\n        int n1 = haystack.length();\\n        int n2 = needle.length();\\n        \\n        while (p1 < n1 && p2 < n2) {\\n            char ch1 = haystack.charAt(p1);\\n            char ch2 = needle.charAt(p2);            \\n            if (ch1 == ch2) {\\n                p1++;\\n                p2++;\\n            }\\n              else {\\n                p1 = p1 - p2 + 1;  // Reset p1 to the next character in haystack\\n                p2 = 0;\\n            }\\n        }\\n\\n        if (p2 == n2) {\\n            return p1 - p2;  // Return the index of the first occurrence of needle\\n        } else {\\n            return -1;  // Needle not found\\n        }\\n    }\\n}\\n i saw this solution but did not understand why p1 = p1-p2 + 1;instead of p1 = p1 + 1;"
                    }
                ]
            },
            {
                "id": 1907151,
                "content": [
                    {
                        "username": "Alog",
                        "content": "try  `binary search` with `while loop`"
                    },
                    {
                        "username": "Dhanya_V",
                        "content": "how to approach this one thought it was easy but isn\\'t "
                    },
                    {
                        "username": "CT-7567",
                        "content": "[@ylee078](/ylee078) \\n\\nI fallowed similar steps but I checked the last char of the needle when there is match (used &&) this way you can reduce couple of unnecessary checking. "
                    },
                    {
                        "username": "ylee078",
                        "content": "take the first alphabet of needles and search through the haystack. Once you find the alphabet that matches, check if the needle is in the haystack. If not continue searching for the next matching alphabet. if it goes through the loop without finding the needle, just return -1"
                    },
                    {
                        "username": "ylee078",
                        "content": "Is it cheating to use the find() function?"
                    },
                    {
                        "username": "nkt123",
                        "content": "CheckOut My Code----\\nimport java.io.*;\\nimport java.util.*;\\nimport java.math.*;\\n\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n\\n    //HashMap<String,Integer> hm=new HashMap<String,Integer>();\\n\\n      for (int i = 0; i < haystack.length(); i++) {\\n\\n            String ss=Character.toString(haystack.charAt(i));\\n            \\n             if(ss.equals(needle)){\\n                 return i;\\n\\n               }\\n\\n            for (int j = i+1 ; j < haystack.length(); j++) {\\n\\n                ss=ss+Character.toString(haystack.charAt(j));\\n\\n               // System.out.println(ss);\\n\\n               \\n             if(ss.equals(needle)){\\n                 return i;\\n                 }\\n\\n           }\\n        }\\n        return -1;  \\n  }\\n}"
                    },
                    {
                        "username": "sourjadhr3",
                        "content": "class Solution {\\n    public int strStr(String haystack, String needle) {\\n        int i,j,g=0,f=1;\\n        int n=needle.length();\\n        for(i=0;i<haystack.length();i++)\\n        {\\n            if((i+n)>=haystack.length())\\n                {\\n                    String  s=haystack.substring(i);\\n                     if(s.equals(needle))\\n                     {\\n                         g=1;\\n                         break;\\n                     }\\n                     else\\n                        break;\\n                }\\n                else{\\n                String s=haystack.substring(i,i+n);\\n               \\n                    if(s.equals(needle))\\n                    {\\n                        g=1;\\n                        break;\\n                     }\\n                }\\n    \\n        }\\n    if( g==1)\\n            return i;\\n        else \\n            return -1;\\n    }\\n}\\n\\n\\nbeats 100 % very easy to understand"
                    },
                    {
                        "username": "ankush920",
                        "content": "100% fast C++ solution with easy code syntax:-\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nApproach\\nComplexity\\nTime complexity:\\nSpace complexity:\\nCode\\nclass Solution {\\npublic:\\n\\n    bool ispossible( string s1, string s2,int index)\\n    {\\n        return ( s2==s1.substr(index, s2.size()) );\\n    }\\n\\n\\n      bool  check ( string s1 , string s2 )\\n      {\\n           unordered_map<int ,int> store;\\n\\n           for( auto it: s1)\\n           {\\n                store[it]++;\\n\\n           }\\n\\n\\n           for( auto  it :s2)\\n           {\\n               store[it]--;\\n               if( store[it]<0)\\n               {\\n                    return false;\\n               }\\n           }\\n\\n               return true ;\\n           \\n      }\\n    int strStr(string s1, string s2) {\\n        \\n        if( s1.size()<s2.size() || !check( s1, s2))\\n        {\\n             return -1;\\n        }\\n       \\n       int j =0;\\n        for( int i =0 ; i<=s1.size()-s2.size();i++)\\n        { \\n            \\n           if( s1[i]==s2[0]) \\n                { \\n\\n                    if( ispossible(s1,s2, i))\\n                    {\\n                         return i;\\n                    }\\n                }\\n        }\\n\\n        return -1;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "lorulalit407",
                        "content": "HEY! Can someone explain to me how i -= j is working, because to me it is causing infinite loop as we will encounter same mismatch again and again if we set i to the first matched value.\\n\\nclass Solution(object):\\n    def strStr(self, x, target):\\n        if not target:\\n            return 0\\n        \\n        i, j = 0, 0\\n\\n        while i < len(x):\\n            if x[i] == target[j]:\\n                j += 1\\n                if j == len(target):\\n                    return i - j + 1\\n            else:\\n                i -= j\\n                j = 0\\n            i += 1\\n        return -1"
                    },
                    {
                        "username": "karshten",
                        "content": "why leetcode return wrong output: \\nhaystack = \"leetcode\", needle = \"leeto\"\\nvsc (node file.js) => -1; \\nleetcode => 7;\\n\\nhaystack = \"aaaaa\", needle = \"bba\"\\nvsc (node file.js) => -1; \\nleetcode => 0;"
                    },
                    {
                        "username": "AnnOl1",
                        "content": "Hello everyone, my solve is working, but leetcode doesn\\'t agree it. I don\\'t understand, why?\\ndef test(haystack, needle):\\n    nums = haystack.find(needle[0]) \\n    if nums == -1:\\n        return -1\\n    elif haystack[nums:nums+len(needle)] == needle:\\n        return nums"
                    },
                    {
                        "username": "naga_vara_pradeep",
                        "content": "Use Sliding Window technique to solve the problem."
                    }
                ]
            },
            {
                "id": 1905259,
                "content": [
                    {
                        "username": "Alog",
                        "content": "try  `binary search` with `while loop`"
                    },
                    {
                        "username": "Dhanya_V",
                        "content": "how to approach this one thought it was easy but isn\\'t "
                    },
                    {
                        "username": "CT-7567",
                        "content": "[@ylee078](/ylee078) \\n\\nI fallowed similar steps but I checked the last char of the needle when there is match (used &&) this way you can reduce couple of unnecessary checking. "
                    },
                    {
                        "username": "ylee078",
                        "content": "take the first alphabet of needles and search through the haystack. Once you find the alphabet that matches, check if the needle is in the haystack. If not continue searching for the next matching alphabet. if it goes through the loop without finding the needle, just return -1"
                    },
                    {
                        "username": "ylee078",
                        "content": "Is it cheating to use the find() function?"
                    },
                    {
                        "username": "nkt123",
                        "content": "CheckOut My Code----\\nimport java.io.*;\\nimport java.util.*;\\nimport java.math.*;\\n\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n\\n    //HashMap<String,Integer> hm=new HashMap<String,Integer>();\\n\\n      for (int i = 0; i < haystack.length(); i++) {\\n\\n            String ss=Character.toString(haystack.charAt(i));\\n            \\n             if(ss.equals(needle)){\\n                 return i;\\n\\n               }\\n\\n            for (int j = i+1 ; j < haystack.length(); j++) {\\n\\n                ss=ss+Character.toString(haystack.charAt(j));\\n\\n               // System.out.println(ss);\\n\\n               \\n             if(ss.equals(needle)){\\n                 return i;\\n                 }\\n\\n           }\\n        }\\n        return -1;  \\n  }\\n}"
                    },
                    {
                        "username": "sourjadhr3",
                        "content": "class Solution {\\n    public int strStr(String haystack, String needle) {\\n        int i,j,g=0,f=1;\\n        int n=needle.length();\\n        for(i=0;i<haystack.length();i++)\\n        {\\n            if((i+n)>=haystack.length())\\n                {\\n                    String  s=haystack.substring(i);\\n                     if(s.equals(needle))\\n                     {\\n                         g=1;\\n                         break;\\n                     }\\n                     else\\n                        break;\\n                }\\n                else{\\n                String s=haystack.substring(i,i+n);\\n               \\n                    if(s.equals(needle))\\n                    {\\n                        g=1;\\n                        break;\\n                     }\\n                }\\n    \\n        }\\n    if( g==1)\\n            return i;\\n        else \\n            return -1;\\n    }\\n}\\n\\n\\nbeats 100 % very easy to understand"
                    },
                    {
                        "username": "ankush920",
                        "content": "100% fast C++ solution with easy code syntax:-\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nApproach\\nComplexity\\nTime complexity:\\nSpace complexity:\\nCode\\nclass Solution {\\npublic:\\n\\n    bool ispossible( string s1, string s2,int index)\\n    {\\n        return ( s2==s1.substr(index, s2.size()) );\\n    }\\n\\n\\n      bool  check ( string s1 , string s2 )\\n      {\\n           unordered_map<int ,int> store;\\n\\n           for( auto it: s1)\\n           {\\n                store[it]++;\\n\\n           }\\n\\n\\n           for( auto  it :s2)\\n           {\\n               store[it]--;\\n               if( store[it]<0)\\n               {\\n                    return false;\\n               }\\n           }\\n\\n               return true ;\\n           \\n      }\\n    int strStr(string s1, string s2) {\\n        \\n        if( s1.size()<s2.size() || !check( s1, s2))\\n        {\\n             return -1;\\n        }\\n       \\n       int j =0;\\n        for( int i =0 ; i<=s1.size()-s2.size();i++)\\n        { \\n            \\n           if( s1[i]==s2[0]) \\n                { \\n\\n                    if( ispossible(s1,s2, i))\\n                    {\\n                         return i;\\n                    }\\n                }\\n        }\\n\\n        return -1;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "lorulalit407",
                        "content": "HEY! Can someone explain to me how i -= j is working, because to me it is causing infinite loop as we will encounter same mismatch again and again if we set i to the first matched value.\\n\\nclass Solution(object):\\n    def strStr(self, x, target):\\n        if not target:\\n            return 0\\n        \\n        i, j = 0, 0\\n\\n        while i < len(x):\\n            if x[i] == target[j]:\\n                j += 1\\n                if j == len(target):\\n                    return i - j + 1\\n            else:\\n                i -= j\\n                j = 0\\n            i += 1\\n        return -1"
                    },
                    {
                        "username": "karshten",
                        "content": "why leetcode return wrong output: \\nhaystack = \"leetcode\", needle = \"leeto\"\\nvsc (node file.js) => -1; \\nleetcode => 7;\\n\\nhaystack = \"aaaaa\", needle = \"bba\"\\nvsc (node file.js) => -1; \\nleetcode => 0;"
                    },
                    {
                        "username": "AnnOl1",
                        "content": "Hello everyone, my solve is working, but leetcode doesn\\'t agree it. I don\\'t understand, why?\\ndef test(haystack, needle):\\n    nums = haystack.find(needle[0]) \\n    if nums == -1:\\n        return -1\\n    elif haystack[nums:nums+len(needle)] == needle:\\n        return nums"
                    },
                    {
                        "username": "naga_vara_pradeep",
                        "content": "Use Sliding Window technique to solve the problem."
                    }
                ]
            },
            {
                "id": 1899633,
                "content": [
                    {
                        "username": "Alog",
                        "content": "try  `binary search` with `while loop`"
                    },
                    {
                        "username": "Dhanya_V",
                        "content": "how to approach this one thought it was easy but isn\\'t "
                    },
                    {
                        "username": "CT-7567",
                        "content": "[@ylee078](/ylee078) \\n\\nI fallowed similar steps but I checked the last char of the needle when there is match (used &&) this way you can reduce couple of unnecessary checking. "
                    },
                    {
                        "username": "ylee078",
                        "content": "take the first alphabet of needles and search through the haystack. Once you find the alphabet that matches, check if the needle is in the haystack. If not continue searching for the next matching alphabet. if it goes through the loop without finding the needle, just return -1"
                    },
                    {
                        "username": "ylee078",
                        "content": "Is it cheating to use the find() function?"
                    },
                    {
                        "username": "nkt123",
                        "content": "CheckOut My Code----\\nimport java.io.*;\\nimport java.util.*;\\nimport java.math.*;\\n\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n\\n    //HashMap<String,Integer> hm=new HashMap<String,Integer>();\\n\\n      for (int i = 0; i < haystack.length(); i++) {\\n\\n            String ss=Character.toString(haystack.charAt(i));\\n            \\n             if(ss.equals(needle)){\\n                 return i;\\n\\n               }\\n\\n            for (int j = i+1 ; j < haystack.length(); j++) {\\n\\n                ss=ss+Character.toString(haystack.charAt(j));\\n\\n               // System.out.println(ss);\\n\\n               \\n             if(ss.equals(needle)){\\n                 return i;\\n                 }\\n\\n           }\\n        }\\n        return -1;  \\n  }\\n}"
                    },
                    {
                        "username": "sourjadhr3",
                        "content": "class Solution {\\n    public int strStr(String haystack, String needle) {\\n        int i,j,g=0,f=1;\\n        int n=needle.length();\\n        for(i=0;i<haystack.length();i++)\\n        {\\n            if((i+n)>=haystack.length())\\n                {\\n                    String  s=haystack.substring(i);\\n                     if(s.equals(needle))\\n                     {\\n                         g=1;\\n                         break;\\n                     }\\n                     else\\n                        break;\\n                }\\n                else{\\n                String s=haystack.substring(i,i+n);\\n               \\n                    if(s.equals(needle))\\n                    {\\n                        g=1;\\n                        break;\\n                     }\\n                }\\n    \\n        }\\n    if( g==1)\\n            return i;\\n        else \\n            return -1;\\n    }\\n}\\n\\n\\nbeats 100 % very easy to understand"
                    },
                    {
                        "username": "ankush920",
                        "content": "100% fast C++ solution with easy code syntax:-\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nApproach\\nComplexity\\nTime complexity:\\nSpace complexity:\\nCode\\nclass Solution {\\npublic:\\n\\n    bool ispossible( string s1, string s2,int index)\\n    {\\n        return ( s2==s1.substr(index, s2.size()) );\\n    }\\n\\n\\n      bool  check ( string s1 , string s2 )\\n      {\\n           unordered_map<int ,int> store;\\n\\n           for( auto it: s1)\\n           {\\n                store[it]++;\\n\\n           }\\n\\n\\n           for( auto  it :s2)\\n           {\\n               store[it]--;\\n               if( store[it]<0)\\n               {\\n                    return false;\\n               }\\n           }\\n\\n               return true ;\\n           \\n      }\\n    int strStr(string s1, string s2) {\\n        \\n        if( s1.size()<s2.size() || !check( s1, s2))\\n        {\\n             return -1;\\n        }\\n       \\n       int j =0;\\n        for( int i =0 ; i<=s1.size()-s2.size();i++)\\n        { \\n            \\n           if( s1[i]==s2[0]) \\n                { \\n\\n                    if( ispossible(s1,s2, i))\\n                    {\\n                         return i;\\n                    }\\n                }\\n        }\\n\\n        return -1;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "lorulalit407",
                        "content": "HEY! Can someone explain to me how i -= j is working, because to me it is causing infinite loop as we will encounter same mismatch again and again if we set i to the first matched value.\\n\\nclass Solution(object):\\n    def strStr(self, x, target):\\n        if not target:\\n            return 0\\n        \\n        i, j = 0, 0\\n\\n        while i < len(x):\\n            if x[i] == target[j]:\\n                j += 1\\n                if j == len(target):\\n                    return i - j + 1\\n            else:\\n                i -= j\\n                j = 0\\n            i += 1\\n        return -1"
                    },
                    {
                        "username": "karshten",
                        "content": "why leetcode return wrong output: \\nhaystack = \"leetcode\", needle = \"leeto\"\\nvsc (node file.js) => -1; \\nleetcode => 7;\\n\\nhaystack = \"aaaaa\", needle = \"bba\"\\nvsc (node file.js) => -1; \\nleetcode => 0;"
                    },
                    {
                        "username": "AnnOl1",
                        "content": "Hello everyone, my solve is working, but leetcode doesn\\'t agree it. I don\\'t understand, why?\\ndef test(haystack, needle):\\n    nums = haystack.find(needle[0]) \\n    if nums == -1:\\n        return -1\\n    elif haystack[nums:nums+len(needle)] == needle:\\n        return nums"
                    },
                    {
                        "username": "naga_vara_pradeep",
                        "content": "Use Sliding Window technique to solve the problem."
                    }
                ]
            },
            {
                "id": 1886191,
                "content": [
                    {
                        "username": "Alog",
                        "content": "try  `binary search` with `while loop`"
                    },
                    {
                        "username": "Dhanya_V",
                        "content": "how to approach this one thought it was easy but isn\\'t "
                    },
                    {
                        "username": "CT-7567",
                        "content": "[@ylee078](/ylee078) \\n\\nI fallowed similar steps but I checked the last char of the needle when there is match (used &&) this way you can reduce couple of unnecessary checking. "
                    },
                    {
                        "username": "ylee078",
                        "content": "take the first alphabet of needles and search through the haystack. Once you find the alphabet that matches, check if the needle is in the haystack. If not continue searching for the next matching alphabet. if it goes through the loop without finding the needle, just return -1"
                    },
                    {
                        "username": "ylee078",
                        "content": "Is it cheating to use the find() function?"
                    },
                    {
                        "username": "nkt123",
                        "content": "CheckOut My Code----\\nimport java.io.*;\\nimport java.util.*;\\nimport java.math.*;\\n\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n\\n    //HashMap<String,Integer> hm=new HashMap<String,Integer>();\\n\\n      for (int i = 0; i < haystack.length(); i++) {\\n\\n            String ss=Character.toString(haystack.charAt(i));\\n            \\n             if(ss.equals(needle)){\\n                 return i;\\n\\n               }\\n\\n            for (int j = i+1 ; j < haystack.length(); j++) {\\n\\n                ss=ss+Character.toString(haystack.charAt(j));\\n\\n               // System.out.println(ss);\\n\\n               \\n             if(ss.equals(needle)){\\n                 return i;\\n                 }\\n\\n           }\\n        }\\n        return -1;  \\n  }\\n}"
                    },
                    {
                        "username": "sourjadhr3",
                        "content": "class Solution {\\n    public int strStr(String haystack, String needle) {\\n        int i,j,g=0,f=1;\\n        int n=needle.length();\\n        for(i=0;i<haystack.length();i++)\\n        {\\n            if((i+n)>=haystack.length())\\n                {\\n                    String  s=haystack.substring(i);\\n                     if(s.equals(needle))\\n                     {\\n                         g=1;\\n                         break;\\n                     }\\n                     else\\n                        break;\\n                }\\n                else{\\n                String s=haystack.substring(i,i+n);\\n               \\n                    if(s.equals(needle))\\n                    {\\n                        g=1;\\n                        break;\\n                     }\\n                }\\n    \\n        }\\n    if( g==1)\\n            return i;\\n        else \\n            return -1;\\n    }\\n}\\n\\n\\nbeats 100 % very easy to understand"
                    },
                    {
                        "username": "ankush920",
                        "content": "100% fast C++ solution with easy code syntax:-\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nApproach\\nComplexity\\nTime complexity:\\nSpace complexity:\\nCode\\nclass Solution {\\npublic:\\n\\n    bool ispossible( string s1, string s2,int index)\\n    {\\n        return ( s2==s1.substr(index, s2.size()) );\\n    }\\n\\n\\n      bool  check ( string s1 , string s2 )\\n      {\\n           unordered_map<int ,int> store;\\n\\n           for( auto it: s1)\\n           {\\n                store[it]++;\\n\\n           }\\n\\n\\n           for( auto  it :s2)\\n           {\\n               store[it]--;\\n               if( store[it]<0)\\n               {\\n                    return false;\\n               }\\n           }\\n\\n               return true ;\\n           \\n      }\\n    int strStr(string s1, string s2) {\\n        \\n        if( s1.size()<s2.size() || !check( s1, s2))\\n        {\\n             return -1;\\n        }\\n       \\n       int j =0;\\n        for( int i =0 ; i<=s1.size()-s2.size();i++)\\n        { \\n            \\n           if( s1[i]==s2[0]) \\n                { \\n\\n                    if( ispossible(s1,s2, i))\\n                    {\\n                         return i;\\n                    }\\n                }\\n        }\\n\\n        return -1;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "lorulalit407",
                        "content": "HEY! Can someone explain to me how i -= j is working, because to me it is causing infinite loop as we will encounter same mismatch again and again if we set i to the first matched value.\\n\\nclass Solution(object):\\n    def strStr(self, x, target):\\n        if not target:\\n            return 0\\n        \\n        i, j = 0, 0\\n\\n        while i < len(x):\\n            if x[i] == target[j]:\\n                j += 1\\n                if j == len(target):\\n                    return i - j + 1\\n            else:\\n                i -= j\\n                j = 0\\n            i += 1\\n        return -1"
                    },
                    {
                        "username": "karshten",
                        "content": "why leetcode return wrong output: \\nhaystack = \"leetcode\", needle = \"leeto\"\\nvsc (node file.js) => -1; \\nleetcode => 7;\\n\\nhaystack = \"aaaaa\", needle = \"bba\"\\nvsc (node file.js) => -1; \\nleetcode => 0;"
                    },
                    {
                        "username": "AnnOl1",
                        "content": "Hello everyone, my solve is working, but leetcode doesn\\'t agree it. I don\\'t understand, why?\\ndef test(haystack, needle):\\n    nums = haystack.find(needle[0]) \\n    if nums == -1:\\n        return -1\\n    elif haystack[nums:nums+len(needle)] == needle:\\n        return nums"
                    },
                    {
                        "username": "naga_vara_pradeep",
                        "content": "Use Sliding Window technique to solve the problem."
                    }
                ]
            },
            {
                "id": 1884643,
                "content": [
                    {
                        "username": "Alog",
                        "content": "try  `binary search` with `while loop`"
                    },
                    {
                        "username": "Dhanya_V",
                        "content": "how to approach this one thought it was easy but isn\\'t "
                    },
                    {
                        "username": "CT-7567",
                        "content": "[@ylee078](/ylee078) \\n\\nI fallowed similar steps but I checked the last char of the needle when there is match (used &&) this way you can reduce couple of unnecessary checking. "
                    },
                    {
                        "username": "ylee078",
                        "content": "take the first alphabet of needles and search through the haystack. Once you find the alphabet that matches, check if the needle is in the haystack. If not continue searching for the next matching alphabet. if it goes through the loop without finding the needle, just return -1"
                    },
                    {
                        "username": "ylee078",
                        "content": "Is it cheating to use the find() function?"
                    },
                    {
                        "username": "nkt123",
                        "content": "CheckOut My Code----\\nimport java.io.*;\\nimport java.util.*;\\nimport java.math.*;\\n\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n\\n    //HashMap<String,Integer> hm=new HashMap<String,Integer>();\\n\\n      for (int i = 0; i < haystack.length(); i++) {\\n\\n            String ss=Character.toString(haystack.charAt(i));\\n            \\n             if(ss.equals(needle)){\\n                 return i;\\n\\n               }\\n\\n            for (int j = i+1 ; j < haystack.length(); j++) {\\n\\n                ss=ss+Character.toString(haystack.charAt(j));\\n\\n               // System.out.println(ss);\\n\\n               \\n             if(ss.equals(needle)){\\n                 return i;\\n                 }\\n\\n           }\\n        }\\n        return -1;  \\n  }\\n}"
                    },
                    {
                        "username": "sourjadhr3",
                        "content": "class Solution {\\n    public int strStr(String haystack, String needle) {\\n        int i,j,g=0,f=1;\\n        int n=needle.length();\\n        for(i=0;i<haystack.length();i++)\\n        {\\n            if((i+n)>=haystack.length())\\n                {\\n                    String  s=haystack.substring(i);\\n                     if(s.equals(needle))\\n                     {\\n                         g=1;\\n                         break;\\n                     }\\n                     else\\n                        break;\\n                }\\n                else{\\n                String s=haystack.substring(i,i+n);\\n               \\n                    if(s.equals(needle))\\n                    {\\n                        g=1;\\n                        break;\\n                     }\\n                }\\n    \\n        }\\n    if( g==1)\\n            return i;\\n        else \\n            return -1;\\n    }\\n}\\n\\n\\nbeats 100 % very easy to understand"
                    },
                    {
                        "username": "ankush920",
                        "content": "100% fast C++ solution with easy code syntax:-\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nApproach\\nComplexity\\nTime complexity:\\nSpace complexity:\\nCode\\nclass Solution {\\npublic:\\n\\n    bool ispossible( string s1, string s2,int index)\\n    {\\n        return ( s2==s1.substr(index, s2.size()) );\\n    }\\n\\n\\n      bool  check ( string s1 , string s2 )\\n      {\\n           unordered_map<int ,int> store;\\n\\n           for( auto it: s1)\\n           {\\n                store[it]++;\\n\\n           }\\n\\n\\n           for( auto  it :s2)\\n           {\\n               store[it]--;\\n               if( store[it]<0)\\n               {\\n                    return false;\\n               }\\n           }\\n\\n               return true ;\\n           \\n      }\\n    int strStr(string s1, string s2) {\\n        \\n        if( s1.size()<s2.size() || !check( s1, s2))\\n        {\\n             return -1;\\n        }\\n       \\n       int j =0;\\n        for( int i =0 ; i<=s1.size()-s2.size();i++)\\n        { \\n            \\n           if( s1[i]==s2[0]) \\n                { \\n\\n                    if( ispossible(s1,s2, i))\\n                    {\\n                         return i;\\n                    }\\n                }\\n        }\\n\\n        return -1;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "lorulalit407",
                        "content": "HEY! Can someone explain to me how i -= j is working, because to me it is causing infinite loop as we will encounter same mismatch again and again if we set i to the first matched value.\\n\\nclass Solution(object):\\n    def strStr(self, x, target):\\n        if not target:\\n            return 0\\n        \\n        i, j = 0, 0\\n\\n        while i < len(x):\\n            if x[i] == target[j]:\\n                j += 1\\n                if j == len(target):\\n                    return i - j + 1\\n            else:\\n                i -= j\\n                j = 0\\n            i += 1\\n        return -1"
                    },
                    {
                        "username": "karshten",
                        "content": "why leetcode return wrong output: \\nhaystack = \"leetcode\", needle = \"leeto\"\\nvsc (node file.js) => -1; \\nleetcode => 7;\\n\\nhaystack = \"aaaaa\", needle = \"bba\"\\nvsc (node file.js) => -1; \\nleetcode => 0;"
                    },
                    {
                        "username": "AnnOl1",
                        "content": "Hello everyone, my solve is working, but leetcode doesn\\'t agree it. I don\\'t understand, why?\\ndef test(haystack, needle):\\n    nums = haystack.find(needle[0]) \\n    if nums == -1:\\n        return -1\\n    elif haystack[nums:nums+len(needle)] == needle:\\n        return nums"
                    },
                    {
                        "username": "naga_vara_pradeep",
                        "content": "Use Sliding Window technique to solve the problem."
                    }
                ]
            },
            {
                "id": 1859564,
                "content": [
                    {
                        "username": "Alog",
                        "content": "try  `binary search` with `while loop`"
                    },
                    {
                        "username": "Dhanya_V",
                        "content": "how to approach this one thought it was easy but isn\\'t "
                    },
                    {
                        "username": "CT-7567",
                        "content": "[@ylee078](/ylee078) \\n\\nI fallowed similar steps but I checked the last char of the needle when there is match (used &&) this way you can reduce couple of unnecessary checking. "
                    },
                    {
                        "username": "ylee078",
                        "content": "take the first alphabet of needles and search through the haystack. Once you find the alphabet that matches, check if the needle is in the haystack. If not continue searching for the next matching alphabet. if it goes through the loop without finding the needle, just return -1"
                    },
                    {
                        "username": "ylee078",
                        "content": "Is it cheating to use the find() function?"
                    },
                    {
                        "username": "nkt123",
                        "content": "CheckOut My Code----\\nimport java.io.*;\\nimport java.util.*;\\nimport java.math.*;\\n\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n\\n    //HashMap<String,Integer> hm=new HashMap<String,Integer>();\\n\\n      for (int i = 0; i < haystack.length(); i++) {\\n\\n            String ss=Character.toString(haystack.charAt(i));\\n            \\n             if(ss.equals(needle)){\\n                 return i;\\n\\n               }\\n\\n            for (int j = i+1 ; j < haystack.length(); j++) {\\n\\n                ss=ss+Character.toString(haystack.charAt(j));\\n\\n               // System.out.println(ss);\\n\\n               \\n             if(ss.equals(needle)){\\n                 return i;\\n                 }\\n\\n           }\\n        }\\n        return -1;  \\n  }\\n}"
                    },
                    {
                        "username": "sourjadhr3",
                        "content": "class Solution {\\n    public int strStr(String haystack, String needle) {\\n        int i,j,g=0,f=1;\\n        int n=needle.length();\\n        for(i=0;i<haystack.length();i++)\\n        {\\n            if((i+n)>=haystack.length())\\n                {\\n                    String  s=haystack.substring(i);\\n                     if(s.equals(needle))\\n                     {\\n                         g=1;\\n                         break;\\n                     }\\n                     else\\n                        break;\\n                }\\n                else{\\n                String s=haystack.substring(i,i+n);\\n               \\n                    if(s.equals(needle))\\n                    {\\n                        g=1;\\n                        break;\\n                     }\\n                }\\n    \\n        }\\n    if( g==1)\\n            return i;\\n        else \\n            return -1;\\n    }\\n}\\n\\n\\nbeats 100 % very easy to understand"
                    },
                    {
                        "username": "ankush920",
                        "content": "100% fast C++ solution with easy code syntax:-\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nApproach\\nComplexity\\nTime complexity:\\nSpace complexity:\\nCode\\nclass Solution {\\npublic:\\n\\n    bool ispossible( string s1, string s2,int index)\\n    {\\n        return ( s2==s1.substr(index, s2.size()) );\\n    }\\n\\n\\n      bool  check ( string s1 , string s2 )\\n      {\\n           unordered_map<int ,int> store;\\n\\n           for( auto it: s1)\\n           {\\n                store[it]++;\\n\\n           }\\n\\n\\n           for( auto  it :s2)\\n           {\\n               store[it]--;\\n               if( store[it]<0)\\n               {\\n                    return false;\\n               }\\n           }\\n\\n               return true ;\\n           \\n      }\\n    int strStr(string s1, string s2) {\\n        \\n        if( s1.size()<s2.size() || !check( s1, s2))\\n        {\\n             return -1;\\n        }\\n       \\n       int j =0;\\n        for( int i =0 ; i<=s1.size()-s2.size();i++)\\n        { \\n            \\n           if( s1[i]==s2[0]) \\n                { \\n\\n                    if( ispossible(s1,s2, i))\\n                    {\\n                         return i;\\n                    }\\n                }\\n        }\\n\\n        return -1;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "lorulalit407",
                        "content": "HEY! Can someone explain to me how i -= j is working, because to me it is causing infinite loop as we will encounter same mismatch again and again if we set i to the first matched value.\\n\\nclass Solution(object):\\n    def strStr(self, x, target):\\n        if not target:\\n            return 0\\n        \\n        i, j = 0, 0\\n\\n        while i < len(x):\\n            if x[i] == target[j]:\\n                j += 1\\n                if j == len(target):\\n                    return i - j + 1\\n            else:\\n                i -= j\\n                j = 0\\n            i += 1\\n        return -1"
                    },
                    {
                        "username": "karshten",
                        "content": "why leetcode return wrong output: \\nhaystack = \"leetcode\", needle = \"leeto\"\\nvsc (node file.js) => -1; \\nleetcode => 7;\\n\\nhaystack = \"aaaaa\", needle = \"bba\"\\nvsc (node file.js) => -1; \\nleetcode => 0;"
                    },
                    {
                        "username": "AnnOl1",
                        "content": "Hello everyone, my solve is working, but leetcode doesn\\'t agree it. I don\\'t understand, why?\\ndef test(haystack, needle):\\n    nums = haystack.find(needle[0]) \\n    if nums == -1:\\n        return -1\\n    elif haystack[nums:nums+len(needle)] == needle:\\n        return nums"
                    },
                    {
                        "username": "naga_vara_pradeep",
                        "content": "Use Sliding Window technique to solve the problem."
                    }
                ]
            },
            {
                "id": 1850003,
                "content": [
                    {
                        "username": "Alog",
                        "content": "try  `binary search` with `while loop`"
                    },
                    {
                        "username": "Dhanya_V",
                        "content": "how to approach this one thought it was easy but isn\\'t "
                    },
                    {
                        "username": "CT-7567",
                        "content": "[@ylee078](/ylee078) \\n\\nI fallowed similar steps but I checked the last char of the needle when there is match (used &&) this way you can reduce couple of unnecessary checking. "
                    },
                    {
                        "username": "ylee078",
                        "content": "take the first alphabet of needles and search through the haystack. Once you find the alphabet that matches, check if the needle is in the haystack. If not continue searching for the next matching alphabet. if it goes through the loop without finding the needle, just return -1"
                    },
                    {
                        "username": "ylee078",
                        "content": "Is it cheating to use the find() function?"
                    },
                    {
                        "username": "nkt123",
                        "content": "CheckOut My Code----\\nimport java.io.*;\\nimport java.util.*;\\nimport java.math.*;\\n\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n\\n    //HashMap<String,Integer> hm=new HashMap<String,Integer>();\\n\\n      for (int i = 0; i < haystack.length(); i++) {\\n\\n            String ss=Character.toString(haystack.charAt(i));\\n            \\n             if(ss.equals(needle)){\\n                 return i;\\n\\n               }\\n\\n            for (int j = i+1 ; j < haystack.length(); j++) {\\n\\n                ss=ss+Character.toString(haystack.charAt(j));\\n\\n               // System.out.println(ss);\\n\\n               \\n             if(ss.equals(needle)){\\n                 return i;\\n                 }\\n\\n           }\\n        }\\n        return -1;  \\n  }\\n}"
                    },
                    {
                        "username": "sourjadhr3",
                        "content": "class Solution {\\n    public int strStr(String haystack, String needle) {\\n        int i,j,g=0,f=1;\\n        int n=needle.length();\\n        for(i=0;i<haystack.length();i++)\\n        {\\n            if((i+n)>=haystack.length())\\n                {\\n                    String  s=haystack.substring(i);\\n                     if(s.equals(needle))\\n                     {\\n                         g=1;\\n                         break;\\n                     }\\n                     else\\n                        break;\\n                }\\n                else{\\n                String s=haystack.substring(i,i+n);\\n               \\n                    if(s.equals(needle))\\n                    {\\n                        g=1;\\n                        break;\\n                     }\\n                }\\n    \\n        }\\n    if( g==1)\\n            return i;\\n        else \\n            return -1;\\n    }\\n}\\n\\n\\nbeats 100 % very easy to understand"
                    },
                    {
                        "username": "ankush920",
                        "content": "100% fast C++ solution with easy code syntax:-\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nApproach\\nComplexity\\nTime complexity:\\nSpace complexity:\\nCode\\nclass Solution {\\npublic:\\n\\n    bool ispossible( string s1, string s2,int index)\\n    {\\n        return ( s2==s1.substr(index, s2.size()) );\\n    }\\n\\n\\n      bool  check ( string s1 , string s2 )\\n      {\\n           unordered_map<int ,int> store;\\n\\n           for( auto it: s1)\\n           {\\n                store[it]++;\\n\\n           }\\n\\n\\n           for( auto  it :s2)\\n           {\\n               store[it]--;\\n               if( store[it]<0)\\n               {\\n                    return false;\\n               }\\n           }\\n\\n               return true ;\\n           \\n      }\\n    int strStr(string s1, string s2) {\\n        \\n        if( s1.size()<s2.size() || !check( s1, s2))\\n        {\\n             return -1;\\n        }\\n       \\n       int j =0;\\n        for( int i =0 ; i<=s1.size()-s2.size();i++)\\n        { \\n            \\n           if( s1[i]==s2[0]) \\n                { \\n\\n                    if( ispossible(s1,s2, i))\\n                    {\\n                         return i;\\n                    }\\n                }\\n        }\\n\\n        return -1;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "lorulalit407",
                        "content": "HEY! Can someone explain to me how i -= j is working, because to me it is causing infinite loop as we will encounter same mismatch again and again if we set i to the first matched value.\\n\\nclass Solution(object):\\n    def strStr(self, x, target):\\n        if not target:\\n            return 0\\n        \\n        i, j = 0, 0\\n\\n        while i < len(x):\\n            if x[i] == target[j]:\\n                j += 1\\n                if j == len(target):\\n                    return i - j + 1\\n            else:\\n                i -= j\\n                j = 0\\n            i += 1\\n        return -1"
                    },
                    {
                        "username": "karshten",
                        "content": "why leetcode return wrong output: \\nhaystack = \"leetcode\", needle = \"leeto\"\\nvsc (node file.js) => -1; \\nleetcode => 7;\\n\\nhaystack = \"aaaaa\", needle = \"bba\"\\nvsc (node file.js) => -1; \\nleetcode => 0;"
                    },
                    {
                        "username": "AnnOl1",
                        "content": "Hello everyone, my solve is working, but leetcode doesn\\'t agree it. I don\\'t understand, why?\\ndef test(haystack, needle):\\n    nums = haystack.find(needle[0]) \\n    if nums == -1:\\n        return -1\\n    elif haystack[nums:nums+len(needle)] == needle:\\n        return nums"
                    },
                    {
                        "username": "naga_vara_pradeep",
                        "content": "Use Sliding Window technique to solve the problem."
                    }
                ]
            },
            {
                "id": 1849798,
                "content": [
                    {
                        "username": "Alog",
                        "content": "try  `binary search` with `while loop`"
                    },
                    {
                        "username": "Dhanya_V",
                        "content": "how to approach this one thought it was easy but isn\\'t "
                    },
                    {
                        "username": "CT-7567",
                        "content": "[@ylee078](/ylee078) \\n\\nI fallowed similar steps but I checked the last char of the needle when there is match (used &&) this way you can reduce couple of unnecessary checking. "
                    },
                    {
                        "username": "ylee078",
                        "content": "take the first alphabet of needles and search through the haystack. Once you find the alphabet that matches, check if the needle is in the haystack. If not continue searching for the next matching alphabet. if it goes through the loop without finding the needle, just return -1"
                    },
                    {
                        "username": "ylee078",
                        "content": "Is it cheating to use the find() function?"
                    },
                    {
                        "username": "nkt123",
                        "content": "CheckOut My Code----\\nimport java.io.*;\\nimport java.util.*;\\nimport java.math.*;\\n\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n\\n    //HashMap<String,Integer> hm=new HashMap<String,Integer>();\\n\\n      for (int i = 0; i < haystack.length(); i++) {\\n\\n            String ss=Character.toString(haystack.charAt(i));\\n            \\n             if(ss.equals(needle)){\\n                 return i;\\n\\n               }\\n\\n            for (int j = i+1 ; j < haystack.length(); j++) {\\n\\n                ss=ss+Character.toString(haystack.charAt(j));\\n\\n               // System.out.println(ss);\\n\\n               \\n             if(ss.equals(needle)){\\n                 return i;\\n                 }\\n\\n           }\\n        }\\n        return -1;  \\n  }\\n}"
                    },
                    {
                        "username": "sourjadhr3",
                        "content": "class Solution {\\n    public int strStr(String haystack, String needle) {\\n        int i,j,g=0,f=1;\\n        int n=needle.length();\\n        for(i=0;i<haystack.length();i++)\\n        {\\n            if((i+n)>=haystack.length())\\n                {\\n                    String  s=haystack.substring(i);\\n                     if(s.equals(needle))\\n                     {\\n                         g=1;\\n                         break;\\n                     }\\n                     else\\n                        break;\\n                }\\n                else{\\n                String s=haystack.substring(i,i+n);\\n               \\n                    if(s.equals(needle))\\n                    {\\n                        g=1;\\n                        break;\\n                     }\\n                }\\n    \\n        }\\n    if( g==1)\\n            return i;\\n        else \\n            return -1;\\n    }\\n}\\n\\n\\nbeats 100 % very easy to understand"
                    },
                    {
                        "username": "ankush920",
                        "content": "100% fast C++ solution with easy code syntax:-\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nApproach\\nComplexity\\nTime complexity:\\nSpace complexity:\\nCode\\nclass Solution {\\npublic:\\n\\n    bool ispossible( string s1, string s2,int index)\\n    {\\n        return ( s2==s1.substr(index, s2.size()) );\\n    }\\n\\n\\n      bool  check ( string s1 , string s2 )\\n      {\\n           unordered_map<int ,int> store;\\n\\n           for( auto it: s1)\\n           {\\n                store[it]++;\\n\\n           }\\n\\n\\n           for( auto  it :s2)\\n           {\\n               store[it]--;\\n               if( store[it]<0)\\n               {\\n                    return false;\\n               }\\n           }\\n\\n               return true ;\\n           \\n      }\\n    int strStr(string s1, string s2) {\\n        \\n        if( s1.size()<s2.size() || !check( s1, s2))\\n        {\\n             return -1;\\n        }\\n       \\n       int j =0;\\n        for( int i =0 ; i<=s1.size()-s2.size();i++)\\n        { \\n            \\n           if( s1[i]==s2[0]) \\n                { \\n\\n                    if( ispossible(s1,s2, i))\\n                    {\\n                         return i;\\n                    }\\n                }\\n        }\\n\\n        return -1;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "lorulalit407",
                        "content": "HEY! Can someone explain to me how i -= j is working, because to me it is causing infinite loop as we will encounter same mismatch again and again if we set i to the first matched value.\\n\\nclass Solution(object):\\n    def strStr(self, x, target):\\n        if not target:\\n            return 0\\n        \\n        i, j = 0, 0\\n\\n        while i < len(x):\\n            if x[i] == target[j]:\\n                j += 1\\n                if j == len(target):\\n                    return i - j + 1\\n            else:\\n                i -= j\\n                j = 0\\n            i += 1\\n        return -1"
                    },
                    {
                        "username": "karshten",
                        "content": "why leetcode return wrong output: \\nhaystack = \"leetcode\", needle = \"leeto\"\\nvsc (node file.js) => -1; \\nleetcode => 7;\\n\\nhaystack = \"aaaaa\", needle = \"bba\"\\nvsc (node file.js) => -1; \\nleetcode => 0;"
                    },
                    {
                        "username": "AnnOl1",
                        "content": "Hello everyone, my solve is working, but leetcode doesn\\'t agree it. I don\\'t understand, why?\\ndef test(haystack, needle):\\n    nums = haystack.find(needle[0]) \\n    if nums == -1:\\n        return -1\\n    elif haystack[nums:nums+len(needle)] == needle:\\n        return nums"
                    },
                    {
                        "username": "naga_vara_pradeep",
                        "content": "Use Sliding Window technique to solve the problem."
                    }
                ]
            },
            {
                "id": 1846614,
                "content": [
                    {
                        "username": "Alog",
                        "content": "try  `binary search` with `while loop`"
                    },
                    {
                        "username": "Dhanya_V",
                        "content": "how to approach this one thought it was easy but isn\\'t "
                    },
                    {
                        "username": "CT-7567",
                        "content": "[@ylee078](/ylee078) \\n\\nI fallowed similar steps but I checked the last char of the needle when there is match (used &&) this way you can reduce couple of unnecessary checking. "
                    },
                    {
                        "username": "ylee078",
                        "content": "take the first alphabet of needles and search through the haystack. Once you find the alphabet that matches, check if the needle is in the haystack. If not continue searching for the next matching alphabet. if it goes through the loop without finding the needle, just return -1"
                    },
                    {
                        "username": "ylee078",
                        "content": "Is it cheating to use the find() function?"
                    },
                    {
                        "username": "nkt123",
                        "content": "CheckOut My Code----\\nimport java.io.*;\\nimport java.util.*;\\nimport java.math.*;\\n\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n\\n    //HashMap<String,Integer> hm=new HashMap<String,Integer>();\\n\\n      for (int i = 0; i < haystack.length(); i++) {\\n\\n            String ss=Character.toString(haystack.charAt(i));\\n            \\n             if(ss.equals(needle)){\\n                 return i;\\n\\n               }\\n\\n            for (int j = i+1 ; j < haystack.length(); j++) {\\n\\n                ss=ss+Character.toString(haystack.charAt(j));\\n\\n               // System.out.println(ss);\\n\\n               \\n             if(ss.equals(needle)){\\n                 return i;\\n                 }\\n\\n           }\\n        }\\n        return -1;  \\n  }\\n}"
                    },
                    {
                        "username": "sourjadhr3",
                        "content": "class Solution {\\n    public int strStr(String haystack, String needle) {\\n        int i,j,g=0,f=1;\\n        int n=needle.length();\\n        for(i=0;i<haystack.length();i++)\\n        {\\n            if((i+n)>=haystack.length())\\n                {\\n                    String  s=haystack.substring(i);\\n                     if(s.equals(needle))\\n                     {\\n                         g=1;\\n                         break;\\n                     }\\n                     else\\n                        break;\\n                }\\n                else{\\n                String s=haystack.substring(i,i+n);\\n               \\n                    if(s.equals(needle))\\n                    {\\n                        g=1;\\n                        break;\\n                     }\\n                }\\n    \\n        }\\n    if( g==1)\\n            return i;\\n        else \\n            return -1;\\n    }\\n}\\n\\n\\nbeats 100 % very easy to understand"
                    },
                    {
                        "username": "ankush920",
                        "content": "100% fast C++ solution with easy code syntax:-\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nApproach\\nComplexity\\nTime complexity:\\nSpace complexity:\\nCode\\nclass Solution {\\npublic:\\n\\n    bool ispossible( string s1, string s2,int index)\\n    {\\n        return ( s2==s1.substr(index, s2.size()) );\\n    }\\n\\n\\n      bool  check ( string s1 , string s2 )\\n      {\\n           unordered_map<int ,int> store;\\n\\n           for( auto it: s1)\\n           {\\n                store[it]++;\\n\\n           }\\n\\n\\n           for( auto  it :s2)\\n           {\\n               store[it]--;\\n               if( store[it]<0)\\n               {\\n                    return false;\\n               }\\n           }\\n\\n               return true ;\\n           \\n      }\\n    int strStr(string s1, string s2) {\\n        \\n        if( s1.size()<s2.size() || !check( s1, s2))\\n        {\\n             return -1;\\n        }\\n       \\n       int j =0;\\n        for( int i =0 ; i<=s1.size()-s2.size();i++)\\n        { \\n            \\n           if( s1[i]==s2[0]) \\n                { \\n\\n                    if( ispossible(s1,s2, i))\\n                    {\\n                         return i;\\n                    }\\n                }\\n        }\\n\\n        return -1;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "lorulalit407",
                        "content": "HEY! Can someone explain to me how i -= j is working, because to me it is causing infinite loop as we will encounter same mismatch again and again if we set i to the first matched value.\\n\\nclass Solution(object):\\n    def strStr(self, x, target):\\n        if not target:\\n            return 0\\n        \\n        i, j = 0, 0\\n\\n        while i < len(x):\\n            if x[i] == target[j]:\\n                j += 1\\n                if j == len(target):\\n                    return i - j + 1\\n            else:\\n                i -= j\\n                j = 0\\n            i += 1\\n        return -1"
                    },
                    {
                        "username": "karshten",
                        "content": "why leetcode return wrong output: \\nhaystack = \"leetcode\", needle = \"leeto\"\\nvsc (node file.js) => -1; \\nleetcode => 7;\\n\\nhaystack = \"aaaaa\", needle = \"bba\"\\nvsc (node file.js) => -1; \\nleetcode => 0;"
                    },
                    {
                        "username": "AnnOl1",
                        "content": "Hello everyone, my solve is working, but leetcode doesn\\'t agree it. I don\\'t understand, why?\\ndef test(haystack, needle):\\n    nums = haystack.find(needle[0]) \\n    if nums == -1:\\n        return -1\\n    elif haystack[nums:nums+len(needle)] == needle:\\n        return nums"
                    },
                    {
                        "username": "naga_vara_pradeep",
                        "content": "Use Sliding Window technique to solve the problem."
                    }
                ]
            },
            {
                "id": 1837997,
                "content": [
                    {
                        "username": "Alog",
                        "content": "try  `binary search` with `while loop`"
                    },
                    {
                        "username": "Dhanya_V",
                        "content": "how to approach this one thought it was easy but isn\\'t "
                    },
                    {
                        "username": "CT-7567",
                        "content": "[@ylee078](/ylee078) \\n\\nI fallowed similar steps but I checked the last char of the needle when there is match (used &&) this way you can reduce couple of unnecessary checking. "
                    },
                    {
                        "username": "ylee078",
                        "content": "take the first alphabet of needles and search through the haystack. Once you find the alphabet that matches, check if the needle is in the haystack. If not continue searching for the next matching alphabet. if it goes through the loop without finding the needle, just return -1"
                    },
                    {
                        "username": "ylee078",
                        "content": "Is it cheating to use the find() function?"
                    },
                    {
                        "username": "nkt123",
                        "content": "CheckOut My Code----\\nimport java.io.*;\\nimport java.util.*;\\nimport java.math.*;\\n\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n\\n    //HashMap<String,Integer> hm=new HashMap<String,Integer>();\\n\\n      for (int i = 0; i < haystack.length(); i++) {\\n\\n            String ss=Character.toString(haystack.charAt(i));\\n            \\n             if(ss.equals(needle)){\\n                 return i;\\n\\n               }\\n\\n            for (int j = i+1 ; j < haystack.length(); j++) {\\n\\n                ss=ss+Character.toString(haystack.charAt(j));\\n\\n               // System.out.println(ss);\\n\\n               \\n             if(ss.equals(needle)){\\n                 return i;\\n                 }\\n\\n           }\\n        }\\n        return -1;  \\n  }\\n}"
                    },
                    {
                        "username": "sourjadhr3",
                        "content": "class Solution {\\n    public int strStr(String haystack, String needle) {\\n        int i,j,g=0,f=1;\\n        int n=needle.length();\\n        for(i=0;i<haystack.length();i++)\\n        {\\n            if((i+n)>=haystack.length())\\n                {\\n                    String  s=haystack.substring(i);\\n                     if(s.equals(needle))\\n                     {\\n                         g=1;\\n                         break;\\n                     }\\n                     else\\n                        break;\\n                }\\n                else{\\n                String s=haystack.substring(i,i+n);\\n               \\n                    if(s.equals(needle))\\n                    {\\n                        g=1;\\n                        break;\\n                     }\\n                }\\n    \\n        }\\n    if( g==1)\\n            return i;\\n        else \\n            return -1;\\n    }\\n}\\n\\n\\nbeats 100 % very easy to understand"
                    },
                    {
                        "username": "ankush920",
                        "content": "100% fast C++ solution with easy code syntax:-\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nApproach\\nComplexity\\nTime complexity:\\nSpace complexity:\\nCode\\nclass Solution {\\npublic:\\n\\n    bool ispossible( string s1, string s2,int index)\\n    {\\n        return ( s2==s1.substr(index, s2.size()) );\\n    }\\n\\n\\n      bool  check ( string s1 , string s2 )\\n      {\\n           unordered_map<int ,int> store;\\n\\n           for( auto it: s1)\\n           {\\n                store[it]++;\\n\\n           }\\n\\n\\n           for( auto  it :s2)\\n           {\\n               store[it]--;\\n               if( store[it]<0)\\n               {\\n                    return false;\\n               }\\n           }\\n\\n               return true ;\\n           \\n      }\\n    int strStr(string s1, string s2) {\\n        \\n        if( s1.size()<s2.size() || !check( s1, s2))\\n        {\\n             return -1;\\n        }\\n       \\n       int j =0;\\n        for( int i =0 ; i<=s1.size()-s2.size();i++)\\n        { \\n            \\n           if( s1[i]==s2[0]) \\n                { \\n\\n                    if( ispossible(s1,s2, i))\\n                    {\\n                         return i;\\n                    }\\n                }\\n        }\\n\\n        return -1;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "lorulalit407",
                        "content": "HEY! Can someone explain to me how i -= j is working, because to me it is causing infinite loop as we will encounter same mismatch again and again if we set i to the first matched value.\\n\\nclass Solution(object):\\n    def strStr(self, x, target):\\n        if not target:\\n            return 0\\n        \\n        i, j = 0, 0\\n\\n        while i < len(x):\\n            if x[i] == target[j]:\\n                j += 1\\n                if j == len(target):\\n                    return i - j + 1\\n            else:\\n                i -= j\\n                j = 0\\n            i += 1\\n        return -1"
                    },
                    {
                        "username": "karshten",
                        "content": "why leetcode return wrong output: \\nhaystack = \"leetcode\", needle = \"leeto\"\\nvsc (node file.js) => -1; \\nleetcode => 7;\\n\\nhaystack = \"aaaaa\", needle = \"bba\"\\nvsc (node file.js) => -1; \\nleetcode => 0;"
                    },
                    {
                        "username": "AnnOl1",
                        "content": "Hello everyone, my solve is working, but leetcode doesn\\'t agree it. I don\\'t understand, why?\\ndef test(haystack, needle):\\n    nums = haystack.find(needle[0]) \\n    if nums == -1:\\n        return -1\\n    elif haystack[nums:nums+len(needle)] == needle:\\n        return nums"
                    },
                    {
                        "username": "naga_vara_pradeep",
                        "content": "Use Sliding Window technique to solve the problem."
                    }
                ]
            },
            {
                "id": 1835462,
                "content": [
                    {
                        "username": "ak_is_here",
                        "content": "Hey! \nCheck out my LeetCode solution, which beats 100% of C++ submissions! Hope it helps. https://leetcode.com/problems/find-the-index-of-the-first-occurrence-in-a-string/solutions/3309240/solution-without-builtin-functions-beats-100-c-with-time-and-space-complexity-explained/\n\nMy solution uses a simple and intuitive approach to search for the substring without using any built-in functions. By iterating over each possible starting index of the substring in the main string, we compare each character of the substring to the corresponding character in the main string. This approach ensures that we find the earliest occurrence of the substring in the main string.\n\nWhat's more, my solution comes with detailed explanations of the time and space complexity, so you can understand exactly how it works under the hood.\n\nSo if you're looking for a fast, efficient, and easy-to-understand solution to finding the index of the first occurrence of a substring in a string, check out my LeetCode solution today!"
                    },
                    {
                        "username": "zyusuke10",
                        "content": "Why do i get time exceeded with this code? \n\n`class Solution:\n\n    def strStr(self, haystack: str, needle: str) -> int:\n        if needle not in haystack:\n            return -1\n        i = 0\n        j = 0\n        while i < len(haystack) and j < len(needle):\n            if haystack[i] == needle[j]:\n                i+=1\n                j+=1\n            else:\n                i=+1\n                j=0\n        return i-j`"
                    },
                    {
                        "username": "calicojack42",
                        "content": "I get the feeling that most if not all of the one-line solutions using builtin functions are working against the spirit of the question. Instead, try to imagine how you\\'d build this procedure if that function didn\\'t exist."
                    },
                    {
                        "username": "priyanshrm",
                        "content": "hello there! can anyone of you help me get the time complexity of my solution (ima little confused)?\n\n        `list_i = []\n        for j in range(len(haystack)):\n            if haystack[j] == needle[0]:\n                list_i.append(j)\n        for i in list_i:\n            if i + len(needle) <= len(haystack):\n                if needle == haystack[i:i + len(needle)]:\n                    return i\n        return -1`\n\nlink: [Code/Solution](https://leetcode.com/problems/find-the-index-of-the-first-occurrence-in-a-string/solutions/3299481/beats-89-27-ms-runtime/)\nI am just using a list to store the indices of haystack which have needle's first letter in them. And then the usual of looping through that list and cross-check the strings. (to find any matches) "
                    },
                    {
                        "username": "Deecodes25",
                        "content": "Can anyone tell what is the Time Complexity of this solution - \n\n ```\ni=0\nj=len(needle)\nwhile j<=len(haystack):\n            if haystack[i:j] == needle:\n                return i\n            i+=1\n            j+=1\nreturn -1\n```"
                    },
                    {
                        "username": "Anshmehta380",
                        "content": "Simplest Problem:\\nJust return haystack.indexOf(needle);\\n0ms solution"
                    },
                    {
                        "username": "redocmi7",
                        "content": "A standard string problem. I solved it using map in c++.\\nStoring each substring of the length of the needle string and then at last checking if the map contains the required needle or not. Mapping has been done from the required string to the 1st index from where the substring starts."
                    },
                    {
                        "username": "jperrin36",
                        "content": "good news and bad news\\ngood news: i made a solution that passes\\nbad news:  it only beats 5% runtime kms"
                    },
                    {
                        "username": "ak_is_here",
                        "content": "Hey! \nCheck out my LeetCode solution, which beats 100% of C++ submissions! Hope it helps.https://leetcode.com/problems/find-the-index-of-the-first-occurrence-in-a-string/solutions/3309240/solution-without-builtin-functions-beats-100-c-with-time-and-space-complexity-explained/\n\nMy solution uses a simple and intuitive approach to search for the substring without using any built-in functions. By iterating over each possible starting index of the substring in the main string, we compare each character of the substring to the corresponding character in the main string. This approach ensures that we find the earliest occurrence of the substring in the main string.\n\nWhat's more, my solution comes with detailed explanations of the time and space complexity, so you can understand exactly how it works under the hood.\n\nSo if you're looking for a fast, efficient, and easy-to-understand solution to finding the index of the first occurrence of a substring in a string, check out my LeetCode solution today!"
                    },
                    {
                        "username": "Karan-Yadav",
                        "content": "same as index method in python 3"
                    },
                    {
                        "username": "hmtthakur",
                        "content": "IMPORTANT :\\nI have 2 codes for this problem both using KMP algo, only difference is in 1st I am using  charArray length in while loop condition and in 2nd I am using String length(). \\nRuntime : \\n1 : Beats 41% (1ms)\\n2 : Beats 100% (0ms)\\n\\nMy question : Is this expected that much of a difference because of length calculation?\\n\\nCodes : \\n1 :\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n        int[] kmp ;\\n        kmp = computeTemporaryArray(needle.toCharArray());\\n        int j = 0, i=0;\\n        while( i< haystack.length() && j < needle.length()){\\n            if(haystack.charAt(i) == needle.charAt(j)){\\n                j++;\\n                i++;\\n                continue;\\n\\n            }\\n            else {\\n                if(j>0)\\n                    j = kmp[j-1];\\n                else\\n                    i++;\\n            }\\n        }\\n\\n        if(j == needle.length()){\\n            return i - needle.length();\\n        }\\n        return -1;\\n    }\\n\\n    private int[] computeTemporaryArray(char[] pattern){\\n        int[] lps = new int[pattern.length];\\n        int index =0;\\n        for(int i=1; i < pattern.length;){\\n            if(pattern[i] == pattern[index]){\\n                lps[i] = index + 1;\\n                index++;\\n                i++;\\n            }else{\\n                if(index != 0){\\n                    index = lps[index-1];\\n                }else{\\n                    lps[i] =0;\\n                    i++;\\n                }\\n            }\\n        }\\n        return lps;\\n    }\\n}\\n\\n\\n2: \\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n        char[] hs = haystack.toCharArray();\\n        char[] ndl = needle.toCharArray();\\n        int[] kmp ;\\n        kmp = computeTemporaryArray(ndl);\\n        int j = 0, i=0;\\n        while( i< hs.length && j < ndl.length){\\n            if(haystack.charAt(i) == needle.charAt(j)){\\n                j++;\\n                i++;\\n                continue;\\n\\n            }\\n            else {\\n                if(j>0)\\n                    j = kmp[j-1];\\n                else\\n                    i++;\\n            }\\n        }\\n\\n        if(j == needle.length()){\\n            return i - needle.length();\\n        }\\n        return -1;\\n    }\\n\\n    private int[] computeTemporaryArray(char[] pattern){\\n        int[] lps = new int[pattern.length];\\n        int index =0;\\n        for(int i=1; i < pattern.length;){\\n            if(pattern[i] == pattern[index]){\\n                lps[i] = index + 1;\\n                index++;\\n                i++;\\n            }else{\\n                if(index != 0){\\n                    index = lps[index-1];\\n                }else{\\n                    lps[i] =0;\\n                    i++;\\n                }\\n            }\\n        }\\n        return lps;\\n    }\\n}\\n\\nPlease do reply anyone????"
                    }
                ]
            },
            {
                "id": 1834996,
                "content": [
                    {
                        "username": "ak_is_here",
                        "content": "Hey! \nCheck out my LeetCode solution, which beats 100% of C++ submissions! Hope it helps. https://leetcode.com/problems/find-the-index-of-the-first-occurrence-in-a-string/solutions/3309240/solution-without-builtin-functions-beats-100-c-with-time-and-space-complexity-explained/\n\nMy solution uses a simple and intuitive approach to search for the substring without using any built-in functions. By iterating over each possible starting index of the substring in the main string, we compare each character of the substring to the corresponding character in the main string. This approach ensures that we find the earliest occurrence of the substring in the main string.\n\nWhat's more, my solution comes with detailed explanations of the time and space complexity, so you can understand exactly how it works under the hood.\n\nSo if you're looking for a fast, efficient, and easy-to-understand solution to finding the index of the first occurrence of a substring in a string, check out my LeetCode solution today!"
                    },
                    {
                        "username": "zyusuke10",
                        "content": "Why do i get time exceeded with this code? \n\n`class Solution:\n\n    def strStr(self, haystack: str, needle: str) -> int:\n        if needle not in haystack:\n            return -1\n        i = 0\n        j = 0\n        while i < len(haystack) and j < len(needle):\n            if haystack[i] == needle[j]:\n                i+=1\n                j+=1\n            else:\n                i=+1\n                j=0\n        return i-j`"
                    },
                    {
                        "username": "calicojack42",
                        "content": "I get the feeling that most if not all of the one-line solutions using builtin functions are working against the spirit of the question. Instead, try to imagine how you\\'d build this procedure if that function didn\\'t exist."
                    },
                    {
                        "username": "priyanshrm",
                        "content": "hello there! can anyone of you help me get the time complexity of my solution (ima little confused)?\n\n        `list_i = []\n        for j in range(len(haystack)):\n            if haystack[j] == needle[0]:\n                list_i.append(j)\n        for i in list_i:\n            if i + len(needle) <= len(haystack):\n                if needle == haystack[i:i + len(needle)]:\n                    return i\n        return -1`\n\nlink: [Code/Solution](https://leetcode.com/problems/find-the-index-of-the-first-occurrence-in-a-string/solutions/3299481/beats-89-27-ms-runtime/)\nI am just using a list to store the indices of haystack which have needle's first letter in them. And then the usual of looping through that list and cross-check the strings. (to find any matches) "
                    },
                    {
                        "username": "Deecodes25",
                        "content": "Can anyone tell what is the Time Complexity of this solution - \n\n ```\ni=0\nj=len(needle)\nwhile j<=len(haystack):\n            if haystack[i:j] == needle:\n                return i\n            i+=1\n            j+=1\nreturn -1\n```"
                    },
                    {
                        "username": "Anshmehta380",
                        "content": "Simplest Problem:\\nJust return haystack.indexOf(needle);\\n0ms solution"
                    },
                    {
                        "username": "redocmi7",
                        "content": "A standard string problem. I solved it using map in c++.\\nStoring each substring of the length of the needle string and then at last checking if the map contains the required needle or not. Mapping has been done from the required string to the 1st index from where the substring starts."
                    },
                    {
                        "username": "jperrin36",
                        "content": "good news and bad news\\ngood news: i made a solution that passes\\nbad news:  it only beats 5% runtime kms"
                    },
                    {
                        "username": "ak_is_here",
                        "content": "Hey! \nCheck out my LeetCode solution, which beats 100% of C++ submissions! Hope it helps.https://leetcode.com/problems/find-the-index-of-the-first-occurrence-in-a-string/solutions/3309240/solution-without-builtin-functions-beats-100-c-with-time-and-space-complexity-explained/\n\nMy solution uses a simple and intuitive approach to search for the substring without using any built-in functions. By iterating over each possible starting index of the substring in the main string, we compare each character of the substring to the corresponding character in the main string. This approach ensures that we find the earliest occurrence of the substring in the main string.\n\nWhat's more, my solution comes with detailed explanations of the time and space complexity, so you can understand exactly how it works under the hood.\n\nSo if you're looking for a fast, efficient, and easy-to-understand solution to finding the index of the first occurrence of a substring in a string, check out my LeetCode solution today!"
                    },
                    {
                        "username": "Karan-Yadav",
                        "content": "same as index method in python 3"
                    },
                    {
                        "username": "hmtthakur",
                        "content": "IMPORTANT :\\nI have 2 codes for this problem both using KMP algo, only difference is in 1st I am using  charArray length in while loop condition and in 2nd I am using String length(). \\nRuntime : \\n1 : Beats 41% (1ms)\\n2 : Beats 100% (0ms)\\n\\nMy question : Is this expected that much of a difference because of length calculation?\\n\\nCodes : \\n1 :\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n        int[] kmp ;\\n        kmp = computeTemporaryArray(needle.toCharArray());\\n        int j = 0, i=0;\\n        while( i< haystack.length() && j < needle.length()){\\n            if(haystack.charAt(i) == needle.charAt(j)){\\n                j++;\\n                i++;\\n                continue;\\n\\n            }\\n            else {\\n                if(j>0)\\n                    j = kmp[j-1];\\n                else\\n                    i++;\\n            }\\n        }\\n\\n        if(j == needle.length()){\\n            return i - needle.length();\\n        }\\n        return -1;\\n    }\\n\\n    private int[] computeTemporaryArray(char[] pattern){\\n        int[] lps = new int[pattern.length];\\n        int index =0;\\n        for(int i=1; i < pattern.length;){\\n            if(pattern[i] == pattern[index]){\\n                lps[i] = index + 1;\\n                index++;\\n                i++;\\n            }else{\\n                if(index != 0){\\n                    index = lps[index-1];\\n                }else{\\n                    lps[i] =0;\\n                    i++;\\n                }\\n            }\\n        }\\n        return lps;\\n    }\\n}\\n\\n\\n2: \\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n        char[] hs = haystack.toCharArray();\\n        char[] ndl = needle.toCharArray();\\n        int[] kmp ;\\n        kmp = computeTemporaryArray(ndl);\\n        int j = 0, i=0;\\n        while( i< hs.length && j < ndl.length){\\n            if(haystack.charAt(i) == needle.charAt(j)){\\n                j++;\\n                i++;\\n                continue;\\n\\n            }\\n            else {\\n                if(j>0)\\n                    j = kmp[j-1];\\n                else\\n                    i++;\\n            }\\n        }\\n\\n        if(j == needle.length()){\\n            return i - needle.length();\\n        }\\n        return -1;\\n    }\\n\\n    private int[] computeTemporaryArray(char[] pattern){\\n        int[] lps = new int[pattern.length];\\n        int index =0;\\n        for(int i=1; i < pattern.length;){\\n            if(pattern[i] == pattern[index]){\\n                lps[i] = index + 1;\\n                index++;\\n                i++;\\n            }else{\\n                if(index != 0){\\n                    index = lps[index-1];\\n                }else{\\n                    lps[i] =0;\\n                    i++;\\n                }\\n            }\\n        }\\n        return lps;\\n    }\\n}\\n\\nPlease do reply anyone????"
                    }
                ]
            },
            {
                "id": 1834269,
                "content": [
                    {
                        "username": "ak_is_here",
                        "content": "Hey! \nCheck out my LeetCode solution, which beats 100% of C++ submissions! Hope it helps. https://leetcode.com/problems/find-the-index-of-the-first-occurrence-in-a-string/solutions/3309240/solution-without-builtin-functions-beats-100-c-with-time-and-space-complexity-explained/\n\nMy solution uses a simple and intuitive approach to search for the substring without using any built-in functions. By iterating over each possible starting index of the substring in the main string, we compare each character of the substring to the corresponding character in the main string. This approach ensures that we find the earliest occurrence of the substring in the main string.\n\nWhat's more, my solution comes with detailed explanations of the time and space complexity, so you can understand exactly how it works under the hood.\n\nSo if you're looking for a fast, efficient, and easy-to-understand solution to finding the index of the first occurrence of a substring in a string, check out my LeetCode solution today!"
                    },
                    {
                        "username": "zyusuke10",
                        "content": "Why do i get time exceeded with this code? \n\n`class Solution:\n\n    def strStr(self, haystack: str, needle: str) -> int:\n        if needle not in haystack:\n            return -1\n        i = 0\n        j = 0\n        while i < len(haystack) and j < len(needle):\n            if haystack[i] == needle[j]:\n                i+=1\n                j+=1\n            else:\n                i=+1\n                j=0\n        return i-j`"
                    },
                    {
                        "username": "calicojack42",
                        "content": "I get the feeling that most if not all of the one-line solutions using builtin functions are working against the spirit of the question. Instead, try to imagine how you\\'d build this procedure if that function didn\\'t exist."
                    },
                    {
                        "username": "priyanshrm",
                        "content": "hello there! can anyone of you help me get the time complexity of my solution (ima little confused)?\n\n        `list_i = []\n        for j in range(len(haystack)):\n            if haystack[j] == needle[0]:\n                list_i.append(j)\n        for i in list_i:\n            if i + len(needle) <= len(haystack):\n                if needle == haystack[i:i + len(needle)]:\n                    return i\n        return -1`\n\nlink: [Code/Solution](https://leetcode.com/problems/find-the-index-of-the-first-occurrence-in-a-string/solutions/3299481/beats-89-27-ms-runtime/)\nI am just using a list to store the indices of haystack which have needle's first letter in them. And then the usual of looping through that list and cross-check the strings. (to find any matches) "
                    },
                    {
                        "username": "Deecodes25",
                        "content": "Can anyone tell what is the Time Complexity of this solution - \n\n ```\ni=0\nj=len(needle)\nwhile j<=len(haystack):\n            if haystack[i:j] == needle:\n                return i\n            i+=1\n            j+=1\nreturn -1\n```"
                    },
                    {
                        "username": "Anshmehta380",
                        "content": "Simplest Problem:\\nJust return haystack.indexOf(needle);\\n0ms solution"
                    },
                    {
                        "username": "redocmi7",
                        "content": "A standard string problem. I solved it using map in c++.\\nStoring each substring of the length of the needle string and then at last checking if the map contains the required needle or not. Mapping has been done from the required string to the 1st index from where the substring starts."
                    },
                    {
                        "username": "jperrin36",
                        "content": "good news and bad news\\ngood news: i made a solution that passes\\nbad news:  it only beats 5% runtime kms"
                    },
                    {
                        "username": "ak_is_here",
                        "content": "Hey! \nCheck out my LeetCode solution, which beats 100% of C++ submissions! Hope it helps.https://leetcode.com/problems/find-the-index-of-the-first-occurrence-in-a-string/solutions/3309240/solution-without-builtin-functions-beats-100-c-with-time-and-space-complexity-explained/\n\nMy solution uses a simple and intuitive approach to search for the substring without using any built-in functions. By iterating over each possible starting index of the substring in the main string, we compare each character of the substring to the corresponding character in the main string. This approach ensures that we find the earliest occurrence of the substring in the main string.\n\nWhat's more, my solution comes with detailed explanations of the time and space complexity, so you can understand exactly how it works under the hood.\n\nSo if you're looking for a fast, efficient, and easy-to-understand solution to finding the index of the first occurrence of a substring in a string, check out my LeetCode solution today!"
                    },
                    {
                        "username": "Karan-Yadav",
                        "content": "same as index method in python 3"
                    },
                    {
                        "username": "hmtthakur",
                        "content": "IMPORTANT :\\nI have 2 codes for this problem both using KMP algo, only difference is in 1st I am using  charArray length in while loop condition and in 2nd I am using String length(). \\nRuntime : \\n1 : Beats 41% (1ms)\\n2 : Beats 100% (0ms)\\n\\nMy question : Is this expected that much of a difference because of length calculation?\\n\\nCodes : \\n1 :\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n        int[] kmp ;\\n        kmp = computeTemporaryArray(needle.toCharArray());\\n        int j = 0, i=0;\\n        while( i< haystack.length() && j < needle.length()){\\n            if(haystack.charAt(i) == needle.charAt(j)){\\n                j++;\\n                i++;\\n                continue;\\n\\n            }\\n            else {\\n                if(j>0)\\n                    j = kmp[j-1];\\n                else\\n                    i++;\\n            }\\n        }\\n\\n        if(j == needle.length()){\\n            return i - needle.length();\\n        }\\n        return -1;\\n    }\\n\\n    private int[] computeTemporaryArray(char[] pattern){\\n        int[] lps = new int[pattern.length];\\n        int index =0;\\n        for(int i=1; i < pattern.length;){\\n            if(pattern[i] == pattern[index]){\\n                lps[i] = index + 1;\\n                index++;\\n                i++;\\n            }else{\\n                if(index != 0){\\n                    index = lps[index-1];\\n                }else{\\n                    lps[i] =0;\\n                    i++;\\n                }\\n            }\\n        }\\n        return lps;\\n    }\\n}\\n\\n\\n2: \\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n        char[] hs = haystack.toCharArray();\\n        char[] ndl = needle.toCharArray();\\n        int[] kmp ;\\n        kmp = computeTemporaryArray(ndl);\\n        int j = 0, i=0;\\n        while( i< hs.length && j < ndl.length){\\n            if(haystack.charAt(i) == needle.charAt(j)){\\n                j++;\\n                i++;\\n                continue;\\n\\n            }\\n            else {\\n                if(j>0)\\n                    j = kmp[j-1];\\n                else\\n                    i++;\\n            }\\n        }\\n\\n        if(j == needle.length()){\\n            return i - needle.length();\\n        }\\n        return -1;\\n    }\\n\\n    private int[] computeTemporaryArray(char[] pattern){\\n        int[] lps = new int[pattern.length];\\n        int index =0;\\n        for(int i=1; i < pattern.length;){\\n            if(pattern[i] == pattern[index]){\\n                lps[i] = index + 1;\\n                index++;\\n                i++;\\n            }else{\\n                if(index != 0){\\n                    index = lps[index-1];\\n                }else{\\n                    lps[i] =0;\\n                    i++;\\n                }\\n            }\\n        }\\n        return lps;\\n    }\\n}\\n\\nPlease do reply anyone????"
                    }
                ]
            },
            {
                "id": 1832986,
                "content": [
                    {
                        "username": "ak_is_here",
                        "content": "Hey! \nCheck out my LeetCode solution, which beats 100% of C++ submissions! Hope it helps. https://leetcode.com/problems/find-the-index-of-the-first-occurrence-in-a-string/solutions/3309240/solution-without-builtin-functions-beats-100-c-with-time-and-space-complexity-explained/\n\nMy solution uses a simple and intuitive approach to search for the substring without using any built-in functions. By iterating over each possible starting index of the substring in the main string, we compare each character of the substring to the corresponding character in the main string. This approach ensures that we find the earliest occurrence of the substring in the main string.\n\nWhat's more, my solution comes with detailed explanations of the time and space complexity, so you can understand exactly how it works under the hood.\n\nSo if you're looking for a fast, efficient, and easy-to-understand solution to finding the index of the first occurrence of a substring in a string, check out my LeetCode solution today!"
                    },
                    {
                        "username": "zyusuke10",
                        "content": "Why do i get time exceeded with this code? \n\n`class Solution:\n\n    def strStr(self, haystack: str, needle: str) -> int:\n        if needle not in haystack:\n            return -1\n        i = 0\n        j = 0\n        while i < len(haystack) and j < len(needle):\n            if haystack[i] == needle[j]:\n                i+=1\n                j+=1\n            else:\n                i=+1\n                j=0\n        return i-j`"
                    },
                    {
                        "username": "calicojack42",
                        "content": "I get the feeling that most if not all of the one-line solutions using builtin functions are working against the spirit of the question. Instead, try to imagine how you\\'d build this procedure if that function didn\\'t exist."
                    },
                    {
                        "username": "priyanshrm",
                        "content": "hello there! can anyone of you help me get the time complexity of my solution (ima little confused)?\n\n        `list_i = []\n        for j in range(len(haystack)):\n            if haystack[j] == needle[0]:\n                list_i.append(j)\n        for i in list_i:\n            if i + len(needle) <= len(haystack):\n                if needle == haystack[i:i + len(needle)]:\n                    return i\n        return -1`\n\nlink: [Code/Solution](https://leetcode.com/problems/find-the-index-of-the-first-occurrence-in-a-string/solutions/3299481/beats-89-27-ms-runtime/)\nI am just using a list to store the indices of haystack which have needle's first letter in them. And then the usual of looping through that list and cross-check the strings. (to find any matches) "
                    },
                    {
                        "username": "Deecodes25",
                        "content": "Can anyone tell what is the Time Complexity of this solution - \n\n ```\ni=0\nj=len(needle)\nwhile j<=len(haystack):\n            if haystack[i:j] == needle:\n                return i\n            i+=1\n            j+=1\nreturn -1\n```"
                    },
                    {
                        "username": "Anshmehta380",
                        "content": "Simplest Problem:\\nJust return haystack.indexOf(needle);\\n0ms solution"
                    },
                    {
                        "username": "redocmi7",
                        "content": "A standard string problem. I solved it using map in c++.\\nStoring each substring of the length of the needle string and then at last checking if the map contains the required needle or not. Mapping has been done from the required string to the 1st index from where the substring starts."
                    },
                    {
                        "username": "jperrin36",
                        "content": "good news and bad news\\ngood news: i made a solution that passes\\nbad news:  it only beats 5% runtime kms"
                    },
                    {
                        "username": "ak_is_here",
                        "content": "Hey! \nCheck out my LeetCode solution, which beats 100% of C++ submissions! Hope it helps.https://leetcode.com/problems/find-the-index-of-the-first-occurrence-in-a-string/solutions/3309240/solution-without-builtin-functions-beats-100-c-with-time-and-space-complexity-explained/\n\nMy solution uses a simple and intuitive approach to search for the substring without using any built-in functions. By iterating over each possible starting index of the substring in the main string, we compare each character of the substring to the corresponding character in the main string. This approach ensures that we find the earliest occurrence of the substring in the main string.\n\nWhat's more, my solution comes with detailed explanations of the time and space complexity, so you can understand exactly how it works under the hood.\n\nSo if you're looking for a fast, efficient, and easy-to-understand solution to finding the index of the first occurrence of a substring in a string, check out my LeetCode solution today!"
                    },
                    {
                        "username": "Karan-Yadav",
                        "content": "same as index method in python 3"
                    },
                    {
                        "username": "hmtthakur",
                        "content": "IMPORTANT :\\nI have 2 codes for this problem both using KMP algo, only difference is in 1st I am using  charArray length in while loop condition and in 2nd I am using String length(). \\nRuntime : \\n1 : Beats 41% (1ms)\\n2 : Beats 100% (0ms)\\n\\nMy question : Is this expected that much of a difference because of length calculation?\\n\\nCodes : \\n1 :\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n        int[] kmp ;\\n        kmp = computeTemporaryArray(needle.toCharArray());\\n        int j = 0, i=0;\\n        while( i< haystack.length() && j < needle.length()){\\n            if(haystack.charAt(i) == needle.charAt(j)){\\n                j++;\\n                i++;\\n                continue;\\n\\n            }\\n            else {\\n                if(j>0)\\n                    j = kmp[j-1];\\n                else\\n                    i++;\\n            }\\n        }\\n\\n        if(j == needle.length()){\\n            return i - needle.length();\\n        }\\n        return -1;\\n    }\\n\\n    private int[] computeTemporaryArray(char[] pattern){\\n        int[] lps = new int[pattern.length];\\n        int index =0;\\n        for(int i=1; i < pattern.length;){\\n            if(pattern[i] == pattern[index]){\\n                lps[i] = index + 1;\\n                index++;\\n                i++;\\n            }else{\\n                if(index != 0){\\n                    index = lps[index-1];\\n                }else{\\n                    lps[i] =0;\\n                    i++;\\n                }\\n            }\\n        }\\n        return lps;\\n    }\\n}\\n\\n\\n2: \\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n        char[] hs = haystack.toCharArray();\\n        char[] ndl = needle.toCharArray();\\n        int[] kmp ;\\n        kmp = computeTemporaryArray(ndl);\\n        int j = 0, i=0;\\n        while( i< hs.length && j < ndl.length){\\n            if(haystack.charAt(i) == needle.charAt(j)){\\n                j++;\\n                i++;\\n                continue;\\n\\n            }\\n            else {\\n                if(j>0)\\n                    j = kmp[j-1];\\n                else\\n                    i++;\\n            }\\n        }\\n\\n        if(j == needle.length()){\\n            return i - needle.length();\\n        }\\n        return -1;\\n    }\\n\\n    private int[] computeTemporaryArray(char[] pattern){\\n        int[] lps = new int[pattern.length];\\n        int index =0;\\n        for(int i=1; i < pattern.length;){\\n            if(pattern[i] == pattern[index]){\\n                lps[i] = index + 1;\\n                index++;\\n                i++;\\n            }else{\\n                if(index != 0){\\n                    index = lps[index-1];\\n                }else{\\n                    lps[i] =0;\\n                    i++;\\n                }\\n            }\\n        }\\n        return lps;\\n    }\\n}\\n\\nPlease do reply anyone????"
                    }
                ]
            },
            {
                "id": 1830612,
                "content": [
                    {
                        "username": "ak_is_here",
                        "content": "Hey! \nCheck out my LeetCode solution, which beats 100% of C++ submissions! Hope it helps. https://leetcode.com/problems/find-the-index-of-the-first-occurrence-in-a-string/solutions/3309240/solution-without-builtin-functions-beats-100-c-with-time-and-space-complexity-explained/\n\nMy solution uses a simple and intuitive approach to search for the substring without using any built-in functions. By iterating over each possible starting index of the substring in the main string, we compare each character of the substring to the corresponding character in the main string. This approach ensures that we find the earliest occurrence of the substring in the main string.\n\nWhat's more, my solution comes with detailed explanations of the time and space complexity, so you can understand exactly how it works under the hood.\n\nSo if you're looking for a fast, efficient, and easy-to-understand solution to finding the index of the first occurrence of a substring in a string, check out my LeetCode solution today!"
                    },
                    {
                        "username": "zyusuke10",
                        "content": "Why do i get time exceeded with this code? \n\n`class Solution:\n\n    def strStr(self, haystack: str, needle: str) -> int:\n        if needle not in haystack:\n            return -1\n        i = 0\n        j = 0\n        while i < len(haystack) and j < len(needle):\n            if haystack[i] == needle[j]:\n                i+=1\n                j+=1\n            else:\n                i=+1\n                j=0\n        return i-j`"
                    },
                    {
                        "username": "calicojack42",
                        "content": "I get the feeling that most if not all of the one-line solutions using builtin functions are working against the spirit of the question. Instead, try to imagine how you\\'d build this procedure if that function didn\\'t exist."
                    },
                    {
                        "username": "priyanshrm",
                        "content": "hello there! can anyone of you help me get the time complexity of my solution (ima little confused)?\n\n        `list_i = []\n        for j in range(len(haystack)):\n            if haystack[j] == needle[0]:\n                list_i.append(j)\n        for i in list_i:\n            if i + len(needle) <= len(haystack):\n                if needle == haystack[i:i + len(needle)]:\n                    return i\n        return -1`\n\nlink: [Code/Solution](https://leetcode.com/problems/find-the-index-of-the-first-occurrence-in-a-string/solutions/3299481/beats-89-27-ms-runtime/)\nI am just using a list to store the indices of haystack which have needle's first letter in them. And then the usual of looping through that list and cross-check the strings. (to find any matches) "
                    },
                    {
                        "username": "Deecodes25",
                        "content": "Can anyone tell what is the Time Complexity of this solution - \n\n ```\ni=0\nj=len(needle)\nwhile j<=len(haystack):\n            if haystack[i:j] == needle:\n                return i\n            i+=1\n            j+=1\nreturn -1\n```"
                    },
                    {
                        "username": "Anshmehta380",
                        "content": "Simplest Problem:\\nJust return haystack.indexOf(needle);\\n0ms solution"
                    },
                    {
                        "username": "redocmi7",
                        "content": "A standard string problem. I solved it using map in c++.\\nStoring each substring of the length of the needle string and then at last checking if the map contains the required needle or not. Mapping has been done from the required string to the 1st index from where the substring starts."
                    },
                    {
                        "username": "jperrin36",
                        "content": "good news and bad news\\ngood news: i made a solution that passes\\nbad news:  it only beats 5% runtime kms"
                    },
                    {
                        "username": "ak_is_here",
                        "content": "Hey! \nCheck out my LeetCode solution, which beats 100% of C++ submissions! Hope it helps.https://leetcode.com/problems/find-the-index-of-the-first-occurrence-in-a-string/solutions/3309240/solution-without-builtin-functions-beats-100-c-with-time-and-space-complexity-explained/\n\nMy solution uses a simple and intuitive approach to search for the substring without using any built-in functions. By iterating over each possible starting index of the substring in the main string, we compare each character of the substring to the corresponding character in the main string. This approach ensures that we find the earliest occurrence of the substring in the main string.\n\nWhat's more, my solution comes with detailed explanations of the time and space complexity, so you can understand exactly how it works under the hood.\n\nSo if you're looking for a fast, efficient, and easy-to-understand solution to finding the index of the first occurrence of a substring in a string, check out my LeetCode solution today!"
                    },
                    {
                        "username": "Karan-Yadav",
                        "content": "same as index method in python 3"
                    },
                    {
                        "username": "hmtthakur",
                        "content": "IMPORTANT :\\nI have 2 codes for this problem both using KMP algo, only difference is in 1st I am using  charArray length in while loop condition and in 2nd I am using String length(). \\nRuntime : \\n1 : Beats 41% (1ms)\\n2 : Beats 100% (0ms)\\n\\nMy question : Is this expected that much of a difference because of length calculation?\\n\\nCodes : \\n1 :\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n        int[] kmp ;\\n        kmp = computeTemporaryArray(needle.toCharArray());\\n        int j = 0, i=0;\\n        while( i< haystack.length() && j < needle.length()){\\n            if(haystack.charAt(i) == needle.charAt(j)){\\n                j++;\\n                i++;\\n                continue;\\n\\n            }\\n            else {\\n                if(j>0)\\n                    j = kmp[j-1];\\n                else\\n                    i++;\\n            }\\n        }\\n\\n        if(j == needle.length()){\\n            return i - needle.length();\\n        }\\n        return -1;\\n    }\\n\\n    private int[] computeTemporaryArray(char[] pattern){\\n        int[] lps = new int[pattern.length];\\n        int index =0;\\n        for(int i=1; i < pattern.length;){\\n            if(pattern[i] == pattern[index]){\\n                lps[i] = index + 1;\\n                index++;\\n                i++;\\n            }else{\\n                if(index != 0){\\n                    index = lps[index-1];\\n                }else{\\n                    lps[i] =0;\\n                    i++;\\n                }\\n            }\\n        }\\n        return lps;\\n    }\\n}\\n\\n\\n2: \\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n        char[] hs = haystack.toCharArray();\\n        char[] ndl = needle.toCharArray();\\n        int[] kmp ;\\n        kmp = computeTemporaryArray(ndl);\\n        int j = 0, i=0;\\n        while( i< hs.length && j < ndl.length){\\n            if(haystack.charAt(i) == needle.charAt(j)){\\n                j++;\\n                i++;\\n                continue;\\n\\n            }\\n            else {\\n                if(j>0)\\n                    j = kmp[j-1];\\n                else\\n                    i++;\\n            }\\n        }\\n\\n        if(j == needle.length()){\\n            return i - needle.length();\\n        }\\n        return -1;\\n    }\\n\\n    private int[] computeTemporaryArray(char[] pattern){\\n        int[] lps = new int[pattern.length];\\n        int index =0;\\n        for(int i=1; i < pattern.length;){\\n            if(pattern[i] == pattern[index]){\\n                lps[i] = index + 1;\\n                index++;\\n                i++;\\n            }else{\\n                if(index != 0){\\n                    index = lps[index-1];\\n                }else{\\n                    lps[i] =0;\\n                    i++;\\n                }\\n            }\\n        }\\n        return lps;\\n    }\\n}\\n\\nPlease do reply anyone????"
                    }
                ]
            },
            {
                "id": 1827152,
                "content": [
                    {
                        "username": "ak_is_here",
                        "content": "Hey! \nCheck out my LeetCode solution, which beats 100% of C++ submissions! Hope it helps. https://leetcode.com/problems/find-the-index-of-the-first-occurrence-in-a-string/solutions/3309240/solution-without-builtin-functions-beats-100-c-with-time-and-space-complexity-explained/\n\nMy solution uses a simple and intuitive approach to search for the substring without using any built-in functions. By iterating over each possible starting index of the substring in the main string, we compare each character of the substring to the corresponding character in the main string. This approach ensures that we find the earliest occurrence of the substring in the main string.\n\nWhat's more, my solution comes with detailed explanations of the time and space complexity, so you can understand exactly how it works under the hood.\n\nSo if you're looking for a fast, efficient, and easy-to-understand solution to finding the index of the first occurrence of a substring in a string, check out my LeetCode solution today!"
                    },
                    {
                        "username": "zyusuke10",
                        "content": "Why do i get time exceeded with this code? \n\n`class Solution:\n\n    def strStr(self, haystack: str, needle: str) -> int:\n        if needle not in haystack:\n            return -1\n        i = 0\n        j = 0\n        while i < len(haystack) and j < len(needle):\n            if haystack[i] == needle[j]:\n                i+=1\n                j+=1\n            else:\n                i=+1\n                j=0\n        return i-j`"
                    },
                    {
                        "username": "calicojack42",
                        "content": "I get the feeling that most if not all of the one-line solutions using builtin functions are working against the spirit of the question. Instead, try to imagine how you\\'d build this procedure if that function didn\\'t exist."
                    },
                    {
                        "username": "priyanshrm",
                        "content": "hello there! can anyone of you help me get the time complexity of my solution (ima little confused)?\n\n        `list_i = []\n        for j in range(len(haystack)):\n            if haystack[j] == needle[0]:\n                list_i.append(j)\n        for i in list_i:\n            if i + len(needle) <= len(haystack):\n                if needle == haystack[i:i + len(needle)]:\n                    return i\n        return -1`\n\nlink: [Code/Solution](https://leetcode.com/problems/find-the-index-of-the-first-occurrence-in-a-string/solutions/3299481/beats-89-27-ms-runtime/)\nI am just using a list to store the indices of haystack which have needle's first letter in them. And then the usual of looping through that list and cross-check the strings. (to find any matches) "
                    },
                    {
                        "username": "Deecodes25",
                        "content": "Can anyone tell what is the Time Complexity of this solution - \n\n ```\ni=0\nj=len(needle)\nwhile j<=len(haystack):\n            if haystack[i:j] == needle:\n                return i\n            i+=1\n            j+=1\nreturn -1\n```"
                    },
                    {
                        "username": "Anshmehta380",
                        "content": "Simplest Problem:\\nJust return haystack.indexOf(needle);\\n0ms solution"
                    },
                    {
                        "username": "redocmi7",
                        "content": "A standard string problem. I solved it using map in c++.\\nStoring each substring of the length of the needle string and then at last checking if the map contains the required needle or not. Mapping has been done from the required string to the 1st index from where the substring starts."
                    },
                    {
                        "username": "jperrin36",
                        "content": "good news and bad news\\ngood news: i made a solution that passes\\nbad news:  it only beats 5% runtime kms"
                    },
                    {
                        "username": "ak_is_here",
                        "content": "Hey! \nCheck out my LeetCode solution, which beats 100% of C++ submissions! Hope it helps.https://leetcode.com/problems/find-the-index-of-the-first-occurrence-in-a-string/solutions/3309240/solution-without-builtin-functions-beats-100-c-with-time-and-space-complexity-explained/\n\nMy solution uses a simple and intuitive approach to search for the substring without using any built-in functions. By iterating over each possible starting index of the substring in the main string, we compare each character of the substring to the corresponding character in the main string. This approach ensures that we find the earliest occurrence of the substring in the main string.\n\nWhat's more, my solution comes with detailed explanations of the time and space complexity, so you can understand exactly how it works under the hood.\n\nSo if you're looking for a fast, efficient, and easy-to-understand solution to finding the index of the first occurrence of a substring in a string, check out my LeetCode solution today!"
                    },
                    {
                        "username": "Karan-Yadav",
                        "content": "same as index method in python 3"
                    },
                    {
                        "username": "hmtthakur",
                        "content": "IMPORTANT :\\nI have 2 codes for this problem both using KMP algo, only difference is in 1st I am using  charArray length in while loop condition and in 2nd I am using String length(). \\nRuntime : \\n1 : Beats 41% (1ms)\\n2 : Beats 100% (0ms)\\n\\nMy question : Is this expected that much of a difference because of length calculation?\\n\\nCodes : \\n1 :\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n        int[] kmp ;\\n        kmp = computeTemporaryArray(needle.toCharArray());\\n        int j = 0, i=0;\\n        while( i< haystack.length() && j < needle.length()){\\n            if(haystack.charAt(i) == needle.charAt(j)){\\n                j++;\\n                i++;\\n                continue;\\n\\n            }\\n            else {\\n                if(j>0)\\n                    j = kmp[j-1];\\n                else\\n                    i++;\\n            }\\n        }\\n\\n        if(j == needle.length()){\\n            return i - needle.length();\\n        }\\n        return -1;\\n    }\\n\\n    private int[] computeTemporaryArray(char[] pattern){\\n        int[] lps = new int[pattern.length];\\n        int index =0;\\n        for(int i=1; i < pattern.length;){\\n            if(pattern[i] == pattern[index]){\\n                lps[i] = index + 1;\\n                index++;\\n                i++;\\n            }else{\\n                if(index != 0){\\n                    index = lps[index-1];\\n                }else{\\n                    lps[i] =0;\\n                    i++;\\n                }\\n            }\\n        }\\n        return lps;\\n    }\\n}\\n\\n\\n2: \\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n        char[] hs = haystack.toCharArray();\\n        char[] ndl = needle.toCharArray();\\n        int[] kmp ;\\n        kmp = computeTemporaryArray(ndl);\\n        int j = 0, i=0;\\n        while( i< hs.length && j < ndl.length){\\n            if(haystack.charAt(i) == needle.charAt(j)){\\n                j++;\\n                i++;\\n                continue;\\n\\n            }\\n            else {\\n                if(j>0)\\n                    j = kmp[j-1];\\n                else\\n                    i++;\\n            }\\n        }\\n\\n        if(j == needle.length()){\\n            return i - needle.length();\\n        }\\n        return -1;\\n    }\\n\\n    private int[] computeTemporaryArray(char[] pattern){\\n        int[] lps = new int[pattern.length];\\n        int index =0;\\n        for(int i=1; i < pattern.length;){\\n            if(pattern[i] == pattern[index]){\\n                lps[i] = index + 1;\\n                index++;\\n                i++;\\n            }else{\\n                if(index != 0){\\n                    index = lps[index-1];\\n                }else{\\n                    lps[i] =0;\\n                    i++;\\n                }\\n            }\\n        }\\n        return lps;\\n    }\\n}\\n\\nPlease do reply anyone????"
                    }
                ]
            },
            {
                "id": 1820839,
                "content": [
                    {
                        "username": "ak_is_here",
                        "content": "Hey! \nCheck out my LeetCode solution, which beats 100% of C++ submissions! Hope it helps. https://leetcode.com/problems/find-the-index-of-the-first-occurrence-in-a-string/solutions/3309240/solution-without-builtin-functions-beats-100-c-with-time-and-space-complexity-explained/\n\nMy solution uses a simple and intuitive approach to search for the substring without using any built-in functions. By iterating over each possible starting index of the substring in the main string, we compare each character of the substring to the corresponding character in the main string. This approach ensures that we find the earliest occurrence of the substring in the main string.\n\nWhat's more, my solution comes with detailed explanations of the time and space complexity, so you can understand exactly how it works under the hood.\n\nSo if you're looking for a fast, efficient, and easy-to-understand solution to finding the index of the first occurrence of a substring in a string, check out my LeetCode solution today!"
                    },
                    {
                        "username": "zyusuke10",
                        "content": "Why do i get time exceeded with this code? \n\n`class Solution:\n\n    def strStr(self, haystack: str, needle: str) -> int:\n        if needle not in haystack:\n            return -1\n        i = 0\n        j = 0\n        while i < len(haystack) and j < len(needle):\n            if haystack[i] == needle[j]:\n                i+=1\n                j+=1\n            else:\n                i=+1\n                j=0\n        return i-j`"
                    },
                    {
                        "username": "calicojack42",
                        "content": "I get the feeling that most if not all of the one-line solutions using builtin functions are working against the spirit of the question. Instead, try to imagine how you\\'d build this procedure if that function didn\\'t exist."
                    },
                    {
                        "username": "priyanshrm",
                        "content": "hello there! can anyone of you help me get the time complexity of my solution (ima little confused)?\n\n        `list_i = []\n        for j in range(len(haystack)):\n            if haystack[j] == needle[0]:\n                list_i.append(j)\n        for i in list_i:\n            if i + len(needle) <= len(haystack):\n                if needle == haystack[i:i + len(needle)]:\n                    return i\n        return -1`\n\nlink: [Code/Solution](https://leetcode.com/problems/find-the-index-of-the-first-occurrence-in-a-string/solutions/3299481/beats-89-27-ms-runtime/)\nI am just using a list to store the indices of haystack which have needle's first letter in them. And then the usual of looping through that list and cross-check the strings. (to find any matches) "
                    },
                    {
                        "username": "Deecodes25",
                        "content": "Can anyone tell what is the Time Complexity of this solution - \n\n ```\ni=0\nj=len(needle)\nwhile j<=len(haystack):\n            if haystack[i:j] == needle:\n                return i\n            i+=1\n            j+=1\nreturn -1\n```"
                    },
                    {
                        "username": "Anshmehta380",
                        "content": "Simplest Problem:\\nJust return haystack.indexOf(needle);\\n0ms solution"
                    },
                    {
                        "username": "redocmi7",
                        "content": "A standard string problem. I solved it using map in c++.\\nStoring each substring of the length of the needle string and then at last checking if the map contains the required needle or not. Mapping has been done from the required string to the 1st index from where the substring starts."
                    },
                    {
                        "username": "jperrin36",
                        "content": "good news and bad news\\ngood news: i made a solution that passes\\nbad news:  it only beats 5% runtime kms"
                    },
                    {
                        "username": "ak_is_here",
                        "content": "Hey! \nCheck out my LeetCode solution, which beats 100% of C++ submissions! Hope it helps.https://leetcode.com/problems/find-the-index-of-the-first-occurrence-in-a-string/solutions/3309240/solution-without-builtin-functions-beats-100-c-with-time-and-space-complexity-explained/\n\nMy solution uses a simple and intuitive approach to search for the substring without using any built-in functions. By iterating over each possible starting index of the substring in the main string, we compare each character of the substring to the corresponding character in the main string. This approach ensures that we find the earliest occurrence of the substring in the main string.\n\nWhat's more, my solution comes with detailed explanations of the time and space complexity, so you can understand exactly how it works under the hood.\n\nSo if you're looking for a fast, efficient, and easy-to-understand solution to finding the index of the first occurrence of a substring in a string, check out my LeetCode solution today!"
                    },
                    {
                        "username": "Karan-Yadav",
                        "content": "same as index method in python 3"
                    },
                    {
                        "username": "hmtthakur",
                        "content": "IMPORTANT :\\nI have 2 codes for this problem both using KMP algo, only difference is in 1st I am using  charArray length in while loop condition and in 2nd I am using String length(). \\nRuntime : \\n1 : Beats 41% (1ms)\\n2 : Beats 100% (0ms)\\n\\nMy question : Is this expected that much of a difference because of length calculation?\\n\\nCodes : \\n1 :\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n        int[] kmp ;\\n        kmp = computeTemporaryArray(needle.toCharArray());\\n        int j = 0, i=0;\\n        while( i< haystack.length() && j < needle.length()){\\n            if(haystack.charAt(i) == needle.charAt(j)){\\n                j++;\\n                i++;\\n                continue;\\n\\n            }\\n            else {\\n                if(j>0)\\n                    j = kmp[j-1];\\n                else\\n                    i++;\\n            }\\n        }\\n\\n        if(j == needle.length()){\\n            return i - needle.length();\\n        }\\n        return -1;\\n    }\\n\\n    private int[] computeTemporaryArray(char[] pattern){\\n        int[] lps = new int[pattern.length];\\n        int index =0;\\n        for(int i=1; i < pattern.length;){\\n            if(pattern[i] == pattern[index]){\\n                lps[i] = index + 1;\\n                index++;\\n                i++;\\n            }else{\\n                if(index != 0){\\n                    index = lps[index-1];\\n                }else{\\n                    lps[i] =0;\\n                    i++;\\n                }\\n            }\\n        }\\n        return lps;\\n    }\\n}\\n\\n\\n2: \\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n        char[] hs = haystack.toCharArray();\\n        char[] ndl = needle.toCharArray();\\n        int[] kmp ;\\n        kmp = computeTemporaryArray(ndl);\\n        int j = 0, i=0;\\n        while( i< hs.length && j < ndl.length){\\n            if(haystack.charAt(i) == needle.charAt(j)){\\n                j++;\\n                i++;\\n                continue;\\n\\n            }\\n            else {\\n                if(j>0)\\n                    j = kmp[j-1];\\n                else\\n                    i++;\\n            }\\n        }\\n\\n        if(j == needle.length()){\\n            return i - needle.length();\\n        }\\n        return -1;\\n    }\\n\\n    private int[] computeTemporaryArray(char[] pattern){\\n        int[] lps = new int[pattern.length];\\n        int index =0;\\n        for(int i=1; i < pattern.length;){\\n            if(pattern[i] == pattern[index]){\\n                lps[i] = index + 1;\\n                index++;\\n                i++;\\n            }else{\\n                if(index != 0){\\n                    index = lps[index-1];\\n                }else{\\n                    lps[i] =0;\\n                    i++;\\n                }\\n            }\\n        }\\n        return lps;\\n    }\\n}\\n\\nPlease do reply anyone????"
                    }
                ]
            },
            {
                "id": 1820720,
                "content": [
                    {
                        "username": "ak_is_here",
                        "content": "Hey! \nCheck out my LeetCode solution, which beats 100% of C++ submissions! Hope it helps. https://leetcode.com/problems/find-the-index-of-the-first-occurrence-in-a-string/solutions/3309240/solution-without-builtin-functions-beats-100-c-with-time-and-space-complexity-explained/\n\nMy solution uses a simple and intuitive approach to search for the substring without using any built-in functions. By iterating over each possible starting index of the substring in the main string, we compare each character of the substring to the corresponding character in the main string. This approach ensures that we find the earliest occurrence of the substring in the main string.\n\nWhat's more, my solution comes with detailed explanations of the time and space complexity, so you can understand exactly how it works under the hood.\n\nSo if you're looking for a fast, efficient, and easy-to-understand solution to finding the index of the first occurrence of a substring in a string, check out my LeetCode solution today!"
                    },
                    {
                        "username": "zyusuke10",
                        "content": "Why do i get time exceeded with this code? \n\n`class Solution:\n\n    def strStr(self, haystack: str, needle: str) -> int:\n        if needle not in haystack:\n            return -1\n        i = 0\n        j = 0\n        while i < len(haystack) and j < len(needle):\n            if haystack[i] == needle[j]:\n                i+=1\n                j+=1\n            else:\n                i=+1\n                j=0\n        return i-j`"
                    },
                    {
                        "username": "calicojack42",
                        "content": "I get the feeling that most if not all of the one-line solutions using builtin functions are working against the spirit of the question. Instead, try to imagine how you\\'d build this procedure if that function didn\\'t exist."
                    },
                    {
                        "username": "priyanshrm",
                        "content": "hello there! can anyone of you help me get the time complexity of my solution (ima little confused)?\n\n        `list_i = []\n        for j in range(len(haystack)):\n            if haystack[j] == needle[0]:\n                list_i.append(j)\n        for i in list_i:\n            if i + len(needle) <= len(haystack):\n                if needle == haystack[i:i + len(needle)]:\n                    return i\n        return -1`\n\nlink: [Code/Solution](https://leetcode.com/problems/find-the-index-of-the-first-occurrence-in-a-string/solutions/3299481/beats-89-27-ms-runtime/)\nI am just using a list to store the indices of haystack which have needle's first letter in them. And then the usual of looping through that list and cross-check the strings. (to find any matches) "
                    },
                    {
                        "username": "Deecodes25",
                        "content": "Can anyone tell what is the Time Complexity of this solution - \n\n ```\ni=0\nj=len(needle)\nwhile j<=len(haystack):\n            if haystack[i:j] == needle:\n                return i\n            i+=1\n            j+=1\nreturn -1\n```"
                    },
                    {
                        "username": "Anshmehta380",
                        "content": "Simplest Problem:\\nJust return haystack.indexOf(needle);\\n0ms solution"
                    },
                    {
                        "username": "redocmi7",
                        "content": "A standard string problem. I solved it using map in c++.\\nStoring each substring of the length of the needle string and then at last checking if the map contains the required needle or not. Mapping has been done from the required string to the 1st index from where the substring starts."
                    },
                    {
                        "username": "jperrin36",
                        "content": "good news and bad news\\ngood news: i made a solution that passes\\nbad news:  it only beats 5% runtime kms"
                    },
                    {
                        "username": "ak_is_here",
                        "content": "Hey! \nCheck out my LeetCode solution, which beats 100% of C++ submissions! Hope it helps.https://leetcode.com/problems/find-the-index-of-the-first-occurrence-in-a-string/solutions/3309240/solution-without-builtin-functions-beats-100-c-with-time-and-space-complexity-explained/\n\nMy solution uses a simple and intuitive approach to search for the substring without using any built-in functions. By iterating over each possible starting index of the substring in the main string, we compare each character of the substring to the corresponding character in the main string. This approach ensures that we find the earliest occurrence of the substring in the main string.\n\nWhat's more, my solution comes with detailed explanations of the time and space complexity, so you can understand exactly how it works under the hood.\n\nSo if you're looking for a fast, efficient, and easy-to-understand solution to finding the index of the first occurrence of a substring in a string, check out my LeetCode solution today!"
                    },
                    {
                        "username": "Karan-Yadav",
                        "content": "same as index method in python 3"
                    },
                    {
                        "username": "hmtthakur",
                        "content": "IMPORTANT :\\nI have 2 codes for this problem both using KMP algo, only difference is in 1st I am using  charArray length in while loop condition and in 2nd I am using String length(). \\nRuntime : \\n1 : Beats 41% (1ms)\\n2 : Beats 100% (0ms)\\n\\nMy question : Is this expected that much of a difference because of length calculation?\\n\\nCodes : \\n1 :\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n        int[] kmp ;\\n        kmp = computeTemporaryArray(needle.toCharArray());\\n        int j = 0, i=0;\\n        while( i< haystack.length() && j < needle.length()){\\n            if(haystack.charAt(i) == needle.charAt(j)){\\n                j++;\\n                i++;\\n                continue;\\n\\n            }\\n            else {\\n                if(j>0)\\n                    j = kmp[j-1];\\n                else\\n                    i++;\\n            }\\n        }\\n\\n        if(j == needle.length()){\\n            return i - needle.length();\\n        }\\n        return -1;\\n    }\\n\\n    private int[] computeTemporaryArray(char[] pattern){\\n        int[] lps = new int[pattern.length];\\n        int index =0;\\n        for(int i=1; i < pattern.length;){\\n            if(pattern[i] == pattern[index]){\\n                lps[i] = index + 1;\\n                index++;\\n                i++;\\n            }else{\\n                if(index != 0){\\n                    index = lps[index-1];\\n                }else{\\n                    lps[i] =0;\\n                    i++;\\n                }\\n            }\\n        }\\n        return lps;\\n    }\\n}\\n\\n\\n2: \\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n        char[] hs = haystack.toCharArray();\\n        char[] ndl = needle.toCharArray();\\n        int[] kmp ;\\n        kmp = computeTemporaryArray(ndl);\\n        int j = 0, i=0;\\n        while( i< hs.length && j < ndl.length){\\n            if(haystack.charAt(i) == needle.charAt(j)){\\n                j++;\\n                i++;\\n                continue;\\n\\n            }\\n            else {\\n                if(j>0)\\n                    j = kmp[j-1];\\n                else\\n                    i++;\\n            }\\n        }\\n\\n        if(j == needle.length()){\\n            return i - needle.length();\\n        }\\n        return -1;\\n    }\\n\\n    private int[] computeTemporaryArray(char[] pattern){\\n        int[] lps = new int[pattern.length];\\n        int index =0;\\n        for(int i=1; i < pattern.length;){\\n            if(pattern[i] == pattern[index]){\\n                lps[i] = index + 1;\\n                index++;\\n                i++;\\n            }else{\\n                if(index != 0){\\n                    index = lps[index-1];\\n                }else{\\n                    lps[i] =0;\\n                    i++;\\n                }\\n            }\\n        }\\n        return lps;\\n    }\\n}\\n\\nPlease do reply anyone????"
                    }
                ]
            },
            {
                "id": 1820718,
                "content": [
                    {
                        "username": "ak_is_here",
                        "content": "Hey! \nCheck out my LeetCode solution, which beats 100% of C++ submissions! Hope it helps. https://leetcode.com/problems/find-the-index-of-the-first-occurrence-in-a-string/solutions/3309240/solution-without-builtin-functions-beats-100-c-with-time-and-space-complexity-explained/\n\nMy solution uses a simple and intuitive approach to search for the substring without using any built-in functions. By iterating over each possible starting index of the substring in the main string, we compare each character of the substring to the corresponding character in the main string. This approach ensures that we find the earliest occurrence of the substring in the main string.\n\nWhat's more, my solution comes with detailed explanations of the time and space complexity, so you can understand exactly how it works under the hood.\n\nSo if you're looking for a fast, efficient, and easy-to-understand solution to finding the index of the first occurrence of a substring in a string, check out my LeetCode solution today!"
                    },
                    {
                        "username": "zyusuke10",
                        "content": "Why do i get time exceeded with this code? \n\n`class Solution:\n\n    def strStr(self, haystack: str, needle: str) -> int:\n        if needle not in haystack:\n            return -1\n        i = 0\n        j = 0\n        while i < len(haystack) and j < len(needle):\n            if haystack[i] == needle[j]:\n                i+=1\n                j+=1\n            else:\n                i=+1\n                j=0\n        return i-j`"
                    },
                    {
                        "username": "calicojack42",
                        "content": "I get the feeling that most if not all of the one-line solutions using builtin functions are working against the spirit of the question. Instead, try to imagine how you\\'d build this procedure if that function didn\\'t exist."
                    },
                    {
                        "username": "priyanshrm",
                        "content": "hello there! can anyone of you help me get the time complexity of my solution (ima little confused)?\n\n        `list_i = []\n        for j in range(len(haystack)):\n            if haystack[j] == needle[0]:\n                list_i.append(j)\n        for i in list_i:\n            if i + len(needle) <= len(haystack):\n                if needle == haystack[i:i + len(needle)]:\n                    return i\n        return -1`\n\nlink: [Code/Solution](https://leetcode.com/problems/find-the-index-of-the-first-occurrence-in-a-string/solutions/3299481/beats-89-27-ms-runtime/)\nI am just using a list to store the indices of haystack which have needle's first letter in them. And then the usual of looping through that list and cross-check the strings. (to find any matches) "
                    },
                    {
                        "username": "Deecodes25",
                        "content": "Can anyone tell what is the Time Complexity of this solution - \n\n ```\ni=0\nj=len(needle)\nwhile j<=len(haystack):\n            if haystack[i:j] == needle:\n                return i\n            i+=1\n            j+=1\nreturn -1\n```"
                    },
                    {
                        "username": "Anshmehta380",
                        "content": "Simplest Problem:\\nJust return haystack.indexOf(needle);\\n0ms solution"
                    },
                    {
                        "username": "redocmi7",
                        "content": "A standard string problem. I solved it using map in c++.\\nStoring each substring of the length of the needle string and then at last checking if the map contains the required needle or not. Mapping has been done from the required string to the 1st index from where the substring starts."
                    },
                    {
                        "username": "jperrin36",
                        "content": "good news and bad news\\ngood news: i made a solution that passes\\nbad news:  it only beats 5% runtime kms"
                    },
                    {
                        "username": "ak_is_here",
                        "content": "Hey! \nCheck out my LeetCode solution, which beats 100% of C++ submissions! Hope it helps.https://leetcode.com/problems/find-the-index-of-the-first-occurrence-in-a-string/solutions/3309240/solution-without-builtin-functions-beats-100-c-with-time-and-space-complexity-explained/\n\nMy solution uses a simple and intuitive approach to search for the substring without using any built-in functions. By iterating over each possible starting index of the substring in the main string, we compare each character of the substring to the corresponding character in the main string. This approach ensures that we find the earliest occurrence of the substring in the main string.\n\nWhat's more, my solution comes with detailed explanations of the time and space complexity, so you can understand exactly how it works under the hood.\n\nSo if you're looking for a fast, efficient, and easy-to-understand solution to finding the index of the first occurrence of a substring in a string, check out my LeetCode solution today!"
                    },
                    {
                        "username": "Karan-Yadav",
                        "content": "same as index method in python 3"
                    },
                    {
                        "username": "hmtthakur",
                        "content": "IMPORTANT :\\nI have 2 codes for this problem both using KMP algo, only difference is in 1st I am using  charArray length in while loop condition and in 2nd I am using String length(). \\nRuntime : \\n1 : Beats 41% (1ms)\\n2 : Beats 100% (0ms)\\n\\nMy question : Is this expected that much of a difference because of length calculation?\\n\\nCodes : \\n1 :\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n        int[] kmp ;\\n        kmp = computeTemporaryArray(needle.toCharArray());\\n        int j = 0, i=0;\\n        while( i< haystack.length() && j < needle.length()){\\n            if(haystack.charAt(i) == needle.charAt(j)){\\n                j++;\\n                i++;\\n                continue;\\n\\n            }\\n            else {\\n                if(j>0)\\n                    j = kmp[j-1];\\n                else\\n                    i++;\\n            }\\n        }\\n\\n        if(j == needle.length()){\\n            return i - needle.length();\\n        }\\n        return -1;\\n    }\\n\\n    private int[] computeTemporaryArray(char[] pattern){\\n        int[] lps = new int[pattern.length];\\n        int index =0;\\n        for(int i=1; i < pattern.length;){\\n            if(pattern[i] == pattern[index]){\\n                lps[i] = index + 1;\\n                index++;\\n                i++;\\n            }else{\\n                if(index != 0){\\n                    index = lps[index-1];\\n                }else{\\n                    lps[i] =0;\\n                    i++;\\n                }\\n            }\\n        }\\n        return lps;\\n    }\\n}\\n\\n\\n2: \\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n        char[] hs = haystack.toCharArray();\\n        char[] ndl = needle.toCharArray();\\n        int[] kmp ;\\n        kmp = computeTemporaryArray(ndl);\\n        int j = 0, i=0;\\n        while( i< hs.length && j < ndl.length){\\n            if(haystack.charAt(i) == needle.charAt(j)){\\n                j++;\\n                i++;\\n                continue;\\n\\n            }\\n            else {\\n                if(j>0)\\n                    j = kmp[j-1];\\n                else\\n                    i++;\\n            }\\n        }\\n\\n        if(j == needle.length()){\\n            return i - needle.length();\\n        }\\n        return -1;\\n    }\\n\\n    private int[] computeTemporaryArray(char[] pattern){\\n        int[] lps = new int[pattern.length];\\n        int index =0;\\n        for(int i=1; i < pattern.length;){\\n            if(pattern[i] == pattern[index]){\\n                lps[i] = index + 1;\\n                index++;\\n                i++;\\n            }else{\\n                if(index != 0){\\n                    index = lps[index-1];\\n                }else{\\n                    lps[i] =0;\\n                    i++;\\n                }\\n            }\\n        }\\n        return lps;\\n    }\\n}\\n\\nPlease do reply anyone????"
                    }
                ]
            },
            {
                "id": 1820711,
                "content": [
                    {
                        "username": "ak_is_here",
                        "content": "Hey! \nCheck out my LeetCode solution, which beats 100% of C++ submissions! Hope it helps. https://leetcode.com/problems/find-the-index-of-the-first-occurrence-in-a-string/solutions/3309240/solution-without-builtin-functions-beats-100-c-with-time-and-space-complexity-explained/\n\nMy solution uses a simple and intuitive approach to search for the substring without using any built-in functions. By iterating over each possible starting index of the substring in the main string, we compare each character of the substring to the corresponding character in the main string. This approach ensures that we find the earliest occurrence of the substring in the main string.\n\nWhat's more, my solution comes with detailed explanations of the time and space complexity, so you can understand exactly how it works under the hood.\n\nSo if you're looking for a fast, efficient, and easy-to-understand solution to finding the index of the first occurrence of a substring in a string, check out my LeetCode solution today!"
                    },
                    {
                        "username": "zyusuke10",
                        "content": "Why do i get time exceeded with this code? \n\n`class Solution:\n\n    def strStr(self, haystack: str, needle: str) -> int:\n        if needle not in haystack:\n            return -1\n        i = 0\n        j = 0\n        while i < len(haystack) and j < len(needle):\n            if haystack[i] == needle[j]:\n                i+=1\n                j+=1\n            else:\n                i=+1\n                j=0\n        return i-j`"
                    },
                    {
                        "username": "calicojack42",
                        "content": "I get the feeling that most if not all of the one-line solutions using builtin functions are working against the spirit of the question. Instead, try to imagine how you\\'d build this procedure if that function didn\\'t exist."
                    },
                    {
                        "username": "priyanshrm",
                        "content": "hello there! can anyone of you help me get the time complexity of my solution (ima little confused)?\n\n        `list_i = []\n        for j in range(len(haystack)):\n            if haystack[j] == needle[0]:\n                list_i.append(j)\n        for i in list_i:\n            if i + len(needle) <= len(haystack):\n                if needle == haystack[i:i + len(needle)]:\n                    return i\n        return -1`\n\nlink: [Code/Solution](https://leetcode.com/problems/find-the-index-of-the-first-occurrence-in-a-string/solutions/3299481/beats-89-27-ms-runtime/)\nI am just using a list to store the indices of haystack which have needle's first letter in them. And then the usual of looping through that list and cross-check the strings. (to find any matches) "
                    },
                    {
                        "username": "Deecodes25",
                        "content": "Can anyone tell what is the Time Complexity of this solution - \n\n ```\ni=0\nj=len(needle)\nwhile j<=len(haystack):\n            if haystack[i:j] == needle:\n                return i\n            i+=1\n            j+=1\nreturn -1\n```"
                    },
                    {
                        "username": "Anshmehta380",
                        "content": "Simplest Problem:\\nJust return haystack.indexOf(needle);\\n0ms solution"
                    },
                    {
                        "username": "redocmi7",
                        "content": "A standard string problem. I solved it using map in c++.\\nStoring each substring of the length of the needle string and then at last checking if the map contains the required needle or not. Mapping has been done from the required string to the 1st index from where the substring starts."
                    },
                    {
                        "username": "jperrin36",
                        "content": "good news and bad news\\ngood news: i made a solution that passes\\nbad news:  it only beats 5% runtime kms"
                    },
                    {
                        "username": "ak_is_here",
                        "content": "Hey! \nCheck out my LeetCode solution, which beats 100% of C++ submissions! Hope it helps.https://leetcode.com/problems/find-the-index-of-the-first-occurrence-in-a-string/solutions/3309240/solution-without-builtin-functions-beats-100-c-with-time-and-space-complexity-explained/\n\nMy solution uses a simple and intuitive approach to search for the substring without using any built-in functions. By iterating over each possible starting index of the substring in the main string, we compare each character of the substring to the corresponding character in the main string. This approach ensures that we find the earliest occurrence of the substring in the main string.\n\nWhat's more, my solution comes with detailed explanations of the time and space complexity, so you can understand exactly how it works under the hood.\n\nSo if you're looking for a fast, efficient, and easy-to-understand solution to finding the index of the first occurrence of a substring in a string, check out my LeetCode solution today!"
                    },
                    {
                        "username": "Karan-Yadav",
                        "content": "same as index method in python 3"
                    },
                    {
                        "username": "hmtthakur",
                        "content": "IMPORTANT :\\nI have 2 codes for this problem both using KMP algo, only difference is in 1st I am using  charArray length in while loop condition and in 2nd I am using String length(). \\nRuntime : \\n1 : Beats 41% (1ms)\\n2 : Beats 100% (0ms)\\n\\nMy question : Is this expected that much of a difference because of length calculation?\\n\\nCodes : \\n1 :\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n        int[] kmp ;\\n        kmp = computeTemporaryArray(needle.toCharArray());\\n        int j = 0, i=0;\\n        while( i< haystack.length() && j < needle.length()){\\n            if(haystack.charAt(i) == needle.charAt(j)){\\n                j++;\\n                i++;\\n                continue;\\n\\n            }\\n            else {\\n                if(j>0)\\n                    j = kmp[j-1];\\n                else\\n                    i++;\\n            }\\n        }\\n\\n        if(j == needle.length()){\\n            return i - needle.length();\\n        }\\n        return -1;\\n    }\\n\\n    private int[] computeTemporaryArray(char[] pattern){\\n        int[] lps = new int[pattern.length];\\n        int index =0;\\n        for(int i=1; i < pattern.length;){\\n            if(pattern[i] == pattern[index]){\\n                lps[i] = index + 1;\\n                index++;\\n                i++;\\n            }else{\\n                if(index != 0){\\n                    index = lps[index-1];\\n                }else{\\n                    lps[i] =0;\\n                    i++;\\n                }\\n            }\\n        }\\n        return lps;\\n    }\\n}\\n\\n\\n2: \\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n        char[] hs = haystack.toCharArray();\\n        char[] ndl = needle.toCharArray();\\n        int[] kmp ;\\n        kmp = computeTemporaryArray(ndl);\\n        int j = 0, i=0;\\n        while( i< hs.length && j < ndl.length){\\n            if(haystack.charAt(i) == needle.charAt(j)){\\n                j++;\\n                i++;\\n                continue;\\n\\n            }\\n            else {\\n                if(j>0)\\n                    j = kmp[j-1];\\n                else\\n                    i++;\\n            }\\n        }\\n\\n        if(j == needle.length()){\\n            return i - needle.length();\\n        }\\n        return -1;\\n    }\\n\\n    private int[] computeTemporaryArray(char[] pattern){\\n        int[] lps = new int[pattern.length];\\n        int index =0;\\n        for(int i=1; i < pattern.length;){\\n            if(pattern[i] == pattern[index]){\\n                lps[i] = index + 1;\\n                index++;\\n                i++;\\n            }else{\\n                if(index != 0){\\n                    index = lps[index-1];\\n                }else{\\n                    lps[i] =0;\\n                    i++;\\n                }\\n            }\\n        }\\n        return lps;\\n    }\\n}\\n\\nPlease do reply anyone????"
                    }
                ]
            },
            {
                "id": 1820630,
                "content": [
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "It is must one for starting with strings and getting a vibe on to the strings."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "what\\'s your say on this\\n"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "what is this problem is for ?"
                    },
                    {
                        "username": "charonme",
                        "content": "the naive O(n^2) solution is now accepted without TLE, no need for KMP"
                    },
                    {
                        "username": "MohitAhlawat",
                        "content": "hint is window of needle"
                    },
                    {
                        "username": "shaloba",
                        "content": "The challenge is to write this without using built in functions, i have succeeded to solve this in O(nlog(n)) while n is the length of haystack"
                    },
                    {
                        "username": "ketansarna",
                        "content": "this question used to be marked as easy lol\\n\\n\\n"
                    },
                    {
                        "username": "space_invader",
                        "content": "Wait, what? Is it a medium?"
                    },
                    {
                        "username": "aitachii",
                        "content": "I think the problem description should mention  that using built-in functions are not allowed or the time complexity should be O(m + n)."
                    },
                    {
                        "username": "AnandBawa",
                        "content": "\"Medium\" with one line solution. LC can be confusing."
                    },
                    {
                        "username": "charonme",
                        "content": "this https://leetcode.com/problems/edit-distance/ also has a one line solution if you use a built-in function"
                    },
                    {
                        "username": "harshitisback",
                        "content": "```\nStringBuffer sb = new StringBuffer(haystack);\n        return sb.indexOf(needle,0);\n```\n\nI solved this question with these two lines and surprised why medium level but what the matter even i solved it by two lines it can't give me satisfaction specially when it is a medium level problem it is same as don't use library they just missed this part like they did in sorting problem "
                    }
                ]
            },
            {
                "id": 1820505,
                "content": [
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "It is must one for starting with strings and getting a vibe on to the strings."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "what\\'s your say on this\\n"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "what is this problem is for ?"
                    },
                    {
                        "username": "charonme",
                        "content": "the naive O(n^2) solution is now accepted without TLE, no need for KMP"
                    },
                    {
                        "username": "MohitAhlawat",
                        "content": "hint is window of needle"
                    },
                    {
                        "username": "shaloba",
                        "content": "The challenge is to write this without using built in functions, i have succeeded to solve this in O(nlog(n)) while n is the length of haystack"
                    },
                    {
                        "username": "ketansarna",
                        "content": "this question used to be marked as easy lol\\n\\n\\n"
                    },
                    {
                        "username": "space_invader",
                        "content": "Wait, what? Is it a medium?"
                    },
                    {
                        "username": "aitachii",
                        "content": "I think the problem description should mention  that using built-in functions are not allowed or the time complexity should be O(m + n)."
                    },
                    {
                        "username": "AnandBawa",
                        "content": "\"Medium\" with one line solution. LC can be confusing."
                    },
                    {
                        "username": "charonme",
                        "content": "this https://leetcode.com/problems/edit-distance/ also has a one line solution if you use a built-in function"
                    },
                    {
                        "username": "harshitisback",
                        "content": "```\nStringBuffer sb = new StringBuffer(haystack);\n        return sb.indexOf(needle,0);\n```\n\nI solved this question with these two lines and surprised why medium level but what the matter even i solved it by two lines it can't give me satisfaction specially when it is a medium level problem it is same as don't use library they just missed this part like they did in sorting problem "
                    }
                ]
            },
            {
                "id": 1820479,
                "content": [
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "It is must one for starting with strings and getting a vibe on to the strings."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "what\\'s your say on this\\n"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "what is this problem is for ?"
                    },
                    {
                        "username": "charonme",
                        "content": "the naive O(n^2) solution is now accepted without TLE, no need for KMP"
                    },
                    {
                        "username": "MohitAhlawat",
                        "content": "hint is window of needle"
                    },
                    {
                        "username": "shaloba",
                        "content": "The challenge is to write this without using built in functions, i have succeeded to solve this in O(nlog(n)) while n is the length of haystack"
                    },
                    {
                        "username": "ketansarna",
                        "content": "this question used to be marked as easy lol\\n\\n\\n"
                    },
                    {
                        "username": "space_invader",
                        "content": "Wait, what? Is it a medium?"
                    },
                    {
                        "username": "aitachii",
                        "content": "I think the problem description should mention  that using built-in functions are not allowed or the time complexity should be O(m + n)."
                    },
                    {
                        "username": "AnandBawa",
                        "content": "\"Medium\" with one line solution. LC can be confusing."
                    },
                    {
                        "username": "charonme",
                        "content": "this https://leetcode.com/problems/edit-distance/ also has a one line solution if you use a built-in function"
                    },
                    {
                        "username": "harshitisback",
                        "content": "```\nStringBuffer sb = new StringBuffer(haystack);\n        return sb.indexOf(needle,0);\n```\n\nI solved this question with these two lines and surprised why medium level but what the matter even i solved it by two lines it can't give me satisfaction specially when it is a medium level problem it is same as don't use library they just missed this part like they did in sorting problem "
                    }
                ]
            },
            {
                "id": 1820455,
                "content": [
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "It is must one for starting with strings and getting a vibe on to the strings."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "what\\'s your say on this\\n"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "what is this problem is for ?"
                    },
                    {
                        "username": "charonme",
                        "content": "the naive O(n^2) solution is now accepted without TLE, no need for KMP"
                    },
                    {
                        "username": "MohitAhlawat",
                        "content": "hint is window of needle"
                    },
                    {
                        "username": "shaloba",
                        "content": "The challenge is to write this without using built in functions, i have succeeded to solve this in O(nlog(n)) while n is the length of haystack"
                    },
                    {
                        "username": "ketansarna",
                        "content": "this question used to be marked as easy lol\\n\\n\\n"
                    },
                    {
                        "username": "space_invader",
                        "content": "Wait, what? Is it a medium?"
                    },
                    {
                        "username": "aitachii",
                        "content": "I think the problem description should mention  that using built-in functions are not allowed or the time complexity should be O(m + n)."
                    },
                    {
                        "username": "AnandBawa",
                        "content": "\"Medium\" with one line solution. LC can be confusing."
                    },
                    {
                        "username": "charonme",
                        "content": "this https://leetcode.com/problems/edit-distance/ also has a one line solution if you use a built-in function"
                    },
                    {
                        "username": "harshitisback",
                        "content": "```\nStringBuffer sb = new StringBuffer(haystack);\n        return sb.indexOf(needle,0);\n```\n\nI solved this question with these two lines and surprised why medium level but what the matter even i solved it by two lines it can't give me satisfaction specially when it is a medium level problem it is same as don't use library they just missed this part like they did in sorting problem "
                    }
                ]
            },
            {
                "id": 1820317,
                "content": [
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "It is must one for starting with strings and getting a vibe on to the strings."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "what\\'s your say on this\\n"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "what is this problem is for ?"
                    },
                    {
                        "username": "charonme",
                        "content": "the naive O(n^2) solution is now accepted without TLE, no need for KMP"
                    },
                    {
                        "username": "MohitAhlawat",
                        "content": "hint is window of needle"
                    },
                    {
                        "username": "shaloba",
                        "content": "The challenge is to write this without using built in functions, i have succeeded to solve this in O(nlog(n)) while n is the length of haystack"
                    },
                    {
                        "username": "ketansarna",
                        "content": "this question used to be marked as easy lol\\n\\n\\n"
                    },
                    {
                        "username": "space_invader",
                        "content": "Wait, what? Is it a medium?"
                    },
                    {
                        "username": "aitachii",
                        "content": "I think the problem description should mention  that using built-in functions are not allowed or the time complexity should be O(m + n)."
                    },
                    {
                        "username": "AnandBawa",
                        "content": "\"Medium\" with one line solution. LC can be confusing."
                    },
                    {
                        "username": "charonme",
                        "content": "this https://leetcode.com/problems/edit-distance/ also has a one line solution if you use a built-in function"
                    },
                    {
                        "username": "harshitisback",
                        "content": "```\nStringBuffer sb = new StringBuffer(haystack);\n        return sb.indexOf(needle,0);\n```\n\nI solved this question with these two lines and surprised why medium level but what the matter even i solved it by two lines it can't give me satisfaction specially when it is a medium level problem it is same as don't use library they just missed this part like they did in sorting problem "
                    }
                ]
            },
            {
                "id": 1820295,
                "content": [
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "It is must one for starting with strings and getting a vibe on to the strings."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "what\\'s your say on this\\n"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "what is this problem is for ?"
                    },
                    {
                        "username": "charonme",
                        "content": "the naive O(n^2) solution is now accepted without TLE, no need for KMP"
                    },
                    {
                        "username": "MohitAhlawat",
                        "content": "hint is window of needle"
                    },
                    {
                        "username": "shaloba",
                        "content": "The challenge is to write this without using built in functions, i have succeeded to solve this in O(nlog(n)) while n is the length of haystack"
                    },
                    {
                        "username": "ketansarna",
                        "content": "this question used to be marked as easy lol\\n\\n\\n"
                    },
                    {
                        "username": "space_invader",
                        "content": "Wait, what? Is it a medium?"
                    },
                    {
                        "username": "aitachii",
                        "content": "I think the problem description should mention  that using built-in functions are not allowed or the time complexity should be O(m + n)."
                    },
                    {
                        "username": "AnandBawa",
                        "content": "\"Medium\" with one line solution. LC can be confusing."
                    },
                    {
                        "username": "charonme",
                        "content": "this https://leetcode.com/problems/edit-distance/ also has a one line solution if you use a built-in function"
                    },
                    {
                        "username": "harshitisback",
                        "content": "```\nStringBuffer sb = new StringBuffer(haystack);\n        return sb.indexOf(needle,0);\n```\n\nI solved this question with these two lines and surprised why medium level but what the matter even i solved it by two lines it can't give me satisfaction specially when it is a medium level problem it is same as don't use library they just missed this part like they did in sorting problem "
                    }
                ]
            },
            {
                "id": 1820277,
                "content": [
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "It is must one for starting with strings and getting a vibe on to the strings."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "what\\'s your say on this\\n"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "what is this problem is for ?"
                    },
                    {
                        "username": "charonme",
                        "content": "the naive O(n^2) solution is now accepted without TLE, no need for KMP"
                    },
                    {
                        "username": "MohitAhlawat",
                        "content": "hint is window of needle"
                    },
                    {
                        "username": "shaloba",
                        "content": "The challenge is to write this without using built in functions, i have succeeded to solve this in O(nlog(n)) while n is the length of haystack"
                    },
                    {
                        "username": "ketansarna",
                        "content": "this question used to be marked as easy lol\\n\\n\\n"
                    },
                    {
                        "username": "space_invader",
                        "content": "Wait, what? Is it a medium?"
                    },
                    {
                        "username": "aitachii",
                        "content": "I think the problem description should mention  that using built-in functions are not allowed or the time complexity should be O(m + n)."
                    },
                    {
                        "username": "AnandBawa",
                        "content": "\"Medium\" with one line solution. LC can be confusing."
                    },
                    {
                        "username": "charonme",
                        "content": "this https://leetcode.com/problems/edit-distance/ also has a one line solution if you use a built-in function"
                    },
                    {
                        "username": "harshitisback",
                        "content": "```\nStringBuffer sb = new StringBuffer(haystack);\n        return sb.indexOf(needle,0);\n```\n\nI solved this question with these two lines and surprised why medium level but what the matter even i solved it by two lines it can't give me satisfaction specially when it is a medium level problem it is same as don't use library they just missed this part like they did in sorting problem "
                    }
                ]
            },
            {
                "id": 1820220,
                "content": [
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "It is must one for starting with strings and getting a vibe on to the strings."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "what\\'s your say on this\\n"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "what is this problem is for ?"
                    },
                    {
                        "username": "charonme",
                        "content": "the naive O(n^2) solution is now accepted without TLE, no need for KMP"
                    },
                    {
                        "username": "MohitAhlawat",
                        "content": "hint is window of needle"
                    },
                    {
                        "username": "shaloba",
                        "content": "The challenge is to write this without using built in functions, i have succeeded to solve this in O(nlog(n)) while n is the length of haystack"
                    },
                    {
                        "username": "ketansarna",
                        "content": "this question used to be marked as easy lol\\n\\n\\n"
                    },
                    {
                        "username": "space_invader",
                        "content": "Wait, what? Is it a medium?"
                    },
                    {
                        "username": "aitachii",
                        "content": "I think the problem description should mention  that using built-in functions are not allowed or the time complexity should be O(m + n)."
                    },
                    {
                        "username": "AnandBawa",
                        "content": "\"Medium\" with one line solution. LC can be confusing."
                    },
                    {
                        "username": "charonme",
                        "content": "this https://leetcode.com/problems/edit-distance/ also has a one line solution if you use a built-in function"
                    },
                    {
                        "username": "harshitisback",
                        "content": "```\nStringBuffer sb = new StringBuffer(haystack);\n        return sb.indexOf(needle,0);\n```\n\nI solved this question with these two lines and surprised why medium level but what the matter even i solved it by two lines it can't give me satisfaction specially when it is a medium level problem it is same as don't use library they just missed this part like they did in sorting problem "
                    }
                ]
            },
            {
                "id": 1820112,
                "content": [
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "It is must one for starting with strings and getting a vibe on to the strings."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "what\\'s your say on this\\n"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "what is this problem is for ?"
                    },
                    {
                        "username": "charonme",
                        "content": "the naive O(n^2) solution is now accepted without TLE, no need for KMP"
                    },
                    {
                        "username": "MohitAhlawat",
                        "content": "hint is window of needle"
                    },
                    {
                        "username": "shaloba",
                        "content": "The challenge is to write this without using built in functions, i have succeeded to solve this in O(nlog(n)) while n is the length of haystack"
                    },
                    {
                        "username": "ketansarna",
                        "content": "this question used to be marked as easy lol\\n\\n\\n"
                    },
                    {
                        "username": "space_invader",
                        "content": "Wait, what? Is it a medium?"
                    },
                    {
                        "username": "aitachii",
                        "content": "I think the problem description should mention  that using built-in functions are not allowed or the time complexity should be O(m + n)."
                    },
                    {
                        "username": "AnandBawa",
                        "content": "\"Medium\" with one line solution. LC can be confusing."
                    },
                    {
                        "username": "charonme",
                        "content": "this https://leetcode.com/problems/edit-distance/ also has a one line solution if you use a built-in function"
                    },
                    {
                        "username": "harshitisback",
                        "content": "```\nStringBuffer sb = new StringBuffer(haystack);\n        return sb.indexOf(needle,0);\n```\n\nI solved this question with these two lines and surprised why medium level but what the matter even i solved it by two lines it can't give me satisfaction specially when it is a medium level problem it is same as don't use library they just missed this part like they did in sorting problem "
                    }
                ]
            },
            {
                "id": 1820072,
                "content": [
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "It is must one for starting with strings and getting a vibe on to the strings."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "what\\'s your say on this\\n"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "what is this problem is for ?"
                    },
                    {
                        "username": "charonme",
                        "content": "the naive O(n^2) solution is now accepted without TLE, no need for KMP"
                    },
                    {
                        "username": "MohitAhlawat",
                        "content": "hint is window of needle"
                    },
                    {
                        "username": "shaloba",
                        "content": "The challenge is to write this without using built in functions, i have succeeded to solve this in O(nlog(n)) while n is the length of haystack"
                    },
                    {
                        "username": "ketansarna",
                        "content": "this question used to be marked as easy lol\\n\\n\\n"
                    },
                    {
                        "username": "space_invader",
                        "content": "Wait, what? Is it a medium?"
                    },
                    {
                        "username": "aitachii",
                        "content": "I think the problem description should mention  that using built-in functions are not allowed or the time complexity should be O(m + n)."
                    },
                    {
                        "username": "AnandBawa",
                        "content": "\"Medium\" with one line solution. LC can be confusing."
                    },
                    {
                        "username": "charonme",
                        "content": "this https://leetcode.com/problems/edit-distance/ also has a one line solution if you use a built-in function"
                    },
                    {
                        "username": "harshitisback",
                        "content": "```\nStringBuffer sb = new StringBuffer(haystack);\n        return sb.indexOf(needle,0);\n```\n\nI solved this question with these two lines and surprised why medium level but what the matter even i solved it by two lines it can't give me satisfaction specially when it is a medium level problem it is same as don't use library they just missed this part like they did in sorting problem "
                    }
                ]
            },
            {
                "id": 1820029,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "EASIEST MEDIUM EVER(in java)"
                    },
                    {
                        "username": "charlieanthony",
                        "content": "classic python one-liner marked as Medium "
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "This should be easy problems."
                    },
                    {
                        "username": "LY4869",
                        "content": " Didn\\'t work...\\n`class Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        \\n        int i = 0, j = 0;\\n        int n1 = haystack.size(), n2 = needle.size();\\n        if(n2 > n1)\\n            return -1;\\n        \\n        while(i < n1)\\n        {\\n            int idx = i;\\n            while(i < n1 && j < n2 && haystack[i++] == needle[j])\\n                j++;\\n            if(j == n2)\\n                return idx;\\n            j = 0;\\n        }\\n        return -1;\\n    }\\n};`"
                    },
                    {
                        "username": "ilyasabdullah00",
                        "content": "Please tell me what i am doing wrong!!!!\\n\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        \\n        c=0\\n        for j in range(len(haystack)):\\n            \\n            if needle[c]==haystack[j]:\\n                for i in range(len(needle)):\\n                    a=j\\n                    if needle[i]==haystack[a]:\\n                        a=a+1\\n                        c=c+1\\n                    else:\\n                        break\\n            if needle[0]==haystack[j]:\\n                break\\n\\n        if len(needle)==c:\\n            return a-len(needle)\\n        else:\\n            return (-1)"
                    },
                    {
                        "username": "mikael6767",
                        "content": "Why is this medium. this is a 1line solution in python3. I don\\'t know how it became ```Medium``` but this is the easiest problem on LeetCode.  Also,   [@Siddharth Mathur](/Siddharth2k007) or Siddharth2k007, this is really easy. I don\\'t understand how can it be hard.\\n\\n"
                    },
                    {
                        "username": "charonme",
                        "content": "if calling a built-in function with the problem arguments makes the problem \"easy\" then this is \"easy\" too https://leetcode.com/problems/edit-distance/ :D"
                    },
                    {
                        "username": "XOFJO",
                        "content": "[@kylecrowley](/kylecrowley) hhhhhh"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "\"Easiest problem on LeetCode\"? Clearly you haven\\'t seen [this](https://leetcode.com/problems/add-two-integers/) problem."
                    },
                    {
                        "username": "MaximPLV",
                        "content": "well, but you aren't supposed to do this in one line with build in functions"
                    },
                    {
                        "username": "happyAD",
                        "content": " Why this code doesn\\'t work?\\n`public int strStr(String haystack, String needle) {\\n        int ans = -1;\\n        for (int i = 0; i < haystack.length(); i++){\\n            if (i + needle.length() < haystack.length() && haystack.substring(i, needle.length()).equals(needle)){\\n                return i;\\n            }\\n        }\\n        return ans;\\n    }`\\n"
                    },
                    {
                        "username": "akib_alvee",
                        "content": "One approach that you can try!!!\\n\\nIf haystack\\'s i-th character match with needle\\'s k-th character we will increment the value of k. If it doesn\\'t match, but previously there was a slightly match, we will try to search the needle from the next point of previously matched position and set the value of k to 0. Because needle maybe reside from the next position, that we\\'ve already passed. For example, haystack = \"mississippi\" and needle = \"issip\" and another haystack = \"mississippi\" and needle = \"pi\".\\n\\nHope it works for you! :)\\n\\n"
                    },
                    {
                        "username": "THRILLMONGER",
                        "content": "is using indexOf() cheating in java\\n"
                    },
                    {
                        "username": "MaximPLV",
                        "content": "Yes"
                    },
                    {
                        "username": "VJKUMAR_",
                        "content": "Java solution\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n\\n        int max=Math.max(haystack.indexOf(needle),-1);\\n        return max;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1819986,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "EASIEST MEDIUM EVER(in java)"
                    },
                    {
                        "username": "charlieanthony",
                        "content": "classic python one-liner marked as Medium "
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "This should be easy problems."
                    },
                    {
                        "username": "LY4869",
                        "content": " Didn\\'t work...\\n`class Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        \\n        int i = 0, j = 0;\\n        int n1 = haystack.size(), n2 = needle.size();\\n        if(n2 > n1)\\n            return -1;\\n        \\n        while(i < n1)\\n        {\\n            int idx = i;\\n            while(i < n1 && j < n2 && haystack[i++] == needle[j])\\n                j++;\\n            if(j == n2)\\n                return idx;\\n            j = 0;\\n        }\\n        return -1;\\n    }\\n};`"
                    },
                    {
                        "username": "ilyasabdullah00",
                        "content": "Please tell me what i am doing wrong!!!!\\n\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        \\n        c=0\\n        for j in range(len(haystack)):\\n            \\n            if needle[c]==haystack[j]:\\n                for i in range(len(needle)):\\n                    a=j\\n                    if needle[i]==haystack[a]:\\n                        a=a+1\\n                        c=c+1\\n                    else:\\n                        break\\n            if needle[0]==haystack[j]:\\n                break\\n\\n        if len(needle)==c:\\n            return a-len(needle)\\n        else:\\n            return (-1)"
                    },
                    {
                        "username": "mikael6767",
                        "content": "Why is this medium. this is a 1line solution in python3. I don\\'t know how it became ```Medium``` but this is the easiest problem on LeetCode.  Also,   [@Siddharth Mathur](/Siddharth2k007) or Siddharth2k007, this is really easy. I don\\'t understand how can it be hard.\\n\\n"
                    },
                    {
                        "username": "charonme",
                        "content": "if calling a built-in function with the problem arguments makes the problem \"easy\" then this is \"easy\" too https://leetcode.com/problems/edit-distance/ :D"
                    },
                    {
                        "username": "XOFJO",
                        "content": "[@kylecrowley](/kylecrowley) hhhhhh"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "\"Easiest problem on LeetCode\"? Clearly you haven\\'t seen [this](https://leetcode.com/problems/add-two-integers/) problem."
                    },
                    {
                        "username": "MaximPLV",
                        "content": "well, but you aren't supposed to do this in one line with build in functions"
                    },
                    {
                        "username": "happyAD",
                        "content": " Why this code doesn\\'t work?\\n`public int strStr(String haystack, String needle) {\\n        int ans = -1;\\n        for (int i = 0; i < haystack.length(); i++){\\n            if (i + needle.length() < haystack.length() && haystack.substring(i, needle.length()).equals(needle)){\\n                return i;\\n            }\\n        }\\n        return ans;\\n    }`\\n"
                    },
                    {
                        "username": "akib_alvee",
                        "content": "One approach that you can try!!!\\n\\nIf haystack\\'s i-th character match with needle\\'s k-th character we will increment the value of k. If it doesn\\'t match, but previously there was a slightly match, we will try to search the needle from the next point of previously matched position and set the value of k to 0. Because needle maybe reside from the next position, that we\\'ve already passed. For example, haystack = \"mississippi\" and needle = \"issip\" and another haystack = \"mississippi\" and needle = \"pi\".\\n\\nHope it works for you! :)\\n\\n"
                    },
                    {
                        "username": "THRILLMONGER",
                        "content": "is using indexOf() cheating in java\\n"
                    },
                    {
                        "username": "MaximPLV",
                        "content": "Yes"
                    },
                    {
                        "username": "VJKUMAR_",
                        "content": "Java solution\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n\\n        int max=Math.max(haystack.indexOf(needle),-1);\\n        return max;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1819951,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "EASIEST MEDIUM EVER(in java)"
                    },
                    {
                        "username": "charlieanthony",
                        "content": "classic python one-liner marked as Medium "
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "This should be easy problems."
                    },
                    {
                        "username": "LY4869",
                        "content": " Didn\\'t work...\\n`class Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        \\n        int i = 0, j = 0;\\n        int n1 = haystack.size(), n2 = needle.size();\\n        if(n2 > n1)\\n            return -1;\\n        \\n        while(i < n1)\\n        {\\n            int idx = i;\\n            while(i < n1 && j < n2 && haystack[i++] == needle[j])\\n                j++;\\n            if(j == n2)\\n                return idx;\\n            j = 0;\\n        }\\n        return -1;\\n    }\\n};`"
                    },
                    {
                        "username": "ilyasabdullah00",
                        "content": "Please tell me what i am doing wrong!!!!\\n\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        \\n        c=0\\n        for j in range(len(haystack)):\\n            \\n            if needle[c]==haystack[j]:\\n                for i in range(len(needle)):\\n                    a=j\\n                    if needle[i]==haystack[a]:\\n                        a=a+1\\n                        c=c+1\\n                    else:\\n                        break\\n            if needle[0]==haystack[j]:\\n                break\\n\\n        if len(needle)==c:\\n            return a-len(needle)\\n        else:\\n            return (-1)"
                    },
                    {
                        "username": "mikael6767",
                        "content": "Why is this medium. this is a 1line solution in python3. I don\\'t know how it became ```Medium``` but this is the easiest problem on LeetCode.  Also,   [@Siddharth Mathur](/Siddharth2k007) or Siddharth2k007, this is really easy. I don\\'t understand how can it be hard.\\n\\n"
                    },
                    {
                        "username": "charonme",
                        "content": "if calling a built-in function with the problem arguments makes the problem \"easy\" then this is \"easy\" too https://leetcode.com/problems/edit-distance/ :D"
                    },
                    {
                        "username": "XOFJO",
                        "content": "[@kylecrowley](/kylecrowley) hhhhhh"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "\"Easiest problem on LeetCode\"? Clearly you haven\\'t seen [this](https://leetcode.com/problems/add-two-integers/) problem."
                    },
                    {
                        "username": "MaximPLV",
                        "content": "well, but you aren't supposed to do this in one line with build in functions"
                    },
                    {
                        "username": "happyAD",
                        "content": " Why this code doesn\\'t work?\\n`public int strStr(String haystack, String needle) {\\n        int ans = -1;\\n        for (int i = 0; i < haystack.length(); i++){\\n            if (i + needle.length() < haystack.length() && haystack.substring(i, needle.length()).equals(needle)){\\n                return i;\\n            }\\n        }\\n        return ans;\\n    }`\\n"
                    },
                    {
                        "username": "akib_alvee",
                        "content": "One approach that you can try!!!\\n\\nIf haystack\\'s i-th character match with needle\\'s k-th character we will increment the value of k. If it doesn\\'t match, but previously there was a slightly match, we will try to search the needle from the next point of previously matched position and set the value of k to 0. Because needle maybe reside from the next position, that we\\'ve already passed. For example, haystack = \"mississippi\" and needle = \"issip\" and another haystack = \"mississippi\" and needle = \"pi\".\\n\\nHope it works for you! :)\\n\\n"
                    },
                    {
                        "username": "THRILLMONGER",
                        "content": "is using indexOf() cheating in java\\n"
                    },
                    {
                        "username": "MaximPLV",
                        "content": "Yes"
                    },
                    {
                        "username": "VJKUMAR_",
                        "content": "Java solution\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n\\n        int max=Math.max(haystack.indexOf(needle),-1);\\n        return max;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1819944,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "EASIEST MEDIUM EVER(in java)"
                    },
                    {
                        "username": "charlieanthony",
                        "content": "classic python one-liner marked as Medium "
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "This should be easy problems."
                    },
                    {
                        "username": "LY4869",
                        "content": " Didn\\'t work...\\n`class Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        \\n        int i = 0, j = 0;\\n        int n1 = haystack.size(), n2 = needle.size();\\n        if(n2 > n1)\\n            return -1;\\n        \\n        while(i < n1)\\n        {\\n            int idx = i;\\n            while(i < n1 && j < n2 && haystack[i++] == needle[j])\\n                j++;\\n            if(j == n2)\\n                return idx;\\n            j = 0;\\n        }\\n        return -1;\\n    }\\n};`"
                    },
                    {
                        "username": "ilyasabdullah00",
                        "content": "Please tell me what i am doing wrong!!!!\\n\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        \\n        c=0\\n        for j in range(len(haystack)):\\n            \\n            if needle[c]==haystack[j]:\\n                for i in range(len(needle)):\\n                    a=j\\n                    if needle[i]==haystack[a]:\\n                        a=a+1\\n                        c=c+1\\n                    else:\\n                        break\\n            if needle[0]==haystack[j]:\\n                break\\n\\n        if len(needle)==c:\\n            return a-len(needle)\\n        else:\\n            return (-1)"
                    },
                    {
                        "username": "mikael6767",
                        "content": "Why is this medium. this is a 1line solution in python3. I don\\'t know how it became ```Medium``` but this is the easiest problem on LeetCode.  Also,   [@Siddharth Mathur](/Siddharth2k007) or Siddharth2k007, this is really easy. I don\\'t understand how can it be hard.\\n\\n"
                    },
                    {
                        "username": "charonme",
                        "content": "if calling a built-in function with the problem arguments makes the problem \"easy\" then this is \"easy\" too https://leetcode.com/problems/edit-distance/ :D"
                    },
                    {
                        "username": "XOFJO",
                        "content": "[@kylecrowley](/kylecrowley) hhhhhh"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "\"Easiest problem on LeetCode\"? Clearly you haven\\'t seen [this](https://leetcode.com/problems/add-two-integers/) problem."
                    },
                    {
                        "username": "MaximPLV",
                        "content": "well, but you aren't supposed to do this in one line with build in functions"
                    },
                    {
                        "username": "happyAD",
                        "content": " Why this code doesn\\'t work?\\n`public int strStr(String haystack, String needle) {\\n        int ans = -1;\\n        for (int i = 0; i < haystack.length(); i++){\\n            if (i + needle.length() < haystack.length() && haystack.substring(i, needle.length()).equals(needle)){\\n                return i;\\n            }\\n        }\\n        return ans;\\n    }`\\n"
                    },
                    {
                        "username": "akib_alvee",
                        "content": "One approach that you can try!!!\\n\\nIf haystack\\'s i-th character match with needle\\'s k-th character we will increment the value of k. If it doesn\\'t match, but previously there was a slightly match, we will try to search the needle from the next point of previously matched position and set the value of k to 0. Because needle maybe reside from the next position, that we\\'ve already passed. For example, haystack = \"mississippi\" and needle = \"issip\" and another haystack = \"mississippi\" and needle = \"pi\".\\n\\nHope it works for you! :)\\n\\n"
                    },
                    {
                        "username": "THRILLMONGER",
                        "content": "is using indexOf() cheating in java\\n"
                    },
                    {
                        "username": "MaximPLV",
                        "content": "Yes"
                    },
                    {
                        "username": "VJKUMAR_",
                        "content": "Java solution\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n\\n        int max=Math.max(haystack.indexOf(needle),-1);\\n        return max;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1813222,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "EASIEST MEDIUM EVER(in java)"
                    },
                    {
                        "username": "charlieanthony",
                        "content": "classic python one-liner marked as Medium "
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "This should be easy problems."
                    },
                    {
                        "username": "LY4869",
                        "content": " Didn\\'t work...\\n`class Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        \\n        int i = 0, j = 0;\\n        int n1 = haystack.size(), n2 = needle.size();\\n        if(n2 > n1)\\n            return -1;\\n        \\n        while(i < n1)\\n        {\\n            int idx = i;\\n            while(i < n1 && j < n2 && haystack[i++] == needle[j])\\n                j++;\\n            if(j == n2)\\n                return idx;\\n            j = 0;\\n        }\\n        return -1;\\n    }\\n};`"
                    },
                    {
                        "username": "ilyasabdullah00",
                        "content": "Please tell me what i am doing wrong!!!!\\n\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        \\n        c=0\\n        for j in range(len(haystack)):\\n            \\n            if needle[c]==haystack[j]:\\n                for i in range(len(needle)):\\n                    a=j\\n                    if needle[i]==haystack[a]:\\n                        a=a+1\\n                        c=c+1\\n                    else:\\n                        break\\n            if needle[0]==haystack[j]:\\n                break\\n\\n        if len(needle)==c:\\n            return a-len(needle)\\n        else:\\n            return (-1)"
                    },
                    {
                        "username": "mikael6767",
                        "content": "Why is this medium. this is a 1line solution in python3. I don\\'t know how it became ```Medium``` but this is the easiest problem on LeetCode.  Also,   [@Siddharth Mathur](/Siddharth2k007) or Siddharth2k007, this is really easy. I don\\'t understand how can it be hard.\\n\\n"
                    },
                    {
                        "username": "charonme",
                        "content": "if calling a built-in function with the problem arguments makes the problem \"easy\" then this is \"easy\" too https://leetcode.com/problems/edit-distance/ :D"
                    },
                    {
                        "username": "XOFJO",
                        "content": "[@kylecrowley](/kylecrowley) hhhhhh"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "\"Easiest problem on LeetCode\"? Clearly you haven\\'t seen [this](https://leetcode.com/problems/add-two-integers/) problem."
                    },
                    {
                        "username": "MaximPLV",
                        "content": "well, but you aren't supposed to do this in one line with build in functions"
                    },
                    {
                        "username": "happyAD",
                        "content": " Why this code doesn\\'t work?\\n`public int strStr(String haystack, String needle) {\\n        int ans = -1;\\n        for (int i = 0; i < haystack.length(); i++){\\n            if (i + needle.length() < haystack.length() && haystack.substring(i, needle.length()).equals(needle)){\\n                return i;\\n            }\\n        }\\n        return ans;\\n    }`\\n"
                    },
                    {
                        "username": "akib_alvee",
                        "content": "One approach that you can try!!!\\n\\nIf haystack\\'s i-th character match with needle\\'s k-th character we will increment the value of k. If it doesn\\'t match, but previously there was a slightly match, we will try to search the needle from the next point of previously matched position and set the value of k to 0. Because needle maybe reside from the next position, that we\\'ve already passed. For example, haystack = \"mississippi\" and needle = \"issip\" and another haystack = \"mississippi\" and needle = \"pi\".\\n\\nHope it works for you! :)\\n\\n"
                    },
                    {
                        "username": "THRILLMONGER",
                        "content": "is using indexOf() cheating in java\\n"
                    },
                    {
                        "username": "MaximPLV",
                        "content": "Yes"
                    },
                    {
                        "username": "VJKUMAR_",
                        "content": "Java solution\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n\\n        int max=Math.max(haystack.indexOf(needle),-1);\\n        return max;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1810036,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "EASIEST MEDIUM EVER(in java)"
                    },
                    {
                        "username": "charlieanthony",
                        "content": "classic python one-liner marked as Medium "
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "This should be easy problems."
                    },
                    {
                        "username": "LY4869",
                        "content": " Didn\\'t work...\\n`class Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        \\n        int i = 0, j = 0;\\n        int n1 = haystack.size(), n2 = needle.size();\\n        if(n2 > n1)\\n            return -1;\\n        \\n        while(i < n1)\\n        {\\n            int idx = i;\\n            while(i < n1 && j < n2 && haystack[i++] == needle[j])\\n                j++;\\n            if(j == n2)\\n                return idx;\\n            j = 0;\\n        }\\n        return -1;\\n    }\\n};`"
                    },
                    {
                        "username": "ilyasabdullah00",
                        "content": "Please tell me what i am doing wrong!!!!\\n\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        \\n        c=0\\n        for j in range(len(haystack)):\\n            \\n            if needle[c]==haystack[j]:\\n                for i in range(len(needle)):\\n                    a=j\\n                    if needle[i]==haystack[a]:\\n                        a=a+1\\n                        c=c+1\\n                    else:\\n                        break\\n            if needle[0]==haystack[j]:\\n                break\\n\\n        if len(needle)==c:\\n            return a-len(needle)\\n        else:\\n            return (-1)"
                    },
                    {
                        "username": "mikael6767",
                        "content": "Why is this medium. this is a 1line solution in python3. I don\\'t know how it became ```Medium``` but this is the easiest problem on LeetCode.  Also,   [@Siddharth Mathur](/Siddharth2k007) or Siddharth2k007, this is really easy. I don\\'t understand how can it be hard.\\n\\n"
                    },
                    {
                        "username": "charonme",
                        "content": "if calling a built-in function with the problem arguments makes the problem \"easy\" then this is \"easy\" too https://leetcode.com/problems/edit-distance/ :D"
                    },
                    {
                        "username": "XOFJO",
                        "content": "[@kylecrowley](/kylecrowley) hhhhhh"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "\"Easiest problem on LeetCode\"? Clearly you haven\\'t seen [this](https://leetcode.com/problems/add-two-integers/) problem."
                    },
                    {
                        "username": "MaximPLV",
                        "content": "well, but you aren't supposed to do this in one line with build in functions"
                    },
                    {
                        "username": "happyAD",
                        "content": " Why this code doesn\\'t work?\\n`public int strStr(String haystack, String needle) {\\n        int ans = -1;\\n        for (int i = 0; i < haystack.length(); i++){\\n            if (i + needle.length() < haystack.length() && haystack.substring(i, needle.length()).equals(needle)){\\n                return i;\\n            }\\n        }\\n        return ans;\\n    }`\\n"
                    },
                    {
                        "username": "akib_alvee",
                        "content": "One approach that you can try!!!\\n\\nIf haystack\\'s i-th character match with needle\\'s k-th character we will increment the value of k. If it doesn\\'t match, but previously there was a slightly match, we will try to search the needle from the next point of previously matched position and set the value of k to 0. Because needle maybe reside from the next position, that we\\'ve already passed. For example, haystack = \"mississippi\" and needle = \"issip\" and another haystack = \"mississippi\" and needle = \"pi\".\\n\\nHope it works for you! :)\\n\\n"
                    },
                    {
                        "username": "THRILLMONGER",
                        "content": "is using indexOf() cheating in java\\n"
                    },
                    {
                        "username": "MaximPLV",
                        "content": "Yes"
                    },
                    {
                        "username": "VJKUMAR_",
                        "content": "Java solution\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n\\n        int max=Math.max(haystack.indexOf(needle),-1);\\n        return max;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1807176,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "EASIEST MEDIUM EVER(in java)"
                    },
                    {
                        "username": "charlieanthony",
                        "content": "classic python one-liner marked as Medium "
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "This should be easy problems."
                    },
                    {
                        "username": "LY4869",
                        "content": " Didn\\'t work...\\n`class Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        \\n        int i = 0, j = 0;\\n        int n1 = haystack.size(), n2 = needle.size();\\n        if(n2 > n1)\\n            return -1;\\n        \\n        while(i < n1)\\n        {\\n            int idx = i;\\n            while(i < n1 && j < n2 && haystack[i++] == needle[j])\\n                j++;\\n            if(j == n2)\\n                return idx;\\n            j = 0;\\n        }\\n        return -1;\\n    }\\n};`"
                    },
                    {
                        "username": "ilyasabdullah00",
                        "content": "Please tell me what i am doing wrong!!!!\\n\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        \\n        c=0\\n        for j in range(len(haystack)):\\n            \\n            if needle[c]==haystack[j]:\\n                for i in range(len(needle)):\\n                    a=j\\n                    if needle[i]==haystack[a]:\\n                        a=a+1\\n                        c=c+1\\n                    else:\\n                        break\\n            if needle[0]==haystack[j]:\\n                break\\n\\n        if len(needle)==c:\\n            return a-len(needle)\\n        else:\\n            return (-1)"
                    },
                    {
                        "username": "mikael6767",
                        "content": "Why is this medium. this is a 1line solution in python3. I don\\'t know how it became ```Medium``` but this is the easiest problem on LeetCode.  Also,   [@Siddharth Mathur](/Siddharth2k007) or Siddharth2k007, this is really easy. I don\\'t understand how can it be hard.\\n\\n"
                    },
                    {
                        "username": "charonme",
                        "content": "if calling a built-in function with the problem arguments makes the problem \"easy\" then this is \"easy\" too https://leetcode.com/problems/edit-distance/ :D"
                    },
                    {
                        "username": "XOFJO",
                        "content": "[@kylecrowley](/kylecrowley) hhhhhh"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "\"Easiest problem on LeetCode\"? Clearly you haven\\'t seen [this](https://leetcode.com/problems/add-two-integers/) problem."
                    },
                    {
                        "username": "MaximPLV",
                        "content": "well, but you aren't supposed to do this in one line with build in functions"
                    },
                    {
                        "username": "happyAD",
                        "content": " Why this code doesn\\'t work?\\n`public int strStr(String haystack, String needle) {\\n        int ans = -1;\\n        for (int i = 0; i < haystack.length(); i++){\\n            if (i + needle.length() < haystack.length() && haystack.substring(i, needle.length()).equals(needle)){\\n                return i;\\n            }\\n        }\\n        return ans;\\n    }`\\n"
                    },
                    {
                        "username": "akib_alvee",
                        "content": "One approach that you can try!!!\\n\\nIf haystack\\'s i-th character match with needle\\'s k-th character we will increment the value of k. If it doesn\\'t match, but previously there was a slightly match, we will try to search the needle from the next point of previously matched position and set the value of k to 0. Because needle maybe reside from the next position, that we\\'ve already passed. For example, haystack = \"mississippi\" and needle = \"issip\" and another haystack = \"mississippi\" and needle = \"pi\".\\n\\nHope it works for you! :)\\n\\n"
                    },
                    {
                        "username": "THRILLMONGER",
                        "content": "is using indexOf() cheating in java\\n"
                    },
                    {
                        "username": "MaximPLV",
                        "content": "Yes"
                    },
                    {
                        "username": "VJKUMAR_",
                        "content": "Java solution\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n\\n        int max=Math.max(haystack.indexOf(needle),-1);\\n        return max;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1796440,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "EASIEST MEDIUM EVER(in java)"
                    },
                    {
                        "username": "charlieanthony",
                        "content": "classic python one-liner marked as Medium "
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "This should be easy problems."
                    },
                    {
                        "username": "LY4869",
                        "content": " Didn\\'t work...\\n`class Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        \\n        int i = 0, j = 0;\\n        int n1 = haystack.size(), n2 = needle.size();\\n        if(n2 > n1)\\n            return -1;\\n        \\n        while(i < n1)\\n        {\\n            int idx = i;\\n            while(i < n1 && j < n2 && haystack[i++] == needle[j])\\n                j++;\\n            if(j == n2)\\n                return idx;\\n            j = 0;\\n        }\\n        return -1;\\n    }\\n};`"
                    },
                    {
                        "username": "ilyasabdullah00",
                        "content": "Please tell me what i am doing wrong!!!!\\n\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        \\n        c=0\\n        for j in range(len(haystack)):\\n            \\n            if needle[c]==haystack[j]:\\n                for i in range(len(needle)):\\n                    a=j\\n                    if needle[i]==haystack[a]:\\n                        a=a+1\\n                        c=c+1\\n                    else:\\n                        break\\n            if needle[0]==haystack[j]:\\n                break\\n\\n        if len(needle)==c:\\n            return a-len(needle)\\n        else:\\n            return (-1)"
                    },
                    {
                        "username": "mikael6767",
                        "content": "Why is this medium. this is a 1line solution in python3. I don\\'t know how it became ```Medium``` but this is the easiest problem on LeetCode.  Also,   [@Siddharth Mathur](/Siddharth2k007) or Siddharth2k007, this is really easy. I don\\'t understand how can it be hard.\\n\\n"
                    },
                    {
                        "username": "charonme",
                        "content": "if calling a built-in function with the problem arguments makes the problem \"easy\" then this is \"easy\" too https://leetcode.com/problems/edit-distance/ :D"
                    },
                    {
                        "username": "XOFJO",
                        "content": "[@kylecrowley](/kylecrowley) hhhhhh"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "\"Easiest problem on LeetCode\"? Clearly you haven\\'t seen [this](https://leetcode.com/problems/add-two-integers/) problem."
                    },
                    {
                        "username": "MaximPLV",
                        "content": "well, but you aren't supposed to do this in one line with build in functions"
                    },
                    {
                        "username": "happyAD",
                        "content": " Why this code doesn\\'t work?\\n`public int strStr(String haystack, String needle) {\\n        int ans = -1;\\n        for (int i = 0; i < haystack.length(); i++){\\n            if (i + needle.length() < haystack.length() && haystack.substring(i, needle.length()).equals(needle)){\\n                return i;\\n            }\\n        }\\n        return ans;\\n    }`\\n"
                    },
                    {
                        "username": "akib_alvee",
                        "content": "One approach that you can try!!!\\n\\nIf haystack\\'s i-th character match with needle\\'s k-th character we will increment the value of k. If it doesn\\'t match, but previously there was a slightly match, we will try to search the needle from the next point of previously matched position and set the value of k to 0. Because needle maybe reside from the next position, that we\\'ve already passed. For example, haystack = \"mississippi\" and needle = \"issip\" and another haystack = \"mississippi\" and needle = \"pi\".\\n\\nHope it works for you! :)\\n\\n"
                    },
                    {
                        "username": "THRILLMONGER",
                        "content": "is using indexOf() cheating in java\\n"
                    },
                    {
                        "username": "MaximPLV",
                        "content": "Yes"
                    },
                    {
                        "username": "VJKUMAR_",
                        "content": "Java solution\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n\\n        int max=Math.max(haystack.indexOf(needle),-1);\\n        return max;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1790289,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "EASIEST MEDIUM EVER(in java)"
                    },
                    {
                        "username": "charlieanthony",
                        "content": "classic python one-liner marked as Medium "
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "This should be easy problems."
                    },
                    {
                        "username": "LY4869",
                        "content": " Didn\\'t work...\\n`class Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        \\n        int i = 0, j = 0;\\n        int n1 = haystack.size(), n2 = needle.size();\\n        if(n2 > n1)\\n            return -1;\\n        \\n        while(i < n1)\\n        {\\n            int idx = i;\\n            while(i < n1 && j < n2 && haystack[i++] == needle[j])\\n                j++;\\n            if(j == n2)\\n                return idx;\\n            j = 0;\\n        }\\n        return -1;\\n    }\\n};`"
                    },
                    {
                        "username": "ilyasabdullah00",
                        "content": "Please tell me what i am doing wrong!!!!\\n\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        \\n        c=0\\n        for j in range(len(haystack)):\\n            \\n            if needle[c]==haystack[j]:\\n                for i in range(len(needle)):\\n                    a=j\\n                    if needle[i]==haystack[a]:\\n                        a=a+1\\n                        c=c+1\\n                    else:\\n                        break\\n            if needle[0]==haystack[j]:\\n                break\\n\\n        if len(needle)==c:\\n            return a-len(needle)\\n        else:\\n            return (-1)"
                    },
                    {
                        "username": "mikael6767",
                        "content": "Why is this medium. this is a 1line solution in python3. I don\\'t know how it became ```Medium``` but this is the easiest problem on LeetCode.  Also,   [@Siddharth Mathur](/Siddharth2k007) or Siddharth2k007, this is really easy. I don\\'t understand how can it be hard.\\n\\n"
                    },
                    {
                        "username": "charonme",
                        "content": "if calling a built-in function with the problem arguments makes the problem \"easy\" then this is \"easy\" too https://leetcode.com/problems/edit-distance/ :D"
                    },
                    {
                        "username": "XOFJO",
                        "content": "[@kylecrowley](/kylecrowley) hhhhhh"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "\"Easiest problem on LeetCode\"? Clearly you haven\\'t seen [this](https://leetcode.com/problems/add-two-integers/) problem."
                    },
                    {
                        "username": "MaximPLV",
                        "content": "well, but you aren't supposed to do this in one line with build in functions"
                    },
                    {
                        "username": "happyAD",
                        "content": " Why this code doesn\\'t work?\\n`public int strStr(String haystack, String needle) {\\n        int ans = -1;\\n        for (int i = 0; i < haystack.length(); i++){\\n            if (i + needle.length() < haystack.length() && haystack.substring(i, needle.length()).equals(needle)){\\n                return i;\\n            }\\n        }\\n        return ans;\\n    }`\\n"
                    },
                    {
                        "username": "akib_alvee",
                        "content": "One approach that you can try!!!\\n\\nIf haystack\\'s i-th character match with needle\\'s k-th character we will increment the value of k. If it doesn\\'t match, but previously there was a slightly match, we will try to search the needle from the next point of previously matched position and set the value of k to 0. Because needle maybe reside from the next position, that we\\'ve already passed. For example, haystack = \"mississippi\" and needle = \"issip\" and another haystack = \"mississippi\" and needle = \"pi\".\\n\\nHope it works for you! :)\\n\\n"
                    },
                    {
                        "username": "THRILLMONGER",
                        "content": "is using indexOf() cheating in java\\n"
                    },
                    {
                        "username": "MaximPLV",
                        "content": "Yes"
                    },
                    {
                        "username": "VJKUMAR_",
                        "content": "Java solution\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n\\n        int max=Math.max(haystack.indexOf(needle),-1);\\n        return max;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1783143,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "EASIEST MEDIUM EVER(in java)"
                    },
                    {
                        "username": "charlieanthony",
                        "content": "classic python one-liner marked as Medium "
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "This should be easy problems."
                    },
                    {
                        "username": "LY4869",
                        "content": " Didn\\'t work...\\n`class Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        \\n        int i = 0, j = 0;\\n        int n1 = haystack.size(), n2 = needle.size();\\n        if(n2 > n1)\\n            return -1;\\n        \\n        while(i < n1)\\n        {\\n            int idx = i;\\n            while(i < n1 && j < n2 && haystack[i++] == needle[j])\\n                j++;\\n            if(j == n2)\\n                return idx;\\n            j = 0;\\n        }\\n        return -1;\\n    }\\n};`"
                    },
                    {
                        "username": "ilyasabdullah00",
                        "content": "Please tell me what i am doing wrong!!!!\\n\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        \\n        c=0\\n        for j in range(len(haystack)):\\n            \\n            if needle[c]==haystack[j]:\\n                for i in range(len(needle)):\\n                    a=j\\n                    if needle[i]==haystack[a]:\\n                        a=a+1\\n                        c=c+1\\n                    else:\\n                        break\\n            if needle[0]==haystack[j]:\\n                break\\n\\n        if len(needle)==c:\\n            return a-len(needle)\\n        else:\\n            return (-1)"
                    },
                    {
                        "username": "mikael6767",
                        "content": "Why is this medium. this is a 1line solution in python3. I don\\'t know how it became ```Medium``` but this is the easiest problem on LeetCode.  Also,   [@Siddharth Mathur](/Siddharth2k007) or Siddharth2k007, this is really easy. I don\\'t understand how can it be hard.\\n\\n"
                    },
                    {
                        "username": "charonme",
                        "content": "if calling a built-in function with the problem arguments makes the problem \"easy\" then this is \"easy\" too https://leetcode.com/problems/edit-distance/ :D"
                    },
                    {
                        "username": "XOFJO",
                        "content": "[@kylecrowley](/kylecrowley) hhhhhh"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "\"Easiest problem on LeetCode\"? Clearly you haven\\'t seen [this](https://leetcode.com/problems/add-two-integers/) problem."
                    },
                    {
                        "username": "MaximPLV",
                        "content": "well, but you aren't supposed to do this in one line with build in functions"
                    },
                    {
                        "username": "happyAD",
                        "content": " Why this code doesn\\'t work?\\n`public int strStr(String haystack, String needle) {\\n        int ans = -1;\\n        for (int i = 0; i < haystack.length(); i++){\\n            if (i + needle.length() < haystack.length() && haystack.substring(i, needle.length()).equals(needle)){\\n                return i;\\n            }\\n        }\\n        return ans;\\n    }`\\n"
                    },
                    {
                        "username": "akib_alvee",
                        "content": "One approach that you can try!!!\\n\\nIf haystack\\'s i-th character match with needle\\'s k-th character we will increment the value of k. If it doesn\\'t match, but previously there was a slightly match, we will try to search the needle from the next point of previously matched position and set the value of k to 0. Because needle maybe reside from the next position, that we\\'ve already passed. For example, haystack = \"mississippi\" and needle = \"issip\" and another haystack = \"mississippi\" and needle = \"pi\".\\n\\nHope it works for you! :)\\n\\n"
                    },
                    {
                        "username": "THRILLMONGER",
                        "content": "is using indexOf() cheating in java\\n"
                    },
                    {
                        "username": "MaximPLV",
                        "content": "Yes"
                    },
                    {
                        "username": "VJKUMAR_",
                        "content": "Java solution\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n\\n        int max=Math.max(haystack.indexOf(needle),-1);\\n        return max;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1771312,
                "content": [
                    {
                        "username": "Ajith_B_J",
                        "content": "This problem having simple and lot of ways\\nhere is easy way  in python\\nreturn haystack.find(needle)\\njust find the needle in haystack"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "I have used sliding window and string library function both in my solution..\\nIs it right way?"
                    },
                    {
                        "username": "rohit6386",
                        "content": "I just used sliding window algorithm for this"
                    },
                    {
                        "username": "MousePotatoa",
                        "content": "I see text and a pattern to match... regex~~"
                    },
                    {
                        "username": "MishaChernov",
                        "content": "It would be better to notice about time/space complexity or \"do not use build-in methods\" to make it as \"Medium\" problem, without this it's \"Easy\""
                    },
                    {
                        "username": "bharath_king77",
                        "content": "May be this is easiest medium question ever \\nJust finished it with 1 line of code"
                    },
                    {
                        "username": "xxxxtj",
                        "content": "This should be easy, no? Especially in python using startswith() ?\\n```\\ndef strStr(self, haystack: str, needle: str) -> int:\\n        for i,l in enumerate(haystack):\\n            if haystack[i::].startswith(needle):\\n                return i\\n        return -1\\n```"
                    },
                    {
                        "username": "__vaxeral",
                        "content": "My solution tried to optimize by iterating both forward and backward at the same time for each character."
                    },
                    {
                        "username": "gaurizade",
                        "content": "Input = \"hello\" \"ll\"\\noutput = 0\\nexpected = 2\\n\\nWhy expected is 2 ?\\n"
                    },
                    {
                        "username": "MaximPLV",
                        "content": "because the first l is on index 2"
                    },
                    {
                        "username": "ritikanandsr123",
                        "content": "can it be solved using recursion?"
                    }
                ]
            },
            {
                "id": 1771182,
                "content": [
                    {
                        "username": "Ajith_B_J",
                        "content": "This problem having simple and lot of ways\\nhere is easy way  in python\\nreturn haystack.find(needle)\\njust find the needle in haystack"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "I have used sliding window and string library function both in my solution..\\nIs it right way?"
                    },
                    {
                        "username": "rohit6386",
                        "content": "I just used sliding window algorithm for this"
                    },
                    {
                        "username": "MousePotatoa",
                        "content": "I see text and a pattern to match... regex~~"
                    },
                    {
                        "username": "MishaChernov",
                        "content": "It would be better to notice about time/space complexity or \"do not use build-in methods\" to make it as \"Medium\" problem, without this it's \"Easy\""
                    },
                    {
                        "username": "bharath_king77",
                        "content": "May be this is easiest medium question ever \\nJust finished it with 1 line of code"
                    },
                    {
                        "username": "xxxxtj",
                        "content": "This should be easy, no? Especially in python using startswith() ?\\n```\\ndef strStr(self, haystack: str, needle: str) -> int:\\n        for i,l in enumerate(haystack):\\n            if haystack[i::].startswith(needle):\\n                return i\\n        return -1\\n```"
                    },
                    {
                        "username": "__vaxeral",
                        "content": "My solution tried to optimize by iterating both forward and backward at the same time for each character."
                    },
                    {
                        "username": "gaurizade",
                        "content": "Input = \"hello\" \"ll\"\\noutput = 0\\nexpected = 2\\n\\nWhy expected is 2 ?\\n"
                    },
                    {
                        "username": "MaximPLV",
                        "content": "because the first l is on index 2"
                    },
                    {
                        "username": "ritikanandsr123",
                        "content": "can it be solved using recursion?"
                    }
                ]
            },
            {
                "id": 1766266,
                "content": [
                    {
                        "username": "Ajith_B_J",
                        "content": "This problem having simple and lot of ways\\nhere is easy way  in python\\nreturn haystack.find(needle)\\njust find the needle in haystack"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "I have used sliding window and string library function both in my solution..\\nIs it right way?"
                    },
                    {
                        "username": "rohit6386",
                        "content": "I just used sliding window algorithm for this"
                    },
                    {
                        "username": "MousePotatoa",
                        "content": "I see text and a pattern to match... regex~~"
                    },
                    {
                        "username": "MishaChernov",
                        "content": "It would be better to notice about time/space complexity or \"do not use build-in methods\" to make it as \"Medium\" problem, without this it's \"Easy\""
                    },
                    {
                        "username": "bharath_king77",
                        "content": "May be this is easiest medium question ever \\nJust finished it with 1 line of code"
                    },
                    {
                        "username": "xxxxtj",
                        "content": "This should be easy, no? Especially in python using startswith() ?\\n```\\ndef strStr(self, haystack: str, needle: str) -> int:\\n        for i,l in enumerate(haystack):\\n            if haystack[i::].startswith(needle):\\n                return i\\n        return -1\\n```"
                    },
                    {
                        "username": "__vaxeral",
                        "content": "My solution tried to optimize by iterating both forward and backward at the same time for each character."
                    },
                    {
                        "username": "gaurizade",
                        "content": "Input = \"hello\" \"ll\"\\noutput = 0\\nexpected = 2\\n\\nWhy expected is 2 ?\\n"
                    },
                    {
                        "username": "MaximPLV",
                        "content": "because the first l is on index 2"
                    },
                    {
                        "username": "ritikanandsr123",
                        "content": "can it be solved using recursion?"
                    }
                ]
            },
            {
                "id": 1765135,
                "content": [
                    {
                        "username": "Ajith_B_J",
                        "content": "This problem having simple and lot of ways\\nhere is easy way  in python\\nreturn haystack.find(needle)\\njust find the needle in haystack"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "I have used sliding window and string library function both in my solution..\\nIs it right way?"
                    },
                    {
                        "username": "rohit6386",
                        "content": "I just used sliding window algorithm for this"
                    },
                    {
                        "username": "MousePotatoa",
                        "content": "I see text and a pattern to match... regex~~"
                    },
                    {
                        "username": "MishaChernov",
                        "content": "It would be better to notice about time/space complexity or \"do not use build-in methods\" to make it as \"Medium\" problem, without this it's \"Easy\""
                    },
                    {
                        "username": "bharath_king77",
                        "content": "May be this is easiest medium question ever \\nJust finished it with 1 line of code"
                    },
                    {
                        "username": "xxxxtj",
                        "content": "This should be easy, no? Especially in python using startswith() ?\\n```\\ndef strStr(self, haystack: str, needle: str) -> int:\\n        for i,l in enumerate(haystack):\\n            if haystack[i::].startswith(needle):\\n                return i\\n        return -1\\n```"
                    },
                    {
                        "username": "__vaxeral",
                        "content": "My solution tried to optimize by iterating both forward and backward at the same time for each character."
                    },
                    {
                        "username": "gaurizade",
                        "content": "Input = \"hello\" \"ll\"\\noutput = 0\\nexpected = 2\\n\\nWhy expected is 2 ?\\n"
                    },
                    {
                        "username": "MaximPLV",
                        "content": "because the first l is on index 2"
                    },
                    {
                        "username": "ritikanandsr123",
                        "content": "can it be solved using recursion?"
                    }
                ]
            },
            {
                "id": 1759238,
                "content": [
                    {
                        "username": "Ajith_B_J",
                        "content": "This problem having simple and lot of ways\\nhere is easy way  in python\\nreturn haystack.find(needle)\\njust find the needle in haystack"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "I have used sliding window and string library function both in my solution..\\nIs it right way?"
                    },
                    {
                        "username": "rohit6386",
                        "content": "I just used sliding window algorithm for this"
                    },
                    {
                        "username": "MousePotatoa",
                        "content": "I see text and a pattern to match... regex~~"
                    },
                    {
                        "username": "MishaChernov",
                        "content": "It would be better to notice about time/space complexity or \"do not use build-in methods\" to make it as \"Medium\" problem, without this it's \"Easy\""
                    },
                    {
                        "username": "bharath_king77",
                        "content": "May be this is easiest medium question ever \\nJust finished it with 1 line of code"
                    },
                    {
                        "username": "xxxxtj",
                        "content": "This should be easy, no? Especially in python using startswith() ?\\n```\\ndef strStr(self, haystack: str, needle: str) -> int:\\n        for i,l in enumerate(haystack):\\n            if haystack[i::].startswith(needle):\\n                return i\\n        return -1\\n```"
                    },
                    {
                        "username": "__vaxeral",
                        "content": "My solution tried to optimize by iterating both forward and backward at the same time for each character."
                    },
                    {
                        "username": "gaurizade",
                        "content": "Input = \"hello\" \"ll\"\\noutput = 0\\nexpected = 2\\n\\nWhy expected is 2 ?\\n"
                    },
                    {
                        "username": "MaximPLV",
                        "content": "because the first l is on index 2"
                    },
                    {
                        "username": "ritikanandsr123",
                        "content": "can it be solved using recursion?"
                    }
                ]
            },
            {
                "id": 1759078,
                "content": [
                    {
                        "username": "Ajith_B_J",
                        "content": "This problem having simple and lot of ways\\nhere is easy way  in python\\nreturn haystack.find(needle)\\njust find the needle in haystack"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "I have used sliding window and string library function both in my solution..\\nIs it right way?"
                    },
                    {
                        "username": "rohit6386",
                        "content": "I just used sliding window algorithm for this"
                    },
                    {
                        "username": "MousePotatoa",
                        "content": "I see text and a pattern to match... regex~~"
                    },
                    {
                        "username": "MishaChernov",
                        "content": "It would be better to notice about time/space complexity or \"do not use build-in methods\" to make it as \"Medium\" problem, without this it's \"Easy\""
                    },
                    {
                        "username": "bharath_king77",
                        "content": "May be this is easiest medium question ever \\nJust finished it with 1 line of code"
                    },
                    {
                        "username": "xxxxtj",
                        "content": "This should be easy, no? Especially in python using startswith() ?\\n```\\ndef strStr(self, haystack: str, needle: str) -> int:\\n        for i,l in enumerate(haystack):\\n            if haystack[i::].startswith(needle):\\n                return i\\n        return -1\\n```"
                    },
                    {
                        "username": "__vaxeral",
                        "content": "My solution tried to optimize by iterating both forward and backward at the same time for each character."
                    },
                    {
                        "username": "gaurizade",
                        "content": "Input = \"hello\" \"ll\"\\noutput = 0\\nexpected = 2\\n\\nWhy expected is 2 ?\\n"
                    },
                    {
                        "username": "MaximPLV",
                        "content": "because the first l is on index 2"
                    },
                    {
                        "username": "ritikanandsr123",
                        "content": "can it be solved using recursion?"
                    }
                ]
            },
            {
                "id": 1758366,
                "content": [
                    {
                        "username": "Ajith_B_J",
                        "content": "This problem having simple and lot of ways\\nhere is easy way  in python\\nreturn haystack.find(needle)\\njust find the needle in haystack"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "I have used sliding window and string library function both in my solution..\\nIs it right way?"
                    },
                    {
                        "username": "rohit6386",
                        "content": "I just used sliding window algorithm for this"
                    },
                    {
                        "username": "MousePotatoa",
                        "content": "I see text and a pattern to match... regex~~"
                    },
                    {
                        "username": "MishaChernov",
                        "content": "It would be better to notice about time/space complexity or \"do not use build-in methods\" to make it as \"Medium\" problem, without this it's \"Easy\""
                    },
                    {
                        "username": "bharath_king77",
                        "content": "May be this is easiest medium question ever \\nJust finished it with 1 line of code"
                    },
                    {
                        "username": "xxxxtj",
                        "content": "This should be easy, no? Especially in python using startswith() ?\\n```\\ndef strStr(self, haystack: str, needle: str) -> int:\\n        for i,l in enumerate(haystack):\\n            if haystack[i::].startswith(needle):\\n                return i\\n        return -1\\n```"
                    },
                    {
                        "username": "__vaxeral",
                        "content": "My solution tried to optimize by iterating both forward and backward at the same time for each character."
                    },
                    {
                        "username": "gaurizade",
                        "content": "Input = \"hello\" \"ll\"\\noutput = 0\\nexpected = 2\\n\\nWhy expected is 2 ?\\n"
                    },
                    {
                        "username": "MaximPLV",
                        "content": "because the first l is on index 2"
                    },
                    {
                        "username": "ritikanandsr123",
                        "content": "can it be solved using recursion?"
                    }
                ]
            },
            {
                "id": 1752195,
                "content": [
                    {
                        "username": "Ajith_B_J",
                        "content": "This problem having simple and lot of ways\\nhere is easy way  in python\\nreturn haystack.find(needle)\\njust find the needle in haystack"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "I have used sliding window and string library function both in my solution..\\nIs it right way?"
                    },
                    {
                        "username": "rohit6386",
                        "content": "I just used sliding window algorithm for this"
                    },
                    {
                        "username": "MousePotatoa",
                        "content": "I see text and a pattern to match... regex~~"
                    },
                    {
                        "username": "MishaChernov",
                        "content": "It would be better to notice about time/space complexity or \"do not use build-in methods\" to make it as \"Medium\" problem, without this it's \"Easy\""
                    },
                    {
                        "username": "bharath_king77",
                        "content": "May be this is easiest medium question ever \\nJust finished it with 1 line of code"
                    },
                    {
                        "username": "xxxxtj",
                        "content": "This should be easy, no? Especially in python using startswith() ?\\n```\\ndef strStr(self, haystack: str, needle: str) -> int:\\n        for i,l in enumerate(haystack):\\n            if haystack[i::].startswith(needle):\\n                return i\\n        return -1\\n```"
                    },
                    {
                        "username": "__vaxeral",
                        "content": "My solution tried to optimize by iterating both forward and backward at the same time for each character."
                    },
                    {
                        "username": "gaurizade",
                        "content": "Input = \"hello\" \"ll\"\\noutput = 0\\nexpected = 2\\n\\nWhy expected is 2 ?\\n"
                    },
                    {
                        "username": "MaximPLV",
                        "content": "because the first l is on index 2"
                    },
                    {
                        "username": "ritikanandsr123",
                        "content": "can it be solved using recursion?"
                    }
                ]
            },
            {
                "id": 1750751,
                "content": [
                    {
                        "username": "Ajith_B_J",
                        "content": "This problem having simple and lot of ways\\nhere is easy way  in python\\nreturn haystack.find(needle)\\njust find the needle in haystack"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "I have used sliding window and string library function both in my solution..\\nIs it right way?"
                    },
                    {
                        "username": "rohit6386",
                        "content": "I just used sliding window algorithm for this"
                    },
                    {
                        "username": "MousePotatoa",
                        "content": "I see text and a pattern to match... regex~~"
                    },
                    {
                        "username": "MishaChernov",
                        "content": "It would be better to notice about time/space complexity or \"do not use build-in methods\" to make it as \"Medium\" problem, without this it's \"Easy\""
                    },
                    {
                        "username": "bharath_king77",
                        "content": "May be this is easiest medium question ever \\nJust finished it with 1 line of code"
                    },
                    {
                        "username": "xxxxtj",
                        "content": "This should be easy, no? Especially in python using startswith() ?\\n```\\ndef strStr(self, haystack: str, needle: str) -> int:\\n        for i,l in enumerate(haystack):\\n            if haystack[i::].startswith(needle):\\n                return i\\n        return -1\\n```"
                    },
                    {
                        "username": "__vaxeral",
                        "content": "My solution tried to optimize by iterating both forward and backward at the same time for each character."
                    },
                    {
                        "username": "gaurizade",
                        "content": "Input = \"hello\" \"ll\"\\noutput = 0\\nexpected = 2\\n\\nWhy expected is 2 ?\\n"
                    },
                    {
                        "username": "MaximPLV",
                        "content": "because the first l is on index 2"
                    },
                    {
                        "username": "ritikanandsr123",
                        "content": "can it be solved using recursion?"
                    }
                ]
            },
            {
                "id": 1749964,
                "content": [
                    {
                        "username": "Ajith_B_J",
                        "content": "This problem having simple and lot of ways\\nhere is easy way  in python\\nreturn haystack.find(needle)\\njust find the needle in haystack"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "I have used sliding window and string library function both in my solution..\\nIs it right way?"
                    },
                    {
                        "username": "rohit6386",
                        "content": "I just used sliding window algorithm for this"
                    },
                    {
                        "username": "MousePotatoa",
                        "content": "I see text and a pattern to match... regex~~"
                    },
                    {
                        "username": "MishaChernov",
                        "content": "It would be better to notice about time/space complexity or \"do not use build-in methods\" to make it as \"Medium\" problem, without this it's \"Easy\""
                    },
                    {
                        "username": "bharath_king77",
                        "content": "May be this is easiest medium question ever \\nJust finished it with 1 line of code"
                    },
                    {
                        "username": "xxxxtj",
                        "content": "This should be easy, no? Especially in python using startswith() ?\\n```\\ndef strStr(self, haystack: str, needle: str) -> int:\\n        for i,l in enumerate(haystack):\\n            if haystack[i::].startswith(needle):\\n                return i\\n        return -1\\n```"
                    },
                    {
                        "username": "__vaxeral",
                        "content": "My solution tried to optimize by iterating both forward and backward at the same time for each character."
                    },
                    {
                        "username": "gaurizade",
                        "content": "Input = \"hello\" \"ll\"\\noutput = 0\\nexpected = 2\\n\\nWhy expected is 2 ?\\n"
                    },
                    {
                        "username": "MaximPLV",
                        "content": "because the first l is on index 2"
                    },
                    {
                        "username": "ritikanandsr123",
                        "content": "can it be solved using recursion?"
                    }
                ]
            },
            {
                "id": 1740839,
                "content": [
                    {
                        "username": "Dec0ySec",
                        "content": "using substring is kinda cheat"
                    },
                    {
                        "username": "ujjwal1234",
                        "content": "\nwhy is it showing -1 when i am submitting the code. but when i am running the test case it is showing correct\n\nhaystack =\n\"mississippi\"\nneedle =\n\"issippi\"\nOutput\n4\nExpected\n-1\n "
                    },
                    {
                        "username": "Vasanth_Kumar_29_19",
                        "content": "ip\\n\"hello\"\\n\"ll\"\\nop - 0\\nexpected - 2\\n??"
                    },
                    {
                        "username": "charonme",
                        "content": "yes that\\'s correct, the \"ll\" needle starts at index 2 of the haystack"
                    },
                    {
                        "username": "vinaykumarbaithi04",
                        "content": "i did in c# but it says unhandled exception \\n"
                    },
                    {
                        "username": "hamaresh",
                        "content": "I am facing issue with leetcode compiler i.e, it shows wrong output while running test cases of python code but this code gives correct output while running on python IDLE or spyder or jupyter note book."
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "class Solution {\n    public int strStr(String haystack, String needle) {\n        if(haystack.contains(needle)){\n            int i = haystack.indexOf(needle);\n            return i;\n        }else{\n            return -1;\n        }\n    }\n}"
                    },
                    {
                        "username": "Vikashrathour",
                        "content": "[leetcode](https://leetcode.com)class Solution {\\n    public int strStr(String haystack, String needle) {\\n        for(int i=0;i<haystack.length();i++){\\n            for(int j=i+1;j<=haystack.length();j++){\\n                if(subString(haystack.substring(i,j),needle)==true)\\n                     return i;\\n            }\\n        }\\n        return -1;\\n    }\\n    public static boolean subString(String str,String s){\\n        if(str.equals(s))\\n           return true;\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "js_27",
                        "content": "// How Can I Optimise It more ??   \\n\\n`\\nclass Solution {\\n    public int strStr(String haystack, String needle) \\n    {\\n        int n = needle.length();\\n        if(haystack.length() < needle.length())\\n        {\\n            return -1;\\n        }\\n        for(int i=0  ; i < haystack.length() ; i++)\\n        {\\n            if(haystack.charAt(i) == needle.charAt(0))\\n            {\\n                if(i+n <= haystack.length())\\n                {\\n                    String a = haystack.substring(i,i+n);\\n                    if(a.equals(needle))\\n                    {\\n                        return i;\\n                    }\\n                }\\n            }\\n            else\\n            {\\n                continue;\\n            }\\n        }\\n        return -1;      \\n    }\\n}\\n\\n`"
                    },
                    {
                        "username": "Shubham_198",
                        "content": "3 Line Code C++ Runtime:0ms\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        int ans2=haystack.find(needle);\\n        if(ans2!=-1){\\n            return ans2;\\n        }\\n        else\\n        return -1;\\n    }\\n};"
                    },
                    {
                        "username": "Ashish_252",
                        "content": "One Line Solution\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n        return ( haystack.indexOf(needle));\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1740017,
                "content": [
                    {
                        "username": "Dec0ySec",
                        "content": "using substring is kinda cheat"
                    },
                    {
                        "username": "ujjwal1234",
                        "content": "\nwhy is it showing -1 when i am submitting the code. but when i am running the test case it is showing correct\n\nhaystack =\n\"mississippi\"\nneedle =\n\"issippi\"\nOutput\n4\nExpected\n-1\n "
                    },
                    {
                        "username": "Vasanth_Kumar_29_19",
                        "content": "ip\\n\"hello\"\\n\"ll\"\\nop - 0\\nexpected - 2\\n??"
                    },
                    {
                        "username": "charonme",
                        "content": "yes that\\'s correct, the \"ll\" needle starts at index 2 of the haystack"
                    },
                    {
                        "username": "vinaykumarbaithi04",
                        "content": "i did in c# but it says unhandled exception \\n"
                    },
                    {
                        "username": "hamaresh",
                        "content": "I am facing issue with leetcode compiler i.e, it shows wrong output while running test cases of python code but this code gives correct output while running on python IDLE or spyder or jupyter note book."
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "class Solution {\n    public int strStr(String haystack, String needle) {\n        if(haystack.contains(needle)){\n            int i = haystack.indexOf(needle);\n            return i;\n        }else{\n            return -1;\n        }\n    }\n}"
                    },
                    {
                        "username": "Vikashrathour",
                        "content": "[leetcode](https://leetcode.com)class Solution {\\n    public int strStr(String haystack, String needle) {\\n        for(int i=0;i<haystack.length();i++){\\n            for(int j=i+1;j<=haystack.length();j++){\\n                if(subString(haystack.substring(i,j),needle)==true)\\n                     return i;\\n            }\\n        }\\n        return -1;\\n    }\\n    public static boolean subString(String str,String s){\\n        if(str.equals(s))\\n           return true;\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "js_27",
                        "content": "// How Can I Optimise It more ??   \\n\\n`\\nclass Solution {\\n    public int strStr(String haystack, String needle) \\n    {\\n        int n = needle.length();\\n        if(haystack.length() < needle.length())\\n        {\\n            return -1;\\n        }\\n        for(int i=0  ; i < haystack.length() ; i++)\\n        {\\n            if(haystack.charAt(i) == needle.charAt(0))\\n            {\\n                if(i+n <= haystack.length())\\n                {\\n                    String a = haystack.substring(i,i+n);\\n                    if(a.equals(needle))\\n                    {\\n                        return i;\\n                    }\\n                }\\n            }\\n            else\\n            {\\n                continue;\\n            }\\n        }\\n        return -1;      \\n    }\\n}\\n\\n`"
                    },
                    {
                        "username": "Shubham_198",
                        "content": "3 Line Code C++ Runtime:0ms\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        int ans2=haystack.find(needle);\\n        if(ans2!=-1){\\n            return ans2;\\n        }\\n        else\\n        return -1;\\n    }\\n};"
                    },
                    {
                        "username": "Ashish_252",
                        "content": "One Line Solution\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n        return ( haystack.indexOf(needle));\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1738308,
                "content": [
                    {
                        "username": "Dec0ySec",
                        "content": "using substring is kinda cheat"
                    },
                    {
                        "username": "ujjwal1234",
                        "content": "\nwhy is it showing -1 when i am submitting the code. but when i am running the test case it is showing correct\n\nhaystack =\n\"mississippi\"\nneedle =\n\"issippi\"\nOutput\n4\nExpected\n-1\n "
                    },
                    {
                        "username": "Vasanth_Kumar_29_19",
                        "content": "ip\\n\"hello\"\\n\"ll\"\\nop - 0\\nexpected - 2\\n??"
                    },
                    {
                        "username": "charonme",
                        "content": "yes that\\'s correct, the \"ll\" needle starts at index 2 of the haystack"
                    },
                    {
                        "username": "vinaykumarbaithi04",
                        "content": "i did in c# but it says unhandled exception \\n"
                    },
                    {
                        "username": "hamaresh",
                        "content": "I am facing issue with leetcode compiler i.e, it shows wrong output while running test cases of python code but this code gives correct output while running on python IDLE or spyder or jupyter note book."
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "class Solution {\n    public int strStr(String haystack, String needle) {\n        if(haystack.contains(needle)){\n            int i = haystack.indexOf(needle);\n            return i;\n        }else{\n            return -1;\n        }\n    }\n}"
                    },
                    {
                        "username": "Vikashrathour",
                        "content": "[leetcode](https://leetcode.com)class Solution {\\n    public int strStr(String haystack, String needle) {\\n        for(int i=0;i<haystack.length();i++){\\n            for(int j=i+1;j<=haystack.length();j++){\\n                if(subString(haystack.substring(i,j),needle)==true)\\n                     return i;\\n            }\\n        }\\n        return -1;\\n    }\\n    public static boolean subString(String str,String s){\\n        if(str.equals(s))\\n           return true;\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "js_27",
                        "content": "// How Can I Optimise It more ??   \\n\\n`\\nclass Solution {\\n    public int strStr(String haystack, String needle) \\n    {\\n        int n = needle.length();\\n        if(haystack.length() < needle.length())\\n        {\\n            return -1;\\n        }\\n        for(int i=0  ; i < haystack.length() ; i++)\\n        {\\n            if(haystack.charAt(i) == needle.charAt(0))\\n            {\\n                if(i+n <= haystack.length())\\n                {\\n                    String a = haystack.substring(i,i+n);\\n                    if(a.equals(needle))\\n                    {\\n                        return i;\\n                    }\\n                }\\n            }\\n            else\\n            {\\n                continue;\\n            }\\n        }\\n        return -1;      \\n    }\\n}\\n\\n`"
                    },
                    {
                        "username": "Shubham_198",
                        "content": "3 Line Code C++ Runtime:0ms\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        int ans2=haystack.find(needle);\\n        if(ans2!=-1){\\n            return ans2;\\n        }\\n        else\\n        return -1;\\n    }\\n};"
                    },
                    {
                        "username": "Ashish_252",
                        "content": "One Line Solution\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n        return ( haystack.indexOf(needle));\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1735714,
                "content": [
                    {
                        "username": "Dec0ySec",
                        "content": "using substring is kinda cheat"
                    },
                    {
                        "username": "ujjwal1234",
                        "content": "\nwhy is it showing -1 when i am submitting the code. but when i am running the test case it is showing correct\n\nhaystack =\n\"mississippi\"\nneedle =\n\"issippi\"\nOutput\n4\nExpected\n-1\n "
                    },
                    {
                        "username": "Vasanth_Kumar_29_19",
                        "content": "ip\\n\"hello\"\\n\"ll\"\\nop - 0\\nexpected - 2\\n??"
                    },
                    {
                        "username": "charonme",
                        "content": "yes that\\'s correct, the \"ll\" needle starts at index 2 of the haystack"
                    },
                    {
                        "username": "vinaykumarbaithi04",
                        "content": "i did in c# but it says unhandled exception \\n"
                    },
                    {
                        "username": "hamaresh",
                        "content": "I am facing issue with leetcode compiler i.e, it shows wrong output while running test cases of python code but this code gives correct output while running on python IDLE or spyder or jupyter note book."
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "class Solution {\n    public int strStr(String haystack, String needle) {\n        if(haystack.contains(needle)){\n            int i = haystack.indexOf(needle);\n            return i;\n        }else{\n            return -1;\n        }\n    }\n}"
                    },
                    {
                        "username": "Vikashrathour",
                        "content": "[leetcode](https://leetcode.com)class Solution {\\n    public int strStr(String haystack, String needle) {\\n        for(int i=0;i<haystack.length();i++){\\n            for(int j=i+1;j<=haystack.length();j++){\\n                if(subString(haystack.substring(i,j),needle)==true)\\n                     return i;\\n            }\\n        }\\n        return -1;\\n    }\\n    public static boolean subString(String str,String s){\\n        if(str.equals(s))\\n           return true;\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "js_27",
                        "content": "// How Can I Optimise It more ??   \\n\\n`\\nclass Solution {\\n    public int strStr(String haystack, String needle) \\n    {\\n        int n = needle.length();\\n        if(haystack.length() < needle.length())\\n        {\\n            return -1;\\n        }\\n        for(int i=0  ; i < haystack.length() ; i++)\\n        {\\n            if(haystack.charAt(i) == needle.charAt(0))\\n            {\\n                if(i+n <= haystack.length())\\n                {\\n                    String a = haystack.substring(i,i+n);\\n                    if(a.equals(needle))\\n                    {\\n                        return i;\\n                    }\\n                }\\n            }\\n            else\\n            {\\n                continue;\\n            }\\n        }\\n        return -1;      \\n    }\\n}\\n\\n`"
                    },
                    {
                        "username": "Shubham_198",
                        "content": "3 Line Code C++ Runtime:0ms\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        int ans2=haystack.find(needle);\\n        if(ans2!=-1){\\n            return ans2;\\n        }\\n        else\\n        return -1;\\n    }\\n};"
                    },
                    {
                        "username": "Ashish_252",
                        "content": "One Line Solution\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n        return ( haystack.indexOf(needle));\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1735376,
                "content": [
                    {
                        "username": "Dec0ySec",
                        "content": "using substring is kinda cheat"
                    },
                    {
                        "username": "ujjwal1234",
                        "content": "\nwhy is it showing -1 when i am submitting the code. but when i am running the test case it is showing correct\n\nhaystack =\n\"mississippi\"\nneedle =\n\"issippi\"\nOutput\n4\nExpected\n-1\n "
                    },
                    {
                        "username": "Vasanth_Kumar_29_19",
                        "content": "ip\\n\"hello\"\\n\"ll\"\\nop - 0\\nexpected - 2\\n??"
                    },
                    {
                        "username": "charonme",
                        "content": "yes that\\'s correct, the \"ll\" needle starts at index 2 of the haystack"
                    },
                    {
                        "username": "vinaykumarbaithi04",
                        "content": "i did in c# but it says unhandled exception \\n"
                    },
                    {
                        "username": "hamaresh",
                        "content": "I am facing issue with leetcode compiler i.e, it shows wrong output while running test cases of python code but this code gives correct output while running on python IDLE or spyder or jupyter note book."
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "class Solution {\n    public int strStr(String haystack, String needle) {\n        if(haystack.contains(needle)){\n            int i = haystack.indexOf(needle);\n            return i;\n        }else{\n            return -1;\n        }\n    }\n}"
                    },
                    {
                        "username": "Vikashrathour",
                        "content": "[leetcode](https://leetcode.com)class Solution {\\n    public int strStr(String haystack, String needle) {\\n        for(int i=0;i<haystack.length();i++){\\n            for(int j=i+1;j<=haystack.length();j++){\\n                if(subString(haystack.substring(i,j),needle)==true)\\n                     return i;\\n            }\\n        }\\n        return -1;\\n    }\\n    public static boolean subString(String str,String s){\\n        if(str.equals(s))\\n           return true;\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "js_27",
                        "content": "// How Can I Optimise It more ??   \\n\\n`\\nclass Solution {\\n    public int strStr(String haystack, String needle) \\n    {\\n        int n = needle.length();\\n        if(haystack.length() < needle.length())\\n        {\\n            return -1;\\n        }\\n        for(int i=0  ; i < haystack.length() ; i++)\\n        {\\n            if(haystack.charAt(i) == needle.charAt(0))\\n            {\\n                if(i+n <= haystack.length())\\n                {\\n                    String a = haystack.substring(i,i+n);\\n                    if(a.equals(needle))\\n                    {\\n                        return i;\\n                    }\\n                }\\n            }\\n            else\\n            {\\n                continue;\\n            }\\n        }\\n        return -1;      \\n    }\\n}\\n\\n`"
                    },
                    {
                        "username": "Shubham_198",
                        "content": "3 Line Code C++ Runtime:0ms\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        int ans2=haystack.find(needle);\\n        if(ans2!=-1){\\n            return ans2;\\n        }\\n        else\\n        return -1;\\n    }\\n};"
                    },
                    {
                        "username": "Ashish_252",
                        "content": "One Line Solution\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n        return ( haystack.indexOf(needle));\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1724552,
                "content": [
                    {
                        "username": "Dec0ySec",
                        "content": "using substring is kinda cheat"
                    },
                    {
                        "username": "ujjwal1234",
                        "content": "\nwhy is it showing -1 when i am submitting the code. but when i am running the test case it is showing correct\n\nhaystack =\n\"mississippi\"\nneedle =\n\"issippi\"\nOutput\n4\nExpected\n-1\n "
                    },
                    {
                        "username": "Vasanth_Kumar_29_19",
                        "content": "ip\\n\"hello\"\\n\"ll\"\\nop - 0\\nexpected - 2\\n??"
                    },
                    {
                        "username": "charonme",
                        "content": "yes that\\'s correct, the \"ll\" needle starts at index 2 of the haystack"
                    },
                    {
                        "username": "vinaykumarbaithi04",
                        "content": "i did in c# but it says unhandled exception \\n"
                    },
                    {
                        "username": "hamaresh",
                        "content": "I am facing issue with leetcode compiler i.e, it shows wrong output while running test cases of python code but this code gives correct output while running on python IDLE or spyder or jupyter note book."
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "class Solution {\n    public int strStr(String haystack, String needle) {\n        if(haystack.contains(needle)){\n            int i = haystack.indexOf(needle);\n            return i;\n        }else{\n            return -1;\n        }\n    }\n}"
                    },
                    {
                        "username": "Vikashrathour",
                        "content": "[leetcode](https://leetcode.com)class Solution {\\n    public int strStr(String haystack, String needle) {\\n        for(int i=0;i<haystack.length();i++){\\n            for(int j=i+1;j<=haystack.length();j++){\\n                if(subString(haystack.substring(i,j),needle)==true)\\n                     return i;\\n            }\\n        }\\n        return -1;\\n    }\\n    public static boolean subString(String str,String s){\\n        if(str.equals(s))\\n           return true;\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "js_27",
                        "content": "// How Can I Optimise It more ??   \\n\\n`\\nclass Solution {\\n    public int strStr(String haystack, String needle) \\n    {\\n        int n = needle.length();\\n        if(haystack.length() < needle.length())\\n        {\\n            return -1;\\n        }\\n        for(int i=0  ; i < haystack.length() ; i++)\\n        {\\n            if(haystack.charAt(i) == needle.charAt(0))\\n            {\\n                if(i+n <= haystack.length())\\n                {\\n                    String a = haystack.substring(i,i+n);\\n                    if(a.equals(needle))\\n                    {\\n                        return i;\\n                    }\\n                }\\n            }\\n            else\\n            {\\n                continue;\\n            }\\n        }\\n        return -1;      \\n    }\\n}\\n\\n`"
                    },
                    {
                        "username": "Shubham_198",
                        "content": "3 Line Code C++ Runtime:0ms\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        int ans2=haystack.find(needle);\\n        if(ans2!=-1){\\n            return ans2;\\n        }\\n        else\\n        return -1;\\n    }\\n};"
                    },
                    {
                        "username": "Ashish_252",
                        "content": "One Line Solution\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n        return ( haystack.indexOf(needle));\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1723170,
                "content": [
                    {
                        "username": "Dec0ySec",
                        "content": "using substring is kinda cheat"
                    },
                    {
                        "username": "ujjwal1234",
                        "content": "\nwhy is it showing -1 when i am submitting the code. but when i am running the test case it is showing correct\n\nhaystack =\n\"mississippi\"\nneedle =\n\"issippi\"\nOutput\n4\nExpected\n-1\n "
                    },
                    {
                        "username": "Vasanth_Kumar_29_19",
                        "content": "ip\\n\"hello\"\\n\"ll\"\\nop - 0\\nexpected - 2\\n??"
                    },
                    {
                        "username": "charonme",
                        "content": "yes that\\'s correct, the \"ll\" needle starts at index 2 of the haystack"
                    },
                    {
                        "username": "vinaykumarbaithi04",
                        "content": "i did in c# but it says unhandled exception \\n"
                    },
                    {
                        "username": "hamaresh",
                        "content": "I am facing issue with leetcode compiler i.e, it shows wrong output while running test cases of python code but this code gives correct output while running on python IDLE or spyder or jupyter note book."
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "class Solution {\n    public int strStr(String haystack, String needle) {\n        if(haystack.contains(needle)){\n            int i = haystack.indexOf(needle);\n            return i;\n        }else{\n            return -1;\n        }\n    }\n}"
                    },
                    {
                        "username": "Vikashrathour",
                        "content": "[leetcode](https://leetcode.com)class Solution {\\n    public int strStr(String haystack, String needle) {\\n        for(int i=0;i<haystack.length();i++){\\n            for(int j=i+1;j<=haystack.length();j++){\\n                if(subString(haystack.substring(i,j),needle)==true)\\n                     return i;\\n            }\\n        }\\n        return -1;\\n    }\\n    public static boolean subString(String str,String s){\\n        if(str.equals(s))\\n           return true;\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "js_27",
                        "content": "// How Can I Optimise It more ??   \\n\\n`\\nclass Solution {\\n    public int strStr(String haystack, String needle) \\n    {\\n        int n = needle.length();\\n        if(haystack.length() < needle.length())\\n        {\\n            return -1;\\n        }\\n        for(int i=0  ; i < haystack.length() ; i++)\\n        {\\n            if(haystack.charAt(i) == needle.charAt(0))\\n            {\\n                if(i+n <= haystack.length())\\n                {\\n                    String a = haystack.substring(i,i+n);\\n                    if(a.equals(needle))\\n                    {\\n                        return i;\\n                    }\\n                }\\n            }\\n            else\\n            {\\n                continue;\\n            }\\n        }\\n        return -1;      \\n    }\\n}\\n\\n`"
                    },
                    {
                        "username": "Shubham_198",
                        "content": "3 Line Code C++ Runtime:0ms\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        int ans2=haystack.find(needle);\\n        if(ans2!=-1){\\n            return ans2;\\n        }\\n        else\\n        return -1;\\n    }\\n};"
                    },
                    {
                        "username": "Ashish_252",
                        "content": "One Line Solution\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n        return ( haystack.indexOf(needle));\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1721652,
                "content": [
                    {
                        "username": "Dec0ySec",
                        "content": "using substring is kinda cheat"
                    },
                    {
                        "username": "ujjwal1234",
                        "content": "\nwhy is it showing -1 when i am submitting the code. but when i am running the test case it is showing correct\n\nhaystack =\n\"mississippi\"\nneedle =\n\"issippi\"\nOutput\n4\nExpected\n-1\n "
                    },
                    {
                        "username": "Vasanth_Kumar_29_19",
                        "content": "ip\\n\"hello\"\\n\"ll\"\\nop - 0\\nexpected - 2\\n??"
                    },
                    {
                        "username": "charonme",
                        "content": "yes that\\'s correct, the \"ll\" needle starts at index 2 of the haystack"
                    },
                    {
                        "username": "vinaykumarbaithi04",
                        "content": "i did in c# but it says unhandled exception \\n"
                    },
                    {
                        "username": "hamaresh",
                        "content": "I am facing issue with leetcode compiler i.e, it shows wrong output while running test cases of python code but this code gives correct output while running on python IDLE or spyder or jupyter note book."
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "class Solution {\n    public int strStr(String haystack, String needle) {\n        if(haystack.contains(needle)){\n            int i = haystack.indexOf(needle);\n            return i;\n        }else{\n            return -1;\n        }\n    }\n}"
                    },
                    {
                        "username": "Vikashrathour",
                        "content": "[leetcode](https://leetcode.com)class Solution {\\n    public int strStr(String haystack, String needle) {\\n        for(int i=0;i<haystack.length();i++){\\n            for(int j=i+1;j<=haystack.length();j++){\\n                if(subString(haystack.substring(i,j),needle)==true)\\n                     return i;\\n            }\\n        }\\n        return -1;\\n    }\\n    public static boolean subString(String str,String s){\\n        if(str.equals(s))\\n           return true;\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "js_27",
                        "content": "// How Can I Optimise It more ??   \\n\\n`\\nclass Solution {\\n    public int strStr(String haystack, String needle) \\n    {\\n        int n = needle.length();\\n        if(haystack.length() < needle.length())\\n        {\\n            return -1;\\n        }\\n        for(int i=0  ; i < haystack.length() ; i++)\\n        {\\n            if(haystack.charAt(i) == needle.charAt(0))\\n            {\\n                if(i+n <= haystack.length())\\n                {\\n                    String a = haystack.substring(i,i+n);\\n                    if(a.equals(needle))\\n                    {\\n                        return i;\\n                    }\\n                }\\n            }\\n            else\\n            {\\n                continue;\\n            }\\n        }\\n        return -1;      \\n    }\\n}\\n\\n`"
                    },
                    {
                        "username": "Shubham_198",
                        "content": "3 Line Code C++ Runtime:0ms\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        int ans2=haystack.find(needle);\\n        if(ans2!=-1){\\n            return ans2;\\n        }\\n        else\\n        return -1;\\n    }\\n};"
                    },
                    {
                        "username": "Ashish_252",
                        "content": "One Line Solution\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n        return ( haystack.indexOf(needle));\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1717432,
                "content": [
                    {
                        "username": "Dec0ySec",
                        "content": "using substring is kinda cheat"
                    },
                    {
                        "username": "ujjwal1234",
                        "content": "\nwhy is it showing -1 when i am submitting the code. but when i am running the test case it is showing correct\n\nhaystack =\n\"mississippi\"\nneedle =\n\"issippi\"\nOutput\n4\nExpected\n-1\n "
                    },
                    {
                        "username": "Vasanth_Kumar_29_19",
                        "content": "ip\\n\"hello\"\\n\"ll\"\\nop - 0\\nexpected - 2\\n??"
                    },
                    {
                        "username": "charonme",
                        "content": "yes that\\'s correct, the \"ll\" needle starts at index 2 of the haystack"
                    },
                    {
                        "username": "vinaykumarbaithi04",
                        "content": "i did in c# but it says unhandled exception \\n"
                    },
                    {
                        "username": "hamaresh",
                        "content": "I am facing issue with leetcode compiler i.e, it shows wrong output while running test cases of python code but this code gives correct output while running on python IDLE or spyder or jupyter note book."
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "class Solution {\n    public int strStr(String haystack, String needle) {\n        if(haystack.contains(needle)){\n            int i = haystack.indexOf(needle);\n            return i;\n        }else{\n            return -1;\n        }\n    }\n}"
                    },
                    {
                        "username": "Vikashrathour",
                        "content": "[leetcode](https://leetcode.com)class Solution {\\n    public int strStr(String haystack, String needle) {\\n        for(int i=0;i<haystack.length();i++){\\n            for(int j=i+1;j<=haystack.length();j++){\\n                if(subString(haystack.substring(i,j),needle)==true)\\n                     return i;\\n            }\\n        }\\n        return -1;\\n    }\\n    public static boolean subString(String str,String s){\\n        if(str.equals(s))\\n           return true;\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "js_27",
                        "content": "// How Can I Optimise It more ??   \\n\\n`\\nclass Solution {\\n    public int strStr(String haystack, String needle) \\n    {\\n        int n = needle.length();\\n        if(haystack.length() < needle.length())\\n        {\\n            return -1;\\n        }\\n        for(int i=0  ; i < haystack.length() ; i++)\\n        {\\n            if(haystack.charAt(i) == needle.charAt(0))\\n            {\\n                if(i+n <= haystack.length())\\n                {\\n                    String a = haystack.substring(i,i+n);\\n                    if(a.equals(needle))\\n                    {\\n                        return i;\\n                    }\\n                }\\n            }\\n            else\\n            {\\n                continue;\\n            }\\n        }\\n        return -1;      \\n    }\\n}\\n\\n`"
                    },
                    {
                        "username": "Shubham_198",
                        "content": "3 Line Code C++ Runtime:0ms\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        int ans2=haystack.find(needle);\\n        if(ans2!=-1){\\n            return ans2;\\n        }\\n        else\\n        return -1;\\n    }\\n};"
                    },
                    {
                        "username": "Ashish_252",
                        "content": "One Line Solution\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n        return ( haystack.indexOf(needle));\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1708503,
                "content": [
                    {
                        "username": "Dec0ySec",
                        "content": "using substring is kinda cheat"
                    },
                    {
                        "username": "ujjwal1234",
                        "content": "\nwhy is it showing -1 when i am submitting the code. but when i am running the test case it is showing correct\n\nhaystack =\n\"mississippi\"\nneedle =\n\"issippi\"\nOutput\n4\nExpected\n-1\n "
                    },
                    {
                        "username": "Vasanth_Kumar_29_19",
                        "content": "ip\\n\"hello\"\\n\"ll\"\\nop - 0\\nexpected - 2\\n??"
                    },
                    {
                        "username": "charonme",
                        "content": "yes that\\'s correct, the \"ll\" needle starts at index 2 of the haystack"
                    },
                    {
                        "username": "vinaykumarbaithi04",
                        "content": "i did in c# but it says unhandled exception \\n"
                    },
                    {
                        "username": "hamaresh",
                        "content": "I am facing issue with leetcode compiler i.e, it shows wrong output while running test cases of python code but this code gives correct output while running on python IDLE or spyder or jupyter note book."
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "class Solution {\n    public int strStr(String haystack, String needle) {\n        if(haystack.contains(needle)){\n            int i = haystack.indexOf(needle);\n            return i;\n        }else{\n            return -1;\n        }\n    }\n}"
                    },
                    {
                        "username": "Vikashrathour",
                        "content": "[leetcode](https://leetcode.com)class Solution {\\n    public int strStr(String haystack, String needle) {\\n        for(int i=0;i<haystack.length();i++){\\n            for(int j=i+1;j<=haystack.length();j++){\\n                if(subString(haystack.substring(i,j),needle)==true)\\n                     return i;\\n            }\\n        }\\n        return -1;\\n    }\\n    public static boolean subString(String str,String s){\\n        if(str.equals(s))\\n           return true;\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "js_27",
                        "content": "// How Can I Optimise It more ??   \\n\\n`\\nclass Solution {\\n    public int strStr(String haystack, String needle) \\n    {\\n        int n = needle.length();\\n        if(haystack.length() < needle.length())\\n        {\\n            return -1;\\n        }\\n        for(int i=0  ; i < haystack.length() ; i++)\\n        {\\n            if(haystack.charAt(i) == needle.charAt(0))\\n            {\\n                if(i+n <= haystack.length())\\n                {\\n                    String a = haystack.substring(i,i+n);\\n                    if(a.equals(needle))\\n                    {\\n                        return i;\\n                    }\\n                }\\n            }\\n            else\\n            {\\n                continue;\\n            }\\n        }\\n        return -1;      \\n    }\\n}\\n\\n`"
                    },
                    {
                        "username": "Shubham_198",
                        "content": "3 Line Code C++ Runtime:0ms\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        int ans2=haystack.find(needle);\\n        if(ans2!=-1){\\n            return ans2;\\n        }\\n        else\\n        return -1;\\n    }\\n};"
                    },
                    {
                        "username": "Ashish_252",
                        "content": "One Line Solution\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n        return ( haystack.indexOf(needle));\\n    }\\n}"
                    }
                ]
            }
        ]
    },
    {
        "title": "Longest Consecutive Sequence",
        "question_content": "<p>Given an unsorted array of integers <code>nums</code>, return <em>the length of the longest consecutive elements sequence.</em></p>\n\n<p>You must write an algorithm that runs in&nbsp;<code>O(n)</code>&nbsp;time.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [100,4,200,1,3,2]\n<strong>Output:</strong> 4\n<strong>Explanation:</strong> The longest consecutive elements sequence is <code>[1, 2, 3, 4]</code>. Therefore its length is 4.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [0,3,7,2,5,8,4,6,0,1]\n<strong>Output:</strong> 9\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>9</sup> &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 41057,
                "title": "simple-o-n-with-explanation-just-walk-each-streak",
                "content": "First turn the input into a *set* of numbers. That takes O(n) and then we can ask in O(1) whether we have a certain number.\\n\\nThen go through the numbers. If the number x is the start of a streak (i.e., x-1 is not in the set), then test y = x+1, x+2, x+3, ... and stop at the first number y *not* in the set. The length of the streak is then simply y-x and we update our global best with that. Since we check each streak only once, this is overall O(n). This ran in 44 ms on the OJ, one of the fastest Python submissions.\\n\\n    def longestConsecutive(self, nums):\\n        nums = set(nums)\\n        best = 0\\n        for x in nums:\\n            if x - 1 not in nums:\\n                y = x + 1\\n                while y in nums:\\n                    y += 1\\n                best = max(best, y - x)\\n        return best",
                "solutionTags": [],
                "code": "First turn the input into a *set* of numbers. That takes O(n) and then we can ask in O(1) whether we have a certain number.\\n\\nThen go through the numbers. If the number x is the start of a streak (i.e., x-1 is not in the set), then test y = x+1, x+2, x+3, ... and stop at the first number y *not* in the set. The length of the streak is then simply y-x and we update our global best with that. Since we check each streak only once, this is overall O(n). This ran in 44 ms on the OJ, one of the fastest Python submissions.\\n\\n    def longestConsecutive(self, nums):\\n        nums = set(nums)\\n        best = 0\\n        for x in nums:\\n            if x - 1 not in nums:\\n                y = x + 1\\n                while y in nums:\\n                    y += 1\\n                best = max(best, y - x)\\n        return best",
                "codeTag": "Python3"
            },
            {
                "id": 41055,
                "title": "my-really-simple-java-o-n-solution-accepted",
                "content": "We will use HashMap. The key thing is to keep track of the sequence length and store that in the boundary points of the sequence. For example, as a result, for sequence {1, 2, 3, 4, 5}, map.get(1) and map.get(5) should both return 5.\\n\\nWhenever a new element **n** is inserted into the map, do two things:\\n\\n 1. See if **n - 1** and **n + 1** exist in the map, and if so, it means there is an existing sequence next to **n**. Variables **left** and **right** will be the length of those two sequences, while **0** means there is no sequence and **n** will be the boundary point later. Store **(left + right + 1)** as the associated value to key **n** into the map.\\n 2. Use **left** and **right** to locate the other end of the sequences to the left and right of **n** respectively, and replace the value with the new length.\\n\\n\\nEverything inside the **for** loop is O(1) so the total time is O(n). Please comment if you see something wrong. Thanks.\\n\\n    public int longestConsecutive(int[] num) {\\n        int res = 0;\\n        HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();\\n        for (int n : num) {\\n            if (!map.containsKey(n)) {\\n                int left = (map.containsKey(n - 1)) ? map.get(n - 1) : 0;\\n                int right = (map.containsKey(n + 1)) ? map.get(n + 1) : 0;\\n                // sum: length of the sequence n is in\\n                int sum = left + right + 1;\\n                map.put(n, sum);\\n                \\n                // keep track of the max length \\n                res = Math.max(res, sum);\\n                \\n                // extend the length to the boundary(s)\\n                // of the sequence\\n                // will do nothing if n has no neighbors\\n                map.put(n - left, sum);\\n                map.put(n + right, sum);\\n            }\\n            else {\\n                // duplicates\\n                continue;\\n            }\\n        }\\n        return res;\\n    }",
                "solutionTags": [],
                "code": "We will use HashMap. The key thing is to keep track of the sequence length and store that in the boundary points of the sequence. For example, as a result, for sequence {1, 2, 3, 4, 5}, map.get(1) and map.get(5) should both return 5.\\n\\nWhenever a new element **n** is inserted into the map, do two things:\\n\\n 1. See if **n - 1** and **n + 1** exist in the map, and if so, it means there is an existing sequence next to **n**. Variables **left** and **right** will be the length of those two sequences, while **0** means there is no sequence and **n** will be the boundary point later. Store **(left + right + 1)** as the associated value to key **n** into the map.\\n 2. Use **left** and **right** to locate the other end of the sequences to the left and right of **n** respectively, and replace the value with the new length.\\n\\n\\nEverything inside the **for** loop is O(1) so the total time is O(n). Please comment if you see something wrong. Thanks.\\n\\n    public int longestConsecutive(int[] num) {\\n        int res = 0;\\n        HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();\\n        for (int n : num) {\\n            if (!map.containsKey(n)) {\\n                int left = (map.containsKey(n - 1)) ? map.get(n - 1) : 0;\\n                int right = (map.containsKey(n + 1)) ? map.get(n + 1) : 0;\\n                // sum: length of the sequence n is in\\n                int sum = left + right + 1;\\n                map.put(n, sum);\\n                \\n                // keep track of the max length \\n                res = Math.max(res, sum);\\n                \\n                // extend the length to the boundary(s)\\n                // of the sequence\\n                // will do nothing if n has no neighbors\\n                map.put(n - left, sum);\\n                map.put(n + right, sum);\\n            }\\n            else {\\n                // duplicates\\n                continue;\\n            }\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3171254,
                "title": "solution",
                "content": "```C++ []\\nint a[100000];\\n\\nint init = [] {\\n    ios_base::sync_with_stdio(false);\\n    cin.tie(nullptr);\\n    ofstream out(\"user.out\");\\n    for (string s; getline(cin, s); out << \\'\\\\n\\') {\\n        if (s.length() == 2) {\\n            out << 0;\\n            continue;\\n        }\\n        int n = 0;\\n        for (int _i = 1, _n = s.length(); _i < _n; ++_i) {\\n            bool _neg = false;\\n            if (s[_i] == \\'-\\') ++_i, _neg = true;\\n            int v = s[_i++] & 15;\\n            while ((s[_i] & 15) < 10) v = v * 10 + (s[_i++] & 15);\\n            if (_neg) v = -v;\\n            a[n++] = v;\\n        }\\n        sort(a, a + n);\\n        int ans = 0;\\n        for (int i = 0; i < n;) {\\n            int i0 = i;\\n            for (++i; i < n && a[i - 1] + 1 >= a[i]; ++i);\\n            ans = max(ans, a[i - 1] - a[i0] + 1);\\n        }\\n        out << ans;\\n    }\\n    out.flush();\\n    exit(0);\\n    return 0;\\n}();\\n\\nclass Solution {\\npublic:\\n    int longestConsecutive(vector<int>) { return 999; }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def longestConsecutive(self, nums: List[int]) -> int:\\n        longest = 0\\n        num_set = set(nums)\\n\\n        for n in num_set:\\n            if (n-1) not in num_set:\\n                length = 1\\n                while (n+length) in num_set:\\n                    length += 1\\n                longest = max(longest, length)\\n        \\n        return longest\\n```\\n\\n```Java []\\nclass Solution {\\n    public int longestConsecutive(int[] nums) {int result = 0;\\n        if (nums.length > 0) {\\n            if (nums.length < 1000) {\\n                Arrays.sort(nums);\\n                int current = 0;\\n                for (int i = 1; i < nums.length; i++) {\\n                    if (nums[i] != nums[i - 1]) {\\n                        if (nums[i] - nums[i - 1] == 1) {\\n                            current++;\\n                        } else {\\n                            if (current + 1 > result) {\\n                                result = current + 1;\\n                            }\\n                            current = 0;\\n                        }\\n                    }\\n                }\\n                if (current + 1 > result) {\\n                    result = current + 1;\\n                }\\n            } else {\\n                int min = Integer.MAX_VALUE;\\n                int max = Integer.MIN_VALUE;\\n                for (int num : nums) {\\n                    if (num > max) {\\n                        max = num;\\n                    }\\n                    if (num < min) {\\n                        min = num;\\n                    }\\n                }\\n                byte[] bits = new byte[max - min + 1];\\n                for (int num : nums) {\\n                    bits[num - min] = 1;\\n                }\\n                int current = 0;\\n                for (byte bit : bits) {\\n                    if (bit > 0) {\\n                        current++;\\n                    } else {\\n                        if (current > result) {\\n                            result = current;\\n                        }\\n                        current = 0;\\n                    }\\n                }\\n                if (current > result) {\\n                    result = current;\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nint a[100000];\\n\\nint init = [] {\\n    ios_base::sync_with_stdio(false);\\n    cin.tie(nullptr);\\n    ofstream out(\"user.out\");\\n    for (string s; getline(cin, s); out << \\'\\\\n\\') {\\n        if (s.length() == 2) {\\n            out << 0;\\n            continue;\\n        }\\n        int n = 0;\\n        for (int _i = 1, _n = s.length(); _i < _n; ++_i) {\\n            bool _neg = false;\\n            if (s[_i] == \\'-\\') ++_i, _neg = true;\\n            int v = s[_i++] & 15;\\n            while ((s[_i] & 15) < 10) v = v * 10 + (s[_i++] & 15);\\n            if (_neg) v = -v;\\n            a[n++] = v;\\n        }\\n        sort(a, a + n);\\n        int ans = 0;\\n        for (int i = 0; i < n;) {\\n            int i0 = i;\\n            for (++i; i < n && a[i - 1] + 1 >= a[i]; ++i);\\n            ans = max(ans, a[i - 1] - a[i0] + 1);\\n        }\\n        out << ans;\\n    }\\n    out.flush();\\n    exit(0);\\n    return 0;\\n}();\\n\\nclass Solution {\\npublic:\\n    int longestConsecutive(vector<int>) { return 999; }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def longestConsecutive(self, nums: List[int]) -> int:\\n        longest = 0\\n        num_set = set(nums)\\n\\n        for n in num_set:\\n            if (n-1) not in num_set:\\n                length = 1\\n                while (n+length) in num_set:\\n                    length += 1\\n                longest = max(longest, length)\\n        \\n        return longest\\n```\n```Java []\\nclass Solution {\\n    public int longestConsecutive(int[] nums) {int result = 0;\\n        if (nums.length > 0) {\\n            if (nums.length < 1000) {\\n                Arrays.sort(nums);\\n                int current = 0;\\n                for (int i = 1; i < nums.length; i++) {\\n                    if (nums[i] != nums[i - 1]) {\\n                        if (nums[i] - nums[i - 1] == 1) {\\n                            current++;\\n                        } else {\\n                            if (current + 1 > result) {\\n                                result = current + 1;\\n                            }\\n                            current = 0;\\n                        }\\n                    }\\n                }\\n                if (current + 1 > result) {\\n                    result = current + 1;\\n                }\\n            } else {\\n                int min = Integer.MAX_VALUE;\\n                int max = Integer.MIN_VALUE;\\n                for (int num : nums) {\\n                    if (num > max) {\\n                        max = num;\\n                    }\\n                    if (num < min) {\\n                        min = num;\\n                    }\\n                }\\n                byte[] bits = new byte[max - min + 1];\\n                for (int num : nums) {\\n                    bits[num - min] = 1;\\n                }\\n                int current = 0;\\n                for (byte bit : bits) {\\n                    if (bit > 0) {\\n                        current++;\\n                    } else {\\n                        if (current > result) {\\n                            result = current;\\n                        }\\n                        current = 0;\\n                    }\\n                }\\n                if (current > result) {\\n                    result = current;\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 41088,
                "title": "possibly-shortest-cpp-solution-only-6-lines",
                "content": "use a hash map to store boundary information of consecutive sequence for each element; there are 4 cases when a new element `i` reached: \\n\\n1) neither `i+1` nor `i-1` has been seen: `m[i]=1`;\\n\\n2) both `i+1` and `i-1` have been seen: extend `m[i+m[i+1]]` and `m[i-m[i-1]]` to each other;\\n\\n3) only `i+1` has been seen: extend `m[i+m[i+1]]` and `m[i]` to each other;\\n\\n4) only `i-1` has been seen: extend `m[i-m[i-1]]` and `m[i]` to each other.\\n\\n\\n```\\nint longestConsecutive(vector<int> &num) {\\n    unordered_map<int, int> m;\\n    int r = 0;\\n    for (int i : num) {\\n        if (m[i]) continue;\\n        r = max(r, m[i] = m[i + m[i + 1]] = m[i - m[i - 1]] = m[i + 1] + m[i - 1] + 1);\\n    }\\n    return r;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint longestConsecutive(vector<int> &num) {\\n    unordered_map<int, int> m;\\n    int r = 0;\\n    for (int i : num) {\\n        if (m[i]) continue;\\n        r = max(r, m[i] = m[i + m[i + 1]] = m[i - m[i - 1]] = m[i + 1] + m[i - 1] + 1);\\n    }\\n    return r;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3171985,
                "title": "best-c-4-solution-hash-table-sorting-brute-force-optimize-one-stop-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can solve this problem using Four approaches. (Here I have explained all the possible solutions of this problem).\\n\\n1. Solved using Array(Three Nested Loop). Brute Force Approach.\\n2. Solved using Array + Sorting. Brute Better Approach.\\n3. Solved using Array + Hash Table(Unordered map). Optimize Approach.\\n4. Solved using Array + Hash Table (Unordered set). Optimize Approach.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can easily understand the All the approaches by seeing the code which is easy to understand with comments.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime complexity is given in code comment.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace complexity is given in code comment.\\n\\n# Code\\n```\\n/*\\n\\n    Time Complexity : O(N^3), The outer loop runs exactly N times, and because currentNumber increments by 1\\n    during each iteration of the while loop, it runs in O(N) time. Then, on each iteration of the while loop, an\\n    O(N) operation in the array is performed. Therefore, this brute force algorithm is really three nested O(N)\\n    loops, which compound multiplicatively to a cubic runtime. Where N is the size of the Array(nums).\\n\\n    Space Complexity : O(1), Constant space.\\n\\n    Using Array(Three Nested Loop). Brute Force Approach.\\n\\n    Note : This will give TLE.\\n\\n*/\\n\\n\\n/***************************************** Approach 1 Code *****************************************/\\n\\nclass Solution {\\nprivate: \\n    bool longestConsecutive(vector<int>& nums, int target){\\n        int n = nums.size();\\n        for(int i=0; i<n; i++){\\n            if(nums[i] == target){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\npublic:\\n    int longestConsecutive(vector<int>& nums) {\\n        int n = nums.size();\\n        int longestConsecutiveSequence = 0;\\n        for(auto num : nums){\\n            int currentNumber = num;\\n            int currentConsecutiveSequence = 1;\\n            while(longestConsecutive(nums, currentNumber+1)){\\n                currentNumber += 1;\\n                currentConsecutiveSequence += 1;\\n            }\\n            longestConsecutiveSequence = max(longestConsecutiveSequence, currentConsecutiveSequence);\\n        }\\n        return longestConsecutiveSequence;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(NlogN), The main for loop does constant work N times, so the algorithm\\'s time complexity\\n    is dominated by the invocation of sorting algorithm, which will run in O(NlogN) time for any sensible\\n    implementation. Where N is the size of the Array(nums).\\n\\n    Space Complexity : O(1), For the implementations provided here, the space complexity is constant because we\\n    sort the input array in place.\\n\\n    Solved using Array + Sorting. Brute Better Approach.\\n\\n*/\\n\\n\\n/***************************************** Approach 2 Code *****************************************/\\n\\nclass Solution {\\npublic:\\n    int longestConsecutive(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n == 0){\\n            return 0;\\n        }\\n        sort(nums.begin(), nums.end());\\n        int currentConsecutiveSequence = 1;\\n        int longestConsecutiveSequence = 0;\\n        for(int i=1; i<n; i++){\\n            if(nums[i] != nums[i-1]){\\n                if(nums[i] == nums[i-1] + 1){\\n                    currentConsecutiveSequence++;\\n                }\\n                else{\\n                    longestConsecutiveSequence = max(longestConsecutiveSequence, currentConsecutiveSequence);\\n                    currentConsecutiveSequence = 1;\\n                }\\n            }\\n        }\\n        return max(longestConsecutiveSequence, currentConsecutiveSequence);\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(N), We are traversing the Array(nums) thrice which creates the time complexity O(N)\\n    becuase Unordered map operating takes constant time. Where N is the size of the Array(nums).\\n\\n    Space Complexity : O(N), Unordered map space.\\n\\n    Solved using Array + Hash Table(Unordered map). Optimize Approach.\\n\\n*/\\n\\n\\n/***************************************** Approach 3 Code *****************************************/\\n\\nclass Solution {\\npublic:\\n    int longestConsecutive(vector<int>& nums) {\\n        unordered_map<int, bool> map;\\n        for(int i = 0; i<nums.size(); i++){\\n            map[nums[i]] = true;\\n        }\\n        for(int i=0; i<nums.size(); i++){\\n            if(map.count(nums[i]-1) > 0){\\n                map[nums[i]] = false;\\n            }\\n        }\\n        int maxlen = 0;\\n        for(int i=0; i<nums.size(); i++){\\n            if(map[nums[i]] == true){\\n                int j=0; int count=0;\\n                while(map.count(nums[i]+j) > 0){\\n                    j++;\\n                    count++;\\n                }\\n                if(count>maxlen){\\n                    maxlen = count;\\n                }\\n            }\\n        }\\n        return maxlen;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(N), Although the time complexity appears to be quadratic due to the while loop nested\\n    within the for loop, closer inspection reveals it to be linear. Because the while loop is reached only when\\n    marks the beginning of a sequence (i.e. currentNumber-1 is not present in nums), the while loop can only run\\n    for N iterations throughout the entire runtime of the algorithm. This means that despite looking like O(N^2)\\n    complexity, the nested loops actually run in O(N+N)=O(N) time. All other computations occur in constant\\n    time, so the overall runtime is linear. Where N is the size of the Array(nums).\\n\\n    Space Complexity : O(N), Unordered set space.\\n\\n    Solved using Array + Hash Table(Unordered set). Optimise Approach.\\n\\n*/\\n\\n\\n/***************************************** Approach 4 Code *****************************************/\\n\\nclass Solution {\\npublic:\\n    int longestConsecutive(vector<int>& nums) {\\n        unordered_set<int> set;\\n        for(int num : nums){\\n            set.insert(num);\\n        }\\n        int longestConsecutiveSequence = 0;\\n        for(int num : nums){\\n            if(set.find(num-1) == set.end()){\\n                int currentNumber = num;\\n                int currentConsecutiveSequence = 1;\\n                while(set.find(currentNumber+1) != set.end()){\\n                    currentNumber++;\\n                    currentConsecutiveSequence++;\\n                }\\n                longestConsecutiveSequence = max(longestConsecutiveSequence, currentConsecutiveSequence);\\n            }\\n        }\\n        return longestConsecutiveSequence;\\n    }\\n};\\n```\\n***IF YOU LIKE THE SOLUTION THEN PLEASE UPVOTE MY SOLUTION BECAUSE IT GIVES ME MOTIVATION TO REGULARLY POST THE SOLUTION.***\\n\\n![WhatsApp Image 2023-02-10 at 19.01.02.jpeg](https://assets.leetcode.com/users/images/0a95fea4-64f4-4502-82aa-41db6d77c05c_1676054939.8270252.jpeg)",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Sort"
                ],
                "code": "```\\n/*\\n\\n    Time Complexity : O(N^3), The outer loop runs exactly N times, and because currentNumber increments by 1\\n    during each iteration of the while loop, it runs in O(N) time. Then, on each iteration of the while loop, an\\n    O(N) operation in the array is performed. Therefore, this brute force algorithm is really three nested O(N)\\n    loops, which compound multiplicatively to a cubic runtime. Where N is the size of the Array(nums).\\n\\n    Space Complexity : O(1), Constant space.\\n\\n    Using Array(Three Nested Loop). Brute Force Approach.\\n\\n    Note : This will give TLE.\\n\\n*/\\n\\n\\n/***************************************** Approach 1 Code *****************************************/\\n\\nclass Solution {\\nprivate: \\n    bool longestConsecutive(vector<int>& nums, int target){\\n        int n = nums.size();\\n        for(int i=0; i<n; i++){\\n            if(nums[i] == target){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\npublic:\\n    int longestConsecutive(vector<int>& nums) {\\n        int n = nums.size();\\n        int longestConsecutiveSequence = 0;\\n        for(auto num : nums){\\n            int currentNumber = num;\\n            int currentConsecutiveSequence = 1;\\n            while(longestConsecutive(nums, currentNumber+1)){\\n                currentNumber += 1;\\n                currentConsecutiveSequence += 1;\\n            }\\n            longestConsecutiveSequence = max(longestConsecutiveSequence, currentConsecutiveSequence);\\n        }\\n        return longestConsecutiveSequence;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(NlogN), The main for loop does constant work N times, so the algorithm\\'s time complexity\\n    is dominated by the invocation of sorting algorithm, which will run in O(NlogN) time for any sensible\\n    implementation. Where N is the size of the Array(nums).\\n\\n    Space Complexity : O(1), For the implementations provided here, the space complexity is constant because we\\n    sort the input array in place.\\n\\n    Solved using Array + Sorting. Brute Better Approach.\\n\\n*/\\n\\n\\n/***************************************** Approach 2 Code *****************************************/\\n\\nclass Solution {\\npublic:\\n    int longestConsecutive(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n == 0){\\n            return 0;\\n        }\\n        sort(nums.begin(), nums.end());\\n        int currentConsecutiveSequence = 1;\\n        int longestConsecutiveSequence = 0;\\n        for(int i=1; i<n; i++){\\n            if(nums[i] != nums[i-1]){\\n                if(nums[i] == nums[i-1] + 1){\\n                    currentConsecutiveSequence++;\\n                }\\n                else{\\n                    longestConsecutiveSequence = max(longestConsecutiveSequence, currentConsecutiveSequence);\\n                    currentConsecutiveSequence = 1;\\n                }\\n            }\\n        }\\n        return max(longestConsecutiveSequence, currentConsecutiveSequence);\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(N), We are traversing the Array(nums) thrice which creates the time complexity O(N)\\n    becuase Unordered map operating takes constant time. Where N is the size of the Array(nums).\\n\\n    Space Complexity : O(N), Unordered map space.\\n\\n    Solved using Array + Hash Table(Unordered map). Optimize Approach.\\n\\n*/\\n\\n\\n/***************************************** Approach 3 Code *****************************************/\\n\\nclass Solution {\\npublic:\\n    int longestConsecutive(vector<int>& nums) {\\n        unordered_map<int, bool> map;\\n        for(int i = 0; i<nums.size(); i++){\\n            map[nums[i]] = true;\\n        }\\n        for(int i=0; i<nums.size(); i++){\\n            if(map.count(nums[i]-1) > 0){\\n                map[nums[i]] = false;\\n            }\\n        }\\n        int maxlen = 0;\\n        for(int i=0; i<nums.size(); i++){\\n            if(map[nums[i]] == true){\\n                int j=0; int count=0;\\n                while(map.count(nums[i]+j) > 0){\\n                    j++;\\n                    count++;\\n                }\\n                if(count>maxlen){\\n                    maxlen = count;\\n                }\\n            }\\n        }\\n        return maxlen;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(N), Although the time complexity appears to be quadratic due to the while loop nested\\n    within the for loop, closer inspection reveals it to be linear. Because the while loop is reached only when\\n    marks the beginning of a sequence (i.e. currentNumber-1 is not present in nums), the while loop can only run\\n    for N iterations throughout the entire runtime of the algorithm. This means that despite looking like O(N^2)\\n    complexity, the nested loops actually run in O(N+N)=O(N) time. All other computations occur in constant\\n    time, so the overall runtime is linear. Where N is the size of the Array(nums).\\n\\n    Space Complexity : O(N), Unordered set space.\\n\\n    Solved using Array + Hash Table(Unordered set). Optimise Approach.\\n\\n*/\\n\\n\\n/***************************************** Approach 4 Code *****************************************/\\n\\nclass Solution {\\npublic:\\n    int longestConsecutive(vector<int>& nums) {\\n        unordered_set<int> set;\\n        for(int num : nums){\\n            set.insert(num);\\n        }\\n        int longestConsecutiveSequence = 0;\\n        for(int num : nums){\\n            if(set.find(num-1) == set.end()){\\n                int currentNumber = num;\\n                int currentConsecutiveSequence = 1;\\n                while(set.find(currentNumber+1) != set.end()){\\n                    currentNumber++;\\n                    currentConsecutiveSequence++;\\n                }\\n                longestConsecutiveSequence = max(longestConsecutiveSequence, currentConsecutiveSequence);\\n            }\\n        }\\n        return longestConsecutiveSequence;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 41060,
                "title": "a-simple-c-solution-using-unordered-set-and-simple-consideration-about-this-problem",
                "content": "I have seen a lot of discussion about this problem.In my opinion,it is not correct to use set(which is ordered),because very time we insert an element to a ordered set,it will cost O(n),so the total complexity is O(nlogn),which violates the request of the problem.So here we use an unordered_set,and one is enough.\\n\\nBesides,to think about this problem,one principle issue we should realize is that usually when we want to reduce the time complexity,we have to increase the space complexity.In this case,if we want to access an element within O(1),we have to use hash table.\\n\\n    class Solution {\\n    public:\\n        int longestConsecutive(vector<int> &num) {\\n            unordered_set<int> record(num.begin(),num.end());\\n            int res = 1;\\n            for(int n : num){\\n                if(record.find(n)==record.end()) continue;\\n                record.erase(n);\\n                int prev = n-1,next = n+1;\\n                while(record.find(prev)!=record.end()) record.erase(prev--);\\n                while(record.find(next)!=record.end()) record.erase(next++);\\n                res = max(res,next-prev-1);\\n            }\\n            return res;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int longestConsecutive(vector<int> &num) {\\n            unordered_set<int> record(num.begin(),num.end());\\n            int res = 1;\\n            for(int n : num){\\n                if(record.find(n)==record.end()) continue;\\n                record.erase(n);\\n                int prev = n-1,next = n+1;\\n                while(record.find(prev)!=record.end()) record.erase(prev--);\\n                while(record.find(next)!=record.end()) record.erase(next++);\\n                res = max(res,next-prev-1);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 166544,
                "title": "union-find-thinking-process",
                "content": "If we regard a consecutive sequence as a `conected component` (or a `disjoint set`), the problem becomes to get the size of largest connected component (or `set`).\\n\\nA node is a value of an element in nums in this case.\\nTwo nodes are **connected** if they are consecutive.\\n\\nO(N) time complexity is reqruired, so given `nums[i]`, we should tell index of `nums[i] - 1` if any, and `nums[i] + 1` if any in O(1). That can be achieved using a map that maps value to index.\\n\\nPlease note that for duplicate elements, we count only once. \\n****\\n```\\nclass Solution {\\n    public int longestConsecutive(int[] nums) {\\n        UF uf = new UF(nums.length);\\n        // Map val to index in nums\\n        Map<Integer, Integer> valToIndex = new HashMap<>();\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            if (valToIndex.containsKey(nums[i])) {\\n                continue;\\n            }\\n            \\n            if (valToIndex.containsKey(nums[i] - 1)) {\\n                uf.union(i, valToIndex.get(nums[i] - 1));\\n            }\\n            \\n            if (valToIndex.containsKey(nums[i] + 1)) {\\n                uf.union(i, valToIndex.get(nums[i] + 1));\\n            }\\n            \\n            valToIndex.put(nums[i], i);\\n        }\\n        \\n        return uf.getLargetComponentSize();\\n    }\\n    \\n    class UF {\\n        private int[] parent;\\n        private int[] size;\\n        \\n        public UF(int n) {\\n            parent = new int[n];\\n            size = new int[n];\\n            for (int i = 0; i < n; i++) {\\n                parent[i] = i;\\n                size[i] = 1;\\n            }\\n        }\\n        \\n        public void union(int x, int y) { // connected if consecutive\\n            int rootX = find(x);\\n            int rootY = find(y);\\n            if (rootX != rootY) {\\n                parent[rootX] = rootY;\\n                size[rootY] += size[rootX];\\n            }\\n        };\\n        \\n        private int find(int x) {\\n            if (parent[x] == x) {\\n                return x;\\n            }\\n            \\n            return parent[x] = find(parent[x]);\\n        };\\n        \\n        public int getLargetComponentSize() {\\n            int maxSize = 0;\\n            for (int i = 0; i < parent.length; i++) {\\n                if (parent[i] == i && size[i] > maxSize) {\\n                    maxSize = size[i];\\n                }\\n            }\\n            \\n            return maxSize;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\n    public int longestConsecutive(int[] nums) {\\n        UF uf = new UF(nums.length);\\n        // Map val to index in nums\\n        Map<Integer, Integer> valToIndex = new HashMap<>();\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            if (valToIndex.containsKey(nums[i])) {\\n                continue;\\n            }\\n            \\n            if (valToIndex.containsKey(nums[i] - 1)) {\\n                uf.union(i, valToIndex.get(nums[i] - 1));\\n            }\\n            \\n            if (valToIndex.containsKey(nums[i] + 1)) {\\n                uf.union(i, valToIndex.get(nums[i] + 1));\\n            }\\n            \\n            valToIndex.put(nums[i], i);\\n        }\\n        \\n        return uf.getLargetComponentSize();\\n    }\\n    \\n    class UF {\\n        private int[] parent;\\n        private int[] size;\\n        \\n        public UF(int n) {\\n            parent = new int[n];\\n            size = new int[n];\\n            for (int i = 0; i < n; i++) {\\n                parent[i] = i;\\n                size[i] = 1;\\n            }\\n        }\\n        \\n        public void union(int x, int y) { // connected if consecutive\\n            int rootX = find(x);\\n            int rootY = find(y);\\n            if (rootX != rootY) {\\n                parent[rootX] = rootY;\\n                size[rootY] += size[rootX];\\n            }\\n        };\\n        \\n        private int find(int x) {\\n            if (parent[x] == x) {\\n                return x;\\n            }\\n            \\n            return parent[x] = find(parent[x]);\\n        };\\n        \\n        public int getLargetComponentSize() {\\n            int maxSize = 0;\\n            for (int i = 0; i < parent.length; i++) {\\n                if (parent[i] == i && size[i] > maxSize) {\\n                    maxSize = size[i];\\n                }\\n            }\\n            \\n            return maxSize;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 41130,
                "title": "another-accepted-java-o-n-solution",
                "content": "    public int longestConsecutive(int[] num) {\\n      int max = 0;\\n      \\n      Set<Integer> set = new HashSet<Integer>();\\n      for (int i = 0; i < nums.length; i++) {\\n        set.add(nums[i]);\\n      }\\n      \\n      for (int i = 0; i < nums.length; i++) {\\n        int count = 1;\\n        \\n        // look left\\n        int num = nums[i];\\n        while (set.contains(--num)) {\\n          count++;\\n          set.remove(num);\\n        }\\n        \\n        // look right\\n        num = nums[i];\\n        while (set.contains(++num)) {\\n          count++;\\n          set.remove(num);\\n        }\\n        \\n        max = Math.max(max, count);\\n      }\\n      \\n      return max;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public int longestConsecutive(int[] num) {\\n      int max = 0;\\n      \\n      Set<Integer> set = new HashSet<Integer>();\\n      for (int i = 0; i < nums.length; i++) {\\n        set.add(nums[i]);\\n      }\\n      \\n      for (int i = 0; i < nums.length; i++) {\\n        int count = 1;\\n        \\n        // look left\\n        int num = nums[i];\\n        while (set.contains(--num)) {\\n          count++;\\n          set.remove(num);\\n        }\\n        \\n        // look right\\n        num = nums[i];\\n        while (set.contains(++num)) {\\n          count++;\\n          set.remove(num);\\n        }\\n        \\n        max = Math.max(max, count);\\n      }\\n      \\n      return max;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1254638,
                "title": "short-easy-solution-w-explanation-o-n-solution-with-comments-using-hashset",
                "content": "\\u2714\\uFE0F ***Solution - I (Sorting)***\\n\\nWe can simply sort the given array and compare consecutive elements. Following cases exists:\\n1. **`nums[i] == nums[i-1] + 1`**: This means the current element is consecutive to previous, so increment current streak count.\\n2. **`nums[i] == nums[i-1]`**: We have found the same element as previous. Skip it, and see if we can still extend the sequence with next elements.\\n3. **None of above** : We can\\'t extend the sequence any further. Update *`longest`* to store longest formed streak till now and reset *`curlongest`*.\\n\\n**C++**\\n```\\nint longestConsecutive(vector<int>& nums) {\\n\\tif(!size(nums)) return 0;\\n\\tsort(begin(nums), end(nums));\\n\\tint longest = 0, cur_longest = 1;\\n\\tfor(int i = 1; i < size(nums); i++) \\n\\t\\tif(nums[i] == nums[i - 1]) continue;\\n\\t\\telse if(nums[i] == nums[i - 1] + 1) cur_longest++; // consecutive element - update current streak length\\n\\t\\telse longest = max(longest, cur_longest), cur_longest = 1;  // reset current streak length\\n\\treturn max(longest, cur_longest);\\n}\\n```\\n\\n---\\n\\n**Python**\\n```\\ndef longestConsecutive(self, nums: List[int]) -> int:\\n\\tnums.sort()\\n\\tlongest, cur_longest = 0, min(1, len(nums))\\n\\tfor i in range(1,len(nums)):\\n\\t\\tif nums[i] == nums[i - 1] : continue\\n\\t\\tif nums[i] == nums[i - 1] + 1: cur_longest += 1\\n\\t\\telse: longest, cur_longest = max(longest, cur_longest), 1\\n\\treturn max(longest, cur_longest)\\n```\\n\\n***Time Complexity :*** **`O(NlogN)`**, where *`N`* is the number of elements in nums\\n***Time Complexity :*** **`O(1)`**, ignoring the space required by sorting algorithm.\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - II (Using Hashset)***\\n\\nWe need to find the longest consecutive sequence in linear time. We can do this if we insert all the elements of *`nums`* into a hashset. Once we have inserted all the elements, we can just iterate over the hashset to find longest consecutive sequence involving  the current element(let\\'s call it *`num`*) under iteration. This can simply be done by **iterating over elements that are consecutive to *`num`* till we keep finding them in the set**. Each time we will also delete those elements from set to ensure we only visit them once.\\n\\n**C++**\\n```\\nint longestConsecutive(vector<int>& nums) {\\n\\tunordered_set<int> s(begin(nums), end(nums)); // inserting all elements into hashset\\n\\tint longest = 0;\\n\\tfor(auto& num : s) {\\n\\t\\tint cur_longest = 1;\\n\\t\\t// find consecutive elements in the backward and forward direction from num\\n\\t\\tfor(int j = 1; s.count(num - j); j++) s.erase(num - j), cur_longest++;\\n\\t\\tfor(int j = 1; s.count(num + j); j++) s.erase(num + j), cur_longest++;\\n\\t\\tlongest = max(longest, cur_longest);  // update longest to hold longest consecutive sequence till now\\n\\t}\\n\\treturn longest;\\n}\\n```\\n\\n---\\n\\n**Python**\\n```\\ndef longestConsecutive(self, nums: List[int]) -> int:\\n\\tlongest, s = 0, set(nums)\\n\\tfor num in nums:\\n\\t\\tcur_longest, j = 1, 1\\n\\t\\twhile num - j in s: \\n\\t\\t\\ts.remove(num - j)\\n\\t\\t\\tcur_longest, j = cur_longest + 1, j + 1\\n\\t\\tj = 1\\n\\t\\twhile num + j in s: \\n\\t\\t\\ts.remove(num + j)\\n\\t\\t\\tcur_longest, j = cur_longest + 1, j + 1\\n\\t\\tlongest = max(longest, cur_longest)\\n\\treturn longest\\n```\\n\\n***Time Complexity :*** **`O(N)`**\\n***Space Complexity :*** **`O(N)`**\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - III (Using Hashset - w/ optimizations)***\\n\\nWe can form a solution without the need to spend time erasing elements from the hashset. \\n\\nInstead of taking the first element that we find in the hashset and iterating both forward and backward, we can just keep skipping till we find that hashset contains `num - 1`. Finally, we can just iterate in the forward direction till we find consecutive elements in hashset and update `longest` at the end\\n\\n**C++**\\n```\\nint longestConsecutive(vector<int>& nums) {\\n\\tunordered_set<int> s(begin(nums), end(nums));\\n\\tint longest = 0;\\n\\tfor(auto& num : s) {\\n        if(s.count(num - 1)) continue;\\n\\t\\tint j = 1;\\n\\t\\twhile(s.count(num + j)) j++;\\n\\t\\tlongest = max(longest, j);\\n\\t}\\n\\treturn longest;\\n}\\n```\\n\\n---\\n\\n**Python**\\n```\\ndef longestConsecutive(self, nums):\\n\\ts, longest = set(nums), 0\\n\\tfor num in s:\\n\\t\\tif num - 1 in s: continue\\n\\t\\tj = 1\\n\\t\\twhile num + j in s: j += 1\\n\\t\\tlongest = max(longest, j)\\n\\treturn longest\\n```\\n\\n***Time Complexity :*** **`O(N)`**\\n***Space Complexity :*** **`O(N)`**\\n\\n---\\n---\\n\\n\\uD83D\\uDCBB\\uD83D\\uDC31\\u200D\\uD83D\\uDCBBIf there are any suggestions / questions / mistakes in my post, please do comment below \\uD83D\\uDC47 \\n\\n---\\n---",
                "solutionTags": [
                    "Python",
                    "C"
                ],
                "code": "```\\nint longestConsecutive(vector<int>& nums) {\\n\\tif(!size(nums)) return 0;\\n\\tsort(begin(nums), end(nums));\\n\\tint longest = 0, cur_longest = 1;\\n\\tfor(int i = 1; i < size(nums); i++) \\n\\t\\tif(nums[i] == nums[i - 1]) continue;\\n\\t\\telse if(nums[i] == nums[i - 1] + 1) cur_longest++; // consecutive element - update current streak length\\n\\t\\telse longest = max(longest, cur_longest), cur_longest = 1;  // reset current streak length\\n\\treturn max(longest, cur_longest);\\n}\\n```\n```\\ndef longestConsecutive(self, nums: List[int]) -> int:\\n\\tnums.sort()\\n\\tlongest, cur_longest = 0, min(1, len(nums))\\n\\tfor i in range(1,len(nums)):\\n\\t\\tif nums[i] == nums[i - 1] : continue\\n\\t\\tif nums[i] == nums[i - 1] + 1: cur_longest += 1\\n\\t\\telse: longest, cur_longest = max(longest, cur_longest), 1\\n\\treturn max(longest, cur_longest)\\n```\n```\\nint longestConsecutive(vector<int>& nums) {\\n\\tunordered_set<int> s(begin(nums), end(nums)); // inserting all elements into hashset\\n\\tint longest = 0;\\n\\tfor(auto& num : s) {\\n\\t\\tint cur_longest = 1;\\n\\t\\t// find consecutive elements in the backward and forward direction from num\\n\\t\\tfor(int j = 1; s.count(num - j); j++) s.erase(num - j), cur_longest++;\\n\\t\\tfor(int j = 1; s.count(num + j); j++) s.erase(num + j), cur_longest++;\\n\\t\\tlongest = max(longest, cur_longest);  // update longest to hold longest consecutive sequence till now\\n\\t}\\n\\treturn longest;\\n}\\n```\n```\\ndef longestConsecutive(self, nums: List[int]) -> int:\\n\\tlongest, s = 0, set(nums)\\n\\tfor num in nums:\\n\\t\\tcur_longest, j = 1, 1\\n\\t\\twhile num - j in s: \\n\\t\\t\\ts.remove(num - j)\\n\\t\\t\\tcur_longest, j = cur_longest + 1, j + 1\\n\\t\\tj = 1\\n\\t\\twhile num + j in s: \\n\\t\\t\\ts.remove(num + j)\\n\\t\\t\\tcur_longest, j = cur_longest + 1, j + 1\\n\\t\\tlongest = max(longest, cur_longest)\\n\\treturn longest\\n```\n```\\nint longestConsecutive(vector<int>& nums) {\\n\\tunordered_set<int> s(begin(nums), end(nums));\\n\\tint longest = 0;\\n\\tfor(auto& num : s) {\\n        if(s.count(num - 1)) continue;\\n\\t\\tint j = 1;\\n\\t\\twhile(s.count(num + j)) j++;\\n\\t\\tlongest = max(longest, j);\\n\\t}\\n\\treturn longest;\\n}\\n```\n```\\ndef longestConsecutive(self, nums):\\n\\ts, longest = set(nums), 0\\n\\tfor num in s:\\n\\t\\tif num - 1 in s: continue\\n\\t\\tj = 1\\n\\t\\twhile num + j in s: j += 1\\n\\t\\tlongest = max(longest, j)\\n\\treturn longest\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2240104,
                "title": "c-detailed-explanation-w-three-approaches-dry-run-each-step-explained",
                "content": "***Brief note about Question-***\\n* We have to return the  length of the longest consecutive elements sequence.\\n```\\nSince understanding question statement is very easy, but just take an example not given in question-\\nSuppose our given array is arr[]: [14, 5, 7, 6, 984, 8, 10]\\n\\nSo, if we rearrange this in a sorted manner, then it looks like arr[]: [5, 6, 7, 8, 10, 14, 984]\\nso we can clearly see that (5, 6, 7, 8) forming an consecutive sequence\\nTherefore, answer is 4\\n```\\n___________\\n***Solution - I (using sorting)-***\\n* The very first thing we can think of is we simply arrange the array in ascendig order.\\n* After arranging the array in sorted order, we just find the length of the longest consecutive sequence.\\n* Like, this is the most basic thing we can do.\\n```\\nTime Complexity --> O(n logn) // where n is the size of the array and since we are using sorting\\nSpace Complexity --> O(1) // we are not using anything extra from our side\\nIt paases [ 71 / 71 ] in built test cases\\n```\\n**Code (C++)**\\n```\\nclass Solution {\\npublic:\\n    int longestConsecutive(vector<int>& arr) {\\n        int n = arr.size(); // extract the size of array\\n        if(n == 0) return 0; // if length of array is zero, then from here simply return 0\\n        \\n        sort(arr.begin(), arr.end()); // sort the array\\n        \\n        int mxLen = 0, currLen = 1; // put mxLen = 0, and currLen as 1\\n        \\n        for(int i = 1; i < n; i++) // traverse from the array\\n        {\\n            if(arr[i] == arr[i - 1] + 1) // this is the part of consecutive sequence\\n            {\\n                currLen++; // increase the curr Length by 1\\n            }\\n            else if(arr[i] != arr[i - 1]) // but if it is not equal\\n            {\\n                mxLen = max(mxLen, currLen); // update our mxLen \\n                currLen = 1; // and reset the currLen with 1\\n            }\\n        }\\n        \\n        mxLen = max(mxLen, currLen); // update our mxLen \\n        return mxLen; // Finally return mxLen\\n    }\\n};\\n```\\n__________\\n***Solution - I| (using Disjoint set Union)-***\\n* What if we assume that every consecutive set of elements are work as connencted component.\\n* It is totally fine, if we put all the consecutive set of elements in a group.\\n* After putting all the elements in a group now we have to just find the maximum size of consecutive set of elements.\\n* Using DSU, we are easily able to do that.\\n* We are using standard format of DSU.\\n* See commented code for better explantion.\\n```\\nTime Complexity --> O(n ) // where n is the size of the array and since we are making component\\nSpace Complexity --> O(n) // we are using map\\nIt paases [ 71 / 71 ] in built test cases\\n```\\n**Code (C++)**\\n```\\nclass Solution {\\npublic:\\n    int parent[100001], Rank[100001]; // make parent and rank array of max size\\n    \\n    int find(int a) // find function used to tell us the parent of the value \\'a\\'\\n    {\\n        if(parent[a] == a)\\n            return a;\\n        \\n        return parent[a] = find(parent[a]);\\n    }\\n    \\n    void Union(int a, int b) // By union we are making parent \\n    {\\n        a = find(a); // find parent of a\\n        b = find(b); // find parent of b\\n        \\n        if(a == b) // if both parents are equal, simply return\\n            return;\\n        \\n        if(Rank[a] > Rank[b]) // rank of a is larger, so it will become parent\\n        {\\n            // a would be parent\\n            parent[b] = a; \\n            Rank[a] += Rank[b]; // a become parent, so increase it\\'s rank\\n        }\\n        else\\n        {\\n            // b would be parent\\n            parent[a] = b;\\n            Rank[b] += Rank[a]; // b become parent, so increase it\\'s rank\\n        } \\n    }\\n    int longestConsecutive(vector<int>& arr) {\\n        int n = arr.size(); // extract the size of array\\n        if(n == 0) return 0; // if length is zero simply return zero\\n        \\n        // since our parent and rank are global array so everytime reintiliaze them\\n        for(int i = 0; i < n; i++) parent[i] = i, Rank[i] = 1;\\n        \\n        unordered_map<int, int> mp; // making map\\n        \\n        for(int i = 0; i < n; i++) // traverse from the arrat\\n        {\\n            // if element is already presnt into the map, just continue\\n            if(mp.find(arr[i]) != mp.end()) continue;\\n            \\n            // if (arr[i] - 1) present in the map, we will perform union\\n            if(mp.find(arr[i] - 1) != mp.end())\\n            {\\n                Union(mp[arr[i] - 1], i);\\n            }\\n            \\n             // also, if (arr[i] - 1) present in the map, we will perform union\\n            if(mp.find(arr[i] + 1) != mp.end())\\n            {\\n                Union(mp[arr[i] + 1], i);\\n            }\\n            \\n             mp[arr[i]] = i;\\n        }\\n        \\n        int ans = 0; // intiliaze ans as zero\\n        for(int i = 0; i < n; i++)\\n        {\\n            ans = max(ans, Rank[i]); // take the largest component\\n        }\\n        \\n        return ans; // finally return ans\\n    }\\n}; \\n```\\n__________________\\n***Solution - III (Concept of map (Three step process), Accepted)-***\\n* In the **first** step, ***for every element of the array we assume that it is the starting point of some consecutive sequence***.\\n* We know that this is not right, so for a moment we just assume that every element is the starting point of some consecutive sequence.\\n* So ***we will take a map, and  with every element as key we put value 1 for each element*.**\\n* Now, in the **second** step ***we check for every element whether (arr[i] - 1)(arr[i] being any element of the array) is present in our map or not.***\\n* Suppose if (arr[i] - 1) is present in our map, then in the first step the assumption we made that every element can be the starting point of some consecutive sequece goes wrong.\\n* Because if (arr[i] - 1) is present in the array then we can surely say that arr[i] can\\'t be the starting point of any consecutive sequence.\\n\\n* ***So, if(arr[i] - 1) is presnt in the array then we put zero for arr[i] in the map.***\\n* Because at this point we can surely say that since (arr[i] - 1) is present in our map, so arr[i] can\\'t be our starting point.\\n* `Suppose, if arr[i] is 5 and we search for (arr[i] - 1) i.e (5 - 1 = 4) is present in our map or not. If 4 is present in our map, then 5 can\\'t be the starting consecutive sequence, so in map we put zero for 5 `\\n* In the **third** step, Now, we can surely say that the elements for which 1 is present in map are definately going to be the starting point of the some consecutive sequence.\\n* So our task is left now, ***for every element for which 1 is presnt in map the now, for them we find the length of their consecutive sequence, and out of them whatever will be the maximum length is going to our answer.***\\n* Taking an example for better understanding, see below.\\n```\\nSuppose our given array is arr[]: [12, 13, 2, 3, 4, 5, 8, 9, 10, 11, 78, 79, 80]\\n\\n1) In the first step, we make a map and for every element we put 1.\\n  (Assuming that every element can be the starting point of some consecutive sequence)\\n  so map looks like:-\\n  \\n  map\\n  element (key)      |    value\\n\\t\\t 12          |     1\\n\\t\\t 13          |     1\\n\\t\\t  2          |     1\\n\\t\\t  3          |     1\\n\\t\\t  4          |     1\\n\\t\\t  5          |     1\\n\\t\\t  8          |     1\\n\\t\\t  9          |     1\\n\\t\\t 10          |     1\\n\\t\\t 11          |     1\\n\\t\\t 78          |     1\\n\\t\\t 79          |     1\\n\\t\\t 80          |     1\\n\\t\\t \\n2) Now, in the second step, we will see whether (arr[i] - 1) is present in our map or not.\\n    If (arr[i] - 1) is present in our map, then arr[i] can\\'t be the starting point of some consecutive sequence.\\n\\t\\n\\tso, map looks like:-\\n\\t map\\n  element (key)      |    value\\n\\t\\t 12          |     0          (since (12 - 1 = 11) is present in map so we put zero in front of 12)\\n\\t\\t 13          |     0          (since (13 - 1 = 12) is present in map so we put zero in front of 13)\\n\\t\\t  2          |     1          (since (2 - 1 = 1) is not present in map so we leave 2 as it is)\\n\\t\\t  3          |     0          (since (3 - 1 = 2) is present in map so we put zero in front of 3)\\n\\t\\t  4          |     0          (since (4 - 1 = 3) is present in map so we put zero in front of 4)\\n\\t\\t  5          |     0          (since (5 - 1 = 4) is present in map so we put zero in front of 5)\\n\\t\\t  8          |     1          (since (8 - 1 = 7) is not present in map so we leave 8 as it is)\\n\\t\\t  9          |     0          (since (9 - 1 = 8) is present in map so we put zero in front of 9)\\n\\t\\t 10          |     0          (since (10 - 1 = 9) is present in map so we put zero in front of 10)\\n\\t\\t 11          |     0          (since (11 - 1 = 10) is present in map so we put zero in front of 11)\\n\\t\\t 78          |     1          (since (78 - 1 = 77) is not present in map so we leave 77 as it is)\\n\\t\\t 79          |     0          (since (79 - 1 = 78) is present in map so we put zero in front of 79)\\n\\t\\t 80          |     0          (since (80 - 1 = 79) is present in map so we put zero in front of 80)\\n\\t\\t \\n3) Now, in the third step, the elements for which 1 is left in the map, for them we can definately say\\n    that they are starting point of some consecutive sequence.\\n\\tHere we can see that elements 2, 8, and 78 definately starting some consecutive sequence.\\n\\t\\n\\tThe only task is left to us now is to find the longest length of the consecutive sequence.\\n\\tHow we are going to do that? let see-\\n\\t\\n\\tNow, at this point we are only going to care about those elements which are having value as 1 in the map.\\n\\tWe also say that they are definately going to be the starting point some consecutive sequence, right.\\n\\tso, intially we define our length as 1, because they are the starting point so its definite they are having length atleast 1.\\n\\tsuppose we take 2, so intially length = 1\\n\\twhat we search now, we say 2 is there, ok, it\\'s fine\\n\\tnow we ask whether 3 is there or not, we say yes it is their, so we increase our length as 2\\n\\tagain, we say whether 4 is there or not, and according to presence we increase our length.\\n\\t\\n\\tso if we observe everytime what we asking for, \\n\\tsuppose arr[i] is being 2 and intially length is 1\\n\\t\\n\\tso if i ask whether (arr[i] + length) is present or not, \\n\\tthan what (arr[i] + length) is, it is (2 + 1 = 3), we say yes 3 is there\\n\\tso we increase our length as 2\\n\\t\\n\\tnow, if we ask again (arr[i] + length) what it looks like, it looks like\\n\\tarr[i] is 2, but length is 2 now so (2 + 2 = 4) is present or not, we say yes  \\n\\tso we increase our length by 1, so length becomes 3\\n\\t\\n\\tagain now, if we ask again (arr[i] + length) what it looks like, it looks like\\n\\tarr[i] is 2, but length is 3 now so (2 + 3 = 5) is present or not, we say yes  \\n\\tso we increase our length by 1, so length becomes 4\\n\\t\\n\\tIn this way we can say that with the help of length we find the length of the consecutive sequence.\\n\\tAnd out of them whatever the will give me the maximum length should be my answer.\\n\\t\\n\\tSo, if we talk about our above example,\\n\\t\\n\\telements that left with value 1 are (2, 8 and 78)\\n\\tfor 2, we will see (2, 3, 4, 5) is the sequence, so length is 4\\n\\tfor 8, we will see (8, 9, 10, 11, 12, 13) is the sequence, so length is 6\\n\\tand for 78, we will see (78, 79, 80) is the sequence, so length is 3\\n\\t\\n\\tso out of three of them maximum is ({4, 6, 3}) is 6\\n\\tso, 6 will be my final answer.\\n\\t\\n\\tI hope you got the concept, see commented code for better understanding.\\n```\\n________\\n```\\nTime Complexity --> O(n + n + n) = O(3n) ~ O(n) \\n// where n is the size of the array and since we are traversing array three times \\n// 1) for putting 1 for each element (step 1)\\n// 2) for improving our assumption (step 2)\\n// 3) for finding sequence (step 3)\\n\\nSpace Complexity --> O(n) // since we are using map\\nIt paases [ 71 / 71 ] in built test cases\\n```\\n___\\n**Code (C++)**\\n```\\nclass Solution {\\npublic:\\n    int longestConsecutive(vector<int>& arr) {\\n        int n = arr.size(); // extract the size of the array\\n        \\n        unordered_map<int, int> mp; // declaring unordered map\\n        \\n        // Step 1)  we are giving 1 to each of the elemnt\\n        // (Assuming that it may be the starting point of consecutive sequence)\\n        for(int i = 0; i < n; i++)\\n        {\\n            mp[arr[i]] = 1;\\n        }\\n        \\n        // step 2) validating our assumption taken in step 1\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(mp.find(arr[i] - 1) != mp.end()) // if(arr[i] - 1) is present in map\\n            {\\n                // then arr[i] can never be the starting point some of consecutive sequence\\n                // so give value zero for that arr[i]\\n                mp[arr[i]] = 0;\\n            }\\n        }\\n        \\n        // step 3) Now the elements for which value 1 is left\\n        // for them we definately know they are the starting point of \\n        // some consecutive sequence, using that length trick we find the maxlen\\n        \\n        int mxLen = 0; // this variable holds my answer\\n        \\n        for(int i = 0; i < n; i++) // travel in the array\\n        {\\n            // if value is 1, then they are starting point some of consecutive sequence\\n            if(mp[arr[i]] == 1) \\n            {\\n                // if it is the starting point, then definately length is going to be \\n                // atleast 1\\n                int length = 1; \\n                \\n               // we dicuss it above\\n                while(mp.find(arr[i] + length) != mp.end())\\n                {\\n                    length++;\\n                }\\n                \\n                mxLen = max(mxLen, length); // update mxLen\\n            }\\n        }\\n        \\n        return mxLen; // Finally return mxLen\\n    }\\n};\\n```\\n_______________\\nA reference article I have taken help from:-\\n* https://leetcode.com/problems/longest-consecutive-sequence/discuss/1127908/2-Approaches-for-your-interview(hindi)\\n____________________\\n***`If u find this useful , please consider to give a upvote!!`***\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nSince understanding question statement is very easy, but just take an example not given in question-\\nSuppose our given array is arr[]: [14, 5, 7, 6, 984, 8, 10]\\n\\nSo, if we rearrange this in a sorted manner, then it looks like arr[]: [5, 6, 7, 8, 10, 14, 984]\\nso we can clearly see that (5, 6, 7, 8) forming an consecutive sequence\\nTherefore, answer is 4\\n```\n```\\nTime Complexity --> O(n logn) // where n is the size of the array and since we are using sorting\\nSpace Complexity --> O(1) // we are not using anything extra from our side\\nIt paases [ 71 / 71 ] in built test cases\\n```\n```\\nclass Solution {\\npublic:\\n    int longestConsecutive(vector<int>& arr) {\\n        int n = arr.size(); // extract the size of array\\n        if(n == 0) return 0; // if length of array is zero, then from here simply return 0\\n        \\n        sort(arr.begin(), arr.end()); // sort the array\\n        \\n        int mxLen = 0, currLen = 1; // put mxLen = 0, and currLen as 1\\n        \\n        for(int i = 1; i < n; i++) // traverse from the array\\n        {\\n            if(arr[i] == arr[i - 1] + 1) // this is the part of consecutive sequence\\n            {\\n                currLen++; // increase the curr Length by 1\\n            }\\n            else if(arr[i] != arr[i - 1]) // but if it is not equal\\n            {\\n                mxLen = max(mxLen, currLen); // update our mxLen \\n                currLen = 1; // and reset the currLen with 1\\n            }\\n        }\\n        \\n        mxLen = max(mxLen, currLen); // update our mxLen \\n        return mxLen; // Finally return mxLen\\n    }\\n};\\n```\n```\\nTime Complexity --> O(n ) // where n is the size of the array and since we are making component\\nSpace Complexity --> O(n) // we are using map\\nIt paases [ 71 / 71 ] in built test cases\\n```\n```\\nclass Solution {\\npublic:\\n    int parent[100001], Rank[100001]; // make parent and rank array of max size\\n    \\n    int find(int a) // find function used to tell us the parent of the value \\'a\\'\\n    {\\n        if(parent[a] == a)\\n            return a;\\n        \\n        return parent[a] = find(parent[a]);\\n    }\\n    \\n    void Union(int a, int b) // By union we are making parent \\n    {\\n        a = find(a); // find parent of a\\n        b = find(b); // find parent of b\\n        \\n        if(a == b) // if both parents are equal, simply return\\n            return;\\n        \\n        if(Rank[a] > Rank[b]) // rank of a is larger, so it will become parent\\n        {\\n            // a would be parent\\n            parent[b] = a; \\n            Rank[a] += Rank[b]; // a become parent, so increase it\\'s rank\\n        }\\n        else\\n        {\\n            // b would be parent\\n            parent[a] = b;\\n            Rank[b] += Rank[a]; // b become parent, so increase it\\'s rank\\n        } \\n    }\\n    int longestConsecutive(vector<int>& arr) {\\n        int n = arr.size(); // extract the size of array\\n        if(n == 0) return 0; // if length is zero simply return zero\\n        \\n        // since our parent and rank are global array so everytime reintiliaze them\\n        for(int i = 0; i < n; i++) parent[i] = i, Rank[i] = 1;\\n        \\n        unordered_map<int, int> mp; // making map\\n        \\n        for(int i = 0; i < n; i++) // traverse from the arrat\\n        {\\n            // if element is already presnt into the map, just continue\\n            if(mp.find(arr[i]) != mp.end()) continue;\\n            \\n            // if (arr[i] - 1) present in the map, we will perform union\\n            if(mp.find(arr[i] - 1) != mp.end())\\n            {\\n                Union(mp[arr[i] - 1], i);\\n            }\\n            \\n             // also, if (arr[i] - 1) present in the map, we will perform union\\n            if(mp.find(arr[i] + 1) != mp.end())\\n            {\\n                Union(mp[arr[i] + 1], i);\\n            }\\n            \\n             mp[arr[i]] = i;\\n        }\\n        \\n        int ans = 0; // intiliaze ans as zero\\n        for(int i = 0; i < n; i++)\\n        {\\n            ans = max(ans, Rank[i]); // take the largest component\\n        }\\n        \\n        return ans; // finally return ans\\n    }\\n}; \\n```\n```\\nSuppose our given array is arr[]: [12, 13, 2, 3, 4, 5, 8, 9, 10, 11, 78, 79, 80]\\n\\n1) In the first step, we make a map and for every element we put 1.\\n  (Assuming that every element can be the starting point of some consecutive sequence)\\n  so map looks like:-\\n  \\n  map\\n  element (key)      |    value\\n\\t\\t 12          |     1\\n\\t\\t 13          |     1\\n\\t\\t  2          |     1\\n\\t\\t  3          |     1\\n\\t\\t  4          |     1\\n\\t\\t  5          |     1\\n\\t\\t  8          |     1\\n\\t\\t  9          |     1\\n\\t\\t 10          |     1\\n\\t\\t 11          |     1\\n\\t\\t 78          |     1\\n\\t\\t 79          |     1\\n\\t\\t 80          |     1\\n\\t\\t \\n2) Now, in the second step, we will see whether (arr[i] - 1) is present in our map or not.\\n    If (arr[i] - 1) is present in our map, then arr[i] can\\'t be the starting point of some consecutive sequence.\\n\\t\\n\\tso, map looks like:-\\n\\t map\\n  element (key)      |    value\\n\\t\\t 12          |     0          (since (12 - 1 = 11) is present in map so we put zero in front of 12)\\n\\t\\t 13          |     0          (since (13 - 1 = 12) is present in map so we put zero in front of 13)\\n\\t\\t  2          |     1          (since (2 - 1 = 1) is not present in map so we leave 2 as it is)\\n\\t\\t  3          |     0          (since (3 - 1 = 2) is present in map so we put zero in front of 3)\\n\\t\\t  4          |     0          (since (4 - 1 = 3) is present in map so we put zero in front of 4)\\n\\t\\t  5          |     0          (since (5 - 1 = 4) is present in map so we put zero in front of 5)\\n\\t\\t  8          |     1          (since (8 - 1 = 7) is not present in map so we leave 8 as it is)\\n\\t\\t  9          |     0          (since (9 - 1 = 8) is present in map so we put zero in front of 9)\\n\\t\\t 10          |     0          (since (10 - 1 = 9) is present in map so we put zero in front of 10)\\n\\t\\t 11          |     0          (since (11 - 1 = 10) is present in map so we put zero in front of 11)\\n\\t\\t 78          |     1          (since (78 - 1 = 77) is not present in map so we leave 77 as it is)\\n\\t\\t 79          |     0          (since (79 - 1 = 78) is present in map so we put zero in front of 79)\\n\\t\\t 80          |     0          (since (80 - 1 = 79) is present in map so we put zero in front of 80)\\n\\t\\t \\n3) Now, in the third step, the elements for which 1 is left in the map, for them we can definately say\\n    that they are starting point of some consecutive sequence.\\n\\tHere we can see that elements 2, 8, and 78 definately starting some consecutive sequence.\\n\\t\\n\\tThe only task is left to us now is to find the longest length of the consecutive sequence.\\n\\tHow we are going to do that? let see-\\n\\t\\n\\tNow, at this point we are only going to care about those elements which are having value as 1 in the map.\\n\\tWe also say that they are definately going to be the starting point some consecutive sequence, right.\\n\\tso, intially we define our length as 1, because they are the starting point so its definite they are having length atleast 1.\\n\\tsuppose we take 2, so intially length = 1\\n\\twhat we search now, we say 2 is there, ok, it\\'s fine\\n\\tnow we ask whether 3 is there or not, we say yes it is their, so we increase our length as 2\\n\\tagain, we say whether 4 is there or not, and according to presence we increase our length.\\n\\t\\n\\tso if we observe everytime what we asking for, \\n\\tsuppose arr[i] is being 2 and intially length is 1\\n\\t\\n\\tso if i ask whether (arr[i] + length) is present or not, \\n\\tthan what (arr[i] + length) is, it is (2 + 1 = 3), we say yes 3 is there\\n\\tso we increase our length as 2\\n\\t\\n\\tnow, if we ask again (arr[i] + length) what it looks like, it looks like\\n\\tarr[i] is 2, but length is 2 now so (2 + 2 = 4) is present or not, we say yes  \\n\\tso we increase our length by 1, so length becomes 3\\n\\t\\n\\tagain now, if we ask again (arr[i] + length) what it looks like, it looks like\\n\\tarr[i] is 2, but length is 3 now so (2 + 3 = 5) is present or not, we say yes  \\n\\tso we increase our length by 1, so length becomes 4\\n\\t\\n\\tIn this way we can say that with the help of length we find the length of the consecutive sequence.\\n\\tAnd out of them whatever the will give me the maximum length should be my answer.\\n\\t\\n\\tSo, if we talk about our above example,\\n\\t\\n\\telements that left with value 1 are (2, 8 and 78)\\n\\tfor 2, we will see (2, 3, 4, 5) is the sequence, so length is 4\\n\\tfor 8, we will see (8, 9, 10, 11, 12, 13) is the sequence, so length is 6\\n\\tand for 78, we will see (78, 79, 80) is the sequence, so length is 3\\n\\t\\n\\tso out of three of them maximum is ({4, 6, 3}) is 6\\n\\tso, 6 will be my final answer.\\n\\t\\n\\tI hope you got the concept, see commented code for better understanding.\\n```\n```\\nTime Complexity --> O(n + n + n) = O(3n) ~ O(n) \\n// where n is the size of the array and since we are traversing array three times \\n// 1) for putting 1 for each element (step 1)\\n// 2) for improving our assumption (step 2)\\n// 3) for finding sequence (step 3)\\n\\nSpace Complexity --> O(n) // since we are using map\\nIt paases [ 71 / 71 ] in built test cases\\n```\n```\\nclass Solution {\\npublic:\\n    int longestConsecutive(vector<int>& arr) {\\n        int n = arr.size(); // extract the size of the array\\n        \\n        unordered_map<int, int> mp; // declaring unordered map\\n        \\n        // Step 1)  we are giving 1 to each of the elemnt\\n        // (Assuming that it may be the starting point of consecutive sequence)\\n        for(int i = 0; i < n; i++)\\n        {\\n            mp[arr[i]] = 1;\\n        }\\n        \\n        // step 2) validating our assumption taken in step 1\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(mp.find(arr[i] - 1) != mp.end()) // if(arr[i] - 1) is present in map\\n            {\\n                // then arr[i] can never be the starting point some of consecutive sequence\\n                // so give value zero for that arr[i]\\n                mp[arr[i]] = 0;\\n            }\\n        }\\n        \\n        // step 3) Now the elements for which value 1 is left\\n        // for them we definately know they are the starting point of \\n        // some consecutive sequence, using that length trick we find the maxlen\\n        \\n        int mxLen = 0; // this variable holds my answer\\n        \\n        for(int i = 0; i < n; i++) // travel in the array\\n        {\\n            // if value is 1, then they are starting point some of consecutive sequence\\n            if(mp[arr[i]] == 1) \\n            {\\n                // if it is the starting point, then definately length is going to be \\n                // atleast 1\\n                int length = 1; \\n                \\n               // we dicuss it above\\n                while(mp.find(arr[i] + length) != mp.end())\\n                {\\n                    length++;\\n                }\\n                \\n                mxLen = max(mxLen, length); // update mxLen\\n            }\\n        }\\n        \\n        return mxLen; // Finally return mxLen\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 41067,
                "title": "simple-fast-java-solution-using-set",
                "content": "Using a set to collect all elements that hasn't been visited. search element will be O(1) and eliminates visiting element again.\\n\\n    public class Solution {\\n    public int longestConsecutive(int[] nums) {\\n        if(nums == null || nums.length == 0) return 0;\\n        \\n        Set<Integer> set = new HashSet<Integer>();\\n        \\n        for(int num: nums) set.add(num);\\n        int max = 1;\\n        for(int num: nums) {\\n            if(set.remove(num)) {//num hasn't been visited\\n                int val = num;\\n                int sum = 1;\\n                while(set.remove(val-1)) val--;\\n                sum += num - val;\\n                \\n                val = num;\\n                while(set.remove(val+1)) val++;\\n                sum += val - num;\\n                \\n                max = Math.max(max, sum);\\n            }\\n        }\\n        return max;\\n    }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int longestConsecutive(int[] nums) {\\n        if(nums == null || nums.length == 0) return 0;\\n        \\n        Set<Integer> set = new HashSet<Integer>();\\n        \\n        for(int num: nums) set.add(num);\\n        int max = 1;\\n        for(int num: nums) {\\n            if(set.remove(num)) {//num hasn't been visited\\n                int val = num;\\n                int sum = 1;\\n                while(set.remove(val-1)) val--;\\n                sum += num - val;\\n                \\n                val = num;\\n                while(set.remove(val+1)) val++;\\n                sum += val - num;\\n                \\n                max = Math.max(max, sum);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1127908,
                "title": "2-approaches-for-your-interview-hindi",
                "content": "### Approach 1 : Brute \\n```\\nvar longestConsecutive = function(arr) {\\n\\n        if(arr.length==0) return 0\\n\\n        let count=1, max = 1\\n        arr.sort((a, b) => a - b)                       // Step1:  Sort karo\\n\\n        for(let i=0; i<arr.length; i++) {\\n\\n            if(arr[i]- arr[i-1] == 1) {                 // Step2 : Aur dekho ki, [mai - mere_se_pichla_elem == 1?]\\n                count=count+1 ;                         //         hua, toh bas count kr lo \\n                max = Math.max(max, count)              //         count krne ke saath saath,  maxLength bhi note krte jaa rhe hum\\n                                                        //         Ek time aisa ayega, ki, consecutive ginn\\'ne ka streak tut jyega, aur count phirse apne ko 1 se suru krna pdega \\n                                                        //         example : [1 2 3 4 6 7]\\n                                                        //                   isme 1234 ka streak rhega, phir 6 pe tut jyega\\n                                                        //                   toh 1234 ke liye count aur max dono = 4. \\n                                                        //                   6 pe tuta, so, count became 1 (look in else condition)\\n                                                        //                   so, 67 ke liye, count=2 , aur max = Math.max(4{from 1234}, 2{from 67})\\n            } \\n    \\n            else if(arr[i]==arr[i-1]) continue          // yeh step LEARNING hai tere liye. nahi toh tu toh SET laga rha tha duplicate hataane ke liye\\n      \\n            else {\\n                count = 1\\n            }\\n           \\n        }\\n        return max\\n};\\n```\\n<br> <br> <br> <hr> <hr>\\n\\n\\n### Approach 2 : Optimised\\n```\\n\\nvar longestConsecutive = function(arr) {\\n\\n    if(arr.length<=0) return 0\\n\\n    let map = new Map()\\n\\n\\n    // STEP1 : MAP MEIN SABKO SEQ INITIATOR ASSUME KRKE, TRUE SET KARO\\n    for(let elem of arr){\\n        map.set(elem, 1)            // map  bithaa ke, sabko True set kr diya\\n                                    // mtlb, assume yeh kr rhe hum abhi ki\\n                                    // harr ek elem, kisi sequence ki suruwaat hai (thats false, we do know that ;)  )\\n    }\\n\\n\\n\\n    // STEP2: YEH DEKHO KI, ISSE PEHLE WALA KAHI PRESENT TOH NAHI HAI MAP MEIN\\n    for(let i in arr){              \\n        if(map.has(arr[i]-1)) {     // ab , ARRAY mein loop laga ke yeh dekh rhe ki\\n                                    // KYA, isse pehle wla numeric number, Map mein already pada hai ?\\n                                    // agar hai, toh YEH TOH SURUWAAT nahi ho skta\\n                                    // suruwaat kaise hoga yeh. inbetween wala kuch elem hoyega\\n                                    // example: 4 ke liye check kr rhe, KYA 3 map mein pada hai ?\\n                                    //          agar hai, mtlb, suruwaat probably 3 hoyega na. 4 toh nahi hoga na suruwaat\\n\\n            map.set(arr[i], 0)      // hence, agar pada hai, toh isko FALSE set kr do.\\n        }\\n    }\\n\\n\\n\\n                                    // ab TRUE woh log reh gaye, jo sacchi kisi sequence ki suruwaat hai\\n                                    // example :  [1234] [100] [200] yeh sequence bann rhi thi initially,\\n                                    //            toh 1->TRUE\\n                                    //              100->TRUE\\n                                    //              200->TRUE mila hai sacchi ka opne ko.\\n                                    //\\n                                    //  so sequence intiator sab mil gaye,\\n                                    //  ab yeh dekhte hai, ki kaunsa sequence intiator, sabse badaa sequence generate krta hai\\n                                    //  lets count\\n\\n\\n\\n\\n\\n\\n    //STEP3: AB SAB SEQ INITIATORS KI LENGTH CALC KRO \\n    let maxLen=1\\n    for(let elem of arr) {\\n        if(map.get(elem)==1) {                           // TRUE walo ko liye, sequence ki length dhundhenge\\n\\n            let seqCount = 1                             // sab element pkka se, kisi sequence ke initiator hai yaha ab. so pehle se hi count=1 set kr diya h (asaani ho rha tha aise coding krne mein)\\n            while(map.has(elem + seqCount)) {            // jab tak sequence badhta rhe,\\n                seqCount+=1                              // count krte raho\\n            }\\n\\n            maxLen = Math.max(maxLen, seqCount)          // jab sequence bdhna khatam ho jaaye, tab maxLen ko update kr do (agar seqCount badaa mila apne ko toh )\\n\\n        }\\n\\n    }\\n\\n\\n\\n    \\n    return maxLen\\n    \\n\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript"
                ],
                "code": "```\\nvar longestConsecutive = function(arr) {\\n\\n        if(arr.length==0) return 0\\n\\n        let count=1, max = 1\\n        arr.sort((a, b) => a - b)                       // Step1:  Sort karo\\n\\n        for(let i=0; i<arr.length; i++) {\\n\\n            if(arr[i]- arr[i-1] == 1) {                 // Step2 : Aur dekho ki, [mai - mere_se_pichla_elem == 1?]\\n                count=count+1 ;                         //         hua, toh bas count kr lo \\n                max = Math.max(max, count)              //         count krne ke saath saath,  maxLength bhi note krte jaa rhe hum\\n                                                        //         Ek time aisa ayega, ki, consecutive ginn\\'ne ka streak tut jyega, aur count phirse apne ko 1 se suru krna pdega \\n                                                        //         example : [1 2 3 4 6 7]\\n                                                        //                   isme 1234 ka streak rhega, phir 6 pe tut jyega\\n                                                        //                   toh 1234 ke liye count aur max dono = 4. \\n                                                        //                   6 pe tuta, so, count became 1 (look in else condition)\\n                                                        //                   so, 67 ke liye, count=2 , aur max = Math.max(4{from 1234}, 2{from 67})\\n            } \\n    \\n            else if(arr[i]==arr[i-1]) continue          // yeh step LEARNING hai tere liye. nahi toh tu toh SET laga rha tha duplicate hataane ke liye\\n      \\n            else {\\n                count = 1\\n            }\\n           \\n        }\\n        return max\\n};\\n```\n```\\n\\nvar longestConsecutive = function(arr) {\\n\\n    if(arr.length<=0) return 0\\n\\n    let map = new Map()\\n\\n\\n    // STEP1 : MAP MEIN SABKO SEQ INITIATOR ASSUME KRKE, TRUE SET KARO\\n    for(let elem of arr){\\n        map.set(elem, 1)            // map  bithaa ke, sabko True set kr diya\\n                                    // mtlb, assume yeh kr rhe hum abhi ki\\n                                    // harr ek elem, kisi sequence ki suruwaat hai (thats false, we do know that ;)  )\\n    }\\n\\n\\n\\n    // STEP2: YEH DEKHO KI, ISSE PEHLE WALA KAHI PRESENT TOH NAHI HAI MAP MEIN\\n    for(let i in arr){              \\n        if(map.has(arr[i]-1)) {     // ab , ARRAY mein loop laga ke yeh dekh rhe ki\\n                                    // KYA, isse pehle wla numeric number, Map mein already pada hai ?\\n                                    // agar hai, toh YEH TOH SURUWAAT nahi ho skta\\n                                    // suruwaat kaise hoga yeh. inbetween wala kuch elem hoyega\\n                                    // example: 4 ke liye check kr rhe, KYA 3 map mein pada hai ?\\n                                    //          agar hai, mtlb, suruwaat probably 3 hoyega na. 4 toh nahi hoga na suruwaat\\n\\n            map.set(arr[i], 0)      // hence, agar pada hai, toh isko FALSE set kr do.\\n        }\\n    }\\n\\n\\n\\n                                    // ab TRUE woh log reh gaye, jo sacchi kisi sequence ki suruwaat hai\\n                                    // example :  [1234] [100] [200] yeh sequence bann rhi thi initially,\\n                                    //            toh 1->TRUE\\n                                    //              100->TRUE\\n                                    //              200->TRUE mila hai sacchi ka opne ko.\\n                                    //\\n                                    //  so sequence intiator sab mil gaye,\\n                                    //  ab yeh dekhte hai, ki kaunsa sequence intiator, sabse badaa sequence generate krta hai\\n                                    //  lets count\\n\\n\\n\\n\\n\\n\\n    //STEP3: AB SAB SEQ INITIATORS KI LENGTH CALC KRO \\n    let maxLen=1\\n    for(let elem of arr) {\\n        if(map.get(elem)==1) {                           // TRUE walo ko liye, sequence ki length dhundhenge\\n\\n            let seqCount = 1                             // sab element pkka se, kisi sequence ke initiator hai yaha ab. so pehle se hi count=1 set kr diya h (asaani ho rha tha aise coding krne mein)\\n            while(map.has(elem + seqCount)) {            // jab tak sequence badhta rhe,\\n                seqCount+=1                              // count krte raho\\n            }\\n\\n            maxLen = Math.max(maxLen, seqCount)          // jab sequence bdhna khatam ho jaaye, tab maxLen ko update kr do (agar seqCount badaa mila apne ko toh )\\n\\n        }\\n\\n    }\\n\\n\\n\\n    \\n    return maxLen\\n    \\n\\n};\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 41062,
                "title": "my-java-solution-using-unionfound",
                "content": "        \\n    public class Solution {\\n            public int longestConsecutive(int[] nums) {\\n                UF uf = new UF(nums.length);\\n                Map<Integer,Integer> map = new HashMap<Integer,Integer>(); // <value,index>\\n                for(int i=0; i<nums.length; i++){\\n                    if(map.containsKey(nums[i])){\\n                        continue;\\n                    }\\n                    map.put(nums[i],i);\\n                    if(map.containsKey(nums[i]+1)){\\n                        uf.union(i,map.get(nums[i]+1));\\n                    }\\n                    if(map.containsKey(nums[i]-1)){\\n                        uf.union(i,map.get(nums[i]-1));\\n                    }\\n                }\\n                return uf.maxUnion();\\n            }\\n        }\\n        \\n        class UF{\\n            private int[] list;\\n            public UF(int n){\\n                list = new int[n];\\n                for(int i=0; i<n; i++){\\n                    list[i] = i;\\n                }\\n            }\\n            \\n            private int root(int i){\\n                while(i!=list[i]){\\n                    list[i] = list[list[i]];\\n                    i = list[i];\\n                }\\n                return i;\\n            }\\n            \\n            public boolean connected(int i, int j){\\n                return root(i) == root(j);\\n            }\\n            \\n            public void union(int p, int q){\\n              int i = root(p);\\n              int j = root(q);\\n              list[i] = j;\\n            }\\n            \\n            // returns the maxium size of union\\n            public int maxUnion(){ // O(n)\\n                int[] count = new int[list.length];\\n                int max = 0;\\n                for(int i=0; i<list.length; i++){\\n                    count[root(i)] ++;\\n                    max = Math.max(max, count[root(i)]);\\n                }\\n                return max;\\n            }\\n        }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n            public int longestConsecutive(int[] nums) {\\n                UF uf = new UF(nums.length);\\n                Map<Integer,Integer> map = new HashMap<Integer,Integer>(); // <value,index>\\n                for(int i=0; i<nums.length; i++){\\n                    if(map.containsKey(nums[i])){\\n                        continue;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 2238932,
                "title": "c-python-simple-solution-w-explanation-o-n-o-n",
                "content": "Given an *unsorted* array of integers `nums`, we need to return the length of the longest consecutive elements sequence.\\ne.g.:\\n\\n```text\\nnums = [0, 3, 2, 1, 5, 6, 9]\\n\\nConsecutive Elements of length\\n1: [0], [1], [2], [3], [5], [6], [9]\\n2: [5, 6]\\n4: [0, 1, 2, 3]\\n\\nHence, we return 4\\n```\\n\\nIt is explicitly mentioned in the problem statement that the algorithm should be of time complexity `O(n)`, so sorting the array is out of the question.\\n\\nI then thought of a solution that is `O(n)` which is as follows:\\n\\n1. Use a boolean array, where the index represents the number itself to store if the number is present or not.\\n2. Then traverse through this array to find the longest consecutive `True` values.\\n\\ne.g.:\\n\\n```text\\nnums = [0, 3, 2, 1, 5, 6, 9]\\nbool_arr = [True, True, True, True, False, True, True, False, False, True]\\n              |     |     |     |     |      |     |     |      |      |\\n              0     1     2     3     4      5     6     7      8      9\\n\\nThe largest consecutive sequence with True values is of length 4, which is our answer.\\n```\\n\\nI then looked at the constraints, which mention `-10\\u2079 <= nums[i] <= 10\\u2079`, so this approach also cannot be used as both time and space complexity would be of order ~`2*10\\u2079`, which is high.\\n\\nSo, let\\'s think of a brute-force approach and then optimize it.\\n___\\n___\\n\\u274C **Solution I: Brute-force [TLE]**\\n\\nStarting from each `num` in the `nums` array, we try to build a consecutive sequence and check if it is the longest. We can do this by checking if `num + 1` is present or not; if present, then check if `num + 2` is present or not and so on.\\n\\n<iframe src=\"https://leetcode.com/playground/R7vj6zuS/shared\" frameBorder=\"0\" width=\"1080\" height=\"330\"></iframe>\\n\\n- **Time Complexity:** `O(n\\xB3)`\\n    > The outer `for` loop runs `n` times. The inner `while` loop can run upto `n` times for the worst case if the entire array forms consecutive sequence, and finding `curr_num + 1 in nums` has complexity `0(n)`.\\n- **Space Complexity:** `O(1)`\\n\\n___\\n\\u274C **Solution II: Optimized Brute-force + HashSet [TLE]**\\n\\nWe are checking if `curr_num + 1` is present in the array in `O(n)` time. We can optimize this lookup to `O(1)` using a HashSet.\\n\\n<iframe src=\"https://leetcode.com/playground/HWrbwqqR/shared\" frameBorder=\"0\" width=\"1080\" height=\"340\"></iframe>\\n\\n- **Time Complexity:** `O(n\\xB2)`\\n    > We reduced the lookup to `O(1)` and everything else remains the same.\\n- **Space Complexity:** `O(n)`\\n\\n___\\n\\u2705 **Solution III: Super Optimized Brute-force + HashSet [Accepted]**\\n\\nWe are still doing many repetitive works. This can be understood by the following example:\\n\\n```text\\nnums = [1, 2, 3, 4, 5]\\n1. num = 1\\n   a. curr_num = 1, curr_len = 1, while condition: True\\n   b. curr_num = 2, curr_len = 2, while condition: True\\n   c. curr_num = 3, curr_len = 3, while condition: True\\n   d. curr_num = 4, curr_len = 4, while condition: True\\n   e. curr_num = 5, curr_len = 5, while condition: False\\n\\n2. num = 2\\n    a. curr_num = 2, curr_len = 1, while condition: True\\n    b. curr_num = 3, curr_len = 2, while condition: True\\n    c. curr_num = 4, curr_len = 3, while condition: True\\n    d. curr_num = 5, curr_len = 4, while condition: False\\n.\\n.\\n.\\n```\\n\\nThis redundancy can be removed in multiple ways. One way could be to use an extra HashSet to store the information that the number is already a part of a sequence that was processed earlier. So, in the previous example, no need to run the inner `while` loop as `2` was already processed. Furthermore, the inner `while` loop won\\'t run for `num = 3, 4 and 5`.\\nThere is one more interesting way. Considering the previous example, after `num = 1` has been processed, `num` becomes `2`. Now we can check if `1,` i.e. `num - 1` is present in the array or not. If present, there is no need to run the inner `while` loop, as it was processed earlier or will be processed later. What do I mean by \"will be processed later\"? This will become clear in the following example.\\n\\n```text\\nnums = [2, 3, 1, 4, 5]\\n1. num = 2\\n   1 is present -> Don\\'t run the inner loop\\n2. num = 3\\n   2 is present -> Don\\'t run the inner loop\\n3. curr_num = 1\\n   0 is not present -> Run the inner loop\\n   a. curr_num = 1, curr_len = 1, while condition: True\\n   b. curr_num = 2, curr_len = 2, while condition: True\\n   c. curr_num = 3, curr_len = 3, while condition: True\\n   d. curr_num = 4, curr_len = 4, while condition: True\\n   e. curr_num = 5, curr_len = 5, while condition: False\\n```\\n\\n<iframe src=\"https://leetcode.com/playground/Ps5QMtvx/shared\" frameBorder=\"0\" width=\"1080\" height=\"380\"></iframe>\\n\\nIn short, the inner while loop will only start if any `num` in `nums` is the start of a new consecutive sequence.\\n\\n- **Time Complexity:** `O(n)`\\n    > This is actually tricky. One may think there are two nested loops, and the complexity should be `O(n\\xB2)`. But, this is not the case. To understand this, focus on my statement just after the code. The `while` loop will only execute when `num` is the start of a sequence and will run up to `n` times for the worst case. So, let\\'s say `nums = [3, 5, 1, 2, 7, 6]`. The `while` loop will only execute when `num = 1 or 5`, which will run till `3` and `7`, respectively. So, the array is covered only once!\\n- **Space Complexity:** `O(n)`\\n\\n___\\n**Update:**\\nThe code can be made even faster if we run the `for` loop through the set instead of the original array. This is because we are not considering duplicate elements. Thanks to [@dennisthomas2002](https://leetcode.com/dennisthomas2002/) and [@shivangtomar](https://leetcode.com/shivangtomar/) for their suggestions.\\n\\n```python\\nclass Solution:\\n    def longestConsecutive(self, nums: List[int]) -> int:\\n        max_len = 0\\n        num_set = set(nums)\\n        for num in num_set:\\n            if num - 1 not in num_set:\\n                curr_num = num\\n                curr_len = 1\\n                while curr_num + 1 in num_set:\\n                    curr_num += 1\\n                    curr_len += 1\\n                max_len = max(max_len, curr_len)\\n        return max_len\\n```\\n\\nThis solution was inspired by [@StefanPochmann](https://leetcode.com/StefanPochmann/)\\'s solution [here](https://leetcode.com/problems/longest-consecutive-sequence/discuss/41057/Simple-O(n)-with-Explanation-Just-walk-each-streak).\\n___\\n___\\nIf you like the solution, please **upvote**! \\uD83D\\uDD3C\\nFor any questions, or discussions, comment below. \\uD83D\\uDC47\\uFE0F\\n",
                "solutionTags": [
                    "Python",
                    "C"
                ],
                "code": "```text\\nnums = [0, 3, 2, 1, 5, 6, 9]\\n\\nConsecutive Elements of length\\n1: [0], [1], [2], [3], [5], [6], [9]\\n2: [5, 6]\\n4: [0, 1, 2, 3]\\n\\nHence, we return 4\\n```\n```text\\nnums = [0, 3, 2, 1, 5, 6, 9]\\nbool_arr = [True, True, True, True, False, True, True, False, False, True]\\n              |     |     |     |     |      |     |     |      |      |\\n              0     1     2     3     4      5     6     7      8      9\\n\\nThe largest consecutive sequence with True values is of length 4, which is our answer.\\n```\n```text\\nnums = [1, 2, 3, 4, 5]\\n1. num = 1\\n   a. curr_num = 1, curr_len = 1, while condition: True\\n   b. curr_num = 2, curr_len = 2, while condition: True\\n   c. curr_num = 3, curr_len = 3, while condition: True\\n   d. curr_num = 4, curr_len = 4, while condition: True\\n   e. curr_num = 5, curr_len = 5, while condition: False\\n\\n2. num = 2\\n    a. curr_num = 2, curr_len = 1, while condition: True\\n    b. curr_num = 3, curr_len = 2, while condition: True\\n    c. curr_num = 4, curr_len = 3, while condition: True\\n    d. curr_num = 5, curr_len = 4, while condition: False\\n.\\n.\\n.\\n```\n```text\\nnums = [2, 3, 1, 4, 5]\\n1. num = 2\\n   1 is present -> Don\\'t run the inner loop\\n2. num = 3\\n   2 is present -> Don\\'t run the inner loop\\n3. curr_num = 1\\n   0 is not present -> Run the inner loop\\n   a. curr_num = 1, curr_len = 1, while condition: True\\n   b. curr_num = 2, curr_len = 2, while condition: True\\n   c. curr_num = 3, curr_len = 3, while condition: True\\n   d. curr_num = 4, curr_len = 4, while condition: True\\n   e. curr_num = 5, curr_len = 5, while condition: False\\n```\n```python\\nclass Solution:\\n    def longestConsecutive(self, nums: List[int]) -> int:\\n        max_len = 0\\n        num_set = set(nums)\\n        for num in num_set:\\n            if num - 1 not in num_set:\\n                curr_num = num\\n                curr_len = 1\\n                while curr_num + 1 in num_set:\\n                    curr_num += 1\\n                    curr_len += 1\\n                max_len = max(max_len, curr_len)\\n        return max_len\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1254566,
                "title": "python-3-solutions-clean-concise",
                "content": "**\\u2714\\uFE0F Solution 1: Sorting then check consecutive elements**\\n```python\\nclass Solution:\\n    def longestConsecutive(self, nums: List[int]) -> int:\\n        if len(nums) == 0: return 0\\n        nums = sorted(set(nums))\\n        lastNum = nums[0]\\n        curLength = 1\\n        res = 1\\n        \\n        for i in range(1, len(nums)):\\n            if nums[i] == lastNum + 1:\\n                curLength += 1\\n            else:\\n                curLength = 1\\n            res = max(res, curLength)\\n            lastNum = nums[i]\\n            \\n        return res\\n```\\nComplexity:\\n- Time: `O(NlogN)`, where `N` is length of `nums` array\\n- Space: `O(N)`\\n\\n---\\n**\\u2714\\uFE0F Solution 2: Top down DP**\\n```python\\nclass Solution:\\n    def longestConsecutive(self, nums: List[int]) -> int:\\n        myset = set(nums)\\n        \\n        @lru_cache(None)\\n        def dp(num):\\n            if num not in myset:\\n                return 0\\n            \\n            return dp(num+1) + 1\\n        \\n        ans = 0\\n        for num in nums:\\n            ans = max(ans, dp(num))\\n        return ans\\n```\\nComplexity:\\n- Time: `O(N)`, where `N` is length of `nums` array\\n- Space: `O(N)`\\n\\n---\\n**\\u2714\\uFE0F Solution 3: Find the left most of the consecutive subsequence then expand the right side**\\n```python\\nclass Solution:\\n    def longestConsecutive(self, nums: List[int]) -> int:\\n        res = 0\\n        nums = set(nums)\\n        for num in nums:\\n            if num - 1 not in nums:  # then num is the left most of the consecutive sequence\\n                left = num\\n                right = num\\n                while right + 1 in nums:  # scan to find the right most of the consecutive sequence\\n                    right += 1\\n                res = max(res, right - left + 1)\\n        return res\\n```\\nComplexity:\\n- Time: `O(N)`, where `N` is length of `nums` array\\n- Space: `O(N)`",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def longestConsecutive(self, nums: List[int]) -> int:\\n        if len(nums) == 0: return 0\\n        nums = sorted(set(nums))\\n        lastNum = nums[0]\\n        curLength = 1\\n        res = 1\\n        \\n        for i in range(1, len(nums)):\\n            if nums[i] == lastNum + 1:\\n                curLength += 1\\n            else:\\n                curLength = 1\\n            res = max(res, curLength)\\n            lastNum = nums[i]\\n            \\n        return res\\n```\n```python\\nclass Solution:\\n    def longestConsecutive(self, nums: List[int]) -> int:\\n        myset = set(nums)\\n        \\n        @lru_cache(None)\\n        def dp(num):\\n            if num not in myset:\\n                return 0\\n            \\n            return dp(num+1) + 1\\n        \\n        ans = 0\\n        for num in nums:\\n            ans = max(ans, dp(num))\\n        return ans\\n```\n```python\\nclass Solution:\\n    def longestConsecutive(self, nums: List[int]) -> int:\\n        res = 0\\n        nums = set(nums)\\n        for num in nums:\\n            if num - 1 not in nums:  # then num is the left most of the consecutive sequence\\n                left = num\\n                right = num\\n                while right + 1 in nums:  # scan to find the right most of the consecutive sequence\\n                    right += 1\\n                res = max(res, right - left + 1)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2239045,
                "title": "c-beats-95-o-n-optimized",
                "content": "**PLEASE UPVOTE IF YOU FIND MY APPROACH HELPFUL, MEANS A LOT \\uD83D\\uDE0A**\\n\\n**Explanation:**\\n* Insert all the elements of the array into set.\\n* Check if the previous number (nums[i] - 1) is present in the set, if it is then that number (nums[i]) is not the starting of the sequence.\\n* If previous number is not present, that means that number is the starting of the sequence.\\n* Make a count variable to count the length of the sequence and current variable to store the current number.\\n* Now in a while loop, traverse and keep searching for consecutive elements until the condition is false.\\n* Now store the maximum of longest_sequence and current length of the sequence.\\n\\n**Time complexity: O(n)**\\n**Space complexity: O(n)**\\n\\n```\\nclass Solution {\\npublic:\\n    int longestConsecutive(vector<int>& nums) {\\n        unordered_set<int> s(nums.begin(),nums.end()); // this is faster\\n        \\n        // for(int i = 0; i<nums.size(); i++)\\n        // {\\n        //     s.insert(nums[i]);\\n        // }\\n        \\n        int longest_sequence = 0;\\n        \\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            if(s.find(nums[i] - 1)!=s.end())\\n                continue;\\n            \\n            else\\n            {\\n                int count = 0;\\n                int current_element = nums[i];\\n                \\n                while(s.find(current_element) != s.end())\\n                {\\n                    count++;\\n                    current_element++;\\n                }\\n                \\n                longest_sequence = max(longest_sequence,count);\\n            }\\n        }\\n        \\n        return longest_sequence;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestConsecutive(vector<int>& nums) {\\n        unordered_set<int> s(nums.begin(),nums.end()); // this is faster\\n        \\n        // for(int i = 0; i<nums.size(); i++)\\n        // {\\n        //     s.insert(nums[i]);\\n        // }\\n        \\n        int longest_sequence = 0;\\n        \\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            if(s.find(nums[i] - 1)!=s.end())\\n                continue;\\n            \\n            else\\n            {\\n                int count = 0;\\n                int current_element = nums[i];\\n                \\n                while(s.find(current_element) != s.end())\\n                {\\n                    count++;\\n                    current_element++;\\n                }\\n                \\n                longest_sequence = max(longest_sequence,count);\\n            }\\n        }\\n        \\n        return longest_sequence;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 41202,
                "title": "python-o-n-solution-using-sets",
                "content": "    class Solution:\\n        # @param num, a list of integer\\n        # @return an integer\\n        def longestConsecutive(self, num):\\n            num=set(num)\\n            maxLen=0\\n            while num:\\n                n=num.pop()\\n                i=n+1\\n                l1=0\\n                l2=0\\n                while i in num:\\n                    num.remove(i)\\n                    i+=1\\n                    l1+=1\\n                i=n-1\\n                while i in num:\\n                    num.remove(i)\\n                    i-=1\\n                    l2+=1\\n                maxLen=max(maxLen,l1+l2+1)\\n            return maxLen",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution:\\n        # @param num, a list of integer\\n        # @return an integer\\n        def longestConsecutive(self, num):\\n            num=set(num)\\n            maxLen=0\\n            while num:\\n                n=num.pop()\\n                i=n+1\\n                l1=0\\n                l2=0\\n                while i in num:\\n                    num.remove(i)\\n                    i+=1\\n                    l1+=1\\n                i=n-1\\n                while i in num:\\n                    num.remove(i)\\n                    i-=1\\n                    l2+=1\\n                maxLen=max(maxLen,l1+l2+1)\\n            return maxLen",
                "codeTag": "Java"
            },
            {
                "id": 2238885,
                "title": "java-o-n-90-faster-easy-explanation-with-comments",
                "content": "```\\nclass Solution {\\n    public int longestConsecutive(int[] nums) {\\n        int res = 0;// answer len\\n        Set<Integer> set = new HashSet<>();\\n        for(int i:nums) set.add(i); // add all elements in a set, we dont require duplicates because - \\n        //suppose we have 1 1 2 2 3 3 in the array the max len will be 3 - (1 2 3) doesnt matter how many times a number is present \\n        for(int i:nums){\\n            // the idea is to assume that the present value \"i\" is the center of the sequence in which it is present \\n            // then we will go left and right of it to find the length of its sequence\\n            // suppose we have 5 1 2 3 4 6 7 8, now the first element we have is 5\\n            int max = 1,prevVal = i-1,nextVal = i+1; // max is the current length as we have one elemet in the sequence that is 5\\n            // now for 5 prevVal = 4\\n            while(set.contains(prevVal)){ // if 4 is present in the set i.e. in the array\\n                max++; // increase the sequence len\\n                set.remove(prevVal--); // remove 4 and decremennt prevVal to 3 and continue \\n            }\\n            // removing the elements because an element can only be part of only one consecutive sequence\\n            while(set.contains(nextVal)){ // same for the nextVal of the sequence\\n                max++;\\n                set.remove(nextVal++);\\n            }\\n            res = Math.max(res,max); // maintaining max len \\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int longestConsecutive(int[] nums) {\\n        int res = 0;// answer len\\n        Set<Integer> set = new HashSet<>();\\n        for(int i:nums) set.add(i); // add all elements in a set, we dont require duplicates because - \\n        //suppose we have 1 1 2 2 3 3 in the array the max len will be 3 - (1 2 3) doesnt matter how many times a number is present \\n        for(int i:nums){\\n            // the idea is to assume that the present value \"i\" is the center of the sequence in which it is present \\n            // then we will go left and right of it to find the length of its sequence\\n            // suppose we have 5 1 2 3 4 6 7 8, now the first element we have is 5\\n            int max = 1,prevVal = i-1,nextVal = i+1; // max is the current length as we have one elemet in the sequence that is 5\\n            // now for 5 prevVal = 4\\n            while(set.contains(prevVal)){ // if 4 is present in the set i.e. in the array\\n                max++; // increase the sequence len\\n                set.remove(prevVal--); // remove 4 and decremennt prevVal to 3 and continue \\n            }\\n            // removing the elements because an element can only be part of only one consecutive sequence\\n            while(set.contains(nextVal)){ // same for the nextVal of the sequence\\n                max++;\\n                set.remove(nextVal++);\\n            }\\n            res = Math.max(res,max); // maintaining max len \\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1254699,
                "title": "python-o-n-time-space-solution-explained",
                "content": "One possible solution is to use Union Find, where we keep different sets of consecutive numbers and if needed, we update it, this can be done in `O(n)` both time and memory, however it is a bit difficult to implement.\\n\\nMore simple way is to keep all numbers in set, and then try to find the longest group, because we have a quick way to check if given number inside our set or not. Imagine, that we have numbers `1, 100, 2, 3, 101, 6, 5, 4` and let us go through the steps of our algorithm to see how it works. The idea is always start with the start of our groups, that is if we have `num - 1` in our set, we ignore this number and go to the next.\\n\\n1. `num = 1`, we check `num - 1 = 0` is inside our set? No, so we do nothing. Next step is to check if `2` is here, then if `3` is here, and so on. In this example we will reach `6`, it means that we found group with length `6`, so we can update our answer.\\n2. `num = 100`, we check if `99` is here, it is not. Then we check `101`, `102` and so on. We found group with `2` elements here.\\n3. `num = 2`, check if `1` is here, yes - it is, so we do nothing, it is not the start of our group!\\n4. `num = 3, 101, 6, 5, 4` are all ignored, because it is not the start of the group.\\n\\n#### Complexity\\nEven though we have while inside for loop, time complexity is linear: in fact we will work with each number at most twice. If we have consecutive sequence `a, ..., b`, then we have one pass over data when we work with number `a` and for each number from `a+1` to `b` we just check in `O(1)` if previous number is here. Space complexity is `O(n)` as well to keep our set of numbers.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def longestConsecutive(self, nums):\\n        set_nums, ans = set(nums), 0\\n        for num in nums:\\n            if num - 1 in set_nums: continue\\n                \\n            nxt = num\\n            while nxt + 1 in set_nums:\\n                nxt += 1\\n            ans = max(ans, nxt-num+1)\\n                \\n        return ans\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Hash Table"
                ],
                "code": "```python\\nclass Solution:\\n    def longestConsecutive(self, nums):\\n        set_nums, ans = set(nums), 0\\n        for num in nums:\\n            if num - 1 in set_nums: continue\\n                \\n            nxt = num\\n            while nxt + 1 in set_nums:\\n                nxt += 1\\n            ans = max(ans, nxt-num+1)\\n                \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3888654,
                "title": "python3-c-java-intervals-greedy-and-dp-without-any-sort",
                "content": "Let\\'s break down the code and its logic in more detail:\\n\\n1. `std::unordered_map<int, std::pair<int, int>> mp;`\\n\\n- `mp` is an unordered map used to store intervals (ranges) of consecutive numbers. Each key represents the right endpoint of an interval, and the corresponding value is a pair `(r, l)` where `r` is the right endpoint and `l` is the left endpoint of the interval.\\n2. `std::unordered_map<int, bool> bl;`\\n\\n- `bl` is an unordered map used to keep track of whether an element `i` has been visited. If an element has been visited, its corresponding value in this map will be `true;` otherwise, it will be `false.`\\n3. `int mx = 0;`\\n\\n- `mx` is a variable that keeps track of the maximum length of consecutive sequence found.\\n4. The main loop iterates through each element `i` in the input `nums` array.\\nInside the loop:\\na. `if (bl[i]) { continue; }`\\nIf the current element `i` has already been visited, skip it and continue to the next iteration of the loop.\\nb. `bl[i] = true;`\\nMark the current element `i` as visited by setting its corresponding value in the `bl` map to `true`.\\nc. Initialize `l` and `r` to the current element `i`, representing the left and right endpoints of the current interval.\\nd. Check if there is an interval with the right endpoint `i + 1` in the `mp` map using `mp.find(i + 1)`. If such an interval exists, update the right endpoint `r` to the right endpoint of that interval.\\ne. Similarly, check if there is an interval with the right endpoint `i - 1` in the `mp` map using `mp.find(i - 1)`. If such an interval exists, update the left endpoint `l` to the left endpoint of that interval.\\nf. Update the `mp` map:\\nSet `mp[r]` to a pair `(r, l)`, indicating the interval with right endpoint `r` and left endpoint l.\\nSet `mp[l]` to the same pair `(r, l)`.\\ng. Calculate the length of the current consecutive sequence as `r - l + 1` and update the maximum length `mx` if this length is greater than the current maximum.\\n\\n5. Finally, return the maximum length mx, which represents the length of the longest consecutive sequence found in the input array.\\nExplanation from chatgpt. The solution is from me \\uD83D\\uDE07.\\n# Code\\n<iframe src=\"https://leetcode.com/playground/PaQPcr82/shared\" frameBorder=\"0\" width=\"800\" height=\"500\"></iframe>\\n\\n![image.png](https://assets.leetcode.com/users/images/2e8406f3-dd08-44bf-8b74-b4c1e3d63cb1_1685761147.083231.png)",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "Let\\'s break down the code and its logic in more detail:\\n\\n1. `std::unordered_map<int, std::pair<int, int>> mp;`\\n\\n- `mp` is an unordered map used to store intervals (ranges) of consecutive numbers. Each key represents the right endpoint of an interval, and the corresponding value is a pair `(r, l)` where `r` is the right endpoint and `l` is the left endpoint of the interval.\\n2. `std::unordered_map<int, bool> bl;`\\n\\n- `bl` is an unordered map used to keep track of whether an element `i` has been visited. If an element has been visited, its corresponding value in this map will be `true;` otherwise, it will be `false.`\\n3. `int mx = 0;`\\n\\n- `mx` is a variable that keeps track of the maximum length of consecutive sequence found.\\n4. The main loop iterates through each element `i` in the input `nums` array.\\nInside the loop:\\na. `if (bl[i]) { continue; }`\\nIf the current element `i` has already been visited, skip it and continue to the next iteration of the loop.\\nb. `bl[i] = true;`\\nMark the current element `i` as visited by setting its corresponding value in the `bl` map to `true`.\\nc. Initialize `l` and `r` to the current element `i`, representing the left and right endpoints of the current interval.\\nd. Check if there is an interval with the right endpoint `i + 1` in the `mp` map using `mp.find(i + 1)`. If such an interval exists, update the right endpoint `r` to the right endpoint of that interval.\\ne. Similarly, check if there is an interval with the right endpoint `i - 1` in the `mp` map using `mp.find(i - 1)`. If such an interval exists, update the left endpoint `l` to the left endpoint of that interval.\\nf. Update the `mp` map:\\nSet `mp[r]` to a pair `(r, l)`, indicating the interval with right endpoint `r` and left endpoint l.\\nSet `mp[l]` to the same pair `(r, l)`.\\ng. Calculate the length of the current consecutive sequence as `r - l + 1` and update the maximum length `mx` if this length is greater than the current maximum.\\n\\n5. Finally, return the maximum length mx, which represents the length of the longest consecutive sequence found in the input array.\\nExplanation from chatgpt. The solution is from me \\uD83D\\uDE07.\\n# Code\\n<iframe src=\"https://leetcode.com/playground/PaQPcr82/shared\" frameBorder=\"0\" width=\"800\" height=\"500\"></iframe>\\n\\n![image.png](https://assets.leetcode.com/users/images/2e8406f3-dd08-44bf-8b74-b4c1e3d63cb1_1685761147.083231.png)",
                "codeTag": "Unknown"
            },
            {
                "id": 139940,
                "title": "simple-javascript-o-n-solution",
                "content": "\\n**Method 1 Hash set**\\n\\nTime O(n)\\nSpace O(n)\\n\\n```\\nfunction longestConsecutive(nums) {\\n  if (nums == null || nums.length === 0) return 0;\\n  \\n  const set = new Set(nums);\\n  let max = 0;\\n\\n  for (let num of set) {\\n    if (set.has(num - 1)) continue;  // make sure starting from the beginning of sequence\\n\\n    let currNum = num;\\n    let currMax = 1;\\n\\n    while (set.has(currNum + 1)) {\\n      currNum++;\\n      currMax++;\\n    }\\n    max = Math.max(max, currMax);\\n  }\\n\\n  return max;\\n}\\n```\\n\\n**Method 2**\\n\\nReference: https://leetcode.com/problems/longest-consecutive-sequence/discuss/41055/My-really-simple-Java-O(n)-solution-Accepted\\n\\nIdea: Only store the sequence length to the boundary points of the sequence\\n\\n```js\\nfunction longestConsecutive(nums) {\\n  let max = 0;\\n  const lens = {};\\n  \\n  for (let n of nums) {\\n    if (lens[n] != null) continue;\\n\\n    const l = lens[n - 1] || 0;   // left length\\n    const r = lens[n + 1] || 0;   // right length\\n\\n    const len = l + r + 1;\\n\\n    // extend the length to the boundaries\\n    lens[n - l] = len;\\n    lens[n] = len;\\n    lens[n + r] = len;\\n\\n    max = Math.max(max, len);\\n  }\\n\\n  return max;\\n}\\n```\\n\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfunction longestConsecutive(nums) {\\n  if (nums == null || nums.length === 0) return 0;\\n  \\n  const set = new Set(nums);\\n  let max = 0;\\n\\n  for (let num of set) {\\n    if (set.has(num - 1)) continue;  // make sure starting from the beginning of sequence\\n\\n    let currNum = num;\\n    let currMax = 1;\\n\\n    while (set.has(currNum + 1)) {\\n      currNum++;\\n      currMax++;\\n    }\\n    max = Math.max(max, currMax);\\n  }\\n\\n  return max;\\n}\\n```\n```js\\nfunction longestConsecutive(nums) {\\n  let max = 0;\\n  const lens = {};\\n  \\n  for (let n of nums) {\\n    if (lens[n] != null) continue;\\n\\n    const l = lens[n - 1] || 0;   // left length\\n    const r = lens[n + 1] || 0;   // right length\\n\\n    const len = l + r + 1;\\n\\n    // extend the length to the boundaries\\n    lens[n - l] = len;\\n    lens[n] = len;\\n    lens[n + r] = len;\\n\\n    max = Math.max(max, len);\\n  }\\n\\n  return max;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 41222,
                "title": "sharing-my-20ms-c-solution-using-hash-set",
                "content": "    class Solution {\\n    public:\\n        int longestConsecutive(vector<int>& nums) {\\n            unordered_set<int> mySet;\\n            for(int i=0; i<nums.size(); i++)\\n                mySet.insert(nums[i]);\\n                \\n            int result = 0;\\n            while(mySet.size()>0)\\n            {\\n                int number = *mySet.begin();\\n                int count = 1;\\n                mySet.erase(number);\\n                int smaller = number-1;\\n                int bigger = number+1;\\n                while(mySet.count(smaller)>0)\\n                {\\n                    mySet.erase(smaller);\\n                    smaller--;\\n                    count++;\\n                }\\n                while(mySet.count(bigger)>0)\\n                {\\n                    mySet.erase(bigger);\\n                    bigger++;\\n                    count++;\\n                }\\n                \\n                result = max(result, count);\\n            }\\n            \\n            return result;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        int longestConsecutive(vector<int>& nums) {\\n            unordered_set<int> mySet;\\n            for(int i=0; i<nums.size(); i++)\\n                mySet.insert(nums[i]);\\n                \\n            int result = 0;\\n            while(mySet.size()>0)\\n            {\\n                int number = *mySet.begin();\\n                int count = 1;\\n                mySet.erase(number);\\n                int smaller = number-1;\\n                int bigger = number+1;\\n                while(mySet.count(smaller)>0)\\n                {\\n                    mySet.erase(smaller);\\n                    smaller--;\\n                    count++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1109808,
                "title": "python-clean-union-find-with-explanation",
                "content": "Idea is simple.\\n1. Iterate over the numbers, if you have seen it before it\\'s a duplicate number so don\\'t repeat the work. Actually, even if i repeated the work it would still doesn\\'t matter(except for penalty of redoing the work) but the algorithm would still be correct.\\n2. Otherwise, find the adjacent element `(num+1, num-1)` \\n3. Do union of adjacent elements and update the size of these nodes. I have modified the union method to return the updated size as it avoids me finding largest connected component once finished. Only time the max_size would change is when there is union of two nodes\\n\\n```\\nclass Node:\\n    def __init__(self, val):\\n        self.val = val\\n        self.parent = self\\n        self.size = 1\\n    \\nclass UnionFind:\\n        \\n    def find(self, node):\\n        if node.parent != node:\\n            node.parent = self.find(node.parent)\\n        return node.parent\\n    \\n    def union(self, node1, node2):\\n        parent_1 = self.find(node1)\\n        parent_2 = self.find(node2)\\n        if parent_1 != parent_2:\\n            parent_2.parent = parent_1\\n            parent_1.size += parent_2.size\\n        return parent_1.size\\n                \\n        \\n        \\nclass Solution:\\n    def longestConsecutive(self, nums: List[int]) -> int:\\n        uf = UnionFind()\\n        nodes = {}\\n        max_size = 0\\n        for num in nums:\\n            if num not in nodes:\\n                node = Node(num)\\n                nodes[num] = node\\n                size = 1\\n                if num + 1 in nodes:\\n                    size = uf.union(node, nodes[num+1])\\n                if num - 1 in nodes:\\n                    size = uf.union(node, nodes[num-1])\\n                max_size = max(max_size, size)\\n                \\n        return max_size\\n\\t\\t```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Union Find"
                ],
                "code": "```\\nclass Node:\\n    def __init__(self, val):\\n        self.val = val\\n        self.parent = self\\n        self.size = 1\\n    \\nclass UnionFind:\\n        \\n    def find(self, node):\\n        if node.parent != node:\\n            node.parent = self.find(node.parent)\\n        return node.parent\\n    \\n    def union(self, node1, node2):\\n        parent_1 = self.find(node1)\\n        parent_2 = self.find(node2)\\n        if parent_1 != parent_2:\\n            parent_2.parent = parent_1\\n            parent_1.size += parent_2.size\\n        return parent_1.size\\n                \\n        \\n        \\nclass Solution:\\n    def longestConsecutive(self, nums: List[int]) -> int:\\n        uf = UnionFind()\\n        nodes = {}\\n        max_size = 0\\n        for num in nums:\\n            if num not in nodes:\\n                node = Node(num)\\n                nodes[num] = node\\n                size = 1\\n                if num + 1 in nodes:\\n                    size = uf.union(node, nodes[num+1])\\n                if num - 1 in nodes:\\n                    size = uf.union(node, nodes[num-1])\\n                max_size = max(max_size, size)\\n                \\n        return max_size\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 326499,
                "title": "java-o-n-union-set-find",
                "content": "We use a hash map to  keep track of each elements\\' index in the *nums* array. For an element *e*, first we check if this element has already been seen before. If yes, ignore it. If element has not been seen before,  we add it\\'s index to the map. We then perform union of *e* with elements *e-1* and *e+1*, if these elements have been seen before in the array. (I modified the union function to return the size of the new set. We could also have just used a global size variable.)\\n```\\nclass UnionSet{\\n    int[] parents;\\n    int[] sizes;\\n    int[] ranks;\\n    UnionSet(int n){\\n        parents = new int[n];\\n        ranks = new int[n];\\n        sizes = new int[n];\\n        for(int i=0;i<n;i++){\\n            parents[i] = i;\\n        }\\n        Arrays.fill(sizes, 1);\\n    }\\n    \\n    public int union(int a, int b){\\n        // union by rank heuristic\\n        int idxA = findSet(a);\\n        int idxB = findSet(b);\\n\\t\\tif(idxA == idxB)\\n\\t\\t    return -1;\\n\\t\\t\\t\\n        if(ranks[idxA]>ranks[idxB]){\\n            parents[idxB] = idxA;\\n            sizes[idxA] += sizes[idxB];\\n            return sizes[idxA];\\n        } else {\\n            parents[idxA] = idxB;\\n            sizes[idxB] += sizes[idxA];\\n            if(ranks[idxB]==ranks[idxA]){\\n                ranks[idxB]++;\\n            }\\n            return sizes[idxB];\\n        }\\n    }\\n    \\n    public int findSet(int idx){\\n        // path compression heuristic\\n        if(parents[idx]!=idx)\\n            parents[idx] = findSet(parents[idx]);\\n        return parents[idx];\\n    }\\n}\\n\\nclass Solution {\\n    public int longestConsecutive(int[] nums) {\\n        int n = nums.length;\\n        if(n<=1){\\n            return n;\\n        }\\n        int longestConsecutiveSeqLen = 1;\\n\\t\\t\\n        // to track index of each element in array\\n        Map<Integer, Integer> mp = new HashMap<>(); \\n        UnionSet unionSet = new UnionSet(n);\\n        for(int i=0;i<n;i++){\\n            int e = nums[i];\\n            if(mp.containsKey(e)){\\n                continue;\\n            }\\n            mp.put(e, i);\\n            if(mp.containsKey(e-1)){\\n                longestConsecutiveSeqLen = Math.max(longestConsecutiveSeqLen, unionSet.union(i, mp.get(e-1)));\\n            }\\n            \\n            if(mp.containsKey(e+1)){\\n                longestConsecutiveSeqLen = Math.max(longestConsecutiveSeqLen, unionSet.union(i, mp.get(e+1)));\\n            }\\n            \\n        }\\n        return longestConsecutiveSeqLen;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass UnionSet{\\n    int[] parents;\\n    int[] sizes;\\n    int[] ranks;\\n    UnionSet(int n){\\n        parents = new int[n];\\n        ranks = new int[n];\\n        sizes = new int[n];\\n        for(int i=0;i<n;i++){\\n            parents[i] = i;\\n        }\\n        Arrays.fill(sizes, 1);\\n    }\\n    \\n    public int union(int a, int b){\\n        // union by rank heuristic\\n        int idxA = findSet(a);\\n        int idxB = findSet(b);\\n\\t\\tif(idxA == idxB)\\n\\t\\t    return -1;\\n\\t\\t\\t\\n        if(ranks[idxA]>ranks[idxB]){\\n            parents[idxB] = idxA;\\n            sizes[idxA] += sizes[idxB];\\n            return sizes[idxA];\\n        } else {\\n            parents[idxA] = idxB;\\n            sizes[idxB] += sizes[idxA];\\n            if(ranks[idxB]==ranks[idxA]){\\n                ranks[idxB]++;\\n            }\\n            return sizes[idxB];\\n        }\\n    }\\n    \\n    public int findSet(int idx){\\n        // path compression heuristic\\n        if(parents[idx]!=idx)\\n            parents[idx] = findSet(parents[idx]);\\n        return parents[idx];\\n    }\\n}\\n\\nclass Solution {\\n    public int longestConsecutive(int[] nums) {\\n        int n = nums.length;\\n        if(n<=1){\\n            return n;\\n        }\\n        int longestConsecutiveSeqLen = 1;\\n\\t\\t\\n        // to track index of each element in array\\n        Map<Integer, Integer> mp = new HashMap<>(); \\n        UnionSet unionSet = new UnionSet(n);\\n        for(int i=0;i<n;i++){\\n            int e = nums[i];\\n            if(mp.containsKey(e)){\\n                continue;\\n            }\\n            mp.put(e, i);\\n            if(mp.containsKey(e-1)){\\n                longestConsecutiveSeqLen = Math.max(longestConsecutiveSeqLen, unionSet.union(i, mp.get(e-1)));\\n            }\\n            \\n            if(mp.containsKey(e+1)){\\n                longestConsecutiveSeqLen = Math.max(longestConsecutiveSeqLen, unionSet.union(i, mp.get(e+1)));\\n            }\\n            \\n        }\\n        return longestConsecutiveSeqLen;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 41281,
                "title": "13-line-c-solution",
                "content": "Thought I would share it here. May be useful for some one. The algorithm itself is pretty straightforward. But it benefited quite much from the neat expression of C++ idioms. Comments are appreciated!\\n\\n    int longestConsecutive(const vector<int> &num) {\\n        unordered_set<int> s(num.begin(), num.end()), searched;\\n        int longest = 0;\\n        for (int i: num) {\\n            if (searched.find(i) != searched.end()) continue;\\n            searched.insert(i);\\n            int j = i - 1, k = i + 1;\\n            while (s.find(j) != s.end()) searched.insert(j--);\\n            while (s.find(k) != s.end()) searched.insert(k++);\\n            longest = max(longest, k - 1 - j);\\n        }\\n        return longest;\\n    }",
                "solutionTags": [],
                "code": "Thought I would share it here. May be useful for some one. The algorithm itself is pretty straightforward. But it benefited quite much from the neat expression of C++ idioms. Comments are appreciated!\\n\\n    int longestConsecutive(const vector<int> &num) {\\n        unordered_set<int> s(num.begin(), num.end()), searched;\\n        int longest = 0;\\n        for (int i: num) {\\n            if (searched.find(i) != searched.end()) continue;\\n            searched.insert(i);\\n            int j = i - 1, k = i + 1;\\n            while (s.find(j) != s.end()) searched.insert(j--);\\n            while (s.find(k) != s.end()) searched.insert(k++);\\n            longest = max(longest, k - 1 - j);\\n        }\\n        return longest;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 41141,
                "title": "o-n-hashmap-java-solution",
                "content": "Use a hashmap to map a number to its longest consecutive sequence length, each time find a new consecutive sequence, only the begin number and end number need to be modified.\\n\\n    public class Solution {\\n        public int longestConsecutive(int[] num) {\\n            int longest = 0;\\n            Map<Integer, Integer> map = new HashMap<Integer, Integer>();\\n            for(int i = 0;i < num.length;i++){\\n                // if there is no duplicates, these two lines can be commented\\n                if(map.containsKey(num[i])) continue;\\n                map.put(num[i],1);\\n                \\n                int end = num[i];\\n                int begin = num[i];\\n                if(map.containsKey(num[i]+1))\\n                    end = num[i] + map.get(num[i]+1);\\n                if(map.containsKey(num[i]-1))\\n                    begin = num[i] - map.get(num[i]-1);\\n                longest = Math.max(longest, end-begin+1);\\n                map.put(end, end-begin+1);\\n                map.put(begin, end-begin+1);\\n            }\\n            return longest;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public int longestConsecutive(int[] num) {\\n            int longest = 0;\\n            Map<Integer, Integer> map = new HashMap<Integer, Integer>();\\n            for(int i = 0;i < num.length;i++){\\n                // if there is no duplicates, these two lines can be commented\\n                if(map.containsKey(num[i])) continue;\\n                map.put(num[i],1);\\n                \\n                int end = num[i];\\n                int begin = num[i];\\n                if(map.containsKey(num[i]+1))\\n                    end = num[i] + map.get(num[i]+1);\\n                if(map.containsKey(num[i]-1))\\n                    begin = num[i] - map.get(num[i]-1);\\n                longest = Math.max(longest, end-begin+1);\\n                map.put(end, end-begin+1);\\n                map.put(begin, end-begin+1);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2238798,
                "title": "python-c-o-n-clear-explanation-illustrated-with-example",
                "content": "**Intuition**\\nIn the array, there could be multiple groups of consecutive numbers. Ideally, we want to process each group only once to achieve the O(n) time complexity specified in the problem statement. To do this, let\\'s count the size of each group only when we are at the smallest element in the group. To check that the current number `num` is the first element in a group, it is sufficient to check that `num - 1` doesn\\'t appear in `nums`.\\n\\n**Example**\\nSuppose `nums = [100,2,101,3,1]`. There are 2 groups of consecutive numbers in `nums`, namely `[1,2,3]` and `[100,101]`.  We iterate through `nums`:\\n1. `[100,2,101,3,1]`\\n`__^____________`\\nSince `100-1=99` is in `nums`, we count the group size that `100` is part of by incrementing `100` until it is no longer in the set. After incrementing from `100 -> 101`, we stop, since `102` is not in `nums`. So we now know `100` is the start of a group of size 2.\\n\\n2. `[100,2,101,3,1]`\\n`_____^_________`\\n`2` is not the start of a group, since `2-1=1` is in `nums`, so we skip to the next element.\\n\\n3. `[100,2,101,3,1]`\\n`________^______`\\nWe skip `101` since `101-1=100` is in `nums`.\\n\\n4. `[100,2,101,3,1]`\\n`___________^___`\\nWe skip `3` since `3-1=2` is in `nums`.\\n\\n5. `[100,2,101,3,1]`\\n`_____________^_`\\nWe know `1` is that first number in a group since `1-1=0` is not in `nums`. We keep incrementing `1` until it is no longer contained in `nums`.  After incrementing from `1 -> 2 -> 3` we stop, since the next number `4` is not contained in `nums`. Thus, we know `1` is the start of a group of size `3`.\\n\\n**Python**\\n```python\\nclass Solution:\\n    def longestConsecutive(self, nums: List[int]) -> int:\\n        num_set = set(nums)\\n        \\n        longest_sequence = 0\\n        for num in nums:\\n            if num - 1 in num_set:\\n                continue\\n            current_length = 1\\n            while num + 1 in num_set:\\n                num += 1\\n                current_length += 1\\n            longest_sequence = max(longest_sequence, current_length)\\n        return longest_sequence\\n```\\n\\n**C++**\\n```c++\\nclass Solution {\\npublic:\\n    int longestConsecutive(vector<int>& nums) {\\n        unordered_set<int> nums_set(nums.begin(), nums.end());\\n        \\n        int longest_sequence = 0;\\n        for (int num : nums) {\\n            if (nums_set.count(num - 1)) continue;\\n            int current_length = 1;\\n            while (nums_set.count(num + 1)) {\\n                num++;\\n                current_length++;\\n            }\\n            longest_sequence = max(longest_sequence, current_length);\\n        }\\n        return longest_sequence;\\n    }\\n};\\n```\\n\\n**Time Complexity**: O(n) - On the surface, it looks like the time complexity might be O(n^2) because of the `while` loop nested inside the `for` loop. But actually, each element in `nums` is processed at most twice. We only run the `while` loop when we\\'re at the start of a group, otherwise we skip to the next element.\\n \\n**Space Complexity**: O(n) - We\\'re creating a set which contains each element in `nums`.\\n\\n**Upvote** if you found this explanation and example helpful!\\n\\n**Join our discord** to meet other people prepping for interviews!\\n**https://discord.gg/7wpQQFYC**",
                "solutionTags": [
                    "C++",
                    "Python",
                    "C"
                ],
                "code": "```python\\nclass Solution:\\n    def longestConsecutive(self, nums: List[int]) -> int:\\n        num_set = set(nums)\\n        \\n        longest_sequence = 0\\n        for num in nums:\\n            if num - 1 in num_set:\\n                continue\\n            current_length = 1\\n            while num + 1 in num_set:\\n                num += 1\\n                current_length += 1\\n            longest_sequence = max(longest_sequence, current_length)\\n        return longest_sequence\\n```\n```c++\\nclass Solution {\\npublic:\\n    int longestConsecutive(vector<int>& nums) {\\n        unordered_set<int> nums_set(nums.begin(), nums.end());\\n        \\n        int longest_sequence = 0;\\n        for (int num : nums) {\\n            if (nums_set.count(num - 1)) continue;\\n            int current_length = 1;\\n            while (nums_set.count(num + 1)) {\\n                num++;\\n                current_length++;\\n            }\\n            longest_sequence = max(longest_sequence, current_length);\\n        }\\n        return longest_sequence;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 735650,
                "title": "simple-c-two-solution-o-n-n-nlogn",
                "content": "(I) SORT THE VECTOR THEN COMPARE EACH VALUE.\\n-----------------------------------O(NLOGN), O(1)----------------------------------------------------------------------\\n\\n```\\nint longestConsecutive(vector<int>& nums) {\\n        if(nums.size() == 0)\\n            return 0;\\n        sort(nums.begin(), nums.end());\\n        \\n        int cus = 1;\\n        int maxs = 1;\\n        \\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i]!=nums[i-1]){\\n                if(nums[i] == nums[i-1]+1){\\n                    cus+=1;\\n            }\\n            else{\\n                maxs = max(maxs,cus);\\n                cus = 1;\\n            }\\n        }\\n       }\\n        return max(maxs,cus);\\n    }\\n```\\n\\n(II) MAKING USE OF THE HASH SET \\n----------------------------------O(N), O(N) --------------------------------------------------------------------------------\\n\\n```\\nint longestConsecutive(vector<int>& nums) {\\n        if(nums.size() == 0)\\n            return 0;\\n        unordered_set<int> s;\\n        for(int i: nums)\\n            s.insert(i);\\n        int ans = 0;\\n        \\n        for(int i=0;i<nums.size();i++){\\n            //minimum element to be searched for the purpose of comparing the next +1 value\\n            if(s.find(nums[i]-1) == s.end()){\\n                int j = nums[i]; // current value\\n                // next values while true do j++\\n                while(s.find(j)!=s.end())\\n                    j++;\\n                // max of previous ans and j - nums[i](-> smallest value)\\n                ans = max(ans,j-nums[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n```\\n\\nDON\\'T FORGET TO UPVOTE. IF YOU UNDERSTOOD BOTH THE APPROACHES.",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint longestConsecutive(vector<int>& nums) {\\n        if(nums.size() == 0)\\n            return 0;\\n        sort(nums.begin(), nums.end());\\n        \\n        int cus = 1;\\n        int maxs = 1;\\n        \\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i]!=nums[i-1]){\\n                if(nums[i] == nums[i-1]+1){\\n                    cus+=1;\\n            }\\n            else{\\n                maxs = max(maxs,cus);\\n                cus = 1;\\n            }\\n        }\\n       }\\n        return max(maxs,cus);\\n    }\\n```\n```\\nint longestConsecutive(vector<int>& nums) {\\n        if(nums.size() == 0)\\n            return 0;\\n        unordered_set<int> s;\\n        for(int i: nums)\\n            s.insert(i);\\n        int ans = 0;\\n        \\n        for(int i=0;i<nums.size();i++){\\n            //minimum element to be searched for the purpose of comparing the next +1 value\\n            if(s.find(nums[i]-1) == s.end()){\\n                int j = nums[i]; // current value\\n                // next values while true do j++\\n                while(s.find(j)!=s.end())\\n                    j++;\\n                // max of previous ans and j - nums[i](-> smallest value)\\n                ans = max(ans,j-nums[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3332396,
                "title": "simplest-python-solution-with-o-n-time-complexity-and-o-n-space-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nPython solution with a simple algorithm to find solution in O(n) time complexity with O(n) space complexity. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Convert list to set using inbuilt set function.\\n2. Create low and high integer to store low and high values in ongoing sequence and assign low and high value to current value.\\n3. Run a while loop that continues till high + 1 or low - 1 is present in uniques set.\\n    * If `low - 1` is present in uniques, decrease value of low by 1, and remove `low - 1` element from uniques.\\n    * If `high + 1` is present in uniques, increase value of high by 1. and remove `high + 1` element from uniques.\\n4. As we keep on iterating, we will be left with empty set, thus stopping our while loop.\\n\\n> Note that **in** operator in case of set has a time complexity of O(1) only.\\n\\n# Complexity\\n- Time complexity: O(n)\\n- Space complexity: O(n)\\n\\n# Code\\n```python3\\nclass Solution:\\n    def longestConsecutive(self, nums: List[int]) -> int:\\n        uniques = set(nums)\\n        max_length = 0\\n\\n        while uniques:\\n            low = high = uniques.pop()\\n            \\n            while low - 1 in uniques or high + 1 in uniques:\\n                if low - 1 in uniques:\\n                    uniques.remove(low - 1)\\n                    low -= 1\\n                \\n                if high + 1 in uniques:\\n                    uniques.remove(high + 1)\\n                    high += 1\\n\\n            max_length = max(high - low + 1, max_length)\\n\\n        return max_length\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python3\\nclass Solution:\\n    def longestConsecutive(self, nums: List[int]) -> int:\\n        uniques = set(nums)\\n        max_length = 0\\n\\n        while uniques:\\n            low = high = uniques.pop()\\n            \\n            while low - 1 in uniques or high + 1 in uniques:\\n                if low - 1 in uniques:\\n                    uniques.remove(low - 1)\\n                    low -= 1\\n                \\n                if high + 1 in uniques:\\n                    uniques.remove(high + 1)\\n                    high += 1\\n\\n            max_length = max(high - low + 1, max_length)\\n\\n        return max_length\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2238898,
                "title": "two-approaches-unordered-map-and-sorting-with-updating-java-and-cpp-solution",
                "content": "**```Time Complexity: O(N log(N))```**\\n\\n**```Java Code```**\\n\\n```\\nclass Solution {\\n    public int longestConsecutive(int[] nums) {\\n        int size = nums.length;\\n        \\n        if(size == 0) return 0;\\n        \\n        Arrays.sort(nums); // sorting the array in O(N log(N))\\n        \\n        int longest = 0;\\n        int current_longest = 1;\\n        \\n        for(int i=1;i<size;i++){\\n            \\n            if(nums[i] == nums[i-1]){\\n                continue; //same element as previous skip this\\n            }\\n            \\n            else if(nums[i] == nums[i-1] + 1){\\n                current_longest++; //current element is consecutive so increase it.\\n            }\\n            \\n            else{\\n                longest = Math.max(longest,current_longest);\\n                current_longest = 1; // we can\\'t extend so update longest as the maximum of the both and reset the current_longest.\\n            }\\n            \\n        }\\n        \\n        return Math.max(longest,current_longest);\\n    }\\n}\\n```\\n\\n**```C++  Code```**\\n\\n```\\nclass Solution {\\npublic:\\n    int longestConsecutive(vector<int>& nums) {\\n        int size = nums.size();\\n        if(!size) return 0;\\n        sort(nums.begin(), nums.end());\\n        int longest = 0;\\n        int current_longest = 1;\\n        for(int i=1;i<size;i++){\\n            if(nums[i] == nums[i-1]) continue; //same element as previous skip this\\n            else if(nums[i] == nums[i-1] + 1) current_longest++; //current element is consecutive so increase it.\\n            else longest = max(longest,current_longest), current_longest = 1; // we can\\'t extend so update longest as the maximum of the both and reset the current_longest.\\n        }\\n        return max(longest,current_longest);\\n    }\\n};\\n```\\n\\n<hr>\\n\\n**```We can write an algorithm in O(N) complexity```**\\n\\n```\\nclass Solution {\\npublic:\\n    int longestConsecutive(vector<int>& nums) {\\n        unordered_set<int> s(begin(nums),end(nums));\\n        int longest = 0;\\n        for(auto& i:s){\\n            if(s.count(i-1)) continue;\\n            int j=1;\\n            while(s.count(i+j)) j++;\\n            longest = max(longest,j);\\n        }\\n        return longest;\\n    }\\n};\\n```\\n\\n<hr>\\n\\nThe first two codes are in complexity O(N log(N)) and the second one is in O(N)\\n\\nsuppose the array length is 4 then \\nO(N log(N)) = O(4 log(4)) = O(2.40823) => Time is upto 2.40823{parameter of time}\\nO(N) = O(4) => Time is upto 4{parameter of time}\\n\\nFrom this we conclude that  **```O(N log(N)) is better than O(N)```**.  **NOPE IT\\'S WRONG**\\n\\n**```Reason```**: \\nThe computer has the log of base 2 not the base of 10. \\nO(N log(N)) = O(4 log(4)) = O(4 * 2 * log2{base 2}) = O(8) = 8{parameters of time}\\nO(N) = O(4) = 4{parameters of time}\\n\\nSo from here we can conclude : **```O(N) < O(N log(N))```**.\\n\\nAlways remember now: **```O(N) is always better than O(N log(N))```**\\n\\n**PS**: **_```Upvote if it helps you```_**",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Sorting",
                    "Ordered Set"
                ],
                "code": "```Time Complexity: O(N log(N))```\n```Java Code```\n```\\nclass Solution {\\n    public int longestConsecutive(int[] nums) {\\n        int size = nums.length;\\n        \\n        if(size == 0) return 0;\\n        \\n        Arrays.sort(nums); // sorting the array in O(N log(N))\\n        \\n        int longest = 0;\\n        int current_longest = 1;\\n        \\n        for(int i=1;i<size;i++){\\n            \\n            if(nums[i] == nums[i-1]){\\n                continue; //same element as previous skip this\\n            }\\n            \\n            else if(nums[i] == nums[i-1] + 1){\\n                current_longest++; //current element is consecutive so increase it.\\n            }\\n            \\n            else{\\n                longest = Math.max(longest,current_longest);\\n                current_longest = 1; // we can\\'t extend so update longest as the maximum of the both and reset the current_longest.\\n            }\\n            \\n        }\\n        \\n        return Math.max(longest,current_longest);\\n    }\\n}\\n```\n```C++  Code```\n```\\nclass Solution {\\npublic:\\n    int longestConsecutive(vector<int>& nums) {\\n        int size = nums.size();\\n        if(!size) return 0;\\n        sort(nums.begin(), nums.end());\\n        int longest = 0;\\n        int current_longest = 1;\\n        for(int i=1;i<size;i++){\\n            if(nums[i] == nums[i-1]) continue; //same element as previous skip this\\n            else if(nums[i] == nums[i-1] + 1) current_longest++; //current element is consecutive so increase it.\\n            else longest = max(longest,current_longest), current_longest = 1; // we can\\'t extend so update longest as the maximum of the both and reset the current_longest.\\n        }\\n        return max(longest,current_longest);\\n    }\\n};\\n```\n```We can write an algorithm in O(N) complexity```\n```\\nclass Solution {\\npublic:\\n    int longestConsecutive(vector<int>& nums) {\\n        unordered_set<int> s(begin(nums),end(nums));\\n        int longest = 0;\\n        for(auto& i:s){\\n            if(s.count(i-1)) continue;\\n            int j=1;\\n            while(s.count(i+j)) j++;\\n            longest = max(longest,j);\\n        }\\n        return longest;\\n    }\\n};\\n```\n```O(N log(N)) is better than O(N)```\n```Reason```\n```O(N) < O(N log(N))```\n```O(N) is always better than O(N log(N))```\n```Upvote if it helps you```",
                "codeTag": "Java"
            },
            {
                "id": 1254738,
                "title": "c-python-simple-and-short-o-n-solutions",
                "content": "**C++:**\\n```\\nclass Solution {\\npublic:\\n    int longestConsecutive(vector<int>& nums) {\\n        unordered_map<int, int> m;\\n        int res = 0, prev, next;\\n        for (auto num : nums) {\\n            if (m.find(num) == m.end()) {\\n                prev = m.find(num-1) != m.end() ? m[num-1] : 0;\\n                next = m.find(num+1) != m.end() ? m[num+1] : 0;\\n                m[num] += prev + next + 1;\\n                m[num-prev] = m[num];\\n                m[num+next] = m[num];\\n                res = max(res, m[num]);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n****\\n**Python:**\\n```\\nclass Solution:\\n    def longestConsecutive(self, nums: List[int]) -> int:\\n        my_dict = defaultdict(int)\\n        maxi = 0\\n        for num in nums:\\n            if num not in my_dict.keys():\\n                prev_ = my_dict.get(num-1, 0)\\n                next_ = my_dict.get(num+1, 0)\\n                my_dict[num] += prev_ + next_ + 1\\n                my_dict[num-prev_] = my_dict[num]\\n                my_dict[num+next_] = my_dict[num]\\n                maxi = max(maxi, my_dict[num])\\n        return maxi\\n```",
                "solutionTags": [
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestConsecutive(vector<int>& nums) {\\n        unordered_map<int, int> m;\\n        int res = 0, prev, next;\\n        for (auto num : nums) {\\n            if (m.find(num) == m.end()) {\\n                prev = m.find(num-1) != m.end() ? m[num-1] : 0;\\n                next = m.find(num+1) != m.end() ? m[num+1] : 0;\\n                m[num] += prev + next + 1;\\n                m[num-prev] = m[num];\\n                m[num+next] = m[num];\\n                res = max(res, m[num]);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def longestConsecutive(self, nums: List[int]) -> int:\\n        my_dict = defaultdict(int)\\n        maxi = 0\\n        for num in nums:\\n            if num not in my_dict.keys():\\n                prev_ = my_dict.get(num-1, 0)\\n                next_ = my_dict.get(num+1, 0)\\n                my_dict[num] += prev_ + next_ + 1\\n                my_dict[num-prev_] = my_dict[num]\\n                my_dict[num+next_] = my_dict[num]\\n                maxi = max(maxi, my_dict[num])\\n        return maxi\\n```",
                "codeTag": "Java"
            },
            {
                "id": 41126,
                "title": "one-java-solution",
                "content": "\\tpublic int longestConsecutive(int[] num) {\\n        Set<Integer> set = new HashSet<Integer>(num.length);\\n        for (int n: num) {\\n        \\tset.add(n);\\n        }\\n        \\n        int maxLength = 0;\\n        for (int n: num) {\\n        \\tif (set.contains(n)) {\\n        \\t\\tint length = 1;\\n            \\tint next = n - 1;\\n            \\twhile (set.contains(next)) {\\n            \\t\\tlength++;\\n            \\t\\tset.remove(next);\\n            \\t\\tnext--;\\n            \\t}\\n            \\tnext = n+1;\\n            \\twhile (set.contains(next)) {\\n            \\t\\tlength++;\\n            \\t\\tset.remove(next);\\n            \\t\\tnext++;\\n            \\t}\\n            \\t\\n            \\tif (length > maxLength) {\\n            \\t\\tmaxLength = length;\\n            \\t}\\n        \\t}\\n        }\\n        \\n        return maxLength;\\n\\t}\\n\\nThe basic idea is put all integers into a set. Iterate all the integers and for every integer try to find its consecutive numbers in the set and accumulate the length. The trick is remove the integer whenever it has been visited, which makes the process O(n) because every integer will only be visited once.",
                "solutionTags": [],
                "code": "\\tpublic int longestConsecutive(int[] num) {\\n        Set<Integer> set = new HashSet<Integer>(num.length);\\n        for (int n: num) {\\n        \\tset.add(n);\\n        }\\n        \\n        int maxLength = 0;\\n        for (int n: num) {\\n        \\tif (set.contains(n)) {\\n        \\t\\tint length = 1;\\n            \\tint next = n - 1;\\n            \\twhile (set.contains(next)) {\\n            \\t\\tlength++;\\n            \\t\\tset.remove(next);\\n            \\t\\tnext--;\\n            \\t}\\n            \\tnext = n+1;\\n            \\twhile (set.contains(next)) {\\n            \\t\\tlength++;\\n            \\t\\tset.remove(next);\\n            \\t\\tnext++;\\n            \\t}\\n            \\t\\n            \\tif (length > maxLength) {\\n            \\t\\tmaxLength = length;\\n            \\t}\\n        \\t}\\n        }\\n        \\n        return maxLength;\\n\\t}\\n\\nThe basic idea is put all integers into a set. Iterate all the integers and for every integer try to find its consecutive numbers in the set and accumulate the length. The trick is remove the integer whenever it has been visited, which makes the process O(n) because every integer will only be visited once.",
                "codeTag": "Unknown"
            },
            {
                "id": 1254645,
                "title": "longest-consecutive-sequence-short-easy-solution-w-explanation-hashset",
                "content": "\\u2714\\uFE0F ***Solution - I (Sorting)***\\n\\nWe can simply sort the given array and compare consecutive elements. Following cases exists:\\n1. **`nums[i] == nums[i-1] + 1`**: This means the current element is consecutive to previous, so increment current streak count.\\n2. **`nums[i] == nums[i-1]`**: We have found the same element as previous. Skip it, and see if we can still extend the sequence with next elements.\\n3. **None of above** : We can\\'t extend the sequence any further. Update *`longest`* to store longest formed streak till now and reset *`curlongest`*.\\n\\n**C++**\\n```\\nint longestConsecutive(vector<int>& nums) {\\n\\tif(!size(nums)) return 0;\\n\\tsort(begin(nums), end(nums));\\n\\tint longest = 0, cur_longest = 1;\\n\\tfor(int i = 1; i < size(nums); i++) \\n\\t\\tif(nums[i] == nums[i - 1]) continue;\\n\\t\\telse if(nums[i] == nums[i - 1] + 1) cur_longest++; // consecutive element - update current streak length\\n\\t\\telse longest = max(longest, cur_longest), cur_longest = 1;  // reset current streak length\\n\\treturn max(longest, cur_longest);\\n}\\n```\\n\\n---\\n\\n**Python**\\n```\\ndef longestConsecutive(self, nums: List[int]) -> int:\\n\\tnums.sort()\\n\\tlongest, cur_longest = 0, min(1, len(nums))\\n\\tfor i in range(1,len(nums)):\\n\\t\\tif nums[i] == nums[i - 1] : continue\\n\\t\\tif nums[i] == nums[i - 1] + 1: cur_longest += 1\\n\\t\\telse: longest, cur_longest = max(longest, cur_longest), 1\\n\\treturn max(longest, cur_longest)\\n```\\n\\n***Time Complexity :*** **`O(NlogN)`**, where *`N`* is the number of elements in nums\\n***Time Complexity :*** **`O(1)`**, ignoring the space required by sorting algorithm.\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - II (Using Hashset)***\\n\\nWe need to find the longest consecutive sequence in linear time. We can do this if we insert all the elements of *`nums`* into a hashset. Once we have inserted all the elements, we can just iterate over the hashset to find longest consecutive sequence involving  the current element(let\\'s call it *`num`*) under iteration. This can simply be done by **iterating over elements that are consecutive to *`num`* till we keep finding them in the set**. Each time we will also delete those elements from set to ensure we only visit them once.\\n\\n**C++**\\n```\\nint longestConsecutive(vector<int>& nums) {\\n\\tunordered_set<int> s(begin(nums), end(nums)); // inserting all elements into hashset\\n\\tint longest = 0;\\n\\tfor(auto& num : s) {\\n\\t\\tint cur_longest = 1;\\n\\t\\t// find consecutive elements in the backward and forward direction from num\\n\\t\\tfor(int j = 1; s.count(num - j); j++) s.erase(num - j), cur_longest++;\\n\\t\\tfor(int j = 1; s.count(num + j); j++) s.erase(num + j), cur_longest++;\\n\\t\\tlongest = max(longest, cur_longest);  // update longest to hold longest consecutive sequence till now\\n\\t}\\n\\treturn longest;\\n}\\n```\\n\\n---\\n\\n**Python**\\n```\\ndef longestConsecutive(self, nums: List[int]) -> int:\\n\\tlongest, s = 0, set(nums)\\n\\tfor num in nums:\\n\\t\\tcur_longest, j = 1, 1\\n\\t\\twhile num - j in s: \\n\\t\\t\\ts.remove(num - j)\\n\\t\\t\\tcur_longest, j = cur_longest + 1, j + 1\\n\\t\\tj = 1\\n\\t\\twhile num + j in s: \\n\\t\\t\\ts.remove(num + j)\\n\\t\\t\\tcur_longest, j = cur_longest + 1, j + 1\\n\\t\\tlongest = max(longest, cur_longest)\\n\\treturn longest\\n```\\n\\n***Time Complexity :*** **`O(N)`**\\n***Space Complexity :*** **`O(N)`**\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - III (Using Hashset - w/ optimizations)***\\n\\nWe can form a solution without the need to spend time erasing elements from the hashset. \\n\\nInstead of taking the first element that we find in the hashset and iterating both forward and backward, we can just keep skipping till we find that hashset contains `num - 1`. Finally, we can just iterate in the forward direction till we find consecutive elements in hashset and update `longest` at the end\\n\\n**C++**\\n```\\nint longestConsecutive(vector<int>& nums) {\\n\\tunordered_set<int> s(begin(nums), end(nums));\\n\\tint longest = 0;\\n\\tfor(auto& num : s) {\\n        if(s.count(num - 1)) continue;\\n\\t\\tint j = 1;\\n\\t\\twhile(s.count(num + j)) j++;\\n\\t\\tlongest = max(longest, j);\\n\\t}\\n\\treturn longest;\\n}\\n```\\n\\n---\\n\\n**Python**\\n```\\ndef longestConsecutive(self, nums):\\n\\ts, longest = set(nums), 0\\n\\tfor num in s:\\n\\t\\tif num - 1 in s: continue\\n\\t\\tj = 1\\n\\t\\twhile num + j in s: j += 1\\n\\t\\tlongest = max(longest, j)\\n\\treturn longest\\n```\\n\\n***Time Complexity :*** **`O(N)`**\\n***Space Complexity :*** **`O(N)`**\\n\\n---\\n---\\n\\n\\uD83D\\uDCBB\\uD83D\\uDC31\\u200D\\uD83D\\uDCBBIf there are any suggestions / questions / mistakes in my post, please do comment below \\uD83D\\uDC47 \\n\\n---\\n---",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint longestConsecutive(vector<int>& nums) {\\n\\tif(!size(nums)) return 0;\\n\\tsort(begin(nums), end(nums));\\n\\tint longest = 0, cur_longest = 1;\\n\\tfor(int i = 1; i < size(nums); i++) \\n\\t\\tif(nums[i] == nums[i - 1]) continue;\\n\\t\\telse if(nums[i] == nums[i - 1] + 1) cur_longest++; // consecutive element - update current streak length\\n\\t\\telse longest = max(longest, cur_longest), cur_longest = 1;  // reset current streak length\\n\\treturn max(longest, cur_longest);\\n}\\n```\n```\\ndef longestConsecutive(self, nums: List[int]) -> int:\\n\\tnums.sort()\\n\\tlongest, cur_longest = 0, min(1, len(nums))\\n\\tfor i in range(1,len(nums)):\\n\\t\\tif nums[i] == nums[i - 1] : continue\\n\\t\\tif nums[i] == nums[i - 1] + 1: cur_longest += 1\\n\\t\\telse: longest, cur_longest = max(longest, cur_longest), 1\\n\\treturn max(longest, cur_longest)\\n```\n```\\nint longestConsecutive(vector<int>& nums) {\\n\\tunordered_set<int> s(begin(nums), end(nums)); // inserting all elements into hashset\\n\\tint longest = 0;\\n\\tfor(auto& num : s) {\\n\\t\\tint cur_longest = 1;\\n\\t\\t// find consecutive elements in the backward and forward direction from num\\n\\t\\tfor(int j = 1; s.count(num - j); j++) s.erase(num - j), cur_longest++;\\n\\t\\tfor(int j = 1; s.count(num + j); j++) s.erase(num + j), cur_longest++;\\n\\t\\tlongest = max(longest, cur_longest);  // update longest to hold longest consecutive sequence till now\\n\\t}\\n\\treturn longest;\\n}\\n```\n```\\ndef longestConsecutive(self, nums: List[int]) -> int:\\n\\tlongest, s = 0, set(nums)\\n\\tfor num in nums:\\n\\t\\tcur_longest, j = 1, 1\\n\\t\\twhile num - j in s: \\n\\t\\t\\ts.remove(num - j)\\n\\t\\t\\tcur_longest, j = cur_longest + 1, j + 1\\n\\t\\tj = 1\\n\\t\\twhile num + j in s: \\n\\t\\t\\ts.remove(num + j)\\n\\t\\t\\tcur_longest, j = cur_longest + 1, j + 1\\n\\t\\tlongest = max(longest, cur_longest)\\n\\treturn longest\\n```\n```\\nint longestConsecutive(vector<int>& nums) {\\n\\tunordered_set<int> s(begin(nums), end(nums));\\n\\tint longest = 0;\\n\\tfor(auto& num : s) {\\n        if(s.count(num - 1)) continue;\\n\\t\\tint j = 1;\\n\\t\\twhile(s.count(num + j)) j++;\\n\\t\\tlongest = max(longest, j);\\n\\t}\\n\\treturn longest;\\n}\\n```\n```\\ndef longestConsecutive(self, nums):\\n\\ts, longest = set(nums), 0\\n\\tfor num in s:\\n\\t\\tif num - 1 in s: continue\\n\\t\\tj = 1\\n\\t\\twhile num + j in s: j += 1\\n\\t\\tlongest = max(longest, j)\\n\\treturn longest\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3552695,
                "title": "c-easy-solution-using-hash-table-optimised-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n* The intuition behind this code is to use a set to store all of the elements in the array. This allows us to quickly check if an element is the start of a new consecutive subsequence. We then iterate over the set, and for each element, we check if its predecessor is in the set. If it is not, then the element is the start of a new consecutive subsequence. We increment a counter for each consecutive subsequence that is found. The longest consecutive subsequence is the one with the largest counter.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1) Create a set to store all of the elements in the array.\\n2) Iterate over the set, and for each element, check if its predecessor is in the set. If it is not, then the element is the start of a new consecutive subsequence.\\n3) The longest consecutive subsequence is the one with the largest counter.\\n# Complexity\\n- Time complexity: $$O(N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(N)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestConsecutive(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n == 0){\\n            return 0;\\n        }\\n        int longest = 1;\\n        unordered_set<int> st;\\n        for(auto x : nums){\\n            st.insert(x);\\n        }\\n        for(auto s : st){\\n            if(st.find(s-1) == st.end()){\\n                int count = 1;\\n                int x = s;\\n                while(st.find(x+1) != st.end()){\\n                    count++;\\n                    x = x+1;\\n                }\\n                longest = max(longest, count);\\n            }\\n        }\\n        return longest;\\n    }\\n};\\n```\\n![UpvoteLeetcode.jpeg](https://assets.leetcode.com/users/images/a60f87a6-fd44-4617-a5a2-2b25878ee138_1684770197.189536.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestConsecutive(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n == 0){\\n            return 0;\\n        }\\n        int longest = 1;\\n        unordered_set<int> st;\\n        for(auto x : nums){\\n            st.insert(x);\\n        }\\n        for(auto s : st){\\n            if(st.find(s-1) == st.end()){\\n                int count = 1;\\n                int x = s;\\n                while(st.find(x+1) != st.end()){\\n                    count++;\\n                    x = x+1;\\n                }\\n                longest = max(longest, count);\\n            }\\n        }\\n        return longest;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1254716,
                "title": "js-python-java-c-easy-o-n-map-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nIn order to accomplish this task in **O(N) time**, we\\'ll have to have some way of looking up values (**nmap**), which means a **set** or **map** object. We\\'ll also need some way of keeping track of which numbers have already been **seen**.\\n\\n_(**Note**: We could forego the **seen** data structure entirely and just follow each path to its end every time, but that would cause us to redo the same sections over and over again, pushing the **time complexity** to **O(N^2)**.)_\\n\\nIf we use a set for **nmap**, then we would need to use a map for **seen** in order to be able to look the numbers up by value. If we instead use a map for **nmap**, with each number pointing to its index, then we can instead use those indexes with an **array** for **seen**, which will be more efficient.\\n\\n_(**Note**: Since we\\'ll be iterating through **nums** from front to back in the next section, we should make sure that we store only the first index at which a number is found in **nmap**. Later indexes of duplicate numbers can be ignored, as by then the number will already be considered **seen**.)_\\n\\nBut now we run into the issue of potentially finding the middle of a sequence before we find the beginning of the sequence. For this we can take inspiration from a **union-find** approach and/or **dynamic programming** (**DP**) approach; We can use **seen** to store the length of the sequence found when starting at the given number.\\n\\n_(**Note**: We don\\'t need to store path length data in any but the smallest number of a found chain, as those nodes can never be actively visited again. Only the entry point, which is the smallest number, needs to have the accurate path length stored. For the other numbers, we just have to register them as seen, so we can just fill them with a **1** or any **non-zero** number to make the check easy.)_\\n\\nThen, if we later find an earlier number in the same sequence, we can notice the value stored in **seen** when we link up with an already-visited tail end of the same sequence and just add that value (representing the tail\\'s length) to our **count** of numbers.\\n\\nFor example, consider **nums = [4,5,6,1,2,3,0]**. We start at **4**, then track through **5** and **6**, filling the **seen** indexes corresponding to **5** and **6** with a **1** each (**seen[1] = 1**, **seen[2] = 1**). Once we reach the end of that chain and have a **count** of **3**, we store that **3** in the **seen** index corresponding to **4** (**seen[0] = 3**).\\n\\nThen, because we\\'ve seen **5** and **6** while checking **4**, we skip to **1**. At **1**, we track through **2** and **3**, filling them with **1**s (**seen[4] = 1**, **seen[5] = 1**). After that, we run into **4**, which has a value of **3** stored in **seen**. At this point, **count** is **3** (from numbers **1**, **2**, and **3**), but we\\'ve just run into another already-discovered chain of **3** (numbers **4**, **5**, and **6**), so we can fill the **seen** index corresponding to **1** with a **6** (**seen[3] = 6**).\\n\\nThen we skip past **2** and **3**, and the **0** will lead us back to **1**, so we\\'ll have a result of **7** for the **seen** index corresponding to **0** (**seen[6] = 7**).\\n\\nAt each step, when we\\'re about to store the **count** in **seen**, we can also update our best result so far (**ans**). Then, once we\\'ve reached the end of the iteration, we can just **return ans**.\\n\\n - _**Time Complexity: O(N)** where **N** is the length of **nums**_\\n - _**Space Complexity: O(N)** for **nmap** and **seen**_\\n\\n---\\n\\n#### ***Javascript Code:***\\n```javascript\\nvar longestConsecutive = function(nums) {\\n    let nmap = new Map(), ans = 0,\\n        seen = new Uint32Array(nums.length)\\n    for (let i = 0; i < nums.length; i++)\\n        if (!nmap.has(nums[i])) nmap.set(nums[i], i)\\n    for (let n of nums) {\\n        let curr = n, count = 1\\n        if (seen[nmap.get(curr)]) continue\\n        while (nmap.has(curr+1)) {\\n            let ix = nmap.get(++curr)\\n            if (seen[ix]) {\\n                count += seen[ix]\\n                break\\n            } else seen[ix] = 1, count++\\n        }\\n        seen[nmap.get(n)] = count\\n        ans = Math.max(ans, count)\\n    }\\n    return ans\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n```python\\nclass Solution:\\n    def longestConsecutive(self, nums: List[int]) -> int:\\n        nmap, seen, ans = defaultdict(int), [0] * len(nums), 0\\n        for i in range(len(nums)):\\n            if nums[i] not in nmap: nmap[nums[i]] = i\\n        for n in nums:\\n            curr, count = n, 1\\n            if seen[nmap[n]]: continue\\n            while curr+1 in nmap:\\n                curr += 1\\n                ix = nmap[curr]\\n                if seen[ix]:\\n                    count += seen[ix]\\n                    break\\n                else:\\n                    seen[ix] = 1\\n                    count += 1\\n            seen[nmap[n]], ans = count, max(ans, count)\\n        return ans\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n```java\\nclass Solution {\\n    public int longestConsecutive(int[] nums) {\\n        Map<Integer, Integer> nmap = new HashMap<>();\\n        int ans = 0;\\n        int[] seen = new int[nums.length];\\n        for (int i = 0; i < nums.length; i++)\\n            if (!nmap.containsKey(nums[i])) nmap.put(nums[i], i);\\n        for (int n : nums) {\\n            int curr = n, count = 1;\\n            if (seen[nmap.get(curr)] > 0) continue;\\n            while (nmap.containsKey(curr+1)) {\\n                int ix = nmap.get(++curr);\\n                if (seen[ix] > 0) {\\n                    count += seen[ix];\\n                    break;\\n                } else {\\n                    seen[ix] = 1;\\n                    count++;\\n                }\\n            }\\n            seen[nmap.get(n)] = count;\\n            ans = Math.max(ans, count);\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n```c++\\nclass Solution {\\npublic:\\n    int longestConsecutive(vector<int>& nums) {\\n        unordered_map<int, int> nmap;\\n        int ans = 0;\\n        vector<int> seen(nums.size());\\n        for (int i = 0; i < nums.size(); i++)\\n            if (nmap.find(nums[i]) == nmap.end())\\n                nmap[nums[i]] = i;\\n        for (auto& n : nums) {\\n            int curr = n, count = 1;\\n            if (seen[nmap[curr]]) continue;\\n            while (nmap.find(curr+1) != nmap.end()) {\\n                int ix = nmap[++curr];\\n                if (seen[ix]) {\\n                    count += seen[ix];\\n                    break;\\n                } else seen[ix] = 1, count++;\\n            }\\n            seen[nmap[n]] = count;\\n            ans = max(ans, count);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "JavaScript"
                ],
                "code": "```javascript\\nvar longestConsecutive = function(nums) {\\n    let nmap = new Map(), ans = 0,\\n        seen = new Uint32Array(nums.length)\\n    for (let i = 0; i < nums.length; i++)\\n        if (!nmap.has(nums[i])) nmap.set(nums[i], i)\\n    for (let n of nums) {\\n        let curr = n, count = 1\\n        if (seen[nmap.get(curr)]) continue\\n        while (nmap.has(curr+1)) {\\n            let ix = nmap.get(++curr)\\n            if (seen[ix]) {\\n                count += seen[ix]\\n                break\\n            } else seen[ix] = 1, count++\\n        }\\n        seen[nmap.get(n)] = count\\n        ans = Math.max(ans, count)\\n    }\\n    return ans\\n};\\n```\n```python\\nclass Solution:\\n    def longestConsecutive(self, nums: List[int]) -> int:\\n        nmap, seen, ans = defaultdict(int), [0] * len(nums), 0\\n        for i in range(len(nums)):\\n            if nums[i] not in nmap: nmap[nums[i]] = i\\n        for n in nums:\\n            curr, count = n, 1\\n            if seen[nmap[n]]: continue\\n            while curr+1 in nmap:\\n                curr += 1\\n                ix = nmap[curr]\\n                if seen[ix]:\\n                    count += seen[ix]\\n                    break\\n                else:\\n                    seen[ix] = 1\\n                    count += 1\\n            seen[nmap[n]], ans = count, max(ans, count)\\n        return ans\\n```\n```java\\nclass Solution {\\n    public int longestConsecutive(int[] nums) {\\n        Map<Integer, Integer> nmap = new HashMap<>();\\n        int ans = 0;\\n        int[] seen = new int[nums.length];\\n        for (int i = 0; i < nums.length; i++)\\n            if (!nmap.containsKey(nums[i])) nmap.put(nums[i], i);\\n        for (int n : nums) {\\n            int curr = n, count = 1;\\n            if (seen[nmap.get(curr)] > 0) continue;\\n            while (nmap.containsKey(curr+1)) {\\n                int ix = nmap.get(++curr);\\n                if (seen[ix] > 0) {\\n                    count += seen[ix];\\n                    break;\\n                } else {\\n                    seen[ix] = 1;\\n                    count++;\\n                }\\n            }\\n            seen[nmap.get(n)] = count;\\n            ans = Math.max(ans, count);\\n        }\\n        return ans;\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    int longestConsecutive(vector<int>& nums) {\\n        unordered_map<int, int> nmap;\\n        int ans = 0;\\n        vector<int> seen(nums.size());\\n        for (int i = 0; i < nums.size(); i++)\\n            if (nmap.find(nums[i]) == nmap.end())\\n                nmap[nums[i]] = i;\\n        for (auto& n : nums) {\\n            int curr = n, count = 1;\\n            if (seen[nmap[curr]]) continue;\\n            while (nmap.find(curr+1) != nmap.end()) {\\n                int ix = nmap[++curr];\\n                if (seen[ix]) {\\n                    count += seen[ix];\\n                    break;\\n                } else seen[ix] = 1, count++;\\n            }\\n            seen[nmap[n]] = count;\\n            ans = max(ans, count);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 384942,
                "title": "easy-peasy-python-o-n-comments-set",
                "content": "\\tdef longestConsecutive(self, nums: List[int]) -> int:\\n        # for each num I will check whether num-1 exists\\n        # if yes, then I ignore this num\\n        # Otherwise if num-1 doesn\\'t exist, then I will go till I can find num+1\\n        # so in a way I am only checking each number max once and once in set.\\n        \\n        st = set(nums)    \\n        mx = 0\\n        for num in nums:\\n            if num-1 not in st:\\n                tmp = 1\\n                while num+1 in st:\\n                    tmp += 1\\n                    num += 1\\n                mx = max(mx, tmp)\\n       \\n        return mx",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "\\tdef longestConsecutive(self, nums: List[int]) -> int:\\n        # for each num I will check whether num-1 exists\\n        # if yes, then I ignore this num\\n        # Otherwise if num-1 doesn\\'t exist, then I will go till I can find num+1\\n        # so in a way I am only checking each number max once and once in set.\\n        \\n        st = set(nums)    \\n        mx = 0\\n        for num in nums:\\n            if num-1 not in st:\\n                tmp = 1\\n                while num+1 in st:\\n                    tmp += 1\\n                    num += 1\\n                mx = max(mx, tmp)\\n       \\n        return mx",
                "codeTag": "Python3"
            },
            {
                "id": 41116,
                "title": "c-union-find-amotrized-o-n",
                "content": "    class Solution {\\n        vector<int> id;\\n        vector<int> size;\\n    public:\\n        int longestConsecutive(vector<int>& nums) {\\n            int n = nums.size();\\n            if(n < 2) return n;\\n            size = vector<int>(n,1);\\n            for(int i = 0; i < n; i++) {\\n                id.push_back(i);\\n            }\\n            unordered_map<int,int> record;\\n            for(int i = 0 ; i < n; i++) {\\n                if(record.find(nums[i]) != record.end()) continue;\\n                record[nums[i]] = i;\\n                if(record.find(nums[i]-1) != record.end()) {\\n                    unionSet(i,record[nums[i]-1]);\\n                }\\n                if(record.find(nums[i]+1) != record.end()) {\\n                    unionSet(i,record[nums[i]+1]);\\n                }\\n            }\\n            int res = *max_element(size.begin(),size.end());\\n            return res;\\n        }\\n        \\n        int find(int p) {\\n            while(p != id[p]) {\\n                id[p] = id[id[p]];\\n                p = id[p];\\n            }\\n            return p;\\n        }\\n        void unionSet(int a, int b) {\\n            int i = find(a);\\n            int j = find(b);\\n            if(i == j) return;\\n            if(size[i] > size[j]) {\\n                id[j] = i;\\n                size[i] += size[j];\\n            } else {\\n                id[i] = j;\\n                size[j] += size[i];\\n            }\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n        vector<int> id;\\n        vector<int> size;\\n    public:\\n        int longestConsecutive(vector<int>& nums) {\\n            int n = nums.size();\\n            if(n < 2) return n;\\n            size = vector<int>(n,1);\\n            for(int i = 0; i < n; i++) {\\n                id.push_back(i);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3430669,
                "title": "simple-swift-o-n-solution-easy-to-understand",
                "content": "# Approach\\nTo solve this problem, we can take the following approach:\\n1. Convert the given array into a `set`. This reduces the time complexity of searching for elements in the array from $$O(n)$$ to $$O(1)$$.\\n2. Initialize a variable `longestStreak` to `0`, which will store the length of the longest consecutive sequence that we find.\\n3. Iterate over the elements in the `set`.\\n4. For each element, check if the `set` contains the previous integer `num - 1`. If it does not, then this `num` is the starting point of a consecutive sequence.\\n5. Initialize two variables `currentNum` and `currentStreak` to the value of `num` and `1` respectively. `currentStreak` represents the length of the current consecutive sequence that we are examining.\\n6. While the `set` contains the next integer `currentNum + 1`, increment `currentNum` and `currentStreak`.\\n7. If the `currentStreak` is greater than the `longestStreak`, update the value of `longestStreak` to `currentStreak`.\\n8. Repeat steps 4 to 7 for all elements in the `set`.\\n9. Return the value of `longestStreak`.\\n\\n\\n# Complexity\\nThe *time complexity* of the given solution is $$O(n)$$, where $$n$$ is the number of elements in the input array.\\n\\nThe *space complexity* of the given solution is $$O(n)$$ where $$n$$ is the number of elements in the input array.\\n\\n# Code\\n```\\nclass Solution {\\n    func longestConsecutive(_ nums: [Int]) -> Int {\\n        let set = Set(nums)\\n        var longestStreak = 0\\n\\n        for num in set {\\n            if !set.contains(num - 1) {\\n                var currentNum = num\\n                var currentStreak = 1\\n\\n                while set.contains(currentNum + 1) {\\n                    currentNum += 1\\n                    currentStreak += 1\\n                }\\n\\n                longestStreak = max(longestStreak, currentStreak)\\n            }\\n        }\\n\\n        return longestStreak\\n    }\\n}\\n```\\n\\n# Upvote ^^\\n\\n![upvote.png](https://assets.leetcode.com/users/images/fca8d363-9250-40c9-87e6-b6cde82d5257_1681816250.3088403.png)\\n",
                "solutionTags": [
                    "Swift",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    func longestConsecutive(_ nums: [Int]) -> Int {\\n        let set = Set(nums)\\n        var longestStreak = 0\\n\\n        for num in set {\\n            if !set.contains(num - 1) {\\n                var currentNum = num\\n                var currentStreak = 1\\n\\n                while set.contains(currentNum + 1) {\\n                    currentNum += 1\\n                    currentStreak += 1\\n                }\\n\\n                longestStreak = max(longestStreak, currentStreak)\\n            }\\n        }\\n\\n        return longestStreak\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2239544,
                "title": "java-simple-o-n-solution-using-hashset",
                "content": "```\\nKINDLY PLEASE UPVOTE IF YOU FIND IT HELPFUL \\n```\\n\\n```\\nclass Solution {\\n    public int longestConsecutive(int[] nums) {\\n      Set <Integer> set = new HashSet <Integer>();\\n      for(int n : nums)\\n        set.add(n);\\n      \\n      int streak = 0;\\n      for(int n : nums) {\\n        if(!set.contains(n - 1)) {\\n          int currNum = n;\\n          int currStreak = 1;\\n          \\n          while(set.contains(currNum + 1)) {\\n            currNum ++;\\n            currStreak ++;\\n          }\\n\\t\\t  \\n          streak = Math.max(streak , currStreak);\\n      }\\n    }\\n      return streak;\\n  }\\n}\\n",
                "solutionTags": [
                    "Java",
                    "Ordered Set"
                ],
                "code": "```\\nKINDLY PLEASE UPVOTE IF YOU FIND IT HELPFUL \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 41328,
                "title": "accepted-short-c-solution-80-ms-1-scan-1-hash-map-with-explanation",
                "content": "1 scan solution with hash map\\n\\nExplanation:\\n\\n 1. main idea is using hash map to check previous and next element in the sequence\\n 2. hash map holds length of consecutive sequence for start of sequence and end of sequence\\n 3. we updating that values when joining intervals\\n 4. longest sequence is calculated during joining intervals\\n\\n          \\n        int longestConsecutive(vector<int> &num) {\\n            if ( num.size() < 2 ) return num.size();\\n            unordered_map<int,int> m;\\n            int longest = 1;\\n            for ( int i: num ){\\n                if ( m.find(i) != m.end() ) continue;\\n                m[i] = 1;\\n                if ( m.find(i-1) != m.end() ){\\n                    int len = m[i] + m[i-1];\\n                    m[i] = len;                            // length of sequence\\n                    m[i-len+1] ++;                      // update start of range by new length of sequence\\n                    longest = max( longest, len );\\n                }\\n                if ( m.find(i+1) != m.end() ){\\n                    int len   = m[i+m[i+1]] + m[i];\\n                    int start = i-m[i]+1;\\n                    int end   = i+m[i+1];\\n                    m[start] = len;\\n                    m[end]   = len;\\n                    longest = max( longest, len );\\n                }\\n            }\\n            return longest;\\n       }",
                "solutionTags": [
                    "Hash Table"
                ],
                "code": "1 scan solution with hash map\\n\\nExplanation:\\n\\n 1. main idea is using hash map to check previous and next element in the sequence\\n 2. hash map holds length of consecutive sequence for start of sequence and end of sequence\\n 3. we updating that values when joining intervals\\n 4. longest sequence is calculated during joining intervals\\n\\n          \\n        int longestConsecutive(vector<int> &num) {\\n            if ( num.size() < 2 ) return num.size();\\n            unordered_map<int,int> m;\\n            int longest = 1;\\n            for ( int i: num ){\\n                if ( m.find(i) != m.end() ) continue;\\n                m[i] = 1;\\n                if ( m.find(i-1) != m.end() ){\\n                    int len = m[i] + m[i-1];\\n                    m[i] = len;                            // length of sequence\\n                    m[i-len+1] ++;                      // update start of range by new length of sequence\\n                    longest = max( longest, len );\\n                }\\n                if ( m.find(i+1) != m.end() ){\\n                    int len   = m[i+m[i+1]] + m[i];\\n                    int start = i-m[i]+1;\\n                    int end   = i+m[i+1];\\n                    m[start] = len;\\n                    m[end]   = len;\\n                    longest = max( longest, len );\\n                }\\n            }\\n            return longest;\\n       }",
                "codeTag": "Unknown"
            },
            {
                "id": 3520778,
                "title": "c-java-python-javascript-simple-code-easy-to-understand",
                "content": "# Intuition:\\nThe problem requires finding the length of the longest consecutive sequence of numbers in the given array. We can sort the array and then traverse it to find the longest consecutive sequence.\\n\\n# Approach:\\n1. Sort the given array.\\n2. Initialize two variables: count and temp. count will store the length of the longest consecutive sequence found so far, and temp will store the length of the current consecutive sequence.\\n3. Traverse the sorted array from the first element to the second last element:\\n   - If the current element is one less than the next element, increment temp.\\n   - If the current element is equal to the next element, do nothing.\\n   - If the current element is not one less than the next element, reset temp to 1.\\n   - After each iteration, update count with the maximum value of count and temp.\\n4. Return count.\\n\\n# Complexity\\n- Time complexity: Sorting the array takes O(n log n) time. The for loop takes O(n) time. Therefore, the overall time complexity of the function is O(n log n + n) which simplifies to O(n log n).\\n\\n- Space complexity: We are not using any additional data structure that grows with the size of the input. Therefore, the space complexity of the function is O(1).\\n\\n---\\n# C++\\n```\\nclass Solution {\\npublic:\\n    int longestConsecutive(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int count=0;\\n        int temp=1;\\n        if(nums.size()==0){\\n            return 0;\\n        }\\n        if(nums.size()==1){\\n            return 1;\\n        }\\n        for(int i=0;i<nums.size()-1;i++){\\n            if(nums[i]==(nums[i+1]-1)){\\n                temp++;\\n                count = max(count,temp);\\n            }\\n            else if(nums[i]==(nums[i+1])){\\n                count = max(count,temp);\\n            }\\n            else{\\n                temp=1;\\n                count = max(count,temp);\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```\\n---\\n# Java\\n```\\nclass Solution {\\n    public int longestConsecutive(int[] nums) {\\n        Arrays.sort(nums);\\n        int count = 0;\\n        int temp = 1;\\n        if (nums.length == 0) {\\n            return 0;\\n        }\\n        if (nums.length == 1) {\\n            return 1;\\n        }\\n        for (int i = 0; i < nums.length - 1; i++) {\\n            if (nums[i] == (nums[i + 1] - 1)) {\\n                temp++;\\n                count = Math.max(count, temp);\\n            } else if (nums[i] == (nums[i + 1])) {\\n                count = Math.max(count, temp);\\n            } else {\\n                temp = 1;\\n                count = Math.max(count, temp);\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```\\n---\\n# Python\\n```\\nclass Solution(object):\\n    def longestConsecutive(self, nums):\\n        nums.sort()\\n        count = 0\\n        temp = 1\\n        if len(nums) == 0:\\n            return 0\\n        if len(nums) == 1:\\n            return 1\\n        for i in range(len(nums) - 1):\\n            if nums[i] == (nums[i + 1] - 1):\\n                temp += 1\\n                count = max(count, temp)\\n            elif nums[i] == (nums[i + 1]):\\n                count = max(count, temp)\\n            else:\\n                temp = 1\\n                count = max(count, temp)\\n        return count\\n```\\n---\\n# JavaScript\\n```\\nvar longestConsecutive = function(nums) {\\n    nums.sort((a, b) => a - b);\\n    let count = 0;\\n    let temp = 1;\\n    if (nums.length === 0) {\\n        return 0;\\n    }\\n    if (nums.length === 1) {\\n        return 1;\\n    }\\n    for (let i = 0; i < nums.length - 1; i++) {\\n        if (nums[i] === nums[i + 1] - 1) {\\n            temp++;\\n            count = Math.max(count, temp);\\n        } else if (nums[i] === nums[i + 1]) {\\n            count = Math.max(count, temp);\\n        } else {\\n            temp = 1;\\n            count = Math.max(count, temp);\\n        }\\n    }\\n    return count;\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestConsecutive(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int count=0;\\n        int temp=1;\\n        if(nums.size()==0){\\n            return 0;\\n        }\\n        if(nums.size()==1){\\n            return 1;\\n        }\\n        for(int i=0;i<nums.size()-1;i++){\\n            if(nums[i]==(nums[i+1]-1)){\\n                temp++;\\n                count = max(count,temp);\\n            }\\n            else if(nums[i]==(nums[i+1])){\\n                count = max(count,temp);\\n            }\\n            else{\\n                temp=1;\\n                count = max(count,temp);\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int longestConsecutive(int[] nums) {\\n        Arrays.sort(nums);\\n        int count = 0;\\n        int temp = 1;\\n        if (nums.length == 0) {\\n            return 0;\\n        }\\n        if (nums.length == 1) {\\n            return 1;\\n        }\\n        for (int i = 0; i < nums.length - 1; i++) {\\n            if (nums[i] == (nums[i + 1] - 1)) {\\n                temp++;\\n                count = Math.max(count, temp);\\n            } else if (nums[i] == (nums[i + 1])) {\\n                count = Math.max(count, temp);\\n            } else {\\n                temp = 1;\\n                count = Math.max(count, temp);\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```\n```\\nclass Solution(object):\\n    def longestConsecutive(self, nums):\\n        nums.sort()\\n        count = 0\\n        temp = 1\\n        if len(nums) == 0:\\n            return 0\\n        if len(nums) == 1:\\n            return 1\\n        for i in range(len(nums) - 1):\\n            if nums[i] == (nums[i + 1] - 1):\\n                temp += 1\\n                count = max(count, temp)\\n            elif nums[i] == (nums[i + 1]):\\n                count = max(count, temp)\\n            else:\\n                temp = 1\\n                count = max(count, temp)\\n        return count\\n```\n```\\nvar longestConsecutive = function(nums) {\\n    nums.sort((a, b) => a - b);\\n    let count = 0;\\n    let temp = 1;\\n    if (nums.length === 0) {\\n        return 0;\\n    }\\n    if (nums.length === 1) {\\n        return 1;\\n    }\\n    for (let i = 0; i < nums.length - 1; i++) {\\n        if (nums[i] === nums[i + 1] - 1) {\\n            temp++;\\n            count = Math.max(count, temp);\\n        } else if (nums[i] === nums[i + 1]) {\\n            count = Math.max(count, temp);\\n        } else {\\n            temp = 1;\\n            count = Math.max(count, temp);\\n        }\\n    }\\n    return count;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3200153,
                "title": "128-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nSolution: We can use a hash set to store all the elements in the input array. We can then traverse the input array and for each element check if the element is the start of the sequence. If the element is the start of the sequence, we can keep incrementing the element by 1 and checking if the next element is present in the hash set. We keep incrementing the element until we reach the end of the sequence, and update the length of the longest sequence found so far.\\n\\nAlgorithm:\\n\\n1. Create an empty hash set.\\n2. Add all elements of the input array to the hash set.\\n3. Initialize a variable to store the length of the longest sequence found so far to 0.\\n4. For each element in the input array, do the following:\\na. If the element is the start of the sequence (i.e., the element-1 is not present in the hash set), do the following:\\ni. Initialize a variable to store the length of the current sequence to 1.\\nii. Keep incrementing the element by 1 and checking if the next element is present in the hash set.\\niii. If the next element is present in the hash set, increment the length of the current sequence by 1.\\niv. If the length of the current sequence is greater than the length of the longest sequence found so far, update the length of the longest sequence found so far.\\n5. Return the length of the longest sequence found so far.\\n# Complexity\\n- Time complexity:\\nTime Complexity: O(n) - We traverse the input array once and perform constant time operations for each element.\\n- Space complexity:\\nSpace Complexity: O(n) - We create a hash set to store all the elements in the input array.\\n\\n# Code\\n```\\nclass Solution:\\n    def longestConsecutive(self, nums: List[int]) -> int:\\n        num_set = set(nums)\\n        longest_seq = 0\\n        \\n        for num in num_set:\\n            if num-1 not in num_set:\\n                current_num = num\\n                current_seq = 1\\n                while current_num+1 in num_set:\\n                    current_num += 1\\n                    current_seq += 1\\n                longest_seq = max(longest_seq, current_seq)\\n                \\n        return longest_seq\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Hash Table",
                    "Union Find"
                ],
                "code": "```\\nclass Solution:\\n    def longestConsecutive(self, nums: List[int]) -> int:\\n        num_set = set(nums)\\n        longest_seq = 0\\n        \\n        for num in num_set:\\n            if num-1 not in num_set:\\n                current_num = num\\n                current_seq = 1\\n                while current_num+1 in num_set:\\n                    current_num += 1\\n                    current_seq += 1\\n                longest_seq = max(longest_seq, current_seq)\\n                \\n        return longest_seq\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1254719,
                "title": "longest-consecutive-sequence-js-python-java-c-easy-o-n-map-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nIn order to accomplish this task in **O(N) time**, we\\'ll have to have some way of looking up values (**nmap**), which means a **set** or **map** object. We\\'ll also need some way of keeping track of which numbers have already been **seen**.\\n\\n_(**Note**: We could forego the **seen** data structure entirely and just follow each path to its end every time, but that would cause us to redo the same sections over and over again, pushing the **time complexity** to **O(N^2)**.)_\\n\\nIf we use a set for **nmap**, then we would need to use a map for **seen** in order to be able to look the numbers up by value. If we instead use a map for **nmap**, with each number pointing to its index, then we can instead use those indexes with an **array** for **seen**, which will be more efficient.\\n\\n_(**Note**: Since we\\'ll be iterating through **nums** from front to back in the next section, we should make sure that we store only the first index at which a number is found in **nmap**. Later indexes of duplicate numbers can be ignored, as by then the number will already be considered **seen**.)_\\n\\nBut now we run into the issue of potentially finding the middle of a sequence before we find the beginning of the sequence. For this we can take inspiration from a **union-find** approach and/or **dynamic programming** (**DP**) approach; We can use **seen** to store the length of the sequence found when starting at the given number.\\n\\n_(**Note**: We don\\'t need to store path length data in any but the smallest number of a found chain, as those nodes can never be actively visited again. Only the entry point, which is the smallest number, needs to have the accurate path length stored. For the other numbers, we just have to register them as seen, so we can just fill them with a **1** or any **non-zero** number to make the check easy.)_\\n\\nThen, if we later find an earlier number in the same sequence, we can notice the value stored in **seen** when we link up with an already-visited tail end of the same sequence and just add that value (representing the tail\\'s length) to our **count** of numbers.\\n\\nFor example, consider **nums = [4,5,6,1,2,3,0]**. We start at **4**, then track through **5** and **6**, filling the **seen** indexes corresponding to **5** and **6** with a **1** each (**seen[1] = 1**, **seen[2] = 1**). Once we reach the end of that chain and have a **count** of **3**, we store that **3** in the **seen** index corresponding to **4** (**seen[0] = 3**).\\n\\nThen, because we\\'ve seen **5** and **6** while checking **4**, we skip to **1**. At **1**, we track through **2** and **3**, filling them with **1**s (**seen[4] = 1**, **seen[5] = 1**). After that, we run into **4**, which has a value of **3** stored in **seen**. At this point, **count** is **3** (from numbers **1**, **2**, and **3**), but we\\'ve just run into another already-discovered chain of **3** (numbers **4**, **5**, and **6**), so we can fill the **seen** index corresponding to **1** with a **6** (**seen[3] = 6**).\\n\\nThen we skip past **2** and **3**, and the **0** will lead us back to **1**, so we\\'ll have a result of **7** for the **seen** index corresponding to **0** (**seen[6] = 7**).\\n\\nAt each step, when we\\'re about to store the **count** in **seen**, we can also update our best result so far (**ans**). Then, once we\\'ve reached the end of the iteration, we can just **return ans**.\\n\\n - _**Time Complexity: O(N)** where **N** is the length of **nums**_\\n - _**Space Complexity: O(N)** for **nmap** and **seen**_\\n\\n---\\n\\n#### ***Javascript Code:***\\n```javascript\\nvar longestConsecutive = function(nums) {\\n    let nmap = new Map(), ans = 0,\\n        seen = new Uint32Array(nums.length)\\n    for (let i = 0; i < nums.length; i++)\\n        if (!nmap.has(nums[i])) nmap.set(nums[i], i)\\n    for (let n of nums) {\\n        let curr = n, count = 1\\n        if (seen[nmap.get(curr)]) continue\\n        while (nmap.has(curr+1)) {\\n            let ix = nmap.get(++curr)\\n            if (seen[ix]) {\\n                count += seen[ix]\\n                break\\n            } else seen[ix] = 1, count++\\n        }\\n        seen[nmap.get(n)] = count\\n        ans = Math.max(ans, count)\\n    }\\n    return ans\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n```python\\nclass Solution:\\n    def longestConsecutive(self, nums: List[int]) -> int:\\n        nmap, seen, ans = defaultdict(int), [0] * len(nums), 0\\n        for i in range(len(nums)):\\n            if nums[i] not in nmap: nmap[nums[i]] = i\\n        for n in nums:\\n            curr, count = n, 1\\n            if seen[nmap[n]]: continue\\n            while curr+1 in nmap:\\n                curr += 1\\n                ix = nmap[curr]\\n                if seen[ix]:\\n                    count += seen[ix]\\n                    break\\n                else:\\n                    seen[ix] = 1\\n                    count += 1\\n            seen[nmap[n]], ans = count, max(ans, count)\\n        return ans\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n```java\\nclass Solution {\\n    public int longestConsecutive(int[] nums) {\\n        Map<Integer, Integer> nmap = new HashMap<>();\\n        int ans = 0;\\n        int[] seen = new int[nums.length];\\n        for (int i = 0; i < nums.length; i++)\\n            if (!nmap.containsKey(nums[i])) nmap.put(nums[i], i);\\n        for (int n : nums) {\\n            int curr = n, count = 1;\\n            if (seen[nmap.get(curr)] > 0) continue;\\n            while (nmap.containsKey(curr+1)) {\\n                int ix = nmap.get(++curr);\\n                if (seen[ix] > 0) {\\n                    count += seen[ix];\\n                    break;\\n                } else {\\n                    seen[ix] = 1;\\n                    count++;\\n                }\\n            }\\n            seen[nmap.get(n)] = count;\\n            ans = Math.max(ans, count);\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n```c++\\nclass Solution {\\npublic:\\n    int longestConsecutive(vector<int>& nums) {\\n        unordered_map<int, int> nmap;\\n        int ans = 0;\\n        vector<int> seen(nums.size());\\n        for (int i = 0; i < nums.size(); i++)\\n            if (nmap.find(nums[i]) == nmap.end())\\n                nmap[nums[i]] = i;\\n        for (auto& n : nums) {\\n            int curr = n, count = 1;\\n            if (seen[nmap[curr]]) continue;\\n            while (nmap.find(curr+1) != nmap.end()) {\\n                int ix = nmap[++curr];\\n                if (seen[ix]) {\\n                    count += seen[ix];\\n                    break;\\n                } else seen[ix] = 1, count++;\\n            }\\n            seen[nmap[n]] = count;\\n            ans = max(ans, count);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\nvar longestConsecutive = function(nums) {\\n    let nmap = new Map(), ans = 0,\\n        seen = new Uint32Array(nums.length)\\n    for (let i = 0; i < nums.length; i++)\\n        if (!nmap.has(nums[i])) nmap.set(nums[i], i)\\n    for (let n of nums) {\\n        let curr = n, count = 1\\n        if (seen[nmap.get(curr)]) continue\\n        while (nmap.has(curr+1)) {\\n            let ix = nmap.get(++curr)\\n            if (seen[ix]) {\\n                count += seen[ix]\\n                break\\n            } else seen[ix] = 1, count++\\n        }\\n        seen[nmap.get(n)] = count\\n        ans = Math.max(ans, count)\\n    }\\n    return ans\\n};\\n```\n```python\\nclass Solution:\\n    def longestConsecutive(self, nums: List[int]) -> int:\\n        nmap, seen, ans = defaultdict(int), [0] * len(nums), 0\\n        for i in range(len(nums)):\\n            if nums[i] not in nmap: nmap[nums[i]] = i\\n        for n in nums:\\n            curr, count = n, 1\\n            if seen[nmap[n]]: continue\\n            while curr+1 in nmap:\\n                curr += 1\\n                ix = nmap[curr]\\n                if seen[ix]:\\n                    count += seen[ix]\\n                    break\\n                else:\\n                    seen[ix] = 1\\n                    count += 1\\n            seen[nmap[n]], ans = count, max(ans, count)\\n        return ans\\n```\n```java\\nclass Solution {\\n    public int longestConsecutive(int[] nums) {\\n        Map<Integer, Integer> nmap = new HashMap<>();\\n        int ans = 0;\\n        int[] seen = new int[nums.length];\\n        for (int i = 0; i < nums.length; i++)\\n            if (!nmap.containsKey(nums[i])) nmap.put(nums[i], i);\\n        for (int n : nums) {\\n            int curr = n, count = 1;\\n            if (seen[nmap.get(curr)] > 0) continue;\\n            while (nmap.containsKey(curr+1)) {\\n                int ix = nmap.get(++curr);\\n                if (seen[ix] > 0) {\\n                    count += seen[ix];\\n                    break;\\n                } else {\\n                    seen[ix] = 1;\\n                    count++;\\n                }\\n            }\\n            seen[nmap.get(n)] = count;\\n            ans = Math.max(ans, count);\\n        }\\n        return ans;\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    int longestConsecutive(vector<int>& nums) {\\n        unordered_map<int, int> nmap;\\n        int ans = 0;\\n        vector<int> seen(nums.size());\\n        for (int i = 0; i < nums.size(); i++)\\n            if (nmap.find(nums[i]) == nmap.end())\\n                nmap[nums[i]] = i;\\n        for (auto& n : nums) {\\n            int curr = n, count = 1;\\n            if (seen[nmap[curr]]) continue;\\n            while (nmap.find(curr+1) != nmap.end()) {\\n                int ix = nmap[++curr];\\n                if (seen[ix]) {\\n                    count += seen[ix];\\n                    break;\\n                } else seen[ix] = 1, count++;\\n            }\\n            seen[nmap[n]] = count;\\n            ans = max(ans, count);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 474127,
                "title": "union-find-solution-python",
                "content": "```python\\nclass Solution:\\n    \\n    def longestConsecutive(self, nums: List[int]) -> int:\\n        \\n        if not nums:\\n            return 0\\n        \\n        # remove the duplicate if any\\n        nums = set(nums)\\n        \\n        group, size = {}, {}\\n        \\n        for n in nums:\\n            group[n] = n\\n            size[n] = 1\\n            \\n        def find(a):\\n            if group[a] != a:\\n                group[a] = find(group[a])\\n            return group[a]\\n            \\n        def union(a, b):\\n            ra, rb = find(a), find(b)\\n            if ra != rb:\\n                group[rb] = ra\\n                size[ra] += size[rb]\\n        \\n        for n in nums:\\n            if n - 1 in nums:\\n                union(n, n-1)\\n            if n + 1 in nums:\\n                union(n, n+1)\\n        \\n        return max(size.values())\\n        \\n        \\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    \\n    def longestConsecutive(self, nums: List[int]) -> int:\\n        \\n        if not nums:\\n            return 0\\n        \\n        # remove the duplicate if any\\n        nums = set(nums)\\n        \\n        group, size = {}, {}\\n        \\n        for n in nums:\\n            group[n] = n\\n            size[n] = 1\\n            \\n        def find(a):\\n            if group[a] != a:\\n                group[a] = find(group[a])\\n            return group[a]\\n            \\n        def union(a, b):\\n            ra, rb = find(a), find(b)\\n            if ra != rb:\\n                group[rb] = ra\\n                size[ra] += size[rb]\\n        \\n        for n in nums:\\n            if n - 1 in nums:\\n                union(n, n-1)\\n            if n + 1 in nums:\\n                union(n, n+1)\\n        \\n        return max(size.values())\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 41217,
                "title": "9loc-java-o-n-solution",
                "content": "    <pre>\\n    public class Solution { <br/>\\n        public int longestConsecutive(int[] nums) {<br/>\\n          Set<Integer> set = new HashSet<>();\\n          int max = 0;\\n          for(int num : nums) set.add(num);\\n          for(int num : nums) if (!set.contains(num-1)) {\\n            int val = num;\\n            while(set.remove(val++));\\n            max = Math.max(max, val-num-1);\\n          }\\n          return max;\\n        }\\n    }\\n    </pre>",
                "solutionTags": [],
                "code": "class Solution { <br/>\\n        public int longestConsecutive(int[] nums) {<br/>\\n          Set<Integer> set = new HashSet<>();\\n          int max = 0;\\n          for(int num : nums) set.add(num);\\n          for(int num : nums) if (!set.contains(num-1)) {\\n            int val = num;\\n            while(set.remove(val++));\\n            max = Math.max(max, val-num-1);\\n          }",
                "codeTag": "Java"
            },
            {
                "id": 2779785,
                "title": "c-solutions",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestConsecutive(vector<int>& nums) {\\n        unordered_set<int> s(nums.begin(),nums.end()); // this is faster\\n        \\n        // for(int i = 0; i<nums.size(); i++)\\n        // {\\n        //     s.insert(nums[i]);\\n        // }\\n        \\n        int longest_sequence = 0;\\n        \\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            if(s.find(nums[i] - 1)!=s.end())\\n                continue;\\n            \\n            else\\n            {\\n                int count = 0;\\n                int current_element = nums[i];\\n                \\n                while(s.find(current_element) != s.end())\\n                {\\n                    count++;\\n                    current_element++;\\n                }\\n                \\n                longest_sequence = max(longest_sequence,count);\\n            }\\n        }\\n        \\n        return longest_sequence;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestConsecutive(vector<int>& nums) {\\n        unordered_set<int> s(nums.begin(),nums.end()); // this is faster\\n        \\n        // for(int i = 0; i<nums.size(); i++)\\n        // {\\n        //     s.insert(nums[i]);\\n        // }\\n        \\n        int longest_sequence = 0;\\n        \\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            if(s.find(nums[i] - 1)!=s.end())\\n                continue;\\n            \\n            else\\n            {\\n                int count = 0;\\n                int current_element = nums[i];\\n                \\n                while(s.find(current_element) != s.end())\\n                {\\n                    count++;\\n                    current_element++;\\n                }\\n                \\n                longest_sequence = max(longest_sequence,count);\\n            }\\n        }\\n        \\n        return longest_sequence;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1703489,
                "title": "javascript",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar longestConsecutive = function(nums) {\\n    let set = new Set();\\n    for(const n of nums) {\\n        set.add(n);\\n    }\\n    let max = 0;\\n    for(let n of set) {\\n        if(!set.has(n-1)) {\\n            let count = 0;\\n            while(set.has(n++)) {\\n                count++;\\n            }\\n            max = Math.max(count, max);\\n        }\\n    }\\n    return max;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Ordered Set"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar longestConsecutive = function(nums) {\\n    let set = new Set();\\n    for(const n of nums) {\\n        set.add(n);\\n    }\\n    let max = 0;\\n    for(let n of set) {\\n        if(!set.has(n-1)) {\\n            let count = 0;\\n            while(set.has(n++)) {\\n                count++;\\n            }\\n            max = Math.max(count, max);\\n        }\\n    }\\n    return max;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 883430,
                "title": "c-o-n-solution",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    int longestConsecutive(vector<int> &nums)\\n    {\\n        unordered_set<int> num_set;\\n        int max_count = 0, count = 0;\\n\\n        for (auto n : nums) {\\n            num_set.insert(n);\\n        }\\n\\n        for (auto n : num_set) {\\n            if (!num_set.count(n - 1)) {\\n                count = 0;\\n                while (num_set.count(n)) {\\n                    count++;\\n                    n = n + 1;\\n                }\\n                max_count = max(count, max_count);\\n            }\\n        }\\n        return max_count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    int longestConsecutive(vector<int> &nums)\\n    {\\n        unordered_set<int> num_set;\\n        int max_count = 0, count = 0;\\n\\n        for (auto n : nums) {\\n            num_set.insert(n);\\n        }\\n\\n        for (auto n : num_set) {\\n            if (!num_set.count(n - 1)) {\\n                count = 0;\\n                while (num_set.count(n)) {\\n                    count++;\\n                    n = n + 1;\\n                }\\n                max_count = max(count, max_count);\\n            }\\n        }\\n        return max_count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1935357,
                "title": "100-fastest-swift-solution",
                "content": "```\\nclass Solution {\\n    func longestConsecutive(_ nums: [Int]) -> Int {\\n        var map: [Int: (Int,Int)] = [:]\\n        var max = 0\\n        \\n        for num in nums {\\n            if map[num] == nil {\\n                let left = map[num - 1]\\n                let right = map[num + 1]\\n                \\n                if let left = left, let right = right {\\n                    map[num] = (left.0 + 1, right.1 + 1)\\n                \\n                } else if let left = left {\\n                    map[num] = (left.0 + 1, 0)\\n                \\n                } else if let right = right {\\n                    map[num] = (0, right.1 + 1)\\n                \\n                } else {\\n                    map[num] = (0, 0)\\n                }\\n                \\n                let lower = num - map[num]!.0\\n                let upper = num + map[num]!.1\\n                map[lower] = (0, upper - lower)\\n                map[upper] = (upper - lower, 0)\\n                let count = upper - lower + 1\\n                max = max > count ? max : count\\n            }\\n        }\\n        \\n        return max\\n    }\\n    \\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func longestConsecutive(_ nums: [Int]) -> Int {\\n        var map: [Int: (Int,Int)] = [:]\\n        var max = 0\\n        \\n        for num in nums {\\n            if map[num] == nil {\\n                let left = map[num - 1]\\n                let right = map[num + 1]\\n                \\n                if let left = left, let right = right {\\n                    map[num] = (left.0 + 1, right.1 + 1)\\n                \\n                } else if let left = left {\\n                    map[num] = (left.0 + 1, 0)\\n                \\n                } else if let right = right {\\n                    map[num] = (0, right.1 + 1)\\n                \\n                } else {\\n                    map[num] = (0, 0)\\n                }\\n                \\n                let lower = num - map[num]!.0\\n                let upper = num + map[num]!.1\\n                map[lower] = (0, upper - lower)\\n                map[upper] = (upper - lower, 0)\\n                let count = upper - lower + 1\\n                max = max > count ? max : count\\n            }\\n        }\\n        \\n        return max\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 41314,
                "title": "remove-number-from-set-consecutively-a-dry-python-code",
                "content": "    class Solution:\\n    # @param num, a list of integer\\n    # @return an integer\\n    def longestConsecutive(self, num):\\n        numbers = set(num)\\n        max_len = 0\\n        while numbers:\\n            m = n = numbers.pop()\\n            length = 1\\n            while m-1 in numbers:\\n                numbers.remove(m-1)\\n                m -= 1\\n                length += 1\\n            while n+1 in numbers:\\n                numbers.remove(n+1)\\n                n += 1\\n                length += 1\\n            max_len = max(max_len, length)\\n        return max_len\\n\\nkeep trace of the max_len",
                "solutionTags": [],
                "code": "    class Solution:\\n    # @param num, a list of integer\\n    # @return an integer\\n    def longestConsecutive(self, num):\\n        numbers = set(num)\\n        max_len = 0\\n        while numbers:\\n            m = n = numbers.pop()\\n            length = 1\\n            while m-1 in numbers:\\n                numbers.remove(m-1)\\n                m -= 1\\n                length += 1\\n            while n+1 in numbers:\\n                numbers.remove(n+1)\\n                n += 1\\n                length += 1\\n            max_len = max(max_len, length)\\n        return max_len\\n\\nkeep trace of the max_len",
                "codeTag": "Java"
            },
            {
                "id": 2925307,
                "title": "python3-o-n-union-find-disjoint-set-full-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo find longest consecutive sequence, for every integer num, we need to look for num - 1 and num + 1. One of the ways of doing this is to use Union Find (or Disjoint Set) Data Structure.\\n\\nWe use this to combine all the consecutive elements and get the largest set.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialize a union-find data structure with each element in the input vector as a separate disjoint set.\\n\\n2. Iterate through the elements in the input vector. For each element, check if the element before and after it (in consecutive order) exist in the union-find data structure. If they do, use the union function to merge their sets.\\n\\n3. After all elements have been processed, iterate through the sets in the union-find data structure and find the set with the largest size. The size of this set is the length of the longest consecutive sequence.\\n\\n\\n# Complexity\\n- Time complexity: O(n * \\u03B1(n)) [where \\u03B1(n) is the inverse Ackermann function]\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass UnionFind:\\n    def __init__(self, size: int) -> None:\\n        # Initially, all the elements will have themselves as the parent\\n        self.parent = [i for i in range(size)]\\n        # Which also means that their size will be 1\\n        self.size = [1 for _ in range(size)]\\n\\n    def find(self, x: int) -> int:\\n        # If the parent of the x is not itself, recursively find the parent\\n        # And apply path compression by assigning the root as the parent\\n        if self.parent[x] != x:\\n            self.parent[x] = self.find(self.parent[x])\\n        return self.parent[x]\\n\\n    def union(self, x: int, y: int) -> None:\\n        # Find the roots of x and y\\n        x_root = self.find(x)\\n        y_root = self.find(y)\\n\\n        # If they both do not belong to the same set\\n        if x_root != y_root:\\n            # Check which one is smaller\\n            # Smaller one should have the bigger one as parent\\n            if self.size[x_root] < self.size[y_root]:\\n                # x now has y as parent and y\\'s size has increased by the size of x\\n                self.parent[x_root] = y_root\\n                self.size[y_root] += self.size[x_root]\\n            else:\\n                self.parent[y_root] = x_root\\n                self.size[x_root] += self.size[y_root]\\n\\nclass Solution:\\n    def longestConsecutive(self, nums: List[int]) -> int:\\n        # Initialize UnionFind data structure for nums\\n        uf = UnionFind(len(nums))\\n        \\n        # Initialize a dictionary to store the indices of all integers\\n        index = dict()\\n\\n        for i, num in enumerate(nums):\\n            # Ignore duplicates\\n            if num in index:\\n                continue\\n\\n            index[num] = i\\n\\n            # Perform union with num - 1 and num + 1, if seen\\n            if num - 1 in index:\\n                uf.union(i, index[num - 1])\\n            if num + 1 in index:\\n                uf.union(i, index[num + 1])\\n\\n        # Find the largest set (include [0] in case the input has no elements)\\n        return max(uf.size + [0])\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Hash Table",
                    "Union Find"
                ],
                "code": "```\\nclass UnionFind:\\n    def __init__(self, size: int) -> None:\\n        # Initially, all the elements will have themselves as the parent\\n        self.parent = [i for i in range(size)]\\n        # Which also means that their size will be 1\\n        self.size = [1 for _ in range(size)]\\n\\n    def find(self, x: int) -> int:\\n        # If the parent of the x is not itself, recursively find the parent\\n        # And apply path compression by assigning the root as the parent\\n        if self.parent[x] != x:\\n            self.parent[x] = self.find(self.parent[x])\\n        return self.parent[x]\\n\\n    def union(self, x: int, y: int) -> None:\\n        # Find the roots of x and y\\n        x_root = self.find(x)\\n        y_root = self.find(y)\\n\\n        # If they both do not belong to the same set\\n        if x_root != y_root:\\n            # Check which one is smaller\\n            # Smaller one should have the bigger one as parent\\n            if self.size[x_root] < self.size[y_root]:\\n                # x now has y as parent and y\\'s size has increased by the size of x\\n                self.parent[x_root] = y_root\\n                self.size[y_root] += self.size[x_root]\\n            else:\\n                self.parent[y_root] = x_root\\n                self.size[x_root] += self.size[y_root]\\n\\nclass Solution:\\n    def longestConsecutive(self, nums: List[int]) -> int:\\n        # Initialize UnionFind data structure for nums\\n        uf = UnionFind(len(nums))\\n        \\n        # Initialize a dictionary to store the indices of all integers\\n        index = dict()\\n\\n        for i, num in enumerate(nums):\\n            # Ignore duplicates\\n            if num in index:\\n                continue\\n\\n            index[num] = i\\n\\n            # Perform union with num - 1 and num + 1, if seen\\n            if num - 1 in index:\\n                uf.union(i, index[num - 1])\\n            if num + 1 in index:\\n                uf.union(i, index[num + 1])\\n\\n        # Find the largest set (include [0] in case the input has no elements)\\n        return max(uf.size + [0])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1199570,
                "title": "rust-simple-fast-hashset-o-n",
                "content": "```\\nuse std::collections::HashSet;\\n\\nimpl Solution {\\n    pub fn longest_consecutive(nums: Vec<i32>) -> i32 {\\n        let num_set: HashSet<_> = nums.into_iter().collect();\\n        let mut ans = 0;\\n        for &num in &num_set {\\n            if !num_set.contains(&(num - 1)) {\\n                let count = (num..).take_while(|x| num_set.contains(x)).count();\\n                ans = ans.max(count);\\n            }\\n        }\\n        ans as i32\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::collections::HashSet;\\n\\nimpl Solution {\\n    pub fn longest_consecutive(nums: Vec<i32>) -> i32 {\\n        let num_set: HashSet<_> = nums.into_iter().collect();\\n        let mut ans = 0;\\n        for &num in &num_set {\\n            if !num_set.contains(&(num - 1)) {\\n                let count = (num..).take_while(|x| num_set.contains(x)).count();\\n                ans = ans.max(count);\\n            }\\n        }\\n        ans as i32\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 41212,
                "title": "python-solution-in-hashmap-with-explanation",
                "content": "    class Solution(object):\\n        def longestConsecutive(self, nums):\\n            \"\"\"\\n            :type nums: List[int]\\n            :rtype: int\\n            \"\"\"\\n            unions = {};\\n            maxlen = 0;\\n            for n in nums:\\n                if unions.has_key(n): # duplicate n, skip\\n                    continue;\\n                start = end = n;\\n                if unions.has_key(n+1): # update end if has bigger neighbouring section\\n                    end = unions[n+1][1];\\n                if unions.has_key(n-1): # update start if has smaller neighbouring section\\n                    start = unions[n-1][0];\\n                unions[start] = unions[end] = unions[n]=(start,end);\\n                maxlen = max(end-start+1, maxlen);\\n            return maxlen;\\n\\nEach section marks its start and end. \\nGiven n, get its neighbouring sections (n == section.max+1 or n == section.min-1) in Hashmap in O(1) and meanwhile update their start and end.\\nFinally return the max length of sections;",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution(object):\\n        def longestConsecutive(self, nums):\\n            \"\"\"\\n            :type nums: List[int]\\n            :rtype: int\\n            \"\"\"\\n            unions = {}",
                "codeTag": "Java"
            },
            {
                "id": 41232,
                "title": "normally-the-best-time-cost-is-20ms-in-c-enclosed-with-two-different-solutions",
                "content": "    class Solution\\n    {\\n        public:\\n            //AC - 24ms - bottom-up method;\\n            int longestConsecutive(vector<int>& nums) \\n            {\\n                int maxCount = 0, lCount = 0, rCount = 0;\\n                unordered_map<int, int> count_map;\\n                for(int i = 0; i < nums.size(); ++i)\\n                {\\n                    if(!count_map[nums[i]])\\n                    {\\n                        int lCount = count_map[nums[i]-1];\\n                        int rCount = count_map[nums[i]+1];\\n                        int sum = lCount+rCount+1;\\n                        count_map[nums[i]] = count_map[nums[i]-lCount] = count_map[nums[i]+rCount] = sum;\\n                        maxCount = max(maxCount, sum);\\n                    }\\n                }\\n                return maxCount;\\n            }\\n    \\n            //AC - 20ms - blood spreading into two directions;\\n            int longestConsecutive(vector<int>& nums)\\n            {\\n                unordered_set<int> set(nums.begin(), nums.end());\\n                int ret = 1;\\n                for(auto &n: nums)\\n                {\\n                    if(!set.count(n)) continue;\\n                    set.erase(n);\\n                    int pre=n-1, next=n+1;\\n                    while(set.count(pre)) set.erase(pre--);\\n                    while(set.count(next)) set.erase(next++);\\n                    ret = max(ret, next-pre-1);\\n                }\\n                return ret;\\n            }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution\\n    {\\n        public:\\n            //AC - 24ms - bottom-up method;\\n            int longestConsecutive(vector<int>& nums) \\n            {\\n                int maxCount = 0, lCount = 0, rCount = 0;\\n                unordered_map<int, int> count_map;\\n                for(int i = 0; i < nums.size(); ++i)\\n                {\\n                    if(!count_map[nums[i]])\\n                    {\\n                        int lCount = count_map[nums[i]-1];\\n                        int rCount = count_map[nums[i]+1];\\n                        int sum = lCount+rCount+1;\\n                        count_map[nums[i]] = count_map[nums[i]-lCount] = count_map[nums[i]+rCount] = sum;\\n                        maxCount = max(maxCount, sum);\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 4081863,
                "title": "simple-java-solutions-with-explanation",
                "content": "# Algorithm:\\n1. Create an empty hash.\\n2. Insert all array elements to hash.\\n3. Do following for every element arr[i]\\n4. Check if this element is the starting point of a subsequence. To check this, simply look for arr[i]\\n1 in the hash, if not found, then this is the first element a subsequence.\\n5. If this element is the first element, then count the number of elements in the consecutive starting\\nwith this element. Iterate from arr[i] + 1 till the last element that can be found.\\n6. If the count is more than the previous longest subsequence found, then update this.\\n\\n# Code\\n```\\nclass Solution {\\n    public int longestConsecutive(int[] nums) {\\n        if (nums.length == 0) return 0;\\n        HashSet<Integer> set = new HashSet<>();\\n        for (int n : nums){\\n            set.add(n);\\n         }\\n\\n        int count = 1;\\n\\n        for (int num : nums) {\\n            if (!set.contains(num - 1)) {\\n                int tempCount = 1;\\n                while (set.contains(num + 1)) {\\n                    tempCount++;\\n                    num++;\\n                }\\n                count = Math.max(count, tempCount);\\n            }\\n\\n            if (count > nums.length / 2) break;\\n        }\\n\\n        return count;\\n    }\\n\\n}\\n```\\n\\n![abcd1.jpeg](https://assets.leetcode.com/users/images/ddabacf2-a0d6-4416-bb2f-ed36cae3d741_1695494595.861337.jpeg)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int longestConsecutive(int[] nums) {\\n        if (nums.length == 0) return 0;\\n        HashSet<Integer> set = new HashSet<>();\\n        for (int n : nums){\\n            set.add(n);\\n         }\\n\\n        int count = 1;\\n\\n        for (int num : nums) {\\n            if (!set.contains(num - 1)) {\\n                int tempCount = 1;\\n                while (set.contains(num + 1)) {\\n                    tempCount++;\\n                    num++;\\n                }\\n                count = Math.max(count, tempCount);\\n            }\\n\\n            if (count > nums.length / 2) break;\\n        }\\n\\n        return count;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2238767,
                "title": "c-python-easy-to-understand-using-hasmap",
                "content": "Though all solutions here are fundamentally the same, I am using a few tricks to make the code faster and cleaner.\\n\\n* The hash-set S contains the numbers we haven\\'t visited yet.\\n* The main loop continues until the set is no longer large enough to make a difference.\\n* We immediately start walking in both directions when we find any number.\\n* We erase all visited numbers from the set as we go.\\n* We use some nice C++ idioms, like the range constructor and the erase method that returns a value.\\n\\n**Time Complexity :**` O(N)`\\n**Space Complexity :** `O(N)`\\n\\n**\\u2714\\uFE0F C++ Solution**\\n\\n```\\nclass Solution {\\npublic:\\n    int longestConsecutive(vector<int>& nums) {\\n        unordered_set<int> record(nums.begin(), nums.end());\\n        int ans=0;\\n        for(int it: nums){\\n            if(record.find(it)==record.end())   continue;\\n            int prev = it-1, next = it+1;\\n            while(record.find(prev)!=record.end()) prev--;               // walk left on the number line, erasing numbers as you go,\\n            while(record.find(next)!=record.end()) next++;              // walk right on the number line, erasing numbers as you go,\\n            ans = max(ans, next-prev-1);                    // and consider the length of the resulting sequence.\\n            record.erase(it);    //must do other wise you got tle\\n        }\\n        return ans;\\n\\t\\t//upvote if you like\\n    }\\n};\\n```\\n\\n**\\u2714\\uFE0F Python Solution**\\n```\\nclass Solution:\\n    def longestConsecutive(self, nums: List[int]) -> int:\\n        max_len = 0\\n        num_set = set(nums)\\n        for num in nums:\\n            if num - 1 not in num_set:\\n                curr_num = num\\n                curr_len = 1\\n                while curr_num + 1 in num_set:\\n                    curr_num += 1\\n                    curr_len += 1\\n                max_len = max(max_len, curr_len)\\n        return max_len\\n```",
                "solutionTags": [
                    "C",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestConsecutive(vector<int>& nums) {\\n        unordered_set<int> record(nums.begin(), nums.end());\\n        int ans=0;\\n        for(int it: nums){\\n            if(record.find(it)==record.end())   continue;\\n            int prev = it-1, next = it+1;\\n            while(record.find(prev)!=record.end()) prev--;               // walk left on the number line, erasing numbers as you go,\\n            while(record.find(next)!=record.end()) next++;              // walk right on the number line, erasing numbers as you go,\\n            ans = max(ans, next-prev-1);                    // and consider the length of the resulting sequence.\\n            record.erase(it);    //must do other wise you got tle\\n        }\\n        return ans;\\n\\t\\t//upvote if you like\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def longestConsecutive(self, nums: List[int]) -> int:\\n        max_len = 0\\n        num_set = set(nums)\\n        for num in nums:\\n            if num - 1 not in num_set:\\n                curr_num = num\\n                curr_len = 1\\n                while curr_num + 1 in num_set:\\n                    curr_num += 1\\n                    curr_len += 1\\n                max_len = max(max_len, curr_len)\\n        return max_len\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1409105,
                "title": "simple-c-solution-using-two-different-approaches",
                "content": "**If you really found my solution helpful please upvote it, as it motivates me to post such kind of codes and help the coding community, if you have some queries or some improvements please feel free to comment and share your views.**\\n\\n```\\n//1st Approach\\n    int longestConsecutive(vector<int>& nums) {\\n        if(nums.size()==0)\\n            return 0;\\n        sort(nums.begin(),nums.end());\\n        int len=1;\\n        int mx=1;\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            if(nums[i-1]+1==nums[i])\\n            {\\n                len++;\\n                mx=max(len,mx);\\n            }\\n            else if(nums[i-1]==nums[i])\\n                continue;\\n            else\\n                len=1;\\n        }\\n        return mx;\\n    }\\n\\n//TC: O(nlogn)\\n//SC: O(1)\\n\\n//2nd Approach\\n int longestConsecutive(vector<int>& nums) {\\n        if(nums.size()==0)\\n            return 0;\\n       unordered_set<int> s;\\n        for(int i=0;i<nums.size();i++)\\n            s.insert(nums[i]);\\n        int mx=1;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(s.find(nums[i]-1)==s.end())\\n            {\\n                int len=1;\\n                int curr=nums[i];\\n                while(s.find(curr+1)!=s.end())\\n                {\\n                    curr=curr+1;\\n                    len++;\\n                }\\n                mx=max(mx,len);\\n            }\\n        }\\n        return mx;\\n    }\\n\\n//TC: O(3n)\\n//SC: O(n)\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n//1st Approach\\n    int longestConsecutive(vector<int>& nums) {\\n        if(nums.size()==0)\\n            return 0;\\n        sort(nums.begin(),nums.end());\\n        int len=1;\\n        int mx=1;\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            if(nums[i-1]+1==nums[i])\\n            {\\n                len++;\\n                mx=max(len,mx);\\n            }\\n            else if(nums[i-1]==nums[i])\\n                continue;\\n            else\\n                len=1;\\n        }\\n        return mx;\\n    }\\n\\n//TC: O(nlogn)\\n//SC: O(1)\\n\\n//2nd Approach\\n int longestConsecutive(vector<int>& nums) {\\n        if(nums.size()==0)\\n            return 0;\\n       unordered_set<int> s;\\n        for(int i=0;i<nums.size();i++)\\n            s.insert(nums[i]);\\n        int mx=1;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(s.find(nums[i]-1)==s.end())\\n            {\\n                int len=1;\\n                int curr=nums[i];\\n                while(s.find(curr+1)!=s.end())\\n                {\\n                    curr=curr+1;\\n                    len++;\\n                }\\n                mx=max(mx,len);\\n            }\\n        }\\n        return mx;\\n    }\\n\\n//TC: O(3n)\\n//SC: O(n)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 41147,
                "title": "python-with-set-o-n",
                "content": "Set is implemented with the hashing mechanism in Python. So the complexity is O(N)\\n\\n    class Solution(object):\\n        def longestConsecutive(self, nums):\\n            \"\"\"\\n            :type nums: List[int]\\n            :rtype: int\\n            \"\"\"\\n            h = set()\\n            for n in nums:\\n                h.add(n)\\n            ans = 0\\n            while h:\\n                x = h.pop()\\n                count = 1\\n                a, b = x-1, x+1\\n                while a in h:\\n                    count += 1\\n                    h.remove(a)\\n                    a -= 1\\n                while b in h:\\n                    count += 1\\n                    h.remove(b)\\n                    b += 1\\n                ans = max(ans, count)\\n            return ans",
                "solutionTags": [],
                "code": "Set is implemented with the hashing mechanism in Python. So the complexity is O(N)\\n\\n    class Solution(object):\\n        def longestConsecutive(self, nums):\\n            \"\"\"\\n            :type nums: List[int]\\n            :rtype: int\\n            \"\"\"\\n            h = set()\\n            for n in nums:\\n                h.add(n)\\n            ans = 0\\n            while h:\\n                x = h.pop()\\n                count = 1\\n                a, b = x-1, x+1\\n                while a in h:\\n                    count += 1\\n                    h.remove(a)\\n                    a -= 1\\n                while b in h:\\n                    count += 1\\n                    h.remove(b)\\n                    b += 1\\n                ans = max(ans, count)\\n            return ans",
                "codeTag": "Java"
            },
            {
                "id": 3493938,
                "title": "java-solution-for-longest-consecutive-sequence-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe solution utilizes a HashSet to efficiently check the presence of elements in the array. It iterates through the array twice: once to add all elements to the set, and again to find the longest consecutive subsequence for each element.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Create a HashSet and add all elements from the array to the set.\\n- Initialize a variable called max to keep track of the maximum length of consecutive subsequence found so far.\\n- Iterate through the array and for each element e:\\na. Check if e-1 is present in the set. If it is, it means e is not the starting element of a subsequence, so we continue to the next element.\\nb. If e-1 is not present, we start counting the length of the consecutive subsequence. We increment count and remove e-1 from the set.\\nc. Next, we check if e+1 is present in the set. If it is, we continue counting the length of the consecutive subsequence by incrementing count and removing e+1 from the set.\\nd. We update the value of max by taking the maximum of the current count and max.\\n- Return the value of max as the length of the longest consecutive subsequence.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of this solution is O(n), where n is the length of the input array. The initial iteration to add elements to the set takes O(n), and the subsequent iteration to find the consecutive subsequences also takes O(n). Since both iterations are performed independently, the overall time complexity is O(n + n) = O(n).\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of this solution is O(n) as the HashSet is used to store the elements of the input array. In the worst-case scenario, where all elements are unique, the HashSet will store all n elements.\\n\\n# Code\\n```\\nclass Solution {\\n    public int longestConsecutive(int[] nums) {\\n        // if array is empty, return 0\\n        if (nums.length == 0) \\n        {\\n            return 0;\\n        }\\n        Set<Integer> set = new HashSet<Integer>();\\n        int max = 1;\\n        for (int e : nums)\\n            set.add(e);\\n        for (int e : nums) \\n        {\\n            int left = e - 1;\\n            int right = e + 1;\\n            int count = 1;\\n            while (set.contains(left)) \\n            {\\n                count++;\\n                set.remove(left);\\n                left--;\\n            }\\n            while (set.contains(right)) \\n            {\\n                count++;\\n                set.remove(right);\\n                right++;\\n            }\\n            max = Math.max(count, max);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int longestConsecutive(int[] nums) {\\n        // if array is empty, return 0\\n        if (nums.length == 0) \\n        {\\n            return 0;\\n        }\\n        Set<Integer> set = new HashSet<Integer>();\\n        int max = 1;\\n        for (int e : nums)\\n            set.add(e);\\n        for (int e : nums) \\n        {\\n            int left = e - 1;\\n            int right = e + 1;\\n            int count = 1;\\n            while (set.contains(left)) \\n            {\\n                count++;\\n                set.remove(left);\\n                left--;\\n            }\\n            while (set.contains(right)) \\n            {\\n                count++;\\n                set.remove(right);\\n                right++;\\n            }\\n            max = Math.max(count, max);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467362,
                "title": "awesome-logic-tc-o-n-and-o-nlogn",
                "content": "# Sorting Approach--->O(NlogN) \\n```\\nclass Solution:\\n    def longestConsecutive(self, nums: List[int]) -> int:\\n        nums=list(set(nums))\\n        nums.sort()\\n        count,ans=1,0\\n        for i in range(len(nums)-1):\\n            if (nums[i+1]-nums[i])==1:\\n                count+=1\\n            else:\\n                count=1\\n            ans=max(ans,count)\\n        return ans\\n```    \\n# without Sorting ------> O(N)\\n```\\nclass Solution:\\n    def longestConsecutive(self, nums: List[int]) -> int:\\n        nums=set(nums)\\n        ans=0\\n        for n in nums:\\n            if n-1 in nums:\\n                continue\\n            nxt=n\\n            while (nxt+1) in nums:\\n                nxt+=1\\n            ans=max(ans,nxt-n+1)\\n        return ans\\n```\\n# please upvote me it would encourage me alot\\n",
                "solutionTags": [
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def longestConsecutive(self, nums: List[int]) -> int:\\n        nums=list(set(nums))\\n        nums.sort()\\n        count,ans=1,0\\n        for i in range(len(nums)-1):\\n            if (nums[i+1]-nums[i])==1:\\n                count+=1\\n            else:\\n                count=1\\n            ans=max(ans,count)\\n        return ans\\n```\n```\\nclass Solution:\\n    def longestConsecutive(self, nums: List[int]) -> int:\\n        nums=set(nums)\\n        ans=0\\n        for n in nums:\\n            if n-1 in nums:\\n                continue\\n            nxt=n\\n            while (nxt+1) in nums:\\n                nxt+=1\\n            ans=max(ans,nxt-n+1)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2978710,
                "title": "c-easy-and-understanding-solution",
                "content": "# Approach\\nFirstly, we need to catch nonrepeated numbers. That\\'s why, we use HashSet. After, in the loop we check previous number of the current number exist or not in the array. If previous number doesn\\'t exist, then we guess that our sequence is starting.\\n\\n# Complexity\\n- Time complexity: O(N)\\n\\n- Space complexity: O(N)\\n\\n# Code\\n```\\npublic class Solution {\\n    public int LongestConsecutive(int[] nums) {\\n        HashSet<int> set = new HashSet<int>(nums);\\n        int maxLength = 0;\\n\\n        foreach(int num in nums) {\\n            if(set.Contains(num - 1)) continue;\\n            \\n            int length = 0;\\n            while(set.Contains(num + length)) length++;\\n\\n            maxLength = Math.Max(maxLength, length);\\n        }\\n\\n        return maxLength;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int LongestConsecutive(int[] nums) {\\n        HashSet<int> set = new HashSet<int>(nums);\\n        int maxLength = 0;\\n\\n        foreach(int num in nums) {\\n            if(set.Contains(num - 1)) continue;\\n            \\n            int length = 0;\\n            while(set.Contains(num + length)) length++;\\n\\n            maxLength = Math.Max(maxLength, length);\\n        }\\n\\n        return maxLength;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2753278,
                "title": "javascript-simple-solution-with-explanation",
                "content": "***The idea is to put all the elements in the set and than again loop throuh the array and check that if any element is starting i.e if that element lower value is not in the set, than run a loop untill that elemnt next value is in the set. and maintain the count ata the same time***\\n    \\n\\t\\n**STEPS**\\n*   Initialize a blank set\\n*  run a loop over the nums arry and put all the element in the set\\n*  again run another loop over nums\\n*  check if that current element is starting element of the sequence. we can check that by seeing that if that element previous element is already in the set. if previous element is not in the set, then go inside that condition.\\n*  inside take a count as 0\\n*  start a loop with the condition that till element next value is present in the set\\n*  offcourse increment the element to check for next value inside while condition. and also increment the count\\n* maintain a maximum count value during each elemengt iteration\\n* at last return that maximum value\\n\\n\\n```\\nvar longestConsecutive = function(nums) {\\n    \\n    let set = new Set()   //initializing a blank set\\n    for(let ele of nums){  //loop over nums and put all elements in the set\\n        set.add(ele)\\n    }\\n    let maxCount = 0   //maintain a maximum count value\\n    for(let ele of nums){  //again loop over nums array\\n        if(!set.has(ele-1)){  //check if a element is a starting element of the sequence\\n            let count = 0  //if so, take count as 0\\n            while(set.has(ele)){  //start a loop with the condition untill element+1 is present in the set\\n                ele++   //making the element as element+1\\n                count++  //incrementing the count\\n            }\\n            maxCount = Math.max(maxCount, count)  //maintaining the maximum count value\\n        }\\n    }\\n    return maxCount\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "***The idea is to put all the elements in the set and than again loop throuh the array and check that if any element is starting i.e if that element lower value is not in the set, than run a loop untill that elemnt next value is in the set. and maintain the count ata the same time***\\n    \\n\\t\\n**STEPS**\\n*   Initialize a blank set\\n*  run a loop over the nums arry and put all the element in the set\\n*  again run another loop over nums\\n*  check if that current element is starting element of the sequence. we can check that by seeing that if that element previous element is already in the set. if previous element is not in the set, then go inside that condition.\\n*  inside take a count as 0\\n*  start a loop with the condition that till element next value is present in the set\\n*  offcourse increment the element to check for next value inside while condition. and also increment the count\\n* maintain a maximum count value during each elemengt iteration\\n* at last return that maximum value\\n\\n\\n```\\nvar longestConsecutive = function(nums) {\\n    \\n    let set = new Set()   //initializing a blank set\\n    for(let ele of nums){  //loop over nums and put all elements in the set\\n        set.add(ele)\\n    }\\n    let maxCount = 0   //maintain a maximum count value\\n    for(let ele of nums){  //again loop over nums array\\n        if(!set.has(ele-1)){  //check if a element is a starting element of the sequence\\n            let count = 0  //if so, take count as 0\\n            while(set.has(ele)){  //start a loop with the condition untill element+1 is present in the set\\n                ele++   //making the element as element+1\\n                count++  //incrementing the count\\n            }\\n            maxCount = Math.max(maxCount, count)  //maintaining the maximum count value\\n        }\\n    }\\n    return maxCount\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 2240176,
                "title": "very-simple-c-soln",
                "content": "\\n        \\n        int longestConsecutive(vector<int>& nums) {\\n\\t\\t\\tif(nums.size()==0) return 0;\\n\\t\\t\\tif(nums.size()==1) return 1;\\n\\t\\t\\tsort(nums.begin(),nums.end());\\n\\t\\t\\tint len=1,maxLen=1;\\n        \\n\\t\\t\\tfor(int i=0;i<nums.size()-1;i++){\\n\\t\\t\\t  if(abs(nums[i+1]-nums[i]) == 1){\\n\\t\\t\\t\\t len++;\\n\\t\\t\\t  }\\n\\t\\t\\t  else if(nums[i]==nums[i+1]){\\n\\t\\t\\t   continue;\\n\\t\\t\\t  }\\n\\t\\t\\t  else{\\n\\t\\t\\t\\t  len=1;         \\n\\t\\t\\t   }\\n\\t\\t\\t   maxLen=max(len,maxLen); \\n\\t\\t\\t}\\n\\t\\t\\treturn maxLen;\\n\\t\\t}\\n\\'\\'\\'",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "\\n        \\n        int longestConsecutive(vector<int>& nums) {\\n\\t\\t\\tif(nums.size()==0) return 0;\\n\\t\\t\\tif(nums.size()==1) return 1;\\n\\t\\t\\tsort(nums.begin(),nums.end());\\n\\t\\t\\tint len=1,maxLen=1;\\n        \\n\\t\\t\\tfor(int i=0;i<nums.size()-1;i++){\\n\\t\\t\\t  if(abs(nums[i+1]-nums[i]) == 1){\\n\\t\\t\\t\\t len++;\\n\\t\\t\\t  }\\n\\t\\t\\t  else if(nums[i]==nums[i+1]){\\n\\t\\t\\t   continue;\\n\\t\\t\\t  }\\n\\t\\t\\t  else{\\n\\t\\t\\t\\t  len=1;         \\n\\t\\t\\t   }\\n\\t\\t\\t   maxLen=max(len,maxLen); \\n\\t\\t\\t}\\n\\t\\t\\treturn maxLen;\\n\\t\\t}\\n\\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 1477621,
                "title": "solution-with-bfs-and-explained-javascript-99-68",
                "content": "Hi,\\n\\nI found this solution using BFS to determine the Longest Consecutive Sequence. In this case, it is possible to describe the elements in `nums` as nodes, and the solution is to find the largest connected graph.\\n\\nIn the `First Loop`, I created a hashmap that will describe every node that I had in `nums` as `NOT_VISITED`.\\n\\nIn the `Second Loop`, we iterate again in the `nums` and add the first `NOT_VISITED` node to the queue. This loop makes sure that we visit every node in `nums`.\\n\\nIn `While statement` it is defined the `currentNode` as `VISITED`, and also add +1 to the connected graph counter. After that, it tries to add to the `queue` the previous number and the next one as well (if the node exists and it is not visited yet).\\n\\nFinishing the `While statement`, we compare the old results to the new one selecting the largest from these values, and return it!\\n\\nThe complexity stills O(2n) => O(n) because the algorithmn is accessing at least two times the elements in `nums`.\\n\\nThat\\'s it, if you find difficulty, please let me know, I\\'ll try my best to explain to you. =)\\n\\n```javascript\\nlet NOT_VISITED = \"NOT_VISITED\";\\nlet VISITED = \"VISITED\";\\n\\nvar longestConsecutive = function(nums) {\\n\\t// First loop\\n    let nodes = {};\\n    for(let i = 0; i < nums.length; i++) {\\n        nodes[nums[i]] = NOT_VISITED;\\n    }\\n    \\n    let max = 0;\\n   \\n\\t// Second loop\\n    for (let i = 0; i < nums.length; i++) {\\n        if (nodes[nums[i]] === VISITED) {\\n            continue;\\n        }\\n        \\n        let queue = [nums[i]];\\n        let newMax = 0;\\n        \\n\\t\\t// Applying BFS\\n        while(queue.length > 0) {\\n            let currentNode = queue.shift();\\n\\n            nodes[currentNode] = VISITED;\\n            newMax++;\\n\\n            if (nodes[currentNode + 1] === NOT_VISITED) {\\n                queue.push(currentNode + 1);\\n            }\\n            if (nodes[currentNode - 1] === NOT_VISITED){\\n                queue.push(currentNode - 1);\\n            }\\n        }\\n        max = Math.max(max, newMax);\\n    }\\n    \\n    return max;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Breadth-First Search"
                ],
                "code": "```javascript\\nlet NOT_VISITED = \"NOT_VISITED\";\\nlet VISITED = \"VISITED\";\\n\\nvar longestConsecutive = function(nums) {\\n\\t// First loop\\n    let nodes = {};\\n    for(let i = 0; i < nums.length; i++) {\\n        nodes[nums[i]] = NOT_VISITED;\\n    }\\n    \\n    let max = 0;\\n   \\n\\t// Second loop\\n    for (let i = 0; i < nums.length; i++) {\\n        if (nodes[nums[i]] === VISITED) {\\n            continue;\\n        }\\n        \\n        let queue = [nums[i]];\\n        let newMax = 0;\\n        \\n\\t\\t// Applying BFS\\n        while(queue.length > 0) {\\n            let currentNode = queue.shift();\\n\\n            nodes[currentNode] = VISITED;\\n            newMax++;\\n\\n            if (nodes[currentNode + 1] === NOT_VISITED) {\\n                queue.push(currentNode + 1);\\n            }\\n            if (nodes[currentNode - 1] === NOT_VISITED){\\n                queue.push(currentNode - 1);\\n            }\\n        }\\n        max = Math.max(max, newMax);\\n    }\\n    \\n    return max;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 931300,
                "title": "python-o-n-with-extra-req-doubles-nums-counted",
                "content": "**like it? please, vote!**\\n*dont like? please, commit suggestions for optimization*\\n    \\n    def longestConsecutive(self, nums):\\n        counter=0\\n        max_=0\\n        d=defaultdict (lambda:0) \\n        for t in nums:\\n            d[t]+=1 \\n\\n        for i in d.keys():\\n            counter=d[i]\\n            k=1\\n\\t\\t\\tif d.get(i-1)==None:\\n\\t\\t\\t\\twhile d.get(i+k):\\n\\t\\t\\t\\t\\tcounter+=d[i+k]\\n\\t\\t\\t\\t\\tk+=1\\n                \\n            if counter>max_:\\n                max_=counter\\n        \\n\\n        return max_",
                "solutionTags": [
                    "Python3"
                ],
                "code": "**like it? please, vote!**\\n*dont like? please, commit suggestions for optimization*\\n    \\n    def longestConsecutive(self, nums):\\n        counter=0\\n        max_=0\\n        d=defaultdict (lambda:0) \\n        for t in nums:\\n            d[t]+=1 \\n\\n        for i in d.keys():\\n            counter=d[i]\\n            k=1\\n\\t\\t\\tif d.get(i-1)==None:\\n\\t\\t\\t\\twhile d.get(i+k):\\n\\t\\t\\t\\t\\tcounter+=d[i+k]\\n\\t\\t\\t\\t\\tk+=1\\n                \\n            if counter>max_:\\n                max_=counter\\n        \\n\\n        return max_",
                "codeTag": "Python3"
            },
            {
                "id": 3094003,
                "title": "best-o-n-solution",
                "content": "# Approach 1\\nSorting\\n\\n# Complexity\\n- Time complexity:\\n$$O(nlogn)$$ \\n\\n- Space complexity:\\n$$O(1)$$ \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestConsecutive(vector<int>& nums) {\\n        if (nums.size() == 0)\\n            return 0;\\n        sort (nums.begin(), nums.end());\\n        int ans = 1, count = 1;\\n        for (int i = 1; i < nums.size(); i++) {\\n            if (nums[i] == nums[i - 1] + 1) {\\n                count++;\\n                ans = max (ans, count);\\n            } else if (nums[i] == nums[i - 1]) {\\n                continue;\\n            } else {\\n                count = 1; \\n            }\\n        }\\n        return ans;\\n    }\\n    }\\n};\\n```\\n\\n# Approach 2\\nUsing HashSet\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$ \\n\\n- Space complexity:\\n$$O(n)$$ \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestConsecutive(vector<int>& nums) {\\n        unordered_set <int> st;\\n        for (int i = 0; i < nums.size(); i++)\\n            st.insert(nums[i]);\\n        int curr = 1, ans = 0;    \\n        for (int i = 0; i < nums.size(); i++) {\\n            if (st.find(nums[i] - 1) == st.end()) {\\n                curr = 1;\\n                while (st.find(nums[i] + curr) != st.end())\\n                    curr++;\\n                ans = max (curr, ans);    \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestConsecutive(vector<int>& nums) {\\n        if (nums.size() == 0)\\n            return 0;\\n        sort (nums.begin(), nums.end());\\n        int ans = 1, count = 1;\\n        for (int i = 1; i < nums.size(); i++) {\\n            if (nums[i] == nums[i - 1] + 1) {\\n                count++;\\n                ans = max (ans, count);\\n            } else if (nums[i] == nums[i - 1]) {\\n                continue;\\n            } else {\\n                count = 1; \\n            }\\n        }\\n        return ans;\\n    }\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int longestConsecutive(vector<int>& nums) {\\n        unordered_set <int> st;\\n        for (int i = 0; i < nums.size(); i++)\\n            st.insert(nums[i]);\\n        int curr = 1, ans = 0;    \\n        for (int i = 0; i < nums.size(); i++) {\\n            if (st.find(nums[i] - 1) == st.end()) {\\n                curr = 1;\\n                while (st.find(nums[i] + curr) != st.end())\\n                    curr++;\\n                ans = max (curr, ans);    \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2745362,
                "title": "longest-consecutive-sequence-easy-method-o-nlogn",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestConsecutive(vector<int>& nums)\\n    {\\n        \\n        \\n\\n        map<int,int>mp;\\n        \\n        int n=nums.size();\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            mp[nums[i]]++;\\n        }\\n        \\n        nums.clear();\\n        \\n        for(auto it=mp.begin();it!=mp.end();it++)\\n        {\\n            nums.push_back(it->first);\\n        }\\n        \\n        if(n==0)\\n        {\\n            return 0;\\n        }\\n        \\n        sort(nums.begin(),nums.end());\\n        \\n        int len=1;\\n        int maxx=INT_MIN;\\n        \\n        for(int i=0;i<nums.size()-1;i++)\\n        {\\n            int value=nums[i+1]-nums[i];\\n            \\n            if(value==1)\\n            {\\n                len++;\\n            }\\n            else\\n            {\\n                maxx=max(maxx,len);\\n                len=1;\\n            }\\n        }\\n        \\n        maxx=max(maxx,len);\\n        \\n        return maxx;\\n    } \\n        \\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestConsecutive(vector<int>& nums)\\n    {\\n        \\n        \\n\\n        map<int,int>mp;\\n        \\n        int n=nums.size();\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            mp[nums[i]]++;\\n        }\\n        \\n        nums.clear();\\n        \\n        for(auto it=mp.begin();it!=mp.end();it++)\\n        {\\n            nums.push_back(it->first);\\n        }\\n        \\n        if(n==0)\\n        {\\n            return 0;\\n        }\\n        \\n        sort(nums.begin(),nums.end());\\n        \\n        int len=1;\\n        int maxx=INT_MIN;\\n        \\n        for(int i=0;i<nums.size()-1;i++)\\n        {\\n            int value=nums[i+1]-nums[i];\\n            \\n            if(value==1)\\n            {\\n                len++;\\n            }\\n            else\\n            {\\n                maxx=max(maxx,len);\\n                len=1;\\n            }\\n        }\\n        \\n        maxx=max(maxx,len);\\n        \\n        return maxx;\\n    } \\n        \\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2238871,
                "title": "python3-a-very-simple-solution-using-heap-ds",
                "content": "#### Introduction\\nFor this problem, you may have seen a lot of the solutions use streak counting system. But it is just another two pointer method \\uD83D\\uDE12. \\n\\nToday, I will show you how to solve this problem using a heap data structure (specifically min heap) \\uD83D\\uDE03.\\nIf you are new to heap ds, I suggest you to see these source:\\n- https://leetcode.com/explore/learn/card/heap/643/heap/4018/ (This intro card is more than enough to understand).\\n- https://docs.python.org/3/library/heapq.html (The python in-built lib for heaps)\\n\\n#### Explanation\\n1. We remove the duplicates since we are only focussing on the consecutive elements rather than a duplicate.\\n\\t- `a = list(set(a))`\\n2. Then we heapify the array with the unique elements.\\n\\t- `heapq.heapify(a)` - this will turn the array into min-heap\\n3. Then we traverse the heap.\\n\\t- For 1 iteration:\\n\\t\\t1. pop the minimum value.\\n\\t\\t2. Increment temp answer by 1\\n\\t\\t2. Check if `peek_value != popped val + 1` (we just peek the first element of heap)\\n\\t\\t3. If so, we check the max of the best value and the temp value and reset the temp.\\n4. The best value is the answer.\\n\\n\\n#### Solution\\n```\\n        a, best, temp = list(set(a)), 0, 0\\n        heapq.heapify(a)\\n\\t\\t\\n        while a:\\n            pop_val = heapq.heappop(a)\\n            t += 1\\n            if a == [] or a[0] != pop_val + 1:\\n                res = max(t, res)\\n                t = 0\\n        return res\\n```\\n\\nPlease do **Upvote** if you like the solution.",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n        a, best, temp = list(set(a)), 0, 0\\n        heapq.heapify(a)\\n\\t\\t\\n        while a:\\n            pop_val = heapq.heappop(a)\\n            t += 1\\n            if a == [] or a[0] != pop_val + 1:\\n                res = max(t, res)\\n                t = 0\\n        return res\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1793746,
                "title": "solution-swift-longest-consecutive-sequence",
                "content": "```swift\\nclass Solution {\\n    func longestConsecutive(_ nums: [Int]) -> Int {\\n        guard nums.count > 1 else { return nums.count }\\n        let setSort = Set(nums).sorted()\\n        var longest = 0, count = 1, num = 0\\n        \\n        while num < setSort.count {\\n            if num - 1 >= 0, setSort[num - 1] == setSort[num] - 1 {\\n                count += 1\\n            } else {\\n                longest = max(count, longest)\\n                count = 1\\n            }\\n            num += 1\\n        }\\n        return max(count, longest)\\n    }\\n}\\n```\\n\\n<hr>\\n\\n<details>\\n<summary><img src=\"https://git.io/JDblm\" height=\"24\"> <b>TEST CASES</b></summary>\\n\\n<pre>\\nResult: Executed 2 tests, with 0 failures (0 unexpected) in 0.008 (0.010) seconds\\n</pre>\\n\\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    // The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4.\\n    func test0() {\\n        let value = solution.longestConsecutive([100,4,200,1,3,2])\\n        XCTAssertEqual(value, 4)\\n    }\\n    \\n    func test1() {\\n        let value = solution.longestConsecutive([0,3,7,2,5,8,4,6,0,1])\\n        XCTAssertEqual(value, 9)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n\\n</details>",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func longestConsecutive(_ nums: [Int]) -> Int {\\n        guard nums.count > 1 else { return nums.count }\\n        let setSort = Set(nums).sorted()\\n        var longest = 0, count = 1, num = 0\\n        \\n        while num < setSort.count {\\n            if num - 1 >= 0, setSort[num - 1] == setSort[num] - 1 {\\n                count += 1\\n            } else {\\n                longest = max(count, longest)\\n                count = 1\\n            }\\n            num += 1\\n        }\\n        return max(count, longest)\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    // The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4.\\n    func test0() {\\n        let value = solution.longestConsecutive([100,4,200,1,3,2])\\n        XCTAssertEqual(value, 4)\\n    }\\n    \\n    func test1() {\\n        let value = solution.longestConsecutive([0,3,7,2,5,8,4,6,0,1])\\n        XCTAssertEqual(value, 9)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1254746,
                "title": "rust-hashset-radix-sort-solutions-details",
                "content": "**HashSet Solution**:\\n\\nInserting to and querying a hash set have `O(1)` time complexity.\\n\\nWe can insert all elements in `nums` into our set in `O(n)` time.\\nThen for each number in our set that _is **not**_ part of a longer consecutive sequence, count how long the sequence is and return the maximum length we find.\\n\\nTo count the length of a sequence, we continuously query for the next ascending number until it\\'s not found in our set, counting how many times we\\'re able to do this.\\nBecause we\\'re _not_ considering sequences that are part of longer ones, the total time complexity of all these queries is `O(n)`.\\n\\n```rust\\nimpl Solution {\\n    pub fn longest_consecutive(nums: Vec<i32>) -> i32 {\\n        let set: std::collections::HashSet<_> = nums.iter().collect();\\n        set.iter()\\n            .filter(|&&x| !set.contains(&(x - 1))) // ensure not part of a longer consecutive sequence\\n            .map(|&&x| (x..).take_while(|x| set.contains(x)).count())\\n            .max()\\n            .unwrap_or(0) as _\\n    }\\n}\\n```\\n\\n---\\n\\n**Base-10 LSD Radix Sort Solution**:\\n\\nUnlike comparison sorts that have `O(n*logn)` time complexity, distribution sorts such as radix sort have `O(n)` complexity.\\n\\nWe can sort `nums` using a distribution sort and count the length of the longest consecutive sequence while iterating through `nums`.\\nBoth operations take `O(n)` time.\\n\\nThis example uses a base-10 radix sort (from the least-significant digits):\\n\\n```rust\\nimpl Solution {\\n    pub fn longest_consecutive(mut nums: Vec<i32>) -> i32 {\\n        Self::radix_sort_base10(&mut nums);\\n        nums.iter()\\n            .zip(nums.iter().skip(1))\\n            .scan(1, |n, (&a, &b)| {\\n                *n = if a + 1 >= b { *n + b - a } else { 1 }; // +1 length if (a+1 == b), +0 if (a == b); otherwise reset length\\n                Some(*n)\\n            })\\n            .max()\\n            .unwrap_or(nums.len().min(1) as _)\\n    }\\n\\n    fn radix_sort_base10(nums: &mut [i32]) {\\n        let mut buckets = vec![vec![]; 20]; // for digits -9 to +9\\n        for i in 0..10 {\\n            nums.iter()\\n                .for_each(|&x| buckets[10 + ((x / 10i32.pow(i)) % 10) as usize].push(x));\\n            buckets\\n                .iter()\\n                .flat_map(|b| b.iter())\\n                .zip(nums.iter_mut())\\n                .for_each(|(&x, y)| *y = x);\\n            buckets.iter_mut().for_each(|b| b.clear());\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nimpl Solution {\\n    pub fn longest_consecutive(nums: Vec<i32>) -> i32 {\\n        let set: std::collections::HashSet<_> = nums.iter().collect();\\n        set.iter()\\n            .filter(|&&x| !set.contains(&(x - 1))) // ensure not part of a longer consecutive sequence\\n            .map(|&&x| (x..).take_while(|x| set.contains(x)).count())\\n            .max()\\n            .unwrap_or(0) as _\\n    }\\n}\\n```\n```rust\\nimpl Solution {\\n    pub fn longest_consecutive(mut nums: Vec<i32>) -> i32 {\\n        Self::radix_sort_base10(&mut nums);\\n        nums.iter()\\n            .zip(nums.iter().skip(1))\\n            .scan(1, |n, (&a, &b)| {\\n                *n = if a + 1 >= b { *n + b - a } else { 1 }; // +1 length if (a+1 == b), +0 if (a == b); otherwise reset length\\n                Some(*n)\\n            })\\n            .max()\\n            .unwrap_or(nums.len().min(1) as _)\\n    }\\n\\n    fn radix_sort_base10(nums: &mut [i32]) {\\n        let mut buckets = vec![vec![]; 20]; // for digits -9 to +9\\n        for i in 0..10 {\\n            nums.iter()\\n                .for_each(|&x| buckets[10 + ((x / 10i32.pow(i)) % 10) as usize].push(x));\\n            buckets\\n                .iter()\\n                .flat_map(|b| b.iter())\\n                .zip(nums.iter_mut())\\n                .for_each(|(&x, y)| *y = x);\\n            buckets.iter_mut().for_each(|b| b.clear());\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1252849,
                "title": "go-iterate-over-map-10x-faster-than-over-slice",
                "content": "I found an interesting behavior in this problem. After I reviewed the solutions in discussion, came up with this approach:\\n```\\nfunc longestConsecutive(nums []int) int {\\n    numMap := map[int]bool{}\\n    consecutiveNumCnt := 0\\n\\n    for _, num := range nums{\\n        numMap[num] = true\\n    }\\n    \\n\\t// If I iterate over the map instead of input nums slice, the runtime would be 10x faster than slice one.\\n    //for _, num := range nums{\\n    for num := range numMap{\\n        if numMap[num - 1]{\\n            continue\\n        }\\n        \\n        cur := num\\n        for numMap[cur+1]{\\n            cur++\\n        }\\n        \\n        consecutiveNumCnt = max(consecutiveNumCnt, cur - num+1)\\n    }\\n    \\n    return consecutiveNumCnt\\n}\\n\\nfunc max(a, b int)int{\\n    if a > b{\\n        return a\\n    }\\n    return b\\n}\\n```\\n\\nIf I iterate over the map instead of input nums slice, the runtime would be 10x faster than slice one.\\nIt\\'s quite odd, based on my understanding of golang, iterate over slice should be faster than map.\\nCan some golang experts help resolve my question? Do I misunderstand or I get anything wrong?\\n",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc longestConsecutive(nums []int) int {\\n    numMap := map[int]bool{}\\n    consecutiveNumCnt := 0\\n\\n    for _, num := range nums{\\n        numMap[num] = true\\n    }\\n    \\n\\t// If I iterate over the map instead of input nums slice, the runtime would be 10x faster than slice one.\\n    //for _, num := range nums{\\n    for num := range numMap{\\n        if numMap[num - 1]{\\n            continue\\n        }\\n        \\n        cur := num\\n        for numMap[cur+1]{\\n            cur++\\n        }\\n        \\n        consecutiveNumCnt = max(consecutiveNumCnt, cur - num+1)\\n    }\\n    \\n    return consecutiveNumCnt\\n}\\n\\nfunc max(a, b int)int{\\n    if a > b{\\n        return a\\n    }\\n    return b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 931231,
                "title": "python-super-short-and-easy-o-n-solution",
                "content": "```\\nclass Solution:\\n    def longestConsecutive(self, nums: List[int]) -> int:\\n        my_dict = defaultdict(int)\\n        maxi = 0\\n        for num in nums:\\n            if num not in my_dict.keys():\\n                prev_ = my_dict.get(num-1, 0)\\n                next_ = my_dict.get(num+1, 0)\\n                my_dict[num] += prev_ + next_ + 1\\n                my_dict[num-prev_] = my_dict[num]\\n                my_dict[num+next_] = my_dict[num]\\n                maxi = max(maxi, my_dict[num])\\n        return maxi\\n```\\n**Like it? please upvote...**",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def longestConsecutive(self, nums: List[int]) -> int:\\n        my_dict = defaultdict(int)\\n        maxi = 0\\n        for num in nums:\\n            if num not in my_dict.keys():\\n                prev_ = my_dict.get(num-1, 0)\\n                next_ = my_dict.get(num+1, 0)\\n                my_dict[num] += prev_ + next_ + 1\\n                my_dict[num-prev_] = my_dict[num]\\n                my_dict[num+next_] = my_dict[num]\\n                maxi = max(maxi, my_dict[num])\\n        return maxi\\n```",
                "codeTag": "Java"
            },
            {
                "id": 324225,
                "title": "swift-98-beat-using-clever-hash-maps-o-n-with-o-n-extra-space",
                "content": "```\\nclass Solution {\\n    func longestConsecutive(_ nums: [Int]) -> Int {\\n        var countMap = [Int: Int]()\\n        var result = 0\\n        for num in nums {\\n            if countMap[num] == nil {\\n                var leftSum = countMap[num - 1] ?? 0\\n                var rightSum = countMap[num + 1] ?? 0\\n                var streak = leftSum + rightSum + 1\\n                countMap[num] = streak\\n                if leftSum != 0 { countMap[num-leftSum] = streak }\\n                if rightSum != 0 { countMap[num+rightSum] = streak }\\n                result = max(result, streak)\\n                \\n            }\\n        }\\n        return result\\n    }\\n}\\n```\\n\\nWorks. Nuff said.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func longestConsecutive(_ nums: [Int]) -> Int {\\n        var countMap = [Int: Int]()\\n        var result = 0\\n        for num in nums {\\n            if countMap[num] == nil {\\n                var leftSum = countMap[num - 1] ?? 0\\n                var rightSum = countMap[num + 1] ?? 0\\n                var streak = leftSum + rightSum + 1\\n                countMap[num] = streak\\n                if leftSum != 0 { countMap[num-leftSum] = streak }\\n                if rightSum != 0 { countMap[num+rightSum] = streak }\\n                result = max(result, streak)\\n                \\n            }\\n        }\\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 41215,
                "title": "my-short-c-solution-using-unordered-map-so-it-s-o-n-time-and-o-n-space",
                "content": "    class Solution {\\n    public:\\n    int longestConsecutive(vector<int>& nums) {\\n        unordered_map<int,bool> mp;\\n        int ret = 0;\\n        for(const auto x:nums)\\n            mp[x] = true;\\n        for(const auto x : mp)\\n            if(x.second)\\n            {\\n                int left = x.first,right = x.first+1;\\n                while(mp.count(left) && mp[left])\\n                    mp[left--] = false;\\n                while(mp.count(right) && mp[right])\\n                    mp[right++] = false;\\n                ret = max(ret,right - left  - 1);\\n            }\\n        return ret;\\n    }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n    int longestConsecutive(vector<int>& nums) {\\n        unordered_map<int,bool> mp;\\n        int ret = 0;\\n        for(const auto x:nums)\\n            mp[x] = true;\\n        for(const auto x : mp)\\n            if(x.second)\\n            {\\n                int left = x.first,right = x.first+1;\\n                while(mp.count(left) && mp[left])\\n                    mp[left--] = false;\\n                while(mp.count(right) && mp[right])\\n                    mp[right++] = false;\\n                ret = max(ret,right - left  - 1);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3742943,
                "title": "my-really-simple-well-commmented-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestConsecutive(vector<int>& nums) {\\n        // we will be using hash\\n        unordered_set<int>numSet(nums.begin(),nums.end());\\n        int best=0;\\n        for(int i:numSet){\\n            //if we didn\\'t found the prev number mean a new series can start from here \\n            if(numSet.find(i-1)==numSet.end()){\\n                int y=i+1;\\n                while(numSet.find(y)!=numSet.end()){\\n                    y++;\\n                }\\n                best=max(best,y-i); \\n                // as values will be consecutivve there difference will give the length\\n            }\\n        }\\n        return best;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestConsecutive(vector<int>& nums) {\\n        // we will be using hash\\n        unordered_set<int>numSet(nums.begin(),nums.end());\\n        int best=0;\\n        for(int i:numSet){\\n            //if we didn\\'t found the prev number mean a new series can start from here \\n            if(numSet.find(i-1)==numSet.end()){\\n                int y=i+1;\\n                while(numSet.find(y)!=numSet.end()){\\n                    y++;\\n                }\\n                best=max(best,y-i); \\n                // as values will be consecutivve there difference will give the length\\n            }\\n        }\\n        return best;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3734953,
                "title": "tc-o-n-super-simple-intuitive",
                "content": "# Approach\\nThe code starts by initializing variables: n as the size of the input vector nums, an unordered set s initialized with the elements of nums, and ans as the variable to store the longest consecutive sequence length.\\n\\nNext, the code iterates through each element nums[i] in nums. For each element, it checks if nums[i]-1 (the previous number in a potential sequence) is present in the unordered set s. If nums[i]-1 is not found in s, it means that nums[i] is the lowest value of a potential consecutive sequence.\\n\\nThen, a counting loop starts, where it increments a count variable for each subsequent number in the sequence (num++) until the next number (num) is not found in the unordered set s. This loop calculates the length of the consecutive sequence starting from nums[i].\\n\\nFinally, the code updates the ans variable to be the maximum between the current ans and the count, which represents the length of the consecutive sequence starting from nums[i]. This ensures that the ans variable always stores the maximum length of a consecutive sequence encountered so far.\\n\\nAfter iterating through all elements of nums, the code returns the value stored in ans, which represents the length of the longest consecutive sequence in nums.\\n\\n# Complexity\\n1. Time complexity: The time complexity of this code is O(n), where n is the size of the input vector nums. This is because the code iterates through the nums vector once and performs constant time operations (such as unordered set lookups and arithmetic operations) within the loop. The unordered set operations have an average time complexity of O(1).\\n\\n2.  Space complexity: The space complexity of this code is O(n), where n is the size of the input vector nums. This is because the code creates an unordered set s to store the unique elements of nums, which can potentially have a size of n in the worst case.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestConsecutive(vector<int>& nums) {\\n        int n=nums.size();\\n        unordered_set<int> s(nums.begin(),nums.end());\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            // nums[i]-1 must not be in set, \\n            // basically we will start from lowest value of any sequence, if nums[i]-1 exist then that nums[i] is not the lowest\\n            if(s.find(nums[i]-1)==s.end()){// lowest one\\n                int count=1; // nums[i] will be part of that sequence\\n                int num=nums[i]+1; //next in sequence\\n                while(s.find(num)!=s.end()){\\n                    //counting all sequeces from nums[i]\\n                    count++;num++;\\n                }\\n                ans=max(ans,count);\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestConsecutive(vector<int>& nums) {\\n        int n=nums.size();\\n        unordered_set<int> s(nums.begin(),nums.end());\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            // nums[i]-1 must not be in set, \\n            // basically we will start from lowest value of any sequence, if nums[i]-1 exist then that nums[i] is not the lowest\\n            if(s.find(nums[i]-1)==s.end()){// lowest one\\n                int count=1; // nums[i] will be part of that sequence\\n                int num=nums[i]+1; //next in sequence\\n                while(s.find(num)!=s.end()){\\n                    //counting all sequeces from nums[i]\\n                    count++;num++;\\n                }\\n                ans=max(ans,count);\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3649044,
                "title": "c-using-unodered-map-with-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf I can find that for any element in the array if element+1 exists and till when we are able to find element+1 in array and similary for element-1, hence adding number of times I was able to find them (both element+1 and element-1) in the array will give me the length of the longest consecutive elements sequence.\\n\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n*Please let me know if I missed anything :), Thank you!*\\n\\n# Code\\n```\\nclass Solution {\\n    // time: O(nlogn + n); space: O(n)\\n    int longestConsecutive_map(vector<int>& nums) {\\n        unordered_map<int, int> mp;\\n\\n        for(auto i: nums) mp[i]++;\\n\\n        int lcs = 0;\\n        for(int i=0; i<nums.size(); i++) {\\n            int count = 0, ele = nums[i];\\n            // check if nums[i] has been checked as a part of series\\n            if(mp[ele] == -1) continue;\\n\\n            // series greater than nums[i]\\n            while(mp[ele]) {\\n                mp[ele] = -1; //making it invalid, can\\'t be used again as already checked once\\n                count++;\\n                ele++;\\n            }\\n\\n            // series lesser than nums[i]\\n            ele = nums[i]-1;\\n            while(mp[ele]) {\\n                mp[ele] = -1; //making it invalid, can\\'t be used again as already checked once\\n                count++;\\n                ele--;\\n            }\\n            lcs = max(lcs, count);\\n        }\\n        return lcs;\\n    }\\npublic:\\n    int longestConsecutive(vector<int>& nums) {\\n        return longestConsecutive_map(nums);\\n    }\\n}; \\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    // time: O(nlogn + n); space: O(n)\\n    int longestConsecutive_map(vector<int>& nums) {\\n        unordered_map<int, int> mp;\\n\\n        for(auto i: nums) mp[i]++;\\n\\n        int lcs = 0;\\n        for(int i=0; i<nums.size(); i++) {\\n            int count = 0, ele = nums[i];\\n            // check if nums[i] has been checked as a part of series\\n            if(mp[ele] == -1) continue;\\n\\n            // series greater than nums[i]\\n            while(mp[ele]) {\\n                mp[ele] = -1; //making it invalid, can\\'t be used again as already checked once\\n                count++;\\n                ele++;\\n            }\\n\\n            // series lesser than nums[i]\\n            ele = nums[i]-1;\\n            while(mp[ele]) {\\n                mp[ele] = -1; //making it invalid, can\\'t be used again as already checked once\\n                count++;\\n                ele--;\\n            }\\n            lcs = max(lcs, count);\\n        }\\n        return lcs;\\n    }\\npublic:\\n    int longestConsecutive(vector<int>& nums) {\\n        return longestConsecutive_map(nums);\\n    }\\n}; \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3552010,
                "title": "c-simple-clean-code-dsu-union-find",
                "content": "\\n\\n# Approach\\nConsider all indexes of the array as nodes.Also note that we need to consider a value only once but as same values can be at different indices we need  if(mp.find(nums[i])!=mp.end()) continue;  to avoid repeting values.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nclass DisjointSet {\\n\\npublic:\\n    vector<int> parent, size;\\n    DisjointSet(int n) {\\n        parent.resize(n + 1);\\n        size.resize(n + 1);\\n        for (int i = 0; i <= n; i++) {\\n            parent[i] = i;\\n            size[i] = 1;\\n        }\\n    }\\n\\n    int findUPar(int node) {\\n        if (node == parent[node])\\n            return node;\\n        return parent[node] = findUPar(parent[node]);\\n    }\\n\\n    void unionBySize(int u, int v) {\\n        int ulp_u = findUPar(u);\\n        int ulp_v = findUPar(v);\\n        if (ulp_u == ulp_v) return;\\n        if (size[ulp_u] < size[ulp_v]) {\\n            parent[ulp_u] = ulp_v;\\n            size[ulp_v] += size[ulp_u];\\n        }\\n        else {\\n            parent[ulp_v] = ulp_u;\\n            size[ulp_u] += size[ulp_v];\\n        }\\n    }\\n};\\n\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    int longestConsecutive(vector<int>& nums) {\\n        int n=nums.size();\\n        if(n<=1) return n;\\n        DisjointSet ds(n);\\n\\n        unordered_map<int,int> mp;\\n\\n        for(int i=0;i<n;i++){\\n           \\n           if(mp.find(nums[i])!=mp.end()) continue;\\n             \\n            mp[nums[i]]=i;\\n\\n            if(mp.find(nums[i]+1)!=mp.end()){\\n                ds.unionBySize(i, mp[nums[i]+1]);\\n            }\\n            if(mp.find(nums[i]-1)!=mp.end()){\\n                ds.unionBySize(i, mp[nums[i]-1]);\\n            }\\n        }\\n\\n        int max_size=INT_MIN;\\n        for(int i=0;i<n;i++){\\n            if(i==ds.findUPar(i)){\\n                max_size=max(max_size,ds.size[i]);\\n            }\\n        }\\n\\n      return max_size;\\n\\n        }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Union Find"
                ],
                "code": "```\\nclass DisjointSet {\\n\\npublic:\\n    vector<int> parent, size;\\n    DisjointSet(int n) {\\n        parent.resize(n + 1);\\n        size.resize(n + 1);\\n        for (int i = 0; i <= n; i++) {\\n            parent[i] = i;\\n            size[i] = 1;\\n        }\\n    }\\n\\n    int findUPar(int node) {\\n        if (node == parent[node])\\n            return node;\\n        return parent[node] = findUPar(parent[node]);\\n    }\\n\\n    void unionBySize(int u, int v) {\\n        int ulp_u = findUPar(u);\\n        int ulp_v = findUPar(v);\\n        if (ulp_u == ulp_v) return;\\n        if (size[ulp_u] < size[ulp_v]) {\\n            parent[ulp_u] = ulp_v;\\n            size[ulp_v] += size[ulp_u];\\n        }\\n        else {\\n            parent[ulp_v] = ulp_u;\\n            size[ulp_u] += size[ulp_v];\\n        }\\n    }\\n};\\n\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    int longestConsecutive(vector<int>& nums) {\\n        int n=nums.size();\\n        if(n<=1) return n;\\n        DisjointSet ds(n);\\n\\n        unordered_map<int,int> mp;\\n\\n        for(int i=0;i<n;i++){\\n           \\n           if(mp.find(nums[i])!=mp.end()) continue;\\n             \\n            mp[nums[i]]=i;\\n\\n            if(mp.find(nums[i]+1)!=mp.end()){\\n                ds.unionBySize(i, mp[nums[i]+1]);\\n            }\\n            if(mp.find(nums[i]-1)!=mp.end()){\\n                ds.unionBySize(i, mp[nums[i]-1]);\\n            }\\n        }\\n\\n        int max_size=INT_MIN;\\n        for(int i=0;i<n;i++){\\n            if(i==ds.findUPar(i)){\\n                max_size=max(max_size,ds.size[i]);\\n            }\\n        }\\n\\n      return max_size;\\n\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2238749,
                "title": "python-union-find",
                "content": "Idea: \\n\\n1. create set of elements\\n2. loop for each x in set. If x + 1 also in set union(x,x+1)\\n3. Find parent of maximum size\\n\\n\\n```python\\nclass Solution:\\n    def longestConsecutive(self, nums: List[int]) -> int:\\n        if not nums:\\n            return 0\\n        \\n        UF = {}\\n        def find(x):\\n            if x != UF[x]:\\n                UF[x] = find(UF[x])\\n            return UF[x]\\n        \\n        def union(x,y):\\n            UF.setdefault(x,x)\\n            UF.setdefault(y,y)\\n            UF[find(x)] = find(y)\\n        \\n        S = set(nums)\\n        \\n        for n in S:\\n            union(n,n)\\n            if n+1 in S:\\n                union(n+1,n)\\n        \\n        # find lengths of all the sequences\\n        c = Counter()\\n        for n in S:\\n            c[find(n)]  +=1\\n        \\n        return max(c.values())\\n```\\n\\nTime: `O(n)`\\nSpace: `O(n)`",
                "solutionTags": [
                    "Python",
                    "Union Find"
                ],
                "code": "```python\\nclass Solution:\\n    def longestConsecutive(self, nums: List[int]) -> int:\\n        if not nums:\\n            return 0\\n        \\n        UF = {}\\n        def find(x):\\n            if x != UF[x]:\\n                UF[x] = find(UF[x])\\n            return UF[x]\\n        \\n        def union(x,y):\\n            UF.setdefault(x,x)\\n            UF.setdefault(y,y)\\n            UF[find(x)] = find(y)\\n        \\n        S = set(nums)\\n        \\n        for n in S:\\n            union(n,n)\\n            if n+1 in S:\\n                union(n+1,n)\\n        \\n        # find lengths of all the sequences\\n        c = Counter()\\n        for n in S:\\n            c[find(n)]  +=1\\n        \\n        return max(c.values())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1744725,
                "title": "o-nlogn-solution-with-explanation",
                "content": "The algorithm is simple:\\n1. Store elements of array in set which is a C++ STL container used to store the unique elements, and all the elements are stored in a sorted manner. We need not to worry about duplicates element as we are dealing with sequence.\\n2. Iterate over set with two pointers namely, prev and cur. And initialize two integers to store lenght and maximum length to 1.\\n3. In each iteration, check `*prev + 1 == cur`. If it is true increment len by 1 else reset it to 1. Finally update maxLen. \\n\\n```\\nclass Solution {\\npublic:\\n    int longestConsecutive(vector<int>& nums) {\\n        if(nums.empty())\\n            return 0;\\n        \\n        // storing nums in numSet\\n        set<int> numSet;\\n        for(int num : nums) \\n            numSet.insert(num);\\n        \\n        int maxLen = 1;\\n        int len = 1;\\n        \\n        // Calculating maxLen in sorted set\\n        auto cur = begin(numSet);\\n        auto prev = cur++;\\n        for(; cur != end(numSet); ++cur, ++prev) {\\n            \\n            // if cur is consecutive to prev, increment len by 1\\n            // else reset it to 1\\n            if(*prev + 1 == *cur) ++len;\\n            else len = 1;\\n            \\n            // update maxLen\\n            maxLen = max(maxLen, len);\\n        }\\n        \\n        return maxLen;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestConsecutive(vector<int>& nums) {\\n        if(nums.empty())\\n            return 0;\\n        \\n        // storing nums in numSet\\n        set<int> numSet;\\n        for(int num : nums) \\n            numSet.insert(num);\\n        \\n        int maxLen = 1;\\n        int len = 1;\\n        \\n        // Calculating maxLen in sorted set\\n        auto cur = begin(numSet);\\n        auto prev = cur++;\\n        for(; cur != end(numSet); ++cur, ++prev) {\\n            \\n            // if cur is consecutive to prev, increment len by 1\\n            // else reset it to 1\\n            if(*prev + 1 == *cur) ++len;\\n            else len = 1;\\n            \\n            // update maxLen\\n            maxLen = max(maxLen, len);\\n        }\\n        \\n        return maxLen;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1435664,
                "title": "dfs-graph-solution",
                "content": "This is similar to the iterative solution presented in the official notes. However, it is different enough in that the problem lends itself naturally to the use of a graph. The nodes here are the entries in the array, and the connections are the numbers greater and lesser than the given entry by 1. We first populatte a \\'present\\' set, which we use to compare if the entry has a neighbor that is greater or smaller by 1. We also create a visited array to avoid visiting entries that have been seen already.\\n\\nTo count the run length, we visit each node in the graph and traverse it in DFS like fashion - first traverse connected entries that are greater than the given item, then we go count entries that are smaller. We then add these. At the outer level, we keep track of the max run length, and reset if our returned quantity for a node is the maximum. Also, since we make note of \\'visited\\' entries, we do not visit them again and keep compute O(N). \\n\\n```\\nclass Solution:\\n    def longestConsecutive(self, nums: List[int]) -> int:\\n        \\n        present = set()\\n        visited = {}\\n        \\n        for num in nums:\\n            present.add(num)\\n            visited[num] = False\\n            \\n        max_run = 0\\n            \\n            \\n        def dfs(num, count):\\n            \\n            if visited[num] == True:\\n                return count\\n            \\n            visited[num] = True\\n            count += 1\\n            \\n            #print(\\'num\\', num, present)\\n            \\n            if num + 1 in present:\\n                count = dfs(num + 1, count)\\n            \\n            if num - 1 in present:\\n                count = dfs(num - 1, count)\\n            \\n            \\n            #print(\\'count\\', num, count)\\n                \\n            return count\\n            \\n        \\n        for num in nums:\\n            max_run = max(max_run, dfs(num, 0))\\n            \\n            \\n            \\n        return max_run\\n```\\n        \\n            \\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def longestConsecutive(self, nums: List[int]) -> int:\\n        \\n        present = set()\\n        visited = {}\\n        \\n        for num in nums:\\n            present.add(num)\\n            visited[num] = False\\n            \\n        max_run = 0\\n            \\n            \\n        def dfs(num, count):\\n            \\n            if visited[num] == True:\\n                return count\\n            \\n            visited[num] = True\\n            count += 1\\n            \\n            #print(\\'num\\', num, present)\\n            \\n            if num + 1 in present:\\n                count = dfs(num + 1, count)\\n            \\n            if num - 1 in present:\\n                count = dfs(num - 1, count)\\n            \\n            \\n            #print(\\'count\\', num, count)\\n                \\n            return count\\n            \\n        \\n        for num in nums:\\n            max_run = max(max_run, dfs(num, 0))\\n            \\n            \\n            \\n        return max_run\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1256456,
                "title": "c-solution",
                "content": "```\\npublic class Solution {\\n    public int LongestConsecutive(int[] nums) {\\n        \\n        HashSet<int> set = new HashSet<int>(nums);\\n        \\n        int max = 0;\\n        foreach(var num in nums)\\n        {\\n            if(!set.Contains(num - 1))\\n            {\\n                int start = num;\\n                int len = 1;\\n                while(set.Contains(++start))\\n                    len++;\\n                \\n                max = Math.Max(max, len);\\n            }\\n        }\\n        \\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int LongestConsecutive(int[] nums) {\\n        \\n        HashSet<int> set = new HashSet<int>(nums);\\n        \\n        int max = 0;\\n        foreach(var num in nums)\\n        {\\n            if(!set.Contains(num - 1))\\n            {\\n                int start = num;\\n                int len = 1;\\n                while(set.Contains(++start))\\n                    len++;\\n                \\n                max = Math.Max(max, len);\\n            }\\n        }\\n        \\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1225184,
                "title": "using-unordered-set-c-step-wise",
                "content": "Step 1: Store all the elements of the given array in an unordered_set\\nStep 2: Traverse the given array\\nObservation: \\n---> any element in the array can only be starting element of the longest consecutive sequence if  value of element -1 is not present in the given array \\neg:\\n[ 1, 3, 6, 0, 4]\\nhere 1 can never be the starting element of the longest consecutive sequence because whatever the length of sequence starting with 1 be  element 0 will always increase the length  by 1\\n\\nSimilarly 4 can never be starting as 3 is present \\n\\n\\nStep 3: Now while traversing the given array check if the current element - 1 is present in the unordered_ set of not \\n------------> if it is present then continue\\n----------->  else keep increasing the value of the current element while it is not found in the unordered_set and also increase the length\\n```\\n\\nclass Solution {\\npublic:\\n    int longestConsecutive(vector<int>& nums) {\\n        unordered_set<int>s;\\n        for(auto child:nums)s.insert(child);\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++){\\n            int len=0;\\n            int val=nums[i]-1;\\n            if(s.find(val)!=s.end()){\\n                continue;\\n            }\\n            else {\\n                while(s.find(nums[i]++)!=s.end()){\\n                    len++;\\n                }\\n                ans=max(ans,len);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int longestConsecutive(vector<int>& nums) {\\n        unordered_set<int>s;\\n        for(auto child:nums)s.insert(child);\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++){\\n            int len=0;\\n            int val=nums[i]-1;\\n            if(s.find(val)!=s.end()){\\n                continue;\\n            }\\n            else {\\n                while(s.find(nums[i]++)!=s.end()){\\n                    len++;\\n                }\\n                ans=max(ans,len);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 916521,
                "title": "python-o-n-four-different-solutions-hash-map-union-find-array-set",
                "content": "# hashmap\\n\\nuse hashmap to keep track of a number\\'s range, [left .. right]\\n\\n```\\nclass Solution:\\n    def longestConsecutive(self, nums: List[int]) -> int:\\n        G = {}  # int -> [left, right]\\n        res = 0\\n        for k in nums:\\n            if k in G: continue\\n            G[k] = [k, k]\\n            if k - 1 in G:  # left neighbor\\n                lst = G[k - 1]\\n                lst[1] = G[k][1]  # expand right\\n                G[k] = G[lst[1]] = lst  # update reference\\n            if k + 1 in G:  # right neighbor\\n                lst = G[k + 1]\\n                lst[0] = G[k][0]  # expand left\\n                G[k] = G[lst[0]] = lst  # update reference\\n            left, right = G[k]\\n            res = max(res, right - left + 1)\\n        return res\\n```\\n\\n# array\\n\\nuse a NEXT array to chain continuous numbers\\' index\\n\\n```\\nclass Solution:\\n    def longestConsecutive(self, nums: List[int]) -> int:\\n        G = {d:i for i, d in enumerate(nums)}  # reverse index\\n        NEXT = [G[d+1] if (d+1) in G else -1 for _, d in enumerate(nums)]\\n        \\n        def dfs(i):\\n            if NEXT[i] < 0: return abs(NEXT[i])\\n            count = 1 + dfs(NEXT[i])\\n            NEXT[i] = -count  # neg as visited\\n            return count\\n        \\n        return max([dfs(i) for i in range(len(nums))], default=0)\\n```\\n\\n# union find\\n\\n```\\nclass UF:\\n    def __init__(self):\\n        self.P = {}  # parent\\n        self.S = {}  # size\\n    \\n    def find(self, x):\\n        if self.P[x] != x:\\n            self.P[x] = self.find(self.P[x])\\n        return self.P[x]\\n    \\n    def union(self, x, y):\\n        rx = self.find(x)\\n        ry = self.find(y)\\n        if rx != ry:\\n            self.P[rx] = ry\\n            self.S[ry] += self.S[rx]\\n        \\n    def add(self, x):\\n        if x in self.P: return\\n        self.P[x] = x\\n        self.S[x] = 1\\n        if x - 1 in self.P:\\n            self.union(x, x - 1)\\n        if x + 1 in self.P:\\n            self.union(x, x + 1)\\n    \\n    def maxSize(self):\\n        return max(self.S.values(), default=0)\\n\\n\\nclass Solution:\\n    def longestConsecutive(self, nums: List[int]) -> int:\\n        uf = UF()\\n        for x in nums:\\n            uf.add(x)\\n        return uf.maxSize()\\n```\\n\\n# set\\n\\ntrigger search when it hits the left border of a range\\n\\n```\\nclass Solution:\\n    def longestConsecutive(self, nums: List[int]) -> int:\\n        MAX = 0\\n        aset = set(nums)\\n        for x in nums:\\n            if x - 1 in aset: continue\\n            # x is a left border of a range\\n            count = 0\\n            while x in aset:\\n                count += 1\\n                x += 1\\n            MAX = max(MAX, count)\\n        return MAX\\n```",
                "solutionTags": [
                    "Python",
                    "Array",
                    "Union Find",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution:\\n    def longestConsecutive(self, nums: List[int]) -> int:\\n        G = {}  # int -> [left, right]\\n        res = 0\\n        for k in nums:\\n            if k in G: continue\\n            G[k] = [k, k]\\n            if k - 1 in G:  # left neighbor\\n                lst = G[k - 1]\\n                lst[1] = G[k][1]  # expand right\\n                G[k] = G[lst[1]] = lst  # update reference\\n            if k + 1 in G:  # right neighbor\\n                lst = G[k + 1]\\n                lst[0] = G[k][0]  # expand left\\n                G[k] = G[lst[0]] = lst  # update reference\\n            left, right = G[k]\\n            res = max(res, right - left + 1)\\n        return res\\n```\n```\\nclass Solution:\\n    def longestConsecutive(self, nums: List[int]) -> int:\\n        G = {d:i for i, d in enumerate(nums)}  # reverse index\\n        NEXT = [G[d+1] if (d+1) in G else -1 for _, d in enumerate(nums)]\\n        \\n        def dfs(i):\\n            if NEXT[i] < 0: return abs(NEXT[i])\\n            count = 1 + dfs(NEXT[i])\\n            NEXT[i] = -count  # neg as visited\\n            return count\\n        \\n        return max([dfs(i) for i in range(len(nums))], default=0)\\n```\n```\\nclass UF:\\n    def __init__(self):\\n        self.P = {}  # parent\\n        self.S = {}  # size\\n    \\n    def find(self, x):\\n        if self.P[x] != x:\\n            self.P[x] = self.find(self.P[x])\\n        return self.P[x]\\n    \\n    def union(self, x, y):\\n        rx = self.find(x)\\n        ry = self.find(y)\\n        if rx != ry:\\n            self.P[rx] = ry\\n            self.S[ry] += self.S[rx]\\n        \\n    def add(self, x):\\n        if x in self.P: return\\n        self.P[x] = x\\n        self.S[x] = 1\\n        if x - 1 in self.P:\\n            self.union(x, x - 1)\\n        if x + 1 in self.P:\\n            self.union(x, x + 1)\\n    \\n    def maxSize(self):\\n        return max(self.S.values(), default=0)\\n\\n\\nclass Solution:\\n    def longestConsecutive(self, nums: List[int]) -> int:\\n        uf = UF()\\n        for x in nums:\\n            uf.add(x)\\n        return uf.maxSize()\\n```\n```\\nclass Solution:\\n    def longestConsecutive(self, nums: List[int]) -> int:\\n        MAX = 0\\n        aset = set(nums)\\n        for x in nums:\\n            if x - 1 in aset: continue\\n            # x is a left border of a range\\n            count = 0\\n            while x in aset:\\n                count += 1\\n                x += 1\\n            MAX = max(MAX, count)\\n        return MAX\\n```",
                "codeTag": "Java"
            },
            {
                "id": 654035,
                "title": "python-union-find-template",
                "content": "Just a union-find template for those who are interested. The algorithm consists of the following steps:\\n1. Graph Constructions:\\n\\tWe iterate through the list and add every number as a separate node in our graph.\\n2. Group Adjacent Nodes:\\n\\tSince we are trying to connect adjacent numbers, we just check whether the next greater number of the current number is in the list, if so, add a edge connecting them (i.e. union).\\n3. Sum Up Number of Nodes in Each Group.\\n\\tSince the nodes are now connected, we again iterate through all the nodes and find their roots, and use a counter to keep track of the number of children of a given root. (i.e. find)\\n4. Finally, knowing all the connected components in our graph and the length of each component, the question askes for the longest component, so we return the max count.\\n\\nNote I iterated the list four times so the algorithm so it\\'s not that fast (72 ms) but it\\'s still O(N). The good thing about using any template is that you don\\'t need to think too much, it generealizes to other problems well.\\n\\nI learned union-find just last night from this guy\\'s lecture (in Chinese) https://www.youtube.com/watch?v=YKE4Vd1ysPIso so I am sure this algorithm can be improved. But I would reccmonde anyone who\\'s not familiar with this algorithm to learn it as it can be applied to many other questions.\\n```\\nclass Solution:\\n    def longestConsecutive(self, nums: List[int]) -> int:\\n        if not nums:\\n            return 0\\n        \\n        def union(node1, node2):\\n            root1, root2 = find(node1), find(node2)\\n            if root1 != root2:\\n                parent[root1] = root2\\n        \\n        def find(node):\\n            if parent[node] == -1:\\n                return node\\n            parent[node] = find(parent[node])\\n            return parent[node]\\n        \\n        node_id = 0\\n        nodes = {}\\n        parent  = []\\n        for num in nums:\\n            parent.append(-1)\\n            nodes[num] = node_id\\n            node_id += 1\\n        \\n        for num in nums:\\n            if num + 1 in nodes:\\n                union(nodes[num], nodes[num + 1])\\n        \\n        counter = collections.defaultdict(int)\\n        for i in range(len(parent)):\\n            root = find(i)\\n            counter[root] += 1\\n        \\n        return max(counter.values())\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def longestConsecutive(self, nums: List[int]) -> int:\\n        if not nums:\\n            return 0\\n        \\n        def union(node1, node2):\\n            root1, root2 = find(node1), find(node2)\\n            if root1 != root2:\\n                parent[root1] = root2\\n        \\n        def find(node):\\n            if parent[node] == -1:\\n                return node\\n            parent[node] = find(parent[node])\\n            return parent[node]\\n        \\n        node_id = 0\\n        nodes = {}\\n        parent  = []\\n        for num in nums:\\n            parent.append(-1)\\n            nodes[num] = node_id\\n            node_id += 1\\n        \\n        for num in nums:\\n            if num + 1 in nodes:\\n                union(nodes[num], nodes[num + 1])\\n        \\n        counter = collections.defaultdict(int)\\n        for i in range(len(parent)):\\n            root = find(i)\\n            counter[root] += 1\\n        \\n        return max(counter.values())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 355781,
                "title": "java-7ms-o-n-solution",
                "content": "```\\nclass Solution {\\n    public int longestConsecutive(int[] nums) {\\n        Map<Integer, Integer> counts = new HashMap<>();\\n        int max = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            if (counts.containsKey(nums[i])) continue;\\n            // |---count down ---| nums[i] |--- count up ---|\\n            int countDown = counts.getOrDefault(nums[i] - 1, 0);\\n            int countUp = counts.getOrDefault(nums[i] + 1, 0);\\n            int count = countUp + countDown + 1;\\n\\t\\t\\t// Now update count for the current number.\\n            counts.put(nums[i], count);\\n\\t\\t\\t// And on each edge. No need to update in between as we skip those elements anyways and they don\\'t matter.\\n            counts.put(nums[i] + countUp, count);\\n            counts.put(nums[i] - countDown, count);\\n            if (count > max) {\\n                max = count;\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int longestConsecutive(int[] nums) {\\n        Map<Integer, Integer> counts = new HashMap<>();\\n        int max = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            if (counts.containsKey(nums[i])) continue;\\n            // |---count down ---| nums[i] |--- count up ---|\\n            int countDown = counts.getOrDefault(nums[i] - 1, 0);\\n            int countUp = counts.getOrDefault(nums[i] + 1, 0);\\n            int count = countUp + countDown + 1;\\n\\t\\t\\t// Now update count for the current number.\\n            counts.put(nums[i], count);\\n\\t\\t\\t// And on each edge. No need to update in between as we skip those elements anyways and they don\\'t matter.\\n            counts.put(nums[i] + countUp, count);\\n            counts.put(nums[i] - countDown, count);\\n            if (count > max) {\\n                max = count;\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 325056,
                "title": "javascript-union-find-with-rank",
                "content": "Union Find Intuition: https://www.quora.com/What-is-an-intuitive-explanation-of-union-find\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar longestConsecutive = function(nums) {\\n    if (nums.length===0) return 0;\\n    let parent = {};\\n    let size = {};\\n\\n    const UnionFind = function(nums){\\n        for (let num of nums){\\n            parent[num] = num;\\n            size[num] = 1;\\n        }\\n\\n        this.find = (n) => {\\n            if (parent[n] === n) return n;\\n            parent[n] = this.find(parent[n]);\\n            return parent[n];\\n        }\\n\\n        this.union = (m,n) => {\\n            const rootM = this.find(m);\\n            const rootN = this.find(n);\\n\\n            // rank\\n            if (rootM === rootN) return;\\n            if (size[rootM] < size[rootN]){\\n                size[rootN] += size[rootM];\\n                parent[rootM] = rootN;\\n            }else{\\n                size[rootM] += size[rootN];\\n                parent[rootN] = rootM;\\n            }\\n        }\\n    }\\n\\n    const uf = new UnionFind(nums);\\n\\n    for (let num of nums){\\n        if (num-1 in parent){\\n            uf.union(num-1, num);\\n        }\\n    }\\n\\n    let max = 0;\\n    for (let num of nums){\\n        max = Math.max(max, size[num]);\\n    }\\n\\n    return max;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Union Find"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar longestConsecutive = function(nums) {\\n    if (nums.length===0) return 0;\\n    let parent = {};\\n    let size = {};\\n\\n    const UnionFind = function(nums){\\n        for (let num of nums){\\n            parent[num] = num;\\n            size[num] = 1;\\n        }\\n\\n        this.find = (n) => {\\n            if (parent[n] === n) return n;\\n            parent[n] = this.find(parent[n]);\\n            return parent[n];\\n        }\\n\\n        this.union = (m,n) => {\\n            const rootM = this.find(m);\\n            const rootN = this.find(n);\\n\\n            // rank\\n            if (rootM === rootN) return;\\n            if (size[rootM] < size[rootN]){\\n                size[rootN] += size[rootM];\\n                parent[rootM] = rootN;\\n            }else{\\n                size[rootM] += size[rootN];\\n                parent[rootN] = rootM;\\n            }\\n        }\\n    }\\n\\n    const uf = new UnionFind(nums);\\n\\n    for (let num of nums){\\n        if (num-1 in parent){\\n            uf.union(num-1, num);\\n        }\\n    }\\n\\n    let max = 0;\\n    for (let num of nums){\\n        max = Math.max(max, size[num]);\\n    }\\n\\n    return max;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 41290,
                "title": "simple-java-solution-using-hashmap",
                "content": "    public class Solution {\\n        public int longestConsecutive(int[] nums) {\\n            if(nums == null || nums.length == 0)\\n                return 0;\\n            \\n            int longest = 1;\\n            HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();\\n            for (int i = 0;i < nums.length; i++)\\n                map.put(nums[i],nums[i] + 1);\\n        \\n            for(int j = 0; j < nums.length; j++){\\n                int current = 1;\\n                int key = nums[j];\\n                if (map.containsKey(key - 1))\\n                    continue;\\n                while (map.containsKey(map.get(key))){\\n                    current++;\\n                    key = map.get(key);\\n                }\\n                if (current > longest)\\n                    longest = current;\\n            }\\n            return longest;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public int longestConsecutive(int[] nums) {\\n            if(nums == null || nums.length == 0)\\n                return 0;\\n            \\n            int longest = 1;\\n            HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();\\n            for (int i = 0;i < nums.length; i++)\\n                map.put(nums[i],nums[i] + 1);\\n        \\n            for(int j = 0; j < nums.length; j++){\\n                int current = 1;\\n                int key = nums[j];\\n                if (map.containsKey(key - 1))\\n                    continue;\\n                while (map.containsKey(map.get(key))){\\n                    current++;\\n                    key = map.get(key);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 41324,
                "title": "java-straightforward-solution",
                "content": "> 1. Use a HashMap<Integer,Boolean>. Use every number in num[] as a key, mark them as not used.\\n> \\n> 2. For each number in the hashmap, if the number is not used, select it as the center to grow a sequence on number++ and number--\\n> directions. Mark used number as used.\\n> \\n> 3. After each growth, update the longestSoFar. \\n> \\n> 4. Return the longestSoFar.  \\n> \\n> 5. Since each number is used only once, the time complexity is O(n).\\n\\n    public class Solution {\\n        public int longestConsecutive(int[] num) {\\n            if(num.length<=1)\\n                return num.length;\\n            HashMap<Integer,Boolean> numberUsed=new HashMap<Integer,Boolean>();\\n            for(int i:num)\\n                numberUsed.put(i,false);\\n            int longestSoFar=1;\\n            for(int i:num)\\n            {\\n                if(numberUsed.get(i)==false)\\n                {\\n                    int localLongest=1;\\n                    int tmp=i+1;\\n                    numberUsed.put(i,true);\\n                    while(numberUsed.containsKey(tmp)&&numberUsed.get(tmp)==false)\\n                    {\\n                        localLongest+=1;\\n                        numberUsed.put(tmp,true);\\n                        tmp+=1;\\n                    }\\n                    tmp=i-1;\\n                    while(numberUsed.containsKey(tmp)&&numberUsed.get(tmp)==false)\\n                    {\\n                        localLongest+=1;\\n                        numberUsed.put(tmp,true);\\n                        tmp-=1;\\n                    }\\n                    longestSoFar=Math.max(longestSoFar,localLongest);\\n                }\\n            }\\n            return longestSoFar;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public int longestConsecutive(int[] num) {\\n            if(num.length<=1)\\n                return num.length;\\n            HashMap<Integer,Boolean> numberUsed=new HashMap<Integer,Boolean>();\\n            for(int i:num)\\n                numberUsed.put(i,false);\\n            int longestSoFar=1;\\n            for(int i:num)\\n            {\\n                if(numberUsed.get(i)==false)\\n                {\\n                    int localLongest=1;\\n                    int tmp=i+1;\\n                    numberUsed.put(i,true);\\n                    while(numberUsed.containsKey(tmp)&&numberUsed.get(tmp)==false)\\n                    {\\n                        localLongest+=1;\\n                        numberUsed.put(tmp,true);\\n                        tmp+=1;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 3761166,
                "title": "java-simple-solution-runtime-31-ms-beats-91",
                "content": "# Intuition\\n    Given an unsorted array of integers nums, return the length \\n    of the longest consecutive elements sequence.\\n\\n    consecutive elements is mean longest Continuous number\\n    ex : (1,2,3,4,7,8)  1,2,3,4  = 4\\n        (0,1,6,7,8)  6,7,8  = 3\\n\\n# Approach\\n    test case : [1,8,7,6,1,2];\\n\\n    we remove all duplicate elements in array (nums).\\n    with the help of set (HashSet<>()). \\n    A Set is not allow to add\\n    duplicate elements (set.add()).\\n```\\nfor(int val : nums) set.add(val);\\n```\\n    now set will be [1,8,7,6,2];\\n\\n    the valid answer{\\n        1,2    size = 2;\\n        6,7,8  size = 3;\\n        return 3 (it is longest consecutive elements);\\n    }\\n\\n    in the set , a starting point is 1,6 (1 to 2 , 6 to 8).\\n\\n    A starting point means the set not have previous element.\\n        ex 1 : 1 (set is not have 0) so it is starting point;\\n        ex 2 : 6 (set is not have 5) so it is also starting point;\\n        ex 3 : 7 (set is have 6 it is previous element of 7) so it \\n        is not starting point;\\n\\n    if (set) contains  (i-1 means previous element) we continue,\\n    bacause now we are in middel or end , we no need to travel \\n    left to right.\\n\\n    if it is not contain previous element, then it\\'s a starting point\\n    we start while loop increment order.\\n\\n    if (i to travel it is contains in set) set remove(i) it\\'s \\n    return  true or false\\n        true means removed(i) and it contain so increment (total).\\n        false means it\\'s not removed and not contain.\\n\\n\\n\\n# Complexity\\n- Time complexity O(nlog(n)):\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity O(n):\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int longestConsecutive(int[] nums) {\\n        int max = 0;\\n        Set<Integer> set = new HashSet<>();\\n        for(int val : nums) set.add(val);\\n        for(int i : nums){\\n            if(set.contains(i-1)) continue;\\n            int total = 0;\\n            while(set.remove(i++)){\\n                total++;\\n            }\\n            if(total > max) max = total;\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Ordered Set"
                ],
                "code": "```\\nfor(int val : nums) set.add(val);\\n```\n```\\nclass Solution {\\n    public int longestConsecutive(int[] nums) {\\n        int max = 0;\\n        Set<Integer> set = new HashSet<>();\\n        for(int val : nums) set.add(val);\\n        for(int i : nums){\\n            if(set.contains(i-1)) continue;\\n            int total = 0;\\n            while(set.remove(i++)){\\n                total++;\\n            }\\n            if(total > max) max = total;\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3323156,
                "title": "easy-solution-optimised-intuitive-o-n-approach-c-soln",
                "content": "**intuition**\\n\\n->BRUTE FORCE :\\n  we can simply sort the array and then apply sliding window technique to find the longest consequetive sequence\\n  \\n  TIme Complexity : O(nlogn) + O(n)\\n  \\n  ->Optimised Approach : \\n   1. insert all the nums elements in a set, now the set will contain all the unique elements in the array.\\n   2. now traverse the array nums.\\n   3. if there is any smaller elemets in the set from num[i], then continue because for the longest sequence we will have to start\\n      from the smallest element of the given sequence.\\n  4. if there is no any smaller element than nums[i] in the set, then starting from current element maitain a while loop until the           next element is not present in the set. Now update the ans variable.\\n  5. finally we get the answer.\\n  \\n  Time Complexity : O(n) + O(2n)\\n  Space Complexity : O(n)\\n\\n```\\nclass Solution {\\npublic:\\n    int longestConsecutive(vector<int>& nums) {\\n        int n=nums.size();\\n        unordered_set<int> st;\\n        for(auto &x : nums)\\n            st.insert(x);\\n         int ans=0;\\n        for(int i=0;i<n;i++){\\n            if(st.find(nums[i]-1)==st.end()){\\n                int num=nums[i];\\n                while(st.find(num)!=st.end()){\\n                    num++;\\n                }\\n                ans=max(ans, num-nums[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestConsecutive(vector<int>& nums) {\\n        int n=nums.size();\\n        unordered_set<int> st;\\n        for(auto &x : nums)\\n            st.insert(x);\\n         int ans=0;\\n        for(int i=0;i<n;i++){\\n            if(st.find(nums[i]-1)==st.end()){\\n                int num=nums[i];\\n                while(st.find(num)!=st.end()){\\n                    num++;\\n                }\\n                ans=max(ans, num-nums[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3274476,
                "title": "java-solution-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFor element check if there exist its consecitive numbers are present or not and count.max count will be our longest consecutive length.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n Try to use data structure which holes distinct elements like set\\nand traverse the array and check for every element it consecitive present or not .If present again increment the value and check in the set until u not found another consecutive.while incrementing count number of consecutives are there and update the maximum consecutive. \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n# Code\\n```\\nclass Solution {\\n    public int longestConsecutive(int[] nums) {\\n        if(nums == null) return 0;\\n        Set<Integer> set = new HashSet<>();\\n        for(int x : nums) set.add(x);\\n        int max = 0;\\n        for(int x : nums) {\\n            int count = 0;\\n            if(!set.contains(x-1)) {\\n                x++;\\n                while(set.contains(x)){\\n                    count++;\\n                    x++;\\n                }\\n                max = Math.max(count+1,max);\\n            }\\n            \\n        }\\n        return max;\\n    }\\n}\\n\\n//Please UpVote If You Like It!!\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int longestConsecutive(int[] nums) {\\n        if(nums == null) return 0;\\n        Set<Integer> set = new HashSet<>();\\n        for(int x : nums) set.add(x);\\n        int max = 0;\\n        for(int x : nums) {\\n            int count = 0;\\n            if(!set.contains(x-1)) {\\n                x++;\\n                while(set.contains(x)){\\n                    count++;\\n                    x++;\\n                }\\n                max = Math.max(count+1,max);\\n            }\\n            \\n        }\\n        return max;\\n    }\\n}\\n\\n//Please UpVote If You Like It!!\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2784784,
                "title": "java-o-n-easy-solution-with-comments",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe\\'ll use a HashMap and perform following steps -\\n1. Assume that each element in the ```nums``` is a starting point for a subsequence by mapping a ```true``` for each element.\\n2. Then, eliminate those elements which can\\'t be a starting point by mapping ```false```.\\n3. Now, as we have all the starting points, get the longest consecutive subsequnce.\\n\\n# Complexity\\n- Time complexity: **O(n)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(n)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$Kindly$$ $$upvote$$ $$if$$ $$you$$ $$understood$$ $$the$$ $$solution.. :)$$\\n# Code\\n```\\nclass Solution {\\n    public int longestConsecutive(int[] nums) {\\n        \\n        //To handle emty nums array\\n        if(nums.length == 0) return 0;\\n\\n        HashMap<Integer, Boolean> map = new HashMap<>();\\n\\n        /* \\n        sval = starting value for the longest consecutive subsequence\\n        maxLength = max length of consecutive subsequence\\n        tempLength = temperory length of consecutive subsequence\\n        */\\n        int sval = nums[0], maxLength = 1, tempLength = 1;\\n        \\n        // This for loop will put a true for each element in the hashmap\\n        for(Integer val : nums) map.put(val, true);\\n\\n        // This for loop will check if each element can be a potential starting point\\n        for(Integer val : nums){\\n            if(map.containsKey(val-1)) map.put(val, false);\\n        }\\n\\n        // This for loop calculates the longest consecutive subsequence\\n        for(Integer val : nums){\\n            if(map.get(val)){\\n                int temp = val;\\n                while(map.containsKey(++temp)) tempLength++;\\n                if(tempLength > maxLength){\\n                    sval = val;\\n                    maxLength = tempLength;\\n                }\\n                tempLength = 1;\\n            }\\n        }\\n        return maxLength;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```nums```\n```true```\n```false```\n```\\nclass Solution {\\n    public int longestConsecutive(int[] nums) {\\n        \\n        //To handle emty nums array\\n        if(nums.length == 0) return 0;\\n\\n        HashMap<Integer, Boolean> map = new HashMap<>();\\n\\n        /* \\n        sval = starting value for the longest consecutive subsequence\\n        maxLength = max length of consecutive subsequence\\n        tempLength = temperory length of consecutive subsequence\\n        */\\n        int sval = nums[0], maxLength = 1, tempLength = 1;\\n        \\n        // This for loop will put a true for each element in the hashmap\\n        for(Integer val : nums) map.put(val, true);\\n\\n        // This for loop will check if each element can be a potential starting point\\n        for(Integer val : nums){\\n            if(map.containsKey(val-1)) map.put(val, false);\\n        }\\n\\n        // This for loop calculates the longest consecutive subsequence\\n        for(Integer val : nums){\\n            if(map.get(val)){\\n                int temp = val;\\n                while(map.containsKey(++temp)) tempLength++;\\n                if(tempLength > maxLength){\\n                    sval = val;\\n                    maxLength = tempLength;\\n                }\\n                tempLength = 1;\\n            }\\n        }\\n        return maxLength;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2669995,
                "title": "c-set-o-n-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestConsecutive(vector<int>& arr) {\\n     int n = arr.size();\\n     unordered_set<int> st;\\n     int res  = 0;\\n     for(int i=0;i<n;i++){\\n         st.insert(arr[i]);\\n     }\\n     \\n     for(int i=0;i<n;i++)\\n     {\\n         if(st.find(arr[i]-1) == st.end()){\\n             int curr = 1;\\n             while(st.find(curr+arr[i]) != st.end()){\\n                 curr++;\\n             }\\n             res = max(res,curr);\\n         }\\n     }\\n     return res;\\n    }\\n};\\n```\\n**Don\\'t forget to Upvote the post, if it\\'s been any help to you**",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestConsecutive(vector<int>& arr) {\\n     int n = arr.size();\\n     unordered_set<int> st;\\n     int res  = 0;\\n     for(int i=0;i<n;i++){\\n         st.insert(arr[i]);\\n     }\\n     \\n     for(int i=0;i<n;i++)\\n     {\\n         if(st.find(arr[i]-1) == st.end()){\\n             int curr = 1;\\n             while(st.find(curr+arr[i]) != st.end()){\\n                 curr++;\\n             }\\n             res = max(res,curr);\\n         }\\n     }\\n     return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2265067,
                "title": "python-o-n-solution-using-set",
                "content": "1) Visualize the problem on a number line after converting the array into a set\\n2) Notice how the starting number of every sequence on a number line doesn\\'t have a neighbor to the left of it? \\n3) Set the length = 1 at the start of every sequence and iterate through instances of n+length using a while loop and at the end of the for loop iteration, set longest = max(length, maxlength)\\n\\n**Time Complexity: O(n)**\\n**Space Complexity: O(n)** \\n\\n\\n![image](https://assets.leetcode.com/users/images/f1595d46-8c18-4d4f-a0a8-3d0dd73b14f6_1657482108.3899848.png)\\n\\n```\\nclass Solution:\\n    def longestConsecutive(self, nums: List[int]) -> int:\\n        seen = set(nums)\\n        longest = 0\\n        \\n        for n in seen:\\n            if (n-1) not in seen:\\n                length = 1\\n                while (n+length) in seen:\\n                    length += 1\\n                longest = max(length, longest)\\n        \\n        return longest\\n```\\n\\n*Shoutout to Neetcode for this.*",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution:\\n    def longestConsecutive(self, nums: List[int]) -> int:\\n        seen = set(nums)\\n        longest = 0\\n        \\n        for n in seen:\\n            if (n-1) not in seen:\\n                length = 1\\n                while (n+length) in seen:\\n                    length += 1\\n                longest = max(length, longest)\\n        \\n        return longest\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2240495,
                "title": "longest-consecutive-sequence-java-solution-using-hashset",
                "content": "**Approach:**\\n* Take a HashSet(hs) and store all the elements of the array in it.\\n* Take a variable maxi=0.\\n* Iterate through the nums array from i to nums.length-1\\n\\t\\t\\t1. \\ttake another variable num = nums[i]\\n\\t\\t\\t2. \\tCheck if the set contains num-1\\n\\t\\t\\t3. \\tIf it doesnt contain num-1\\n\\t\\t\\t\\t\\t\\t* \\tTake c = 1\\n\\t\\t\\t\\t\\t\\t* \\tKeep checking if the set contains num+1\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t1. \\tIf yes, do c++ and num++\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t2. \\telse break out from loop\\n\\t\\t\\t\\t\\t\\t* \\tdo maxi = Math.max(maxi,c)\\n\\t\\t\\t4.  Return maxi.\\n![image](https://assets.leetcode.com/users/images/66bebc92-d942-4db6-9701-98c50270e1c7_1657010537.8777153.jpeg)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n```\\nclass Solution {\\n    public int longestConsecutive(int[] nums) {\\n        HashSet<Integer> hs = new HashSet<>();\\n        for(int i:nums)\\n            hs.add(i);\\n        int maxi=0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            int num = nums[i];\\n            if(!hs.contains(num-1))\\n            {\\n                int c=1;\\n                while(hs.contains(num+1))                                                                                                                                                                    \\n                {\\n                    c++;\\n                    num++;\\n                }\\n                maxi=Math.max(maxi,c);\\n            }\\n        }\\n        return maxi;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int longestConsecutive(int[] nums) {\\n        HashSet<Integer> hs = new HashSet<>();\\n        for(int i:nums)\\n            hs.add(i);\\n        int maxi=0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            int num = nums[i];\\n            if(!hs.contains(num-1))\\n            {\\n                int c=1;\\n                while(hs.contains(num+1))                                                                                                                                                                    \\n                {\\n                    c++;\\n                    num++;\\n                }\\n                maxi=Math.max(maxi,c);\\n            }\\n        }\\n        return maxi;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2232529,
                "title": "c-union-find",
                "content": "``` \\nclass Solution {  \\n    unordered_map<int,int>par; \\n    int findpar(int n){  \\n        if(par.count(n)==0) return n ; \\n        return par[n]=findpar(par[n]);\\n    }\\n    void Union(int a,int b){  \\n        a=findpar(a); \\n        b=findpar(b); \\n        par[b]=a;\\n    }\\npublic:\\n    int longestConsecutive(vector<int>& nums) {\\n        unordered_map<int,int>mp; \\n        int ans=0;\\n        for(int i:nums){ \\n            int curr=findpar(i);\\n            if(mp.count(curr)) continue; \\n            int prev=findpar(i-1);\\n            int next=findpar(i+1);   \\n            mp[curr]=1;\\n            if(mp.count(prev)){ \\n                mp[curr]+=mp[prev];\\n                Union(curr,prev);       \\n            } \\n            if(mp.count(next)){ \\n                mp[curr]+=mp[next]; \\n                Union(curr,next); \\n            }      \\n            ans=max(ans,mp[curr]);    \\n        } \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Union Find"
                ],
                "code": "``` \\nclass Solution {  \\n    unordered_map<int,int>par; \\n    int findpar(int n){  \\n        if(par.count(n)==0) return n ; \\n        return par[n]=findpar(par[n]);\\n    }\\n    void Union(int a,int b){  \\n        a=findpar(a); \\n        b=findpar(b); \\n        par[b]=a;\\n    }\\npublic:\\n    int longestConsecutive(vector<int>& nums) {\\n        unordered_map<int,int>mp; \\n        int ans=0;\\n        for(int i:nums){ \\n            int curr=findpar(i);\\n            if(mp.count(curr)) continue; \\n            int prev=findpar(i-1);\\n            int next=findpar(i+1);   \\n            mp[curr]=1;\\n            if(mp.count(prev)){ \\n                mp[curr]+=mp[prev];\\n                Union(curr,prev);       \\n            } \\n            if(mp.count(next)){ \\n                mp[curr]+=mp[next]; \\n                Union(curr,next); \\n            }      \\n            ans=max(ans,mp[curr]);    \\n        } \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2212153,
                "title": "striversdesheet-brute-optimal-c",
                "content": "**BRUTE FORCE**\\nSort krke check krlenege \\nT.C=O(N logN)\\nSC.=O(1)\\n\\n```\\nclass Solution {\\npublic:\\n   int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        int count=1,maxx=1;\\n        if(n==1) return 1;\\n        if(n==0) return 0;\\n        for(int i=0;i<n-1;i++)\\n        {            \\n            if(nums[i]==nums[i+1]-1)\\n            {\\n                count++;\\n                maxx=max(maxx,count);\\n            }\\n            else if(nums[i]==nums[i+1])\\n                continue;\\n            else\\n                count=1;\\n        }\\n        return maxx;\\n    }\\n};\\n```\\n\\n**OPTIMAL**\\n\\nVector ko set me daalenge , then check for element if it exists in set or not,\\nif exists check for another, else increse the number until it is not found in the set.\\n.TC=O(N) + O(N) +O(N) \\nS.C=O(N)\\n\\n```\\nclass Solution {\\npublic:\\n    int longestConsecutive(vector<int>& nums) {\\n        unordered_set<int> st;\\n        for(int i=0;i<nums.size();i++){\\n            st.insert(nums[i]);\\n        }\\n        int longest=0;\\n        for(auto it:nums){\\n            if(!st.count(it-1)){\\n                int currentNum=it;\\n                int currentlong=1;\\n                while(st.count(currentNum+1)){\\n                    currentlong++;\\n                    currentNum++;\\n                }\\n                 longest=max(longest , currentlong);\\n            }\\n           \\n        }\\n        return longest;\\n    }\\n};\\n```\\n\\nDo Upvote if you find it useful.\\n\\n",
                "solutionTags": [
                    "C++",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        int count=1,maxx=1;\\n        if(n==1) return 1;\\n        if(n==0) return 0;\\n        for(int i=0;i<n-1;i++)\\n        {            \\n            if(nums[i]==nums[i+1]-1)\\n            {\\n                count++;\\n                maxx=max(maxx,count);\\n            }\\n            else if(nums[i]==nums[i+1])\\n                continue;\\n            else\\n                count=1;\\n        }\\n        return maxx;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int longestConsecutive(vector<int>& nums) {\\n        unordered_set<int> st;\\n        for(int i=0;i<nums.size();i++){\\n            st.insert(nums[i]);\\n        }\\n        int longest=0;\\n        for(auto it:nums){\\n            if(!st.count(it-1)){\\n                int currentNum=it;\\n                int currentlong=1;\\n                while(st.count(currentNum+1)){\\n                    currentlong++;\\n                    currentNum++;\\n                }\\n                 longest=max(longest , currentlong);\\n            }\\n           \\n        }\\n        return longest;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2068621,
                "title": "o-n-solution-using-sets-in-cpp",
                "content": "We traverse through the array and insert all the elements in a set. We then traverse again through the array and see if the element corresponding to (element-1) is already present in the set. \\nIf it is present, it implies that the current element is not beginning element of a sequence and we simply ignore it.\\nIf it is not present, it implies that the current element is a beginning element of a new sequence.\\nHence we count the number of elements in set, starting from current element and increment it by 1.\\n\\n**Pls upvote if you found it helpful**\\n\\n```\\nclass Solution {\\npublic:\\n    int longestConsecutive(vector<int>& nums) {\\n        unordered_set<int> st;\\n        for(int i:nums) st.insert(i);\\n        int res=0;\\n        for(int i=0;i<nums.size();i++) {\\n            if(st.count(nums[i]-1)==0) {\\n                int curr=1;\\n                while(st.count(nums[i]+curr)>0) curr++;\\n                res=max(res, curr);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestConsecutive(vector<int>& nums) {\\n        unordered_set<int> st;\\n        for(int i:nums) st.insert(i);\\n        int res=0;\\n        for(int i=0;i<nums.size();i++) {\\n            if(st.count(nums[i]-1)==0) {\\n                int curr=1;\\n                while(st.count(nums[i]+curr)>0) curr++;\\n                res=max(res, curr);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1979994,
                "title": "python-union-find-the-most-standard-template-for-union-find",
                "content": "```\\n# We have 3 method to write Union Find. \\n# 1, by Brute force,\\n# 2, by size,\\n# 3, by rank (depth).\\n```\\nThe template of them is below.\\n```\\n# 1, written by brute force:\\nclass UF:\\n\\n\\tdef __init__(self, n):\\n\\t\\tself.parent = {i: i for i in range(n)}\\n\\t\\n\\tdef find(self, x):\\n\\t\\tif x != self.parent[x]:\\n\\t\\t\\tself.parent[x] = self.find(self.parent[x])\\n\\t\\treturn self.parent[x]\\n\\t\\n\\tdef union(self, x, y):\\n\\t\\tself.parent[self.find(x)] = self.find(y)\\n```\\n```\\n# 2, written by size:\\nclass UF:\\n\\n\\tdef __init__(self, n):\\n\\t\\tself.parent = {i: i for i in range(n)}\\n\\t\\tself.size = {i: 1 for i in range(n)}\\n\\t\\n\\tdef find(self, x):\\n\\t\\tif x != self.parent[x]:\\n\\t\\t\\tself.parent[x] = self.find(self.parent[x])\\n\\t\\treturn self.parent[x]\\n\\t\\n\\tdef union(self, x, y):\\n\\t\\trootX = self.find(x)\\n\\t\\trootY = self.find(y)\\n\\t\\tif rootX == rootY:\\n\\t\\t\\treturn\\n\\t\\t\\n\\t\\tif self.size[rootX] <= self.size[rootY]:\\n\\t\\t\\tself.parent[rootX] = rootY\\n\\t\\t\\tself.size[rootY] += self.size[rootX]\\n\\t\\t\\n\\t\\telse:\\n\\t\\t\\tself.parent[rootY] = rootX\\n\\t\\t\\tself.size[rootX] += self.size[rootY]\\n```\\n```\\n# 3, written by rank (depth):\\nclass UF:\\n\\n\\tdef __init__(self, n):\\n\\t\\tself.parent = {i: i for i in range(n)}\\n\\t\\tself.rank = {i: 1 for i in range(n)}\\n\\t\\n\\tdef find(self, x):\\n\\t\\tif x != self.parent[x]:\\n\\t\\t\\tself.parent[x] = self.find(self.parent[x])\\n\\t\\treturn self.parent[x]\\n\\t\\n\\tdef union(self, x, y):\\n\\t\\trootX = self.find(x)\\n\\t\\trootY = self.find(y)\\n\\t\\tif rootX == rootY:\\n\\t\\t\\treturn\\n\\t\\t\\n\\t\\tif self.rank[rootX] < self.rank[rootY]:\\n\\t\\t\\tself.parent[rootX] = rootY\\n\\t\\t\\n\\t\\telif self.rank[rootY] < self.rank[rootX]:\\n\\t\\t\\tself.parent[rootY] = rootX\\n\\t\\t\\n\\t\\telse:\\n\\t\\t\\tself.parent[rootX] = rootY\\n\\t\\t\\tself.rank[rootY] += 1\\n```\\n\\n```\\n# The answer below is the type written by size.\\n# We have another 2 writing methods, that is, written by Brute force and written by rank (depth).\\n# Size is the common one that we usually write, but it can not deal with some particular cases.\\n# For example, \\n\"\"\"\\n        1            4\\n2   3   0              5\\n                         6\\n                   \\nWe can see the right tree has depth 3, left has depth 2. So\\nit is better to combine in this way, that is, put left tree into right tree, then the depth is still 3.\\n\\n            4\\n\\t      1    5\\n 2    3   0      6\\n\\t \\nBut if we write by size, since left size is 4, right size is 3, left > right, \\nso we put right tree into left, then the left tree increase the depth, which is not good.\\n\\n            1\\n\\t2   3   0   4\\n                   5\\n\\t\\t\\t\\t      6\\n\\nBut writing Union Find in size way will give you the benefit when the problem wants you to count\\nthe total number of nodes in the tree. Usually we write in the way of size.\\n\\nThis problem of course can be written in Brute force way, but that is too brute.\\n\"\"\"\\n```\\n```\\nclass UF:\\n    \\n    def __init__(self, n):\\n        self.parent = {i: i for i in range(n)}\\n        self.size = {i: 1 for i in range(n)}\\n    \\n    def find(self, x):\\n        if x != self.parent[x]:\\n            self.parent[x] = self.find(self.parent[x])\\n        return self.parent[x]\\n    \\n    def union(self, x, y):\\n        rootX = self.find(x)\\n        rootY = self.find(y)\\n        if rootX == rootY:\\n            return\\n        \\n        if self.size[rootX] <= self.size[rootY]:\\n            self.parent[rootX] = rootY\\n            self.size[rootY] += self.size[rootX]\\n        \\n        else: \\n            self.parent[rootY] = rootX\\n            self.size[rootX] += self.size[rootY]\\n    \\n    def find_max(self):\\n        return max(self.size.values())\\n\\n    \\nclass Solution:\\n    def longestConsecutive(self, nums: List[int]) -> int:\\n        \\n        if not nums:\\n            return 0\\n        \\n        n = len(nums)\\n        \\n        uf = UF(n)\\n        \\n        dic = {}\\n        \\n        for i in range(n):\\n            \\n            if nums[i] in dic:\\n                continue\\n            \\n            dic[nums[i]] = i\\n            \\n            if nums[i] + 1 in dic:\\n                uf.union(i, dic[nums[i] + 1])\\n            \\n            if nums[i] - 1 in dic:\\n                uf.union(i, dic[nums[i] - 1])\\n        \\n        return uf.find_max()\\n```",
                "solutionTags": [
                    "Python",
                    "Union Find"
                ],
                "code": "```\\n# We have 3 method to write Union Find. \\n# 1, by Brute force,\\n# 2, by size,\\n# 3, by rank (depth).\\n```\n```\\n# 1, written by brute force:\\nclass UF:\\n\\n\\tdef __init__(self, n):\\n\\t\\tself.parent = {i: i for i in range(n)}\\n\\t\\n\\tdef find(self, x):\\n\\t\\tif x != self.parent[x]:\\n\\t\\t\\tself.parent[x] = self.find(self.parent[x])\\n\\t\\treturn self.parent[x]\\n\\t\\n\\tdef union(self, x, y):\\n\\t\\tself.parent[self.find(x)] = self.find(y)\\n```\n```\\n# 2, written by size:\\nclass UF:\\n\\n\\tdef __init__(self, n):\\n\\t\\tself.parent = {i: i for i in range(n)}\\n\\t\\tself.size = {i: 1 for i in range(n)}\\n\\t\\n\\tdef find(self, x):\\n\\t\\tif x != self.parent[x]:\\n\\t\\t\\tself.parent[x] = self.find(self.parent[x])\\n\\t\\treturn self.parent[x]\\n\\t\\n\\tdef union(self, x, y):\\n\\t\\trootX = self.find(x)\\n\\t\\trootY = self.find(y)\\n\\t\\tif rootX == rootY:\\n\\t\\t\\treturn\\n\\t\\t\\n\\t\\tif self.size[rootX] <= self.size[rootY]:\\n\\t\\t\\tself.parent[rootX] = rootY\\n\\t\\t\\tself.size[rootY] += self.size[rootX]\\n\\t\\t\\n\\t\\telse:\\n\\t\\t\\tself.parent[rootY] = rootX\\n\\t\\t\\tself.size[rootX] += self.size[rootY]\\n```\n```\\n# 3, written by rank (depth):\\nclass UF:\\n\\n\\tdef __init__(self, n):\\n\\t\\tself.parent = {i: i for i in range(n)}\\n\\t\\tself.rank = {i: 1 for i in range(n)}\\n\\t\\n\\tdef find(self, x):\\n\\t\\tif x != self.parent[x]:\\n\\t\\t\\tself.parent[x] = self.find(self.parent[x])\\n\\t\\treturn self.parent[x]\\n\\t\\n\\tdef union(self, x, y):\\n\\t\\trootX = self.find(x)\\n\\t\\trootY = self.find(y)\\n\\t\\tif rootX == rootY:\\n\\t\\t\\treturn\\n\\t\\t\\n\\t\\tif self.rank[rootX] < self.rank[rootY]:\\n\\t\\t\\tself.parent[rootX] = rootY\\n\\t\\t\\n\\t\\telif self.rank[rootY] < self.rank[rootX]:\\n\\t\\t\\tself.parent[rootY] = rootX\\n\\t\\t\\n\\t\\telse:\\n\\t\\t\\tself.parent[rootX] = rootY\\n\\t\\t\\tself.rank[rootY] += 1\\n```\n```\\n# The answer below is the type written by size.\\n# We have another 2 writing methods, that is, written by Brute force and written by rank (depth).\\n# Size is the common one that we usually write, but it can not deal with some particular cases.\\n# For example, \\n\"\"\"\\n        1            4\\n2   3   0              5\\n                         6\\n                   \\nWe can see the right tree has depth 3, left has depth 2. So\\nit is better to combine in this way, that is, put left tree into right tree, then the depth is still 3.\\n\\n            4\\n\\t      1    5\\n 2    3   0      6\\n\\t \\nBut if we write by size, since left size is 4, right size is 3, left > right, \\nso we put right tree into left, then the left tree increase the depth, which is not good.\\n\\n            1\\n\\t2   3   0   4\\n                   5\\n\\t\\t\\t\\t      6\\n\\nBut writing Union Find in size way will give you the benefit when the problem wants you to count\\nthe total number of nodes in the tree. Usually we write in the way of size.\\n\\nThis problem of course can be written in Brute force way, but that is too brute.\\n\"\"\"\\n```\n```\\nclass UF:\\n    \\n    def __init__(self, n):\\n        self.parent = {i: i for i in range(n)}\\n        self.size = {i: 1 for i in range(n)}\\n    \\n    def find(self, x):\\n        if x != self.parent[x]:\\n            self.parent[x] = self.find(self.parent[x])\\n        return self.parent[x]\\n    \\n    def union(self, x, y):\\n        rootX = self.find(x)\\n        rootY = self.find(y)\\n        if rootX == rootY:\\n            return\\n        \\n        if self.size[rootX] <= self.size[rootY]:\\n            self.parent[rootX] = rootY\\n            self.size[rootY] += self.size[rootX]\\n        \\n        else: \\n            self.parent[rootY] = rootX\\n            self.size[rootX] += self.size[rootY]\\n    \\n    def find_max(self):\\n        return max(self.size.values())\\n\\n    \\nclass Solution:\\n    def longestConsecutive(self, nums: List[int]) -> int:\\n        \\n        if not nums:\\n            return 0\\n        \\n        n = len(nums)\\n        \\n        uf = UF(n)\\n        \\n        dic = {}\\n        \\n        for i in range(n):\\n            \\n            if nums[i] in dic:\\n                continue\\n            \\n            dic[nums[i]] = i\\n            \\n            if nums[i] + 1 in dic:\\n                uf.union(i, dic[nums[i] + 1])\\n            \\n            if nums[i] - 1 in dic:\\n                uf.union(i, dic[nums[i] - 1])\\n        \\n        return uf.find_max()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1294511,
                "title": "java-explanation-in-simple-english-o-n-hashset",
                "content": "Read the Explaination and try once again to code without looking to program.\\n\\n**Idea:** Consider each element to be a part of some sequece, and try to find the maximum length sequence you can generate which includes this number. \\n\\n1. Copy all the element in set first. \\n2. Count the previous consecutive element from this element and similar next consecutive elememts from this element \\n3. So maximum seqence from this element would be \"prevCount + nextCount + 1\".\\n4. Maximun of this sequence is result.\\n\\n**Trick**: Trick is to keep deleting the numbers you visited once, If you dont do so, you will again try to find the sequence from a number , which is already part of some sequence.\\nComplexity of program will change to O(n2) if you dont delete the elements. \\n\\n**Please Upvote if you like the explanation**\\n\\n```\\nclass Solution {\\n    public int longestConsecutive(int[] a) {\\n        \\n        int len = a.length;\\n        if(len == 0 || len == 1) {\\n            return len;\\n        }\\n        \\n        int result = 0;\\n        \\n        HashSet<Integer> set = new HashSet<Integer>();\\n        \\n        for(int i : a) {\\n            set.add(i);\\n        }\\n        \\n        for(int i = 0; i < len; i++) {\\n            \\n            int item = a[i];\\n            \\n            if(!set.contains(item)) continue;\\n            \\n            int prevItem = item-1;\\n            int nextItem = item+1;\\n            int prevCount = 0;\\n            int nextCount = 0;\\n            \\n            set.remove(item);\\n            \\n            while(set.contains(prevItem)) {\\n                set.remove(prevItem);\\n                prevCount++;\\n                prevItem--;\\n            }\\n            \\n            while(set.contains(nextItem)) {\\n                set.remove(nextItem);\\n                nextCount++;\\n                nextItem++;\\n            }\\n            \\n            result = Math.max(result, (prevCount+nextCount+1));\\n            \\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int longestConsecutive(int[] a) {\\n        \\n        int len = a.length;\\n        if(len == 0 || len == 1) {\\n            return len;\\n        }\\n        \\n        int result = 0;\\n        \\n        HashSet<Integer> set = new HashSet<Integer>();\\n        \\n        for(int i : a) {\\n            set.add(i);\\n        }\\n        \\n        for(int i = 0; i < len; i++) {\\n            \\n            int item = a[i];\\n            \\n            if(!set.contains(item)) continue;\\n            \\n            int prevItem = item-1;\\n            int nextItem = item+1;\\n            int prevCount = 0;\\n            int nextCount = 0;\\n            \\n            set.remove(item);\\n            \\n            while(set.contains(prevItem)) {\\n                set.remove(prevItem);\\n                prevCount++;\\n                prevItem--;\\n            }\\n            \\n            while(set.contains(nextItem)) {\\n                set.remove(nextItem);\\n                nextCount++;\\n                nextItem++;\\n            }\\n            \\n            result = Math.max(result, (prevCount+nextCount+1));\\n            \\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1254660,
                "title": "longest-consecutive-sequence-python-solution",
                "content": "* so this is a pretty easy solution lets go step by step:\\n* if we have duplicates still the chain wont be affected for ex 1,1,2,3,4 is still 4 in size as we so we craeate a set as duplicates wont affect\\n* now see if he 1,2,3,4 now the basic idea is to start a chain from that no whose num-1 is not there otherwise we will start from num-1 to make chain bigger in size ...for eg in this case if we start at 2 but we see we have 2-1 already and if we start from their we get long chain and so we got the idea of start point\\n* now from starting point we see how far can we get the chain thats why i used while loop used a count variable and at last after every iteration we checked for max result \\n* at end returned the resuly\\n* **if u find this helpfull do plz upvote**\\n* **we also not sorted this list nums**\\n```py\\nclass Solution(object):\\n    def longestConsecutive(self, nums):\\n        if not nums:\\n            return 0\\n        result=0\\n        numset=set(nums)\\n        \\n        for num in numset:\\n            if num -1 not in numset:\\n                count=1\\n                while num+1 in numset:\\n                    count+=1\\n                    num+=1\\n                result=max(result,count)\\n        return result",
                "solutionTags": [
                    "Python",
                    "Ordered Set"
                ],
                "code": "* so this is a pretty easy solution lets go step by step:\\n* if we have duplicates still the chain wont be affected for ex 1,1,2,3,4 is still 4 in size as we so we craeate a set as duplicates wont affect\\n* now see if he 1,2,3,4 now the basic idea is to start a chain from that no whose num-1 is not there otherwise we will start from num-1 to make chain bigger in size ...for eg in this case if we start at 2 but we see we have 2-1 already and if we start from their we get long chain and so we got the idea of start point\\n* now from starting point we see how far can we get the chain thats why i used while loop used a count variable and at last after every iteration we checked for max result \\n* at end returned the resuly\\n* **if u find this helpfull do plz upvote**\\n* **we also not sorted this list nums**\\n```py\\nclass Solution(object):\\n    def longestConsecutive(self, nums):\\n        if not nums:\\n            return 0\\n        result=0\\n        numset=set(nums)\\n        \\n        for num in numset:\\n            if num -1 not in numset:\\n                count=1\\n                while num+1 in numset:\\n                    count+=1\\n                    num+=1\\n                result=max(result,count)\\n        return result",
                "codeTag": "Java"
            },
            {
                "id": 1059534,
                "title": "java-union-find-solution",
                "content": "Apparently, UnionFind can help in many problems that you never thought it would. The idea here is to have a very basic union-find class with one extra method to return the maximum size of the components we have. By mapping the elements we have (without duplicates) to indecies, create a unionfind object with them, you can easily union each number(i) and the next number (i+1) if exists and the previous number (i-1) if exists and that will give you connected components of consecutive sequences. Then, by getting the maximum size of these components (using the getMax method that was added to the UnionFind class), you got the maximum size of the consecutive sequence.\\n\\n```\\nclass UnionFind{\\n    int[] parents;\\n    int[] sizes;\\n    \\n    UnionFind(int n){\\n        this.parents = new int[n];\\n        this.sizes = new int[n];\\n        for (int i=0;i<n;i++){\\n            parents[i] = i;\\n            sizes[i] = 1;\\n        }\\n    }\\n    \\n    public int find(int a){\\n        int root = a;\\n        while (root != parents[root])\\n            root = parents[root];\\n        while (a != parents[a]){\\n            int tmp = parents[a];\\n            parents[a] = root;\\n            a = tmp;\\n        }\\n        return root;\\n    }\\n    \\n    public void union(int a, int b){\\n        if ((a == -1) || (b == -1))\\n            return;\\n        \\n        int rootA = find(a);\\n        int rootB = find(b);\\n        \\n        if (rootA == rootB)\\n            return;\\n        \\n        if (sizes[rootA] < sizes[rootB]){\\n            sizes[rootB] += sizes[rootA];\\n            parents[rootA] = rootB;\\n        } else {\\n            sizes[rootA] += sizes[rootB];\\n            parents[rootB] = rootA;\\n        }\\n    }\\n    \\n    public int getMax(){\\n        int max = sizes[0];\\n        for (int i=1;i<sizes.length;i++)\\n            max = Math.max(max, sizes[i]);\\n        return max;\\n    }\\n}\\n\\nclass Solution {\\n    public int longestConsecutive(int[] nums) {\\n        if (nums.length == 0)\\n            return 0;\\n        \\n        Map<Integer, Integer> map = new HashMap<Integer, Integer>();\\n        int counter = 0;\\n        for (int i: nums){\\n            if (map.containsKey(i))\\n                continue;\\n            map.put(i, counter);\\n            counter++;\\n        }\\n        \\n        UnionFind uf = new UnionFind(map.size());\\n        for (int i: nums){\\n            uf.union(map.get(i), map.getOrDefault(i-1, -1));\\n            uf.union(map.get(i), map.getOrDefault(i+1, -1));\\n        }\\n        \\n        return uf.getMax();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Union Find"
                ],
                "code": "```\\nclass UnionFind{\\n    int[] parents;\\n    int[] sizes;\\n    \\n    UnionFind(int n){\\n        this.parents = new int[n];\\n        this.sizes = new int[n];\\n        for (int i=0;i<n;i++){\\n            parents[i] = i;\\n            sizes[i] = 1;\\n        }\\n    }\\n    \\n    public int find(int a){\\n        int root = a;\\n        while (root != parents[root])\\n            root = parents[root];\\n        while (a != parents[a]){\\n            int tmp = parents[a];\\n            parents[a] = root;\\n            a = tmp;\\n        }\\n        return root;\\n    }\\n    \\n    public void union(int a, int b){\\n        if ((a == -1) || (b == -1))\\n            return;\\n        \\n        int rootA = find(a);\\n        int rootB = find(b);\\n        \\n        if (rootA == rootB)\\n            return;\\n        \\n        if (sizes[rootA] < sizes[rootB]){\\n            sizes[rootB] += sizes[rootA];\\n            parents[rootA] = rootB;\\n        } else {\\n            sizes[rootA] += sizes[rootB];\\n            parents[rootB] = rootA;\\n        }\\n    }\\n    \\n    public int getMax(){\\n        int max = sizes[0];\\n        for (int i=1;i<sizes.length;i++)\\n            max = Math.max(max, sizes[i]);\\n        return max;\\n    }\\n}\\n\\nclass Solution {\\n    public int longestConsecutive(int[] nums) {\\n        if (nums.length == 0)\\n            return 0;\\n        \\n        Map<Integer, Integer> map = new HashMap<Integer, Integer>();\\n        int counter = 0;\\n        for (int i: nums){\\n            if (map.containsKey(i))\\n                continue;\\n            map.put(i, counter);\\n            counter++;\\n        }\\n        \\n        UnionFind uf = new UnionFind(map.size());\\n        for (int i: nums){\\n            uf.union(map.get(i), map.getOrDefault(i-1, -1));\\n            uf.union(map.get(i), map.getOrDefault(i+1, -1));\\n        }\\n        \\n        return uf.getMax();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 733504,
                "title": "swift-o-n-solution-easy-to-understand",
                "content": "Eventhough it looks like O(n^2). In the worst scenario, we only check each number twice.\\nTime: O(n), Space: O(n)\\n\\n```\\nfunc longestConsecutive(_ nums: [Int]) -> Int {\\n\\tvar set = Set(nums)\\n\\tvar maxLength = 0\\n\\n\\tfor num in nums {\\n\\t\\tif !set.contains(num - 1) { // only start with the smallest number\\n\\t\\t\\tvar currLength = 1\\n\\t\\t\\tvar temp = num + 1\\n\\n\\t\\t\\twhile set.contains(temp) {\\n\\t\\t\\t\\tcurrLength += 1\\n\\t\\t\\t\\ttemp += 1\\n\\t\\t\\t}\\n\\n\\t\\t\\tmaxLength = max(maxLength, currLength)\\n\\t\\t}\\n\\t}\\n\\n\\treturn maxLength\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nfunc longestConsecutive(_ nums: [Int]) -> Int {\\n\\tvar set = Set(nums)\\n\\tvar maxLength = 0\\n\\n\\tfor num in nums {\\n\\t\\tif !set.contains(num - 1) { // only start with the smallest number\\n\\t\\t\\tvar currLength = 1\\n\\t\\t\\tvar temp = num + 1\\n\\n\\t\\t\\twhile set.contains(temp) {\\n\\t\\t\\t\\tcurrLength += 1\\n\\t\\t\\t\\ttemp += 1\\n\\t\\t\\t}\\n\\n\\t\\t\\tmaxLength = max(maxLength, currLength)\\n\\t\\t}\\n\\t}\\n\\n\\treturn maxLength\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 501812,
                "title": "c-simple-and-fast-8-short-lines-with-explanation-0-ms",
                "content": "Though all solutions here are fundamentally the same, I am using a few tricks to make the code faster and cleaner.\\n\\n* The hash-set `S` contains the numbers we haven\\'t visited yet.\\n* The main loop continues until the set is no longer large enough to make a difference.\\n* We immediately start walking in both directions when we find any number.\\n* We erase all visited numbers from the set as we go.\\n* We use some nice C++ idioms, like the [range constructor](https://en.cppreference.com/w/cpp/container/unordered_set/unordered_set) and the [`erase`](https://en.cppreference.com/w/cpp/container/unordered_set/erase) method that returns a value.\\n\\n```C++\\nint longestConsecutive(vector<int> const& nums) {\\n  unordered_set<int> S(nums.begin(), nums.end());\\n  int result = 0;\\n  while (S.size() > result) {     // While there are enough numbers left to make a difference,\\n    int l = *S.begin(), r = l+1;  // take an arbitrary unvisited number from the set,\\n    while (S.erase(l)) --l;       // walk left on the number line, erasing numbers as you go,\\n    while (S.erase(r)) ++r;       // walk right on the number line, erasing numbers as you go,\\n    result = max(result, r-l-1);  // and consider the length of the resulting sequence.\\n  }\\n  return result;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```C++\\nint longestConsecutive(vector<int> const& nums) {\\n  unordered_set<int> S(nums.begin(), nums.end());\\n  int result = 0;\\n  while (S.size() > result) {     // While there are enough numbers left to make a difference,\\n    int l = *S.begin(), r = l+1;  // take an arbitrary unvisited number from the set,\\n    while (S.erase(l)) --l;       // walk left on the number line, erasing numbers as you go,\\n    while (S.erase(r)) ++r;       // walk right on the number line, erasing numbers as you go,\\n    result = max(result, r-l-1);  // and consider the length of the resulting sequence.\\n  }\\n  return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 468925,
                "title": "easy-python-3-solution-using-hashmap-beats-99",
                "content": "```\\ndef longestConsecutive(self, nums: List[int]) -> int:\\n\\tbest: int = 0\\n\\tx: Dict[int, int] = {i: 1 for i in nums}\\n\\n\\tfor i in list(x.keys()):\\n\\t\\tif i not in x:\\n\\t\\t\\tcontinue\\n\\t\\tcounter: int = 1\\n\\t\\tj: int = 1\\n\\t\\twhile i + j in x:\\n\\t\\t\\tcounter += 1\\n\\t\\t\\tdel x[i + j]\\n\\t\\t\\tj += 1\\n\\t\\tj = 1\\n\\t\\twhile i - j in x:\\n\\t\\t\\tcounter += 1\\n\\t\\t\\tdel x[i - j]\\n\\t\\t\\tj += 1\\n\\t\\tdel x[i]\\n\\n\\t\\tbest = max(best, counter)\\n\\t\\tif not x:\\n\\t\\t\\tbreak\\n\\n\\n\\treturn best\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table"
                ],
                "code": "```\\ndef longestConsecutive(self, nums: List[int]) -> int:\\n\\tbest: int = 0\\n\\tx: Dict[int, int] = {i: 1 for i in nums}\\n\\n\\tfor i in list(x.keys()):\\n\\t\\tif i not in x:\\n\\t\\t\\tcontinue\\n\\t\\tcounter: int = 1\\n\\t\\tj: int = 1\\n\\t\\twhile i + j in x:\\n\\t\\t\\tcounter += 1\\n\\t\\t\\tdel x[i + j]\\n\\t\\t\\tj += 1\\n\\t\\tj = 1\\n\\t\\twhile i - j in x:\\n\\t\\t\\tcounter += 1\\n\\t\\t\\tdel x[i - j]\\n\\t\\t\\tj += 1\\n\\t\\tdel x[i]\\n\\n\\t\\tbest = max(best, counter)\\n\\t\\tif not x:\\n\\t\\t\\tbreak\\n\\n\\n\\treturn best\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 221370,
                "title": "easy-to-understand-python-o-n-solution",
                "content": "```\\nclass Solution:\\n    def longestConsecutive(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        num_set = set(nums)\\n        max_len = 0\\n        \\n        for num in num_set:\\n            if num - 1 not in num_set:\\n                offset = 1\\n                while num + offset in num_set:\\n                    offset += 1\\n                max_len = max(max_len, offset)\\n        \\n        return max_len\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def longestConsecutive(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        num_set = set(nums)\\n        max_len = 0\\n        \\n        for num in num_set:\\n            if num - 1 not in num_set:\\n                offset = 1\\n                while num + offset in num_set:\\n                    offset += 1\\n                max_len = max(max_len, offset)\\n        \\n        return max_len\\n```",
                "codeTag": "Java"
            },
            {
                "id": 41163,
                "title": "simple-unionfind-java-solution-beat-75",
                "content": "There are many short excellent solutions for this particular problem. However, this problem can also be solved by union find. There is a very good material to learn union find.\\n\\nhttps://www.cs.princeton.edu/~rs/AlgsDS07/01UnionFind.pdf\\n\\n```\\npublic class Solution {\\n    int[] id;\\n    int[] sz;\\n    Map<Integer, Integer> map;\\n    \\n    public int longestConsecutive(int[] nums) {\\n        id = new int[nums.length];\\n        sz = new int[nums.length];\\n        map = new HashMap<>();\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            insert(nums[i], i);\\n        }\\n        \\n        int res = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            res = Math.max(res, sz[i]);\\n        }\\n        \\n        return res;\\n    }\\n    \\n    private void insert(int num, int index) {\\n        if (!map.containsKey(num)) {\\n            map.put(num, index);\\n            id[index] = index;\\n            sz[index] = 1;\\n            if (map.containsKey(num - 1)) {\\n                unite(num - 1, num);\\n            }\\n            if (map.containsKey(num + 1)) {\\n                unite(num + 1, num);\\n            }\\n        }\\n    }\\n    \\n    private void unite(int num1, int num2) {\\n        int p = findSet(map.get(num1));\\n        int q = findSet(map.get(num2));\\n        if (p != q) {\\n            if (sz[p] > sz[q]) {\\n                id[q] = p;\\n                sz[p] += sz[q];\\n            } else {\\n                id[p] = q;\\n                sz[q] += sz[p];\\n            }\\n        }\\n    }\\n    \\n    private int findSet(int p) {\\n        if (id[p] != p) {\\n            id[p] = findSet(id[p]);\\n        }\\n        return id[p];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    int[] id;\\n    int[] sz;\\n    Map<Integer, Integer> map;\\n    \\n    public int longestConsecutive(int[] nums) {\\n        id = new int[nums.length];\\n        sz = new int[nums.length];\\n        map = new HashMap<>();\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            insert(nums[i], i);\\n        }\\n        \\n        int res = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            res = Math.max(res, sz[i]);\\n        }\\n        \\n        return res;\\n    }\\n    \\n    private void insert(int num, int index) {\\n        if (!map.containsKey(num)) {\\n            map.put(num, index);\\n            id[index] = index;\\n            sz[index] = 1;\\n            if (map.containsKey(num - 1)) {\\n                unite(num - 1, num);\\n            }\\n            if (map.containsKey(num + 1)) {\\n                unite(num + 1, num);\\n            }\\n        }\\n    }\\n    \\n    private void unite(int num1, int num2) {\\n        int p = findSet(map.get(num1));\\n        int q = findSet(map.get(num2));\\n        if (p != q) {\\n            if (sz[p] > sz[q]) {\\n                id[q] = p;\\n                sz[p] += sz[q];\\n            } else {\\n                id[p] = q;\\n                sz[q] += sz[p];\\n            }\\n        }\\n    }\\n    \\n    private int findSet(int p) {\\n        if (id[p] != p) {\\n            id[p] = findSet(id[p]);\\n        }\\n        return id[p];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 41251,
                "title": "simple-c-o-n-solution-using-set",
                "content": "    class Solution {\\n    public:\\n        int longestConsecutive(vector<int>& nums) {\\n            int len = 0, candidate, val;\\n            unordered_set<int> set(nums.begin(), nums.end());\\n            while (!set.empty()) {\\n                val = *set.begin();\\n                set.erase(val);\\n                candidate = 1;\\n                for (int i = val + 1; set.find(i) != set.end(); ++i) {\\n                    set.erase(i);\\n                    candidate++;\\n                }\\n                for (int i = val - 1; set.find(i) != set.end(); --i) {\\n                    set.erase(i);\\n                    candidate++;\\n                }\\n                len = max(len, candidate);\\n            }\\n            return len;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int longestConsecutive(vector<int>& nums) {\\n            int len = 0, candidate, val;\\n            unordered_set<int> set(nums.begin(), nums.end());\\n            while (!set.empty()) {\\n                val = *set.begin();\\n                set.erase(val);\\n                candidate = 1;\\n                for (int i = val + 1; set.find(i) != set.end(); ++i) {\\n                    set.erase(i);\\n                    candidate++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 41345,
                "title": "solution-of-mine-o-n-complexity-and-o-n-space-with-single-scan",
                "content": "I find this is problem is a good practice of disjoint-set.\\n\\nI have two hash tables:\\n\\nvTable: v(x) = the max length of consecutive sequence starting from x\\n\\naTable: a(x) = the ancestor of x (if x is the largest in the sequence, h(x) is the smallest of that sequence, and vice versa. For elements in the middle of sequence, h(x) will never be looked up)\\n\\nBasic idea is, we maintain the two ends of every sequence and update v(x). The rest is just about proper logic. Some other threads cover the same idea though. I put my code here for comparison. It's only 24 lines.\\n\\n    class Solution {\\n    public:\\n        int longestConsecutive(vector<int> &num) {\\n            unordered_map<int,int> vTable;\\n            unordered_map<int,vector<int>::iterator> aTable;\\n            for (vector<int>::iterator i = num.begin(); i!=num.end(); i++) {\\n                if(vTable.count(*i)) continue;      // Ignore same number\\n                vTable[*i]=1;\\n                aTable[*i]=i;                       // Initialization of new input\\n                if(vTable.count(*i+1)) {            // If i+1 exists\\n                    vTable[*i] += vTable[*i+1];     // Update v(x)\\n                    aTable[*i] = aTable[*i+1];      // Update a(x)\\n                }\\n                if(vTable.count(*i-1)) {            // If i-1 exists, same idea\\n                    vTable[*aTable[*i-1]] += vTable[*i];\\n                    aTable[*aTable[*i]] = aTable[*i-1];\\n                    aTable[*aTable[*i-1]] = (vTable.count(*i+1)) ? aTable[*i] : i;\\n                }else aTable[*aTable[*i]] = i;\\n            }\\n            int max=0;                              // Find max in vTable\\n            for (auto& x:vTable) if (x.second>max) max = x.second;\\n            return max;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int longestConsecutive(vector<int> &num) {\\n            unordered_map<int,int> vTable;\\n            unordered_map<int,vector<int>::iterator> aTable;\\n            for (vector<int>::iterator i = num.begin(); i!=num.end(); i++) {\\n                if(vTable.count(*i)) continue;      // Ignore same number\\n                vTable[*i]=1;\\n                aTable[*i]=i;                       // Initialization of new input\\n                if(vTable.count(*i+1)) {            // If i+1 exists\\n                    vTable[*i] += vTable[*i+1];     // Update v(x)\\n                    aTable[*i] = aTable[*i+1];      // Update a(x)\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3701266,
                "title": "100-working-easiest-solution-ever",
                "content": "# Intuition\\nBelieve me, its not a MEDIUM problem at all.\\n\\nThink about, what do you actually mean by a sequence!?\\nThe main thought process should be how you equate the two consequtive numbers.\\n\\n\\n***Think before scrolling, YOU CAN DO IT.***\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Sort the Array.\\n2. Check whether the (i+1)th element is equal to 1+ith element.\\n3. If yes, we continue the count. Else, we break the count and reassign it to 1.\\n4. Take the maximum of the current count or maxCount.\\n5. Return the maxCount.\\n\\n# Code\\n```\\nclass Solution {\\n    public int longestConsecutive(int[] nums) {\\n        if(nums.length == 0)\\n            return 0;\\n        Arrays.sort(nums);\\n        int count = 1;\\n        int maxCount = 1;\\n        for(int i = 0; i < nums.length - 1; i++)\\n        {\\n            if(nums[i+1] == nums[i] + 1)\\n                count++;\\n            else if(nums[i+1] == nums[i])\\n                continue;\\n            else\\n                count = 1;\\n\\n            maxCount = Math.max(maxCount,count);\\n        }\\n        return maxCount;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int longestConsecutive(int[] nums) {\\n        if(nums.length == 0)\\n            return 0;\\n        Arrays.sort(nums);\\n        int count = 1;\\n        int maxCount = 1;\\n        for(int i = 0; i < nums.length - 1; i++)\\n        {\\n            if(nums[i+1] == nums[i] + 1)\\n                count++;\\n            else if(nums[i+1] == nums[i])\\n                continue;\\n            else\\n                count = 1;\\n\\n            maxCount = Math.max(maxCount,count);\\n        }\\n        return maxCount;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3690013,
                "title": "super-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nhttps://takeuforward.org/data-structure/longest-consecutive-sequence-in-an-array/\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestConsecutive(vector<int>& nums) {\\n        unordered_set<int> mp;\\n        int maxi=0;\\n        for(int i=0;i<nums.size();i++){\\n            mp.insert(nums[i]);\\n        }\\n        for(int i=0;i<nums.size();i++){\\n            if(mp.find(nums[i]-1)!=mp.end()){\\n                continue;\\n            }else{\\n              int count=0;int cp=nums[i];\\n              while(mp.find(cp)!=mp.end()) {\\n                  cp++;\\n                  count++;\\n                  maxi=max(count,maxi);\\n              }\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestConsecutive(vector<int>& nums) {\\n        unordered_set<int> mp;\\n        int maxi=0;\\n        for(int i=0;i<nums.size();i++){\\n            mp.insert(nums[i]);\\n        }\\n        for(int i=0;i<nums.size();i++){\\n            if(mp.find(nums[i]-1)!=mp.end()){\\n                continue;\\n            }else{\\n              int count=0;int cp=nums[i];\\n              while(mp.find(cp)!=mp.end()) {\\n                  cp++;\\n                  count++;\\n                  maxi=max(count,maxi);\\n              }\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3391225,
                "title": "simplest-python-solution-with-linear-time-complexity",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def longestConsecutive(self, nums: List[int]) -> int:\\n        numSet=set(nums)\\n        longest=0\\n        for i in nums:\\n            length=0\\n            if i-1 not in numSet:\\n                while i+length in numSet:\\n                    length+=1\\n            longest=max(length,longest)\\n        return longest    \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestConsecutive(self, nums: List[int]) -> int:\\n        numSet=set(nums)\\n        longest=0\\n        for i in nums:\\n            length=0\\n            if i-1 not in numSet:\\n                while i+length in numSet:\\n                    length+=1\\n            longest=max(length,longest)\\n        return longest    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3349973,
                "title": "java-solution-accepted",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int longestConsecutive(int[] nums) \\n    {\\n        if(nums.length==0) return 0;\\n        int c=1;\\n        int max=1;\\n        Arrays.sort(nums);\\n        for(int i=0; i<nums.length-1; i++)\\n        {\\n            if(nums[i]+1==nums[i+1]) \\n            {\\n                c++;\\n                if(max<c) max=c;\\n            }\\n            else if(nums[i]==nums[i+1]) continue;\\n            else\\n            {\\n                c=1;\\n            }\\n        }    \\n        return max;\\n        \\n    }\\n}\\n\\n\\n```\\n# \\u2B06\\uFE0FUpvote if you like the solution",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int longestConsecutive(int[] nums) \\n    {\\n        if(nums.length==0) return 0;\\n        int c=1;\\n        int max=1;\\n        Arrays.sort(nums);\\n        for(int i=0; i<nums.length-1; i++)\\n        {\\n            if(nums[i]+1==nums[i+1]) \\n            {\\n                c++;\\n                if(max<c) max=c;\\n            }\\n            else if(nums[i]==nums[i+1]) continue;\\n            else\\n            {\\n                c=1;\\n            }\\n        }    \\n        return max;\\n        \\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3228009,
                "title": "super-easy-hashset-solution-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\n    public int longestConsecutive(int[] nums) {\\n        HashSet<Integer>set=new HashSet<>();\\n        for(int i=0;i<nums.length;i++){\\n            set.add(nums[i]);\\n        }\\n        int longSeq=0;\\n        int count=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(!set.contains(nums[i]-1)){\\n                int num=nums[i]+1;\\n                count=1;\\n                while(set.contains(num)){\\n                    num+=1;\\n                    count++;\\n                }\\n                longSeq=Math.max(longSeq,count);\\n            }\\n        }\\n        return longSeq;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int longestConsecutive(int[] nums) {\\n        HashSet<Integer>set=new HashSet<>();\\n        for(int i=0;i<nums.length;i++){\\n            set.add(nums[i]);\\n        }\\n        int longSeq=0;\\n        int count=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(!set.contains(nums[i]-1)){\\n                int num=nums[i]+1;\\n                count=1;\\n                while(set.contains(num)){\\n                    num+=1;\\n                    count++;\\n                }\\n                longSeq=Math.max(longSeq,count);\\n            }\\n        }\\n        return longSeq;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3026221,
                "title": "go-o-n-clean-solution-explained-complexity",
                "content": "# Complexity\\n- Time complexity: $O(n)$. It consists of building a set in $O(n)$ time + iteration in $O(n)$.\\n\\n- Space complexity: at worst $n$ elements will be stored in the set, so $O(n)$.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunc longestConsecutive(nums []int) int {\\n    // Construct a set out of the nums array.\\n    numsSet := make(map[int]struct{})\\n    for _, n := range nums {\\n        numsSet[n] = struct{}{}\\n    }\\n\\n    // The answer is stored here.\\n    maxSequenceLen := 0\\n\\n    // Iterate through the set.\\n    for n := range numsSet {\\n        // We check if n-1 is in the set. If it is, then n is not the beginning of a sequence\\n        // and we go to the next number immediately.\\n        if _, ok := numsSet[n-1]; !ok {\\n            // Otherwise, we increment n in a loop to see if the next consecutive value is stored in nums.\\n            seqLen := 1\\n            for {\\n                if _, ok = numsSet[n+seqLen]; ok {\\n                    seqLen++\\n                    continue\\n                }\\n                // When the sequence is over, see if we did better than before.\\n                maxSequenceLen = max(seqLen, maxSequenceLen)\\n                break\\n            }\\n        }\\n    }\\n\\n    return maxSequenceLen\\n}\\n\\nfunc max(a, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    return b\\n}\\n\\n```",
                "solutionTags": [
                    "Go",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nfunc longestConsecutive(nums []int) int {\\n    // Construct a set out of the nums array.\\n    numsSet := make(map[int]struct{})\\n    for _, n := range nums {\\n        numsSet[n] = struct{}{}\\n    }\\n\\n    // The answer is stored here.\\n    maxSequenceLen := 0\\n\\n    // Iterate through the set.\\n    for n := range numsSet {\\n        // We check if n-1 is in the set. If it is, then n is not the beginning of a sequence\\n        // and we go to the next number immediately.\\n        if _, ok := numsSet[n-1]; !ok {\\n            // Otherwise, we increment n in a loop to see if the next consecutive value is stored in nums.\\n            seqLen := 1\\n            for {\\n                if _, ok = numsSet[n+seqLen]; ok {\\n                    seqLen++\\n                    continue\\n                }\\n                // When the sequence is over, see if we did better than before.\\n                maxSequenceLen = max(seqLen, maxSequenceLen)\\n                break\\n            }\\n        }\\n    }\\n\\n    return maxSequenceLen\\n}\\n\\nfunc max(a, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    return b\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2598678,
                "title": "c-easy-solution-o-n",
                "content": "```\\n**********// ***PLEASE UPVOTE***************\\n\\nint longestConsecutive(vector<int>& nums) {\\n\\n\\tint max_count=0,curr_count=0;\\n\\t\\n\\t// use unordered set and store all elem\\n\\tunordered_set<int> s;\\n\\tfor(int val:nums){\\n\\t\\ts.insert(val);\\n\\t}\\n\\t\\n\\t// Traverse through the set\\n\\tfor(auto val : s){\\n\\t\\tif(!s.count(val-1)){ // for each element in set if u get value of prev consecutive number then continue for next iteration becoz u will come across that iteration in further iteration of the loop \\n\\t\\t\\tcurr_count = 1;\\n\\t\\t\\twhile(s.count(val+1)){ // check consecutive for each number\\n\\t\\t\\t\\tcurr_count++;\\n\\t\\t\\t\\tval+=1;\\n\\t\\t\\t}\\n\\t\\t\\tmax_count = max(max_count,curr_count); \\n\\t\\t}\\n\\t}\\n\\treturn max_count;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Hash Table"
                ],
                "code": "```\\n**********// ***PLEASE UPVOTE***************\\n\\nint longestConsecutive(vector<int>& nums) {\\n\\n\\tint max_count=0,curr_count=0;\\n\\t\\n\\t// use unordered set and store all elem\\n\\tunordered_set<int> s;\\n\\tfor(int val:nums){\\n\\t\\ts.insert(val);\\n\\t}\\n\\t\\n\\t// Traverse through the set\\n\\tfor(auto val : s){\\n\\t\\tif(!s.count(val-1)){ // for each element in set if u get value of prev consecutive number then continue for next iteration becoz u will come across that iteration in further iteration of the loop \\n\\t\\t\\tcurr_count = 1;\\n\\t\\t\\twhile(s.count(val+1)){ // check consecutive for each number\\n\\t\\t\\t\\tcurr_count++;\\n\\t\\t\\t\\tval+=1;\\n\\t\\t\\t}\\n\\t\\t\\tmax_count = max(max_count,curr_count); \\n\\t\\t}\\n\\t}\\n\\treturn max_count;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2489034,
                "title": "java-solution-with-explanation",
                "content": "**Approach**,\\n1. First we need to observe that every number can be part of only single subsequence. \\n2. Even if any number has multiple occurance it\\'ll be taken only one time to form longest subsequence.\\n3. Using a set to store all the elements is sufficient for this problem.\\n4. To visualize the solution. Let\\'s take a example \\n\\nLet us take the following example... -2 -1 0 1 2 3 4 5\\n\\nSince we\\'re using a HashSet that will not maintain order of elements. We assume every element a pivot and search it\\'s left and right for consecutive elements. Since every element can be a part of only one subsequence we can safely remove from the set. If we take -1 as pivot and search for it\\'s left and right part we\\'ll eventually find the length of the subsequence. \\n\\nIn this way we only visit any element not once not. So overall complexity doesn\\'t exceeds O(n)\\n\\nBelow is implementation of same\\n```\\nclass Solution {\\n    public int longestConsecutive(int[] nums) {\\n        Set<Long> set = new HashSet<>();\\n        for (int x : nums) {\\n            set.add(x*1l);\\n        }\\n        int ans = 0;\\n        for (int x : nums) {\\n            long val = x;\\n            if (!set.contains(val)) continue;\\n            long prev = val - 1;\\n            long next = val + 1;\\n            int len = 1;\\n            while (set.contains(prev)) {\\n                len++;\\n                set.remove(prev);\\n                prev--;\\n            }\\n            while (set.contains(next)) {\\n                len++;\\n                set.remove(next);\\n                next++;\\n            }\\n            ans = Math.max(ans,len);\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\nLet me know if there is any better way of solving this and if you find any gaps in explanation do tell me in comments.\\n\\nHappy coding\\n\\n\\n",
                "solutionTags": [
                    "Java",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\n    public int longestConsecutive(int[] nums) {\\n        Set<Long> set = new HashSet<>();\\n        for (int x : nums) {\\n            set.add(x*1l);\\n        }\\n        int ans = 0;\\n        for (int x : nums) {\\n            long val = x;\\n            if (!set.contains(val)) continue;\\n            long prev = val - 1;\\n            long next = val + 1;\\n            int len = 1;\\n            while (set.contains(prev)) {\\n                len++;\\n                set.remove(prev);\\n                prev--;\\n            }\\n            while (set.contains(next)) {\\n                len++;\\n                set.remove(next);\\n                next++;\\n            }\\n            ans = Math.max(ans,len);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2242636,
                "title": "c-easy-solution",
                "content": "class Solution {\\npublic:\\n\\n    int longestConsecutive(vector<int>& nums) {\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<nums.size();i++){\\n            mp[nums[i]]++;\\n        }\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(mp.find(nums[i]-1)==mp.end()){  //to check whether number just less than 1 is present or not\\n              int ans1=1;\\n                //int j=i;\\n                int v=1; // for serial sequence\\n                while(true){\\n                    if(mp.find(nums[i]+v)==mp.end()) break;\\n                    ans1+=1;\\n                    //j+=1;\\n                    v+=1;\\n                }\\n                ans = std::max(ans,ans1);\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int longestConsecutive(vector<int>& nums) {\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<nums.size();i++){\\n            mp[nums[i]]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2241556,
                "title": "easy-c-sol-naive-efficient-approaches-hashset",
                "content": "```\\n// Naive Solution : Simply Sorting and then Travering the Array :: Time : O(NlogN) + O(N) :: Aux_Space : O(1)\\n\\nclass Solution {\\npublic:\\n    int longestConsecutive(vector<int>& nums) {\\n\\n        int n = nums.size();\\n\\n        if(n == 0){\\n            return 0;\\n        }\\n\\n        sort(nums.begin(),nums.end());\\n\\n\\n        int max_len = 1,cnt = 1;\\n\\n        for(int i=1;i<n;i++){\\n\\n            if(nums[i]-nums[i-1] == 1){\\n                cnt++;\\n                max_len = max(max_len,cnt);\\n            }else if(nums[i] == nums[i-1]){\\n                   continue;\\n            }else{\\n                cnt = 1;\\n            }\\n        }\\n        return max_len;\\n    }\\n};\\n\\n// Efficient Solution :: Time : O(3N) :: Aux_Space : O(N)\\n\\n\\nclass Solution {\\npublic:\\n    int longestConsecutive(vector<int>& nums) {\\n\\n        int n = nums.size();\\n\\n        unordered_set<int> s;\\n\\n        for(int i=0;i<n;i++){\\n            s.insert(nums[i]);\\n        }\\n\\n        int max_len = 0;\\n\\n        for(int i=0;i<n;i++){\\n\\n            if(!s.count(nums[i]-1)){\\n                int currele = nums[i];\\n                int res =1;\\n\\n                while(s.count(currele+1)){\\n                    currele++;\\n                    res++;\\n                }\\n                max_len = max(max_len,res);\\n            }\\n        }\\n        return max_len;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "class Solution {\\npublic:\\n    int longestConsecutive(vector<int>& nums) {\\n\\n        int n = nums.size();\\n\\n        if(n == 0){\\n            return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2239833,
                "title": "easy-c-solution-using-hashmap-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestConsecutive(vector<int>& nums) {\\n        if(nums.size()<=1)\\n            return nums.size();\\n        \\n        int mx = INT_MIN,count=1;                          //mx- length of longest consecutive sequence \\n        int mxnums = INT_MIN,mnnums=INT_MAX;               //mxnums - max element which may have consecutive element before that,mnnums-min element for same purpose\\n        int start = INT_MAX;                               //minimum element in nums\\n        int end = INT_MIN;                                 //maximum element in nums\\n        \\n        unordered_map<int,int>map;                         //map to store freq of element \\n        for(int x:nums)map[x]++;\\n        \\n        for(int i=0;i<nums.size();i++){\\n            if(map[nums[i]-1]!=0 && map[nums[i]+1]==0){\\n                mxnums = max(mxnums,nums[i]);               \\n            }\\n            if(map[nums[i]-1]==0 && map[nums[i]+1]!=0){\\n                mnnums = min(mnnums,nums[i]);\\n            }\\n            start = min(start,nums[i]);\\n            end = max(end,nums[i]);\\n        }\\n        \\n        end = min(mxnums,end);                             //updating end to max element which has consecutive elements\\n        start = max(mnnums,start);                         //updating start to smallest element which has consective elements\\n        \\n        \\n        for(int i=start;i<end;i++){\\n            if(map[i+1]!=0)count++;                        //traversing from start to end and increasing count if found consecutive elements\\n            else{\\n                mx = max(mx,count);                        //storing count in mx if not found consecutive element \\n                count=0;\\n            }\\n        }\\n        \\n        mx = max(mx,count);                             \\n        \\n        return mx;                                         //returning mx length of consecutive elements\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestConsecutive(vector<int>& nums) {\\n        if(nums.size()<=1)\\n            return nums.size();\\n        \\n        int mx = INT_MIN,count=1;                          //mx- length of longest consecutive sequence \\n        int mxnums = INT_MIN,mnnums=INT_MAX;               //mxnums - max element which may have consecutive element before that,mnnums-min element for same purpose\\n        int start = INT_MAX;                               //minimum element in nums\\n        int end = INT_MIN;                                 //maximum element in nums\\n        \\n        unordered_map<int,int>map;                         //map to store freq of element \\n        for(int x:nums)map[x]++;\\n        \\n        for(int i=0;i<nums.size();i++){\\n            if(map[nums[i]-1]!=0 && map[nums[i]+1]==0){\\n                mxnums = max(mxnums,nums[i]);               \\n            }\\n            if(map[nums[i]-1]==0 && map[nums[i]+1]!=0){\\n                mnnums = min(mnnums,nums[i]);\\n            }\\n            start = min(start,nums[i]);\\n            end = max(end,nums[i]);\\n        }\\n        \\n        end = min(mxnums,end);                             //updating end to max element which has consecutive elements\\n        start = max(mnnums,start);                         //updating start to smallest element which has consective elements\\n        \\n        \\n        for(int i=start;i<end;i++){\\n            if(map[i+1]!=0)count++;                        //traversing from start to end and increasing count if found consecutive elements\\n            else{\\n                mx = max(mx,count);                        //storing count in mx if not found consecutive element \\n                count=0;\\n            }\\n        }\\n        \\n        mx = max(mx,count);                             \\n        \\n        return mx;                                         //returning mx length of consecutive elements\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2239584,
                "title": "o-n-easiest-solution-with-explanation-c",
                "content": "We will first add all the elements in the unordered_set which will take us O(n) time. Also search operations on an unordered_set are O(1) operations.\\nThen we will traverse the given array and see if the current element is the starting element of a streak. It is only possible if (curr element - 1) is not present in the set.\\nIf we find an element with which the streak is starting we can simply check till where this streak continues and then update our answer.\\n\\nBelow is the C++ implementation of the above approach:\\n\\n```\\nclass Solution {\\npublic:\\n    int longestConsecutive(vector<int>& nums) {\\n        unordered_set<int> s(nums.begin(),nums.end());//declaring and adding elements in the set\\n        int ans = 0;\\n        for(int i=0;i<nums.size();i++) // traversing the vector\\n        {\\n            // if nums[i] - 1 is not found it means that it is \\n            // the starting element of a streak\\n            if(s.find(nums[i]-1)==s.end())\\n            {\\n                int end = nums[i];\\n\\t\\t\\t\\t// although it might seem that it is a O(n^2) solution as we are using nested loops but this \\n\\t\\t\\t\\t//while loop will only run if the element is the starting element of a streak and \\n\\t\\t\\t\\t//thus every element will be processed just once and thus making our time complexity O(n)\\n                while(s.find(end)!=s.end())\\n                    end++;\\n\\t\\t\\t\\t\\t\\n                ans = max(ans,end-nums[i]);// update the answer\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nUpvote this solution if you like it.",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestConsecutive(vector<int>& nums) {\\n        unordered_set<int> s(nums.begin(),nums.end());//declaring and adding elements in the set\\n        int ans = 0;\\n        for(int i=0;i<nums.size();i++) // traversing the vector\\n        {\\n            // if nums[i] - 1 is not found it means that it is \\n            // the starting element of a streak\\n            if(s.find(nums[i]-1)==s.end())\\n            {\\n                int end = nums[i];\\n\\t\\t\\t\\t// although it might seem that it is a O(n^2) solution as we are using nested loops but this \\n\\t\\t\\t\\t//while loop will only run if the element is the starting element of a streak and \\n\\t\\t\\t\\t//thus every element will be processed just once and thus making our time complexity O(n)\\n                while(s.find(end)!=s.end())\\n                    end++;\\n\\t\\t\\t\\t\\t\\n                ans = max(ans,end-nums[i]);// update the answer\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2239150,
                "title": "c-easy-solution-o-n-time-complexity-well-commented-code",
                "content": "Using unorderd_map as insertion and searching of any value can be done in O(1) complexity.\\n\\nMark all the element of nums as 1 in unorderd_map\\n\\nstore all the value whose value-1 not present in nums.\\n\\nstart traversing from value untill the value is not found in map and store the maximum value in the answer.\\n\\n```\\nclass Solution {\\npublic:\\n    int longestConsecutive(vector<int>& nums) {\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<nums.size();i++){\\n            mp[nums[i]]=1;\\n        }\\n        vector<int> temp;\\n        for(auto x:mp){\\n            int xy=x.first-1;\\n            if(mp.find(xy)==mp.end()){\\n                temp.push_back(x.first);\\n            }\\n        }\\n        int ans=0;\\n        for(auto x:temp){\\n            int j=x;\\n            int tempi=0;\\n            while(true){\\n                if(mp[j]==0)\\n                    break;\\n                tempi++;\\n                j++;\\n            }\\n            ans=max(ans,tempi);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestConsecutive(vector<int>& nums) {\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<nums.size();i++){\\n            mp[nums[i]]=1;\\n        }\\n        vector<int> temp;\\n        for(auto x:mp){\\n            int xy=x.first-1;\\n            if(mp.find(xy)==mp.end()){\\n                temp.push_back(x.first);\\n            }\\n        }\\n        int ans=0;\\n        for(auto x:temp){\\n            int j=x;\\n            int tempi=0;\\n            while(true){\\n                if(mp[j]==0)\\n                    break;\\n                tempi++;\\n                j++;\\n            }\\n            ans=max(ans,tempi);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2238778,
                "title": "c-2-approaches-o-n-solution-beginner-friendly-easy-short",
                "content": "**UPVOTE IF YOU FIND IT USEFUL**\\n\\n**Time Complexity : O(N)\\nSpace : O(N)**\\n```\\nclass Solution {\\npublic:\\n    // Optimised version\\n    \\n    int longestConsecutive(vector<int>& nums) \\n    {\\n       int n=nums.size();\\n        if(n==0)\\n         return 0;\\n       \\n        unordered_set<int>st;\\n        int ans=0;\\n        \\n\\t\\t//  insert all the elements of nums into a hashset. \\n        for(auto i:nums)\\n            st.insert(i);\\n       \\n\\t   /* we can just iterate over the hashset to find longest consecutive sequence involving the current \\n\\t   element under iteration. We will iterate over elements that are consecutive to num till we keep finding \\n\\t   them in the set. Each time we will also delete those elements from set to ensure we only visit them once.*/\\n\\t     for(auto i : st)\\n        {\\n           int count=1;\\n        \\n\\t\\t/* for checking elements which are consecutive and less that current element \\n\\t\\tEg: if we have element 4 we will check for  3,2,1... and so on.  */\\n            for(int j=1;st.count(i-j);j++)\\n            {\\n                count++;\\n                st.erase(i-j);\\n            }\\n            \\n\\t\\t/* for checking elements which are consecutive and less that current element \\n\\t\\tEg: if we have element 4 we will check for  5,6,7... and so on.  */\\t\\n            for(int j=1;st.count(i+j);j++)\\n            {\\n                count++;\\n                st.erase(i+j);\\n            }\\n            ans=max(ans,count);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n\\n**Time Complexity : O(NlogN)**\\n**Space : O(1)**\\n```\\nclass Solution {\\npublic:\\n    int longestConsecutive(vector<int>& nums) {\\n       int n=nums.size();\\n        if(n==0)\\n           return 0;\\n\\t\\t\\n\\t\\t// sort the vector so that the consecutive elements become adjacent to each other\\n        sort(nums.begin(),nums.end());\\n        int prev=nums[0];\\n        int c=1,ans=0;\\n        for(int i=1;i<n;i++)\\n        {\\n             /*nums[i] == nums[i-1]+ 1: This means the current element is consecutive to previous, \\n\\t\\t\\t  so increment current streak count. */\\n            if(nums[i]==prev+1)\\n            {\\n                prev=nums[i];\\n                c++;\\n            }\\n\\t\\t\\t\\n\\t\\t  /*nums[i] == nums[i-1]: We have found the same element as previous. Skip it, and see if we can\\n\\t\\tstill extend the sequence with next elements.*/\\n\\t\\t\\n\\t\\t/* when nums[i]!=nums[i-1] means we have got one of our answers,  now we can search next \\n\\t\\tlongest  sequence */\\n\\t\\t\\n            else if(nums[i] != prev)\\n            {\\n                ans=max(c,ans);\\n                c=1;\\n                prev=nums[i];\\n            }\\n        }\\n        ans=max(c,ans);\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // Optimised version\\n    \\n    int longestConsecutive(vector<int>& nums) \\n    {\\n       int n=nums.size();\\n        if(n==0)\\n         return 0;\\n       \\n        unordered_set<int>st;\\n        int ans=0;\\n        \\n\\t\\t//  insert all the elements of nums into a hashset. \\n        for(auto i:nums)\\n            st.insert(i);\\n       \\n\\t   /* we can just iterate over the hashset to find longest consecutive sequence involving the current \\n\\t   element under iteration. We will iterate over elements that are consecutive to num till we keep finding \\n\\t   them in the set. Each time we will also delete those elements from set to ensure we only visit them once.*/\\n\\t     for(auto i : st)\\n        {\\n           int count=1;\\n        \\n\\t\\t/* for checking elements which are consecutive and less that current element \\n\\t\\tEg: if we have element 4 we will check for  3,2,1... and so on.  */\\n            for(int j=1;st.count(i-j);j++)\\n            {\\n                count++;\\n                st.erase(i-j);\\n            }\\n            \\n\\t\\t/* for checking elements which are consecutive and less that current element \\n\\t\\tEg: if we have element 4 we will check for  5,6,7... and so on.  */\\t\\n            for(int j=1;st.count(i+j);j++)\\n            {\\n                count++;\\n                st.erase(i+j);\\n            }\\n            ans=max(ans,count);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int longestConsecutive(vector<int>& nums) {\\n       int n=nums.size();\\n        if(n==0)\\n           return 0;\\n\\t\\t\\n\\t\\t// sort the vector so that the consecutive elements become adjacent to each other\\n        sort(nums.begin(),nums.end());\\n        int prev=nums[0];\\n        int c=1,ans=0;\\n        for(int i=1;i<n;i++)\\n        {\\n             /*nums[i] == nums[i-1]+ 1: This means the current element is consecutive to previous, \\n\\t\\t\\t  so increment current streak count. */\\n            if(nums[i]==prev+1)\\n            {\\n                prev=nums[i];\\n                c++;\\n            }\\n\\t\\t\\t\\n\\t\\t  /*nums[i] == nums[i-1]: We have found the same element as previous. Skip it, and see if we can\\n\\t\\tstill extend the sequence with next elements.*/\\n\\t\\t\\n\\t\\t/* when nums[i]!=nums[i-1] means we have got one of our answers,  now we can search next \\n\\t\\tlongest  sequence */\\n\\t\\t\\n            else if(nums[i] != prev)\\n            {\\n                ans=max(c,ans);\\n                c=1;\\n                prev=nums[i];\\n            }\\n        }\\n        ans=max(c,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2103444,
                "title": "c-t-o-n",
                "content": "```\\nint longestConsecutive(vector<int>& nums) {\\n\\tunordered_map<int,bool> m;\\n\\n\\tint n=nums.size();\\n\\tfor(int z=0;z<n;z++)\\n\\t{\\n\\t\\tm[nums[z]]=1;\\n\\t}\\n\\tint ans=0;\\n\\tfor(int z=0;z<n;z++)\\n\\t{\\n\\t\\tif(!m[nums[z]-1])\\n\\t\\t{\\n\\t\\t\\tint k=nums[z];\\n\\t\\t\\tint temp=0;\\n\\t\\t\\twhile(m[k])\\n\\t\\t\\t{\\n\\t\\t\\t\\ttemp++;\\n\\t\\t\\t\\tk++;\\n\\t\\t\\t}\\n\\t\\t\\tans=max(ans,temp);\\n\\t\\t}\\n\\t}\\n\\treturn ans;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint longestConsecutive(vector<int>& nums) {\\n\\tunordered_map<int,bool> m;\\n\\n\\tint n=nums.size();\\n\\tfor(int z=0;z<n;z++)\\n\\t{\\n\\t\\tm[nums[z]]=1;\\n\\t}\\n\\tint ans=0;\\n\\tfor(int z=0;z<n;z++)\\n\\t{\\n\\t\\tif(!m[nums[z]-1])\\n\\t\\t{\\n\\t\\t\\tint k=nums[z];\\n\\t\\t\\tint temp=0;\\n\\t\\t\\twhile(m[k])\\n\\t\\t\\t{\\n\\t\\t\\t\\ttemp++;\\n\\t\\t\\t\\tk++;\\n\\t\\t\\t}\\n\\t\\t\\tans=max(ans,temp);\\n\\t\\t}\\n\\t}\\n\\treturn ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1284810,
                "title": "c-unordered-set-priority-queue-o-n",
                "content": "We can solve this problem using Unordered Set and Min-Heap.\\nThe running time for both the solutions is O(n)\\n\\nUnordered Set\\n```\\n\\tint longesetConsecutive(vector<int>& nums){\\n\\t\\tint count = 1; \\n\\t\\tint max_count = 0;\\n\\t\\tint i, j; // i - traverse array, j - traverse consecutive numbers\\n\\n\\t\\tunordered_set<int> uset(nums.begin(), nums.end());\\n\\n\\t\\tfor(i = 0; i < nums.size(); i++){\\n\\t\\t\\tj = 1; count = 1;\\n\\t\\t\\t\\n\\t\\t\\t// Check if the previous consecutive number exists, if not find all consecutive number greater than nums[i]\\n\\t\\t\\tif(uset.find(nums[i] - 1) == uset.end()){\\n\\t\\t\\t\\twhile(uset.find(nums[i]+j) != uset.end()){\\n\\t\\t\\t\\t\\tj++; count++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\tmax_count = max(count, max_count);\\n\\t\\t}\\n\\t\\treturn max_count;\\n\\t}\\n```\\n\\n\\nPriority Queues : Min-Heap\\n```\\n    int longestConsecutive(vector<int>& nums) {\\n        int min; // store minimum value of priority queue\\n        int count = 1;  //count the number of consecutive values\\n        int max_count = 0; //store maximum number of consecutive values\\n\\n        priority_queue<int, vector<int>, greater<int>> heap(nums.begin(), nums.end()); // initializing a min-heap\\n\\n        for(int i = 0; i < nums.size(); i++){\\n\\n            min = heap.top(); // store the minimum value in min\\n            heap.pop(); // delete the minimum value from heap\\n\\n            if(min + 1 == heap.top()) count++; // if new minimum is 1+previous minimum increase count\\n            else if(min != heap.top()) count = 1; // if new minimum is not same as the previous minimum restart count \\n\\n            max_count = max(count, max_count); // take the maximum of count and maximum count\\n        }\\n\\n        return max_count;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n\\tint longesetConsecutive(vector<int>& nums){\\n\\t\\tint count = 1; \\n\\t\\tint max_count = 0;\\n\\t\\tint i, j; // i - traverse array, j - traverse consecutive numbers\\n\\n\\t\\tunordered_set<int> uset(nums.begin(), nums.end());\\n\\n\\t\\tfor(i = 0; i < nums.size(); i++){\\n\\t\\t\\tj = 1; count = 1;\\n\\t\\t\\t\\n\\t\\t\\t// Check if the previous consecutive number exists, if not find all consecutive number greater than nums[i]\\n\\t\\t\\tif(uset.find(nums[i] - 1) == uset.end()){\\n\\t\\t\\t\\twhile(uset.find(nums[i]+j) != uset.end()){\\n\\t\\t\\t\\t\\tj++; count++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\tmax_count = max(count, max_count);\\n\\t\\t}\\n\\t\\treturn max_count;\\n\\t}\\n```\n```\\n    int longestConsecutive(vector<int>& nums) {\\n        int min; // store minimum value of priority queue\\n        int count = 1;  //count the number of consecutive values\\n        int max_count = 0; //store maximum number of consecutive values\\n\\n        priority_queue<int, vector<int>, greater<int>> heap(nums.begin(), nums.end()); // initializing a min-heap\\n\\n        for(int i = 0; i < nums.size(); i++){\\n\\n            min = heap.top(); // store the minimum value in min\\n            heap.pop(); // delete the minimum value from heap\\n\\n            if(min + 1 == heap.top()) count++; // if new minimum is 1+previous minimum increase count\\n            else if(min != heap.top()) count = 1; // if new minimum is not same as the previous minimum restart count \\n\\n            max_count = max(count, max_count); // take the maximum of count and maximum count\\n        }\\n\\n        return max_count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1254518,
                "title": "simple-c-easy-solution-commented",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestConsecutive(vector<int>& nums) {\\n        unordered_set<int> s;\\n        \\n        //an empty list\\n        if(nums.size()==0){\\n            return 0;\\n        }\\n        \\n        //insert all the values into a set\\n        for(int i=0;i<nums.size();i++){\\n            s.insert(nums[i]);\\n        }\\n        \\n        \\n        int count=1;  // since a number itself can be a sequence\\n        for(int i=0;i<nums.size();i++){\\n            \\n            //find the starting value of the sequence\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0if(!s.count(nums[i]-1)){\\n                int curr_num=nums[i];\\n                int curr_count=0;\\n                //find the consecutive sequence\\n                while(s.find(curr_num)!=s.end()){\\n                    curr_count++;\\n                    curr_num++;\\n                }\\n                count=max(count,curr_count);\\n            }\\n        }\\n        return count;\\n        \\n    }\\n};\\n```\\n**Please upvote if this helps you :)**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestConsecutive(vector<int>& nums) {\\n        unordered_set<int> s;\\n        \\n        //an empty list\\n        if(nums.size()==0){\\n            return 0;\\n        }\\n        \\n        //insert all the values into a set\\n        for(int i=0;i<nums.size();i++){\\n            s.insert(nums[i]);\\n        }\\n        \\n        \\n        int count=1;  // since a number itself can be a sequence\\n        for(int i=0;i<nums.size();i++){\\n            \\n            //find the starting value of the sequence\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0if(!s.count(nums[i]-1)){\\n                int curr_num=nums[i];\\n                int curr_count=0;\\n                //find the consecutive sequence\\n                while(s.find(curr_num)!=s.end()){\\n                    curr_count++;\\n                    curr_num++;\\n                }\\n                count=max(count,curr_count);\\n            }\\n        }\\n        return count;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1205184,
                "title": "union-find-solution",
                "content": "```\\nclass UnionFind {\\nprivate:\\n    typedef vector<int> vi;\\n    vi parent;\\n    vi parentSize;\\n    vi rank;\\n    int maxGroup;\\npublic:\\n    UnionFind(int N) {\\n        for(int i=0; i<N; i++) {\\n            parent.push_back(i);\\n            parentSize.push_back(1);\\n            rank.push_back(0);\\n            maxGroup = 1;\\n        }\\n    }\\n    \\n    int find(int x) {\\n        if (parent[x] == x) return x;\\n        parent[x] = find(parent[x]);\\n        return parent[x];\\n    }\\n    \\n    bool isSame(int x, int y) {\\n        return find(x) == find(y);\\n    }\\n    \\n    void join(int x, int y) {\\n        if (!isSame(x, y)) {\\n            int px = parent[x];\\n            int py = parent[y];\\n            if (rank[px] < rank[py]) {\\n                parent[px] = py;\\n                parentSize[py] += parentSize[px];\\n                if (maxGroup < parentSize[py]) maxGroup = parentSize[py];\\n            } else {\\n                parent[py] = px;\\n                parentSize[px] += parentSize[py];\\n                if (maxGroup < parentSize[px]) maxGroup = parentSize[px];\\n                if (rank[py] == rank[px]) rank[px] += 1;\\n            } \\n        }\\n    }\\n    \\n    int maxGroupSize() {\\n        return maxGroup;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int longestConsecutive(vector<int>& nums) {\\n        if (nums.empty()) return 0;\\n        unordered_map<int, int> mp;\\n        int idx = 0;\\n        for(int i=0; i<nums.size(); i++) \\n            if (!mp.count(nums[i]))\\n                mp[nums[i]] = idx++;\\n        UnionFind uf = UnionFind(mp.size());\\n        for(auto &[k,v]: mp) {\\n            if (mp.count(k-1))\\n                uf.join(v,mp[k-1]);\\n        }\\n        return uf.maxGroupSize();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass UnionFind {\\nprivate:\\n    typedef vector<int> vi;\\n    vi parent;\\n    vi parentSize;\\n    vi rank;\\n    int maxGroup;\\npublic:\\n    UnionFind(int N) {\\n        for(int i=0; i<N; i++) {\\n            parent.push_back(i);\\n            parentSize.push_back(1);\\n            rank.push_back(0);\\n            maxGroup = 1;\\n        }\\n    }\\n    \\n    int find(int x) {\\n        if (parent[x] == x) return x;\\n        parent[x] = find(parent[x]);\\n        return parent[x];\\n    }\\n    \\n    bool isSame(int x, int y) {\\n        return find(x) == find(y);\\n    }\\n    \\n    void join(int x, int y) {\\n        if (!isSame(x, y)) {\\n            int px = parent[x];\\n            int py = parent[y];\\n            if (rank[px] < rank[py]) {\\n                parent[px] = py;\\n                parentSize[py] += parentSize[px];\\n                if (maxGroup < parentSize[py]) maxGroup = parentSize[py];\\n            } else {\\n                parent[py] = px;\\n                parentSize[px] += parentSize[py];\\n                if (maxGroup < parentSize[px]) maxGroup = parentSize[px];\\n                if (rank[py] == rank[px]) rank[px] += 1;\\n            } \\n        }\\n    }\\n    \\n    int maxGroupSize() {\\n        return maxGroup;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int longestConsecutive(vector<int>& nums) {\\n        if (nums.empty()) return 0;\\n        unordered_map<int, int> mp;\\n        int idx = 0;\\n        for(int i=0; i<nums.size(); i++) \\n            if (!mp.count(nums[i]))\\n                mp[nums[i]] = idx++;\\n        UnionFind uf = UnionFind(mp.size());\\n        for(auto &[k,v]: mp) {\\n            if (mp.count(k-1))\\n                uf.join(v,mp[k-1]);\\n        }\\n        return uf.maxGroupSize();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1156381,
                "title": "c-faster",
                "content": "***Do upvote if you found it helpful to keep me motivated***\\n```\\nclass Solution {\\npublic:\\n    int longestConsecutive(vector<int>& nums) {\\n        if(nums.size()==0)\\n            return 0;\\n        \\n      int i , c=0 , res=1;\\n        set<int> s;\\n        for(i=0;i<nums.size();i++)\\n          s.insert(nums[i]);\\n        vector<int> v;\\n        for(auto x: s)\\n        v.push_back(x);\\n      \\n        for(i=1;i<v.size()-1;i++)\\n        {\\n            if(i>0 && v[i] == v[i-1]+1)\\n            {\\n             c++;\\n             res=max(res,c);\\n            }\\n            else\\n            c=1;\\n        }\\n        return res;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int longestConsecutive(vector<int>& nums) {\\n        if(nums.size()==0)\\n            return 0;\\n        \\n      int i , c=0 , res=1;\\n        set<int> s;\\n        for(i=0;i<nums.size();i++)\\n          s.insert(nums[i]);\\n        vector<int> v;\\n        for(auto x: s)\\n        v.push_back(x);\\n      \\n        for(i=1;i<v.size()-1;i++)\\n        {\\n            if(i>0 && v[i] == v[i-1]+1)\\n            {\\n             c++;\\n             res=max(res,c);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1076733,
                "title": "javascript",
                "content": "```js\\nvar longestConsecutive = function(A) {\\n    const M = {}; // {number: length}\\n    let ret = 0;\\n    for (let a of A) {\\n        if (M[a]) continue; // duplicates\\n        const left = M[a - 1] || 0;\\n        const right = M[a + 1] || 0;\\n        const length = left + right + 1;\\n        ret = Math.max(ret, length);\\n        M[a] = length;\\n        M[a - left] = length;\\n        M[a + right] = length;\\n    }\\n    return ret;\\n};\\n```",
                "solutionTags": [],
                "code": "```js\\nvar longestConsecutive = function(A) {\\n    const M = {}; // {number: length}\\n    let ret = 0;\\n    for (let a of A) {\\n        if (M[a]) continue; // duplicates\\n        const left = M[a - 1] || 0;\\n        const right = M[a + 1] || 0;\\n        const length = left + right + 1;\\n        ret = Math.max(ret, length);\\n        M[a] = length;\\n        M[a - left] = length;\\n        M[a + right] = length;\\n    }\\n    return ret;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 947055,
                "title": "java-o-n-union-find-thought-process",
                "content": "**Intuition**\\n\\n* Given an input array of size `n`, imagine `n` components of size 1 each.\\n* Merge components together if *connected* by a consecutive number.\\n* Find the size of the largest connected component.\\n\\n**Code**\\n\\n* Define a class `UnionFind` to abstract the union operation and the connected component state.\\n* Maintain a map between a number and the index of the number in the array. Use the index from this map to refer to a value in the union find data structure.\\n\\n```\\nclass Solution {\\n    private class UnionFind {\\n        private int[] vals;\\n        private int[] sizes;\\n        private int[] ranks;\\n        \\n        public UnionFind(int n) {\\n            this.vals = new int[n];\\n            this.sizes = new int[n];\\n            this.ranks = new int[n];\\n            \\n            for (int i = 0; i < n; i++) {\\n                vals[i] = i;\\n                sizes[i] = 1;\\n            }\\n        }\\n        \\n        public void union(int i, int j) {\\n            int iroot = root(i);\\n            int jroot = root(j);\\n            \\n            if (iroot == jroot) {\\n                return;\\n            }\\n            \\n            // union by rank\\n            if (ranks[iroot] > ranks[jroot]) {\\n                vals[jroot] = iroot;\\n                ranks[iroot]++;\\n                sizes[iroot] += sizes[jroot];\\n            } else {\\n                vals[iroot] = jroot;\\n                ranks[jroot]++;\\n                sizes[jroot] += sizes[iroot];\\n            }\\n        }\\n\\n        private int root(int i) {\\n            int ret = i;\\n\\n            while (ret != vals[ret]) {\\n                vals[ret] = vals[vals[ret]]; // path compression\\n                ret = vals[ret];\\n            }\\n            \\n            return ret;\\n        }\\n        \\n        public int getMaxSize() {\\n            int ret = Integer.MIN_VALUE;\\n            for (int s : sizes) {\\n                ret = Math.max(ret, s);\\n            }\\n            \\n            return ret;\\n        }\\n    }\\n\\n    public int longestConsecutive(int[] nums) {\\n        int n = nums.length;\\n        if (n <= 1) {\\n            return n;\\n        }\\n        Map<Integer, Integer> numToIdx = new HashMap();\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            numToIdx.put(nums[i], i);\\n        }\\n\\n        UnionFind uf = new UnionFind(nums.length);\\n        \\n        for (int num : nums) {\\n            int idx = numToIdx.get(num);\\n            int nextNumIdx = numToIdx.getOrDefault(num+1, -1);\\n            int prevNumIdx = numToIdx.getOrDefault(num-1, -1);\\n\\n            if (nextNumIdx != -1) {\\n                uf.union(idx, nextNumIdx);\\n            }\\n            if (prevNumIdx != -1) {\\n                uf.union(idx, prevNumIdx);\\n            }\\n        }\\n        \\n        return uf.getMaxSize();\\n    }\\n}\\n```\\n\\nPlease note that the union find implementation above has two optimizations:\\n\\n1. Union by rank (merge a tree of smaller height under a tree of greater height)\\n2. Path compression (as we walk the parent-link to find the root, compress the path)\\n\\n**Analysis**\\n\\nLet N be the length of the input array.\\n\\nThe algorithm takes `~O(N)` time because for each number, it does a constant amount of work by unioning components. (Concretely, unioning takes `~O(log*N)` time where `log*` is an iterated logarithm, a number of times a logarithm has to be applied before the result is less than or equal to 1).\\n\\nIt takes `~O(N)` space to initiailze the union find data structure, as well as the hash map to keep indices.\\n\\n**Further thoughts**\\n\\nIt does not seem to matter if the input contains duplicate. After all, by using a hash map from a number to an index, the algorithm will only consider one of the duplicates.",
                "solutionTags": [
                    "Java",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\n    private class UnionFind {\\n        private int[] vals;\\n        private int[] sizes;\\n        private int[] ranks;\\n        \\n        public UnionFind(int n) {\\n            this.vals = new int[n];\\n            this.sizes = new int[n];\\n            this.ranks = new int[n];\\n            \\n            for (int i = 0; i < n; i++) {\\n                vals[i] = i;\\n                sizes[i] = 1;\\n            }\\n        }\\n        \\n        public void union(int i, int j) {\\n            int iroot = root(i);\\n            int jroot = root(j);\\n            \\n            if (iroot == jroot) {\\n                return;\\n            }\\n            \\n            // union by rank\\n            if (ranks[iroot] > ranks[jroot]) {\\n                vals[jroot] = iroot;\\n                ranks[iroot]++;\\n                sizes[iroot] += sizes[jroot];\\n            } else {\\n                vals[iroot] = jroot;\\n                ranks[jroot]++;\\n                sizes[jroot] += sizes[iroot];\\n            }\\n        }\\n\\n        private int root(int i) {\\n            int ret = i;\\n\\n            while (ret != vals[ret]) {\\n                vals[ret] = vals[vals[ret]]; // path compression\\n                ret = vals[ret];\\n            }\\n            \\n            return ret;\\n        }\\n        \\n        public int getMaxSize() {\\n            int ret = Integer.MIN_VALUE;\\n            for (int s : sizes) {\\n                ret = Math.max(ret, s);\\n            }\\n            \\n            return ret;\\n        }\\n    }\\n\\n    public int longestConsecutive(int[] nums) {\\n        int n = nums.length;\\n        if (n <= 1) {\\n            return n;\\n        }\\n        Map<Integer, Integer> numToIdx = new HashMap();\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            numToIdx.put(nums[i], i);\\n        }\\n\\n        UnionFind uf = new UnionFind(nums.length);\\n        \\n        for (int num : nums) {\\n            int idx = numToIdx.get(num);\\n            int nextNumIdx = numToIdx.getOrDefault(num+1, -1);\\n            int prevNumIdx = numToIdx.getOrDefault(num-1, -1);\\n\\n            if (nextNumIdx != -1) {\\n                uf.union(idx, nextNumIdx);\\n            }\\n            if (prevNumIdx != -1) {\\n                uf.union(idx, prevNumIdx);\\n            }\\n        }\\n        \\n        return uf.getMaxSize();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 871162,
                "title": "simple-o-n-solution-using-hashmap-in-c-faster-than-91-16-longest-consecutive-sequence",
                "content": "class Solution {\\npublic:\\n\\n    int longestConsecutive(vector<int>& nums) {\\n        if (nums.size() == 0) {\\n            return 0;\\n        }\\n\\t\\t\\n        unordered_map<int, bool> mp;\\n        \\n        for (int i = 0; i < nums.size(); i++) {\\n            mp[nums[i]] = true;\\n        }\\n        \\n        int maxCount = 0;\\n        \\n        for (int i = 0; i < nums.size(); i++) {\\n            int count = 0;\\n            int num = nums[i];\\n            int tempNum = num;\\n            \\n            while (mp[tempNum] == true) {\\n                mp[tempNum] = false;\\n                tempNum++;\\n                count++;\\n            }\\n            \\n            tempNum = num-1;\\n            \\n            while (mp[tempNum] == true) {\\n                mp[tempNum] = false;\\n                tempNum--;\\n                count++;\\n            }\\n            \\n            maxCount = max(maxCount, count);\\n        }\\n        return maxCount;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int longestConsecutive(vector<int>& nums) {\\n        if (nums.size() == 0) {\\n            return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 852984,
                "title": "python-3-faster-than-91-86",
                "content": "*Runtime: 52 ms, faster than 91.86% of Python3 online submissions for Longest Consecutive Sequence.\\nMemory Usage: 14.9 MB, less than 90.09% of Python3 online submissions for Longest Consecutive Sequence.*\\n\\n```python\\nclass Solution:\\n    def longestConsecutive(self, nums: List[int]) -> int:\\n        if not nums: return 0\\n        # store nums in memory\\n        memory = set(nums)\\n        # explore the chains of consecutive numbers in the array\\n        current_max = 1\\n        for e in nums:\\n            # is it the begining of the chain\\n            if e - 1 in memory: continue\\n            counter = 1\\n            while e + 1 in memory:\\n                counter += 1\\n                e += 1\\n            # update max\\n            current_max = max(current_max, counter)\\n        return current_max\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def longestConsecutive(self, nums: List[int]) -> int:\\n        if not nums: return 0\\n        # store nums in memory\\n        memory = set(nums)\\n        # explore the chains of consecutive numbers in the array\\n        current_max = 1\\n        for e in nums:\\n            # is it the begining of the chain\\n            if e - 1 in memory: continue\\n            counter = 1\\n            while e + 1 in memory:\\n                counter += 1\\n                e += 1\\n            # update max\\n            current_max = max(current_max, counter)\\n        return current_max\\n```",
                "codeTag": "Java"
            },
            {
                "id": 773690,
                "title": "simple-o-n-python-solution-with-explanation",
                "content": "Base Case: If nums is null, longest seq will be zero ofc\\n\\nFor each number, we will only consider it if there is no number = n -1 so that we can fully count the longest potential sequence.\\n\\nThe most efficient way to check membership is with a set. Each check is O(1). \\n\\nWe keep checking whether n+1 is in nums through the set and increment our count.\\n\\nWe return the longest count\\n```\\nclass Solution:\\n    def longestConsecutive(self, nums: List[int]) -> int:\\n        if not nums:\\n            return 0\\n        \\n        num_set = set(nums)\\n        longest = 0\\n        for n in nums:\\n            if n-1 not in num_set:\\n                length = 0\\n                while n in num_set:\\n                    length += 1\\n                    n += 1\\n                longest = max(longest, length)\\n        return longest\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestConsecutive(self, nums: List[int]) -> int:\\n        if not nums:\\n            return 0\\n        \\n        num_set = set(nums)\\n        longest = 0\\n        for n in nums:\\n            if n-1 not in num_set:\\n                length = 0\\n                while n in num_set:\\n                    length += 1\\n                    n += 1\\n                longest = max(longest, length)\\n        return longest\\n```",
                "codeTag": "Java"
            },
            {
                "id": 649609,
                "title": "my-concise-java-solution-with-picture-explanation",
                "content": "\\nThanks [@dchen0215](https://leetcode.com/problems/longest-consecutive-sequence/discuss/41055/My-really-simple-Java-O(n)) and [@wangliang](https://leetcode.wang/leetcode-128-Longest-Consecutive-Sequence.html)  \\n\\n![](https://yyc-images.oss-cn-beijing.aliyuncs.com/leetcode_128_improve_2020_0524.png)  \\n\\n\\n``` java\\nclass Solution {\\n    public int longestConsecutive(int[] nums) {\\n        HashMap<Integer, Integer> hMap = new HashMap<>(64);\\n        int max = 0;\\n        for (int n: nums){\\n            if (hMap.containsKey(n)){\\n                continue;\\n            }\\n            int l = hMap.getOrDefault(n - 1, 0);\\n            int r = hMap.getOrDefault(n + 1, 0);\\n            int sum = l + r + 1;\\n            max = Math.max(max, sum);\\n            hMap.put(n, sum);\\n            if (l > 0) hMap.put(n - l, sum);\\n            if (r > 0) hMap.put(n + r, sum);\\n        }\\n        return max;\\n    }\\n}\\n```\\n\\n`Enjoy it!`",
                "solutionTags": [],
                "code": "``` java\\nclass Solution {\\n    public int longestConsecutive(int[] nums) {\\n        HashMap<Integer, Integer> hMap = new HashMap<>(64);\\n        int max = 0;\\n        for (int n: nums){\\n            if (hMap.containsKey(n)){\\n                continue;\\n            }\\n            int l = hMap.getOrDefault(n - 1, 0);\\n            int r = hMap.getOrDefault(n + 1, 0);\\n            int sum = l + r + 1;\\n            max = Math.max(max, sum);\\n            hMap.put(n, sum);\\n            if (l > 0) hMap.put(n - l, sum);\\n            if (r > 0) hMap.put(n + r, sum);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 427141,
                "title": "javascript-solution",
                "content": "#### The Idea\\n1. Save numbers as a set\\n2. Count concecutive numbers within the set by keep adding 1 and record max\\n3. Only check numbers that is the smallest in a concecutive  (`!set.has(num-1)`) to archive O(n).\\n```\\nvar longestConsecutive = function(nums) {\\n    let set = new Set();\\n    let c = 0, max = 0;\\n    for (let num of nums) {\\n        set.add(num);\\n    }\\n\\n    for (let num of nums) {\\n        if (!set.has(num-1)){\\n            let temp = num;\\n            while (set.has(temp++)) {\\n                c++;\\n                max = Math.max(max, c);\\n            }\\n            c = 0;\\n        }\\n    }\\n    return max;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar longestConsecutive = function(nums) {\\n    let set = new Set();\\n    let c = 0, max = 0;\\n    for (let num of nums) {\\n        set.add(num);\\n    }\\n\\n    for (let num of nums) {\\n        if (!set.has(num-1)){\\n            let temp = num;\\n            while (set.has(temp++)) {\\n                c++;\\n                max = Math.max(max, c);\\n            }\\n            c = 0;\\n        }\\n    }\\n    return max;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 324239,
                "title": "c-40-85-beat-simple-walking-solution-o-n-requires-o-3n-space",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestConsecutive(vector<int>& nums) {\\n        \\n        int aResult = 0, aStreak = 0, aLeft = 0, aRight = 0;\\n        unordered_map<int, int> aMap;\\n        unordered_set<int> aVisited;\\n        \\n        for (auto aNum : nums) {\\n            if (aVisited.count(aNum) == 0) {\\n            \\n                aLeft = aMap[aNum - 1];\\n                aRight = aMap[aNum + 1];\\n                \\n                aStreak = aLeft + aRight + 1;\\n\\n                if (aLeft != 0 ) { aMap[aNum - aLeft] = aStreak; }\\n                if (aRight != 0) { aMap[aNum + aRight] = aStreak; }\\n                \\n                aMap[aNum] = aStreak;\\n                aVisited.insert(aNum);\\n\\n                aResult = max(aStreak, aResult);\\n            }\\n        }\\n        return aResult;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestConsecutive(vector<int>& nums) {\\n        \\n        int aResult = 0, aStreak = 0, aLeft = 0, aRight = 0;\\n        unordered_map<int, int> aMap;\\n        unordered_set<int> aVisited;\\n        \\n        for (auto aNum : nums) {\\n            if (aVisited.count(aNum) == 0) {\\n            \\n                aLeft = aMap[aNum - 1];\\n                aRight = aMap[aNum + 1];\\n                \\n                aStreak = aLeft + aRight + 1;\\n\\n                if (aLeft != 0 ) { aMap[aNum - aLeft] = aStreak; }\\n                if (aRight != 0) { aMap[aNum + aRight] = aStreak; }\\n                \\n                aMap[aNum] = aStreak;\\n                aVisited.insert(aNum);\\n\\n                aResult = max(aStreak, aResult);\\n            }\\n        }\\n        return aResult;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 225131,
                "title": "java-solutions",
                "content": "**Solution 1: Using Set**\\n\\n**Algorithm:**\\n- The numbers are stored in a `Set` to allow constant time lookups.\\n- We only attempt to build sequences from numbers that are not already part of a longer sequence. \\n- This is accomplished by first ensuring that the number that would immediately precede the current number in a sequence is not present in the set, as that number would necessarily be part of a longer sequence.\\n\\n**Complexity Analysis:**\\n- While loop is executed only when `n - 1` is not present in array, so that computations can be started from the lowest number in the consecutive sequence. So the while loop can run for `n` iterations throughout the entire runtime of the algorithm. \\n- This means that despite looking like `O(n * n)` complexity, the nested loops actually run in `O(n + n) = O(n)` time. All other computations occur in constant time, so the overall runtime is linear.\\n- We are using set to store all the array elements, so space complexity is also linear.\\n\\nTime complexity: `O(n)`\\nSpace complexity: `O(n)`\\n\\n```\\nclass Solution \\n{\\n\\tpublic int longestConsecutive(int[] A)\\n\\t{\\n        Set<Integer> set = new HashSet<>();\\n        int max = 0;\\n\\t\\t\\n\\t\\tfor(int n : A)\\n            set.add(n);\\n\\t\\t\\n        for(int n : A)\\n\\t\\t{\\n            if(!set.contains(n - 1))\\n\\t\\t\\t{\\n                int count = 0;\\n\\n                while(set.contains(n++))\\n                    count++;\\n\\n\\t\\t\\t\\tmax = Math.max(max, count);\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```\\n\\n**Solution 2: Sorting**\\n\\n**Algorithm:**\\n- Sort an array and consider each number up to the second last since we need to compare each number to its next number. \\n- If the current number and the next are equal, then our current sequence is neither extended nor broken, so we simply move on to the next number. \\n- If they are unequal, then we must check whether the next number extends the sequence, i.e. `A[i] + 1 == A[i + 1]`. If it does, then we update the count and continue. Otherwise, the sequence is broken, so we record our current sequence count and reset the counter to `1` to include the number that broke the sequence. \\n- It is possible that the last element of an array is a part of the longest sequence, so we return the maximum of the current sequence count and the longest one.\\n\\nTime complexity: `O(n log n)` - The main for loop does constant work for `n` times, so the algorithm\\'s time complexity is dominated by the sorting runtime.\\nSpace complexity: `O(1)`\\n\\n```\\nclass Solution \\n{\\n\\tpublic int longestConsecutive(int[] A)\\n\\t{\\n        if(A.length == 0)\\n            return 0;\\n\\n        int count = 1, max = 0;\\n\\t\\tArrays.sort(A);\\n        \\n\\t\\tfor(int i = 0; i < A.length - 1; i++)\\n        {\\n            if(A[i] != A[i + 1])\\n            {\\n                if(A[i] + 1 == A[i + 1])\\n                {\\n                    count++;\\n                }\\n                else\\n                {\\n                    max = Math.max(max, count);\\n                    count = 1;\\n                }    \\n            }\\n        }\\n        return Math.max(max, count);\\n    }\\n}\\n```\\n\\n**Solution 3: Brute-Force Algorithm**\\n\\n**Algorithm:**\\n- The brute force algorithm just considers each number in array, attempting to count as many as possible from that number using the subsequent consecutive numbers in array. \\n- When array does not contain the next number in consecutive sequence, current sequence count is recorded if it is larger than the current maximum.\\n\\n**Complexity Analysis:**\\n- The outer loop runs exactly n times to process each element of an array. While loops also runs in `O(n)` time, since current number `n` is incremented by `1` during each iteration of the while loop. Then, on each iteration of the while loop, an `O(n)` lookup in the array (linear search) is performed. Therefore, this brute-force algorithm is having three nested `O(n)` loops, which compound multiplicatively to a cubic runtime, `O(n * n * n)`\\n\\nTime complexity: `O(n^3)`\\nSpace complexity: `O(1)`\\n\\n```\\nclass Solution\\n{\\n    public int longestConsecutive(int[] A)\\n\\t{\\n        int max = 0;\\n\\n        for (int n : A)\\n\\t\\t{\\n            int count = 0;\\n\\n            while(arrayContains(A, n++))\\n                count++;\\n\\n            max = Math.max(max, count);\\n        }\\n        return max;\\n    }\\n\\t\\n\\tprivate boolean arrayContains(int[] A, int n)\\n\\t{\\n        for(int i = 0; i < A.length; i++)\\n\\t\\t{\\n            if(A[i] == n)\\n                return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution \\n{\\n\\tpublic int longestConsecutive(int[] A)\\n\\t{\\n        Set<Integer> set = new HashSet<>();\\n        int max = 0;\\n\\t\\t\\n\\t\\tfor(int n : A)\\n            set.add(n);\\n\\t\\t\\n        for(int n : A)\\n\\t\\t{\\n            if(!set.contains(n - 1))\\n\\t\\t\\t{\\n                int count = 0;\\n\\n                while(set.contains(n++))\\n                    count++;\\n\\n\\t\\t\\t\\tmax = Math.max(max, count);\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```\n```\\nclass Solution \\n{\\n\\tpublic int longestConsecutive(int[] A)\\n\\t{\\n        if(A.length == 0)\\n            return 0;\\n\\n        int count = 1, max = 0;\\n\\t\\tArrays.sort(A);\\n        \\n\\t\\tfor(int i = 0; i < A.length - 1; i++)\\n        {\\n            if(A[i] != A[i + 1])\\n            {\\n                if(A[i] + 1 == A[i + 1])\\n                {\\n                    count++;\\n                }\\n                else\\n                {\\n                    max = Math.max(max, count);\\n                    count = 1;\\n                }    \\n            }\\n        }\\n        return Math.max(max, count);\\n    }\\n}\\n```\n```\\nclass Solution\\n{\\n    public int longestConsecutive(int[] A)\\n\\t{\\n        int max = 0;\\n\\n        for (int n : A)\\n\\t\\t{\\n            int count = 0;\\n\\n            while(arrayContains(A, n++))\\n                count++;\\n\\n            max = Math.max(max, count);\\n        }\\n        return max;\\n    }\\n\\t\\n\\tprivate boolean arrayContains(int[] A, int n)\\n\\t{\\n        for(int i = 0; i < A.length; i++)\\n\\t\\t{\\n            if(A[i] == n)\\n                return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 189968,
                "title": "graph-based-approach-o-n-dfs-on-tree",
                "content": "* Tree construction - O(N)\\n\\t* Iterate through the array\\n\\t* Maintain **address_table** such that **address_table[num] = memory address of the node representing num**\\n\\t* For every **num**-\\n\\t\\t* If **(num-1)** is in **address_table**, add an undirected edge between the nodes representing **num** & **(num-1)**\\n\\t\\t* If **(num+1)** is in **address_table**, add an undirected edge between the nodes representing **num** & **(num+1)**\\n* DFS - O(N)\\n\\t* Use DFS to find the largest connected component\\n\\t* Size of the largest connected component is the answer\\n* Therefore, overall time complexity - O(N), space complexity - O(N)\\n\\n# C++ Code\\n```c++\\nstruct Node {\\n    int val;\\n    int index;\\n    Node * left = NULL;\\n    Node * right = NULL;\\n};\\n\\nint DFS(Node * node, bool visited[]) {\\n    visited[node->index] = true;\\n    int count = 1;\\n    if(node->left && !visited[node->left->index]) {\\n        count += DFS(node->left,visited);\\n    }\\n    if(node->right && !visited[node->right->index]) {\\n        count += DFS(node->right,visited);\\n    }\\n    return count;\\n}\\n\\nint longestConsecutive(vector<int>& nums) {\\n    int i, N=nums.size();\\n    if(N==0) return 0;\\n    map<int,Node*> address_table; \\n    for(i=0; i<N; i++) {\\n        int num = nums[i];\\n        Node * node = new Node;\\n        node->val = num;\\n        node->index = i;\\n        if(address_table.count(num-1)) {\\n            Node * prev = address_table.at(num-1);\\n            prev->right = node;\\n            node->left = prev;\\n        }\\n        if(address_table.count(num+1)) {\\n            Node * next = address_table.at(num+1);\\n            node->right = next;\\n            next->left = node;\\n        }\\n        address_table[num] = node;\\n    }\\n    bool visited[N];\\n    for(i=0;i<N;i++) visited[i] = false;\\n    int ans = 0;\\n    for(i=0;i<N;i++) {\\n        if(!visited[i]) {\\n           ans = max(ans,DFS(address_table[nums[i]], visited));\\n        }\\n    }\\n    return ans;\\n}\\n```",
                "solutionTags": [],
                "code": "```c++\\nstruct Node {\\n    int val;\\n    int index;\\n    Node * left = NULL;\\n    Node * right = NULL;\\n};\\n\\nint DFS(Node * node, bool visited[]) {\\n    visited[node->index] = true;\\n    int count = 1;\\n    if(node->left && !visited[node->left->index]) {\\n        count += DFS(node->left,visited);\\n    }\\n    if(node->right && !visited[node->right->index]) {\\n        count += DFS(node->right,visited);\\n    }\\n    return count;\\n}\\n\\nint longestConsecutive(vector<int>& nums) {\\n    int i, N=nums.size();\\n    if(N==0) return 0;\\n    map<int,Node*> address_table; \\n    for(i=0; i<N; i++) {\\n        int num = nums[i];\\n        Node * node = new Node;\\n        node->val = num;\\n        node->index = i;\\n        if(address_table.count(num-1)) {\\n            Node * prev = address_table.at(num-1);\\n            prev->right = node;\\n            node->left = prev;\\n        }\\n        if(address_table.count(num+1)) {\\n            Node * next = address_table.at(num+1);\\n            node->right = next;\\n            next->left = node;\\n        }\\n        address_table[num] = node;\\n    }\\n    bool visited[N];\\n    for(i=0;i<N;i++) visited[i] = false;\\n    int ans = 0;\\n    for(i=0;i<N;i++) {\\n        if(!visited[i]) {\\n           ans = max(ans,DFS(address_table[nums[i]], visited));\\n        }\\n    }\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 41298,
                "title": "my-java-solution-use-hashmap-o-n",
                "content": "I use a hashmap to save the array's element. And iterative the array from 0 index to the length. When i visit a element of array, i will search the (element + 1) or (element - 1) in the hashmap. If there exits, then plus 1 or miner 1 and continue search in the hashmap. When i find a target, the max consecutive sequence length plus 1. And when the search end, remove the element from hashmap.\\n\\nBuilding the hashMap takes O(N) and the loop also takes O(N). The search in hashmap, commonly think that takes O(1).  So the result of this solution is O(N + N + 1). The result is O(N). It is a linear complexity solution.\\n\\nUpon is my own thought. Anything wrong please tell me !  I appreciate that. \\n\\n    public class Solution {\\n        public int longestConsecutive(int[] num) {\\n            int length = num.length;\\n            if (length == 0 || length == 1) {\\n                return length;\\n            }\\n            \\n            Map<Integer, Integer> numMap = new HashMap<Integer, Integer>();\\n            \\n            for (int i=0; i<length; i++) {\\n                numMap.put(num[i], 1);\\n            }\\n            \\n            int maxLen = 0;\\n            for (int i=0; i<length; i++) {\\n                if (!numMap.containsKey(num[i])) {\\n                    continue;\\n                }\\n                int max = 1;\\n                int temp1 = num[i];\\n                int temp2 = num[i];\\n                while (numMap.containsKey(++temp1)) {\\n                    max+=1;\\n                    numMap.remove(temp1);\\n                }\\n                while(numMap.containsKey(--temp2)) {\\n                    max+=1;\\n                    numMap.remove(temp2);\\n                }\\n                numMap.remove(num[i]);\\n                if (max>maxLen) {\\n                    maxLen = max;\\n                }\\n            }\\n            return maxLen;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public int longestConsecutive(int[] num) {\\n            int length = num.length;\\n            if (length == 0 || length == 1) {\\n                return length;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 41340,
                "title": "finally-accepted-using-two-unordered-map-with-complexity-o-n",
                "content": "I use two maps to keep the numbers from ascending and descending order. In fact, I think these two maps can be merged into one. But that would be much more difficult to understand\\n\\n    class Solution {\\n    public:\\n        int longestConsecutive(vector<int> &num) {\\n            unordered_map<int,int> seq;     //lower to higher\\n            unordered_map<int,int> seq2;    //higher to lower\\n            int maxlen = 0;\\n            for(int i=0;i<num.size();i++){\\n                unordered_map<int,int>::iterator it;\\n                unordered_map<int,int>::iterator it2;\\n                it = seq.find(num[i]);\\n                it2 = seq2.find(num[i]);\\n                if(it != seq.end() || it2 != seq2.end()){\\n                    continue;\\n                }\\n                it = seq.find(num[i]+1);    //find if num[i] can be lower\\n                it2 = seq2.find(num[i]-1);  //find if num[i] can be higher\\n                if(it != seq.end() && it2 != seq2.end()){ //if there are two sequences that can be merged together\\n                    int high = it->second;\\n                    int low = it2->second;\\n                    seq.erase(it);\\n                    seq.erase(low);\\n                    seq2.erase(high);\\n                    seq2.erase(it2);\\n                    seq.insert(pair<int,int>(low,high));\\n                    seq2.insert(pair<int,int>(high,low));\\n                    maxlen = maxlen > high-low+1 ? maxlen : high-low+1;\\n                }\\n                else if(it != seq.end()){\\n                    int high = it->second;\\n                    seq.erase(it);\\n                    seq2.erase(high);\\n                    seq.insert(pair<int,int>(num[i],high));\\n                    seq2.insert(pair<int,int>(high,num[i]));\\n                    maxlen = maxlen > high-num[i]+1 ? maxlen : high-num[i]+1;\\n                }\\n                else if(it2 != seq2.end()){\\n                    int low = it2->second;\\n                    seq2.erase(it2);\\n                    seq.erase(low);\\n                    seq.insert(pair<int,int>(low,num[i]));\\n                    seq2.insert(pair<int,int>(num[i],low));\\n                    maxlen = maxlen > num[i]-low+1 ? maxlen : num[i]-low+1;\\n                }\\n                else{\\n                    seq.insert(pair<int,int>(num[i],num[i]));\\n                    seq2.insert(pair<int,int>(num[i],num[i]));\\n                    maxlen = maxlen > 1 ? maxlen : 1;\\n                }\\n            }\\n            return maxlen;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int longestConsecutive(vector<int> &num) {\\n            unordered_map<int,int> seq;     //lower to higher\\n            unordered_map<int,int> seq2;    //higher to lower\\n            int maxlen = 0;\\n            for(int i=0;i<num.size();i++){\\n                unordered_map<int,int>::iterator it;\\n                unordered_map<int,int>::iterator it2;\\n                it = seq.find(num[i]);\\n                it2 = seq2.find(num[i]);\\n                if(it != seq.end() || it2 != seq2.end()){\\n                    continue;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3989267,
                "title": "longest-consecutive-sequence",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestConsecutive(vector<int>& nums) {\\n        vector<int>v;\\n        map<int,int>mp;\\n        for(auto it:nums){\\n            mp[it]++;\\n        }\\n        for(auto it:mp){\\n            v.push_back(it.first);\\n        }\\n        for(auto it:v){\\n           cout<<it<<endl;\\n        }\\n        if(v.size()==0){\\n            return 0;\\n        }\\n        if(v.size()==1){\\n            return 1;\\n        }\\n        int ans=INT_MIN;\\n        int count=0;\\n        for(int i=1;i<v.size()+1;i++){\\n            if(i==v.size()){\\n                ans=max(ans,count);\\n                break;\\n            }\\n            if(v[i-1]+1==v[i]){\\n                count++;\\n            }\\n            else{\\n                ans=max(ans,count);\\n                count=0;\\n            }\\n            \\n            \\n        }\\n        \\n        return ans+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestConsecutive(vector<int>& nums) {\\n        vector<int>v;\\n        map<int,int>mp;\\n        for(auto it:nums){\\n            mp[it]++;\\n        }\\n        for(auto it:mp){\\n            v.push_back(it.first);\\n        }\\n        for(auto it:v){\\n           cout<<it<<endl;\\n        }\\n        if(v.size()==0){\\n            return 0;\\n        }\\n        if(v.size()==1){\\n            return 1;\\n        }\\n        int ans=INT_MIN;\\n        int count=0;\\n        for(int i=1;i<v.size()+1;i++){\\n            if(i==v.size()){\\n                ans=max(ans,count);\\n                break;\\n            }\\n            if(v[i-1]+1==v[i]){\\n                count++;\\n            }\\n            else{\\n                ans=max(ans,count);\\n                count=0;\\n            }\\n            \\n            \\n        }\\n        \\n        return ans+1;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3987669,
                "title": "easy-java-solution-striver",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int longestConsecutive(int[] a) {\\n        HashSet<Integer> h = new HashSet<>();\\n        int max=0,longest=0,ans=0;\\n        for(int i:a) h.add(i);\\n        for(int i:h){\\n            if(!h.contains(i-1)){\\n                max=1;\\n                longest=i;\\n                while(h.contains(longest+1)){\\n                    max+=1; longest+=1;\\n                }\\n            }\\n            ans=Math.max(ans,max);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\n    public int longestConsecutive(int[] a) {\\n        HashSet<Integer> h = new HashSet<>();\\n        int max=0,longest=0,ans=0;\\n        for(int i:a) h.add(i);\\n        for(int i:h){\\n            if(!h.contains(i-1)){\\n                max=1;\\n                longest=i;\\n                while(h.contains(longest+1)){\\n                    max+=1; longest+=1;\\n                }\\n            }\\n            ans=Math.max(ans,max);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3750619,
                "title": "brute-force-optimal-easy-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWE WILL DISCUSS TWO SOLUTIONS BRUTE FORCE AND OPTIMAL . \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n BRUTE FORCE ->\\n\\n1. Most of the times  basic funda of brute force is take elements one by one and do some operations with respect to other elements .\\n2. we are also doing the same over here , we take first element and then we are searching for it\\'s further increements .\\n3. we have made one function also for the same linear , we will run while loop until we are getting it\\'s further elements , that\"s why we are incrementing N value \\n4. Hence we  are storing the result of count for each element .\\n5. This solution will give T.L.E after 60 test cases .\\n6. Let\\'s jump to optimal approach .\\n\\n\\n\\nOPTIMAL APPROACH ->\\n\\n1. we will simply sort the array , if we are getting same elements we will simply continue the loop and move further .\\n2. if not then we are searching for difference =-1 as we are looking for consecutive ones . \\n3. simply increase the count as we are getting the expected , if not then again initialize the count =1;\\n4. REMEMBER : we are setting count=1 , bcz everytime atleast there is one element and we are considering that \\n5. if array length =0 then we are handling this case in separate condition .\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\nBRUTE force one ->\\n\\n public int longestConsecutive(int[] nums) {\\n        int count=1;\\n        int res=Integer.MIN_VALUE;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            int n=nums[i];\\n            while(linear(nums,n+1)==true)\\n            {\\n                n=n+1;\\n                count++;\\n                \\n            }\\n            res=Math.max(res,count);\\n            count=1;\\n        }\\n        if(res==Integer.MIN_VALUE)\\n        {\\n            return 0;\\n        }\\n        return res;\\n   \\n    }\\n    public boolean linear(int[]arr , int x)\\n    {\\n        for(int i=0;i<arr.length;i++)\\n        {\\n            if(arr[i]==x)\\n            {\\n                return true;\\n            }\\n            \\n        }\\n        return false;\\n    }\\n\\nOPTIMAL ONE ->\\n```\\nclass Solution {\\n    public int longestConsecutive(int[] nums) {\\n        Arrays.sort(nums);\\n        int count =1;\\n        int res=Integer.MIN_VALUE;\\n        for(int i=0;i<nums.length-1;i++)\\n        {\\n            if(nums[i]==nums[i+1])\\n            {\\n                continue;\\n            }\\n            else if (nums[i]-nums[i+1]==-1)\\n            {\\n                count++;\\n                res=Math.max(res,count);\\n            }\\n            else\\n            {\\n                count=1;\\n            }\\n        }\\n        res=Math.max(res,count);\\n        if(res==Integer.MIN_VALUE || nums.length==0)\\n        {\\n            return 0;\\n        }\\n        return res;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int longestConsecutive(int[] nums) {\\n        Arrays.sort(nums);\\n        int count =1;\\n        int res=Integer.MIN_VALUE;\\n        for(int i=0;i<nums.length-1;i++)\\n        {\\n            if(nums[i]==nums[i+1])\\n            {\\n                continue;\\n            }\\n            else if (nums[i]-nums[i+1]==-1)\\n            {\\n                count++;\\n                res=Math.max(res,count);\\n            }\\n            else\\n            {\\n                count=1;\\n            }\\n        }\\n        res=Math.max(res,count);\\n        if(res==Integer.MIN_VALUE || nums.length==0)\\n        {\\n            return 0;\\n        }\\n        return res;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3643722,
                "title": "python3-c-brute-force-better-optimal-full-explanation",
                "content": "- Approach\\n    - Brute-force\\n        - For each element count its consecutive elements present in the array\\n        - Time Complexity: $O(n^3)$\\n        - Space Complexity: $O(1)$\\n    - Better\\n        - Sort the array and check for consecutive elements\\n        - Time Complexity: $O(nlogn)$\\n        - Space Complexity: $O(1)$\\n    - Optimal\\n        - Add all nums in set\\n        - Then we will run a for loop and check for any number(x) if it is the starting number of the consecutive sequence by checking if the set contains (x-1) or not\\n        - If x is the starting number of the consecutive sequence we will keep searching for the numbers y = x+1, x+2, x+3, \\u2026.. And stop at the first y which is not present in the set\\n        - Time Complexity: $O(n)$ (assuming set takes O(1) to search)\\n        - Space Complexity: $O(n)$\\n\\n```python\\n# Python3\\n# Brute-force Solution\\nclass Solution:\\n    def find(self, nums, a):\\n        for i in nums:\\n            if i == a:\\n                return True\\n        return False\\n\\n    def longestConsecutive(self, nums: List[int]) -> int:\\n        if len(nums) == 0:  return 0\\n        maxi = 1\\n        for i in nums:\\n            conseq = 1\\n            while self.find(nums, i + conseq):\\n                conseq += 1\\n            maxi = max(maxi, conseq)\\n        return maxi\\n```\\n\\n```python\\n# Python3\\n# Better Solution\\nclass Solution:\\n    def longestConsecutive(self, nums: List[int]) -> int:\\n        if len(nums) == 0:  return 0\\n        nums.sort()\\n        maxi = 1\\n        cur_max = 1\\n        for i in range(1, len(nums)):\\n            if nums[i] == nums[i-1]:\\n                continue\\n            if nums[i] == nums[i-1]+1:\\n                cur_max += 1\\n            else:\\n                cur_max = 1\\n            maxi = max(maxi, cur_max)\\n        return maxi\\n```\\n\\n```python\\n# Python3\\n# Optimal Solution\\nclass Solution:\\n    def longestConsecutive(self, nums: List[int]) -> int:\\n        if len(nums) == 0:  return 0\\n        uset = set(nums)\\n        maxi = 1\\n        for i in uset:\\n            if i-1 in uset:\\n                continue\\n            else:\\n                conseq = 1\\n                while i + conseq in uset:\\n                    conseq += 1\\n                maxi = max(maxi, conseq)\\n        return maxi\\n```\\n\\n```cpp\\n// C++\\n// Optimal Solution\\n#include <bits/stdc++.h>\\nclass Solution{\\n  public:\\n    int findLongestConseqSubseq(int arr[], int N)\\n    {\\n        unordered_set<int> uset;\\n        for (int i = 0; i < N; i++) {\\n            uset.insert(arr[i]);\\n        }\\n        int maxi = 1;\\n        for (auto num: uset) {\\n            if (uset.count(num - 1)) {continue;}\\n            int conseq = 1;\\n            while (uset.count(num + conseq)) {\\n                conseq++;\\n            }\\n            maxi = max(maxi, conseq);\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Python3",
                    "Array",
                    "Hash Table"
                ],
                "code": "```python\\n# Python3\\n# Brute-force Solution\\nclass Solution:\\n    def find(self, nums, a):\\n        for i in nums:\\n            if i == a:\\n                return True\\n        return False\\n\\n    def longestConsecutive(self, nums: List[int]) -> int:\\n        if len(nums) == 0:  return 0\\n        maxi = 1\\n        for i in nums:\\n            conseq = 1\\n            while self.find(nums, i + conseq):\\n                conseq += 1\\n            maxi = max(maxi, conseq)\\n        return maxi\\n```\n```python\\n# Python3\\n# Better Solution\\nclass Solution:\\n    def longestConsecutive(self, nums: List[int]) -> int:\\n        if len(nums) == 0:  return 0\\n        nums.sort()\\n        maxi = 1\\n        cur_max = 1\\n        for i in range(1, len(nums)):\\n            if nums[i] == nums[i-1]:\\n                continue\\n            if nums[i] == nums[i-1]+1:\\n                cur_max += 1\\n            else:\\n                cur_max = 1\\n            maxi = max(maxi, cur_max)\\n        return maxi\\n```\n```python\\n# Python3\\n# Optimal Solution\\nclass Solution:\\n    def longestConsecutive(self, nums: List[int]) -> int:\\n        if len(nums) == 0:  return 0\\n        uset = set(nums)\\n        maxi = 1\\n        for i in uset:\\n            if i-1 in uset:\\n                continue\\n            else:\\n                conseq = 1\\n                while i + conseq in uset:\\n                    conseq += 1\\n                maxi = max(maxi, conseq)\\n        return maxi\\n```\n```cpp\\n// C++\\n// Optimal Solution\\n#include <bits/stdc++.h>\\nclass Solution{\\n  public:\\n    int findLongestConseqSubseq(int arr[], int N)\\n    {\\n        unordered_set<int> uset;\\n        for (int i = 0; i < N; i++) {\\n            uset.insert(arr[i]);\\n        }\\n        int maxi = 1;\\n        for (auto num: uset) {\\n            if (uset.count(num - 1)) {continue;}\\n            int conseq = 1;\\n            while (uset.count(num + conseq)) {\\n                conseq++;\\n            }\\n            maxi = max(maxi, conseq);\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3485502,
                "title": "simple-python-solution-using-sortedset",
                "content": "\\n\\n# Code\\n```\\nfrom sortedcontainers import SortedSet\\nclass Solution:\\n    def longestConsecutive(self, nums: List[int]) -> int:\\n        nums = SortedSet(nums)      \\n        mx, cur = 0, 0\\n        for num in nums:\\n            if num - 1 in nums:\\n                cur += 1\\n            else:\\n                mx = max(mx, cur)\\n                cur = 1\\n        mx = max(mx, cur)\\n        return mx\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom sortedcontainers import SortedSet\\nclass Solution:\\n    def longestConsecutive(self, nums: List[int]) -> int:\\n        nums = SortedSet(nums)      \\n        mx, cur = 0, 0\\n        for num in nums:\\n            if num - 1 in nums:\\n                cur += 1\\n            else:\\n                mx = max(mx, cur)\\n                cur = 1\\n        mx = max(mx, cur)\\n        return mx\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3444165,
                "title": "easy-solution-sorting",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestConsecutive(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int mx=1,cur=1;\\n        if(nums.size()<=1) return nums.size();\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i]==nums[i-1]+1) {\\n               cur++;\\n            }\\n            mx=max(cur,mx);\\n          if(nums[i]!=nums[i-1]+1 && nums[i]!=nums[i-1]) {\\n               cur=1;\\n            }      \\n           if(nums[i]==nums[i-1]){\\n            cur=cur;\\n            }      \\n        }\\n        return mx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestConsecutive(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int mx=1,cur=1;\\n        if(nums.size()<=1) return nums.size();\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i]==nums[i-1]+1) {\\n               cur++;\\n            }\\n            mx=max(cur,mx);\\n          if(nums[i]!=nums[i-1]+1 && nums[i]!=nums[i-1]) {\\n               cur=1;\\n            }      \\n           if(nums[i]==nums[i-1]){\\n            cur=cur;\\n            }      \\n        }\\n        return mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3359827,
                "title": "solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestConsecutive(vector<int>& nums) \\n    {    \\n        if(nums.size()==0) return 0;   \\n        vector<int> vec;\\n        sort(nums.begin(),nums.end());\\n        int count=1;\\n        int i=0;\\n        for(int j=1;j<nums.size();j++)\\n        {    \\n            if(nums[j]-nums[i]==0) {cout<<\"Sudi\";}   \\n            if(nums[j]-nums[i]==1){\\n                count++;\\n            }\\n            if(nums[j]-nums[i]>1)\\n            {\\n                vec.push_back(count);\\n                count=1;\\n            }\\n           i++;\\n        }\\n        vec.push_back(count);\\n        sort(vec.begin(),vec.end());\\n        int idx=vec.size()-1;\\n        return vec[idx];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestConsecutive(vector<int>& nums) \\n    {    \\n        if(nums.size()==0) return 0;   \\n        vector<int> vec;\\n        sort(nums.begin(),nums.end());\\n        int count=1;\\n        int i=0;\\n        for(int j=1;j<nums.size();j++)\\n        {    \\n            if(nums[j]-nums[i]==0) {cout<<\"Sudi\";}   \\n            if(nums[j]-nums[i]==1){\\n                count++;\\n            }\\n            if(nums[j]-nums[i]>1)\\n            {\\n                vec.push_back(count);\\n                count=1;\\n            }\\n           i++;\\n        }\\n        vec.push_back(count);\\n        sort(vec.begin(),vec.end());\\n        int idx=vec.size()-1;\\n        return vec[idx];\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3346501,
                "title": "optimized-linear-time-java-solution-using-hashset",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n# Code\\n```\\nclass Solution {\\n    public int longestConsecutive(int[] nums) {\\n        Set<Integer> hs = new HashSet<>();\\n        for(int num : nums) {\\n            hs.add(num);\\n        }\\n\\n        int longestSeq = 0;\\n        for(int val : nums) {\\n            if(!hs.contains(val - 1)) {\\n                int count = 1;\\n                int currVal = val;\\n\\n                while(hs.contains(currVal + 1)) {\\n                    count++;\\n                    currVal++;\\n                }\\n\\n                longestSeq = Math.max(longestSeq, count);\\n            }\\n        }\\n\\n        return longestSeq;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\n    public int longestConsecutive(int[] nums) {\\n        Set<Integer> hs = new HashSet<>();\\n        for(int num : nums) {\\n            hs.add(num);\\n        }\\n\\n        int longestSeq = 0;\\n        for(int val : nums) {\\n            if(!hs.contains(val - 1)) {\\n                int count = 1;\\n                int currVal = val;\\n\\n                while(hs.contains(currVal + 1)) {\\n                    count++;\\n                    currVal++;\\n                }\\n\\n                longestSeq = Math.max(longestSeq, count);\\n            }\\n        }\\n\\n        return longestSeq;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3150852,
                "title": "easiest-c-code-using-unique-function-of-vector",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestConsecutive(vector<int>& nums) {\\n        int c=1,m=1;\\n           sort(nums.begin(),nums.end());\\n        unique(nums.begin(),nums.end());\\n     \\n        int n=nums.size();\\n        for(int i=0;i<n-1;i++){\\n            if(nums[i]-nums[i+1]==-1){\\n                    c++;\\n            }\\n            else {\\n            m=max(m,c);\\n            c=1;\\n            }\\n        }\\n        m=max(m,c);\\n// for(auto &i:nums){\\n//     cout<<i<<\" \";\\n// }\\n\\n        if(n>0) return m;\\n        else return 0;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestConsecutive(vector<int>& nums) {\\n        int c=1,m=1;\\n           sort(nums.begin(),nums.end());\\n        unique(nums.begin(),nums.end());\\n     \\n        int n=nums.size();\\n        for(int i=0;i<n-1;i++){\\n            if(nums[i]-nums[i+1]==-1){\\n                    c++;\\n            }\\n            else {\\n            m=max(m,c);\\n            c=1;\\n            }\\n        }\\n        m=max(m,c);\\n// for(auto &i:nums){\\n//     cout<<i<<\" \";\\n// }\\n\\n        if(n>0) return m;\\n        else return 0;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            }
        ],
        "discussions": [
            {
                "id": 1570293,
                "content": [
                    {
                        "username": "dghosh133",
                        "content": "How does [1,2,0,1] tc gives output as 3? It should be 2! Someone please clarify.\\n[0,1,1,2] -> has at most 2 consecutive nos."
                    },
                    {
                        "username": "TraySoek",
                        "content": "[@PrashantZuko](/PrashantZuko) yes that\\'s it"
                    },
                    {
                        "username": "dsoum",
                        "content": "[@OmarEffat](/OmarEffat) No highest sequence here is, 0,1,2,3,4,5,6,7,8 hence 9. why 10?"
                    },
                    {
                        "username": "Priyashreyas",
                        "content": "[@ironmonger1](/ironmonger1)  if thats the case, the example given above\\n Input: nums = [0,3,7,2,5,8,4,6,0,1]\\nOutput: 9 then it should be 10 and not 9 right? "
                    },
                    {
                        "username": "Priyashreyas",
                        "content": "[@Ajay_Singh9990](/Ajay_Singh9990) if thats the case, the example given above\\n Input: nums = [0,3,7,2,5,8,4,6,0,1]\\nOutput: 9 then it should be 10 and not 9 right? "
                    },
                    {
                        "username": "Rajiv_123",
                        "content": "[@Dipan Ghosh](/dghosh133) For input [0,1,1,2] Longest consecutive seq would be 0,1,2 hence answer would be 3.  We can ignore the 1 at 2nd index as you are allowed to pick numbers at random indexes such that they are consecutive."
                    },
                    {
                        "username": "OmarEffat",
                        "content": "[@geekgeekvm](/geekgeekvm)  In this case, [0,3,7,2,5,8,4,6,0,1] this should be returning 10 (Example 2)"
                    },
                    {
                        "username": "geekgeekvm",
                        "content": "This was not clear from the question, but the question seems to indicate any sequence of consecutive numbers even if there is a repition in between"
                    },
                    {
                        "username": "sh1kamaruNara",
                        "content": "0,1,2 "
                    },
                    {
                        "username": "cookieslasher",
                        "content": "I had the same question. I thought the count should break off it reaches a duplicate number. I guess this wasn\\'t obvious in the problem description."
                    },
                    {
                        "username": "PrashantZuko",
                        "content": "no,it will be 3 since 0,1,2 are all consecutive."
                    },
                    {
                        "username": "user0241F",
                        "content": "            if inputArr[l] == inputArr[l + 1] then only increase"
                    },
                    {
                        "username": "devanshumasodker357",
                        "content": "bro u forget to add 0 that\\'s why it gives 3"
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "whenever duplicates elements in array but we have to return longest sequence\\nex  (1,1,2,2,3,3.4)    answer is 4\\nbcoz hume duplicate se mtlb nahi hai 1,2,3,4, numbers hai gap 1 ka hai then duplicates ko ignore kr dege "
                    },
                    {
                        "username": "Vishal773",
                        "content": "I think duplicates numbers not counted\\n"
                    },
                    {
                        "username": "ankit528",
                        "content": "subsequence could be in any order\\n"
                    },
                    {
                        "username": "subhadipmandalbagjuri",
                        "content": "i also faced same query, but with another else if statement if got resolved"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "well 0,1,2 there\\'s your sequence"
                    },
                    {
                        "username": "user5582eQ",
                        "content": "So many solutions here claiming to be O(n) are actually either O(n^2) or O(nlogn). How can people here have such poor understanding of time complexity."
                    },
                    {
                        "username": "_Ritik_Singh_",
                        "content": "Bro there is no need to judge anyone on the basis of their solution as long as they are solving and learning so chill out and watch  yourself."
                    },
                    {
                        "username": "RealNameHidden",
                        "content": "Explain it then if you understand it so well, so people can learn"
                    },
                    {
                        "username": "dragosarsene7",
                        "content": "[@carlosfonchii](/carlosfonchii) Learn what exactly. The whole point of the problem is to not sort, otherwise it is trivial. People who use sorting barely learn something, if anything at all, they just call sort and then iterate through an array."
                    },
                    {
                        "username": "dipanshuSaini",
                        "content": "[@Rimberse](/Rimberse)  my nlogn solution is as per leetcode -> 99 % faster. So yes, nlogn solution works here perfectly fine."
                    },
                    {
                        "username": "countdankula",
                        "content": "If you use set it will never reach N^2"
                    },
                    {
                        "username": "carlosfonchii",
                        "content": "There is literally no need to come at people when everyone is here to practice and get BETTER at coding. Check yourself."
                    },
                    {
                        "username": "grave18",
                        "content": "[@Rimberse](/Rimberse) No, i am sorting nums (nlogn) and pass the submission."
                    },
                    {
                        "username": "Rimberse",
                        "content": "I actually came up with O(nlogn) solution, but it didn\\'t work. Got TLE\\nSo anything either than O(n) won\\'t actually be accepted as a solution."
                    },
                    {
                        "username": "Saurabh8720",
                        "content": "Sorry To Interrupt Sir But, The Optimised Solution Dont Have a TC of N^2 or NlogN Sorry to Say But u r Wrong, It is Just O(3N) ~= O(N) "
                    },
                    {
                        "username": "nalinnishant",
                        "content": "agree "
                    },
                    {
                        "username": "Angrydemon",
                        "content": "I think they, first try to solve the given question using brute force without considering the time complexity then they try to optimes it, and if it not works they leave the question for later!"
                    },
                    {
                        "username": "aryansuvarna",
                        "content": "lol so true"
                    },
                    {
                        "username": "user7312022",
                        "content": "You can run your code against these test cases before submisson. Hope it helps!\\n\\n[100,4,200,1,3,2]\\n[0,3,7,2,5,8,4,6,0,1]\\n[1,2,0,1]\\n[0]\\n[0,0]\\n[]"
                    },
                    {
                        "username": "subhadipmandalbagjuri",
                        "content": "[9,1,4,7,3,-1,0,5,8,-1,6]"
                    },
                    {
                        "username": "iChuan",
                        "content": "This is really weried to me. Hard to understand the meaning of this question."
                    },
                    {
                        "username": "tusharmathew",
                        "content": "Its not sub sequence so we dont have to maintain order"
                    },
                    {
                        "username": "amansoni22103",
                        "content": "actually we need to avoid duplicate elements here that\\'s why it is showing 3 instead of 2"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/nA5TRClw96I"
                    },
                    {
                        "username": "nareshvishram",
                        "content": "![image](https://assets.leetcode.com/users/images/c8f1a005-5f10-4957-81be-7fb5c11163dd_1596370783.9489772.png)\\n"
                    },
                    {
                        "username": "addictive_head",
                        "content": "This is O(N) solution actually.\\n1. We are iterating over all elements of hash Set O(N).\\n 2. We then are looking for elements which are starting the subsequence, then we are searching elements set(i)+1, we keep searching till we are finding them. Update the final Count if required.\\nNote that we do not iterate over same numbers again. So O(N).\\n\\ni.e.  O(2N) ~= O(N)"
                    },
                    {
                        "username": "0bro",
                        "content": "At best it O(n log n), n for iterating the entire array, then log n for sub iterating through the hash within the loop that is iterating through the passed array. The search for the O(n) is real lol"
                    },
                    {
                        "username": "ethanultra",
                        "content": "[@SunilKumawat](/SunilKumawat) how? when we iterate through again to find a starting point, we only perform the search if there are elements in the subsequence, so when we encounter another element later that\\'s part of the subsequence, we skip it, so it\\'s not O(N^2) time, it is a multiple of O(N), so O(N)"
                    },
                    {
                        "username": "bhautikkapadiya6",
                        "content": "This algo is work but it has O(n*2) complexity"
                    },
                    {
                        "username": "kamran3210",
                        "content": "[@SunilKumawat](/SunilKumawat) \n\nI may be mistaken but surely its O(N)?\n\nInitialise set with the elements: O(N)\n\nIterate over array and check if it is the start of a subsequence (does not have a predecessor): O(N)\n\nSum of  lengths of all subsequences starting from a number that doesn't have a predecessor = N, therefore countining lengths of all subsequences: O(N)\n\noverall complexity: O(N)"
                    },
                    {
                        "username": "user5062LR",
                        "content": "[@SunilKumawat](/SunilKumawat) its O(3N) ~= O(N)"
                    },
                    {
                        "username": "hardikgupta083",
                        "content": "That is not O(N)"
                    },
                    {
                        "username": "SunilKumawat",
                        "content": "this solution has 0(N^2) time complexity genius"
                    },
                    {
                        "username": "forrrjoyuri",
                        "content": "Just for the sake of comparison, I implemented a naive solution in O(n log n) that sorts the array.\\nMy solution runs in 9ms. I copypasted the best linear solutions from the top posts here and the best i got was 30ms.\\n\\nIn theory, something is wrong here. Why is it the case ?"
                    },
                    {
                        "username": "energyperformer",
                        "content": "One thing u need to remeber is Best time complexity Solution doesn\\'t necessarly mean the fastet solution every instance ,initally for small numbers of n ,even if time complexity is more it can give faster result ,but when we go for large values of n then less time complexity solution offer better time results"
                    },
                    {
                        "username": "treat",
                        "content": "[@DeclanGH](/DeclanGH) Your assumed O(N) might actually be O(N^2)"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "I think leetcode needs to add a very large testcase for this problem to make a nlogn fail"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "[@matthewjiao](/matthewjiao) You are right in theory, but if you could see my two solutions, you would see the comment i made. My first O(n) solution ran 463 ms while the nlogn ran 14ms. its really weird and i was graced to get one testcase wrong, which had 10000 as its answer (which is the largest input size). Not saying you are wrong, but the fact that my result was that way still confuses me. "
                    },
                    {
                        "username": "ixeridium",
                        "content": "E.g. with Python it can happen that using some builtin primitive (or libraries such as numpy) give very significant speedups. A factor of 100 or more is not unusual. In such situations it can happen that a O(n log n) solution is always faster than a O(n) solution for any practical input size. I.e., n log n < 100 * n for all n < exp(100)."
                    },
                    {
                        "username": "wasam1119",
                        "content": "[@matthewjiao](/matthewjiao) Accurate. Observe graphs of y = x and y = x*log(x)"
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "from my experience agr aap ek baar best runtime solution dekh lo ja kr after submission and copy pr aap submit kro then this time code not beats 100 percent submission zyada time lega \\nmay be this is leetcode feature jisse leetcode ke solution ko dekh bo dusro ke solution ko beat na kr paye jin logo ne bina ldekhe kiya hai leetcode best solution \\n"
                    },
                    {
                        "username": "matthewjiao",
                        "content": "Time complexity is not a function of speed, it\\'s a function of growth based on input size. Perhaps with smaller inputs, the linearithmic solution is faster than the linear solution, but as input grows in size, O(n) will eventually out perform O(nlogn)."
                    },
                    {
                        "username": "coolkid0006",
                        "content": "Big O notation drops constants from algorithms\\' complexity because Big O notation is concerned with asymptotic inputs (the input size heads towards infinity). The leetcode test cases aren\\'t large enough to ideally represent the asymptotic complexity, so the constants dropped off when calculating the Big O complexity can have a significant effect on runtime. For example:\\n\\nImagine 2 algorithms for a problem: one has a complexity of n^2 and one has an algorithm of n + 10000. The big O notation drops the constants, so the complexities are O(n^2) and O(n). If you work with small amounts of data the n^2 will have a much smaller runtime, but once a certain point is reached the +10000 won\\'t make much of a difference on the runtime.\\n\\nFor this leetcode problem the naive solution has a smaller runtime for inputs smaller than a certain point. This point is larger than the input sizes of the leetcode solution.\\n\\nIf your solution is at the very bottom of the time and memory leaderboard you might want to make sure it is implemented correctly, but because of the asymptotic nature of Big O notation it isn\\'t always accurate to whether it is the ideal solution."
                    },
                    {
                        "username": "Triquetra",
                        "content": "Try to plot execution time of both solutions against n = 100, 1000, 10000, ... \\u2014 maybe you will see a pattern."
                    },
                    {
                        "username": "kiyosaanb",
                        "content": "In case you are doing something like  nums[i]++ or nums[i]-- , you will encounter problems with this new test case ---> [2147483647,-2147483648]"
                    },
                    {
                        "username": "ShiqiLu77",
                        "content": "-1,000,000,000 <= nums[i] <= 1,000,000,000"
                    },
                    {
                        "username": "yis1178",
                        "content": "I think there is a restriction of the value of nums[i] -- not sure if this is lately added"
                    },
                    {
                        "username": "jasusy",
                        "content": "Is it better to need to clarify duplicate numbers not included in consecutive seq?\\n\\nFor example, if input [0, 0] should output 1, instead of 2, since no duplication counted in result.\\n\\nIf duplicate number considered, we need use HashMap instead of HashSet, and a little different in coding."
                    },
                    {
                        "username": "rubayamim381",
                        "content": "[@shanwu](/shanwu) [1,1,2,3,4] = 5"
                    },
                    {
                        "username": "user6161I",
                        "content": "[@shanwu](/shanwu) 4 ... Because Duplicates are to be treated as single."
                    },
                    {
                        "username": "khritish17",
                        "content": "duplicates should be treated as one\\ne.g : nums = [0,0,1,2,3,4,5,6,7,8] -> output: 9 ([0,1,2,3,4,5,6,7,8])"
                    },
                    {
                        "username": "shanwu",
                        "content": "I agree with you. If duplicate numbers are allowed, then what should be the answer of [100,4,200,1,1,3,2] ? It would be unclear."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/longest-consecutive-sequence/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Sorting\n\n  \n**Approach 3:** HashSet and Intelligent Sequence Building\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "PruthviChippa",
                        "content": "this deserves to be hard for o(n)"
                    },
                    {
                        "username": "Hopity",
                        "content": "for some reason it accepts o(nlogn) that\\'s why it\\'s in medium"
                    }
                ]
            },
            {
                "id": 1576092,
                "content": [
                    {
                        "username": "dghosh133",
                        "content": "How does [1,2,0,1] tc gives output as 3? It should be 2! Someone please clarify.\\n[0,1,1,2] -> has at most 2 consecutive nos."
                    },
                    {
                        "username": "TraySoek",
                        "content": "[@PrashantZuko](/PrashantZuko) yes that\\'s it"
                    },
                    {
                        "username": "dsoum",
                        "content": "[@OmarEffat](/OmarEffat) No highest sequence here is, 0,1,2,3,4,5,6,7,8 hence 9. why 10?"
                    },
                    {
                        "username": "Priyashreyas",
                        "content": "[@ironmonger1](/ironmonger1)  if thats the case, the example given above\\n Input: nums = [0,3,7,2,5,8,4,6,0,1]\\nOutput: 9 then it should be 10 and not 9 right? "
                    },
                    {
                        "username": "Priyashreyas",
                        "content": "[@Ajay_Singh9990](/Ajay_Singh9990) if thats the case, the example given above\\n Input: nums = [0,3,7,2,5,8,4,6,0,1]\\nOutput: 9 then it should be 10 and not 9 right? "
                    },
                    {
                        "username": "Rajiv_123",
                        "content": "[@Dipan Ghosh](/dghosh133) For input [0,1,1,2] Longest consecutive seq would be 0,1,2 hence answer would be 3.  We can ignore the 1 at 2nd index as you are allowed to pick numbers at random indexes such that they are consecutive."
                    },
                    {
                        "username": "OmarEffat",
                        "content": "[@geekgeekvm](/geekgeekvm)  In this case, [0,3,7,2,5,8,4,6,0,1] this should be returning 10 (Example 2)"
                    },
                    {
                        "username": "geekgeekvm",
                        "content": "This was not clear from the question, but the question seems to indicate any sequence of consecutive numbers even if there is a repition in between"
                    },
                    {
                        "username": "sh1kamaruNara",
                        "content": "0,1,2 "
                    },
                    {
                        "username": "cookieslasher",
                        "content": "I had the same question. I thought the count should break off it reaches a duplicate number. I guess this wasn\\'t obvious in the problem description."
                    },
                    {
                        "username": "PrashantZuko",
                        "content": "no,it will be 3 since 0,1,2 are all consecutive."
                    },
                    {
                        "username": "user0241F",
                        "content": "            if inputArr[l] == inputArr[l + 1] then only increase"
                    },
                    {
                        "username": "devanshumasodker357",
                        "content": "bro u forget to add 0 that\\'s why it gives 3"
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "whenever duplicates elements in array but we have to return longest sequence\\nex  (1,1,2,2,3,3.4)    answer is 4\\nbcoz hume duplicate se mtlb nahi hai 1,2,3,4, numbers hai gap 1 ka hai then duplicates ko ignore kr dege "
                    },
                    {
                        "username": "Vishal773",
                        "content": "I think duplicates numbers not counted\\n"
                    },
                    {
                        "username": "ankit528",
                        "content": "subsequence could be in any order\\n"
                    },
                    {
                        "username": "subhadipmandalbagjuri",
                        "content": "i also faced same query, but with another else if statement if got resolved"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "well 0,1,2 there\\'s your sequence"
                    },
                    {
                        "username": "user5582eQ",
                        "content": "So many solutions here claiming to be O(n) are actually either O(n^2) or O(nlogn). How can people here have such poor understanding of time complexity."
                    },
                    {
                        "username": "_Ritik_Singh_",
                        "content": "Bro there is no need to judge anyone on the basis of their solution as long as they are solving and learning so chill out and watch  yourself."
                    },
                    {
                        "username": "RealNameHidden",
                        "content": "Explain it then if you understand it so well, so people can learn"
                    },
                    {
                        "username": "dragosarsene7",
                        "content": "[@carlosfonchii](/carlosfonchii) Learn what exactly. The whole point of the problem is to not sort, otherwise it is trivial. People who use sorting barely learn something, if anything at all, they just call sort and then iterate through an array."
                    },
                    {
                        "username": "dipanshuSaini",
                        "content": "[@Rimberse](/Rimberse)  my nlogn solution is as per leetcode -> 99 % faster. So yes, nlogn solution works here perfectly fine."
                    },
                    {
                        "username": "countdankula",
                        "content": "If you use set it will never reach N^2"
                    },
                    {
                        "username": "carlosfonchii",
                        "content": "There is literally no need to come at people when everyone is here to practice and get BETTER at coding. Check yourself."
                    },
                    {
                        "username": "grave18",
                        "content": "[@Rimberse](/Rimberse) No, i am sorting nums (nlogn) and pass the submission."
                    },
                    {
                        "username": "Rimberse",
                        "content": "I actually came up with O(nlogn) solution, but it didn\\'t work. Got TLE\\nSo anything either than O(n) won\\'t actually be accepted as a solution."
                    },
                    {
                        "username": "Saurabh8720",
                        "content": "Sorry To Interrupt Sir But, The Optimised Solution Dont Have a TC of N^2 or NlogN Sorry to Say But u r Wrong, It is Just O(3N) ~= O(N) "
                    },
                    {
                        "username": "nalinnishant",
                        "content": "agree "
                    },
                    {
                        "username": "Angrydemon",
                        "content": "I think they, first try to solve the given question using brute force without considering the time complexity then they try to optimes it, and if it not works they leave the question for later!"
                    },
                    {
                        "username": "aryansuvarna",
                        "content": "lol so true"
                    },
                    {
                        "username": "user7312022",
                        "content": "You can run your code against these test cases before submisson. Hope it helps!\\n\\n[100,4,200,1,3,2]\\n[0,3,7,2,5,8,4,6,0,1]\\n[1,2,0,1]\\n[0]\\n[0,0]\\n[]"
                    },
                    {
                        "username": "subhadipmandalbagjuri",
                        "content": "[9,1,4,7,3,-1,0,5,8,-1,6]"
                    },
                    {
                        "username": "iChuan",
                        "content": "This is really weried to me. Hard to understand the meaning of this question."
                    },
                    {
                        "username": "tusharmathew",
                        "content": "Its not sub sequence so we dont have to maintain order"
                    },
                    {
                        "username": "amansoni22103",
                        "content": "actually we need to avoid duplicate elements here that\\'s why it is showing 3 instead of 2"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/nA5TRClw96I"
                    },
                    {
                        "username": "nareshvishram",
                        "content": "![image](https://assets.leetcode.com/users/images/c8f1a005-5f10-4957-81be-7fb5c11163dd_1596370783.9489772.png)\\n"
                    },
                    {
                        "username": "addictive_head",
                        "content": "This is O(N) solution actually.\\n1. We are iterating over all elements of hash Set O(N).\\n 2. We then are looking for elements which are starting the subsequence, then we are searching elements set(i)+1, we keep searching till we are finding them. Update the final Count if required.\\nNote that we do not iterate over same numbers again. So O(N).\\n\\ni.e.  O(2N) ~= O(N)"
                    },
                    {
                        "username": "0bro",
                        "content": "At best it O(n log n), n for iterating the entire array, then log n for sub iterating through the hash within the loop that is iterating through the passed array. The search for the O(n) is real lol"
                    },
                    {
                        "username": "ethanultra",
                        "content": "[@SunilKumawat](/SunilKumawat) how? when we iterate through again to find a starting point, we only perform the search if there are elements in the subsequence, so when we encounter another element later that\\'s part of the subsequence, we skip it, so it\\'s not O(N^2) time, it is a multiple of O(N), so O(N)"
                    },
                    {
                        "username": "bhautikkapadiya6",
                        "content": "This algo is work but it has O(n*2) complexity"
                    },
                    {
                        "username": "kamran3210",
                        "content": "[@SunilKumawat](/SunilKumawat) \n\nI may be mistaken but surely its O(N)?\n\nInitialise set with the elements: O(N)\n\nIterate over array and check if it is the start of a subsequence (does not have a predecessor): O(N)\n\nSum of  lengths of all subsequences starting from a number that doesn't have a predecessor = N, therefore countining lengths of all subsequences: O(N)\n\noverall complexity: O(N)"
                    },
                    {
                        "username": "user5062LR",
                        "content": "[@SunilKumawat](/SunilKumawat) its O(3N) ~= O(N)"
                    },
                    {
                        "username": "hardikgupta083",
                        "content": "That is not O(N)"
                    },
                    {
                        "username": "SunilKumawat",
                        "content": "this solution has 0(N^2) time complexity genius"
                    },
                    {
                        "username": "forrrjoyuri",
                        "content": "Just for the sake of comparison, I implemented a naive solution in O(n log n) that sorts the array.\\nMy solution runs in 9ms. I copypasted the best linear solutions from the top posts here and the best i got was 30ms.\\n\\nIn theory, something is wrong here. Why is it the case ?"
                    },
                    {
                        "username": "energyperformer",
                        "content": "One thing u need to remeber is Best time complexity Solution doesn\\'t necessarly mean the fastet solution every instance ,initally for small numbers of n ,even if time complexity is more it can give faster result ,but when we go for large values of n then less time complexity solution offer better time results"
                    },
                    {
                        "username": "treat",
                        "content": "[@DeclanGH](/DeclanGH) Your assumed O(N) might actually be O(N^2)"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "I think leetcode needs to add a very large testcase for this problem to make a nlogn fail"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "[@matthewjiao](/matthewjiao) You are right in theory, but if you could see my two solutions, you would see the comment i made. My first O(n) solution ran 463 ms while the nlogn ran 14ms. its really weird and i was graced to get one testcase wrong, which had 10000 as its answer (which is the largest input size). Not saying you are wrong, but the fact that my result was that way still confuses me. "
                    },
                    {
                        "username": "ixeridium",
                        "content": "E.g. with Python it can happen that using some builtin primitive (or libraries such as numpy) give very significant speedups. A factor of 100 or more is not unusual. In such situations it can happen that a O(n log n) solution is always faster than a O(n) solution for any practical input size. I.e., n log n < 100 * n for all n < exp(100)."
                    },
                    {
                        "username": "wasam1119",
                        "content": "[@matthewjiao](/matthewjiao) Accurate. Observe graphs of y = x and y = x*log(x)"
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "from my experience agr aap ek baar best runtime solution dekh lo ja kr after submission and copy pr aap submit kro then this time code not beats 100 percent submission zyada time lega \\nmay be this is leetcode feature jisse leetcode ke solution ko dekh bo dusro ke solution ko beat na kr paye jin logo ne bina ldekhe kiya hai leetcode best solution \\n"
                    },
                    {
                        "username": "matthewjiao",
                        "content": "Time complexity is not a function of speed, it\\'s a function of growth based on input size. Perhaps with smaller inputs, the linearithmic solution is faster than the linear solution, but as input grows in size, O(n) will eventually out perform O(nlogn)."
                    },
                    {
                        "username": "coolkid0006",
                        "content": "Big O notation drops constants from algorithms\\' complexity because Big O notation is concerned with asymptotic inputs (the input size heads towards infinity). The leetcode test cases aren\\'t large enough to ideally represent the asymptotic complexity, so the constants dropped off when calculating the Big O complexity can have a significant effect on runtime. For example:\\n\\nImagine 2 algorithms for a problem: one has a complexity of n^2 and one has an algorithm of n + 10000. The big O notation drops the constants, so the complexities are O(n^2) and O(n). If you work with small amounts of data the n^2 will have a much smaller runtime, but once a certain point is reached the +10000 won\\'t make much of a difference on the runtime.\\n\\nFor this leetcode problem the naive solution has a smaller runtime for inputs smaller than a certain point. This point is larger than the input sizes of the leetcode solution.\\n\\nIf your solution is at the very bottom of the time and memory leaderboard you might want to make sure it is implemented correctly, but because of the asymptotic nature of Big O notation it isn\\'t always accurate to whether it is the ideal solution."
                    },
                    {
                        "username": "Triquetra",
                        "content": "Try to plot execution time of both solutions against n = 100, 1000, 10000, ... \\u2014 maybe you will see a pattern."
                    },
                    {
                        "username": "kiyosaanb",
                        "content": "In case you are doing something like  nums[i]++ or nums[i]-- , you will encounter problems with this new test case ---> [2147483647,-2147483648]"
                    },
                    {
                        "username": "ShiqiLu77",
                        "content": "-1,000,000,000 <= nums[i] <= 1,000,000,000"
                    },
                    {
                        "username": "yis1178",
                        "content": "I think there is a restriction of the value of nums[i] -- not sure if this is lately added"
                    },
                    {
                        "username": "jasusy",
                        "content": "Is it better to need to clarify duplicate numbers not included in consecutive seq?\\n\\nFor example, if input [0, 0] should output 1, instead of 2, since no duplication counted in result.\\n\\nIf duplicate number considered, we need use HashMap instead of HashSet, and a little different in coding."
                    },
                    {
                        "username": "rubayamim381",
                        "content": "[@shanwu](/shanwu) [1,1,2,3,4] = 5"
                    },
                    {
                        "username": "user6161I",
                        "content": "[@shanwu](/shanwu) 4 ... Because Duplicates are to be treated as single."
                    },
                    {
                        "username": "khritish17",
                        "content": "duplicates should be treated as one\\ne.g : nums = [0,0,1,2,3,4,5,6,7,8] -> output: 9 ([0,1,2,3,4,5,6,7,8])"
                    },
                    {
                        "username": "shanwu",
                        "content": "I agree with you. If duplicate numbers are allowed, then what should be the answer of [100,4,200,1,1,3,2] ? It would be unclear."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/longest-consecutive-sequence/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Sorting\n\n  \n**Approach 3:** HashSet and Intelligent Sequence Building\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "PruthviChippa",
                        "content": "this deserves to be hard for o(n)"
                    },
                    {
                        "username": "Hopity",
                        "content": "for some reason it accepts o(nlogn) that\\'s why it\\'s in medium"
                    }
                ]
            },
            {
                "id": 1575370,
                "content": [
                    {
                        "username": "dghosh133",
                        "content": "How does [1,2,0,1] tc gives output as 3? It should be 2! Someone please clarify.\\n[0,1,1,2] -> has at most 2 consecutive nos."
                    },
                    {
                        "username": "TraySoek",
                        "content": "[@PrashantZuko](/PrashantZuko) yes that\\'s it"
                    },
                    {
                        "username": "dsoum",
                        "content": "[@OmarEffat](/OmarEffat) No highest sequence here is, 0,1,2,3,4,5,6,7,8 hence 9. why 10?"
                    },
                    {
                        "username": "Priyashreyas",
                        "content": "[@ironmonger1](/ironmonger1)  if thats the case, the example given above\\n Input: nums = [0,3,7,2,5,8,4,6,0,1]\\nOutput: 9 then it should be 10 and not 9 right? "
                    },
                    {
                        "username": "Priyashreyas",
                        "content": "[@Ajay_Singh9990](/Ajay_Singh9990) if thats the case, the example given above\\n Input: nums = [0,3,7,2,5,8,4,6,0,1]\\nOutput: 9 then it should be 10 and not 9 right? "
                    },
                    {
                        "username": "Rajiv_123",
                        "content": "[@Dipan Ghosh](/dghosh133) For input [0,1,1,2] Longest consecutive seq would be 0,1,2 hence answer would be 3.  We can ignore the 1 at 2nd index as you are allowed to pick numbers at random indexes such that they are consecutive."
                    },
                    {
                        "username": "OmarEffat",
                        "content": "[@geekgeekvm](/geekgeekvm)  In this case, [0,3,7,2,5,8,4,6,0,1] this should be returning 10 (Example 2)"
                    },
                    {
                        "username": "geekgeekvm",
                        "content": "This was not clear from the question, but the question seems to indicate any sequence of consecutive numbers even if there is a repition in between"
                    },
                    {
                        "username": "sh1kamaruNara",
                        "content": "0,1,2 "
                    },
                    {
                        "username": "cookieslasher",
                        "content": "I had the same question. I thought the count should break off it reaches a duplicate number. I guess this wasn\\'t obvious in the problem description."
                    },
                    {
                        "username": "PrashantZuko",
                        "content": "no,it will be 3 since 0,1,2 are all consecutive."
                    },
                    {
                        "username": "user0241F",
                        "content": "            if inputArr[l] == inputArr[l + 1] then only increase"
                    },
                    {
                        "username": "devanshumasodker357",
                        "content": "bro u forget to add 0 that\\'s why it gives 3"
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "whenever duplicates elements in array but we have to return longest sequence\\nex  (1,1,2,2,3,3.4)    answer is 4\\nbcoz hume duplicate se mtlb nahi hai 1,2,3,4, numbers hai gap 1 ka hai then duplicates ko ignore kr dege "
                    },
                    {
                        "username": "Vishal773",
                        "content": "I think duplicates numbers not counted\\n"
                    },
                    {
                        "username": "ankit528",
                        "content": "subsequence could be in any order\\n"
                    },
                    {
                        "username": "subhadipmandalbagjuri",
                        "content": "i also faced same query, but with another else if statement if got resolved"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "well 0,1,2 there\\'s your sequence"
                    },
                    {
                        "username": "user5582eQ",
                        "content": "So many solutions here claiming to be O(n) are actually either O(n^2) or O(nlogn). How can people here have such poor understanding of time complexity."
                    },
                    {
                        "username": "_Ritik_Singh_",
                        "content": "Bro there is no need to judge anyone on the basis of their solution as long as they are solving and learning so chill out and watch  yourself."
                    },
                    {
                        "username": "RealNameHidden",
                        "content": "Explain it then if you understand it so well, so people can learn"
                    },
                    {
                        "username": "dragosarsene7",
                        "content": "[@carlosfonchii](/carlosfonchii) Learn what exactly. The whole point of the problem is to not sort, otherwise it is trivial. People who use sorting barely learn something, if anything at all, they just call sort and then iterate through an array."
                    },
                    {
                        "username": "dipanshuSaini",
                        "content": "[@Rimberse](/Rimberse)  my nlogn solution is as per leetcode -> 99 % faster. So yes, nlogn solution works here perfectly fine."
                    },
                    {
                        "username": "countdankula",
                        "content": "If you use set it will never reach N^2"
                    },
                    {
                        "username": "carlosfonchii",
                        "content": "There is literally no need to come at people when everyone is here to practice and get BETTER at coding. Check yourself."
                    },
                    {
                        "username": "grave18",
                        "content": "[@Rimberse](/Rimberse) No, i am sorting nums (nlogn) and pass the submission."
                    },
                    {
                        "username": "Rimberse",
                        "content": "I actually came up with O(nlogn) solution, but it didn\\'t work. Got TLE\\nSo anything either than O(n) won\\'t actually be accepted as a solution."
                    },
                    {
                        "username": "Saurabh8720",
                        "content": "Sorry To Interrupt Sir But, The Optimised Solution Dont Have a TC of N^2 or NlogN Sorry to Say But u r Wrong, It is Just O(3N) ~= O(N) "
                    },
                    {
                        "username": "nalinnishant",
                        "content": "agree "
                    },
                    {
                        "username": "Angrydemon",
                        "content": "I think they, first try to solve the given question using brute force without considering the time complexity then they try to optimes it, and if it not works they leave the question for later!"
                    },
                    {
                        "username": "aryansuvarna",
                        "content": "lol so true"
                    },
                    {
                        "username": "user7312022",
                        "content": "You can run your code against these test cases before submisson. Hope it helps!\\n\\n[100,4,200,1,3,2]\\n[0,3,7,2,5,8,4,6,0,1]\\n[1,2,0,1]\\n[0]\\n[0,0]\\n[]"
                    },
                    {
                        "username": "subhadipmandalbagjuri",
                        "content": "[9,1,4,7,3,-1,0,5,8,-1,6]"
                    },
                    {
                        "username": "iChuan",
                        "content": "This is really weried to me. Hard to understand the meaning of this question."
                    },
                    {
                        "username": "tusharmathew",
                        "content": "Its not sub sequence so we dont have to maintain order"
                    },
                    {
                        "username": "amansoni22103",
                        "content": "actually we need to avoid duplicate elements here that\\'s why it is showing 3 instead of 2"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/nA5TRClw96I"
                    },
                    {
                        "username": "nareshvishram",
                        "content": "![image](https://assets.leetcode.com/users/images/c8f1a005-5f10-4957-81be-7fb5c11163dd_1596370783.9489772.png)\\n"
                    },
                    {
                        "username": "addictive_head",
                        "content": "This is O(N) solution actually.\\n1. We are iterating over all elements of hash Set O(N).\\n 2. We then are looking for elements which are starting the subsequence, then we are searching elements set(i)+1, we keep searching till we are finding them. Update the final Count if required.\\nNote that we do not iterate over same numbers again. So O(N).\\n\\ni.e.  O(2N) ~= O(N)"
                    },
                    {
                        "username": "0bro",
                        "content": "At best it O(n log n), n for iterating the entire array, then log n for sub iterating through the hash within the loop that is iterating through the passed array. The search for the O(n) is real lol"
                    },
                    {
                        "username": "ethanultra",
                        "content": "[@SunilKumawat](/SunilKumawat) how? when we iterate through again to find a starting point, we only perform the search if there are elements in the subsequence, so when we encounter another element later that\\'s part of the subsequence, we skip it, so it\\'s not O(N^2) time, it is a multiple of O(N), so O(N)"
                    },
                    {
                        "username": "bhautikkapadiya6",
                        "content": "This algo is work but it has O(n*2) complexity"
                    },
                    {
                        "username": "kamran3210",
                        "content": "[@SunilKumawat](/SunilKumawat) \n\nI may be mistaken but surely its O(N)?\n\nInitialise set with the elements: O(N)\n\nIterate over array and check if it is the start of a subsequence (does not have a predecessor): O(N)\n\nSum of  lengths of all subsequences starting from a number that doesn't have a predecessor = N, therefore countining lengths of all subsequences: O(N)\n\noverall complexity: O(N)"
                    },
                    {
                        "username": "user5062LR",
                        "content": "[@SunilKumawat](/SunilKumawat) its O(3N) ~= O(N)"
                    },
                    {
                        "username": "hardikgupta083",
                        "content": "That is not O(N)"
                    },
                    {
                        "username": "SunilKumawat",
                        "content": "this solution has 0(N^2) time complexity genius"
                    },
                    {
                        "username": "forrrjoyuri",
                        "content": "Just for the sake of comparison, I implemented a naive solution in O(n log n) that sorts the array.\\nMy solution runs in 9ms. I copypasted the best linear solutions from the top posts here and the best i got was 30ms.\\n\\nIn theory, something is wrong here. Why is it the case ?"
                    },
                    {
                        "username": "energyperformer",
                        "content": "One thing u need to remeber is Best time complexity Solution doesn\\'t necessarly mean the fastet solution every instance ,initally for small numbers of n ,even if time complexity is more it can give faster result ,but when we go for large values of n then less time complexity solution offer better time results"
                    },
                    {
                        "username": "treat",
                        "content": "[@DeclanGH](/DeclanGH) Your assumed O(N) might actually be O(N^2)"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "I think leetcode needs to add a very large testcase for this problem to make a nlogn fail"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "[@matthewjiao](/matthewjiao) You are right in theory, but if you could see my two solutions, you would see the comment i made. My first O(n) solution ran 463 ms while the nlogn ran 14ms. its really weird and i was graced to get one testcase wrong, which had 10000 as its answer (which is the largest input size). Not saying you are wrong, but the fact that my result was that way still confuses me. "
                    },
                    {
                        "username": "ixeridium",
                        "content": "E.g. with Python it can happen that using some builtin primitive (or libraries such as numpy) give very significant speedups. A factor of 100 or more is not unusual. In such situations it can happen that a O(n log n) solution is always faster than a O(n) solution for any practical input size. I.e., n log n < 100 * n for all n < exp(100)."
                    },
                    {
                        "username": "wasam1119",
                        "content": "[@matthewjiao](/matthewjiao) Accurate. Observe graphs of y = x and y = x*log(x)"
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "from my experience agr aap ek baar best runtime solution dekh lo ja kr after submission and copy pr aap submit kro then this time code not beats 100 percent submission zyada time lega \\nmay be this is leetcode feature jisse leetcode ke solution ko dekh bo dusro ke solution ko beat na kr paye jin logo ne bina ldekhe kiya hai leetcode best solution \\n"
                    },
                    {
                        "username": "matthewjiao",
                        "content": "Time complexity is not a function of speed, it\\'s a function of growth based on input size. Perhaps with smaller inputs, the linearithmic solution is faster than the linear solution, but as input grows in size, O(n) will eventually out perform O(nlogn)."
                    },
                    {
                        "username": "coolkid0006",
                        "content": "Big O notation drops constants from algorithms\\' complexity because Big O notation is concerned with asymptotic inputs (the input size heads towards infinity). The leetcode test cases aren\\'t large enough to ideally represent the asymptotic complexity, so the constants dropped off when calculating the Big O complexity can have a significant effect on runtime. For example:\\n\\nImagine 2 algorithms for a problem: one has a complexity of n^2 and one has an algorithm of n + 10000. The big O notation drops the constants, so the complexities are O(n^2) and O(n). If you work with small amounts of data the n^2 will have a much smaller runtime, but once a certain point is reached the +10000 won\\'t make much of a difference on the runtime.\\n\\nFor this leetcode problem the naive solution has a smaller runtime for inputs smaller than a certain point. This point is larger than the input sizes of the leetcode solution.\\n\\nIf your solution is at the very bottom of the time and memory leaderboard you might want to make sure it is implemented correctly, but because of the asymptotic nature of Big O notation it isn\\'t always accurate to whether it is the ideal solution."
                    },
                    {
                        "username": "Triquetra",
                        "content": "Try to plot execution time of both solutions against n = 100, 1000, 10000, ... \\u2014 maybe you will see a pattern."
                    },
                    {
                        "username": "kiyosaanb",
                        "content": "In case you are doing something like  nums[i]++ or nums[i]-- , you will encounter problems with this new test case ---> [2147483647,-2147483648]"
                    },
                    {
                        "username": "ShiqiLu77",
                        "content": "-1,000,000,000 <= nums[i] <= 1,000,000,000"
                    },
                    {
                        "username": "yis1178",
                        "content": "I think there is a restriction of the value of nums[i] -- not sure if this is lately added"
                    },
                    {
                        "username": "jasusy",
                        "content": "Is it better to need to clarify duplicate numbers not included in consecutive seq?\\n\\nFor example, if input [0, 0] should output 1, instead of 2, since no duplication counted in result.\\n\\nIf duplicate number considered, we need use HashMap instead of HashSet, and a little different in coding."
                    },
                    {
                        "username": "rubayamim381",
                        "content": "[@shanwu](/shanwu) [1,1,2,3,4] = 5"
                    },
                    {
                        "username": "user6161I",
                        "content": "[@shanwu](/shanwu) 4 ... Because Duplicates are to be treated as single."
                    },
                    {
                        "username": "khritish17",
                        "content": "duplicates should be treated as one\\ne.g : nums = [0,0,1,2,3,4,5,6,7,8] -> output: 9 ([0,1,2,3,4,5,6,7,8])"
                    },
                    {
                        "username": "shanwu",
                        "content": "I agree with you. If duplicate numbers are allowed, then what should be the answer of [100,4,200,1,1,3,2] ? It would be unclear."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/longest-consecutive-sequence/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Sorting\n\n  \n**Approach 3:** HashSet and Intelligent Sequence Building\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "PruthviChippa",
                        "content": "this deserves to be hard for o(n)"
                    },
                    {
                        "username": "Hopity",
                        "content": "for some reason it accepts o(nlogn) that\\'s why it\\'s in medium"
                    }
                ]
            },
            {
                "id": 1566539,
                "content": [
                    {
                        "username": "dghosh133",
                        "content": "How does [1,2,0,1] tc gives output as 3? It should be 2! Someone please clarify.\\n[0,1,1,2] -> has at most 2 consecutive nos."
                    },
                    {
                        "username": "TraySoek",
                        "content": "[@PrashantZuko](/PrashantZuko) yes that\\'s it"
                    },
                    {
                        "username": "dsoum",
                        "content": "[@OmarEffat](/OmarEffat) No highest sequence here is, 0,1,2,3,4,5,6,7,8 hence 9. why 10?"
                    },
                    {
                        "username": "Priyashreyas",
                        "content": "[@ironmonger1](/ironmonger1)  if thats the case, the example given above\\n Input: nums = [0,3,7,2,5,8,4,6,0,1]\\nOutput: 9 then it should be 10 and not 9 right? "
                    },
                    {
                        "username": "Priyashreyas",
                        "content": "[@Ajay_Singh9990](/Ajay_Singh9990) if thats the case, the example given above\\n Input: nums = [0,3,7,2,5,8,4,6,0,1]\\nOutput: 9 then it should be 10 and not 9 right? "
                    },
                    {
                        "username": "Rajiv_123",
                        "content": "[@Dipan Ghosh](/dghosh133) For input [0,1,1,2] Longest consecutive seq would be 0,1,2 hence answer would be 3.  We can ignore the 1 at 2nd index as you are allowed to pick numbers at random indexes such that they are consecutive."
                    },
                    {
                        "username": "OmarEffat",
                        "content": "[@geekgeekvm](/geekgeekvm)  In this case, [0,3,7,2,5,8,4,6,0,1] this should be returning 10 (Example 2)"
                    },
                    {
                        "username": "geekgeekvm",
                        "content": "This was not clear from the question, but the question seems to indicate any sequence of consecutive numbers even if there is a repition in between"
                    },
                    {
                        "username": "sh1kamaruNara",
                        "content": "0,1,2 "
                    },
                    {
                        "username": "cookieslasher",
                        "content": "I had the same question. I thought the count should break off it reaches a duplicate number. I guess this wasn\\'t obvious in the problem description."
                    },
                    {
                        "username": "PrashantZuko",
                        "content": "no,it will be 3 since 0,1,2 are all consecutive."
                    },
                    {
                        "username": "user0241F",
                        "content": "            if inputArr[l] == inputArr[l + 1] then only increase"
                    },
                    {
                        "username": "devanshumasodker357",
                        "content": "bro u forget to add 0 that\\'s why it gives 3"
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "whenever duplicates elements in array but we have to return longest sequence\\nex  (1,1,2,2,3,3.4)    answer is 4\\nbcoz hume duplicate se mtlb nahi hai 1,2,3,4, numbers hai gap 1 ka hai then duplicates ko ignore kr dege "
                    },
                    {
                        "username": "Vishal773",
                        "content": "I think duplicates numbers not counted\\n"
                    },
                    {
                        "username": "ankit528",
                        "content": "subsequence could be in any order\\n"
                    },
                    {
                        "username": "subhadipmandalbagjuri",
                        "content": "i also faced same query, but with another else if statement if got resolved"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "well 0,1,2 there\\'s your sequence"
                    },
                    {
                        "username": "user5582eQ",
                        "content": "So many solutions here claiming to be O(n) are actually either O(n^2) or O(nlogn). How can people here have such poor understanding of time complexity."
                    },
                    {
                        "username": "_Ritik_Singh_",
                        "content": "Bro there is no need to judge anyone on the basis of their solution as long as they are solving and learning so chill out and watch  yourself."
                    },
                    {
                        "username": "RealNameHidden",
                        "content": "Explain it then if you understand it so well, so people can learn"
                    },
                    {
                        "username": "dragosarsene7",
                        "content": "[@carlosfonchii](/carlosfonchii) Learn what exactly. The whole point of the problem is to not sort, otherwise it is trivial. People who use sorting barely learn something, if anything at all, they just call sort and then iterate through an array."
                    },
                    {
                        "username": "dipanshuSaini",
                        "content": "[@Rimberse](/Rimberse)  my nlogn solution is as per leetcode -> 99 % faster. So yes, nlogn solution works here perfectly fine."
                    },
                    {
                        "username": "countdankula",
                        "content": "If you use set it will never reach N^2"
                    },
                    {
                        "username": "carlosfonchii",
                        "content": "There is literally no need to come at people when everyone is here to practice and get BETTER at coding. Check yourself."
                    },
                    {
                        "username": "grave18",
                        "content": "[@Rimberse](/Rimberse) No, i am sorting nums (nlogn) and pass the submission."
                    },
                    {
                        "username": "Rimberse",
                        "content": "I actually came up with O(nlogn) solution, but it didn\\'t work. Got TLE\\nSo anything either than O(n) won\\'t actually be accepted as a solution."
                    },
                    {
                        "username": "Saurabh8720",
                        "content": "Sorry To Interrupt Sir But, The Optimised Solution Dont Have a TC of N^2 or NlogN Sorry to Say But u r Wrong, It is Just O(3N) ~= O(N) "
                    },
                    {
                        "username": "nalinnishant",
                        "content": "agree "
                    },
                    {
                        "username": "Angrydemon",
                        "content": "I think they, first try to solve the given question using brute force without considering the time complexity then they try to optimes it, and if it not works they leave the question for later!"
                    },
                    {
                        "username": "aryansuvarna",
                        "content": "lol so true"
                    },
                    {
                        "username": "user7312022",
                        "content": "You can run your code against these test cases before submisson. Hope it helps!\\n\\n[100,4,200,1,3,2]\\n[0,3,7,2,5,8,4,6,0,1]\\n[1,2,0,1]\\n[0]\\n[0,0]\\n[]"
                    },
                    {
                        "username": "subhadipmandalbagjuri",
                        "content": "[9,1,4,7,3,-1,0,5,8,-1,6]"
                    },
                    {
                        "username": "iChuan",
                        "content": "This is really weried to me. Hard to understand the meaning of this question."
                    },
                    {
                        "username": "tusharmathew",
                        "content": "Its not sub sequence so we dont have to maintain order"
                    },
                    {
                        "username": "amansoni22103",
                        "content": "actually we need to avoid duplicate elements here that\\'s why it is showing 3 instead of 2"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/nA5TRClw96I"
                    },
                    {
                        "username": "nareshvishram",
                        "content": "![image](https://assets.leetcode.com/users/images/c8f1a005-5f10-4957-81be-7fb5c11163dd_1596370783.9489772.png)\\n"
                    },
                    {
                        "username": "addictive_head",
                        "content": "This is O(N) solution actually.\\n1. We are iterating over all elements of hash Set O(N).\\n 2. We then are looking for elements which are starting the subsequence, then we are searching elements set(i)+1, we keep searching till we are finding them. Update the final Count if required.\\nNote that we do not iterate over same numbers again. So O(N).\\n\\ni.e.  O(2N) ~= O(N)"
                    },
                    {
                        "username": "0bro",
                        "content": "At best it O(n log n), n for iterating the entire array, then log n for sub iterating through the hash within the loop that is iterating through the passed array. The search for the O(n) is real lol"
                    },
                    {
                        "username": "ethanultra",
                        "content": "[@SunilKumawat](/SunilKumawat) how? when we iterate through again to find a starting point, we only perform the search if there are elements in the subsequence, so when we encounter another element later that\\'s part of the subsequence, we skip it, so it\\'s not O(N^2) time, it is a multiple of O(N), so O(N)"
                    },
                    {
                        "username": "bhautikkapadiya6",
                        "content": "This algo is work but it has O(n*2) complexity"
                    },
                    {
                        "username": "kamran3210",
                        "content": "[@SunilKumawat](/SunilKumawat) \n\nI may be mistaken but surely its O(N)?\n\nInitialise set with the elements: O(N)\n\nIterate over array and check if it is the start of a subsequence (does not have a predecessor): O(N)\n\nSum of  lengths of all subsequences starting from a number that doesn't have a predecessor = N, therefore countining lengths of all subsequences: O(N)\n\noverall complexity: O(N)"
                    },
                    {
                        "username": "user5062LR",
                        "content": "[@SunilKumawat](/SunilKumawat) its O(3N) ~= O(N)"
                    },
                    {
                        "username": "hardikgupta083",
                        "content": "That is not O(N)"
                    },
                    {
                        "username": "SunilKumawat",
                        "content": "this solution has 0(N^2) time complexity genius"
                    },
                    {
                        "username": "forrrjoyuri",
                        "content": "Just for the sake of comparison, I implemented a naive solution in O(n log n) that sorts the array.\\nMy solution runs in 9ms. I copypasted the best linear solutions from the top posts here and the best i got was 30ms.\\n\\nIn theory, something is wrong here. Why is it the case ?"
                    },
                    {
                        "username": "energyperformer",
                        "content": "One thing u need to remeber is Best time complexity Solution doesn\\'t necessarly mean the fastet solution every instance ,initally for small numbers of n ,even if time complexity is more it can give faster result ,but when we go for large values of n then less time complexity solution offer better time results"
                    },
                    {
                        "username": "treat",
                        "content": "[@DeclanGH](/DeclanGH) Your assumed O(N) might actually be O(N^2)"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "I think leetcode needs to add a very large testcase for this problem to make a nlogn fail"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "[@matthewjiao](/matthewjiao) You are right in theory, but if you could see my two solutions, you would see the comment i made. My first O(n) solution ran 463 ms while the nlogn ran 14ms. its really weird and i was graced to get one testcase wrong, which had 10000 as its answer (which is the largest input size). Not saying you are wrong, but the fact that my result was that way still confuses me. "
                    },
                    {
                        "username": "ixeridium",
                        "content": "E.g. with Python it can happen that using some builtin primitive (or libraries such as numpy) give very significant speedups. A factor of 100 or more is not unusual. In such situations it can happen that a O(n log n) solution is always faster than a O(n) solution for any practical input size. I.e., n log n < 100 * n for all n < exp(100)."
                    },
                    {
                        "username": "wasam1119",
                        "content": "[@matthewjiao](/matthewjiao) Accurate. Observe graphs of y = x and y = x*log(x)"
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "from my experience agr aap ek baar best runtime solution dekh lo ja kr after submission and copy pr aap submit kro then this time code not beats 100 percent submission zyada time lega \\nmay be this is leetcode feature jisse leetcode ke solution ko dekh bo dusro ke solution ko beat na kr paye jin logo ne bina ldekhe kiya hai leetcode best solution \\n"
                    },
                    {
                        "username": "matthewjiao",
                        "content": "Time complexity is not a function of speed, it\\'s a function of growth based on input size. Perhaps with smaller inputs, the linearithmic solution is faster than the linear solution, but as input grows in size, O(n) will eventually out perform O(nlogn)."
                    },
                    {
                        "username": "coolkid0006",
                        "content": "Big O notation drops constants from algorithms\\' complexity because Big O notation is concerned with asymptotic inputs (the input size heads towards infinity). The leetcode test cases aren\\'t large enough to ideally represent the asymptotic complexity, so the constants dropped off when calculating the Big O complexity can have a significant effect on runtime. For example:\\n\\nImagine 2 algorithms for a problem: one has a complexity of n^2 and one has an algorithm of n + 10000. The big O notation drops the constants, so the complexities are O(n^2) and O(n). If you work with small amounts of data the n^2 will have a much smaller runtime, but once a certain point is reached the +10000 won\\'t make much of a difference on the runtime.\\n\\nFor this leetcode problem the naive solution has a smaller runtime for inputs smaller than a certain point. This point is larger than the input sizes of the leetcode solution.\\n\\nIf your solution is at the very bottom of the time and memory leaderboard you might want to make sure it is implemented correctly, but because of the asymptotic nature of Big O notation it isn\\'t always accurate to whether it is the ideal solution."
                    },
                    {
                        "username": "Triquetra",
                        "content": "Try to plot execution time of both solutions against n = 100, 1000, 10000, ... \\u2014 maybe you will see a pattern."
                    },
                    {
                        "username": "kiyosaanb",
                        "content": "In case you are doing something like  nums[i]++ or nums[i]-- , you will encounter problems with this new test case ---> [2147483647,-2147483648]"
                    },
                    {
                        "username": "ShiqiLu77",
                        "content": "-1,000,000,000 <= nums[i] <= 1,000,000,000"
                    },
                    {
                        "username": "yis1178",
                        "content": "I think there is a restriction of the value of nums[i] -- not sure if this is lately added"
                    },
                    {
                        "username": "jasusy",
                        "content": "Is it better to need to clarify duplicate numbers not included in consecutive seq?\\n\\nFor example, if input [0, 0] should output 1, instead of 2, since no duplication counted in result.\\n\\nIf duplicate number considered, we need use HashMap instead of HashSet, and a little different in coding."
                    },
                    {
                        "username": "rubayamim381",
                        "content": "[@shanwu](/shanwu) [1,1,2,3,4] = 5"
                    },
                    {
                        "username": "user6161I",
                        "content": "[@shanwu](/shanwu) 4 ... Because Duplicates are to be treated as single."
                    },
                    {
                        "username": "khritish17",
                        "content": "duplicates should be treated as one\\ne.g : nums = [0,0,1,2,3,4,5,6,7,8] -> output: 9 ([0,1,2,3,4,5,6,7,8])"
                    },
                    {
                        "username": "shanwu",
                        "content": "I agree with you. If duplicate numbers are allowed, then what should be the answer of [100,4,200,1,1,3,2] ? It would be unclear."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/longest-consecutive-sequence/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Sorting\n\n  \n**Approach 3:** HashSet and Intelligent Sequence Building\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "PruthviChippa",
                        "content": "this deserves to be hard for o(n)"
                    },
                    {
                        "username": "Hopity",
                        "content": "for some reason it accepts o(nlogn) that\\'s why it\\'s in medium"
                    }
                ]
            },
            {
                "id": 1574147,
                "content": [
                    {
                        "username": "dghosh133",
                        "content": "How does [1,2,0,1] tc gives output as 3? It should be 2! Someone please clarify.\\n[0,1,1,2] -> has at most 2 consecutive nos."
                    },
                    {
                        "username": "TraySoek",
                        "content": "[@PrashantZuko](/PrashantZuko) yes that\\'s it"
                    },
                    {
                        "username": "dsoum",
                        "content": "[@OmarEffat](/OmarEffat) No highest sequence here is, 0,1,2,3,4,5,6,7,8 hence 9. why 10?"
                    },
                    {
                        "username": "Priyashreyas",
                        "content": "[@ironmonger1](/ironmonger1)  if thats the case, the example given above\\n Input: nums = [0,3,7,2,5,8,4,6,0,1]\\nOutput: 9 then it should be 10 and not 9 right? "
                    },
                    {
                        "username": "Priyashreyas",
                        "content": "[@Ajay_Singh9990](/Ajay_Singh9990) if thats the case, the example given above\\n Input: nums = [0,3,7,2,5,8,4,6,0,1]\\nOutput: 9 then it should be 10 and not 9 right? "
                    },
                    {
                        "username": "Rajiv_123",
                        "content": "[@Dipan Ghosh](/dghosh133) For input [0,1,1,2] Longest consecutive seq would be 0,1,2 hence answer would be 3.  We can ignore the 1 at 2nd index as you are allowed to pick numbers at random indexes such that they are consecutive."
                    },
                    {
                        "username": "OmarEffat",
                        "content": "[@geekgeekvm](/geekgeekvm)  In this case, [0,3,7,2,5,8,4,6,0,1] this should be returning 10 (Example 2)"
                    },
                    {
                        "username": "geekgeekvm",
                        "content": "This was not clear from the question, but the question seems to indicate any sequence of consecutive numbers even if there is a repition in between"
                    },
                    {
                        "username": "sh1kamaruNara",
                        "content": "0,1,2 "
                    },
                    {
                        "username": "cookieslasher",
                        "content": "I had the same question. I thought the count should break off it reaches a duplicate number. I guess this wasn\\'t obvious in the problem description."
                    },
                    {
                        "username": "PrashantZuko",
                        "content": "no,it will be 3 since 0,1,2 are all consecutive."
                    },
                    {
                        "username": "user0241F",
                        "content": "            if inputArr[l] == inputArr[l + 1] then only increase"
                    },
                    {
                        "username": "devanshumasodker357",
                        "content": "bro u forget to add 0 that\\'s why it gives 3"
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "whenever duplicates elements in array but we have to return longest sequence\\nex  (1,1,2,2,3,3.4)    answer is 4\\nbcoz hume duplicate se mtlb nahi hai 1,2,3,4, numbers hai gap 1 ka hai then duplicates ko ignore kr dege "
                    },
                    {
                        "username": "Vishal773",
                        "content": "I think duplicates numbers not counted\\n"
                    },
                    {
                        "username": "ankit528",
                        "content": "subsequence could be in any order\\n"
                    },
                    {
                        "username": "subhadipmandalbagjuri",
                        "content": "i also faced same query, but with another else if statement if got resolved"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "well 0,1,2 there\\'s your sequence"
                    },
                    {
                        "username": "user5582eQ",
                        "content": "So many solutions here claiming to be O(n) are actually either O(n^2) or O(nlogn). How can people here have such poor understanding of time complexity."
                    },
                    {
                        "username": "_Ritik_Singh_",
                        "content": "Bro there is no need to judge anyone on the basis of their solution as long as they are solving and learning so chill out and watch  yourself."
                    },
                    {
                        "username": "RealNameHidden",
                        "content": "Explain it then if you understand it so well, so people can learn"
                    },
                    {
                        "username": "dragosarsene7",
                        "content": "[@carlosfonchii](/carlosfonchii) Learn what exactly. The whole point of the problem is to not sort, otherwise it is trivial. People who use sorting barely learn something, if anything at all, they just call sort and then iterate through an array."
                    },
                    {
                        "username": "dipanshuSaini",
                        "content": "[@Rimberse](/Rimberse)  my nlogn solution is as per leetcode -> 99 % faster. So yes, nlogn solution works here perfectly fine."
                    },
                    {
                        "username": "countdankula",
                        "content": "If you use set it will never reach N^2"
                    },
                    {
                        "username": "carlosfonchii",
                        "content": "There is literally no need to come at people when everyone is here to practice and get BETTER at coding. Check yourself."
                    },
                    {
                        "username": "grave18",
                        "content": "[@Rimberse](/Rimberse) No, i am sorting nums (nlogn) and pass the submission."
                    },
                    {
                        "username": "Rimberse",
                        "content": "I actually came up with O(nlogn) solution, but it didn\\'t work. Got TLE\\nSo anything either than O(n) won\\'t actually be accepted as a solution."
                    },
                    {
                        "username": "Saurabh8720",
                        "content": "Sorry To Interrupt Sir But, The Optimised Solution Dont Have a TC of N^2 or NlogN Sorry to Say But u r Wrong, It is Just O(3N) ~= O(N) "
                    },
                    {
                        "username": "nalinnishant",
                        "content": "agree "
                    },
                    {
                        "username": "Angrydemon",
                        "content": "I think they, first try to solve the given question using brute force without considering the time complexity then they try to optimes it, and if it not works they leave the question for later!"
                    },
                    {
                        "username": "aryansuvarna",
                        "content": "lol so true"
                    },
                    {
                        "username": "user7312022",
                        "content": "You can run your code against these test cases before submisson. Hope it helps!\\n\\n[100,4,200,1,3,2]\\n[0,3,7,2,5,8,4,6,0,1]\\n[1,2,0,1]\\n[0]\\n[0,0]\\n[]"
                    },
                    {
                        "username": "subhadipmandalbagjuri",
                        "content": "[9,1,4,7,3,-1,0,5,8,-1,6]"
                    },
                    {
                        "username": "iChuan",
                        "content": "This is really weried to me. Hard to understand the meaning of this question."
                    },
                    {
                        "username": "tusharmathew",
                        "content": "Its not sub sequence so we dont have to maintain order"
                    },
                    {
                        "username": "amansoni22103",
                        "content": "actually we need to avoid duplicate elements here that\\'s why it is showing 3 instead of 2"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/nA5TRClw96I"
                    },
                    {
                        "username": "nareshvishram",
                        "content": "![image](https://assets.leetcode.com/users/images/c8f1a005-5f10-4957-81be-7fb5c11163dd_1596370783.9489772.png)\\n"
                    },
                    {
                        "username": "addictive_head",
                        "content": "This is O(N) solution actually.\\n1. We are iterating over all elements of hash Set O(N).\\n 2. We then are looking for elements which are starting the subsequence, then we are searching elements set(i)+1, we keep searching till we are finding them. Update the final Count if required.\\nNote that we do not iterate over same numbers again. So O(N).\\n\\ni.e.  O(2N) ~= O(N)"
                    },
                    {
                        "username": "0bro",
                        "content": "At best it O(n log n), n for iterating the entire array, then log n for sub iterating through the hash within the loop that is iterating through the passed array. The search for the O(n) is real lol"
                    },
                    {
                        "username": "ethanultra",
                        "content": "[@SunilKumawat](/SunilKumawat) how? when we iterate through again to find a starting point, we only perform the search if there are elements in the subsequence, so when we encounter another element later that\\'s part of the subsequence, we skip it, so it\\'s not O(N^2) time, it is a multiple of O(N), so O(N)"
                    },
                    {
                        "username": "bhautikkapadiya6",
                        "content": "This algo is work but it has O(n*2) complexity"
                    },
                    {
                        "username": "kamran3210",
                        "content": "[@SunilKumawat](/SunilKumawat) \n\nI may be mistaken but surely its O(N)?\n\nInitialise set with the elements: O(N)\n\nIterate over array and check if it is the start of a subsequence (does not have a predecessor): O(N)\n\nSum of  lengths of all subsequences starting from a number that doesn't have a predecessor = N, therefore countining lengths of all subsequences: O(N)\n\noverall complexity: O(N)"
                    },
                    {
                        "username": "user5062LR",
                        "content": "[@SunilKumawat](/SunilKumawat) its O(3N) ~= O(N)"
                    },
                    {
                        "username": "hardikgupta083",
                        "content": "That is not O(N)"
                    },
                    {
                        "username": "SunilKumawat",
                        "content": "this solution has 0(N^2) time complexity genius"
                    },
                    {
                        "username": "forrrjoyuri",
                        "content": "Just for the sake of comparison, I implemented a naive solution in O(n log n) that sorts the array.\\nMy solution runs in 9ms. I copypasted the best linear solutions from the top posts here and the best i got was 30ms.\\n\\nIn theory, something is wrong here. Why is it the case ?"
                    },
                    {
                        "username": "energyperformer",
                        "content": "One thing u need to remeber is Best time complexity Solution doesn\\'t necessarly mean the fastet solution every instance ,initally for small numbers of n ,even if time complexity is more it can give faster result ,but when we go for large values of n then less time complexity solution offer better time results"
                    },
                    {
                        "username": "treat",
                        "content": "[@DeclanGH](/DeclanGH) Your assumed O(N) might actually be O(N^2)"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "I think leetcode needs to add a very large testcase for this problem to make a nlogn fail"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "[@matthewjiao](/matthewjiao) You are right in theory, but if you could see my two solutions, you would see the comment i made. My first O(n) solution ran 463 ms while the nlogn ran 14ms. its really weird and i was graced to get one testcase wrong, which had 10000 as its answer (which is the largest input size). Not saying you are wrong, but the fact that my result was that way still confuses me. "
                    },
                    {
                        "username": "ixeridium",
                        "content": "E.g. with Python it can happen that using some builtin primitive (or libraries such as numpy) give very significant speedups. A factor of 100 or more is not unusual. In such situations it can happen that a O(n log n) solution is always faster than a O(n) solution for any practical input size. I.e., n log n < 100 * n for all n < exp(100)."
                    },
                    {
                        "username": "wasam1119",
                        "content": "[@matthewjiao](/matthewjiao) Accurate. Observe graphs of y = x and y = x*log(x)"
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "from my experience agr aap ek baar best runtime solution dekh lo ja kr after submission and copy pr aap submit kro then this time code not beats 100 percent submission zyada time lega \\nmay be this is leetcode feature jisse leetcode ke solution ko dekh bo dusro ke solution ko beat na kr paye jin logo ne bina ldekhe kiya hai leetcode best solution \\n"
                    },
                    {
                        "username": "matthewjiao",
                        "content": "Time complexity is not a function of speed, it\\'s a function of growth based on input size. Perhaps with smaller inputs, the linearithmic solution is faster than the linear solution, but as input grows in size, O(n) will eventually out perform O(nlogn)."
                    },
                    {
                        "username": "coolkid0006",
                        "content": "Big O notation drops constants from algorithms\\' complexity because Big O notation is concerned with asymptotic inputs (the input size heads towards infinity). The leetcode test cases aren\\'t large enough to ideally represent the asymptotic complexity, so the constants dropped off when calculating the Big O complexity can have a significant effect on runtime. For example:\\n\\nImagine 2 algorithms for a problem: one has a complexity of n^2 and one has an algorithm of n + 10000. The big O notation drops the constants, so the complexities are O(n^2) and O(n). If you work with small amounts of data the n^2 will have a much smaller runtime, but once a certain point is reached the +10000 won\\'t make much of a difference on the runtime.\\n\\nFor this leetcode problem the naive solution has a smaller runtime for inputs smaller than a certain point. This point is larger than the input sizes of the leetcode solution.\\n\\nIf your solution is at the very bottom of the time and memory leaderboard you might want to make sure it is implemented correctly, but because of the asymptotic nature of Big O notation it isn\\'t always accurate to whether it is the ideal solution."
                    },
                    {
                        "username": "Triquetra",
                        "content": "Try to plot execution time of both solutions against n = 100, 1000, 10000, ... \\u2014 maybe you will see a pattern."
                    },
                    {
                        "username": "kiyosaanb",
                        "content": "In case you are doing something like  nums[i]++ or nums[i]-- , you will encounter problems with this new test case ---> [2147483647,-2147483648]"
                    },
                    {
                        "username": "ShiqiLu77",
                        "content": "-1,000,000,000 <= nums[i] <= 1,000,000,000"
                    },
                    {
                        "username": "yis1178",
                        "content": "I think there is a restriction of the value of nums[i] -- not sure if this is lately added"
                    },
                    {
                        "username": "jasusy",
                        "content": "Is it better to need to clarify duplicate numbers not included in consecutive seq?\\n\\nFor example, if input [0, 0] should output 1, instead of 2, since no duplication counted in result.\\n\\nIf duplicate number considered, we need use HashMap instead of HashSet, and a little different in coding."
                    },
                    {
                        "username": "rubayamim381",
                        "content": "[@shanwu](/shanwu) [1,1,2,3,4] = 5"
                    },
                    {
                        "username": "user6161I",
                        "content": "[@shanwu](/shanwu) 4 ... Because Duplicates are to be treated as single."
                    },
                    {
                        "username": "khritish17",
                        "content": "duplicates should be treated as one\\ne.g : nums = [0,0,1,2,3,4,5,6,7,8] -> output: 9 ([0,1,2,3,4,5,6,7,8])"
                    },
                    {
                        "username": "shanwu",
                        "content": "I agree with you. If duplicate numbers are allowed, then what should be the answer of [100,4,200,1,1,3,2] ? It would be unclear."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/longest-consecutive-sequence/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Sorting\n\n  \n**Approach 3:** HashSet and Intelligent Sequence Building\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "PruthviChippa",
                        "content": "this deserves to be hard for o(n)"
                    },
                    {
                        "username": "Hopity",
                        "content": "for some reason it accepts o(nlogn) that\\'s why it\\'s in medium"
                    }
                ]
            },
            {
                "id": 1575709,
                "content": [
                    {
                        "username": "dghosh133",
                        "content": "How does [1,2,0,1] tc gives output as 3? It should be 2! Someone please clarify.\\n[0,1,1,2] -> has at most 2 consecutive nos."
                    },
                    {
                        "username": "TraySoek",
                        "content": "[@PrashantZuko](/PrashantZuko) yes that\\'s it"
                    },
                    {
                        "username": "dsoum",
                        "content": "[@OmarEffat](/OmarEffat) No highest sequence here is, 0,1,2,3,4,5,6,7,8 hence 9. why 10?"
                    },
                    {
                        "username": "Priyashreyas",
                        "content": "[@ironmonger1](/ironmonger1)  if thats the case, the example given above\\n Input: nums = [0,3,7,2,5,8,4,6,0,1]\\nOutput: 9 then it should be 10 and not 9 right? "
                    },
                    {
                        "username": "Priyashreyas",
                        "content": "[@Ajay_Singh9990](/Ajay_Singh9990) if thats the case, the example given above\\n Input: nums = [0,3,7,2,5,8,4,6,0,1]\\nOutput: 9 then it should be 10 and not 9 right? "
                    },
                    {
                        "username": "Rajiv_123",
                        "content": "[@Dipan Ghosh](/dghosh133) For input [0,1,1,2] Longest consecutive seq would be 0,1,2 hence answer would be 3.  We can ignore the 1 at 2nd index as you are allowed to pick numbers at random indexes such that they are consecutive."
                    },
                    {
                        "username": "OmarEffat",
                        "content": "[@geekgeekvm](/geekgeekvm)  In this case, [0,3,7,2,5,8,4,6,0,1] this should be returning 10 (Example 2)"
                    },
                    {
                        "username": "geekgeekvm",
                        "content": "This was not clear from the question, but the question seems to indicate any sequence of consecutive numbers even if there is a repition in between"
                    },
                    {
                        "username": "sh1kamaruNara",
                        "content": "0,1,2 "
                    },
                    {
                        "username": "cookieslasher",
                        "content": "I had the same question. I thought the count should break off it reaches a duplicate number. I guess this wasn\\'t obvious in the problem description."
                    },
                    {
                        "username": "PrashantZuko",
                        "content": "no,it will be 3 since 0,1,2 are all consecutive."
                    },
                    {
                        "username": "user0241F",
                        "content": "            if inputArr[l] == inputArr[l + 1] then only increase"
                    },
                    {
                        "username": "devanshumasodker357",
                        "content": "bro u forget to add 0 that\\'s why it gives 3"
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "whenever duplicates elements in array but we have to return longest sequence\\nex  (1,1,2,2,3,3.4)    answer is 4\\nbcoz hume duplicate se mtlb nahi hai 1,2,3,4, numbers hai gap 1 ka hai then duplicates ko ignore kr dege "
                    },
                    {
                        "username": "Vishal773",
                        "content": "I think duplicates numbers not counted\\n"
                    },
                    {
                        "username": "ankit528",
                        "content": "subsequence could be in any order\\n"
                    },
                    {
                        "username": "subhadipmandalbagjuri",
                        "content": "i also faced same query, but with another else if statement if got resolved"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "well 0,1,2 there\\'s your sequence"
                    },
                    {
                        "username": "user5582eQ",
                        "content": "So many solutions here claiming to be O(n) are actually either O(n^2) or O(nlogn). How can people here have such poor understanding of time complexity."
                    },
                    {
                        "username": "_Ritik_Singh_",
                        "content": "Bro there is no need to judge anyone on the basis of their solution as long as they are solving and learning so chill out and watch  yourself."
                    },
                    {
                        "username": "RealNameHidden",
                        "content": "Explain it then if you understand it so well, so people can learn"
                    },
                    {
                        "username": "dragosarsene7",
                        "content": "[@carlosfonchii](/carlosfonchii) Learn what exactly. The whole point of the problem is to not sort, otherwise it is trivial. People who use sorting barely learn something, if anything at all, they just call sort and then iterate through an array."
                    },
                    {
                        "username": "dipanshuSaini",
                        "content": "[@Rimberse](/Rimberse)  my nlogn solution is as per leetcode -> 99 % faster. So yes, nlogn solution works here perfectly fine."
                    },
                    {
                        "username": "countdankula",
                        "content": "If you use set it will never reach N^2"
                    },
                    {
                        "username": "carlosfonchii",
                        "content": "There is literally no need to come at people when everyone is here to practice and get BETTER at coding. Check yourself."
                    },
                    {
                        "username": "grave18",
                        "content": "[@Rimberse](/Rimberse) No, i am sorting nums (nlogn) and pass the submission."
                    },
                    {
                        "username": "Rimberse",
                        "content": "I actually came up with O(nlogn) solution, but it didn\\'t work. Got TLE\\nSo anything either than O(n) won\\'t actually be accepted as a solution."
                    },
                    {
                        "username": "Saurabh8720",
                        "content": "Sorry To Interrupt Sir But, The Optimised Solution Dont Have a TC of N^2 or NlogN Sorry to Say But u r Wrong, It is Just O(3N) ~= O(N) "
                    },
                    {
                        "username": "nalinnishant",
                        "content": "agree "
                    },
                    {
                        "username": "Angrydemon",
                        "content": "I think they, first try to solve the given question using brute force without considering the time complexity then they try to optimes it, and if it not works they leave the question for later!"
                    },
                    {
                        "username": "aryansuvarna",
                        "content": "lol so true"
                    },
                    {
                        "username": "user7312022",
                        "content": "You can run your code against these test cases before submisson. Hope it helps!\\n\\n[100,4,200,1,3,2]\\n[0,3,7,2,5,8,4,6,0,1]\\n[1,2,0,1]\\n[0]\\n[0,0]\\n[]"
                    },
                    {
                        "username": "subhadipmandalbagjuri",
                        "content": "[9,1,4,7,3,-1,0,5,8,-1,6]"
                    },
                    {
                        "username": "iChuan",
                        "content": "This is really weried to me. Hard to understand the meaning of this question."
                    },
                    {
                        "username": "tusharmathew",
                        "content": "Its not sub sequence so we dont have to maintain order"
                    },
                    {
                        "username": "amansoni22103",
                        "content": "actually we need to avoid duplicate elements here that\\'s why it is showing 3 instead of 2"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/nA5TRClw96I"
                    },
                    {
                        "username": "nareshvishram",
                        "content": "![image](https://assets.leetcode.com/users/images/c8f1a005-5f10-4957-81be-7fb5c11163dd_1596370783.9489772.png)\\n"
                    },
                    {
                        "username": "addictive_head",
                        "content": "This is O(N) solution actually.\\n1. We are iterating over all elements of hash Set O(N).\\n 2. We then are looking for elements which are starting the subsequence, then we are searching elements set(i)+1, we keep searching till we are finding them. Update the final Count if required.\\nNote that we do not iterate over same numbers again. So O(N).\\n\\ni.e.  O(2N) ~= O(N)"
                    },
                    {
                        "username": "0bro",
                        "content": "At best it O(n log n), n for iterating the entire array, then log n for sub iterating through the hash within the loop that is iterating through the passed array. The search for the O(n) is real lol"
                    },
                    {
                        "username": "ethanultra",
                        "content": "[@SunilKumawat](/SunilKumawat) how? when we iterate through again to find a starting point, we only perform the search if there are elements in the subsequence, so when we encounter another element later that\\'s part of the subsequence, we skip it, so it\\'s not O(N^2) time, it is a multiple of O(N), so O(N)"
                    },
                    {
                        "username": "bhautikkapadiya6",
                        "content": "This algo is work but it has O(n*2) complexity"
                    },
                    {
                        "username": "kamran3210",
                        "content": "[@SunilKumawat](/SunilKumawat) \n\nI may be mistaken but surely its O(N)?\n\nInitialise set with the elements: O(N)\n\nIterate over array and check if it is the start of a subsequence (does not have a predecessor): O(N)\n\nSum of  lengths of all subsequences starting from a number that doesn't have a predecessor = N, therefore countining lengths of all subsequences: O(N)\n\noverall complexity: O(N)"
                    },
                    {
                        "username": "user5062LR",
                        "content": "[@SunilKumawat](/SunilKumawat) its O(3N) ~= O(N)"
                    },
                    {
                        "username": "hardikgupta083",
                        "content": "That is not O(N)"
                    },
                    {
                        "username": "SunilKumawat",
                        "content": "this solution has 0(N^2) time complexity genius"
                    },
                    {
                        "username": "forrrjoyuri",
                        "content": "Just for the sake of comparison, I implemented a naive solution in O(n log n) that sorts the array.\\nMy solution runs in 9ms. I copypasted the best linear solutions from the top posts here and the best i got was 30ms.\\n\\nIn theory, something is wrong here. Why is it the case ?"
                    },
                    {
                        "username": "energyperformer",
                        "content": "One thing u need to remeber is Best time complexity Solution doesn\\'t necessarly mean the fastet solution every instance ,initally for small numbers of n ,even if time complexity is more it can give faster result ,but when we go for large values of n then less time complexity solution offer better time results"
                    },
                    {
                        "username": "treat",
                        "content": "[@DeclanGH](/DeclanGH) Your assumed O(N) might actually be O(N^2)"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "I think leetcode needs to add a very large testcase for this problem to make a nlogn fail"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "[@matthewjiao](/matthewjiao) You are right in theory, but if you could see my two solutions, you would see the comment i made. My first O(n) solution ran 463 ms while the nlogn ran 14ms. its really weird and i was graced to get one testcase wrong, which had 10000 as its answer (which is the largest input size). Not saying you are wrong, but the fact that my result was that way still confuses me. "
                    },
                    {
                        "username": "ixeridium",
                        "content": "E.g. with Python it can happen that using some builtin primitive (or libraries such as numpy) give very significant speedups. A factor of 100 or more is not unusual. In such situations it can happen that a O(n log n) solution is always faster than a O(n) solution for any practical input size. I.e., n log n < 100 * n for all n < exp(100)."
                    },
                    {
                        "username": "wasam1119",
                        "content": "[@matthewjiao](/matthewjiao) Accurate. Observe graphs of y = x and y = x*log(x)"
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "from my experience agr aap ek baar best runtime solution dekh lo ja kr after submission and copy pr aap submit kro then this time code not beats 100 percent submission zyada time lega \\nmay be this is leetcode feature jisse leetcode ke solution ko dekh bo dusro ke solution ko beat na kr paye jin logo ne bina ldekhe kiya hai leetcode best solution \\n"
                    },
                    {
                        "username": "matthewjiao",
                        "content": "Time complexity is not a function of speed, it\\'s a function of growth based on input size. Perhaps with smaller inputs, the linearithmic solution is faster than the linear solution, but as input grows in size, O(n) will eventually out perform O(nlogn)."
                    },
                    {
                        "username": "coolkid0006",
                        "content": "Big O notation drops constants from algorithms\\' complexity because Big O notation is concerned with asymptotic inputs (the input size heads towards infinity). The leetcode test cases aren\\'t large enough to ideally represent the asymptotic complexity, so the constants dropped off when calculating the Big O complexity can have a significant effect on runtime. For example:\\n\\nImagine 2 algorithms for a problem: one has a complexity of n^2 and one has an algorithm of n + 10000. The big O notation drops the constants, so the complexities are O(n^2) and O(n). If you work with small amounts of data the n^2 will have a much smaller runtime, but once a certain point is reached the +10000 won\\'t make much of a difference on the runtime.\\n\\nFor this leetcode problem the naive solution has a smaller runtime for inputs smaller than a certain point. This point is larger than the input sizes of the leetcode solution.\\n\\nIf your solution is at the very bottom of the time and memory leaderboard you might want to make sure it is implemented correctly, but because of the asymptotic nature of Big O notation it isn\\'t always accurate to whether it is the ideal solution."
                    },
                    {
                        "username": "Triquetra",
                        "content": "Try to plot execution time of both solutions against n = 100, 1000, 10000, ... \\u2014 maybe you will see a pattern."
                    },
                    {
                        "username": "kiyosaanb",
                        "content": "In case you are doing something like  nums[i]++ or nums[i]-- , you will encounter problems with this new test case ---> [2147483647,-2147483648]"
                    },
                    {
                        "username": "ShiqiLu77",
                        "content": "-1,000,000,000 <= nums[i] <= 1,000,000,000"
                    },
                    {
                        "username": "yis1178",
                        "content": "I think there is a restriction of the value of nums[i] -- not sure if this is lately added"
                    },
                    {
                        "username": "jasusy",
                        "content": "Is it better to need to clarify duplicate numbers not included in consecutive seq?\\n\\nFor example, if input [0, 0] should output 1, instead of 2, since no duplication counted in result.\\n\\nIf duplicate number considered, we need use HashMap instead of HashSet, and a little different in coding."
                    },
                    {
                        "username": "rubayamim381",
                        "content": "[@shanwu](/shanwu) [1,1,2,3,4] = 5"
                    },
                    {
                        "username": "user6161I",
                        "content": "[@shanwu](/shanwu) 4 ... Because Duplicates are to be treated as single."
                    },
                    {
                        "username": "khritish17",
                        "content": "duplicates should be treated as one\\ne.g : nums = [0,0,1,2,3,4,5,6,7,8] -> output: 9 ([0,1,2,3,4,5,6,7,8])"
                    },
                    {
                        "username": "shanwu",
                        "content": "I agree with you. If duplicate numbers are allowed, then what should be the answer of [100,4,200,1,1,3,2] ? It would be unclear."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/longest-consecutive-sequence/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Sorting\n\n  \n**Approach 3:** HashSet and Intelligent Sequence Building\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "PruthviChippa",
                        "content": "this deserves to be hard for o(n)"
                    },
                    {
                        "username": "Hopity",
                        "content": "for some reason it accepts o(nlogn) that\\'s why it\\'s in medium"
                    }
                ]
            },
            {
                "id": 1566994,
                "content": [
                    {
                        "username": "dghosh133",
                        "content": "How does [1,2,0,1] tc gives output as 3? It should be 2! Someone please clarify.\\n[0,1,1,2] -> has at most 2 consecutive nos."
                    },
                    {
                        "username": "TraySoek",
                        "content": "[@PrashantZuko](/PrashantZuko) yes that\\'s it"
                    },
                    {
                        "username": "dsoum",
                        "content": "[@OmarEffat](/OmarEffat) No highest sequence here is, 0,1,2,3,4,5,6,7,8 hence 9. why 10?"
                    },
                    {
                        "username": "Priyashreyas",
                        "content": "[@ironmonger1](/ironmonger1)  if thats the case, the example given above\\n Input: nums = [0,3,7,2,5,8,4,6,0,1]\\nOutput: 9 then it should be 10 and not 9 right? "
                    },
                    {
                        "username": "Priyashreyas",
                        "content": "[@Ajay_Singh9990](/Ajay_Singh9990) if thats the case, the example given above\\n Input: nums = [0,3,7,2,5,8,4,6,0,1]\\nOutput: 9 then it should be 10 and not 9 right? "
                    },
                    {
                        "username": "Rajiv_123",
                        "content": "[@Dipan Ghosh](/dghosh133) For input [0,1,1,2] Longest consecutive seq would be 0,1,2 hence answer would be 3.  We can ignore the 1 at 2nd index as you are allowed to pick numbers at random indexes such that they are consecutive."
                    },
                    {
                        "username": "OmarEffat",
                        "content": "[@geekgeekvm](/geekgeekvm)  In this case, [0,3,7,2,5,8,4,6,0,1] this should be returning 10 (Example 2)"
                    },
                    {
                        "username": "geekgeekvm",
                        "content": "This was not clear from the question, but the question seems to indicate any sequence of consecutive numbers even if there is a repition in between"
                    },
                    {
                        "username": "sh1kamaruNara",
                        "content": "0,1,2 "
                    },
                    {
                        "username": "cookieslasher",
                        "content": "I had the same question. I thought the count should break off it reaches a duplicate number. I guess this wasn\\'t obvious in the problem description."
                    },
                    {
                        "username": "PrashantZuko",
                        "content": "no,it will be 3 since 0,1,2 are all consecutive."
                    },
                    {
                        "username": "user0241F",
                        "content": "            if inputArr[l] == inputArr[l + 1] then only increase"
                    },
                    {
                        "username": "devanshumasodker357",
                        "content": "bro u forget to add 0 that\\'s why it gives 3"
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "whenever duplicates elements in array but we have to return longest sequence\\nex  (1,1,2,2,3,3.4)    answer is 4\\nbcoz hume duplicate se mtlb nahi hai 1,2,3,4, numbers hai gap 1 ka hai then duplicates ko ignore kr dege "
                    },
                    {
                        "username": "Vishal773",
                        "content": "I think duplicates numbers not counted\\n"
                    },
                    {
                        "username": "ankit528",
                        "content": "subsequence could be in any order\\n"
                    },
                    {
                        "username": "subhadipmandalbagjuri",
                        "content": "i also faced same query, but with another else if statement if got resolved"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "well 0,1,2 there\\'s your sequence"
                    },
                    {
                        "username": "user5582eQ",
                        "content": "So many solutions here claiming to be O(n) are actually either O(n^2) or O(nlogn). How can people here have such poor understanding of time complexity."
                    },
                    {
                        "username": "_Ritik_Singh_",
                        "content": "Bro there is no need to judge anyone on the basis of their solution as long as they are solving and learning so chill out and watch  yourself."
                    },
                    {
                        "username": "RealNameHidden",
                        "content": "Explain it then if you understand it so well, so people can learn"
                    },
                    {
                        "username": "dragosarsene7",
                        "content": "[@carlosfonchii](/carlosfonchii) Learn what exactly. The whole point of the problem is to not sort, otherwise it is trivial. People who use sorting barely learn something, if anything at all, they just call sort and then iterate through an array."
                    },
                    {
                        "username": "dipanshuSaini",
                        "content": "[@Rimberse](/Rimberse)  my nlogn solution is as per leetcode -> 99 % faster. So yes, nlogn solution works here perfectly fine."
                    },
                    {
                        "username": "countdankula",
                        "content": "If you use set it will never reach N^2"
                    },
                    {
                        "username": "carlosfonchii",
                        "content": "There is literally no need to come at people when everyone is here to practice and get BETTER at coding. Check yourself."
                    },
                    {
                        "username": "grave18",
                        "content": "[@Rimberse](/Rimberse) No, i am sorting nums (nlogn) and pass the submission."
                    },
                    {
                        "username": "Rimberse",
                        "content": "I actually came up with O(nlogn) solution, but it didn\\'t work. Got TLE\\nSo anything either than O(n) won\\'t actually be accepted as a solution."
                    },
                    {
                        "username": "Saurabh8720",
                        "content": "Sorry To Interrupt Sir But, The Optimised Solution Dont Have a TC of N^2 or NlogN Sorry to Say But u r Wrong, It is Just O(3N) ~= O(N) "
                    },
                    {
                        "username": "nalinnishant",
                        "content": "agree "
                    },
                    {
                        "username": "Angrydemon",
                        "content": "I think they, first try to solve the given question using brute force without considering the time complexity then they try to optimes it, and if it not works they leave the question for later!"
                    },
                    {
                        "username": "aryansuvarna",
                        "content": "lol so true"
                    },
                    {
                        "username": "user7312022",
                        "content": "You can run your code against these test cases before submisson. Hope it helps!\\n\\n[100,4,200,1,3,2]\\n[0,3,7,2,5,8,4,6,0,1]\\n[1,2,0,1]\\n[0]\\n[0,0]\\n[]"
                    },
                    {
                        "username": "subhadipmandalbagjuri",
                        "content": "[9,1,4,7,3,-1,0,5,8,-1,6]"
                    },
                    {
                        "username": "iChuan",
                        "content": "This is really weried to me. Hard to understand the meaning of this question."
                    },
                    {
                        "username": "tusharmathew",
                        "content": "Its not sub sequence so we dont have to maintain order"
                    },
                    {
                        "username": "amansoni22103",
                        "content": "actually we need to avoid duplicate elements here that\\'s why it is showing 3 instead of 2"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/nA5TRClw96I"
                    },
                    {
                        "username": "nareshvishram",
                        "content": "![image](https://assets.leetcode.com/users/images/c8f1a005-5f10-4957-81be-7fb5c11163dd_1596370783.9489772.png)\\n"
                    },
                    {
                        "username": "addictive_head",
                        "content": "This is O(N) solution actually.\\n1. We are iterating over all elements of hash Set O(N).\\n 2. We then are looking for elements which are starting the subsequence, then we are searching elements set(i)+1, we keep searching till we are finding them. Update the final Count if required.\\nNote that we do not iterate over same numbers again. So O(N).\\n\\ni.e.  O(2N) ~= O(N)"
                    },
                    {
                        "username": "0bro",
                        "content": "At best it O(n log n), n for iterating the entire array, then log n for sub iterating through the hash within the loop that is iterating through the passed array. The search for the O(n) is real lol"
                    },
                    {
                        "username": "ethanultra",
                        "content": "[@SunilKumawat](/SunilKumawat) how? when we iterate through again to find a starting point, we only perform the search if there are elements in the subsequence, so when we encounter another element later that\\'s part of the subsequence, we skip it, so it\\'s not O(N^2) time, it is a multiple of O(N), so O(N)"
                    },
                    {
                        "username": "bhautikkapadiya6",
                        "content": "This algo is work but it has O(n*2) complexity"
                    },
                    {
                        "username": "kamran3210",
                        "content": "[@SunilKumawat](/SunilKumawat) \n\nI may be mistaken but surely its O(N)?\n\nInitialise set with the elements: O(N)\n\nIterate over array and check if it is the start of a subsequence (does not have a predecessor): O(N)\n\nSum of  lengths of all subsequences starting from a number that doesn't have a predecessor = N, therefore countining lengths of all subsequences: O(N)\n\noverall complexity: O(N)"
                    },
                    {
                        "username": "user5062LR",
                        "content": "[@SunilKumawat](/SunilKumawat) its O(3N) ~= O(N)"
                    },
                    {
                        "username": "hardikgupta083",
                        "content": "That is not O(N)"
                    },
                    {
                        "username": "SunilKumawat",
                        "content": "this solution has 0(N^2) time complexity genius"
                    },
                    {
                        "username": "forrrjoyuri",
                        "content": "Just for the sake of comparison, I implemented a naive solution in O(n log n) that sorts the array.\\nMy solution runs in 9ms. I copypasted the best linear solutions from the top posts here and the best i got was 30ms.\\n\\nIn theory, something is wrong here. Why is it the case ?"
                    },
                    {
                        "username": "energyperformer",
                        "content": "One thing u need to remeber is Best time complexity Solution doesn\\'t necessarly mean the fastet solution every instance ,initally for small numbers of n ,even if time complexity is more it can give faster result ,but when we go for large values of n then less time complexity solution offer better time results"
                    },
                    {
                        "username": "treat",
                        "content": "[@DeclanGH](/DeclanGH) Your assumed O(N) might actually be O(N^2)"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "I think leetcode needs to add a very large testcase for this problem to make a nlogn fail"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "[@matthewjiao](/matthewjiao) You are right in theory, but if you could see my two solutions, you would see the comment i made. My first O(n) solution ran 463 ms while the nlogn ran 14ms. its really weird and i was graced to get one testcase wrong, which had 10000 as its answer (which is the largest input size). Not saying you are wrong, but the fact that my result was that way still confuses me. "
                    },
                    {
                        "username": "ixeridium",
                        "content": "E.g. with Python it can happen that using some builtin primitive (or libraries such as numpy) give very significant speedups. A factor of 100 or more is not unusual. In such situations it can happen that a O(n log n) solution is always faster than a O(n) solution for any practical input size. I.e., n log n < 100 * n for all n < exp(100)."
                    },
                    {
                        "username": "wasam1119",
                        "content": "[@matthewjiao](/matthewjiao) Accurate. Observe graphs of y = x and y = x*log(x)"
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "from my experience agr aap ek baar best runtime solution dekh lo ja kr after submission and copy pr aap submit kro then this time code not beats 100 percent submission zyada time lega \\nmay be this is leetcode feature jisse leetcode ke solution ko dekh bo dusro ke solution ko beat na kr paye jin logo ne bina ldekhe kiya hai leetcode best solution \\n"
                    },
                    {
                        "username": "matthewjiao",
                        "content": "Time complexity is not a function of speed, it\\'s a function of growth based on input size. Perhaps with smaller inputs, the linearithmic solution is faster than the linear solution, but as input grows in size, O(n) will eventually out perform O(nlogn)."
                    },
                    {
                        "username": "coolkid0006",
                        "content": "Big O notation drops constants from algorithms\\' complexity because Big O notation is concerned with asymptotic inputs (the input size heads towards infinity). The leetcode test cases aren\\'t large enough to ideally represent the asymptotic complexity, so the constants dropped off when calculating the Big O complexity can have a significant effect on runtime. For example:\\n\\nImagine 2 algorithms for a problem: one has a complexity of n^2 and one has an algorithm of n + 10000. The big O notation drops the constants, so the complexities are O(n^2) and O(n). If you work with small amounts of data the n^2 will have a much smaller runtime, but once a certain point is reached the +10000 won\\'t make much of a difference on the runtime.\\n\\nFor this leetcode problem the naive solution has a smaller runtime for inputs smaller than a certain point. This point is larger than the input sizes of the leetcode solution.\\n\\nIf your solution is at the very bottom of the time and memory leaderboard you might want to make sure it is implemented correctly, but because of the asymptotic nature of Big O notation it isn\\'t always accurate to whether it is the ideal solution."
                    },
                    {
                        "username": "Triquetra",
                        "content": "Try to plot execution time of both solutions against n = 100, 1000, 10000, ... \\u2014 maybe you will see a pattern."
                    },
                    {
                        "username": "kiyosaanb",
                        "content": "In case you are doing something like  nums[i]++ or nums[i]-- , you will encounter problems with this new test case ---> [2147483647,-2147483648]"
                    },
                    {
                        "username": "ShiqiLu77",
                        "content": "-1,000,000,000 <= nums[i] <= 1,000,000,000"
                    },
                    {
                        "username": "yis1178",
                        "content": "I think there is a restriction of the value of nums[i] -- not sure if this is lately added"
                    },
                    {
                        "username": "jasusy",
                        "content": "Is it better to need to clarify duplicate numbers not included in consecutive seq?\\n\\nFor example, if input [0, 0] should output 1, instead of 2, since no duplication counted in result.\\n\\nIf duplicate number considered, we need use HashMap instead of HashSet, and a little different in coding."
                    },
                    {
                        "username": "rubayamim381",
                        "content": "[@shanwu](/shanwu) [1,1,2,3,4] = 5"
                    },
                    {
                        "username": "user6161I",
                        "content": "[@shanwu](/shanwu) 4 ... Because Duplicates are to be treated as single."
                    },
                    {
                        "username": "khritish17",
                        "content": "duplicates should be treated as one\\ne.g : nums = [0,0,1,2,3,4,5,6,7,8] -> output: 9 ([0,1,2,3,4,5,6,7,8])"
                    },
                    {
                        "username": "shanwu",
                        "content": "I agree with you. If duplicate numbers are allowed, then what should be the answer of [100,4,200,1,1,3,2] ? It would be unclear."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/longest-consecutive-sequence/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Sorting\n\n  \n**Approach 3:** HashSet and Intelligent Sequence Building\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "PruthviChippa",
                        "content": "this deserves to be hard for o(n)"
                    },
                    {
                        "username": "Hopity",
                        "content": "for some reason it accepts o(nlogn) that\\'s why it\\'s in medium"
                    }
                ]
            },
            {
                "id": 1567206,
                "content": [
                    {
                        "username": "dghosh133",
                        "content": "How does [1,2,0,1] tc gives output as 3? It should be 2! Someone please clarify.\\n[0,1,1,2] -> has at most 2 consecutive nos."
                    },
                    {
                        "username": "TraySoek",
                        "content": "[@PrashantZuko](/PrashantZuko) yes that\\'s it"
                    },
                    {
                        "username": "dsoum",
                        "content": "[@OmarEffat](/OmarEffat) No highest sequence here is, 0,1,2,3,4,5,6,7,8 hence 9. why 10?"
                    },
                    {
                        "username": "Priyashreyas",
                        "content": "[@ironmonger1](/ironmonger1)  if thats the case, the example given above\\n Input: nums = [0,3,7,2,5,8,4,6,0,1]\\nOutput: 9 then it should be 10 and not 9 right? "
                    },
                    {
                        "username": "Priyashreyas",
                        "content": "[@Ajay_Singh9990](/Ajay_Singh9990) if thats the case, the example given above\\n Input: nums = [0,3,7,2,5,8,4,6,0,1]\\nOutput: 9 then it should be 10 and not 9 right? "
                    },
                    {
                        "username": "Rajiv_123",
                        "content": "[@Dipan Ghosh](/dghosh133) For input [0,1,1,2] Longest consecutive seq would be 0,1,2 hence answer would be 3.  We can ignore the 1 at 2nd index as you are allowed to pick numbers at random indexes such that they are consecutive."
                    },
                    {
                        "username": "OmarEffat",
                        "content": "[@geekgeekvm](/geekgeekvm)  In this case, [0,3,7,2,5,8,4,6,0,1] this should be returning 10 (Example 2)"
                    },
                    {
                        "username": "geekgeekvm",
                        "content": "This was not clear from the question, but the question seems to indicate any sequence of consecutive numbers even if there is a repition in between"
                    },
                    {
                        "username": "sh1kamaruNara",
                        "content": "0,1,2 "
                    },
                    {
                        "username": "cookieslasher",
                        "content": "I had the same question. I thought the count should break off it reaches a duplicate number. I guess this wasn\\'t obvious in the problem description."
                    },
                    {
                        "username": "PrashantZuko",
                        "content": "no,it will be 3 since 0,1,2 are all consecutive."
                    },
                    {
                        "username": "user0241F",
                        "content": "            if inputArr[l] == inputArr[l + 1] then only increase"
                    },
                    {
                        "username": "devanshumasodker357",
                        "content": "bro u forget to add 0 that\\'s why it gives 3"
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "whenever duplicates elements in array but we have to return longest sequence\\nex  (1,1,2,2,3,3.4)    answer is 4\\nbcoz hume duplicate se mtlb nahi hai 1,2,3,4, numbers hai gap 1 ka hai then duplicates ko ignore kr dege "
                    },
                    {
                        "username": "Vishal773",
                        "content": "I think duplicates numbers not counted\\n"
                    },
                    {
                        "username": "ankit528",
                        "content": "subsequence could be in any order\\n"
                    },
                    {
                        "username": "subhadipmandalbagjuri",
                        "content": "i also faced same query, but with another else if statement if got resolved"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "well 0,1,2 there\\'s your sequence"
                    },
                    {
                        "username": "user5582eQ",
                        "content": "So many solutions here claiming to be O(n) are actually either O(n^2) or O(nlogn). How can people here have such poor understanding of time complexity."
                    },
                    {
                        "username": "_Ritik_Singh_",
                        "content": "Bro there is no need to judge anyone on the basis of their solution as long as they are solving and learning so chill out and watch  yourself."
                    },
                    {
                        "username": "RealNameHidden",
                        "content": "Explain it then if you understand it so well, so people can learn"
                    },
                    {
                        "username": "dragosarsene7",
                        "content": "[@carlosfonchii](/carlosfonchii) Learn what exactly. The whole point of the problem is to not sort, otherwise it is trivial. People who use sorting barely learn something, if anything at all, they just call sort and then iterate through an array."
                    },
                    {
                        "username": "dipanshuSaini",
                        "content": "[@Rimberse](/Rimberse)  my nlogn solution is as per leetcode -> 99 % faster. So yes, nlogn solution works here perfectly fine."
                    },
                    {
                        "username": "countdankula",
                        "content": "If you use set it will never reach N^2"
                    },
                    {
                        "username": "carlosfonchii",
                        "content": "There is literally no need to come at people when everyone is here to practice and get BETTER at coding. Check yourself."
                    },
                    {
                        "username": "grave18",
                        "content": "[@Rimberse](/Rimberse) No, i am sorting nums (nlogn) and pass the submission."
                    },
                    {
                        "username": "Rimberse",
                        "content": "I actually came up with O(nlogn) solution, but it didn\\'t work. Got TLE\\nSo anything either than O(n) won\\'t actually be accepted as a solution."
                    },
                    {
                        "username": "Saurabh8720",
                        "content": "Sorry To Interrupt Sir But, The Optimised Solution Dont Have a TC of N^2 or NlogN Sorry to Say But u r Wrong, It is Just O(3N) ~= O(N) "
                    },
                    {
                        "username": "nalinnishant",
                        "content": "agree "
                    },
                    {
                        "username": "Angrydemon",
                        "content": "I think they, first try to solve the given question using brute force without considering the time complexity then they try to optimes it, and if it not works they leave the question for later!"
                    },
                    {
                        "username": "aryansuvarna",
                        "content": "lol so true"
                    },
                    {
                        "username": "user7312022",
                        "content": "You can run your code against these test cases before submisson. Hope it helps!\\n\\n[100,4,200,1,3,2]\\n[0,3,7,2,5,8,4,6,0,1]\\n[1,2,0,1]\\n[0]\\n[0,0]\\n[]"
                    },
                    {
                        "username": "subhadipmandalbagjuri",
                        "content": "[9,1,4,7,3,-1,0,5,8,-1,6]"
                    },
                    {
                        "username": "iChuan",
                        "content": "This is really weried to me. Hard to understand the meaning of this question."
                    },
                    {
                        "username": "tusharmathew",
                        "content": "Its not sub sequence so we dont have to maintain order"
                    },
                    {
                        "username": "amansoni22103",
                        "content": "actually we need to avoid duplicate elements here that\\'s why it is showing 3 instead of 2"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/nA5TRClw96I"
                    },
                    {
                        "username": "nareshvishram",
                        "content": "![image](https://assets.leetcode.com/users/images/c8f1a005-5f10-4957-81be-7fb5c11163dd_1596370783.9489772.png)\\n"
                    },
                    {
                        "username": "addictive_head",
                        "content": "This is O(N) solution actually.\\n1. We are iterating over all elements of hash Set O(N).\\n 2. We then are looking for elements which are starting the subsequence, then we are searching elements set(i)+1, we keep searching till we are finding them. Update the final Count if required.\\nNote that we do not iterate over same numbers again. So O(N).\\n\\ni.e.  O(2N) ~= O(N)"
                    },
                    {
                        "username": "0bro",
                        "content": "At best it O(n log n), n for iterating the entire array, then log n for sub iterating through the hash within the loop that is iterating through the passed array. The search for the O(n) is real lol"
                    },
                    {
                        "username": "ethanultra",
                        "content": "[@SunilKumawat](/SunilKumawat) how? when we iterate through again to find a starting point, we only perform the search if there are elements in the subsequence, so when we encounter another element later that\\'s part of the subsequence, we skip it, so it\\'s not O(N^2) time, it is a multiple of O(N), so O(N)"
                    },
                    {
                        "username": "bhautikkapadiya6",
                        "content": "This algo is work but it has O(n*2) complexity"
                    },
                    {
                        "username": "kamran3210",
                        "content": "[@SunilKumawat](/SunilKumawat) \n\nI may be mistaken but surely its O(N)?\n\nInitialise set with the elements: O(N)\n\nIterate over array and check if it is the start of a subsequence (does not have a predecessor): O(N)\n\nSum of  lengths of all subsequences starting from a number that doesn't have a predecessor = N, therefore countining lengths of all subsequences: O(N)\n\noverall complexity: O(N)"
                    },
                    {
                        "username": "user5062LR",
                        "content": "[@SunilKumawat](/SunilKumawat) its O(3N) ~= O(N)"
                    },
                    {
                        "username": "hardikgupta083",
                        "content": "That is not O(N)"
                    },
                    {
                        "username": "SunilKumawat",
                        "content": "this solution has 0(N^2) time complexity genius"
                    },
                    {
                        "username": "forrrjoyuri",
                        "content": "Just for the sake of comparison, I implemented a naive solution in O(n log n) that sorts the array.\\nMy solution runs in 9ms. I copypasted the best linear solutions from the top posts here and the best i got was 30ms.\\n\\nIn theory, something is wrong here. Why is it the case ?"
                    },
                    {
                        "username": "energyperformer",
                        "content": "One thing u need to remeber is Best time complexity Solution doesn\\'t necessarly mean the fastet solution every instance ,initally for small numbers of n ,even if time complexity is more it can give faster result ,but when we go for large values of n then less time complexity solution offer better time results"
                    },
                    {
                        "username": "treat",
                        "content": "[@DeclanGH](/DeclanGH) Your assumed O(N) might actually be O(N^2)"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "I think leetcode needs to add a very large testcase for this problem to make a nlogn fail"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "[@matthewjiao](/matthewjiao) You are right in theory, but if you could see my two solutions, you would see the comment i made. My first O(n) solution ran 463 ms while the nlogn ran 14ms. its really weird and i was graced to get one testcase wrong, which had 10000 as its answer (which is the largest input size). Not saying you are wrong, but the fact that my result was that way still confuses me. "
                    },
                    {
                        "username": "ixeridium",
                        "content": "E.g. with Python it can happen that using some builtin primitive (or libraries such as numpy) give very significant speedups. A factor of 100 or more is not unusual. In such situations it can happen that a O(n log n) solution is always faster than a O(n) solution for any practical input size. I.e., n log n < 100 * n for all n < exp(100)."
                    },
                    {
                        "username": "wasam1119",
                        "content": "[@matthewjiao](/matthewjiao) Accurate. Observe graphs of y = x and y = x*log(x)"
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "from my experience agr aap ek baar best runtime solution dekh lo ja kr after submission and copy pr aap submit kro then this time code not beats 100 percent submission zyada time lega \\nmay be this is leetcode feature jisse leetcode ke solution ko dekh bo dusro ke solution ko beat na kr paye jin logo ne bina ldekhe kiya hai leetcode best solution \\n"
                    },
                    {
                        "username": "matthewjiao",
                        "content": "Time complexity is not a function of speed, it\\'s a function of growth based on input size. Perhaps with smaller inputs, the linearithmic solution is faster than the linear solution, but as input grows in size, O(n) will eventually out perform O(nlogn)."
                    },
                    {
                        "username": "coolkid0006",
                        "content": "Big O notation drops constants from algorithms\\' complexity because Big O notation is concerned with asymptotic inputs (the input size heads towards infinity). The leetcode test cases aren\\'t large enough to ideally represent the asymptotic complexity, so the constants dropped off when calculating the Big O complexity can have a significant effect on runtime. For example:\\n\\nImagine 2 algorithms for a problem: one has a complexity of n^2 and one has an algorithm of n + 10000. The big O notation drops the constants, so the complexities are O(n^2) and O(n). If you work with small amounts of data the n^2 will have a much smaller runtime, but once a certain point is reached the +10000 won\\'t make much of a difference on the runtime.\\n\\nFor this leetcode problem the naive solution has a smaller runtime for inputs smaller than a certain point. This point is larger than the input sizes of the leetcode solution.\\n\\nIf your solution is at the very bottom of the time and memory leaderboard you might want to make sure it is implemented correctly, but because of the asymptotic nature of Big O notation it isn\\'t always accurate to whether it is the ideal solution."
                    },
                    {
                        "username": "Triquetra",
                        "content": "Try to plot execution time of both solutions against n = 100, 1000, 10000, ... \\u2014 maybe you will see a pattern."
                    },
                    {
                        "username": "kiyosaanb",
                        "content": "In case you are doing something like  nums[i]++ or nums[i]-- , you will encounter problems with this new test case ---> [2147483647,-2147483648]"
                    },
                    {
                        "username": "ShiqiLu77",
                        "content": "-1,000,000,000 <= nums[i] <= 1,000,000,000"
                    },
                    {
                        "username": "yis1178",
                        "content": "I think there is a restriction of the value of nums[i] -- not sure if this is lately added"
                    },
                    {
                        "username": "jasusy",
                        "content": "Is it better to need to clarify duplicate numbers not included in consecutive seq?\\n\\nFor example, if input [0, 0] should output 1, instead of 2, since no duplication counted in result.\\n\\nIf duplicate number considered, we need use HashMap instead of HashSet, and a little different in coding."
                    },
                    {
                        "username": "rubayamim381",
                        "content": "[@shanwu](/shanwu) [1,1,2,3,4] = 5"
                    },
                    {
                        "username": "user6161I",
                        "content": "[@shanwu](/shanwu) 4 ... Because Duplicates are to be treated as single."
                    },
                    {
                        "username": "khritish17",
                        "content": "duplicates should be treated as one\\ne.g : nums = [0,0,1,2,3,4,5,6,7,8] -> output: 9 ([0,1,2,3,4,5,6,7,8])"
                    },
                    {
                        "username": "shanwu",
                        "content": "I agree with you. If duplicate numbers are allowed, then what should be the answer of [100,4,200,1,1,3,2] ? It would be unclear."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/longest-consecutive-sequence/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Sorting\n\n  \n**Approach 3:** HashSet and Intelligent Sequence Building\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "PruthviChippa",
                        "content": "this deserves to be hard for o(n)"
                    },
                    {
                        "username": "Hopity",
                        "content": "for some reason it accepts o(nlogn) that\\'s why it\\'s in medium"
                    }
                ]
            },
            {
                "id": 1566228,
                "content": [
                    {
                        "username": "dghosh133",
                        "content": "How does [1,2,0,1] tc gives output as 3? It should be 2! Someone please clarify.\\n[0,1,1,2] -> has at most 2 consecutive nos."
                    },
                    {
                        "username": "TraySoek",
                        "content": "[@PrashantZuko](/PrashantZuko) yes that\\'s it"
                    },
                    {
                        "username": "dsoum",
                        "content": "[@OmarEffat](/OmarEffat) No highest sequence here is, 0,1,2,3,4,5,6,7,8 hence 9. why 10?"
                    },
                    {
                        "username": "Priyashreyas",
                        "content": "[@ironmonger1](/ironmonger1)  if thats the case, the example given above\\n Input: nums = [0,3,7,2,5,8,4,6,0,1]\\nOutput: 9 then it should be 10 and not 9 right? "
                    },
                    {
                        "username": "Priyashreyas",
                        "content": "[@Ajay_Singh9990](/Ajay_Singh9990) if thats the case, the example given above\\n Input: nums = [0,3,7,2,5,8,4,6,0,1]\\nOutput: 9 then it should be 10 and not 9 right? "
                    },
                    {
                        "username": "Rajiv_123",
                        "content": "[@Dipan Ghosh](/dghosh133) For input [0,1,1,2] Longest consecutive seq would be 0,1,2 hence answer would be 3.  We can ignore the 1 at 2nd index as you are allowed to pick numbers at random indexes such that they are consecutive."
                    },
                    {
                        "username": "OmarEffat",
                        "content": "[@geekgeekvm](/geekgeekvm)  In this case, [0,3,7,2,5,8,4,6,0,1] this should be returning 10 (Example 2)"
                    },
                    {
                        "username": "geekgeekvm",
                        "content": "This was not clear from the question, but the question seems to indicate any sequence of consecutive numbers even if there is a repition in between"
                    },
                    {
                        "username": "sh1kamaruNara",
                        "content": "0,1,2 "
                    },
                    {
                        "username": "cookieslasher",
                        "content": "I had the same question. I thought the count should break off it reaches a duplicate number. I guess this wasn\\'t obvious in the problem description."
                    },
                    {
                        "username": "PrashantZuko",
                        "content": "no,it will be 3 since 0,1,2 are all consecutive."
                    },
                    {
                        "username": "user0241F",
                        "content": "            if inputArr[l] == inputArr[l + 1] then only increase"
                    },
                    {
                        "username": "devanshumasodker357",
                        "content": "bro u forget to add 0 that\\'s why it gives 3"
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "whenever duplicates elements in array but we have to return longest sequence\\nex  (1,1,2,2,3,3.4)    answer is 4\\nbcoz hume duplicate se mtlb nahi hai 1,2,3,4, numbers hai gap 1 ka hai then duplicates ko ignore kr dege "
                    },
                    {
                        "username": "Vishal773",
                        "content": "I think duplicates numbers not counted\\n"
                    },
                    {
                        "username": "ankit528",
                        "content": "subsequence could be in any order\\n"
                    },
                    {
                        "username": "subhadipmandalbagjuri",
                        "content": "i also faced same query, but with another else if statement if got resolved"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "well 0,1,2 there\\'s your sequence"
                    },
                    {
                        "username": "user5582eQ",
                        "content": "So many solutions here claiming to be O(n) are actually either O(n^2) or O(nlogn). How can people here have such poor understanding of time complexity."
                    },
                    {
                        "username": "_Ritik_Singh_",
                        "content": "Bro there is no need to judge anyone on the basis of their solution as long as they are solving and learning so chill out and watch  yourself."
                    },
                    {
                        "username": "RealNameHidden",
                        "content": "Explain it then if you understand it so well, so people can learn"
                    },
                    {
                        "username": "dragosarsene7",
                        "content": "[@carlosfonchii](/carlosfonchii) Learn what exactly. The whole point of the problem is to not sort, otherwise it is trivial. People who use sorting barely learn something, if anything at all, they just call sort and then iterate through an array."
                    },
                    {
                        "username": "dipanshuSaini",
                        "content": "[@Rimberse](/Rimberse)  my nlogn solution is as per leetcode -> 99 % faster. So yes, nlogn solution works here perfectly fine."
                    },
                    {
                        "username": "countdankula",
                        "content": "If you use set it will never reach N^2"
                    },
                    {
                        "username": "carlosfonchii",
                        "content": "There is literally no need to come at people when everyone is here to practice and get BETTER at coding. Check yourself."
                    },
                    {
                        "username": "grave18",
                        "content": "[@Rimberse](/Rimberse) No, i am sorting nums (nlogn) and pass the submission."
                    },
                    {
                        "username": "Rimberse",
                        "content": "I actually came up with O(nlogn) solution, but it didn\\'t work. Got TLE\\nSo anything either than O(n) won\\'t actually be accepted as a solution."
                    },
                    {
                        "username": "Saurabh8720",
                        "content": "Sorry To Interrupt Sir But, The Optimised Solution Dont Have a TC of N^2 or NlogN Sorry to Say But u r Wrong, It is Just O(3N) ~= O(N) "
                    },
                    {
                        "username": "nalinnishant",
                        "content": "agree "
                    },
                    {
                        "username": "Angrydemon",
                        "content": "I think they, first try to solve the given question using brute force without considering the time complexity then they try to optimes it, and if it not works they leave the question for later!"
                    },
                    {
                        "username": "aryansuvarna",
                        "content": "lol so true"
                    },
                    {
                        "username": "user7312022",
                        "content": "You can run your code against these test cases before submisson. Hope it helps!\\n\\n[100,4,200,1,3,2]\\n[0,3,7,2,5,8,4,6,0,1]\\n[1,2,0,1]\\n[0]\\n[0,0]\\n[]"
                    },
                    {
                        "username": "subhadipmandalbagjuri",
                        "content": "[9,1,4,7,3,-1,0,5,8,-1,6]"
                    },
                    {
                        "username": "iChuan",
                        "content": "This is really weried to me. Hard to understand the meaning of this question."
                    },
                    {
                        "username": "tusharmathew",
                        "content": "Its not sub sequence so we dont have to maintain order"
                    },
                    {
                        "username": "amansoni22103",
                        "content": "actually we need to avoid duplicate elements here that\\'s why it is showing 3 instead of 2"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/nA5TRClw96I"
                    },
                    {
                        "username": "nareshvishram",
                        "content": "![image](https://assets.leetcode.com/users/images/c8f1a005-5f10-4957-81be-7fb5c11163dd_1596370783.9489772.png)\\n"
                    },
                    {
                        "username": "addictive_head",
                        "content": "This is O(N) solution actually.\\n1. We are iterating over all elements of hash Set O(N).\\n 2. We then are looking for elements which are starting the subsequence, then we are searching elements set(i)+1, we keep searching till we are finding them. Update the final Count if required.\\nNote that we do not iterate over same numbers again. So O(N).\\n\\ni.e.  O(2N) ~= O(N)"
                    },
                    {
                        "username": "0bro",
                        "content": "At best it O(n log n), n for iterating the entire array, then log n for sub iterating through the hash within the loop that is iterating through the passed array. The search for the O(n) is real lol"
                    },
                    {
                        "username": "ethanultra",
                        "content": "[@SunilKumawat](/SunilKumawat) how? when we iterate through again to find a starting point, we only perform the search if there are elements in the subsequence, so when we encounter another element later that\\'s part of the subsequence, we skip it, so it\\'s not O(N^2) time, it is a multiple of O(N), so O(N)"
                    },
                    {
                        "username": "bhautikkapadiya6",
                        "content": "This algo is work but it has O(n*2) complexity"
                    },
                    {
                        "username": "kamran3210",
                        "content": "[@SunilKumawat](/SunilKumawat) \n\nI may be mistaken but surely its O(N)?\n\nInitialise set with the elements: O(N)\n\nIterate over array and check if it is the start of a subsequence (does not have a predecessor): O(N)\n\nSum of  lengths of all subsequences starting from a number that doesn't have a predecessor = N, therefore countining lengths of all subsequences: O(N)\n\noverall complexity: O(N)"
                    },
                    {
                        "username": "user5062LR",
                        "content": "[@SunilKumawat](/SunilKumawat) its O(3N) ~= O(N)"
                    },
                    {
                        "username": "hardikgupta083",
                        "content": "That is not O(N)"
                    },
                    {
                        "username": "SunilKumawat",
                        "content": "this solution has 0(N^2) time complexity genius"
                    },
                    {
                        "username": "forrrjoyuri",
                        "content": "Just for the sake of comparison, I implemented a naive solution in O(n log n) that sorts the array.\\nMy solution runs in 9ms. I copypasted the best linear solutions from the top posts here and the best i got was 30ms.\\n\\nIn theory, something is wrong here. Why is it the case ?"
                    },
                    {
                        "username": "energyperformer",
                        "content": "One thing u need to remeber is Best time complexity Solution doesn\\'t necessarly mean the fastet solution every instance ,initally for small numbers of n ,even if time complexity is more it can give faster result ,but when we go for large values of n then less time complexity solution offer better time results"
                    },
                    {
                        "username": "treat",
                        "content": "[@DeclanGH](/DeclanGH) Your assumed O(N) might actually be O(N^2)"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "I think leetcode needs to add a very large testcase for this problem to make a nlogn fail"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "[@matthewjiao](/matthewjiao) You are right in theory, but if you could see my two solutions, you would see the comment i made. My first O(n) solution ran 463 ms while the nlogn ran 14ms. its really weird and i was graced to get one testcase wrong, which had 10000 as its answer (which is the largest input size). Not saying you are wrong, but the fact that my result was that way still confuses me. "
                    },
                    {
                        "username": "ixeridium",
                        "content": "E.g. with Python it can happen that using some builtin primitive (or libraries such as numpy) give very significant speedups. A factor of 100 or more is not unusual. In such situations it can happen that a O(n log n) solution is always faster than a O(n) solution for any practical input size. I.e., n log n < 100 * n for all n < exp(100)."
                    },
                    {
                        "username": "wasam1119",
                        "content": "[@matthewjiao](/matthewjiao) Accurate. Observe graphs of y = x and y = x*log(x)"
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "from my experience agr aap ek baar best runtime solution dekh lo ja kr after submission and copy pr aap submit kro then this time code not beats 100 percent submission zyada time lega \\nmay be this is leetcode feature jisse leetcode ke solution ko dekh bo dusro ke solution ko beat na kr paye jin logo ne bina ldekhe kiya hai leetcode best solution \\n"
                    },
                    {
                        "username": "matthewjiao",
                        "content": "Time complexity is not a function of speed, it\\'s a function of growth based on input size. Perhaps with smaller inputs, the linearithmic solution is faster than the linear solution, but as input grows in size, O(n) will eventually out perform O(nlogn)."
                    },
                    {
                        "username": "coolkid0006",
                        "content": "Big O notation drops constants from algorithms\\' complexity because Big O notation is concerned with asymptotic inputs (the input size heads towards infinity). The leetcode test cases aren\\'t large enough to ideally represent the asymptotic complexity, so the constants dropped off when calculating the Big O complexity can have a significant effect on runtime. For example:\\n\\nImagine 2 algorithms for a problem: one has a complexity of n^2 and one has an algorithm of n + 10000. The big O notation drops the constants, so the complexities are O(n^2) and O(n). If you work with small amounts of data the n^2 will have a much smaller runtime, but once a certain point is reached the +10000 won\\'t make much of a difference on the runtime.\\n\\nFor this leetcode problem the naive solution has a smaller runtime for inputs smaller than a certain point. This point is larger than the input sizes of the leetcode solution.\\n\\nIf your solution is at the very bottom of the time and memory leaderboard you might want to make sure it is implemented correctly, but because of the asymptotic nature of Big O notation it isn\\'t always accurate to whether it is the ideal solution."
                    },
                    {
                        "username": "Triquetra",
                        "content": "Try to plot execution time of both solutions against n = 100, 1000, 10000, ... \\u2014 maybe you will see a pattern."
                    },
                    {
                        "username": "kiyosaanb",
                        "content": "In case you are doing something like  nums[i]++ or nums[i]-- , you will encounter problems with this new test case ---> [2147483647,-2147483648]"
                    },
                    {
                        "username": "ShiqiLu77",
                        "content": "-1,000,000,000 <= nums[i] <= 1,000,000,000"
                    },
                    {
                        "username": "yis1178",
                        "content": "I think there is a restriction of the value of nums[i] -- not sure if this is lately added"
                    },
                    {
                        "username": "jasusy",
                        "content": "Is it better to need to clarify duplicate numbers not included in consecutive seq?\\n\\nFor example, if input [0, 0] should output 1, instead of 2, since no duplication counted in result.\\n\\nIf duplicate number considered, we need use HashMap instead of HashSet, and a little different in coding."
                    },
                    {
                        "username": "rubayamim381",
                        "content": "[@shanwu](/shanwu) [1,1,2,3,4] = 5"
                    },
                    {
                        "username": "user6161I",
                        "content": "[@shanwu](/shanwu) 4 ... Because Duplicates are to be treated as single."
                    },
                    {
                        "username": "khritish17",
                        "content": "duplicates should be treated as one\\ne.g : nums = [0,0,1,2,3,4,5,6,7,8] -> output: 9 ([0,1,2,3,4,5,6,7,8])"
                    },
                    {
                        "username": "shanwu",
                        "content": "I agree with you. If duplicate numbers are allowed, then what should be the answer of [100,4,200,1,1,3,2] ? It would be unclear."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/longest-consecutive-sequence/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Sorting\n\n  \n**Approach 3:** HashSet and Intelligent Sequence Building\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "PruthviChippa",
                        "content": "this deserves to be hard for o(n)"
                    },
                    {
                        "username": "Hopity",
                        "content": "for some reason it accepts o(nlogn) that\\'s why it\\'s in medium"
                    }
                ]
            },
            {
                "id": 1760209,
                "content": [
                    {
                        "username": "dghosh133",
                        "content": "How does [1,2,0,1] tc gives output as 3? It should be 2! Someone please clarify.\\n[0,1,1,2] -> has at most 2 consecutive nos."
                    },
                    {
                        "username": "TraySoek",
                        "content": "[@PrashantZuko](/PrashantZuko) yes that\\'s it"
                    },
                    {
                        "username": "dsoum",
                        "content": "[@OmarEffat](/OmarEffat) No highest sequence here is, 0,1,2,3,4,5,6,7,8 hence 9. why 10?"
                    },
                    {
                        "username": "Priyashreyas",
                        "content": "[@ironmonger1](/ironmonger1)  if thats the case, the example given above\\n Input: nums = [0,3,7,2,5,8,4,6,0,1]\\nOutput: 9 then it should be 10 and not 9 right? "
                    },
                    {
                        "username": "Priyashreyas",
                        "content": "[@Ajay_Singh9990](/Ajay_Singh9990) if thats the case, the example given above\\n Input: nums = [0,3,7,2,5,8,4,6,0,1]\\nOutput: 9 then it should be 10 and not 9 right? "
                    },
                    {
                        "username": "Rajiv_123",
                        "content": "[@Dipan Ghosh](/dghosh133) For input [0,1,1,2] Longest consecutive seq would be 0,1,2 hence answer would be 3.  We can ignore the 1 at 2nd index as you are allowed to pick numbers at random indexes such that they are consecutive."
                    },
                    {
                        "username": "OmarEffat",
                        "content": "[@geekgeekvm](/geekgeekvm)  In this case, [0,3,7,2,5,8,4,6,0,1] this should be returning 10 (Example 2)"
                    },
                    {
                        "username": "geekgeekvm",
                        "content": "This was not clear from the question, but the question seems to indicate any sequence of consecutive numbers even if there is a repition in between"
                    },
                    {
                        "username": "sh1kamaruNara",
                        "content": "0,1,2 "
                    },
                    {
                        "username": "cookieslasher",
                        "content": "I had the same question. I thought the count should break off it reaches a duplicate number. I guess this wasn\\'t obvious in the problem description."
                    },
                    {
                        "username": "PrashantZuko",
                        "content": "no,it will be 3 since 0,1,2 are all consecutive."
                    },
                    {
                        "username": "user0241F",
                        "content": "            if inputArr[l] == inputArr[l + 1] then only increase"
                    },
                    {
                        "username": "devanshumasodker357",
                        "content": "bro u forget to add 0 that\\'s why it gives 3"
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "whenever duplicates elements in array but we have to return longest sequence\\nex  (1,1,2,2,3,3.4)    answer is 4\\nbcoz hume duplicate se mtlb nahi hai 1,2,3,4, numbers hai gap 1 ka hai then duplicates ko ignore kr dege "
                    },
                    {
                        "username": "Vishal773",
                        "content": "I think duplicates numbers not counted\\n"
                    },
                    {
                        "username": "ankit528",
                        "content": "subsequence could be in any order\\n"
                    },
                    {
                        "username": "subhadipmandalbagjuri",
                        "content": "i also faced same query, but with another else if statement if got resolved"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "well 0,1,2 there\\'s your sequence"
                    },
                    {
                        "username": "user5582eQ",
                        "content": "So many solutions here claiming to be O(n) are actually either O(n^2) or O(nlogn). How can people here have such poor understanding of time complexity."
                    },
                    {
                        "username": "_Ritik_Singh_",
                        "content": "Bro there is no need to judge anyone on the basis of their solution as long as they are solving and learning so chill out and watch  yourself."
                    },
                    {
                        "username": "RealNameHidden",
                        "content": "Explain it then if you understand it so well, so people can learn"
                    },
                    {
                        "username": "dragosarsene7",
                        "content": "[@carlosfonchii](/carlosfonchii) Learn what exactly. The whole point of the problem is to not sort, otherwise it is trivial. People who use sorting barely learn something, if anything at all, they just call sort and then iterate through an array."
                    },
                    {
                        "username": "dipanshuSaini",
                        "content": "[@Rimberse](/Rimberse)  my nlogn solution is as per leetcode -> 99 % faster. So yes, nlogn solution works here perfectly fine."
                    },
                    {
                        "username": "countdankula",
                        "content": "If you use set it will never reach N^2"
                    },
                    {
                        "username": "carlosfonchii",
                        "content": "There is literally no need to come at people when everyone is here to practice and get BETTER at coding. Check yourself."
                    },
                    {
                        "username": "grave18",
                        "content": "[@Rimberse](/Rimberse) No, i am sorting nums (nlogn) and pass the submission."
                    },
                    {
                        "username": "Rimberse",
                        "content": "I actually came up with O(nlogn) solution, but it didn\\'t work. Got TLE\\nSo anything either than O(n) won\\'t actually be accepted as a solution."
                    },
                    {
                        "username": "Saurabh8720",
                        "content": "Sorry To Interrupt Sir But, The Optimised Solution Dont Have a TC of N^2 or NlogN Sorry to Say But u r Wrong, It is Just O(3N) ~= O(N) "
                    },
                    {
                        "username": "nalinnishant",
                        "content": "agree "
                    },
                    {
                        "username": "Angrydemon",
                        "content": "I think they, first try to solve the given question using brute force without considering the time complexity then they try to optimes it, and if it not works they leave the question for later!"
                    },
                    {
                        "username": "aryansuvarna",
                        "content": "lol so true"
                    },
                    {
                        "username": "user7312022",
                        "content": "You can run your code against these test cases before submisson. Hope it helps!\\n\\n[100,4,200,1,3,2]\\n[0,3,7,2,5,8,4,6,0,1]\\n[1,2,0,1]\\n[0]\\n[0,0]\\n[]"
                    },
                    {
                        "username": "subhadipmandalbagjuri",
                        "content": "[9,1,4,7,3,-1,0,5,8,-1,6]"
                    },
                    {
                        "username": "iChuan",
                        "content": "This is really weried to me. Hard to understand the meaning of this question."
                    },
                    {
                        "username": "tusharmathew",
                        "content": "Its not sub sequence so we dont have to maintain order"
                    },
                    {
                        "username": "amansoni22103",
                        "content": "actually we need to avoid duplicate elements here that\\'s why it is showing 3 instead of 2"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/nA5TRClw96I"
                    },
                    {
                        "username": "nareshvishram",
                        "content": "![image](https://assets.leetcode.com/users/images/c8f1a005-5f10-4957-81be-7fb5c11163dd_1596370783.9489772.png)\\n"
                    },
                    {
                        "username": "addictive_head",
                        "content": "This is O(N) solution actually.\\n1. We are iterating over all elements of hash Set O(N).\\n 2. We then are looking for elements which are starting the subsequence, then we are searching elements set(i)+1, we keep searching till we are finding them. Update the final Count if required.\\nNote that we do not iterate over same numbers again. So O(N).\\n\\ni.e.  O(2N) ~= O(N)"
                    },
                    {
                        "username": "0bro",
                        "content": "At best it O(n log n), n for iterating the entire array, then log n for sub iterating through the hash within the loop that is iterating through the passed array. The search for the O(n) is real lol"
                    },
                    {
                        "username": "ethanultra",
                        "content": "[@SunilKumawat](/SunilKumawat) how? when we iterate through again to find a starting point, we only perform the search if there are elements in the subsequence, so when we encounter another element later that\\'s part of the subsequence, we skip it, so it\\'s not O(N^2) time, it is a multiple of O(N), so O(N)"
                    },
                    {
                        "username": "bhautikkapadiya6",
                        "content": "This algo is work but it has O(n*2) complexity"
                    },
                    {
                        "username": "kamran3210",
                        "content": "[@SunilKumawat](/SunilKumawat) \n\nI may be mistaken but surely its O(N)?\n\nInitialise set with the elements: O(N)\n\nIterate over array and check if it is the start of a subsequence (does not have a predecessor): O(N)\n\nSum of  lengths of all subsequences starting from a number that doesn't have a predecessor = N, therefore countining lengths of all subsequences: O(N)\n\noverall complexity: O(N)"
                    },
                    {
                        "username": "user5062LR",
                        "content": "[@SunilKumawat](/SunilKumawat) its O(3N) ~= O(N)"
                    },
                    {
                        "username": "hardikgupta083",
                        "content": "That is not O(N)"
                    },
                    {
                        "username": "SunilKumawat",
                        "content": "this solution has 0(N^2) time complexity genius"
                    },
                    {
                        "username": "forrrjoyuri",
                        "content": "Just for the sake of comparison, I implemented a naive solution in O(n log n) that sorts the array.\\nMy solution runs in 9ms. I copypasted the best linear solutions from the top posts here and the best i got was 30ms.\\n\\nIn theory, something is wrong here. Why is it the case ?"
                    },
                    {
                        "username": "energyperformer",
                        "content": "One thing u need to remeber is Best time complexity Solution doesn\\'t necessarly mean the fastet solution every instance ,initally for small numbers of n ,even if time complexity is more it can give faster result ,but when we go for large values of n then less time complexity solution offer better time results"
                    },
                    {
                        "username": "treat",
                        "content": "[@DeclanGH](/DeclanGH) Your assumed O(N) might actually be O(N^2)"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "I think leetcode needs to add a very large testcase for this problem to make a nlogn fail"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "[@matthewjiao](/matthewjiao) You are right in theory, but if you could see my two solutions, you would see the comment i made. My first O(n) solution ran 463 ms while the nlogn ran 14ms. its really weird and i was graced to get one testcase wrong, which had 10000 as its answer (which is the largest input size). Not saying you are wrong, but the fact that my result was that way still confuses me. "
                    },
                    {
                        "username": "ixeridium",
                        "content": "E.g. with Python it can happen that using some builtin primitive (or libraries such as numpy) give very significant speedups. A factor of 100 or more is not unusual. In such situations it can happen that a O(n log n) solution is always faster than a O(n) solution for any practical input size. I.e., n log n < 100 * n for all n < exp(100)."
                    },
                    {
                        "username": "wasam1119",
                        "content": "[@matthewjiao](/matthewjiao) Accurate. Observe graphs of y = x and y = x*log(x)"
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "from my experience agr aap ek baar best runtime solution dekh lo ja kr after submission and copy pr aap submit kro then this time code not beats 100 percent submission zyada time lega \\nmay be this is leetcode feature jisse leetcode ke solution ko dekh bo dusro ke solution ko beat na kr paye jin logo ne bina ldekhe kiya hai leetcode best solution \\n"
                    },
                    {
                        "username": "matthewjiao",
                        "content": "Time complexity is not a function of speed, it\\'s a function of growth based on input size. Perhaps with smaller inputs, the linearithmic solution is faster than the linear solution, but as input grows in size, O(n) will eventually out perform O(nlogn)."
                    },
                    {
                        "username": "coolkid0006",
                        "content": "Big O notation drops constants from algorithms\\' complexity because Big O notation is concerned with asymptotic inputs (the input size heads towards infinity). The leetcode test cases aren\\'t large enough to ideally represent the asymptotic complexity, so the constants dropped off when calculating the Big O complexity can have a significant effect on runtime. For example:\\n\\nImagine 2 algorithms for a problem: one has a complexity of n^2 and one has an algorithm of n + 10000. The big O notation drops the constants, so the complexities are O(n^2) and O(n). If you work with small amounts of data the n^2 will have a much smaller runtime, but once a certain point is reached the +10000 won\\'t make much of a difference on the runtime.\\n\\nFor this leetcode problem the naive solution has a smaller runtime for inputs smaller than a certain point. This point is larger than the input sizes of the leetcode solution.\\n\\nIf your solution is at the very bottom of the time and memory leaderboard you might want to make sure it is implemented correctly, but because of the asymptotic nature of Big O notation it isn\\'t always accurate to whether it is the ideal solution."
                    },
                    {
                        "username": "Triquetra",
                        "content": "Try to plot execution time of both solutions against n = 100, 1000, 10000, ... \\u2014 maybe you will see a pattern."
                    },
                    {
                        "username": "kiyosaanb",
                        "content": "In case you are doing something like  nums[i]++ or nums[i]-- , you will encounter problems with this new test case ---> [2147483647,-2147483648]"
                    },
                    {
                        "username": "ShiqiLu77",
                        "content": "-1,000,000,000 <= nums[i] <= 1,000,000,000"
                    },
                    {
                        "username": "yis1178",
                        "content": "I think there is a restriction of the value of nums[i] -- not sure if this is lately added"
                    },
                    {
                        "username": "jasusy",
                        "content": "Is it better to need to clarify duplicate numbers not included in consecutive seq?\\n\\nFor example, if input [0, 0] should output 1, instead of 2, since no duplication counted in result.\\n\\nIf duplicate number considered, we need use HashMap instead of HashSet, and a little different in coding."
                    },
                    {
                        "username": "rubayamim381",
                        "content": "[@shanwu](/shanwu) [1,1,2,3,4] = 5"
                    },
                    {
                        "username": "user6161I",
                        "content": "[@shanwu](/shanwu) 4 ... Because Duplicates are to be treated as single."
                    },
                    {
                        "username": "khritish17",
                        "content": "duplicates should be treated as one\\ne.g : nums = [0,0,1,2,3,4,5,6,7,8] -> output: 9 ([0,1,2,3,4,5,6,7,8])"
                    },
                    {
                        "username": "shanwu",
                        "content": "I agree with you. If duplicate numbers are allowed, then what should be the answer of [100,4,200,1,1,3,2] ? It would be unclear."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/longest-consecutive-sequence/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Sorting\n\n  \n**Approach 3:** HashSet and Intelligent Sequence Building\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "PruthviChippa",
                        "content": "this deserves to be hard for o(n)"
                    },
                    {
                        "username": "Hopity",
                        "content": "for some reason it accepts o(nlogn) that\\'s why it\\'s in medium"
                    }
                ]
            },
            {
                "id": 1570293,
                "content": [
                    {
                        "username": "dghosh133",
                        "content": "How does [1,2,0,1] tc gives output as 3? It should be 2! Someone please clarify.\\n[0,1,1,2] -> has at most 2 consecutive nos."
                    },
                    {
                        "username": "TraySoek",
                        "content": "[@PrashantZuko](/PrashantZuko) yes that\\'s it"
                    },
                    {
                        "username": "dsoum",
                        "content": "[@OmarEffat](/OmarEffat) No highest sequence here is, 0,1,2,3,4,5,6,7,8 hence 9. why 10?"
                    },
                    {
                        "username": "Priyashreyas",
                        "content": "[@ironmonger1](/ironmonger1)  if thats the case, the example given above\\n Input: nums = [0,3,7,2,5,8,4,6,0,1]\\nOutput: 9 then it should be 10 and not 9 right? "
                    },
                    {
                        "username": "Priyashreyas",
                        "content": "[@Ajay_Singh9990](/Ajay_Singh9990) if thats the case, the example given above\\n Input: nums = [0,3,7,2,5,8,4,6,0,1]\\nOutput: 9 then it should be 10 and not 9 right? "
                    },
                    {
                        "username": "Rajiv_123",
                        "content": "[@Dipan Ghosh](/dghosh133) For input [0,1,1,2] Longest consecutive seq would be 0,1,2 hence answer would be 3.  We can ignore the 1 at 2nd index as you are allowed to pick numbers at random indexes such that they are consecutive."
                    },
                    {
                        "username": "OmarEffat",
                        "content": "[@geekgeekvm](/geekgeekvm)  In this case, [0,3,7,2,5,8,4,6,0,1] this should be returning 10 (Example 2)"
                    },
                    {
                        "username": "geekgeekvm",
                        "content": "This was not clear from the question, but the question seems to indicate any sequence of consecutive numbers even if there is a repition in between"
                    },
                    {
                        "username": "sh1kamaruNara",
                        "content": "0,1,2 "
                    },
                    {
                        "username": "cookieslasher",
                        "content": "I had the same question. I thought the count should break off it reaches a duplicate number. I guess this wasn\\'t obvious in the problem description."
                    },
                    {
                        "username": "PrashantZuko",
                        "content": "no,it will be 3 since 0,1,2 are all consecutive."
                    },
                    {
                        "username": "user0241F",
                        "content": "            if inputArr[l] == inputArr[l + 1] then only increase"
                    },
                    {
                        "username": "devanshumasodker357",
                        "content": "bro u forget to add 0 that\\'s why it gives 3"
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "whenever duplicates elements in array but we have to return longest sequence\\nex  (1,1,2,2,3,3.4)    answer is 4\\nbcoz hume duplicate se mtlb nahi hai 1,2,3,4, numbers hai gap 1 ka hai then duplicates ko ignore kr dege "
                    },
                    {
                        "username": "Vishal773",
                        "content": "I think duplicates numbers not counted\\n"
                    },
                    {
                        "username": "ankit528",
                        "content": "subsequence could be in any order\\n"
                    },
                    {
                        "username": "subhadipmandalbagjuri",
                        "content": "i also faced same query, but with another else if statement if got resolved"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "well 0,1,2 there\\'s your sequence"
                    },
                    {
                        "username": "user5582eQ",
                        "content": "So many solutions here claiming to be O(n) are actually either O(n^2) or O(nlogn). How can people here have such poor understanding of time complexity."
                    },
                    {
                        "username": "_Ritik_Singh_",
                        "content": "Bro there is no need to judge anyone on the basis of their solution as long as they are solving and learning so chill out and watch  yourself."
                    },
                    {
                        "username": "RealNameHidden",
                        "content": "Explain it then if you understand it so well, so people can learn"
                    },
                    {
                        "username": "dragosarsene7",
                        "content": "[@carlosfonchii](/carlosfonchii) Learn what exactly. The whole point of the problem is to not sort, otherwise it is trivial. People who use sorting barely learn something, if anything at all, they just call sort and then iterate through an array."
                    },
                    {
                        "username": "dipanshuSaini",
                        "content": "[@Rimberse](/Rimberse)  my nlogn solution is as per leetcode -> 99 % faster. So yes, nlogn solution works here perfectly fine."
                    },
                    {
                        "username": "countdankula",
                        "content": "If you use set it will never reach N^2"
                    },
                    {
                        "username": "carlosfonchii",
                        "content": "There is literally no need to come at people when everyone is here to practice and get BETTER at coding. Check yourself."
                    },
                    {
                        "username": "grave18",
                        "content": "[@Rimberse](/Rimberse) No, i am sorting nums (nlogn) and pass the submission."
                    },
                    {
                        "username": "Rimberse",
                        "content": "I actually came up with O(nlogn) solution, but it didn\\'t work. Got TLE\\nSo anything either than O(n) won\\'t actually be accepted as a solution."
                    },
                    {
                        "username": "Saurabh8720",
                        "content": "Sorry To Interrupt Sir But, The Optimised Solution Dont Have a TC of N^2 or NlogN Sorry to Say But u r Wrong, It is Just O(3N) ~= O(N) "
                    },
                    {
                        "username": "nalinnishant",
                        "content": "agree "
                    },
                    {
                        "username": "Angrydemon",
                        "content": "I think they, first try to solve the given question using brute force without considering the time complexity then they try to optimes it, and if it not works they leave the question for later!"
                    },
                    {
                        "username": "aryansuvarna",
                        "content": "lol so true"
                    },
                    {
                        "username": "user7312022",
                        "content": "You can run your code against these test cases before submisson. Hope it helps!\\n\\n[100,4,200,1,3,2]\\n[0,3,7,2,5,8,4,6,0,1]\\n[1,2,0,1]\\n[0]\\n[0,0]\\n[]"
                    },
                    {
                        "username": "subhadipmandalbagjuri",
                        "content": "[9,1,4,7,3,-1,0,5,8,-1,6]"
                    },
                    {
                        "username": "iChuan",
                        "content": "This is really weried to me. Hard to understand the meaning of this question."
                    },
                    {
                        "username": "tusharmathew",
                        "content": "Its not sub sequence so we dont have to maintain order"
                    },
                    {
                        "username": "amansoni22103",
                        "content": "actually we need to avoid duplicate elements here that\\'s why it is showing 3 instead of 2"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/nA5TRClw96I"
                    },
                    {
                        "username": "nareshvishram",
                        "content": "![image](https://assets.leetcode.com/users/images/c8f1a005-5f10-4957-81be-7fb5c11163dd_1596370783.9489772.png)\\n"
                    },
                    {
                        "username": "addictive_head",
                        "content": "This is O(N) solution actually.\\n1. We are iterating over all elements of hash Set O(N).\\n 2. We then are looking for elements which are starting the subsequence, then we are searching elements set(i)+1, we keep searching till we are finding them. Update the final Count if required.\\nNote that we do not iterate over same numbers again. So O(N).\\n\\ni.e.  O(2N) ~= O(N)"
                    },
                    {
                        "username": "0bro",
                        "content": "At best it O(n log n), n for iterating the entire array, then log n for sub iterating through the hash within the loop that is iterating through the passed array. The search for the O(n) is real lol"
                    },
                    {
                        "username": "ethanultra",
                        "content": "[@SunilKumawat](/SunilKumawat) how? when we iterate through again to find a starting point, we only perform the search if there are elements in the subsequence, so when we encounter another element later that\\'s part of the subsequence, we skip it, so it\\'s not O(N^2) time, it is a multiple of O(N), so O(N)"
                    },
                    {
                        "username": "bhautikkapadiya6",
                        "content": "This algo is work but it has O(n*2) complexity"
                    },
                    {
                        "username": "kamran3210",
                        "content": "[@SunilKumawat](/SunilKumawat) \n\nI may be mistaken but surely its O(N)?\n\nInitialise set with the elements: O(N)\n\nIterate over array and check if it is the start of a subsequence (does not have a predecessor): O(N)\n\nSum of  lengths of all subsequences starting from a number that doesn't have a predecessor = N, therefore countining lengths of all subsequences: O(N)\n\noverall complexity: O(N)"
                    },
                    {
                        "username": "user5062LR",
                        "content": "[@SunilKumawat](/SunilKumawat) its O(3N) ~= O(N)"
                    },
                    {
                        "username": "hardikgupta083",
                        "content": "That is not O(N)"
                    },
                    {
                        "username": "SunilKumawat",
                        "content": "this solution has 0(N^2) time complexity genius"
                    },
                    {
                        "username": "forrrjoyuri",
                        "content": "Just for the sake of comparison, I implemented a naive solution in O(n log n) that sorts the array.\\nMy solution runs in 9ms. I copypasted the best linear solutions from the top posts here and the best i got was 30ms.\\n\\nIn theory, something is wrong here. Why is it the case ?"
                    },
                    {
                        "username": "energyperformer",
                        "content": "One thing u need to remeber is Best time complexity Solution doesn\\'t necessarly mean the fastet solution every instance ,initally for small numbers of n ,even if time complexity is more it can give faster result ,but when we go for large values of n then less time complexity solution offer better time results"
                    },
                    {
                        "username": "treat",
                        "content": "[@DeclanGH](/DeclanGH) Your assumed O(N) might actually be O(N^2)"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "I think leetcode needs to add a very large testcase for this problem to make a nlogn fail"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "[@matthewjiao](/matthewjiao) You are right in theory, but if you could see my two solutions, you would see the comment i made. My first O(n) solution ran 463 ms while the nlogn ran 14ms. its really weird and i was graced to get one testcase wrong, which had 10000 as its answer (which is the largest input size). Not saying you are wrong, but the fact that my result was that way still confuses me. "
                    },
                    {
                        "username": "ixeridium",
                        "content": "E.g. with Python it can happen that using some builtin primitive (or libraries such as numpy) give very significant speedups. A factor of 100 or more is not unusual. In such situations it can happen that a O(n log n) solution is always faster than a O(n) solution for any practical input size. I.e., n log n < 100 * n for all n < exp(100)."
                    },
                    {
                        "username": "wasam1119",
                        "content": "[@matthewjiao](/matthewjiao) Accurate. Observe graphs of y = x and y = x*log(x)"
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "from my experience agr aap ek baar best runtime solution dekh lo ja kr after submission and copy pr aap submit kro then this time code not beats 100 percent submission zyada time lega \\nmay be this is leetcode feature jisse leetcode ke solution ko dekh bo dusro ke solution ko beat na kr paye jin logo ne bina ldekhe kiya hai leetcode best solution \\n"
                    },
                    {
                        "username": "matthewjiao",
                        "content": "Time complexity is not a function of speed, it\\'s a function of growth based on input size. Perhaps with smaller inputs, the linearithmic solution is faster than the linear solution, but as input grows in size, O(n) will eventually out perform O(nlogn)."
                    },
                    {
                        "username": "coolkid0006",
                        "content": "Big O notation drops constants from algorithms\\' complexity because Big O notation is concerned with asymptotic inputs (the input size heads towards infinity). The leetcode test cases aren\\'t large enough to ideally represent the asymptotic complexity, so the constants dropped off when calculating the Big O complexity can have a significant effect on runtime. For example:\\n\\nImagine 2 algorithms for a problem: one has a complexity of n^2 and one has an algorithm of n + 10000. The big O notation drops the constants, so the complexities are O(n^2) and O(n). If you work with small amounts of data the n^2 will have a much smaller runtime, but once a certain point is reached the +10000 won\\'t make much of a difference on the runtime.\\n\\nFor this leetcode problem the naive solution has a smaller runtime for inputs smaller than a certain point. This point is larger than the input sizes of the leetcode solution.\\n\\nIf your solution is at the very bottom of the time and memory leaderboard you might want to make sure it is implemented correctly, but because of the asymptotic nature of Big O notation it isn\\'t always accurate to whether it is the ideal solution."
                    },
                    {
                        "username": "Triquetra",
                        "content": "Try to plot execution time of both solutions against n = 100, 1000, 10000, ... \\u2014 maybe you will see a pattern."
                    },
                    {
                        "username": "kiyosaanb",
                        "content": "In case you are doing something like  nums[i]++ or nums[i]-- , you will encounter problems with this new test case ---> [2147483647,-2147483648]"
                    },
                    {
                        "username": "ShiqiLu77",
                        "content": "-1,000,000,000 <= nums[i] <= 1,000,000,000"
                    },
                    {
                        "username": "yis1178",
                        "content": "I think there is a restriction of the value of nums[i] -- not sure if this is lately added"
                    },
                    {
                        "username": "jasusy",
                        "content": "Is it better to need to clarify duplicate numbers not included in consecutive seq?\\n\\nFor example, if input [0, 0] should output 1, instead of 2, since no duplication counted in result.\\n\\nIf duplicate number considered, we need use HashMap instead of HashSet, and a little different in coding."
                    },
                    {
                        "username": "rubayamim381",
                        "content": "[@shanwu](/shanwu) [1,1,2,3,4] = 5"
                    },
                    {
                        "username": "user6161I",
                        "content": "[@shanwu](/shanwu) 4 ... Because Duplicates are to be treated as single."
                    },
                    {
                        "username": "khritish17",
                        "content": "duplicates should be treated as one\\ne.g : nums = [0,0,1,2,3,4,5,6,7,8] -> output: 9 ([0,1,2,3,4,5,6,7,8])"
                    },
                    {
                        "username": "shanwu",
                        "content": "I agree with you. If duplicate numbers are allowed, then what should be the answer of [100,4,200,1,1,3,2] ? It would be unclear."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/longest-consecutive-sequence/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Sorting\n\n  \n**Approach 3:** HashSet and Intelligent Sequence Building\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "PruthviChippa",
                        "content": "this deserves to be hard for o(n)"
                    },
                    {
                        "username": "Hopity",
                        "content": "for some reason it accepts o(nlogn) that\\'s why it\\'s in medium"
                    }
                ]
            },
            {
                "id": 1576092,
                "content": [
                    {
                        "username": "dghosh133",
                        "content": "How does [1,2,0,1] tc gives output as 3? It should be 2! Someone please clarify.\\n[0,1,1,2] -> has at most 2 consecutive nos."
                    },
                    {
                        "username": "TraySoek",
                        "content": "[@PrashantZuko](/PrashantZuko) yes that\\'s it"
                    },
                    {
                        "username": "dsoum",
                        "content": "[@OmarEffat](/OmarEffat) No highest sequence here is, 0,1,2,3,4,5,6,7,8 hence 9. why 10?"
                    },
                    {
                        "username": "Priyashreyas",
                        "content": "[@ironmonger1](/ironmonger1)  if thats the case, the example given above\\n Input: nums = [0,3,7,2,5,8,4,6,0,1]\\nOutput: 9 then it should be 10 and not 9 right? "
                    },
                    {
                        "username": "Priyashreyas",
                        "content": "[@Ajay_Singh9990](/Ajay_Singh9990) if thats the case, the example given above\\n Input: nums = [0,3,7,2,5,8,4,6,0,1]\\nOutput: 9 then it should be 10 and not 9 right? "
                    },
                    {
                        "username": "Rajiv_123",
                        "content": "[@Dipan Ghosh](/dghosh133) For input [0,1,1,2] Longest consecutive seq would be 0,1,2 hence answer would be 3.  We can ignore the 1 at 2nd index as you are allowed to pick numbers at random indexes such that they are consecutive."
                    },
                    {
                        "username": "OmarEffat",
                        "content": "[@geekgeekvm](/geekgeekvm)  In this case, [0,3,7,2,5,8,4,6,0,1] this should be returning 10 (Example 2)"
                    },
                    {
                        "username": "geekgeekvm",
                        "content": "This was not clear from the question, but the question seems to indicate any sequence of consecutive numbers even if there is a repition in between"
                    },
                    {
                        "username": "sh1kamaruNara",
                        "content": "0,1,2 "
                    },
                    {
                        "username": "cookieslasher",
                        "content": "I had the same question. I thought the count should break off it reaches a duplicate number. I guess this wasn\\'t obvious in the problem description."
                    },
                    {
                        "username": "PrashantZuko",
                        "content": "no,it will be 3 since 0,1,2 are all consecutive."
                    },
                    {
                        "username": "user0241F",
                        "content": "            if inputArr[l] == inputArr[l + 1] then only increase"
                    },
                    {
                        "username": "devanshumasodker357",
                        "content": "bro u forget to add 0 that\\'s why it gives 3"
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "whenever duplicates elements in array but we have to return longest sequence\\nex  (1,1,2,2,3,3.4)    answer is 4\\nbcoz hume duplicate se mtlb nahi hai 1,2,3,4, numbers hai gap 1 ka hai then duplicates ko ignore kr dege "
                    },
                    {
                        "username": "Vishal773",
                        "content": "I think duplicates numbers not counted\\n"
                    },
                    {
                        "username": "ankit528",
                        "content": "subsequence could be in any order\\n"
                    },
                    {
                        "username": "subhadipmandalbagjuri",
                        "content": "i also faced same query, but with another else if statement if got resolved"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "well 0,1,2 there\\'s your sequence"
                    },
                    {
                        "username": "user5582eQ",
                        "content": "So many solutions here claiming to be O(n) are actually either O(n^2) or O(nlogn). How can people here have such poor understanding of time complexity."
                    },
                    {
                        "username": "_Ritik_Singh_",
                        "content": "Bro there is no need to judge anyone on the basis of their solution as long as they are solving and learning so chill out and watch  yourself."
                    },
                    {
                        "username": "RealNameHidden",
                        "content": "Explain it then if you understand it so well, so people can learn"
                    },
                    {
                        "username": "dragosarsene7",
                        "content": "[@carlosfonchii](/carlosfonchii) Learn what exactly. The whole point of the problem is to not sort, otherwise it is trivial. People who use sorting barely learn something, if anything at all, they just call sort and then iterate through an array."
                    },
                    {
                        "username": "dipanshuSaini",
                        "content": "[@Rimberse](/Rimberse)  my nlogn solution is as per leetcode -> 99 % faster. So yes, nlogn solution works here perfectly fine."
                    },
                    {
                        "username": "countdankula",
                        "content": "If you use set it will never reach N^2"
                    },
                    {
                        "username": "carlosfonchii",
                        "content": "There is literally no need to come at people when everyone is here to practice and get BETTER at coding. Check yourself."
                    },
                    {
                        "username": "grave18",
                        "content": "[@Rimberse](/Rimberse) No, i am sorting nums (nlogn) and pass the submission."
                    },
                    {
                        "username": "Rimberse",
                        "content": "I actually came up with O(nlogn) solution, but it didn\\'t work. Got TLE\\nSo anything either than O(n) won\\'t actually be accepted as a solution."
                    },
                    {
                        "username": "Saurabh8720",
                        "content": "Sorry To Interrupt Sir But, The Optimised Solution Dont Have a TC of N^2 or NlogN Sorry to Say But u r Wrong, It is Just O(3N) ~= O(N) "
                    },
                    {
                        "username": "nalinnishant",
                        "content": "agree "
                    },
                    {
                        "username": "Angrydemon",
                        "content": "I think they, first try to solve the given question using brute force without considering the time complexity then they try to optimes it, and if it not works they leave the question for later!"
                    },
                    {
                        "username": "aryansuvarna",
                        "content": "lol so true"
                    },
                    {
                        "username": "user7312022",
                        "content": "You can run your code against these test cases before submisson. Hope it helps!\\n\\n[100,4,200,1,3,2]\\n[0,3,7,2,5,8,4,6,0,1]\\n[1,2,0,1]\\n[0]\\n[0,0]\\n[]"
                    },
                    {
                        "username": "subhadipmandalbagjuri",
                        "content": "[9,1,4,7,3,-1,0,5,8,-1,6]"
                    },
                    {
                        "username": "iChuan",
                        "content": "This is really weried to me. Hard to understand the meaning of this question."
                    },
                    {
                        "username": "tusharmathew",
                        "content": "Its not sub sequence so we dont have to maintain order"
                    },
                    {
                        "username": "amansoni22103",
                        "content": "actually we need to avoid duplicate elements here that\\'s why it is showing 3 instead of 2"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/nA5TRClw96I"
                    },
                    {
                        "username": "nareshvishram",
                        "content": "![image](https://assets.leetcode.com/users/images/c8f1a005-5f10-4957-81be-7fb5c11163dd_1596370783.9489772.png)\\n"
                    },
                    {
                        "username": "addictive_head",
                        "content": "This is O(N) solution actually.\\n1. We are iterating over all elements of hash Set O(N).\\n 2. We then are looking for elements which are starting the subsequence, then we are searching elements set(i)+1, we keep searching till we are finding them. Update the final Count if required.\\nNote that we do not iterate over same numbers again. So O(N).\\n\\ni.e.  O(2N) ~= O(N)"
                    },
                    {
                        "username": "0bro",
                        "content": "At best it O(n log n), n for iterating the entire array, then log n for sub iterating through the hash within the loop that is iterating through the passed array. The search for the O(n) is real lol"
                    },
                    {
                        "username": "ethanultra",
                        "content": "[@SunilKumawat](/SunilKumawat) how? when we iterate through again to find a starting point, we only perform the search if there are elements in the subsequence, so when we encounter another element later that\\'s part of the subsequence, we skip it, so it\\'s not O(N^2) time, it is a multiple of O(N), so O(N)"
                    },
                    {
                        "username": "bhautikkapadiya6",
                        "content": "This algo is work but it has O(n*2) complexity"
                    },
                    {
                        "username": "kamran3210",
                        "content": "[@SunilKumawat](/SunilKumawat) \n\nI may be mistaken but surely its O(N)?\n\nInitialise set with the elements: O(N)\n\nIterate over array and check if it is the start of a subsequence (does not have a predecessor): O(N)\n\nSum of  lengths of all subsequences starting from a number that doesn't have a predecessor = N, therefore countining lengths of all subsequences: O(N)\n\noverall complexity: O(N)"
                    },
                    {
                        "username": "user5062LR",
                        "content": "[@SunilKumawat](/SunilKumawat) its O(3N) ~= O(N)"
                    },
                    {
                        "username": "hardikgupta083",
                        "content": "That is not O(N)"
                    },
                    {
                        "username": "SunilKumawat",
                        "content": "this solution has 0(N^2) time complexity genius"
                    },
                    {
                        "username": "forrrjoyuri",
                        "content": "Just for the sake of comparison, I implemented a naive solution in O(n log n) that sorts the array.\\nMy solution runs in 9ms. I copypasted the best linear solutions from the top posts here and the best i got was 30ms.\\n\\nIn theory, something is wrong here. Why is it the case ?"
                    },
                    {
                        "username": "energyperformer",
                        "content": "One thing u need to remeber is Best time complexity Solution doesn\\'t necessarly mean the fastet solution every instance ,initally for small numbers of n ,even if time complexity is more it can give faster result ,but when we go for large values of n then less time complexity solution offer better time results"
                    },
                    {
                        "username": "treat",
                        "content": "[@DeclanGH](/DeclanGH) Your assumed O(N) might actually be O(N^2)"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "I think leetcode needs to add a very large testcase for this problem to make a nlogn fail"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "[@matthewjiao](/matthewjiao) You are right in theory, but if you could see my two solutions, you would see the comment i made. My first O(n) solution ran 463 ms while the nlogn ran 14ms. its really weird and i was graced to get one testcase wrong, which had 10000 as its answer (which is the largest input size). Not saying you are wrong, but the fact that my result was that way still confuses me. "
                    },
                    {
                        "username": "ixeridium",
                        "content": "E.g. with Python it can happen that using some builtin primitive (or libraries such as numpy) give very significant speedups. A factor of 100 or more is not unusual. In such situations it can happen that a O(n log n) solution is always faster than a O(n) solution for any practical input size. I.e., n log n < 100 * n for all n < exp(100)."
                    },
                    {
                        "username": "wasam1119",
                        "content": "[@matthewjiao](/matthewjiao) Accurate. Observe graphs of y = x and y = x*log(x)"
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "from my experience agr aap ek baar best runtime solution dekh lo ja kr after submission and copy pr aap submit kro then this time code not beats 100 percent submission zyada time lega \\nmay be this is leetcode feature jisse leetcode ke solution ko dekh bo dusro ke solution ko beat na kr paye jin logo ne bina ldekhe kiya hai leetcode best solution \\n"
                    },
                    {
                        "username": "matthewjiao",
                        "content": "Time complexity is not a function of speed, it\\'s a function of growth based on input size. Perhaps with smaller inputs, the linearithmic solution is faster than the linear solution, but as input grows in size, O(n) will eventually out perform O(nlogn)."
                    },
                    {
                        "username": "coolkid0006",
                        "content": "Big O notation drops constants from algorithms\\' complexity because Big O notation is concerned with asymptotic inputs (the input size heads towards infinity). The leetcode test cases aren\\'t large enough to ideally represent the asymptotic complexity, so the constants dropped off when calculating the Big O complexity can have a significant effect on runtime. For example:\\n\\nImagine 2 algorithms for a problem: one has a complexity of n^2 and one has an algorithm of n + 10000. The big O notation drops the constants, so the complexities are O(n^2) and O(n). If you work with small amounts of data the n^2 will have a much smaller runtime, but once a certain point is reached the +10000 won\\'t make much of a difference on the runtime.\\n\\nFor this leetcode problem the naive solution has a smaller runtime for inputs smaller than a certain point. This point is larger than the input sizes of the leetcode solution.\\n\\nIf your solution is at the very bottom of the time and memory leaderboard you might want to make sure it is implemented correctly, but because of the asymptotic nature of Big O notation it isn\\'t always accurate to whether it is the ideal solution."
                    },
                    {
                        "username": "Triquetra",
                        "content": "Try to plot execution time of both solutions against n = 100, 1000, 10000, ... \\u2014 maybe you will see a pattern."
                    },
                    {
                        "username": "kiyosaanb",
                        "content": "In case you are doing something like  nums[i]++ or nums[i]-- , you will encounter problems with this new test case ---> [2147483647,-2147483648]"
                    },
                    {
                        "username": "ShiqiLu77",
                        "content": "-1,000,000,000 <= nums[i] <= 1,000,000,000"
                    },
                    {
                        "username": "yis1178",
                        "content": "I think there is a restriction of the value of nums[i] -- not sure if this is lately added"
                    },
                    {
                        "username": "jasusy",
                        "content": "Is it better to need to clarify duplicate numbers not included in consecutive seq?\\n\\nFor example, if input [0, 0] should output 1, instead of 2, since no duplication counted in result.\\n\\nIf duplicate number considered, we need use HashMap instead of HashSet, and a little different in coding."
                    },
                    {
                        "username": "rubayamim381",
                        "content": "[@shanwu](/shanwu) [1,1,2,3,4] = 5"
                    },
                    {
                        "username": "user6161I",
                        "content": "[@shanwu](/shanwu) 4 ... Because Duplicates are to be treated as single."
                    },
                    {
                        "username": "khritish17",
                        "content": "duplicates should be treated as one\\ne.g : nums = [0,0,1,2,3,4,5,6,7,8] -> output: 9 ([0,1,2,3,4,5,6,7,8])"
                    },
                    {
                        "username": "shanwu",
                        "content": "I agree with you. If duplicate numbers are allowed, then what should be the answer of [100,4,200,1,1,3,2] ? It would be unclear."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/longest-consecutive-sequence/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Sorting\n\n  \n**Approach 3:** HashSet and Intelligent Sequence Building\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "PruthviChippa",
                        "content": "this deserves to be hard for o(n)"
                    },
                    {
                        "username": "Hopity",
                        "content": "for some reason it accepts o(nlogn) that\\'s why it\\'s in medium"
                    }
                ]
            },
            {
                "id": 1575370,
                "content": [
                    {
                        "username": "dghosh133",
                        "content": "How does [1,2,0,1] tc gives output as 3? It should be 2! Someone please clarify.\\n[0,1,1,2] -> has at most 2 consecutive nos."
                    },
                    {
                        "username": "TraySoek",
                        "content": "[@PrashantZuko](/PrashantZuko) yes that\\'s it"
                    },
                    {
                        "username": "dsoum",
                        "content": "[@OmarEffat](/OmarEffat) No highest sequence here is, 0,1,2,3,4,5,6,7,8 hence 9. why 10?"
                    },
                    {
                        "username": "Priyashreyas",
                        "content": "[@ironmonger1](/ironmonger1)  if thats the case, the example given above\\n Input: nums = [0,3,7,2,5,8,4,6,0,1]\\nOutput: 9 then it should be 10 and not 9 right? "
                    },
                    {
                        "username": "Priyashreyas",
                        "content": "[@Ajay_Singh9990](/Ajay_Singh9990) if thats the case, the example given above\\n Input: nums = [0,3,7,2,5,8,4,6,0,1]\\nOutput: 9 then it should be 10 and not 9 right? "
                    },
                    {
                        "username": "Rajiv_123",
                        "content": "[@Dipan Ghosh](/dghosh133) For input [0,1,1,2] Longest consecutive seq would be 0,1,2 hence answer would be 3.  We can ignore the 1 at 2nd index as you are allowed to pick numbers at random indexes such that they are consecutive."
                    },
                    {
                        "username": "OmarEffat",
                        "content": "[@geekgeekvm](/geekgeekvm)  In this case, [0,3,7,2,5,8,4,6,0,1] this should be returning 10 (Example 2)"
                    },
                    {
                        "username": "geekgeekvm",
                        "content": "This was not clear from the question, but the question seems to indicate any sequence of consecutive numbers even if there is a repition in between"
                    },
                    {
                        "username": "sh1kamaruNara",
                        "content": "0,1,2 "
                    },
                    {
                        "username": "cookieslasher",
                        "content": "I had the same question. I thought the count should break off it reaches a duplicate number. I guess this wasn\\'t obvious in the problem description."
                    },
                    {
                        "username": "PrashantZuko",
                        "content": "no,it will be 3 since 0,1,2 are all consecutive."
                    },
                    {
                        "username": "user0241F",
                        "content": "            if inputArr[l] == inputArr[l + 1] then only increase"
                    },
                    {
                        "username": "devanshumasodker357",
                        "content": "bro u forget to add 0 that\\'s why it gives 3"
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "whenever duplicates elements in array but we have to return longest sequence\\nex  (1,1,2,2,3,3.4)    answer is 4\\nbcoz hume duplicate se mtlb nahi hai 1,2,3,4, numbers hai gap 1 ka hai then duplicates ko ignore kr dege "
                    },
                    {
                        "username": "Vishal773",
                        "content": "I think duplicates numbers not counted\\n"
                    },
                    {
                        "username": "ankit528",
                        "content": "subsequence could be in any order\\n"
                    },
                    {
                        "username": "subhadipmandalbagjuri",
                        "content": "i also faced same query, but with another else if statement if got resolved"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "well 0,1,2 there\\'s your sequence"
                    },
                    {
                        "username": "user5582eQ",
                        "content": "So many solutions here claiming to be O(n) are actually either O(n^2) or O(nlogn). How can people here have such poor understanding of time complexity."
                    },
                    {
                        "username": "_Ritik_Singh_",
                        "content": "Bro there is no need to judge anyone on the basis of their solution as long as they are solving and learning so chill out and watch  yourself."
                    },
                    {
                        "username": "RealNameHidden",
                        "content": "Explain it then if you understand it so well, so people can learn"
                    },
                    {
                        "username": "dragosarsene7",
                        "content": "[@carlosfonchii](/carlosfonchii) Learn what exactly. The whole point of the problem is to not sort, otherwise it is trivial. People who use sorting barely learn something, if anything at all, they just call sort and then iterate through an array."
                    },
                    {
                        "username": "dipanshuSaini",
                        "content": "[@Rimberse](/Rimberse)  my nlogn solution is as per leetcode -> 99 % faster. So yes, nlogn solution works here perfectly fine."
                    },
                    {
                        "username": "countdankula",
                        "content": "If you use set it will never reach N^2"
                    },
                    {
                        "username": "carlosfonchii",
                        "content": "There is literally no need to come at people when everyone is here to practice and get BETTER at coding. Check yourself."
                    },
                    {
                        "username": "grave18",
                        "content": "[@Rimberse](/Rimberse) No, i am sorting nums (nlogn) and pass the submission."
                    },
                    {
                        "username": "Rimberse",
                        "content": "I actually came up with O(nlogn) solution, but it didn\\'t work. Got TLE\\nSo anything either than O(n) won\\'t actually be accepted as a solution."
                    },
                    {
                        "username": "Saurabh8720",
                        "content": "Sorry To Interrupt Sir But, The Optimised Solution Dont Have a TC of N^2 or NlogN Sorry to Say But u r Wrong, It is Just O(3N) ~= O(N) "
                    },
                    {
                        "username": "nalinnishant",
                        "content": "agree "
                    },
                    {
                        "username": "Angrydemon",
                        "content": "I think they, first try to solve the given question using brute force without considering the time complexity then they try to optimes it, and if it not works they leave the question for later!"
                    },
                    {
                        "username": "aryansuvarna",
                        "content": "lol so true"
                    },
                    {
                        "username": "user7312022",
                        "content": "You can run your code against these test cases before submisson. Hope it helps!\\n\\n[100,4,200,1,3,2]\\n[0,3,7,2,5,8,4,6,0,1]\\n[1,2,0,1]\\n[0]\\n[0,0]\\n[]"
                    },
                    {
                        "username": "subhadipmandalbagjuri",
                        "content": "[9,1,4,7,3,-1,0,5,8,-1,6]"
                    },
                    {
                        "username": "iChuan",
                        "content": "This is really weried to me. Hard to understand the meaning of this question."
                    },
                    {
                        "username": "tusharmathew",
                        "content": "Its not sub sequence so we dont have to maintain order"
                    },
                    {
                        "username": "amansoni22103",
                        "content": "actually we need to avoid duplicate elements here that\\'s why it is showing 3 instead of 2"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/nA5TRClw96I"
                    },
                    {
                        "username": "nareshvishram",
                        "content": "![image](https://assets.leetcode.com/users/images/c8f1a005-5f10-4957-81be-7fb5c11163dd_1596370783.9489772.png)\\n"
                    },
                    {
                        "username": "addictive_head",
                        "content": "This is O(N) solution actually.\\n1. We are iterating over all elements of hash Set O(N).\\n 2. We then are looking for elements which are starting the subsequence, then we are searching elements set(i)+1, we keep searching till we are finding them. Update the final Count if required.\\nNote that we do not iterate over same numbers again. So O(N).\\n\\ni.e.  O(2N) ~= O(N)"
                    },
                    {
                        "username": "0bro",
                        "content": "At best it O(n log n), n for iterating the entire array, then log n for sub iterating through the hash within the loop that is iterating through the passed array. The search for the O(n) is real lol"
                    },
                    {
                        "username": "ethanultra",
                        "content": "[@SunilKumawat](/SunilKumawat) how? when we iterate through again to find a starting point, we only perform the search if there are elements in the subsequence, so when we encounter another element later that\\'s part of the subsequence, we skip it, so it\\'s not O(N^2) time, it is a multiple of O(N), so O(N)"
                    },
                    {
                        "username": "bhautikkapadiya6",
                        "content": "This algo is work but it has O(n*2) complexity"
                    },
                    {
                        "username": "kamran3210",
                        "content": "[@SunilKumawat](/SunilKumawat) \n\nI may be mistaken but surely its O(N)?\n\nInitialise set with the elements: O(N)\n\nIterate over array and check if it is the start of a subsequence (does not have a predecessor): O(N)\n\nSum of  lengths of all subsequences starting from a number that doesn't have a predecessor = N, therefore countining lengths of all subsequences: O(N)\n\noverall complexity: O(N)"
                    },
                    {
                        "username": "user5062LR",
                        "content": "[@SunilKumawat](/SunilKumawat) its O(3N) ~= O(N)"
                    },
                    {
                        "username": "hardikgupta083",
                        "content": "That is not O(N)"
                    },
                    {
                        "username": "SunilKumawat",
                        "content": "this solution has 0(N^2) time complexity genius"
                    },
                    {
                        "username": "forrrjoyuri",
                        "content": "Just for the sake of comparison, I implemented a naive solution in O(n log n) that sorts the array.\\nMy solution runs in 9ms. I copypasted the best linear solutions from the top posts here and the best i got was 30ms.\\n\\nIn theory, something is wrong here. Why is it the case ?"
                    },
                    {
                        "username": "energyperformer",
                        "content": "One thing u need to remeber is Best time complexity Solution doesn\\'t necessarly mean the fastet solution every instance ,initally for small numbers of n ,even if time complexity is more it can give faster result ,but when we go for large values of n then less time complexity solution offer better time results"
                    },
                    {
                        "username": "treat",
                        "content": "[@DeclanGH](/DeclanGH) Your assumed O(N) might actually be O(N^2)"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "I think leetcode needs to add a very large testcase for this problem to make a nlogn fail"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "[@matthewjiao](/matthewjiao) You are right in theory, but if you could see my two solutions, you would see the comment i made. My first O(n) solution ran 463 ms while the nlogn ran 14ms. its really weird and i was graced to get one testcase wrong, which had 10000 as its answer (which is the largest input size). Not saying you are wrong, but the fact that my result was that way still confuses me. "
                    },
                    {
                        "username": "ixeridium",
                        "content": "E.g. with Python it can happen that using some builtin primitive (or libraries such as numpy) give very significant speedups. A factor of 100 or more is not unusual. In such situations it can happen that a O(n log n) solution is always faster than a O(n) solution for any practical input size. I.e., n log n < 100 * n for all n < exp(100)."
                    },
                    {
                        "username": "wasam1119",
                        "content": "[@matthewjiao](/matthewjiao) Accurate. Observe graphs of y = x and y = x*log(x)"
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "from my experience agr aap ek baar best runtime solution dekh lo ja kr after submission and copy pr aap submit kro then this time code not beats 100 percent submission zyada time lega \\nmay be this is leetcode feature jisse leetcode ke solution ko dekh bo dusro ke solution ko beat na kr paye jin logo ne bina ldekhe kiya hai leetcode best solution \\n"
                    },
                    {
                        "username": "matthewjiao",
                        "content": "Time complexity is not a function of speed, it\\'s a function of growth based on input size. Perhaps with smaller inputs, the linearithmic solution is faster than the linear solution, but as input grows in size, O(n) will eventually out perform O(nlogn)."
                    },
                    {
                        "username": "coolkid0006",
                        "content": "Big O notation drops constants from algorithms\\' complexity because Big O notation is concerned with asymptotic inputs (the input size heads towards infinity). The leetcode test cases aren\\'t large enough to ideally represent the asymptotic complexity, so the constants dropped off when calculating the Big O complexity can have a significant effect on runtime. For example:\\n\\nImagine 2 algorithms for a problem: one has a complexity of n^2 and one has an algorithm of n + 10000. The big O notation drops the constants, so the complexities are O(n^2) and O(n). If you work with small amounts of data the n^2 will have a much smaller runtime, but once a certain point is reached the +10000 won\\'t make much of a difference on the runtime.\\n\\nFor this leetcode problem the naive solution has a smaller runtime for inputs smaller than a certain point. This point is larger than the input sizes of the leetcode solution.\\n\\nIf your solution is at the very bottom of the time and memory leaderboard you might want to make sure it is implemented correctly, but because of the asymptotic nature of Big O notation it isn\\'t always accurate to whether it is the ideal solution."
                    },
                    {
                        "username": "Triquetra",
                        "content": "Try to plot execution time of both solutions against n = 100, 1000, 10000, ... \\u2014 maybe you will see a pattern."
                    },
                    {
                        "username": "kiyosaanb",
                        "content": "In case you are doing something like  nums[i]++ or nums[i]-- , you will encounter problems with this new test case ---> [2147483647,-2147483648]"
                    },
                    {
                        "username": "ShiqiLu77",
                        "content": "-1,000,000,000 <= nums[i] <= 1,000,000,000"
                    },
                    {
                        "username": "yis1178",
                        "content": "I think there is a restriction of the value of nums[i] -- not sure if this is lately added"
                    },
                    {
                        "username": "jasusy",
                        "content": "Is it better to need to clarify duplicate numbers not included in consecutive seq?\\n\\nFor example, if input [0, 0] should output 1, instead of 2, since no duplication counted in result.\\n\\nIf duplicate number considered, we need use HashMap instead of HashSet, and a little different in coding."
                    },
                    {
                        "username": "rubayamim381",
                        "content": "[@shanwu](/shanwu) [1,1,2,3,4] = 5"
                    },
                    {
                        "username": "user6161I",
                        "content": "[@shanwu](/shanwu) 4 ... Because Duplicates are to be treated as single."
                    },
                    {
                        "username": "khritish17",
                        "content": "duplicates should be treated as one\\ne.g : nums = [0,0,1,2,3,4,5,6,7,8] -> output: 9 ([0,1,2,3,4,5,6,7,8])"
                    },
                    {
                        "username": "shanwu",
                        "content": "I agree with you. If duplicate numbers are allowed, then what should be the answer of [100,4,200,1,1,3,2] ? It would be unclear."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/longest-consecutive-sequence/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Sorting\n\n  \n**Approach 3:** HashSet and Intelligent Sequence Building\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "PruthviChippa",
                        "content": "this deserves to be hard for o(n)"
                    },
                    {
                        "username": "Hopity",
                        "content": "for some reason it accepts o(nlogn) that\\'s why it\\'s in medium"
                    }
                ]
            },
            {
                "id": 1566539,
                "content": [
                    {
                        "username": "dghosh133",
                        "content": "How does [1,2,0,1] tc gives output as 3? It should be 2! Someone please clarify.\\n[0,1,1,2] -> has at most 2 consecutive nos."
                    },
                    {
                        "username": "TraySoek",
                        "content": "[@PrashantZuko](/PrashantZuko) yes that\\'s it"
                    },
                    {
                        "username": "dsoum",
                        "content": "[@OmarEffat](/OmarEffat) No highest sequence here is, 0,1,2,3,4,5,6,7,8 hence 9. why 10?"
                    },
                    {
                        "username": "Priyashreyas",
                        "content": "[@ironmonger1](/ironmonger1)  if thats the case, the example given above\\n Input: nums = [0,3,7,2,5,8,4,6,0,1]\\nOutput: 9 then it should be 10 and not 9 right? "
                    },
                    {
                        "username": "Priyashreyas",
                        "content": "[@Ajay_Singh9990](/Ajay_Singh9990) if thats the case, the example given above\\n Input: nums = [0,3,7,2,5,8,4,6,0,1]\\nOutput: 9 then it should be 10 and not 9 right? "
                    },
                    {
                        "username": "Rajiv_123",
                        "content": "[@Dipan Ghosh](/dghosh133) For input [0,1,1,2] Longest consecutive seq would be 0,1,2 hence answer would be 3.  We can ignore the 1 at 2nd index as you are allowed to pick numbers at random indexes such that they are consecutive."
                    },
                    {
                        "username": "OmarEffat",
                        "content": "[@geekgeekvm](/geekgeekvm)  In this case, [0,3,7,2,5,8,4,6,0,1] this should be returning 10 (Example 2)"
                    },
                    {
                        "username": "geekgeekvm",
                        "content": "This was not clear from the question, but the question seems to indicate any sequence of consecutive numbers even if there is a repition in between"
                    },
                    {
                        "username": "sh1kamaruNara",
                        "content": "0,1,2 "
                    },
                    {
                        "username": "cookieslasher",
                        "content": "I had the same question. I thought the count should break off it reaches a duplicate number. I guess this wasn\\'t obvious in the problem description."
                    },
                    {
                        "username": "PrashantZuko",
                        "content": "no,it will be 3 since 0,1,2 are all consecutive."
                    },
                    {
                        "username": "user0241F",
                        "content": "            if inputArr[l] == inputArr[l + 1] then only increase"
                    },
                    {
                        "username": "devanshumasodker357",
                        "content": "bro u forget to add 0 that\\'s why it gives 3"
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "whenever duplicates elements in array but we have to return longest sequence\\nex  (1,1,2,2,3,3.4)    answer is 4\\nbcoz hume duplicate se mtlb nahi hai 1,2,3,4, numbers hai gap 1 ka hai then duplicates ko ignore kr dege "
                    },
                    {
                        "username": "Vishal773",
                        "content": "I think duplicates numbers not counted\\n"
                    },
                    {
                        "username": "ankit528",
                        "content": "subsequence could be in any order\\n"
                    },
                    {
                        "username": "subhadipmandalbagjuri",
                        "content": "i also faced same query, but with another else if statement if got resolved"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "well 0,1,2 there\\'s your sequence"
                    },
                    {
                        "username": "user5582eQ",
                        "content": "So many solutions here claiming to be O(n) are actually either O(n^2) or O(nlogn). How can people here have such poor understanding of time complexity."
                    },
                    {
                        "username": "_Ritik_Singh_",
                        "content": "Bro there is no need to judge anyone on the basis of their solution as long as they are solving and learning so chill out and watch  yourself."
                    },
                    {
                        "username": "RealNameHidden",
                        "content": "Explain it then if you understand it so well, so people can learn"
                    },
                    {
                        "username": "dragosarsene7",
                        "content": "[@carlosfonchii](/carlosfonchii) Learn what exactly. The whole point of the problem is to not sort, otherwise it is trivial. People who use sorting barely learn something, if anything at all, they just call sort and then iterate through an array."
                    },
                    {
                        "username": "dipanshuSaini",
                        "content": "[@Rimberse](/Rimberse)  my nlogn solution is as per leetcode -> 99 % faster. So yes, nlogn solution works here perfectly fine."
                    },
                    {
                        "username": "countdankula",
                        "content": "If you use set it will never reach N^2"
                    },
                    {
                        "username": "carlosfonchii",
                        "content": "There is literally no need to come at people when everyone is here to practice and get BETTER at coding. Check yourself."
                    },
                    {
                        "username": "grave18",
                        "content": "[@Rimberse](/Rimberse) No, i am sorting nums (nlogn) and pass the submission."
                    },
                    {
                        "username": "Rimberse",
                        "content": "I actually came up with O(nlogn) solution, but it didn\\'t work. Got TLE\\nSo anything either than O(n) won\\'t actually be accepted as a solution."
                    },
                    {
                        "username": "Saurabh8720",
                        "content": "Sorry To Interrupt Sir But, The Optimised Solution Dont Have a TC of N^2 or NlogN Sorry to Say But u r Wrong, It is Just O(3N) ~= O(N) "
                    },
                    {
                        "username": "nalinnishant",
                        "content": "agree "
                    },
                    {
                        "username": "Angrydemon",
                        "content": "I think they, first try to solve the given question using brute force without considering the time complexity then they try to optimes it, and if it not works they leave the question for later!"
                    },
                    {
                        "username": "aryansuvarna",
                        "content": "lol so true"
                    },
                    {
                        "username": "user7312022",
                        "content": "You can run your code against these test cases before submisson. Hope it helps!\\n\\n[100,4,200,1,3,2]\\n[0,3,7,2,5,8,4,6,0,1]\\n[1,2,0,1]\\n[0]\\n[0,0]\\n[]"
                    },
                    {
                        "username": "subhadipmandalbagjuri",
                        "content": "[9,1,4,7,3,-1,0,5,8,-1,6]"
                    },
                    {
                        "username": "iChuan",
                        "content": "This is really weried to me. Hard to understand the meaning of this question."
                    },
                    {
                        "username": "tusharmathew",
                        "content": "Its not sub sequence so we dont have to maintain order"
                    },
                    {
                        "username": "amansoni22103",
                        "content": "actually we need to avoid duplicate elements here that\\'s why it is showing 3 instead of 2"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/nA5TRClw96I"
                    },
                    {
                        "username": "nareshvishram",
                        "content": "![image](https://assets.leetcode.com/users/images/c8f1a005-5f10-4957-81be-7fb5c11163dd_1596370783.9489772.png)\\n"
                    },
                    {
                        "username": "addictive_head",
                        "content": "This is O(N) solution actually.\\n1. We are iterating over all elements of hash Set O(N).\\n 2. We then are looking for elements which are starting the subsequence, then we are searching elements set(i)+1, we keep searching till we are finding them. Update the final Count if required.\\nNote that we do not iterate over same numbers again. So O(N).\\n\\ni.e.  O(2N) ~= O(N)"
                    },
                    {
                        "username": "0bro",
                        "content": "At best it O(n log n), n for iterating the entire array, then log n for sub iterating through the hash within the loop that is iterating through the passed array. The search for the O(n) is real lol"
                    },
                    {
                        "username": "ethanultra",
                        "content": "[@SunilKumawat](/SunilKumawat) how? when we iterate through again to find a starting point, we only perform the search if there are elements in the subsequence, so when we encounter another element later that\\'s part of the subsequence, we skip it, so it\\'s not O(N^2) time, it is a multiple of O(N), so O(N)"
                    },
                    {
                        "username": "bhautikkapadiya6",
                        "content": "This algo is work but it has O(n*2) complexity"
                    },
                    {
                        "username": "kamran3210",
                        "content": "[@SunilKumawat](/SunilKumawat) \n\nI may be mistaken but surely its O(N)?\n\nInitialise set with the elements: O(N)\n\nIterate over array and check if it is the start of a subsequence (does not have a predecessor): O(N)\n\nSum of  lengths of all subsequences starting from a number that doesn't have a predecessor = N, therefore countining lengths of all subsequences: O(N)\n\noverall complexity: O(N)"
                    },
                    {
                        "username": "user5062LR",
                        "content": "[@SunilKumawat](/SunilKumawat) its O(3N) ~= O(N)"
                    },
                    {
                        "username": "hardikgupta083",
                        "content": "That is not O(N)"
                    },
                    {
                        "username": "SunilKumawat",
                        "content": "this solution has 0(N^2) time complexity genius"
                    },
                    {
                        "username": "forrrjoyuri",
                        "content": "Just for the sake of comparison, I implemented a naive solution in O(n log n) that sorts the array.\\nMy solution runs in 9ms. I copypasted the best linear solutions from the top posts here and the best i got was 30ms.\\n\\nIn theory, something is wrong here. Why is it the case ?"
                    },
                    {
                        "username": "energyperformer",
                        "content": "One thing u need to remeber is Best time complexity Solution doesn\\'t necessarly mean the fastet solution every instance ,initally for small numbers of n ,even if time complexity is more it can give faster result ,but when we go for large values of n then less time complexity solution offer better time results"
                    },
                    {
                        "username": "treat",
                        "content": "[@DeclanGH](/DeclanGH) Your assumed O(N) might actually be O(N^2)"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "I think leetcode needs to add a very large testcase for this problem to make a nlogn fail"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "[@matthewjiao](/matthewjiao) You are right in theory, but if you could see my two solutions, you would see the comment i made. My first O(n) solution ran 463 ms while the nlogn ran 14ms. its really weird and i was graced to get one testcase wrong, which had 10000 as its answer (which is the largest input size). Not saying you are wrong, but the fact that my result was that way still confuses me. "
                    },
                    {
                        "username": "ixeridium",
                        "content": "E.g. with Python it can happen that using some builtin primitive (or libraries such as numpy) give very significant speedups. A factor of 100 or more is not unusual. In such situations it can happen that a O(n log n) solution is always faster than a O(n) solution for any practical input size. I.e., n log n < 100 * n for all n < exp(100)."
                    },
                    {
                        "username": "wasam1119",
                        "content": "[@matthewjiao](/matthewjiao) Accurate. Observe graphs of y = x and y = x*log(x)"
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "from my experience agr aap ek baar best runtime solution dekh lo ja kr after submission and copy pr aap submit kro then this time code not beats 100 percent submission zyada time lega \\nmay be this is leetcode feature jisse leetcode ke solution ko dekh bo dusro ke solution ko beat na kr paye jin logo ne bina ldekhe kiya hai leetcode best solution \\n"
                    },
                    {
                        "username": "matthewjiao",
                        "content": "Time complexity is not a function of speed, it\\'s a function of growth based on input size. Perhaps with smaller inputs, the linearithmic solution is faster than the linear solution, but as input grows in size, O(n) will eventually out perform O(nlogn)."
                    },
                    {
                        "username": "coolkid0006",
                        "content": "Big O notation drops constants from algorithms\\' complexity because Big O notation is concerned with asymptotic inputs (the input size heads towards infinity). The leetcode test cases aren\\'t large enough to ideally represent the asymptotic complexity, so the constants dropped off when calculating the Big O complexity can have a significant effect on runtime. For example:\\n\\nImagine 2 algorithms for a problem: one has a complexity of n^2 and one has an algorithm of n + 10000. The big O notation drops the constants, so the complexities are O(n^2) and O(n). If you work with small amounts of data the n^2 will have a much smaller runtime, but once a certain point is reached the +10000 won\\'t make much of a difference on the runtime.\\n\\nFor this leetcode problem the naive solution has a smaller runtime for inputs smaller than a certain point. This point is larger than the input sizes of the leetcode solution.\\n\\nIf your solution is at the very bottom of the time and memory leaderboard you might want to make sure it is implemented correctly, but because of the asymptotic nature of Big O notation it isn\\'t always accurate to whether it is the ideal solution."
                    },
                    {
                        "username": "Triquetra",
                        "content": "Try to plot execution time of both solutions against n = 100, 1000, 10000, ... \\u2014 maybe you will see a pattern."
                    },
                    {
                        "username": "kiyosaanb",
                        "content": "In case you are doing something like  nums[i]++ or nums[i]-- , you will encounter problems with this new test case ---> [2147483647,-2147483648]"
                    },
                    {
                        "username": "ShiqiLu77",
                        "content": "-1,000,000,000 <= nums[i] <= 1,000,000,000"
                    },
                    {
                        "username": "yis1178",
                        "content": "I think there is a restriction of the value of nums[i] -- not sure if this is lately added"
                    },
                    {
                        "username": "jasusy",
                        "content": "Is it better to need to clarify duplicate numbers not included in consecutive seq?\\n\\nFor example, if input [0, 0] should output 1, instead of 2, since no duplication counted in result.\\n\\nIf duplicate number considered, we need use HashMap instead of HashSet, and a little different in coding."
                    },
                    {
                        "username": "rubayamim381",
                        "content": "[@shanwu](/shanwu) [1,1,2,3,4] = 5"
                    },
                    {
                        "username": "user6161I",
                        "content": "[@shanwu](/shanwu) 4 ... Because Duplicates are to be treated as single."
                    },
                    {
                        "username": "khritish17",
                        "content": "duplicates should be treated as one\\ne.g : nums = [0,0,1,2,3,4,5,6,7,8] -> output: 9 ([0,1,2,3,4,5,6,7,8])"
                    },
                    {
                        "username": "shanwu",
                        "content": "I agree with you. If duplicate numbers are allowed, then what should be the answer of [100,4,200,1,1,3,2] ? It would be unclear."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/longest-consecutive-sequence/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Sorting\n\n  \n**Approach 3:** HashSet and Intelligent Sequence Building\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "PruthviChippa",
                        "content": "this deserves to be hard for o(n)"
                    },
                    {
                        "username": "Hopity",
                        "content": "for some reason it accepts o(nlogn) that\\'s why it\\'s in medium"
                    }
                ]
            },
            {
                "id": 1574147,
                "content": [
                    {
                        "username": "dghosh133",
                        "content": "How does [1,2,0,1] tc gives output as 3? It should be 2! Someone please clarify.\\n[0,1,1,2] -> has at most 2 consecutive nos."
                    },
                    {
                        "username": "TraySoek",
                        "content": "[@PrashantZuko](/PrashantZuko) yes that\\'s it"
                    },
                    {
                        "username": "dsoum",
                        "content": "[@OmarEffat](/OmarEffat) No highest sequence here is, 0,1,2,3,4,5,6,7,8 hence 9. why 10?"
                    },
                    {
                        "username": "Priyashreyas",
                        "content": "[@ironmonger1](/ironmonger1)  if thats the case, the example given above\\n Input: nums = [0,3,7,2,5,8,4,6,0,1]\\nOutput: 9 then it should be 10 and not 9 right? "
                    },
                    {
                        "username": "Priyashreyas",
                        "content": "[@Ajay_Singh9990](/Ajay_Singh9990) if thats the case, the example given above\\n Input: nums = [0,3,7,2,5,8,4,6,0,1]\\nOutput: 9 then it should be 10 and not 9 right? "
                    },
                    {
                        "username": "Rajiv_123",
                        "content": "[@Dipan Ghosh](/dghosh133) For input [0,1,1,2] Longest consecutive seq would be 0,1,2 hence answer would be 3.  We can ignore the 1 at 2nd index as you are allowed to pick numbers at random indexes such that they are consecutive."
                    },
                    {
                        "username": "OmarEffat",
                        "content": "[@geekgeekvm](/geekgeekvm)  In this case, [0,3,7,2,5,8,4,6,0,1] this should be returning 10 (Example 2)"
                    },
                    {
                        "username": "geekgeekvm",
                        "content": "This was not clear from the question, but the question seems to indicate any sequence of consecutive numbers even if there is a repition in between"
                    },
                    {
                        "username": "sh1kamaruNara",
                        "content": "0,1,2 "
                    },
                    {
                        "username": "cookieslasher",
                        "content": "I had the same question. I thought the count should break off it reaches a duplicate number. I guess this wasn\\'t obvious in the problem description."
                    },
                    {
                        "username": "PrashantZuko",
                        "content": "no,it will be 3 since 0,1,2 are all consecutive."
                    },
                    {
                        "username": "user0241F",
                        "content": "            if inputArr[l] == inputArr[l + 1] then only increase"
                    },
                    {
                        "username": "devanshumasodker357",
                        "content": "bro u forget to add 0 that\\'s why it gives 3"
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "whenever duplicates elements in array but we have to return longest sequence\\nex  (1,1,2,2,3,3.4)    answer is 4\\nbcoz hume duplicate se mtlb nahi hai 1,2,3,4, numbers hai gap 1 ka hai then duplicates ko ignore kr dege "
                    },
                    {
                        "username": "Vishal773",
                        "content": "I think duplicates numbers not counted\\n"
                    },
                    {
                        "username": "ankit528",
                        "content": "subsequence could be in any order\\n"
                    },
                    {
                        "username": "subhadipmandalbagjuri",
                        "content": "i also faced same query, but with another else if statement if got resolved"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "well 0,1,2 there\\'s your sequence"
                    },
                    {
                        "username": "user5582eQ",
                        "content": "So many solutions here claiming to be O(n) are actually either O(n^2) or O(nlogn). How can people here have such poor understanding of time complexity."
                    },
                    {
                        "username": "_Ritik_Singh_",
                        "content": "Bro there is no need to judge anyone on the basis of their solution as long as they are solving and learning so chill out and watch  yourself."
                    },
                    {
                        "username": "RealNameHidden",
                        "content": "Explain it then if you understand it so well, so people can learn"
                    },
                    {
                        "username": "dragosarsene7",
                        "content": "[@carlosfonchii](/carlosfonchii) Learn what exactly. The whole point of the problem is to not sort, otherwise it is trivial. People who use sorting barely learn something, if anything at all, they just call sort and then iterate through an array."
                    },
                    {
                        "username": "dipanshuSaini",
                        "content": "[@Rimberse](/Rimberse)  my nlogn solution is as per leetcode -> 99 % faster. So yes, nlogn solution works here perfectly fine."
                    },
                    {
                        "username": "countdankula",
                        "content": "If you use set it will never reach N^2"
                    },
                    {
                        "username": "carlosfonchii",
                        "content": "There is literally no need to come at people when everyone is here to practice and get BETTER at coding. Check yourself."
                    },
                    {
                        "username": "grave18",
                        "content": "[@Rimberse](/Rimberse) No, i am sorting nums (nlogn) and pass the submission."
                    },
                    {
                        "username": "Rimberse",
                        "content": "I actually came up with O(nlogn) solution, but it didn\\'t work. Got TLE\\nSo anything either than O(n) won\\'t actually be accepted as a solution."
                    },
                    {
                        "username": "Saurabh8720",
                        "content": "Sorry To Interrupt Sir But, The Optimised Solution Dont Have a TC of N^2 or NlogN Sorry to Say But u r Wrong, It is Just O(3N) ~= O(N) "
                    },
                    {
                        "username": "nalinnishant",
                        "content": "agree "
                    },
                    {
                        "username": "Angrydemon",
                        "content": "I think they, first try to solve the given question using brute force without considering the time complexity then they try to optimes it, and if it not works they leave the question for later!"
                    },
                    {
                        "username": "aryansuvarna",
                        "content": "lol so true"
                    },
                    {
                        "username": "user7312022",
                        "content": "You can run your code against these test cases before submisson. Hope it helps!\\n\\n[100,4,200,1,3,2]\\n[0,3,7,2,5,8,4,6,0,1]\\n[1,2,0,1]\\n[0]\\n[0,0]\\n[]"
                    },
                    {
                        "username": "subhadipmandalbagjuri",
                        "content": "[9,1,4,7,3,-1,0,5,8,-1,6]"
                    },
                    {
                        "username": "iChuan",
                        "content": "This is really weried to me. Hard to understand the meaning of this question."
                    },
                    {
                        "username": "tusharmathew",
                        "content": "Its not sub sequence so we dont have to maintain order"
                    },
                    {
                        "username": "amansoni22103",
                        "content": "actually we need to avoid duplicate elements here that\\'s why it is showing 3 instead of 2"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/nA5TRClw96I"
                    },
                    {
                        "username": "nareshvishram",
                        "content": "![image](https://assets.leetcode.com/users/images/c8f1a005-5f10-4957-81be-7fb5c11163dd_1596370783.9489772.png)\\n"
                    },
                    {
                        "username": "addictive_head",
                        "content": "This is O(N) solution actually.\\n1. We are iterating over all elements of hash Set O(N).\\n 2. We then are looking for elements which are starting the subsequence, then we are searching elements set(i)+1, we keep searching till we are finding them. Update the final Count if required.\\nNote that we do not iterate over same numbers again. So O(N).\\n\\ni.e.  O(2N) ~= O(N)"
                    },
                    {
                        "username": "0bro",
                        "content": "At best it O(n log n), n for iterating the entire array, then log n for sub iterating through the hash within the loop that is iterating through the passed array. The search for the O(n) is real lol"
                    },
                    {
                        "username": "ethanultra",
                        "content": "[@SunilKumawat](/SunilKumawat) how? when we iterate through again to find a starting point, we only perform the search if there are elements in the subsequence, so when we encounter another element later that\\'s part of the subsequence, we skip it, so it\\'s not O(N^2) time, it is a multiple of O(N), so O(N)"
                    },
                    {
                        "username": "bhautikkapadiya6",
                        "content": "This algo is work but it has O(n*2) complexity"
                    },
                    {
                        "username": "kamran3210",
                        "content": "[@SunilKumawat](/SunilKumawat) \n\nI may be mistaken but surely its O(N)?\n\nInitialise set with the elements: O(N)\n\nIterate over array and check if it is the start of a subsequence (does not have a predecessor): O(N)\n\nSum of  lengths of all subsequences starting from a number that doesn't have a predecessor = N, therefore countining lengths of all subsequences: O(N)\n\noverall complexity: O(N)"
                    },
                    {
                        "username": "user5062LR",
                        "content": "[@SunilKumawat](/SunilKumawat) its O(3N) ~= O(N)"
                    },
                    {
                        "username": "hardikgupta083",
                        "content": "That is not O(N)"
                    },
                    {
                        "username": "SunilKumawat",
                        "content": "this solution has 0(N^2) time complexity genius"
                    },
                    {
                        "username": "forrrjoyuri",
                        "content": "Just for the sake of comparison, I implemented a naive solution in O(n log n) that sorts the array.\\nMy solution runs in 9ms. I copypasted the best linear solutions from the top posts here and the best i got was 30ms.\\n\\nIn theory, something is wrong here. Why is it the case ?"
                    },
                    {
                        "username": "energyperformer",
                        "content": "One thing u need to remeber is Best time complexity Solution doesn\\'t necessarly mean the fastet solution every instance ,initally for small numbers of n ,even if time complexity is more it can give faster result ,but when we go for large values of n then less time complexity solution offer better time results"
                    },
                    {
                        "username": "treat",
                        "content": "[@DeclanGH](/DeclanGH) Your assumed O(N) might actually be O(N^2)"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "I think leetcode needs to add a very large testcase for this problem to make a nlogn fail"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "[@matthewjiao](/matthewjiao) You are right in theory, but if you could see my two solutions, you would see the comment i made. My first O(n) solution ran 463 ms while the nlogn ran 14ms. its really weird and i was graced to get one testcase wrong, which had 10000 as its answer (which is the largest input size). Not saying you are wrong, but the fact that my result was that way still confuses me. "
                    },
                    {
                        "username": "ixeridium",
                        "content": "E.g. with Python it can happen that using some builtin primitive (or libraries such as numpy) give very significant speedups. A factor of 100 or more is not unusual. In such situations it can happen that a O(n log n) solution is always faster than a O(n) solution for any practical input size. I.e., n log n < 100 * n for all n < exp(100)."
                    },
                    {
                        "username": "wasam1119",
                        "content": "[@matthewjiao](/matthewjiao) Accurate. Observe graphs of y = x and y = x*log(x)"
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "from my experience agr aap ek baar best runtime solution dekh lo ja kr after submission and copy pr aap submit kro then this time code not beats 100 percent submission zyada time lega \\nmay be this is leetcode feature jisse leetcode ke solution ko dekh bo dusro ke solution ko beat na kr paye jin logo ne bina ldekhe kiya hai leetcode best solution \\n"
                    },
                    {
                        "username": "matthewjiao",
                        "content": "Time complexity is not a function of speed, it\\'s a function of growth based on input size. Perhaps with smaller inputs, the linearithmic solution is faster than the linear solution, but as input grows in size, O(n) will eventually out perform O(nlogn)."
                    },
                    {
                        "username": "coolkid0006",
                        "content": "Big O notation drops constants from algorithms\\' complexity because Big O notation is concerned with asymptotic inputs (the input size heads towards infinity). The leetcode test cases aren\\'t large enough to ideally represent the asymptotic complexity, so the constants dropped off when calculating the Big O complexity can have a significant effect on runtime. For example:\\n\\nImagine 2 algorithms for a problem: one has a complexity of n^2 and one has an algorithm of n + 10000. The big O notation drops the constants, so the complexities are O(n^2) and O(n). If you work with small amounts of data the n^2 will have a much smaller runtime, but once a certain point is reached the +10000 won\\'t make much of a difference on the runtime.\\n\\nFor this leetcode problem the naive solution has a smaller runtime for inputs smaller than a certain point. This point is larger than the input sizes of the leetcode solution.\\n\\nIf your solution is at the very bottom of the time and memory leaderboard you might want to make sure it is implemented correctly, but because of the asymptotic nature of Big O notation it isn\\'t always accurate to whether it is the ideal solution."
                    },
                    {
                        "username": "Triquetra",
                        "content": "Try to plot execution time of both solutions against n = 100, 1000, 10000, ... \\u2014 maybe you will see a pattern."
                    },
                    {
                        "username": "kiyosaanb",
                        "content": "In case you are doing something like  nums[i]++ or nums[i]-- , you will encounter problems with this new test case ---> [2147483647,-2147483648]"
                    },
                    {
                        "username": "ShiqiLu77",
                        "content": "-1,000,000,000 <= nums[i] <= 1,000,000,000"
                    },
                    {
                        "username": "yis1178",
                        "content": "I think there is a restriction of the value of nums[i] -- not sure if this is lately added"
                    },
                    {
                        "username": "jasusy",
                        "content": "Is it better to need to clarify duplicate numbers not included in consecutive seq?\\n\\nFor example, if input [0, 0] should output 1, instead of 2, since no duplication counted in result.\\n\\nIf duplicate number considered, we need use HashMap instead of HashSet, and a little different in coding."
                    },
                    {
                        "username": "rubayamim381",
                        "content": "[@shanwu](/shanwu) [1,1,2,3,4] = 5"
                    },
                    {
                        "username": "user6161I",
                        "content": "[@shanwu](/shanwu) 4 ... Because Duplicates are to be treated as single."
                    },
                    {
                        "username": "khritish17",
                        "content": "duplicates should be treated as one\\ne.g : nums = [0,0,1,2,3,4,5,6,7,8] -> output: 9 ([0,1,2,3,4,5,6,7,8])"
                    },
                    {
                        "username": "shanwu",
                        "content": "I agree with you. If duplicate numbers are allowed, then what should be the answer of [100,4,200,1,1,3,2] ? It would be unclear."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/longest-consecutive-sequence/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Sorting\n\n  \n**Approach 3:** HashSet and Intelligent Sequence Building\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "PruthviChippa",
                        "content": "this deserves to be hard for o(n)"
                    },
                    {
                        "username": "Hopity",
                        "content": "for some reason it accepts o(nlogn) that\\'s why it\\'s in medium"
                    }
                ]
            },
            {
                "id": 1575709,
                "content": [
                    {
                        "username": "dghosh133",
                        "content": "How does [1,2,0,1] tc gives output as 3? It should be 2! Someone please clarify.\\n[0,1,1,2] -> has at most 2 consecutive nos."
                    },
                    {
                        "username": "TraySoek",
                        "content": "[@PrashantZuko](/PrashantZuko) yes that\\'s it"
                    },
                    {
                        "username": "dsoum",
                        "content": "[@OmarEffat](/OmarEffat) No highest sequence here is, 0,1,2,3,4,5,6,7,8 hence 9. why 10?"
                    },
                    {
                        "username": "Priyashreyas",
                        "content": "[@ironmonger1](/ironmonger1)  if thats the case, the example given above\\n Input: nums = [0,3,7,2,5,8,4,6,0,1]\\nOutput: 9 then it should be 10 and not 9 right? "
                    },
                    {
                        "username": "Priyashreyas",
                        "content": "[@Ajay_Singh9990](/Ajay_Singh9990) if thats the case, the example given above\\n Input: nums = [0,3,7,2,5,8,4,6,0,1]\\nOutput: 9 then it should be 10 and not 9 right? "
                    },
                    {
                        "username": "Rajiv_123",
                        "content": "[@Dipan Ghosh](/dghosh133) For input [0,1,1,2] Longest consecutive seq would be 0,1,2 hence answer would be 3.  We can ignore the 1 at 2nd index as you are allowed to pick numbers at random indexes such that they are consecutive."
                    },
                    {
                        "username": "OmarEffat",
                        "content": "[@geekgeekvm](/geekgeekvm)  In this case, [0,3,7,2,5,8,4,6,0,1] this should be returning 10 (Example 2)"
                    },
                    {
                        "username": "geekgeekvm",
                        "content": "This was not clear from the question, but the question seems to indicate any sequence of consecutive numbers even if there is a repition in between"
                    },
                    {
                        "username": "sh1kamaruNara",
                        "content": "0,1,2 "
                    },
                    {
                        "username": "cookieslasher",
                        "content": "I had the same question. I thought the count should break off it reaches a duplicate number. I guess this wasn\\'t obvious in the problem description."
                    },
                    {
                        "username": "PrashantZuko",
                        "content": "no,it will be 3 since 0,1,2 are all consecutive."
                    },
                    {
                        "username": "user0241F",
                        "content": "            if inputArr[l] == inputArr[l + 1] then only increase"
                    },
                    {
                        "username": "devanshumasodker357",
                        "content": "bro u forget to add 0 that\\'s why it gives 3"
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "whenever duplicates elements in array but we have to return longest sequence\\nex  (1,1,2,2,3,3.4)    answer is 4\\nbcoz hume duplicate se mtlb nahi hai 1,2,3,4, numbers hai gap 1 ka hai then duplicates ko ignore kr dege "
                    },
                    {
                        "username": "Vishal773",
                        "content": "I think duplicates numbers not counted\\n"
                    },
                    {
                        "username": "ankit528",
                        "content": "subsequence could be in any order\\n"
                    },
                    {
                        "username": "subhadipmandalbagjuri",
                        "content": "i also faced same query, but with another else if statement if got resolved"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "well 0,1,2 there\\'s your sequence"
                    },
                    {
                        "username": "user5582eQ",
                        "content": "So many solutions here claiming to be O(n) are actually either O(n^2) or O(nlogn). How can people here have such poor understanding of time complexity."
                    },
                    {
                        "username": "_Ritik_Singh_",
                        "content": "Bro there is no need to judge anyone on the basis of their solution as long as they are solving and learning so chill out and watch  yourself."
                    },
                    {
                        "username": "RealNameHidden",
                        "content": "Explain it then if you understand it so well, so people can learn"
                    },
                    {
                        "username": "dragosarsene7",
                        "content": "[@carlosfonchii](/carlosfonchii) Learn what exactly. The whole point of the problem is to not sort, otherwise it is trivial. People who use sorting barely learn something, if anything at all, they just call sort and then iterate through an array."
                    },
                    {
                        "username": "dipanshuSaini",
                        "content": "[@Rimberse](/Rimberse)  my nlogn solution is as per leetcode -> 99 % faster. So yes, nlogn solution works here perfectly fine."
                    },
                    {
                        "username": "countdankula",
                        "content": "If you use set it will never reach N^2"
                    },
                    {
                        "username": "carlosfonchii",
                        "content": "There is literally no need to come at people when everyone is here to practice and get BETTER at coding. Check yourself."
                    },
                    {
                        "username": "grave18",
                        "content": "[@Rimberse](/Rimberse) No, i am sorting nums (nlogn) and pass the submission."
                    },
                    {
                        "username": "Rimberse",
                        "content": "I actually came up with O(nlogn) solution, but it didn\\'t work. Got TLE\\nSo anything either than O(n) won\\'t actually be accepted as a solution."
                    },
                    {
                        "username": "Saurabh8720",
                        "content": "Sorry To Interrupt Sir But, The Optimised Solution Dont Have a TC of N^2 or NlogN Sorry to Say But u r Wrong, It is Just O(3N) ~= O(N) "
                    },
                    {
                        "username": "nalinnishant",
                        "content": "agree "
                    },
                    {
                        "username": "Angrydemon",
                        "content": "I think they, first try to solve the given question using brute force without considering the time complexity then they try to optimes it, and if it not works they leave the question for later!"
                    },
                    {
                        "username": "aryansuvarna",
                        "content": "lol so true"
                    },
                    {
                        "username": "user7312022",
                        "content": "You can run your code against these test cases before submisson. Hope it helps!\\n\\n[100,4,200,1,3,2]\\n[0,3,7,2,5,8,4,6,0,1]\\n[1,2,0,1]\\n[0]\\n[0,0]\\n[]"
                    },
                    {
                        "username": "subhadipmandalbagjuri",
                        "content": "[9,1,4,7,3,-1,0,5,8,-1,6]"
                    },
                    {
                        "username": "iChuan",
                        "content": "This is really weried to me. Hard to understand the meaning of this question."
                    },
                    {
                        "username": "tusharmathew",
                        "content": "Its not sub sequence so we dont have to maintain order"
                    },
                    {
                        "username": "amansoni22103",
                        "content": "actually we need to avoid duplicate elements here that\\'s why it is showing 3 instead of 2"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/nA5TRClw96I"
                    },
                    {
                        "username": "nareshvishram",
                        "content": "![image](https://assets.leetcode.com/users/images/c8f1a005-5f10-4957-81be-7fb5c11163dd_1596370783.9489772.png)\\n"
                    },
                    {
                        "username": "addictive_head",
                        "content": "This is O(N) solution actually.\\n1. We are iterating over all elements of hash Set O(N).\\n 2. We then are looking for elements which are starting the subsequence, then we are searching elements set(i)+1, we keep searching till we are finding them. Update the final Count if required.\\nNote that we do not iterate over same numbers again. So O(N).\\n\\ni.e.  O(2N) ~= O(N)"
                    },
                    {
                        "username": "0bro",
                        "content": "At best it O(n log n), n for iterating the entire array, then log n for sub iterating through the hash within the loop that is iterating through the passed array. The search for the O(n) is real lol"
                    },
                    {
                        "username": "ethanultra",
                        "content": "[@SunilKumawat](/SunilKumawat) how? when we iterate through again to find a starting point, we only perform the search if there are elements in the subsequence, so when we encounter another element later that\\'s part of the subsequence, we skip it, so it\\'s not O(N^2) time, it is a multiple of O(N), so O(N)"
                    },
                    {
                        "username": "bhautikkapadiya6",
                        "content": "This algo is work but it has O(n*2) complexity"
                    },
                    {
                        "username": "kamran3210",
                        "content": "[@SunilKumawat](/SunilKumawat) \n\nI may be mistaken but surely its O(N)?\n\nInitialise set with the elements: O(N)\n\nIterate over array and check if it is the start of a subsequence (does not have a predecessor): O(N)\n\nSum of  lengths of all subsequences starting from a number that doesn't have a predecessor = N, therefore countining lengths of all subsequences: O(N)\n\noverall complexity: O(N)"
                    },
                    {
                        "username": "user5062LR",
                        "content": "[@SunilKumawat](/SunilKumawat) its O(3N) ~= O(N)"
                    },
                    {
                        "username": "hardikgupta083",
                        "content": "That is not O(N)"
                    },
                    {
                        "username": "SunilKumawat",
                        "content": "this solution has 0(N^2) time complexity genius"
                    },
                    {
                        "username": "forrrjoyuri",
                        "content": "Just for the sake of comparison, I implemented a naive solution in O(n log n) that sorts the array.\\nMy solution runs in 9ms. I copypasted the best linear solutions from the top posts here and the best i got was 30ms.\\n\\nIn theory, something is wrong here. Why is it the case ?"
                    },
                    {
                        "username": "energyperformer",
                        "content": "One thing u need to remeber is Best time complexity Solution doesn\\'t necessarly mean the fastet solution every instance ,initally for small numbers of n ,even if time complexity is more it can give faster result ,but when we go for large values of n then less time complexity solution offer better time results"
                    },
                    {
                        "username": "treat",
                        "content": "[@DeclanGH](/DeclanGH) Your assumed O(N) might actually be O(N^2)"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "I think leetcode needs to add a very large testcase for this problem to make a nlogn fail"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "[@matthewjiao](/matthewjiao) You are right in theory, but if you could see my two solutions, you would see the comment i made. My first O(n) solution ran 463 ms while the nlogn ran 14ms. its really weird and i was graced to get one testcase wrong, which had 10000 as its answer (which is the largest input size). Not saying you are wrong, but the fact that my result was that way still confuses me. "
                    },
                    {
                        "username": "ixeridium",
                        "content": "E.g. with Python it can happen that using some builtin primitive (or libraries such as numpy) give very significant speedups. A factor of 100 or more is not unusual. In such situations it can happen that a O(n log n) solution is always faster than a O(n) solution for any practical input size. I.e., n log n < 100 * n for all n < exp(100)."
                    },
                    {
                        "username": "wasam1119",
                        "content": "[@matthewjiao](/matthewjiao) Accurate. Observe graphs of y = x and y = x*log(x)"
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "from my experience agr aap ek baar best runtime solution dekh lo ja kr after submission and copy pr aap submit kro then this time code not beats 100 percent submission zyada time lega \\nmay be this is leetcode feature jisse leetcode ke solution ko dekh bo dusro ke solution ko beat na kr paye jin logo ne bina ldekhe kiya hai leetcode best solution \\n"
                    },
                    {
                        "username": "matthewjiao",
                        "content": "Time complexity is not a function of speed, it\\'s a function of growth based on input size. Perhaps with smaller inputs, the linearithmic solution is faster than the linear solution, but as input grows in size, O(n) will eventually out perform O(nlogn)."
                    },
                    {
                        "username": "coolkid0006",
                        "content": "Big O notation drops constants from algorithms\\' complexity because Big O notation is concerned with asymptotic inputs (the input size heads towards infinity). The leetcode test cases aren\\'t large enough to ideally represent the asymptotic complexity, so the constants dropped off when calculating the Big O complexity can have a significant effect on runtime. For example:\\n\\nImagine 2 algorithms for a problem: one has a complexity of n^2 and one has an algorithm of n + 10000. The big O notation drops the constants, so the complexities are O(n^2) and O(n). If you work with small amounts of data the n^2 will have a much smaller runtime, but once a certain point is reached the +10000 won\\'t make much of a difference on the runtime.\\n\\nFor this leetcode problem the naive solution has a smaller runtime for inputs smaller than a certain point. This point is larger than the input sizes of the leetcode solution.\\n\\nIf your solution is at the very bottom of the time and memory leaderboard you might want to make sure it is implemented correctly, but because of the asymptotic nature of Big O notation it isn\\'t always accurate to whether it is the ideal solution."
                    },
                    {
                        "username": "Triquetra",
                        "content": "Try to plot execution time of both solutions against n = 100, 1000, 10000, ... \\u2014 maybe you will see a pattern."
                    },
                    {
                        "username": "kiyosaanb",
                        "content": "In case you are doing something like  nums[i]++ or nums[i]-- , you will encounter problems with this new test case ---> [2147483647,-2147483648]"
                    },
                    {
                        "username": "ShiqiLu77",
                        "content": "-1,000,000,000 <= nums[i] <= 1,000,000,000"
                    },
                    {
                        "username": "yis1178",
                        "content": "I think there is a restriction of the value of nums[i] -- not sure if this is lately added"
                    },
                    {
                        "username": "jasusy",
                        "content": "Is it better to need to clarify duplicate numbers not included in consecutive seq?\\n\\nFor example, if input [0, 0] should output 1, instead of 2, since no duplication counted in result.\\n\\nIf duplicate number considered, we need use HashMap instead of HashSet, and a little different in coding."
                    },
                    {
                        "username": "rubayamim381",
                        "content": "[@shanwu](/shanwu) [1,1,2,3,4] = 5"
                    },
                    {
                        "username": "user6161I",
                        "content": "[@shanwu](/shanwu) 4 ... Because Duplicates are to be treated as single."
                    },
                    {
                        "username": "khritish17",
                        "content": "duplicates should be treated as one\\ne.g : nums = [0,0,1,2,3,4,5,6,7,8] -> output: 9 ([0,1,2,3,4,5,6,7,8])"
                    },
                    {
                        "username": "shanwu",
                        "content": "I agree with you. If duplicate numbers are allowed, then what should be the answer of [100,4,200,1,1,3,2] ? It would be unclear."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/longest-consecutive-sequence/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Sorting\n\n  \n**Approach 3:** HashSet and Intelligent Sequence Building\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "PruthviChippa",
                        "content": "this deserves to be hard for o(n)"
                    },
                    {
                        "username": "Hopity",
                        "content": "for some reason it accepts o(nlogn) that\\'s why it\\'s in medium"
                    }
                ]
            },
            {
                "id": 1566994,
                "content": [
                    {
                        "username": "dghosh133",
                        "content": "How does [1,2,0,1] tc gives output as 3? It should be 2! Someone please clarify.\\n[0,1,1,2] -> has at most 2 consecutive nos."
                    },
                    {
                        "username": "TraySoek",
                        "content": "[@PrashantZuko](/PrashantZuko) yes that\\'s it"
                    },
                    {
                        "username": "dsoum",
                        "content": "[@OmarEffat](/OmarEffat) No highest sequence here is, 0,1,2,3,4,5,6,7,8 hence 9. why 10?"
                    },
                    {
                        "username": "Priyashreyas",
                        "content": "[@ironmonger1](/ironmonger1)  if thats the case, the example given above\\n Input: nums = [0,3,7,2,5,8,4,6,0,1]\\nOutput: 9 then it should be 10 and not 9 right? "
                    },
                    {
                        "username": "Priyashreyas",
                        "content": "[@Ajay_Singh9990](/Ajay_Singh9990) if thats the case, the example given above\\n Input: nums = [0,3,7,2,5,8,4,6,0,1]\\nOutput: 9 then it should be 10 and not 9 right? "
                    },
                    {
                        "username": "Rajiv_123",
                        "content": "[@Dipan Ghosh](/dghosh133) For input [0,1,1,2] Longest consecutive seq would be 0,1,2 hence answer would be 3.  We can ignore the 1 at 2nd index as you are allowed to pick numbers at random indexes such that they are consecutive."
                    },
                    {
                        "username": "OmarEffat",
                        "content": "[@geekgeekvm](/geekgeekvm)  In this case, [0,3,7,2,5,8,4,6,0,1] this should be returning 10 (Example 2)"
                    },
                    {
                        "username": "geekgeekvm",
                        "content": "This was not clear from the question, but the question seems to indicate any sequence of consecutive numbers even if there is a repition in between"
                    },
                    {
                        "username": "sh1kamaruNara",
                        "content": "0,1,2 "
                    },
                    {
                        "username": "cookieslasher",
                        "content": "I had the same question. I thought the count should break off it reaches a duplicate number. I guess this wasn\\'t obvious in the problem description."
                    },
                    {
                        "username": "PrashantZuko",
                        "content": "no,it will be 3 since 0,1,2 are all consecutive."
                    },
                    {
                        "username": "user0241F",
                        "content": "            if inputArr[l] == inputArr[l + 1] then only increase"
                    },
                    {
                        "username": "devanshumasodker357",
                        "content": "bro u forget to add 0 that\\'s why it gives 3"
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "whenever duplicates elements in array but we have to return longest sequence\\nex  (1,1,2,2,3,3.4)    answer is 4\\nbcoz hume duplicate se mtlb nahi hai 1,2,3,4, numbers hai gap 1 ka hai then duplicates ko ignore kr dege "
                    },
                    {
                        "username": "Vishal773",
                        "content": "I think duplicates numbers not counted\\n"
                    },
                    {
                        "username": "ankit528",
                        "content": "subsequence could be in any order\\n"
                    },
                    {
                        "username": "subhadipmandalbagjuri",
                        "content": "i also faced same query, but with another else if statement if got resolved"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "well 0,1,2 there\\'s your sequence"
                    },
                    {
                        "username": "user5582eQ",
                        "content": "So many solutions here claiming to be O(n) are actually either O(n^2) or O(nlogn). How can people here have such poor understanding of time complexity."
                    },
                    {
                        "username": "_Ritik_Singh_",
                        "content": "Bro there is no need to judge anyone on the basis of their solution as long as they are solving and learning so chill out and watch  yourself."
                    },
                    {
                        "username": "RealNameHidden",
                        "content": "Explain it then if you understand it so well, so people can learn"
                    },
                    {
                        "username": "dragosarsene7",
                        "content": "[@carlosfonchii](/carlosfonchii) Learn what exactly. The whole point of the problem is to not sort, otherwise it is trivial. People who use sorting barely learn something, if anything at all, they just call sort and then iterate through an array."
                    },
                    {
                        "username": "dipanshuSaini",
                        "content": "[@Rimberse](/Rimberse)  my nlogn solution is as per leetcode -> 99 % faster. So yes, nlogn solution works here perfectly fine."
                    },
                    {
                        "username": "countdankula",
                        "content": "If you use set it will never reach N^2"
                    },
                    {
                        "username": "carlosfonchii",
                        "content": "There is literally no need to come at people when everyone is here to practice and get BETTER at coding. Check yourself."
                    },
                    {
                        "username": "grave18",
                        "content": "[@Rimberse](/Rimberse) No, i am sorting nums (nlogn) and pass the submission."
                    },
                    {
                        "username": "Rimberse",
                        "content": "I actually came up with O(nlogn) solution, but it didn\\'t work. Got TLE\\nSo anything either than O(n) won\\'t actually be accepted as a solution."
                    },
                    {
                        "username": "Saurabh8720",
                        "content": "Sorry To Interrupt Sir But, The Optimised Solution Dont Have a TC of N^2 or NlogN Sorry to Say But u r Wrong, It is Just O(3N) ~= O(N) "
                    },
                    {
                        "username": "nalinnishant",
                        "content": "agree "
                    },
                    {
                        "username": "Angrydemon",
                        "content": "I think they, first try to solve the given question using brute force without considering the time complexity then they try to optimes it, and if it not works they leave the question for later!"
                    },
                    {
                        "username": "aryansuvarna",
                        "content": "lol so true"
                    },
                    {
                        "username": "user7312022",
                        "content": "You can run your code against these test cases before submisson. Hope it helps!\\n\\n[100,4,200,1,3,2]\\n[0,3,7,2,5,8,4,6,0,1]\\n[1,2,0,1]\\n[0]\\n[0,0]\\n[]"
                    },
                    {
                        "username": "subhadipmandalbagjuri",
                        "content": "[9,1,4,7,3,-1,0,5,8,-1,6]"
                    },
                    {
                        "username": "iChuan",
                        "content": "This is really weried to me. Hard to understand the meaning of this question."
                    },
                    {
                        "username": "tusharmathew",
                        "content": "Its not sub sequence so we dont have to maintain order"
                    },
                    {
                        "username": "amansoni22103",
                        "content": "actually we need to avoid duplicate elements here that\\'s why it is showing 3 instead of 2"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/nA5TRClw96I"
                    },
                    {
                        "username": "nareshvishram",
                        "content": "![image](https://assets.leetcode.com/users/images/c8f1a005-5f10-4957-81be-7fb5c11163dd_1596370783.9489772.png)\\n"
                    },
                    {
                        "username": "addictive_head",
                        "content": "This is O(N) solution actually.\\n1. We are iterating over all elements of hash Set O(N).\\n 2. We then are looking for elements which are starting the subsequence, then we are searching elements set(i)+1, we keep searching till we are finding them. Update the final Count if required.\\nNote that we do not iterate over same numbers again. So O(N).\\n\\ni.e.  O(2N) ~= O(N)"
                    },
                    {
                        "username": "0bro",
                        "content": "At best it O(n log n), n for iterating the entire array, then log n for sub iterating through the hash within the loop that is iterating through the passed array. The search for the O(n) is real lol"
                    },
                    {
                        "username": "ethanultra",
                        "content": "[@SunilKumawat](/SunilKumawat) how? when we iterate through again to find a starting point, we only perform the search if there are elements in the subsequence, so when we encounter another element later that\\'s part of the subsequence, we skip it, so it\\'s not O(N^2) time, it is a multiple of O(N), so O(N)"
                    },
                    {
                        "username": "bhautikkapadiya6",
                        "content": "This algo is work but it has O(n*2) complexity"
                    },
                    {
                        "username": "kamran3210",
                        "content": "[@SunilKumawat](/SunilKumawat) \n\nI may be mistaken but surely its O(N)?\n\nInitialise set with the elements: O(N)\n\nIterate over array and check if it is the start of a subsequence (does not have a predecessor): O(N)\n\nSum of  lengths of all subsequences starting from a number that doesn't have a predecessor = N, therefore countining lengths of all subsequences: O(N)\n\noverall complexity: O(N)"
                    },
                    {
                        "username": "user5062LR",
                        "content": "[@SunilKumawat](/SunilKumawat) its O(3N) ~= O(N)"
                    },
                    {
                        "username": "hardikgupta083",
                        "content": "That is not O(N)"
                    },
                    {
                        "username": "SunilKumawat",
                        "content": "this solution has 0(N^2) time complexity genius"
                    },
                    {
                        "username": "forrrjoyuri",
                        "content": "Just for the sake of comparison, I implemented a naive solution in O(n log n) that sorts the array.\\nMy solution runs in 9ms. I copypasted the best linear solutions from the top posts here and the best i got was 30ms.\\n\\nIn theory, something is wrong here. Why is it the case ?"
                    },
                    {
                        "username": "energyperformer",
                        "content": "One thing u need to remeber is Best time complexity Solution doesn\\'t necessarly mean the fastet solution every instance ,initally for small numbers of n ,even if time complexity is more it can give faster result ,but when we go for large values of n then less time complexity solution offer better time results"
                    },
                    {
                        "username": "treat",
                        "content": "[@DeclanGH](/DeclanGH) Your assumed O(N) might actually be O(N^2)"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "I think leetcode needs to add a very large testcase for this problem to make a nlogn fail"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "[@matthewjiao](/matthewjiao) You are right in theory, but if you could see my two solutions, you would see the comment i made. My first O(n) solution ran 463 ms while the nlogn ran 14ms. its really weird and i was graced to get one testcase wrong, which had 10000 as its answer (which is the largest input size). Not saying you are wrong, but the fact that my result was that way still confuses me. "
                    },
                    {
                        "username": "ixeridium",
                        "content": "E.g. with Python it can happen that using some builtin primitive (or libraries such as numpy) give very significant speedups. A factor of 100 or more is not unusual. In such situations it can happen that a O(n log n) solution is always faster than a O(n) solution for any practical input size. I.e., n log n < 100 * n for all n < exp(100)."
                    },
                    {
                        "username": "wasam1119",
                        "content": "[@matthewjiao](/matthewjiao) Accurate. Observe graphs of y = x and y = x*log(x)"
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "from my experience agr aap ek baar best runtime solution dekh lo ja kr after submission and copy pr aap submit kro then this time code not beats 100 percent submission zyada time lega \\nmay be this is leetcode feature jisse leetcode ke solution ko dekh bo dusro ke solution ko beat na kr paye jin logo ne bina ldekhe kiya hai leetcode best solution \\n"
                    },
                    {
                        "username": "matthewjiao",
                        "content": "Time complexity is not a function of speed, it\\'s a function of growth based on input size. Perhaps with smaller inputs, the linearithmic solution is faster than the linear solution, but as input grows in size, O(n) will eventually out perform O(nlogn)."
                    },
                    {
                        "username": "coolkid0006",
                        "content": "Big O notation drops constants from algorithms\\' complexity because Big O notation is concerned with asymptotic inputs (the input size heads towards infinity). The leetcode test cases aren\\'t large enough to ideally represent the asymptotic complexity, so the constants dropped off when calculating the Big O complexity can have a significant effect on runtime. For example:\\n\\nImagine 2 algorithms for a problem: one has a complexity of n^2 and one has an algorithm of n + 10000. The big O notation drops the constants, so the complexities are O(n^2) and O(n). If you work with small amounts of data the n^2 will have a much smaller runtime, but once a certain point is reached the +10000 won\\'t make much of a difference on the runtime.\\n\\nFor this leetcode problem the naive solution has a smaller runtime for inputs smaller than a certain point. This point is larger than the input sizes of the leetcode solution.\\n\\nIf your solution is at the very bottom of the time and memory leaderboard you might want to make sure it is implemented correctly, but because of the asymptotic nature of Big O notation it isn\\'t always accurate to whether it is the ideal solution."
                    },
                    {
                        "username": "Triquetra",
                        "content": "Try to plot execution time of both solutions against n = 100, 1000, 10000, ... \\u2014 maybe you will see a pattern."
                    },
                    {
                        "username": "kiyosaanb",
                        "content": "In case you are doing something like  nums[i]++ or nums[i]-- , you will encounter problems with this new test case ---> [2147483647,-2147483648]"
                    },
                    {
                        "username": "ShiqiLu77",
                        "content": "-1,000,000,000 <= nums[i] <= 1,000,000,000"
                    },
                    {
                        "username": "yis1178",
                        "content": "I think there is a restriction of the value of nums[i] -- not sure if this is lately added"
                    },
                    {
                        "username": "jasusy",
                        "content": "Is it better to need to clarify duplicate numbers not included in consecutive seq?\\n\\nFor example, if input [0, 0] should output 1, instead of 2, since no duplication counted in result.\\n\\nIf duplicate number considered, we need use HashMap instead of HashSet, and a little different in coding."
                    },
                    {
                        "username": "rubayamim381",
                        "content": "[@shanwu](/shanwu) [1,1,2,3,4] = 5"
                    },
                    {
                        "username": "user6161I",
                        "content": "[@shanwu](/shanwu) 4 ... Because Duplicates are to be treated as single."
                    },
                    {
                        "username": "khritish17",
                        "content": "duplicates should be treated as one\\ne.g : nums = [0,0,1,2,3,4,5,6,7,8] -> output: 9 ([0,1,2,3,4,5,6,7,8])"
                    },
                    {
                        "username": "shanwu",
                        "content": "I agree with you. If duplicate numbers are allowed, then what should be the answer of [100,4,200,1,1,3,2] ? It would be unclear."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/longest-consecutive-sequence/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Sorting\n\n  \n**Approach 3:** HashSet and Intelligent Sequence Building\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "PruthviChippa",
                        "content": "this deserves to be hard for o(n)"
                    },
                    {
                        "username": "Hopity",
                        "content": "for some reason it accepts o(nlogn) that\\'s why it\\'s in medium"
                    }
                ]
            },
            {
                "id": 1567206,
                "content": [
                    {
                        "username": "dghosh133",
                        "content": "How does [1,2,0,1] tc gives output as 3? It should be 2! Someone please clarify.\\n[0,1,1,2] -> has at most 2 consecutive nos."
                    },
                    {
                        "username": "TraySoek",
                        "content": "[@PrashantZuko](/PrashantZuko) yes that\\'s it"
                    },
                    {
                        "username": "dsoum",
                        "content": "[@OmarEffat](/OmarEffat) No highest sequence here is, 0,1,2,3,4,5,6,7,8 hence 9. why 10?"
                    },
                    {
                        "username": "Priyashreyas",
                        "content": "[@ironmonger1](/ironmonger1)  if thats the case, the example given above\\n Input: nums = [0,3,7,2,5,8,4,6,0,1]\\nOutput: 9 then it should be 10 and not 9 right? "
                    },
                    {
                        "username": "Priyashreyas",
                        "content": "[@Ajay_Singh9990](/Ajay_Singh9990) if thats the case, the example given above\\n Input: nums = [0,3,7,2,5,8,4,6,0,1]\\nOutput: 9 then it should be 10 and not 9 right? "
                    },
                    {
                        "username": "Rajiv_123",
                        "content": "[@Dipan Ghosh](/dghosh133) For input [0,1,1,2] Longest consecutive seq would be 0,1,2 hence answer would be 3.  We can ignore the 1 at 2nd index as you are allowed to pick numbers at random indexes such that they are consecutive."
                    },
                    {
                        "username": "OmarEffat",
                        "content": "[@geekgeekvm](/geekgeekvm)  In this case, [0,3,7,2,5,8,4,6,0,1] this should be returning 10 (Example 2)"
                    },
                    {
                        "username": "geekgeekvm",
                        "content": "This was not clear from the question, but the question seems to indicate any sequence of consecutive numbers even if there is a repition in between"
                    },
                    {
                        "username": "sh1kamaruNara",
                        "content": "0,1,2 "
                    },
                    {
                        "username": "cookieslasher",
                        "content": "I had the same question. I thought the count should break off it reaches a duplicate number. I guess this wasn\\'t obvious in the problem description."
                    },
                    {
                        "username": "PrashantZuko",
                        "content": "no,it will be 3 since 0,1,2 are all consecutive."
                    },
                    {
                        "username": "user0241F",
                        "content": "            if inputArr[l] == inputArr[l + 1] then only increase"
                    },
                    {
                        "username": "devanshumasodker357",
                        "content": "bro u forget to add 0 that\\'s why it gives 3"
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "whenever duplicates elements in array but we have to return longest sequence\\nex  (1,1,2,2,3,3.4)    answer is 4\\nbcoz hume duplicate se mtlb nahi hai 1,2,3,4, numbers hai gap 1 ka hai then duplicates ko ignore kr dege "
                    },
                    {
                        "username": "Vishal773",
                        "content": "I think duplicates numbers not counted\\n"
                    },
                    {
                        "username": "ankit528",
                        "content": "subsequence could be in any order\\n"
                    },
                    {
                        "username": "subhadipmandalbagjuri",
                        "content": "i also faced same query, but with another else if statement if got resolved"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "well 0,1,2 there\\'s your sequence"
                    },
                    {
                        "username": "user5582eQ",
                        "content": "So many solutions here claiming to be O(n) are actually either O(n^2) or O(nlogn). How can people here have such poor understanding of time complexity."
                    },
                    {
                        "username": "_Ritik_Singh_",
                        "content": "Bro there is no need to judge anyone on the basis of their solution as long as they are solving and learning so chill out and watch  yourself."
                    },
                    {
                        "username": "RealNameHidden",
                        "content": "Explain it then if you understand it so well, so people can learn"
                    },
                    {
                        "username": "dragosarsene7",
                        "content": "[@carlosfonchii](/carlosfonchii) Learn what exactly. The whole point of the problem is to not sort, otherwise it is trivial. People who use sorting barely learn something, if anything at all, they just call sort and then iterate through an array."
                    },
                    {
                        "username": "dipanshuSaini",
                        "content": "[@Rimberse](/Rimberse)  my nlogn solution is as per leetcode -> 99 % faster. So yes, nlogn solution works here perfectly fine."
                    },
                    {
                        "username": "countdankula",
                        "content": "If you use set it will never reach N^2"
                    },
                    {
                        "username": "carlosfonchii",
                        "content": "There is literally no need to come at people when everyone is here to practice and get BETTER at coding. Check yourself."
                    },
                    {
                        "username": "grave18",
                        "content": "[@Rimberse](/Rimberse) No, i am sorting nums (nlogn) and pass the submission."
                    },
                    {
                        "username": "Rimberse",
                        "content": "I actually came up with O(nlogn) solution, but it didn\\'t work. Got TLE\\nSo anything either than O(n) won\\'t actually be accepted as a solution."
                    },
                    {
                        "username": "Saurabh8720",
                        "content": "Sorry To Interrupt Sir But, The Optimised Solution Dont Have a TC of N^2 or NlogN Sorry to Say But u r Wrong, It is Just O(3N) ~= O(N) "
                    },
                    {
                        "username": "nalinnishant",
                        "content": "agree "
                    },
                    {
                        "username": "Angrydemon",
                        "content": "I think they, first try to solve the given question using brute force without considering the time complexity then they try to optimes it, and if it not works they leave the question for later!"
                    },
                    {
                        "username": "aryansuvarna",
                        "content": "lol so true"
                    },
                    {
                        "username": "user7312022",
                        "content": "You can run your code against these test cases before submisson. Hope it helps!\\n\\n[100,4,200,1,3,2]\\n[0,3,7,2,5,8,4,6,0,1]\\n[1,2,0,1]\\n[0]\\n[0,0]\\n[]"
                    },
                    {
                        "username": "subhadipmandalbagjuri",
                        "content": "[9,1,4,7,3,-1,0,5,8,-1,6]"
                    },
                    {
                        "username": "iChuan",
                        "content": "This is really weried to me. Hard to understand the meaning of this question."
                    },
                    {
                        "username": "tusharmathew",
                        "content": "Its not sub sequence so we dont have to maintain order"
                    },
                    {
                        "username": "amansoni22103",
                        "content": "actually we need to avoid duplicate elements here that\\'s why it is showing 3 instead of 2"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/nA5TRClw96I"
                    },
                    {
                        "username": "nareshvishram",
                        "content": "![image](https://assets.leetcode.com/users/images/c8f1a005-5f10-4957-81be-7fb5c11163dd_1596370783.9489772.png)\\n"
                    },
                    {
                        "username": "addictive_head",
                        "content": "This is O(N) solution actually.\\n1. We are iterating over all elements of hash Set O(N).\\n 2. We then are looking for elements which are starting the subsequence, then we are searching elements set(i)+1, we keep searching till we are finding them. Update the final Count if required.\\nNote that we do not iterate over same numbers again. So O(N).\\n\\ni.e.  O(2N) ~= O(N)"
                    },
                    {
                        "username": "0bro",
                        "content": "At best it O(n log n), n for iterating the entire array, then log n for sub iterating through the hash within the loop that is iterating through the passed array. The search for the O(n) is real lol"
                    },
                    {
                        "username": "ethanultra",
                        "content": "[@SunilKumawat](/SunilKumawat) how? when we iterate through again to find a starting point, we only perform the search if there are elements in the subsequence, so when we encounter another element later that\\'s part of the subsequence, we skip it, so it\\'s not O(N^2) time, it is a multiple of O(N), so O(N)"
                    },
                    {
                        "username": "bhautikkapadiya6",
                        "content": "This algo is work but it has O(n*2) complexity"
                    },
                    {
                        "username": "kamran3210",
                        "content": "[@SunilKumawat](/SunilKumawat) \n\nI may be mistaken but surely its O(N)?\n\nInitialise set with the elements: O(N)\n\nIterate over array and check if it is the start of a subsequence (does not have a predecessor): O(N)\n\nSum of  lengths of all subsequences starting from a number that doesn't have a predecessor = N, therefore countining lengths of all subsequences: O(N)\n\noverall complexity: O(N)"
                    },
                    {
                        "username": "user5062LR",
                        "content": "[@SunilKumawat](/SunilKumawat) its O(3N) ~= O(N)"
                    },
                    {
                        "username": "hardikgupta083",
                        "content": "That is not O(N)"
                    },
                    {
                        "username": "SunilKumawat",
                        "content": "this solution has 0(N^2) time complexity genius"
                    },
                    {
                        "username": "forrrjoyuri",
                        "content": "Just for the sake of comparison, I implemented a naive solution in O(n log n) that sorts the array.\\nMy solution runs in 9ms. I copypasted the best linear solutions from the top posts here and the best i got was 30ms.\\n\\nIn theory, something is wrong here. Why is it the case ?"
                    },
                    {
                        "username": "energyperformer",
                        "content": "One thing u need to remeber is Best time complexity Solution doesn\\'t necessarly mean the fastet solution every instance ,initally for small numbers of n ,even if time complexity is more it can give faster result ,but when we go for large values of n then less time complexity solution offer better time results"
                    },
                    {
                        "username": "treat",
                        "content": "[@DeclanGH](/DeclanGH) Your assumed O(N) might actually be O(N^2)"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "I think leetcode needs to add a very large testcase for this problem to make a nlogn fail"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "[@matthewjiao](/matthewjiao) You are right in theory, but if you could see my two solutions, you would see the comment i made. My first O(n) solution ran 463 ms while the nlogn ran 14ms. its really weird and i was graced to get one testcase wrong, which had 10000 as its answer (which is the largest input size). Not saying you are wrong, but the fact that my result was that way still confuses me. "
                    },
                    {
                        "username": "ixeridium",
                        "content": "E.g. with Python it can happen that using some builtin primitive (or libraries such as numpy) give very significant speedups. A factor of 100 or more is not unusual. In such situations it can happen that a O(n log n) solution is always faster than a O(n) solution for any practical input size. I.e., n log n < 100 * n for all n < exp(100)."
                    },
                    {
                        "username": "wasam1119",
                        "content": "[@matthewjiao](/matthewjiao) Accurate. Observe graphs of y = x and y = x*log(x)"
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "from my experience agr aap ek baar best runtime solution dekh lo ja kr after submission and copy pr aap submit kro then this time code not beats 100 percent submission zyada time lega \\nmay be this is leetcode feature jisse leetcode ke solution ko dekh bo dusro ke solution ko beat na kr paye jin logo ne bina ldekhe kiya hai leetcode best solution \\n"
                    },
                    {
                        "username": "matthewjiao",
                        "content": "Time complexity is not a function of speed, it\\'s a function of growth based on input size. Perhaps with smaller inputs, the linearithmic solution is faster than the linear solution, but as input grows in size, O(n) will eventually out perform O(nlogn)."
                    },
                    {
                        "username": "coolkid0006",
                        "content": "Big O notation drops constants from algorithms\\' complexity because Big O notation is concerned with asymptotic inputs (the input size heads towards infinity). The leetcode test cases aren\\'t large enough to ideally represent the asymptotic complexity, so the constants dropped off when calculating the Big O complexity can have a significant effect on runtime. For example:\\n\\nImagine 2 algorithms for a problem: one has a complexity of n^2 and one has an algorithm of n + 10000. The big O notation drops the constants, so the complexities are O(n^2) and O(n). If you work with small amounts of data the n^2 will have a much smaller runtime, but once a certain point is reached the +10000 won\\'t make much of a difference on the runtime.\\n\\nFor this leetcode problem the naive solution has a smaller runtime for inputs smaller than a certain point. This point is larger than the input sizes of the leetcode solution.\\n\\nIf your solution is at the very bottom of the time and memory leaderboard you might want to make sure it is implemented correctly, but because of the asymptotic nature of Big O notation it isn\\'t always accurate to whether it is the ideal solution."
                    },
                    {
                        "username": "Triquetra",
                        "content": "Try to plot execution time of both solutions against n = 100, 1000, 10000, ... \\u2014 maybe you will see a pattern."
                    },
                    {
                        "username": "kiyosaanb",
                        "content": "In case you are doing something like  nums[i]++ or nums[i]-- , you will encounter problems with this new test case ---> [2147483647,-2147483648]"
                    },
                    {
                        "username": "ShiqiLu77",
                        "content": "-1,000,000,000 <= nums[i] <= 1,000,000,000"
                    },
                    {
                        "username": "yis1178",
                        "content": "I think there is a restriction of the value of nums[i] -- not sure if this is lately added"
                    },
                    {
                        "username": "jasusy",
                        "content": "Is it better to need to clarify duplicate numbers not included in consecutive seq?\\n\\nFor example, if input [0, 0] should output 1, instead of 2, since no duplication counted in result.\\n\\nIf duplicate number considered, we need use HashMap instead of HashSet, and a little different in coding."
                    },
                    {
                        "username": "rubayamim381",
                        "content": "[@shanwu](/shanwu) [1,1,2,3,4] = 5"
                    },
                    {
                        "username": "user6161I",
                        "content": "[@shanwu](/shanwu) 4 ... Because Duplicates are to be treated as single."
                    },
                    {
                        "username": "khritish17",
                        "content": "duplicates should be treated as one\\ne.g : nums = [0,0,1,2,3,4,5,6,7,8] -> output: 9 ([0,1,2,3,4,5,6,7,8])"
                    },
                    {
                        "username": "shanwu",
                        "content": "I agree with you. If duplicate numbers are allowed, then what should be the answer of [100,4,200,1,1,3,2] ? It would be unclear."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/longest-consecutive-sequence/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Sorting\n\n  \n**Approach 3:** HashSet and Intelligent Sequence Building\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "PruthviChippa",
                        "content": "this deserves to be hard for o(n)"
                    },
                    {
                        "username": "Hopity",
                        "content": "for some reason it accepts o(nlogn) that\\'s why it\\'s in medium"
                    }
                ]
            },
            {
                "id": 1566228,
                "content": [
                    {
                        "username": "dghosh133",
                        "content": "How does [1,2,0,1] tc gives output as 3? It should be 2! Someone please clarify.\\n[0,1,1,2] -> has at most 2 consecutive nos."
                    },
                    {
                        "username": "TraySoek",
                        "content": "[@PrashantZuko](/PrashantZuko) yes that\\'s it"
                    },
                    {
                        "username": "dsoum",
                        "content": "[@OmarEffat](/OmarEffat) No highest sequence here is, 0,1,2,3,4,5,6,7,8 hence 9. why 10?"
                    },
                    {
                        "username": "Priyashreyas",
                        "content": "[@ironmonger1](/ironmonger1)  if thats the case, the example given above\\n Input: nums = [0,3,7,2,5,8,4,6,0,1]\\nOutput: 9 then it should be 10 and not 9 right? "
                    },
                    {
                        "username": "Priyashreyas",
                        "content": "[@Ajay_Singh9990](/Ajay_Singh9990) if thats the case, the example given above\\n Input: nums = [0,3,7,2,5,8,4,6,0,1]\\nOutput: 9 then it should be 10 and not 9 right? "
                    },
                    {
                        "username": "Rajiv_123",
                        "content": "[@Dipan Ghosh](/dghosh133) For input [0,1,1,2] Longest consecutive seq would be 0,1,2 hence answer would be 3.  We can ignore the 1 at 2nd index as you are allowed to pick numbers at random indexes such that they are consecutive."
                    },
                    {
                        "username": "OmarEffat",
                        "content": "[@geekgeekvm](/geekgeekvm)  In this case, [0,3,7,2,5,8,4,6,0,1] this should be returning 10 (Example 2)"
                    },
                    {
                        "username": "geekgeekvm",
                        "content": "This was not clear from the question, but the question seems to indicate any sequence of consecutive numbers even if there is a repition in between"
                    },
                    {
                        "username": "sh1kamaruNara",
                        "content": "0,1,2 "
                    },
                    {
                        "username": "cookieslasher",
                        "content": "I had the same question. I thought the count should break off it reaches a duplicate number. I guess this wasn\\'t obvious in the problem description."
                    },
                    {
                        "username": "PrashantZuko",
                        "content": "no,it will be 3 since 0,1,2 are all consecutive."
                    },
                    {
                        "username": "user0241F",
                        "content": "            if inputArr[l] == inputArr[l + 1] then only increase"
                    },
                    {
                        "username": "devanshumasodker357",
                        "content": "bro u forget to add 0 that\\'s why it gives 3"
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "whenever duplicates elements in array but we have to return longest sequence\\nex  (1,1,2,2,3,3.4)    answer is 4\\nbcoz hume duplicate se mtlb nahi hai 1,2,3,4, numbers hai gap 1 ka hai then duplicates ko ignore kr dege "
                    },
                    {
                        "username": "Vishal773",
                        "content": "I think duplicates numbers not counted\\n"
                    },
                    {
                        "username": "ankit528",
                        "content": "subsequence could be in any order\\n"
                    },
                    {
                        "username": "subhadipmandalbagjuri",
                        "content": "i also faced same query, but with another else if statement if got resolved"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "well 0,1,2 there\\'s your sequence"
                    },
                    {
                        "username": "user5582eQ",
                        "content": "So many solutions here claiming to be O(n) are actually either O(n^2) or O(nlogn). How can people here have such poor understanding of time complexity."
                    },
                    {
                        "username": "_Ritik_Singh_",
                        "content": "Bro there is no need to judge anyone on the basis of their solution as long as they are solving and learning so chill out and watch  yourself."
                    },
                    {
                        "username": "RealNameHidden",
                        "content": "Explain it then if you understand it so well, so people can learn"
                    },
                    {
                        "username": "dragosarsene7",
                        "content": "[@carlosfonchii](/carlosfonchii) Learn what exactly. The whole point of the problem is to not sort, otherwise it is trivial. People who use sorting barely learn something, if anything at all, they just call sort and then iterate through an array."
                    },
                    {
                        "username": "dipanshuSaini",
                        "content": "[@Rimberse](/Rimberse)  my nlogn solution is as per leetcode -> 99 % faster. So yes, nlogn solution works here perfectly fine."
                    },
                    {
                        "username": "countdankula",
                        "content": "If you use set it will never reach N^2"
                    },
                    {
                        "username": "carlosfonchii",
                        "content": "There is literally no need to come at people when everyone is here to practice and get BETTER at coding. Check yourself."
                    },
                    {
                        "username": "grave18",
                        "content": "[@Rimberse](/Rimberse) No, i am sorting nums (nlogn) and pass the submission."
                    },
                    {
                        "username": "Rimberse",
                        "content": "I actually came up with O(nlogn) solution, but it didn\\'t work. Got TLE\\nSo anything either than O(n) won\\'t actually be accepted as a solution."
                    },
                    {
                        "username": "Saurabh8720",
                        "content": "Sorry To Interrupt Sir But, The Optimised Solution Dont Have a TC of N^2 or NlogN Sorry to Say But u r Wrong, It is Just O(3N) ~= O(N) "
                    },
                    {
                        "username": "nalinnishant",
                        "content": "agree "
                    },
                    {
                        "username": "Angrydemon",
                        "content": "I think they, first try to solve the given question using brute force without considering the time complexity then they try to optimes it, and if it not works they leave the question for later!"
                    },
                    {
                        "username": "aryansuvarna",
                        "content": "lol so true"
                    },
                    {
                        "username": "user7312022",
                        "content": "You can run your code against these test cases before submisson. Hope it helps!\\n\\n[100,4,200,1,3,2]\\n[0,3,7,2,5,8,4,6,0,1]\\n[1,2,0,1]\\n[0]\\n[0,0]\\n[]"
                    },
                    {
                        "username": "subhadipmandalbagjuri",
                        "content": "[9,1,4,7,3,-1,0,5,8,-1,6]"
                    },
                    {
                        "username": "iChuan",
                        "content": "This is really weried to me. Hard to understand the meaning of this question."
                    },
                    {
                        "username": "tusharmathew",
                        "content": "Its not sub sequence so we dont have to maintain order"
                    },
                    {
                        "username": "amansoni22103",
                        "content": "actually we need to avoid duplicate elements here that\\'s why it is showing 3 instead of 2"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/nA5TRClw96I"
                    },
                    {
                        "username": "nareshvishram",
                        "content": "![image](https://assets.leetcode.com/users/images/c8f1a005-5f10-4957-81be-7fb5c11163dd_1596370783.9489772.png)\\n"
                    },
                    {
                        "username": "addictive_head",
                        "content": "This is O(N) solution actually.\\n1. We are iterating over all elements of hash Set O(N).\\n 2. We then are looking for elements which are starting the subsequence, then we are searching elements set(i)+1, we keep searching till we are finding them. Update the final Count if required.\\nNote that we do not iterate over same numbers again. So O(N).\\n\\ni.e.  O(2N) ~= O(N)"
                    },
                    {
                        "username": "0bro",
                        "content": "At best it O(n log n), n for iterating the entire array, then log n for sub iterating through the hash within the loop that is iterating through the passed array. The search for the O(n) is real lol"
                    },
                    {
                        "username": "ethanultra",
                        "content": "[@SunilKumawat](/SunilKumawat) how? when we iterate through again to find a starting point, we only perform the search if there are elements in the subsequence, so when we encounter another element later that\\'s part of the subsequence, we skip it, so it\\'s not O(N^2) time, it is a multiple of O(N), so O(N)"
                    },
                    {
                        "username": "bhautikkapadiya6",
                        "content": "This algo is work but it has O(n*2) complexity"
                    },
                    {
                        "username": "kamran3210",
                        "content": "[@SunilKumawat](/SunilKumawat) \n\nI may be mistaken but surely its O(N)?\n\nInitialise set with the elements: O(N)\n\nIterate over array and check if it is the start of a subsequence (does not have a predecessor): O(N)\n\nSum of  lengths of all subsequences starting from a number that doesn't have a predecessor = N, therefore countining lengths of all subsequences: O(N)\n\noverall complexity: O(N)"
                    },
                    {
                        "username": "user5062LR",
                        "content": "[@SunilKumawat](/SunilKumawat) its O(3N) ~= O(N)"
                    },
                    {
                        "username": "hardikgupta083",
                        "content": "That is not O(N)"
                    },
                    {
                        "username": "SunilKumawat",
                        "content": "this solution has 0(N^2) time complexity genius"
                    },
                    {
                        "username": "forrrjoyuri",
                        "content": "Just for the sake of comparison, I implemented a naive solution in O(n log n) that sorts the array.\\nMy solution runs in 9ms. I copypasted the best linear solutions from the top posts here and the best i got was 30ms.\\n\\nIn theory, something is wrong here. Why is it the case ?"
                    },
                    {
                        "username": "energyperformer",
                        "content": "One thing u need to remeber is Best time complexity Solution doesn\\'t necessarly mean the fastet solution every instance ,initally for small numbers of n ,even if time complexity is more it can give faster result ,but when we go for large values of n then less time complexity solution offer better time results"
                    },
                    {
                        "username": "treat",
                        "content": "[@DeclanGH](/DeclanGH) Your assumed O(N) might actually be O(N^2)"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "I think leetcode needs to add a very large testcase for this problem to make a nlogn fail"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "[@matthewjiao](/matthewjiao) You are right in theory, but if you could see my two solutions, you would see the comment i made. My first O(n) solution ran 463 ms while the nlogn ran 14ms. its really weird and i was graced to get one testcase wrong, which had 10000 as its answer (which is the largest input size). Not saying you are wrong, but the fact that my result was that way still confuses me. "
                    },
                    {
                        "username": "ixeridium",
                        "content": "E.g. with Python it can happen that using some builtin primitive (or libraries such as numpy) give very significant speedups. A factor of 100 or more is not unusual. In such situations it can happen that a O(n log n) solution is always faster than a O(n) solution for any practical input size. I.e., n log n < 100 * n for all n < exp(100)."
                    },
                    {
                        "username": "wasam1119",
                        "content": "[@matthewjiao](/matthewjiao) Accurate. Observe graphs of y = x and y = x*log(x)"
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "from my experience agr aap ek baar best runtime solution dekh lo ja kr after submission and copy pr aap submit kro then this time code not beats 100 percent submission zyada time lega \\nmay be this is leetcode feature jisse leetcode ke solution ko dekh bo dusro ke solution ko beat na kr paye jin logo ne bina ldekhe kiya hai leetcode best solution \\n"
                    },
                    {
                        "username": "matthewjiao",
                        "content": "Time complexity is not a function of speed, it\\'s a function of growth based on input size. Perhaps with smaller inputs, the linearithmic solution is faster than the linear solution, but as input grows in size, O(n) will eventually out perform O(nlogn)."
                    },
                    {
                        "username": "coolkid0006",
                        "content": "Big O notation drops constants from algorithms\\' complexity because Big O notation is concerned with asymptotic inputs (the input size heads towards infinity). The leetcode test cases aren\\'t large enough to ideally represent the asymptotic complexity, so the constants dropped off when calculating the Big O complexity can have a significant effect on runtime. For example:\\n\\nImagine 2 algorithms for a problem: one has a complexity of n^2 and one has an algorithm of n + 10000. The big O notation drops the constants, so the complexities are O(n^2) and O(n). If you work with small amounts of data the n^2 will have a much smaller runtime, but once a certain point is reached the +10000 won\\'t make much of a difference on the runtime.\\n\\nFor this leetcode problem the naive solution has a smaller runtime for inputs smaller than a certain point. This point is larger than the input sizes of the leetcode solution.\\n\\nIf your solution is at the very bottom of the time and memory leaderboard you might want to make sure it is implemented correctly, but because of the asymptotic nature of Big O notation it isn\\'t always accurate to whether it is the ideal solution."
                    },
                    {
                        "username": "Triquetra",
                        "content": "Try to plot execution time of both solutions against n = 100, 1000, 10000, ... \\u2014 maybe you will see a pattern."
                    },
                    {
                        "username": "kiyosaanb",
                        "content": "In case you are doing something like  nums[i]++ or nums[i]-- , you will encounter problems with this new test case ---> [2147483647,-2147483648]"
                    },
                    {
                        "username": "ShiqiLu77",
                        "content": "-1,000,000,000 <= nums[i] <= 1,000,000,000"
                    },
                    {
                        "username": "yis1178",
                        "content": "I think there is a restriction of the value of nums[i] -- not sure if this is lately added"
                    },
                    {
                        "username": "jasusy",
                        "content": "Is it better to need to clarify duplicate numbers not included in consecutive seq?\\n\\nFor example, if input [0, 0] should output 1, instead of 2, since no duplication counted in result.\\n\\nIf duplicate number considered, we need use HashMap instead of HashSet, and a little different in coding."
                    },
                    {
                        "username": "rubayamim381",
                        "content": "[@shanwu](/shanwu) [1,1,2,3,4] = 5"
                    },
                    {
                        "username": "user6161I",
                        "content": "[@shanwu](/shanwu) 4 ... Because Duplicates are to be treated as single."
                    },
                    {
                        "username": "khritish17",
                        "content": "duplicates should be treated as one\\ne.g : nums = [0,0,1,2,3,4,5,6,7,8] -> output: 9 ([0,1,2,3,4,5,6,7,8])"
                    },
                    {
                        "username": "shanwu",
                        "content": "I agree with you. If duplicate numbers are allowed, then what should be the answer of [100,4,200,1,1,3,2] ? It would be unclear."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/longest-consecutive-sequence/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Sorting\n\n  \n**Approach 3:** HashSet and Intelligent Sequence Building\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "PruthviChippa",
                        "content": "this deserves to be hard for o(n)"
                    },
                    {
                        "username": "Hopity",
                        "content": "for some reason it accepts o(nlogn) that\\'s why it\\'s in medium"
                    }
                ]
            },
            {
                "id": 1760209,
                "content": [
                    {
                        "username": "dghosh133",
                        "content": "How does [1,2,0,1] tc gives output as 3? It should be 2! Someone please clarify.\\n[0,1,1,2] -> has at most 2 consecutive nos."
                    },
                    {
                        "username": "TraySoek",
                        "content": "[@PrashantZuko](/PrashantZuko) yes that\\'s it"
                    },
                    {
                        "username": "dsoum",
                        "content": "[@OmarEffat](/OmarEffat) No highest sequence here is, 0,1,2,3,4,5,6,7,8 hence 9. why 10?"
                    },
                    {
                        "username": "Priyashreyas",
                        "content": "[@ironmonger1](/ironmonger1)  if thats the case, the example given above\\n Input: nums = [0,3,7,2,5,8,4,6,0,1]\\nOutput: 9 then it should be 10 and not 9 right? "
                    },
                    {
                        "username": "Priyashreyas",
                        "content": "[@Ajay_Singh9990](/Ajay_Singh9990) if thats the case, the example given above\\n Input: nums = [0,3,7,2,5,8,4,6,0,1]\\nOutput: 9 then it should be 10 and not 9 right? "
                    },
                    {
                        "username": "Rajiv_123",
                        "content": "[@Dipan Ghosh](/dghosh133) For input [0,1,1,2] Longest consecutive seq would be 0,1,2 hence answer would be 3.  We can ignore the 1 at 2nd index as you are allowed to pick numbers at random indexes such that they are consecutive."
                    },
                    {
                        "username": "OmarEffat",
                        "content": "[@geekgeekvm](/geekgeekvm)  In this case, [0,3,7,2,5,8,4,6,0,1] this should be returning 10 (Example 2)"
                    },
                    {
                        "username": "geekgeekvm",
                        "content": "This was not clear from the question, but the question seems to indicate any sequence of consecutive numbers even if there is a repition in between"
                    },
                    {
                        "username": "sh1kamaruNara",
                        "content": "0,1,2 "
                    },
                    {
                        "username": "cookieslasher",
                        "content": "I had the same question. I thought the count should break off it reaches a duplicate number. I guess this wasn\\'t obvious in the problem description."
                    },
                    {
                        "username": "PrashantZuko",
                        "content": "no,it will be 3 since 0,1,2 are all consecutive."
                    },
                    {
                        "username": "user0241F",
                        "content": "            if inputArr[l] == inputArr[l + 1] then only increase"
                    },
                    {
                        "username": "devanshumasodker357",
                        "content": "bro u forget to add 0 that\\'s why it gives 3"
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "whenever duplicates elements in array but we have to return longest sequence\\nex  (1,1,2,2,3,3.4)    answer is 4\\nbcoz hume duplicate se mtlb nahi hai 1,2,3,4, numbers hai gap 1 ka hai then duplicates ko ignore kr dege "
                    },
                    {
                        "username": "Vishal773",
                        "content": "I think duplicates numbers not counted\\n"
                    },
                    {
                        "username": "ankit528",
                        "content": "subsequence could be in any order\\n"
                    },
                    {
                        "username": "subhadipmandalbagjuri",
                        "content": "i also faced same query, but with another else if statement if got resolved"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "well 0,1,2 there\\'s your sequence"
                    },
                    {
                        "username": "user5582eQ",
                        "content": "So many solutions here claiming to be O(n) are actually either O(n^2) or O(nlogn). How can people here have such poor understanding of time complexity."
                    },
                    {
                        "username": "_Ritik_Singh_",
                        "content": "Bro there is no need to judge anyone on the basis of their solution as long as they are solving and learning so chill out and watch  yourself."
                    },
                    {
                        "username": "RealNameHidden",
                        "content": "Explain it then if you understand it so well, so people can learn"
                    },
                    {
                        "username": "dragosarsene7",
                        "content": "[@carlosfonchii](/carlosfonchii) Learn what exactly. The whole point of the problem is to not sort, otherwise it is trivial. People who use sorting barely learn something, if anything at all, they just call sort and then iterate through an array."
                    },
                    {
                        "username": "dipanshuSaini",
                        "content": "[@Rimberse](/Rimberse)  my nlogn solution is as per leetcode -> 99 % faster. So yes, nlogn solution works here perfectly fine."
                    },
                    {
                        "username": "countdankula",
                        "content": "If you use set it will never reach N^2"
                    },
                    {
                        "username": "carlosfonchii",
                        "content": "There is literally no need to come at people when everyone is here to practice and get BETTER at coding. Check yourself."
                    },
                    {
                        "username": "grave18",
                        "content": "[@Rimberse](/Rimberse) No, i am sorting nums (nlogn) and pass the submission."
                    },
                    {
                        "username": "Rimberse",
                        "content": "I actually came up with O(nlogn) solution, but it didn\\'t work. Got TLE\\nSo anything either than O(n) won\\'t actually be accepted as a solution."
                    },
                    {
                        "username": "Saurabh8720",
                        "content": "Sorry To Interrupt Sir But, The Optimised Solution Dont Have a TC of N^2 or NlogN Sorry to Say But u r Wrong, It is Just O(3N) ~= O(N) "
                    },
                    {
                        "username": "nalinnishant",
                        "content": "agree "
                    },
                    {
                        "username": "Angrydemon",
                        "content": "I think they, first try to solve the given question using brute force without considering the time complexity then they try to optimes it, and if it not works they leave the question for later!"
                    },
                    {
                        "username": "aryansuvarna",
                        "content": "lol so true"
                    },
                    {
                        "username": "user7312022",
                        "content": "You can run your code against these test cases before submisson. Hope it helps!\\n\\n[100,4,200,1,3,2]\\n[0,3,7,2,5,8,4,6,0,1]\\n[1,2,0,1]\\n[0]\\n[0,0]\\n[]"
                    },
                    {
                        "username": "subhadipmandalbagjuri",
                        "content": "[9,1,4,7,3,-1,0,5,8,-1,6]"
                    },
                    {
                        "username": "iChuan",
                        "content": "This is really weried to me. Hard to understand the meaning of this question."
                    },
                    {
                        "username": "tusharmathew",
                        "content": "Its not sub sequence so we dont have to maintain order"
                    },
                    {
                        "username": "amansoni22103",
                        "content": "actually we need to avoid duplicate elements here that\\'s why it is showing 3 instead of 2"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/nA5TRClw96I"
                    },
                    {
                        "username": "nareshvishram",
                        "content": "![image](https://assets.leetcode.com/users/images/c8f1a005-5f10-4957-81be-7fb5c11163dd_1596370783.9489772.png)\\n"
                    },
                    {
                        "username": "addictive_head",
                        "content": "This is O(N) solution actually.\\n1. We are iterating over all elements of hash Set O(N).\\n 2. We then are looking for elements which are starting the subsequence, then we are searching elements set(i)+1, we keep searching till we are finding them. Update the final Count if required.\\nNote that we do not iterate over same numbers again. So O(N).\\n\\ni.e.  O(2N) ~= O(N)"
                    },
                    {
                        "username": "0bro",
                        "content": "At best it O(n log n), n for iterating the entire array, then log n for sub iterating through the hash within the loop that is iterating through the passed array. The search for the O(n) is real lol"
                    },
                    {
                        "username": "ethanultra",
                        "content": "[@SunilKumawat](/SunilKumawat) how? when we iterate through again to find a starting point, we only perform the search if there are elements in the subsequence, so when we encounter another element later that\\'s part of the subsequence, we skip it, so it\\'s not O(N^2) time, it is a multiple of O(N), so O(N)"
                    },
                    {
                        "username": "bhautikkapadiya6",
                        "content": "This algo is work but it has O(n*2) complexity"
                    },
                    {
                        "username": "kamran3210",
                        "content": "[@SunilKumawat](/SunilKumawat) \n\nI may be mistaken but surely its O(N)?\n\nInitialise set with the elements: O(N)\n\nIterate over array and check if it is the start of a subsequence (does not have a predecessor): O(N)\n\nSum of  lengths of all subsequences starting from a number that doesn't have a predecessor = N, therefore countining lengths of all subsequences: O(N)\n\noverall complexity: O(N)"
                    },
                    {
                        "username": "user5062LR",
                        "content": "[@SunilKumawat](/SunilKumawat) its O(3N) ~= O(N)"
                    },
                    {
                        "username": "hardikgupta083",
                        "content": "That is not O(N)"
                    },
                    {
                        "username": "SunilKumawat",
                        "content": "this solution has 0(N^2) time complexity genius"
                    },
                    {
                        "username": "forrrjoyuri",
                        "content": "Just for the sake of comparison, I implemented a naive solution in O(n log n) that sorts the array.\\nMy solution runs in 9ms. I copypasted the best linear solutions from the top posts here and the best i got was 30ms.\\n\\nIn theory, something is wrong here. Why is it the case ?"
                    },
                    {
                        "username": "energyperformer",
                        "content": "One thing u need to remeber is Best time complexity Solution doesn\\'t necessarly mean the fastet solution every instance ,initally for small numbers of n ,even if time complexity is more it can give faster result ,but when we go for large values of n then less time complexity solution offer better time results"
                    },
                    {
                        "username": "treat",
                        "content": "[@DeclanGH](/DeclanGH) Your assumed O(N) might actually be O(N^2)"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "I think leetcode needs to add a very large testcase for this problem to make a nlogn fail"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "[@matthewjiao](/matthewjiao) You are right in theory, but if you could see my two solutions, you would see the comment i made. My first O(n) solution ran 463 ms while the nlogn ran 14ms. its really weird and i was graced to get one testcase wrong, which had 10000 as its answer (which is the largest input size). Not saying you are wrong, but the fact that my result was that way still confuses me. "
                    },
                    {
                        "username": "ixeridium",
                        "content": "E.g. with Python it can happen that using some builtin primitive (or libraries such as numpy) give very significant speedups. A factor of 100 or more is not unusual. In such situations it can happen that a O(n log n) solution is always faster than a O(n) solution for any practical input size. I.e., n log n < 100 * n for all n < exp(100)."
                    },
                    {
                        "username": "wasam1119",
                        "content": "[@matthewjiao](/matthewjiao) Accurate. Observe graphs of y = x and y = x*log(x)"
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "from my experience agr aap ek baar best runtime solution dekh lo ja kr after submission and copy pr aap submit kro then this time code not beats 100 percent submission zyada time lega \\nmay be this is leetcode feature jisse leetcode ke solution ko dekh bo dusro ke solution ko beat na kr paye jin logo ne bina ldekhe kiya hai leetcode best solution \\n"
                    },
                    {
                        "username": "matthewjiao",
                        "content": "Time complexity is not a function of speed, it\\'s a function of growth based on input size. Perhaps with smaller inputs, the linearithmic solution is faster than the linear solution, but as input grows in size, O(n) will eventually out perform O(nlogn)."
                    },
                    {
                        "username": "coolkid0006",
                        "content": "Big O notation drops constants from algorithms\\' complexity because Big O notation is concerned with asymptotic inputs (the input size heads towards infinity). The leetcode test cases aren\\'t large enough to ideally represent the asymptotic complexity, so the constants dropped off when calculating the Big O complexity can have a significant effect on runtime. For example:\\n\\nImagine 2 algorithms for a problem: one has a complexity of n^2 and one has an algorithm of n + 10000. The big O notation drops the constants, so the complexities are O(n^2) and O(n). If you work with small amounts of data the n^2 will have a much smaller runtime, but once a certain point is reached the +10000 won\\'t make much of a difference on the runtime.\\n\\nFor this leetcode problem the naive solution has a smaller runtime for inputs smaller than a certain point. This point is larger than the input sizes of the leetcode solution.\\n\\nIf your solution is at the very bottom of the time and memory leaderboard you might want to make sure it is implemented correctly, but because of the asymptotic nature of Big O notation it isn\\'t always accurate to whether it is the ideal solution."
                    },
                    {
                        "username": "Triquetra",
                        "content": "Try to plot execution time of both solutions against n = 100, 1000, 10000, ... \\u2014 maybe you will see a pattern."
                    },
                    {
                        "username": "kiyosaanb",
                        "content": "In case you are doing something like  nums[i]++ or nums[i]-- , you will encounter problems with this new test case ---> [2147483647,-2147483648]"
                    },
                    {
                        "username": "ShiqiLu77",
                        "content": "-1,000,000,000 <= nums[i] <= 1,000,000,000"
                    },
                    {
                        "username": "yis1178",
                        "content": "I think there is a restriction of the value of nums[i] -- not sure if this is lately added"
                    },
                    {
                        "username": "jasusy",
                        "content": "Is it better to need to clarify duplicate numbers not included in consecutive seq?\\n\\nFor example, if input [0, 0] should output 1, instead of 2, since no duplication counted in result.\\n\\nIf duplicate number considered, we need use HashMap instead of HashSet, and a little different in coding."
                    },
                    {
                        "username": "rubayamim381",
                        "content": "[@shanwu](/shanwu) [1,1,2,3,4] = 5"
                    },
                    {
                        "username": "user6161I",
                        "content": "[@shanwu](/shanwu) 4 ... Because Duplicates are to be treated as single."
                    },
                    {
                        "username": "khritish17",
                        "content": "duplicates should be treated as one\\ne.g : nums = [0,0,1,2,3,4,5,6,7,8] -> output: 9 ([0,1,2,3,4,5,6,7,8])"
                    },
                    {
                        "username": "shanwu",
                        "content": "I agree with you. If duplicate numbers are allowed, then what should be the answer of [100,4,200,1,1,3,2] ? It would be unclear."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/longest-consecutive-sequence/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Sorting\n\n  \n**Approach 3:** HashSet and Intelligent Sequence Building\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "PruthviChippa",
                        "content": "this deserves to be hard for o(n)"
                    },
                    {
                        "username": "Hopity",
                        "content": "for some reason it accepts o(nlogn) that\\'s why it\\'s in medium"
                    }
                ]
            },
            {
                "id": 1567877,
                "content": [
                    {
                        "username": "cusion",
                        "content": "I used sort() in STL, which also passed the judgement."
                    },
                    {
                        "username": "ankush20386",
                        "content": "it actually takes O(nlogn) which defies the given constraint"
                    },
                    {
                        "username": "PentaMa",
                        "content": "no, sort() is nlogn"
                    },
                    {
                        "username": "jakubbala",
                        "content": "I\\'m looking at solutions and as soon as I see \"sort\" you\\'ve failed, its not O(n)"
                    },
                    {
                        "username": "Evan2767",
                        "content": "[@AlexTsa](/AlexTsa) radix sort has O(n) complixity?\\n"
                    },
                    {
                        "username": "AlexTsa",
                        "content": "[@sooohka](/sooohka) unless you use radix sort or count sort"
                    },
                    {
                        "username": "sooohka",
                        "content": "agree"
                    },
                    {
                        "username": "Pedraamy",
                        "content": "I thought sorting took N logN but it says the question must be solved within O(N), so how are people able to use sort?"
                    },
                    {
                        "username": "OpeLeke",
                        "content": "`[0,0]` isn\\'t supposed to equate to 1 because it isn\\'t consecutive"
                    },
                    {
                        "username": "GTexx",
                        "content": "yup like,  [0,0,1,2,3,4,5,6,7,8] = 9 because counts only the second 0 to 1 and not the 0 to 0"
                    },
                    {
                        "username": "kartyk",
                        "content": "what approach should i take to solve it in O(n) \\nas the most efficient i can get now is O(nlog(n))"
                    },
                    {
                        "username": "thecodingsage",
                        "content": "i think this video will help: https://youtu.be/P6RZZMu_maU"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Hey everyone who doesn't understand why the O(N) time solution of this problem has O(N) time (O(3*N) to be precise) even though there's a loop inside another loop please listen. Stop always analysing TC based on number of nested loops, the inner loop will run atmost N times that's it. It won't run N times for every element in the hashSet.\nAnother really good example is 'montonic stack' questions such as https://leetcode.com/problems/next-greater-element-ii/, which also has a loop inside a loop but has TC of O(2*N).\n\n"
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "[@ShantanuDutta](/ShantanuDutta) \\nwhat TC term means ? \\nis it a data structure I have to learn in order to solve problems?\\n"
                    },
                    {
                        "username": "ShantanuDutta",
                        "content": "Now I found someone having actual knowledge of TC, RESPECT++"
                    },
                    {
                        "username": "Gnome67",
                        "content": "[9,1,4,7,3,-1,0,5,8,-1,6]\\n\\nSays the answer should be 7, but I only see 3?\\n\\n-1 -> 0 -> 1"
                    },
                    {
                        "username": "Shekhar333",
                        "content": "3,4,5,6,7,8,9\n"
                    },
                    {
                        "username": "Zephyr_8",
                        "content": "The description of this question is very confusing or maybe based on some knowledge of prior questions. What is LCS please clarify in your question"
                    },
                    {
                        "username": "Vithesh",
                        "content": "People forget why this problem is medium.\\nEveryone can solve this problem in O(nlogn).\\nBut only few people can come up with their own algorithm with O(n) time.\\n\\nWho is gonna tell them."
                    },
                    {
                        "username": "yygy",
                        "content": "For this data, My output is 1. However, the standard is 2."
                    }
                ]
            },
            {
                "id": 1949594,
                "content": [
                    {
                        "username": "cusion",
                        "content": "I used sort() in STL, which also passed the judgement."
                    },
                    {
                        "username": "ankush20386",
                        "content": "it actually takes O(nlogn) which defies the given constraint"
                    },
                    {
                        "username": "PentaMa",
                        "content": "no, sort() is nlogn"
                    },
                    {
                        "username": "jakubbala",
                        "content": "I\\'m looking at solutions and as soon as I see \"sort\" you\\'ve failed, its not O(n)"
                    },
                    {
                        "username": "Evan2767",
                        "content": "[@AlexTsa](/AlexTsa) radix sort has O(n) complixity?\\n"
                    },
                    {
                        "username": "AlexTsa",
                        "content": "[@sooohka](/sooohka) unless you use radix sort or count sort"
                    },
                    {
                        "username": "sooohka",
                        "content": "agree"
                    },
                    {
                        "username": "Pedraamy",
                        "content": "I thought sorting took N logN but it says the question must be solved within O(N), so how are people able to use sort?"
                    },
                    {
                        "username": "OpeLeke",
                        "content": "`[0,0]` isn\\'t supposed to equate to 1 because it isn\\'t consecutive"
                    },
                    {
                        "username": "GTexx",
                        "content": "yup like,  [0,0,1,2,3,4,5,6,7,8] = 9 because counts only the second 0 to 1 and not the 0 to 0"
                    },
                    {
                        "username": "kartyk",
                        "content": "what approach should i take to solve it in O(n) \\nas the most efficient i can get now is O(nlog(n))"
                    },
                    {
                        "username": "thecodingsage",
                        "content": "i think this video will help: https://youtu.be/P6RZZMu_maU"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Hey everyone who doesn't understand why the O(N) time solution of this problem has O(N) time (O(3*N) to be precise) even though there's a loop inside another loop please listen. Stop always analysing TC based on number of nested loops, the inner loop will run atmost N times that's it. It won't run N times for every element in the hashSet.\nAnother really good example is 'montonic stack' questions such as https://leetcode.com/problems/next-greater-element-ii/, which also has a loop inside a loop but has TC of O(2*N).\n\n"
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "[@ShantanuDutta](/ShantanuDutta) \\nwhat TC term means ? \\nis it a data structure I have to learn in order to solve problems?\\n"
                    },
                    {
                        "username": "ShantanuDutta",
                        "content": "Now I found someone having actual knowledge of TC, RESPECT++"
                    },
                    {
                        "username": "Gnome67",
                        "content": "[9,1,4,7,3,-1,0,5,8,-1,6]\\n\\nSays the answer should be 7, but I only see 3?\\n\\n-1 -> 0 -> 1"
                    },
                    {
                        "username": "Shekhar333",
                        "content": "3,4,5,6,7,8,9\n"
                    },
                    {
                        "username": "Zephyr_8",
                        "content": "The description of this question is very confusing or maybe based on some knowledge of prior questions. What is LCS please clarify in your question"
                    },
                    {
                        "username": "Vithesh",
                        "content": "People forget why this problem is medium.\\nEveryone can solve this problem in O(nlogn).\\nBut only few people can come up with their own algorithm with O(n) time.\\n\\nWho is gonna tell them."
                    },
                    {
                        "username": "yygy",
                        "content": "For this data, My output is 1. However, the standard is 2."
                    }
                ]
            },
            {
                "id": 1575367,
                "content": [
                    {
                        "username": "cusion",
                        "content": "I used sort() in STL, which also passed the judgement."
                    },
                    {
                        "username": "ankush20386",
                        "content": "it actually takes O(nlogn) which defies the given constraint"
                    },
                    {
                        "username": "PentaMa",
                        "content": "no, sort() is nlogn"
                    },
                    {
                        "username": "jakubbala",
                        "content": "I\\'m looking at solutions and as soon as I see \"sort\" you\\'ve failed, its not O(n)"
                    },
                    {
                        "username": "Evan2767",
                        "content": "[@AlexTsa](/AlexTsa) radix sort has O(n) complixity?\\n"
                    },
                    {
                        "username": "AlexTsa",
                        "content": "[@sooohka](/sooohka) unless you use radix sort or count sort"
                    },
                    {
                        "username": "sooohka",
                        "content": "agree"
                    },
                    {
                        "username": "Pedraamy",
                        "content": "I thought sorting took N logN but it says the question must be solved within O(N), so how are people able to use sort?"
                    },
                    {
                        "username": "OpeLeke",
                        "content": "`[0,0]` isn\\'t supposed to equate to 1 because it isn\\'t consecutive"
                    },
                    {
                        "username": "GTexx",
                        "content": "yup like,  [0,0,1,2,3,4,5,6,7,8] = 9 because counts only the second 0 to 1 and not the 0 to 0"
                    },
                    {
                        "username": "kartyk",
                        "content": "what approach should i take to solve it in O(n) \\nas the most efficient i can get now is O(nlog(n))"
                    },
                    {
                        "username": "thecodingsage",
                        "content": "i think this video will help: https://youtu.be/P6RZZMu_maU"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Hey everyone who doesn't understand why the O(N) time solution of this problem has O(N) time (O(3*N) to be precise) even though there's a loop inside another loop please listen. Stop always analysing TC based on number of nested loops, the inner loop will run atmost N times that's it. It won't run N times for every element in the hashSet.\nAnother really good example is 'montonic stack' questions such as https://leetcode.com/problems/next-greater-element-ii/, which also has a loop inside a loop but has TC of O(2*N).\n\n"
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "[@ShantanuDutta](/ShantanuDutta) \\nwhat TC term means ? \\nis it a data structure I have to learn in order to solve problems?\\n"
                    },
                    {
                        "username": "ShantanuDutta",
                        "content": "Now I found someone having actual knowledge of TC, RESPECT++"
                    },
                    {
                        "username": "Gnome67",
                        "content": "[9,1,4,7,3,-1,0,5,8,-1,6]\\n\\nSays the answer should be 7, but I only see 3?\\n\\n-1 -> 0 -> 1"
                    },
                    {
                        "username": "Shekhar333",
                        "content": "3,4,5,6,7,8,9\n"
                    },
                    {
                        "username": "Zephyr_8",
                        "content": "The description of this question is very confusing or maybe based on some knowledge of prior questions. What is LCS please clarify in your question"
                    },
                    {
                        "username": "Vithesh",
                        "content": "People forget why this problem is medium.\\nEveryone can solve this problem in O(nlogn).\\nBut only few people can come up with their own algorithm with O(n) time.\\n\\nWho is gonna tell them."
                    },
                    {
                        "username": "yygy",
                        "content": "For this data, My output is 1. However, the standard is 2."
                    }
                ]
            },
            {
                "id": 1857359,
                "content": [
                    {
                        "username": "cusion",
                        "content": "I used sort() in STL, which also passed the judgement."
                    },
                    {
                        "username": "ankush20386",
                        "content": "it actually takes O(nlogn) which defies the given constraint"
                    },
                    {
                        "username": "PentaMa",
                        "content": "no, sort() is nlogn"
                    },
                    {
                        "username": "jakubbala",
                        "content": "I\\'m looking at solutions and as soon as I see \"sort\" you\\'ve failed, its not O(n)"
                    },
                    {
                        "username": "Evan2767",
                        "content": "[@AlexTsa](/AlexTsa) radix sort has O(n) complixity?\\n"
                    },
                    {
                        "username": "AlexTsa",
                        "content": "[@sooohka](/sooohka) unless you use radix sort or count sort"
                    },
                    {
                        "username": "sooohka",
                        "content": "agree"
                    },
                    {
                        "username": "Pedraamy",
                        "content": "I thought sorting took N logN but it says the question must be solved within O(N), so how are people able to use sort?"
                    },
                    {
                        "username": "OpeLeke",
                        "content": "`[0,0]` isn\\'t supposed to equate to 1 because it isn\\'t consecutive"
                    },
                    {
                        "username": "GTexx",
                        "content": "yup like,  [0,0,1,2,3,4,5,6,7,8] = 9 because counts only the second 0 to 1 and not the 0 to 0"
                    },
                    {
                        "username": "kartyk",
                        "content": "what approach should i take to solve it in O(n) \\nas the most efficient i can get now is O(nlog(n))"
                    },
                    {
                        "username": "thecodingsage",
                        "content": "i think this video will help: https://youtu.be/P6RZZMu_maU"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Hey everyone who doesn't understand why the O(N) time solution of this problem has O(N) time (O(3*N) to be precise) even though there's a loop inside another loop please listen. Stop always analysing TC based on number of nested loops, the inner loop will run atmost N times that's it. It won't run N times for every element in the hashSet.\nAnother really good example is 'montonic stack' questions such as https://leetcode.com/problems/next-greater-element-ii/, which also has a loop inside a loop but has TC of O(2*N).\n\n"
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "[@ShantanuDutta](/ShantanuDutta) \\nwhat TC term means ? \\nis it a data structure I have to learn in order to solve problems?\\n"
                    },
                    {
                        "username": "ShantanuDutta",
                        "content": "Now I found someone having actual knowledge of TC, RESPECT++"
                    },
                    {
                        "username": "Gnome67",
                        "content": "[9,1,4,7,3,-1,0,5,8,-1,6]\\n\\nSays the answer should be 7, but I only see 3?\\n\\n-1 -> 0 -> 1"
                    },
                    {
                        "username": "Shekhar333",
                        "content": "3,4,5,6,7,8,9\n"
                    },
                    {
                        "username": "Zephyr_8",
                        "content": "The description of this question is very confusing or maybe based on some knowledge of prior questions. What is LCS please clarify in your question"
                    },
                    {
                        "username": "Vithesh",
                        "content": "People forget why this problem is medium.\\nEveryone can solve this problem in O(nlogn).\\nBut only few people can come up with their own algorithm with O(n) time.\\n\\nWho is gonna tell them."
                    },
                    {
                        "username": "yygy",
                        "content": "For this data, My output is 1. However, the standard is 2."
                    }
                ]
            },
            {
                "id": 1743886,
                "content": [
                    {
                        "username": "cusion",
                        "content": "I used sort() in STL, which also passed the judgement."
                    },
                    {
                        "username": "ankush20386",
                        "content": "it actually takes O(nlogn) which defies the given constraint"
                    },
                    {
                        "username": "PentaMa",
                        "content": "no, sort() is nlogn"
                    },
                    {
                        "username": "jakubbala",
                        "content": "I\\'m looking at solutions and as soon as I see \"sort\" you\\'ve failed, its not O(n)"
                    },
                    {
                        "username": "Evan2767",
                        "content": "[@AlexTsa](/AlexTsa) radix sort has O(n) complixity?\\n"
                    },
                    {
                        "username": "AlexTsa",
                        "content": "[@sooohka](/sooohka) unless you use radix sort or count sort"
                    },
                    {
                        "username": "sooohka",
                        "content": "agree"
                    },
                    {
                        "username": "Pedraamy",
                        "content": "I thought sorting took N logN but it says the question must be solved within O(N), so how are people able to use sort?"
                    },
                    {
                        "username": "OpeLeke",
                        "content": "`[0,0]` isn\\'t supposed to equate to 1 because it isn\\'t consecutive"
                    },
                    {
                        "username": "GTexx",
                        "content": "yup like,  [0,0,1,2,3,4,5,6,7,8] = 9 because counts only the second 0 to 1 and not the 0 to 0"
                    },
                    {
                        "username": "kartyk",
                        "content": "what approach should i take to solve it in O(n) \\nas the most efficient i can get now is O(nlog(n))"
                    },
                    {
                        "username": "thecodingsage",
                        "content": "i think this video will help: https://youtu.be/P6RZZMu_maU"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Hey everyone who doesn't understand why the O(N) time solution of this problem has O(N) time (O(3*N) to be precise) even though there's a loop inside another loop please listen. Stop always analysing TC based on number of nested loops, the inner loop will run atmost N times that's it. It won't run N times for every element in the hashSet.\nAnother really good example is 'montonic stack' questions such as https://leetcode.com/problems/next-greater-element-ii/, which also has a loop inside a loop but has TC of O(2*N).\n\n"
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "[@ShantanuDutta](/ShantanuDutta) \\nwhat TC term means ? \\nis it a data structure I have to learn in order to solve problems?\\n"
                    },
                    {
                        "username": "ShantanuDutta",
                        "content": "Now I found someone having actual knowledge of TC, RESPECT++"
                    },
                    {
                        "username": "Gnome67",
                        "content": "[9,1,4,7,3,-1,0,5,8,-1,6]\\n\\nSays the answer should be 7, but I only see 3?\\n\\n-1 -> 0 -> 1"
                    },
                    {
                        "username": "Shekhar333",
                        "content": "3,4,5,6,7,8,9\n"
                    },
                    {
                        "username": "Zephyr_8",
                        "content": "The description of this question is very confusing or maybe based on some knowledge of prior questions. What is LCS please clarify in your question"
                    },
                    {
                        "username": "Vithesh",
                        "content": "People forget why this problem is medium.\\nEveryone can solve this problem in O(nlogn).\\nBut only few people can come up with their own algorithm with O(n) time.\\n\\nWho is gonna tell them."
                    },
                    {
                        "username": "yygy",
                        "content": "For this data, My output is 1. However, the standard is 2."
                    }
                ]
            },
            {
                "id": 1934786,
                "content": [
                    {
                        "username": "cusion",
                        "content": "I used sort() in STL, which also passed the judgement."
                    },
                    {
                        "username": "ankush20386",
                        "content": "it actually takes O(nlogn) which defies the given constraint"
                    },
                    {
                        "username": "PentaMa",
                        "content": "no, sort() is nlogn"
                    },
                    {
                        "username": "jakubbala",
                        "content": "I\\'m looking at solutions and as soon as I see \"sort\" you\\'ve failed, its not O(n)"
                    },
                    {
                        "username": "Evan2767",
                        "content": "[@AlexTsa](/AlexTsa) radix sort has O(n) complixity?\\n"
                    },
                    {
                        "username": "AlexTsa",
                        "content": "[@sooohka](/sooohka) unless you use radix sort or count sort"
                    },
                    {
                        "username": "sooohka",
                        "content": "agree"
                    },
                    {
                        "username": "Pedraamy",
                        "content": "I thought sorting took N logN but it says the question must be solved within O(N), so how are people able to use sort?"
                    },
                    {
                        "username": "OpeLeke",
                        "content": "`[0,0]` isn\\'t supposed to equate to 1 because it isn\\'t consecutive"
                    },
                    {
                        "username": "GTexx",
                        "content": "yup like,  [0,0,1,2,3,4,5,6,7,8] = 9 because counts only the second 0 to 1 and not the 0 to 0"
                    },
                    {
                        "username": "kartyk",
                        "content": "what approach should i take to solve it in O(n) \\nas the most efficient i can get now is O(nlog(n))"
                    },
                    {
                        "username": "thecodingsage",
                        "content": "i think this video will help: https://youtu.be/P6RZZMu_maU"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Hey everyone who doesn't understand why the O(N) time solution of this problem has O(N) time (O(3*N) to be precise) even though there's a loop inside another loop please listen. Stop always analysing TC based on number of nested loops, the inner loop will run atmost N times that's it. It won't run N times for every element in the hashSet.\nAnother really good example is 'montonic stack' questions such as https://leetcode.com/problems/next-greater-element-ii/, which also has a loop inside a loop but has TC of O(2*N).\n\n"
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "[@ShantanuDutta](/ShantanuDutta) \\nwhat TC term means ? \\nis it a data structure I have to learn in order to solve problems?\\n"
                    },
                    {
                        "username": "ShantanuDutta",
                        "content": "Now I found someone having actual knowledge of TC, RESPECT++"
                    },
                    {
                        "username": "Gnome67",
                        "content": "[9,1,4,7,3,-1,0,5,8,-1,6]\\n\\nSays the answer should be 7, but I only see 3?\\n\\n-1 -> 0 -> 1"
                    },
                    {
                        "username": "Shekhar333",
                        "content": "3,4,5,6,7,8,9\n"
                    },
                    {
                        "username": "Zephyr_8",
                        "content": "The description of this question is very confusing or maybe based on some knowledge of prior questions. What is LCS please clarify in your question"
                    },
                    {
                        "username": "Vithesh",
                        "content": "People forget why this problem is medium.\\nEveryone can solve this problem in O(nlogn).\\nBut only few people can come up with their own algorithm with O(n) time.\\n\\nWho is gonna tell them."
                    },
                    {
                        "username": "yygy",
                        "content": "For this data, My output is 1. However, the standard is 2."
                    }
                ]
            },
            {
                "id": 1907800,
                "content": [
                    {
                        "username": "cusion",
                        "content": "I used sort() in STL, which also passed the judgement."
                    },
                    {
                        "username": "ankush20386",
                        "content": "it actually takes O(nlogn) which defies the given constraint"
                    },
                    {
                        "username": "PentaMa",
                        "content": "no, sort() is nlogn"
                    },
                    {
                        "username": "jakubbala",
                        "content": "I\\'m looking at solutions and as soon as I see \"sort\" you\\'ve failed, its not O(n)"
                    },
                    {
                        "username": "Evan2767",
                        "content": "[@AlexTsa](/AlexTsa) radix sort has O(n) complixity?\\n"
                    },
                    {
                        "username": "AlexTsa",
                        "content": "[@sooohka](/sooohka) unless you use radix sort or count sort"
                    },
                    {
                        "username": "sooohka",
                        "content": "agree"
                    },
                    {
                        "username": "Pedraamy",
                        "content": "I thought sorting took N logN but it says the question must be solved within O(N), so how are people able to use sort?"
                    },
                    {
                        "username": "OpeLeke",
                        "content": "`[0,0]` isn\\'t supposed to equate to 1 because it isn\\'t consecutive"
                    },
                    {
                        "username": "GTexx",
                        "content": "yup like,  [0,0,1,2,3,4,5,6,7,8] = 9 because counts only the second 0 to 1 and not the 0 to 0"
                    },
                    {
                        "username": "kartyk",
                        "content": "what approach should i take to solve it in O(n) \\nas the most efficient i can get now is O(nlog(n))"
                    },
                    {
                        "username": "thecodingsage",
                        "content": "i think this video will help: https://youtu.be/P6RZZMu_maU"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Hey everyone who doesn't understand why the O(N) time solution of this problem has O(N) time (O(3*N) to be precise) even though there's a loop inside another loop please listen. Stop always analysing TC based on number of nested loops, the inner loop will run atmost N times that's it. It won't run N times for every element in the hashSet.\nAnother really good example is 'montonic stack' questions such as https://leetcode.com/problems/next-greater-element-ii/, which also has a loop inside a loop but has TC of O(2*N).\n\n"
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "[@ShantanuDutta](/ShantanuDutta) \\nwhat TC term means ? \\nis it a data structure I have to learn in order to solve problems?\\n"
                    },
                    {
                        "username": "ShantanuDutta",
                        "content": "Now I found someone having actual knowledge of TC, RESPECT++"
                    },
                    {
                        "username": "Gnome67",
                        "content": "[9,1,4,7,3,-1,0,5,8,-1,6]\\n\\nSays the answer should be 7, but I only see 3?\\n\\n-1 -> 0 -> 1"
                    },
                    {
                        "username": "Shekhar333",
                        "content": "3,4,5,6,7,8,9\n"
                    },
                    {
                        "username": "Zephyr_8",
                        "content": "The description of this question is very confusing or maybe based on some knowledge of prior questions. What is LCS please clarify in your question"
                    },
                    {
                        "username": "Vithesh",
                        "content": "People forget why this problem is medium.\\nEveryone can solve this problem in O(nlogn).\\nBut only few people can come up with their own algorithm with O(n) time.\\n\\nWho is gonna tell them."
                    },
                    {
                        "username": "yygy",
                        "content": "For this data, My output is 1. However, the standard is 2."
                    }
                ]
            },
            {
                "id": 1845470,
                "content": [
                    {
                        "username": "cusion",
                        "content": "I used sort() in STL, which also passed the judgement."
                    },
                    {
                        "username": "ankush20386",
                        "content": "it actually takes O(nlogn) which defies the given constraint"
                    },
                    {
                        "username": "PentaMa",
                        "content": "no, sort() is nlogn"
                    },
                    {
                        "username": "jakubbala",
                        "content": "I\\'m looking at solutions and as soon as I see \"sort\" you\\'ve failed, its not O(n)"
                    },
                    {
                        "username": "Evan2767",
                        "content": "[@AlexTsa](/AlexTsa) radix sort has O(n) complixity?\\n"
                    },
                    {
                        "username": "AlexTsa",
                        "content": "[@sooohka](/sooohka) unless you use radix sort or count sort"
                    },
                    {
                        "username": "sooohka",
                        "content": "agree"
                    },
                    {
                        "username": "Pedraamy",
                        "content": "I thought sorting took N logN but it says the question must be solved within O(N), so how are people able to use sort?"
                    },
                    {
                        "username": "OpeLeke",
                        "content": "`[0,0]` isn\\'t supposed to equate to 1 because it isn\\'t consecutive"
                    },
                    {
                        "username": "GTexx",
                        "content": "yup like,  [0,0,1,2,3,4,5,6,7,8] = 9 because counts only the second 0 to 1 and not the 0 to 0"
                    },
                    {
                        "username": "kartyk",
                        "content": "what approach should i take to solve it in O(n) \\nas the most efficient i can get now is O(nlog(n))"
                    },
                    {
                        "username": "thecodingsage",
                        "content": "i think this video will help: https://youtu.be/P6RZZMu_maU"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Hey everyone who doesn't understand why the O(N) time solution of this problem has O(N) time (O(3*N) to be precise) even though there's a loop inside another loop please listen. Stop always analysing TC based on number of nested loops, the inner loop will run atmost N times that's it. It won't run N times for every element in the hashSet.\nAnother really good example is 'montonic stack' questions such as https://leetcode.com/problems/next-greater-element-ii/, which also has a loop inside a loop but has TC of O(2*N).\n\n"
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "[@ShantanuDutta](/ShantanuDutta) \\nwhat TC term means ? \\nis it a data structure I have to learn in order to solve problems?\\n"
                    },
                    {
                        "username": "ShantanuDutta",
                        "content": "Now I found someone having actual knowledge of TC, RESPECT++"
                    },
                    {
                        "username": "Gnome67",
                        "content": "[9,1,4,7,3,-1,0,5,8,-1,6]\\n\\nSays the answer should be 7, but I only see 3?\\n\\n-1 -> 0 -> 1"
                    },
                    {
                        "username": "Shekhar333",
                        "content": "3,4,5,6,7,8,9\n"
                    },
                    {
                        "username": "Zephyr_8",
                        "content": "The description of this question is very confusing or maybe based on some knowledge of prior questions. What is LCS please clarify in your question"
                    },
                    {
                        "username": "Vithesh",
                        "content": "People forget why this problem is medium.\\nEveryone can solve this problem in O(nlogn).\\nBut only few people can come up with their own algorithm with O(n) time.\\n\\nWho is gonna tell them."
                    },
                    {
                        "username": "yygy",
                        "content": "For this data, My output is 1. However, the standard is 2."
                    }
                ]
            },
            {
                "id": 1836006,
                "content": [
                    {
                        "username": "cusion",
                        "content": "I used sort() in STL, which also passed the judgement."
                    },
                    {
                        "username": "ankush20386",
                        "content": "it actually takes O(nlogn) which defies the given constraint"
                    },
                    {
                        "username": "PentaMa",
                        "content": "no, sort() is nlogn"
                    },
                    {
                        "username": "jakubbala",
                        "content": "I\\'m looking at solutions and as soon as I see \"sort\" you\\'ve failed, its not O(n)"
                    },
                    {
                        "username": "Evan2767",
                        "content": "[@AlexTsa](/AlexTsa) radix sort has O(n) complixity?\\n"
                    },
                    {
                        "username": "AlexTsa",
                        "content": "[@sooohka](/sooohka) unless you use radix sort or count sort"
                    },
                    {
                        "username": "sooohka",
                        "content": "agree"
                    },
                    {
                        "username": "Pedraamy",
                        "content": "I thought sorting took N logN but it says the question must be solved within O(N), so how are people able to use sort?"
                    },
                    {
                        "username": "OpeLeke",
                        "content": "`[0,0]` isn\\'t supposed to equate to 1 because it isn\\'t consecutive"
                    },
                    {
                        "username": "GTexx",
                        "content": "yup like,  [0,0,1,2,3,4,5,6,7,8] = 9 because counts only the second 0 to 1 and not the 0 to 0"
                    },
                    {
                        "username": "kartyk",
                        "content": "what approach should i take to solve it in O(n) \\nas the most efficient i can get now is O(nlog(n))"
                    },
                    {
                        "username": "thecodingsage",
                        "content": "i think this video will help: https://youtu.be/P6RZZMu_maU"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Hey everyone who doesn't understand why the O(N) time solution of this problem has O(N) time (O(3*N) to be precise) even though there's a loop inside another loop please listen. Stop always analysing TC based on number of nested loops, the inner loop will run atmost N times that's it. It won't run N times for every element in the hashSet.\nAnother really good example is 'montonic stack' questions such as https://leetcode.com/problems/next-greater-element-ii/, which also has a loop inside a loop but has TC of O(2*N).\n\n"
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "[@ShantanuDutta](/ShantanuDutta) \\nwhat TC term means ? \\nis it a data structure I have to learn in order to solve problems?\\n"
                    },
                    {
                        "username": "ShantanuDutta",
                        "content": "Now I found someone having actual knowledge of TC, RESPECT++"
                    },
                    {
                        "username": "Gnome67",
                        "content": "[9,1,4,7,3,-1,0,5,8,-1,6]\\n\\nSays the answer should be 7, but I only see 3?\\n\\n-1 -> 0 -> 1"
                    },
                    {
                        "username": "Shekhar333",
                        "content": "3,4,5,6,7,8,9\n"
                    },
                    {
                        "username": "Zephyr_8",
                        "content": "The description of this question is very confusing or maybe based on some knowledge of prior questions. What is LCS please clarify in your question"
                    },
                    {
                        "username": "Vithesh",
                        "content": "People forget why this problem is medium.\\nEveryone can solve this problem in O(nlogn).\\nBut only few people can come up with their own algorithm with O(n) time.\\n\\nWho is gonna tell them."
                    },
                    {
                        "username": "yygy",
                        "content": "For this data, My output is 1. However, the standard is 2."
                    }
                ]
            },
            {
                "id": 1568948,
                "content": [
                    {
                        "username": "cusion",
                        "content": "I used sort() in STL, which also passed the judgement."
                    },
                    {
                        "username": "ankush20386",
                        "content": "it actually takes O(nlogn) which defies the given constraint"
                    },
                    {
                        "username": "PentaMa",
                        "content": "no, sort() is nlogn"
                    },
                    {
                        "username": "jakubbala",
                        "content": "I\\'m looking at solutions and as soon as I see \"sort\" you\\'ve failed, its not O(n)"
                    },
                    {
                        "username": "Evan2767",
                        "content": "[@AlexTsa](/AlexTsa) radix sort has O(n) complixity?\\n"
                    },
                    {
                        "username": "AlexTsa",
                        "content": "[@sooohka](/sooohka) unless you use radix sort or count sort"
                    },
                    {
                        "username": "sooohka",
                        "content": "agree"
                    },
                    {
                        "username": "Pedraamy",
                        "content": "I thought sorting took N logN but it says the question must be solved within O(N), so how are people able to use sort?"
                    },
                    {
                        "username": "OpeLeke",
                        "content": "`[0,0]` isn\\'t supposed to equate to 1 because it isn\\'t consecutive"
                    },
                    {
                        "username": "GTexx",
                        "content": "yup like,  [0,0,1,2,3,4,5,6,7,8] = 9 because counts only the second 0 to 1 and not the 0 to 0"
                    },
                    {
                        "username": "kartyk",
                        "content": "what approach should i take to solve it in O(n) \\nas the most efficient i can get now is O(nlog(n))"
                    },
                    {
                        "username": "thecodingsage",
                        "content": "i think this video will help: https://youtu.be/P6RZZMu_maU"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Hey everyone who doesn't understand why the O(N) time solution of this problem has O(N) time (O(3*N) to be precise) even though there's a loop inside another loop please listen. Stop always analysing TC based on number of nested loops, the inner loop will run atmost N times that's it. It won't run N times for every element in the hashSet.\nAnother really good example is 'montonic stack' questions such as https://leetcode.com/problems/next-greater-element-ii/, which also has a loop inside a loop but has TC of O(2*N).\n\n"
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "[@ShantanuDutta](/ShantanuDutta) \\nwhat TC term means ? \\nis it a data structure I have to learn in order to solve problems?\\n"
                    },
                    {
                        "username": "ShantanuDutta",
                        "content": "Now I found someone having actual knowledge of TC, RESPECT++"
                    },
                    {
                        "username": "Gnome67",
                        "content": "[9,1,4,7,3,-1,0,5,8,-1,6]\\n\\nSays the answer should be 7, but I only see 3?\\n\\n-1 -> 0 -> 1"
                    },
                    {
                        "username": "Shekhar333",
                        "content": "3,4,5,6,7,8,9\n"
                    },
                    {
                        "username": "Zephyr_8",
                        "content": "The description of this question is very confusing or maybe based on some knowledge of prior questions. What is LCS please clarify in your question"
                    },
                    {
                        "username": "Vithesh",
                        "content": "People forget why this problem is medium.\\nEveryone can solve this problem in O(nlogn).\\nBut only few people can come up with their own algorithm with O(n) time.\\n\\nWho is gonna tell them."
                    },
                    {
                        "username": "yygy",
                        "content": "For this data, My output is 1. However, the standard is 2."
                    }
                ]
            },
            {
                "id": 1567617,
                "content": [
                    {
                        "username": "YehudisK",
                        "content": "Sometimes I see downvotes on beautiful solutions.\\nIf you don\\'t like the solution, and decide to downvote, please explain what you don\\'t like about it!"
                    },
                    {
                        "username": "intijk",
                        "content": "From these popular solutions. I see mainly 2 kind of solutions:\\n\\n1. use set\\n2. use map\\n\\nThe truth is, non of the above solutions are O(n).\\n\\nFor map, most map implementations using red-black tree. Thus the query operation take O(lgN) time. \\n\\nFor set, disjoint set has an amortized time complexity O(a(n)), where a(n) is the reverse function of Ackermann function. O(a(n)) grows very very very slow, but still, it is not O(1).\\n\\nObviously, use disjoint set is a better choice, both asymptotically and co-efficiently ."
                    },
                    {
                        "username": "stephenwallen",
                        "content": "IIUC, if a raw array is used to hash `nums`, the key insertion / lookup is O(1) giving an O(n) solution. However, the maximum element can be 10^9. A hash that big exceeds the memory limit. \\n\\nThe other accepted answers use a `set`, `map`, or sorting... all of which yield an overall worst-case complexity of O(nlogn). I don\\'t think this problem can be solved in O(n) unless I\\'m missing something here..."
                    },
                    {
                        "username": "dsa_looser365",
                        "content": "I am able to come up with approach 2 (sort based) and when I submit it runtime is around 70ms and time complexity is O(nlogn) whereas when i submit approach 3 answer it\\'s taking around 1700ms everytime and it\\'s time complexity is O(n).\\n\\nWhy is it happening like this?"
                    },
                    {
                        "username": "isadhwani",
                        "content": "This is really poorly worded and difficult to understand"
                    },
                    {
                        "username": "Tracck",
                        "content": "Case 69: [-8,-4,9,9,4,6,1,-4,-1,6,8]\\nIt said the answer is 2 but there\\'s [4,6,8]."
                    },
                    {
                        "username": "zebinzhou0922",
                        "content": "During the solving process, I find out that the clarification of the question is weird. \\n\\n[1,2,2,2,3] -> Expected output is 3 because duplicate numbers like 2s are ignored and considered as just 1 number.\\nOn the other hand, [0, 0, 1, 2, 3, 4, 5, 6, 7, 8] -> Expected output is 9  because the first zero should be considered duplicated.\\n\\nSo I think the way to clarify that question is if there are any same numbers in between the \"consecutive mode\" and are treated as 1 number. But anything before and after that should consider duplicated.  \\n\\nPlease correct me if I am wrong. \\n \\n \\n"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Bruh your high or smtg ?? 0 to 8 is 9 numbers lmao"
                    },
                    {
                        "username": "user1084vL",
                        "content": "0-8 is 9 numbers, so the 0 isn\\'t being duplicated."
                    },
                    {
                        "username": "keshxvsingla",
                        "content": "are we ignoring duplicates like in test case\\n[1,2,0,1]\\noutput expected is 3.??\\n"
                    },
                    {
                        "username": "max_223",
                        "content": "Easy well-commented solution in C++/Python/Java\\nhttps://www.techiedelight.com/find-longest-subsequence-formed-by-consecutive-integers/"
                    },
                    {
                        "username": "pavel-shlyk",
                        "content": "Has any one an idea how to solve this problem without using HashMap? I don't think that when using map.find() or map.contains() inside for-next solution complexity still remains O(n).\\n\\nPlease, correct me if i'm wrong."
                    },
                    {
                        "username": "pybol96",
                        "content": "The second example should suppose to be 10, not 9 as I understand"
                    }
                ]
            },
            {
                "id": 1567205,
                "content": [
                    {
                        "username": "YehudisK",
                        "content": "Sometimes I see downvotes on beautiful solutions.\\nIf you don\\'t like the solution, and decide to downvote, please explain what you don\\'t like about it!"
                    },
                    {
                        "username": "intijk",
                        "content": "From these popular solutions. I see mainly 2 kind of solutions:\\n\\n1. use set\\n2. use map\\n\\nThe truth is, non of the above solutions are O(n).\\n\\nFor map, most map implementations using red-black tree. Thus the query operation take O(lgN) time. \\n\\nFor set, disjoint set has an amortized time complexity O(a(n)), where a(n) is the reverse function of Ackermann function. O(a(n)) grows very very very slow, but still, it is not O(1).\\n\\nObviously, use disjoint set is a better choice, both asymptotically and co-efficiently ."
                    },
                    {
                        "username": "stephenwallen",
                        "content": "IIUC, if a raw array is used to hash `nums`, the key insertion / lookup is O(1) giving an O(n) solution. However, the maximum element can be 10^9. A hash that big exceeds the memory limit. \\n\\nThe other accepted answers use a `set`, `map`, or sorting... all of which yield an overall worst-case complexity of O(nlogn). I don\\'t think this problem can be solved in O(n) unless I\\'m missing something here..."
                    },
                    {
                        "username": "dsa_looser365",
                        "content": "I am able to come up with approach 2 (sort based) and when I submit it runtime is around 70ms and time complexity is O(nlogn) whereas when i submit approach 3 answer it\\'s taking around 1700ms everytime and it\\'s time complexity is O(n).\\n\\nWhy is it happening like this?"
                    },
                    {
                        "username": "isadhwani",
                        "content": "This is really poorly worded and difficult to understand"
                    },
                    {
                        "username": "Tracck",
                        "content": "Case 69: [-8,-4,9,9,4,6,1,-4,-1,6,8]\\nIt said the answer is 2 but there\\'s [4,6,8]."
                    },
                    {
                        "username": "zebinzhou0922",
                        "content": "During the solving process, I find out that the clarification of the question is weird. \\n\\n[1,2,2,2,3] -> Expected output is 3 because duplicate numbers like 2s are ignored and considered as just 1 number.\\nOn the other hand, [0, 0, 1, 2, 3, 4, 5, 6, 7, 8] -> Expected output is 9  because the first zero should be considered duplicated.\\n\\nSo I think the way to clarify that question is if there are any same numbers in between the \"consecutive mode\" and are treated as 1 number. But anything before and after that should consider duplicated.  \\n\\nPlease correct me if I am wrong. \\n \\n \\n"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Bruh your high or smtg ?? 0 to 8 is 9 numbers lmao"
                    },
                    {
                        "username": "user1084vL",
                        "content": "0-8 is 9 numbers, so the 0 isn\\'t being duplicated."
                    },
                    {
                        "username": "keshxvsingla",
                        "content": "are we ignoring duplicates like in test case\\n[1,2,0,1]\\noutput expected is 3.??\\n"
                    },
                    {
                        "username": "max_223",
                        "content": "Easy well-commented solution in C++/Python/Java\\nhttps://www.techiedelight.com/find-longest-subsequence-formed-by-consecutive-integers/"
                    },
                    {
                        "username": "pavel-shlyk",
                        "content": "Has any one an idea how to solve this problem without using HashMap? I don't think that when using map.find() or map.contains() inside for-next solution complexity still remains O(n).\\n\\nPlease, correct me if i'm wrong."
                    },
                    {
                        "username": "pybol96",
                        "content": "The second example should suppose to be 10, not 9 as I understand"
                    }
                ]
            },
            {
                "id": 2073554,
                "content": [
                    {
                        "username": "YehudisK",
                        "content": "Sometimes I see downvotes on beautiful solutions.\\nIf you don\\'t like the solution, and decide to downvote, please explain what you don\\'t like about it!"
                    },
                    {
                        "username": "intijk",
                        "content": "From these popular solutions. I see mainly 2 kind of solutions:\\n\\n1. use set\\n2. use map\\n\\nThe truth is, non of the above solutions are O(n).\\n\\nFor map, most map implementations using red-black tree. Thus the query operation take O(lgN) time. \\n\\nFor set, disjoint set has an amortized time complexity O(a(n)), where a(n) is the reverse function of Ackermann function. O(a(n)) grows very very very slow, but still, it is not O(1).\\n\\nObviously, use disjoint set is a better choice, both asymptotically and co-efficiently ."
                    },
                    {
                        "username": "stephenwallen",
                        "content": "IIUC, if a raw array is used to hash `nums`, the key insertion / lookup is O(1) giving an O(n) solution. However, the maximum element can be 10^9. A hash that big exceeds the memory limit. \\n\\nThe other accepted answers use a `set`, `map`, or sorting... all of which yield an overall worst-case complexity of O(nlogn). I don\\'t think this problem can be solved in O(n) unless I\\'m missing something here..."
                    },
                    {
                        "username": "dsa_looser365",
                        "content": "I am able to come up with approach 2 (sort based) and when I submit it runtime is around 70ms and time complexity is O(nlogn) whereas when i submit approach 3 answer it\\'s taking around 1700ms everytime and it\\'s time complexity is O(n).\\n\\nWhy is it happening like this?"
                    },
                    {
                        "username": "isadhwani",
                        "content": "This is really poorly worded and difficult to understand"
                    },
                    {
                        "username": "Tracck",
                        "content": "Case 69: [-8,-4,9,9,4,6,1,-4,-1,6,8]\\nIt said the answer is 2 but there\\'s [4,6,8]."
                    },
                    {
                        "username": "zebinzhou0922",
                        "content": "During the solving process, I find out that the clarification of the question is weird. \\n\\n[1,2,2,2,3] -> Expected output is 3 because duplicate numbers like 2s are ignored and considered as just 1 number.\\nOn the other hand, [0, 0, 1, 2, 3, 4, 5, 6, 7, 8] -> Expected output is 9  because the first zero should be considered duplicated.\\n\\nSo I think the way to clarify that question is if there are any same numbers in between the \"consecutive mode\" and are treated as 1 number. But anything before and after that should consider duplicated.  \\n\\nPlease correct me if I am wrong. \\n \\n \\n"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Bruh your high or smtg ?? 0 to 8 is 9 numbers lmao"
                    },
                    {
                        "username": "user1084vL",
                        "content": "0-8 is 9 numbers, so the 0 isn\\'t being duplicated."
                    },
                    {
                        "username": "keshxvsingla",
                        "content": "are we ignoring duplicates like in test case\\n[1,2,0,1]\\noutput expected is 3.??\\n"
                    },
                    {
                        "username": "max_223",
                        "content": "Easy well-commented solution in C++/Python/Java\\nhttps://www.techiedelight.com/find-longest-subsequence-formed-by-consecutive-integers/"
                    },
                    {
                        "username": "pavel-shlyk",
                        "content": "Has any one an idea how to solve this problem without using HashMap? I don't think that when using map.find() or map.contains() inside for-next solution complexity still remains O(n).\\n\\nPlease, correct me if i'm wrong."
                    },
                    {
                        "username": "pybol96",
                        "content": "The second example should suppose to be 10, not 9 as I understand"
                    }
                ]
            },
            {
                "id": 1992099,
                "content": [
                    {
                        "username": "YehudisK",
                        "content": "Sometimes I see downvotes on beautiful solutions.\\nIf you don\\'t like the solution, and decide to downvote, please explain what you don\\'t like about it!"
                    },
                    {
                        "username": "intijk",
                        "content": "From these popular solutions. I see mainly 2 kind of solutions:\\n\\n1. use set\\n2. use map\\n\\nThe truth is, non of the above solutions are O(n).\\n\\nFor map, most map implementations using red-black tree. Thus the query operation take O(lgN) time. \\n\\nFor set, disjoint set has an amortized time complexity O(a(n)), where a(n) is the reverse function of Ackermann function. O(a(n)) grows very very very slow, but still, it is not O(1).\\n\\nObviously, use disjoint set is a better choice, both asymptotically and co-efficiently ."
                    },
                    {
                        "username": "stephenwallen",
                        "content": "IIUC, if a raw array is used to hash `nums`, the key insertion / lookup is O(1) giving an O(n) solution. However, the maximum element can be 10^9. A hash that big exceeds the memory limit. \\n\\nThe other accepted answers use a `set`, `map`, or sorting... all of which yield an overall worst-case complexity of O(nlogn). I don\\'t think this problem can be solved in O(n) unless I\\'m missing something here..."
                    },
                    {
                        "username": "dsa_looser365",
                        "content": "I am able to come up with approach 2 (sort based) and when I submit it runtime is around 70ms and time complexity is O(nlogn) whereas when i submit approach 3 answer it\\'s taking around 1700ms everytime and it\\'s time complexity is O(n).\\n\\nWhy is it happening like this?"
                    },
                    {
                        "username": "isadhwani",
                        "content": "This is really poorly worded and difficult to understand"
                    },
                    {
                        "username": "Tracck",
                        "content": "Case 69: [-8,-4,9,9,4,6,1,-4,-1,6,8]\\nIt said the answer is 2 but there\\'s [4,6,8]."
                    },
                    {
                        "username": "zebinzhou0922",
                        "content": "During the solving process, I find out that the clarification of the question is weird. \\n\\n[1,2,2,2,3] -> Expected output is 3 because duplicate numbers like 2s are ignored and considered as just 1 number.\\nOn the other hand, [0, 0, 1, 2, 3, 4, 5, 6, 7, 8] -> Expected output is 9  because the first zero should be considered duplicated.\\n\\nSo I think the way to clarify that question is if there are any same numbers in between the \"consecutive mode\" and are treated as 1 number. But anything before and after that should consider duplicated.  \\n\\nPlease correct me if I am wrong. \\n \\n \\n"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Bruh your high or smtg ?? 0 to 8 is 9 numbers lmao"
                    },
                    {
                        "username": "user1084vL",
                        "content": "0-8 is 9 numbers, so the 0 isn\\'t being duplicated."
                    },
                    {
                        "username": "keshxvsingla",
                        "content": "are we ignoring duplicates like in test case\\n[1,2,0,1]\\noutput expected is 3.??\\n"
                    },
                    {
                        "username": "max_223",
                        "content": "Easy well-commented solution in C++/Python/Java\\nhttps://www.techiedelight.com/find-longest-subsequence-formed-by-consecutive-integers/"
                    },
                    {
                        "username": "pavel-shlyk",
                        "content": "Has any one an idea how to solve this problem without using HashMap? I don't think that when using map.find() or map.contains() inside for-next solution complexity still remains O(n).\\n\\nPlease, correct me if i'm wrong."
                    },
                    {
                        "username": "pybol96",
                        "content": "The second example should suppose to be 10, not 9 as I understand"
                    }
                ]
            },
            {
                "id": 1895917,
                "content": [
                    {
                        "username": "YehudisK",
                        "content": "Sometimes I see downvotes on beautiful solutions.\\nIf you don\\'t like the solution, and decide to downvote, please explain what you don\\'t like about it!"
                    },
                    {
                        "username": "intijk",
                        "content": "From these popular solutions. I see mainly 2 kind of solutions:\\n\\n1. use set\\n2. use map\\n\\nThe truth is, non of the above solutions are O(n).\\n\\nFor map, most map implementations using red-black tree. Thus the query operation take O(lgN) time. \\n\\nFor set, disjoint set has an amortized time complexity O(a(n)), where a(n) is the reverse function of Ackermann function. O(a(n)) grows very very very slow, but still, it is not O(1).\\n\\nObviously, use disjoint set is a better choice, both asymptotically and co-efficiently ."
                    },
                    {
                        "username": "stephenwallen",
                        "content": "IIUC, if a raw array is used to hash `nums`, the key insertion / lookup is O(1) giving an O(n) solution. However, the maximum element can be 10^9. A hash that big exceeds the memory limit. \\n\\nThe other accepted answers use a `set`, `map`, or sorting... all of which yield an overall worst-case complexity of O(nlogn). I don\\'t think this problem can be solved in O(n) unless I\\'m missing something here..."
                    },
                    {
                        "username": "dsa_looser365",
                        "content": "I am able to come up with approach 2 (sort based) and when I submit it runtime is around 70ms and time complexity is O(nlogn) whereas when i submit approach 3 answer it\\'s taking around 1700ms everytime and it\\'s time complexity is O(n).\\n\\nWhy is it happening like this?"
                    },
                    {
                        "username": "isadhwani",
                        "content": "This is really poorly worded and difficult to understand"
                    },
                    {
                        "username": "Tracck",
                        "content": "Case 69: [-8,-4,9,9,4,6,1,-4,-1,6,8]\\nIt said the answer is 2 but there\\'s [4,6,8]."
                    },
                    {
                        "username": "zebinzhou0922",
                        "content": "During the solving process, I find out that the clarification of the question is weird. \\n\\n[1,2,2,2,3] -> Expected output is 3 because duplicate numbers like 2s are ignored and considered as just 1 number.\\nOn the other hand, [0, 0, 1, 2, 3, 4, 5, 6, 7, 8] -> Expected output is 9  because the first zero should be considered duplicated.\\n\\nSo I think the way to clarify that question is if there are any same numbers in between the \"consecutive mode\" and are treated as 1 number. But anything before and after that should consider duplicated.  \\n\\nPlease correct me if I am wrong. \\n \\n \\n"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Bruh your high or smtg ?? 0 to 8 is 9 numbers lmao"
                    },
                    {
                        "username": "user1084vL",
                        "content": "0-8 is 9 numbers, so the 0 isn\\'t being duplicated."
                    },
                    {
                        "username": "keshxvsingla",
                        "content": "are we ignoring duplicates like in test case\\n[1,2,0,1]\\noutput expected is 3.??\\n"
                    },
                    {
                        "username": "max_223",
                        "content": "Easy well-commented solution in C++/Python/Java\\nhttps://www.techiedelight.com/find-longest-subsequence-formed-by-consecutive-integers/"
                    },
                    {
                        "username": "pavel-shlyk",
                        "content": "Has any one an idea how to solve this problem without using HashMap? I don't think that when using map.find() or map.contains() inside for-next solution complexity still remains O(n).\\n\\nPlease, correct me if i'm wrong."
                    },
                    {
                        "username": "pybol96",
                        "content": "The second example should suppose to be 10, not 9 as I understand"
                    }
                ]
            },
            {
                "id": 1810388,
                "content": [
                    {
                        "username": "YehudisK",
                        "content": "Sometimes I see downvotes on beautiful solutions.\\nIf you don\\'t like the solution, and decide to downvote, please explain what you don\\'t like about it!"
                    },
                    {
                        "username": "intijk",
                        "content": "From these popular solutions. I see mainly 2 kind of solutions:\\n\\n1. use set\\n2. use map\\n\\nThe truth is, non of the above solutions are O(n).\\n\\nFor map, most map implementations using red-black tree. Thus the query operation take O(lgN) time. \\n\\nFor set, disjoint set has an amortized time complexity O(a(n)), where a(n) is the reverse function of Ackermann function. O(a(n)) grows very very very slow, but still, it is not O(1).\\n\\nObviously, use disjoint set is a better choice, both asymptotically and co-efficiently ."
                    },
                    {
                        "username": "stephenwallen",
                        "content": "IIUC, if a raw array is used to hash `nums`, the key insertion / lookup is O(1) giving an O(n) solution. However, the maximum element can be 10^9. A hash that big exceeds the memory limit. \\n\\nThe other accepted answers use a `set`, `map`, or sorting... all of which yield an overall worst-case complexity of O(nlogn). I don\\'t think this problem can be solved in O(n) unless I\\'m missing something here..."
                    },
                    {
                        "username": "dsa_looser365",
                        "content": "I am able to come up with approach 2 (sort based) and when I submit it runtime is around 70ms and time complexity is O(nlogn) whereas when i submit approach 3 answer it\\'s taking around 1700ms everytime and it\\'s time complexity is O(n).\\n\\nWhy is it happening like this?"
                    },
                    {
                        "username": "isadhwani",
                        "content": "This is really poorly worded and difficult to understand"
                    },
                    {
                        "username": "Tracck",
                        "content": "Case 69: [-8,-4,9,9,4,6,1,-4,-1,6,8]\\nIt said the answer is 2 but there\\'s [4,6,8]."
                    },
                    {
                        "username": "zebinzhou0922",
                        "content": "During the solving process, I find out that the clarification of the question is weird. \\n\\n[1,2,2,2,3] -> Expected output is 3 because duplicate numbers like 2s are ignored and considered as just 1 number.\\nOn the other hand, [0, 0, 1, 2, 3, 4, 5, 6, 7, 8] -> Expected output is 9  because the first zero should be considered duplicated.\\n\\nSo I think the way to clarify that question is if there are any same numbers in between the \"consecutive mode\" and are treated as 1 number. But anything before and after that should consider duplicated.  \\n\\nPlease correct me if I am wrong. \\n \\n \\n"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Bruh your high or smtg ?? 0 to 8 is 9 numbers lmao"
                    },
                    {
                        "username": "user1084vL",
                        "content": "0-8 is 9 numbers, so the 0 isn\\'t being duplicated."
                    },
                    {
                        "username": "keshxvsingla",
                        "content": "are we ignoring duplicates like in test case\\n[1,2,0,1]\\noutput expected is 3.??\\n"
                    },
                    {
                        "username": "max_223",
                        "content": "Easy well-commented solution in C++/Python/Java\\nhttps://www.techiedelight.com/find-longest-subsequence-formed-by-consecutive-integers/"
                    },
                    {
                        "username": "pavel-shlyk",
                        "content": "Has any one an idea how to solve this problem without using HashMap? I don't think that when using map.find() or map.contains() inside for-next solution complexity still remains O(n).\\n\\nPlease, correct me if i'm wrong."
                    },
                    {
                        "username": "pybol96",
                        "content": "The second example should suppose to be 10, not 9 as I understand"
                    }
                ]
            },
            {
                "id": 1755584,
                "content": [
                    {
                        "username": "YehudisK",
                        "content": "Sometimes I see downvotes on beautiful solutions.\\nIf you don\\'t like the solution, and decide to downvote, please explain what you don\\'t like about it!"
                    },
                    {
                        "username": "intijk",
                        "content": "From these popular solutions. I see mainly 2 kind of solutions:\\n\\n1. use set\\n2. use map\\n\\nThe truth is, non of the above solutions are O(n).\\n\\nFor map, most map implementations using red-black tree. Thus the query operation take O(lgN) time. \\n\\nFor set, disjoint set has an amortized time complexity O(a(n)), where a(n) is the reverse function of Ackermann function. O(a(n)) grows very very very slow, but still, it is not O(1).\\n\\nObviously, use disjoint set is a better choice, both asymptotically and co-efficiently ."
                    },
                    {
                        "username": "stephenwallen",
                        "content": "IIUC, if a raw array is used to hash `nums`, the key insertion / lookup is O(1) giving an O(n) solution. However, the maximum element can be 10^9. A hash that big exceeds the memory limit. \\n\\nThe other accepted answers use a `set`, `map`, or sorting... all of which yield an overall worst-case complexity of O(nlogn). I don\\'t think this problem can be solved in O(n) unless I\\'m missing something here..."
                    },
                    {
                        "username": "dsa_looser365",
                        "content": "I am able to come up with approach 2 (sort based) and when I submit it runtime is around 70ms and time complexity is O(nlogn) whereas when i submit approach 3 answer it\\'s taking around 1700ms everytime and it\\'s time complexity is O(n).\\n\\nWhy is it happening like this?"
                    },
                    {
                        "username": "isadhwani",
                        "content": "This is really poorly worded and difficult to understand"
                    },
                    {
                        "username": "Tracck",
                        "content": "Case 69: [-8,-4,9,9,4,6,1,-4,-1,6,8]\\nIt said the answer is 2 but there\\'s [4,6,8]."
                    },
                    {
                        "username": "zebinzhou0922",
                        "content": "During the solving process, I find out that the clarification of the question is weird. \\n\\n[1,2,2,2,3] -> Expected output is 3 because duplicate numbers like 2s are ignored and considered as just 1 number.\\nOn the other hand, [0, 0, 1, 2, 3, 4, 5, 6, 7, 8] -> Expected output is 9  because the first zero should be considered duplicated.\\n\\nSo I think the way to clarify that question is if there are any same numbers in between the \"consecutive mode\" and are treated as 1 number. But anything before and after that should consider duplicated.  \\n\\nPlease correct me if I am wrong. \\n \\n \\n"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Bruh your high or smtg ?? 0 to 8 is 9 numbers lmao"
                    },
                    {
                        "username": "user1084vL",
                        "content": "0-8 is 9 numbers, so the 0 isn\\'t being duplicated."
                    },
                    {
                        "username": "keshxvsingla",
                        "content": "are we ignoring duplicates like in test case\\n[1,2,0,1]\\noutput expected is 3.??\\n"
                    },
                    {
                        "username": "max_223",
                        "content": "Easy well-commented solution in C++/Python/Java\\nhttps://www.techiedelight.com/find-longest-subsequence-formed-by-consecutive-integers/"
                    },
                    {
                        "username": "pavel-shlyk",
                        "content": "Has any one an idea how to solve this problem without using HashMap? I don't think that when using map.find() or map.contains() inside for-next solution complexity still remains O(n).\\n\\nPlease, correct me if i'm wrong."
                    },
                    {
                        "username": "pybol96",
                        "content": "The second example should suppose to be 10, not 9 as I understand"
                    }
                ]
            },
            {
                "id": 1573932,
                "content": [
                    {
                        "username": "YehudisK",
                        "content": "Sometimes I see downvotes on beautiful solutions.\\nIf you don\\'t like the solution, and decide to downvote, please explain what you don\\'t like about it!"
                    },
                    {
                        "username": "intijk",
                        "content": "From these popular solutions. I see mainly 2 kind of solutions:\\n\\n1. use set\\n2. use map\\n\\nThe truth is, non of the above solutions are O(n).\\n\\nFor map, most map implementations using red-black tree. Thus the query operation take O(lgN) time. \\n\\nFor set, disjoint set has an amortized time complexity O(a(n)), where a(n) is the reverse function of Ackermann function. O(a(n)) grows very very very slow, but still, it is not O(1).\\n\\nObviously, use disjoint set is a better choice, both asymptotically and co-efficiently ."
                    },
                    {
                        "username": "stephenwallen",
                        "content": "IIUC, if a raw array is used to hash `nums`, the key insertion / lookup is O(1) giving an O(n) solution. However, the maximum element can be 10^9. A hash that big exceeds the memory limit. \\n\\nThe other accepted answers use a `set`, `map`, or sorting... all of which yield an overall worst-case complexity of O(nlogn). I don\\'t think this problem can be solved in O(n) unless I\\'m missing something here..."
                    },
                    {
                        "username": "dsa_looser365",
                        "content": "I am able to come up with approach 2 (sort based) and when I submit it runtime is around 70ms and time complexity is O(nlogn) whereas when i submit approach 3 answer it\\'s taking around 1700ms everytime and it\\'s time complexity is O(n).\\n\\nWhy is it happening like this?"
                    },
                    {
                        "username": "isadhwani",
                        "content": "This is really poorly worded and difficult to understand"
                    },
                    {
                        "username": "Tracck",
                        "content": "Case 69: [-8,-4,9,9,4,6,1,-4,-1,6,8]\\nIt said the answer is 2 but there\\'s [4,6,8]."
                    },
                    {
                        "username": "zebinzhou0922",
                        "content": "During the solving process, I find out that the clarification of the question is weird. \\n\\n[1,2,2,2,3] -> Expected output is 3 because duplicate numbers like 2s are ignored and considered as just 1 number.\\nOn the other hand, [0, 0, 1, 2, 3, 4, 5, 6, 7, 8] -> Expected output is 9  because the first zero should be considered duplicated.\\n\\nSo I think the way to clarify that question is if there are any same numbers in between the \"consecutive mode\" and are treated as 1 number. But anything before and after that should consider duplicated.  \\n\\nPlease correct me if I am wrong. \\n \\n \\n"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Bruh your high or smtg ?? 0 to 8 is 9 numbers lmao"
                    },
                    {
                        "username": "user1084vL",
                        "content": "0-8 is 9 numbers, so the 0 isn\\'t being duplicated."
                    },
                    {
                        "username": "keshxvsingla",
                        "content": "are we ignoring duplicates like in test case\\n[1,2,0,1]\\noutput expected is 3.??\\n"
                    },
                    {
                        "username": "max_223",
                        "content": "Easy well-commented solution in C++/Python/Java\\nhttps://www.techiedelight.com/find-longest-subsequence-formed-by-consecutive-integers/"
                    },
                    {
                        "username": "pavel-shlyk",
                        "content": "Has any one an idea how to solve this problem without using HashMap? I don't think that when using map.find() or map.contains() inside for-next solution complexity still remains O(n).\\n\\nPlease, correct me if i'm wrong."
                    },
                    {
                        "username": "pybol96",
                        "content": "The second example should suppose to be 10, not 9 as I understand"
                    }
                ]
            },
            {
                "id": 1571275,
                "content": [
                    {
                        "username": "YehudisK",
                        "content": "Sometimes I see downvotes on beautiful solutions.\\nIf you don\\'t like the solution, and decide to downvote, please explain what you don\\'t like about it!"
                    },
                    {
                        "username": "intijk",
                        "content": "From these popular solutions. I see mainly 2 kind of solutions:\\n\\n1. use set\\n2. use map\\n\\nThe truth is, non of the above solutions are O(n).\\n\\nFor map, most map implementations using red-black tree. Thus the query operation take O(lgN) time. \\n\\nFor set, disjoint set has an amortized time complexity O(a(n)), where a(n) is the reverse function of Ackermann function. O(a(n)) grows very very very slow, but still, it is not O(1).\\n\\nObviously, use disjoint set is a better choice, both asymptotically and co-efficiently ."
                    },
                    {
                        "username": "stephenwallen",
                        "content": "IIUC, if a raw array is used to hash `nums`, the key insertion / lookup is O(1) giving an O(n) solution. However, the maximum element can be 10^9. A hash that big exceeds the memory limit. \\n\\nThe other accepted answers use a `set`, `map`, or sorting... all of which yield an overall worst-case complexity of O(nlogn). I don\\'t think this problem can be solved in O(n) unless I\\'m missing something here..."
                    },
                    {
                        "username": "dsa_looser365",
                        "content": "I am able to come up with approach 2 (sort based) and when I submit it runtime is around 70ms and time complexity is O(nlogn) whereas when i submit approach 3 answer it\\'s taking around 1700ms everytime and it\\'s time complexity is O(n).\\n\\nWhy is it happening like this?"
                    },
                    {
                        "username": "isadhwani",
                        "content": "This is really poorly worded and difficult to understand"
                    },
                    {
                        "username": "Tracck",
                        "content": "Case 69: [-8,-4,9,9,4,6,1,-4,-1,6,8]\\nIt said the answer is 2 but there\\'s [4,6,8]."
                    },
                    {
                        "username": "zebinzhou0922",
                        "content": "During the solving process, I find out that the clarification of the question is weird. \\n\\n[1,2,2,2,3] -> Expected output is 3 because duplicate numbers like 2s are ignored and considered as just 1 number.\\nOn the other hand, [0, 0, 1, 2, 3, 4, 5, 6, 7, 8] -> Expected output is 9  because the first zero should be considered duplicated.\\n\\nSo I think the way to clarify that question is if there are any same numbers in between the \"consecutive mode\" and are treated as 1 number. But anything before and after that should consider duplicated.  \\n\\nPlease correct me if I am wrong. \\n \\n \\n"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Bruh your high or smtg ?? 0 to 8 is 9 numbers lmao"
                    },
                    {
                        "username": "user1084vL",
                        "content": "0-8 is 9 numbers, so the 0 isn\\'t being duplicated."
                    },
                    {
                        "username": "keshxvsingla",
                        "content": "are we ignoring duplicates like in test case\\n[1,2,0,1]\\noutput expected is 3.??\\n"
                    },
                    {
                        "username": "max_223",
                        "content": "Easy well-commented solution in C++/Python/Java\\nhttps://www.techiedelight.com/find-longest-subsequence-formed-by-consecutive-integers/"
                    },
                    {
                        "username": "pavel-shlyk",
                        "content": "Has any one an idea how to solve this problem without using HashMap? I don't think that when using map.find() or map.contains() inside for-next solution complexity still remains O(n).\\n\\nPlease, correct me if i'm wrong."
                    },
                    {
                        "username": "pybol96",
                        "content": "The second example should suppose to be 10, not 9 as I understand"
                    }
                ]
            },
            {
                "id": 2072601,
                "content": [
                    {
                        "username": "YehudisK",
                        "content": "Sometimes I see downvotes on beautiful solutions.\\nIf you don\\'t like the solution, and decide to downvote, please explain what you don\\'t like about it!"
                    },
                    {
                        "username": "intijk",
                        "content": "From these popular solutions. I see mainly 2 kind of solutions:\\n\\n1. use set\\n2. use map\\n\\nThe truth is, non of the above solutions are O(n).\\n\\nFor map, most map implementations using red-black tree. Thus the query operation take O(lgN) time. \\n\\nFor set, disjoint set has an amortized time complexity O(a(n)), where a(n) is the reverse function of Ackermann function. O(a(n)) grows very very very slow, but still, it is not O(1).\\n\\nObviously, use disjoint set is a better choice, both asymptotically and co-efficiently ."
                    },
                    {
                        "username": "stephenwallen",
                        "content": "IIUC, if a raw array is used to hash `nums`, the key insertion / lookup is O(1) giving an O(n) solution. However, the maximum element can be 10^9. A hash that big exceeds the memory limit. \\n\\nThe other accepted answers use a `set`, `map`, or sorting... all of which yield an overall worst-case complexity of O(nlogn). I don\\'t think this problem can be solved in O(n) unless I\\'m missing something here..."
                    },
                    {
                        "username": "dsa_looser365",
                        "content": "I am able to come up with approach 2 (sort based) and when I submit it runtime is around 70ms and time complexity is O(nlogn) whereas when i submit approach 3 answer it\\'s taking around 1700ms everytime and it\\'s time complexity is O(n).\\n\\nWhy is it happening like this?"
                    },
                    {
                        "username": "isadhwani",
                        "content": "This is really poorly worded and difficult to understand"
                    },
                    {
                        "username": "Tracck",
                        "content": "Case 69: [-8,-4,9,9,4,6,1,-4,-1,6,8]\\nIt said the answer is 2 but there\\'s [4,6,8]."
                    },
                    {
                        "username": "zebinzhou0922",
                        "content": "During the solving process, I find out that the clarification of the question is weird. \\n\\n[1,2,2,2,3] -> Expected output is 3 because duplicate numbers like 2s are ignored and considered as just 1 number.\\nOn the other hand, [0, 0, 1, 2, 3, 4, 5, 6, 7, 8] -> Expected output is 9  because the first zero should be considered duplicated.\\n\\nSo I think the way to clarify that question is if there are any same numbers in between the \"consecutive mode\" and are treated as 1 number. But anything before and after that should consider duplicated.  \\n\\nPlease correct me if I am wrong. \\n \\n \\n"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Bruh your high or smtg ?? 0 to 8 is 9 numbers lmao"
                    },
                    {
                        "username": "user1084vL",
                        "content": "0-8 is 9 numbers, so the 0 isn\\'t being duplicated."
                    },
                    {
                        "username": "keshxvsingla",
                        "content": "are we ignoring duplicates like in test case\\n[1,2,0,1]\\noutput expected is 3.??\\n"
                    },
                    {
                        "username": "max_223",
                        "content": "Easy well-commented solution in C++/Python/Java\\nhttps://www.techiedelight.com/find-longest-subsequence-formed-by-consecutive-integers/"
                    },
                    {
                        "username": "pavel-shlyk",
                        "content": "Has any one an idea how to solve this problem without using HashMap? I don't think that when using map.find() or map.contains() inside for-next solution complexity still remains O(n).\\n\\nPlease, correct me if i'm wrong."
                    },
                    {
                        "username": "pybol96",
                        "content": "The second example should suppose to be 10, not 9 as I understand"
                    }
                ]
            },
            {
                "id": 2068201,
                "content": [
                    {
                        "username": "Shaik_Waheed",
                        "content": "What is the difference between using nums and numSet in the for loop?\n `for i in numSet:`\n `for i in nums:`"
                    },
                    {
                        "username": "BriMa",
                        "content": "A set does not contain duplicate keys so traversing numSet prevents us from operating on the same number more than once, e.g., nums = [0,1,0,10] vs numSet = {0,1,10}. A set also has a O(1) lookup time complexity whereas the nums arrays would have an O(n) lookup."
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Please help me check this solution in java, why it wrong\\n ` // consequence\\n    int maxLen = 0;\\n    HashSet<Integer> set = new HashSet<Integer>();\\n    for (int num : nums) {\\n      set.add(num);\\n    }\\n\\n    for (int num : nums) {\\n      // check if num is start of consecutive integer\\n      if (!set.contains(num - 1)) {\\n        int currentNum = num;\\n        maxLen = 1;\\n        while (set.contains(currentNum + 1)) {\\n          maxLen++;\\n          currentNum++;\\n        }\\n        maxLen = Math.max(maxLen, currentNum);\\n      }\\n    }\\n    return maxLen;\\n  }`"
                    },
                    {
                        "username": "ajaybyadgi",
                        "content": "Why my O(logn*n) solution that sorts is 90% faster than any other solution but without sorting and is in O(N) is slower ? "
                    },
                    {
                        "username": "vbarinov",
                        "content": "Same"
                    },
                    {
                        "username": "A_Y",
                        "content": "The solution with dfs :\nhttps://leetcode.com/problems/longest-consecutive-sequence/solutions/3994290/longest-consecutive-sequence-dfs-c/\n\nThe standard solution with built in function sort() : \nhttps://leetcode.com/problems/longest-consecutive-sequence/solutions/3994298/longest-consecutive-sequence-c/"
                    },
                    {
                        "username": "ankitk742",
                        "content": "Check for start of subsequence only and iterate.\\n\\nThe start of subsequence ( m ) would not have m-1 in the list. "
                    },
                    {
                        "username": "layyy",
                        "content": "make an unordered set and keep erasing elements until no consecutive elements are found (keeping track of longest length)"
                    },
                    {
                        "username": "ashish_dixit15",
                        "content": "[ ] ->how to represent this?\n"
                    },
                    {
                        "username": "user2190wY",
                        "content": "The sequence [9,1,4,7,3,-1,0,5,8,-1,6] does not have 2. Why was 7 \"expected\" and not 3?\\nSometimes these tests are horrible."
                    },
                    {
                        "username": "user2190wY",
                        "content": "[@vijay__bhaskar](/vijay__bhaskar) Yes, I\\'ve already figured it out. Feel stupid."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "because there is sequence 3,4,5,6,7,8,9 so its length is 7"
                    },
                    {
                        "username": "julkar9",
                        "content": "Think if this as a graph,\\nSo just apply dfs"
                    },
                    {
                        "username": "KRATOS_23",
                        "content": "I understand this solution but how do you get the intuition to solve this?"
                    }
                ]
            },
            {
                "id": 2064073,
                "content": [
                    {
                        "username": "Shaik_Waheed",
                        "content": "What is the difference between using nums and numSet in the for loop?\n `for i in numSet:`\n `for i in nums:`"
                    },
                    {
                        "username": "BriMa",
                        "content": "A set does not contain duplicate keys so traversing numSet prevents us from operating on the same number more than once, e.g., nums = [0,1,0,10] vs numSet = {0,1,10}. A set also has a O(1) lookup time complexity whereas the nums arrays would have an O(n) lookup."
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Please help me check this solution in java, why it wrong\\n ` // consequence\\n    int maxLen = 0;\\n    HashSet<Integer> set = new HashSet<Integer>();\\n    for (int num : nums) {\\n      set.add(num);\\n    }\\n\\n    for (int num : nums) {\\n      // check if num is start of consecutive integer\\n      if (!set.contains(num - 1)) {\\n        int currentNum = num;\\n        maxLen = 1;\\n        while (set.contains(currentNum + 1)) {\\n          maxLen++;\\n          currentNum++;\\n        }\\n        maxLen = Math.max(maxLen, currentNum);\\n      }\\n    }\\n    return maxLen;\\n  }`"
                    },
                    {
                        "username": "ajaybyadgi",
                        "content": "Why my O(logn*n) solution that sorts is 90% faster than any other solution but without sorting and is in O(N) is slower ? "
                    },
                    {
                        "username": "vbarinov",
                        "content": "Same"
                    },
                    {
                        "username": "A_Y",
                        "content": "The solution with dfs :\nhttps://leetcode.com/problems/longest-consecutive-sequence/solutions/3994290/longest-consecutive-sequence-dfs-c/\n\nThe standard solution with built in function sort() : \nhttps://leetcode.com/problems/longest-consecutive-sequence/solutions/3994298/longest-consecutive-sequence-c/"
                    },
                    {
                        "username": "ankitk742",
                        "content": "Check for start of subsequence only and iterate.\\n\\nThe start of subsequence ( m ) would not have m-1 in the list. "
                    },
                    {
                        "username": "layyy",
                        "content": "make an unordered set and keep erasing elements until no consecutive elements are found (keeping track of longest length)"
                    },
                    {
                        "username": "ashish_dixit15",
                        "content": "[ ] ->how to represent this?\n"
                    },
                    {
                        "username": "user2190wY",
                        "content": "The sequence [9,1,4,7,3,-1,0,5,8,-1,6] does not have 2. Why was 7 \"expected\" and not 3?\\nSometimes these tests are horrible."
                    },
                    {
                        "username": "user2190wY",
                        "content": "[@vijay__bhaskar](/vijay__bhaskar) Yes, I\\'ve already figured it out. Feel stupid."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "because there is sequence 3,4,5,6,7,8,9 so its length is 7"
                    },
                    {
                        "username": "julkar9",
                        "content": "Think if this as a graph,\\nSo just apply dfs"
                    },
                    {
                        "username": "KRATOS_23",
                        "content": "I understand this solution but how do you get the intuition to solve this?"
                    }
                ]
            },
            {
                "id": 2045245,
                "content": [
                    {
                        "username": "Shaik_Waheed",
                        "content": "What is the difference between using nums and numSet in the for loop?\n `for i in numSet:`\n `for i in nums:`"
                    },
                    {
                        "username": "BriMa",
                        "content": "A set does not contain duplicate keys so traversing numSet prevents us from operating on the same number more than once, e.g., nums = [0,1,0,10] vs numSet = {0,1,10}. A set also has a O(1) lookup time complexity whereas the nums arrays would have an O(n) lookup."
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Please help me check this solution in java, why it wrong\\n ` // consequence\\n    int maxLen = 0;\\n    HashSet<Integer> set = new HashSet<Integer>();\\n    for (int num : nums) {\\n      set.add(num);\\n    }\\n\\n    for (int num : nums) {\\n      // check if num is start of consecutive integer\\n      if (!set.contains(num - 1)) {\\n        int currentNum = num;\\n        maxLen = 1;\\n        while (set.contains(currentNum + 1)) {\\n          maxLen++;\\n          currentNum++;\\n        }\\n        maxLen = Math.max(maxLen, currentNum);\\n      }\\n    }\\n    return maxLen;\\n  }`"
                    },
                    {
                        "username": "ajaybyadgi",
                        "content": "Why my O(logn*n) solution that sorts is 90% faster than any other solution but without sorting and is in O(N) is slower ? "
                    },
                    {
                        "username": "vbarinov",
                        "content": "Same"
                    },
                    {
                        "username": "A_Y",
                        "content": "The solution with dfs :\nhttps://leetcode.com/problems/longest-consecutive-sequence/solutions/3994290/longest-consecutive-sequence-dfs-c/\n\nThe standard solution with built in function sort() : \nhttps://leetcode.com/problems/longest-consecutive-sequence/solutions/3994298/longest-consecutive-sequence-c/"
                    },
                    {
                        "username": "ankitk742",
                        "content": "Check for start of subsequence only and iterate.\\n\\nThe start of subsequence ( m ) would not have m-1 in the list. "
                    },
                    {
                        "username": "layyy",
                        "content": "make an unordered set and keep erasing elements until no consecutive elements are found (keeping track of longest length)"
                    },
                    {
                        "username": "ashish_dixit15",
                        "content": "[ ] ->how to represent this?\n"
                    },
                    {
                        "username": "user2190wY",
                        "content": "The sequence [9,1,4,7,3,-1,0,5,8,-1,6] does not have 2. Why was 7 \"expected\" and not 3?\\nSometimes these tests are horrible."
                    },
                    {
                        "username": "user2190wY",
                        "content": "[@vijay__bhaskar](/vijay__bhaskar) Yes, I\\'ve already figured it out. Feel stupid."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "because there is sequence 3,4,5,6,7,8,9 so its length is 7"
                    },
                    {
                        "username": "julkar9",
                        "content": "Think if this as a graph,\\nSo just apply dfs"
                    },
                    {
                        "username": "KRATOS_23",
                        "content": "I understand this solution but how do you get the intuition to solve this?"
                    }
                ]
            },
            {
                "id": 2041474,
                "content": [
                    {
                        "username": "Shaik_Waheed",
                        "content": "What is the difference between using nums and numSet in the for loop?\n `for i in numSet:`\n `for i in nums:`"
                    },
                    {
                        "username": "BriMa",
                        "content": "A set does not contain duplicate keys so traversing numSet prevents us from operating on the same number more than once, e.g., nums = [0,1,0,10] vs numSet = {0,1,10}. A set also has a O(1) lookup time complexity whereas the nums arrays would have an O(n) lookup."
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Please help me check this solution in java, why it wrong\\n ` // consequence\\n    int maxLen = 0;\\n    HashSet<Integer> set = new HashSet<Integer>();\\n    for (int num : nums) {\\n      set.add(num);\\n    }\\n\\n    for (int num : nums) {\\n      // check if num is start of consecutive integer\\n      if (!set.contains(num - 1)) {\\n        int currentNum = num;\\n        maxLen = 1;\\n        while (set.contains(currentNum + 1)) {\\n          maxLen++;\\n          currentNum++;\\n        }\\n        maxLen = Math.max(maxLen, currentNum);\\n      }\\n    }\\n    return maxLen;\\n  }`"
                    },
                    {
                        "username": "ajaybyadgi",
                        "content": "Why my O(logn*n) solution that sorts is 90% faster than any other solution but without sorting and is in O(N) is slower ? "
                    },
                    {
                        "username": "vbarinov",
                        "content": "Same"
                    },
                    {
                        "username": "A_Y",
                        "content": "The solution with dfs :\nhttps://leetcode.com/problems/longest-consecutive-sequence/solutions/3994290/longest-consecutive-sequence-dfs-c/\n\nThe standard solution with built in function sort() : \nhttps://leetcode.com/problems/longest-consecutive-sequence/solutions/3994298/longest-consecutive-sequence-c/"
                    },
                    {
                        "username": "ankitk742",
                        "content": "Check for start of subsequence only and iterate.\\n\\nThe start of subsequence ( m ) would not have m-1 in the list. "
                    },
                    {
                        "username": "layyy",
                        "content": "make an unordered set and keep erasing elements until no consecutive elements are found (keeping track of longest length)"
                    },
                    {
                        "username": "ashish_dixit15",
                        "content": "[ ] ->how to represent this?\n"
                    },
                    {
                        "username": "user2190wY",
                        "content": "The sequence [9,1,4,7,3,-1,0,5,8,-1,6] does not have 2. Why was 7 \"expected\" and not 3?\\nSometimes these tests are horrible."
                    },
                    {
                        "username": "user2190wY",
                        "content": "[@vijay__bhaskar](/vijay__bhaskar) Yes, I\\'ve already figured it out. Feel stupid."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "because there is sequence 3,4,5,6,7,8,9 so its length is 7"
                    },
                    {
                        "username": "julkar9",
                        "content": "Think if this as a graph,\\nSo just apply dfs"
                    },
                    {
                        "username": "KRATOS_23",
                        "content": "I understand this solution but how do you get the intuition to solve this?"
                    }
                ]
            },
            {
                "id": 2036997,
                "content": [
                    {
                        "username": "Shaik_Waheed",
                        "content": "What is the difference between using nums and numSet in the for loop?\n `for i in numSet:`\n `for i in nums:`"
                    },
                    {
                        "username": "BriMa",
                        "content": "A set does not contain duplicate keys so traversing numSet prevents us from operating on the same number more than once, e.g., nums = [0,1,0,10] vs numSet = {0,1,10}. A set also has a O(1) lookup time complexity whereas the nums arrays would have an O(n) lookup."
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Please help me check this solution in java, why it wrong\\n ` // consequence\\n    int maxLen = 0;\\n    HashSet<Integer> set = new HashSet<Integer>();\\n    for (int num : nums) {\\n      set.add(num);\\n    }\\n\\n    for (int num : nums) {\\n      // check if num is start of consecutive integer\\n      if (!set.contains(num - 1)) {\\n        int currentNum = num;\\n        maxLen = 1;\\n        while (set.contains(currentNum + 1)) {\\n          maxLen++;\\n          currentNum++;\\n        }\\n        maxLen = Math.max(maxLen, currentNum);\\n      }\\n    }\\n    return maxLen;\\n  }`"
                    },
                    {
                        "username": "ajaybyadgi",
                        "content": "Why my O(logn*n) solution that sorts is 90% faster than any other solution but without sorting and is in O(N) is slower ? "
                    },
                    {
                        "username": "vbarinov",
                        "content": "Same"
                    },
                    {
                        "username": "A_Y",
                        "content": "The solution with dfs :\nhttps://leetcode.com/problems/longest-consecutive-sequence/solutions/3994290/longest-consecutive-sequence-dfs-c/\n\nThe standard solution with built in function sort() : \nhttps://leetcode.com/problems/longest-consecutive-sequence/solutions/3994298/longest-consecutive-sequence-c/"
                    },
                    {
                        "username": "ankitk742",
                        "content": "Check for start of subsequence only and iterate.\\n\\nThe start of subsequence ( m ) would not have m-1 in the list. "
                    },
                    {
                        "username": "layyy",
                        "content": "make an unordered set and keep erasing elements until no consecutive elements are found (keeping track of longest length)"
                    },
                    {
                        "username": "ashish_dixit15",
                        "content": "[ ] ->how to represent this?\n"
                    },
                    {
                        "username": "user2190wY",
                        "content": "The sequence [9,1,4,7,3,-1,0,5,8,-1,6] does not have 2. Why was 7 \"expected\" and not 3?\\nSometimes these tests are horrible."
                    },
                    {
                        "username": "user2190wY",
                        "content": "[@vijay__bhaskar](/vijay__bhaskar) Yes, I\\'ve already figured it out. Feel stupid."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "because there is sequence 3,4,5,6,7,8,9 so its length is 7"
                    },
                    {
                        "username": "julkar9",
                        "content": "Think if this as a graph,\\nSo just apply dfs"
                    },
                    {
                        "username": "KRATOS_23",
                        "content": "I understand this solution but how do you get the intuition to solve this?"
                    }
                ]
            },
            {
                "id": 2034594,
                "content": [
                    {
                        "username": "Shaik_Waheed",
                        "content": "What is the difference between using nums and numSet in the for loop?\n `for i in numSet:`\n `for i in nums:`"
                    },
                    {
                        "username": "BriMa",
                        "content": "A set does not contain duplicate keys so traversing numSet prevents us from operating on the same number more than once, e.g., nums = [0,1,0,10] vs numSet = {0,1,10}. A set also has a O(1) lookup time complexity whereas the nums arrays would have an O(n) lookup."
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Please help me check this solution in java, why it wrong\\n ` // consequence\\n    int maxLen = 0;\\n    HashSet<Integer> set = new HashSet<Integer>();\\n    for (int num : nums) {\\n      set.add(num);\\n    }\\n\\n    for (int num : nums) {\\n      // check if num is start of consecutive integer\\n      if (!set.contains(num - 1)) {\\n        int currentNum = num;\\n        maxLen = 1;\\n        while (set.contains(currentNum + 1)) {\\n          maxLen++;\\n          currentNum++;\\n        }\\n        maxLen = Math.max(maxLen, currentNum);\\n      }\\n    }\\n    return maxLen;\\n  }`"
                    },
                    {
                        "username": "ajaybyadgi",
                        "content": "Why my O(logn*n) solution that sorts is 90% faster than any other solution but without sorting and is in O(N) is slower ? "
                    },
                    {
                        "username": "vbarinov",
                        "content": "Same"
                    },
                    {
                        "username": "A_Y",
                        "content": "The solution with dfs :\nhttps://leetcode.com/problems/longest-consecutive-sequence/solutions/3994290/longest-consecutive-sequence-dfs-c/\n\nThe standard solution with built in function sort() : \nhttps://leetcode.com/problems/longest-consecutive-sequence/solutions/3994298/longest-consecutive-sequence-c/"
                    },
                    {
                        "username": "ankitk742",
                        "content": "Check for start of subsequence only and iterate.\\n\\nThe start of subsequence ( m ) would not have m-1 in the list. "
                    },
                    {
                        "username": "layyy",
                        "content": "make an unordered set and keep erasing elements until no consecutive elements are found (keeping track of longest length)"
                    },
                    {
                        "username": "ashish_dixit15",
                        "content": "[ ] ->how to represent this?\n"
                    },
                    {
                        "username": "user2190wY",
                        "content": "The sequence [9,1,4,7,3,-1,0,5,8,-1,6] does not have 2. Why was 7 \"expected\" and not 3?\\nSometimes these tests are horrible."
                    },
                    {
                        "username": "user2190wY",
                        "content": "[@vijay__bhaskar](/vijay__bhaskar) Yes, I\\'ve already figured it out. Feel stupid."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "because there is sequence 3,4,5,6,7,8,9 so its length is 7"
                    },
                    {
                        "username": "julkar9",
                        "content": "Think if this as a graph,\\nSo just apply dfs"
                    },
                    {
                        "username": "KRATOS_23",
                        "content": "I understand this solution but how do you get the intuition to solve this?"
                    }
                ]
            },
            {
                "id": 2031297,
                "content": [
                    {
                        "username": "Shaik_Waheed",
                        "content": "What is the difference between using nums and numSet in the for loop?\n `for i in numSet:`\n `for i in nums:`"
                    },
                    {
                        "username": "BriMa",
                        "content": "A set does not contain duplicate keys so traversing numSet prevents us from operating on the same number more than once, e.g., nums = [0,1,0,10] vs numSet = {0,1,10}. A set also has a O(1) lookup time complexity whereas the nums arrays would have an O(n) lookup."
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Please help me check this solution in java, why it wrong\\n ` // consequence\\n    int maxLen = 0;\\n    HashSet<Integer> set = new HashSet<Integer>();\\n    for (int num : nums) {\\n      set.add(num);\\n    }\\n\\n    for (int num : nums) {\\n      // check if num is start of consecutive integer\\n      if (!set.contains(num - 1)) {\\n        int currentNum = num;\\n        maxLen = 1;\\n        while (set.contains(currentNum + 1)) {\\n          maxLen++;\\n          currentNum++;\\n        }\\n        maxLen = Math.max(maxLen, currentNum);\\n      }\\n    }\\n    return maxLen;\\n  }`"
                    },
                    {
                        "username": "ajaybyadgi",
                        "content": "Why my O(logn*n) solution that sorts is 90% faster than any other solution but without sorting and is in O(N) is slower ? "
                    },
                    {
                        "username": "vbarinov",
                        "content": "Same"
                    },
                    {
                        "username": "A_Y",
                        "content": "The solution with dfs :\nhttps://leetcode.com/problems/longest-consecutive-sequence/solutions/3994290/longest-consecutive-sequence-dfs-c/\n\nThe standard solution with built in function sort() : \nhttps://leetcode.com/problems/longest-consecutive-sequence/solutions/3994298/longest-consecutive-sequence-c/"
                    },
                    {
                        "username": "ankitk742",
                        "content": "Check for start of subsequence only and iterate.\\n\\nThe start of subsequence ( m ) would not have m-1 in the list. "
                    },
                    {
                        "username": "layyy",
                        "content": "make an unordered set and keep erasing elements until no consecutive elements are found (keeping track of longest length)"
                    },
                    {
                        "username": "ashish_dixit15",
                        "content": "[ ] ->how to represent this?\n"
                    },
                    {
                        "username": "user2190wY",
                        "content": "The sequence [9,1,4,7,3,-1,0,5,8,-1,6] does not have 2. Why was 7 \"expected\" and not 3?\\nSometimes these tests are horrible."
                    },
                    {
                        "username": "user2190wY",
                        "content": "[@vijay__bhaskar](/vijay__bhaskar) Yes, I\\'ve already figured it out. Feel stupid."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "because there is sequence 3,4,5,6,7,8,9 so its length is 7"
                    },
                    {
                        "username": "julkar9",
                        "content": "Think if this as a graph,\\nSo just apply dfs"
                    },
                    {
                        "username": "KRATOS_23",
                        "content": "I understand this solution but how do you get the intuition to solve this?"
                    }
                ]
            },
            {
                "id": 2028158,
                "content": [
                    {
                        "username": "Shaik_Waheed",
                        "content": "What is the difference between using nums and numSet in the for loop?\n `for i in numSet:`\n `for i in nums:`"
                    },
                    {
                        "username": "BriMa",
                        "content": "A set does not contain duplicate keys so traversing numSet prevents us from operating on the same number more than once, e.g., nums = [0,1,0,10] vs numSet = {0,1,10}. A set also has a O(1) lookup time complexity whereas the nums arrays would have an O(n) lookup."
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Please help me check this solution in java, why it wrong\\n ` // consequence\\n    int maxLen = 0;\\n    HashSet<Integer> set = new HashSet<Integer>();\\n    for (int num : nums) {\\n      set.add(num);\\n    }\\n\\n    for (int num : nums) {\\n      // check if num is start of consecutive integer\\n      if (!set.contains(num - 1)) {\\n        int currentNum = num;\\n        maxLen = 1;\\n        while (set.contains(currentNum + 1)) {\\n          maxLen++;\\n          currentNum++;\\n        }\\n        maxLen = Math.max(maxLen, currentNum);\\n      }\\n    }\\n    return maxLen;\\n  }`"
                    },
                    {
                        "username": "ajaybyadgi",
                        "content": "Why my O(logn*n) solution that sorts is 90% faster than any other solution but without sorting and is in O(N) is slower ? "
                    },
                    {
                        "username": "vbarinov",
                        "content": "Same"
                    },
                    {
                        "username": "A_Y",
                        "content": "The solution with dfs :\nhttps://leetcode.com/problems/longest-consecutive-sequence/solutions/3994290/longest-consecutive-sequence-dfs-c/\n\nThe standard solution with built in function sort() : \nhttps://leetcode.com/problems/longest-consecutive-sequence/solutions/3994298/longest-consecutive-sequence-c/"
                    },
                    {
                        "username": "ankitk742",
                        "content": "Check for start of subsequence only and iterate.\\n\\nThe start of subsequence ( m ) would not have m-1 in the list. "
                    },
                    {
                        "username": "layyy",
                        "content": "make an unordered set and keep erasing elements until no consecutive elements are found (keeping track of longest length)"
                    },
                    {
                        "username": "ashish_dixit15",
                        "content": "[ ] ->how to represent this?\n"
                    },
                    {
                        "username": "user2190wY",
                        "content": "The sequence [9,1,4,7,3,-1,0,5,8,-1,6] does not have 2. Why was 7 \"expected\" and not 3?\\nSometimes these tests are horrible."
                    },
                    {
                        "username": "user2190wY",
                        "content": "[@vijay__bhaskar](/vijay__bhaskar) Yes, I\\'ve already figured it out. Feel stupid."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "because there is sequence 3,4,5,6,7,8,9 so its length is 7"
                    },
                    {
                        "username": "julkar9",
                        "content": "Think if this as a graph,\\nSo just apply dfs"
                    },
                    {
                        "username": "KRATOS_23",
                        "content": "I understand this solution but how do you get the intuition to solve this?"
                    }
                ]
            },
            {
                "id": 2027119,
                "content": [
                    {
                        "username": "Shaik_Waheed",
                        "content": "What is the difference between using nums and numSet in the for loop?\n `for i in numSet:`\n `for i in nums:`"
                    },
                    {
                        "username": "BriMa",
                        "content": "A set does not contain duplicate keys so traversing numSet prevents us from operating on the same number more than once, e.g., nums = [0,1,0,10] vs numSet = {0,1,10}. A set also has a O(1) lookup time complexity whereas the nums arrays would have an O(n) lookup."
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Please help me check this solution in java, why it wrong\\n ` // consequence\\n    int maxLen = 0;\\n    HashSet<Integer> set = new HashSet<Integer>();\\n    for (int num : nums) {\\n      set.add(num);\\n    }\\n\\n    for (int num : nums) {\\n      // check if num is start of consecutive integer\\n      if (!set.contains(num - 1)) {\\n        int currentNum = num;\\n        maxLen = 1;\\n        while (set.contains(currentNum + 1)) {\\n          maxLen++;\\n          currentNum++;\\n        }\\n        maxLen = Math.max(maxLen, currentNum);\\n      }\\n    }\\n    return maxLen;\\n  }`"
                    },
                    {
                        "username": "ajaybyadgi",
                        "content": "Why my O(logn*n) solution that sorts is 90% faster than any other solution but without sorting and is in O(N) is slower ? "
                    },
                    {
                        "username": "vbarinov",
                        "content": "Same"
                    },
                    {
                        "username": "A_Y",
                        "content": "The solution with dfs :\nhttps://leetcode.com/problems/longest-consecutive-sequence/solutions/3994290/longest-consecutive-sequence-dfs-c/\n\nThe standard solution with built in function sort() : \nhttps://leetcode.com/problems/longest-consecutive-sequence/solutions/3994298/longest-consecutive-sequence-c/"
                    },
                    {
                        "username": "ankitk742",
                        "content": "Check for start of subsequence only and iterate.\\n\\nThe start of subsequence ( m ) would not have m-1 in the list. "
                    },
                    {
                        "username": "layyy",
                        "content": "make an unordered set and keep erasing elements until no consecutive elements are found (keeping track of longest length)"
                    },
                    {
                        "username": "ashish_dixit15",
                        "content": "[ ] ->how to represent this?\n"
                    },
                    {
                        "username": "user2190wY",
                        "content": "The sequence [9,1,4,7,3,-1,0,5,8,-1,6] does not have 2. Why was 7 \"expected\" and not 3?\\nSometimes these tests are horrible."
                    },
                    {
                        "username": "user2190wY",
                        "content": "[@vijay__bhaskar](/vijay__bhaskar) Yes, I\\'ve already figured it out. Feel stupid."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "because there is sequence 3,4,5,6,7,8,9 so its length is 7"
                    },
                    {
                        "username": "julkar9",
                        "content": "Think if this as a graph,\\nSo just apply dfs"
                    },
                    {
                        "username": "KRATOS_23",
                        "content": "I understand this solution but how do you get the intuition to solve this?"
                    }
                ]
            },
            {
                "id": 2023067,
                "content": [
                    {
                        "username": "Shaik_Waheed",
                        "content": "What is the difference between using nums and numSet in the for loop?\n `for i in numSet:`\n `for i in nums:`"
                    },
                    {
                        "username": "BriMa",
                        "content": "A set does not contain duplicate keys so traversing numSet prevents us from operating on the same number more than once, e.g., nums = [0,1,0,10] vs numSet = {0,1,10}. A set also has a O(1) lookup time complexity whereas the nums arrays would have an O(n) lookup."
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Please help me check this solution in java, why it wrong\\n ` // consequence\\n    int maxLen = 0;\\n    HashSet<Integer> set = new HashSet<Integer>();\\n    for (int num : nums) {\\n      set.add(num);\\n    }\\n\\n    for (int num : nums) {\\n      // check if num is start of consecutive integer\\n      if (!set.contains(num - 1)) {\\n        int currentNum = num;\\n        maxLen = 1;\\n        while (set.contains(currentNum + 1)) {\\n          maxLen++;\\n          currentNum++;\\n        }\\n        maxLen = Math.max(maxLen, currentNum);\\n      }\\n    }\\n    return maxLen;\\n  }`"
                    },
                    {
                        "username": "ajaybyadgi",
                        "content": "Why my O(logn*n) solution that sorts is 90% faster than any other solution but without sorting and is in O(N) is slower ? "
                    },
                    {
                        "username": "vbarinov",
                        "content": "Same"
                    },
                    {
                        "username": "A_Y",
                        "content": "The solution with dfs :\nhttps://leetcode.com/problems/longest-consecutive-sequence/solutions/3994290/longest-consecutive-sequence-dfs-c/\n\nThe standard solution with built in function sort() : \nhttps://leetcode.com/problems/longest-consecutive-sequence/solutions/3994298/longest-consecutive-sequence-c/"
                    },
                    {
                        "username": "ankitk742",
                        "content": "Check for start of subsequence only and iterate.\\n\\nThe start of subsequence ( m ) would not have m-1 in the list. "
                    },
                    {
                        "username": "layyy",
                        "content": "make an unordered set and keep erasing elements until no consecutive elements are found (keeping track of longest length)"
                    },
                    {
                        "username": "ashish_dixit15",
                        "content": "[ ] ->how to represent this?\n"
                    },
                    {
                        "username": "user2190wY",
                        "content": "The sequence [9,1,4,7,3,-1,0,5,8,-1,6] does not have 2. Why was 7 \"expected\" and not 3?\\nSometimes these tests are horrible."
                    },
                    {
                        "username": "user2190wY",
                        "content": "[@vijay__bhaskar](/vijay__bhaskar) Yes, I\\'ve already figured it out. Feel stupid."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "because there is sequence 3,4,5,6,7,8,9 so its length is 7"
                    },
                    {
                        "username": "julkar9",
                        "content": "Think if this as a graph,\\nSo just apply dfs"
                    },
                    {
                        "username": "KRATOS_23",
                        "content": "I understand this solution but how do you get the intuition to solve this?"
                    }
                ]
            },
            {
                "id": 2004546,
                "content": [
                    {
                        "username": "Manoj_Chavva",
                        "content": "Is this code correct\\nclass Solution(object):\\n    def longestConsecutive(nums):\\n        if not nums:\\n            return 0\\n\\n        sorted_nums = sorted(set(nums))  # Sort and remove duplicates\\n\\n        max_length = 1\\n        current_length = 1\\n\\n        for i in range(1, len(sorted_nums)):\\n            if sorted_nums[i] == sorted_nums[i - 1] + 1:\\n                current_length += 1\\n            else:\\n                max_length = max(max_length, current_length)\\n                current_length = 1\\n\\n        return max(max_length, current_length)\\n\\n\\n"
                    },
                    {
                        "username": "SureDoo",
                        "content": "[@georgezakharov](/georgezakharov) And when he uses \\'sort\\', the solution can not meet the requirement O(n)."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "julian_sikora",
                        "content": "Why is iterating throw the nums as a set much faster than iterating throw the list?\n\nSo why is:\nfor n in nums:\n     pass\n\nslower than\n\nfor n in set(nums):\n    pass\n\nShouldn't it be more or less the same? For me it was the difference between being better than 40% of the solutions to being better than 98% and I don't really get why?"
                    },
                    {
                        "username": "treat",
                        "content": "If you are not preparing for any of these weekly competitions, don't bother yourself with such details. What is more important is that you understand all the different approaches that can be used to solve a problem. Also once you understand do code down your own solution. "
                    },
                    {
                        "username": "RealNameHidden",
                        "content": "Did it using a priority queue, bot the most optimal but its accepted.\\n\\n `class Solution {\\n    public int longestConsecutive(int[] nums) {\\n        Queue<Integer> pq = new PriorityQueue<>((a,b)->a-b);\\n        if(nums.length==0){\\n            return 0;\\n        }\\n        for(int i=0; i<nums.length; i++){\\n            pq.add(nums[i]);\\n        }\\n        \\n        int maxLen = 1;\\n        int currLen = 1;\\n        int prevEle = pq.remove();\\n        while(!pq.isEmpty()){\\n            int curr = pq.remove();\\n            if(curr==prevEle){\\n                continue;\\n            }\\n            if(Math.abs(curr-prevEle)==1){\\n                currLen++;\\n                maxLen = Math.max(maxLen,currLen);\\n            } else{\\n                currLen = 1;\\n            }\\n            prevEle = curr;\\n        }\\n        return maxLen;\\n    }\\n}`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "AnthonyShuey",
                        "content": "Give me a score based on how good this solution is on a scale of 0-10: \\nimport heapq\\nclass Solution:\\n    def longestConsecutive(self, nums: List[int]) -> int:\\n        if len(nums)==0:\\n            return 0\\n        h = set()\\n        for i in nums:\\n            if i in h:\\n                continue\\n            else:\\n                h.add(i)\\n        helper =h.copy()\\n        longest = 1\\n        for num in helper:\\n            if num in h:\\n                l =1\\n                start = num-1\\n                while start in h:\\n                    l+=1\\n                    start = start-1\\n                    h.remove(start+1)\\n                start = num+1\\n                while start in h:\\n                    l+=1\\n                    start = start+1\\n                    h.remove(start-1)\\n                if l > longest:\\n                    longest = l\\n        return longest"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "AnthonyShuey",
                        "content": "Will someone tell me why my code beats 65% of other submissions even though it is nlogn. I removed the duplicates then used a heap to pop the smallest off and check if the next one to be popped off is 1 greater than the currently one that is popped off. If so, then I will increase l. I do this until there are no other elements. The \"while numsy\" is worse case O(n) and then we do \"start = heapq.heappop(numsy)\" which is logn. Therefore, my solution is nlogn. \\nHere is the exact code: \\n\\nimport heapq\\nclass Solution:\\n    def longestConsecutive(self, nums: List[int]) -> int:\\n        h = set()\\n        for i in nums:\\n            if i in h:\\n                continue\\n            else:\\n                h.add(i)\\n        numsy =[]\\n        for i in h:\\n            numsy.append(i)\\n        for i in range(0,len(numsy)):\\n            numsy[i]*=-1\\n        heapq.heapify(numsy)\\n        longest = 1\\n        if len(numsy)==0:\\n            return 0\\n        while numsy:\\n            l =1\\n            start = heapq.heappop(numsy)\\n            while len(numsy)>0 and numsy[0]==start+1:\\n                l+=1\\n                start = heapq.heappop(numsy)\\n            if l>longest:\\n                longest = l\\n        return longest"
                    },
                    {
                        "username": "dragosarsene7",
                        "content": "For everyone using set to get O(n), if you do not remove elements as you go, your complexity would be O(n*sqrt(n)) worst-case, eg. {0, 1, 2, 4, 5, 6, 8, 9, 10}, where you have sqrt(n) clusters of sqrt(n) consecutive elements each"
                    },
                    {
                        "username": "Szymon5922",
                        "content": "I strongly recommend SortedSet; Algo faster than 96.20% of sumbissions with C# created with low effort."
                    },
                    {
                        "username": "Pikiato",
                        "content": "Why is [-6,-1,-1,9,-8,-6,-6,4,4,-3,-8,-1] returns 1 ?? there are no consecutive numbers?? I\\'m confused. Please help me."
                    },
                    {
                        "username": "sakshamgaur96",
                        "content": "what is wrong yaar with this 25th test case how come it is expecting output to be 7 , like howwww?????\\nin the test case it is given that the sample inputs are: [9,1,4,7,3,-1,0,5,8,-1,6]\\nsince they are asking for LONGEST CONSECUTIVE , and i just can\\'t get where the fuck is \\'2\\' in the given array and without that how come they are expecting the length of 7 to be the output of the program !!!"
                    },
                    {
                        "username": "Orange_Smuggler",
                        "content": "[3,4,5,6,7,8,9]"
                    },
                    {
                        "username": "Orange_Smuggler",
                        "content": "I'm kinda puzzled: [1,2,1,1,1,1,3,3,3,3,4] has to be 4 for LeetCode. But the given examples kinda missed the point here. My initial guess was that we're looking for possible consecutive sequences with a strict relation to amount of numbers in array. Say, we sort my example, we get this: [1,1,1,1,1,2,3,3,3,3,4]. I thought that the answer is 3, because you can clearly see consecutive sequence [1,2,3]. But the answer 4 suggests that we also include 4, despite having four '3's? This is huge oversight and kinda lame in my opinion. Is there any point in counting these numbers at all?"
                    },
                    {
                        "username": "2uringTested",
                        "content": "I dont think its an oversight. They have clearly mentioned that the sequence has the following property:\\n\\n\"It is a consecutive sequence\"\\n\\nmeaning that for every index \\'i\\' in the sequence, a[i+1] = a[i] +1\\n\\nso if the sequence was {1,2,3,3} the property is violated at the i = 2, where a[i+1] != a[i]+1\\nso 4 is infact the correct answer for [1,2,1,1,1,1,3,3,3,3,3,4] as the longest sequence which follows this property is {1,2,3,4}."
                    }
                ]
            },
            {
                "id": 2000178,
                "content": [
                    {
                        "username": "Manoj_Chavva",
                        "content": "Is this code correct\\nclass Solution(object):\\n    def longestConsecutive(nums):\\n        if not nums:\\n            return 0\\n\\n        sorted_nums = sorted(set(nums))  # Sort and remove duplicates\\n\\n        max_length = 1\\n        current_length = 1\\n\\n        for i in range(1, len(sorted_nums)):\\n            if sorted_nums[i] == sorted_nums[i - 1] + 1:\\n                current_length += 1\\n            else:\\n                max_length = max(max_length, current_length)\\n                current_length = 1\\n\\n        return max(max_length, current_length)\\n\\n\\n"
                    },
                    {
                        "username": "SureDoo",
                        "content": "[@georgezakharov](/georgezakharov) And when he uses \\'sort\\', the solution can not meet the requirement O(n)."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "julian_sikora",
                        "content": "Why is iterating throw the nums as a set much faster than iterating throw the list?\n\nSo why is:\nfor n in nums:\n     pass\n\nslower than\n\nfor n in set(nums):\n    pass\n\nShouldn't it be more or less the same? For me it was the difference between being better than 40% of the solutions to being better than 98% and I don't really get why?"
                    },
                    {
                        "username": "treat",
                        "content": "If you are not preparing for any of these weekly competitions, don't bother yourself with such details. What is more important is that you understand all the different approaches that can be used to solve a problem. Also once you understand do code down your own solution. "
                    },
                    {
                        "username": "RealNameHidden",
                        "content": "Did it using a priority queue, bot the most optimal but its accepted.\\n\\n `class Solution {\\n    public int longestConsecutive(int[] nums) {\\n        Queue<Integer> pq = new PriorityQueue<>((a,b)->a-b);\\n        if(nums.length==0){\\n            return 0;\\n        }\\n        for(int i=0; i<nums.length; i++){\\n            pq.add(nums[i]);\\n        }\\n        \\n        int maxLen = 1;\\n        int currLen = 1;\\n        int prevEle = pq.remove();\\n        while(!pq.isEmpty()){\\n            int curr = pq.remove();\\n            if(curr==prevEle){\\n                continue;\\n            }\\n            if(Math.abs(curr-prevEle)==1){\\n                currLen++;\\n                maxLen = Math.max(maxLen,currLen);\\n            } else{\\n                currLen = 1;\\n            }\\n            prevEle = curr;\\n        }\\n        return maxLen;\\n    }\\n}`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "AnthonyShuey",
                        "content": "Give me a score based on how good this solution is on a scale of 0-10: \\nimport heapq\\nclass Solution:\\n    def longestConsecutive(self, nums: List[int]) -> int:\\n        if len(nums)==0:\\n            return 0\\n        h = set()\\n        for i in nums:\\n            if i in h:\\n                continue\\n            else:\\n                h.add(i)\\n        helper =h.copy()\\n        longest = 1\\n        for num in helper:\\n            if num in h:\\n                l =1\\n                start = num-1\\n                while start in h:\\n                    l+=1\\n                    start = start-1\\n                    h.remove(start+1)\\n                start = num+1\\n                while start in h:\\n                    l+=1\\n                    start = start+1\\n                    h.remove(start-1)\\n                if l > longest:\\n                    longest = l\\n        return longest"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "AnthonyShuey",
                        "content": "Will someone tell me why my code beats 65% of other submissions even though it is nlogn. I removed the duplicates then used a heap to pop the smallest off and check if the next one to be popped off is 1 greater than the currently one that is popped off. If so, then I will increase l. I do this until there are no other elements. The \"while numsy\" is worse case O(n) and then we do \"start = heapq.heappop(numsy)\" which is logn. Therefore, my solution is nlogn. \\nHere is the exact code: \\n\\nimport heapq\\nclass Solution:\\n    def longestConsecutive(self, nums: List[int]) -> int:\\n        h = set()\\n        for i in nums:\\n            if i in h:\\n                continue\\n            else:\\n                h.add(i)\\n        numsy =[]\\n        for i in h:\\n            numsy.append(i)\\n        for i in range(0,len(numsy)):\\n            numsy[i]*=-1\\n        heapq.heapify(numsy)\\n        longest = 1\\n        if len(numsy)==0:\\n            return 0\\n        while numsy:\\n            l =1\\n            start = heapq.heappop(numsy)\\n            while len(numsy)>0 and numsy[0]==start+1:\\n                l+=1\\n                start = heapq.heappop(numsy)\\n            if l>longest:\\n                longest = l\\n        return longest"
                    },
                    {
                        "username": "dragosarsene7",
                        "content": "For everyone using set to get O(n), if you do not remove elements as you go, your complexity would be O(n*sqrt(n)) worst-case, eg. {0, 1, 2, 4, 5, 6, 8, 9, 10}, where you have sqrt(n) clusters of sqrt(n) consecutive elements each"
                    },
                    {
                        "username": "Szymon5922",
                        "content": "I strongly recommend SortedSet; Algo faster than 96.20% of sumbissions with C# created with low effort."
                    },
                    {
                        "username": "Pikiato",
                        "content": "Why is [-6,-1,-1,9,-8,-6,-6,4,4,-3,-8,-1] returns 1 ?? there are no consecutive numbers?? I\\'m confused. Please help me."
                    },
                    {
                        "username": "sakshamgaur96",
                        "content": "what is wrong yaar with this 25th test case how come it is expecting output to be 7 , like howwww?????\\nin the test case it is given that the sample inputs are: [9,1,4,7,3,-1,0,5,8,-1,6]\\nsince they are asking for LONGEST CONSECUTIVE , and i just can\\'t get where the fuck is \\'2\\' in the given array and without that how come they are expecting the length of 7 to be the output of the program !!!"
                    },
                    {
                        "username": "Orange_Smuggler",
                        "content": "[3,4,5,6,7,8,9]"
                    },
                    {
                        "username": "Orange_Smuggler",
                        "content": "I'm kinda puzzled: [1,2,1,1,1,1,3,3,3,3,4] has to be 4 for LeetCode. But the given examples kinda missed the point here. My initial guess was that we're looking for possible consecutive sequences with a strict relation to amount of numbers in array. Say, we sort my example, we get this: [1,1,1,1,1,2,3,3,3,3,4]. I thought that the answer is 3, because you can clearly see consecutive sequence [1,2,3]. But the answer 4 suggests that we also include 4, despite having four '3's? This is huge oversight and kinda lame in my opinion. Is there any point in counting these numbers at all?"
                    },
                    {
                        "username": "2uringTested",
                        "content": "I dont think its an oversight. They have clearly mentioned that the sequence has the following property:\\n\\n\"It is a consecutive sequence\"\\n\\nmeaning that for every index \\'i\\' in the sequence, a[i+1] = a[i] +1\\n\\nso if the sequence was {1,2,3,3} the property is violated at the i = 2, where a[i+1] != a[i]+1\\nso 4 is infact the correct answer for [1,2,1,1,1,1,3,3,3,3,3,4] as the longest sequence which follows this property is {1,2,3,4}."
                    }
                ]
            },
            {
                "id": 1998682,
                "content": [
                    {
                        "username": "Manoj_Chavva",
                        "content": "Is this code correct\\nclass Solution(object):\\n    def longestConsecutive(nums):\\n        if not nums:\\n            return 0\\n\\n        sorted_nums = sorted(set(nums))  # Sort and remove duplicates\\n\\n        max_length = 1\\n        current_length = 1\\n\\n        for i in range(1, len(sorted_nums)):\\n            if sorted_nums[i] == sorted_nums[i - 1] + 1:\\n                current_length += 1\\n            else:\\n                max_length = max(max_length, current_length)\\n                current_length = 1\\n\\n        return max(max_length, current_length)\\n\\n\\n"
                    },
                    {
                        "username": "SureDoo",
                        "content": "[@georgezakharov](/georgezakharov) And when he uses \\'sort\\', the solution can not meet the requirement O(n)."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "julian_sikora",
                        "content": "Why is iterating throw the nums as a set much faster than iterating throw the list?\n\nSo why is:\nfor n in nums:\n     pass\n\nslower than\n\nfor n in set(nums):\n    pass\n\nShouldn't it be more or less the same? For me it was the difference between being better than 40% of the solutions to being better than 98% and I don't really get why?"
                    },
                    {
                        "username": "treat",
                        "content": "If you are not preparing for any of these weekly competitions, don't bother yourself with such details. What is more important is that you understand all the different approaches that can be used to solve a problem. Also once you understand do code down your own solution. "
                    },
                    {
                        "username": "RealNameHidden",
                        "content": "Did it using a priority queue, bot the most optimal but its accepted.\\n\\n `class Solution {\\n    public int longestConsecutive(int[] nums) {\\n        Queue<Integer> pq = new PriorityQueue<>((a,b)->a-b);\\n        if(nums.length==0){\\n            return 0;\\n        }\\n        for(int i=0; i<nums.length; i++){\\n            pq.add(nums[i]);\\n        }\\n        \\n        int maxLen = 1;\\n        int currLen = 1;\\n        int prevEle = pq.remove();\\n        while(!pq.isEmpty()){\\n            int curr = pq.remove();\\n            if(curr==prevEle){\\n                continue;\\n            }\\n            if(Math.abs(curr-prevEle)==1){\\n                currLen++;\\n                maxLen = Math.max(maxLen,currLen);\\n            } else{\\n                currLen = 1;\\n            }\\n            prevEle = curr;\\n        }\\n        return maxLen;\\n    }\\n}`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "AnthonyShuey",
                        "content": "Give me a score based on how good this solution is on a scale of 0-10: \\nimport heapq\\nclass Solution:\\n    def longestConsecutive(self, nums: List[int]) -> int:\\n        if len(nums)==0:\\n            return 0\\n        h = set()\\n        for i in nums:\\n            if i in h:\\n                continue\\n            else:\\n                h.add(i)\\n        helper =h.copy()\\n        longest = 1\\n        for num in helper:\\n            if num in h:\\n                l =1\\n                start = num-1\\n                while start in h:\\n                    l+=1\\n                    start = start-1\\n                    h.remove(start+1)\\n                start = num+1\\n                while start in h:\\n                    l+=1\\n                    start = start+1\\n                    h.remove(start-1)\\n                if l > longest:\\n                    longest = l\\n        return longest"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "AnthonyShuey",
                        "content": "Will someone tell me why my code beats 65% of other submissions even though it is nlogn. I removed the duplicates then used a heap to pop the smallest off and check if the next one to be popped off is 1 greater than the currently one that is popped off. If so, then I will increase l. I do this until there are no other elements. The \"while numsy\" is worse case O(n) and then we do \"start = heapq.heappop(numsy)\" which is logn. Therefore, my solution is nlogn. \\nHere is the exact code: \\n\\nimport heapq\\nclass Solution:\\n    def longestConsecutive(self, nums: List[int]) -> int:\\n        h = set()\\n        for i in nums:\\n            if i in h:\\n                continue\\n            else:\\n                h.add(i)\\n        numsy =[]\\n        for i in h:\\n            numsy.append(i)\\n        for i in range(0,len(numsy)):\\n            numsy[i]*=-1\\n        heapq.heapify(numsy)\\n        longest = 1\\n        if len(numsy)==0:\\n            return 0\\n        while numsy:\\n            l =1\\n            start = heapq.heappop(numsy)\\n            while len(numsy)>0 and numsy[0]==start+1:\\n                l+=1\\n                start = heapq.heappop(numsy)\\n            if l>longest:\\n                longest = l\\n        return longest"
                    },
                    {
                        "username": "dragosarsene7",
                        "content": "For everyone using set to get O(n), if you do not remove elements as you go, your complexity would be O(n*sqrt(n)) worst-case, eg. {0, 1, 2, 4, 5, 6, 8, 9, 10}, where you have sqrt(n) clusters of sqrt(n) consecutive elements each"
                    },
                    {
                        "username": "Szymon5922",
                        "content": "I strongly recommend SortedSet; Algo faster than 96.20% of sumbissions with C# created with low effort."
                    },
                    {
                        "username": "Pikiato",
                        "content": "Why is [-6,-1,-1,9,-8,-6,-6,4,4,-3,-8,-1] returns 1 ?? there are no consecutive numbers?? I\\'m confused. Please help me."
                    },
                    {
                        "username": "sakshamgaur96",
                        "content": "what is wrong yaar with this 25th test case how come it is expecting output to be 7 , like howwww?????\\nin the test case it is given that the sample inputs are: [9,1,4,7,3,-1,0,5,8,-1,6]\\nsince they are asking for LONGEST CONSECUTIVE , and i just can\\'t get where the fuck is \\'2\\' in the given array and without that how come they are expecting the length of 7 to be the output of the program !!!"
                    },
                    {
                        "username": "Orange_Smuggler",
                        "content": "[3,4,5,6,7,8,9]"
                    },
                    {
                        "username": "Orange_Smuggler",
                        "content": "I'm kinda puzzled: [1,2,1,1,1,1,3,3,3,3,4] has to be 4 for LeetCode. But the given examples kinda missed the point here. My initial guess was that we're looking for possible consecutive sequences with a strict relation to amount of numbers in array. Say, we sort my example, we get this: [1,1,1,1,1,2,3,3,3,3,4]. I thought that the answer is 3, because you can clearly see consecutive sequence [1,2,3]. But the answer 4 suggests that we also include 4, despite having four '3's? This is huge oversight and kinda lame in my opinion. Is there any point in counting these numbers at all?"
                    },
                    {
                        "username": "2uringTested",
                        "content": "I dont think its an oversight. They have clearly mentioned that the sequence has the following property:\\n\\n\"It is a consecutive sequence\"\\n\\nmeaning that for every index \\'i\\' in the sequence, a[i+1] = a[i] +1\\n\\nso if the sequence was {1,2,3,3} the property is violated at the i = 2, where a[i+1] != a[i]+1\\nso 4 is infact the correct answer for [1,2,1,1,1,1,3,3,3,3,3,4] as the longest sequence which follows this property is {1,2,3,4}."
                    }
                ]
            },
            {
                "id": 1995071,
                "content": [
                    {
                        "username": "Manoj_Chavva",
                        "content": "Is this code correct\\nclass Solution(object):\\n    def longestConsecutive(nums):\\n        if not nums:\\n            return 0\\n\\n        sorted_nums = sorted(set(nums))  # Sort and remove duplicates\\n\\n        max_length = 1\\n        current_length = 1\\n\\n        for i in range(1, len(sorted_nums)):\\n            if sorted_nums[i] == sorted_nums[i - 1] + 1:\\n                current_length += 1\\n            else:\\n                max_length = max(max_length, current_length)\\n                current_length = 1\\n\\n        return max(max_length, current_length)\\n\\n\\n"
                    },
                    {
                        "username": "SureDoo",
                        "content": "[@georgezakharov](/georgezakharov) And when he uses \\'sort\\', the solution can not meet the requirement O(n)."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "julian_sikora",
                        "content": "Why is iterating throw the nums as a set much faster than iterating throw the list?\n\nSo why is:\nfor n in nums:\n     pass\n\nslower than\n\nfor n in set(nums):\n    pass\n\nShouldn't it be more or less the same? For me it was the difference between being better than 40% of the solutions to being better than 98% and I don't really get why?"
                    },
                    {
                        "username": "treat",
                        "content": "If you are not preparing for any of these weekly competitions, don't bother yourself with such details. What is more important is that you understand all the different approaches that can be used to solve a problem. Also once you understand do code down your own solution. "
                    },
                    {
                        "username": "RealNameHidden",
                        "content": "Did it using a priority queue, bot the most optimal but its accepted.\\n\\n `class Solution {\\n    public int longestConsecutive(int[] nums) {\\n        Queue<Integer> pq = new PriorityQueue<>((a,b)->a-b);\\n        if(nums.length==0){\\n            return 0;\\n        }\\n        for(int i=0; i<nums.length; i++){\\n            pq.add(nums[i]);\\n        }\\n        \\n        int maxLen = 1;\\n        int currLen = 1;\\n        int prevEle = pq.remove();\\n        while(!pq.isEmpty()){\\n            int curr = pq.remove();\\n            if(curr==prevEle){\\n                continue;\\n            }\\n            if(Math.abs(curr-prevEle)==1){\\n                currLen++;\\n                maxLen = Math.max(maxLen,currLen);\\n            } else{\\n                currLen = 1;\\n            }\\n            prevEle = curr;\\n        }\\n        return maxLen;\\n    }\\n}`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "AnthonyShuey",
                        "content": "Give me a score based on how good this solution is on a scale of 0-10: \\nimport heapq\\nclass Solution:\\n    def longestConsecutive(self, nums: List[int]) -> int:\\n        if len(nums)==0:\\n            return 0\\n        h = set()\\n        for i in nums:\\n            if i in h:\\n                continue\\n            else:\\n                h.add(i)\\n        helper =h.copy()\\n        longest = 1\\n        for num in helper:\\n            if num in h:\\n                l =1\\n                start = num-1\\n                while start in h:\\n                    l+=1\\n                    start = start-1\\n                    h.remove(start+1)\\n                start = num+1\\n                while start in h:\\n                    l+=1\\n                    start = start+1\\n                    h.remove(start-1)\\n                if l > longest:\\n                    longest = l\\n        return longest"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "AnthonyShuey",
                        "content": "Will someone tell me why my code beats 65% of other submissions even though it is nlogn. I removed the duplicates then used a heap to pop the smallest off and check if the next one to be popped off is 1 greater than the currently one that is popped off. If so, then I will increase l. I do this until there are no other elements. The \"while numsy\" is worse case O(n) and then we do \"start = heapq.heappop(numsy)\" which is logn. Therefore, my solution is nlogn. \\nHere is the exact code: \\n\\nimport heapq\\nclass Solution:\\n    def longestConsecutive(self, nums: List[int]) -> int:\\n        h = set()\\n        for i in nums:\\n            if i in h:\\n                continue\\n            else:\\n                h.add(i)\\n        numsy =[]\\n        for i in h:\\n            numsy.append(i)\\n        for i in range(0,len(numsy)):\\n            numsy[i]*=-1\\n        heapq.heapify(numsy)\\n        longest = 1\\n        if len(numsy)==0:\\n            return 0\\n        while numsy:\\n            l =1\\n            start = heapq.heappop(numsy)\\n            while len(numsy)>0 and numsy[0]==start+1:\\n                l+=1\\n                start = heapq.heappop(numsy)\\n            if l>longest:\\n                longest = l\\n        return longest"
                    },
                    {
                        "username": "dragosarsene7",
                        "content": "For everyone using set to get O(n), if you do not remove elements as you go, your complexity would be O(n*sqrt(n)) worst-case, eg. {0, 1, 2, 4, 5, 6, 8, 9, 10}, where you have sqrt(n) clusters of sqrt(n) consecutive elements each"
                    },
                    {
                        "username": "Szymon5922",
                        "content": "I strongly recommend SortedSet; Algo faster than 96.20% of sumbissions with C# created with low effort."
                    },
                    {
                        "username": "Pikiato",
                        "content": "Why is [-6,-1,-1,9,-8,-6,-6,4,4,-3,-8,-1] returns 1 ?? there are no consecutive numbers?? I\\'m confused. Please help me."
                    },
                    {
                        "username": "sakshamgaur96",
                        "content": "what is wrong yaar with this 25th test case how come it is expecting output to be 7 , like howwww?????\\nin the test case it is given that the sample inputs are: [9,1,4,7,3,-1,0,5,8,-1,6]\\nsince they are asking for LONGEST CONSECUTIVE , and i just can\\'t get where the fuck is \\'2\\' in the given array and without that how come they are expecting the length of 7 to be the output of the program !!!"
                    },
                    {
                        "username": "Orange_Smuggler",
                        "content": "[3,4,5,6,7,8,9]"
                    },
                    {
                        "username": "Orange_Smuggler",
                        "content": "I'm kinda puzzled: [1,2,1,1,1,1,3,3,3,3,4] has to be 4 for LeetCode. But the given examples kinda missed the point here. My initial guess was that we're looking for possible consecutive sequences with a strict relation to amount of numbers in array. Say, we sort my example, we get this: [1,1,1,1,1,2,3,3,3,3,4]. I thought that the answer is 3, because you can clearly see consecutive sequence [1,2,3]. But the answer 4 suggests that we also include 4, despite having four '3's? This is huge oversight and kinda lame in my opinion. Is there any point in counting these numbers at all?"
                    },
                    {
                        "username": "2uringTested",
                        "content": "I dont think its an oversight. They have clearly mentioned that the sequence has the following property:\\n\\n\"It is a consecutive sequence\"\\n\\nmeaning that for every index \\'i\\' in the sequence, a[i+1] = a[i] +1\\n\\nso if the sequence was {1,2,3,3} the property is violated at the i = 2, where a[i+1] != a[i]+1\\nso 4 is infact the correct answer for [1,2,1,1,1,1,3,3,3,3,3,4] as the longest sequence which follows this property is {1,2,3,4}."
                    }
                ]
            },
            {
                "id": 1993829,
                "content": [
                    {
                        "username": "Manoj_Chavva",
                        "content": "Is this code correct\\nclass Solution(object):\\n    def longestConsecutive(nums):\\n        if not nums:\\n            return 0\\n\\n        sorted_nums = sorted(set(nums))  # Sort and remove duplicates\\n\\n        max_length = 1\\n        current_length = 1\\n\\n        for i in range(1, len(sorted_nums)):\\n            if sorted_nums[i] == sorted_nums[i - 1] + 1:\\n                current_length += 1\\n            else:\\n                max_length = max(max_length, current_length)\\n                current_length = 1\\n\\n        return max(max_length, current_length)\\n\\n\\n"
                    },
                    {
                        "username": "SureDoo",
                        "content": "[@georgezakharov](/georgezakharov) And when he uses \\'sort\\', the solution can not meet the requirement O(n)."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "julian_sikora",
                        "content": "Why is iterating throw the nums as a set much faster than iterating throw the list?\n\nSo why is:\nfor n in nums:\n     pass\n\nslower than\n\nfor n in set(nums):\n    pass\n\nShouldn't it be more or less the same? For me it was the difference between being better than 40% of the solutions to being better than 98% and I don't really get why?"
                    },
                    {
                        "username": "treat",
                        "content": "If you are not preparing for any of these weekly competitions, don't bother yourself with such details. What is more important is that you understand all the different approaches that can be used to solve a problem. Also once you understand do code down your own solution. "
                    },
                    {
                        "username": "RealNameHidden",
                        "content": "Did it using a priority queue, bot the most optimal but its accepted.\\n\\n `class Solution {\\n    public int longestConsecutive(int[] nums) {\\n        Queue<Integer> pq = new PriorityQueue<>((a,b)->a-b);\\n        if(nums.length==0){\\n            return 0;\\n        }\\n        for(int i=0; i<nums.length; i++){\\n            pq.add(nums[i]);\\n        }\\n        \\n        int maxLen = 1;\\n        int currLen = 1;\\n        int prevEle = pq.remove();\\n        while(!pq.isEmpty()){\\n            int curr = pq.remove();\\n            if(curr==prevEle){\\n                continue;\\n            }\\n            if(Math.abs(curr-prevEle)==1){\\n                currLen++;\\n                maxLen = Math.max(maxLen,currLen);\\n            } else{\\n                currLen = 1;\\n            }\\n            prevEle = curr;\\n        }\\n        return maxLen;\\n    }\\n}`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "AnthonyShuey",
                        "content": "Give me a score based on how good this solution is on a scale of 0-10: \\nimport heapq\\nclass Solution:\\n    def longestConsecutive(self, nums: List[int]) -> int:\\n        if len(nums)==0:\\n            return 0\\n        h = set()\\n        for i in nums:\\n            if i in h:\\n                continue\\n            else:\\n                h.add(i)\\n        helper =h.copy()\\n        longest = 1\\n        for num in helper:\\n            if num in h:\\n                l =1\\n                start = num-1\\n                while start in h:\\n                    l+=1\\n                    start = start-1\\n                    h.remove(start+1)\\n                start = num+1\\n                while start in h:\\n                    l+=1\\n                    start = start+1\\n                    h.remove(start-1)\\n                if l > longest:\\n                    longest = l\\n        return longest"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "AnthonyShuey",
                        "content": "Will someone tell me why my code beats 65% of other submissions even though it is nlogn. I removed the duplicates then used a heap to pop the smallest off and check if the next one to be popped off is 1 greater than the currently one that is popped off. If so, then I will increase l. I do this until there are no other elements. The \"while numsy\" is worse case O(n) and then we do \"start = heapq.heappop(numsy)\" which is logn. Therefore, my solution is nlogn. \\nHere is the exact code: \\n\\nimport heapq\\nclass Solution:\\n    def longestConsecutive(self, nums: List[int]) -> int:\\n        h = set()\\n        for i in nums:\\n            if i in h:\\n                continue\\n            else:\\n                h.add(i)\\n        numsy =[]\\n        for i in h:\\n            numsy.append(i)\\n        for i in range(0,len(numsy)):\\n            numsy[i]*=-1\\n        heapq.heapify(numsy)\\n        longest = 1\\n        if len(numsy)==0:\\n            return 0\\n        while numsy:\\n            l =1\\n            start = heapq.heappop(numsy)\\n            while len(numsy)>0 and numsy[0]==start+1:\\n                l+=1\\n                start = heapq.heappop(numsy)\\n            if l>longest:\\n                longest = l\\n        return longest"
                    },
                    {
                        "username": "dragosarsene7",
                        "content": "For everyone using set to get O(n), if you do not remove elements as you go, your complexity would be O(n*sqrt(n)) worst-case, eg. {0, 1, 2, 4, 5, 6, 8, 9, 10}, where you have sqrt(n) clusters of sqrt(n) consecutive elements each"
                    },
                    {
                        "username": "Szymon5922",
                        "content": "I strongly recommend SortedSet; Algo faster than 96.20% of sumbissions with C# created with low effort."
                    },
                    {
                        "username": "Pikiato",
                        "content": "Why is [-6,-1,-1,9,-8,-6,-6,4,4,-3,-8,-1] returns 1 ?? there are no consecutive numbers?? I\\'m confused. Please help me."
                    },
                    {
                        "username": "sakshamgaur96",
                        "content": "what is wrong yaar with this 25th test case how come it is expecting output to be 7 , like howwww?????\\nin the test case it is given that the sample inputs are: [9,1,4,7,3,-1,0,5,8,-1,6]\\nsince they are asking for LONGEST CONSECUTIVE , and i just can\\'t get where the fuck is \\'2\\' in the given array and without that how come they are expecting the length of 7 to be the output of the program !!!"
                    },
                    {
                        "username": "Orange_Smuggler",
                        "content": "[3,4,5,6,7,8,9]"
                    },
                    {
                        "username": "Orange_Smuggler",
                        "content": "I'm kinda puzzled: [1,2,1,1,1,1,3,3,3,3,4] has to be 4 for LeetCode. But the given examples kinda missed the point here. My initial guess was that we're looking for possible consecutive sequences with a strict relation to amount of numbers in array. Say, we sort my example, we get this: [1,1,1,1,1,2,3,3,3,3,4]. I thought that the answer is 3, because you can clearly see consecutive sequence [1,2,3]. But the answer 4 suggests that we also include 4, despite having four '3's? This is huge oversight and kinda lame in my opinion. Is there any point in counting these numbers at all?"
                    },
                    {
                        "username": "2uringTested",
                        "content": "I dont think its an oversight. They have clearly mentioned that the sequence has the following property:\\n\\n\"It is a consecutive sequence\"\\n\\nmeaning that for every index \\'i\\' in the sequence, a[i+1] = a[i] +1\\n\\nso if the sequence was {1,2,3,3} the property is violated at the i = 2, where a[i+1] != a[i]+1\\nso 4 is infact the correct answer for [1,2,1,1,1,1,3,3,3,3,3,4] as the longest sequence which follows this property is {1,2,3,4}."
                    }
                ]
            },
            {
                "id": 1992592,
                "content": [
                    {
                        "username": "Manoj_Chavva",
                        "content": "Is this code correct\\nclass Solution(object):\\n    def longestConsecutive(nums):\\n        if not nums:\\n            return 0\\n\\n        sorted_nums = sorted(set(nums))  # Sort and remove duplicates\\n\\n        max_length = 1\\n        current_length = 1\\n\\n        for i in range(1, len(sorted_nums)):\\n            if sorted_nums[i] == sorted_nums[i - 1] + 1:\\n                current_length += 1\\n            else:\\n                max_length = max(max_length, current_length)\\n                current_length = 1\\n\\n        return max(max_length, current_length)\\n\\n\\n"
                    },
                    {
                        "username": "SureDoo",
                        "content": "[@georgezakharov](/georgezakharov) And when he uses \\'sort\\', the solution can not meet the requirement O(n)."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "julian_sikora",
                        "content": "Why is iterating throw the nums as a set much faster than iterating throw the list?\n\nSo why is:\nfor n in nums:\n     pass\n\nslower than\n\nfor n in set(nums):\n    pass\n\nShouldn't it be more or less the same? For me it was the difference between being better than 40% of the solutions to being better than 98% and I don't really get why?"
                    },
                    {
                        "username": "treat",
                        "content": "If you are not preparing for any of these weekly competitions, don't bother yourself with such details. What is more important is that you understand all the different approaches that can be used to solve a problem. Also once you understand do code down your own solution. "
                    },
                    {
                        "username": "RealNameHidden",
                        "content": "Did it using a priority queue, bot the most optimal but its accepted.\\n\\n `class Solution {\\n    public int longestConsecutive(int[] nums) {\\n        Queue<Integer> pq = new PriorityQueue<>((a,b)->a-b);\\n        if(nums.length==0){\\n            return 0;\\n        }\\n        for(int i=0; i<nums.length; i++){\\n            pq.add(nums[i]);\\n        }\\n        \\n        int maxLen = 1;\\n        int currLen = 1;\\n        int prevEle = pq.remove();\\n        while(!pq.isEmpty()){\\n            int curr = pq.remove();\\n            if(curr==prevEle){\\n                continue;\\n            }\\n            if(Math.abs(curr-prevEle)==1){\\n                currLen++;\\n                maxLen = Math.max(maxLen,currLen);\\n            } else{\\n                currLen = 1;\\n            }\\n            prevEle = curr;\\n        }\\n        return maxLen;\\n    }\\n}`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "AnthonyShuey",
                        "content": "Give me a score based on how good this solution is on a scale of 0-10: \\nimport heapq\\nclass Solution:\\n    def longestConsecutive(self, nums: List[int]) -> int:\\n        if len(nums)==0:\\n            return 0\\n        h = set()\\n        for i in nums:\\n            if i in h:\\n                continue\\n            else:\\n                h.add(i)\\n        helper =h.copy()\\n        longest = 1\\n        for num in helper:\\n            if num in h:\\n                l =1\\n                start = num-1\\n                while start in h:\\n                    l+=1\\n                    start = start-1\\n                    h.remove(start+1)\\n                start = num+1\\n                while start in h:\\n                    l+=1\\n                    start = start+1\\n                    h.remove(start-1)\\n                if l > longest:\\n                    longest = l\\n        return longest"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "AnthonyShuey",
                        "content": "Will someone tell me why my code beats 65% of other submissions even though it is nlogn. I removed the duplicates then used a heap to pop the smallest off and check if the next one to be popped off is 1 greater than the currently one that is popped off. If so, then I will increase l. I do this until there are no other elements. The \"while numsy\" is worse case O(n) and then we do \"start = heapq.heappop(numsy)\" which is logn. Therefore, my solution is nlogn. \\nHere is the exact code: \\n\\nimport heapq\\nclass Solution:\\n    def longestConsecutive(self, nums: List[int]) -> int:\\n        h = set()\\n        for i in nums:\\n            if i in h:\\n                continue\\n            else:\\n                h.add(i)\\n        numsy =[]\\n        for i in h:\\n            numsy.append(i)\\n        for i in range(0,len(numsy)):\\n            numsy[i]*=-1\\n        heapq.heapify(numsy)\\n        longest = 1\\n        if len(numsy)==0:\\n            return 0\\n        while numsy:\\n            l =1\\n            start = heapq.heappop(numsy)\\n            while len(numsy)>0 and numsy[0]==start+1:\\n                l+=1\\n                start = heapq.heappop(numsy)\\n            if l>longest:\\n                longest = l\\n        return longest"
                    },
                    {
                        "username": "dragosarsene7",
                        "content": "For everyone using set to get O(n), if you do not remove elements as you go, your complexity would be O(n*sqrt(n)) worst-case, eg. {0, 1, 2, 4, 5, 6, 8, 9, 10}, where you have sqrt(n) clusters of sqrt(n) consecutive elements each"
                    },
                    {
                        "username": "Szymon5922",
                        "content": "I strongly recommend SortedSet; Algo faster than 96.20% of sumbissions with C# created with low effort."
                    },
                    {
                        "username": "Pikiato",
                        "content": "Why is [-6,-1,-1,9,-8,-6,-6,4,4,-3,-8,-1] returns 1 ?? there are no consecutive numbers?? I\\'m confused. Please help me."
                    },
                    {
                        "username": "sakshamgaur96",
                        "content": "what is wrong yaar with this 25th test case how come it is expecting output to be 7 , like howwww?????\\nin the test case it is given that the sample inputs are: [9,1,4,7,3,-1,0,5,8,-1,6]\\nsince they are asking for LONGEST CONSECUTIVE , and i just can\\'t get where the fuck is \\'2\\' in the given array and without that how come they are expecting the length of 7 to be the output of the program !!!"
                    },
                    {
                        "username": "Orange_Smuggler",
                        "content": "[3,4,5,6,7,8,9]"
                    },
                    {
                        "username": "Orange_Smuggler",
                        "content": "I'm kinda puzzled: [1,2,1,1,1,1,3,3,3,3,4] has to be 4 for LeetCode. But the given examples kinda missed the point here. My initial guess was that we're looking for possible consecutive sequences with a strict relation to amount of numbers in array. Say, we sort my example, we get this: [1,1,1,1,1,2,3,3,3,3,4]. I thought that the answer is 3, because you can clearly see consecutive sequence [1,2,3]. But the answer 4 suggests that we also include 4, despite having four '3's? This is huge oversight and kinda lame in my opinion. Is there any point in counting these numbers at all?"
                    },
                    {
                        "username": "2uringTested",
                        "content": "I dont think its an oversight. They have clearly mentioned that the sequence has the following property:\\n\\n\"It is a consecutive sequence\"\\n\\nmeaning that for every index \\'i\\' in the sequence, a[i+1] = a[i] +1\\n\\nso if the sequence was {1,2,3,3} the property is violated at the i = 2, where a[i+1] != a[i]+1\\nso 4 is infact the correct answer for [1,2,1,1,1,1,3,3,3,3,3,4] as the longest sequence which follows this property is {1,2,3,4}."
                    }
                ]
            },
            {
                "id": 1990858,
                "content": [
                    {
                        "username": "Manoj_Chavva",
                        "content": "Is this code correct\\nclass Solution(object):\\n    def longestConsecutive(nums):\\n        if not nums:\\n            return 0\\n\\n        sorted_nums = sorted(set(nums))  # Sort and remove duplicates\\n\\n        max_length = 1\\n        current_length = 1\\n\\n        for i in range(1, len(sorted_nums)):\\n            if sorted_nums[i] == sorted_nums[i - 1] + 1:\\n                current_length += 1\\n            else:\\n                max_length = max(max_length, current_length)\\n                current_length = 1\\n\\n        return max(max_length, current_length)\\n\\n\\n"
                    },
                    {
                        "username": "SureDoo",
                        "content": "[@georgezakharov](/georgezakharov) And when he uses \\'sort\\', the solution can not meet the requirement O(n)."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "julian_sikora",
                        "content": "Why is iterating throw the nums as a set much faster than iterating throw the list?\n\nSo why is:\nfor n in nums:\n     pass\n\nslower than\n\nfor n in set(nums):\n    pass\n\nShouldn't it be more or less the same? For me it was the difference between being better than 40% of the solutions to being better than 98% and I don't really get why?"
                    },
                    {
                        "username": "treat",
                        "content": "If you are not preparing for any of these weekly competitions, don't bother yourself with such details. What is more important is that you understand all the different approaches that can be used to solve a problem. Also once you understand do code down your own solution. "
                    },
                    {
                        "username": "RealNameHidden",
                        "content": "Did it using a priority queue, bot the most optimal but its accepted.\\n\\n `class Solution {\\n    public int longestConsecutive(int[] nums) {\\n        Queue<Integer> pq = new PriorityQueue<>((a,b)->a-b);\\n        if(nums.length==0){\\n            return 0;\\n        }\\n        for(int i=0; i<nums.length; i++){\\n            pq.add(nums[i]);\\n        }\\n        \\n        int maxLen = 1;\\n        int currLen = 1;\\n        int prevEle = pq.remove();\\n        while(!pq.isEmpty()){\\n            int curr = pq.remove();\\n            if(curr==prevEle){\\n                continue;\\n            }\\n            if(Math.abs(curr-prevEle)==1){\\n                currLen++;\\n                maxLen = Math.max(maxLen,currLen);\\n            } else{\\n                currLen = 1;\\n            }\\n            prevEle = curr;\\n        }\\n        return maxLen;\\n    }\\n}`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "AnthonyShuey",
                        "content": "Give me a score based on how good this solution is on a scale of 0-10: \\nimport heapq\\nclass Solution:\\n    def longestConsecutive(self, nums: List[int]) -> int:\\n        if len(nums)==0:\\n            return 0\\n        h = set()\\n        for i in nums:\\n            if i in h:\\n                continue\\n            else:\\n                h.add(i)\\n        helper =h.copy()\\n        longest = 1\\n        for num in helper:\\n            if num in h:\\n                l =1\\n                start = num-1\\n                while start in h:\\n                    l+=1\\n                    start = start-1\\n                    h.remove(start+1)\\n                start = num+1\\n                while start in h:\\n                    l+=1\\n                    start = start+1\\n                    h.remove(start-1)\\n                if l > longest:\\n                    longest = l\\n        return longest"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "AnthonyShuey",
                        "content": "Will someone tell me why my code beats 65% of other submissions even though it is nlogn. I removed the duplicates then used a heap to pop the smallest off and check if the next one to be popped off is 1 greater than the currently one that is popped off. If so, then I will increase l. I do this until there are no other elements. The \"while numsy\" is worse case O(n) and then we do \"start = heapq.heappop(numsy)\" which is logn. Therefore, my solution is nlogn. \\nHere is the exact code: \\n\\nimport heapq\\nclass Solution:\\n    def longestConsecutive(self, nums: List[int]) -> int:\\n        h = set()\\n        for i in nums:\\n            if i in h:\\n                continue\\n            else:\\n                h.add(i)\\n        numsy =[]\\n        for i in h:\\n            numsy.append(i)\\n        for i in range(0,len(numsy)):\\n            numsy[i]*=-1\\n        heapq.heapify(numsy)\\n        longest = 1\\n        if len(numsy)==0:\\n            return 0\\n        while numsy:\\n            l =1\\n            start = heapq.heappop(numsy)\\n            while len(numsy)>0 and numsy[0]==start+1:\\n                l+=1\\n                start = heapq.heappop(numsy)\\n            if l>longest:\\n                longest = l\\n        return longest"
                    },
                    {
                        "username": "dragosarsene7",
                        "content": "For everyone using set to get O(n), if you do not remove elements as you go, your complexity would be O(n*sqrt(n)) worst-case, eg. {0, 1, 2, 4, 5, 6, 8, 9, 10}, where you have sqrt(n) clusters of sqrt(n) consecutive elements each"
                    },
                    {
                        "username": "Szymon5922",
                        "content": "I strongly recommend SortedSet; Algo faster than 96.20% of sumbissions with C# created with low effort."
                    },
                    {
                        "username": "Pikiato",
                        "content": "Why is [-6,-1,-1,9,-8,-6,-6,4,4,-3,-8,-1] returns 1 ?? there are no consecutive numbers?? I\\'m confused. Please help me."
                    },
                    {
                        "username": "sakshamgaur96",
                        "content": "what is wrong yaar with this 25th test case how come it is expecting output to be 7 , like howwww?????\\nin the test case it is given that the sample inputs are: [9,1,4,7,3,-1,0,5,8,-1,6]\\nsince they are asking for LONGEST CONSECUTIVE , and i just can\\'t get where the fuck is \\'2\\' in the given array and without that how come they are expecting the length of 7 to be the output of the program !!!"
                    },
                    {
                        "username": "Orange_Smuggler",
                        "content": "[3,4,5,6,7,8,9]"
                    },
                    {
                        "username": "Orange_Smuggler",
                        "content": "I'm kinda puzzled: [1,2,1,1,1,1,3,3,3,3,4] has to be 4 for LeetCode. But the given examples kinda missed the point here. My initial guess was that we're looking for possible consecutive sequences with a strict relation to amount of numbers in array. Say, we sort my example, we get this: [1,1,1,1,1,2,3,3,3,3,4]. I thought that the answer is 3, because you can clearly see consecutive sequence [1,2,3]. But the answer 4 suggests that we also include 4, despite having four '3's? This is huge oversight and kinda lame in my opinion. Is there any point in counting these numbers at all?"
                    },
                    {
                        "username": "2uringTested",
                        "content": "I dont think its an oversight. They have clearly mentioned that the sequence has the following property:\\n\\n\"It is a consecutive sequence\"\\n\\nmeaning that for every index \\'i\\' in the sequence, a[i+1] = a[i] +1\\n\\nso if the sequence was {1,2,3,3} the property is violated at the i = 2, where a[i+1] != a[i]+1\\nso 4 is infact the correct answer for [1,2,1,1,1,1,3,3,3,3,3,4] as the longest sequence which follows this property is {1,2,3,4}."
                    }
                ]
            },
            {
                "id": 1985413,
                "content": [
                    {
                        "username": "Manoj_Chavva",
                        "content": "Is this code correct\\nclass Solution(object):\\n    def longestConsecutive(nums):\\n        if not nums:\\n            return 0\\n\\n        sorted_nums = sorted(set(nums))  # Sort and remove duplicates\\n\\n        max_length = 1\\n        current_length = 1\\n\\n        for i in range(1, len(sorted_nums)):\\n            if sorted_nums[i] == sorted_nums[i - 1] + 1:\\n                current_length += 1\\n            else:\\n                max_length = max(max_length, current_length)\\n                current_length = 1\\n\\n        return max(max_length, current_length)\\n\\n\\n"
                    },
                    {
                        "username": "SureDoo",
                        "content": "[@georgezakharov](/georgezakharov) And when he uses \\'sort\\', the solution can not meet the requirement O(n)."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "julian_sikora",
                        "content": "Why is iterating throw the nums as a set much faster than iterating throw the list?\n\nSo why is:\nfor n in nums:\n     pass\n\nslower than\n\nfor n in set(nums):\n    pass\n\nShouldn't it be more or less the same? For me it was the difference between being better than 40% of the solutions to being better than 98% and I don't really get why?"
                    },
                    {
                        "username": "treat",
                        "content": "If you are not preparing for any of these weekly competitions, don't bother yourself with such details. What is more important is that you understand all the different approaches that can be used to solve a problem. Also once you understand do code down your own solution. "
                    },
                    {
                        "username": "RealNameHidden",
                        "content": "Did it using a priority queue, bot the most optimal but its accepted.\\n\\n `class Solution {\\n    public int longestConsecutive(int[] nums) {\\n        Queue<Integer> pq = new PriorityQueue<>((a,b)->a-b);\\n        if(nums.length==0){\\n            return 0;\\n        }\\n        for(int i=0; i<nums.length; i++){\\n            pq.add(nums[i]);\\n        }\\n        \\n        int maxLen = 1;\\n        int currLen = 1;\\n        int prevEle = pq.remove();\\n        while(!pq.isEmpty()){\\n            int curr = pq.remove();\\n            if(curr==prevEle){\\n                continue;\\n            }\\n            if(Math.abs(curr-prevEle)==1){\\n                currLen++;\\n                maxLen = Math.max(maxLen,currLen);\\n            } else{\\n                currLen = 1;\\n            }\\n            prevEle = curr;\\n        }\\n        return maxLen;\\n    }\\n}`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "AnthonyShuey",
                        "content": "Give me a score based on how good this solution is on a scale of 0-10: \\nimport heapq\\nclass Solution:\\n    def longestConsecutive(self, nums: List[int]) -> int:\\n        if len(nums)==0:\\n            return 0\\n        h = set()\\n        for i in nums:\\n            if i in h:\\n                continue\\n            else:\\n                h.add(i)\\n        helper =h.copy()\\n        longest = 1\\n        for num in helper:\\n            if num in h:\\n                l =1\\n                start = num-1\\n                while start in h:\\n                    l+=1\\n                    start = start-1\\n                    h.remove(start+1)\\n                start = num+1\\n                while start in h:\\n                    l+=1\\n                    start = start+1\\n                    h.remove(start-1)\\n                if l > longest:\\n                    longest = l\\n        return longest"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "AnthonyShuey",
                        "content": "Will someone tell me why my code beats 65% of other submissions even though it is nlogn. I removed the duplicates then used a heap to pop the smallest off and check if the next one to be popped off is 1 greater than the currently one that is popped off. If so, then I will increase l. I do this until there are no other elements. The \"while numsy\" is worse case O(n) and then we do \"start = heapq.heappop(numsy)\" which is logn. Therefore, my solution is nlogn. \\nHere is the exact code: \\n\\nimport heapq\\nclass Solution:\\n    def longestConsecutive(self, nums: List[int]) -> int:\\n        h = set()\\n        for i in nums:\\n            if i in h:\\n                continue\\n            else:\\n                h.add(i)\\n        numsy =[]\\n        for i in h:\\n            numsy.append(i)\\n        for i in range(0,len(numsy)):\\n            numsy[i]*=-1\\n        heapq.heapify(numsy)\\n        longest = 1\\n        if len(numsy)==0:\\n            return 0\\n        while numsy:\\n            l =1\\n            start = heapq.heappop(numsy)\\n            while len(numsy)>0 and numsy[0]==start+1:\\n                l+=1\\n                start = heapq.heappop(numsy)\\n            if l>longest:\\n                longest = l\\n        return longest"
                    },
                    {
                        "username": "dragosarsene7",
                        "content": "For everyone using set to get O(n), if you do not remove elements as you go, your complexity would be O(n*sqrt(n)) worst-case, eg. {0, 1, 2, 4, 5, 6, 8, 9, 10}, where you have sqrt(n) clusters of sqrt(n) consecutive elements each"
                    },
                    {
                        "username": "Szymon5922",
                        "content": "I strongly recommend SortedSet; Algo faster than 96.20% of sumbissions with C# created with low effort."
                    },
                    {
                        "username": "Pikiato",
                        "content": "Why is [-6,-1,-1,9,-8,-6,-6,4,4,-3,-8,-1] returns 1 ?? there are no consecutive numbers?? I\\'m confused. Please help me."
                    },
                    {
                        "username": "sakshamgaur96",
                        "content": "what is wrong yaar with this 25th test case how come it is expecting output to be 7 , like howwww?????\\nin the test case it is given that the sample inputs are: [9,1,4,7,3,-1,0,5,8,-1,6]\\nsince they are asking for LONGEST CONSECUTIVE , and i just can\\'t get where the fuck is \\'2\\' in the given array and without that how come they are expecting the length of 7 to be the output of the program !!!"
                    },
                    {
                        "username": "Orange_Smuggler",
                        "content": "[3,4,5,6,7,8,9]"
                    },
                    {
                        "username": "Orange_Smuggler",
                        "content": "I'm kinda puzzled: [1,2,1,1,1,1,3,3,3,3,4] has to be 4 for LeetCode. But the given examples kinda missed the point here. My initial guess was that we're looking for possible consecutive sequences with a strict relation to amount of numbers in array. Say, we sort my example, we get this: [1,1,1,1,1,2,3,3,3,3,4]. I thought that the answer is 3, because you can clearly see consecutive sequence [1,2,3]. But the answer 4 suggests that we also include 4, despite having four '3's? This is huge oversight and kinda lame in my opinion. Is there any point in counting these numbers at all?"
                    },
                    {
                        "username": "2uringTested",
                        "content": "I dont think its an oversight. They have clearly mentioned that the sequence has the following property:\\n\\n\"It is a consecutive sequence\"\\n\\nmeaning that for every index \\'i\\' in the sequence, a[i+1] = a[i] +1\\n\\nso if the sequence was {1,2,3,3} the property is violated at the i = 2, where a[i+1] != a[i]+1\\nso 4 is infact the correct answer for [1,2,1,1,1,1,3,3,3,3,3,4] as the longest sequence which follows this property is {1,2,3,4}."
                    }
                ]
            },
            {
                "id": 1983244,
                "content": [
                    {
                        "username": "Manoj_Chavva",
                        "content": "Is this code correct\\nclass Solution(object):\\n    def longestConsecutive(nums):\\n        if not nums:\\n            return 0\\n\\n        sorted_nums = sorted(set(nums))  # Sort and remove duplicates\\n\\n        max_length = 1\\n        current_length = 1\\n\\n        for i in range(1, len(sorted_nums)):\\n            if sorted_nums[i] == sorted_nums[i - 1] + 1:\\n                current_length += 1\\n            else:\\n                max_length = max(max_length, current_length)\\n                current_length = 1\\n\\n        return max(max_length, current_length)\\n\\n\\n"
                    },
                    {
                        "username": "SureDoo",
                        "content": "[@georgezakharov](/georgezakharov) And when he uses \\'sort\\', the solution can not meet the requirement O(n)."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "julian_sikora",
                        "content": "Why is iterating throw the nums as a set much faster than iterating throw the list?\n\nSo why is:\nfor n in nums:\n     pass\n\nslower than\n\nfor n in set(nums):\n    pass\n\nShouldn't it be more or less the same? For me it was the difference between being better than 40% of the solutions to being better than 98% and I don't really get why?"
                    },
                    {
                        "username": "treat",
                        "content": "If you are not preparing for any of these weekly competitions, don't bother yourself with such details. What is more important is that you understand all the different approaches that can be used to solve a problem. Also once you understand do code down your own solution. "
                    },
                    {
                        "username": "RealNameHidden",
                        "content": "Did it using a priority queue, bot the most optimal but its accepted.\\n\\n `class Solution {\\n    public int longestConsecutive(int[] nums) {\\n        Queue<Integer> pq = new PriorityQueue<>((a,b)->a-b);\\n        if(nums.length==0){\\n            return 0;\\n        }\\n        for(int i=0; i<nums.length; i++){\\n            pq.add(nums[i]);\\n        }\\n        \\n        int maxLen = 1;\\n        int currLen = 1;\\n        int prevEle = pq.remove();\\n        while(!pq.isEmpty()){\\n            int curr = pq.remove();\\n            if(curr==prevEle){\\n                continue;\\n            }\\n            if(Math.abs(curr-prevEle)==1){\\n                currLen++;\\n                maxLen = Math.max(maxLen,currLen);\\n            } else{\\n                currLen = 1;\\n            }\\n            prevEle = curr;\\n        }\\n        return maxLen;\\n    }\\n}`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "AnthonyShuey",
                        "content": "Give me a score based on how good this solution is on a scale of 0-10: \\nimport heapq\\nclass Solution:\\n    def longestConsecutive(self, nums: List[int]) -> int:\\n        if len(nums)==0:\\n            return 0\\n        h = set()\\n        for i in nums:\\n            if i in h:\\n                continue\\n            else:\\n                h.add(i)\\n        helper =h.copy()\\n        longest = 1\\n        for num in helper:\\n            if num in h:\\n                l =1\\n                start = num-1\\n                while start in h:\\n                    l+=1\\n                    start = start-1\\n                    h.remove(start+1)\\n                start = num+1\\n                while start in h:\\n                    l+=1\\n                    start = start+1\\n                    h.remove(start-1)\\n                if l > longest:\\n                    longest = l\\n        return longest"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "AnthonyShuey",
                        "content": "Will someone tell me why my code beats 65% of other submissions even though it is nlogn. I removed the duplicates then used a heap to pop the smallest off and check if the next one to be popped off is 1 greater than the currently one that is popped off. If so, then I will increase l. I do this until there are no other elements. The \"while numsy\" is worse case O(n) and then we do \"start = heapq.heappop(numsy)\" which is logn. Therefore, my solution is nlogn. \\nHere is the exact code: \\n\\nimport heapq\\nclass Solution:\\n    def longestConsecutive(self, nums: List[int]) -> int:\\n        h = set()\\n        for i in nums:\\n            if i in h:\\n                continue\\n            else:\\n                h.add(i)\\n        numsy =[]\\n        for i in h:\\n            numsy.append(i)\\n        for i in range(0,len(numsy)):\\n            numsy[i]*=-1\\n        heapq.heapify(numsy)\\n        longest = 1\\n        if len(numsy)==0:\\n            return 0\\n        while numsy:\\n            l =1\\n            start = heapq.heappop(numsy)\\n            while len(numsy)>0 and numsy[0]==start+1:\\n                l+=1\\n                start = heapq.heappop(numsy)\\n            if l>longest:\\n                longest = l\\n        return longest"
                    },
                    {
                        "username": "dragosarsene7",
                        "content": "For everyone using set to get O(n), if you do not remove elements as you go, your complexity would be O(n*sqrt(n)) worst-case, eg. {0, 1, 2, 4, 5, 6, 8, 9, 10}, where you have sqrt(n) clusters of sqrt(n) consecutive elements each"
                    },
                    {
                        "username": "Szymon5922",
                        "content": "I strongly recommend SortedSet; Algo faster than 96.20% of sumbissions with C# created with low effort."
                    },
                    {
                        "username": "Pikiato",
                        "content": "Why is [-6,-1,-1,9,-8,-6,-6,4,4,-3,-8,-1] returns 1 ?? there are no consecutive numbers?? I\\'m confused. Please help me."
                    },
                    {
                        "username": "sakshamgaur96",
                        "content": "what is wrong yaar with this 25th test case how come it is expecting output to be 7 , like howwww?????\\nin the test case it is given that the sample inputs are: [9,1,4,7,3,-1,0,5,8,-1,6]\\nsince they are asking for LONGEST CONSECUTIVE , and i just can\\'t get where the fuck is \\'2\\' in the given array and without that how come they are expecting the length of 7 to be the output of the program !!!"
                    },
                    {
                        "username": "Orange_Smuggler",
                        "content": "[3,4,5,6,7,8,9]"
                    },
                    {
                        "username": "Orange_Smuggler",
                        "content": "I'm kinda puzzled: [1,2,1,1,1,1,3,3,3,3,4] has to be 4 for LeetCode. But the given examples kinda missed the point here. My initial guess was that we're looking for possible consecutive sequences with a strict relation to amount of numbers in array. Say, we sort my example, we get this: [1,1,1,1,1,2,3,3,3,3,4]. I thought that the answer is 3, because you can clearly see consecutive sequence [1,2,3]. But the answer 4 suggests that we also include 4, despite having four '3's? This is huge oversight and kinda lame in my opinion. Is there any point in counting these numbers at all?"
                    },
                    {
                        "username": "2uringTested",
                        "content": "I dont think its an oversight. They have clearly mentioned that the sequence has the following property:\\n\\n\"It is a consecutive sequence\"\\n\\nmeaning that for every index \\'i\\' in the sequence, a[i+1] = a[i] +1\\n\\nso if the sequence was {1,2,3,3} the property is violated at the i = 2, where a[i+1] != a[i]+1\\nso 4 is infact the correct answer for [1,2,1,1,1,1,3,3,3,3,3,4] as the longest sequence which follows this property is {1,2,3,4}."
                    }
                ]
            },
            {
                "id": 1973369,
                "content": [
                    {
                        "username": "Manoj_Chavva",
                        "content": "Is this code correct\\nclass Solution(object):\\n    def longestConsecutive(nums):\\n        if not nums:\\n            return 0\\n\\n        sorted_nums = sorted(set(nums))  # Sort and remove duplicates\\n\\n        max_length = 1\\n        current_length = 1\\n\\n        for i in range(1, len(sorted_nums)):\\n            if sorted_nums[i] == sorted_nums[i - 1] + 1:\\n                current_length += 1\\n            else:\\n                max_length = max(max_length, current_length)\\n                current_length = 1\\n\\n        return max(max_length, current_length)\\n\\n\\n"
                    },
                    {
                        "username": "SureDoo",
                        "content": "[@georgezakharov](/georgezakharov) And when he uses \\'sort\\', the solution can not meet the requirement O(n)."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "julian_sikora",
                        "content": "Why is iterating throw the nums as a set much faster than iterating throw the list?\n\nSo why is:\nfor n in nums:\n     pass\n\nslower than\n\nfor n in set(nums):\n    pass\n\nShouldn't it be more or less the same? For me it was the difference between being better than 40% of the solutions to being better than 98% and I don't really get why?"
                    },
                    {
                        "username": "treat",
                        "content": "If you are not preparing for any of these weekly competitions, don't bother yourself with such details. What is more important is that you understand all the different approaches that can be used to solve a problem. Also once you understand do code down your own solution. "
                    },
                    {
                        "username": "RealNameHidden",
                        "content": "Did it using a priority queue, bot the most optimal but its accepted.\\n\\n `class Solution {\\n    public int longestConsecutive(int[] nums) {\\n        Queue<Integer> pq = new PriorityQueue<>((a,b)->a-b);\\n        if(nums.length==0){\\n            return 0;\\n        }\\n        for(int i=0; i<nums.length; i++){\\n            pq.add(nums[i]);\\n        }\\n        \\n        int maxLen = 1;\\n        int currLen = 1;\\n        int prevEle = pq.remove();\\n        while(!pq.isEmpty()){\\n            int curr = pq.remove();\\n            if(curr==prevEle){\\n                continue;\\n            }\\n            if(Math.abs(curr-prevEle)==1){\\n                currLen++;\\n                maxLen = Math.max(maxLen,currLen);\\n            } else{\\n                currLen = 1;\\n            }\\n            prevEle = curr;\\n        }\\n        return maxLen;\\n    }\\n}`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "AnthonyShuey",
                        "content": "Give me a score based on how good this solution is on a scale of 0-10: \\nimport heapq\\nclass Solution:\\n    def longestConsecutive(self, nums: List[int]) -> int:\\n        if len(nums)==0:\\n            return 0\\n        h = set()\\n        for i in nums:\\n            if i in h:\\n                continue\\n            else:\\n                h.add(i)\\n        helper =h.copy()\\n        longest = 1\\n        for num in helper:\\n            if num in h:\\n                l =1\\n                start = num-1\\n                while start in h:\\n                    l+=1\\n                    start = start-1\\n                    h.remove(start+1)\\n                start = num+1\\n                while start in h:\\n                    l+=1\\n                    start = start+1\\n                    h.remove(start-1)\\n                if l > longest:\\n                    longest = l\\n        return longest"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "AnthonyShuey",
                        "content": "Will someone tell me why my code beats 65% of other submissions even though it is nlogn. I removed the duplicates then used a heap to pop the smallest off and check if the next one to be popped off is 1 greater than the currently one that is popped off. If so, then I will increase l. I do this until there are no other elements. The \"while numsy\" is worse case O(n) and then we do \"start = heapq.heappop(numsy)\" which is logn. Therefore, my solution is nlogn. \\nHere is the exact code: \\n\\nimport heapq\\nclass Solution:\\n    def longestConsecutive(self, nums: List[int]) -> int:\\n        h = set()\\n        for i in nums:\\n            if i in h:\\n                continue\\n            else:\\n                h.add(i)\\n        numsy =[]\\n        for i in h:\\n            numsy.append(i)\\n        for i in range(0,len(numsy)):\\n            numsy[i]*=-1\\n        heapq.heapify(numsy)\\n        longest = 1\\n        if len(numsy)==0:\\n            return 0\\n        while numsy:\\n            l =1\\n            start = heapq.heappop(numsy)\\n            while len(numsy)>0 and numsy[0]==start+1:\\n                l+=1\\n                start = heapq.heappop(numsy)\\n            if l>longest:\\n                longest = l\\n        return longest"
                    },
                    {
                        "username": "dragosarsene7",
                        "content": "For everyone using set to get O(n), if you do not remove elements as you go, your complexity would be O(n*sqrt(n)) worst-case, eg. {0, 1, 2, 4, 5, 6, 8, 9, 10}, where you have sqrt(n) clusters of sqrt(n) consecutive elements each"
                    },
                    {
                        "username": "Szymon5922",
                        "content": "I strongly recommend SortedSet; Algo faster than 96.20% of sumbissions with C# created with low effort."
                    },
                    {
                        "username": "Pikiato",
                        "content": "Why is [-6,-1,-1,9,-8,-6,-6,4,4,-3,-8,-1] returns 1 ?? there are no consecutive numbers?? I\\'m confused. Please help me."
                    },
                    {
                        "username": "sakshamgaur96",
                        "content": "what is wrong yaar with this 25th test case how come it is expecting output to be 7 , like howwww?????\\nin the test case it is given that the sample inputs are: [9,1,4,7,3,-1,0,5,8,-1,6]\\nsince they are asking for LONGEST CONSECUTIVE , and i just can\\'t get where the fuck is \\'2\\' in the given array and without that how come they are expecting the length of 7 to be the output of the program !!!"
                    },
                    {
                        "username": "Orange_Smuggler",
                        "content": "[3,4,5,6,7,8,9]"
                    },
                    {
                        "username": "Orange_Smuggler",
                        "content": "I'm kinda puzzled: [1,2,1,1,1,1,3,3,3,3,4] has to be 4 for LeetCode. But the given examples kinda missed the point here. My initial guess was that we're looking for possible consecutive sequences with a strict relation to amount of numbers in array. Say, we sort my example, we get this: [1,1,1,1,1,2,3,3,3,3,4]. I thought that the answer is 3, because you can clearly see consecutive sequence [1,2,3]. But the answer 4 suggests that we also include 4, despite having four '3's? This is huge oversight and kinda lame in my opinion. Is there any point in counting these numbers at all?"
                    },
                    {
                        "username": "2uringTested",
                        "content": "I dont think its an oversight. They have clearly mentioned that the sequence has the following property:\\n\\n\"It is a consecutive sequence\"\\n\\nmeaning that for every index \\'i\\' in the sequence, a[i+1] = a[i] +1\\n\\nso if the sequence was {1,2,3,3} the property is violated at the i = 2, where a[i+1] != a[i]+1\\nso 4 is infact the correct answer for [1,2,1,1,1,1,3,3,3,3,3,4] as the longest sequence which follows this property is {1,2,3,4}."
                    }
                ]
            },
            {
                "id": 1966032,
                "content": [
                    {
                        "username": "joydeep-lc",
                        "content": "I had a completely different approach to this. Basically:\n1. Build a hashmap by putting all the elements and initializing the value to 1\n2. Iterate over the nums array, for each num in nums, find the leftLength and rightLength\n3. LeftLength is defined as the length of the contiguous sequence < num (exclusive)\n4. RightLength is defined as  length of the contiguous sequence > num (exclusive)\n5. so for the given num, the largest possible contiguous sequence is leftLen + rightLen + 1\n6. To optimize this and run it in O(n), we can remove all elements which we encountered in LeftLen and RightLen search. This ensures we iterate over each element exactly once. \n\nHere is the code\nhttps://leetcode.com/problems/longest-consecutive-sequence/submissions/992061594/\n\nI'm reading this can also be done via union find and I am bamboozled. It never occured to me "
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "```HINT```\nUse Set to store the nums  it will be sorted  & duplicate will be removed.\nNow iterate the set and check for the  consecutive sequence and update the answer accordingly. \nJust use the iterator from begining to end to compare all the elements.\nThis will be done in O(nlogn) Time & O(n) space as well\n\n```question```\nSince I am unable to find O(n) solution can anyone  tell me O(n) appraoch.?\nAs most of the solution here are O(nlogn) time using map,priority queue set which take logn time for insertion."
                    },
                    {
                        "username": "pandeyaman5410",
                        "content": "how to get the output\\n"
                    },
                    {
                        "username": "2uringTested",
                        "content": "SPOILERS  AHEAD : An actual O(n) solution\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n\\n```\\nclass Solution {\\npublic:\\n    unordered_map<int,int> parent;\\n    unordered_map<int,int> rank;\\n    int find_compressed(int x){\\n        if(parent[x]==x) return x;\\n        else{\\n            int temp = find_compressed(parent[x]);\\n            parent[x] = temp;\\n            return temp;\\n        }\\n    }\\n\\n    bool union_by_rank(int x,int y){\\n\\n        int parentx = find_compressed(x);\\n        int parenty = find_compressed(y);\\n        if(parentx==parenty) return false;\\n\\n        if(rank[parentx]>rank[parenty]){\\n            parent[parenty]=parentx;\\n        }else if(rank[parentx]<rank[parenty]){\\n            parent[parentx]=parenty;\\n        }else{\\n            parent[parenty] = parentx;\\n            ++rank[parentx];\\n        }\\n        return true;\\n    }\\n    int longestConsecutive(vector<int>& nums) {\\n        \\n        unordered_map<int,int> freq;\\n        for(auto num:nums){\\n            parent[num]=num;\\n            rank[num]=1;\\n        }\\n        for(auto num: nums){\\n            if(parent.find(num+1)!=parent.end()) union_by_rank(num,num+1);\\n            if(parent.find(num-1)!=parent.end()) union_by_rank(num,num-1);\\n        }\\n        for(auto it: parent){\\n            int leader = find_compressed(it.first);\\n            ++freq[leader];\\n        }\\n\\n        int ans =0;\\n        for(auto it: freq){\\n            ans = max(ans,it.second);\\n        }\\n\\n        return ans;\\n        \\n    }\\n};\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "The rules ahead.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "kevinsutan99",
                        "content": "For anyone failing testcase 43 in this question using python, try switching to python 3 instead"
                    },
                    {
                        "username": "Swapnamoy45",
                        "content": "Not a medium Problem by ay means!!"
                    },
                    {
                        "username": "rohan5",
                        "content": "It should be clarified whether duplicates are ignored or taken into account.\\neg\\n`[100,3,200,1,2,2]` -- should it be `3` or `4` ?"
                    },
                    {
                        "username": "MorganFxrmer",
                        "content": "Hi, to answer your question duplicates are ignored and [100,3,200,1,2,2] should be 3. The reason for this is that we are looking for consecutive numbers and duplicate numbers don\\'t count as consecutive. The definition of a consecutive sequence is a sequence where the numbers follow from each other e.g. 1, 2, 3, 4. Referring to your example [100,3,200,1,2,2]: 1, 2, 2, 3 would not be a consecutive sequence because the second 2 does not follow from its previous number (which is also a 2). I hope this helped and good luck!"
                    },
                    {
                        "username": "mohafiz",
                        "content": "What about that too long tc ? it gives me time limit exceeded. My solution has a time complexity of O(n)"
                    },
                    {
                        "username": "mohafiz",
                        "content": "What about that long test case ? it gives me time limit exceeded whatever I do! And my solution is O(n) "
                    },
                    {
                        "username": "DeclanGH",
                        "content": "My first O(n) solution ran 463 ms while the nlogn ran 14ms. its really weird. i was graced to get one testcase wrong durring my attempts, which had 10000 as its answer (the largest input size). Meaning linearithmic time still beat the linear time. Again, Weird. "
                    }
                ]
            },
            {
                "id": 1958004,
                "content": [
                    {
                        "username": "joydeep-lc",
                        "content": "I had a completely different approach to this. Basically:\n1. Build a hashmap by putting all the elements and initializing the value to 1\n2. Iterate over the nums array, for each num in nums, find the leftLength and rightLength\n3. LeftLength is defined as the length of the contiguous sequence < num (exclusive)\n4. RightLength is defined as  length of the contiguous sequence > num (exclusive)\n5. so for the given num, the largest possible contiguous sequence is leftLen + rightLen + 1\n6. To optimize this and run it in O(n), we can remove all elements which we encountered in LeftLen and RightLen search. This ensures we iterate over each element exactly once. \n\nHere is the code\nhttps://leetcode.com/problems/longest-consecutive-sequence/submissions/992061594/\n\nI'm reading this can also be done via union find and I am bamboozled. It never occured to me "
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "```HINT```\nUse Set to store the nums  it will be sorted  & duplicate will be removed.\nNow iterate the set and check for the  consecutive sequence and update the answer accordingly. \nJust use the iterator from begining to end to compare all the elements.\nThis will be done in O(nlogn) Time & O(n) space as well\n\n```question```\nSince I am unable to find O(n) solution can anyone  tell me O(n) appraoch.?\nAs most of the solution here are O(nlogn) time using map,priority queue set which take logn time for insertion."
                    },
                    {
                        "username": "pandeyaman5410",
                        "content": "how to get the output\\n"
                    },
                    {
                        "username": "2uringTested",
                        "content": "SPOILERS  AHEAD : An actual O(n) solution\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n\\n```\\nclass Solution {\\npublic:\\n    unordered_map<int,int> parent;\\n    unordered_map<int,int> rank;\\n    int find_compressed(int x){\\n        if(parent[x]==x) return x;\\n        else{\\n            int temp = find_compressed(parent[x]);\\n            parent[x] = temp;\\n            return temp;\\n        }\\n    }\\n\\n    bool union_by_rank(int x,int y){\\n\\n        int parentx = find_compressed(x);\\n        int parenty = find_compressed(y);\\n        if(parentx==parenty) return false;\\n\\n        if(rank[parentx]>rank[parenty]){\\n            parent[parenty]=parentx;\\n        }else if(rank[parentx]<rank[parenty]){\\n            parent[parentx]=parenty;\\n        }else{\\n            parent[parenty] = parentx;\\n            ++rank[parentx];\\n        }\\n        return true;\\n    }\\n    int longestConsecutive(vector<int>& nums) {\\n        \\n        unordered_map<int,int> freq;\\n        for(auto num:nums){\\n            parent[num]=num;\\n            rank[num]=1;\\n        }\\n        for(auto num: nums){\\n            if(parent.find(num+1)!=parent.end()) union_by_rank(num,num+1);\\n            if(parent.find(num-1)!=parent.end()) union_by_rank(num,num-1);\\n        }\\n        for(auto it: parent){\\n            int leader = find_compressed(it.first);\\n            ++freq[leader];\\n        }\\n\\n        int ans =0;\\n        for(auto it: freq){\\n            ans = max(ans,it.second);\\n        }\\n\\n        return ans;\\n        \\n    }\\n};\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "The rules ahead.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "kevinsutan99",
                        "content": "For anyone failing testcase 43 in this question using python, try switching to python 3 instead"
                    },
                    {
                        "username": "Swapnamoy45",
                        "content": "Not a medium Problem by ay means!!"
                    },
                    {
                        "username": "rohan5",
                        "content": "It should be clarified whether duplicates are ignored or taken into account.\\neg\\n`[100,3,200,1,2,2]` -- should it be `3` or `4` ?"
                    },
                    {
                        "username": "MorganFxrmer",
                        "content": "Hi, to answer your question duplicates are ignored and [100,3,200,1,2,2] should be 3. The reason for this is that we are looking for consecutive numbers and duplicate numbers don\\'t count as consecutive. The definition of a consecutive sequence is a sequence where the numbers follow from each other e.g. 1, 2, 3, 4. Referring to your example [100,3,200,1,2,2]: 1, 2, 2, 3 would not be a consecutive sequence because the second 2 does not follow from its previous number (which is also a 2). I hope this helped and good luck!"
                    },
                    {
                        "username": "mohafiz",
                        "content": "What about that too long tc ? it gives me time limit exceeded. My solution has a time complexity of O(n)"
                    },
                    {
                        "username": "mohafiz",
                        "content": "What about that long test case ? it gives me time limit exceeded whatever I do! And my solution is O(n) "
                    },
                    {
                        "username": "DeclanGH",
                        "content": "My first O(n) solution ran 463 ms while the nlogn ran 14ms. its really weird. i was graced to get one testcase wrong durring my attempts, which had 10000 as its answer (the largest input size). Meaning linearithmic time still beat the linear time. Again, Weird. "
                    }
                ]
            },
            {
                "id": 1956058,
                "content": [
                    {
                        "username": "joydeep-lc",
                        "content": "I had a completely different approach to this. Basically:\n1. Build a hashmap by putting all the elements and initializing the value to 1\n2. Iterate over the nums array, for each num in nums, find the leftLength and rightLength\n3. LeftLength is defined as the length of the contiguous sequence < num (exclusive)\n4. RightLength is defined as  length of the contiguous sequence > num (exclusive)\n5. so for the given num, the largest possible contiguous sequence is leftLen + rightLen + 1\n6. To optimize this and run it in O(n), we can remove all elements which we encountered in LeftLen and RightLen search. This ensures we iterate over each element exactly once. \n\nHere is the code\nhttps://leetcode.com/problems/longest-consecutive-sequence/submissions/992061594/\n\nI'm reading this can also be done via union find and I am bamboozled. It never occured to me "
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "```HINT```\nUse Set to store the nums  it will be sorted  & duplicate will be removed.\nNow iterate the set and check for the  consecutive sequence and update the answer accordingly. \nJust use the iterator from begining to end to compare all the elements.\nThis will be done in O(nlogn) Time & O(n) space as well\n\n```question```\nSince I am unable to find O(n) solution can anyone  tell me O(n) appraoch.?\nAs most of the solution here are O(nlogn) time using map,priority queue set which take logn time for insertion."
                    },
                    {
                        "username": "pandeyaman5410",
                        "content": "how to get the output\\n"
                    },
                    {
                        "username": "2uringTested",
                        "content": "SPOILERS  AHEAD : An actual O(n) solution\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n\\n```\\nclass Solution {\\npublic:\\n    unordered_map<int,int> parent;\\n    unordered_map<int,int> rank;\\n    int find_compressed(int x){\\n        if(parent[x]==x) return x;\\n        else{\\n            int temp = find_compressed(parent[x]);\\n            parent[x] = temp;\\n            return temp;\\n        }\\n    }\\n\\n    bool union_by_rank(int x,int y){\\n\\n        int parentx = find_compressed(x);\\n        int parenty = find_compressed(y);\\n        if(parentx==parenty) return false;\\n\\n        if(rank[parentx]>rank[parenty]){\\n            parent[parenty]=parentx;\\n        }else if(rank[parentx]<rank[parenty]){\\n            parent[parentx]=parenty;\\n        }else{\\n            parent[parenty] = parentx;\\n            ++rank[parentx];\\n        }\\n        return true;\\n    }\\n    int longestConsecutive(vector<int>& nums) {\\n        \\n        unordered_map<int,int> freq;\\n        for(auto num:nums){\\n            parent[num]=num;\\n            rank[num]=1;\\n        }\\n        for(auto num: nums){\\n            if(parent.find(num+1)!=parent.end()) union_by_rank(num,num+1);\\n            if(parent.find(num-1)!=parent.end()) union_by_rank(num,num-1);\\n        }\\n        for(auto it: parent){\\n            int leader = find_compressed(it.first);\\n            ++freq[leader];\\n        }\\n\\n        int ans =0;\\n        for(auto it: freq){\\n            ans = max(ans,it.second);\\n        }\\n\\n        return ans;\\n        \\n    }\\n};\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "The rules ahead.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "kevinsutan99",
                        "content": "For anyone failing testcase 43 in this question using python, try switching to python 3 instead"
                    },
                    {
                        "username": "Swapnamoy45",
                        "content": "Not a medium Problem by ay means!!"
                    },
                    {
                        "username": "rohan5",
                        "content": "It should be clarified whether duplicates are ignored or taken into account.\\neg\\n`[100,3,200,1,2,2]` -- should it be `3` or `4` ?"
                    },
                    {
                        "username": "MorganFxrmer",
                        "content": "Hi, to answer your question duplicates are ignored and [100,3,200,1,2,2] should be 3. The reason for this is that we are looking for consecutive numbers and duplicate numbers don\\'t count as consecutive. The definition of a consecutive sequence is a sequence where the numbers follow from each other e.g. 1, 2, 3, 4. Referring to your example [100,3,200,1,2,2]: 1, 2, 2, 3 would not be a consecutive sequence because the second 2 does not follow from its previous number (which is also a 2). I hope this helped and good luck!"
                    },
                    {
                        "username": "mohafiz",
                        "content": "What about that too long tc ? it gives me time limit exceeded. My solution has a time complexity of O(n)"
                    },
                    {
                        "username": "mohafiz",
                        "content": "What about that long test case ? it gives me time limit exceeded whatever I do! And my solution is O(n) "
                    },
                    {
                        "username": "DeclanGH",
                        "content": "My first O(n) solution ran 463 ms while the nlogn ran 14ms. its really weird. i was graced to get one testcase wrong durring my attempts, which had 10000 as its answer (the largest input size). Meaning linearithmic time still beat the linear time. Again, Weird. "
                    }
                ]
            },
            {
                "id": 1953572,
                "content": [
                    {
                        "username": "joydeep-lc",
                        "content": "I had a completely different approach to this. Basically:\n1. Build a hashmap by putting all the elements and initializing the value to 1\n2. Iterate over the nums array, for each num in nums, find the leftLength and rightLength\n3. LeftLength is defined as the length of the contiguous sequence < num (exclusive)\n4. RightLength is defined as  length of the contiguous sequence > num (exclusive)\n5. so for the given num, the largest possible contiguous sequence is leftLen + rightLen + 1\n6. To optimize this and run it in O(n), we can remove all elements which we encountered in LeftLen and RightLen search. This ensures we iterate over each element exactly once. \n\nHere is the code\nhttps://leetcode.com/problems/longest-consecutive-sequence/submissions/992061594/\n\nI'm reading this can also be done via union find and I am bamboozled. It never occured to me "
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "```HINT```\nUse Set to store the nums  it will be sorted  & duplicate will be removed.\nNow iterate the set and check for the  consecutive sequence and update the answer accordingly. \nJust use the iterator from begining to end to compare all the elements.\nThis will be done in O(nlogn) Time & O(n) space as well\n\n```question```\nSince I am unable to find O(n) solution can anyone  tell me O(n) appraoch.?\nAs most of the solution here are O(nlogn) time using map,priority queue set which take logn time for insertion."
                    },
                    {
                        "username": "pandeyaman5410",
                        "content": "how to get the output\\n"
                    },
                    {
                        "username": "2uringTested",
                        "content": "SPOILERS  AHEAD : An actual O(n) solution\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n\\n```\\nclass Solution {\\npublic:\\n    unordered_map<int,int> parent;\\n    unordered_map<int,int> rank;\\n    int find_compressed(int x){\\n        if(parent[x]==x) return x;\\n        else{\\n            int temp = find_compressed(parent[x]);\\n            parent[x] = temp;\\n            return temp;\\n        }\\n    }\\n\\n    bool union_by_rank(int x,int y){\\n\\n        int parentx = find_compressed(x);\\n        int parenty = find_compressed(y);\\n        if(parentx==parenty) return false;\\n\\n        if(rank[parentx]>rank[parenty]){\\n            parent[parenty]=parentx;\\n        }else if(rank[parentx]<rank[parenty]){\\n            parent[parentx]=parenty;\\n        }else{\\n            parent[parenty] = parentx;\\n            ++rank[parentx];\\n        }\\n        return true;\\n    }\\n    int longestConsecutive(vector<int>& nums) {\\n        \\n        unordered_map<int,int> freq;\\n        for(auto num:nums){\\n            parent[num]=num;\\n            rank[num]=1;\\n        }\\n        for(auto num: nums){\\n            if(parent.find(num+1)!=parent.end()) union_by_rank(num,num+1);\\n            if(parent.find(num-1)!=parent.end()) union_by_rank(num,num-1);\\n        }\\n        for(auto it: parent){\\n            int leader = find_compressed(it.first);\\n            ++freq[leader];\\n        }\\n\\n        int ans =0;\\n        for(auto it: freq){\\n            ans = max(ans,it.second);\\n        }\\n\\n        return ans;\\n        \\n    }\\n};\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "The rules ahead.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "kevinsutan99",
                        "content": "For anyone failing testcase 43 in this question using python, try switching to python 3 instead"
                    },
                    {
                        "username": "Swapnamoy45",
                        "content": "Not a medium Problem by ay means!!"
                    },
                    {
                        "username": "rohan5",
                        "content": "It should be clarified whether duplicates are ignored or taken into account.\\neg\\n`[100,3,200,1,2,2]` -- should it be `3` or `4` ?"
                    },
                    {
                        "username": "MorganFxrmer",
                        "content": "Hi, to answer your question duplicates are ignored and [100,3,200,1,2,2] should be 3. The reason for this is that we are looking for consecutive numbers and duplicate numbers don\\'t count as consecutive. The definition of a consecutive sequence is a sequence where the numbers follow from each other e.g. 1, 2, 3, 4. Referring to your example [100,3,200,1,2,2]: 1, 2, 2, 3 would not be a consecutive sequence because the second 2 does not follow from its previous number (which is also a 2). I hope this helped and good luck!"
                    },
                    {
                        "username": "mohafiz",
                        "content": "What about that too long tc ? it gives me time limit exceeded. My solution has a time complexity of O(n)"
                    },
                    {
                        "username": "mohafiz",
                        "content": "What about that long test case ? it gives me time limit exceeded whatever I do! And my solution is O(n) "
                    },
                    {
                        "username": "DeclanGH",
                        "content": "My first O(n) solution ran 463 ms while the nlogn ran 14ms. its really weird. i was graced to get one testcase wrong durring my attempts, which had 10000 as its answer (the largest input size). Meaning linearithmic time still beat the linear time. Again, Weird. "
                    }
                ]
            },
            {
                "id": 1951521,
                "content": [
                    {
                        "username": "joydeep-lc",
                        "content": "I had a completely different approach to this. Basically:\n1. Build a hashmap by putting all the elements and initializing the value to 1\n2. Iterate over the nums array, for each num in nums, find the leftLength and rightLength\n3. LeftLength is defined as the length of the contiguous sequence < num (exclusive)\n4. RightLength is defined as  length of the contiguous sequence > num (exclusive)\n5. so for the given num, the largest possible contiguous sequence is leftLen + rightLen + 1\n6. To optimize this and run it in O(n), we can remove all elements which we encountered in LeftLen and RightLen search. This ensures we iterate over each element exactly once. \n\nHere is the code\nhttps://leetcode.com/problems/longest-consecutive-sequence/submissions/992061594/\n\nI'm reading this can also be done via union find and I am bamboozled. It never occured to me "
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "```HINT```\nUse Set to store the nums  it will be sorted  & duplicate will be removed.\nNow iterate the set and check for the  consecutive sequence and update the answer accordingly. \nJust use the iterator from begining to end to compare all the elements.\nThis will be done in O(nlogn) Time & O(n) space as well\n\n```question```\nSince I am unable to find O(n) solution can anyone  tell me O(n) appraoch.?\nAs most of the solution here are O(nlogn) time using map,priority queue set which take logn time for insertion."
                    },
                    {
                        "username": "pandeyaman5410",
                        "content": "how to get the output\\n"
                    },
                    {
                        "username": "2uringTested",
                        "content": "SPOILERS  AHEAD : An actual O(n) solution\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n\\n```\\nclass Solution {\\npublic:\\n    unordered_map<int,int> parent;\\n    unordered_map<int,int> rank;\\n    int find_compressed(int x){\\n        if(parent[x]==x) return x;\\n        else{\\n            int temp = find_compressed(parent[x]);\\n            parent[x] = temp;\\n            return temp;\\n        }\\n    }\\n\\n    bool union_by_rank(int x,int y){\\n\\n        int parentx = find_compressed(x);\\n        int parenty = find_compressed(y);\\n        if(parentx==parenty) return false;\\n\\n        if(rank[parentx]>rank[parenty]){\\n            parent[parenty]=parentx;\\n        }else if(rank[parentx]<rank[parenty]){\\n            parent[parentx]=parenty;\\n        }else{\\n            parent[parenty] = parentx;\\n            ++rank[parentx];\\n        }\\n        return true;\\n    }\\n    int longestConsecutive(vector<int>& nums) {\\n        \\n        unordered_map<int,int> freq;\\n        for(auto num:nums){\\n            parent[num]=num;\\n            rank[num]=1;\\n        }\\n        for(auto num: nums){\\n            if(parent.find(num+1)!=parent.end()) union_by_rank(num,num+1);\\n            if(parent.find(num-1)!=parent.end()) union_by_rank(num,num-1);\\n        }\\n        for(auto it: parent){\\n            int leader = find_compressed(it.first);\\n            ++freq[leader];\\n        }\\n\\n        int ans =0;\\n        for(auto it: freq){\\n            ans = max(ans,it.second);\\n        }\\n\\n        return ans;\\n        \\n    }\\n};\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "The rules ahead.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "kevinsutan99",
                        "content": "For anyone failing testcase 43 in this question using python, try switching to python 3 instead"
                    },
                    {
                        "username": "Swapnamoy45",
                        "content": "Not a medium Problem by ay means!!"
                    },
                    {
                        "username": "rohan5",
                        "content": "It should be clarified whether duplicates are ignored or taken into account.\\neg\\n`[100,3,200,1,2,2]` -- should it be `3` or `4` ?"
                    },
                    {
                        "username": "MorganFxrmer",
                        "content": "Hi, to answer your question duplicates are ignored and [100,3,200,1,2,2] should be 3. The reason for this is that we are looking for consecutive numbers and duplicate numbers don\\'t count as consecutive. The definition of a consecutive sequence is a sequence where the numbers follow from each other e.g. 1, 2, 3, 4. Referring to your example [100,3,200,1,2,2]: 1, 2, 2, 3 would not be a consecutive sequence because the second 2 does not follow from its previous number (which is also a 2). I hope this helped and good luck!"
                    },
                    {
                        "username": "mohafiz",
                        "content": "What about that too long tc ? it gives me time limit exceeded. My solution has a time complexity of O(n)"
                    },
                    {
                        "username": "mohafiz",
                        "content": "What about that long test case ? it gives me time limit exceeded whatever I do! And my solution is O(n) "
                    },
                    {
                        "username": "DeclanGH",
                        "content": "My first O(n) solution ran 463 ms while the nlogn ran 14ms. its really weird. i was graced to get one testcase wrong durring my attempts, which had 10000 as its answer (the largest input size). Meaning linearithmic time still beat the linear time. Again, Weird. "
                    }
                ]
            },
            {
                "id": 1950711,
                "content": [
                    {
                        "username": "joydeep-lc",
                        "content": "I had a completely different approach to this. Basically:\n1. Build a hashmap by putting all the elements and initializing the value to 1\n2. Iterate over the nums array, for each num in nums, find the leftLength and rightLength\n3. LeftLength is defined as the length of the contiguous sequence < num (exclusive)\n4. RightLength is defined as  length of the contiguous sequence > num (exclusive)\n5. so for the given num, the largest possible contiguous sequence is leftLen + rightLen + 1\n6. To optimize this and run it in O(n), we can remove all elements which we encountered in LeftLen and RightLen search. This ensures we iterate over each element exactly once. \n\nHere is the code\nhttps://leetcode.com/problems/longest-consecutive-sequence/submissions/992061594/\n\nI'm reading this can also be done via union find and I am bamboozled. It never occured to me "
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "```HINT```\nUse Set to store the nums  it will be sorted  & duplicate will be removed.\nNow iterate the set and check for the  consecutive sequence and update the answer accordingly. \nJust use the iterator from begining to end to compare all the elements.\nThis will be done in O(nlogn) Time & O(n) space as well\n\n```question```\nSince I am unable to find O(n) solution can anyone  tell me O(n) appraoch.?\nAs most of the solution here are O(nlogn) time using map,priority queue set which take logn time for insertion."
                    },
                    {
                        "username": "pandeyaman5410",
                        "content": "how to get the output\\n"
                    },
                    {
                        "username": "2uringTested",
                        "content": "SPOILERS  AHEAD : An actual O(n) solution\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n\\n```\\nclass Solution {\\npublic:\\n    unordered_map<int,int> parent;\\n    unordered_map<int,int> rank;\\n    int find_compressed(int x){\\n        if(parent[x]==x) return x;\\n        else{\\n            int temp = find_compressed(parent[x]);\\n            parent[x] = temp;\\n            return temp;\\n        }\\n    }\\n\\n    bool union_by_rank(int x,int y){\\n\\n        int parentx = find_compressed(x);\\n        int parenty = find_compressed(y);\\n        if(parentx==parenty) return false;\\n\\n        if(rank[parentx]>rank[parenty]){\\n            parent[parenty]=parentx;\\n        }else if(rank[parentx]<rank[parenty]){\\n            parent[parentx]=parenty;\\n        }else{\\n            parent[parenty] = parentx;\\n            ++rank[parentx];\\n        }\\n        return true;\\n    }\\n    int longestConsecutive(vector<int>& nums) {\\n        \\n        unordered_map<int,int> freq;\\n        for(auto num:nums){\\n            parent[num]=num;\\n            rank[num]=1;\\n        }\\n        for(auto num: nums){\\n            if(parent.find(num+1)!=parent.end()) union_by_rank(num,num+1);\\n            if(parent.find(num-1)!=parent.end()) union_by_rank(num,num-1);\\n        }\\n        for(auto it: parent){\\n            int leader = find_compressed(it.first);\\n            ++freq[leader];\\n        }\\n\\n        int ans =0;\\n        for(auto it: freq){\\n            ans = max(ans,it.second);\\n        }\\n\\n        return ans;\\n        \\n    }\\n};\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "The rules ahead.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "kevinsutan99",
                        "content": "For anyone failing testcase 43 in this question using python, try switching to python 3 instead"
                    },
                    {
                        "username": "Swapnamoy45",
                        "content": "Not a medium Problem by ay means!!"
                    },
                    {
                        "username": "rohan5",
                        "content": "It should be clarified whether duplicates are ignored or taken into account.\\neg\\n`[100,3,200,1,2,2]` -- should it be `3` or `4` ?"
                    },
                    {
                        "username": "MorganFxrmer",
                        "content": "Hi, to answer your question duplicates are ignored and [100,3,200,1,2,2] should be 3. The reason for this is that we are looking for consecutive numbers and duplicate numbers don\\'t count as consecutive. The definition of a consecutive sequence is a sequence where the numbers follow from each other e.g. 1, 2, 3, 4. Referring to your example [100,3,200,1,2,2]: 1, 2, 2, 3 would not be a consecutive sequence because the second 2 does not follow from its previous number (which is also a 2). I hope this helped and good luck!"
                    },
                    {
                        "username": "mohafiz",
                        "content": "What about that too long tc ? it gives me time limit exceeded. My solution has a time complexity of O(n)"
                    },
                    {
                        "username": "mohafiz",
                        "content": "What about that long test case ? it gives me time limit exceeded whatever I do! And my solution is O(n) "
                    },
                    {
                        "username": "DeclanGH",
                        "content": "My first O(n) solution ran 463 ms while the nlogn ran 14ms. its really weird. i was graced to get one testcase wrong durring my attempts, which had 10000 as its answer (the largest input size). Meaning linearithmic time still beat the linear time. Again, Weird. "
                    }
                ]
            },
            {
                "id": 1949182,
                "content": [
                    {
                        "username": "joydeep-lc",
                        "content": "I had a completely different approach to this. Basically:\n1. Build a hashmap by putting all the elements and initializing the value to 1\n2. Iterate over the nums array, for each num in nums, find the leftLength and rightLength\n3. LeftLength is defined as the length of the contiguous sequence < num (exclusive)\n4. RightLength is defined as  length of the contiguous sequence > num (exclusive)\n5. so for the given num, the largest possible contiguous sequence is leftLen + rightLen + 1\n6. To optimize this and run it in O(n), we can remove all elements which we encountered in LeftLen and RightLen search. This ensures we iterate over each element exactly once. \n\nHere is the code\nhttps://leetcode.com/problems/longest-consecutive-sequence/submissions/992061594/\n\nI'm reading this can also be done via union find and I am bamboozled. It never occured to me "
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "```HINT```\nUse Set to store the nums  it will be sorted  & duplicate will be removed.\nNow iterate the set and check for the  consecutive sequence and update the answer accordingly. \nJust use the iterator from begining to end to compare all the elements.\nThis will be done in O(nlogn) Time & O(n) space as well\n\n```question```\nSince I am unable to find O(n) solution can anyone  tell me O(n) appraoch.?\nAs most of the solution here are O(nlogn) time using map,priority queue set which take logn time for insertion."
                    },
                    {
                        "username": "pandeyaman5410",
                        "content": "how to get the output\\n"
                    },
                    {
                        "username": "2uringTested",
                        "content": "SPOILERS  AHEAD : An actual O(n) solution\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n\\n```\\nclass Solution {\\npublic:\\n    unordered_map<int,int> parent;\\n    unordered_map<int,int> rank;\\n    int find_compressed(int x){\\n        if(parent[x]==x) return x;\\n        else{\\n            int temp = find_compressed(parent[x]);\\n            parent[x] = temp;\\n            return temp;\\n        }\\n    }\\n\\n    bool union_by_rank(int x,int y){\\n\\n        int parentx = find_compressed(x);\\n        int parenty = find_compressed(y);\\n        if(parentx==parenty) return false;\\n\\n        if(rank[parentx]>rank[parenty]){\\n            parent[parenty]=parentx;\\n        }else if(rank[parentx]<rank[parenty]){\\n            parent[parentx]=parenty;\\n        }else{\\n            parent[parenty] = parentx;\\n            ++rank[parentx];\\n        }\\n        return true;\\n    }\\n    int longestConsecutive(vector<int>& nums) {\\n        \\n        unordered_map<int,int> freq;\\n        for(auto num:nums){\\n            parent[num]=num;\\n            rank[num]=1;\\n        }\\n        for(auto num: nums){\\n            if(parent.find(num+1)!=parent.end()) union_by_rank(num,num+1);\\n            if(parent.find(num-1)!=parent.end()) union_by_rank(num,num-1);\\n        }\\n        for(auto it: parent){\\n            int leader = find_compressed(it.first);\\n            ++freq[leader];\\n        }\\n\\n        int ans =0;\\n        for(auto it: freq){\\n            ans = max(ans,it.second);\\n        }\\n\\n        return ans;\\n        \\n    }\\n};\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "The rules ahead.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "kevinsutan99",
                        "content": "For anyone failing testcase 43 in this question using python, try switching to python 3 instead"
                    },
                    {
                        "username": "Swapnamoy45",
                        "content": "Not a medium Problem by ay means!!"
                    },
                    {
                        "username": "rohan5",
                        "content": "It should be clarified whether duplicates are ignored or taken into account.\\neg\\n`[100,3,200,1,2,2]` -- should it be `3` or `4` ?"
                    },
                    {
                        "username": "MorganFxrmer",
                        "content": "Hi, to answer your question duplicates are ignored and [100,3,200,1,2,2] should be 3. The reason for this is that we are looking for consecutive numbers and duplicate numbers don\\'t count as consecutive. The definition of a consecutive sequence is a sequence where the numbers follow from each other e.g. 1, 2, 3, 4. Referring to your example [100,3,200,1,2,2]: 1, 2, 2, 3 would not be a consecutive sequence because the second 2 does not follow from its previous number (which is also a 2). I hope this helped and good luck!"
                    },
                    {
                        "username": "mohafiz",
                        "content": "What about that too long tc ? it gives me time limit exceeded. My solution has a time complexity of O(n)"
                    },
                    {
                        "username": "mohafiz",
                        "content": "What about that long test case ? it gives me time limit exceeded whatever I do! And my solution is O(n) "
                    },
                    {
                        "username": "DeclanGH",
                        "content": "My first O(n) solution ran 463 ms while the nlogn ran 14ms. its really weird. i was graced to get one testcase wrong durring my attempts, which had 10000 as its answer (the largest input size). Meaning linearithmic time still beat the linear time. Again, Weird. "
                    }
                ]
            },
            {
                "id": 1944092,
                "content": [
                    {
                        "username": "joydeep-lc",
                        "content": "I had a completely different approach to this. Basically:\n1. Build a hashmap by putting all the elements and initializing the value to 1\n2. Iterate over the nums array, for each num in nums, find the leftLength and rightLength\n3. LeftLength is defined as the length of the contiguous sequence < num (exclusive)\n4. RightLength is defined as  length of the contiguous sequence > num (exclusive)\n5. so for the given num, the largest possible contiguous sequence is leftLen + rightLen + 1\n6. To optimize this and run it in O(n), we can remove all elements which we encountered in LeftLen and RightLen search. This ensures we iterate over each element exactly once. \n\nHere is the code\nhttps://leetcode.com/problems/longest-consecutive-sequence/submissions/992061594/\n\nI'm reading this can also be done via union find and I am bamboozled. It never occured to me "
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "```HINT```\nUse Set to store the nums  it will be sorted  & duplicate will be removed.\nNow iterate the set and check for the  consecutive sequence and update the answer accordingly. \nJust use the iterator from begining to end to compare all the elements.\nThis will be done in O(nlogn) Time & O(n) space as well\n\n```question```\nSince I am unable to find O(n) solution can anyone  tell me O(n) appraoch.?\nAs most of the solution here are O(nlogn) time using map,priority queue set which take logn time for insertion."
                    },
                    {
                        "username": "pandeyaman5410",
                        "content": "how to get the output\\n"
                    },
                    {
                        "username": "2uringTested",
                        "content": "SPOILERS  AHEAD : An actual O(n) solution\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n\\n```\\nclass Solution {\\npublic:\\n    unordered_map<int,int> parent;\\n    unordered_map<int,int> rank;\\n    int find_compressed(int x){\\n        if(parent[x]==x) return x;\\n        else{\\n            int temp = find_compressed(parent[x]);\\n            parent[x] = temp;\\n            return temp;\\n        }\\n    }\\n\\n    bool union_by_rank(int x,int y){\\n\\n        int parentx = find_compressed(x);\\n        int parenty = find_compressed(y);\\n        if(parentx==parenty) return false;\\n\\n        if(rank[parentx]>rank[parenty]){\\n            parent[parenty]=parentx;\\n        }else if(rank[parentx]<rank[parenty]){\\n            parent[parentx]=parenty;\\n        }else{\\n            parent[parenty] = parentx;\\n            ++rank[parentx];\\n        }\\n        return true;\\n    }\\n    int longestConsecutive(vector<int>& nums) {\\n        \\n        unordered_map<int,int> freq;\\n        for(auto num:nums){\\n            parent[num]=num;\\n            rank[num]=1;\\n        }\\n        for(auto num: nums){\\n            if(parent.find(num+1)!=parent.end()) union_by_rank(num,num+1);\\n            if(parent.find(num-1)!=parent.end()) union_by_rank(num,num-1);\\n        }\\n        for(auto it: parent){\\n            int leader = find_compressed(it.first);\\n            ++freq[leader];\\n        }\\n\\n        int ans =0;\\n        for(auto it: freq){\\n            ans = max(ans,it.second);\\n        }\\n\\n        return ans;\\n        \\n    }\\n};\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "The rules ahead.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "kevinsutan99",
                        "content": "For anyone failing testcase 43 in this question using python, try switching to python 3 instead"
                    },
                    {
                        "username": "Swapnamoy45",
                        "content": "Not a medium Problem by ay means!!"
                    },
                    {
                        "username": "rohan5",
                        "content": "It should be clarified whether duplicates are ignored or taken into account.\\neg\\n`[100,3,200,1,2,2]` -- should it be `3` or `4` ?"
                    },
                    {
                        "username": "MorganFxrmer",
                        "content": "Hi, to answer your question duplicates are ignored and [100,3,200,1,2,2] should be 3. The reason for this is that we are looking for consecutive numbers and duplicate numbers don\\'t count as consecutive. The definition of a consecutive sequence is a sequence where the numbers follow from each other e.g. 1, 2, 3, 4. Referring to your example [100,3,200,1,2,2]: 1, 2, 2, 3 would not be a consecutive sequence because the second 2 does not follow from its previous number (which is also a 2). I hope this helped and good luck!"
                    },
                    {
                        "username": "mohafiz",
                        "content": "What about that too long tc ? it gives me time limit exceeded. My solution has a time complexity of O(n)"
                    },
                    {
                        "username": "mohafiz",
                        "content": "What about that long test case ? it gives me time limit exceeded whatever I do! And my solution is O(n) "
                    },
                    {
                        "username": "DeclanGH",
                        "content": "My first O(n) solution ran 463 ms while the nlogn ran 14ms. its really weird. i was graced to get one testcase wrong durring my attempts, which had 10000 as its answer (the largest input size). Meaning linearithmic time still beat the linear time. Again, Weird. "
                    }
                ]
            },
            {
                "id": 1943838,
                "content": [
                    {
                        "username": "joydeep-lc",
                        "content": "I had a completely different approach to this. Basically:\n1. Build a hashmap by putting all the elements and initializing the value to 1\n2. Iterate over the nums array, for each num in nums, find the leftLength and rightLength\n3. LeftLength is defined as the length of the contiguous sequence < num (exclusive)\n4. RightLength is defined as  length of the contiguous sequence > num (exclusive)\n5. so for the given num, the largest possible contiguous sequence is leftLen + rightLen + 1\n6. To optimize this and run it in O(n), we can remove all elements which we encountered in LeftLen and RightLen search. This ensures we iterate over each element exactly once. \n\nHere is the code\nhttps://leetcode.com/problems/longest-consecutive-sequence/submissions/992061594/\n\nI'm reading this can also be done via union find and I am bamboozled. It never occured to me "
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "```HINT```\nUse Set to store the nums  it will be sorted  & duplicate will be removed.\nNow iterate the set and check for the  consecutive sequence and update the answer accordingly. \nJust use the iterator from begining to end to compare all the elements.\nThis will be done in O(nlogn) Time & O(n) space as well\n\n```question```\nSince I am unable to find O(n) solution can anyone  tell me O(n) appraoch.?\nAs most of the solution here are O(nlogn) time using map,priority queue set which take logn time for insertion."
                    },
                    {
                        "username": "pandeyaman5410",
                        "content": "how to get the output\\n"
                    },
                    {
                        "username": "2uringTested",
                        "content": "SPOILERS  AHEAD : An actual O(n) solution\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n\\n```\\nclass Solution {\\npublic:\\n    unordered_map<int,int> parent;\\n    unordered_map<int,int> rank;\\n    int find_compressed(int x){\\n        if(parent[x]==x) return x;\\n        else{\\n            int temp = find_compressed(parent[x]);\\n            parent[x] = temp;\\n            return temp;\\n        }\\n    }\\n\\n    bool union_by_rank(int x,int y){\\n\\n        int parentx = find_compressed(x);\\n        int parenty = find_compressed(y);\\n        if(parentx==parenty) return false;\\n\\n        if(rank[parentx]>rank[parenty]){\\n            parent[parenty]=parentx;\\n        }else if(rank[parentx]<rank[parenty]){\\n            parent[parentx]=parenty;\\n        }else{\\n            parent[parenty] = parentx;\\n            ++rank[parentx];\\n        }\\n        return true;\\n    }\\n    int longestConsecutive(vector<int>& nums) {\\n        \\n        unordered_map<int,int> freq;\\n        for(auto num:nums){\\n            parent[num]=num;\\n            rank[num]=1;\\n        }\\n        for(auto num: nums){\\n            if(parent.find(num+1)!=parent.end()) union_by_rank(num,num+1);\\n            if(parent.find(num-1)!=parent.end()) union_by_rank(num,num-1);\\n        }\\n        for(auto it: parent){\\n            int leader = find_compressed(it.first);\\n            ++freq[leader];\\n        }\\n\\n        int ans =0;\\n        for(auto it: freq){\\n            ans = max(ans,it.second);\\n        }\\n\\n        return ans;\\n        \\n    }\\n};\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "The rules ahead.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "kevinsutan99",
                        "content": "For anyone failing testcase 43 in this question using python, try switching to python 3 instead"
                    },
                    {
                        "username": "Swapnamoy45",
                        "content": "Not a medium Problem by ay means!!"
                    },
                    {
                        "username": "rohan5",
                        "content": "It should be clarified whether duplicates are ignored or taken into account.\\neg\\n`[100,3,200,1,2,2]` -- should it be `3` or `4` ?"
                    },
                    {
                        "username": "MorganFxrmer",
                        "content": "Hi, to answer your question duplicates are ignored and [100,3,200,1,2,2] should be 3. The reason for this is that we are looking for consecutive numbers and duplicate numbers don\\'t count as consecutive. The definition of a consecutive sequence is a sequence where the numbers follow from each other e.g. 1, 2, 3, 4. Referring to your example [100,3,200,1,2,2]: 1, 2, 2, 3 would not be a consecutive sequence because the second 2 does not follow from its previous number (which is also a 2). I hope this helped and good luck!"
                    },
                    {
                        "username": "mohafiz",
                        "content": "What about that too long tc ? it gives me time limit exceeded. My solution has a time complexity of O(n)"
                    },
                    {
                        "username": "mohafiz",
                        "content": "What about that long test case ? it gives me time limit exceeded whatever I do! And my solution is O(n) "
                    },
                    {
                        "username": "DeclanGH",
                        "content": "My first O(n) solution ran 463 ms while the nlogn ran 14ms. its really weird. i was graced to get one testcase wrong durring my attempts, which had 10000 as its answer (the largest input size). Meaning linearithmic time still beat the linear time. Again, Weird. "
                    }
                ]
            },
            {
                "id": 1941092,
                "content": [
                    {
                        "username": "joydeep-lc",
                        "content": "I had a completely different approach to this. Basically:\n1. Build a hashmap by putting all the elements and initializing the value to 1\n2. Iterate over the nums array, for each num in nums, find the leftLength and rightLength\n3. LeftLength is defined as the length of the contiguous sequence < num (exclusive)\n4. RightLength is defined as  length of the contiguous sequence > num (exclusive)\n5. so for the given num, the largest possible contiguous sequence is leftLen + rightLen + 1\n6. To optimize this and run it in O(n), we can remove all elements which we encountered in LeftLen and RightLen search. This ensures we iterate over each element exactly once. \n\nHere is the code\nhttps://leetcode.com/problems/longest-consecutive-sequence/submissions/992061594/\n\nI'm reading this can also be done via union find and I am bamboozled. It never occured to me "
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "```HINT```\nUse Set to store the nums  it will be sorted  & duplicate will be removed.\nNow iterate the set and check for the  consecutive sequence and update the answer accordingly. \nJust use the iterator from begining to end to compare all the elements.\nThis will be done in O(nlogn) Time & O(n) space as well\n\n```question```\nSince I am unable to find O(n) solution can anyone  tell me O(n) appraoch.?\nAs most of the solution here are O(nlogn) time using map,priority queue set which take logn time for insertion."
                    },
                    {
                        "username": "pandeyaman5410",
                        "content": "how to get the output\\n"
                    },
                    {
                        "username": "2uringTested",
                        "content": "SPOILERS  AHEAD : An actual O(n) solution\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n\\n```\\nclass Solution {\\npublic:\\n    unordered_map<int,int> parent;\\n    unordered_map<int,int> rank;\\n    int find_compressed(int x){\\n        if(parent[x]==x) return x;\\n        else{\\n            int temp = find_compressed(parent[x]);\\n            parent[x] = temp;\\n            return temp;\\n        }\\n    }\\n\\n    bool union_by_rank(int x,int y){\\n\\n        int parentx = find_compressed(x);\\n        int parenty = find_compressed(y);\\n        if(parentx==parenty) return false;\\n\\n        if(rank[parentx]>rank[parenty]){\\n            parent[parenty]=parentx;\\n        }else if(rank[parentx]<rank[parenty]){\\n            parent[parentx]=parenty;\\n        }else{\\n            parent[parenty] = parentx;\\n            ++rank[parentx];\\n        }\\n        return true;\\n    }\\n    int longestConsecutive(vector<int>& nums) {\\n        \\n        unordered_map<int,int> freq;\\n        for(auto num:nums){\\n            parent[num]=num;\\n            rank[num]=1;\\n        }\\n        for(auto num: nums){\\n            if(parent.find(num+1)!=parent.end()) union_by_rank(num,num+1);\\n            if(parent.find(num-1)!=parent.end()) union_by_rank(num,num-1);\\n        }\\n        for(auto it: parent){\\n            int leader = find_compressed(it.first);\\n            ++freq[leader];\\n        }\\n\\n        int ans =0;\\n        for(auto it: freq){\\n            ans = max(ans,it.second);\\n        }\\n\\n        return ans;\\n        \\n    }\\n};\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "The rules ahead.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "kevinsutan99",
                        "content": "For anyone failing testcase 43 in this question using python, try switching to python 3 instead"
                    },
                    {
                        "username": "Swapnamoy45",
                        "content": "Not a medium Problem by ay means!!"
                    },
                    {
                        "username": "rohan5",
                        "content": "It should be clarified whether duplicates are ignored or taken into account.\\neg\\n`[100,3,200,1,2,2]` -- should it be `3` or `4` ?"
                    },
                    {
                        "username": "MorganFxrmer",
                        "content": "Hi, to answer your question duplicates are ignored and [100,3,200,1,2,2] should be 3. The reason for this is that we are looking for consecutive numbers and duplicate numbers don\\'t count as consecutive. The definition of a consecutive sequence is a sequence where the numbers follow from each other e.g. 1, 2, 3, 4. Referring to your example [100,3,200,1,2,2]: 1, 2, 2, 3 would not be a consecutive sequence because the second 2 does not follow from its previous number (which is also a 2). I hope this helped and good luck!"
                    },
                    {
                        "username": "mohafiz",
                        "content": "What about that too long tc ? it gives me time limit exceeded. My solution has a time complexity of O(n)"
                    },
                    {
                        "username": "mohafiz",
                        "content": "What about that long test case ? it gives me time limit exceeded whatever I do! And my solution is O(n) "
                    },
                    {
                        "username": "DeclanGH",
                        "content": "My first O(n) solution ran 463 ms while the nlogn ran 14ms. its really weird. i was graced to get one testcase wrong durring my attempts, which had 10000 as its answer (the largest input size). Meaning linearithmic time still beat the linear time. Again, Weird. "
                    }
                ]
            },
            {
                "id": 1938784,
                "content": [
                    {
                        "username": "MorganFxrmer",
                        "content": "A key hint to be able to solve this problem is understanding that O(n) time complexity doesn't always mean that you cannot have nested loops. Once you realise that it is possible to use a nested loop with the correct logic, and it not result in O(n^2) time complexity, it becomes a more straightforward problem."
                    },
                    {
                        "username": "OrJacob10",
                        "content": "I don\\'t think it\\'s possible to solve this in java with time complexity of O(n), because unlike python, we can\\'t convert an array directly to set without looping through the arrat and add to a new HashSet."
                    },
                    {
                        "username": "DPcodes123",
                        "content": "all the top submissions use sorting which doesn\\'t fit the constraint of O(n) ....."
                    },
                    {
                        "username": "gerald_ho",
                        "content": "I was confused with question and got wrong answer. It refers to the array element instead of the value, i.e. [1,2,0,1] has 3 elements 0, 1, 2. So, this case answer is 3 rather than 2 [0, 1] or [1, 2].\\n\\nSorting O(nlog n) is not necessary. Use the hash and count the object in consecutive sequence."
                    },
                    {
                        "username": "GTexx",
                        "content": "[-8,-8,-6,-6,-6,-3,-1,-1,-1,4,4,9] how this returns 1 where\\'s the sequence??"
                    },
                    {
                        "username": "buinhatanhisded",
                        "content": "longest sequence has length 1"
                    },
                    {
                        "username": "ismoilhasanov68",
                        "content": "Smth is wrong here:\\nOn this test case [9,1,4,7,3,-1,0,5,8,-1,6] my result is 3 and I thinks it should be 3 but expected output is 7 can anyone explain to me whats going on?"
                    },
                    {
                        "username": "Shekhar333",
                        "content": "3,4,5,6,7,8,9"
                    },
                    {
                        "username": "itsgosho",
                        "content": "That is very good problem to practice searching, studying, implementing, testing and solving that problem via Disjoint Set."
                    },
                    {
                        "username": "yxcntu",
                        "content": "the fastest solutions are all using hash + sorting, which blows my mind"
                    },
                    {
                        "username": "SivaramanSelvam",
                        "content": "Need help, tried third approach in Javascript getting around 500 ms. Where as official java solution runs in 33ms?\nANY HELP WOULD BE APPRECIATED!!!\n\nvar longestConsecutive = function(nums) {\n    if (nums.length == 0) {\n        return 0;\n    }\n    let numsSet = new Set();\n    for (let i = 0; i < nums.length; i++) {\n        numsSet.add(nums[i]);\n    }\n    let seqCnt = 1;\n    let maxCnt = 1;\n    let nextElem = 0;\n    for (let i = 0; i < nums.length; i++) {\n        if ( !numsSet.has(nums[i] - 1)) {\n            seqCnt = 1;\n            nextElem = nums[i] + 1;\n            while (numsSet.has(nextElem)) {\n                nextElem += 1;\n                seqCnt += 1;\n            }\n            if (maxCnt < seqCnt) {\n                maxCnt = seqCnt;\n            }\n        }\n    }\n    return maxCnt;\n};\n\n\n\n"
                    },
                    {
                        "username": "robertdoweny761",
                        "content": "88% faster than other by just adding a  line from top submission\nclass Solution {\npublic:\n    int longestConsecutive(vector<int>& nums) {\n    //<----------------------Brute Force-------------------------->\n     ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n    \n    int n = nums.size();\n   if(n == 0) return 0;\n\n        sort(nums.begin(), nums.end());\n\n        int ans = 0;  \n\n        int currlength = 1;\n        \n         for (int i = 1; i<n; i++)\n         {\n\n              if(nums[i] == nums[i-1]+1)\n              { \n                 currlength++;\n                 }\n                 else if(nums[i]!=  nums[i-1])\n                 {\n                    ans = max(ans, currlength);\n\n                    currlength=1;\n                    }          \n         }\n           \n           ans = max(ans, currlength);\n         return ans;\n    }\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1933566,
                "content": [
                    {
                        "username": "MorganFxrmer",
                        "content": "A key hint to be able to solve this problem is understanding that O(n) time complexity doesn't always mean that you cannot have nested loops. Once you realise that it is possible to use a nested loop with the correct logic, and it not result in O(n^2) time complexity, it becomes a more straightforward problem."
                    },
                    {
                        "username": "OrJacob10",
                        "content": "I don\\'t think it\\'s possible to solve this in java with time complexity of O(n), because unlike python, we can\\'t convert an array directly to set without looping through the arrat and add to a new HashSet."
                    },
                    {
                        "username": "DPcodes123",
                        "content": "all the top submissions use sorting which doesn\\'t fit the constraint of O(n) ....."
                    },
                    {
                        "username": "gerald_ho",
                        "content": "I was confused with question and got wrong answer. It refers to the array element instead of the value, i.e. [1,2,0,1] has 3 elements 0, 1, 2. So, this case answer is 3 rather than 2 [0, 1] or [1, 2].\\n\\nSorting O(nlog n) is not necessary. Use the hash and count the object in consecutive sequence."
                    },
                    {
                        "username": "GTexx",
                        "content": "[-8,-8,-6,-6,-6,-3,-1,-1,-1,4,4,9] how this returns 1 where\\'s the sequence??"
                    },
                    {
                        "username": "buinhatanhisded",
                        "content": "longest sequence has length 1"
                    },
                    {
                        "username": "ismoilhasanov68",
                        "content": "Smth is wrong here:\\nOn this test case [9,1,4,7,3,-1,0,5,8,-1,6] my result is 3 and I thinks it should be 3 but expected output is 7 can anyone explain to me whats going on?"
                    },
                    {
                        "username": "Shekhar333",
                        "content": "3,4,5,6,7,8,9"
                    },
                    {
                        "username": "itsgosho",
                        "content": "That is very good problem to practice searching, studying, implementing, testing and solving that problem via Disjoint Set."
                    },
                    {
                        "username": "yxcntu",
                        "content": "the fastest solutions are all using hash + sorting, which blows my mind"
                    },
                    {
                        "username": "SivaramanSelvam",
                        "content": "Need help, tried third approach in Javascript getting around 500 ms. Where as official java solution runs in 33ms?\nANY HELP WOULD BE APPRECIATED!!!\n\nvar longestConsecutive = function(nums) {\n    if (nums.length == 0) {\n        return 0;\n    }\n    let numsSet = new Set();\n    for (let i = 0; i < nums.length; i++) {\n        numsSet.add(nums[i]);\n    }\n    let seqCnt = 1;\n    let maxCnt = 1;\n    let nextElem = 0;\n    for (let i = 0; i < nums.length; i++) {\n        if ( !numsSet.has(nums[i] - 1)) {\n            seqCnt = 1;\n            nextElem = nums[i] + 1;\n            while (numsSet.has(nextElem)) {\n                nextElem += 1;\n                seqCnt += 1;\n            }\n            if (maxCnt < seqCnt) {\n                maxCnt = seqCnt;\n            }\n        }\n    }\n    return maxCnt;\n};\n\n\n\n"
                    },
                    {
                        "username": "robertdoweny761",
                        "content": "88% faster than other by just adding a  line from top submission\nclass Solution {\npublic:\n    int longestConsecutive(vector<int>& nums) {\n    //<----------------------Brute Force-------------------------->\n     ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n    \n    int n = nums.size();\n   if(n == 0) return 0;\n\n        sort(nums.begin(), nums.end());\n\n        int ans = 0;  \n\n        int currlength = 1;\n        \n         for (int i = 1; i<n; i++)\n         {\n\n              if(nums[i] == nums[i-1]+1)\n              { \n                 currlength++;\n                 }\n                 else if(nums[i]!=  nums[i-1])\n                 {\n                    ans = max(ans, currlength);\n\n                    currlength=1;\n                    }          \n         }\n           \n           ans = max(ans, currlength);\n         return ans;\n    }\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1930816,
                "content": [
                    {
                        "username": "MorganFxrmer",
                        "content": "A key hint to be able to solve this problem is understanding that O(n) time complexity doesn't always mean that you cannot have nested loops. Once you realise that it is possible to use a nested loop with the correct logic, and it not result in O(n^2) time complexity, it becomes a more straightforward problem."
                    },
                    {
                        "username": "OrJacob10",
                        "content": "I don\\'t think it\\'s possible to solve this in java with time complexity of O(n), because unlike python, we can\\'t convert an array directly to set without looping through the arrat and add to a new HashSet."
                    },
                    {
                        "username": "DPcodes123",
                        "content": "all the top submissions use sorting which doesn\\'t fit the constraint of O(n) ....."
                    },
                    {
                        "username": "gerald_ho",
                        "content": "I was confused with question and got wrong answer. It refers to the array element instead of the value, i.e. [1,2,0,1] has 3 elements 0, 1, 2. So, this case answer is 3 rather than 2 [0, 1] or [1, 2].\\n\\nSorting O(nlog n) is not necessary. Use the hash and count the object in consecutive sequence."
                    },
                    {
                        "username": "GTexx",
                        "content": "[-8,-8,-6,-6,-6,-3,-1,-1,-1,4,4,9] how this returns 1 where\\'s the sequence??"
                    },
                    {
                        "username": "buinhatanhisded",
                        "content": "longest sequence has length 1"
                    },
                    {
                        "username": "ismoilhasanov68",
                        "content": "Smth is wrong here:\\nOn this test case [9,1,4,7,3,-1,0,5,8,-1,6] my result is 3 and I thinks it should be 3 but expected output is 7 can anyone explain to me whats going on?"
                    },
                    {
                        "username": "Shekhar333",
                        "content": "3,4,5,6,7,8,9"
                    },
                    {
                        "username": "itsgosho",
                        "content": "That is very good problem to practice searching, studying, implementing, testing and solving that problem via Disjoint Set."
                    },
                    {
                        "username": "yxcntu",
                        "content": "the fastest solutions are all using hash + sorting, which blows my mind"
                    },
                    {
                        "username": "SivaramanSelvam",
                        "content": "Need help, tried third approach in Javascript getting around 500 ms. Where as official java solution runs in 33ms?\nANY HELP WOULD BE APPRECIATED!!!\n\nvar longestConsecutive = function(nums) {\n    if (nums.length == 0) {\n        return 0;\n    }\n    let numsSet = new Set();\n    for (let i = 0; i < nums.length; i++) {\n        numsSet.add(nums[i]);\n    }\n    let seqCnt = 1;\n    let maxCnt = 1;\n    let nextElem = 0;\n    for (let i = 0; i < nums.length; i++) {\n        if ( !numsSet.has(nums[i] - 1)) {\n            seqCnt = 1;\n            nextElem = nums[i] + 1;\n            while (numsSet.has(nextElem)) {\n                nextElem += 1;\n                seqCnt += 1;\n            }\n            if (maxCnt < seqCnt) {\n                maxCnt = seqCnt;\n            }\n        }\n    }\n    return maxCnt;\n};\n\n\n\n"
                    },
                    {
                        "username": "robertdoweny761",
                        "content": "88% faster than other by just adding a  line from top submission\nclass Solution {\npublic:\n    int longestConsecutive(vector<int>& nums) {\n    //<----------------------Brute Force-------------------------->\n     ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n    \n    int n = nums.size();\n   if(n == 0) return 0;\n\n        sort(nums.begin(), nums.end());\n\n        int ans = 0;  \n\n        int currlength = 1;\n        \n         for (int i = 1; i<n; i++)\n         {\n\n              if(nums[i] == nums[i-1]+1)\n              { \n                 currlength++;\n                 }\n                 else if(nums[i]!=  nums[i-1])\n                 {\n                    ans = max(ans, currlength);\n\n                    currlength=1;\n                    }          \n         }\n           \n           ans = max(ans, currlength);\n         return ans;\n    }\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1930734,
                "content": [
                    {
                        "username": "MorganFxrmer",
                        "content": "A key hint to be able to solve this problem is understanding that O(n) time complexity doesn't always mean that you cannot have nested loops. Once you realise that it is possible to use a nested loop with the correct logic, and it not result in O(n^2) time complexity, it becomes a more straightforward problem."
                    },
                    {
                        "username": "OrJacob10",
                        "content": "I don\\'t think it\\'s possible to solve this in java with time complexity of O(n), because unlike python, we can\\'t convert an array directly to set without looping through the arrat and add to a new HashSet."
                    },
                    {
                        "username": "DPcodes123",
                        "content": "all the top submissions use sorting which doesn\\'t fit the constraint of O(n) ....."
                    },
                    {
                        "username": "gerald_ho",
                        "content": "I was confused with question and got wrong answer. It refers to the array element instead of the value, i.e. [1,2,0,1] has 3 elements 0, 1, 2. So, this case answer is 3 rather than 2 [0, 1] or [1, 2].\\n\\nSorting O(nlog n) is not necessary. Use the hash and count the object in consecutive sequence."
                    },
                    {
                        "username": "GTexx",
                        "content": "[-8,-8,-6,-6,-6,-3,-1,-1,-1,4,4,9] how this returns 1 where\\'s the sequence??"
                    },
                    {
                        "username": "buinhatanhisded",
                        "content": "longest sequence has length 1"
                    },
                    {
                        "username": "ismoilhasanov68",
                        "content": "Smth is wrong here:\\nOn this test case [9,1,4,7,3,-1,0,5,8,-1,6] my result is 3 and I thinks it should be 3 but expected output is 7 can anyone explain to me whats going on?"
                    },
                    {
                        "username": "Shekhar333",
                        "content": "3,4,5,6,7,8,9"
                    },
                    {
                        "username": "itsgosho",
                        "content": "That is very good problem to practice searching, studying, implementing, testing and solving that problem via Disjoint Set."
                    },
                    {
                        "username": "yxcntu",
                        "content": "the fastest solutions are all using hash + sorting, which blows my mind"
                    },
                    {
                        "username": "SivaramanSelvam",
                        "content": "Need help, tried third approach in Javascript getting around 500 ms. Where as official java solution runs in 33ms?\nANY HELP WOULD BE APPRECIATED!!!\n\nvar longestConsecutive = function(nums) {\n    if (nums.length == 0) {\n        return 0;\n    }\n    let numsSet = new Set();\n    for (let i = 0; i < nums.length; i++) {\n        numsSet.add(nums[i]);\n    }\n    let seqCnt = 1;\n    let maxCnt = 1;\n    let nextElem = 0;\n    for (let i = 0; i < nums.length; i++) {\n        if ( !numsSet.has(nums[i] - 1)) {\n            seqCnt = 1;\n            nextElem = nums[i] + 1;\n            while (numsSet.has(nextElem)) {\n                nextElem += 1;\n                seqCnt += 1;\n            }\n            if (maxCnt < seqCnt) {\n                maxCnt = seqCnt;\n            }\n        }\n    }\n    return maxCnt;\n};\n\n\n\n"
                    },
                    {
                        "username": "robertdoweny761",
                        "content": "88% faster than other by just adding a  line from top submission\nclass Solution {\npublic:\n    int longestConsecutive(vector<int>& nums) {\n    //<----------------------Brute Force-------------------------->\n     ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n    \n    int n = nums.size();\n   if(n == 0) return 0;\n\n        sort(nums.begin(), nums.end());\n\n        int ans = 0;  \n\n        int currlength = 1;\n        \n         for (int i = 1; i<n; i++)\n         {\n\n              if(nums[i] == nums[i-1]+1)\n              { \n                 currlength++;\n                 }\n                 else if(nums[i]!=  nums[i-1])\n                 {\n                    ans = max(ans, currlength);\n\n                    currlength=1;\n                    }          \n         }\n           \n           ans = max(ans, currlength);\n         return ans;\n    }\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1924446,
                "content": [
                    {
                        "username": "MorganFxrmer",
                        "content": "A key hint to be able to solve this problem is understanding that O(n) time complexity doesn't always mean that you cannot have nested loops. Once you realise that it is possible to use a nested loop with the correct logic, and it not result in O(n^2) time complexity, it becomes a more straightforward problem."
                    },
                    {
                        "username": "OrJacob10",
                        "content": "I don\\'t think it\\'s possible to solve this in java with time complexity of O(n), because unlike python, we can\\'t convert an array directly to set without looping through the arrat and add to a new HashSet."
                    },
                    {
                        "username": "DPcodes123",
                        "content": "all the top submissions use sorting which doesn\\'t fit the constraint of O(n) ....."
                    },
                    {
                        "username": "gerald_ho",
                        "content": "I was confused with question and got wrong answer. It refers to the array element instead of the value, i.e. [1,2,0,1] has 3 elements 0, 1, 2. So, this case answer is 3 rather than 2 [0, 1] or [1, 2].\\n\\nSorting O(nlog n) is not necessary. Use the hash and count the object in consecutive sequence."
                    },
                    {
                        "username": "GTexx",
                        "content": "[-8,-8,-6,-6,-6,-3,-1,-1,-1,4,4,9] how this returns 1 where\\'s the sequence??"
                    },
                    {
                        "username": "buinhatanhisded",
                        "content": "longest sequence has length 1"
                    },
                    {
                        "username": "ismoilhasanov68",
                        "content": "Smth is wrong here:\\nOn this test case [9,1,4,7,3,-1,0,5,8,-1,6] my result is 3 and I thinks it should be 3 but expected output is 7 can anyone explain to me whats going on?"
                    },
                    {
                        "username": "Shekhar333",
                        "content": "3,4,5,6,7,8,9"
                    },
                    {
                        "username": "itsgosho",
                        "content": "That is very good problem to practice searching, studying, implementing, testing and solving that problem via Disjoint Set."
                    },
                    {
                        "username": "yxcntu",
                        "content": "the fastest solutions are all using hash + sorting, which blows my mind"
                    },
                    {
                        "username": "SivaramanSelvam",
                        "content": "Need help, tried third approach in Javascript getting around 500 ms. Where as official java solution runs in 33ms?\nANY HELP WOULD BE APPRECIATED!!!\n\nvar longestConsecutive = function(nums) {\n    if (nums.length == 0) {\n        return 0;\n    }\n    let numsSet = new Set();\n    for (let i = 0; i < nums.length; i++) {\n        numsSet.add(nums[i]);\n    }\n    let seqCnt = 1;\n    let maxCnt = 1;\n    let nextElem = 0;\n    for (let i = 0; i < nums.length; i++) {\n        if ( !numsSet.has(nums[i] - 1)) {\n            seqCnt = 1;\n            nextElem = nums[i] + 1;\n            while (numsSet.has(nextElem)) {\n                nextElem += 1;\n                seqCnt += 1;\n            }\n            if (maxCnt < seqCnt) {\n                maxCnt = seqCnt;\n            }\n        }\n    }\n    return maxCnt;\n};\n\n\n\n"
                    },
                    {
                        "username": "robertdoweny761",
                        "content": "88% faster than other by just adding a  line from top submission\nclass Solution {\npublic:\n    int longestConsecutive(vector<int>& nums) {\n    //<----------------------Brute Force-------------------------->\n     ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n    \n    int n = nums.size();\n   if(n == 0) return 0;\n\n        sort(nums.begin(), nums.end());\n\n        int ans = 0;  \n\n        int currlength = 1;\n        \n         for (int i = 1; i<n; i++)\n         {\n\n              if(nums[i] == nums[i-1]+1)\n              { \n                 currlength++;\n                 }\n                 else if(nums[i]!=  nums[i-1])\n                 {\n                    ans = max(ans, currlength);\n\n                    currlength=1;\n                    }          \n         }\n           \n           ans = max(ans, currlength);\n         return ans;\n    }\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1921899,
                "content": [
                    {
                        "username": "MorganFxrmer",
                        "content": "A key hint to be able to solve this problem is understanding that O(n) time complexity doesn't always mean that you cannot have nested loops. Once you realise that it is possible to use a nested loop with the correct logic, and it not result in O(n^2) time complexity, it becomes a more straightforward problem."
                    },
                    {
                        "username": "OrJacob10",
                        "content": "I don\\'t think it\\'s possible to solve this in java with time complexity of O(n), because unlike python, we can\\'t convert an array directly to set without looping through the arrat and add to a new HashSet."
                    },
                    {
                        "username": "DPcodes123",
                        "content": "all the top submissions use sorting which doesn\\'t fit the constraint of O(n) ....."
                    },
                    {
                        "username": "gerald_ho",
                        "content": "I was confused with question and got wrong answer. It refers to the array element instead of the value, i.e. [1,2,0,1] has 3 elements 0, 1, 2. So, this case answer is 3 rather than 2 [0, 1] or [1, 2].\\n\\nSorting O(nlog n) is not necessary. Use the hash and count the object in consecutive sequence."
                    },
                    {
                        "username": "GTexx",
                        "content": "[-8,-8,-6,-6,-6,-3,-1,-1,-1,4,4,9] how this returns 1 where\\'s the sequence??"
                    },
                    {
                        "username": "buinhatanhisded",
                        "content": "longest sequence has length 1"
                    },
                    {
                        "username": "ismoilhasanov68",
                        "content": "Smth is wrong here:\\nOn this test case [9,1,4,7,3,-1,0,5,8,-1,6] my result is 3 and I thinks it should be 3 but expected output is 7 can anyone explain to me whats going on?"
                    },
                    {
                        "username": "Shekhar333",
                        "content": "3,4,5,6,7,8,9"
                    },
                    {
                        "username": "itsgosho",
                        "content": "That is very good problem to practice searching, studying, implementing, testing and solving that problem via Disjoint Set."
                    },
                    {
                        "username": "yxcntu",
                        "content": "the fastest solutions are all using hash + sorting, which blows my mind"
                    },
                    {
                        "username": "SivaramanSelvam",
                        "content": "Need help, tried third approach in Javascript getting around 500 ms. Where as official java solution runs in 33ms?\nANY HELP WOULD BE APPRECIATED!!!\n\nvar longestConsecutive = function(nums) {\n    if (nums.length == 0) {\n        return 0;\n    }\n    let numsSet = new Set();\n    for (let i = 0; i < nums.length; i++) {\n        numsSet.add(nums[i]);\n    }\n    let seqCnt = 1;\n    let maxCnt = 1;\n    let nextElem = 0;\n    for (let i = 0; i < nums.length; i++) {\n        if ( !numsSet.has(nums[i] - 1)) {\n            seqCnt = 1;\n            nextElem = nums[i] + 1;\n            while (numsSet.has(nextElem)) {\n                nextElem += 1;\n                seqCnt += 1;\n            }\n            if (maxCnt < seqCnt) {\n                maxCnt = seqCnt;\n            }\n        }\n    }\n    return maxCnt;\n};\n\n\n\n"
                    },
                    {
                        "username": "robertdoweny761",
                        "content": "88% faster than other by just adding a  line from top submission\nclass Solution {\npublic:\n    int longestConsecutive(vector<int>& nums) {\n    //<----------------------Brute Force-------------------------->\n     ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n    \n    int n = nums.size();\n   if(n == 0) return 0;\n\n        sort(nums.begin(), nums.end());\n\n        int ans = 0;  \n\n        int currlength = 1;\n        \n         for (int i = 1; i<n; i++)\n         {\n\n              if(nums[i] == nums[i-1]+1)\n              { \n                 currlength++;\n                 }\n                 else if(nums[i]!=  nums[i-1])\n                 {\n                    ans = max(ans, currlength);\n\n                    currlength=1;\n                    }          \n         }\n           \n           ans = max(ans, currlength);\n         return ans;\n    }\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1915829,
                "content": [
                    {
                        "username": "MorganFxrmer",
                        "content": "A key hint to be able to solve this problem is understanding that O(n) time complexity doesn't always mean that you cannot have nested loops. Once you realise that it is possible to use a nested loop with the correct logic, and it not result in O(n^2) time complexity, it becomes a more straightforward problem."
                    },
                    {
                        "username": "OrJacob10",
                        "content": "I don\\'t think it\\'s possible to solve this in java with time complexity of O(n), because unlike python, we can\\'t convert an array directly to set without looping through the arrat and add to a new HashSet."
                    },
                    {
                        "username": "DPcodes123",
                        "content": "all the top submissions use sorting which doesn\\'t fit the constraint of O(n) ....."
                    },
                    {
                        "username": "gerald_ho",
                        "content": "I was confused with question and got wrong answer. It refers to the array element instead of the value, i.e. [1,2,0,1] has 3 elements 0, 1, 2. So, this case answer is 3 rather than 2 [0, 1] or [1, 2].\\n\\nSorting O(nlog n) is not necessary. Use the hash and count the object in consecutive sequence."
                    },
                    {
                        "username": "GTexx",
                        "content": "[-8,-8,-6,-6,-6,-3,-1,-1,-1,4,4,9] how this returns 1 where\\'s the sequence??"
                    },
                    {
                        "username": "buinhatanhisded",
                        "content": "longest sequence has length 1"
                    },
                    {
                        "username": "ismoilhasanov68",
                        "content": "Smth is wrong here:\\nOn this test case [9,1,4,7,3,-1,0,5,8,-1,6] my result is 3 and I thinks it should be 3 but expected output is 7 can anyone explain to me whats going on?"
                    },
                    {
                        "username": "Shekhar333",
                        "content": "3,4,5,6,7,8,9"
                    },
                    {
                        "username": "itsgosho",
                        "content": "That is very good problem to practice searching, studying, implementing, testing and solving that problem via Disjoint Set."
                    },
                    {
                        "username": "yxcntu",
                        "content": "the fastest solutions are all using hash + sorting, which blows my mind"
                    },
                    {
                        "username": "SivaramanSelvam",
                        "content": "Need help, tried third approach in Javascript getting around 500 ms. Where as official java solution runs in 33ms?\nANY HELP WOULD BE APPRECIATED!!!\n\nvar longestConsecutive = function(nums) {\n    if (nums.length == 0) {\n        return 0;\n    }\n    let numsSet = new Set();\n    for (let i = 0; i < nums.length; i++) {\n        numsSet.add(nums[i]);\n    }\n    let seqCnt = 1;\n    let maxCnt = 1;\n    let nextElem = 0;\n    for (let i = 0; i < nums.length; i++) {\n        if ( !numsSet.has(nums[i] - 1)) {\n            seqCnt = 1;\n            nextElem = nums[i] + 1;\n            while (numsSet.has(nextElem)) {\n                nextElem += 1;\n                seqCnt += 1;\n            }\n            if (maxCnt < seqCnt) {\n                maxCnt = seqCnt;\n            }\n        }\n    }\n    return maxCnt;\n};\n\n\n\n"
                    },
                    {
                        "username": "robertdoweny761",
                        "content": "88% faster than other by just adding a  line from top submission\nclass Solution {\npublic:\n    int longestConsecutive(vector<int>& nums) {\n    //<----------------------Brute Force-------------------------->\n     ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n    \n    int n = nums.size();\n   if(n == 0) return 0;\n\n        sort(nums.begin(), nums.end());\n\n        int ans = 0;  \n\n        int currlength = 1;\n        \n         for (int i = 1; i<n; i++)\n         {\n\n              if(nums[i] == nums[i-1]+1)\n              { \n                 currlength++;\n                 }\n                 else if(nums[i]!=  nums[i-1])\n                 {\n                    ans = max(ans, currlength);\n\n                    currlength=1;\n                    }          \n         }\n           \n           ans = max(ans, currlength);\n         return ans;\n    }\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1915100,
                "content": [
                    {
                        "username": "MorganFxrmer",
                        "content": "A key hint to be able to solve this problem is understanding that O(n) time complexity doesn't always mean that you cannot have nested loops. Once you realise that it is possible to use a nested loop with the correct logic, and it not result in O(n^2) time complexity, it becomes a more straightforward problem."
                    },
                    {
                        "username": "OrJacob10",
                        "content": "I don\\'t think it\\'s possible to solve this in java with time complexity of O(n), because unlike python, we can\\'t convert an array directly to set without looping through the arrat and add to a new HashSet."
                    },
                    {
                        "username": "DPcodes123",
                        "content": "all the top submissions use sorting which doesn\\'t fit the constraint of O(n) ....."
                    },
                    {
                        "username": "gerald_ho",
                        "content": "I was confused with question and got wrong answer. It refers to the array element instead of the value, i.e. [1,2,0,1] has 3 elements 0, 1, 2. So, this case answer is 3 rather than 2 [0, 1] or [1, 2].\\n\\nSorting O(nlog n) is not necessary. Use the hash and count the object in consecutive sequence."
                    },
                    {
                        "username": "GTexx",
                        "content": "[-8,-8,-6,-6,-6,-3,-1,-1,-1,4,4,9] how this returns 1 where\\'s the sequence??"
                    },
                    {
                        "username": "buinhatanhisded",
                        "content": "longest sequence has length 1"
                    },
                    {
                        "username": "ismoilhasanov68",
                        "content": "Smth is wrong here:\\nOn this test case [9,1,4,7,3,-1,0,5,8,-1,6] my result is 3 and I thinks it should be 3 but expected output is 7 can anyone explain to me whats going on?"
                    },
                    {
                        "username": "Shekhar333",
                        "content": "3,4,5,6,7,8,9"
                    },
                    {
                        "username": "itsgosho",
                        "content": "That is very good problem to practice searching, studying, implementing, testing and solving that problem via Disjoint Set."
                    },
                    {
                        "username": "yxcntu",
                        "content": "the fastest solutions are all using hash + sorting, which blows my mind"
                    },
                    {
                        "username": "SivaramanSelvam",
                        "content": "Need help, tried third approach in Javascript getting around 500 ms. Where as official java solution runs in 33ms?\nANY HELP WOULD BE APPRECIATED!!!\n\nvar longestConsecutive = function(nums) {\n    if (nums.length == 0) {\n        return 0;\n    }\n    let numsSet = new Set();\n    for (let i = 0; i < nums.length; i++) {\n        numsSet.add(nums[i]);\n    }\n    let seqCnt = 1;\n    let maxCnt = 1;\n    let nextElem = 0;\n    for (let i = 0; i < nums.length; i++) {\n        if ( !numsSet.has(nums[i] - 1)) {\n            seqCnt = 1;\n            nextElem = nums[i] + 1;\n            while (numsSet.has(nextElem)) {\n                nextElem += 1;\n                seqCnt += 1;\n            }\n            if (maxCnt < seqCnt) {\n                maxCnt = seqCnt;\n            }\n        }\n    }\n    return maxCnt;\n};\n\n\n\n"
                    },
                    {
                        "username": "robertdoweny761",
                        "content": "88% faster than other by just adding a  line from top submission\nclass Solution {\npublic:\n    int longestConsecutive(vector<int>& nums) {\n    //<----------------------Brute Force-------------------------->\n     ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n    \n    int n = nums.size();\n   if(n == 0) return 0;\n\n        sort(nums.begin(), nums.end());\n\n        int ans = 0;  \n\n        int currlength = 1;\n        \n         for (int i = 1; i<n; i++)\n         {\n\n              if(nums[i] == nums[i-1]+1)\n              { \n                 currlength++;\n                 }\n                 else if(nums[i]!=  nums[i-1])\n                 {\n                    ans = max(ans, currlength);\n\n                    currlength=1;\n                    }          \n         }\n           \n           ans = max(ans, currlength);\n         return ans;\n    }\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1913205,
                "content": [
                    {
                        "username": "MorganFxrmer",
                        "content": "A key hint to be able to solve this problem is understanding that O(n) time complexity doesn't always mean that you cannot have nested loops. Once you realise that it is possible to use a nested loop with the correct logic, and it not result in O(n^2) time complexity, it becomes a more straightforward problem."
                    },
                    {
                        "username": "OrJacob10",
                        "content": "I don\\'t think it\\'s possible to solve this in java with time complexity of O(n), because unlike python, we can\\'t convert an array directly to set without looping through the arrat and add to a new HashSet."
                    },
                    {
                        "username": "DPcodes123",
                        "content": "all the top submissions use sorting which doesn\\'t fit the constraint of O(n) ....."
                    },
                    {
                        "username": "gerald_ho",
                        "content": "I was confused with question and got wrong answer. It refers to the array element instead of the value, i.e. [1,2,0,1] has 3 elements 0, 1, 2. So, this case answer is 3 rather than 2 [0, 1] or [1, 2].\\n\\nSorting O(nlog n) is not necessary. Use the hash and count the object in consecutive sequence."
                    },
                    {
                        "username": "GTexx",
                        "content": "[-8,-8,-6,-6,-6,-3,-1,-1,-1,4,4,9] how this returns 1 where\\'s the sequence??"
                    },
                    {
                        "username": "buinhatanhisded",
                        "content": "longest sequence has length 1"
                    },
                    {
                        "username": "ismoilhasanov68",
                        "content": "Smth is wrong here:\\nOn this test case [9,1,4,7,3,-1,0,5,8,-1,6] my result is 3 and I thinks it should be 3 but expected output is 7 can anyone explain to me whats going on?"
                    },
                    {
                        "username": "Shekhar333",
                        "content": "3,4,5,6,7,8,9"
                    },
                    {
                        "username": "itsgosho",
                        "content": "That is very good problem to practice searching, studying, implementing, testing and solving that problem via Disjoint Set."
                    },
                    {
                        "username": "yxcntu",
                        "content": "the fastest solutions are all using hash + sorting, which blows my mind"
                    },
                    {
                        "username": "SivaramanSelvam",
                        "content": "Need help, tried third approach in Javascript getting around 500 ms. Where as official java solution runs in 33ms?\nANY HELP WOULD BE APPRECIATED!!!\n\nvar longestConsecutive = function(nums) {\n    if (nums.length == 0) {\n        return 0;\n    }\n    let numsSet = new Set();\n    for (let i = 0; i < nums.length; i++) {\n        numsSet.add(nums[i]);\n    }\n    let seqCnt = 1;\n    let maxCnt = 1;\n    let nextElem = 0;\n    for (let i = 0; i < nums.length; i++) {\n        if ( !numsSet.has(nums[i] - 1)) {\n            seqCnt = 1;\n            nextElem = nums[i] + 1;\n            while (numsSet.has(nextElem)) {\n                nextElem += 1;\n                seqCnt += 1;\n            }\n            if (maxCnt < seqCnt) {\n                maxCnt = seqCnt;\n            }\n        }\n    }\n    return maxCnt;\n};\n\n\n\n"
                    },
                    {
                        "username": "robertdoweny761",
                        "content": "88% faster than other by just adding a  line from top submission\nclass Solution {\npublic:\n    int longestConsecutive(vector<int>& nums) {\n    //<----------------------Brute Force-------------------------->\n     ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n    \n    int n = nums.size();\n   if(n == 0) return 0;\n\n        sort(nums.begin(), nums.end());\n\n        int ans = 0;  \n\n        int currlength = 1;\n        \n         for (int i = 1; i<n; i++)\n         {\n\n              if(nums[i] == nums[i-1]+1)\n              { \n                 currlength++;\n                 }\n                 else if(nums[i]!=  nums[i-1])\n                 {\n                    ans = max(ans, currlength);\n\n                    currlength=1;\n                    }          \n         }\n           \n           ans = max(ans, currlength);\n         return ans;\n    }\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1904471,
                "content": [
                    {
                        "username": "MorganFxrmer",
                        "content": "A key hint to be able to solve this problem is understanding that O(n) time complexity doesn't always mean that you cannot have nested loops. Once you realise that it is possible to use a nested loop with the correct logic, and it not result in O(n^2) time complexity, it becomes a more straightforward problem."
                    },
                    {
                        "username": "OrJacob10",
                        "content": "I don\\'t think it\\'s possible to solve this in java with time complexity of O(n), because unlike python, we can\\'t convert an array directly to set without looping through the arrat and add to a new HashSet."
                    },
                    {
                        "username": "DPcodes123",
                        "content": "all the top submissions use sorting which doesn\\'t fit the constraint of O(n) ....."
                    },
                    {
                        "username": "gerald_ho",
                        "content": "I was confused with question and got wrong answer. It refers to the array element instead of the value, i.e. [1,2,0,1] has 3 elements 0, 1, 2. So, this case answer is 3 rather than 2 [0, 1] or [1, 2].\\n\\nSorting O(nlog n) is not necessary. Use the hash and count the object in consecutive sequence."
                    },
                    {
                        "username": "GTexx",
                        "content": "[-8,-8,-6,-6,-6,-3,-1,-1,-1,4,4,9] how this returns 1 where\\'s the sequence??"
                    },
                    {
                        "username": "buinhatanhisded",
                        "content": "longest sequence has length 1"
                    },
                    {
                        "username": "ismoilhasanov68",
                        "content": "Smth is wrong here:\\nOn this test case [9,1,4,7,3,-1,0,5,8,-1,6] my result is 3 and I thinks it should be 3 but expected output is 7 can anyone explain to me whats going on?"
                    },
                    {
                        "username": "Shekhar333",
                        "content": "3,4,5,6,7,8,9"
                    },
                    {
                        "username": "itsgosho",
                        "content": "That is very good problem to practice searching, studying, implementing, testing and solving that problem via Disjoint Set."
                    },
                    {
                        "username": "yxcntu",
                        "content": "the fastest solutions are all using hash + sorting, which blows my mind"
                    },
                    {
                        "username": "SivaramanSelvam",
                        "content": "Need help, tried third approach in Javascript getting around 500 ms. Where as official java solution runs in 33ms?\nANY HELP WOULD BE APPRECIATED!!!\n\nvar longestConsecutive = function(nums) {\n    if (nums.length == 0) {\n        return 0;\n    }\n    let numsSet = new Set();\n    for (let i = 0; i < nums.length; i++) {\n        numsSet.add(nums[i]);\n    }\n    let seqCnt = 1;\n    let maxCnt = 1;\n    let nextElem = 0;\n    for (let i = 0; i < nums.length; i++) {\n        if ( !numsSet.has(nums[i] - 1)) {\n            seqCnt = 1;\n            nextElem = nums[i] + 1;\n            while (numsSet.has(nextElem)) {\n                nextElem += 1;\n                seqCnt += 1;\n            }\n            if (maxCnt < seqCnt) {\n                maxCnt = seqCnt;\n            }\n        }\n    }\n    return maxCnt;\n};\n\n\n\n"
                    },
                    {
                        "username": "robertdoweny761",
                        "content": "88% faster than other by just adding a  line from top submission\nclass Solution {\npublic:\n    int longestConsecutive(vector<int>& nums) {\n    //<----------------------Brute Force-------------------------->\n     ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n    \n    int n = nums.size();\n   if(n == 0) return 0;\n\n        sort(nums.begin(), nums.end());\n\n        int ans = 0;  \n\n        int currlength = 1;\n        \n         for (int i = 1; i<n; i++)\n         {\n\n              if(nums[i] == nums[i-1]+1)\n              { \n                 currlength++;\n                 }\n                 else if(nums[i]!=  nums[i-1])\n                 {\n                    ans = max(ans, currlength);\n\n                    currlength=1;\n                    }          \n         }\n           \n           ans = max(ans, currlength);\n         return ans;\n    }\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1893986,
                "content": [
                    {
                        "username": "swapnil019",
                        "content": "class Solution {\\npublic:\\n    int longestConsecutive(vector<int>& nums) {\\n        int cnt = 1;\\n        int maxi = 1;\\n        map<int, int> mp;\\n        for(auto it : nums){\\n            mp[it]++;\\n        }\\n        vector<int> ans;\\n        for(auto it : mp){\\n            ans.push_back(it.first);\\n        }\\n\\n        if(ans.size() < 1){\\n            return 0;\\n        }\\n        //sort(ans.begin(), ans.end());\\n        for(int i = 1; i < ans.size(); ++i)\\n        {\\n            if(ans[i-1]+1 == ans[i]){\\n                cnt++;\\n                maxi = max(cnt, maxi);\\n            }else{\\n                cnt = 1;\\n            }\\n        }\\n\\n        return maxi;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "dewanharsh",
                        "content": "I tried with 2 approaches, both successful \\n1. Using Priority Queue. Time Complexity O(n), \\n    Space Complexity O(n)\\n\\n2. First sorting the array and then traversing it. \\n    Time Complexity O(nlogn)."
                    },
                    {
                        "username": "raiymbek_zhumatov",
                        "content": "Is it possible to sovle this problem with bfs? I\\'ve tried, but things that work in my compiler simply does not work on lc"
                    },
                    {
                        "username": "miha4406",
                        "content": "Is it legal to sort it beforehand?"
                    },
                    {
                        "username": "tamtam484-new",
                        "content": "Because of problem limitation, only algorithm with O(n) should be accepted, but it seems that testcase is too short to evaluate that. \\nAnd in python3, sorting algorithm is even firster than correct algorithm!"
                    },
                    {
                        "username": "NIKHIL9119",
                        "content": "The question is itself unclear.\\nFor the test case [0,0] correct answer is 1\\nwhile for test case [1,2,0,1] it is 3."
                    },
                    {
                        "username": "Vithesh",
                        "content": "its correct\\nfirst test case answer is [0] and next one is [0,1,2] so answer is 1 and 3."
                    },
                    {
                        "username": "JSorngard",
                        "content": "If you use radix sort you can do O(n) with sorting ;)"
                    },
                    {
                        "username": "kamranmemon25",
                        "content": "[9,1,4,7,3,-1,0,5,8,-1,6]\\nHow is the output for this nums expected 7 ( there is no 2 in the array) it should be 3) -- > [-1,0,1]"
                    },
                    {
                        "username": "ash030",
                        "content": "since largest has to be returned, answer will be 7 - > 3, 4, 5, 6, 7, 8, 9 "
                    },
                    {
                        "username": "sohussain",
                        "content": "Why does iterating over a set result in a much faster runtime compared to iterating over a list?\\nThis is confusing because iterating over a list should be faster.\\nlist\\n![image](https://user-images.githubusercontent.com/1150371/218372757-dfcff8f8-935f-45ee-a67b-e6bb99f1ac77.png)\\nset\\n![image](https://user-images.githubusercontent.com/1150371/218372794-db2dc92e-c900-45bb-9ce2-75c0dc7dddae.png)\\nruntime\\n![runtime](https://user-images.githubusercontent.com/1150371/218372173-f87210f0-2349-4ce0-9174-05be20361583.png)"
                    },
                    {
                        "username": "dkmar",
                        "content": "It\\'s more than what bargavkoduri said. You can speed up the solutions iterating over the list by similar margins. Try adding a `s.remove(n)` in your streak-counting while loop. We should not be seeing this level of speed-up.\\n\\nI think leetcode has imposed memory limits and we are seeing speed-up whenever we ease our memory usage (by removing numbers from the set after we\\'ve seen them; or by omitting the for-loop over nums list, which probably saves us from loading the nums list into cache or memory)"
                    },
                    {
                        "username": "sohussain",
                        "content": "[@bargavkoduri](/bargavkoduri) Thanks! in hindsight it sounds obvious but I never thought of it that way."
                    },
                    {
                        "username": "bargavkoduri",
                        "content": "iterating over set is better than list.In set we find the length from each start point exactly once, in list we find it frequency of start point times. suppose [1,2,3,4,5,6,1,1,1] is the given input in set we find length of longest sequence from 1 exactly once in list we find it 4 times."
                    },
                    {
                        "username": "user1084S",
                        "content": "class Solution {\\n    public int longestConsecutive(int[] nums) {\\n        Arrays.sort(nums); //sorting for getting conintous numbers\\n        if(nums.length==0) \\n         return 0;\\n        int c=1,ans=1;\\n        for(int i=1;i<nums.length;i++){\\n            if(nums[i-1]==nums[i]-1) //checking if diff is 1 then it is cons\\n              c++;\\n            else if(nums[i]==nums[i-1])// for repetition \\n            continue;\\n            else\\n             c=1;  //if diff >1\\n           ans=Math.max(ans,c);\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1892015,
                "content": [
                    {
                        "username": "swapnil019",
                        "content": "class Solution {\\npublic:\\n    int longestConsecutive(vector<int>& nums) {\\n        int cnt = 1;\\n        int maxi = 1;\\n        map<int, int> mp;\\n        for(auto it : nums){\\n            mp[it]++;\\n        }\\n        vector<int> ans;\\n        for(auto it : mp){\\n            ans.push_back(it.first);\\n        }\\n\\n        if(ans.size() < 1){\\n            return 0;\\n        }\\n        //sort(ans.begin(), ans.end());\\n        for(int i = 1; i < ans.size(); ++i)\\n        {\\n            if(ans[i-1]+1 == ans[i]){\\n                cnt++;\\n                maxi = max(cnt, maxi);\\n            }else{\\n                cnt = 1;\\n            }\\n        }\\n\\n        return maxi;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "dewanharsh",
                        "content": "I tried with 2 approaches, both successful \\n1. Using Priority Queue. Time Complexity O(n), \\n    Space Complexity O(n)\\n\\n2. First sorting the array and then traversing it. \\n    Time Complexity O(nlogn)."
                    },
                    {
                        "username": "raiymbek_zhumatov",
                        "content": "Is it possible to sovle this problem with bfs? I\\'ve tried, but things that work in my compiler simply does not work on lc"
                    },
                    {
                        "username": "miha4406",
                        "content": "Is it legal to sort it beforehand?"
                    },
                    {
                        "username": "tamtam484-new",
                        "content": "Because of problem limitation, only algorithm with O(n) should be accepted, but it seems that testcase is too short to evaluate that. \\nAnd in python3, sorting algorithm is even firster than correct algorithm!"
                    },
                    {
                        "username": "NIKHIL9119",
                        "content": "The question is itself unclear.\\nFor the test case [0,0] correct answer is 1\\nwhile for test case [1,2,0,1] it is 3."
                    },
                    {
                        "username": "Vithesh",
                        "content": "its correct\\nfirst test case answer is [0] and next one is [0,1,2] so answer is 1 and 3."
                    },
                    {
                        "username": "JSorngard",
                        "content": "If you use radix sort you can do O(n) with sorting ;)"
                    },
                    {
                        "username": "kamranmemon25",
                        "content": "[9,1,4,7,3,-1,0,5,8,-1,6]\\nHow is the output for this nums expected 7 ( there is no 2 in the array) it should be 3) -- > [-1,0,1]"
                    },
                    {
                        "username": "ash030",
                        "content": "since largest has to be returned, answer will be 7 - > 3, 4, 5, 6, 7, 8, 9 "
                    },
                    {
                        "username": "sohussain",
                        "content": "Why does iterating over a set result in a much faster runtime compared to iterating over a list?\\nThis is confusing because iterating over a list should be faster.\\nlist\\n![image](https://user-images.githubusercontent.com/1150371/218372757-dfcff8f8-935f-45ee-a67b-e6bb99f1ac77.png)\\nset\\n![image](https://user-images.githubusercontent.com/1150371/218372794-db2dc92e-c900-45bb-9ce2-75c0dc7dddae.png)\\nruntime\\n![runtime](https://user-images.githubusercontent.com/1150371/218372173-f87210f0-2349-4ce0-9174-05be20361583.png)"
                    },
                    {
                        "username": "dkmar",
                        "content": "It\\'s more than what bargavkoduri said. You can speed up the solutions iterating over the list by similar margins. Try adding a `s.remove(n)` in your streak-counting while loop. We should not be seeing this level of speed-up.\\n\\nI think leetcode has imposed memory limits and we are seeing speed-up whenever we ease our memory usage (by removing numbers from the set after we\\'ve seen them; or by omitting the for-loop over nums list, which probably saves us from loading the nums list into cache or memory)"
                    },
                    {
                        "username": "sohussain",
                        "content": "[@bargavkoduri](/bargavkoduri) Thanks! in hindsight it sounds obvious but I never thought of it that way."
                    },
                    {
                        "username": "bargavkoduri",
                        "content": "iterating over set is better than list.In set we find the length from each start point exactly once, in list we find it frequency of start point times. suppose [1,2,3,4,5,6,1,1,1] is the given input in set we find length of longest sequence from 1 exactly once in list we find it 4 times."
                    },
                    {
                        "username": "user1084S",
                        "content": "class Solution {\\n    public int longestConsecutive(int[] nums) {\\n        Arrays.sort(nums); //sorting for getting conintous numbers\\n        if(nums.length==0) \\n         return 0;\\n        int c=1,ans=1;\\n        for(int i=1;i<nums.length;i++){\\n            if(nums[i-1]==nums[i]-1) //checking if diff is 1 then it is cons\\n              c++;\\n            else if(nums[i]==nums[i-1])// for repetition \\n            continue;\\n            else\\n             c=1;  //if diff >1\\n           ans=Math.max(ans,c);\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1890208,
                "content": [
                    {
                        "username": "swapnil019",
                        "content": "class Solution {\\npublic:\\n    int longestConsecutive(vector<int>& nums) {\\n        int cnt = 1;\\n        int maxi = 1;\\n        map<int, int> mp;\\n        for(auto it : nums){\\n            mp[it]++;\\n        }\\n        vector<int> ans;\\n        for(auto it : mp){\\n            ans.push_back(it.first);\\n        }\\n\\n        if(ans.size() < 1){\\n            return 0;\\n        }\\n        //sort(ans.begin(), ans.end());\\n        for(int i = 1; i < ans.size(); ++i)\\n        {\\n            if(ans[i-1]+1 == ans[i]){\\n                cnt++;\\n                maxi = max(cnt, maxi);\\n            }else{\\n                cnt = 1;\\n            }\\n        }\\n\\n        return maxi;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "dewanharsh",
                        "content": "I tried with 2 approaches, both successful \\n1. Using Priority Queue. Time Complexity O(n), \\n    Space Complexity O(n)\\n\\n2. First sorting the array and then traversing it. \\n    Time Complexity O(nlogn)."
                    },
                    {
                        "username": "raiymbek_zhumatov",
                        "content": "Is it possible to sovle this problem with bfs? I\\'ve tried, but things that work in my compiler simply does not work on lc"
                    },
                    {
                        "username": "miha4406",
                        "content": "Is it legal to sort it beforehand?"
                    },
                    {
                        "username": "tamtam484-new",
                        "content": "Because of problem limitation, only algorithm with O(n) should be accepted, but it seems that testcase is too short to evaluate that. \\nAnd in python3, sorting algorithm is even firster than correct algorithm!"
                    },
                    {
                        "username": "NIKHIL9119",
                        "content": "The question is itself unclear.\\nFor the test case [0,0] correct answer is 1\\nwhile for test case [1,2,0,1] it is 3."
                    },
                    {
                        "username": "Vithesh",
                        "content": "its correct\\nfirst test case answer is [0] and next one is [0,1,2] so answer is 1 and 3."
                    },
                    {
                        "username": "JSorngard",
                        "content": "If you use radix sort you can do O(n) with sorting ;)"
                    },
                    {
                        "username": "kamranmemon25",
                        "content": "[9,1,4,7,3,-1,0,5,8,-1,6]\\nHow is the output for this nums expected 7 ( there is no 2 in the array) it should be 3) -- > [-1,0,1]"
                    },
                    {
                        "username": "ash030",
                        "content": "since largest has to be returned, answer will be 7 - > 3, 4, 5, 6, 7, 8, 9 "
                    },
                    {
                        "username": "sohussain",
                        "content": "Why does iterating over a set result in a much faster runtime compared to iterating over a list?\\nThis is confusing because iterating over a list should be faster.\\nlist\\n![image](https://user-images.githubusercontent.com/1150371/218372757-dfcff8f8-935f-45ee-a67b-e6bb99f1ac77.png)\\nset\\n![image](https://user-images.githubusercontent.com/1150371/218372794-db2dc92e-c900-45bb-9ce2-75c0dc7dddae.png)\\nruntime\\n![runtime](https://user-images.githubusercontent.com/1150371/218372173-f87210f0-2349-4ce0-9174-05be20361583.png)"
                    },
                    {
                        "username": "dkmar",
                        "content": "It\\'s more than what bargavkoduri said. You can speed up the solutions iterating over the list by similar margins. Try adding a `s.remove(n)` in your streak-counting while loop. We should not be seeing this level of speed-up.\\n\\nI think leetcode has imposed memory limits and we are seeing speed-up whenever we ease our memory usage (by removing numbers from the set after we\\'ve seen them; or by omitting the for-loop over nums list, which probably saves us from loading the nums list into cache or memory)"
                    },
                    {
                        "username": "sohussain",
                        "content": "[@bargavkoduri](/bargavkoduri) Thanks! in hindsight it sounds obvious but I never thought of it that way."
                    },
                    {
                        "username": "bargavkoduri",
                        "content": "iterating over set is better than list.In set we find the length from each start point exactly once, in list we find it frequency of start point times. suppose [1,2,3,4,5,6,1,1,1] is the given input in set we find length of longest sequence from 1 exactly once in list we find it 4 times."
                    },
                    {
                        "username": "user1084S",
                        "content": "class Solution {\\n    public int longestConsecutive(int[] nums) {\\n        Arrays.sort(nums); //sorting for getting conintous numbers\\n        if(nums.length==0) \\n         return 0;\\n        int c=1,ans=1;\\n        for(int i=1;i<nums.length;i++){\\n            if(nums[i-1]==nums[i]-1) //checking if diff is 1 then it is cons\\n              c++;\\n            else if(nums[i]==nums[i-1])// for repetition \\n            continue;\\n            else\\n             c=1;  //if diff >1\\n           ans=Math.max(ans,c);\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1878735,
                "content": [
                    {
                        "username": "swapnil019",
                        "content": "class Solution {\\npublic:\\n    int longestConsecutive(vector<int>& nums) {\\n        int cnt = 1;\\n        int maxi = 1;\\n        map<int, int> mp;\\n        for(auto it : nums){\\n            mp[it]++;\\n        }\\n        vector<int> ans;\\n        for(auto it : mp){\\n            ans.push_back(it.first);\\n        }\\n\\n        if(ans.size() < 1){\\n            return 0;\\n        }\\n        //sort(ans.begin(), ans.end());\\n        for(int i = 1; i < ans.size(); ++i)\\n        {\\n            if(ans[i-1]+1 == ans[i]){\\n                cnt++;\\n                maxi = max(cnt, maxi);\\n            }else{\\n                cnt = 1;\\n            }\\n        }\\n\\n        return maxi;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "dewanharsh",
                        "content": "I tried with 2 approaches, both successful \\n1. Using Priority Queue. Time Complexity O(n), \\n    Space Complexity O(n)\\n\\n2. First sorting the array and then traversing it. \\n    Time Complexity O(nlogn)."
                    },
                    {
                        "username": "raiymbek_zhumatov",
                        "content": "Is it possible to sovle this problem with bfs? I\\'ve tried, but things that work in my compiler simply does not work on lc"
                    },
                    {
                        "username": "miha4406",
                        "content": "Is it legal to sort it beforehand?"
                    },
                    {
                        "username": "tamtam484-new",
                        "content": "Because of problem limitation, only algorithm with O(n) should be accepted, but it seems that testcase is too short to evaluate that. \\nAnd in python3, sorting algorithm is even firster than correct algorithm!"
                    },
                    {
                        "username": "NIKHIL9119",
                        "content": "The question is itself unclear.\\nFor the test case [0,0] correct answer is 1\\nwhile for test case [1,2,0,1] it is 3."
                    },
                    {
                        "username": "Vithesh",
                        "content": "its correct\\nfirst test case answer is [0] and next one is [0,1,2] so answer is 1 and 3."
                    },
                    {
                        "username": "JSorngard",
                        "content": "If you use radix sort you can do O(n) with sorting ;)"
                    },
                    {
                        "username": "kamranmemon25",
                        "content": "[9,1,4,7,3,-1,0,5,8,-1,6]\\nHow is the output for this nums expected 7 ( there is no 2 in the array) it should be 3) -- > [-1,0,1]"
                    },
                    {
                        "username": "ash030",
                        "content": "since largest has to be returned, answer will be 7 - > 3, 4, 5, 6, 7, 8, 9 "
                    },
                    {
                        "username": "sohussain",
                        "content": "Why does iterating over a set result in a much faster runtime compared to iterating over a list?\\nThis is confusing because iterating over a list should be faster.\\nlist\\n![image](https://user-images.githubusercontent.com/1150371/218372757-dfcff8f8-935f-45ee-a67b-e6bb99f1ac77.png)\\nset\\n![image](https://user-images.githubusercontent.com/1150371/218372794-db2dc92e-c900-45bb-9ce2-75c0dc7dddae.png)\\nruntime\\n![runtime](https://user-images.githubusercontent.com/1150371/218372173-f87210f0-2349-4ce0-9174-05be20361583.png)"
                    },
                    {
                        "username": "dkmar",
                        "content": "It\\'s more than what bargavkoduri said. You can speed up the solutions iterating over the list by similar margins. Try adding a `s.remove(n)` in your streak-counting while loop. We should not be seeing this level of speed-up.\\n\\nI think leetcode has imposed memory limits and we are seeing speed-up whenever we ease our memory usage (by removing numbers from the set after we\\'ve seen them; or by omitting the for-loop over nums list, which probably saves us from loading the nums list into cache or memory)"
                    },
                    {
                        "username": "sohussain",
                        "content": "[@bargavkoduri](/bargavkoduri) Thanks! in hindsight it sounds obvious but I never thought of it that way."
                    },
                    {
                        "username": "bargavkoduri",
                        "content": "iterating over set is better than list.In set we find the length from each start point exactly once, in list we find it frequency of start point times. suppose [1,2,3,4,5,6,1,1,1] is the given input in set we find length of longest sequence from 1 exactly once in list we find it 4 times."
                    },
                    {
                        "username": "user1084S",
                        "content": "class Solution {\\n    public int longestConsecutive(int[] nums) {\\n        Arrays.sort(nums); //sorting for getting conintous numbers\\n        if(nums.length==0) \\n         return 0;\\n        int c=1,ans=1;\\n        for(int i=1;i<nums.length;i++){\\n            if(nums[i-1]==nums[i]-1) //checking if diff is 1 then it is cons\\n              c++;\\n            else if(nums[i]==nums[i-1])// for repetition \\n            continue;\\n            else\\n             c=1;  //if diff >1\\n           ans=Math.max(ans,c);\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1849804,
                "content": [
                    {
                        "username": "swapnil019",
                        "content": "class Solution {\\npublic:\\n    int longestConsecutive(vector<int>& nums) {\\n        int cnt = 1;\\n        int maxi = 1;\\n        map<int, int> mp;\\n        for(auto it : nums){\\n            mp[it]++;\\n        }\\n        vector<int> ans;\\n        for(auto it : mp){\\n            ans.push_back(it.first);\\n        }\\n\\n        if(ans.size() < 1){\\n            return 0;\\n        }\\n        //sort(ans.begin(), ans.end());\\n        for(int i = 1; i < ans.size(); ++i)\\n        {\\n            if(ans[i-1]+1 == ans[i]){\\n                cnt++;\\n                maxi = max(cnt, maxi);\\n            }else{\\n                cnt = 1;\\n            }\\n        }\\n\\n        return maxi;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "dewanharsh",
                        "content": "I tried with 2 approaches, both successful \\n1. Using Priority Queue. Time Complexity O(n), \\n    Space Complexity O(n)\\n\\n2. First sorting the array and then traversing it. \\n    Time Complexity O(nlogn)."
                    },
                    {
                        "username": "raiymbek_zhumatov",
                        "content": "Is it possible to sovle this problem with bfs? I\\'ve tried, but things that work in my compiler simply does not work on lc"
                    },
                    {
                        "username": "miha4406",
                        "content": "Is it legal to sort it beforehand?"
                    },
                    {
                        "username": "tamtam484-new",
                        "content": "Because of problem limitation, only algorithm with O(n) should be accepted, but it seems that testcase is too short to evaluate that. \\nAnd in python3, sorting algorithm is even firster than correct algorithm!"
                    },
                    {
                        "username": "NIKHIL9119",
                        "content": "The question is itself unclear.\\nFor the test case [0,0] correct answer is 1\\nwhile for test case [1,2,0,1] it is 3."
                    },
                    {
                        "username": "Vithesh",
                        "content": "its correct\\nfirst test case answer is [0] and next one is [0,1,2] so answer is 1 and 3."
                    },
                    {
                        "username": "JSorngard",
                        "content": "If you use radix sort you can do O(n) with sorting ;)"
                    },
                    {
                        "username": "kamranmemon25",
                        "content": "[9,1,4,7,3,-1,0,5,8,-1,6]\\nHow is the output for this nums expected 7 ( there is no 2 in the array) it should be 3) -- > [-1,0,1]"
                    },
                    {
                        "username": "ash030",
                        "content": "since largest has to be returned, answer will be 7 - > 3, 4, 5, 6, 7, 8, 9 "
                    },
                    {
                        "username": "sohussain",
                        "content": "Why does iterating over a set result in a much faster runtime compared to iterating over a list?\\nThis is confusing because iterating over a list should be faster.\\nlist\\n![image](https://user-images.githubusercontent.com/1150371/218372757-dfcff8f8-935f-45ee-a67b-e6bb99f1ac77.png)\\nset\\n![image](https://user-images.githubusercontent.com/1150371/218372794-db2dc92e-c900-45bb-9ce2-75c0dc7dddae.png)\\nruntime\\n![runtime](https://user-images.githubusercontent.com/1150371/218372173-f87210f0-2349-4ce0-9174-05be20361583.png)"
                    },
                    {
                        "username": "dkmar",
                        "content": "It\\'s more than what bargavkoduri said. You can speed up the solutions iterating over the list by similar margins. Try adding a `s.remove(n)` in your streak-counting while loop. We should not be seeing this level of speed-up.\\n\\nI think leetcode has imposed memory limits and we are seeing speed-up whenever we ease our memory usage (by removing numbers from the set after we\\'ve seen them; or by omitting the for-loop over nums list, which probably saves us from loading the nums list into cache or memory)"
                    },
                    {
                        "username": "sohussain",
                        "content": "[@bargavkoduri](/bargavkoduri) Thanks! in hindsight it sounds obvious but I never thought of it that way."
                    },
                    {
                        "username": "bargavkoduri",
                        "content": "iterating over set is better than list.In set we find the length from each start point exactly once, in list we find it frequency of start point times. suppose [1,2,3,4,5,6,1,1,1] is the given input in set we find length of longest sequence from 1 exactly once in list we find it 4 times."
                    },
                    {
                        "username": "user1084S",
                        "content": "class Solution {\\n    public int longestConsecutive(int[] nums) {\\n        Arrays.sort(nums); //sorting for getting conintous numbers\\n        if(nums.length==0) \\n         return 0;\\n        int c=1,ans=1;\\n        for(int i=1;i<nums.length;i++){\\n            if(nums[i-1]==nums[i]-1) //checking if diff is 1 then it is cons\\n              c++;\\n            else if(nums[i]==nums[i-1])// for repetition \\n            continue;\\n            else\\n             c=1;  //if diff >1\\n           ans=Math.max(ans,c);\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1813188,
                "content": [
                    {
                        "username": "swapnil019",
                        "content": "class Solution {\\npublic:\\n    int longestConsecutive(vector<int>& nums) {\\n        int cnt = 1;\\n        int maxi = 1;\\n        map<int, int> mp;\\n        for(auto it : nums){\\n            mp[it]++;\\n        }\\n        vector<int> ans;\\n        for(auto it : mp){\\n            ans.push_back(it.first);\\n        }\\n\\n        if(ans.size() < 1){\\n            return 0;\\n        }\\n        //sort(ans.begin(), ans.end());\\n        for(int i = 1; i < ans.size(); ++i)\\n        {\\n            if(ans[i-1]+1 == ans[i]){\\n                cnt++;\\n                maxi = max(cnt, maxi);\\n            }else{\\n                cnt = 1;\\n            }\\n        }\\n\\n        return maxi;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "dewanharsh",
                        "content": "I tried with 2 approaches, both successful \\n1. Using Priority Queue. Time Complexity O(n), \\n    Space Complexity O(n)\\n\\n2. First sorting the array and then traversing it. \\n    Time Complexity O(nlogn)."
                    },
                    {
                        "username": "raiymbek_zhumatov",
                        "content": "Is it possible to sovle this problem with bfs? I\\'ve tried, but things that work in my compiler simply does not work on lc"
                    },
                    {
                        "username": "miha4406",
                        "content": "Is it legal to sort it beforehand?"
                    },
                    {
                        "username": "tamtam484-new",
                        "content": "Because of problem limitation, only algorithm with O(n) should be accepted, but it seems that testcase is too short to evaluate that. \\nAnd in python3, sorting algorithm is even firster than correct algorithm!"
                    },
                    {
                        "username": "NIKHIL9119",
                        "content": "The question is itself unclear.\\nFor the test case [0,0] correct answer is 1\\nwhile for test case [1,2,0,1] it is 3."
                    },
                    {
                        "username": "Vithesh",
                        "content": "its correct\\nfirst test case answer is [0] and next one is [0,1,2] so answer is 1 and 3."
                    },
                    {
                        "username": "JSorngard",
                        "content": "If you use radix sort you can do O(n) with sorting ;)"
                    },
                    {
                        "username": "kamranmemon25",
                        "content": "[9,1,4,7,3,-1,0,5,8,-1,6]\\nHow is the output for this nums expected 7 ( there is no 2 in the array) it should be 3) -- > [-1,0,1]"
                    },
                    {
                        "username": "ash030",
                        "content": "since largest has to be returned, answer will be 7 - > 3, 4, 5, 6, 7, 8, 9 "
                    },
                    {
                        "username": "sohussain",
                        "content": "Why does iterating over a set result in a much faster runtime compared to iterating over a list?\\nThis is confusing because iterating over a list should be faster.\\nlist\\n![image](https://user-images.githubusercontent.com/1150371/218372757-dfcff8f8-935f-45ee-a67b-e6bb99f1ac77.png)\\nset\\n![image](https://user-images.githubusercontent.com/1150371/218372794-db2dc92e-c900-45bb-9ce2-75c0dc7dddae.png)\\nruntime\\n![runtime](https://user-images.githubusercontent.com/1150371/218372173-f87210f0-2349-4ce0-9174-05be20361583.png)"
                    },
                    {
                        "username": "dkmar",
                        "content": "It\\'s more than what bargavkoduri said. You can speed up the solutions iterating over the list by similar margins. Try adding a `s.remove(n)` in your streak-counting while loop. We should not be seeing this level of speed-up.\\n\\nI think leetcode has imposed memory limits and we are seeing speed-up whenever we ease our memory usage (by removing numbers from the set after we\\'ve seen them; or by omitting the for-loop over nums list, which probably saves us from loading the nums list into cache or memory)"
                    },
                    {
                        "username": "sohussain",
                        "content": "[@bargavkoduri](/bargavkoduri) Thanks! in hindsight it sounds obvious but I never thought of it that way."
                    },
                    {
                        "username": "bargavkoduri",
                        "content": "iterating over set is better than list.In set we find the length from each start point exactly once, in list we find it frequency of start point times. suppose [1,2,3,4,5,6,1,1,1] is the given input in set we find length of longest sequence from 1 exactly once in list we find it 4 times."
                    },
                    {
                        "username": "user1084S",
                        "content": "class Solution {\\n    public int longestConsecutive(int[] nums) {\\n        Arrays.sort(nums); //sorting for getting conintous numbers\\n        if(nums.length==0) \\n         return 0;\\n        int c=1,ans=1;\\n        for(int i=1;i<nums.length;i++){\\n            if(nums[i-1]==nums[i]-1) //checking if diff is 1 then it is cons\\n              c++;\\n            else if(nums[i]==nums[i-1])// for repetition \\n            continue;\\n            else\\n             c=1;  //if diff >1\\n           ans=Math.max(ans,c);\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1805884,
                "content": [
                    {
                        "username": "swapnil019",
                        "content": "class Solution {\\npublic:\\n    int longestConsecutive(vector<int>& nums) {\\n        int cnt = 1;\\n        int maxi = 1;\\n        map<int, int> mp;\\n        for(auto it : nums){\\n            mp[it]++;\\n        }\\n        vector<int> ans;\\n        for(auto it : mp){\\n            ans.push_back(it.first);\\n        }\\n\\n        if(ans.size() < 1){\\n            return 0;\\n        }\\n        //sort(ans.begin(), ans.end());\\n        for(int i = 1; i < ans.size(); ++i)\\n        {\\n            if(ans[i-1]+1 == ans[i]){\\n                cnt++;\\n                maxi = max(cnt, maxi);\\n            }else{\\n                cnt = 1;\\n            }\\n        }\\n\\n        return maxi;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "dewanharsh",
                        "content": "I tried with 2 approaches, both successful \\n1. Using Priority Queue. Time Complexity O(n), \\n    Space Complexity O(n)\\n\\n2. First sorting the array and then traversing it. \\n    Time Complexity O(nlogn)."
                    },
                    {
                        "username": "raiymbek_zhumatov",
                        "content": "Is it possible to sovle this problem with bfs? I\\'ve tried, but things that work in my compiler simply does not work on lc"
                    },
                    {
                        "username": "miha4406",
                        "content": "Is it legal to sort it beforehand?"
                    },
                    {
                        "username": "tamtam484-new",
                        "content": "Because of problem limitation, only algorithm with O(n) should be accepted, but it seems that testcase is too short to evaluate that. \\nAnd in python3, sorting algorithm is even firster than correct algorithm!"
                    },
                    {
                        "username": "NIKHIL9119",
                        "content": "The question is itself unclear.\\nFor the test case [0,0] correct answer is 1\\nwhile for test case [1,2,0,1] it is 3."
                    },
                    {
                        "username": "Vithesh",
                        "content": "its correct\\nfirst test case answer is [0] and next one is [0,1,2] so answer is 1 and 3."
                    },
                    {
                        "username": "JSorngard",
                        "content": "If you use radix sort you can do O(n) with sorting ;)"
                    },
                    {
                        "username": "kamranmemon25",
                        "content": "[9,1,4,7,3,-1,0,5,8,-1,6]\\nHow is the output for this nums expected 7 ( there is no 2 in the array) it should be 3) -- > [-1,0,1]"
                    },
                    {
                        "username": "ash030",
                        "content": "since largest has to be returned, answer will be 7 - > 3, 4, 5, 6, 7, 8, 9 "
                    },
                    {
                        "username": "sohussain",
                        "content": "Why does iterating over a set result in a much faster runtime compared to iterating over a list?\\nThis is confusing because iterating over a list should be faster.\\nlist\\n![image](https://user-images.githubusercontent.com/1150371/218372757-dfcff8f8-935f-45ee-a67b-e6bb99f1ac77.png)\\nset\\n![image](https://user-images.githubusercontent.com/1150371/218372794-db2dc92e-c900-45bb-9ce2-75c0dc7dddae.png)\\nruntime\\n![runtime](https://user-images.githubusercontent.com/1150371/218372173-f87210f0-2349-4ce0-9174-05be20361583.png)"
                    },
                    {
                        "username": "dkmar",
                        "content": "It\\'s more than what bargavkoduri said. You can speed up the solutions iterating over the list by similar margins. Try adding a `s.remove(n)` in your streak-counting while loop. We should not be seeing this level of speed-up.\\n\\nI think leetcode has imposed memory limits and we are seeing speed-up whenever we ease our memory usage (by removing numbers from the set after we\\'ve seen them; or by omitting the for-loop over nums list, which probably saves us from loading the nums list into cache or memory)"
                    },
                    {
                        "username": "sohussain",
                        "content": "[@bargavkoduri](/bargavkoduri) Thanks! in hindsight it sounds obvious but I never thought of it that way."
                    },
                    {
                        "username": "bargavkoduri",
                        "content": "iterating over set is better than list.In set we find the length from each start point exactly once, in list we find it frequency of start point times. suppose [1,2,3,4,5,6,1,1,1] is the given input in set we find length of longest sequence from 1 exactly once in list we find it 4 times."
                    },
                    {
                        "username": "user1084S",
                        "content": "class Solution {\\n    public int longestConsecutive(int[] nums) {\\n        Arrays.sort(nums); //sorting for getting conintous numbers\\n        if(nums.length==0) \\n         return 0;\\n        int c=1,ans=1;\\n        for(int i=1;i<nums.length;i++){\\n            if(nums[i-1]==nums[i]-1) //checking if diff is 1 then it is cons\\n              c++;\\n            else if(nums[i]==nums[i-1])// for repetition \\n            continue;\\n            else\\n             c=1;  //if diff >1\\n           ans=Math.max(ans,c);\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1799099,
                "content": [
                    {
                        "username": "swapnil019",
                        "content": "class Solution {\\npublic:\\n    int longestConsecutive(vector<int>& nums) {\\n        int cnt = 1;\\n        int maxi = 1;\\n        map<int, int> mp;\\n        for(auto it : nums){\\n            mp[it]++;\\n        }\\n        vector<int> ans;\\n        for(auto it : mp){\\n            ans.push_back(it.first);\\n        }\\n\\n        if(ans.size() < 1){\\n            return 0;\\n        }\\n        //sort(ans.begin(), ans.end());\\n        for(int i = 1; i < ans.size(); ++i)\\n        {\\n            if(ans[i-1]+1 == ans[i]){\\n                cnt++;\\n                maxi = max(cnt, maxi);\\n            }else{\\n                cnt = 1;\\n            }\\n        }\\n\\n        return maxi;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "dewanharsh",
                        "content": "I tried with 2 approaches, both successful \\n1. Using Priority Queue. Time Complexity O(n), \\n    Space Complexity O(n)\\n\\n2. First sorting the array and then traversing it. \\n    Time Complexity O(nlogn)."
                    },
                    {
                        "username": "raiymbek_zhumatov",
                        "content": "Is it possible to sovle this problem with bfs? I\\'ve tried, but things that work in my compiler simply does not work on lc"
                    },
                    {
                        "username": "miha4406",
                        "content": "Is it legal to sort it beforehand?"
                    },
                    {
                        "username": "tamtam484-new",
                        "content": "Because of problem limitation, only algorithm with O(n) should be accepted, but it seems that testcase is too short to evaluate that. \\nAnd in python3, sorting algorithm is even firster than correct algorithm!"
                    },
                    {
                        "username": "NIKHIL9119",
                        "content": "The question is itself unclear.\\nFor the test case [0,0] correct answer is 1\\nwhile for test case [1,2,0,1] it is 3."
                    },
                    {
                        "username": "Vithesh",
                        "content": "its correct\\nfirst test case answer is [0] and next one is [0,1,2] so answer is 1 and 3."
                    },
                    {
                        "username": "JSorngard",
                        "content": "If you use radix sort you can do O(n) with sorting ;)"
                    },
                    {
                        "username": "kamranmemon25",
                        "content": "[9,1,4,7,3,-1,0,5,8,-1,6]\\nHow is the output for this nums expected 7 ( there is no 2 in the array) it should be 3) -- > [-1,0,1]"
                    },
                    {
                        "username": "ash030",
                        "content": "since largest has to be returned, answer will be 7 - > 3, 4, 5, 6, 7, 8, 9 "
                    },
                    {
                        "username": "sohussain",
                        "content": "Why does iterating over a set result in a much faster runtime compared to iterating over a list?\\nThis is confusing because iterating over a list should be faster.\\nlist\\n![image](https://user-images.githubusercontent.com/1150371/218372757-dfcff8f8-935f-45ee-a67b-e6bb99f1ac77.png)\\nset\\n![image](https://user-images.githubusercontent.com/1150371/218372794-db2dc92e-c900-45bb-9ce2-75c0dc7dddae.png)\\nruntime\\n![runtime](https://user-images.githubusercontent.com/1150371/218372173-f87210f0-2349-4ce0-9174-05be20361583.png)"
                    },
                    {
                        "username": "dkmar",
                        "content": "It\\'s more than what bargavkoduri said. You can speed up the solutions iterating over the list by similar margins. Try adding a `s.remove(n)` in your streak-counting while loop. We should not be seeing this level of speed-up.\\n\\nI think leetcode has imposed memory limits and we are seeing speed-up whenever we ease our memory usage (by removing numbers from the set after we\\'ve seen them; or by omitting the for-loop over nums list, which probably saves us from loading the nums list into cache or memory)"
                    },
                    {
                        "username": "sohussain",
                        "content": "[@bargavkoduri](/bargavkoduri) Thanks! in hindsight it sounds obvious but I never thought of it that way."
                    },
                    {
                        "username": "bargavkoduri",
                        "content": "iterating over set is better than list.In set we find the length from each start point exactly once, in list we find it frequency of start point times. suppose [1,2,3,4,5,6,1,1,1] is the given input in set we find length of longest sequence from 1 exactly once in list we find it 4 times."
                    },
                    {
                        "username": "user1084S",
                        "content": "class Solution {\\n    public int longestConsecutive(int[] nums) {\\n        Arrays.sort(nums); //sorting for getting conintous numbers\\n        if(nums.length==0) \\n         return 0;\\n        int c=1,ans=1;\\n        for(int i=1;i<nums.length;i++){\\n            if(nums[i-1]==nums[i]-1) //checking if diff is 1 then it is cons\\n              c++;\\n            else if(nums[i]==nums[i-1])// for repetition \\n            continue;\\n            else\\n             c=1;  //if diff >1\\n           ans=Math.max(ans,c);\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1799021,
                "content": [
                    {
                        "username": "swapnil019",
                        "content": "class Solution {\\npublic:\\n    int longestConsecutive(vector<int>& nums) {\\n        int cnt = 1;\\n        int maxi = 1;\\n        map<int, int> mp;\\n        for(auto it : nums){\\n            mp[it]++;\\n        }\\n        vector<int> ans;\\n        for(auto it : mp){\\n            ans.push_back(it.first);\\n        }\\n\\n        if(ans.size() < 1){\\n            return 0;\\n        }\\n        //sort(ans.begin(), ans.end());\\n        for(int i = 1; i < ans.size(); ++i)\\n        {\\n            if(ans[i-1]+1 == ans[i]){\\n                cnt++;\\n                maxi = max(cnt, maxi);\\n            }else{\\n                cnt = 1;\\n            }\\n        }\\n\\n        return maxi;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "dewanharsh",
                        "content": "I tried with 2 approaches, both successful \\n1. Using Priority Queue. Time Complexity O(n), \\n    Space Complexity O(n)\\n\\n2. First sorting the array and then traversing it. \\n    Time Complexity O(nlogn)."
                    },
                    {
                        "username": "raiymbek_zhumatov",
                        "content": "Is it possible to sovle this problem with bfs? I\\'ve tried, but things that work in my compiler simply does not work on lc"
                    },
                    {
                        "username": "miha4406",
                        "content": "Is it legal to sort it beforehand?"
                    },
                    {
                        "username": "tamtam484-new",
                        "content": "Because of problem limitation, only algorithm with O(n) should be accepted, but it seems that testcase is too short to evaluate that. \\nAnd in python3, sorting algorithm is even firster than correct algorithm!"
                    },
                    {
                        "username": "NIKHIL9119",
                        "content": "The question is itself unclear.\\nFor the test case [0,0] correct answer is 1\\nwhile for test case [1,2,0,1] it is 3."
                    },
                    {
                        "username": "Vithesh",
                        "content": "its correct\\nfirst test case answer is [0] and next one is [0,1,2] so answer is 1 and 3."
                    },
                    {
                        "username": "JSorngard",
                        "content": "If you use radix sort you can do O(n) with sorting ;)"
                    },
                    {
                        "username": "kamranmemon25",
                        "content": "[9,1,4,7,3,-1,0,5,8,-1,6]\\nHow is the output for this nums expected 7 ( there is no 2 in the array) it should be 3) -- > [-1,0,1]"
                    },
                    {
                        "username": "ash030",
                        "content": "since largest has to be returned, answer will be 7 - > 3, 4, 5, 6, 7, 8, 9 "
                    },
                    {
                        "username": "sohussain",
                        "content": "Why does iterating over a set result in a much faster runtime compared to iterating over a list?\\nThis is confusing because iterating over a list should be faster.\\nlist\\n![image](https://user-images.githubusercontent.com/1150371/218372757-dfcff8f8-935f-45ee-a67b-e6bb99f1ac77.png)\\nset\\n![image](https://user-images.githubusercontent.com/1150371/218372794-db2dc92e-c900-45bb-9ce2-75c0dc7dddae.png)\\nruntime\\n![runtime](https://user-images.githubusercontent.com/1150371/218372173-f87210f0-2349-4ce0-9174-05be20361583.png)"
                    },
                    {
                        "username": "dkmar",
                        "content": "It\\'s more than what bargavkoduri said. You can speed up the solutions iterating over the list by similar margins. Try adding a `s.remove(n)` in your streak-counting while loop. We should not be seeing this level of speed-up.\\n\\nI think leetcode has imposed memory limits and we are seeing speed-up whenever we ease our memory usage (by removing numbers from the set after we\\'ve seen them; or by omitting the for-loop over nums list, which probably saves us from loading the nums list into cache or memory)"
                    },
                    {
                        "username": "sohussain",
                        "content": "[@bargavkoduri](/bargavkoduri) Thanks! in hindsight it sounds obvious but I never thought of it that way."
                    },
                    {
                        "username": "bargavkoduri",
                        "content": "iterating over set is better than list.In set we find the length from each start point exactly once, in list we find it frequency of start point times. suppose [1,2,3,4,5,6,1,1,1] is the given input in set we find length of longest sequence from 1 exactly once in list we find it 4 times."
                    },
                    {
                        "username": "user1084S",
                        "content": "class Solution {\\n    public int longestConsecutive(int[] nums) {\\n        Arrays.sort(nums); //sorting for getting conintous numbers\\n        if(nums.length==0) \\n         return 0;\\n        int c=1,ans=1;\\n        for(int i=1;i<nums.length;i++){\\n            if(nums[i-1]==nums[i]-1) //checking if diff is 1 then it is cons\\n              c++;\\n            else if(nums[i]==nums[i-1])// for repetition \\n            continue;\\n            else\\n             c=1;  //if diff >1\\n           ans=Math.max(ans,c);\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1798482,
                "content": [
                    {
                        "username": "swapnil019",
                        "content": "class Solution {\\npublic:\\n    int longestConsecutive(vector<int>& nums) {\\n        int cnt = 1;\\n        int maxi = 1;\\n        map<int, int> mp;\\n        for(auto it : nums){\\n            mp[it]++;\\n        }\\n        vector<int> ans;\\n        for(auto it : mp){\\n            ans.push_back(it.first);\\n        }\\n\\n        if(ans.size() < 1){\\n            return 0;\\n        }\\n        //sort(ans.begin(), ans.end());\\n        for(int i = 1; i < ans.size(); ++i)\\n        {\\n            if(ans[i-1]+1 == ans[i]){\\n                cnt++;\\n                maxi = max(cnt, maxi);\\n            }else{\\n                cnt = 1;\\n            }\\n        }\\n\\n        return maxi;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "dewanharsh",
                        "content": "I tried with 2 approaches, both successful \\n1. Using Priority Queue. Time Complexity O(n), \\n    Space Complexity O(n)\\n\\n2. First sorting the array and then traversing it. \\n    Time Complexity O(nlogn)."
                    },
                    {
                        "username": "raiymbek_zhumatov",
                        "content": "Is it possible to sovle this problem with bfs? I\\'ve tried, but things that work in my compiler simply does not work on lc"
                    },
                    {
                        "username": "miha4406",
                        "content": "Is it legal to sort it beforehand?"
                    },
                    {
                        "username": "tamtam484-new",
                        "content": "Because of problem limitation, only algorithm with O(n) should be accepted, but it seems that testcase is too short to evaluate that. \\nAnd in python3, sorting algorithm is even firster than correct algorithm!"
                    },
                    {
                        "username": "NIKHIL9119",
                        "content": "The question is itself unclear.\\nFor the test case [0,0] correct answer is 1\\nwhile for test case [1,2,0,1] it is 3."
                    },
                    {
                        "username": "Vithesh",
                        "content": "its correct\\nfirst test case answer is [0] and next one is [0,1,2] so answer is 1 and 3."
                    },
                    {
                        "username": "JSorngard",
                        "content": "If you use radix sort you can do O(n) with sorting ;)"
                    },
                    {
                        "username": "kamranmemon25",
                        "content": "[9,1,4,7,3,-1,0,5,8,-1,6]\\nHow is the output for this nums expected 7 ( there is no 2 in the array) it should be 3) -- > [-1,0,1]"
                    },
                    {
                        "username": "ash030",
                        "content": "since largest has to be returned, answer will be 7 - > 3, 4, 5, 6, 7, 8, 9 "
                    },
                    {
                        "username": "sohussain",
                        "content": "Why does iterating over a set result in a much faster runtime compared to iterating over a list?\\nThis is confusing because iterating over a list should be faster.\\nlist\\n![image](https://user-images.githubusercontent.com/1150371/218372757-dfcff8f8-935f-45ee-a67b-e6bb99f1ac77.png)\\nset\\n![image](https://user-images.githubusercontent.com/1150371/218372794-db2dc92e-c900-45bb-9ce2-75c0dc7dddae.png)\\nruntime\\n![runtime](https://user-images.githubusercontent.com/1150371/218372173-f87210f0-2349-4ce0-9174-05be20361583.png)"
                    },
                    {
                        "username": "dkmar",
                        "content": "It\\'s more than what bargavkoduri said. You can speed up the solutions iterating over the list by similar margins. Try adding a `s.remove(n)` in your streak-counting while loop. We should not be seeing this level of speed-up.\\n\\nI think leetcode has imposed memory limits and we are seeing speed-up whenever we ease our memory usage (by removing numbers from the set after we\\'ve seen them; or by omitting the for-loop over nums list, which probably saves us from loading the nums list into cache or memory)"
                    },
                    {
                        "username": "sohussain",
                        "content": "[@bargavkoduri](/bargavkoduri) Thanks! in hindsight it sounds obvious but I never thought of it that way."
                    },
                    {
                        "username": "bargavkoduri",
                        "content": "iterating over set is better than list.In set we find the length from each start point exactly once, in list we find it frequency of start point times. suppose [1,2,3,4,5,6,1,1,1] is the given input in set we find length of longest sequence from 1 exactly once in list we find it 4 times."
                    },
                    {
                        "username": "user1084S",
                        "content": "class Solution {\\n    public int longestConsecutive(int[] nums) {\\n        Arrays.sort(nums); //sorting for getting conintous numbers\\n        if(nums.length==0) \\n         return 0;\\n        int c=1,ans=1;\\n        for(int i=1;i<nums.length;i++){\\n            if(nums[i-1]==nums[i]-1) //checking if diff is 1 then it is cons\\n              c++;\\n            else if(nums[i]==nums[i-1])// for repetition \\n            continue;\\n            else\\n             c=1;  //if diff >1\\n           ans=Math.max(ans,c);\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1793370,
                "content": [
                    {
                        "username": "girishbhargava9202",
                        "content": "How to think of this question in terms of union find algorithm?"
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "jab mene ye question gfg pr dekha tb smj aaya ki ye task hai "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "anonrahman120",
                        "content": "For my algorithm I used Arrays.sort(nums), but in a real interview, would they expect you to implement a sorting algorithm like quicksort instead of using the generic Arrays.sort?"
                    },
                    {
                        "username": "j8ahmed",
                        "content": "Is anyone else having an issue running a working solution in JavaScript. My exact same solution works in Python but when I tried it in JavaScript it did not work."
                    },
                    {
                        "username": "mfayala",
                        "content": "i have a time limit exceeded in the last testcase where nums = null I assume evevn though I\\'m checking in the beginning of my method with if(nums.empty()) return 0; what can my error be?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/nA5TRClw96I"
                    },
                    {
                        "username": "nachiket-s",
                        "content": "Is it just me or the time limit is tooshort for testcase 69 for python3 ? The code I wrote uses dictionary and doesnt look inefficient at all. It is not perfectly O(n), though. I have no idea how to make it faster"
                    },
                    {
                        "username": "shiwanshu342",
                        "content": "my solution is giving tle after 65 testcases. how can i optimise it?\\nclass Solution {\\npublic:\\n    int longestConsecutive(vector<int>& nums) {\\n        if(nums.size()==0 || nums.size()==1)\\n        return nums.size();\\n        set<int> st;\\n        int cnt=0,ans=0;\\n        for (auto it: nums){\\n            st.insert(it);\\n        }\\n        vector<int>arr;\\n        for(auto it:st){\\n            arr.push_back(it);\\n        }\\n           \\n        for(int i=0;i<st.size();i++){\\n            cnt=0;\\n            if(st.find(arr[i])!=st.end()){\\n                cnt=1;\\n                if(st.find(arr[i]+1)!=st.end()){\\n                cnt=1;\\n                while(st.find(arr[i]+1)!=st.end()){\\n                    cnt++;\\n                     ans =max(cnt,ans);\\n                    arr[i]=arr[i]+1;\\n                }\\n                }\\n                //else{continue;}\\n            }\\n            ans =max(cnt,ans);\\n        }\\n        return ans;\\n\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1775340,
                "content": [
                    {
                        "username": "girishbhargava9202",
                        "content": "How to think of this question in terms of union find algorithm?"
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "jab mene ye question gfg pr dekha tb smj aaya ki ye task hai "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "anonrahman120",
                        "content": "For my algorithm I used Arrays.sort(nums), but in a real interview, would they expect you to implement a sorting algorithm like quicksort instead of using the generic Arrays.sort?"
                    },
                    {
                        "username": "j8ahmed",
                        "content": "Is anyone else having an issue running a working solution in JavaScript. My exact same solution works in Python but when I tried it in JavaScript it did not work."
                    },
                    {
                        "username": "mfayala",
                        "content": "i have a time limit exceeded in the last testcase where nums = null I assume evevn though I\\'m checking in the beginning of my method with if(nums.empty()) return 0; what can my error be?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/nA5TRClw96I"
                    },
                    {
                        "username": "nachiket-s",
                        "content": "Is it just me or the time limit is tooshort for testcase 69 for python3 ? The code I wrote uses dictionary and doesnt look inefficient at all. It is not perfectly O(n), though. I have no idea how to make it faster"
                    },
                    {
                        "username": "shiwanshu342",
                        "content": "my solution is giving tle after 65 testcases. how can i optimise it?\\nclass Solution {\\npublic:\\n    int longestConsecutive(vector<int>& nums) {\\n        if(nums.size()==0 || nums.size()==1)\\n        return nums.size();\\n        set<int> st;\\n        int cnt=0,ans=0;\\n        for (auto it: nums){\\n            st.insert(it);\\n        }\\n        vector<int>arr;\\n        for(auto it:st){\\n            arr.push_back(it);\\n        }\\n           \\n        for(int i=0;i<st.size();i++){\\n            cnt=0;\\n            if(st.find(arr[i])!=st.end()){\\n                cnt=1;\\n                if(st.find(arr[i]+1)!=st.end()){\\n                cnt=1;\\n                while(st.find(arr[i]+1)!=st.end()){\\n                    cnt++;\\n                     ans =max(cnt,ans);\\n                    arr[i]=arr[i]+1;\\n                }\\n                }\\n                //else{continue;}\\n            }\\n            ans =max(cnt,ans);\\n        }\\n        return ans;\\n\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1768462,
                "content": [
                    {
                        "username": "girishbhargava9202",
                        "content": "How to think of this question in terms of union find algorithm?"
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "jab mene ye question gfg pr dekha tb smj aaya ki ye task hai "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "anonrahman120",
                        "content": "For my algorithm I used Arrays.sort(nums), but in a real interview, would they expect you to implement a sorting algorithm like quicksort instead of using the generic Arrays.sort?"
                    },
                    {
                        "username": "j8ahmed",
                        "content": "Is anyone else having an issue running a working solution in JavaScript. My exact same solution works in Python but when I tried it in JavaScript it did not work."
                    },
                    {
                        "username": "mfayala",
                        "content": "i have a time limit exceeded in the last testcase where nums = null I assume evevn though I\\'m checking in the beginning of my method with if(nums.empty()) return 0; what can my error be?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/nA5TRClw96I"
                    },
                    {
                        "username": "nachiket-s",
                        "content": "Is it just me or the time limit is tooshort for testcase 69 for python3 ? The code I wrote uses dictionary and doesnt look inefficient at all. It is not perfectly O(n), though. I have no idea how to make it faster"
                    },
                    {
                        "username": "shiwanshu342",
                        "content": "my solution is giving tle after 65 testcases. how can i optimise it?\\nclass Solution {\\npublic:\\n    int longestConsecutive(vector<int>& nums) {\\n        if(nums.size()==0 || nums.size()==1)\\n        return nums.size();\\n        set<int> st;\\n        int cnt=0,ans=0;\\n        for (auto it: nums){\\n            st.insert(it);\\n        }\\n        vector<int>arr;\\n        for(auto it:st){\\n            arr.push_back(it);\\n        }\\n           \\n        for(int i=0;i<st.size();i++){\\n            cnt=0;\\n            if(st.find(arr[i])!=st.end()){\\n                cnt=1;\\n                if(st.find(arr[i]+1)!=st.end()){\\n                cnt=1;\\n                while(st.find(arr[i]+1)!=st.end()){\\n                    cnt++;\\n                     ans =max(cnt,ans);\\n                    arr[i]=arr[i]+1;\\n                }\\n                }\\n                //else{continue;}\\n            }\\n            ans =max(cnt,ans);\\n        }\\n        return ans;\\n\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1756348,
                "content": [
                    {
                        "username": "girishbhargava9202",
                        "content": "How to think of this question in terms of union find algorithm?"
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "jab mene ye question gfg pr dekha tb smj aaya ki ye task hai "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "anonrahman120",
                        "content": "For my algorithm I used Arrays.sort(nums), but in a real interview, would they expect you to implement a sorting algorithm like quicksort instead of using the generic Arrays.sort?"
                    },
                    {
                        "username": "j8ahmed",
                        "content": "Is anyone else having an issue running a working solution in JavaScript. My exact same solution works in Python but when I tried it in JavaScript it did not work."
                    },
                    {
                        "username": "mfayala",
                        "content": "i have a time limit exceeded in the last testcase where nums = null I assume evevn though I\\'m checking in the beginning of my method with if(nums.empty()) return 0; what can my error be?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/nA5TRClw96I"
                    },
                    {
                        "username": "nachiket-s",
                        "content": "Is it just me or the time limit is tooshort for testcase 69 for python3 ? The code I wrote uses dictionary and doesnt look inefficient at all. It is not perfectly O(n), though. I have no idea how to make it faster"
                    },
                    {
                        "username": "shiwanshu342",
                        "content": "my solution is giving tle after 65 testcases. how can i optimise it?\\nclass Solution {\\npublic:\\n    int longestConsecutive(vector<int>& nums) {\\n        if(nums.size()==0 || nums.size()==1)\\n        return nums.size();\\n        set<int> st;\\n        int cnt=0,ans=0;\\n        for (auto it: nums){\\n            st.insert(it);\\n        }\\n        vector<int>arr;\\n        for(auto it:st){\\n            arr.push_back(it);\\n        }\\n           \\n        for(int i=0;i<st.size();i++){\\n            cnt=0;\\n            if(st.find(arr[i])!=st.end()){\\n                cnt=1;\\n                if(st.find(arr[i]+1)!=st.end()){\\n                cnt=1;\\n                while(st.find(arr[i]+1)!=st.end()){\\n                    cnt++;\\n                     ans =max(cnt,ans);\\n                    arr[i]=arr[i]+1;\\n                }\\n                }\\n                //else{continue;}\\n            }\\n            ans =max(cnt,ans);\\n        }\\n        return ans;\\n\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1750445,
                "content": [
                    {
                        "username": "girishbhargava9202",
                        "content": "How to think of this question in terms of union find algorithm?"
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "jab mene ye question gfg pr dekha tb smj aaya ki ye task hai "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "anonrahman120",
                        "content": "For my algorithm I used Arrays.sort(nums), but in a real interview, would they expect you to implement a sorting algorithm like quicksort instead of using the generic Arrays.sort?"
                    },
                    {
                        "username": "j8ahmed",
                        "content": "Is anyone else having an issue running a working solution in JavaScript. My exact same solution works in Python but when I tried it in JavaScript it did not work."
                    },
                    {
                        "username": "mfayala",
                        "content": "i have a time limit exceeded in the last testcase where nums = null I assume evevn though I\\'m checking in the beginning of my method with if(nums.empty()) return 0; what can my error be?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/nA5TRClw96I"
                    },
                    {
                        "username": "nachiket-s",
                        "content": "Is it just me or the time limit is tooshort for testcase 69 for python3 ? The code I wrote uses dictionary and doesnt look inefficient at all. It is not perfectly O(n), though. I have no idea how to make it faster"
                    },
                    {
                        "username": "shiwanshu342",
                        "content": "my solution is giving tle after 65 testcases. how can i optimise it?\\nclass Solution {\\npublic:\\n    int longestConsecutive(vector<int>& nums) {\\n        if(nums.size()==0 || nums.size()==1)\\n        return nums.size();\\n        set<int> st;\\n        int cnt=0,ans=0;\\n        for (auto it: nums){\\n            st.insert(it);\\n        }\\n        vector<int>arr;\\n        for(auto it:st){\\n            arr.push_back(it);\\n        }\\n           \\n        for(int i=0;i<st.size();i++){\\n            cnt=0;\\n            if(st.find(arr[i])!=st.end()){\\n                cnt=1;\\n                if(st.find(arr[i]+1)!=st.end()){\\n                cnt=1;\\n                while(st.find(arr[i]+1)!=st.end()){\\n                    cnt++;\\n                     ans =max(cnt,ans);\\n                    arr[i]=arr[i]+1;\\n                }\\n                }\\n                //else{continue;}\\n            }\\n            ans =max(cnt,ans);\\n        }\\n        return ans;\\n\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1743416,
                "content": [
                    {
                        "username": "girishbhargava9202",
                        "content": "How to think of this question in terms of union find algorithm?"
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "jab mene ye question gfg pr dekha tb smj aaya ki ye task hai "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "anonrahman120",
                        "content": "For my algorithm I used Arrays.sort(nums), but in a real interview, would they expect you to implement a sorting algorithm like quicksort instead of using the generic Arrays.sort?"
                    },
                    {
                        "username": "j8ahmed",
                        "content": "Is anyone else having an issue running a working solution in JavaScript. My exact same solution works in Python but when I tried it in JavaScript it did not work."
                    },
                    {
                        "username": "mfayala",
                        "content": "i have a time limit exceeded in the last testcase where nums = null I assume evevn though I\\'m checking in the beginning of my method with if(nums.empty()) return 0; what can my error be?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/nA5TRClw96I"
                    },
                    {
                        "username": "nachiket-s",
                        "content": "Is it just me or the time limit is tooshort for testcase 69 for python3 ? The code I wrote uses dictionary and doesnt look inefficient at all. It is not perfectly O(n), though. I have no idea how to make it faster"
                    },
                    {
                        "username": "shiwanshu342",
                        "content": "my solution is giving tle after 65 testcases. how can i optimise it?\\nclass Solution {\\npublic:\\n    int longestConsecutive(vector<int>& nums) {\\n        if(nums.size()==0 || nums.size()==1)\\n        return nums.size();\\n        set<int> st;\\n        int cnt=0,ans=0;\\n        for (auto it: nums){\\n            st.insert(it);\\n        }\\n        vector<int>arr;\\n        for(auto it:st){\\n            arr.push_back(it);\\n        }\\n           \\n        for(int i=0;i<st.size();i++){\\n            cnt=0;\\n            if(st.find(arr[i])!=st.end()){\\n                cnt=1;\\n                if(st.find(arr[i]+1)!=st.end()){\\n                cnt=1;\\n                while(st.find(arr[i]+1)!=st.end()){\\n                    cnt++;\\n                     ans =max(cnt,ans);\\n                    arr[i]=arr[i]+1;\\n                }\\n                }\\n                //else{continue;}\\n            }\\n            ans =max(cnt,ans);\\n        }\\n        return ans;\\n\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1735788,
                "content": [
                    {
                        "username": "girishbhargava9202",
                        "content": "How to think of this question in terms of union find algorithm?"
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "jab mene ye question gfg pr dekha tb smj aaya ki ye task hai "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "anonrahman120",
                        "content": "For my algorithm I used Arrays.sort(nums), but in a real interview, would they expect you to implement a sorting algorithm like quicksort instead of using the generic Arrays.sort?"
                    },
                    {
                        "username": "j8ahmed",
                        "content": "Is anyone else having an issue running a working solution in JavaScript. My exact same solution works in Python but when I tried it in JavaScript it did not work."
                    },
                    {
                        "username": "mfayala",
                        "content": "i have a time limit exceeded in the last testcase where nums = null I assume evevn though I\\'m checking in the beginning of my method with if(nums.empty()) return 0; what can my error be?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/nA5TRClw96I"
                    },
                    {
                        "username": "nachiket-s",
                        "content": "Is it just me or the time limit is tooshort for testcase 69 for python3 ? The code I wrote uses dictionary and doesnt look inefficient at all. It is not perfectly O(n), though. I have no idea how to make it faster"
                    },
                    {
                        "username": "shiwanshu342",
                        "content": "my solution is giving tle after 65 testcases. how can i optimise it?\\nclass Solution {\\npublic:\\n    int longestConsecutive(vector<int>& nums) {\\n        if(nums.size()==0 || nums.size()==1)\\n        return nums.size();\\n        set<int> st;\\n        int cnt=0,ans=0;\\n        for (auto it: nums){\\n            st.insert(it);\\n        }\\n        vector<int>arr;\\n        for(auto it:st){\\n            arr.push_back(it);\\n        }\\n           \\n        for(int i=0;i<st.size();i++){\\n            cnt=0;\\n            if(st.find(arr[i])!=st.end()){\\n                cnt=1;\\n                if(st.find(arr[i]+1)!=st.end()){\\n                cnt=1;\\n                while(st.find(arr[i]+1)!=st.end()){\\n                    cnt++;\\n                     ans =max(cnt,ans);\\n                    arr[i]=arr[i]+1;\\n                }\\n                }\\n                //else{continue;}\\n            }\\n            ans =max(cnt,ans);\\n        }\\n        return ans;\\n\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1723943,
                "content": [
                    {
                        "username": "girishbhargava9202",
                        "content": "How to think of this question in terms of union find algorithm?"
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "jab mene ye question gfg pr dekha tb smj aaya ki ye task hai "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "anonrahman120",
                        "content": "For my algorithm I used Arrays.sort(nums), but in a real interview, would they expect you to implement a sorting algorithm like quicksort instead of using the generic Arrays.sort?"
                    },
                    {
                        "username": "j8ahmed",
                        "content": "Is anyone else having an issue running a working solution in JavaScript. My exact same solution works in Python but when I tried it in JavaScript it did not work."
                    },
                    {
                        "username": "mfayala",
                        "content": "i have a time limit exceeded in the last testcase where nums = null I assume evevn though I\\'m checking in the beginning of my method with if(nums.empty()) return 0; what can my error be?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/nA5TRClw96I"
                    },
                    {
                        "username": "nachiket-s",
                        "content": "Is it just me or the time limit is tooshort for testcase 69 for python3 ? The code I wrote uses dictionary and doesnt look inefficient at all. It is not perfectly O(n), though. I have no idea how to make it faster"
                    },
                    {
                        "username": "shiwanshu342",
                        "content": "my solution is giving tle after 65 testcases. how can i optimise it?\\nclass Solution {\\npublic:\\n    int longestConsecutive(vector<int>& nums) {\\n        if(nums.size()==0 || nums.size()==1)\\n        return nums.size();\\n        set<int> st;\\n        int cnt=0,ans=0;\\n        for (auto it: nums){\\n            st.insert(it);\\n        }\\n        vector<int>arr;\\n        for(auto it:st){\\n            arr.push_back(it);\\n        }\\n           \\n        for(int i=0;i<st.size();i++){\\n            cnt=0;\\n            if(st.find(arr[i])!=st.end()){\\n                cnt=1;\\n                if(st.find(arr[i]+1)!=st.end()){\\n                cnt=1;\\n                while(st.find(arr[i]+1)!=st.end()){\\n                    cnt++;\\n                     ans =max(cnt,ans);\\n                    arr[i]=arr[i]+1;\\n                }\\n                }\\n                //else{continue;}\\n            }\\n            ans =max(cnt,ans);\\n        }\\n        return ans;\\n\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1720932,
                "content": [
                    {
                        "username": "girishbhargava9202",
                        "content": "How to think of this question in terms of union find algorithm?"
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "jab mene ye question gfg pr dekha tb smj aaya ki ye task hai "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "anonrahman120",
                        "content": "For my algorithm I used Arrays.sort(nums), but in a real interview, would they expect you to implement a sorting algorithm like quicksort instead of using the generic Arrays.sort?"
                    },
                    {
                        "username": "j8ahmed",
                        "content": "Is anyone else having an issue running a working solution in JavaScript. My exact same solution works in Python but when I tried it in JavaScript it did not work."
                    },
                    {
                        "username": "mfayala",
                        "content": "i have a time limit exceeded in the last testcase where nums = null I assume evevn though I\\'m checking in the beginning of my method with if(nums.empty()) return 0; what can my error be?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/nA5TRClw96I"
                    },
                    {
                        "username": "nachiket-s",
                        "content": "Is it just me or the time limit is tooshort for testcase 69 for python3 ? The code I wrote uses dictionary and doesnt look inefficient at all. It is not perfectly O(n), though. I have no idea how to make it faster"
                    },
                    {
                        "username": "shiwanshu342",
                        "content": "my solution is giving tle after 65 testcases. how can i optimise it?\\nclass Solution {\\npublic:\\n    int longestConsecutive(vector<int>& nums) {\\n        if(nums.size()==0 || nums.size()==1)\\n        return nums.size();\\n        set<int> st;\\n        int cnt=0,ans=0;\\n        for (auto it: nums){\\n            st.insert(it);\\n        }\\n        vector<int>arr;\\n        for(auto it:st){\\n            arr.push_back(it);\\n        }\\n           \\n        for(int i=0;i<st.size();i++){\\n            cnt=0;\\n            if(st.find(arr[i])!=st.end()){\\n                cnt=1;\\n                if(st.find(arr[i]+1)!=st.end()){\\n                cnt=1;\\n                while(st.find(arr[i]+1)!=st.end()){\\n                    cnt++;\\n                     ans =max(cnt,ans);\\n                    arr[i]=arr[i]+1;\\n                }\\n                }\\n                //else{continue;}\\n            }\\n            ans =max(cnt,ans);\\n        }\\n        return ans;\\n\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1718972,
                "content": [
                    {
                        "username": "girishbhargava9202",
                        "content": "How to think of this question in terms of union find algorithm?"
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "jab mene ye question gfg pr dekha tb smj aaya ki ye task hai "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "anonrahman120",
                        "content": "For my algorithm I used Arrays.sort(nums), but in a real interview, would they expect you to implement a sorting algorithm like quicksort instead of using the generic Arrays.sort?"
                    },
                    {
                        "username": "j8ahmed",
                        "content": "Is anyone else having an issue running a working solution in JavaScript. My exact same solution works in Python but when I tried it in JavaScript it did not work."
                    },
                    {
                        "username": "mfayala",
                        "content": "i have a time limit exceeded in the last testcase where nums = null I assume evevn though I\\'m checking in the beginning of my method with if(nums.empty()) return 0; what can my error be?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/nA5TRClw96I"
                    },
                    {
                        "username": "nachiket-s",
                        "content": "Is it just me or the time limit is tooshort for testcase 69 for python3 ? The code I wrote uses dictionary and doesnt look inefficient at all. It is not perfectly O(n), though. I have no idea how to make it faster"
                    },
                    {
                        "username": "shiwanshu342",
                        "content": "my solution is giving tle after 65 testcases. how can i optimise it?\\nclass Solution {\\npublic:\\n    int longestConsecutive(vector<int>& nums) {\\n        if(nums.size()==0 || nums.size()==1)\\n        return nums.size();\\n        set<int> st;\\n        int cnt=0,ans=0;\\n        for (auto it: nums){\\n            st.insert(it);\\n        }\\n        vector<int>arr;\\n        for(auto it:st){\\n            arr.push_back(it);\\n        }\\n           \\n        for(int i=0;i<st.size();i++){\\n            cnt=0;\\n            if(st.find(arr[i])!=st.end()){\\n                cnt=1;\\n                if(st.find(arr[i]+1)!=st.end()){\\n                cnt=1;\\n                while(st.find(arr[i]+1)!=st.end()){\\n                    cnt++;\\n                     ans =max(cnt,ans);\\n                    arr[i]=arr[i]+1;\\n                }\\n                }\\n                //else{continue;}\\n            }\\n            ans =max(cnt,ans);\\n        }\\n        return ans;\\n\\n    }\\n};"
                    }
                ]
            }
        ]
    },
    {
        "title": "Summary Ranges",
        "question_content": "<p>You are given a <strong>sorted unique</strong> integer array <code>nums</code>.</p>\n\n<p>A <strong>range</strong> <code>[a,b]</code> is the set of all integers from <code>a</code> to <code>b</code> (inclusive).</p>\n\n<p>Return <em>the <strong>smallest sorted</strong> list of ranges that <strong>cover all the numbers in the array exactly</strong></em>. That is, each element of <code>nums</code> is covered by exactly one of the ranges, and there is no integer <code>x</code> such that <code>x</code> is in one of the ranges but not in <code>nums</code>.</p>\n\n<p>Each range <code>[a,b]</code> in the list should be output as:</p>\n\n<ul>\n\t<li><code>&quot;a-&gt;b&quot;</code> if <code>a != b</code></li>\n\t<li><code>&quot;a&quot;</code> if <code>a == b</code></li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [0,1,2,4,5,7]\n<strong>Output:</strong> [&quot;0-&gt;2&quot;,&quot;4-&gt;5&quot;,&quot;7&quot;]\n<strong>Explanation:</strong> The ranges are:\n[0,2] --&gt; &quot;0-&gt;2&quot;\n[4,5] --&gt; &quot;4-&gt;5&quot;\n[7,7] --&gt; &quot;7&quot;\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [0,2,3,4,6,8,9]\n<strong>Output:</strong> [&quot;0&quot;,&quot;2-&gt;4&quot;,&quot;6&quot;,&quot;8-&gt;9&quot;]\n<strong>Explanation:</strong> The ranges are:\n[0,0] --&gt; &quot;0&quot;\n[2,4] --&gt; &quot;2-&gt;4&quot;\n[6,6] --&gt; &quot;6&quot;\n[8,9] --&gt; &quot;8-&gt;9&quot;\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= nums.length &lt;= 20</code></li>\n\t<li><code>-2<sup>31</sup> &lt;= nums[i] &lt;= 2<sup>31</sup> - 1</code></li>\n\t<li>All the values of <code>nums</code> are <strong>unique</strong>.</li>\n\t<li><code>nums</code> is sorted in ascending order.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 1805583,
                "title": "c-detailed-explanation-w-dry-run-faster-than-100-basic-concept-used",
                "content": "***Brief note about Question-***\\n* We have to *return the smallest sorted list of ranges that cover all the numbers in the array exactly.*\\n```\\nLet\\'s take an example not given in question -\\nSuppose array given to us is like, arr[]: [0,1,2,3,4,6,7,8,10,11,12,14]\\n\\nArray given to us is arr[]:  [0, 1, 2, 3, 4, 6, 7, 8, 10, 11, 12, 14]\\nIdeally it should look like: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14]\\n\\nIf we see then in our given array 5, 9, and 13 is not present.\\nSo this breaks our continuation\\nso our answer should be [\"0->4\",\"6->8\",\"10->12\",\"14\"]\\n\\nFirst from      \"0->4\", 5 is not their so it breaks our range \\nthen again from \"6->8\", 9 is not their so it breaks our range\\nthen again from \"10->12\", 13 is not their so it breaks our range\\nand lastly left \"14\", as it remain alone so we include it, like me, sad life :)\\n```\\n____________\\n***Solution - I (Using Normal Maths, Accepted)-***\\n* If we observe our question, then what is the first basic thing we can do.\\n* We simply say, we run a loop in the array and when it differs from our expected number we break the loop and store it in answer as the main advanatage given to us is *array is in already sorted form*.\\n* After that we shift to our next element and again start doing that.\\n* Let\\'s see some in more detailed way.\\n```\\nSuppose array given to us is like, arr[]: [0,1,2,3,4,6,7,8,10,11,12,14]\\n\\narr[]: [0, 1, 2, 3, 4, 6, 7, 8, 10, 11, 12, 14]\\n        \\u2191  (intially we stand on our zeroth element)\\n\\t\\tNow, what we want to be our next element, we say it should be 1\\n\\t\\tso we will check our next element, and yes it is 1,\\n\\t\\tso we move ahead without breaking our current range \\n\\t\\t\\narr[]: [0, 1, 2, 3, 4, 6, 7, 8, 10, 11, 12, 14]\\n           \\u2191  (now, we stand on our first element)\\n\\t\\tNow, what we want to be our next element, we say it should be 2\\n\\t\\tso we will check our next element, and yes it is 2,\\n\\t\\tso we move ahead without breaking our current range \\n\\t\\t\\narr[]: [0, 1, 2, 3, 4, 6, 7, 8, 10, 11, 12, 14]\\n              \\u2191  (now, we stand on our second element)\\n\\t\\tNow, what we want to be our next element, we say it should be 3\\n\\t\\tso we will check our next element, and yes it is 3,\\n\\t\\tso we move ahead without breaking our current range\\n\\t\\t\\narr[]: [0, 1, 2, 3, 4, 6, 7, 8, 10, 11, 12, 14]\\n                 \\u2191  (now, we stand on our third element)\\n\\t\\tNow, what we want to be our next element, we say it should be 4\\n\\t\\tso we will check our next element, and yes it is 4,\\n\\t\\tso we move ahead without breaking our current range\\n\\t\\t\\narr[]: [0, 1, 2, 3, 4, 6, 7, 8, 10, 11, 12, 14]\\n                    \\u2191  (now, we stand on our fourth element)\\n\\t\\tNow, what we want to be our next element, we say it should be 5\\n\\t\\tBut here our next element is not 5, it is 6\\n\\t\\tso, our current range breaks here and \\n\\t\\twe store this particular range into our answer i.e \"0->4\" and move head\\n\\t\\t\\narr[]: [0, 1, 2, 3, 4, 6, 7, 8, 10, 11, 12, 14]\\n                       \\u2191  (now, we stand on our fifth element and will do a fresh start from here)\\n\\t\\tNow, what we want to be our next element, we say it should be 7\\n\\t\\tso we will check our next element, and yes it is 7,\\n\\t\\tso we move ahead without breaking our current range\\n\\t\\t\\narr[]: [0, 1, 2, 3, 4, 6, 7, 8, 10, 11, 12, 14]\\n                          \\u2191  (now, we stand on our sixth element)\\n\\t\\tNow, what we want to be our next element, we say it should be 8\\n\\t\\tso we will check our next element, and yes it is 8,\\n\\t\\tso we move ahead without breaking our current range\\n\\t\\t\\narr[]: [0, 1, 2, 3, 4, 6, 7, 8, 10, 11, 12, 14]\\n                             \\u2191  (now, we stand on our seventh element)\\n\\t\\tNow, what we want to be our next element, we say it should be 9\\n\\t\\tBut here our next element is 10, it is not 9\\n\\t\\tso, our current range breaks here and \\n\\t\\twe store this particular range into our answer i.e \"6->8\" and move head\\n\\t\\t\\narr[]: [0, 1, 2, 3, 4, 6, 7, 8, 10, 11, 12, 14]\\n                                 \\u2191 (now, we stand on our eighth element and will do a fresh start from here)\\n\\t\\tNow, what we want to be our next element, we say it should be 11\\n\\t\\tso we will check our next element, and yes it is 11,\\n\\t\\tso we move ahead without breaking our current range\\n\\t\\t\\narr[]: [0, 1, 2, 3, 4, 6, 7, 8, 10, 11, 12, 14]\\n                                     \\u2191 (now, we stand on our ninth element )\\n\\t\\tNow, what we want to be our next element, we say it should be 12\\n\\t\\tso we will check our next element, and yes it is 12,\\n\\t\\tso we move ahead without breaking our current range\\n\\t\\t\\narr[]: [0, 1, 2, 3, 4, 6, 7, 8, 10, 11, 12, 14]\\n                                         \\u2191 (now, we stand on our tenth element)\\n\\t\\tNow, what we want to be our next element, we say it should be 13\\n\\t\\tBut here our next element is 14, it is not 13\\n\\t\\tso, our current range breaks here and \\n\\t\\twe store this particular range into our answer i.e \"10->12\" and move head\\n\\t\\t\\narr[]: [0, 1, 2, 3, 4, 6, 7, 8, 10, 11, 12, 14]\\n                                             \\u2191\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t And lastly only one element is left\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t so simply we push it into our answer i.e \"14\"\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t \\nSo, Our final answer array looks like [\"0->4\",\"6->8\",\"10->12\",\"14\"]\\n```\\n______________\\n```\\nTime Complexity --> O(n) // where n is the length of the array \\nSpace Complexity --> O(1) // we are not using anything extra from our side\\n//also, we are not considering answer array, as we have to return that, we only push our answers to that\\n\\nIt paases [ 28 / 28 ] in built test cases\\n```\\n_________________\\n![image](https://assets.leetcode.com/users/images/83046a59-c596-4935-8df9-4160ff038135_1646020649.459944.png)\\n_______________\\n**Code (C++)**\\n```\\nclass Solution {\\npublic:\\n    vector<string> summaryRanges(vector<int>& arr) {\\n        int n = arr.size(); // extracting size of the array\\n        vector<string> ans; // declaring answer array to store our answer\\n        \\n        string temp = \"\"; // temproray string that stores all possible answer\\n        \\n        for(int i = 0; i < n; i++) // start traversing from the array\\n        {\\n            int j = i; // declare anthor pointer that will move\\n            \\n            // run that pointer until our range is not break\\n            while(j + 1 < n && arr[j + 1] == arr[j] + 1)\\n            {\\n                j++;\\n            }\\n            \\n            // if j > i, that means we got our range more than one element\\n            if(j > i)\\n            {\\n                temp += to_string(arr[i]); // first store starting point\\n                temp += \"->\"; // then store arrow, as question wants it\\n                temp += to_string(arr[j]); // and lastly store the end point\\n            }\\n            else // we got only one element as range\\n            {\\n                temp += to_string(arr[i]); // then store that element in temp\\n            }\\n            \\n            ans.push_back(temp); // push one possible answer string to our answer\\n            temp = \"\"; // again reintiliaze temp for new possible answers\\n            i = j; // and move i to j for a fresh start\\n        }\\n        \\n        return ans; // and at last finally return the answer array\\n    }\\n};\\n```\\n***`If u find this useful , please consider to give a upvote!!`***",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nLet\\'s take an example not given in question -\\nSuppose array given to us is like, arr[]: [0,1,2,3,4,6,7,8,10,11,12,14]\\n\\nArray given to us is arr[]:  [0, 1, 2, 3, 4, 6, 7, 8, 10, 11, 12, 14]\\nIdeally it should look like: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14]\\n\\nIf we see then in our given array 5, 9, and 13 is not present.\\nSo this breaks our continuation\\nso our answer should be [\"0->4\",\"6->8\",\"10->12\",\"14\"]\\n\\nFirst from      \"0->4\", 5 is not their so it breaks our range \\nthen again from \"6->8\", 9 is not their so it breaks our range\\nthen again from \"10->12\", 13 is not their so it breaks our range\\nand lastly left \"14\", as it remain alone so we include it, like me, sad life :)\\n```\n```\\nSuppose array given to us is like, arr[]: [0,1,2,3,4,6,7,8,10,11,12,14]\\n\\narr[]: [0, 1, 2, 3, 4, 6, 7, 8, 10, 11, 12, 14]\\n        \\u2191  (intially we stand on our zeroth element)\\n\\t\\tNow, what we want to be our next element, we say it should be 1\\n\\t\\tso we will check our next element, and yes it is 1,\\n\\t\\tso we move ahead without breaking our current range \\n\\t\\t\\narr[]: [0, 1, 2, 3, 4, 6, 7, 8, 10, 11, 12, 14]\\n           \\u2191  (now, we stand on our first element)\\n\\t\\tNow, what we want to be our next element, we say it should be 2\\n\\t\\tso we will check our next element, and yes it is 2,\\n\\t\\tso we move ahead without breaking our current range \\n\\t\\t\\narr[]: [0, 1, 2, 3, 4, 6, 7, 8, 10, 11, 12, 14]\\n              \\u2191  (now, we stand on our second element)\\n\\t\\tNow, what we want to be our next element, we say it should be 3\\n\\t\\tso we will check our next element, and yes it is 3,\\n\\t\\tso we move ahead without breaking our current range\\n\\t\\t\\narr[]: [0, 1, 2, 3, 4, 6, 7, 8, 10, 11, 12, 14]\\n                 \\u2191  (now, we stand on our third element)\\n\\t\\tNow, what we want to be our next element, we say it should be 4\\n\\t\\tso we will check our next element, and yes it is 4,\\n\\t\\tso we move ahead without breaking our current range\\n\\t\\t\\narr[]: [0, 1, 2, 3, 4, 6, 7, 8, 10, 11, 12, 14]\\n                    \\u2191  (now, we stand on our fourth element)\\n\\t\\tNow, what we want to be our next element, we say it should be 5\\n\\t\\tBut here our next element is not 5, it is 6\\n\\t\\tso, our current range breaks here and \\n\\t\\twe store this particular range into our answer i.e \"0->4\" and move head\\n\\t\\t\\narr[]: [0, 1, 2, 3, 4, 6, 7, 8, 10, 11, 12, 14]\\n                       \\u2191  (now, we stand on our fifth element and will do a fresh start from here)\\n\\t\\tNow, what we want to be our next element, we say it should be 7\\n\\t\\tso we will check our next element, and yes it is 7,\\n\\t\\tso we move ahead without breaking our current range\\n\\t\\t\\narr[]: [0, 1, 2, 3, 4, 6, 7, 8, 10, 11, 12, 14]\\n                          \\u2191  (now, we stand on our sixth element)\\n\\t\\tNow, what we want to be our next element, we say it should be 8\\n\\t\\tso we will check our next element, and yes it is 8,\\n\\t\\tso we move ahead without breaking our current range\\n\\t\\t\\narr[]: [0, 1, 2, 3, 4, 6, 7, 8, 10, 11, 12, 14]\\n                             \\u2191  (now, we stand on our seventh element)\\n\\t\\tNow, what we want to be our next element, we say it should be 9\\n\\t\\tBut here our next element is 10, it is not 9\\n\\t\\tso, our current range breaks here and \\n\\t\\twe store this particular range into our answer i.e \"6->8\" and move head\\n\\t\\t\\narr[]: [0, 1, 2, 3, 4, 6, 7, 8, 10, 11, 12, 14]\\n                                 \\u2191 (now, we stand on our eighth element and will do a fresh start from here)\\n\\t\\tNow, what we want to be our next element, we say it should be 11\\n\\t\\tso we will check our next element, and yes it is 11,\\n\\t\\tso we move ahead without breaking our current range\\n\\t\\t\\narr[]: [0, 1, 2, 3, 4, 6, 7, 8, 10, 11, 12, 14]\\n                                     \\u2191 (now, we stand on our ninth element )\\n\\t\\tNow, what we want to be our next element, we say it should be 12\\n\\t\\tso we will check our next element, and yes it is 12,\\n\\t\\tso we move ahead without breaking our current range\\n\\t\\t\\narr[]: [0, 1, 2, 3, 4, 6, 7, 8, 10, 11, 12, 14]\\n                                         \\u2191 (now, we stand on our tenth element)\\n\\t\\tNow, what we want to be our next element, we say it should be 13\\n\\t\\tBut here our next element is 14, it is not 13\\n\\t\\tso, our current range breaks here and \\n\\t\\twe store this particular range into our answer i.e \"10->12\" and move head\\n\\t\\t\\narr[]: [0, 1, 2, 3, 4, 6, 7, 8, 10, 11, 12, 14]\\n                                             \\u2191\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t And lastly only one element is left\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t so simply we push it into our answer i.e \"14\"\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t \\nSo, Our final answer array looks like [\"0->4\",\"6->8\",\"10->12\",\"14\"]\\n```\n```\\nTime Complexity --> O(n) // where n is the length of the array \\nSpace Complexity --> O(1) // we are not using anything extra from our side\\n//also, we are not considering answer array, as we have to return that, we only push our answers to that\\n\\nIt paases [ 28 / 28 ] in built test cases\\n```\n```\\nclass Solution {\\npublic:\\n    vector<string> summaryRanges(vector<int>& arr) {\\n        int n = arr.size(); // extracting size of the array\\n        vector<string> ans; // declaring answer array to store our answer\\n        \\n        string temp = \"\"; // temproray string that stores all possible answer\\n        \\n        for(int i = 0; i < n; i++) // start traversing from the array\\n        {\\n            int j = i; // declare anthor pointer that will move\\n            \\n            // run that pointer until our range is not break\\n            while(j + 1 < n && arr[j + 1] == arr[j] + 1)\\n            {\\n                j++;\\n            }\\n            \\n            // if j > i, that means we got our range more than one element\\n            if(j > i)\\n            {\\n                temp += to_string(arr[i]); // first store starting point\\n                temp += \"->\"; // then store arrow, as question wants it\\n                temp += to_string(arr[j]); // and lastly store the end point\\n            }\\n            else // we got only one element as range\\n            {\\n                temp += to_string(arr[i]); // then store that element in temp\\n            }\\n            \\n            ans.push_back(temp); // push one possible answer string to our answer\\n            temp = \"\"; // again reintiliaze temp for new possible answers\\n            i = j; // and move i to j for a fresh start\\n        }\\n        \\n        return ans; // and at last finally return the answer array\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1805391,
                "title": "concise-solution-in-0-n-with-approach-explained-in-detail",
                "content": "```\\nLet us understand question first\\nQuestion is saying wherever you are finding continous elements then keep them in an interval\\nelse keep them alone\\n\\nEX->  [0,1,2,4,5,7]\\n[0,1,2]-->[0->2] {2-4 in array is breakpoint}\\n[4,5]  -->[4->5]\\n[7]    -->[7]\\n\\nApproach\\n\\nTraverse the entire array\\n1.keep start at every element and check whether i doesnt reached end and the ith element added with 1 gives the next element. If so then keep travelling ahead by incrementing i until you find a breakpoint\\n2. Once you find a breakpoint where nums[i]+1!=nums[i+1],so at that time check whether nums[i]!=start,if so add it to list start+\"->\"+nums[i]\\n3. else add just the start \\n\\nTime Compl-> 0(N)\\nSpace -> 0(1)\\n    \\n    \\n-------------------------------------------------------------------------\\nclass Solution {\\n    public List<String> summaryRanges(int[] nums) {\\n       ArrayList<String> al=new ArrayList<>();\\n        \\n        for(int i=0;i<nums.length;i++){\\n            int start=nums[i];\\n            while(i+1<nums.length && nums[i]+1==nums[i+1])\\n                i++;\\n            \\n            if(start!=nums[i]){\\n                al.add(\"\"+start+\"->\"+nums[i]);\\n            }\\n            else{\\n                al.add(\"\"+start);\\n            }\\n        }\\n        return al;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nLet us understand question first\\nQuestion is saying wherever you are finding continous elements then keep them in an interval\\nelse keep them alone\\n\\nEX->  [0,1,2,4,5,7]\\n[0,1,2]-->[0->2] {2-4 in array is breakpoint}\\n[4,5]  -->[4->5]\\n[7]    -->[7]\\n\\nApproach\\n\\nTraverse the entire array\\n1.keep start at every element and check whether i doesnt reached end and the ith element added with 1 gives the next element. If so then keep travelling ahead by incrementing i until you find a breakpoint\\n2. Once you find a breakpoint where nums[i]+1!=nums[i+1],so at that time check whether nums[i]!=start,if so add it to list start+\"->\"+nums[i]\\n3. else add just the start \\n\\nTime Compl-> 0(N)\\nSpace -> 0(1)\\n    \\n    \\n-------------------------------------------------------------------------\\nclass Solution {\\n    public List<String> summaryRanges(int[] nums) {\\n       ArrayList<String> al=new ArrayList<>();\\n        \\n        for(int i=0;i<nums.length;i++){\\n            int start=nums[i];\\n            while(i+1<nums.length && nums[i]+1==nums[i+1])\\n                i++;\\n            \\n            if(start!=nums[i]){\\n                al.add(\"\"+start+\"->\"+nums[i]);\\n            }\\n            else{\\n                al.add(\"\"+start);\\n            }\\n        }\\n        return al;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1805321,
                "title": "c-0ms-100-easy-to-understand-full-explanation",
                "content": "# 228. Summary Ranges\\n**KNOCKCAT**\\n* SOMEONE AGAIN DOWNVOTNG BY BIG NUMBERS:(\\n```\\n1. Easy C++\\n2. Line by Line Explanation with Comments.\\n3. Detailed Explanation \\u2705\\n4. Please Upvote if it helps\\u2B06\\uFE0F\\n5. Link to my Github Profile contains a repository of Leetcode with all my Solutions. \\u2B07\\uFE0F\\n\\t// \\uD83D\\uDE09If you Like the repository don\\'t foget to star & fork the repository\\uD83D\\uDE09 \\n```\\n\\n[LeetCode](https://github.com/knockcat/Leetcode)  **LINK TO LEETCODE REPOSITORY**\\n\\nPlease upvote my comment so that i get to win the 2022 giveaway and motivate to make such discussion post.\\n**Happy new Year 2023 to all of you**\\n**keep solving keep improving**\\nLink To comment\\n[Leetcode Give away comment](https://leetcode.com/discuss/general-discussion/2946993/2022-Annual-Badge-and-the-Giveaway/1734919)\\n\\n![image](https://assets.leetcode.com/users/images/07adca95-d77d-42fc-a1e8-2d2a8a3ecf7e_1646012418.2197788.png)\\n\\n**EXPLANATION**\\n1. We are given a sorted unique integer array nums.\\n2. We have to return the smallest list of ranges that cover all the number in the array exactly..\\n\\teg **Input: nums** = **[0,1,2,4,5,7]\\nOutput:  [\"0->2\",\"4->5\",\"7\"]**\\n3. So let take the first iteration as our for loop will iteratre from 0 to n (n is vector size, and assign **a = nums[i]**.\\n4. Now acc, to above sample case for first iteartion i = 0\\n5. We are checking for a condition than if our i == n-1 or nums[i] + 1 != nums[i+1]\\n* so for *first iteration* **0 != 5 or 1 != 1** ( none of them is true) **Condition False**\\n* now for *second iteration* i = 1; **1 != 5 or 2 != 2** (none of them is true) **Condition False**\\n* now for third iteration i = 2; **2 != 5 or 3 != 4** (bothare true) **Condition True**\\n* So now for the first time it will executes under For Loop.\\n* now if condition under for loop says, **2 != 0**  therfore now we will push a -> nums[i] in the result;\\n* i.e **\"0->2\"**  *result vector becomes* **[\"0->2\"]**\\n* also there is aif check for updating a by nums[i+1] & here 2 != 5 therefore now a = 4; as a = nums[i+1] we have to update it\\n* Now, for fourth iteration i = 3; **3 != 5 or 5 != 5** both are false **Condition False**\\n* For the fifth iteration now i = 4; **4  != 5 or 6 != 7** (both are true) **Condition True**\\n* Now we will execute under for if condition , **5 != 4**  *(nums[i] != a)*\\n* therfore we will add  **4->5** in the string. *result vector becomes* **[\"0->2\",\"4->5\"]**\\n* now again checking for if condition which says **$ != 5** (condition true) **Condion True** therefore we will  **update a by nums[i+1]** i.e **a = 7**.\\n* Now for the *sixth Iteration* i = 5; **5 == 5 || 6 != out of bound** (first condition true) **Condition True**.\\n* WE will execute under if  **7 != 4** Therefore we will execute else part.\\n* we will add a to string i.e **7** *result vector becomes* **[\"0->2\",\"4->5\",\"7\"]**\\n* now for seventh iteration **i = 6; i < 6** (false) **Condition False**\\n* Now we will return the result as \\n* Output  - **[\"0->2\",\"4->5\",\"7\"]**\\n```\\n```\\n**TIME COMPLEXITY**  **O(N)**  *we are iterating over vector nums Once.*\\n**SPACE COMPLEXTY** **O(1)**\\n```\\n```\\n**CODE WITH EXPLNATION**\\n```\\n\\t\\t\\t\\t\\t\\t// \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09Please upvote if it helps \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\nclass Solution {\\npublic:\\n    vector<string> summaryRanges(vector<int>& nums) {\\n\\t\\t// resultant string\\n        vector<string> result;\\n        \\n        int n = nums.size();\\n\\t\\t// if size happens to be  zero return empty string\\n        if(n == 0 )\\n                return result;\\n        \\n\\t\\t// assigning first element to a\\n        int a = nums[0];\\n        \\n        for(int i = 0; i<n; i++)\\n        {\\n\\t\\t\\t// if one of both is true\\n            if( i == n-1 || nums[i]+1 != nums[i+1])\\n            {\\n\\t\\t\\t    // if current element is not equals a\\n\\t\\t\\t\\t// this means we have found a range.\\n                if(nums[i] != a)\\n                    result.push_back(to_string(a)+ \"->\"+ to_string(nums[i]));\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t// this means we have reached to the end of string and now\\n\\t\\t\\t\\t// we have to add a that should be the last element\\n                else\\n                        result.push_back(to_string(a));\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t// checking  for this condition so that a got updated for next range\\n\\t\\t\\t\\t// also n-1 so that a doesn\\'t contain out of bound value\\n                if(i != n-1)\\n                    a = nums[i+1];\\n            }\\n        }\\n\\t\\t// return result\\n        return result;\\n    }\\n};\\n```\\n**DRY RUN OF 1 TEST CASE IS EXPLAINED ABOVE**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n1. Easy C++\\n2. Line by Line Explanation with Comments.\\n3. Detailed Explanation \\u2705\\n4. Please Upvote if it helps\\u2B06\\uFE0F\\n5. Link to my Github Profile contains a repository of Leetcode with all my Solutions. \\u2B07\\uFE0F\\n\\t// \\uD83D\\uDE09If you Like the repository don\\'t foget to star & fork the repository\\uD83D\\uDE09 \\n```\n```\\n```\n```\\n```\n```\\n\\t\\t\\t\\t\\t\\t// \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09Please upvote if it helps \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\nclass Solution {\\npublic:\\n    vector<string> summaryRanges(vector<int>& nums) {\\n\\t\\t// resultant string\\n        vector<string> result;\\n        \\n        int n = nums.size();\\n\\t\\t// if size happens to be  zero return empty string\\n        if(n == 0 )\\n                return result;\\n        \\n\\t\\t// assigning first element to a\\n        int a = nums[0];\\n        \\n        for(int i = 0; i<n; i++)\\n        {\\n\\t\\t\\t// if one of both is true\\n            if( i == n-1 || nums[i]+1 != nums[i+1])\\n            {\\n\\t\\t\\t    // if current element is not equals a\\n\\t\\t\\t\\t// this means we have found a range.\\n                if(nums[i] != a)\\n                    result.push_back(to_string(a)+ \"->\"+ to_string(nums[i]));\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t// this means we have reached to the end of string and now\\n\\t\\t\\t\\t// we have to add a that should be the last element\\n                else\\n                        result.push_back(to_string(a));\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t// checking  for this condition so that a got updated for next range\\n\\t\\t\\t\\t// also n-1 so that a doesn\\'t contain out of bound value\\n                if(i != n-1)\\n                    a = nums[i+1];\\n            }\\n        }\\n\\t\\t// return result\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 63219,
                "title": "accepted-java-solution-easy-to-understand",
                "content": "    List<String> list=new ArrayList();\\n    \\tif(nums.length==1){\\n    \\t\\tlist.add(nums[0]+\"\");\\n    \\t\\treturn list;\\n    \\t}\\n        for(int i=0;i<nums.length;i++){\\n        \\tint a=nums[i];\\n        \\twhile(i+1<nums.length&&(nums[i+1]-nums[i])==1){\\n        \\t\\ti++;\\n        \\t}\\n        \\tif(a!=nums[i]){\\n        \\t\\tlist.add(a+\"->\"+nums[i]);\\n        \\t}else{\\n        \\t\\tlist.add(a+\"\");\\n        \\t}\\n        }\\n        return list;",
                "solutionTags": [],
                "code": "    List<String> list=new ArrayList();\\n    \\tif(nums.length==1){\\n    \\t\\tlist.add(nums[0]+\"\");\\n    \\t\\treturn list;\\n    \\t}\\n        for(int i=0;i<nums.length;i++){\\n        \\tint a=nums[i];\\n        \\twhile(i+1<nums.length&&(nums[i+1]-nums[i])==1){\\n        \\t\\ti++;\\n        \\t}\\n        \\tif(a!=nums[i]){\\n        \\t\\tlist.add(a+\"->\"+nums[i]);\\n        \\t}else{\\n        \\t\\tlist.add(a+\"\");\\n        \\t}\\n        }\\n        return list;",
                "codeTag": "Unknown"
            },
            {
                "id": 63193,
                "title": "6-lines-in-python",
                "content": "Three versions of the same algorithm, all take O(n) time.\\n\\n---\\n\\n**Solution 1**\\n\\nJust collect the ranges, then format and return them.\\n\\n    def summaryRanges(self, nums):\\n        ranges = []\\n        for n in nums:\\n            if not ranges or n > ranges[-1][-1] + 1:\\n                ranges += [],\\n            ranges[-1][1:] = n,\\n        return ['->'.join(map(str, r)) for r in ranges]\\n\\n---\\n\\n**Solution 2**\\n\\nA variation of solution 1, holding the current range in an extra variable `r` to make things easier. Note that `r` contains at most two elements, so the `in`-check takes constant time.\\n\\n    def summaryRanges(self, nums):\\n        ranges, r = [], []\\n        for n in nums:\\n            if n-1 not in r:\\n                r = []\\n                ranges += r,\\n            r[1:] = n,\\n        return ['->'.join(map(str, r)) for r in ranges]\\n\\n---\\n\\n**Solution 3**\\n\\nA tricky short version.\\n\\n    def summaryRanges(self, nums):\\n        ranges = r = []\\n        for n in nums:\\n            if `n-1` not in r:\\n                r = []\\n                ranges += r,\\n            r[1:] = `n`,\\n        return map('->'.join, ranges)\\n\\n---\\n\\n**About the commas :-)**\\n\\nThree people asked about them in the comments, so I'll also explain it here as well. I have these two basic cases:\\n\\n    ranges += [],\\n    r[1:] = n,\\n\\nWhy the trailing commas? Because it turns the right hand side into a tuple and I get the same effects as these more common alternatives:\\n\\n    ranges += [[]]\\n    or\\n    ranges.append([])\\n\\n    r[1:] = [n]\\n\\nWithout the comma, ...\\n\\n - `ranges += []` wouldn't add `[]` itself but only its elements, i.e., nothing.\\n - `r[1:] = n` wouldn't work, because my `n` is not an iterable.\\n\\nWhy do it this way instead of the more common alternatives I showed above? Because it's shorter and faster (according to tests I did a while back).",
                "solutionTags": [
                    "Python"
                ],
                "code": "Three versions of the same algorithm, all take O(n) time.\\n\\n---\\n\\n**Solution 1**\\n\\nJust collect the ranges, then format and return them.\\n\\n    def summaryRanges(self, nums):\\n        ranges = []\\n        for n in nums:\\n            if not ranges or n > ranges[-1][-1] + 1:\\n                ranges += [],\\n            ranges[-1][1:] = n,\\n        return ['->'.join(map(str, r)) for r in ranges]\\n\\n---\\n\\n**Solution 2**\\n\\nA variation of solution 1, holding the current range in an extra variable `r` to make things easier. Note that `r` contains at most two elements, so the `in`-check takes constant time.\\n\\n    def summaryRanges(self, nums):\\n        ranges, r = [], []\\n        for n in nums:\\n            if n-1 not in r:\\n                r = []\\n                ranges += r,\\n            r[1:] = n,\\n        return ['->'.join(map(str, r)) for r in ranges]\\n\\n---\\n\\n**Solution 3**\\n\\nA tricky short version.\\n\\n    def summaryRanges(self, nums):\\n        ranges = r = []\\n        for n in nums:\\n            if `n-1` not in r:\\n                r = []\\n                ranges += r,\\n            r[1:] = `n`,\\n        return map('->'.join, ranges)\\n\\n---\\n\\n**About the commas :-)**\\n\\nThree people asked about them in the comments, so I'll also explain it here as well. I have these two basic cases:\\n\\n    ranges += [],\\n    r[1:] = n,\\n\\nWhy the trailing commas? Because it turns the right hand side into a tuple and I get the same effects as these more common alternatives:\\n\\n    ranges += [[]]\\n    or\\n    ranges.append([])\\n\\n    r[1:] = [n]\\n\\nWithout the comma, ...\\n\\n - `ranges += []` wouldn't add `[]` itself but only its elements, i.e., nothing.\\n - `r[1:] = n` wouldn't work, because my `n` is not an iterable.\\n\\nWhy do it this way instead of the more common alternatives I showed above? Because it's shorter and faster (according to tests I did a while back).",
                "codeTag": "Python3"
            },
            {
                "id": 63284,
                "title": "10-line-c-easy-understand",
                "content": "       vector<string> summaryRanges(vector<int>& nums) {\\n        const int size_n = nums.size();\\n        vector<string> res;\\n        if ( 0 == size_n) return res;\\n        for (int i = 0; i < size_n;) {\\n            int start = i, end = i;\\n            while (end + 1 < size_n && nums[end+1] == nums[end] + 1) end++;\\n            if (end > start) res.push_back(to_string(nums[start]) + \"->\" + to_string(nums[end]));\\n            else res.push_back(to_string(nums[start]));\\n            i = end+1;\\n        }\\n        return res;\\n    }",
                "solutionTags": [],
                "code": "       vector<string> summaryRanges(vector<int>& nums) {\\n        const int size_n = nums.size();\\n        vector<string> res;\\n        if ( 0 == size_n) return res;\\n        for (int i = 0; i < size_n;) {\\n            int start = i, end = i;\\n            while (end + 1 < size_n && nums[end+1] == nums[end] + 1) end++;\\n            if (end > start) res.push_back(to_string(nums[start]) + \"->\" + to_string(nums[end]));\\n            else res.push_back(to_string(nums[start]));\\n            i = end+1;\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 63446,
                "title": "my-easy-to-understand-python-solution",
                "content": "    def summaryRanges(self, nums):\\n        if not nums:\\n            return []\\n        res, i, start = [], 0, 0\\n        while i < len(nums)-1:\\n            if nums[i]+1 != nums[i+1]:\\n                res.append(self.printRange(nums[start], nums[i]))\\n                start = i+1\\n            i += 1\\n        res.append(self.printRange(nums[start], nums[i]))\\n        return res\\n    \\n    def printRange(self, l, r):\\n        if l == r:\\n            return str(l)\\n        else:\\n            return str(l) + \"->\" + str(r)",
                "solutionTags": [],
                "code": "    def summaryRanges(self, nums):\\n        if not nums:\\n            return []\\n        res, i, start = [], 0, 0\\n        while i < len(nums)-1:\\n            if nums[i]+1 != nums[i+1]:\\n                res.append(self.printRange(nums[start], nums[i]))\\n                start = i+1\\n            i += 1\\n        res.append(self.printRange(nums[start], nums[i]))\\n        return res\\n    \\n    def printRange(self, l, r):\\n        if l == r:\\n            return str(l)\\n        else:\\n            return str(l) + \"->\" + str(r)",
                "codeTag": "Python3"
            },
            {
                "id": 63474,
                "title": "idea-1-liner-group-by-number-index",
                "content": "**The Idea**\\n\\nThe difference between a number and its index identifies the range. Consider the given example input:\\n\\n    numbers:  [0, 1, 2, 4, 5, 7]\\n    indexes:  [0, 1, 2, 3, 4, 5]\\n    subtract: [0, 0, 0, 1, 1, 2]\\n\\nYou can see I have three differences (0, 1 and 2), corresponding to the three ranges. That can then be used to group the elements.\\n\\n---\\n\\n**Solution 1**\\n\\nRuby and Python can exploit it particularly well, thanks to their groupby functions:\\n\\nRuby:\\n\\n    def summary_ranges(nums)\\n      nums.each_with_index.group_by{|n,i| n-i}.map{|d,r| [r[0][0], r[-1][0]].uniq.join('->')}\\n    end\\n\\nPython:\\n\\n    def summaryRanges(self, nums):\\n        return [re.sub('->.*>', '->', '->'.join(`n` for i, n in g))\\n                for _, g in itertools.groupby(enumerate(nums), lambda (i, n): n-i)]\\n\\n---\\n\\n**Solution 2**\\n\\nHere I build two dicts, telling me the first and last number of each range. For the given example I get:\\n\\n    first = {0: 0, 1: 4, 2: 7}\\n    last  = {0: 2, 1: 5, 2: 7}\\n\\nThe code:\\n\\n    def summaryRanges(self, nums):\\n        diff = [(n-i, n) for i, n in enumerate(nums)]\\n        first, last = dict(diff[::-1]), dict(diff)\\n        return [`n` + ('->'+`last[d]`)*(n<last[d]) for d, n in sorted(first.items())]\\n\\n---\\n\\n**Solution 3**\\n\\nStoring `[first, last]` for each range in a dict (`last` being optional).\\n\\n    def summaryRanges(self, nums):\\n        ranges = collections.defaultdict(list)\\n        for i, n in enumerate(nums):\\n            ranges[n-i][1:] = n,\\n        return ['->'.join(map(str, r)) for r in sorted(ranges.values())]",
                "solutionTags": [
                    "Python",
                    "Ruby"
                ],
                "code": "**The Idea**\\n\\nThe difference between a number and its index identifies the range. Consider the given example input:\\n\\n    numbers:  [0, 1, 2, 4, 5, 7]\\n    indexes:  [0, 1, 2, 3, 4, 5]\\n    subtract: [0, 0, 0, 1, 1, 2]\\n\\nYou can see I have three differences (0, 1 and 2), corresponding to the three ranges. That can then be used to group the elements.\\n\\n---\\n\\n**Solution 1**\\n\\nRuby and Python can exploit it particularly well, thanks to their groupby functions:\\n\\nRuby:\\n\\n    def summary_ranges(nums)\\n      nums.each_with_index.group_by{|n,i| n-i}.map{|d,r| [r[0][0], r[-1][0]].uniq.join('->')}\\n    end\\n\\nPython:\\n\\n    def summaryRanges(self, nums):\\n        return [re.sub('->.*>', '->', '->'.join(`n` for i, n in g))\\n                for _, g in itertools.groupby(enumerate(nums), lambda (i, n): n-i)]\\n\\n---\\n\\n**Solution 2**\\n\\nHere I build two dicts, telling me the first and last number of each range. For the given example I get:\\n\\n    first = {0: 0, 1: 4, 2: 7}\\n    last  = {0: 2, 1: 5, 2: 7}\\n\\nThe code:\\n\\n    def summaryRanges(self, nums):\\n        diff = [(n-i, n) for i, n in enumerate(nums)]\\n        first, last = dict(diff[::-1]), dict(diff)\\n        return [`n` + ('->'+`last[d]`)*(n<last[d]) for d, n in sorted(first.items())]\\n\\n---\\n\\n**Solution 3**\\n\\nStoring `[first, last]` for each range in a dict (`last` being optional).\\n\\n    def summaryRanges(self, nums):\\n        ranges = collections.defaultdict(list)\\n        for i, n in enumerate(nums):\\n            ranges[n-i][1:] = n,\\n        return ['->'.join(map(str, r)) for r in sorted(ranges.values())]",
                "codeTag": "Python3"
            },
            {
                "id": 63386,
                "title": "my-concise-java-solution",
                "content": "    public List<String> summaryRanges(int[] nums) {\\n        int length = nums.length;\\n        List<String> result = new ArrayList<String>(length);\\n        for (int i = 0; i < length; i++) {\\n            int num = nums[i];\\n            while (i < length - 1 && nums[i] + 1 == nums[i + 1]) {\\n                i++;\\n            }\\n            if (num != nums[i]) {\\n                result.add(num + \"->\" + nums[i]);\\n            } else {\\n                result.add(num + \"\");\\n            }\\n        }\\n        return result;\\n    }",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "    public List<String> summaryRanges(int[] nums) {\\n        int length = nums.length;\\n        List<String> result = new ArrayList<String>(length);\\n        for (int i = 0; i < length; i++) {\\n            int num = nums[i];\\n            while (i < length - 1 && nums[i] + 1 == nums[i + 1]) {\\n                i++;\\n            }\\n            if (num != nums[i]) {\\n                result.add(num + \"->\" + nums[i]);\\n            } else {\\n                result.add(num + \"\");\\n            }\\n        }\\n        return result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 913432,
                "title": "python-two-pointers-o-n-solution-explained",
                "content": "What we need to in this problem is just traverse our data and create our ranges. Like if we have `1,2,3,4,5,7`, we see at `1`, `2`, `3`, `4` and `5`, and then we need to stop and start new range. We use two pointers approach with `beg` and `end` pointers. We increase our `end` pointers until next number is not equal to current + 1. Also we need to check if we have range with only one number of with more than one.\\n\\n**Complexity**: time complexity is `O(n)`, because we pass only once over our data. Space complexity is also potentially `O(n)`, because it can be the size of our answer.\\n\\n```\\nclass Solution:\\n    def summaryRanges(self, nums):\\n        i, result, N = 0, [], len(nums)\\n        \\n        while i < N:\\n            beg = end = i\\n            while end < N - 1 and nums[end] + 1 == nums[end + 1]: end += 1\\n            result.append(str(nums[beg]) + (\"->\" + str(nums[end])) *(beg != end))     \\n            i = end + 1\\n        \\n        return result\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def summaryRanges(self, nums):\\n        i, result, N = 0, [], len(nums)\\n        \\n        while i < N:\\n            beg = end = i\\n            while end < N - 1 and nums[end] + 1 == nums[end + 1]: end += 1\\n            result.append(str(nums[beg]) + (\"->\" + str(nums[end])) *(beg != end))     \\n            i = end + 1\\n        \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 538113,
                "title": "concise-and-easy-with-pictures",
                "content": "Here is basic two-pointers *O(N)* solution.\\n```\\nvector<string> summaryRanges(vector<int>& n) \\n{\\n\\tvector<string> r;\\n\\tfor (auto p(0), q(0); q<size(n); ++q)\\n\\t\\tif (q+1==size(n) || n[q+1]!=n[q]+1)\\n\\t\\t{\\n\\t\\t\\tr.emplace_back( p!=q ? to_string(n[p])+\"->\"+to_string(n[q]) : to_string(n[p]) );\\n\\t\\t\\tp=q+1;\\n\\t\\t}\\n\\treturn r;\\n}\\n```\\nHere are few pictures that illustrate the algo:\\n\\n![image](https://assets.leetcode.com/users/andriy111/image_1584106916.png)\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nvector<string> summaryRanges(vector<int>& n) \\n{\\n\\tvector<string> r;\\n\\tfor (auto p(0), q(0); q<size(n); ++q)\\n\\t\\tif (q+1==size(n) || n[q+1]!=n[q]+1)\\n\\t\\t{\\n\\t\\t\\tr.emplace_back( p!=q ? to_string(n[p])+\"->\"+to_string(n[q]) : to_string(n[p]) );\\n\\t\\t\\tp=q+1;\\n\\t\\t}\\n\\treturn r;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1805476,
                "title": "python-simple-python-solution-using-iterative-approach-o-n",
                "content": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 34 ms, faster than 71.53% of Python3 online submissions for Summary Ranges.\\n# Memory Usage: 13.8 MB, less than 88.25% of Python3 online submissions for Summary Ranges.\\n# Time Complexity : - O(n)\\n\\n\\tclass Solution:\\n\\t\\tdef summaryRanges(self, nums: List[int]) -> List[str]:\\n\\n\\t\\t\\tresult = []\\n\\n\\t\\t\\tstart , end = 0 , 0\\n\\n\\t\\t\\twhile start < len(nums) and end < len(nums):\\n\\n\\t\\t\\t\\tif (end + 1) < len(nums) and nums[end] + 1 == nums[end + 1]:\\n\\t\\t\\t\\t\\tend = end + 1\\n\\t\\t\\t\\telse:\\n\\n\\t\\t\\t\\t\\tif nums[start] == nums[end]:\\n\\t\\t\\t\\t\\t\\tresult.append(str(nums[start]))\\n\\t\\t\\t\\t\\t\\tstart = start + 1\\n\\t\\t\\t\\t\\t\\tend = end + 1\\n\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tresult.append(str(nums[start]) + \\'->\\' + str(nums[end]))\\n\\t\\t\\t\\t\\t\\tend = end + 1\\n\\t\\t\\t\\t\\t\\tstart = end\\n\\n\\t\\t\\treturn result\\n\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Iterator"
                ],
                "code": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 34 ms, faster than 71.53% of Python3 online submissions for Summary Ranges.\\n# Memory Usage: 13.8 MB, less than 88.25% of Python3 online submissions for Summary Ranges.\\n# Time Complexity : - O(n)\\n\\n\\tclass Solution:\\n\\t\\tdef summaryRanges(self, nums: List[int]) -> List[str]:\\n\\n\\t\\t\\tresult = []\\n\\n\\t\\t\\tstart , end = 0 , 0\\n\\n\\t\\t\\twhile start < len(nums) and end < len(nums):\\n\\n\\t\\t\\t\\tif (end + 1) < len(nums) and nums[end] + 1 == nums[end + 1]:\\n\\t\\t\\t\\t\\tend = end + 1\\n\\t\\t\\t\\telse:\\n\\n\\t\\t\\t\\t\\tif nums[start] == nums[end]:\\n\\t\\t\\t\\t\\t\\tresult.append(str(nums[start]))\\n\\t\\t\\t\\t\\t\\tstart = start + 1\\n\\t\\t\\t\\t\\t\\tend = end + 1\\n\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tresult.append(str(nums[start]) + \\'->\\' + str(nums[end]))\\n\\t\\t\\t\\t\\t\\tend = end + 1\\n\\t\\t\\t\\t\\t\\tstart = end\\n\\n\\t\\t\\treturn result\\n\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D\\n",
                "codeTag": "Java"
            },
            {
                "id": 3627119,
                "title": "python-java-c-simple-solution-easy-to-understand",
                "content": "# An Upvote will be encouraging \\uD83D\\uDC4D\\n\\n# Approach and Intuition\\n\\n- First, we check if the input list nums is empty. If it is, we return an empty list since there are no ranges to summarize.\\n\\n- Initialize an empty list called ranges to store the summarized ranges.\\n\\n- Set the start variable to the first element of the nums list. This will be the starting point of the current range.\\n\\n- Iterate over the nums list starting from the second element (index 1) using a for loop.\\n\\n- For each iteration, compare the current element nums[i] with the previous element nums[i-1]. If they are not consecutive (i.e., nums[i] is not equal to nums[i-1] + 1), it means the current range has ended.\\n\\n- In this case, we need to add the summarized range to the ranges list. We check if the start value is equal to the previous element (nums[i-1]). If they are equal, it means the range consists of only one number. So we append the string representation of start to the ranges list.\\n\\n- If the start value is different from the previous element, it means the range has more than one number. In this case, we append the string representation of start concatenated with \"->\" and the string representation of the previous element (nums[i-1]) to the ranges list.\\n\\n- After adding the summarized range, we update the start variable to the current element (nums[i]) since it will be the starting point of the next range.\\n\\n- After the loop, we need to handle the last range. We check if the start value is equal to the last element of nums (nums[-1]). If they are equal, it means the last range consists of only one number. So we append the string representation of start to the ranges list.\\n\\n- If the start value is different from the last element, it means the last range has more than one number. In this case, we append the string representation of start concatenated with \"->\" and the string representation of the last element (nums[-1]) to the ranges list.\\n\\n- Finally, we return the ranges list, which contains the summarized ranges as strings.\\n\\nThe intuition behind this approach is to iterate over the nums list and identify consecutive sequences of numbers. Whenever a sequence is interrupted, we add the summarized range to the ranges list. By keeping track of the starting point of each range (start variable), we can determine whether a range consists of a single number or multiple numbers. The code handles the first and last ranges separately to ensure all ranges are summarized correctly.\\n\\n```Python []\\nclass Solution:\\n    def summaryRanges(self, nums):\\n        if not nums:\\n            return []\\n\\n        ranges = []\\n        start = nums[0]\\n\\n        for i in range(1, len(nums)):\\n            if nums[i] != nums[i-1] + 1:\\n                if start == nums[i-1]:\\n                    ranges.append(str(start))\\n                else:\\n                    ranges.append(str(start) + \"->\" + str(nums[i-1]))\\n                start = nums[i]\\n\\n        # Handle the last range\\n        if start == nums[-1]:\\n            ranges.append(str(start))\\n        else:\\n            ranges.append(str(start) + \"->\" + str(nums[-1]))\\n\\n        return ranges\\n```\\n```Java []\\n\\nclass Solution {\\n    public List<String> summaryRanges(int[] nums) {\\n        if (nums == null || nums.length == 0) {\\n            return new ArrayList<>();\\n        }\\n\\n        List<String> ranges = new ArrayList<>();\\n        int start = nums[0];\\n\\n        for (int i = 1; i < nums.length; i++) {\\n            if (nums[i] != nums[i - 1] + 1) {\\n                if (start == nums[i - 1]) {\\n                    ranges.add(Integer.toString(start));\\n                } else {\\n                    ranges.add(start + \"->\" + nums[i - 1]);\\n                }\\n                start = nums[i];\\n            }\\n        }\\n\\n        // Handle the last range\\n        if (start == nums[nums.length - 1]) {\\n            ranges.add(Integer.toString(start));\\n        } else {\\n            ranges.add(start + \"->\" + nums[nums.length - 1]);\\n        }\\n\\n        return ranges;\\n    }\\n}\\n\\n```\\n```C++ []\\n\\nclass Solution {\\npublic:\\n    std::vector<std::string> summaryRanges(std::vector<int>& nums) {\\n        if (nums.empty()) {\\n            return {};\\n        }\\n\\n        std::vector<std::string> ranges;\\n        int start = nums[0];\\n\\n        for (int i = 1; i < nums.size(); i++) {\\n            if (nums[i] != nums[i - 1] + 1) {\\n                if (start == nums[i - 1]) {\\n                    ranges.push_back(std::to_string(start));\\n                } else {\\n                    ranges.push_back(std::to_string(start) + \"->\" + std::to_string(nums[i - 1]));\\n                }\\n                start = nums[i];\\n            }\\n        }\\n\\n        // Handle the last range\\n        if (start == nums.back()) {\\n            ranges.push_back(std::to_string(start));\\n        } else {\\n            ranges.push_back(std::to_string(start) + \"->\" + std::to_string(nums.back()));\\n        }\\n\\n        return ranges;\\n    }\\n};\\n```\\n# An Upvote will be encouraging \\uD83D\\uDC4D",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Array"
                ],
                "code": "```Python []\\nclass Solution:\\n    def summaryRanges(self, nums):\\n        if not nums:\\n            return []\\n\\n        ranges = []\\n        start = nums[0]\\n\\n        for i in range(1, len(nums)):\\n            if nums[i] != nums[i-1] + 1:\\n                if start == nums[i-1]:\\n                    ranges.append(str(start))\\n                else:\\n                    ranges.append(str(start) + \"->\" + str(nums[i-1]))\\n                start = nums[i]\\n\\n        # Handle the last range\\n        if start == nums[-1]:\\n            ranges.append(str(start))\\n        else:\\n            ranges.append(str(start) + \"->\" + str(nums[-1]))\\n\\n        return ranges\\n```\n```Java []\\n\\nclass Solution {\\n    public List<String> summaryRanges(int[] nums) {\\n        if (nums == null || nums.length == 0) {\\n            return new ArrayList<>();\\n        }\\n\\n        List<String> ranges = new ArrayList<>();\\n        int start = nums[0];\\n\\n        for (int i = 1; i < nums.length; i++) {\\n            if (nums[i] != nums[i - 1] + 1) {\\n                if (start == nums[i - 1]) {\\n                    ranges.add(Integer.toString(start));\\n                } else {\\n                    ranges.add(start + \"->\" + nums[i - 1]);\\n                }\\n                start = nums[i];\\n            }\\n        }\\n\\n        // Handle the last range\\n        if (start == nums[nums.length - 1]) {\\n            ranges.add(Integer.toString(start));\\n        } else {\\n            ranges.add(start + \"->\" + nums[nums.length - 1]);\\n        }\\n\\n        return ranges;\\n    }\\n}\\n\\n```\n```C++ []\\n\\nclass Solution {\\npublic:\\n    std::vector<std::string> summaryRanges(std::vector<int>& nums) {\\n        if (nums.empty()) {\\n            return {};\\n        }\\n\\n        std::vector<std::string> ranges;\\n        int start = nums[0];\\n\\n        for (int i = 1; i < nums.size(); i++) {\\n            if (nums[i] != nums[i - 1] + 1) {\\n                if (start == nums[i - 1]) {\\n                    ranges.push_back(std::to_string(start));\\n                } else {\\n                    ranges.push_back(std::to_string(start) + \"->\" + std::to_string(nums[i - 1]));\\n                }\\n                start = nums[i];\\n            }\\n        }\\n\\n        // Handle the last range\\n        if (start == nums.back()) {\\n            ranges.push_back(std::to_string(start));\\n        } else {\\n            ranges.push_back(std::to_string(start) + \"->\" + std::to_string(nums.back()));\\n        }\\n\\n        return ranges;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3627121,
                "title": "python-3-find-ranges-x-y-and-return-formatted-result-beats-97",
                "content": "```\\nclass Solution:\\n    def summaryRanges(self, nums: List[int]) -> List[str]:\\n        ranges = [] # [start, end] or [x, y]\\n        for i, n in enumerate(nums):\\n            if ranges and ranges[-1][1] == n-1:\\n                ranges[-1][1] = n\\n            else:\\n                ranges.append([n, n])\\n\\n        return [f\\'{x}->{y}\\' if x != y else f\\'{x}\\' for x, y in ranges]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def summaryRanges(self, nums: List[int]) -> List[str]:\\n        ranges = [] # [start, end] or [x, y]\\n        for i, n in enumerate(nums):\\n            if ranges and ranges[-1][1] == n-1:\\n                ranges[-1][1] = n\\n            else:\\n                ranges.append([n, n])\\n\\n        return [f\\'{x}->{y}\\' if x != y else f\\'{x}\\' for x, y in ranges]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2467583,
                "title": "very-easy-100-fully-explained-java-c-python-javascript-python3",
                "content": "# **Java Solution:**\\n```\\n// Runtime: 3 ms, faster than 92.99% of Java online submissions for Summary Ranges.\\n// Time Complexity : O(N)\\n// Space Complexity : O(1)\\nclass Solution {\\n    public List<String> summaryRanges(int[] nums) {\\n        // Create a list of string to store the output result...\\n        List<String> output = new ArrayList<String>();\\n        // Start traversing the array from idx = 0 till idx < sizeofarray in a while loop.\\n        int idx = 0;\\n        while(idx < nums.length) {\\n            // Initialize beg and last index for identifying the continuous element in the array...\\n            int beg, last;\\n            // Mark the number at current index as beginning element of the range...\\n            beg = nums[idx];\\n            // Traverse the array beggining from current index & find the last element whose difference from previous element is exactly 1, i.e. nums[idx + 1] == nums[idx] + 1...\\n            while(idx+1 < nums.length && nums[idx+1] == nums[idx] + 1) \\n                idx++;\\n            // Set this element as last element of the range...\\n            last = nums[idx];\\n            // If continuous element isn\\'t present...\\n            if(beg == last)\\n                output.add(beg + \"\");\\n            // If present...\\n            else\\n                output.add( beg + \"->\" + last );\\n            idx++;          \\n        }\\n        return output;      // Return the output result list...\\n    }\\n}\\n```\\n\\n# **C++ Solution:**\\n```\\n// Runtime: 2 ms, faster than 81.97% of C++ online submissions for Summary Ranges.\\n// Time Complexity : O(N)\\n// Space Complexity : O(1)\\nclass Solution {\\npublic:\\n    vector<string> summaryRanges(vector<int>& nums) {\\n        // Create a list of string to store the output result...\\n        vector<string> output;\\n        // Start traversing the array from idx = 0 till idx < sizeofarray in a while loop.\\n        int idx = 0;\\n        while(idx < nums.size()) {\\n            // Initialize beg and last index for identifying the continuous element in the array...\\n            int beg, last;\\n            // Mark the number at current index as beginning element of the range...\\n            beg = nums[idx];\\n            // Traverse the array beggining from current index & find the last element whose difference from previous element is exactly 1, i.e. nums[idx + 1] == nums[idx] + 1...\\n            while(idx+1 < nums.size() && nums[idx+1] == nums[idx] + 1)\\n                idx++;\\n            // Set this element as last element of the range...\\n            last = nums[idx];\\n            // If continuous element isn\\'t present...\\n            if(beg == last)\\n                output.push_back(to_string(beg));\\n            // If present...\\n            else\\n                output.push_back(to_string(beg) + \"->\" + to_string(last));\\n            idx++;\\n        }\\n        return output;      // Return the output result list\\n    }\\n};\\n```\\n\\n# **Python/Python3 Solution:**\\n```\\n# Runtime: 11 ms, faster than 98.68% of Python online submissions for Summary Ranges.\\n# Memory Usage: 13.4 MB, less than 82.54% of Python online submissions for Summary Ranges.\\n# Time Complexity : O(N)\\n# Space Complexity : O(1)\\nclass Solution(object):\\n    def summaryRanges(self, nums):\\n        # Create a list of string to store the output result...\\n        output = []\\n        # Start traversing the array from idx = 0 till idx < sizeofarray in a while loop.\\n        idx = 0\\n        while idx < len(nums):\\n            # Mark the number at current index as beginning element of the range...\\n            beg = nums[idx]\\n            # Traverse the array beggining from current index & find the last element whose difference from previous element is exactly 1, i.e. nums[idx + 1] == nums[idx] + 1...\\n            while idx+1 < len(nums) and nums[idx+1] == nums[idx] + 1:\\n                idx += 1\\n            # Set this element as last element of the range...\\n            last = nums[idx]\\n            # If continuous element isn\\'t present...\\n            if beg == last:\\n                output.append(str(beg))\\n            # If present...\\n            else:\\n                output.append(str(beg) + \"->\" + str(last))\\n            idx += 1\\n        return output;      # Return the output result list...\\n```\\n            \\n# **JavaScript Solution:**\\n```\\n// Runtime: 46 ms, faster than 86.21% of JavaScript online submissions for Summary Ranges.\\n// Time Complexity : O(N)\\n// Space Complexity : O(1)\\nvar summaryRanges = function(nums) {\\n    // Create a list of string to store the output result...\\n    const output = [];\\n    // Start traversing the array from idx = 0 till idx < sizeofarray in a while loop.\\n    let idx = 0;\\n    while(idx < nums.length) {\\n        // Initialize beg and last index for identifying the continuous element in the array...\\n        let beg, last;\\n        // Mark the number at current index as beginning element of the range...\\n        beg = nums[idx];\\n        // Traverse the array beggining from current index & find the last element whose difference from previous element is exactly 1, i.e. nums[idx + 1] == nums[idx] + 1...\\n        while(idx+1 < nums.length && nums[idx+1] == nums[idx] + 1) \\n            idx++;\\n        // Set this element as last element of the range...\\n        last = nums[idx];\\n        // If continuous element isn\\'t present...\\n        if(beg == last)\\n            output.push(beg + \"\");\\n        // If present...\\n        else\\n            output.push( beg + \"->\" + last );\\n        idx++;          \\n    }\\n    return output;      // Return the output result list...\\n};\\n```\\n**I am working hard for you guys...\\nPlease upvote if you found any help with this code...**",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript"
                ],
                "code": "```\\n// Runtime: 3 ms, faster than 92.99% of Java online submissions for Summary Ranges.\\n// Time Complexity : O(N)\\n// Space Complexity : O(1)\\nclass Solution {\\n    public List<String> summaryRanges(int[] nums) {\\n        // Create a list of string to store the output result...\\n        List<String> output = new ArrayList<String>();\\n        // Start traversing the array from idx = 0 till idx < sizeofarray in a while loop.\\n        int idx = 0;\\n        while(idx < nums.length) {\\n            // Initialize beg and last index for identifying the continuous element in the array...\\n            int beg, last;\\n            // Mark the number at current index as beginning element of the range...\\n            beg = nums[idx];\\n            // Traverse the array beggining from current index & find the last element whose difference from previous element is exactly 1, i.e. nums[idx + 1] == nums[idx] + 1...\\n            while(idx+1 < nums.length && nums[idx+1] == nums[idx] + 1) \\n                idx++;\\n            // Set this element as last element of the range...\\n            last = nums[idx];\\n            // If continuous element isn\\'t present...\\n            if(beg == last)\\n                output.add(beg + \"\");\\n            // If present...\\n            else\\n                output.add( beg + \"->\" + last );\\n            idx++;          \\n        }\\n        return output;      // Return the output result list...\\n    }\\n}\\n```\n```\\n// Runtime: 2 ms, faster than 81.97% of C++ online submissions for Summary Ranges.\\n// Time Complexity : O(N)\\n// Space Complexity : O(1)\\nclass Solution {\\npublic:\\n    vector<string> summaryRanges(vector<int>& nums) {\\n        // Create a list of string to store the output result...\\n        vector<string> output;\\n        // Start traversing the array from idx = 0 till idx < sizeofarray in a while loop.\\n        int idx = 0;\\n        while(idx < nums.size()) {\\n            // Initialize beg and last index for identifying the continuous element in the array...\\n            int beg, last;\\n            // Mark the number at current index as beginning element of the range...\\n            beg = nums[idx];\\n            // Traverse the array beggining from current index & find the last element whose difference from previous element is exactly 1, i.e. nums[idx + 1] == nums[idx] + 1...\\n            while(idx+1 < nums.size() && nums[idx+1] == nums[idx] + 1)\\n                idx++;\\n            // Set this element as last element of the range...\\n            last = nums[idx];\\n            // If continuous element isn\\'t present...\\n            if(beg == last)\\n                output.push_back(to_string(beg));\\n            // If present...\\n            else\\n                output.push_back(to_string(beg) + \"->\" + to_string(last));\\n            idx++;\\n        }\\n        return output;      // Return the output result list\\n    }\\n};\\n```\n```\\n# Runtime: 11 ms, faster than 98.68% of Python online submissions for Summary Ranges.\\n# Memory Usage: 13.4 MB, less than 82.54% of Python online submissions for Summary Ranges.\\n# Time Complexity : O(N)\\n# Space Complexity : O(1)\\nclass Solution(object):\\n    def summaryRanges(self, nums):\\n        # Create a list of string to store the output result...\\n        output = []\\n        # Start traversing the array from idx = 0 till idx < sizeofarray in a while loop.\\n        idx = 0\\n        while idx < len(nums):\\n            # Mark the number at current index as beginning element of the range...\\n            beg = nums[idx]\\n            # Traverse the array beggining from current index & find the last element whose difference from previous element is exactly 1, i.e. nums[idx + 1] == nums[idx] + 1...\\n            while idx+1 < len(nums) and nums[idx+1] == nums[idx] + 1:\\n                idx += 1\\n            # Set this element as last element of the range...\\n            last = nums[idx]\\n            # If continuous element isn\\'t present...\\n            if beg == last:\\n                output.append(str(beg))\\n            # If present...\\n            else:\\n                output.append(str(beg) + \"->\" + str(last))\\n            idx += 1\\n        return output;      # Return the output result list...\\n```\n```\\n// Runtime: 46 ms, faster than 86.21% of JavaScript online submissions for Summary Ranges.\\n// Time Complexity : O(N)\\n// Space Complexity : O(1)\\nvar summaryRanges = function(nums) {\\n    // Create a list of string to store the output result...\\n    const output = [];\\n    // Start traversing the array from idx = 0 till idx < sizeofarray in a while loop.\\n    let idx = 0;\\n    while(idx < nums.length) {\\n        // Initialize beg and last index for identifying the continuous element in the array...\\n        let beg, last;\\n        // Mark the number at current index as beginning element of the range...\\n        beg = nums[idx];\\n        // Traverse the array beggining from current index & find the last element whose difference from previous element is exactly 1, i.e. nums[idx + 1] == nums[idx] + 1...\\n        while(idx+1 < nums.length && nums[idx+1] == nums[idx] + 1) \\n            idx++;\\n        // Set this element as last element of the range...\\n        last = nums[idx];\\n        // If continuous element isn\\'t present...\\n        if(beg == last)\\n            output.push(beg + \"\");\\n        // If present...\\n        else\\n            output.push( beg + \"->\" + last );\\n        idx++;          \\n    }\\n    return output;      // Return the output result list...\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 63236,
                "title": "my-java-0ms-not-always-luckily-you-are-here-your-runtime-beats-97-90-of-java-submissions",
                "content": "    public class Solution {\\n        public List<String> summaryRanges(int[] nums) {\\n    \\t\\tList<String> list = new ArrayList<>();\\n    \\t\\tfor (int i = 0, len = nums.length, k; i < len; i = k + 1) {\\n    \\t\\t\\tk = help(nums, i, len);\\n    \\t\\t\\tif (i != k)\\n    \\t\\t\\t\\tlist.add(\"\" + nums[i] + \"->\" + nums[k]);\\n    \\t\\t\\telse\\n    \\t\\t\\t\\tlist.add(\"\" + nums[i]);\\n    \\t\\t}\\n    \\t\\treturn list;\\n    \\t}\\n    \\n    \\tprivate int help(int[] nums, int l, int r) {\\n    \\t\\twhile (l + 1 < r) {\\n    \\t\\t\\tint m = (l + r) / 2;\\n    \\t\\t\\tif (nums[m] - nums[l] == m - l)\\n    \\t\\t\\t\\tl = m;\\n    \\t\\t\\telse\\n    \\t\\t\\t\\tr = m;\\n    \\t\\t}\\n    \\t\\treturn l;\\n    \\t}\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public List<String> summaryRanges(int[] nums) {\\n    \\t\\tList<String> list = new ArrayList<>();\\n    \\t\\tfor (int i = 0, len = nums.length, k; i < len; i = k + 1) {\\n    \\t\\t\\tk = help(nums, i, len);\\n    \\t\\t\\tif (i != k)\\n    \\t\\t\\t\\tlist.add(\"\" + nums[i] + \"->\" + nums[k]);\\n    \\t\\t\\telse\\n    \\t\\t\\t\\tlist.add(\"\" + nums[i]);\\n    \\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 63455,
                "title": "share-my-accepted-javascript-solution",
                "content": "Use a '#' to mark the end of the array, similar to Leetcode 38 Count and Say.\\n\\n    var summaryRanges = function(nums) {\\n        var t = 0\\n        var ans = []\\n        nums.push('#')\\n        for(var i=1;i<nums.length;i++)\\n            if(nums[i]-nums[t] !== i-t){\\n                if(i-t>1)\\n                    ans.push(nums[t]+'->'+(nums[i-1]))\\n                else\\n                    ans.push(nums[t].toString())\\n                t = i\\n            }\\n        return ans\\n    }",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "Use a '#' to mark the end of the array, similar to Leetcode 38 Count and Say.\\n\\n    var summaryRanges = function(nums) {\\n        var t = 0\\n        var ans = []\\n        nums.push('#')\\n        for(var i=1;i<nums.length;i++)\\n            if(nums[i]-nums[t] !== i-t){\\n                if(i-t>1)\\n                    ans.push(nums[t]+'->'+(nums[i-1]))\\n                else\\n                    ans.push(nums[t].toString())\\n                t = i\\n            }\\n        return ans\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 63393,
                "title": "7-line-python-implementation",
                "content": "Thoughts are simple O(n) solution, just share my implementation!\\n\\n\\n    def summaryRanges(self, nums):\\n        begin, res = 0, []\\n        strout = lambda b, e: str(b) + \"->\" + str(e) if b != e else str(b)\\n        for i in range(1, len(nums)+1):\\n            if i == len(nums) or nums[i] - nums[i-1] != 1:\\n                res.append(strout(nums[begin], nums[i-1]))\\n                begin = i\\n        return res",
                "solutionTags": [
                    "Python"
                ],
                "code": "Thoughts are simple O(n) solution, just share my implementation!\\n\\n\\n    def summaryRanges(self, nums):\\n        begin, res = 0, []\\n        strout = lambda b, e: str(b) + \"->\" + str(e) if b != e else str(b)\\n        for i in range(1, len(nums)+1):\\n            if i == len(nums) or nums[i] - nums[i-1] != 1:\\n                res.append(strout(nums[begin], nums[i-1]))\\n                begin = i\\n        return res",
                "codeTag": "Python3"
            },
            {
                "id": 63351,
                "title": "simple-javascript-solution",
                "content": "    function summaryRanges(nums) {\\n      var res = [];\\n      for (var i = 0, left = nums[0]; i < nums.length; i++) {\\n        if (nums[i] + 1 !== nums[i + 1]) {\\n          res.push(left === nums[i] ? '' + nums[i] : left + '->' + nums[i]);\\n          left = nums[i + 1];\\n        }\\n      }\\n      return res;\\n    }",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "    function summaryRanges(nums) {\\n      var res = [];\\n      for (var i = 0, left = nums[0]; i < nums.length; i++) {\\n        if (nums[i] + 1 !== nums[i + 1]) {\\n          res.push(left === nums[i] ? '' + nums[i] : left + '->' + nums[i]);\\n          left = nums[i + 1];\\n        }\\n      }\\n      return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 63372,
                "title": "my-c-solution-using-only-one-for-loop",
                "content": "    class Solution {\\n    public:\\n        vector<string> summaryRanges(vector<int>& nums) {\\n            vector<string> ret;\\n            int s = 0;\\n            for(int i = 0; i < nums.size(); i++){\\n                if(i + 1 == nums.size() || nums[i] + 1 != nums[i+1]){\\n                    string tmp = to_string(nums[s]);\\n                    if(i != s) tmp += \"->\" + to_string(nums[i]);\\n                    ret.push_back(tmp);\\n                    s = i + 1;\\n                }\\n            }\\n            \\n            return ret;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<string> summaryRanges(vector<int>& nums) {\\n            vector<string> ret;\\n            int s = 0;\\n            for(int i = 0; i < nums.size(); i++){\\n                if(i + 1 == nums.size() || nums[i] + 1 != nums[i+1]){\\n                    string tmp = to_string(nums[s]);\\n                    if(i != s) tmp += \"->\" + to_string(nums[i]);\\n                    ret.push_back(tmp);\\n                    s = i + 1;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1061035,
                "title": "simple-python-beats-82-in-time-99-in-space",
                "content": "```\\n    def summaryRanges(self, nums: List[int]) -> List[str]:\\n        ret=[]\\n        save=\"\"\\n        for i in range(len(nums)):\\n            if i<=len(nums)-2 and nums[i+1]==nums[i]+1:\\n                if save==\"\": save=str(nums[i])+\"->\"\\n            else:\\n                ret.append(save+str(nums[i]))\\n                save=\"\"\\n\\n        return ret        \\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n    def summaryRanges(self, nums: List[int]) -> List[str]:\\n        ret=[]\\n        save=\"\"\\n        for i in range(len(nums)):\\n            if i<=len(nums)-2 and nums[i+1]==nums[i]+1:\\n                if save==\"\": save=str(nums[i])+\"->\"\\n            else:\\n                ret.append(save+str(nums[i]))\\n                save=\"\"\\n\\n        return ret        \\n",
                "codeTag": "Python3"
            },
            {
                "id": 185327,
                "title": "java-one-pass-solution-beats-100-o-1-extra-space-explanation",
                "content": "The idea is simple - we go through the array (beginning from the 1st position) and check is difference between current and previous elements ==1. \\n**If yes,** we just increment special counter (in code it\\'s variable \"length\"). Why do we need this counter? To build a range A->B, we don\\'t need to remember all the elements between A and B. We just need to know the length of this range.\\n**If no,** having length, we build this range - find the first element of the range, and current previous element as the last in range.\\nFor example:\\n![image](https://assets.leetcode.com/users/olsh/image_1540392211.png)\\nstarting from first position:**1**\\ncheck if 1-0==1\\n![image](https://assets.leetcode.com/users/olsh/image_1540392372.png)\\nall is okay -> we increment length value and go next:\\n![image](https://assets.leetcode.com/users/olsh/image_1540392913.png)\\ncheck again:\\n![image](https://assets.leetcode.com/users/olsh/image_1540393904.png)\\n\\n4-2!=1 -> length becomes 0, add to result the next range:\\n**\"i-length\"->\"previous element\"**\\nin our case: \\n**0 -> 2**\\n![image](https://assets.leetcode.com/users/olsh/image_1540393486.png)\\ngo next:\\n![image](https://assets.leetcode.com/users/olsh/image_1540393542.png)\\nyes -> increment length and go next:\\n![image](https://assets.leetcode.com/users/olsh/image_1540393630.png)\\nNo -> build range as above:\\n![image](https://assets.leetcode.com/users/olsh/image_1540394006.png)\\nwe reached the last element and leave it as is.\\n\\n```\\nclass Solution {\\n public List < String > summaryRanges(int[] nums) {\\n  int length = 1;\\n  List < String > res = new ArrayList < String > ();\\n  for (int i = 1; i <= nums.length; i++) {\\n   if (i == nums.length || nums[i] != nums[i - 1] + 1) {\\n    if (length == 1) {\\n     res.add(String.valueOf(nums[i - length]));\\n    } else {\\n     res.add(nums[i - length] + \"->\" + nums[i - 1]);\\n    }\\n    length = 1;\\n   } else {\\n    length++;\\n   }\\n  }\\n  return res;\\n }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n public List < String > summaryRanges(int[] nums) {\\n  int length = 1;\\n  List < String > res = new ArrayList < String > ();\\n  for (int i = 1; i <= nums.length; i++) {\\n   if (i == nums.length || nums[i] != nums[i - 1] + 1) {\\n    if (length == 1) {\\n     res.add(String.valueOf(nums[i - length]));\\n    } else {\\n     res.add(nums[i - length] + \"->\" + nums[i - 1]);\\n    }\\n    length = 1;\\n   } else {\\n    length++;\\n   }\\n  }\\n  return res;\\n }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 63451,
                "title": "9-lines-c-0ms-solution",
                "content": "     vector<string> summaryRanges(vector<int>& nums) {\\n        int i = 0, size = nums.size();\\n        vector<string> result; \\n        while(i < size){\\n            int j = 1; \\n            while(i + j < size && nums[i + j] - nums[i] == j) ++j;\\n            result.push_back(j <= 1 ? to_string(nums[i]) : to_string(nums[i]) + \"->\" + to_string(nums[i + j - 1]));\\n            i += j; \\n        }\\n        return result; \\n    }",
                "solutionTags": [],
                "code": "     vector<string> summaryRanges(vector<int>& nums) {\\n        int i = 0, size = nums.size();\\n        vector<string> result; \\n        while(i < size){\\n            int j = 1; \\n            while(i + j < size && nums[i + j] - nums[i] == j) ++j;\\n            result.push_back(j <= 1 ? to_string(nums[i]) : to_string(nums[i]) + \"->\" + to_string(nums[i + j - 1]));\\n            i += j; \\n        }\\n        return result; \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 63212,
                "title": "using-divide-and-conquer-but-worst-case-o-n",
                "content": "public class Solution {\\n    \\n    class Range {\\n        int start;\\n        int end;\\n        \\n        Range(int s, int e) {\\n            start = s;\\n            end = e;\\n        }\\n    }\\n    \\n    public List<String> summaryRanges(int[] nums) {\\n        \\n        List<String> resStr = new ArrayList<>();\\n        \\n        if (nums.length == 0) {\\n            return resStr;\\n        }\\n        \\n        List<Range> res = new ArrayList<>();\\n        helper(nums, 0, nums.length - 1, res);\\n        \\n        for (Range r : res) {\\n            if (r.start == r.end) {\\n                resStr.add(Integer.toString(r.start));\\n            } else {\\n                resStr.add(r.start + \"->\" + r.end);\\n            }\\n        }\\n        \\n        return resStr;\\n    }\\n    \\n    private void helper(int[] nums, int i, int j, List<Range> res) {\\n        if (i == j || nums[j] - nums[i] == j - i) {\\n            add2res(nums[i], nums[j], res);\\n            return;\\n        }\\n        \\n        int m = (i + j) / 2;\\n        \\n        helper(nums, i, m, res);\\n        helper(nums, m + 1, j, res);\\n    }\\n    \\n    private void add2res(int a, int b, List<Range> res) {\\n        if (res.isEmpty() || res.get(res.size() - 1).end != a - 1) {\\n            res.add(new Range(a, b));\\n        } else {\\n            res.get(res.size() - 1).end = b;\\n        }\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    \\n    class Range {\\n        int start;\\n        int end;\\n        \\n        Range(int s, int e) {\\n            start = s;\\n            end = e;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 63335,
                "title": "simple-python-solution",
                "content": "Add a dummy number in the end, which will not be printed out\\n\\n    def summaryRanges(self, nums):\\n        if not nums:\\n            return []\\n        \\n        nums = nums + [nums[-1]+2]\\n        res = []\\n        head = nums[0]\\n        for i in range(1,len(nums)):\\n            if nums[i] - nums[i-1] > 1:\\n                if head == nums[i-1]:\\n                    res.append(str(head))\\n                else:\\n                    res.append(str(head) + \"->\" + str(nums[i-1]))\\n                head = nums[i]\\n        return res\\n\\nsame idea, a bit cleaner, use two dummy numbers..\\n\\n    def summaryRanges(self, nums):\\n        start, end, res = -2**31, -2**31, []\\n        for i in nums+[2**31-1]:\\n            if i - end == 1:\\n                end = i\\n            else:\\n                res += [str(start)] if start == end else [str(start) + \"->\" + str(end)]\\n                start = end = i\\n        return res[1:]",
                "solutionTags": [
                    "Python"
                ],
                "code": "Add a dummy number in the end, which will not be printed out\\n\\n    def summaryRanges(self, nums):\\n        if not nums:\\n            return []\\n        \\n        nums = nums + [nums[-1]+2]\\n        res = []\\n        head = nums[0]\\n        for i in range(1,len(nums)):\\n            if nums[i] - nums[i-1] > 1:\\n                if head == nums[i-1]:\\n                    res.append(str(head))\\n                else:\\n                    res.append(str(head) + \"->\" + str(nums[i-1]))\\n                head = nums[i]\\n        return res\\n\\nsame idea, a bit cleaner, use two dummy numbers..\\n\\n    def summaryRanges(self, nums):\\n        start, end, res = -2**31, -2**31, []\\n        for i in nums+[2**31-1]:\\n            if i - end == 1:\\n                end = i\\n            else:\\n                res += [str(start)] if start == end else [str(start) + \"->\" + str(end)]\\n                start = end = i\\n        return res[1:]",
                "codeTag": "Python3"
            },
            {
                "id": 3230054,
                "title": "228-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThis code implements the solution to the problem of finding the summary ranges for a given sorted unique integer array nums. The main idea is to iterate through nums and find the beginning and ending of each range.\\n\\nThe function summaryRanges takes a list of integers nums as input and returns a list of strings ans.\\n\\nThe variable ans is initialized as an empty list to store the final summary ranges.\\n\\nThe variable i is initialized to 0, which is used as the index to iterate through nums.\\n\\nIn the while loop, we first find the beginning of the range by assigning the value of nums[i] to the variable begin.\\n\\nThen we check if the current element and the next element form a range by checking if nums[i] is equal to nums[i+1] - 1. If they do form a range, we keep incrementing i until we reach the end of the range. We update the value of end to nums[i] once we reach the end of the range.\\n\\nNext, we check if the range contains only one element, i.e., begin is equal to end. If it does, we append the string representation of begin to ans. If not, we append the string representation of begin concatenated with \"->\" and the string representation of end to ans.\\n\\nFinally, we increment i by 1 to move to the next element in nums.\\n\\nOnce the loop is done, we return ans, which contains the summary ranges.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n  def summaryRanges(self, nums: List[int]) -> List[str]:\\n    ans = []\\n\\n    i = 0\\n    while i < len(nums):\\n      begin = nums[i]\\n      while i < len(nums) - 1 and nums[i] == nums[i + 1] - 1:\\n        i += 1\\n      end = nums[i]\\n      if begin == end:\\n        ans.append(str(begin))\\n      else:\\n        ans.append(str(begin) + \"->\" + str(end))\\n      i += 1\\n\\n    return ans\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array"
                ],
                "code": "```\\nclass Solution:\\n  def summaryRanges(self, nums: List[int]) -> List[str]:\\n    ans = []\\n\\n    i = 0\\n    while i < len(nums):\\n      begin = nums[i]\\n      while i < len(nums) - 1 and nums[i] == nums[i + 1] - 1:\\n        i += 1\\n      end = nums[i]\\n      if begin == end:\\n        ans.append(str(begin))\\n      else:\\n        ans.append(str(begin) + \"->\" + str(end))\\n      i += 1\\n\\n    return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 914271,
                "title": "c-super-simple-and-short-intuitive-solution-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    string getStr(int first, int last) {\\n        return first == last ? to_string(first) : to_string(first) + \"->\" + to_string(last);\\n    }\\n    \\n    vector<string> summaryRanges(vector<int>& nums) {\\n        if (nums.size() == 0)\\n            return vector<string>();\\n        \\n        vector<string> res;\\n        int first = nums[0];\\n        for (int i=1; i<nums.size(); ++i) {\\n            if (nums[i-1]+1 != nums[i]) {\\n                res.push_back(getStr(first, nums[i-1]));\\n                first = nums[i];\\n            }\\n        }\\n        res.push_back(getStr(first, nums.back()));\\n        return res;\\n    }\\n};\\n```\\n**Like it? please upvote...**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string getStr(int first, int last) {\\n        return first == last ? to_string(first) : to_string(first) + \"->\" + to_string(last);\\n    }\\n    \\n    vector<string> summaryRanges(vector<int>& nums) {\\n        if (nums.size() == 0)\\n            return vector<string>();\\n        \\n        vector<string> res;\\n        int first = nums[0];\\n        for (int i=1; i<nums.size(); ++i) {\\n            if (nums[i-1]+1 != nums[i]) {\\n                res.push_back(getStr(first, nums[i-1]));\\n                first = nums[i];\\n            }\\n        }\\n        res.push_back(getStr(first, nums.back()));\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 913441,
                "title": "c-simple-2-pointers-solution-explained-100-time-100-space",
                "content": "The first idea that popped into my mind reading the description was to use 2 pointers to wrap subsequences of consecutive numbers, create a temporary string to be pushed into an accumulator variable and then return it.\\n\\nAnd so I did.\\n\\nFirst of all, we will need a few variables:\\n* `res` will store our ongoing findings;\\n* `len` will store the length of our input vector;\\n* `i` and `j` will be our pointers, with `i` initialised to the beginning of the vector, at `0`;\\n* `tmp` is our temporary string to be created for each consecutive range.\\n\\nThen we move on with a main loop, going on as long as `i < len`.\\n\\nInside it, we will first of all set `j` to be immediately after `i` and then check if `nums[j]` is immediately consecutive to `nums[j - 1]`. Knowing our numbers are sorted and unique, be sure to check this condition in a way similar to `nums[j - 1] + 1 == nums[j]`; yes, that is basically plain logic, just to avoid the pains of an overflow.\\n\\nOnce we are done with the internal loop, we know that `j` will be positioned right after the last consecutive element starting from `i`, so we can create `tmp`, push it into `res` and finally update `i` to take the current `j` value before starting another loop.\\n\\nOnce we are done, we return `res`.\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<string> summaryRanges(vector<int>& nums) {\\n        // support variables\\n        vector<string> res;\\n        int len = nums.size(), i = 0, j;\\n        string tmp;\\n        while (i < len) {\\n            // moving j right after the last sequential element after i\\n            j = i + 1;\\n            while (j < len && nums[j - 1] + 1 == nums[j]) j++;\\n            // composing and appending the next element to res, then settin i for the next loop\\n            tmp = to_string(nums[i]) + (j - i > 1 ? \"->\" + to_string(nums[j - 1]) : \"\");\\n            res.push_back(tmp);\\n            i = j;\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nAnd since I just noticed you don\\'t even really need to explicitly create a `tmp` variable, you can remove its declaration and go a bit more cramped in the last steps of your loop like this:\\n\\n```cpp\\n            // ...\\n\\t\\t\\t// composing and appending the next element to res, then setting i for the next loop\\n            res.push_back(to_string(nums[i]) + (j - i > 1 ? \"->\" + to_string(nums[j - 1]) : \"\"));\\n            i = j;\\n        }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<string> summaryRanges(vector<int>& nums) {\\n        // support variables\\n        vector<string> res;\\n        int len = nums.size(), i = 0, j;\\n        string tmp;\\n        while (i < len) {\\n            // moving j right after the last sequential element after i\\n            j = i + 1;\\n            while (j < len && nums[j - 1] + 1 == nums[j]) j++;\\n            // composing and appending the next element to res, then settin i for the next loop\\n            tmp = to_string(nums[i]) + (j - i > 1 ? \"->\" + to_string(nums[j - 1]) : \"\");\\n            res.push_back(tmp);\\n            i = j;\\n        }\\n        return res;\\n    }\\n};\\n```\n```cpp\\n            // ...\\n\\t\\t\\t// composing and appending the next element to res, then setting i for the next loop\\n            res.push_back(to_string(nums[i]) + (j - i > 1 ? \"->\" + to_string(nums[j - 1]) : \"\"));\\n            i = j;\\n        }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2765340,
                "title": "ranges-in-python",
                "content": "```\\nclass Solution:\\n\\tdef summaryRanges(self, nums: List[int]) -> List[str]:\\n\\n\\t\\tstart = 0\\n\\t\\tend = 0\\n\\n\\t\\tresult = []\\n\\n\\t\\twhile start < len(nums) and end<len(nums):\\n\\n\\t\\t\\tif end+1 < len(nums) and nums[end]+1 == nums[end+1]:\\n\\t\\t\\t\\tend=end+1\\n\\n\\t\\t\\telse:\\n\\t\\t\\t\\tif start == end:\\n\\t\\t\\t\\t\\tresult.append(str(nums[start]))\\n\\t\\t\\t\\t\\tstart = start + 1\\n\\t\\t\\t\\t\\tend = end + 1\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tresult.append(str(nums[start])+\\'->\\'+str(nums[end]))\\n\\t\\t\\t\\t\\tstart = end + 1\\n\\t\\t\\t\\t\\tend = end + 1\\n\\n\\t\\treturn result\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n\\tdef summaryRanges(self, nums: List[int]) -> List[str]:\\n\\n\\t\\tstart = 0\\n\\t\\tend = 0\\n\\n\\t\\tresult = []\\n\\n\\t\\twhile start < len(nums) and end<len(nums):\\n\\n\\t\\t\\tif end+1 < len(nums) and nums[end]+1 == nums[end+1]:\\n\\t\\t\\t\\tend=end+1\\n\\n\\t\\t\\telse:\\n\\t\\t\\t\\tif start == end:\\n\\t\\t\\t\\t\\tresult.append(str(nums[start]))\\n\\t\\t\\t\\t\\tstart = start + 1\\n\\t\\t\\t\\t\\tend = end + 1\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tresult.append(str(nums[start])+\\'->\\'+str(nums[end]))\\n\\t\\t\\t\\t\\tstart = end + 1\\n\\t\\t\\t\\t\\tend = end + 1\\n\\n\\t\\treturn result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1812051,
                "title": "0ms-0-n-solution-using-c-with-full-explanation",
                "content": "The idea is to use three pointer i,j and k where:\\n-> i will traverse the whole array\\n-> j will mark the end point of the subset\\n-> k will mark the starting point of the subset\\n\\ni will be initialised to index 1 and j and k to index 0\\n\\nNow if the diff is 1 i.e num[i]-num[j]==1 then i and j will be incremented until the difference becomes more than 1.\\n\\nas the diff becomes more than 1 values at j and k are inserted to the string as subsets and then i and  j are incremented and k is brought to the position of j.\\n\\nbut this way the last elemnt of the array will not be processed .so we need a delimiter at the end of the actual list whose diff is more than 1 than the last element of the given array.\\n\\nalso we need to consider negative inputs so abs differences should be taken.\\n\\nDry Run:\\n\\n0   1  2  4 7\\n\\nafter adding delimiter\\n\\n0  1   2   4   7   9\\n\\n\\n\\n0   1   2   4   7   9               //1-0==1\\n      i\\nj\\nk\\n\\n0   1   2   4   7   9               //2-1==1\\n           i\\n     j\\nk\\n\\n0   1   2   4   7   9               //4-2!=1          \"0->2\"\\n                i\\n          j\\nk\\n\\n0   1   2   4   7   9               //7-4!=1          \"4\"\\n                    i\\n               j\\n               k\\n\\t\\t\\t   \\n0   1   2   4   7   9               //9-7!=1          \"7\"\\n                          i\\n                     j\\n                    k\\n\\t\\t\\t   \\nFinal output:    [\"0->2\",\"4\",\"7\"]\\n \\n \\n```\\n class Solution {\\npublic:\\n    vector<string> summaryRanges(vector<int>& nums) {\\n\\n        \\n     \\n      vector<string> v;\\n      int i,j,k;\\n      i=1;                                                                          \\n      j=k=0;\\n      int n=nums.size();\\n      \\n      if(n==0){\\n        return v;\\n      }\\n        \\n      long long int last_element=nums[n-1];                                 \\n      nums.push_back(last_element + 2);                                           \\n      \\n      while(i<=n)\\n      {\\n        \\n        \\n            if(abs(abs(nums[i])-abs(nums[j]))==1)\\n            {\\n              i++;\\n              j++;\\n            }\\n\\n\\n            else \\n            {\\n              if(nums[j]!=nums[k])\\n                v.push_back(to_string(nums[k])+\"->\"+to_string(nums[j]));\\n              \\n              else if(nums[j]==nums[k])\\n                v.push_back(to_string(nums[k]));\\n              \\n              \\n              i++;\\n              j++;\\n              k=j;\\n            }\\n      }\\n      return v;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    vector<string> summaryRanges(vector<int>& nums) {\\n\\n        \\n     \\n      vector<string> v;\\n      int i,j,k;\\n      i=1;                                                                          \\n      j=k=0;\\n      int n=nums.size();\\n      \\n      if(n==0){\\n        return v;\\n      }",
                "codeTag": "Java"
            },
            {
                "id": 1805815,
                "title": "c-0ms-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> summaryRanges(vector<int>& nums) {\\n        vector<string> ans;\\n        int size = nums.size();\\n        if (size==0) \\n            return ans;\\n        \\n        for (int i = 0; i < size;){\\n            \\n            int low = i, hi = i;\\n            // traversing the array nums while array is contionus\\n            // loop will break when nums[hi]+1!= nums[hi+1]\\n            while (hi + 1 < size && nums[hi+1] == nums[hi] + 1) \\n                hi++;\\n            //checking if it a single elemnt or not\\n            if (hi > low) \\n                ans.push_back(to_string(nums[low]) + \"->\" + to_string(nums[hi]));\\n            else \\n                ans.push_back(to_string(nums[hi]));\\n            // increment  i by hi+1 \\n            i = hi+1;\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> summaryRanges(vector<int>& nums) {\\n        vector<string> ans;\\n        int size = nums.size();\\n        if (size==0) \\n            return ans;\\n        \\n        for (int i = 0; i < size;){\\n            \\n            int low = i, hi = i;\\n            // traversing the array nums while array is contionus\\n            // loop will break when nums[hi]+1!= nums[hi+1]\\n            while (hi + 1 < size && nums[hi+1] == nums[hi] + 1) \\n                hi++;\\n            //checking if it a single elemnt or not\\n            if (hi > low) \\n                ans.push_back(to_string(nums[low]) + \"->\" + to_string(nums[hi]));\\n            else \\n                ans.push_back(to_string(nums[hi]));\\n            // increment  i by hi+1 \\n            i = hi+1;\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3629631,
                "title": "best-solution-in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<String> summaryRanges(int[] nums) {\\n        \\n List<String> stringList = new ArrayList<>();\\n        int fromIndex = 0;\\n        int toIndex = nums.length;\\n\\n        for (int i = 0; i <= nums.length - 1; i++) {\\n            fromIndex = i;\\n\\n            while (i != nums.length - 1 && nums[i] + 1 == nums[i + 1]) {\\n                i++;\\n            }\\n\\n            toIndex = i;\\n\\n            if (fromIndex == toIndex) {\\n                stringList.add(\"\" + nums[fromIndex]);\\n\\n            } else {\\n                stringList.add(nums[fromIndex] + \"->\" + nums[toIndex]);\\n\\n            }\\n\\n        }\\n\\n        return stringList;\\n            }\\n}\\n```\\n\\n\\n![e78315ef-8a9d-492b-9908-e3917f23eb31_1674946036.087042.jpeg](https://assets.leetcode.com/users/images/5dd26c91-c808-4120-97c9-451138a705a1_1686578177.2812939.jpeg)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> summaryRanges(int[] nums) {\\n        \\n List<String> stringList = new ArrayList<>();\\n        int fromIndex = 0;\\n        int toIndex = nums.length;\\n\\n        for (int i = 0; i <= nums.length - 1; i++) {\\n            fromIndex = i;\\n\\n            while (i != nums.length - 1 && nums[i] + 1 == nums[i + 1]) {\\n                i++;\\n            }\\n\\n            toIndex = i;\\n\\n            if (fromIndex == toIndex) {\\n                stringList.add(\"\" + nums[fromIndex]);\\n\\n            } else {\\n                stringList.add(nums[fromIndex] + \"->\" + nums[toIndex]);\\n\\n            }\\n\\n        }\\n\\n        return stringList;\\n            }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3627479,
                "title": "c-easy-o-n",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> summaryRanges(vector<int>& v) {\\n         vector<string>d;\\n         if(v.size()==0)return d;\\n        int start,end;\\n        start = end = v[0];\\n        for(int i=1;i<v.size();i++){\\n            if(v[i]==v[i-1]+1){\\n                end ++;\\n            }\\n            else {\\n                 string s=\"\";\\n                if(start!=end){\\n                    s += to_string(start) + \"->\" + to_string(end);\\n                }\\n                else {\\n                    s += to_string(start);\\n                }\\n                d.push_back(s);\\n                start = end = v[i];\\n            }\\n        }\\n          string s=\"\";\\n               if(start!=end){\\n          \\n                    s += to_string(start) + \"->\" + to_string(end);\\n                }\\n                else {\\n                    s += to_string(start);\\n                }\\n                d.push_back(s);\\n                return d;\\n    }\\n};\\n```\\n![upvote (2).jpg](https://assets.leetcode.com/users/images/761c65c5-d659-4671-b359-da7b1abe3ba6_1686540971.6886976.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> summaryRanges(vector<int>& v) {\\n         vector<string>d;\\n         if(v.size()==0)return d;\\n        int start,end;\\n        start = end = v[0];\\n        for(int i=1;i<v.size();i++){\\n            if(v[i]==v[i-1]+1){\\n                end ++;\\n            }\\n            else {\\n                 string s=\"\";\\n                if(start!=end){\\n                    s += to_string(start) + \"->\" + to_string(end);\\n                }\\n                else {\\n                    s += to_string(start);\\n                }\\n                d.push_back(s);\\n                start = end = v[i];\\n            }\\n        }\\n          string s=\"\";\\n               if(start!=end){\\n          \\n                    s += to_string(start) + \"->\" + to_string(end);\\n                }\\n                else {\\n                    s += to_string(start);\\n                }\\n                d.push_back(s);\\n                return d;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 402364,
                "title": "golang-faster-than-100-00-of-go-online-submissions",
                "content": "```\\nfunc summaryRanges(nums []int) []string {\\n    if len(nums) == 0 {\\n\\t\\treturn nil\\n\\t}\\n    var res []string\\n    var head int = 0\\n    \\n    for i := range nums {\\n        if (i < len(nums)-1 && nums[i]+1 == nums[i+1]) {\\n            continue\\n        }\\n        if head == i {\\n            res = append(res, strconv.Itoa(nums[i]))\\n        } else {\\n            tmp := strconv.Itoa(nums[head]) + \"->\" + strconv.Itoa(nums[i])\\n            res = append(res, tmp)\\n        }\\n        \\n        head = i + 1\\n    }\\n    \\n    return res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc summaryRanges(nums []int) []string {\\n    if len(nums) == 0 {\\n\\t\\treturn nil\\n\\t}\\n    var res []string\\n    var head int = 0\\n    \\n    for i := range nums {\\n        if (i < len(nums)-1 && nums[i]+1 == nums[i+1]) {\\n            continue\\n        }\\n        if head == i {\\n            res = append(res, strconv.Itoa(nums[i]))\\n        } else {\\n            tmp := strconv.Itoa(nums[head]) + \"->\" + strconv.Itoa(nums[i])\\n            res = append(res, tmp)\\n        }\\n        \\n        head = i + 1\\n    }\\n    \\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3627688,
                "title": "c-easy-explanation-self-explanatory-code",
                "content": "# Approach\\nUsing 2 Pointers to mark the `prevIndex` and `currIndex` Of the list\\nFind the length of the list using the 2 pointer and generate the required list accordingly\\n\\n# Complexity\\n- Time complexity:  $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> summaryRanges(vector<int>& nums) {\\n        vector<string> ans;\\n        int n = nums.size(); \\n        int prevIndex = 0; \\n\\n        for(int i = 1; i <= n; i++) {\\n            if(i < n and nums[i] == nums[i-1]+1) {\\n                \\n                continue;\\n            } else {\\n                int currIndex = i-1; // Store the current index as i-1\\n                if(currIndex == prevIndex) {\\n                    // If the range has only one element, add it to the result\\n                    ans.push_back(to_string(nums[prevIndex]));\\n                } else {\\n                    // If the range has more than one element, add the range to the result\\n                    ans.push_back(to_string(nums[prevIndex]) + \"->\" + to_string(nums[currIndex]));\\n                }\\n                prevIndex = i; // Update the previous index to the current index\\n            }\\n        }\\n     \\n        return ans; \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> summaryRanges(vector<int>& nums) {\\n        vector<string> ans;\\n        int n = nums.size(); \\n        int prevIndex = 0; \\n\\n        for(int i = 1; i <= n; i++) {\\n            if(i < n and nums[i] == nums[i-1]+1) {\\n                \\n                continue;\\n            } else {\\n                int currIndex = i-1; // Store the current index as i-1\\n                if(currIndex == prevIndex) {\\n                    // If the range has only one element, add it to the result\\n                    ans.push_back(to_string(nums[prevIndex]));\\n                } else {\\n                    // If the range has more than one element, add the range to the result\\n                    ans.push_back(to_string(nums[prevIndex]) + \"->\" + to_string(nums[currIndex]));\\n                }\\n                prevIndex = i; // Update the previous index to the current index\\n            }\\n        }\\n     \\n        return ans; \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3108805,
                "title": "python3-solution",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def summaryRanges(self,nums:List[int])->List[int]:\\n        if not nums:\\n            return None\\n\\n        ans=[]\\n        j=0\\n        for i in range(len(nums)):\\n            if i+1==len(nums) or nums[i]+1!=nums[i+1]:\\n                if j==i:\\n                    ans.append(str(nums[i]))\\n\\n                else:\\n                    ans.append(str(nums[j])+\"->\"+str(nums[i]))\\n                j=i+1\\n\\n        return ans                            \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def summaryRanges(self,nums:List[int])->List[int]:\\n        if not nums:\\n            return None\\n\\n        ans=[]\\n        j=0\\n        for i in range(len(nums)):\\n            if i+1==len(nums) or nums[i]+1!=nums[i+1]:\\n                if j==i:\\n                    ans.append(str(nums[i]))\\n\\n                else:\\n                    ans.append(str(nums[j])+\"->\"+str(nums[i]))\\n                j=i+1\\n\\n        return ans                            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3628597,
                "title": "easy-c-solution-intuitive",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> summaryRanges(vector<int>& a) {\\n        int i,j,k,c=0;\\n        vector<string>v;\\n        i=0;\\n        if(a.size()==0)\\n        return v;\\n        while(i<a.size()-1){\\n            if(a[i+1]-a[i]>1){\\n                v.push_back(to_string(a[i]));\\n                i++;\\n            } else{\\n                j=i+1;\\n                k=i;\\n                while(j<a.size() and (a[j])<=1+a[k]){\\n                    j++;\\n                    k++;\\n                }\\n                string s=to_string(a[i])+\"->\"+to_string(a[j-1]);\\n                v.push_back(s);\\n                i=j;\\n            }\\n            \\n        }\\n        if(i<a.size()){\\n            v.push_back(to_string(a[i]));\\n        }\\n        return v;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> summaryRanges(vector<int>& a) {\\n        int i,j,k,c=0;\\n        vector<string>v;\\n        i=0;\\n        if(a.size()==0)\\n        return v;\\n        while(i<a.size()-1){\\n            if(a[i+1]-a[i]>1){\\n                v.push_back(to_string(a[i]));\\n                i++;\\n            } else{\\n                j=i+1;\\n                k=i;\\n                while(j<a.size() and (a[j])<=1+a[k]){\\n                    j++;\\n                    k++;\\n                }\\n                string s=to_string(a[i])+\"->\"+to_string(a[j-1]);\\n                v.push_back(s);\\n                i=j;\\n            }\\n            \\n        }\\n        if(i<a.size()){\\n            v.push_back(to_string(a[i]));\\n        }\\n        return v;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 914262,
                "title": "python-simple-intuitive-solution-o-n",
                "content": "```\\nclass Solution:\\n    def getStr(self, first, last):\\n        return str(first) if first == last else f\"{first}->{last}\"\\n\\n    def summaryRanges(self, nums: List[int]) -> List[str]:\\n        if len(nums) == 0:\\n            return nums\\n        \\n        res = []\\n        first = nums[0]\\n        for i in range(1, len(nums)):\\n            if nums[i-1]+1 != nums[i]:\\n                res.append(self.getStr(first, nums[i-1]))\\n                first = nums[i]\\n                \\n        res.append(self.getStr(first, nums[-1]))\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getStr(self, first, last):\\n        return str(first) if first == last else f\"{first}->{last}\"\\n\\n    def summaryRanges(self, nums: List[int]) -> List[str]:\\n        if len(nums) == 0:\\n            return nums\\n        \\n        res = []\\n        first = nums[0]\\n        for i in range(1, len(nums)):\\n            if nums[i-1]+1 != nums[i]:\\n                res.append(self.getStr(first, nums[i-1]))\\n                first = nums[i]\\n                \\n        res.append(self.getStr(first, nums[-1]))\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 63243,
                "title": "easy-java-solution-9-lines",
                "content": "    public List<String> summaryRanges(int[] nums){\\n        List<String> list = new ArrayList<>();\\n        int n = nums.length;\\n        for(int i = 0, j = 1; j <= n; j++){\\n            if(j == n || nums[j] > nums[j-1] + 1){\\n              list.add(Integer.toString(nums[i]) + (i == j-1 ? \"\" : \"->\" + Integer.toString(nums[j-1])));\\n              i = j;\\n            }\\n        }\\n        return list;\\n    }",
                "solutionTags": [],
                "code": "    public List<String> summaryRanges(int[] nums){\\n        List<String> list = new ArrayList<>();\\n        int n = nums.length;\\n        for(int i = 0, j = 1; j <= n; j++){\\n            if(j == n || nums[j] > nums[j-1] + 1){\\n              list.add(Integer.toString(nums[i]) + (i == j-1 ? \"\" : \"->\" + Integer.toString(nums[j-1])));\\n              i = j;\\n            }\\n        }\\n        return list;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3627800,
                "title": "easiest-python-o-n-solution-clearly-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem requires summarizing consecutive ranges of numbers in a given list. We can iterate through the list and identify the start and end of each range by checking if the numbers are consecutive.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCheck if the input list is empty. If it is, return an empty list as there are no ranges to summarize.\\n1.Initialize an empty list to store the summary ranges.\\n\\n2.Initialize variables start and end to the first element of the list.\\n\\n3.Iterate through the numbers starting from the second element.\\n\\n4.If the current number is consecutive to the previous number, update the end of the range.\\n\\n5.If the current number is not consecutive, add the current range to the result list.\\n\\n6.Reset the start and end variables to the current number.\\n\\n7.After the loop, add the last range to the result list.\\nReturn the list of summary ranges.\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def summaryRanges(self, nums: List[int]) -> List[str]:\\n    \\n        # Check if the input list is empty\\n        if nums == []:\\n            return []\\n        \\n        # Initialize the list to store the summary ranges\\n        ranges = []\\n        \\n        # Initialize variables for the start and end of the range\\n        start = nums[0]\\n        end = nums[0]\\n\\n        # Iterate through the numbers starting from the second element\\n        for num in nums[1:]:\\n            if num == end + 1:\\n                # The number is consecutive, update the end of the range\\n                end = num\\n            else:\\n                # The number is not consecutive, add the current range to the result list\\n                if start == end:\\n                    ranges.append(str(start))\\n                else:\\n                    ranges.append(f\"{start}->{end}\")\\n                \\n                # Reset the start and end to the current number\\n                start = num\\n                end = num\\n\\n        # Add the last range to the result list\\n        if start == end:\\n            ranges.append(str(start))\\n        else:\\n            ranges.append(f\"{start}->{end}\")\\n        \\n        return ranges\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def summaryRanges(self, nums: List[int]) -> List[str]:\\n    \\n        # Check if the input list is empty\\n        if nums == []:\\n            return []\\n        \\n        # Initialize the list to store the summary ranges\\n        ranges = []\\n        \\n        # Initialize variables for the start and end of the range\\n        start = nums[0]\\n        end = nums[0]\\n\\n        # Iterate through the numbers starting from the second element\\n        for num in nums[1:]:\\n            if num == end + 1:\\n                # The number is consecutive, update the end of the range\\n                end = num\\n            else:\\n                # The number is not consecutive, add the current range to the result list\\n                if start == end:\\n                    ranges.append(str(start))\\n                else:\\n                    ranges.append(f\"{start}->{end}\")\\n                \\n                # Reset the start and end to the current number\\n                start = num\\n                end = num\\n\\n        # Add the last range to the result list\\n        if start == end:\\n            ranges.append(str(start))\\n        else:\\n            ranges.append(f\"{start}->{end}\")\\n        \\n        return ranges\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3627141,
                "title": "java-easy-solution-beats-88-9-lines-clean-code",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public List<String> summaryRanges(int[] nums) {\\n    int start, end, n = nums.length, i = 0;\\n    var ans = new ArrayList<String>();\\n\\n    while (i<n) {\\n      for (start = end = nums[i]; i<n && end == nums[i]; i++, end++);\\n\\n      ans.add(\\n        end == start + 1\\n          ? \"\" + start\\n          : String.format(\"%d->%d\", start, end-1));\\n    }\\n    return ans;\\n  }\\n}\\n```\\nIf you like my solution, please upvote it!",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n  public List<String> summaryRanges(int[] nums) {\\n    int start, end, n = nums.length, i = 0;\\n    var ans = new ArrayList<String>();\\n\\n    while (i<n) {\\n      for (start = end = nums[i]; i<n && end == nums[i]; i++, end++);\\n\\n      ans.add(\\n        end == start + 1\\n          ? \"\" + start\\n          : String.format(\"%d->%d\", start, end-1));\\n    }\\n    return ans;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2704747,
                "title": "java-two-pointer-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nwe can use two pointers to mark the continous range.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nwe initilize two pointers start and end to 0 at first.\\nthen we check if difference between nums[i + 1] and nums[i] is 1 ,if that is true then increment end pointer,\\nelse check if its a number alone(start == end) or a range .if its a number alone just add the string value of that number,else add the range.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n) - since a single loop is used \\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n) - case were all the numbers are not continous\\n\\nplease upvote if you understand.\\n# Code\\n```\\nclass Solution {\\n    public List<String> summaryRanges(int[] nums) {\\n        \\n        ArrayList<String> ans = new ArrayList<>();\\n\\n        if(nums == null || nums.length == 0)\\n          return ans;\\n\\n\\n        int start = 0;\\n        int end = 0;\\n        int n = nums.length;\\n        int i = 0;        \\n        while(i < n)\\n        {\\n            if(i + 1 < n && nums[i + 1] - nums[i] == 1)\\n            {\\n                end++;\\n            }\\n            else {\\n              \\n              if(start == end)\\n              {\\n                  ans.add(String.valueOf(nums[end]));\\n              }\\n              else{\\n                  ans.add(nums[start] + \"->\" + nums[end]);\\n              }\\n\\n              end++;\\n              start = end;\\n            }\\n          i++;      \\n        } \\n       return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Two Pointers",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> summaryRanges(int[] nums) {\\n        \\n        ArrayList<String> ans = new ArrayList<>();\\n\\n        if(nums == null || nums.length == 0)\\n          return ans;\\n\\n\\n        int start = 0;\\n        int end = 0;\\n        int n = nums.length;\\n        int i = 0;        \\n        while(i < n)\\n        {\\n            if(i + 1 < n && nums[i + 1] - nums[i] == 1)\\n            {\\n                end++;\\n            }\\n            else {\\n              \\n              if(start == end)\\n              {\\n                  ans.add(String.valueOf(nums[end]));\\n              }\\n              else{\\n                  ans.add(nums[start] + \"->\" + nums[end]);\\n              }\\n\\n              end++;\\n              start = end;\\n            }\\n          i++;      \\n        } \\n       return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 63385,
                "title": "c-concise-solution",
                "content": "        \\n    vector<string> summaryRanges(vector<int>& nums) {\\n        vector<string> ret;\\n        for (int i=0; i<nums.size(); i++) {\\n            int pre = nums[i];\\n            while (i+1<nums.size() && nums[i+1]==nums[i]+1)  \\n                i++;\\n            if (pre == nums[i])\\n                ret.push_back(to_string(pre));\\n            else\\n                ret.push_back(to_string(pre)+\"->\"+to_string(nums[i]));\\n        }\\n        return ret;\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "        \\n    vector<string> summaryRanges(vector<int>& nums) {\\n        vector<string> ret;\\n        for (int i=0; i<nums.size(); i++) {\\n            int pre = nums[i];\\n            while (i+1<nums.size() && nums[i+1]==nums[i]+1)  \\n                i++;\\n            if (pre == nums[i])\\n                ret.push_back(to_string(pre));\\n            else\\n                ret.push_back(to_string(pre)+\"->\"+to_string(nums[i]));\\n        }\\n        return ret;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3627383,
                "title": "beats-100-o-n-2-pointer-approach-full-optmized-code",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n![image.png](https://assets.leetcode.com/users/images/bf405874-a4e5-41f1-b9e1-cf1960056a42_1686538193.728684.png)\\n\\n- **Its Very Simple LOOK !!**\\n- Set to pointer start and end \\n- Start to set at the starting of the range and end for the end of the range \\n- if they are in continous range means next number is +1 , then end++ till you find the out of range is not +1.\\n- At last push the  element to vector;\\n- To handle to overflow caused by i+1 ,handle the last element sepeartly in the last !! \\n- Doone !!\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> summaryRanges(vector<int>& nums) {\\n        vector<string>jat;\\n        if(nums.size()==0) return jat;\\n        long long start=0,end=0;\\n        for(int i=0;i<nums.size()-1;i++)\\n        {\\n            \\n            if((nums[i]+1)==nums[i+1])\\n            {\\n                end++;\\n            }\\n            else\\n            {\\n                if(start==end)\\n                jat.push_back(to_string(nums[start]));\\n                else\\n                {\\n                    string s=to_string(nums[start]);\\n                    string e=to_string(nums[end]);\\n                    string final=s+\"->\"+e;\\n                    jat.push_back(final);\\n                }\\n                start=end+1;\\n                end+=1;\\n            }\\n        }\\n        if(start==end)\\n                jat.push_back(to_string(nums[start]));\\n                else\\n                {\\n                    string s=to_string(nums[start]);\\n                    string e=to_string(nums[end]);\\n                    string final=s+\"->\"+e;\\n                    jat.push_back(final);\\n                }\\n\\n        return jat;\\n        \\n    }\\n};\\n```\\n![7abc56.jpg](https://assets.leetcode.com/users/images/3d152983-a055-4d26-a160-a07c96ca205e_1686538681.7463417.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> summaryRanges(vector<int>& nums) {\\n        vector<string>jat;\\n        if(nums.size()==0) return jat;\\n        long long start=0,end=0;\\n        for(int i=0;i<nums.size()-1;i++)\\n        {\\n            \\n            if((nums[i]+1)==nums[i+1])\\n            {\\n                end++;\\n            }\\n            else\\n            {\\n                if(start==end)\\n                jat.push_back(to_string(nums[start]));\\n                else\\n                {\\n                    string s=to_string(nums[start]);\\n                    string e=to_string(nums[end]);\\n                    string final=s+\"->\"+e;\\n                    jat.push_back(final);\\n                }\\n                start=end+1;\\n                end+=1;\\n            }\\n        }\\n        if(start==end)\\n                jat.push_back(to_string(nums[start]));\\n                else\\n                {\\n                    string s=to_string(nums[start]);\\n                    string e=to_string(nums[end]);\\n                    string final=s+\"->\"+e;\\n                    jat.push_back(final);\\n                }\\n\\n        return jat;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3108826,
                "title": "java-easy-solution-explained",
                "content": "---\\n# Please Upvote \\uD83D\\uDE07\\n---\\n``` java []\\nclass Solution {\\n    public List<String> summaryRanges(int[] nums) {\\n        List<String> ans = new ArrayList<>();   // initialise answer arraylist\\n        if (nums.length == 0) { // if nums is empty\\n            return ans;         // return empty arraylist\\n        }\\n        \\n        // assume the start and ends as the first element of nums\\n        int start = nums[0], end = nums[0];\\n        // we will iterate over nums, if the number is adjacent/consecutive\\n        // to \\'end\\', we will update \\'end\\'\\n        for (int n : nums) {\\n            // skip the first element of nums\\n            // we need to check from the second element of nums\\n            if (n == start) {\\n                continue;\\n            } \\n            // if say end is 6, and we see 7, end will be updated to 7\\n            else if (n == end + 1) {\\n                end = n;\\n            } \\n            // if we lose the consecutiveness, we will push the interval obtained so far\\n            else {\\n                // say start is 2 and end is 7, so we will add \"2->7\"\\n                // but say if we only have 2, i.e. no consecutiveness to both side of start/end\\n                // we will insert 2 only (start or end, start and end will be equal in that case\\n                String interval = (start != end)?\\n                (start + \"->\" + end) : (end + \"\");\\n                ans.add(interval);  // add the interval\\n                // we will begin afresh from the new value and iterate further to get more intervals\\n                start = end = n;\\n            }\\n        }\\n        \\n        // we will be left with a interval after the iteration is finished\\n        // so we will add that interval too\\n        String interval = (start != end)?\\n        (start + \"->\" + end) : (end + \"\");\\n        ans.add(interval);  // add the interval\\n\\n        return ans;     // return the answer arraylist\\n    }\\n}\\n\\n```\\n--- \\n### Clean solution:\\n``` java []\\nclass Solution {\\n    public List<String> summaryRanges(int[] nums) {\\n        List<String> ans = new ArrayList<>();   \\n        if (nums.length == 0) { \\n            return ans;        \\n        }\\n        \\n        int start = nums[0], end = nums[0];\\n        for (int n : nums) {\\n            if (n == start) {\\n                continue;\\n            } else if (n == end + 1) {\\n                end = n;\\n            } else {\\n                String interval = (start != end)?\\n                (start + \"->\" + end) : (end + \"\");\\n                ans.add(interval);  \\n                start = end = n;\\n            }\\n        }\\n        \\n        String interval = (start != end)?\\n        (start + \"->\" + end) : (end + \"\");\\n        ans.add(interval);  \\n\\n        return ans;     \\n    }\\n}\\n```\\n---\\n### Time complexity: $$O(n)$$\\n### Space complexity: $$O(n)$$",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "``` java []\\nclass Solution {\\n    public List<String> summaryRanges(int[] nums) {\\n        List<String> ans = new ArrayList<>();   // initialise answer arraylist\\n        if (nums.length == 0) { // if nums is empty\\n            return ans;         // return empty arraylist\\n        }\\n        \\n        // assume the start and ends as the first element of nums\\n        int start = nums[0], end = nums[0];\\n        // we will iterate over nums, if the number is adjacent/consecutive\\n        // to \\'end\\', we will update \\'end\\'\\n        for (int n : nums) {\\n            // skip the first element of nums\\n            // we need to check from the second element of nums\\n            if (n == start) {\\n                continue;\\n            } \\n            // if say end is 6, and we see 7, end will be updated to 7\\n            else if (n == end + 1) {\\n                end = n;\\n            } \\n            // if we lose the consecutiveness, we will push the interval obtained so far\\n            else {\\n                // say start is 2 and end is 7, so we will add \"2->7\"\\n                // but say if we only have 2, i.e. no consecutiveness to both side of start/end\\n                // we will insert 2 only (start or end, start and end will be equal in that case\\n                String interval = (start != end)?\\n                (start + \"->\" + end) : (end + \"\");\\n                ans.add(interval);  // add the interval\\n                // we will begin afresh from the new value and iterate further to get more intervals\\n                start = end = n;\\n            }\\n        }\\n        \\n        // we will be left with a interval after the iteration is finished\\n        // so we will add that interval too\\n        String interval = (start != end)?\\n        (start + \"->\" + end) : (end + \"\");\\n        ans.add(interval);  // add the interval\\n\\n        return ans;     // return the answer arraylist\\n    }\\n}\\n\\n```\n``` java []\\nclass Solution {\\n    public List<String> summaryRanges(int[] nums) {\\n        List<String> ans = new ArrayList<>();   \\n        if (nums.length == 0) { \\n            return ans;        \\n        }\\n        \\n        int start = nums[0], end = nums[0];\\n        for (int n : nums) {\\n            if (n == start) {\\n                continue;\\n            } else if (n == end + 1) {\\n                end = n;\\n            } else {\\n                String interval = (start != end)?\\n                (start + \"->\" + end) : (end + \"\");\\n                ans.add(interval);  \\n                start = end = n;\\n            }\\n        }\\n        \\n        String interval = (start != end)?\\n        (start + \"->\" + end) : (end + \"\");\\n        ans.add(interval);  \\n\\n        return ans;     \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2109717,
                "title": "kotlin-short-and-easy-to-understand-solution",
                "content": "```\\nclass Solution {\\n    fun summaryRanges(nums: IntArray): List<String> {\\n        if (nums.size == 1) return listOf(\"${nums[0]}\")\\n        \\n        var result = mutableListOf<String>()        \\n        var l = 0\\n        var r = 1\\n            \\n        while (r <= nums.size) {            \\n            if (r == nums.size || nums[r-1] + 1 != nums[r]) {\\n                if (r - l == 1) result.add(\"${nums[l]}\")\\n                else result.add(\"${nums[l]}->${nums[r-1]}\")\\n                l=r\\n            }\\n            r++\\n        }\\n        \\n        return result\\n    }\\n}\\n```\\nPlease upvote, if you like the solution)",
                "solutionTags": [
                    "Kotlin",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    fun summaryRanges(nums: IntArray): List<String> {\\n        if (nums.size == 1) return listOf(\"${nums[0]}\")\\n        \\n        var result = mutableListOf<String>()        \\n        var l = 0\\n        var r = 1\\n            \\n        while (r <= nums.size) {            \\n            if (r == nums.size || nums[r-1] + 1 != nums[r]) {\\n                if (r - l == 1) result.add(\"${nums[l]}\")\\n                else result.add(\"${nums[l]}->${nums[r-1]}\")\\n                l=r\\n            }\\n            r++\\n        }\\n        \\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1805674,
                "title": "short-and-easy-c-0ms-solution",
                "content": "```\\nclass Solution {\\n    public:\\n        vector<string> summaryRanges(vector<int>& nums) \\n        {\\n            int first=0,last=0,x=0, size=nums.size(); vector<string> ans;\\n            while(x<size)\\n            {   \\n                last=x;\\n                if(x==size-1 || nums[x]+1 != nums[x+1])     //range termination conditions\\n                {\\n                    string s=\"\";\\n                    first==last? s=to_string(nums[x]): s=to_string(nums[first])+\"->\"+to_string(nums[last]);\\n                    ans.push_back(s);\\n                    first=x+1;  //start of a new range\\n                }\\n                x++;\\n            }\\n            return ans;\\n        }\\n};\\n```\\n**PS**: \"0ms\" or \"100% faster, 100% lesser space\" on leetcode are not consistent, don\\'t focus on them. You might have written a most efficient code but still not get 0ms. **The only way to make sure you have written efficient code is to compare your solution with 0ms solution in submission section.**",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    public:\\n        vector<string> summaryRanges(vector<int>& nums) \\n        {\\n            int first=0,last=0,x=0, size=nums.size(); vector<string> ans;\\n            while(x<size)\\n            {   \\n                last=x;\\n                if(x==size-1 || nums[x]+1 != nums[x+1])     //range termination conditions\\n                {\\n                    string s=\"\";\\n                    first==last? s=to_string(nums[x]): s=to_string(nums[first])+\"->\"+to_string(nums[last]);\\n                    ans.push_back(s);\\n                    first=x+1;  //start of a new range\\n                }\\n                x++;\\n            }\\n            return ans;\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 914104,
                "title": "python-3-one-pass-and-an-explanation",
                "content": "**Disclaimer:** it\\'s one of the annoying questions with edge cases that are hard to pick up without being able to compile the code in an interview.\\n\\n**Idea:**\\nObvious edge cases are easy (when we have zero or one element).\\nThe main part starts with placing the first element into ```curr```.\\nThen we traverse through the rest of the list.\\nIf the current element is exactly 1 larger than the last element in ```curr```, it\\'s good: we\\'re building an interval by adding this element to ```curr```.\\nIf it is not a case, then we need to prepare the content of ```curr``` for being appended to ```res```.\\nIf ```curr``` has more than one element, it means that there is an interval, so let\\'s add the interval. Don\\'t forget to clean and update ```curr``` after that.\\nIf ```curr``` has exactly one element, it\\'s just a number. It still has to be added but the syntax will be different (no arrows). Don\\'t forget to clean and update ```curr``` after that.\\nHere is an annoying part: once you reached the end of nums, you need to \"manually\" add the last interval from ```curr```. Again, depending on how many elements are there, you will either add an interval (with an arrow), or just a number (without an arrow).\\n\\n```\\ndef summaryRanges(nums):\\n    if len(nums) == 0: return []\\n    if len(nums) == 1: return [str(nums[0])]\\n    res = []\\n    curr = []\\n    curr.append(nums[0])\\n    for i in range(1, len(nums)):\\n        if nums[i] - curr[-1] == 1:\\n            curr.append(nums[i])\\n        else:\\n            if len(curr) > 1:\\n                res.append(str(curr[0]) + \\'->\\' + str(curr[-1]))\\n                curr = []\\n                curr.append(nums[i])\\n            else:\\n                res.append(str(curr[-1]))\\n                curr = []\\n                curr.append(nums[i])\\n        if i == len(nums) - 1 and len(curr) == 1:\\n            res.append(str(nums[-1]))\\n        if i == len(nums) - 1 and len(curr) > 1:\\n            res.append(str(curr[0]) + \\'->\\' + str(curr[-1]))\\n    return res\\n\\t```\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```curr```\n```curr```\n```curr```\n```curr```\n```res```\n```curr```\n```curr```\n```curr```\n```curr```\n```curr```\n```\\ndef summaryRanges(nums):\\n    if len(nums) == 0: return []\\n    if len(nums) == 1: return [str(nums[0])]\\n    res = []\\n    curr = []\\n    curr.append(nums[0])\\n    for i in range(1, len(nums)):\\n        if nums[i] - curr[-1] == 1:\\n            curr.append(nums[i])\\n        else:\\n            if len(curr) > 1:\\n                res.append(str(curr[0]) + \\'->\\' + str(curr[-1]))\\n                curr = []\\n                curr.append(nums[i])\\n            else:\\n                res.append(str(curr[-1]))\\n                curr = []\\n                curr.append(nums[i])\\n        if i == len(nums) - 1 and len(curr) == 1:\\n            res.append(str(nums[-1]))\\n        if i == len(nums) - 1 and len(curr) > 1:\\n            res.append(str(curr[0]) + \\'->\\' + str(curr[-1]))\\n    return res\\n\\t```",
                "codeTag": "Python3"
            },
            {
                "id": 892482,
                "title": "simple-java-solution-using-two-pointers",
                "content": "```\\npublic List<String> summaryRanges(int[] nums) {\\n        List<String> ranges = new ArrayList<>();\\n\\n        if (nums.length == 0) {\\n            return ranges;\\n        }\\n\\n        int start = nums[0];\\n        int end = nums[0];\\n\\n        for (int i = 0; i < nums.length - 1; i++) {\\n            int curNum = nums[i];\\n            int nextNum = nums[i + 1];\\n\\n            if (nextNum - curNum == 1) {\\n                end++;\\n            } else {\\n                ranges.add(format(start, end));\\n                start = nextNum;\\n                end = nextNum;\\n            }\\n        }\\n\\n        ranges.add(format(start, end));\\n\\n        return ranges;\\n    }\\n\\n    private String format(int start, int end) {\\n        if (start == end) {\\n            return start + \"\";\\n        } else {\\n            return start + \"->\" + end;\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\npublic List<String> summaryRanges(int[] nums) {\\n        List<String> ranges = new ArrayList<>();\\n\\n        if (nums.length == 0) {\\n            return ranges;\\n        }\\n\\n        int start = nums[0];\\n        int end = nums[0];\\n\\n        for (int i = 0; i < nums.length - 1; i++) {\\n            int curNum = nums[i];\\n            int nextNum = nums[i + 1];\\n\\n            if (nextNum - curNum == 1) {\\n                end++;\\n            } else {\\n                ranges.add(format(start, end));\\n                start = nextNum;\\n                end = nextNum;\\n            }\\n        }\\n\\n        ranges.add(format(start, end));\\n\\n        return ranges;\\n    }\\n\\n    private String format(int start, int end) {\\n        if (start == end) {\\n            return start + \"\";\\n        } else {\\n            return start + \"->\" + end;\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 400926,
                "title": "1-line-in-js",
                "content": "```\\nconst summaryRanges = (nums, s = nums[0]) => \\n\\tnums.reduce((p,c,i) =>((c+1 !== nums[i+1] ? p.push(s === c ? `${c}` : `${s}->${c}`) : \\'\\') && (s = nums[i+1]), p), [])\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst summaryRanges = (nums, s = nums[0]) => \\n\\tnums.reduce((p,c,i) =>((c+1 !== nums[i+1] ? p.push(s === c ? `${c}` : `${s}->${c}`) : \\'\\') && (s = nums[i+1]), p), [])\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 63416,
                "title": "easy-to-understand-c-code",
                "content": "    vector<string> summaryRanges(vector<int>& nums) {\\n            vector<string> ret;\\n            string str;\\n            if(nums.size()==0)\\n                return ret;\\n            int start = nums[0];   \\n            int end=0;\\n            for(int i=1;i<nums.size();i++){\\n                str = to_string(start);\\n                if(nums[i]==nums[i-1]+1)\\n                    end = nums[i];\\n                if(nums[i]!=nums[i-1]+1){\\n                    if(end != 0)\\n                        str = str + \"->\" + to_string(end);\\n                    ret.push_back(str);\\n                    start = nums[i];\\n                    end = 0;\\n                }\\n            }\\n            if(end!=0)\\n                str = to_string(start) + \"->\" + to_string(end);\\n            if(end==0)\\n                str = to_string(start);\\n            ret.push_back(str);\\n            return ret;\\n        }",
                "solutionTags": [],
                "code": "    vector<string> summaryRanges(vector<int>& nums) {\\n            vector<string> ret;\\n            string str;\\n            if(nums.size()==0)\\n                return ret;\\n            int start = nums[0];   \\n            int end=0;\\n            for(int i=1;i<nums.size();i++){\\n                str = to_string(start);\\n                if(nums[i]==nums[i-1]+1)\\n                    end = nums[i];\\n                if(nums[i]!=nums[i-1]+1){\\n                    if(end != 0)\\n                        str = str + \"->\" + to_string(end);\\n                    ret.push_back(str);\\n                    start = nums[i];\\n                    end = 0;\\n                }\\n            }\\n            if(end!=0)\\n                str = to_string(start) + \"->\" + to_string(end);\\n            if(end==0)\\n                str = to_string(start);\\n            ret.push_back(str);\\n            return ret;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 63454,
                "title": "share-my-java-accepted-solution",
                "content": "   \\n    public List<String> summaryRanges(int[] nums) {\\n        List<String> res = new ArrayList<String>();\\n        if(nums == null || nums.length == 0)\\n            return res;\\n        int start = 0;\\n        int end = 0;\\n        \\n        while(end < nums.length){\\n            StringBuilder sb = new StringBuilder();\\n            while(end < nums.length - 1 && nums[end] == nums[end + 1] - 1){\\n                end ++;\\n            }\\n            if(start == end){\\n                sb.append(nums[start]);\\n                res.add(sb.toString());\\n            }else{\\n                sb.append(nums[start]);\\n                sb.append(\"->\");\\n                sb.append(nums[end]);\\n                res.add(sb.toString());\\n            }\\n            end++;\\n            start = end;\\n        }\\n        \\n        return res;\\n    }",
                "solutionTags": [],
                "code": "   \\n    public List<String> summaryRanges(int[] nums) {\\n        List<String> res = new ArrayList<String>();\\n        if(nums == null || nums.length == 0)\\n            return res;\\n        int start = 0;\\n        int end = 0;\\n        \\n        while(end < nums.length){\\n            StringBuilder sb = new StringBuilder();\\n            while(end < nums.length - 1 && nums[end] == nums[end + 1] - 1){\\n                end ++;\\n            }\\n            if(start == end){\\n                sb.append(nums[start]);\\n                res.add(sb.toString());\\n            }else{\\n                sb.append(nums[start]);\\n                sb.append(\"->\");\\n                sb.append(nums[end]);\\n                res.add(sb.toString());\\n            }\\n            end++;\\n            start = end;\\n        }\\n        \\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 4000883,
                "title": "simple-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<String> summaryRanges(int[] nums) {\\n        List<String> al = new ArrayList();\\n        for(int i = 0; i < nums.length; i++) {\\n            int a = nums[i];\\n            while(i < nums.length - 1 && nums[i] + 1 == nums[i+1]) {\\n                i++;\\n            }\\n            if(a == nums[i]) {\\n                al.add(\"\" + nums[i]);\\n            } else {\\n                al.add(a + \"->\" + nums[i]);\\n            }\\n        }\\n        return al;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> summaryRanges(int[] nums) {\\n        List<String> al = new ArrayList();\\n        for(int i = 0; i < nums.length; i++) {\\n            int a = nums[i];\\n            while(i < nums.length - 1 && nums[i] + 1 == nums[i+1]) {\\n                i++;\\n            }\\n            if(a == nums[i]) {\\n                al.add(\"\" + nums[i]);\\n            } else {\\n                al.add(a + \"->\" + nums[i]);\\n            }\\n        }\\n        return al;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3640135,
                "title": "c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> summaryRanges(vector<int>& nums) {\\n        \\n       vector<string> Res;\\n        \\n        if(nums.size() < 1)\\n           return Res;\\n        \\n        for(int i=0;i<nums.size();)\\n        {\\n            int low=i;\\n            int high=i;\\n            \\n            while(high+1 < nums.size() && nums[high+1] == nums[high]+1)\\n                high++;\\n            \\n            if(high > low)\\n                Res.push_back(to_string(nums[low]) + \"->\" + to_string(nums[high]));\\n            \\n            else\\n                Res.push_back(to_string(nums[high]));\\n            \\n            i=high+1;\\n            \\n        }  \\n        \\n        return Res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> summaryRanges(vector<int>& nums) {\\n        \\n       vector<string> Res;\\n        \\n        if(nums.size() < 1)\\n           return Res;\\n        \\n        for(int i=0;i<nums.size();)\\n        {\\n            int low=i;\\n            int high=i;\\n            \\n            while(high+1 < nums.size() && nums[high+1] == nums[high]+1)\\n                high++;\\n            \\n            if(high > low)\\n                Res.push_back(to_string(nums[low]) + \"->\" + to_string(nums[high]));\\n            \\n            else\\n                Res.push_back(to_string(nums[high]));\\n            \\n            i=high+1;\\n            \\n        }  \\n        \\n        return Res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3629731,
                "title": "two-pointer-technique-python-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo solve this problem we can follow a two pointer technique .\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe use a two pointer technique with i and j values at the zeroth index. we use a while loop to check whether further elements are included in the range . Therefore the while loop which we used inside is to get the exact two positions of the range . After the execution of while loop if the position of j doesn\\'t change the we can conclude that there is only one number in the range and we append only one number as string . Otherwise we append the number at position i with -> and number at position  j into the result .\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity is $$O(n)$$ . Though we have used two while loops we are traversing the nums list only once Hence the time complexity cannot be $$O(n^2)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nWe haven\\'t used any extra spaces so the space complexity is $$O(1)$$.\\nThe result list which are returning cannot be considered . Usage of normal variables takes a constant space.\\n```java []\\nclass Solution {\\n    public List<String> summaryRanges(int[] nums) {\\n        ArrayList<String> result = new ArrayList<>();\\n        int i = 0;\\n        int j = 0;\\n        int n = nums.length;\\n        while(j<n)\\n        {\\n            while(j<n-1 && nums[j+1] == nums[j]+1)\\n            {\\n                j+=1;\\n            }\\n            String temp = \"\";\\n            if(j == i)\\n            {\\n                temp = String.valueOf(nums[i]);\\n            }\\n            else\\n            {\\n                temp = String.valueOf(nums[i])+\"->\"+String.valueOf(nums[j]);\\n            }\\n            result.add(temp);\\n            j+=1;\\n            i = j;\\n        }\\n        return result;\\n    }\\n}\\n```\\n```python []\\nclass Solution:\\n    def summaryRanges(self, nums: List[int]) -> List[str]:\\n        result = []\\n        i,j = 0,0\\n        while i < len(nums) and j < len(nums):\\n            while j+1 <len(nums) and nums[j]+1==nums[j+1]:\\n                j+=1\\n            if nums[i]==nums[j]:\\n                result.append(str(nums[i]))\\n            else:\\n                result.append(str(nums[i])+\"->\"+str(nums[j]))\\n            j+=1\\n            i=j\\n        return result\\n```\\n\\n---\\n#### *Please don\\'t forget to upvote if you\\'ve liked my explanation.*\\n\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```java []\\nclass Solution {\\n    public List<String> summaryRanges(int[] nums) {\\n        ArrayList<String> result = new ArrayList<>();\\n        int i = 0;\\n        int j = 0;\\n        int n = nums.length;\\n        while(j<n)\\n        {\\n            while(j<n-1 && nums[j+1] == nums[j]+1)\\n            {\\n                j+=1;\\n            }\\n            String temp = \"\";\\n            if(j == i)\\n            {\\n                temp = String.valueOf(nums[i]);\\n            }\\n            else\\n            {\\n                temp = String.valueOf(nums[i])+\"->\"+String.valueOf(nums[j]);\\n            }\\n            result.add(temp);\\n            j+=1;\\n            i = j;\\n        }\\n        return result;\\n    }\\n}\\n```\n```python []\\nclass Solution:\\n    def summaryRanges(self, nums: List[int]) -> List[str]:\\n        result = []\\n        i,j = 0,0\\n        while i < len(nums) and j < len(nums):\\n            while j+1 <len(nums) and nums[j]+1==nums[j+1]:\\n                j+=1\\n            if nums[i]==nums[j]:\\n                result.append(str(nums[i]))\\n            else:\\n                result.append(str(nums[i])+\"->\"+str(nums[j]))\\n            j+=1\\n            i=j\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3628719,
                "title": "c-two-pointer-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> summaryRanges(vector<int>& nums) \\n    {\\n        int i = 0, j = 0, n =nums.size(),k;\\n        vector<string> ans;\\n        while(i<n)\\n        {\\n            k = i;\\n            j = i+1;\\n            while(j<n && nums[j]==nums[i]+1)\\n            {\\n                i++;j++;\\n            }\\n            if(i==k)\\n            {\\n                ans.push_back(to_string(nums[i]));\\n                i++;\\n            }else\\n            {\\n                ans.push_back(to_string(nums[k])+\"->\"+to_string(nums[i]));\\n                i = j;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> summaryRanges(vector<int>& nums) \\n    {\\n        int i = 0, j = 0, n =nums.size(),k;\\n        vector<string> ans;\\n        while(i<n)\\n        {\\n            k = i;\\n            j = i+1;\\n            while(j<n && nums[j]==nums[i]+1)\\n            {\\n                i++;j++;\\n            }\\n            if(i==k)\\n            {\\n                ans.push_back(to_string(nums[i]));\\n                i++;\\n            }else\\n            {\\n                ans.push_back(to_string(nums[k])+\"->\"+to_string(nums[i]));\\n                i = j;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3627690,
                "title": "easy-clean-code-c",
                "content": "\\nIf the adjacents are not consecutive numbers, we store 1 range in ans and like this all the ranges are formed.\\nAlso take care if the range consists of 1 element, it does not include an -> (start variable is taking care of that)\\n\\n```\\nclass Solution {\\npublic:\\n    vector<string> summaryRanges(vector<int>& nums) {\\n        vector<string> ans;\\n        string output = \"\";\\n        int end=0,start=0;\\n        while(end<nums.size()){\\n            if(output.length()==0) output+=to_string(nums[end]);\\n            else if(nums[end]!=nums[end-1]+1){\\n                if(start!=end-1) output+= \"->\" + to_string(nums[end-1]);\\n                ans.push_back(output);\\n                output=\"\";\\n                start = end;\\n                continue;\\n            }\\n            end++;\\n        }\\n        if(start!=end-1 && start!=end) output+= \"->\" + to_string(nums[end-1]);\\n        if(output.length()!=0) ans.push_back(output);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> summaryRanges(vector<int>& nums) {\\n        vector<string> ans;\\n        string output = \"\";\\n        int end=0,start=0;\\n        while(end<nums.size()){\\n            if(output.length()==0) output+=to_string(nums[end]);\\n            else if(nums[end]!=nums[end-1]+1){\\n                if(start!=end-1) output+= \"->\" + to_string(nums[end-1]);\\n                ans.push_back(output);\\n                output=\"\";\\n                start = end;\\n                continue;\\n            }\\n            end++;\\n        }\\n        if(start!=end-1 && start!=end) output+= \"->\" + to_string(nums[end-1]);\\n        if(output.length()!=0) ans.push_back(output);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3627631,
                "title": "simple-solution-beginner-friendly-100-faster",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSimple approach to do this\\n> Create an empty string vector __ans__\\n>Traverse the array\\n>>Take the element at the current index as the starting point\\n>>>While the next element is = previous element + 1\\n>>>>Move on to the next element\\n>>\\n>>If the current index points to the starting point\\n>>>Store the __to_string__(starting_point) in the vector\\n>>\\n>>Else\\n>>>Store __to_string__(starting_point) + \"->\" + __to_string__(ending_point) in the array\\n>>\\n>\\n>Return the Resultant vector \"__ans__\"\\n\\n##### to_string() : converts the integer data to string\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution //Runtime: 0 ms, faster than 100.00% of C++ online submissions for Summary Ranges.\\n{\\n  public:\\n    vector<string> summaryRanges(vector<int>& nums) \\n    {\\n        vector<string> ans;\\n        int len = nums.size(),start_point;\\n        for(int end_point = 0; end_point < len;end_point++)\\n        {\\n            start_point = nums[end_point];\\n            while(end_point+1 < len && nums[end_point+1] == nums[end_point] + 1)\\n                end_point++;\\n            if(start_point == nums[end_point])\\n                ans.push_back(to_string(start_point));\\n            else\\n                ans.push_back(to_string(start_point) + \"->\" + to_string(nums[end_point]));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution //Runtime: 0 ms, faster than 100.00% of C++ online submissions for Summary Ranges.\\n{\\n  public:\\n    vector<string> summaryRanges(vector<int>& nums) \\n    {\\n        vector<string> ans;\\n        int len = nums.size(),start_point;\\n        for(int end_point = 0; end_point < len;end_point++)\\n        {\\n            start_point = nums[end_point];\\n            while(end_point+1 < len && nums[end_point+1] == nums[end_point] + 1)\\n                end_point++;\\n            if(start_point == nums[end_point])\\n                ans.push_back(to_string(start_point));\\n            else\\n                ans.push_back(to_string(start_point) + \"->\" + to_string(nums[end_point]));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3627609,
                "title": "easy-solution-python",
                "content": "**Approach**\\nCreate an empty list called ranges to store the resulting ranges.\\n\\nInitialize start and end variables with the first element of the input nums list.\\n\\nIterate over the remaining elements of the nums list, starting from the second element.\\n\\nCheck if the current element (nums[i]) is consecutive to the previous element (end + 1). If it is, update the end variable to the current element. This means the current element extends the current range.\\n\\nIf the current element is not consecutive to the previous element, it means we have reached the end of a range. In this case, check if the start and end variables are the same, indicating a single element range. If they are the same, append str(start) to the ranges list. Otherwise, append str(start) + \"->\" + str(end) to the ranges list, representing the range from start to end.\\n\\nAfter the loop, there might be one last range remaining. Check if start is equal to end, and append the appropriate string representation to the ranges list.\\n\\nFinally, return the ranges list containing the smallest sorted list of ranges.\\n\\n```\\nclass Solution:\\n    def summaryRanges(self, nums: List[int]) -> List[str]:\\n        if not nums:\\n            return []\\n        \\n        ranges = []\\n        start = end = nums[0]\\n        \\n        for i in range(1, len(nums)):\\n            if nums[i] == end + 1:\\n                end = nums[i]\\n            else:\\n                if start == end:\\n                    ranges.append(str(start))\\n                else:\\n                    ranges.append(str(start) + \"->\" + str(end))\\n                start = end = nums[i]\\n        \\n        if start == end:\\n            ranges.append(str(start))\\n        else:\\n            ranges.append(str(start) + \"->\" + str(end))\\n        \\n        return ranges\\n            \\n```\\n\\n\\n## If you like it,Please Upvote it:)\\n![image](https://assets.leetcode.com/users/images/8eb50331-e963-472d-bd05-7b026f193554_1686544177.9354348.jpeg)\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def summaryRanges(self, nums: List[int]) -> List[str]:\\n        if not nums:\\n            return []\\n        \\n        ranges = []\\n        start = end = nums[0]\\n        \\n        for i in range(1, len(nums)):\\n            if nums[i] == end + 1:\\n                end = nums[i]\\n            else:\\n                if start == end:\\n                    ranges.append(str(start))\\n                else:\\n                    ranges.append(str(start) + \"->\" + str(end))\\n                start = end = nums[i]\\n        \\n        if start == end:\\n            ranges.append(str(start))\\n        else:\\n            ranges.append(str(start) + \"->\" + str(end))\\n        \\n        return ranges\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3627230,
                "title": "time-space-100-beats-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> summaryRanges(vector<int>& nums) {\\n        int i = 0, j = 0, n =nums.size(),k;\\n        vector<string> ans;\\n        while(i<n){\\n            k = i;\\n            j = i+1;\\n            while(j<n && nums[j]==nums[i]+1){\\n                i++;j++;\\n            }\\n            if(i==k){\\n                ans.push_back(to_string(nums[i]));\\n                i++;\\n            }else{\\n                ans.push_back(to_string(nums[k])+\"->\"+to_string(nums[i]));\\n                i = j;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> summaryRanges(vector<int>& nums) {\\n        int i = 0, j = 0, n =nums.size(),k;\\n        vector<string> ans;\\n        while(i<n){\\n            k = i;\\n            j = i+1;\\n            while(j<n && nums[j]==nums[i]+1){\\n                i++;j++;\\n            }\\n            if(i==k){\\n                ans.push_back(to_string(nums[i]));\\n                i++;\\n            }else{\\n                ans.push_back(to_string(nums[k])+\"->\"+to_string(nums[i]));\\n                i = j;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2813243,
                "title": "two-pointer-python",
                "content": "```\\nclass Solution:\\n    def summaryRanges(self, nums):\\n        i, result, N = 0, [], len(nums)\\n        \\n        while i < N:\\n            beg = end = i\\n            while end < N - 1 and nums[end] + 1 == nums[end + 1]: end += 1\\n            result.append(str(nums[beg]) + (\"->\" + str(nums[end])) *(beg != end))     \\n            i = end + 1\\n        \\n        return result\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def summaryRanges(self, nums):\\n        i, result, N = 0, [], len(nums)\\n        \\n        while i < N:\\n            beg = end = i\\n            while end < N - 1 and nums[end] + 1 == nums[end + 1]: end += 1\\n            result.append(str(nums[beg]) + (\"->\" + str(nums[end])) *(beg != end))     \\n            i = end + 1\\n        \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2763141,
                "title": "easy-java-solution-beats-75",
                "content": "```\\nclass Solution {\\n    public List<String> summaryRanges(int[] nums) {\\n        List<String> result = new LinkedList<String>();\\n        if (nums == null || nums.length == 0) {\\n            return result;\\n        }\\n        for (int i = 0; i < nums.length; i ++) {\\n            if (i == nums.length - 1 || nums[i] != nums[i + 1] - 1) {\\n                result.add(nums[i] + \"\");\\n                continue;\\n            }\\n            int left = nums[i];\\n            int j = i + 1;\\n            for (; j < nums.length; j ++) {\\n                if (j == nums.length - 1 || nums[j] != nums[j + 1] - 1) {\\n                    break;\\n                }\\n            }\\n            result.add(left + \"->\" + nums[j]);\\n            i = j;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> summaryRanges(int[] nums) {\\n        List<String> result = new LinkedList<String>();\\n        if (nums == null || nums.length == 0) {\\n            return result;\\n        }\\n        for (int i = 0; i < nums.length; i ++) {\\n            if (i == nums.length - 1 || nums[i] != nums[i + 1] - 1) {\\n                result.add(nums[i] + \"\");\\n                continue;\\n            }\\n            int left = nums[i];\\n            int j = i + 1;\\n            for (; j < nums.length; j ++) {\\n                if (j == nums.length - 1 || nums[j] != nums[j + 1] - 1) {\\n                    break;\\n                }\\n            }\\n            result.add(left + \"->\" + nums[j]);\\n            i = j;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1905255,
                "title": "python-12ms-96-58-using-map",
                "content": "```\\nclass Solution(object):\\n    def summaryRanges(self, nums):\\n        ranges = []\\n        for n in nums:\\n            if not ranges or n > ranges[-1][-1] + 1:\\n                ranges += [],\\n            ranges[-1][1:] = n,\\n        return [\\'->\\'.join(map(str, r)) for r in ranges]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def summaryRanges(self, nums):\\n        ranges = []\\n        for n in nums:\\n            if not ranges or n > ranges[-1][-1] + 1:\\n                ranges += [],\\n            ranges[-1][1:] = n,\\n        return [\\'->\\'.join(map(str, r)) for r in ranges]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1808764,
                "title": "simple-and-intuitive-java-solution",
                "content": "With every range that we want to insert, we basically need to know the *start* and *end* of a particular range. So we can either maintain two such variables or an array of size *2* with index *0* representing the starting value and index *1* representing the ending value of a range.\\n\\nNext, we initialize starting value to be the first value in the array, and the ending value to be same as starting value.\\n\\n**Logic**\\nNow, we loop through the entire array and follow these steps:\\n1. If consecutive elements (Elements at index ```i``` and ```i + 1```) have a difference of *1*, we update *end* to be the next element (Element at index ```i + 1```).\\n2. Else, we add the current set of *start* and *end* values to our solution, and update start and end values, both to the next element in the array (Element at index ```i + 1```).\\n\\n**Creating Strings**\\n* If both *start* and *end* values are same, it indicates that there is only one element in this particular range. So the string that we will need is just *\"start\"* OR *\"end\"*\\n* Else, the string would be *start + \"->\" + end*\\n \\n```\\nclass Solution {\\n    public List<String> summaryRanges(int[] nums) {\\n\\t\\t// Solution list containing all ranges\\n        List<String> solution = new ArrayList<String>();\\n        \\n\\t\\t// Edge case condition\\n        if (nums.length == 0) {\\n            return solution;\\n        }\\n        \\n\\t\\t// currValues array\\n\\t\\t// *start* value at index 0\\n\\t\\t// *end* value at index 1\\n        int[] currValues = new int[2];\\n        currValues[0] = nums[0];\\n        currValues[1] = nums[0];\\n        \\n\\t\\t// Iterating through the entire array\\n        for (int i = 0; i < nums.length - 1; i++) {\\n\\t\\t\\n\\t\\t\\t// If consecutive elements differ by only 1.\\n\\t\\t\\t// We update the value of *end*\\n\\t\\t\\t// Else, we add the current range to our solution list\\n\\t\\t\\t// And update *start* and *end* values in *currValues*\\n            if (nums[i + 1] - nums[i] == 1) {\\n                currValues[1] = nums[i + 1];\\n            } else {\\n\\t\\t\\t\\t// Creating strings using the aforementioned steps\\n                StringBuilder currString = new StringBuilder(\"\" + currValues[0]);\\n                if (currValues[1] != currValues[0]) {\\n                    currString.append(\"->\" + currValues[1]);\\n                }\\n                solution.add(currString.toString());\\n                currValues[0] = nums[i + 1];\\n                currValues[1] = nums[i + 1];\\n            }\\n        }\\n        \\n\\t\\t// Creating the last string which is left to be inserted\\n        StringBuilder currString = new StringBuilder(\"\" + currValues[0]);\\n        if (currValues[1] != currValues[0]) {\\n            currString.append(\"->\" + currValues[1]);\\n        }\\n        solution.add(currString.toString());\\n        \\n        return solution;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```i```\n```i + 1```\n```i + 1```\n```i + 1```\n```\\nclass Solution {\\n    public List<String> summaryRanges(int[] nums) {\\n\\t\\t// Solution list containing all ranges\\n        List<String> solution = new ArrayList<String>();\\n        \\n\\t\\t// Edge case condition\\n        if (nums.length == 0) {\\n            return solution;\\n        }\\n        \\n\\t\\t// currValues array\\n\\t\\t// *start* value at index 0\\n\\t\\t// *end* value at index 1\\n        int[] currValues = new int[2];\\n        currValues[0] = nums[0];\\n        currValues[1] = nums[0];\\n        \\n\\t\\t// Iterating through the entire array\\n        for (int i = 0; i < nums.length - 1; i++) {\\n\\t\\t\\n\\t\\t\\t// If consecutive elements differ by only 1.\\n\\t\\t\\t// We update the value of *end*\\n\\t\\t\\t// Else, we add the current range to our solution list\\n\\t\\t\\t// And update *start* and *end* values in *currValues*\\n            if (nums[i + 1] - nums[i] == 1) {\\n                currValues[1] = nums[i + 1];\\n            } else {\\n\\t\\t\\t\\t// Creating strings using the aforementioned steps\\n                StringBuilder currString = new StringBuilder(\"\" + currValues[0]);\\n                if (currValues[1] != currValues[0]) {\\n                    currString.append(\"->\" + currValues[1]);\\n                }\\n                solution.add(currString.toString());\\n                currValues[0] = nums[i + 1];\\n                currValues[1] = nums[i + 1];\\n            }\\n        }\\n        \\n\\t\\t// Creating the last string which is left to be inserted\\n        StringBuilder currString = new StringBuilder(\"\" + currValues[0]);\\n        if (currValues[1] != currValues[0]) {\\n            currString.append(\"->\" + currValues[1]);\\n        }\\n        solution.add(currString.toString());\\n        \\n        return solution;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1807312,
                "title": "kotlin-trying-to-make-it-kotlin-style",
                "content": "```\\nclass Solution {\\n    fun summaryRanges(nums: IntArray): List<String> {\\n       var prev=0\\n       var groupPos=0\\n       return nums\\n                .groupBy{\\n                    if(it-1!=prev) groupPos++\\n\\n                    prev=it\\n                    groupPos\\n                }\\n                .values\\n                .map{\\n                    if(it.size==1)\"${it[0]}\"\\n                    else \"${it.first()}->${it.last()}\"\\n                }\\n                .toList()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun summaryRanges(nums: IntArray): List<String> {\\n       var prev=0\\n       var groupPos=0\\n       return nums\\n                .groupBy{\\n                    if(it-1!=prev) groupPos++\\n\\n                    prev=it\\n                    groupPos\\n                }\\n                .values\\n                .map{\\n                    if(it.size==1)\"${it[0]}\"\\n                    else \"${it.first()}->${it.last()}\"\\n                }\\n                .toList()\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1806308,
                "title": "scala-simple-fold-left",
                "content": "```scala\\nobject Solution {\\n  val fmtRange = (a: Int, b: Int) => if (a != b) s\"$a->$b\" else s\"$a\"\\n\\n  def ranges(nums: Array[Int]): List[(Int, Int)] =\\n    nums\\n      .foldLeft(List.empty[(Int, Int)]) { (acc, v) =>\\n        acc match {\\n          case (start, end) :: tail if end + 1 == v => (start, v) :: tail\\n          case _                                    => (v, v) :: acc\\n        }\\n      }\\n      .reverse\\n\\n  def summaryRanges(nums: Array[Int]): List[String] = ranges(nums).map(fmtRange.tupled)\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```scala\\nobject Solution {\\n  val fmtRange = (a: Int, b: Int) => if (a != b) s\"$a->$b\" else s\"$a\"\\n\\n  def ranges(nums: Array[Int]): List[(Int, Int)] =\\n    nums\\n      .foldLeft(List.empty[(Int, Int)]) { (acc, v) =>\\n        acc match {\\n          case (start, end) :: tail if end + 1 == v => (start, v) :: tail\\n          case _                                    => (v, v) :: acc\\n        }\\n      }\\n      .reverse\\n\\n  def summaryRanges(nums: Array[Int]): List[String] = ranges(nums).map(fmtRange.tupled)\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1806040,
                "title": "python-easy-o-n-solution-explained",
                "content": "```\\nclass Solution:\\n    def summaryRanges(self, nums: List[int]) -> List[str]:\\n        ans, i = [], 0                # take i to traverse the array, ans to fill the ranges\\n        while i < len(nums):          # traverse the array\\n            lower = upper = nums[i]   # for a range we need to find the upper and lower values\\n            while i < len(nums) and nums[i] == upper:  # increment the i and upper as well in order to check they are equal.\\n                i += 1\\n                upper += 1\\n            ans.append(str(lower) + (\"->\" + str(upper-1) if upper-lower-1 else \"\"))  # if upper-1 and lower both are equal append only lower, else append the range\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def summaryRanges(self, nums: List[int]) -> List[str]:\\n        ans, i = [], 0                # take i to traverse the array, ans to fill the ranges\\n        while i < len(nums):          # traverse the array\\n            lower = upper = nums[i]   # for a range we need to find the upper and lower values\\n            while i < len(nums) and nums[i] == upper:  # increment the i and upper as well in order to check they are equal.\\n                i += 1\\n                upper += 1\\n            ans.append(str(lower) + (\"->\" + str(upper-1) if upper-lower-1 else \"\"))  # if upper-1 and lower both are equal append only lower, else append the range\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1806028,
                "title": "faster-than-100-one-pass-c",
                "content": "We exploit the fact that the array is sorted. For a consecutive subarray from index i to j, nums[i] + j-i = nums[j] (since each pair of successive elements differs by 1, j-i pairs in total). If the above condition doesn\\'t hold, it means we\\'ve encountered a break in the solution and thus we need to note accordingly the size of the subarray we were working on until now. After this, we update the start of new subarray and continue checking the condition till failure/end of array, whichever comes first. In the latter case, since we haven\\'t failed, we need to note the last subarray separately outside the while loop.\\nNote that we can write the following code in a concise manner quite comfortably, I\\'ve used extra spaces for better readability :)\\nAlso make sure to handle border cases. Cheers!\\nP.S. Upvote if you liked it!\\n```\\nclass Solution {\\npublic:\\n    vector<string> summaryRanges(vector<int>& nums) {\\n        vector<string> res;\\n        int index = 0, i = 1;\\n        \\n        if(nums.size() <= 1)\\n        {\\n            if(nums.size() == 0) return res;\\n            res.push_back(to_string(nums[index]));\\n            return res;\\n        }\\n\\n        while(index + i < nums.size())\\n        {\\n            if(i + nums[index] != nums[index+i])\\n            {\\n                if(i == 1)\\n                {\\n                    res.push_back(to_string(nums[index]));\\n                }\\n                else\\n                {\\n                    string temp = to_string(nums[index]) + \"->\" + to_string(nums[index+i-1]);\\n                    res.push_back(temp);\\n                }\\n                index = index + i;\\n                i = 1; \\n            }\\n            else\\n            {\\n                i++;\\n            }\\n        }\\n        if(i == 1)\\n        {\\n            res.push_back(to_string(nums[index]));\\n        }\\n        else\\n        {\\n            string temp = to_string(nums[index]) + \"->\" + to_string(nums[index+i-1]);\\n            res.push_back(temp);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> summaryRanges(vector<int>& nums) {\\n        vector<string> res;\\n        int index = 0, i = 1;\\n        \\n        if(nums.size() <= 1)\\n        {\\n            if(nums.size() == 0) return res;\\n            res.push_back(to_string(nums[index]));\\n            return res;\\n        }\\n\\n        while(index + i < nums.size())\\n        {\\n            if(i + nums[index] != nums[index+i])\\n            {\\n                if(i == 1)\\n                {\\n                    res.push_back(to_string(nums[index]));\\n                }\\n                else\\n                {\\n                    string temp = to_string(nums[index]) + \"->\" + to_string(nums[index+i-1]);\\n                    res.push_back(temp);\\n                }\\n                index = index + i;\\n                i = 1; \\n            }\\n            else\\n            {\\n                i++;\\n            }\\n        }\\n        if(i == 1)\\n        {\\n            res.push_back(to_string(nums[index]));\\n        }\\n        else\\n        {\\n            string temp = to_string(nums[index]) + \"->\" + to_string(nums[index+i-1]);\\n            res.push_back(temp);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1805905,
                "title": "simple-java-solution-with-answer-and-question-explaination-o-n-time",
                "content": "Toughest part of this question is question statement itself.\\n\\nSimplifed statement -> \\nDivide array in intervals of [start,end] in a way that consecutive elements should come together.\\nfor example -> \\n[0,2,3,4,5,7,8,10]\\noutput => [\"0\",\"2->5\",\"7->8\",\"10\"]\\nsince 1 is not in input hence 0 cannot be combine further. next element is 2 which can be combined till 5 as 2,3,4,5 are in sequence. now 7,8 can combined again. and at last 10.\\n\\nfor input like [1,2,3,4] output would be [\"1->4\"]\\n\\nCode ->\\nwill use the above idea for each element nums[i] and check if next element is 1 + currElement. if yes cosume it. repeat inner loop till above condition matches. once inner loop finishes add interval to list.\\n```\\n public List<String> summaryRanges(int[] nums) {\\n        List<String> list = new ArrayList<>();\\n\\t\\t//loop every element\\n        for(int i=0;i<nums.length;i++) {\\n\\t\\t\\t//start element\\n            int start=nums[i];\\n\\t\\t\\t//iterate till current element +1 equals next element\\n            while(i<nums.length-1 && nums[i]+1==nums[i+1]) {\\n                i++;\\n            }\\n\\t\\t\\t//add only start, if above loop condition does not met\\n            if(start==nums[i]) {\\n                list.add(String.valueOf(start));\\n            } else {\\n\\t\\t\\t\\t//else it means answer exists and add start+\"->\"+nums[i] to answer\\n                list.add(start+\"->\"+nums[i]);                            \\n            }\\n        }\\n\\t\\t//return list of intervals\\n        return list;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n public List<String> summaryRanges(int[] nums) {\\n        List<String> list = new ArrayList<>();\\n\\t\\t//loop every element\\n        for(int i=0;i<nums.length;i++) {\\n\\t\\t\\t//start element\\n            int start=nums[i];\\n\\t\\t\\t//iterate till current element +1 equals next element\\n            while(i<nums.length-1 && nums[i]+1==nums[i+1]) {\\n                i++;\\n            }\\n\\t\\t\\t//add only start, if above loop condition does not met\\n            if(start==nums[i]) {\\n                list.add(String.valueOf(start));\\n            } else {\\n\\t\\t\\t\\t//else it means answer exists and add start+\"->\"+nums[i] to answer\\n                list.add(start+\"->\"+nums[i]);                            \\n            }\\n        }\\n\\t\\t//return list of intervals\\n        return list;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1805327,
                "title": "python-very-easy-2-pointer-approach",
                "content": "```\\n\\tdef summaryRanges(self, nums: List[int]) -> List[str]:\\n        op = []\\n        temp = \"\"\\n        i, j = 0, 0\\n        while i < len(nums):\\n            while j < len(nums)-1 and nums[j] == nums[j+1] - 1:\\n                j += 1\\n            if i == j:\\n                op.append(str(nums[i]))\\n            else:\\n                op.append(str(nums[i]) + \"->\" + str(nums[j]))\\n            j += 1\\n            i = j\\n        return op",
                "solutionTags": [
                    "Python",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```\\n\\tdef summaryRanges(self, nums: List[int]) -> List[str]:\\n        op = []\\n        temp = \"\"\\n        i, j = 0, 0\\n        while i < len(nums):\\n            while j < len(nums)-1 and nums[j] == nums[j+1] - 1:\\n                j += 1\\n            if i == j:\\n                op.append(str(nums[i]))\\n            else:\\n                op.append(str(nums[i]) + \"->\" + str(nums[j]))\\n            j += 1\\n            i = j\\n        return op",
                "codeTag": "Python3"
            },
            {
                "id": 1677097,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> summaryRanges(vector<int>& nums) {\\n        vector<string>ans;\\n        int i=0;\\n        while(i<nums.size())\\n        {\\n            int j=i;\\n            while(i+1<nums.size() && nums[i]==nums[i+1]-1)\\n            {\\n                i++;\\n            }\\n            if(i==j)\\n            {\\n                ans.push_back(to_string(nums[j]));\\n            }\\n            else\\n            {\\n                ans.push_back(to_string(nums[j])+\"->\"+to_string(nums[i]));\\n            }\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n***Please upvote if you have got any help from my code. Thank you.***",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> summaryRanges(vector<int>& nums) {\\n        vector<string>ans;\\n        int i=0;\\n        while(i<nums.size())\\n        {\\n            int j=i;\\n            while(i+1<nums.size() && nums[i]==nums[i+1]-1)\\n            {\\n                i++;\\n            }\\n            if(i==j)\\n            {\\n                ans.push_back(to_string(nums[j]));\\n            }\\n            else\\n            {\\n                ans.push_back(to_string(nums[j])+\"->\"+to_string(nums[i]));\\n            }\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1327739,
                "title": "java-solution-0-ms",
                "content": "```\\nclass Solution {\\n    public List<String> summaryRanges(int[] nums) {\\n        var result = new ArrayList<String>();\\n        StringBuilder sb = new StringBuilder();\\n        int i = 0;\\n        \\n        while (i < nums.length) {\\n            int temp = nums[i];\\n            sb.append(nums[i++]);\\n            \\n            while (i < nums.length && nums[i] - nums[i-1] == 1) i++;\\n            if (temp != nums[i-1]) sb.append(\"->\").append(nums[i-1]);\\n\\n            result.add(sb.toString());\\n            sb.setLength(0);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> summaryRanges(int[] nums) {\\n        var result = new ArrayList<String>();\\n        StringBuilder sb = new StringBuilder();\\n        int i = 0;\\n        \\n        while (i < nums.length) {\\n            int temp = nums[i];\\n            sb.append(nums[i++]);\\n            \\n            while (i < nums.length && nums[i] - nums[i-1] == 1) i++;\\n            if (temp != nums[i-1]) sb.append(\"->\").append(nums[i-1]);\\n\\n            result.add(sb.toString());\\n            sb.setLength(0);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 943337,
                "title": "python-single-pass-time-o-n-space-o-1",
                "content": "```\\nclass Solution:\\n    def summaryRanges(self, nums: List[int]) -> List[str]:\\n        ranges = []\\n        \\n        start = None        \\n        for i, n in enumerate(nums):\\n            if start is None:\\n                start = n\\n            if i == len(nums) - 1 or n < nums[i + 1] - 1:\\n                ranges.append(str(start) + \"->\" + str(n) if start != n else str(n))                \\n                start = None\\n            \\n        return ranges\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def summaryRanges(self, nums: List[int]) -> List[str]:\\n        ranges = []\\n        \\n        start = None        \\n        for i, n in enumerate(nums):\\n            if start is None:\\n                start = n\\n            if i == len(nums) - 1 or n < nums[i + 1] - 1:\\n                ranges.append(str(start) + \"->\" + str(n) if start != n else str(n))                \\n                start = None\\n            \\n        return ranges\\n```",
                "codeTag": "Java"
            },
            {
                "id": 913739,
                "title": "golang-idiomatic-solution",
                "content": "```\\nimport \"fmt\"\\n\\nfunc summaryRanges(nums []int) []string {\\n    var ans []string\\n    for i, j := 0, 0; j < len(nums); j++ {\\n        i = j\\n        for j + 1 < len(nums) && nums[j] + 1 == nums[j + 1] {\\n            j++\\n        }\\n        if i == j {\\n            ans = append(ans, fmt.Sprint(nums[i]))\\n        } else {\\n            ans = append(ans, fmt.Sprintf(\"%v->%v\", nums[i], nums[j]))\\n        }\\n    }   \\n    return ans\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nimport \"fmt\"\\n\\nfunc summaryRanges(nums []int) []string {\\n    var ans []string\\n    for i, j := 0, 0; j < len(nums); j++ {\\n        i = j\\n        for j + 1 < len(nums) && nums[j] + 1 == nums[j + 1] {\\n            j++\\n        }\\n        if i == j {\\n            ans = append(ans, fmt.Sprint(nums[i]))\\n        } else {\\n            ans = append(ans, fmt.Sprintf(\"%v->%v\", nums[i], nums[j]))\\n        }\\n    }   \\n    return ans\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 913717,
                "title": "c-with-explanation-100-runtime-100-memory-efficient",
                "content": "#### 100% fast and 100% memory efficient\\n#### for better explanation refer the video \\nhttps://youtu.be/wvpd_FvSNzo\\n```\\nclass Solution {\\npublic:\\n    vector<string> summaryRanges(vector<int>& nums) {\\n        vector<string> range; \\n        int n =  nums.size();\\n        for(int i = 0; i < n; i++) {\\n            int start =  nums[i];  // starting value\\n            \\n           // check until consecutive elements are there \\n            while(i+1 < n && nums[i+1] == nums[i]+1) {  \\n                i++;\\n            }\\n            \\n            // if end found then put start->end int the vector\\n                string s, e;\\n                if(start != nums[i]) {\\n                     s = to_string(start);\\n                     e = to_string(nums[i]);\\n                    \\n                     s = s + \"->\" + e; // start->end\\n                    range.push_back(s); \\n                    \\n                }\\n                else {\\n                    string str = to_string(start);\\n                    range.push_back(str); // if only one element is there\\n                }\\n            \\n        }\\n        return range;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> summaryRanges(vector<int>& nums) {\\n        vector<string> range; \\n        int n =  nums.size();\\n        for(int i = 0; i < n; i++) {\\n            int start =  nums[i];  // starting value\\n            \\n           // check until consecutive elements are there \\n            while(i+1 < n && nums[i+1] == nums[i]+1) {  \\n                i++;\\n            }\\n            \\n            // if end found then put start->end int the vector\\n                string s, e;\\n                if(start != nums[i]) {\\n                     s = to_string(start);\\n                     e = to_string(nums[i]);\\n                    \\n                     s = s + \"->\" + e; // start->end\\n                    range.push_back(s); \\n                    \\n                }\\n                else {\\n                    string str = to_string(start);\\n                    range.push_back(str); // if only one element is there\\n                }\\n            \\n        }\\n        return range;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 909410,
                "title": "python-o-n-faster-than-99",
                "content": "\\tclass Solution(object):\\n\\t\\tdef summaryRanges(self, nums):\\n\\t\\t\\tans=[]\\n\\n\\t\\t\\tfor i in nums:\\n\\t\\t\\t\\tif i-1 not in nums:\\n\\t\\t\\t\\t\\ty=i+1\\n\\t\\t\\t\\t\\twhile y in nums:\\n\\t\\t\\t\\t\\t\\ty+=1\\n\\t\\t\\t\\t\\tif i==y-1:\\n\\t\\t\\t\\t\\t\\tans.append(str(i))\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tans.append(str(i)+\"->\"+str(y-1))\\n\\t\\t\\treturn ans",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\tclass Solution(object):\\n\\t\\tdef summaryRanges(self, nums):\\n\\t\\t\\tans=[]\\n\\n\\t\\t\\tfor i in nums:\\n\\t\\t\\t\\tif i-1 not in nums:\\n\\t\\t\\t\\t\\ty=i+1\\n\\t\\t\\t\\t\\twhile y in nums:\\n\\t\\t\\t\\t\\t\\ty+=1\\n\\t\\t\\t\\t\\tif i==y-1:\\n\\t\\t\\t\\t\\t\\tans.append(str(i))\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tans.append(str(i)+\"->\"+str(y-1))\\n\\t\\t\\treturn ans",
                "codeTag": "Java"
            },
            {
                "id": 835781,
                "title": "runtime-0-ms-100-faster-easy-understanding",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> summaryRanges(vector<int>& nums) {\\n       if(nums.size()==0) return {};\\n       if(nums.size()==1) return {to_string(nums[0])}; \\n       int start=nums[0],end;\\n       vector<string> str;\\n       for(int i=1;i<nums.size();i++){\\n           if(nums[i-1]+1==nums[i]){\\n               if(i==nums.size()-1)\\n                   str.push_back(to_string(start)+\"->\"+to_string(nums[i]));\\n               continue;\\n           }else{\\n               end=nums[i-1];\\n               if(start==end)\\n                   str.push_back(to_string(start));\\n               else \\n                   str.push_back(to_string(start)+\"->\"+to_string(end));\\n               start=nums[i];\\n               if(i==nums.size()-1)\\n                   str.push_back(to_string(start));\\n           }\\n       }\\n       return str;\\n    }\\n};\\n```\\n**Feel free to ask any question in the comment section.**\\nI hope that you\\'ve found the solution useful.\\nIn that case, **please do upvote and encourage me** to on my quest to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> summaryRanges(vector<int>& nums) {\\n       if(nums.size()==0) return {};\\n       if(nums.size()==1) return {to_string(nums[0])}; \\n       int start=nums[0],end;\\n       vector<string> str;\\n       for(int i=1;i<nums.size();i++){\\n           if(nums[i-1]+1==nums[i]){\\n               if(i==nums.size()-1)\\n                   str.push_back(to_string(start)+\"->\"+to_string(nums[i]));\\n               continue;\\n           }else{\\n               end=nums[i-1];\\n               if(start==end)\\n                   str.push_back(to_string(start));\\n               else \\n                   str.push_back(to_string(start)+\"->\"+to_string(end));\\n               start=nums[i];\\n               if(i==nums.size()-1)\\n                   str.push_back(to_string(start));\\n           }\\n       }\\n       return str;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 63394,
                "title": "14-line-one-pass-c-answer-easy-to-understand",
                "content": "    vector<string> summaryRanges(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<string> res;\\n        int i = 0;\\n        while(i<n){\\n            res.push_back(to_string(nums[i]));\\n            int j = i+1;\\n            while(j<n && nums[j]==nums[j-1]+1)++j;\\n            if(j>i+1){//more than one consecutive number\\n                res.back()+=\"->\"+to_string(nums[j-1]);\\n            }//else just single number\\n            i=j;\\n        }\\n        return res;\\n    }",
                "solutionTags": [],
                "code": "    vector<string> summaryRanges(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<string> res;\\n        int i = 0;\\n        while(i<n){\\n            res.push_back(to_string(nums[i]));\\n            int j = i+1;\\n            while(j<n && nums[j]==nums[j-1]+1)++j;\\n            if(j>i+1){//more than one consecutive number\\n                res.back()+=\"->\"+to_string(nums[j-1]);\\n            }//else just single number\\n            i=j;\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 63417,
                "title": "python-o-n-time-space",
                "content": "    class Solution:\\n        # @param {integer[]} nums\\n        # @return {string[]}\\n        def summaryRanges(self, nums):\\n            result = []\\n            if not nums: return result\\n            start = current = None\\n            for num in nums:\\n                if start == None:\\n                    start = current = num\\n                elif num == current + 1:\\n                    current = num\\n                else:\\n                    result.append(self.generateStringRange(start, current))\\n                    start = current = num\\n            result.append(self.generateStringRange(start, current))\\n            return result\\n        \\n        \\n        def generateStringRange(self, start, end):\\n            result = str(start)\\n            if start != end: result += \"->\" + str(end)\\n            return result",
                "solutionTags": [],
                "code": "class Solution:\\n        # @param {integer[]}",
                "codeTag": "Java"
            },
            {
                "id": 63464,
                "title": "0ms-c-solution-easy-to-understand",
                "content": "    char** summaryRanges(int* nums, int numsSize, int* returnSize) {\\n        char ret[100][50] = {{0}};\\n        int count =0;\\n        int i;\\n        int left, right, prev;\\n        char** summary = NULL;\\n        \\n        if (numsSize == 0)\\n            return NULL;\\n        \\n        left = nums[0];\\n        prev = left;\\n        for (i = 1; i < numsSize; i++)\\n        {\\n            if (nums[i] == prev + 1)\\n            {\\n                prev = nums[i];\\n            }\\n            else\\n            {\\n                right = prev;\\n    \\n    \\t\\t\\tif(left != right)\\n    \\t\\t\\t\\tsprintf(ret[count], \"%d->%d\", left, right);\\n    \\t\\t\\telse\\n    \\t\\t\\t\\tsprintf(ret[count], \"%d\", left);\\n    \\n                count++;\\n                left = nums[i];\\n                prev = left;\\n            }\\n        }\\n        \\n        right = prev;\\n    \\tif(left != right)\\n    \\t\\tsprintf(ret[count], \"%d->%d\", left, right);\\n    \\telse\\n    \\t\\tsprintf(ret[count], \"%d\", left);\\n        count++;\\n    \\n    \\t*returnSize = count;\\n    \\n    \\tsummary = (char**)malloc(sizeof(char*)*count);\\n    \\n    \\tfor (i=0; i< count; i++)\\n    \\t{\\n    \\t\\tchar *st = (char*)malloc(sizeof(char)*50);\\n    \\t\\tsprintf(st, \"%s\", ret[i]);\\n    \\t\\tsummary[i] = st;\\n    \\t}\\n    \\t\\n    \\treturn summary;\\n    }",
                "solutionTags": [],
                "code": "    char** summaryRanges(int* nums, int numsSize, int* returnSize) {\\n        char ret[100][50] = {{0}};\\n        int count =0;\\n        int i;\\n        int left, right, prev;\\n        char** summary = NULL;\\n        \\n        if (numsSize == 0)\\n            return NULL;\\n        \\n        left = nums[0];\\n        prev = left;\\n        for (i = 1; i < numsSize; i++)\\n        {\\n            if (nums[i] == prev + 1)\\n            {\\n                prev = nums[i];\\n            }\\n            else\\n            {\\n                right = prev;\\n    \\n    \\t\\t\\tif(left != right)\\n    \\t\\t\\t\\tsprintf(ret[count], \"%d->%d\", left, right);\\n    \\t\\t\\telse\\n    \\t\\t\\t\\tsprintf(ret[count], \"%d\", left);\\n    \\n                count++;\\n                left = nums[i];\\n                prev = left;\\n            }\\n        }\\n        \\n        right = prev;\\n    \\tif(left != right)\\n    \\t\\tsprintf(ret[count], \"%d->%d\", left, right);\\n    \\telse\\n    \\t\\tsprintf(ret[count], \"%d\", left);\\n        count++;\\n    \\n    \\t*returnSize = count;\\n    \\n    \\tsummary = (char**)malloc(sizeof(char*)*count);\\n    \\n    \\tfor (i=0; i< count; i++)\\n    \\t{\\n    \\t\\tchar *st = (char*)malloc(sizeof(char)*50);\\n    \\t\\tsprintf(st, \"%s\", ret[i]);\\n    \\t\\tsummary[i] = st;\\n    \\t}\\n    \\t\\n    \\treturn summary;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3629954,
                "title": "explained-with-cases-0-ms-faster-than-100-6-9-mb-memory-usage-1-loop-solution",
                "content": "```c++\\nclass Solution {\\npublic:\\n    vector<string> summaryRanges(vector<int>& nums) {\\n\\t\\t// answer vector\\n        vector<string> ans;\\n        \\n\\t\\t// a storage variable to store if the elements in the array are continuous\\n\\t\\t// for example, 1,2,3\\n\\t\\t// in this case, it will store the index of 1\\n        int continuous = -1;\\n        \\n\\t\\t// we don\\'t traverse till the last element in this solution.\\n\\t\\t// we travel only till the n - 1 element\\n\\t\\t// to prevent the last element from missing the traversal, we add this value\\n        nums.push_back(INT_MIN);\\n        \\n        for (int i = 0; i < nums.size() - 1; i++) {\\n\\t\\t\\t// checks if the continuous variable currently doesn\\'t hold any index\\n\\t\\t\\t// that means a continuous range hasn\\'t appeared yet\\n\\t\\t\\t// then, we store the index of the first element in this variable, if such index appears\\n            if ((long) nums[i + 1] - nums[i] == 1 && continuous == -1) {\\n                continuous = i;\\n            }\\n\\t\\t\\t\\n\\t\\t\\t// a continuous range is there, and it continues\\n\\t\\t\\t// we do nothing, and continue the traversal\\n\\t\\t\\telse if ((long) nums[i + 1] - nums[i] == 1 && continuous != -1) {\\n                continue;\\n            } \\n\\t\\t\\t\\n\\t\\t\\telse {\\n\\t\\t\\t\\t// continuous to be equal to -1 means variables not appearing in a chain.\\n\\t\\t\\t\\t// example - 0,1,2,7,8,9\\n\\t\\t\\t\\t// in this case, 7 matches this condition\\n\\t\\t\\t\\t// we push 7 in the result\\n                if (continuous == -1) {\\n                    ans.push_back(to_string(nums[i]));\\n                } \\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// a continuous range existed till now, but got broken\\n\\t\\t\\t\\t// push the starting index of the range and the current i\\n\\t\\t\\t\\telse {\\n                    ans.push_back(to_string(nums[continuous]) + \"->\" + to_string(nums[i]));\\n                    continuous = -1;\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```c++\\nclass Solution {\\npublic:\\n    vector<string> summaryRanges(vector<int>& nums) {\\n\\t\\t// answer vector\\n        vector<string> ans;\\n        \\n\\t\\t// a storage variable to store if the elements in the array are continuous\\n\\t\\t// for example, 1,2,3\\n\\t\\t// in this case, it will store the index of 1\\n        int continuous = -1;\\n        \\n\\t\\t// we don\\'t traverse till the last element in this solution.\\n\\t\\t// we travel only till the n - 1 element\\n\\t\\t// to prevent the last element from missing the traversal, we add this value\\n        nums.push_back(INT_MIN);\\n        \\n        for (int i = 0; i < nums.size() - 1; i++) {\\n\\t\\t\\t// checks if the continuous variable currently doesn\\'t hold any index\\n\\t\\t\\t// that means a continuous range hasn\\'t appeared yet\\n\\t\\t\\t// then, we store the index of the first element in this variable, if such index appears\\n            if ((long) nums[i + 1] - nums[i] == 1 && continuous == -1) {\\n                continuous = i;\\n            }\\n\\t\\t\\t\\n\\t\\t\\t// a continuous range is there, and it continues\\n\\t\\t\\t// we do nothing, and continue the traversal\\n\\t\\t\\telse if ((long) nums[i + 1] - nums[i] == 1 && continuous != -1) {\\n                continue;\\n            } \\n\\t\\t\\t\\n\\t\\t\\telse {\\n\\t\\t\\t\\t// continuous to be equal to -1 means variables not appearing in a chain.\\n\\t\\t\\t\\t// example - 0,1,2,7,8,9\\n\\t\\t\\t\\t// in this case, 7 matches this condition\\n\\t\\t\\t\\t// we push 7 in the result\\n                if (continuous == -1) {\\n                    ans.push_back(to_string(nums[i]));\\n                } \\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// a continuous range existed till now, but got broken\\n\\t\\t\\t\\t// push the starting index of the range and the current i\\n\\t\\t\\t\\telse {\\n                    ans.push_back(to_string(nums[continuous]) + \"->\" + to_string(nums[i]));\\n                    continuous = -1;\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3628444,
                "title": "100-0-ms-very-simple-proof",
                "content": "![image.png](https://assets.leetcode.com/users/images/6ceb64e4-95ae-43be-b8df-4b6f7323e7c5_1686557352.2486875.png)\\n\\n\\n# Complexity\\n- Time complexity:o(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:o(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<String> summaryRanges(int[] nums) {\\n        var ans = new ArrayList<String>();\\n        var n = nums.length;\\n        var sb = new StringBuilder();\\n        for(int i=0;i<n;i++){\\n            var start = nums[i];\\n            while(i+1<n && nums[i]+1==nums[i+1])i++;\\n            sb.append(start);\\n            if(start!=nums[i]) ans.add(sb.append(\"->\").append(nums[i]).toString());\\n            else ans.add(sb.toString());\\n            sb.setLength(0);\\n        }return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> summaryRanges(int[] nums) {\\n        var ans = new ArrayList<String>();\\n        var n = nums.length;\\n        var sb = new StringBuilder();\\n        for(int i=0;i<n;i++){\\n            var start = nums[i];\\n            while(i+1<n && nums[i]+1==nums[i+1])i++;\\n            sb.append(start);\\n            if(start!=nums[i]) ans.add(sb.append(\"->\").append(nums[i]).toString());\\n            else ans.add(sb.toString());\\n            sb.setLength(0);\\n        }return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3627651,
                "title": "c-easy-implementation",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> summaryRanges(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n == 1) return vector<string> {to_string(nums[0])};\\n        vector<string> ans;\\n        int c = 1;\\n        for(int i = 1; i < n; ++i){\\n            if(nums[i] != nums[i - 1] + 1){\\n                if(c == 1) ans.push_back(to_string(nums[i - 1]));\\n                else ans.push_back(to_string(nums[i - c]) + \"->\" + to_string(nums[i - 1]));\\n                c = 0;\\n            }\\n            if(i == n - 1){\\n                if(c == 0) ans.push_back(to_string(nums[i]));\\n                else ans.push_back(to_string(nums[i - c]) + \"->\" + to_string(nums[i]));\\n            }\\n            ++c;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> summaryRanges(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n == 1) return vector<string> {to_string(nums[0])};\\n        vector<string> ans;\\n        int c = 1;\\n        for(int i = 1; i < n; ++i){\\n            if(nums[i] != nums[i - 1] + 1){\\n                if(c == 1) ans.push_back(to_string(nums[i - 1]));\\n                else ans.push_back(to_string(nums[i - c]) + \"->\" + to_string(nums[i - 1]));\\n                c = 0;\\n            }\\n            if(i == n - 1){\\n                if(c == 0) ans.push_back(to_string(nums[i]));\\n                else ans.push_back(to_string(nums[i - c]) + \"->\" + to_string(nums[i]));\\n            }\\n            ++c;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3627619,
                "title": "easy-py",
                "content": "# Code\\n```\\nclass Solution:\\n    def summaryRanges(self, nums: List[int]) -> List[str]:\\n        if len(nums)==0:return []\\n        ans,i=[],0\\n        st=nums[0]\\n        for i in range(1,len(nums)):\\n            if nums[i]!=nums[i-1]+1:\\n                if st==nums[i-1]:\\n                    ans.append(str(st))\\n                else:\\n                    ans.append(str(st)+\"->\"+str(nums[i-1]))\\n                st=nums[i]\\n        if st==nums[-1]:\\n            ans.append(str(st))\\n        else:\\n            ans.append(str(st)+\"->\"+str(nums[len(nums)-1]))\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def summaryRanges(self, nums: List[int]) -> List[str]:\\n        if len(nums)==0:return []\\n        ans,i=[],0\\n        st=nums[0]\\n        for i in range(1,len(nums)):\\n            if nums[i]!=nums[i-1]+1:\\n                if st==nums[i-1]:\\n                    ans.append(str(st))\\n                else:\\n                    ans.append(str(st)+\"->\"+str(nums[i-1]))\\n                st=nums[i]\\n        if st==nums[-1]:\\n            ans.append(str(st))\\n        else:\\n            ans.append(str(st)+\"->\"+str(nums[len(nums)-1]))\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3627615,
                "title": "python-short-and-clean-1-liner-functional-programming",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$, including output.\\n\\nwhere, `n is length of nums.`\\n\\n# Code\\nImperative:\\n```python\\nclass Solution:\\n    def summaryRanges(self, nums: list[int]) -> list[str]:\\n        ranges = [[-inf, -inf]]\\n        for x in nums:\\n            if x == ranges[-1][1] + 1: ranges[-1][1] = x\\n            else: ranges.append([x, x])\\n\\n        return [f\\'{a}\\' if a == b else f\\'{a}->{b}\\' for a, b in islice(ranges, 1, None)]\\n\\n\\n```\\n\\nFunctional (multiline for readability):\\n```python\\nclass Solution:\\n    def summaryRanges(self, nums: list[int]) -> list[str]:\\n        make_range = lambda a, x: (setitem(a[-1], 1, x) if x == a[-1][1] + 1 else a.append([x, x])) or a\\n        ranges = reduce(make_range, nums, [[-inf, -inf]])\\n        return [f\\'{a}\\' if a == b else f\\'{a}->{b}\\' for a, b in islice(ranges, 1, None)]\\n\\n\\n```\\n\\nFunctional (1-liner, less readable):\\n```python\\nclass Solution:\\n    def summaryRanges(self, nums: list[int]) -> list[str]:\\n        return [f\\'{a}\\' if a == b else f\\'{a}->{b}\\' for a, b in islice(reduce(lambda a, x: (setitem(a[-1], 1, x) if x == a[-1][1] + 1 else a.append([x, x])) or a, nums, [[-inf, -inf]]), 1, None)]\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "String"
                ],
                "code": "```python\\nclass Solution:\\n    def summaryRanges(self, nums: list[int]) -> list[str]:\\n        ranges = [[-inf, -inf]]\\n        for x in nums:\\n            if x == ranges[-1][1] + 1: ranges[-1][1] = x\\n            else: ranges.append([x, x])\\n\\n        return [f\\'{a}\\' if a == b else f\\'{a}->{b}\\' for a, b in islice(ranges, 1, None)]\\n\\n\\n```\n```python\\nclass Solution:\\n    def summaryRanges(self, nums: list[int]) -> list[str]:\\n        make_range = lambda a, x: (setitem(a[-1], 1, x) if x == a[-1][1] + 1 else a.append([x, x])) or a\\n        ranges = reduce(make_range, nums, [[-inf, -inf]])\\n        return [f\\'{a}\\' if a == b else f\\'{a}->{b}\\' for a, b in islice(ranges, 1, None)]\\n\\n\\n```\n```python\\nclass Solution:\\n    def summaryRanges(self, nums: list[int]) -> list[str]:\\n        return [f\\'{a}\\' if a == b else f\\'{a}->{b}\\' for a, b in islice(reduce(lambda a, x: (setitem(a[-1], 1, x) if x == a[-1][1] + 1 else a.append([x, x])) or a, nums, [[-inf, -inf]]), 1, None)]\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3627275,
                "title": "four-easy-solutions-c-python-java-fastest",
                "content": "# Approach :Queue (C++)\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Code 1\\n```\\nclass Solution {\\npublic:\\n    vector<string> summaryRanges(vector<int>& nums) {\\n\\tdeque<int> q;\\n\\tvector<string> v;\\n\\tauto begin = nums.begin();\\n\\n\\twhile (begin != nums.end()){\\n\\t\\tif (q.empty() || *begin == q.back() + 1){\\n\\t\\t\\tq.push_back(*begin);\\n\\t\\t\\t++begin;\\n\\t\\t}\\n\\t\\tif (begin == nums.end() || *begin !=q.back() + 1){\\n\\t\\t\\tstring str;\\n\\t\\t\\tif (q.size() == 1)\\n\\t\\t\\t\\tstr = to_string(q.front());\\n\\t\\t\\telse\\n\\t\\t\\t\\tstr += to_string(q.front()) + \"->\" + to_string(q.back());\\n\\t\\t\\t\\n\\t\\t\\tv.push_back(str);\\n\\t\\t\\tq.clear();\\n\\t\\t}\\n\\t}\\n\\treturn v;\\n}\\n};\\n```\\n\\n# Approach :Vector ( C++)\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Code 2\\n```\\nclass Solution {\\npublic:\\n    vector<string> summaryRanges(vector<int>& nums) {\\n        vector<string> res;\\n        if (nums.size() <= 0) \\n            return res;\\n        long stt = nums[0];\\n        long curr = stt;\\n        string str = to_string(stt);\\n        for (int i = 1; i < nums.size(); i++) {\\n            if (nums[i] != curr + 1) {\\n                if (stt != curr) {\\n                    str = str + \"->\" + to_string(curr);\\n                }\\n                res.push_back(str);\\n                stt = nums[i];\\n                str = to_string(stt);\\n            }\\n            curr = nums[i];\\n        }\\n        if (stt == curr) {\\n            res.push_back(str);\\n        }\\n        else {\\n            str = str + \"->\" + to_string(curr);\\n            res.push_back(str);\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n# Approach :List (Python)\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Code 3\\n```\\nclass Solution(object):\\ndef summaryRanges(self, nums):\\n    \"\"\"\\n    :type nums: List[int]\\n    :rtype: List[str]\\n    \"\"\"\\n    if not nums: return []\\n    start = end = 0\\n    res=[]\\n    nums.append(nums[-1])\\n    for i in range (len(nums)-1):\\n        if nums[i+1] - nums[i] == 1:\\n            end+=1\\n        else:\\n            if start<end:\\n                res.append(str(nums[start])+\"->\"+str(nums[end]))\\n            else:\\n                res.append(str(nums[start]))\\n            start = end = i+1\\n    return res\\n```\\n\\n# Approach :List (Java)\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Code 4\\n```\\npublic class Solution {\\npublic List<String> summaryRanges(int[] nums) {\\n List<String> list =new ArrayList<String>();\\n if(nums.length==0)return list;\\n int index=0;\\n for(int i=0;i<nums.length-1;i++){\\n     \\n     if(nums[i+1]-nums[i]!=1){\\n         if(index!=i){list.add(nums[index]+\"->\"+nums[i]);}\\n         else list.add(Integer.toString(nums[index]));\\n         \\n         index=i+1;\\n     }\\n }\\n if(index==nums.length-1)list.add(Integer.toString(nums[index]));\\n else {list.add(nums[index]+\"->\"+nums[nums.length-1]);}\\n return list;\\n}\\n}\\n\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Array",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> summaryRanges(vector<int>& nums) {\\n\\tdeque<int> q;\\n\\tvector<string> v;\\n\\tauto begin = nums.begin();\\n\\n\\twhile (begin != nums.end()){\\n\\t\\tif (q.empty() || *begin == q.back() + 1){\\n\\t\\t\\tq.push_back(*begin);\\n\\t\\t\\t++begin;\\n\\t\\t}\\n\\t\\tif (begin == nums.end() || *begin !=q.back() + 1){\\n\\t\\t\\tstring str;\\n\\t\\t\\tif (q.size() == 1)\\n\\t\\t\\t\\tstr = to_string(q.front());\\n\\t\\t\\telse\\n\\t\\t\\t\\tstr += to_string(q.front()) + \"->\" + to_string(q.back());\\n\\t\\t\\t\\n\\t\\t\\tv.push_back(str);\\n\\t\\t\\tq.clear();\\n\\t\\t}\\n\\t}\\n\\treturn v;\\n}\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<string> summaryRanges(vector<int>& nums) {\\n        vector<string> res;\\n        if (nums.size() <= 0) \\n            return res;\\n        long stt = nums[0];\\n        long curr = stt;\\n        string str = to_string(stt);\\n        for (int i = 1; i < nums.size(); i++) {\\n            if (nums[i] != curr + 1) {\\n                if (stt != curr) {\\n                    str = str + \"->\" + to_string(curr);\\n                }\\n                res.push_back(str);\\n                stt = nums[i];\\n                str = to_string(stt);\\n            }\\n            curr = nums[i];\\n        }\\n        if (stt == curr) {\\n            res.push_back(str);\\n        }\\n        else {\\n            str = str + \"->\" + to_string(curr);\\n            res.push_back(str);\\n        }\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution(object):\\ndef summaryRanges(self, nums):\\n    \"\"\"\\n    :type nums: List[int]\\n    :rtype: List[str]\\n    \"\"\"\\n    if not nums: return []\\n    start = end = 0\\n    res=[]\\n    nums.append(nums[-1])\\n    for i in range (len(nums)-1):\\n        if nums[i+1] - nums[i] == 1:\\n            end+=1\\n        else:\\n            if start<end:\\n                res.append(str(nums[start])+\"->\"+str(nums[end]))\\n            else:\\n                res.append(str(nums[start]))\\n            start = end = i+1\\n    return res\\n```\n```\\npublic class Solution {\\npublic List<String> summaryRanges(int[] nums) {\\n List<String> list =new ArrayList<String>();\\n if(nums.length==0)return list;\\n int index=0;\\n for(int i=0;i<nums.length-1;i++){\\n     \\n     if(nums[i+1]-nums[i]!=1){\\n         if(index!=i){list.add(nums[index]+\"->\"+nums[i]);}\\n         else list.add(Integer.toString(nums[index]));\\n         \\n         index=i+1;\\n     }\\n }\\n if(index==nums.length-1)list.add(Integer.toString(nums[index]));\\n else {list.add(nums[index]+\"->\"+nums[nums.length-1]);}\\n return list;\\n}\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3627264,
                "title": "optimized-solution-0ms-runtime",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> summaryRanges(vector<int>& nums) {\\n        vector<string> result;\\n        int n = nums.size();\\n        for (int i = 0; i < n; i++) {\\n            int start = nums[i];\\n            while (i < n - 1 && nums[i] + 1 == nums[i + 1])\\n                i++;\\n            int end = nums[i];\\n            if (start == end)\\n                result.push_back(to_string(start));\\n            else\\n                result.push_back(to_string(start) + \"->\" + to_string(end));\\n        }\\n        return result;\\n    }\\n};\\n```\\n\\n**PLEASE UPVOTE :)**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> summaryRanges(vector<int>& nums) {\\n        vector<string> result;\\n        int n = nums.size();\\n        for (int i = 0; i < n; i++) {\\n            int start = nums[i];\\n            while (i < n - 1 && nums[i] + 1 == nums[i + 1])\\n                i++;\\n            int end = nums[i];\\n            if (start == end)\\n                result.push_back(to_string(start));\\n            else\\n                result.push_back(to_string(start) + \"->\" + to_string(end));\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3627191,
                "title": "c-beginner-friendly-o-n-beats-100-one-for-loop",
                "content": "# 1. Intuition:\\nThe code aims to summarize ranges of consecutive numbers in the given vector `nums` and return the summary as a vector of strings. \\n\\n# 2. Approach:\\nThe code iterates through the `nums` vector and checks if the current number and the previous number form a consecutive range. If they do, the end value of the range is updated. If they don\\'t form a consecutive range, the previous range is summarized and added to the `ans` vector. After the loop, the last range is also summarized and added to `ans`.\\n\\n# 3. Time Complexity:\\nThe time complexity of the code is O(n), where n is the size of the `nums` vector. This is because the code iterates through the vector once.\\n\\n# 4. Space Complexity:\\nThe space complexity of the code is O(1) in terms of auxiliary space because it uses a constant amount of extra space. However, the space complexity of the returned `ans` vector is O(m), where m is the number of summarized ranges. In the worst case, when all numbers in `nums` are distinct and not consecutive, the number of ranges will be equal to the size of `nums`, resulting in a space complexity of O(n) for the `ans` vector.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> summaryRanges(vector<int>& nums) {\\n        if(nums.size() == 0) return {};\\n        if(nums.size() == 1) return {to_string(nums[0])};\\n\\n        vector<string> ans;\\n        long s = nums[0];\\n        long e = nums[0];\\n        long i;\\n\\n        for(i=1; i<nums.size(); i++)\\n        {\\n            if(nums[i] - e == 1){\\n                e = nums[i];\\n            }\\n            else{\\n                if(s == e)\\n                    ans.push_back(to_string(s));\\n                else{\\n                    ans.push_back(to_string(s)+\"->\"+to_string(e));\\n                }\\n                s = nums[i];\\n                e = nums[i];\\n            }\\n        }\\n\\n        if(s == e)\\n            ans.push_back(to_string(s));\\n        else{\\n            ans.push_back(to_string(s)+\"->\"+to_string(e));\\n            s = nums[i];\\n            e = nums[i];\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> summaryRanges(vector<int>& nums) {\\n        if(nums.size() == 0) return {};\\n        if(nums.size() == 1) return {to_string(nums[0])};\\n\\n        vector<string> ans;\\n        long s = nums[0];\\n        long e = nums[0];\\n        long i;\\n\\n        for(i=1; i<nums.size(); i++)\\n        {\\n            if(nums[i] - e == 1){\\n                e = nums[i];\\n            }\\n            else{\\n                if(s == e)\\n                    ans.push_back(to_string(s));\\n                else{\\n                    ans.push_back(to_string(s)+\"->\"+to_string(e));\\n                }\\n                s = nums[i];\\n                e = nums[i];\\n            }\\n        }\\n\\n        if(s == e)\\n            ans.push_back(to_string(s));\\n        else{\\n            ans.push_back(to_string(s)+\"->\"+to_string(e));\\n            s = nums[i];\\n            e = nums[i];\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3518716,
                "title": "java-solution-for-summary-ranges-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe code aims to find consecutive elements in the array and group them into summary ranges. A summary range is represented as a string in the form of \"start->end\" if there is a range of consecutive numbers or just \"start\" if there is a single number.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialize an empty list, result, to store the summary ranges.\\n2. If the input array, nums, is null or empty, return the result list.\\n3. If the array contains only one element, add it to the result list as a single range and return the result.\\n4. Initialize variables pre (previous element) and first (first element of the range) to nums[0].\\n5. Iterate through the array starting from the second element (index 1):\\n- If the current element, nums[i], is consecutive to the previous element, update pre to nums[i].\\n- If nums[i] is not consecutive to the previous element, check if the range contains only a single number or a range of numbers:\\n1. If first and pre are the same, add first to the result list as a single number.\\n2. If first and pre are different, add the range to the result list in the form of \"first->pre\".\\n3. Update first to the current element, nums[i].\\n- If it is the last element of the array, add it to the result list as a single number.\\n6. Return the result list.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the code is O(n), where n is the length of the input array. It iterates through the array once to process all the elements.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity is O(1) since the code uses a constant amount of extra space for storing variables and the result list, which grows linearly with the input size.\\n\\n# Code\\n```\\nclass Solution {\\n    public List<String> summaryRanges(int[] nums) {\\n        List<String> result = new ArrayList<String>();\\n        if(nums == null || nums.length==0)\\n            return result;\\n        if(nums.length==1)\\n        {\\n            result.add(nums[0]+\"\");\\n        }\\n        int pre = nums[0]; // previous element\\n        int first = pre; // first element of each range\\n        for(int i=1; i<nums.length; i++)\\n        {\\n            if(nums[i]==pre+1)\\n            {\\n                if(i==nums.length-1)\\n                {\\n                    result.add(first+\"->\"+nums[i]);\\n                }\\n            }\\n            else\\n            {\\n                if(first == pre)\\n                {\\n                    result.add(first+\"\");\\n                }\\n                else\\n                {\\n                    result.add(first + \"->\"+pre);\\n                }\\n                if(i==nums.length-1)\\n                {\\n                    result.add(nums[i]+\"\");\\n                }\\n                first = nums[i];\\n            }\\n            pre = nums[i];\\n        }\\n        return result;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> summaryRanges(int[] nums) {\\n        List<String> result = new ArrayList<String>();\\n        if(nums == null || nums.length==0)\\n            return result;\\n        if(nums.length==1)\\n        {\\n            result.add(nums[0]+\"\");\\n        }\\n        int pre = nums[0]; // previous element\\n        int first = pre; // first element of each range\\n        for(int i=1; i<nums.length; i++)\\n        {\\n            if(nums[i]==pre+1)\\n            {\\n                if(i==nums.length-1)\\n                {\\n                    result.add(first+\"->\"+nums[i]);\\n                }\\n            }\\n            else\\n            {\\n                if(first == pre)\\n                {\\n                    result.add(first+\"\");\\n                }\\n                else\\n                {\\n                    result.add(first + \"->\"+pre);\\n                }\\n                if(i==nums.length-1)\\n                {\\n                    result.add(nums[i]+\"\");\\n                }\\n                first = nums[i];\\n            }\\n            pre = nums[i];\\n        }\\n        return result;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3410473,
                "title": "beats-99-short-simple-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunction summaryRanges(nums: number[]): string[] {\\n    const result = []\\n    let str = \\'\\'\\n\\n    let start = nums[0]\\n\\n    for (let i = 1; i <= nums.length; i++) {\\n        if (nums[i] - nums[i - 1] === 1) continue\\n        \\n        str = (start === nums[i - 1]) \\n            ? `${start}`\\n            : `${start}->${nums[i - 1]}`\\n\\n        result.push(str)\\n        start = nums[i]\\n    }\\n\\n    return result\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction summaryRanges(nums: number[]): string[] {\\n    const result = []\\n    let str = \\'\\'\\n\\n    let start = nums[0]\\n\\n    for (let i = 1; i <= nums.length; i++) {\\n        if (nums[i] - nums[i - 1] === 1) continue\\n        \\n        str = (start === nums[i - 1]) \\n            ? `${start}`\\n            : `${start}->${nums[i - 1]}`\\n\\n        result.push(str)\\n        start = nums[i]\\n    }\\n\\n    return result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3257609,
                "title": "rust-one-liner-with-some-additional-structures-it-s-how-i-would-do-it-in-java",
                "content": "# Intuition\\nprocess the list keeping current state (accumulator) in memory. Add a new range or update the last range. \\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimpl Solution {\\n    pub fn summary_ranges(nums: Vec<i32>) -> Vec<String> {\\n        nums.iter().fold(Ranges::new(), |mut acc, x| {acc.add(*x); acc}).ranges.iter().map(|r| r.to_string()).collect() \\n    }\\n}\\n\\nstruct Ranges {\\n    ranges: Vec<Range>\\n}\\n\\nimpl Ranges {\\n    pub fn new() -> Ranges {\\n        Ranges{ranges: Vec::new()}\\n    }\\n\\n    pub fn add(&mut self, x: i32) {\\n        match self.ranges.last_mut() {\\n            Some(Range(lo, hi)) if *hi+1 == x => *hi = x,\\n            _ => self.ranges.push(Range(x, x))\\n        }\\n    }\\n}\\n\\nstruct Range (i32, i32);\\n\\nuse std::fmt;\\n\\nimpl fmt::Display for Range {\\n    fn fmt(&self, f: &mut fmt::Formatter<\\'_>) -> fmt::Result {\\n        if self.0 == self.1 {\\n            write!(f, \"{}\", self.0)\\n        } else {\\n            write!(f, \"{}->{}\", self.0, self.1)\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn summary_ranges(nums: Vec<i32>) -> Vec<String> {\\n        nums.iter().fold(Ranges::new(), |mut acc, x| {acc.add(*x); acc}).ranges.iter().map(|r| r.to_string()).collect() \\n    }\\n}\\n\\nstruct Ranges {\\n    ranges: Vec<Range>\\n}\\n\\nimpl Ranges {\\n    pub fn new() -> Ranges {\\n        Ranges{ranges: Vec::new()}\\n    }\\n\\n    pub fn add(&mut self, x: i32) {\\n        match self.ranges.last_mut() {\\n            Some(Range(lo, hi)) if *hi+1 == x => *hi = x,\\n            _ => self.ranges.push(Range(x, x))\\n        }\\n    }\\n}\\n\\nstruct Range (i32, i32);\\n\\nuse std::fmt;\\n\\nimpl fmt::Display for Range {\\n    fn fmt(&self, f: &mut fmt::Formatter<\\'_>) -> fmt::Result {\\n        if self.0 == self.1 {\\n            write!(f, \"{}\", self.0)\\n        } else {\\n            write!(f, \"{}->{}\", self.0, self.1)\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3205684,
                "title": "finding-ranges-for-a-sorted-unique-integer-array",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem can be solved by iterating over the input array and maintaining the start and end pointers to keep track of the current range. Whenever there is a gap between two consecutive numbers, we add the current range to the list of ranges and start a new range with the new number.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach to solving this problem is as follows:\\n\\n1. Create an empty list called \"ranges\" to store the ranges.\\n\\n2. Initialize two pointers, \"start\" and \"end\", to the first number in the array.\\n\\n3. Iterate over the array from the second number to the last number.\\n\\n4. If the current number is equal to the previous number plus one, update the \"end\" pointer to the current number.\\n\\n5. If the current number is not equal to the previous number plus one, add the current range to the list of ranges and start a new range with the current number as both the start and end.\\n\\n6. After the loop, add the final range to the list of ranges.\\n\\n7. Convert each range in the list of ranges to its corresponding string format, \"a->b\" if a != b or \"a\" if a == b.\\n\\n8. Return the list of strings.\\n\\n\\n# Complexity\\n- Time complexity: $$O(n)$$, where $n$ is the length of the input array, as we iterate over the array once.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$O(n)$, as we store the list of ranges in memory.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def summaryRanges(self, nums: List[int]) -> List[str]:\\n        if not nums:\\n            return []\\n        ranges = []\\n        start, end = nums[0], nums[0]\\n        for i in range(1, len(nums)):\\n            if nums[i] == end + 1:\\n                end = nums[i]\\n            else:\\n                if start == end:\\n                    ranges.append(str(start))\\n                else:\\n                    ranges.append(str(start) + \\'->\\' + str(end))\\n                start, end = nums[i], nums[i]\\n        if start == end:\\n            ranges.append(str(start))\\n        else:\\n            ranges.append(str(start) + \\'->\\' + str(end))\\n        return ranges\\n```",
                "solutionTags": [
                    "Python3",
                    "Array"
                ],
                "code": "```\\nclass Solution:\\n    def summaryRanges(self, nums: List[int]) -> List[str]:\\n        if not nums:\\n            return []\\n        ranges = []\\n        start, end = nums[0], nums[0]\\n        for i in range(1, len(nums)):\\n            if nums[i] == end + 1:\\n                end = nums[i]\\n            else:\\n                if start == end:\\n                    ranges.append(str(start))\\n                else:\\n                    ranges.append(str(start) + \\'->\\' + str(end))\\n                start, end = nums[i], nums[i]\\n        if start == end:\\n            ranges.append(str(start))\\n        else:\\n            ranges.append(str(start) + \\'->\\' + str(end))\\n        return ranges\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3160709,
                "title": "python-clean-and-optimized-code",
                "content": "\\n### Upvote if it helps! \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- ```def construct``` allows to generate the string to add, it checks the condition ```a==b```.\\n- Using this function is a clean way to code because we use it twice.\\n- **But** its definition  increases the execution time.\\n- So here are the 2 versions.\\n\\n# Code: Clean Version (beats 50%)\\n```\\nclass Solution(object):\\n    def summaryRanges(self, nums):\\n        res = []\\n        if not nums: return []\\n        a, b = nums[0], nums[0]\\n\\n        def construct(a, b):\\n            if a == b:\\n                return str(a)\\n            else:\\n                return str(a) + \"->\" + str(b)\\n\\n        for i in range(1, len(nums)):\\n            if nums[i] != nums[i-1] + 1:\\n                res.append(construct(a,b))\\n                a = nums[i]\\n                b = nums[i]\\n            else:\\n                b = nums[i]\\n        res.append(construct(a,b))\\n        return res\\n```\\n\\n# Code: Optimized Version (beats 99%)\\n```\\nclass Solution(object):\\n    def summaryRanges(self, nums):\\n        res = []\\n        if not nums: return []\\n        a, b = nums[0], nums[0]\\n\\n        for i in range(1, len(nums)):\\n            if nums[i] != nums[i-1] + 1:\\n                if a == b:\\n                    res.append(str(a))\\n                else:\\n                    res.append(str(a) + \"->\" + str(b))\\n                a = nums[i]\\n                b = nums[i]\\n            else:\\n                b = nums[i]\\n        if a == b:\\n            res.append(str(a))\\n        else:\\n            res.append(str(a) + \"->\" + str(b))\\n        return res\\n\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```def construct```\n```a==b```\n```\\nclass Solution(object):\\n    def summaryRanges(self, nums):\\n        res = []\\n        if not nums: return []\\n        a, b = nums[0], nums[0]\\n\\n        def construct(a, b):\\n            if a == b:\\n                return str(a)\\n            else:\\n                return str(a) + \"->\" + str(b)\\n\\n        for i in range(1, len(nums)):\\n            if nums[i] != nums[i-1] + 1:\\n                res.append(construct(a,b))\\n                a = nums[i]\\n                b = nums[i]\\n            else:\\n                b = nums[i]\\n        res.append(construct(a,b))\\n        return res\\n```\n```\\nclass Solution(object):\\n    def summaryRanges(self, nums):\\n        res = []\\n        if not nums: return []\\n        a, b = nums[0], nums[0]\\n\\n        for i in range(1, len(nums)):\\n            if nums[i] != nums[i-1] + 1:\\n                if a == b:\\n                    res.append(str(a))\\n                else:\\n                    res.append(str(a) + \"->\" + str(b))\\n                a = nums[i]\\n                b = nums[i]\\n            else:\\n                b = nums[i]\\n        if a == b:\\n            res.append(str(a))\\n        else:\\n            res.append(str(a) + \"->\" + str(b))\\n        return res\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3114805,
                "title": "python-readable-solution-beats-97",
                "content": "*Time complexity: O(n)*\\n\\n\\n__Code:__\\n```\\nclass Solution:\\n    def summaryRanges(self, nums: List[int]) -> List[str]:\\n        if len(nums) == 0: return []\\n        if len(nums) == 1: return [f\\'{nums[0]}\\']\\n        s = []\\n        pre = start = nums[0]\\n        for i in nums[1:]:\\n            if i - pre != 1:\\n                s.append(f\\'{start}->{pre}\\' if pre - start > 0 else f\\'{pre}\\')\\n                start = i\\n            pre = i\\n        s.append(f\\'{start}->{pre}\\' if pre - start > 0 else f\\'{pre}\\')\\n        return s\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Array"
                ],
                "code": "```\\nclass Solution:\\n    def summaryRanges(self, nums: List[int]) -> List[str]:\\n        if len(nums) == 0: return []\\n        if len(nums) == 1: return [f\\'{nums[0]}\\']\\n        s = []\\n        pre = start = nums[0]\\n        for i in nums[1:]:\\n            if i - pre != 1:\\n                s.append(f\\'{start}->{pre}\\' if pre - start > 0 else f\\'{pre}\\')\\n                start = i\\n            pre = i\\n        s.append(f\\'{start}->{pre}\\' if pre - start > 0 else f\\'{pre}\\')\\n        return s\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2932974,
                "title": "c-0ms-100-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> summaryRanges(vector<int>& nums) {\\n       \\n        if(nums.size()==0)return {};\\n        if(nums.size()==1)return {to_string(nums[0])};\\n         int a=nums[0], b=nums[0];\\n        nums.push_back(0);\\n        vector<string> v;\\n        for(int i=0; i<nums.size()-1; i++){\\n            if(nums[i+1]-1!=nums[i]){\\n                if(a==b)v.push_back(to_string(a));\\n                else v.push_back(to_string(a)+\"->\"+to_string(b));\\n                a=nums[i+1], b=nums[i+1];\\n            }\\n            else b++;\\n        }\\nreturn v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> summaryRanges(vector<int>& nums) {\\n       \\n        if(nums.size()==0)return {};\\n        if(nums.size()==1)return {to_string(nums[0])};\\n         int a=nums[0], b=nums[0];\\n        nums.push_back(0);\\n        vector<string> v;\\n        for(int i=0; i<nums.size()-1; i++){\\n            if(nums[i+1]-1!=nums[i]){\\n                if(a==b)v.push_back(to_string(a));\\n                else v.push_back(to_string(a)+\"->\"+to_string(b));\\n                a=nums[i+1], b=nums[i+1];\\n            }\\n            else b++;\\n        }\\nreturn v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2830239,
                "title": "c-simple-solution-faster-than-100",
                "content": "```\\nchar ** summaryRanges(int* nums, int numsSize, int* returnSize){\\n    int start = 0;\\n    char** final_arr = (char**)malloc(20*sizeof(char*));\\n    int count =0;\\n        for (int k=0;k<numsSize;k++){\\n            if (k==0 || nums[k]-1 > nums[k-1]){ // did \"-1\" here, since the number will not be stored (too large)\\n                start=nums[k];\\n            }\\n            if (k==numsSize-1 || nums[k]+1 < nums[k+1]){ // we are at the finish line\\n                // printf(\"[%d..%d]\\\\n\",start,nums[k]);\\n                final_arr[count]= (char*) malloc(28*sizeof(char));\\n                if (start<nums[k]){\\n                    snprintf(final_arr[count],28,\"%d->%d\",start,nums[k]); \\n                }\\n                else \\n                    snprintf(final_arr[count],28,\"%d\",start);\\n                printf(\"%s\\\\n\",final_arr[count]);\\n                count++;\\n            }\\n        }\\n    *returnSize = count;\\n    return final_arr;\\n    \\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nchar ** summaryRanges(int* nums, int numsSize, int* returnSize){\\n    int start = 0;\\n    char** final_arr = (char**)malloc(20*sizeof(char*));\\n    int count =0;\\n        for (int k=0;k<numsSize;k++){\\n            if (k==0 || nums[k]-1 > nums[k-1]){ // did \"-1\" here, since the number will not be stored (too large)\\n                start=nums[k];\\n            }\\n            if (k==numsSize-1 || nums[k]+1 < nums[k+1]){ // we are at the finish line\\n                // printf(\"[%d..%d]\\\\n\",start,nums[k]);\\n                final_arr[count]= (char*) malloc(28*sizeof(char));\\n                if (start<nums[k]){\\n                    snprintf(final_arr[count],28,\"%d->%d\",start,nums[k]); \\n                }\\n                else \\n                    snprintf(final_arr[count],28,\"%d\",start);\\n                printf(\"%s\\\\n\",final_arr[count]);\\n                count++;\\n            }\\n        }\\n    *returnSize = count;\\n    return final_arr;\\n    \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2694720,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public List<String> summaryRanges(int[] nums) {\\n        List<String> result = new LinkedList<String>();\\n        if (nums == null || nums.length == 0) {\\n            return result;\\n        }\\n        for (int i = 0; i < nums.length; i ++) {\\n            if (i == nums.length - 1 || nums[i] != nums[i + 1] - 1) {\\n                result.add(nums[i] + \"\");\\n                continue;\\n            }\\n            int left = nums[i];\\n            int j = i + 1;\\n            for (; j < nums.length; j ++) {\\n                if (j == nums.length - 1 || nums[j] != nums[j + 1] - 1) {\\n                    break;\\n                }\\n            }\\n            result.add(left + \"->\" + nums[j]);\\n            i = j;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<String> summaryRanges(int[] nums) {\\n        List<String> result = new LinkedList<String>();\\n        if (nums == null || nums.length == 0) {\\n            return result;\\n        }\\n        for (int i = 0; i < nums.length; i ++) {\\n            if (i == nums.length - 1 || nums[i] != nums[i + 1] - 1) {\\n                result.add(nums[i] + \"\");\\n                continue;\\n            }\\n            int left = nums[i];\\n            int j = i + 1;\\n            for (; j < nums.length; j ++) {\\n                if (j == nums.length - 1 || nums[j] != nums[j + 1] - 1) {\\n                    break;\\n                }\\n            }\\n            result.add(left + \"->\" + nums[j]);\\n            i = j;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2562201,
                "title": "java-easy-to-understand-solution",
                "content": "```\\nclass Solution {\\n    public List<String> summaryRanges(int[] nums) {\\n        List<String> list=new ArrayList();\\n\\tif(nums.length==1){\\n\\t\\tlist.add(nums[0]+\"\");\\n\\t\\treturn list;\\n\\t}\\n    for(int i=0;i<nums.length;i++){\\n    \\tint a=nums[i];\\n    \\twhile(i+1<nums.length&&(nums[i+1]-nums[i])==1){\\n    \\t\\ti++;\\n    \\t}\\n    \\tif(a!=nums[i]){\\n    \\t\\tlist.add(a+\"->\"+nums[i]);\\n    \\t}else{\\n    \\t\\tlist.add(a+\"\");\\n    \\t}\\n    }\\n    return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> summaryRanges(int[] nums) {\\n        List<String> list=new ArrayList();\\n\\tif(nums.length==1){\\n\\t\\tlist.add(nums[0]+\"\");\\n\\t\\treturn list;\\n\\t}\\n    for(int i=0;i<nums.length;i++){\\n    \\tint a=nums[i];\\n    \\twhile(i+1<nums.length&&(nums[i+1]-nums[i])==1){\\n    \\t\\ti++;\\n    \\t}\\n    \\tif(a!=nums[i]){\\n    \\t\\tlist.add(a+\"->\"+nums[i]);\\n    \\t}else{\\n    \\t\\tlist.add(a+\"\");\\n    \\t}\\n    }\\n    return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2012883,
                "title": "python-clean-and-simple",
                "content": "**Solution**:\\n```\\nclass Solution:\\n    def summaryRanges(self, nums: List[int]) -> List[str]:\\n        ans, n = [], len(nums)\\n        \\n        start = 0\\n        for i in range(1,n+1):\\n            if i == n or nums[i] != nums[i-1]+1:\\n                ans.append(self.helper(nums[start],nums[i-1]))\\n                start = i\\n        return ans\\n    \\n    def helper(self, a, b):\\n        return str(a) if a==b else str(a)+\"->\"+str(b)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def summaryRanges(self, nums: List[int]) -> List[str]:\\n        ans, n = [], len(nums)\\n        \\n        start = 0\\n        for i in range(1,n+1):\\n            if i == n or nums[i] != nums[i-1]+1:\\n                ans.append(self.helper(nums[start],nums[i-1]))\\n                start = i\\n        return ans\\n    \\n    def helper(self, a, b):\\n        return str(a) if a==b else str(a)+\"->\"+str(b)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1807770,
                "title": "c-and-js-solution-iterative-fast-simple-intuitive-100-faster",
                "content": "```\\npublic class Solution {\\n        public IList<string> SummaryRanges(int[] nums)\\n        {\\n            var result = new List<string>();\\n            for (int i = 0; i < nums.Length; i++)\\n            {\\n                int start = nums[i];\\n                while (i < nums.Length - 1 && nums[i + 1] - nums[i] == 1)\\n                {\\n                    i++;\\n                }\\n                if (start != nums[i])\\n                    result.Add($\"{start}->{nums[i]}\");\\n                else\\n                    result.Add($\"{start}\");\\n            }\\n\\n            return result;\\n        }\\n}\\n```\\ntrasnlate to js:\\n```\\n/**\\n * @param {number[]} nums\\n * @return {string[]}\\n */\\nvar summaryRanges = function (nums) {\\n    let result = [];\\n    for (let i = 0; i < nums.length; i++) {\\n        let start = nums[i];\\n        while (i < nums.length - 1 && nums[i + 1] - nums[i] == 1) {\\n            i++;\\n        }\\n        if (start != nums[i])\\n\\t\\t    result.push(`${start}->${nums[i]}`);\\n        else \\n\\t\\t    result.push(start.toString());\\n    }\\n    return result;\\n};\\n\\n```",
                "solutionTags": [
                    "C#",
                    "JavaScript",
                    "Array"
                ],
                "code": "```\\npublic class Solution {\\n        public IList<string> SummaryRanges(int[] nums)\\n        {\\n            var result = new List<string>();\\n            for (int i = 0; i < nums.Length; i++)\\n            {\\n                int start = nums[i];\\n                while (i < nums.Length - 1 && nums[i + 1] - nums[i] == 1)\\n                {\\n                    i++;\\n                }\\n                if (start != nums[i])\\n                    result.Add($\"{start}->{nums[i]}\");\\n                else\\n                    result.Add($\"{start}\");\\n            }\\n\\n            return result;\\n        }\\n}\\n```\n```\\n/**\\n * @param {number[]} nums\\n * @return {string[]}\\n */\\nvar summaryRanges = function (nums) {\\n    let result = [];\\n    for (let i = 0; i < nums.length; i++) {\\n        let start = nums[i];\\n        while (i < nums.length - 1 && nums[i + 1] - nums[i] == 1) {\\n            i++;\\n        }\\n        if (start != nums[i])\\n\\t\\t    result.push(`${start}->${nums[i]}`);\\n        else \\n\\t\\t    result.push(start.toString());\\n    }\\n    return result;\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1807003,
                "title": "easy-python-solution-with-comments",
                "content": "Upvote the post, if you found it useful.\\n```\\nclass Solution:\\n    def summaryRanges(self, nums: List[int]) -> List[str]:\\n        a = 0\\n        res =[]\\n        if nums == [] or len(nums)==1: #if input list is empty or contains single elem\\n            return list(map(str,nums)) #typecast the int to str\\n        \\n        for i in range(len(nums)):\\n            if i == len(nums)-1 or nums[i+1] != nums[i]+1:#if it is last elem or the next elem is just one greater\\n                                                            #than current elem do this\\n                \\n                if nums[a] == nums[i]:      # if the start and end of range is same elem append it.         \\n                    res.append(str(nums[i]))        \\n                                        \\n                else:                 #else append the str form of the range\\n                    res.append(str(nums[a])+\"->\"+str(nums[i]))\\n                    \\n                a = i+1 #move the start of range to next of current elem\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def summaryRanges(self, nums: List[int]) -> List[str]:\\n        a = 0\\n        res =[]\\n        if nums == [] or len(nums)==1: #if input list is empty or contains single elem\\n            return list(map(str,nums)) #typecast the int to str\\n        \\n        for i in range(len(nums)):\\n            if i == len(nums)-1 or nums[i+1] != nums[i]+1:#if it is last elem or the next elem is just one greater\\n                                                            #than current elem do this\\n                \\n                if nums[a] == nums[i]:      # if the start and end of range is same elem append it.         \\n                    res.append(str(nums[i]))        \\n                                        \\n                else:                 #else append the str form of the range\\n                    res.append(str(nums[a])+\"->\"+str(nums[i]))\\n                    \\n                a = i+1 #move the start of range to next of current elem\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1806922,
                "title": "ruby-compact",
                "content": "```ruby\\ndef summary_ranges(nums)\\n    nums.chunk_while{ |a, b| a + 1 == b }\\n        .map{ |x| [x.first, x.last].uniq.join(\"->\") }\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby\\ndef summary_ranges(nums)\\n    nums.chunk_while{ |a, b| a + 1 == b }\\n        .map{ |x| [x.first, x.last].uniq.join(\"->\") }\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1806662,
                "title": "accepted-in-0ms-easy-fast-and-simple-solution-with-comments",
                "content": "### \\u2714 Summary Ranges  | C++ | Easy Level | Easy, Fast and Simple | 0ms \\n\\n<br>\\n \\uD83D\\uDDD3\\uFE0F This problem is the Daily LeetCoding Challenge for February, Day 28.\\n<br>\\n<br>\\n\\n```\\nclass Solution {\\npublic:\\n    vector<string> summaryRanges(vector<int>& nums) {\\n        vector<string> result;\\n        int n = nums.size();\\n        \\n        // If numms is empty simply return zero.\\n        if(n == 0){\\n            return result;\\n        }\\n        \\n        // Take temp variable to store starting value of range.\\n        int temp = nums[0];\\n        \\n        for(int i=0; i<n; i++){\\n            // Loop until end of nums or there is a continious range.\\n            if(i == n - 1 || nums[i] + 1 != nums[i + 1]){\\n                \\n                // If current value is not equals to the starting value then only there will be a range.\\n                if(nums[i] != temp){\\n                    result.push_back(to_string(temp) + \"->\" + to_string(nums[i]));\\n                }else{\\n                    result.push_back(to_string(temp));\\n                }\\n                \\n                // If not end of nums update the starting value of range.\\n                if(i != n - 1){\\n                    temp = nums[i + 1];\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```\\n\\nPlease Upvote if you liked the solution :)",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> summaryRanges(vector<int>& nums) {\\n        vector<string> result;\\n        int n = nums.size();\\n        \\n        // If numms is empty simply return zero.\\n        if(n == 0){\\n            return result;\\n        }\\n        \\n        // Take temp variable to store starting value of range.\\n        int temp = nums[0];\\n        \\n        for(int i=0; i<n; i++){\\n            // Loop until end of nums or there is a continious range.\\n            if(i == n - 1 || nums[i] + 1 != nums[i + 1]){\\n                \\n                // If current value is not equals to the starting value then only there will be a range.\\n                if(nums[i] != temp){\\n                    result.push_back(to_string(temp) + \"->\" + to_string(nums[i]));\\n                }else{\\n                    result.push_back(to_string(temp));\\n                }\\n                \\n                // If not end of nums update the starting value of range.\\n                if(i != n - 1){\\n                    temp = nums[i + 1];\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1806071,
                "title": "accepted-java-solution-0ms-100",
                "content": "```\\nclass Solution {\\n    public List<String> summaryRanges(int[] nums) {\\n        List<String> result = new ArrayList<>();\\n        if (nums.length == 0) {\\n            return result;\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        for (int i=0; i< nums.length; i++) {\\n            int currentNumber = nums[i];\\n            sb.setLength(0);\\n            while (i + 1 < nums.length && nums[i+1] - nums[i] == 1) {\\n                i++;\\n            }\\n            \\n            if(currentNumber != nums[i]) {\\n                sb.append(currentNumber);\\n                sb.append(\"->\");\\n                sb.append(nums[i]);\\n            } else {\\n                sb.append(currentNumber);\\n            }\\n            result.add(sb.toString());\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> summaryRanges(int[] nums) {\\n        List<String> result = new ArrayList<>();\\n        if (nums.length == 0) {\\n            return result;\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        for (int i=0; i< nums.length; i++) {\\n            int currentNumber = nums[i];\\n            sb.setLength(0);\\n            while (i + 1 < nums.length && nums[i+1] - nums[i] == 1) {\\n                i++;\\n            }\\n            \\n            if(currentNumber != nums[i]) {\\n                sb.append(currentNumber);\\n                sb.append(\"->\");\\n                sb.append(nums[i]);\\n            } else {\\n                sb.append(currentNumber);\\n            }\\n            result.add(sb.toString());\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1806065,
                "title": "python-o-n-solution-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def summaryRanges(self, nums: List[int]) -> List[str]:\\n        if not nums:\\n            return nums\\n        start=-1\\n        ans=[]\\n        for i in range(1,len(nums)):\\n            if nums[i]-nums[i-1]==1 and start==-1:\\n                start=nums[i-1]\\n            if nums[i]-nums[i-1]!=1:\\n                if start==-1:\\n                    ans.append(str(nums[i-1]))\\n                else:\\n                    ans.append(str(start)+\\'->\\'+str(nums[i-1]))\\n                    start=-1\\n        if start==-1:\\n            ans.append(str(nums[-1]))\\n        else:\\n            ans.append(str(start)+\\'->\\'+str(nums[-1]))\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def summaryRanges(self, nums: List[int]) -> List[str]:\\n        if not nums:\\n            return nums\\n        start=-1\\n        ans=[]\\n        for i in range(1,len(nums)):\\n            if nums[i]-nums[i-1]==1 and start==-1:\\n                start=nums[i-1]\\n            if nums[i]-nums[i-1]!=1:\\n                if start==-1:\\n                    ans.append(str(nums[i-1]))\\n                else:\\n                    ans.append(str(start)+\\'->\\'+str(nums[i-1]))\\n                    start=-1\\n        if start==-1:\\n            ans.append(str(nums[-1]))\\n        else:\\n            ans.append(str(start)+\\'->\\'+str(nums[-1]))\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1806027,
                "title": "very-easy-c-solution-time-o-n-space-o-1",
                "content": "### Approach:\\nSo what are we trying to do?\\nWe want the interval to be single till condition is true, Condition being the latter element must be +1 than the former one.\\nIf the interval formed is of single length, We only push the element, Otherwise we push \" start -> end\"\\n\\n\\n### Code:\\n```\\n vector<string> summaryRanges(vector<int>& nums) {\\n        int start,end,size=nums.size();   \\n        vector<string> summaries;\\n        \\n        start=0;\\n        while(start<size){\\n            end=start+1;\\n            while(end<size && nums[end] == nums[end-1]+1)\\n                end++;\\n            string summary=\"\";\\n            if(end == start+1)\\n                summary += to_string(nums[start]);\\n            else\\n                summary += to_string(nums[start]) + \"->\" + to_string(nums[end-1]);\\n            \\n            summaries.push_back(summary);\\n            start=end;\\n        }\\n        return summaries;\\n    }\\n```\\n\\n**Time complexity:** O(n), Since the start and end in total is traversing array single time.\\n**Space complexity:** O(1), Since there is no extra space being used for the approach except the summaries array which we need to return and hence will not contribute towards space complexity.\\n\\n**P.S: Please do upvote if you like it and let me know if there are any questions/optimizations in the comment section below.**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\n vector<string> summaryRanges(vector<int>& nums) {\\n        int start,end,size=nums.size();   \\n        vector<string> summaries;\\n        \\n        start=0;\\n        while(start<size){\\n            end=start+1;\\n            while(end<size && nums[end] == nums[end-1]+1)\\n                end++;\\n            string summary=\"\";\\n            if(end == start+1)\\n                summary += to_string(nums[start]);\\n            else\\n                summary += to_string(nums[start]) + \"->\" + to_string(nums[end-1]);\\n            \\n            summaries.push_back(summary);\\n            start=end;\\n        }\\n        return summaries;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1805967,
                "title": "easy-to-understand-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> summaryRanges(vector<int>& nums) {\\n        vector<string> ans;\\n        //Time Complexity : O(n^2)\\n        //Space Complexity :O(n) ignoring the ans vector\\n        \\n        for(int i=0;i<nums.size();i++)\\n        {\\n            string s=\"\";\\n            // first loop is used to store the starting element\\n            s+=to_string(nums[i]);\\n            for(int j=i+1;j<nums.size();j++)\\n            {\\n                // if they are not successive elements \\n                if(nums[j-1]+1!=nums[j])\\n                {\\n                    //if they are equal then it is already stored in s and we have to break\\n                    if(nums[i]==nums[j-1])\\n                    {\\n                        i=j-1;\\n                        break;\\n                    }\\n                    //it means the index is not stored and we have to store it and it is the final element\\n                    else\\n                    {\\n                        s+=\"->\";\\n                        s+=to_string(nums[j-1]);\\n                        i=j-1;\\n                        break;\\n                    }\\n                }\\n                //it used to check the last elemnt is it successive then we have to store it also\\n                if(j==nums.size()-1)\\n                {\\n                        s+=\"->\";\\n                        s+=to_string(nums[j]);\\n                        i=j;\\n                }\\n            }\\n            ans.push_back(s);\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> summaryRanges(vector<int>& nums) {\\n        vector<string> ans;\\n        //Time Complexity : O(n^2)\\n        //Space Complexity :O(n) ignoring the ans vector\\n        \\n        for(int i=0;i<nums.size();i++)\\n        {\\n            string s=\"\";\\n            // first loop is used to store the starting element\\n            s+=to_string(nums[i]);\\n            for(int j=i+1;j<nums.size();j++)\\n            {\\n                // if they are not successive elements \\n                if(nums[j-1]+1!=nums[j])\\n                {\\n                    //if they are equal then it is already stored in s and we have to break\\n                    if(nums[i]==nums[j-1])\\n                    {\\n                        i=j-1;\\n                        break;\\n                    }\\n                    //it means the index is not stored and we have to store it and it is the final element\\n                    else\\n                    {\\n                        s+=\"->\";\\n                        s+=to_string(nums[j-1]);\\n                        i=j-1;\\n                        break;\\n                    }\\n                }\\n                //it used to check the last elemnt is it successive then we have to store it also\\n                if(j==nums.size()-1)\\n                {\\n                        s+=\"->\";\\n                        s+=to_string(nums[j]);\\n                        i=j;\\n                }\\n            }\\n            ans.push_back(s);\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1805961,
                "title": "python-3-detailed-solution-and-explanation",
                "content": "**\\uD83D\\uDC46Please UPVOTE it if you find my soulutions are useful \\uD83D\\uDC46 Feel free to ask any question**\\n# [Python 3] \\uD83C\\uDF1F Detailed Solution and Explanation \\uD83D\\uDC95\\n\\n## 1\\uFE0F\\u20E3 Main Idea:\\n**main function**\\n\\n0. Edge Case: if nums = [ ] return [ ]\\n1.  Init parameters\\n\\t* init final result\\'s array res = [ ] \\n\\t* init currRange = [startPoint, endPoint] both nums[0]\\n2.  Iterate through nums:\\n\\t* If current num is not consecutive to previous one, append currRange to res and reinit currRange  = [currentNum, currentNum]\\n\\t* Else we expand endPoint to current numbers, currRange[1] = nums[i]\\n3. Once finish iteration, append final range to result.\\n \\n**updateSummary** function is to convert currRange to corrent format and append it to summary\\n1. Case 1: if startPoint == endPoint: append \"a\"\\n2. Case 2: if startPoint != endPoint append \"a->b\"\\n\\n## Complexity Analysis\\n* Time: O(N) : Iterate through nums O(N)\\n* Space: O(1)\\n## Solution Code\\n```\\n# O(N) | O(1)\\nclass Solution:\\n    def summaryRanges(self, nums: List[int]) -> List[str]:\\n        if not nums: return []\\n        # Init parameters currRange = [startPoint, endPoint]\\n        res = []\\n        currRange = [nums[0], nums[0]]\\n        \\n        for i in range(1, len(nums)):\\n            # Once nums are not consecutive, update res and reinit currRange\\n            if nums[i] != nums[i - 1] + 1:\\n                self.updateSummary(currRange, res)\\n                currRange = [nums[i], nums[i]]\\n            # Update endPoint\\n            else:\\n                currRange[1] = nums[i]\\n                \\n        # Update res again to append final range\\n        self.updateSummary(currRange, res)\\n        return res\\n    \\n    def updateSummary(self, currRange, summary):\\n        # Case 1: \"a\" if a == b\\n        if currRange[0] == currRange[1]:\\n            summary.append(str(currRange[0]))\\n        # Case 2: \"a->b\" if a != b\\n        else:\\n            summary.append(\"{}->{}\".format(currRange[0], currRange[1]))\\n```\\n\\n\\n* See more 2022 Daily Challenge Solution : [GitHub](https://github.com/gcobs0834/2022-Daily-LeetCoding-Challenge-python3-)",
                "solutionTags": [],
                "code": "```\\n# O(N) | O(1)\\nclass Solution:\\n    def summaryRanges(self, nums: List[int]) -> List[str]:\\n        if not nums: return []\\n        # Init parameters currRange = [startPoint, endPoint]\\n        res = []\\n        currRange = [nums[0], nums[0]]\\n        \\n        for i in range(1, len(nums)):\\n            # Once nums are not consecutive, update res and reinit currRange\\n            if nums[i] != nums[i - 1] + 1:\\n                self.updateSummary(currRange, res)\\n                currRange = [nums[i], nums[i]]\\n            # Update endPoint\\n            else:\\n                currRange[1] = nums[i]\\n                \\n        # Update res again to append final range\\n        self.updateSummary(currRange, res)\\n        return res\\n    \\n    def updateSummary(self, currRange, summary):\\n        # Case 1: \"a\" if a == b\\n        if currRange[0] == currRange[1]:\\n            summary.append(str(currRange[0]))\\n        # Case 2: \"a->b\" if a != b\\n        else:\\n            summary.append(\"{}->{}\".format(currRange[0], currRange[1]))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1805922,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    typedef long long ll; \\n    vector<string> summaryRanges(vector<int>& nums) {\\n      vector<string>ans;\\n      ll n=nums.size();\\n      for(int i=0;i<n;i++){\\n          ll j=i,final=0,initial=nums[i],cur=nums[i];\\n          string s;\\n          s+=to_string(initial);\\n          while(j<n and nums[j]==cur){\\n              final=nums[j];\\n              j++;\\n              cur++;\\n          }\\n          if(final!=initial){ \\n            s+=\"->\";\\n            s+=to_string(final);\\n          }\\n           ans.push_back(s);\\n           i=j-1;\\n      }return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    typedef long long ll; \\n    vector<string> summaryRanges(vector<int>& nums) {\\n      vector<string>ans;\\n      ll n=nums.size();\\n      for(int i=0;i<n;i++){\\n          ll j=i,final=0,initial=nums[i],cur=nums[i];\\n          string s;\\n          s+=to_string(initial);\\n          while(j<n and nums[j]==cur){\\n              final=nums[j];\\n              j++;\\n              cur++;\\n          }\\n          if(final!=initial){ \\n            s+=\"->\";\\n            s+=to_string(final);\\n          }\\n           ans.push_back(s);\\n           i=j-1;\\n      }return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1581516,
                "title": "java-simple-solution",
                "content": "**Runtime: 6 ms, faster than 73.70% of Java online submissions for Summary Ranges.\\nMemory Usage: 37.7 MB, less than 47.60% of Java online submissions for Summary Ranges.**\\n```\\nclass Solution {\\n    public List<String> summaryRanges(int[] nums) {\\n        List<String> res = new ArrayList<>();\\n        for(int i = 0;i<nums.length;i++){\\n            int start = nums[i];\\n            while(i+1 < nums.length && (nums[i+1] - nums[i]) == 1)i++;\\n            if(nums[i] != start)res.add(start + \"->\" + nums[i]);\\n            else res.add(\"\"+start);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> summaryRanges(int[] nums) {\\n        List<String> res = new ArrayList<>();\\n        for(int i = 0;i<nums.length;i++){\\n            int start = nums[i];\\n            while(i+1 < nums.length && (nums[i+1] - nums[i]) == 1)i++;\\n            if(nums[i] != start)res.add(start + \"->\" + nums[i]);\\n            else res.add(\"\"+start);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1314273,
                "title": "c-0-ms-beats-100",
                "content": "```c++\\nclass Solution {\\npublic:\\n    vector<string> summaryRanges(vector<int>& nums) {\\n        \\n        if ( nums.empty()) { return {}; }\\n        \\n        int _min = INT_MAX;\\n        int _max =  INT_MIN;\\n        \\n        vector<string> result;\\n        \\n        // For making it generalized\\n        nums.push_back(nums[nums.size() - 1]); \\n        \\n        for( int i = 0; i < nums.size() - 1; i++ ) {\\n            \\n            // overflow prevent\\n            long long distance = (long long)nums[i+1] - (long long)nums[i];\\n            \\n            if( distance == 1 ) {\\n                _min = min(nums[i], _min);\\n                _max = max(nums[i+1], _max);\\n            } else {\\n                \\n                string s;\\n                if ( _min == INT_MAX && _max == INT_MIN ) {\\n                    s = to_string(nums[i]);\\n                } else {\\n                    s = to_string(_min) + \"->\" + to_string(_max); \\n                }\\n                \\n                result.push_back(s);\\n                \\n                _min = INT_MAX;\\n                _max = INT_MIN;\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n```\\n\\n**For more solutions, check out this \\uD83C\\uDFC6  [GITHUB REPOSITORY](https://github.com/MuhtasimTanmoy/playground) with over 1500+ solutions.**",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n    vector<string> summaryRanges(vector<int>& nums) {\\n        \\n        if ( nums.empty()) { return {}; }\\n        \\n        int _min = INT_MAX;\\n        int _max =  INT_MIN;\\n        \\n        vector<string> result;\\n        \\n        // For making it generalized\\n        nums.push_back(nums[nums.size() - 1]); \\n        \\n        for( int i = 0; i < nums.size() - 1; i++ ) {\\n            \\n            // overflow prevent\\n            long long distance = (long long)nums[i+1] - (long long)nums[i];\\n            \\n            if( distance == 1 ) {\\n                _min = min(nums[i], _min);\\n                _max = max(nums[i+1], _max);\\n            } else {\\n                \\n                string s;\\n                if ( _min == INT_MAX && _max == INT_MIN ) {\\n                    s = to_string(nums[i]);\\n                } else {\\n                    s = to_string(_min) + \"->\" + to_string(_max); \\n                }\\n                \\n                result.push_back(s);\\n                \\n                _min = INT_MAX;\\n                _max = INT_MIN;\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1294422,
                "title": "c-easy-to-understand",
                "content": "```\\npublic class Solution {\\n    public IList<string> SummaryRanges(int[] nums) {\\n        List<string> ans = new List<string>();        \\n        for(int i = 0; i < nums.Length; i++)\\n        {\\n            int first = nums[i];\\n            while(i + 1 < nums.Length && nums[i + 1] - nums[i] == 1)\\n                i++;\\n            ans.Add(nums[i] == first ? first + \"\" : first + \"->\" + nums[i]);\\n        }\\n        \\n        return ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public IList<string> SummaryRanges(int[] nums) {\\n        List<string> ans = new List<string>();        \\n        for(int i = 0; i < nums.Length; i++)\\n        {\\n            int first = nums[i];\\n            while(i + 1 < nums.Length && nums[i + 1] - nums[i] == 1)\\n                i++;\\n            ans.Add(nums[i] == first ? first + \"\" : first + \"->\" + nums[i]);\\n        }\\n        \\n        return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 928361,
                "title": "o-n-o-1-js-solution",
                "content": "```\\nvar summaryRanges = function(nums) {\\n    let i = 0, res = [];\\n    for (let j = 0; j < nums.length; j++) {\\n        if (nums[j+1] === nums[j] + 1) continue;\\n        else {\\n            if (i == j) res.push(nums[i] + \"\");\\n            else res.push( nums[i] + \"->\" + nums[j] );\\n            i = j + 1;\\n        }\\n    }\\n    return res;\\n    // Time Complexity: O(n)\\n    // Space Complexity: O(1)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar summaryRanges = function(nums) {\\n    let i = 0, res = [];\\n    for (let j = 0; j < nums.length; j++) {\\n        if (nums[j+1] === nums[j] + 1) continue;\\n        else {\\n            if (i == j) res.push(nums[i] + \"\");\\n            else res.push( nums[i] + \"->\" + nums[j] );\\n            i = j + 1;\\n        }\\n    }\\n    return res;\\n    // Time Complexity: O(n)\\n    // Space Complexity: O(1)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 914739,
                "title": "c-o-n-solution",
                "content": "**Complexity**\\n- Time: O(n)\\n- Space: O(n) for the output.\\n\\n**Implementation**\\n```\\npublic class Solution {\\n    public IList<string> SummaryRanges(int[] nums) {\\n        \\n        List<string> res = new List<string>();\\n        if(nums == null || nums.Length == 0)\\n            return res;\\n        \\n        for(int i = 0; i < nums.Length; i++)\\n        {\\n            int start = nums[i];\\n            \\n            while(i + 1 < nums.Length && nums[i + 1] - nums[i] == 1)\\n                i++;\\n            \\n            string range = nums[i] == start? start.ToString() : start + \"->\" + nums[i];\\n            \\n            res.Add(range);\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public IList<string> SummaryRanges(int[] nums) {\\n        \\n        List<string> res = new List<string>();\\n        if(nums == null || nums.Length == 0)\\n            return res;\\n        \\n        for(int i = 0; i < nums.Length; i++)\\n        {\\n            int start = nums[i];\\n            \\n            while(i + 1 < nums.Length && nums[i + 1] - nums[i] == 1)\\n                i++;\\n            \\n            string range = nums[i] == start? start.ToString() : start + \"->\" + nums[i];\\n            \\n            res.Add(range);\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 913894,
                "title": "c-simulation-on-example",
                "content": "```\\n/*\\nExample 1:\\nInput: nums = [0,1,2,4,5,7]\\nOutput: [\"0->2\",\"4->5\",\"7\"]\\nExplanation: The ranges are:\\n[0,2] --> \"0->2\"\\n[4,5] --> \"4->5\"\\n[7,7] --> \"7\"\\n*/\\nclass Solution { // Linear scan simulation\\npublic: // Time/Space: O(N); O(1)\\n    vector<string> summaryRanges(vector<int>& nums) {\\n        vector<string> ans;\\n        const int n = nums.size();        \\n        if(n == 0) return ans;\\n        int left = nums[0], right = nums[0];\\n        for(int i = 1; i < n; i++){            \\n            if(nums[i]!=right + 1){ \\n                if(left!=right) ans.emplace_back(to_string(left)+\"->\"+to_string(right));\\n                else ans.emplace_back(to_string(left));\\n                left = right = nums[i];\\n            }else right++;            \\n        }\\n        if(left!=right) ans.emplace_back(to_string(left)+\"->\"+to_string(right));\\n        else ans.emplace_back(to_string(left));\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\nExample 1:\\nInput: nums = [0,1,2,4,5,7]\\nOutput: [\"0->2\",\"4->5\",\"7\"]\\nExplanation: The ranges are:\\n[0,2] --> \"0->2\"\\n[4,5] --> \"4->5\"\\n[7,7] --> \"7\"\\n*/\\nclass Solution { // Linear scan simulation\\npublic: // Time/Space: O(N); O(1)\\n    vector<string> summaryRanges(vector<int>& nums) {\\n        vector<string> ans;\\n        const int n = nums.size();        \\n        if(n == 0) return ans;\\n        int left = nums[0], right = nums[0];\\n        for(int i = 1; i < n; i++){            \\n            if(nums[i]!=right + 1){ \\n                if(left!=right) ans.emplace_back(to_string(left)+\"->\"+to_string(right));\\n                else ans.emplace_back(to_string(left));\\n                left = right = nums[i];\\n            }else right++;            \\n        }\\n        if(left!=right) ans.emplace_back(to_string(left)+\"->\"+to_string(right));\\n        else ans.emplace_back(to_string(left));\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 545352,
                "title": "python3-o-n-solution",
                "content": "```\\nclass Solution:\\n    def summaryRanges(self, nums: List[int]) -> List[str]:\\n        result = []\\n        if nums:\\n            start = str(nums[0])\\n            end = str(nums[0])\\n            for i in nums[1:]:\\n                if abs(int(end)-i)>1:\\n                    if start!=end:\\n                        result.append(start+\"->\"+end)\\n                    else:\\n                        result.append(start)\\n                    start = str(i)\\n                    end = str(i)\\n                else:\\n                    end = str(i)\\n            if start!=end:\\n                result.append(start+\"->\"+end)\\n            else:\\n                result.append(start)\\n        return result\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def summaryRanges(self, nums: List[int]) -> List[str]:\\n        result = []\\n        if nums:\\n            start = str(nums[0])\\n            end = str(nums[0])\\n            for i in nums[1:]:\\n                if abs(int(end)-i)>1:\\n                    if start!=end:\\n                        result.append(start+\"->\"+end)\\n                    else:\\n                        result.append(start)\\n                    start = str(i)\\n                    end = str(i)\\n                else:\\n                    end = str(i)\\n            if start!=end:\\n                result.append(start+\"->\"+end)\\n            else:\\n                result.append(start)\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 517938,
                "title": "rust-solution",
                "content": "```rust\\nimpl Solution {\\n    pub fn summary_ranges(nums: Vec<i32>) -> Vec<String> {\\n        let mut answer = Vec::new();\\n        let mut i = 0;\\n        while i < nums.len() {\\n            let n = nums[i];\\n            while i < nums.len() - 1 && nums[i + 1] == nums[i] + 1 {\\n                i += 1;\\n            }\\n            let mut s = n.to_string();\\n            if n != nums[i] {\\n                s += \"->\";\\n                s += &nums[i].to_string();\\n            };\\n            answer.push(s);\\n            i += 1;\\n        }\\n        answer\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nimpl Solution {\\n    pub fn summary_ranges(nums: Vec<i32>) -> Vec<String> {\\n        let mut answer = Vec::new();\\n        let mut i = 0;\\n        while i < nums.len() {\\n            let n = nums[i];\\n            while i < nums.len() - 1 && nums[i + 1] == nums[i] + 1 {\\n                i += 1;\\n            }\\n            let mut s = n.to_string();\\n            if n != nums[i] {\\n                s += \"->\";\\n                s += &nums[i].to_string();\\n            };\\n            answer.push(s);\\n            i += 1;\\n        }\\n        answer\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 259553,
                "title": "python-easy-to-understand",
                "content": "A short and generalized version, easier to remember.\\n```\\nclass Solution:\\n    def summaryRanges(self, nums: List[int]) -> List[str]:\\n        begin, res = 0, []\\n        for i in range(len(nums)):\\n            if i + 1 >=len(nums) or nums[i+1]-nums[i] != 1:\\n                b = str(nums[begin])\\n                e =  str(nums[i])\\n                res.append(b + \"->\" + e if b != e else b)\\n                begin = i + 1\\n        return res\\n\\t",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "A short and generalized version, easier to remember.\\n```\\nclass Solution:\\n    def summaryRanges(self, nums: List[int]) -> List[str]:\\n        begin, res = 0, []\\n        for i in range(len(nums)):\\n            if i + 1 >=len(nums) or nums[i+1]-nums[i] != 1:\\n                b = str(nums[begin])\\n                e =  str(nums[i])\\n                res.append(b + \"->\" + e if b != e else b)\\n                begin = i + 1\\n        return res\\n\\t",
                "codeTag": "Java"
            },
            {
                "id": 244127,
                "title": "little-bit-different-solution",
                "content": "```\\nclass Solution:\\n    def summaryRanges(self, nums: List[int]) -> List[str]:\\n        ans, j = [], float(\"-inf\")\\n        for i in nums:\\n            if i>j:\\n                s = str(i)\\n                if i+1 in nums:\\n                    s = s+\"->\"\\n                    j = i\\n                    while j+1 in nums:\\n                        j += 1\\n                    s = s+str(j)\\n            if s not in ans:\\n                ans.append(s)\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def summaryRanges(self, nums: List[int]) -> List[str]:\\n        ans, j = [], float(\"-inf\")\\n        for i in nums:\\n            if i>j:\\n                s = str(i)\\n                if i+1 in nums:\\n                    s = s+\"->\"\\n                    j = i\\n                    while j+1 in nums:\\n                        j += 1\\n                    s = s+str(j)\\n            if s not in ans:\\n                ans.append(s)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 242238,
                "title": "c-two-pointer",
                "content": "Use two pointers (`i` and `j`) to track the boundaries of each range.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<string> summaryRanges(vector<int>& nums) {\\n        vector<string> summaries;\\n        for (int i = 0, j = 0; j < nums.size(); i = ++j) {\\n            while (j + 1 < nums.size() && nums[j + 1] == nums[j] + 1) {\\n                j++;\\n            }\\n            summaries.push_back(to_string(nums[i]) + (i < j ? \"->\" + to_string(nums[j]) : \"\"));\\n        }\\n        return summaries;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<string> summaryRanges(vector<int>& nums) {\\n        vector<string> summaries;\\n        for (int i = 0, j = 0; j < nums.size(); i = ++j) {\\n            while (j + 1 < nums.size() && nums[j + 1] == nums[j] + 1) {\\n                j++;\\n            }\\n            summaries.push_back(to_string(nums[i]) + (i < j ? \"->\" + to_string(nums[j]) : \"\"));\\n        }\\n        return summaries;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 164419,
                "title": "follow-up-in-a-real-interview-question-better-than-o-n",
                "content": "Most solutions are with O(n). But there are two follow-ups in a real interview.\\nFollow up 1: better than O(n)\\nHere is my solution, but O(nlogn) with the worst case.\\n```\\nclass Solution(object):\\n    \\n    \\n    def summaryRanges(self, nums):\\n        \\n        res = []\\n        i = 0\\n        while i < len(nums):\\n            lo, hi = i + 1, len(nums) - 1\\n            last = -1\\n            while lo <= hi:\\n                mid = (lo + hi) >> 1\\n                if nums[mid] - nums[i] <= mid - i:\\n                    last = mid\\n                    lo = mid + 1\\n                else:\\n                    hi = mid - 1\\n            if last == -1:\\n                res.append(str(nums[i]))\\n                i += 1\\n            else:\\n                res.append(str(nums[i]) + \\'->\\' + str(nums[last]))\\n                i = last + 1\\n        return res\\n```\\n\\nFollow up2, Can it be sovled  O(n) in the worst case?\\n\\nHere is my solution, but I am not certain it is correct.\\n```\\ndef summaryRanges(self, nums):\\n    \"\"\"\\n    :type nums: List[int]\\n    :rtype: List[str]\\n    \"\"\"\\n    res = []\\n     \\n    def qs(lo, hi):\\n        # only one element\\n        if lo == hi:\\n            # if there are consecutive numbers already\\n            if res and res[-1][1] == nums[lo] - 1:\\n                res[-1][1] = nums[lo]\\n            else:\\n                res.append([nums[lo], nums[lo]])\\n            return\\n        # if the array is consecutive\\n        if nums[hi] - nums[lo] == hi - lo:\\n            # there are consecutive numbers already\\n            if res and res[-1][1] == nums[lo] - 1:\\n                res[-1][1] = nums[hi]\\n            else:\\n                res.append([nums[lo], nums[hi]])\\n            return\\n        qs(lo, (lo + hi) / 2)\\n        qs((lo + hi) / 2 + 1, hi)\\n    if not nums:\\n        return []\\n    qs(0, len(nums) - 1)\\n    return [\"%s->%s\"%(i,j) if i != j else str(i) for i, j in res]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    \\n    \\n    def summaryRanges(self, nums):\\n        \\n        res = []\\n        i = 0\\n        while i < len(nums):\\n            lo, hi = i + 1, len(nums) - 1\\n            last = -1\\n            while lo <= hi:\\n                mid = (lo + hi) >> 1\\n                if nums[mid] - nums[i] <= mid - i:\\n                    last = mid\\n                    lo = mid + 1\\n                else:\\n                    hi = mid - 1\\n            if last == -1:\\n                res.append(str(nums[i]))\\n                i += 1\\n            else:\\n                res.append(str(nums[i]) + \\'->\\' + str(nums[last]))\\n                i = last + 1\\n        return res\\n```\n```\\ndef summaryRanges(self, nums):\\n    \"\"\"\\n    :type nums: List[int]\\n    :rtype: List[str]\\n    \"\"\"\\n    res = []\\n     \\n    def qs(lo, hi):\\n        # only one element\\n        if lo == hi:\\n            # if there are consecutive numbers already\\n            if res and res[-1][1] == nums[lo] - 1:\\n                res[-1][1] = nums[lo]\\n            else:\\n                res.append([nums[lo], nums[lo]])\\n            return\\n        # if the array is consecutive\\n        if nums[hi] - nums[lo] == hi - lo:\\n            # there are consecutive numbers already\\n            if res and res[-1][1] == nums[lo] - 1:\\n                res[-1][1] = nums[hi]\\n            else:\\n                res.append([nums[lo], nums[hi]])\\n            return\\n        qs(lo, (lo + hi) / 2)\\n        qs((lo + hi) / 2 + 1, hi)\\n    if not nums:\\n        return []\\n    qs(0, len(nums) - 1)\\n    return [\"%s->%s\"%(i,j) if i != j else str(i) for i, j in res]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 63280,
                "title": "not-brutal-force-best-o-logn-binary-search-approach",
                "content": "    /**\\n\\t * For each starting number S, find its most right element E which satisfies E - S == indexE - indexS.\\n\\t * @author xuechao\\n\\t *\\n\\t */    \\n    public List<String> summaryRanges(int[] nums) {\\n\\t\\tList<String> ret = new ArrayList<>();\\n\\t\\t//edge cases\\n\\t\\tif (nums == null || nums.length == 0) {\\n\\t\\t\\treturn ret;\\n\\t\\t}\\n\\t\\t//binary search. Finding most right element satisfying\\n\\t\\tint index = 0;\\n\\t\\twhile (index < nums.length) {\\n\\t\\t\\tint start = nums[index];\\n\\t\\t\\tint lo = index;\\n\\t\\t\\tint hi = nums.length -1 ;\\n\\t\\t\\twhile (lo < hi) {\\n\\t\\t\\t\\tint mid = lo + (hi - lo)/2;\\n\\t\\t\\t\\tif (nums[mid] > start + mid - index) {\\n\\t\\t\\t\\t\\t//get rid of unsatisfying ones\\n\\t\\t\\t\\t\\thi = mid - 1;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t//keep possible candidate\\n\\t\\t\\t\\t\\tlo = mid;\\n\\t\\t\\t\\t\\t//tie breaking. \\n\\t\\t\\t\\t\\tif (lo == hi - 1) {\\n\\t\\t\\t\\t\\t\\tif (nums[hi] == nums[lo] + 1) lo++;\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\tif (lo == index) {\\n\\t\\t\\t\\tret.add(\"\" + start);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tret.add(start + \"->\" + nums[lo]);\\n\\t\\t\\t}\\n                index =  lo + 1;\\n\\t\\t}\\n\\t\\t\\t\\n\\t\\treturn ret;\\n\\t}",
                "solutionTags": [],
                "code": "    /**\\n\\t * For each starting number S, find its most right element E which satisfies E - S == indexE - indexS.\\n\\t * @author xuechao\\n\\t *\\n\\t */    \\n    public List<String> summaryRanges(int[] nums) {\\n\\t\\tList<String> ret = new ArrayList<>();\\n\\t\\t//edge cases\\n\\t\\tif (nums == null || nums.length == 0) {\\n\\t\\t\\treturn ret;\\n\\t\\t}\\n\\t\\t//binary search. Finding most right element satisfying\\n\\t\\tint index = 0;\\n\\t\\twhile (index < nums.length) {\\n\\t\\t\\tint start = nums[index];\\n\\t\\t\\tint lo = index;\\n\\t\\t\\tint hi = nums.length -1 ;\\n\\t\\t\\twhile (lo < hi) {\\n\\t\\t\\t\\tint mid = lo + (hi - lo)/2;\\n\\t\\t\\t\\tif (nums[mid] > start + mid - index) {\\n\\t\\t\\t\\t\\t//get rid of unsatisfying ones\\n\\t\\t\\t\\t\\thi = mid - 1;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t//keep possible candidate\\n\\t\\t\\t\\t\\tlo = mid;\\n\\t\\t\\t\\t\\t//tie breaking. \\n\\t\\t\\t\\t\\tif (lo == hi - 1) {\\n\\t\\t\\t\\t\\t\\tif (nums[hi] == nums[lo] + 1) lo++;\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\tif (lo == index) {\\n\\t\\t\\t\\tret.add(\"\" + start);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tret.add(start + \"->\" + nums[lo]);\\n\\t\\t\\t}\\n                index =  lo + 1;\\n\\t\\t}\\n\\t\\t\\t\\n\\t\\treturn ret;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 63321,
                "title": "concise-and-easy-understanding-c-solutions",
                "content": "    class Solution {\\n    public:\\n        vector<string> summaryRanges(vector<int>& nums) {\\n            vector<string> ranges;\\n            if (nums.size() == 0)\\n                return ranges;\\n            int lower = 0;\\n            nums.push_back(INT_MAX);\\n            for (int i = 1; i < nums.size(); i++) {\\n                if (nums[i] > nums[i - 1] + 1) {\\n                    ranges.push_back(num2range(nums[lower], nums[i - 1]));\\n                    lower = i;\\n                }\\n            }\\n            return ranges;\\n        }\\n        \\n        string num2range(int lower, int upper) {\\n            if (lower == upper)\\n                return to_string(lower);\\n            return to_string(lower) + \"->\" + to_string(upper);\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        vector<string> summaryRanges(vector<int>& nums) {\\n            vector<string> ranges;\\n            if (nums.size() == 0)\\n                return ranges;\\n            int lower = 0;\\n            nums.push_back(INT_MAX);\\n            for (int i = 1; i < nums.size(); i++) {\\n                if (nums[i] > nums[i - 1] + 1) {\\n                    ranges.push_back(num2range(nums[lower], nums[i - 1]));\\n                    lower = i;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 63331,
                "title": "java-solution-with-1ms-runtime-what-s-the-complexity",
                "content": "    public class Solution {\\n        public List<String> summaryRanges(int[] nums) {\\n            int min;\\n            List<String> ls = new ArrayList<String>();\\n            \\n            if(nums.length > 0) {\\n                min = nums[0];\\n                for (int i = 0; i < nums.length;i++) {\\n                    if ((i+1 < nums.length) && (Math.abs(nums[i] - nums[i+1]) == 1)) {\\n                        continue;\\n                    } else {\\n                        if(min == nums[i]) \\n                                ls.add(nums[i]+\"\");\\n                        else \\n                            ls.add(min+\"->\"+nums[i]);\\n                        if(i+1 < nums.length) \\n                            min = nums[i+1];\\n                    }\\n                }\\n            }\\n            return ls;\\n        }\\n    }\\nwhat is the complexity ?",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public List<String> summaryRanges(int[] nums) {\\n            int min;\\n            List<String> ls = new ArrayList<String>();\\n            \\n            if(nums.length > 0) {\\n                min = nums[0];\\n                for (int i = 0; i < nums.length;i++) {\\n                    if ((i+1 < nums.length) && (Math.abs(nums[i] - nums[i+1]) == 1)) {\\n                        continue;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 63401,
                "title": "most-space-efficient-in-c-solutions",
                "content": "Dynamically allocate the 2-dimentional array.     \\n\\n    char** summaryRanges(int* nums, int numsSize, int* returnSize) {\\n\\n\\tchar **result = (char **)malloc(sizeof(char *));\\n\\t*returnSize = 0;\\n\\tint s = 0, e = 0;\\n\\n\\twhile (s < numsSize)\\n\\t{\\n\\t\\tif ((e + 1 < numsSize) && (nums[e + 1] == nums[e] + 1))\\n\\t\\t\\te++;\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tif (s == e)\\n\\t\\t\\t{\\n\\t\\t\\t\\t(*returnSize)++;\\n\\t\\t\\t\\tresult = (char **)realloc(result, (*returnSize)*sizeof(char *));\\n\\t\\t\\t\\tresult[*returnSize - 1] = (char *)malloc(12 * sizeof(char));//integer may have many decimal bits\\n\\t\\t\\t\\tsprintf(result[*returnSize - 1], \"%d\", nums[s]);\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\t(*returnSize)++;\\n\\t\\t\\t\\tresult = (char **)realloc(result, (*returnSize)*sizeof(char *));\\n\\t\\t\\t\\tresult[*returnSize - 1] = (char *)malloc(25 * sizeof(char)); //integer may have many decimal bits\\n\\t\\t\\t\\tsprintf(result[*returnSize - 1], \"%d->%d\", nums[s], nums[e]);\\n\\t\\t\\t}\\n\\t\\t\\ts = e + 1;\\n\\t\\t\\te = s;\\n\\t\\t}\\n\\t}\\n\\treturn result;\\n}",
                "solutionTags": [],
                "code": "Dynamically allocate the 2-dimentional array.     \\n\\n    char** summaryRanges(int* nums, int numsSize, int* returnSize) {\\n\\n\\tchar **result = (char **)malloc(sizeof(char *));\\n\\t*returnSize = 0;\\n\\tint s = 0, e = 0;\\n\\n\\twhile (s < numsSize)\\n\\t{\\n\\t\\tif ((e + 1 < numsSize) && (nums[e + 1] == nums[e] + 1))\\n\\t\\t\\te++;\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tif (s == e)\\n\\t\\t\\t{\\n\\t\\t\\t\\t(*returnSize)++;\\n\\t\\t\\t\\tresult = (char **)realloc(result, (*returnSize)*sizeof(char *));\\n\\t\\t\\t\\tresult[*returnSize - 1] = (char *)malloc(12 * sizeof(char));//integer may have many decimal bits\\n\\t\\t\\t\\tsprintf(result[*returnSize - 1], \"%d\", nums[s]);\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\t(*returnSize)++;\\n\\t\\t\\t\\tresult = (char **)realloc(result, (*returnSize)*sizeof(char *));\\n\\t\\t\\t\\tresult[*returnSize - 1] = (char *)malloc(25 * sizeof(char)); //integer may have many decimal bits\\n\\t\\t\\t\\tsprintf(result[*returnSize - 1], \"%d->%d\", nums[s], nums[e]);\\n\\t\\t\\t}\\n\\t\\t\\ts = e + 1;\\n\\t\\t\\te = s;\\n\\t\\t}\\n\\t}\\n\\treturn result;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 63407,
                "title": "my-java-solution-in-detail",
                "content": "public class SummaryRanges {\\n\\t\\n\\tpublic List<String> summaryRanges(int nums[]){\\n\\t\\t\\n\\t\\t\\n        List<String> ranges = new ArrayList<String>(); //Initialize the return array\\n        \\n        if(nums.length == 0){ //If the array is empty, return directly\\n            return ranges;\\n        }\\n        \\n        if(nums.length == 1){ //If the array has a length of 1, just add to the return array\\n            ranges.add(String.valueOf(nums[0]));\\n        }\\n        \\n        int start = nums[0]; //Initialize an integer marker to mark the start of each range\\n        \\n        String pointer = \"->\";\\n        \\n        //Main logic goes here\\n        for(int i=0;i<=nums.length-2;i++){\\n            if(nums[i+1]-nums[i]!=1){       //Judge whether two adjacent integers are in same range\\n                if(nums[i] != start){       //If the start marker not equals to the number at current index,\\n                \\t                        //it means that this range has more than two elements\\n                  ranges.add(String.valueOf(start)+pointer+String.valueOf(nums[i]));\\n                }else{                      //Else, this range only contains one element.\\n                  ranges.add(String.valueOf(nums[i]));\\n                }\\n                if(i==nums.length-2){       //And we have to judge whether the next element is the last one element in array\\n                    ranges.add(String.valueOf(nums[i+1]));//If true, simply treat the last element as a new range and break from the loop\\n                    break;\\n                }\\n                start = nums[i+1];   //Otherwise, reset the start marker to the next element\\n            }else{\\n                if(i==nums.length-2){//If the last element is still within a range, end this loop by adding the last range to the return array\\n                    ranges.add(String.valueOf(start)+pointer+String.valueOf(nums[i+1]));\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return ranges;\\n\\t}\\n\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "public class SummaryRanges {\\n\\t\\n\\tpublic List<String> summaryRanges(int nums[]){\\n\\t\\t\\n\\t\\t\\n        List<String> ranges = new ArrayList<String>(); //Initialize the return array\\n        \\n        if(nums.length == 0){ //If the array is empty, return directly\\n            return ranges;\\n        }\\n        \\n        if(nums.length == 1){ //If the array has a length of 1, just add to the return array\\n            ranges.add(String.valueOf(nums[0]));\\n        }\\n        \\n        int start = nums[0]; //Initialize an integer marker to mark the start of each range\\n        \\n        String pointer = \"->\";\\n        \\n        //Main logic goes here\\n        for(int i=0;i<=nums.length-2;i++){\\n            if(nums[i+1]-nums[i]!=1){       //Judge whether two adjacent integers are in same range\\n                if(nums[i] != start){       //If the start marker not equals to the number at current index,\\n                \\t                        //it means that this range has more than two elements\\n                  ranges.add(String.valueOf(start)+pointer+String.valueOf(nums[i]));\\n                }else{                      //Else, this range only contains one element.\\n                  ranges.add(String.valueOf(nums[i]));\\n                }\\n                if(i==nums.length-2){       //And we have to judge whether the next element is the last one element in array\\n                    ranges.add(String.valueOf(nums[i+1]));//If true, simply treat the last element as a new range and break from the loop\\n                    break;\\n                }\\n                start = nums[i+1];   //Otherwise, reset the start marker to the next element\\n            }else{\\n                if(i==nums.length-2){//If the last element is still within a range, end this loop by adding the last range to the return array\\n                    ranges.add(String.valueOf(start)+pointer+String.valueOf(nums[i+1]));\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return ranges;\\n\\t}\\n\\n}",
                "codeTag": "Java"
            },
            {
                "id": 63433,
                "title": "my-concise-c-solution-with-0ms",
                "content": "\\n\\n\\nclass Solution {\\npublic:\\n\\n    vector<string> summaryRanges(vector<int>& nums) {\\n        \\n        vector<string> result;\\n        for(int i = 0; i < nums.size();)\\n        {\\n            int j = i + 1;\\n            while(j < nums.size() && ((j-i) == (nums[j]-nums[i]))) j++;  //(j-i) == (nums[j]-nums[i])\\n            \\n            if(j-1 > i)\\n            {\\n                result.push_back(to_string(nums[i]) + \"->\" + to_string(nums[j-1]));\\n            }\\n            else\\n            {\\n                result.push_back(to_string(nums[i]));\\n            }\\n            \\n            i = j; //Update i\\n        }\\n        \\n        return result;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n    vector<string> summaryRanges(vector<int>& nums) {\\n        \\n        vector<string> result;\\n        for(int i = 0; i < nums.size();)\\n        {\\n            int j = i + 1;\\n            while(j < nums.size() && ((j-i) == (nums[j]-nums[i]))) j++;  //(j-i) == (nums[j]-nums[i])\\n            \\n            if(j-1 > i)\\n            {\\n                result.push_back(to_string(nums[i]) + \"->\" + to_string(nums[j-1]));\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 63459,
                "title": "general-and-easy-to-understand-python-implementation",
                "content": "The basic idea is based on 2 lists. One (list r) is used to record the start and end of the range and therefore it stores at most 2 elements. Another one (list ranges) collects all the ranges in the list nums.  \\n\\n for example:\\n\\n     nums = [0, 1, 2, 4, 5, 7]\\n     r = [\"0\"]\\n     ranges = []\\n    -------------\\n     r = [\"0\", \"1\"]\\n     ranges = []\\n     ------------\\n    r = [\"0\",\"2\"]\\n    ranges = []\\n    -------------\\n    r = [\"4\"]\\n    ranges = [[\"0\",\"2\"]]\\n    -------------\\n    r = [\"4\", \"5\"]\\n    ranges = [[\"0\", \"2\"]]\\n    -------------\\n    r = [\"7\"]\\n    ranges = [[\"0\", \"2\"], [\"4\", \"5\"]]\\n    -------------\\n    r = [\"7\"]\\n    ranges = [[\"0\", \"2\"], [\"4\", \"5\"], [\"7\"]]\\n               \\nCodes:\\n\\n    class Solution:\\n        # @param {integer[]} nums\\n        # @return {string[]}\\n        def summaryRanges(self, nums):\\n      \\n            def add_range(r, num):\\n                \"\"\" function to add num to r.\\n                r only store 2 elements.\\n                \"\"\"\\n                if len(r) < 2:\\n                    r.append(num)\\n                else:\\n                    r[-1] = num\\n\\n            if not nums:\\n                return []\\n\\n            ranges, r = [], [str(nums[0])]\\n            \\n            i = 1\\n            while i < len(nums):\\n                #if nums[i] - 1 != num[i-1]\\n                if str(nums[i] - 1) not in r:\\n                    #add range r to ranges\\n                    ranges.append(r)\\n                    #clear range r\\n                    r = []\\n                #update r\\n                add_range(r, str(nums[i]))\\n                i += 1\\n            #for the last range r to ranges\\n            ranges.append(r)\\n                    \\n            return map('->'.join, ranges)",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n        # @param {integer[]}",
                "codeTag": "Java"
            },
            {
                "id": 63468,
                "title": "share-my-java-accepted-solution",
                "content": "    public List<String> summaryRanges(int[] nums) {\\n        List<String> list = new ArrayList<String>();\\n        int i = 0;\\n        while (i < nums.length) {\\n            StringBuilder builder = new StringBuilder();\\n            builder.append(nums[i]);\\n            int flag = 0;\\n            while (i < nums.length - 1 && nums[i] + 1 == nums[i + 1]) {\\n                flag = 1;\\n                i ++;\\n            }\\n            if (flag == 1) {\\n                builder.append(\"->\");\\n                builder.append(nums[i]);\\n            }\\n            list.add(builder.toString());\\n            i ++;\\n        }\\n        return list;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public List<String> summaryRanges(int[] nums) {\\n        List<String> list = new ArrayList<String>();\\n        int i = 0;\\n        while (i < nums.length) {\\n            StringBuilder builder = new StringBuilder();\\n            builder.append(nums[i]);\\n            int flag = 0;\\n            while (i < nums.length - 1 && nums[i] + 1 == nums[i + 1]) {\\n                flag = 1;\\n                i ++;\\n            }\\n            if (flag == 1) {\\n                builder.append(\"->\");\\n                builder.append(nums[i]);\\n            }\\n            list.add(builder.toString());\\n            i ++;\\n        }\\n        return list;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 63472,
                "title": "python-straight-forward-and-groupby-solution",
                "content": "    class Solution:\\n    # @param {integer[]} nums\\n    # @return {string[]}\\n    def summaryRanges(self, nums):\\n        ans = []\\n        start = 0\\n        for n in range(1, len(nums)):\\n            if nums[n] != nums[n - 1] + 1:\\n                ans.append('{}->{}'.format(nums[start], nums[n - 1]))\\n                start = n\\n        nums and ans.append('{}->{}'.format(nums[start], nums[-1]))\\n        return [i.replace('->' + i[:len(i) // 2 - 1], '') for i in ans]\\n\\nitertools.groupby\\n\\n    class Solution:\\n    # @param {integer[]} nums\\n    # @return {string[]}\\n    def summaryRanges(self, nums):\\n        f = lambda x: x[0] - x[1]\\n        groups = [list(g) for _, g in itertools.groupby(enumerate(nums), f)]\\n        groups = ['{}->{}'.format(g[0][1], g[-1][1])\\n                  if len(g) > 1 else str(g[0][1]) for g in groups]\\n        return groups",
                "solutionTags": [],
                "code": "class Solution:\\n    # @param {integer[]}",
                "codeTag": "Java"
            },
            {
                "id": 63481,
                "title": "my-accepted-python-solution",
                "content": "record the ranges, then covert the range to the wanted string, and append the string to the result\\n\\n    def summaryRanges(self, nums):\\n        def getRange(begin, end):\\n            return str(begin)+\"->\" + str(end) if begin != end else str(begin)\\n        n = len(nums)\\n        if n==0:\\n            return []\\n        res = []\\n        pre = start = nums[0]\\n        for num in nums:\\n            cur = num \\n            if cur - pre > 1:\\n                res.append(getRange(start, pre))\\n                start = cur\\n            if cur == nums[-1]:\\n                res.append(getRange(start, cur))\\n            pre = cur\\n        return res",
                "solutionTags": [],
                "code": "record the ranges, then covert the range to the wanted string, and append the string to the result\\n\\n    def summaryRanges(self, nums):\\n        def getRange(begin, end):\\n            return str(begin)+\"->\" + str(end) if begin != end else str(begin)\\n        n = len(nums)\\n        if n==0:\\n            return []\\n        res = []\\n        pre = start = nums[0]\\n        for num in nums:\\n            cur = num \\n            if cur - pre > 1:\\n                res.append(getRange(start, pre))\\n                start = cur\\n            if cur == nums[-1]:\\n                res.append(getRange(start, cur))\\n            pre = cur\\n        return res",
                "codeTag": "Python3"
            },
            {
                "id": 63492,
                "title": "7-9-lines-in-c",
                "content": "**Solution 1**\\n\\nGo through the numbers, `i0` is the index where the current range starts and `i` is the current index. At the end of a range, recognized by `i == nums.size()-1 || nums[i+1] > nums[i]+1`, add the range to the output and update `i0` for the next range.\\n\\n    vector<string> summaryRanges(vector<int>& nums) {\\n        vector<string> ranges;\\n        for (int i=0, i0=0; i<nums.size(); i++) {\\n            if (i == nums.size()-1 || nums[i+1] > nums[i]+1) {\\n                ranges.push_back(to_string(nums[i0]));\\n                if (i > i0) ranges.back() += \"->\" + to_string(nums[i]);\\n                i0 = i + 1;\\n            }\\n        }\\n        return ranges;\\n    }\\n\\n**Solution 2**\\n\\nI saw [lestrois's solution](https://leetcode.com/discuss/42198/a-7-line-c%23-plain-solution) and then wrote that approach myself in C++. For each range, find its end and then add the range to the output.\\n\\n    vector<string> summaryRanges(vector<int>& nums) {\\n        vector<string> ranges;\\n        for (int i=0, i0=0; i<nums.size(); i0=++i) {\\n            while (i+1<nums.size() && nums[i+1]==nums[i]+1) i++;\\n            ranges.push_back(to_string(nums[i0]));\\n            if (i > i0) ranges.back() += \"->\" + to_string(nums[i]);\\n        }\\n        return ranges;\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "**Solution 1**\\n\\nGo through the numbers, `i0` is the index where the current range starts and `i` is the current index. At the end of a range, recognized by `i == nums.size()-1 || nums[i+1] > nums[i]+1`, add the range to the output and update `i0` for the next range.\\n\\n    vector<string> summaryRanges(vector<int>& nums) {\\n        vector<string> ranges;\\n        for (int i=0, i0=0; i<nums.size(); i++) {\\n            if (i == nums.size()-1 || nums[i+1] > nums[i]+1) {\\n                ranges.push_back(to_string(nums[i0]));\\n                if (i > i0) ranges.back() += \"->\" + to_string(nums[i]);\\n                i0 = i + 1;\\n            }\\n        }\\n        return ranges;\\n    }\\n\\n**Solution 2**\\n\\nI saw [lestrois's solution](https://leetcode.com/discuss/42198/a-7-line-c%23-plain-solution) and then wrote that approach myself in C++. For each range, find its end and then add the range to the output.\\n\\n    vector<string> summaryRanges(vector<int>& nums) {\\n        vector<string> ranges;\\n        for (int i=0, i0=0; i<nums.size(); i0=++i) {\\n            while (i+1<nums.size() && nums[i+1]==nums[i]+1) i++;\\n            ranges.push_back(to_string(nums[i0]));\\n            if (i > i0) ranges.back() += \"->\" + to_string(nums[i]);\\n        }\\n        return ranges;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 63486,
                "title": "a-7-line-c-plain-solution",
                "content": "    public IList<string> SummaryRanges(int[] nums) {\\n        List<string> result = new List<string>();\\n        for(int i = 0, wall = 0; i < nums.Length; wall = ++i){\\n            while(i + 1 < nums.Length && nums[i + 1] - nums[i] == 1) i++;\\n            if(wall == i) result.Add(nums[wall].ToString());\\n            else result.Add(nums[wall] + \"->\" + nums[i]);\\n        }\\n        return result;\\n    }",
                "solutionTags": [],
                "code": "    public IList<string> SummaryRanges(int[] nums) {\\n        List<string> result = new List<string>();\\n        for(int i = 0, wall = 0; i < nums.Length; wall = ++i){\\n            while(i + 1 < nums.Length && nums[i + 1] - nums[i] == 1) i++;\\n            if(wall == i) result.Add(nums[wall].ToString());\\n            else result.Add(nums[wall] + \"->\" + nums[i]);\\n        }\\n        return result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3860778,
                "title": "python-simple-solution-beats-93-tc-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIt is sorted and in a range the element next to \"n\" has to be \\n\"n+1\". it can be used to derive a simple solution to this problem.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTake a variable to keep the starting point of the range and an other variable to keep the current or last of the range.\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def summaryRanges(self, nums: List[int]) -> List[str]:\\n        ans = []\\n        if not len(nums):\\n            return ans\\n        num = nums[0]\\n        temp = nums[0]\\n        \\n\\n        for i in range(1,len(nums)):\\n            if nums[i] == temp+1:\\n                temp = nums[i]\\n            else:\\n                if (temp - num) >= 1:\\n                       ans.append(f\"{num}->{temp}\")\\n                else:\\n                    ans.append(str(num))\\n                num = nums[i]\\n                temp = nums[i]\\n\\n        # to add the last elements in the list.\\n        if (temp - num) >= 1:   \\n            ans.append(f\"{num}->{temp}\")\\n        else:\\n            ans.append(str(num))\\n\\n        return ans\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def summaryRanges(self, nums: List[int]) -> List[str]:\\n        ans = []\\n        if not len(nums):\\n            return ans\\n        num = nums[0]\\n        temp = nums[0]\\n        \\n\\n        for i in range(1,len(nums)):\\n            if nums[i] == temp+1:\\n                temp = nums[i]\\n            else:\\n                if (temp - num) >= 1:\\n                       ans.append(f\"{num}->{temp}\")\\n                else:\\n                    ans.append(str(num))\\n                num = nums[i]\\n                temp = nums[i]\\n\\n        # to add the last elements in the list.\\n        if (temp - num) >= 1:   \\n            ans.append(f\"{num}->{temp}\")\\n        else:\\n            ans.append(str(num))\\n\\n        return ans\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3841841,
                "title": "simple-java-solution-beats-100",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<String> summaryRanges(int[] nums) {\\n        final int length = nums.length;\\n        final List<String> result = new ArrayList<>(length);\\n\\n        for (int index = 0; index < length; index++) {\\n            final int current = nums[index];\\n            final StringBuilder sb = new StringBuilder().append(current);\\n            int predict = current + 1;\\n\\n            // skip all consecutive numbers\\n            while (++index < length && predict == nums[index]) {\\n                ++predict;                \\n            }\\n\\n            // substract 1 because nums[index] breaks the subsequence\\n            if (current != nums[--index]) {\\n                sb.append(\"->\").append(nums[index]);\\n            } \\n            result.add(sb.toString());\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> summaryRanges(int[] nums) {\\n        final int length = nums.length;\\n        final List<String> result = new ArrayList<>(length);\\n\\n        for (int index = 0; index < length; index++) {\\n            final int current = nums[index];\\n            final StringBuilder sb = new StringBuilder().append(current);\\n            int predict = current + 1;\\n\\n            // skip all consecutive numbers\\n            while (++index < length && predict == nums[index]) {\\n                ++predict;                \\n            }\\n\\n            // substract 1 because nums[index] breaks the subsequence\\n            if (current != nums[--index]) {\\n                sb.append(\"->\").append(nums[index]);\\n            } \\n            result.add(sb.toString());\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3767262,
                "title": "java-easy-understanding-solution-o-n",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1) auxilary space\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<String> summaryRanges(int[] nums) {\\n     List<String> list = new ArrayList<>();\\n     if(nums.length == 1) {\\n         list.add(nums[0] + \"\");\\n         return list;\\n     }   \\n     for(int i = 0; i < nums.length; i ++) {\\n         int a = nums[i];\\n         while(i + 1 < nums.length && nums[i + 1] - nums[i] == 1) i ++;\\n         if(a != nums[i]) \\n             list.add(a + \"->\" + nums[i]);\\n         else\\n             list.add(a + \"\");\\n     }\\n     return list;\\n    }\\n}\\n```\\n# PLEASE UPVOTE IF IT WAS HELPFULL",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> summaryRanges(int[] nums) {\\n     List<String> list = new ArrayList<>();\\n     if(nums.length == 1) {\\n         list.add(nums[0] + \"\");\\n         return list;\\n     }   \\n     for(int i = 0; i < nums.length; i ++) {\\n         int a = nums[i];\\n         while(i + 1 < nums.length && nums[i + 1] - nums[i] == 1) i ++;\\n         if(a != nums[i]) \\n             list.add(a + \"->\" + nums[i]);\\n         else\\n             list.add(a + \"\");\\n     }\\n     return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3657849,
                "title": "python-simple-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def summaryRanges(self, nums: List[int]) -> List[str]:\\n        ranges = [] # [start, end] or [x, y]\\n        for i, n in enumerate(nums):\\n            if ranges and ranges[-1][1] == n-1:\\n                ranges[-1][1] = n\\n            else:\\n                ranges.append([n, n])\\n\\n        return [f\\'{x}->{y}\\' if x != y else f\\'{x}\\' for x, y in ranges]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def summaryRanges(self, nums: List[int]) -> List[str]:\\n        ranges = [] # [start, end] or [x, y]\\n        for i, n in enumerate(nums):\\n            if ranges and ranges[-1][1] == n-1:\\n                ranges[-1][1] = n\\n            else:\\n                ranges.append([n, n])\\n\\n        return [f\\'{x}->{y}\\' if x != y else f\\'{x}\\' for x, y in ranges]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3634559,
                "title": "easy-linear-approach-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMain idea is to maintain a \"Streak\" which is basically numbers in natural progression (difference between consecutive array values is of 1)\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe check if the current element and the next element are having a difference of 1. If they do have it, then we increment streak by 1. This is to get the range. If the streak is broken i.e. difference current and next to current number is not one, then we have to append to the solution.\\n\\nIf the streak is 0, or the single element case where streak is like a->a, we simply push the character to the result vector of string. Otherwise, we can get our range by subtracting streak of current index (streak cannot exceed the length of array because of how it is handled in the logic).\\n\\nAnd the end point of the range is the current index where the streak was broken.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n&emsp; *Not including result array here because that is necessary*\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> summaryRanges(vector<int>& nums) {\\n        string temp = \"\";\\n        vector<string> res;\\n        int streak = 0, n = nums.size(), start;\\n        for(int i = 0 ; i < n ; i++){\\n            start = nums[i];\\n            if (i < nums.size() - 1 && start + 1 == nums[i + 1]) {\\n                streak++;\\n            }\\n            else{\\n                if(streak == 0){\\n                    temp = to_string(nums[i - streak]);\\n                }\\n                else{\\n                    temp = to_string(nums[i - streak]) + \"->\" + to_string(start);\\n                    streak = 0;\\n                }\\n                res.push_back(temp);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> summaryRanges(vector<int>& nums) {\\n        string temp = \"\";\\n        vector<string> res;\\n        int streak = 0, n = nums.size(), start;\\n        for(int i = 0 ; i < n ; i++){\\n            start = nums[i];\\n            if (i < nums.size() - 1 && start + 1 == nums[i + 1]) {\\n                streak++;\\n            }\\n            else{\\n                if(streak == 0){\\n                    temp = to_string(nums[i - streak]);\\n                }\\n                else{\\n                    temp = to_string(nums[i - streak]) + \"->\" + to_string(start);\\n                    streak = 0;\\n                }\\n                res.push_back(temp);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3633519,
                "title": "c-super-easy-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> summaryRanges(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<string> ans;\\n        for(int i=0; i<n; i++){\\n            int start = nums[i];\\n            while(i+1 < n && nums[i] + 1 == nums[i+1]){\\n                i++;\\n            }\\n            if(start != nums[i]){\\n                ans.push_back(to_string(start) + \"->\" + to_string(nums[i]));\\n            }\\n            else{\\n                ans.push_back(to_string(start));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> summaryRanges(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<string> ans;\\n        for(int i=0; i<n; i++){\\n            int start = nums[i];\\n            while(i+1 < n && nums[i] + 1 == nums[i+1]){\\n                i++;\\n            }\\n            if(start != nums[i]){\\n                ans.push_back(to_string(start) + \"->\" + to_string(nums[i]));\\n            }\\n            else{\\n                ans.push_back(to_string(start));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3630395,
                "title": "c-solution",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> summaryRanges(vector<int>& nums) {\\n        vector<string> ans;\\n        for (int i = 0; i < nums.size(); i++) {\\n            int start = nums[i];\\n            while (i + 1 < nums.size() && nums[i] + 1 == nums[i + 1]) i++;\\n            if (start != nums[i]) ans.push_back(to_string(start) + \"->\" + to_string(nums[i]));\\n            else ans.push_back(to_string(start));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> summaryRanges(vector<int>& nums) {\\n        vector<string> ans;\\n        for (int i = 0; i < nums.size(); i++) {\\n            int start = nums[i];\\n            while (i + 1 < nums.size() && nums[i] + 1 == nums[i + 1]) i++;\\n            if (start != nums[i]) ans.push_back(to_string(start) + \"->\" + to_string(nums[i]));\\n            else ans.push_back(to_string(start));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3629975,
                "title": "python-code-easy-solution",
                "content": "# Intuition\\nwe need to check for the continuity of numbers.We check \\nif(nums[i]+1==nums[i])\\nand if it is false it means the loop should break and one end is marked by nums[i] and add it to ans.\\n# Approach\\nwe start from beginning and wherever the nums[i]+1!=nums[i] we make it as end add it to ans. The next nums[i] becomes the start and again we check for nums[i]+1!=nums[i] that marks the end range.\\n# Complexity\\n- Time complexity:\\nThe time complexity of the provided code is O(n), where n is the length of the input list nums. This is because the code iterates through the elements of nums once using the while loop. In the worst case, each element is visited once.\\n\\n- Space complexity:\\nThe space complexity of the code is O(1) because the space used is constant and does not depend on the size of the input. \\n\\n# Code\\n```\\nclass Solution:\\n    def summaryRanges(self, nums: List[int]) -> List[str]:\\n        ans=[]\\n        i=0\\n        while(i<len(nums)-1):\\n            if (nums[i]+1!=nums[i+1]):\\n                ans.append(str(nums[i]))\\n            else:\\n                a=nums[i]\\n                while(i<len(nums)-1 and nums[i]+1==nums[i+1]):\\n                    i+=1\\n                b=nums[i]\\n                t=str(a)+\"->\"+str(b)\\n                ans.append(t)\\n            i+=1\\n        if (i==len(nums)-1):\\n            ans.append(str(nums[len(nums)-1]))\\n        return(ans)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def summaryRanges(self, nums: List[int]) -> List[str]:\\n        ans=[]\\n        i=0\\n        while(i<len(nums)-1):\\n            if (nums[i]+1!=nums[i+1]):\\n                ans.append(str(nums[i]))\\n            else:\\n                a=nums[i]\\n                while(i<len(nums)-1 and nums[i]+1==nums[i+1]):\\n                    i+=1\\n                b=nums[i]\\n                t=str(a)+\"->\"+str(b)\\n                ans.append(t)\\n            i+=1\\n        if (i==len(nums)-1):\\n            ans.append(str(nums[len(nums)-1]))\\n        return(ans)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3628888,
                "title": "c-easy-100-faster-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> summaryRanges(vector<int>& nums) {\\n    vector<string> s;\\n    if(nums.size() == 0) return {};\\n    // long long prev = nums[0];\\n    \\n    // string temp = to_string(nums[0]);\\n    // temp += \"->\";\\n    long long n = nums.size();\\n    // long long next =  prev;\\n    int start = 0;\\n    int end = 1;\\n    int diff = 1;\\n    while(end<n){\\n        if( (abs(long(nums[start]) - long (nums[end]))) == diff){\\n            diff++;\\n            end++;\\n        }\\n        else{\\n            string temp;\\n            if(start == end-1){\\n               temp = to_string(nums[start]);\\n            }\\n            else  temp = to_string(nums[start]) + \"->\" + to_string(nums[end-1]);\\n            diff = 1;\\n            s.push_back(temp);\\n            start = end;\\n            end++;\\n        }\\n\\n    }\\n       string temp;\\n    if(start == end-1) temp = to_string(nums[start]);\\n            \\n    else  temp = to_string(nums[start]) + \"->\" + to_string(nums[end-1]);\\n    //  temp = to_string(nums[start]) + \"->\" + to_string(nums[end-1]);\\n    s.push_back(temp);\\n    \\n    return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> summaryRanges(vector<int>& nums) {\\n    vector<string> s;\\n    if(nums.size() == 0) return {};\\n    // long long prev = nums[0];\\n    \\n    // string temp = to_string(nums[0]);\\n    // temp += \"->\";\\n    long long n = nums.size();\\n    // long long next =  prev;\\n    int start = 0;\\n    int end = 1;\\n    int diff = 1;\\n    while(end<n){\\n        if( (abs(long(nums[start]) - long (nums[end]))) == diff){\\n            diff++;\\n            end++;\\n        }\\n        else{\\n            string temp;\\n            if(start == end-1){\\n               temp = to_string(nums[start]);\\n            }\\n            else  temp = to_string(nums[start]) + \"->\" + to_string(nums[end-1]);\\n            diff = 1;\\n            s.push_back(temp);\\n            start = end;\\n            end++;\\n        }\\n\\n    }\\n       string temp;\\n    if(start == end-1) temp = to_string(nums[start]);\\n            \\n    else  temp = to_string(nums[start]) + \"->\" + to_string(nums[end-1]);\\n    //  temp = to_string(nums[start]) + \"->\" + to_string(nums[end-1]);\\n    s.push_back(temp);\\n    \\n    return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3628438,
                "title": "simple-c-solution-arrays",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\n**O(n)**\\n\\n- Space complexity:\\n**O(n)**\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> summaryRanges(vector<int>& vec) {\\n        vector<string>res;\\n        if(vec.size()==0){\\n            return res;\\n        }\\n        if(vec.size()==1){\\n            string p=to_string(vec[0]);\\n            res.push_back(p);\\n            return res;\\n        }\\n        int n=vec.size();\\n        int l=0,r=0;\\n        int i=0;\\n        vector<pair<int,int>>ans;\\n        while(i<n-1){\\n            if(vec[i]+1==vec[i+1]){\\n                r++;\\n            }\\n            else if(vec[i]+1!=vec[i+1]){\\n                ans.push_back({vec[l],vec[r]});\\n                l=i+1;\\n                r=i+1;\\n            }\\n            i++;\\n        }\\n        if(vec[i]==vec[i-1]+1){\\n            ans.push_back({vec[l],vec[r]});\\n        }\\n        else{\\n            ans.push_back({vec[l],vec[r]});\\n        }\\n        for(auto ele:ans){\\n            string temp=\"\";\\n            cout<<ele.first<<\" \"<<ele.second<<endl;\\n            if(ele.first!=ele.second){\\n                temp+=(to_string(ele.first));\\n                temp+=\"->\";\\n                temp+=(to_string(ele.second));\\n            }\\n            else{\\n                temp+=(to_string(ele.first));\\n            }\\n            res.push_back(temp);\\n        }\\n        return res;\\n    }\\n    //<!-- Please upvote if you liked!!! -->\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> summaryRanges(vector<int>& vec) {\\n        vector<string>res;\\n        if(vec.size()==0){\\n            return res;\\n        }\\n        if(vec.size()==1){\\n            string p=to_string(vec[0]);\\n            res.push_back(p);\\n            return res;\\n        }\\n        int n=vec.size();\\n        int l=0,r=0;\\n        int i=0;\\n        vector<pair<int,int>>ans;\\n        while(i<n-1){\\n            if(vec[i]+1==vec[i+1]){\\n                r++;\\n            }\\n            else if(vec[i]+1!=vec[i+1]){\\n                ans.push_back({vec[l],vec[r]});\\n                l=i+1;\\n                r=i+1;\\n            }\\n            i++;\\n        }\\n        if(vec[i]==vec[i-1]+1){\\n            ans.push_back({vec[l],vec[r]});\\n        }\\n        else{\\n            ans.push_back({vec[l],vec[r]});\\n        }\\n        for(auto ele:ans){\\n            string temp=\"\";\\n            cout<<ele.first<<\" \"<<ele.second<<endl;\\n            if(ele.first!=ele.second){\\n                temp+=(to_string(ele.first));\\n                temp+=\"->\";\\n                temp+=(to_string(ele.second));\\n            }\\n            else{\\n                temp+=(to_string(ele.first));\\n            }\\n            res.push_back(temp);\\n        }\\n        return res;\\n    }\\n    //<!-- Please upvote if you liked!!! -->\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3628390,
                "title": "easy-java-solution-beginner-friendly",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<String> summaryRanges(int[] nums) {\\n        List<String> ans = new ArrayList<>();\\n        if(nums.length == 0){\\n            return ans;\\n        }\\n        int count = 1;\\n        int prevIndex = 0;\\n        int i;\\n        for(i = 1; i < nums.length; i ++){\\n            if(nums[i] - nums[i-1] == 1){\\n                count++;\\n                continue;\\n            }else{\\n                if(count == 1){\\n                    ans.add(nums[prevIndex] + \"\");\\n                }else{\\n                    ans.add(nums[prevIndex] + \"->\" +nums[i-1]);\\n                }\\n                prevIndex = i;\\n                count = 1;\\n            }\\n        }\\n        if(count == 1){\\n            ans.add(nums[prevIndex] + \"\");\\n        }else{\\n            ans.add(nums[prevIndex] + \"->\" +nums[i-1]);\\n        }\\n        return ans;\\n    }\\n}\\n```\\n**If you really found my solution helpful please upvote it, as it motivates me to post such kind of codes and help the coding community, if you have some queries or some improvements please feel free to comment and share your views.\\nHappy Coding**",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> summaryRanges(int[] nums) {\\n        List<String> ans = new ArrayList<>();\\n        if(nums.length == 0){\\n            return ans;\\n        }\\n        int count = 1;\\n        int prevIndex = 0;\\n        int i;\\n        for(i = 1; i < nums.length; i ++){\\n            if(nums[i] - nums[i-1] == 1){\\n                count++;\\n                continue;\\n            }else{\\n                if(count == 1){\\n                    ans.add(nums[prevIndex] + \"\");\\n                }else{\\n                    ans.add(nums[prevIndex] + \"->\" +nums[i-1]);\\n                }\\n                prevIndex = i;\\n                count = 1;\\n            }\\n        }\\n        if(count == 1){\\n            ans.add(nums[prevIndex] + \"\");\\n        }else{\\n            ans.add(nums[prevIndex] + \"->\" +nums[i-1]);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3628237,
                "title": "easily-understandable-c-approach-o-n-two-pointer-method-0ms-beats-100",
                "content": "# Intuition\\nOn first seeing the problem, our initial intuition will be to iterate over every element in the array given to determine if the next element in the array is also the next number to the current element. \\n\\n# Approach\\nWe define two variables, `startpos` and `endpos`. These variables represent the starting position and the ending position of a range of numbers that are in continous succession. Both these pointers are set to the initial value of `0` to indicate the first element.\\n\\nWe begin an iteration until we reach the end of the array i.e, `endpos < nums.size()`. As long as the next element is 1 greater than the current element, our range of continous elements must grow, so we increment `endpos` in this case.\\n\\nHowever, if the next element is not continous to the current range, or if we have reached the last element, then we need to end the current range and append it to the result vector `res`. \\n\\nThe problem requires us to consider two cases where the current range is either a single element or multiple elements:\\n1. If it is a single element, the start of the range equals the end of the range i.e, `startpos == endpos`. Hence we simply append the element at endpos to our `res` vector.\\n2. Otherwise, we will have to append to the result in the form of `\"startpos->endpos\"`, so we convert both positions to a string and append them accordingly.\\n\\nOnce we have done this, we now need to start a new range. This new range would start from the next element in order, and end there as well, until we determine if we can grow that range further. Hence we need to set both `startpos` and `endpos` to `endpos + 1`, which is achieved by the shorthand notation `startpos = ++endpos`.\\n\\nThe loop continues to append all the ranges until the end of the array is reached, and then we return the resultant array `res`.\\n\\n\\n# Complexity\\n- Time complexity: `O(n)`, since we iterate over the length of the array\\n\\n- Space complexity: `O(1)`, as no extra space is used\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> summaryRanges(vector<int>& nums) \\n    {\\n        int startpos = 0 , endpos = 0;\\n        vector<string> res;\\n        while(endpos < nums.size())\\n        {\\n            if(endpos == nums.size() - 1 || nums[endpos + 1] != nums[endpos] + 1)\\n            {\\n                if(startpos == endpos)\\n                    res.push_back(to_string(nums[endpos]));\\n                else\\n                    res.push_back(to_string(nums[startpos]) + \"->\" + to_string(nums[endpos]));\\n                startpos = ++endpos;\\n            }\\n            else\\n                endpos++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> summaryRanges(vector<int>& nums) \\n    {\\n        int startpos = 0 , endpos = 0;\\n        vector<string> res;\\n        while(endpos < nums.size())\\n        {\\n            if(endpos == nums.size() - 1 || nums[endpos + 1] != nums[endpos] + 1)\\n            {\\n                if(startpos == endpos)\\n                    res.push_back(to_string(nums[endpos]));\\n                else\\n                    res.push_back(to_string(nums[startpos]) + \"->\" + to_string(nums[endpos]));\\n                startpos = ++endpos;\\n            }\\n            else\\n                endpos++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3628059,
                "title": "beats-c-queue-solution-with-dry-run-o-n-time-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**Aim**: Subarray ranges where each subarray is an AP of common difference 1.\\n**OR**\\n**Aim**: To get min and max of all subarrays where subarrays have consecutive elements.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nYou see that:\\n```\\n[0,1,2],[4,5],[7]\\n```\\nare the subarrays in the array. You have to find start and end of each subarray and represent it as strings showing ranges:\\n```\\n[\"0->2\",\"4->5\",\"7\"]\\n``` \\n# Main approach\\n- Add nums[i] (```0```) to queue. \\n    ```Queue:[0]```\\n- I keep adding all numbers in queue if ```q.back()+1==nums[i]``` where nums[i] is my current element. (Checking if consecutive)\\n    ```Queue: [0,1,2]```\\n- If nums[i] (```4```) is not consecutive, don\\'t add to queue.\\n- Stringify my current queue ```[0,1,2]``` to ```\"0->2\"```\\n- Repeat until you reach end of given array\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n//Appending elements first and last number in queue to string\\n    string queuetostring(queue<int>&q)\\n    {\\n        //Appending first element to string with arrow \"->\"\\n        string ans=to_string(q.front())+\"->\"; q.pop();\\n        //If elements in between, keep popping until 1 element left\\n        while(!q.empty()&&q.size()!=1)\\n            q.pop();\\n        //If still not empty (1 element left) then add to string\\n        if(!q.empty()){ans+=to_string(q.front())+\"->\"; q.pop();}\\n        //Remove the two last characters of the arrow - and >        \\n        ans.pop_back();ans.pop_back();\\n        //return string\\n        return ans;\\n    }\\n    vector<string> summaryRanges(vector<int>& nums) {\\n        queue<int> q;\\n        vector<string> ans;\\n        for(int i=0;i<nums.size();)\\n        {\\n            q.push(nums[i++]);\\n            while(!q.empty() && i<nums.size() && q.back()+1==nums[i]) q.push(nums[i++]);\\n            ans.push_back(queuetostring(q));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Stack",
                    "Queue"
                ],
                "code": "```\\n[0,1,2],[4,5],[7]\\n```\n```\\n[\"0->2\",\"4->5\",\"7\"]\\n```\n```0```\n```Queue:[0]```\n```q.back()+1==nums[i]```\n```Queue: [0,1,2]```\n```4```\n```[0,1,2]```\n```\"0->2\"```\n```\\nclass Solution {\\npublic:\\n//Appending elements first and last number in queue to string\\n    string queuetostring(queue<int>&q)\\n    {\\n        //Appending first element to string with arrow \"->\"\\n        string ans=to_string(q.front())+\"->\"; q.pop();\\n        //If elements in between, keep popping until 1 element left\\n        while(!q.empty()&&q.size()!=1)\\n            q.pop();\\n        //If still not empty (1 element left) then add to string\\n        if(!q.empty()){ans+=to_string(q.front())+\"->\"; q.pop();}\\n        //Remove the two last characters of the arrow - and >        \\n        ans.pop_back();ans.pop_back();\\n        //return string\\n        return ans;\\n    }\\n    vector<string> summaryRanges(vector<int>& nums) {\\n        queue<int> q;\\n        vector<string> ans;\\n        for(int i=0;i<nums.size();)\\n        {\\n            q.push(nums[i++]);\\n            while(!q.empty() && i<nums.size() && q.back()+1==nums[i]) q.push(nums[i++]);\\n            ans.push_back(queuetostring(q));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3627823,
                "title": "easy-approach-o-n-solution-java",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(N)\\n\\n- Space complexity: O(N)\\n\\n# Code\\n```\\nclass Solution {\\n    public List<String> summaryRanges(int[] nums) {\\n        List<String> ans = new ArrayList<>();\\n        for (int i = 0; i < nums.length; ++i) {\\n            final int begin = nums[i];\\n            while (i + 1 < nums.length && nums[i] == nums[i + 1] - 1)\\n                ++i;\\n            final int end = nums[i];\\n            if (begin == end)\\n                ans.add(\"\" + begin);\\n            else\\n                ans.add(\"\" + begin + \"->\" + end);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> summaryRanges(int[] nums) {\\n        List<String> ans = new ArrayList<>();\\n        for (int i = 0; i < nums.length; ++i) {\\n            final int begin = nums[i];\\n            while (i + 1 < nums.length && nums[i] == nums[i + 1] - 1)\\n                ++i;\\n            final int end = nums[i];\\n            if (begin == end)\\n                ans.add(\"\" + begin);\\n            else\\n                ans.add(\"\" + begin + \"->\" + end);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3627401,
                "title": "google-expectes-crisp-code-explanation-clean-c-code-codestorywithmik",
                "content": "YouTube Link : [Summary Ranges](https://www.youtube.com/watch?v=PyYZCJRAMmY)\\nMy Github Treasure : [Summary Ranges](https://github.com/MAZHARMIK/Interview_DS_Algo/blob/master/Arrays/Summary%20Ranges.cpp)\\n\\n```\\nclass Solution {\\npublic:\\n    vector<string> summaryRanges(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n == 0)\\n            return {};\\n        \\n        vector<string> result;\\n        \\n        for(int i = 0; i<n; i++) {\\n            \\n            int start = nums[i];\\n            \\n            while(i+1 < n && nums[i]+1 == nums[i+1]) {\\n                i++;\\n            }\\n            \\n            if(start != nums[i]) {\\n                result.push_back(to_string(start) + \"->\" + to_string(nums[i]));\\n            } else {\\n                result.push_back(to_string(start));\\n            }\\n            \\n        }\\n        \\n        return result;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> summaryRanges(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n == 0)\\n            return {};\\n        \\n        vector<string> result;\\n        \\n        for(int i = 0; i<n; i++) {\\n            \\n            int start = nums[i];\\n            \\n            while(i+1 < n && nums[i]+1 == nums[i+1]) {\\n                i++;\\n            }\\n            \\n            if(start != nums[i]) {\\n                result.push_back(to_string(start) + \"->\" + to_string(nums[i]));\\n            } else {\\n                result.push_back(to_string(start));\\n            }\\n            \\n        }\\n        \\n        return result;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3627225,
                "title": "check-consecutive-range-python-js-solution",
                "content": "Hello **Tenno Leetcoders**,\\n\\nFor this problem, we are given a sorted unique integer array `nums`.\\n\\nA range `[a,b]` is the set of all integers from a to b (inclusive).\\n\\nWe want to return the `smallest sorted` list of ranges that `cover all the numbers in the array exactly`. That is, each element of nums is covered by exactly one of the ranges, and there is no integer x such that x is in one of the ranges but not in nums.\\n\\nEach range `[a,b]` in the list should be output as:\\n\\n1) \"a->b\" if a != b\\n\\n2) \"a\" if a == b\\n\\n### Explanation\\n\\nWe are asked to take the given sorted unique array `nums` and generate the smallest sorted list of ranges which can cover all the number in the array\\n\\nGiven the above statement about each range `[a,b]` in the list should be output as:\\n\\n1) \"a->b\" if a != b\\n\\n2) \"a\" if a == b\\n\\nWe can use these two statement to help create `starting / ending position` of our range for the new list which can cover all numbers in the array\\n\\n1) Initialize:\\n\\n    1) An empty list ranges to store the generated ranges \\n    \\n    2) start and end to store the first element in nums array to keep track of the current considered range\\n    \\n2) Iterate through the second element as we already declared the first element \\n\\n    - Check if the current element `nums[i]` is consecutive to the previous element `end + 1`. \\n    \\n        - If so, the range is continuous. Update the end variable to the current element\\n        \\n     - If not consecutive, we have reach the end of the range, so add the range to ranges array. Before \\n       adding the range to the new array, we have to check the above two statements:\\n          \\n          1) If start does not equal end element, we add the range in this format: start -> end \\n          \\n          2) If the range only have one element, we add str(start) to the ranges array\\n          \\n          3) Update start / end to the current element to help find the next range\\n          \\n3) After the loop, we again check: \\n\\n      1) If start does not equal end element, we add the range in this format: start -> end \\n          \\n      2) If the range only have one element, we add str(start) to the ranges array\\n      \\n   making sure we also handle the last set of range to add to our ranges array\\n\\n# Code\\n\\n**Python**\\n\\n```\\ndef summaryRanges(self, nums: List[int]) -> List[str]:\\n        if not nums: return []\\n        ranges = []\\n        start = end = nums[0]\\n\\n        for i in range(1, len(nums)):\\n            if nums[i] == end + 1: end = nums[i]\\n            else:\\n                if start != end: ranges.append(f\"{start}->{end}\") \\n                else:   ranges.append(str(start))\\n            \\n                start = end = nums[i]\\n\\n        if start != end: ranges.append(f\"{start}->{end}\")\\n        else: ranges.append(str(start))\\n\\n        return ranges\\n```\\n\\n**JavaScript**\\n```\\n/**\\n * @param {number[]} nums\\n * @return {string[]}\\n */\\nvar summaryRanges = function(nums) {\\n    if (nums.length === 0) return []\\n\\n    const ranges = []\\n    let start = nums[0]\\n    let end  = nums[0]\\n\\n    for (let i = 1; i < nums.length; i++) {\\n    if (nums[i] === end + 1) {\\n      end = nums[i];\\n    } else {\\n       ranges.push(start !== end ? `${start}->${end}` : start.toString());\\n      start = end = nums[i];\\n    }\\n  }\\n    ranges.push(start !== end ? `${start}->${end}` : start.toString());\\n    return ranges\\n};\\n```\\n \\n### Time Complexity: `O(n)`\\n### Space Complexity: `O(n)`\\n \\n***Warframe\\'s Darvo wants you to upvote this post  \\uD83D\\uDE4F\\uD83C\\uDFFB \\u2764\\uFE0F\\u200D\\uD83D\\uDD25***\\n![image](https://assets.leetcode.com/users/images/814f5668-c966-46d7-ba42-e5435c4c1761_1675302761.3081913.gif)",
                "solutionTags": [
                    "Python3",
                    "JavaScript"
                ],
                "code": "```\\ndef summaryRanges(self, nums: List[int]) -> List[str]:\\n        if not nums: return []\\n        ranges = []\\n        start = end = nums[0]\\n\\n        for i in range(1, len(nums)):\\n            if nums[i] == end + 1: end = nums[i]\\n            else:\\n                if start != end: ranges.append(f\"{start}->{end}\") \\n                else:   ranges.append(str(start))\\n            \\n                start = end = nums[i]\\n\\n        if start != end: ranges.append(f\"{start}->{end}\")\\n        else: ranges.append(str(start))\\n\\n        return ranges\\n```\n```\\n/**\\n * @param {number[]} nums\\n * @return {string[]}\\n */\\nvar summaryRanges = function(nums) {\\n    if (nums.length === 0) return []\\n\\n    const ranges = []\\n    let start = nums[0]\\n    let end  = nums[0]\\n\\n    for (let i = 1; i < nums.length; i++) {\\n    if (nums[i] === end + 1) {\\n      end = nums[i];\\n    } else {\\n       ranges.push(start !== end ? `${start}->${end}` : start.toString());\\n      start = end = nums[i];\\n    }\\n  }\\n    ranges.push(start !== end ? `${start}->${end}` : start.toString());\\n    return ranges\\n};\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3627193,
                "title": "o-n-beats-100-runtime-94-memory-clean-solution",
                "content": "[]()\\n![Screenshot 2023-06-11 at 5.43.59 PM.png](https://assets.leetcode.com/users/images/0b6c8c56-c123-43c0-af52-ba471fae905d_1686531419.1339943.png)\\n\\n# Approach\\nThe `summaryRanges(_:) `function is designed to process a sorted integer array, and produce an array of strings that succinctly describe contiguous ranges of numbers present in the input array. The method works by iterating over the input array, maintaining a current range, and extending it if the next number is consecutive to the current one.\\n\\nA nested helper function `resolve()` is employed, which generates a string representation of the current range and appends it to the result. This string is a single number if the range represents a single value, otherwise it\\'s in the `start->end` format.\\n\\nDuring iteration, for each number, if it\\'s a consecutive increment of the previous one, the current range is extended to include it. If it\\'s not consecutive, the current range is finalized by invoking `resolve()`, then a new range starting with this number is initiated.\\n\\nOnce all numbers have been processed, `resolve()` is called once more to ensure the final range is included in the output. Therefore, if the input array is ***[0, 1, 2, 4, 5, 7]***, the function will output ***[\"0->2\", \"4->5\", \"7\"]***.\\n\\nThis approach offers an efficient and clean solution to the problem of summarizing numerical ranges in a sorted array. It leverages **Swift\\'s** powerful language features such as `structs`, `custom string descriptions`, and `function inlining` to optimize performance.\\n\\n# Time Complexity\\n**O(n)**\\nThe function iterates through the input array exactly once, so the time complexity is linear with respect to the size of the input array, where n is the number of elements in the input array.\\n\\n# Space complexity\\n**O(n)**\\nThe function uses an auxiliary array ranges to store the output strings. In the worst-case scenario where no consecutive numbers exist in the array, every number would become a single range, resulting in the size of ranges being the same as the input array. Hence, the space complexity is also linear with respect to the size of the input array.\\n\\n# Solution\\n```swift\\nfinal class Solution {\\n    /// This structure holds the range of numbers, with left and right representing the start and end of the range respectively. It also includes helper computed properties to convert left and right to strings, and to format the string representation of the range. The assign(_:) function is used to reset the left and right values to a new number.\\n    struct NumRange: CustomStringConvertible {\\n        var left: Int\\n        var right: Int\\n\\n        var sleft: String { \"\\\\(left)\" }\\n        var sright: String { \"\\\\(right)\" }\\n        var description: String { sleft + \"->\" + sright }\\n\\n        mutating func assign(_ val: Int) {\\n            left = val\\n            right = val\\n        }\\n    }\\n\\n    @inline(__always)\\n    func summaryRanges(_ nums: [Int]) -> [String] {\\n        guard !nums.isEmpty else { return [] }\\n        var ranges = [String]()\\n        // Keep track of the current range \\n        var range = NumRange(left: nums[0], right: nums[0])\\n\\n        // This function is used to generate the string representation of the current range and add it to the ranges array. If left and right of the range are the same, it simply adds the string representation of left, otherwise it adds the range in the left->right format.\\n        @inline(__always)\\n        func resolve() {\\n            ranges += [range.left == range.right ? range.sleft : range.description]\\n        }\\n\\n        // Iterate over the input array from the second element onwards\\n        for num in nums[1...] {\\n            // For each number, it check if it\\'s a consecutive number of the previous number by comparing it with right + 1 of the range. If it\\'s consecutive, it extends the current range by setting right to this number. If it\\'s not consecutive, it means the current range has ended, so it calls resolve() to add the current range to ranges and resets range to the new number.\\n            if range.right + 1 == num {\\n                range.right = num\\n            } else {\\n                resolve()\\n                range.assign(num)\\n            }\\n        }\\n        // Call resolve() one more time to ensure the last range is added to ranges.\\n        resolve()\\n\\n        return ranges\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nfinal class Solution {\\n    /// This structure holds the range of numbers, with left and right representing the start and end of the range respectively. It also includes helper computed properties to convert left and right to strings, and to format the string representation of the range. The assign(_:) function is used to reset the left and right values to a new number.\\n    struct NumRange: CustomStringConvertible {\\n        var left: Int\\n        var right: Int\\n\\n        var sleft: String { \"\\\\(left)\" }\\n        var sright: String { \"\\\\(right)\" }\\n        var description: String { sleft + \"->\" + sright }\\n\\n        mutating func assign(_ val: Int) {\\n            left = val\\n            right = val\\n        }\\n    }\\n\\n    @inline(__always)\\n    func summaryRanges(_ nums: [Int]) -> [String] {\\n        guard !nums.isEmpty else { return [] }\\n        var ranges = [String]()\\n        // Keep track of the current range \\n        var range = NumRange(left: nums[0], right: nums[0])\\n\\n        // This function is used to generate the string representation of the current range and add it to the ranges array. If left and right of the range are the same, it simply adds the string representation of left, otherwise it adds the range in the left->right format.\\n        @inline(__always)\\n        func resolve() {\\n            ranges += [range.left == range.right ? range.sleft : range.description]\\n        }\\n\\n        // Iterate over the input array from the second element onwards\\n        for num in nums[1...] {\\n            // For each number, it check if it\\'s a consecutive number of the previous number by comparing it with right + 1 of the range. If it\\'s consecutive, it extends the current range by setting right to this number. If it\\'s not consecutive, it means the current range has ended, so it calls resolve() to add the current range to ranges and resets range to the new number.\\n            if range.right + 1 == num {\\n                range.right = num\\n            } else {\\n                resolve()\\n                range.assign(num)\\n            }\\n        }\\n        // Call resolve() one more time to ensure the last range is added to ranges.\\n        resolve()\\n\\n        return ranges\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1565117,
                "content": [
                    {
                        "username": "yuanshuo",
                        "content": "I don't really understand what this question is asking. It says return the summary of its ranges but the what does this mean?"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "[@bjlslopez](/bjlslopez) dude own\\'s leetcode ! what a clear cut explanation"
                    },
                    {
                        "username": "The_ThunderBolt",
                        "content": "[@bjlslopez](/bjlslopez)  it helps, Thanks man!"
                    },
                    {
                        "username": "charanarc3",
                        "content": "[@bjlslopez](/bjlslopez) it helps thanks\\n"
                    },
                    {
                        "username": "Ilkhomjon",
                        "content": "[@bjlslopez](/bjlslopez) Thank you man, your explanation is really concise!"
                    },
                    {
                        "username": "bjlslopez",
                        "content": "It is asking for you to summarize continuous numbers into a range. For example, 0, 1 should be converted to 0->1. A more useful application would be 2,3,4,5,6,7,8,9,10 can be summarized to 2->10.\\nHowever, if you have 0,2, there is a gap in the range, so you should return \"0\", \"2\".\\nExample: 0, 2, 3, 4, 5, 6, 7, 8, 10, 20, 25, 26, 27\\nTurns to: 0, 2->8, 10, 20, 25->27\\nYou can think of it in terms of how pages are referenced in bibliographies. Example: Python for Dummies. Pages: 1-4, 10 means pages 1 to 4 and page 10."
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Image Explanation\\n```\\nInput: nums = [0,2,3,4,6,8,9]\\n```\\n![image.png](https://assets.leetcode.com/users/images/5ede8d3f-665d-4d88-a628-de73a0986db9_1686559423.6645904.png)\\nThe problem asks us to \"group\" the elements of array into ranges that are continuous. That is, in one range their should not be any number absent in array. And we need to minimize the different ranges we use, so try to take as big range as possible. At each element, make a different range only when you find some number absent in between current and last element, otherwise expand the current range by $1$.\\n```\\nOutput: [\"0\",\"2->4\",\"6\",\"8->9\"]\\n```"
                    },
                    {
                        "username": "Musfik41",
                        "content": "[@mmtemel](/mmtemel) leetcode should hire you for this awesome visual explanation\\uD83D\\uDE05. 100% satisfied."
                    },
                    {
                        "username": "mmtemel",
                        "content": "your explanation should be the problem explanation"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is an easy question. But test this test case before submitting, especially for the  C/C++ programmer!\\n```\\n[-2147483648,-2147483647,2147483647]\\n```"
                    },
                    {
                        "username": "dfisheritp",
                        "content": "the array is sorted. `[INT_MIN, INT_MAX]` has a solution. `nums[i] + 1 == nums[i + 1]`\\n\\nLEFT SIDE : -2147483648 -> -2147483647\\nRIGHT SIDE : 2147483647 -> -2147483648\\n\\nIt fails the test.\\n\\nYou need a guard clause for the \"->\" anyway. And the compiler will cache that because it see\\'s that it\\'s needed immediately after. Like come on."
                    },
                    {
                        "username": "Rifat121",
                        "content": "how to solve this overflow issue!\\n"
                    },
                    {
                        "username": "geekyshark",
                        "content": "[@jasonpyau](/jasonpyau) same here lol, i checked for [\"0\"] but forgot to check for empty array\\n"
                    },
                    {
                        "username": "autf",
                        "content": "Me too (Rust)\\nOne of a million ways to fail a binary search."
                    },
                    {
                        "username": "daring-calf",
                        "content": "This got me too! (golang)"
                    },
                    {
                        "username": "redocmi7",
                        "content": "Yeah, me too! Got confused untill I viewed the testcase where it failed.\\n\\nMoral of the lesson: Always check for integer overflows!"
                    },
                    {
                        "username": "jasonpyau",
                        "content": "Wasted 2 submissions cuz of integer overflow and empty array!! :["
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "me: Who passed in single go without any error or WA \\uD83D\\uDE0E"
                    },
                    {
                        "username": "antoxakartoxa",
                        "content": "In the task description there is \"nums is sorted in ascending order\". But one of testcases checked after submission is [2, -1] which is descending order. "
                    },
                    {
                        "username": "daregula",
                        "content": "dude I just ran into the same thing lol I had to use abs() when checking for the difference to bypass this invalid test case"
                    },
                    {
                        "username": "baryonix",
                        "content": "I have the same issue, this prevents me from completing the 150-question Study Plan :(.\\nThe thing is I solved this question before this new constraint/test case was added"
                    },
                    {
                        "username": "kokolen77",
                        "content": "I wrote about this on github, but seems like they dont see an error here https://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/16112"
                    },
                    {
                        "username": "batman12345",
                        "content": "![image](https://assets.leetcode.com/users/jasinghe/image_1541988925.png)\\n\\nAll submissions are the exact same. A couple ms makes a huge difference in how fast your submission is judged so resubmit a couple times to be sure your solution isn\\'t actually slow :) \\n\\n32ms = you beat 100%\\n52ms = you beat 10% \\n\\nlol"
                    },
                    {
                        "username": "andreasfesshahagglund",
                        "content": "Yeah man. I went from beating 5 % to beating 92 % of all submissions with the same lines of code. =/"
                    },
                    {
                        "username": "District_12",
                        "content": "Why not [\"0-7\"] as a result? What do you need? Problem description is so bad."
                    },
                    {
                        "username": "rishavranjan1821",
                        "content": "the range means you have to give a range in which it should contain all the numbers that comes between these numbers. See [\"0 - 7\"] is not a range because as per the question the range should contain 0,1,,2,3,4,5,6,7 but in the nums array after 0,1,2 . 4 comes which will not be considered as in the range of [0,7] for that after 2 , 3 has to be present thats why [\"0,7\\'] range is not possible\\n"
                    },
                    {
                        "username": "sandyy",
                        "content": "The numbers in the resultant set must be consecutive only. For input [0,1,2,4,5,7] there are only 3 consecutive sets. First is [0,1,2], second is [4,5] and third is [7]. [0,7] can be the answer when input is [0,1,2,3,4,5,6,7]. I agree that the problem statement is not clear enough."
                    },
                    {
                        "username": "mayank17081998",
                        "content": "![image](https://assets.leetcode.com/users/images/308e256b-0272-4010-876a-8b3745b95fed_1646015105.510134.png)\\n![image](https://assets.leetcode.com/users/images/be57f0f2-c7c0-433e-9e1d-d61ba0fc4dcc_1646015113.6479263.png)\\n![image](https://assets.leetcode.com/users/images/e883adbe-45dd-49e6-975b-294d0670c670_1646015121.1118414.png)\\n![image](https://assets.leetcode.com/users/images/1de2db64-268f-4bf9-bcd5-7a511f79f254_1646015129.5048964.png)\\n![image](https://assets.leetcode.com/users/images/c3f49c2e-359d-4f23-a4d7-b02f56b87cff_1646015136.1616788.png)\\n![image](https://assets.leetcode.com/users/images/170ea0b6-91ee-4b2e-8ad8-dfac1374944c_1646015141.054478.png)\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "Tim_Guan",
                        "content": "Dislike for confusing test case [2; -1]"
                    },
                    {
                        "username": "mayankagarwal2402",
                        "content": "it not confusing, it's incorrect. \nHave submitted a feedback for the same, others should too, to get it highlighted and rectified. "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 28.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/summary-ranges/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 0 approach in the official solution</summary>\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "mindstrong",
                        "content": "I can not understand what does this question is. the example show's none principles to summarize the ranges. why [0,1,2,4,5,7] should be summarized to [\"0->2\", \"4->5\", \"7\"], why not [\"0-1\", \"2->5\", \"7\"?\\n\\nwho can explain this question more clearly ? thank you in advance."
                    },
                    {
                        "username": "emma-vuksich",
                        "content": "The ranges have to be consecutive numbers (one after the other, in order). Within [0,1,2,4,5,7], 0->2 is a range because the numbers 0, 1, 2 are consecutive. 4->5 is a range because the numbers 4 and 5 are consecutive."
                    },
                    {
                        "username": "sardarsj",
                        "content": "In this problem, the range means we have to give a range in which it should contain all the numbers consecutively. [\"0 - 7\"] is not a range because as per the question the range should contain 0,1,,2,3,4,5,6,7 but in the \\'nums\\' array after 0,1,2 . 4 comes which will not be considered as in the range of [0,7] for that after 2 , 3 has to be present thatswhy [\"0,7\\'] range is not possible"
                    },
                    {
                        "username": "firuz97",
                        "content": "Hi there!\\nFor me as one who is not a native speaker to figure out the task was confusing. I think over the examples and found this.\\nit makes a range until it mets skip number in array.\\nFor example.\\n[0,2,3] -> [\"0\", \"2->3\"]\\n[0,1,3] -> [\"0->1\", \"3\"]\\nI hope my comment will help someone."
                    },
                    {
                        "username": "LuciferYSD",
                        "content": "if you do it 2->5 3 is not present\\n"
                    }
                ]
            },
            {
                "id": 1926534,
                "content": [
                    {
                        "username": "yuanshuo",
                        "content": "I don't really understand what this question is asking. It says return the summary of its ranges but the what does this mean?"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "[@bjlslopez](/bjlslopez) dude own\\'s leetcode ! what a clear cut explanation"
                    },
                    {
                        "username": "The_ThunderBolt",
                        "content": "[@bjlslopez](/bjlslopez)  it helps, Thanks man!"
                    },
                    {
                        "username": "charanarc3",
                        "content": "[@bjlslopez](/bjlslopez) it helps thanks\\n"
                    },
                    {
                        "username": "Ilkhomjon",
                        "content": "[@bjlslopez](/bjlslopez) Thank you man, your explanation is really concise!"
                    },
                    {
                        "username": "bjlslopez",
                        "content": "It is asking for you to summarize continuous numbers into a range. For example, 0, 1 should be converted to 0->1. A more useful application would be 2,3,4,5,6,7,8,9,10 can be summarized to 2->10.\\nHowever, if you have 0,2, there is a gap in the range, so you should return \"0\", \"2\".\\nExample: 0, 2, 3, 4, 5, 6, 7, 8, 10, 20, 25, 26, 27\\nTurns to: 0, 2->8, 10, 20, 25->27\\nYou can think of it in terms of how pages are referenced in bibliographies. Example: Python for Dummies. Pages: 1-4, 10 means pages 1 to 4 and page 10."
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Image Explanation\\n```\\nInput: nums = [0,2,3,4,6,8,9]\\n```\\n![image.png](https://assets.leetcode.com/users/images/5ede8d3f-665d-4d88-a628-de73a0986db9_1686559423.6645904.png)\\nThe problem asks us to \"group\" the elements of array into ranges that are continuous. That is, in one range their should not be any number absent in array. And we need to minimize the different ranges we use, so try to take as big range as possible. At each element, make a different range only when you find some number absent in between current and last element, otherwise expand the current range by $1$.\\n```\\nOutput: [\"0\",\"2->4\",\"6\",\"8->9\"]\\n```"
                    },
                    {
                        "username": "Musfik41",
                        "content": "[@mmtemel](/mmtemel) leetcode should hire you for this awesome visual explanation\\uD83D\\uDE05. 100% satisfied."
                    },
                    {
                        "username": "mmtemel",
                        "content": "your explanation should be the problem explanation"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is an easy question. But test this test case before submitting, especially for the  C/C++ programmer!\\n```\\n[-2147483648,-2147483647,2147483647]\\n```"
                    },
                    {
                        "username": "dfisheritp",
                        "content": "the array is sorted. `[INT_MIN, INT_MAX]` has a solution. `nums[i] + 1 == nums[i + 1]`\\n\\nLEFT SIDE : -2147483648 -> -2147483647\\nRIGHT SIDE : 2147483647 -> -2147483648\\n\\nIt fails the test.\\n\\nYou need a guard clause for the \"->\" anyway. And the compiler will cache that because it see\\'s that it\\'s needed immediately after. Like come on."
                    },
                    {
                        "username": "Rifat121",
                        "content": "how to solve this overflow issue!\\n"
                    },
                    {
                        "username": "geekyshark",
                        "content": "[@jasonpyau](/jasonpyau) same here lol, i checked for [\"0\"] but forgot to check for empty array\\n"
                    },
                    {
                        "username": "autf",
                        "content": "Me too (Rust)\\nOne of a million ways to fail a binary search."
                    },
                    {
                        "username": "daring-calf",
                        "content": "This got me too! (golang)"
                    },
                    {
                        "username": "redocmi7",
                        "content": "Yeah, me too! Got confused untill I viewed the testcase where it failed.\\n\\nMoral of the lesson: Always check for integer overflows!"
                    },
                    {
                        "username": "jasonpyau",
                        "content": "Wasted 2 submissions cuz of integer overflow and empty array!! :["
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "me: Who passed in single go without any error or WA \\uD83D\\uDE0E"
                    },
                    {
                        "username": "antoxakartoxa",
                        "content": "In the task description there is \"nums is sorted in ascending order\". But one of testcases checked after submission is [2, -1] which is descending order. "
                    },
                    {
                        "username": "daregula",
                        "content": "dude I just ran into the same thing lol I had to use abs() when checking for the difference to bypass this invalid test case"
                    },
                    {
                        "username": "baryonix",
                        "content": "I have the same issue, this prevents me from completing the 150-question Study Plan :(.\\nThe thing is I solved this question before this new constraint/test case was added"
                    },
                    {
                        "username": "kokolen77",
                        "content": "I wrote about this on github, but seems like they dont see an error here https://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/16112"
                    },
                    {
                        "username": "batman12345",
                        "content": "![image](https://assets.leetcode.com/users/jasinghe/image_1541988925.png)\\n\\nAll submissions are the exact same. A couple ms makes a huge difference in how fast your submission is judged so resubmit a couple times to be sure your solution isn\\'t actually slow :) \\n\\n32ms = you beat 100%\\n52ms = you beat 10% \\n\\nlol"
                    },
                    {
                        "username": "andreasfesshahagglund",
                        "content": "Yeah man. I went from beating 5 % to beating 92 % of all submissions with the same lines of code. =/"
                    },
                    {
                        "username": "District_12",
                        "content": "Why not [\"0-7\"] as a result? What do you need? Problem description is so bad."
                    },
                    {
                        "username": "rishavranjan1821",
                        "content": "the range means you have to give a range in which it should contain all the numbers that comes between these numbers. See [\"0 - 7\"] is not a range because as per the question the range should contain 0,1,,2,3,4,5,6,7 but in the nums array after 0,1,2 . 4 comes which will not be considered as in the range of [0,7] for that after 2 , 3 has to be present thats why [\"0,7\\'] range is not possible\\n"
                    },
                    {
                        "username": "sandyy",
                        "content": "The numbers in the resultant set must be consecutive only. For input [0,1,2,4,5,7] there are only 3 consecutive sets. First is [0,1,2], second is [4,5] and third is [7]. [0,7] can be the answer when input is [0,1,2,3,4,5,6,7]. I agree that the problem statement is not clear enough."
                    },
                    {
                        "username": "mayank17081998",
                        "content": "![image](https://assets.leetcode.com/users/images/308e256b-0272-4010-876a-8b3745b95fed_1646015105.510134.png)\\n![image](https://assets.leetcode.com/users/images/be57f0f2-c7c0-433e-9e1d-d61ba0fc4dcc_1646015113.6479263.png)\\n![image](https://assets.leetcode.com/users/images/e883adbe-45dd-49e6-975b-294d0670c670_1646015121.1118414.png)\\n![image](https://assets.leetcode.com/users/images/1de2db64-268f-4bf9-bcd5-7a511f79f254_1646015129.5048964.png)\\n![image](https://assets.leetcode.com/users/images/c3f49c2e-359d-4f23-a4d7-b02f56b87cff_1646015136.1616788.png)\\n![image](https://assets.leetcode.com/users/images/170ea0b6-91ee-4b2e-8ad8-dfac1374944c_1646015141.054478.png)\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "Tim_Guan",
                        "content": "Dislike for confusing test case [2; -1]"
                    },
                    {
                        "username": "mayankagarwal2402",
                        "content": "it not confusing, it's incorrect. \nHave submitted a feedback for the same, others should too, to get it highlighted and rectified. "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 28.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/summary-ranges/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 0 approach in the official solution</summary>\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "mindstrong",
                        "content": "I can not understand what does this question is. the example show's none principles to summarize the ranges. why [0,1,2,4,5,7] should be summarized to [\"0->2\", \"4->5\", \"7\"], why not [\"0-1\", \"2->5\", \"7\"?\\n\\nwho can explain this question more clearly ? thank you in advance."
                    },
                    {
                        "username": "emma-vuksich",
                        "content": "The ranges have to be consecutive numbers (one after the other, in order). Within [0,1,2,4,5,7], 0->2 is a range because the numbers 0, 1, 2 are consecutive. 4->5 is a range because the numbers 4 and 5 are consecutive."
                    },
                    {
                        "username": "sardarsj",
                        "content": "In this problem, the range means we have to give a range in which it should contain all the numbers consecutively. [\"0 - 7\"] is not a range because as per the question the range should contain 0,1,,2,3,4,5,6,7 but in the \\'nums\\' array after 0,1,2 . 4 comes which will not be considered as in the range of [0,7] for that after 2 , 3 has to be present thatswhy [\"0,7\\'] range is not possible"
                    },
                    {
                        "username": "firuz97",
                        "content": "Hi there!\\nFor me as one who is not a native speaker to figure out the task was confusing. I think over the examples and found this.\\nit makes a range until it mets skip number in array.\\nFor example.\\n[0,2,3] -> [\"0\", \"2->3\"]\\n[0,1,3] -> [\"0->1\", \"3\"]\\nI hope my comment will help someone."
                    },
                    {
                        "username": "LuciferYSD",
                        "content": "if you do it 2->5 3 is not present\\n"
                    }
                ]
            },
            {
                "id": 1926073,
                "content": [
                    {
                        "username": "yuanshuo",
                        "content": "I don't really understand what this question is asking. It says return the summary of its ranges but the what does this mean?"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "[@bjlslopez](/bjlslopez) dude own\\'s leetcode ! what a clear cut explanation"
                    },
                    {
                        "username": "The_ThunderBolt",
                        "content": "[@bjlslopez](/bjlslopez)  it helps, Thanks man!"
                    },
                    {
                        "username": "charanarc3",
                        "content": "[@bjlslopez](/bjlslopez) it helps thanks\\n"
                    },
                    {
                        "username": "Ilkhomjon",
                        "content": "[@bjlslopez](/bjlslopez) Thank you man, your explanation is really concise!"
                    },
                    {
                        "username": "bjlslopez",
                        "content": "It is asking for you to summarize continuous numbers into a range. For example, 0, 1 should be converted to 0->1. A more useful application would be 2,3,4,5,6,7,8,9,10 can be summarized to 2->10.\\nHowever, if you have 0,2, there is a gap in the range, so you should return \"0\", \"2\".\\nExample: 0, 2, 3, 4, 5, 6, 7, 8, 10, 20, 25, 26, 27\\nTurns to: 0, 2->8, 10, 20, 25->27\\nYou can think of it in terms of how pages are referenced in bibliographies. Example: Python for Dummies. Pages: 1-4, 10 means pages 1 to 4 and page 10."
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Image Explanation\\n```\\nInput: nums = [0,2,3,4,6,8,9]\\n```\\n![image.png](https://assets.leetcode.com/users/images/5ede8d3f-665d-4d88-a628-de73a0986db9_1686559423.6645904.png)\\nThe problem asks us to \"group\" the elements of array into ranges that are continuous. That is, in one range their should not be any number absent in array. And we need to minimize the different ranges we use, so try to take as big range as possible. At each element, make a different range only when you find some number absent in between current and last element, otherwise expand the current range by $1$.\\n```\\nOutput: [\"0\",\"2->4\",\"6\",\"8->9\"]\\n```"
                    },
                    {
                        "username": "Musfik41",
                        "content": "[@mmtemel](/mmtemel) leetcode should hire you for this awesome visual explanation\\uD83D\\uDE05. 100% satisfied."
                    },
                    {
                        "username": "mmtemel",
                        "content": "your explanation should be the problem explanation"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is an easy question. But test this test case before submitting, especially for the  C/C++ programmer!\\n```\\n[-2147483648,-2147483647,2147483647]\\n```"
                    },
                    {
                        "username": "dfisheritp",
                        "content": "the array is sorted. `[INT_MIN, INT_MAX]` has a solution. `nums[i] + 1 == nums[i + 1]`\\n\\nLEFT SIDE : -2147483648 -> -2147483647\\nRIGHT SIDE : 2147483647 -> -2147483648\\n\\nIt fails the test.\\n\\nYou need a guard clause for the \"->\" anyway. And the compiler will cache that because it see\\'s that it\\'s needed immediately after. Like come on."
                    },
                    {
                        "username": "Rifat121",
                        "content": "how to solve this overflow issue!\\n"
                    },
                    {
                        "username": "geekyshark",
                        "content": "[@jasonpyau](/jasonpyau) same here lol, i checked for [\"0\"] but forgot to check for empty array\\n"
                    },
                    {
                        "username": "autf",
                        "content": "Me too (Rust)\\nOne of a million ways to fail a binary search."
                    },
                    {
                        "username": "daring-calf",
                        "content": "This got me too! (golang)"
                    },
                    {
                        "username": "redocmi7",
                        "content": "Yeah, me too! Got confused untill I viewed the testcase where it failed.\\n\\nMoral of the lesson: Always check for integer overflows!"
                    },
                    {
                        "username": "jasonpyau",
                        "content": "Wasted 2 submissions cuz of integer overflow and empty array!! :["
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "me: Who passed in single go without any error or WA \\uD83D\\uDE0E"
                    },
                    {
                        "username": "antoxakartoxa",
                        "content": "In the task description there is \"nums is sorted in ascending order\". But one of testcases checked after submission is [2, -1] which is descending order. "
                    },
                    {
                        "username": "daregula",
                        "content": "dude I just ran into the same thing lol I had to use abs() when checking for the difference to bypass this invalid test case"
                    },
                    {
                        "username": "baryonix",
                        "content": "I have the same issue, this prevents me from completing the 150-question Study Plan :(.\\nThe thing is I solved this question before this new constraint/test case was added"
                    },
                    {
                        "username": "kokolen77",
                        "content": "I wrote about this on github, but seems like they dont see an error here https://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/16112"
                    },
                    {
                        "username": "batman12345",
                        "content": "![image](https://assets.leetcode.com/users/jasinghe/image_1541988925.png)\\n\\nAll submissions are the exact same. A couple ms makes a huge difference in how fast your submission is judged so resubmit a couple times to be sure your solution isn\\'t actually slow :) \\n\\n32ms = you beat 100%\\n52ms = you beat 10% \\n\\nlol"
                    },
                    {
                        "username": "andreasfesshahagglund",
                        "content": "Yeah man. I went from beating 5 % to beating 92 % of all submissions with the same lines of code. =/"
                    },
                    {
                        "username": "District_12",
                        "content": "Why not [\"0-7\"] as a result? What do you need? Problem description is so bad."
                    },
                    {
                        "username": "rishavranjan1821",
                        "content": "the range means you have to give a range in which it should contain all the numbers that comes between these numbers. See [\"0 - 7\"] is not a range because as per the question the range should contain 0,1,,2,3,4,5,6,7 but in the nums array after 0,1,2 . 4 comes which will not be considered as in the range of [0,7] for that after 2 , 3 has to be present thats why [\"0,7\\'] range is not possible\\n"
                    },
                    {
                        "username": "sandyy",
                        "content": "The numbers in the resultant set must be consecutive only. For input [0,1,2,4,5,7] there are only 3 consecutive sets. First is [0,1,2], second is [4,5] and third is [7]. [0,7] can be the answer when input is [0,1,2,3,4,5,6,7]. I agree that the problem statement is not clear enough."
                    },
                    {
                        "username": "mayank17081998",
                        "content": "![image](https://assets.leetcode.com/users/images/308e256b-0272-4010-876a-8b3745b95fed_1646015105.510134.png)\\n![image](https://assets.leetcode.com/users/images/be57f0f2-c7c0-433e-9e1d-d61ba0fc4dcc_1646015113.6479263.png)\\n![image](https://assets.leetcode.com/users/images/e883adbe-45dd-49e6-975b-294d0670c670_1646015121.1118414.png)\\n![image](https://assets.leetcode.com/users/images/1de2db64-268f-4bf9-bcd5-7a511f79f254_1646015129.5048964.png)\\n![image](https://assets.leetcode.com/users/images/c3f49c2e-359d-4f23-a4d7-b02f56b87cff_1646015136.1616788.png)\\n![image](https://assets.leetcode.com/users/images/170ea0b6-91ee-4b2e-8ad8-dfac1374944c_1646015141.054478.png)\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "Tim_Guan",
                        "content": "Dislike for confusing test case [2; -1]"
                    },
                    {
                        "username": "mayankagarwal2402",
                        "content": "it not confusing, it's incorrect. \nHave submitted a feedback for the same, others should too, to get it highlighted and rectified. "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 28.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/summary-ranges/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 0 approach in the official solution</summary>\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "mindstrong",
                        "content": "I can not understand what does this question is. the example show's none principles to summarize the ranges. why [0,1,2,4,5,7] should be summarized to [\"0->2\", \"4->5\", \"7\"], why not [\"0-1\", \"2->5\", \"7\"?\\n\\nwho can explain this question more clearly ? thank you in advance."
                    },
                    {
                        "username": "emma-vuksich",
                        "content": "The ranges have to be consecutive numbers (one after the other, in order). Within [0,1,2,4,5,7], 0->2 is a range because the numbers 0, 1, 2 are consecutive. 4->5 is a range because the numbers 4 and 5 are consecutive."
                    },
                    {
                        "username": "sardarsj",
                        "content": "In this problem, the range means we have to give a range in which it should contain all the numbers consecutively. [\"0 - 7\"] is not a range because as per the question the range should contain 0,1,,2,3,4,5,6,7 but in the \\'nums\\' array after 0,1,2 . 4 comes which will not be considered as in the range of [0,7] for that after 2 , 3 has to be present thatswhy [\"0,7\\'] range is not possible"
                    },
                    {
                        "username": "firuz97",
                        "content": "Hi there!\\nFor me as one who is not a native speaker to figure out the task was confusing. I think over the examples and found this.\\nit makes a range until it mets skip number in array.\\nFor example.\\n[0,2,3] -> [\"0\", \"2->3\"]\\n[0,1,3] -> [\"0->1\", \"3\"]\\nI hope my comment will help someone."
                    },
                    {
                        "username": "LuciferYSD",
                        "content": "if you do it 2->5 3 is not present\\n"
                    }
                ]
            },
            {
                "id": 2042711,
                "content": [
                    {
                        "username": "yuanshuo",
                        "content": "I don't really understand what this question is asking. It says return the summary of its ranges but the what does this mean?"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "[@bjlslopez](/bjlslopez) dude own\\'s leetcode ! what a clear cut explanation"
                    },
                    {
                        "username": "The_ThunderBolt",
                        "content": "[@bjlslopez](/bjlslopez)  it helps, Thanks man!"
                    },
                    {
                        "username": "charanarc3",
                        "content": "[@bjlslopez](/bjlslopez) it helps thanks\\n"
                    },
                    {
                        "username": "Ilkhomjon",
                        "content": "[@bjlslopez](/bjlslopez) Thank you man, your explanation is really concise!"
                    },
                    {
                        "username": "bjlslopez",
                        "content": "It is asking for you to summarize continuous numbers into a range. For example, 0, 1 should be converted to 0->1. A more useful application would be 2,3,4,5,6,7,8,9,10 can be summarized to 2->10.\\nHowever, if you have 0,2, there is a gap in the range, so you should return \"0\", \"2\".\\nExample: 0, 2, 3, 4, 5, 6, 7, 8, 10, 20, 25, 26, 27\\nTurns to: 0, 2->8, 10, 20, 25->27\\nYou can think of it in terms of how pages are referenced in bibliographies. Example: Python for Dummies. Pages: 1-4, 10 means pages 1 to 4 and page 10."
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Image Explanation\\n```\\nInput: nums = [0,2,3,4,6,8,9]\\n```\\n![image.png](https://assets.leetcode.com/users/images/5ede8d3f-665d-4d88-a628-de73a0986db9_1686559423.6645904.png)\\nThe problem asks us to \"group\" the elements of array into ranges that are continuous. That is, in one range their should not be any number absent in array. And we need to minimize the different ranges we use, so try to take as big range as possible. At each element, make a different range only when you find some number absent in between current and last element, otherwise expand the current range by $1$.\\n```\\nOutput: [\"0\",\"2->4\",\"6\",\"8->9\"]\\n```"
                    },
                    {
                        "username": "Musfik41",
                        "content": "[@mmtemel](/mmtemel) leetcode should hire you for this awesome visual explanation\\uD83D\\uDE05. 100% satisfied."
                    },
                    {
                        "username": "mmtemel",
                        "content": "your explanation should be the problem explanation"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is an easy question. But test this test case before submitting, especially for the  C/C++ programmer!\\n```\\n[-2147483648,-2147483647,2147483647]\\n```"
                    },
                    {
                        "username": "dfisheritp",
                        "content": "the array is sorted. `[INT_MIN, INT_MAX]` has a solution. `nums[i] + 1 == nums[i + 1]`\\n\\nLEFT SIDE : -2147483648 -> -2147483647\\nRIGHT SIDE : 2147483647 -> -2147483648\\n\\nIt fails the test.\\n\\nYou need a guard clause for the \"->\" anyway. And the compiler will cache that because it see\\'s that it\\'s needed immediately after. Like come on."
                    },
                    {
                        "username": "Rifat121",
                        "content": "how to solve this overflow issue!\\n"
                    },
                    {
                        "username": "geekyshark",
                        "content": "[@jasonpyau](/jasonpyau) same here lol, i checked for [\"0\"] but forgot to check for empty array\\n"
                    },
                    {
                        "username": "autf",
                        "content": "Me too (Rust)\\nOne of a million ways to fail a binary search."
                    },
                    {
                        "username": "daring-calf",
                        "content": "This got me too! (golang)"
                    },
                    {
                        "username": "redocmi7",
                        "content": "Yeah, me too! Got confused untill I viewed the testcase where it failed.\\n\\nMoral of the lesson: Always check for integer overflows!"
                    },
                    {
                        "username": "jasonpyau",
                        "content": "Wasted 2 submissions cuz of integer overflow and empty array!! :["
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "me: Who passed in single go without any error or WA \\uD83D\\uDE0E"
                    },
                    {
                        "username": "antoxakartoxa",
                        "content": "In the task description there is \"nums is sorted in ascending order\". But one of testcases checked after submission is [2, -1] which is descending order. "
                    },
                    {
                        "username": "daregula",
                        "content": "dude I just ran into the same thing lol I had to use abs() when checking for the difference to bypass this invalid test case"
                    },
                    {
                        "username": "baryonix",
                        "content": "I have the same issue, this prevents me from completing the 150-question Study Plan :(.\\nThe thing is I solved this question before this new constraint/test case was added"
                    },
                    {
                        "username": "kokolen77",
                        "content": "I wrote about this on github, but seems like they dont see an error here https://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/16112"
                    },
                    {
                        "username": "batman12345",
                        "content": "![image](https://assets.leetcode.com/users/jasinghe/image_1541988925.png)\\n\\nAll submissions are the exact same. A couple ms makes a huge difference in how fast your submission is judged so resubmit a couple times to be sure your solution isn\\'t actually slow :) \\n\\n32ms = you beat 100%\\n52ms = you beat 10% \\n\\nlol"
                    },
                    {
                        "username": "andreasfesshahagglund",
                        "content": "Yeah man. I went from beating 5 % to beating 92 % of all submissions with the same lines of code. =/"
                    },
                    {
                        "username": "District_12",
                        "content": "Why not [\"0-7\"] as a result? What do you need? Problem description is so bad."
                    },
                    {
                        "username": "rishavranjan1821",
                        "content": "the range means you have to give a range in which it should contain all the numbers that comes between these numbers. See [\"0 - 7\"] is not a range because as per the question the range should contain 0,1,,2,3,4,5,6,7 but in the nums array after 0,1,2 . 4 comes which will not be considered as in the range of [0,7] for that after 2 , 3 has to be present thats why [\"0,7\\'] range is not possible\\n"
                    },
                    {
                        "username": "sandyy",
                        "content": "The numbers in the resultant set must be consecutive only. For input [0,1,2,4,5,7] there are only 3 consecutive sets. First is [0,1,2], second is [4,5] and third is [7]. [0,7] can be the answer when input is [0,1,2,3,4,5,6,7]. I agree that the problem statement is not clear enough."
                    },
                    {
                        "username": "mayank17081998",
                        "content": "![image](https://assets.leetcode.com/users/images/308e256b-0272-4010-876a-8b3745b95fed_1646015105.510134.png)\\n![image](https://assets.leetcode.com/users/images/be57f0f2-c7c0-433e-9e1d-d61ba0fc4dcc_1646015113.6479263.png)\\n![image](https://assets.leetcode.com/users/images/e883adbe-45dd-49e6-975b-294d0670c670_1646015121.1118414.png)\\n![image](https://assets.leetcode.com/users/images/1de2db64-268f-4bf9-bcd5-7a511f79f254_1646015129.5048964.png)\\n![image](https://assets.leetcode.com/users/images/c3f49c2e-359d-4f23-a4d7-b02f56b87cff_1646015136.1616788.png)\\n![image](https://assets.leetcode.com/users/images/170ea0b6-91ee-4b2e-8ad8-dfac1374944c_1646015141.054478.png)\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "Tim_Guan",
                        "content": "Dislike for confusing test case [2; -1]"
                    },
                    {
                        "username": "mayankagarwal2402",
                        "content": "it not confusing, it's incorrect. \nHave submitted a feedback for the same, others should too, to get it highlighted and rectified. "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 28.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/summary-ranges/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 0 approach in the official solution</summary>\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "mindstrong",
                        "content": "I can not understand what does this question is. the example show's none principles to summarize the ranges. why [0,1,2,4,5,7] should be summarized to [\"0->2\", \"4->5\", \"7\"], why not [\"0-1\", \"2->5\", \"7\"?\\n\\nwho can explain this question more clearly ? thank you in advance."
                    },
                    {
                        "username": "emma-vuksich",
                        "content": "The ranges have to be consecutive numbers (one after the other, in order). Within [0,1,2,4,5,7], 0->2 is a range because the numbers 0, 1, 2 are consecutive. 4->5 is a range because the numbers 4 and 5 are consecutive."
                    },
                    {
                        "username": "sardarsj",
                        "content": "In this problem, the range means we have to give a range in which it should contain all the numbers consecutively. [\"0 - 7\"] is not a range because as per the question the range should contain 0,1,,2,3,4,5,6,7 but in the \\'nums\\' array after 0,1,2 . 4 comes which will not be considered as in the range of [0,7] for that after 2 , 3 has to be present thatswhy [\"0,7\\'] range is not possible"
                    },
                    {
                        "username": "firuz97",
                        "content": "Hi there!\\nFor me as one who is not a native speaker to figure out the task was confusing. I think over the examples and found this.\\nit makes a range until it mets skip number in array.\\nFor example.\\n[0,2,3] -> [\"0\", \"2->3\"]\\n[0,1,3] -> [\"0->1\", \"3\"]\\nI hope my comment will help someone."
                    },
                    {
                        "username": "LuciferYSD",
                        "content": "if you do it 2->5 3 is not present\\n"
                    }
                ]
            },
            {
                "id": 1568072,
                "content": [
                    {
                        "username": "yuanshuo",
                        "content": "I don't really understand what this question is asking. It says return the summary of its ranges but the what does this mean?"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "[@bjlslopez](/bjlslopez) dude own\\'s leetcode ! what a clear cut explanation"
                    },
                    {
                        "username": "The_ThunderBolt",
                        "content": "[@bjlslopez](/bjlslopez)  it helps, Thanks man!"
                    },
                    {
                        "username": "charanarc3",
                        "content": "[@bjlslopez](/bjlslopez) it helps thanks\\n"
                    },
                    {
                        "username": "Ilkhomjon",
                        "content": "[@bjlslopez](/bjlslopez) Thank you man, your explanation is really concise!"
                    },
                    {
                        "username": "bjlslopez",
                        "content": "It is asking for you to summarize continuous numbers into a range. For example, 0, 1 should be converted to 0->1. A more useful application would be 2,3,4,5,6,7,8,9,10 can be summarized to 2->10.\\nHowever, if you have 0,2, there is a gap in the range, so you should return \"0\", \"2\".\\nExample: 0, 2, 3, 4, 5, 6, 7, 8, 10, 20, 25, 26, 27\\nTurns to: 0, 2->8, 10, 20, 25->27\\nYou can think of it in terms of how pages are referenced in bibliographies. Example: Python for Dummies. Pages: 1-4, 10 means pages 1 to 4 and page 10."
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Image Explanation\\n```\\nInput: nums = [0,2,3,4,6,8,9]\\n```\\n![image.png](https://assets.leetcode.com/users/images/5ede8d3f-665d-4d88-a628-de73a0986db9_1686559423.6645904.png)\\nThe problem asks us to \"group\" the elements of array into ranges that are continuous. That is, in one range their should not be any number absent in array. And we need to minimize the different ranges we use, so try to take as big range as possible. At each element, make a different range only when you find some number absent in between current and last element, otherwise expand the current range by $1$.\\n```\\nOutput: [\"0\",\"2->4\",\"6\",\"8->9\"]\\n```"
                    },
                    {
                        "username": "Musfik41",
                        "content": "[@mmtemel](/mmtemel) leetcode should hire you for this awesome visual explanation\\uD83D\\uDE05. 100% satisfied."
                    },
                    {
                        "username": "mmtemel",
                        "content": "your explanation should be the problem explanation"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is an easy question. But test this test case before submitting, especially for the  C/C++ programmer!\\n```\\n[-2147483648,-2147483647,2147483647]\\n```"
                    },
                    {
                        "username": "dfisheritp",
                        "content": "the array is sorted. `[INT_MIN, INT_MAX]` has a solution. `nums[i] + 1 == nums[i + 1]`\\n\\nLEFT SIDE : -2147483648 -> -2147483647\\nRIGHT SIDE : 2147483647 -> -2147483648\\n\\nIt fails the test.\\n\\nYou need a guard clause for the \"->\" anyway. And the compiler will cache that because it see\\'s that it\\'s needed immediately after. Like come on."
                    },
                    {
                        "username": "Rifat121",
                        "content": "how to solve this overflow issue!\\n"
                    },
                    {
                        "username": "geekyshark",
                        "content": "[@jasonpyau](/jasonpyau) same here lol, i checked for [\"0\"] but forgot to check for empty array\\n"
                    },
                    {
                        "username": "autf",
                        "content": "Me too (Rust)\\nOne of a million ways to fail a binary search."
                    },
                    {
                        "username": "daring-calf",
                        "content": "This got me too! (golang)"
                    },
                    {
                        "username": "redocmi7",
                        "content": "Yeah, me too! Got confused untill I viewed the testcase where it failed.\\n\\nMoral of the lesson: Always check for integer overflows!"
                    },
                    {
                        "username": "jasonpyau",
                        "content": "Wasted 2 submissions cuz of integer overflow and empty array!! :["
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "me: Who passed in single go without any error or WA \\uD83D\\uDE0E"
                    },
                    {
                        "username": "antoxakartoxa",
                        "content": "In the task description there is \"nums is sorted in ascending order\". But one of testcases checked after submission is [2, -1] which is descending order. "
                    },
                    {
                        "username": "daregula",
                        "content": "dude I just ran into the same thing lol I had to use abs() when checking for the difference to bypass this invalid test case"
                    },
                    {
                        "username": "baryonix",
                        "content": "I have the same issue, this prevents me from completing the 150-question Study Plan :(.\\nThe thing is I solved this question before this new constraint/test case was added"
                    },
                    {
                        "username": "kokolen77",
                        "content": "I wrote about this on github, but seems like they dont see an error here https://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/16112"
                    },
                    {
                        "username": "batman12345",
                        "content": "![image](https://assets.leetcode.com/users/jasinghe/image_1541988925.png)\\n\\nAll submissions are the exact same. A couple ms makes a huge difference in how fast your submission is judged so resubmit a couple times to be sure your solution isn\\'t actually slow :) \\n\\n32ms = you beat 100%\\n52ms = you beat 10% \\n\\nlol"
                    },
                    {
                        "username": "andreasfesshahagglund",
                        "content": "Yeah man. I went from beating 5 % to beating 92 % of all submissions with the same lines of code. =/"
                    },
                    {
                        "username": "District_12",
                        "content": "Why not [\"0-7\"] as a result? What do you need? Problem description is so bad."
                    },
                    {
                        "username": "rishavranjan1821",
                        "content": "the range means you have to give a range in which it should contain all the numbers that comes between these numbers. See [\"0 - 7\"] is not a range because as per the question the range should contain 0,1,,2,3,4,5,6,7 but in the nums array after 0,1,2 . 4 comes which will not be considered as in the range of [0,7] for that after 2 , 3 has to be present thats why [\"0,7\\'] range is not possible\\n"
                    },
                    {
                        "username": "sandyy",
                        "content": "The numbers in the resultant set must be consecutive only. For input [0,1,2,4,5,7] there are only 3 consecutive sets. First is [0,1,2], second is [4,5] and third is [7]. [0,7] can be the answer when input is [0,1,2,3,4,5,6,7]. I agree that the problem statement is not clear enough."
                    },
                    {
                        "username": "mayank17081998",
                        "content": "![image](https://assets.leetcode.com/users/images/308e256b-0272-4010-876a-8b3745b95fed_1646015105.510134.png)\\n![image](https://assets.leetcode.com/users/images/be57f0f2-c7c0-433e-9e1d-d61ba0fc4dcc_1646015113.6479263.png)\\n![image](https://assets.leetcode.com/users/images/e883adbe-45dd-49e6-975b-294d0670c670_1646015121.1118414.png)\\n![image](https://assets.leetcode.com/users/images/1de2db64-268f-4bf9-bcd5-7a511f79f254_1646015129.5048964.png)\\n![image](https://assets.leetcode.com/users/images/c3f49c2e-359d-4f23-a4d7-b02f56b87cff_1646015136.1616788.png)\\n![image](https://assets.leetcode.com/users/images/170ea0b6-91ee-4b2e-8ad8-dfac1374944c_1646015141.054478.png)\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "Tim_Guan",
                        "content": "Dislike for confusing test case [2; -1]"
                    },
                    {
                        "username": "mayankagarwal2402",
                        "content": "it not confusing, it's incorrect. \nHave submitted a feedback for the same, others should too, to get it highlighted and rectified. "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 28.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/summary-ranges/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 0 approach in the official solution</summary>\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "mindstrong",
                        "content": "I can not understand what does this question is. the example show's none principles to summarize the ranges. why [0,1,2,4,5,7] should be summarized to [\"0->2\", \"4->5\", \"7\"], why not [\"0-1\", \"2->5\", \"7\"?\\n\\nwho can explain this question more clearly ? thank you in advance."
                    },
                    {
                        "username": "emma-vuksich",
                        "content": "The ranges have to be consecutive numbers (one after the other, in order). Within [0,1,2,4,5,7], 0->2 is a range because the numbers 0, 1, 2 are consecutive. 4->5 is a range because the numbers 4 and 5 are consecutive."
                    },
                    {
                        "username": "sardarsj",
                        "content": "In this problem, the range means we have to give a range in which it should contain all the numbers consecutively. [\"0 - 7\"] is not a range because as per the question the range should contain 0,1,,2,3,4,5,6,7 but in the \\'nums\\' array after 0,1,2 . 4 comes which will not be considered as in the range of [0,7] for that after 2 , 3 has to be present thatswhy [\"0,7\\'] range is not possible"
                    },
                    {
                        "username": "firuz97",
                        "content": "Hi there!\\nFor me as one who is not a native speaker to figure out the task was confusing. I think over the examples and found this.\\nit makes a range until it mets skip number in array.\\nFor example.\\n[0,2,3] -> [\"0\", \"2->3\"]\\n[0,1,3] -> [\"0->1\", \"3\"]\\nI hope my comment will help someone."
                    },
                    {
                        "username": "LuciferYSD",
                        "content": "if you do it 2->5 3 is not present\\n"
                    }
                ]
            },
            {
                "id": 1731777,
                "content": [
                    {
                        "username": "yuanshuo",
                        "content": "I don't really understand what this question is asking. It says return the summary of its ranges but the what does this mean?"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "[@bjlslopez](/bjlslopez) dude own\\'s leetcode ! what a clear cut explanation"
                    },
                    {
                        "username": "The_ThunderBolt",
                        "content": "[@bjlslopez](/bjlslopez)  it helps, Thanks man!"
                    },
                    {
                        "username": "charanarc3",
                        "content": "[@bjlslopez](/bjlslopez) it helps thanks\\n"
                    },
                    {
                        "username": "Ilkhomjon",
                        "content": "[@bjlslopez](/bjlslopez) Thank you man, your explanation is really concise!"
                    },
                    {
                        "username": "bjlslopez",
                        "content": "It is asking for you to summarize continuous numbers into a range. For example, 0, 1 should be converted to 0->1. A more useful application would be 2,3,4,5,6,7,8,9,10 can be summarized to 2->10.\\nHowever, if you have 0,2, there is a gap in the range, so you should return \"0\", \"2\".\\nExample: 0, 2, 3, 4, 5, 6, 7, 8, 10, 20, 25, 26, 27\\nTurns to: 0, 2->8, 10, 20, 25->27\\nYou can think of it in terms of how pages are referenced in bibliographies. Example: Python for Dummies. Pages: 1-4, 10 means pages 1 to 4 and page 10."
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Image Explanation\\n```\\nInput: nums = [0,2,3,4,6,8,9]\\n```\\n![image.png](https://assets.leetcode.com/users/images/5ede8d3f-665d-4d88-a628-de73a0986db9_1686559423.6645904.png)\\nThe problem asks us to \"group\" the elements of array into ranges that are continuous. That is, in one range their should not be any number absent in array. And we need to minimize the different ranges we use, so try to take as big range as possible. At each element, make a different range only when you find some number absent in between current and last element, otherwise expand the current range by $1$.\\n```\\nOutput: [\"0\",\"2->4\",\"6\",\"8->9\"]\\n```"
                    },
                    {
                        "username": "Musfik41",
                        "content": "[@mmtemel](/mmtemel) leetcode should hire you for this awesome visual explanation\\uD83D\\uDE05. 100% satisfied."
                    },
                    {
                        "username": "mmtemel",
                        "content": "your explanation should be the problem explanation"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is an easy question. But test this test case before submitting, especially for the  C/C++ programmer!\\n```\\n[-2147483648,-2147483647,2147483647]\\n```"
                    },
                    {
                        "username": "dfisheritp",
                        "content": "the array is sorted. `[INT_MIN, INT_MAX]` has a solution. `nums[i] + 1 == nums[i + 1]`\\n\\nLEFT SIDE : -2147483648 -> -2147483647\\nRIGHT SIDE : 2147483647 -> -2147483648\\n\\nIt fails the test.\\n\\nYou need a guard clause for the \"->\" anyway. And the compiler will cache that because it see\\'s that it\\'s needed immediately after. Like come on."
                    },
                    {
                        "username": "Rifat121",
                        "content": "how to solve this overflow issue!\\n"
                    },
                    {
                        "username": "geekyshark",
                        "content": "[@jasonpyau](/jasonpyau) same here lol, i checked for [\"0\"] but forgot to check for empty array\\n"
                    },
                    {
                        "username": "autf",
                        "content": "Me too (Rust)\\nOne of a million ways to fail a binary search."
                    },
                    {
                        "username": "daring-calf",
                        "content": "This got me too! (golang)"
                    },
                    {
                        "username": "redocmi7",
                        "content": "Yeah, me too! Got confused untill I viewed the testcase where it failed.\\n\\nMoral of the lesson: Always check for integer overflows!"
                    },
                    {
                        "username": "jasonpyau",
                        "content": "Wasted 2 submissions cuz of integer overflow and empty array!! :["
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "me: Who passed in single go without any error or WA \\uD83D\\uDE0E"
                    },
                    {
                        "username": "antoxakartoxa",
                        "content": "In the task description there is \"nums is sorted in ascending order\". But one of testcases checked after submission is [2, -1] which is descending order. "
                    },
                    {
                        "username": "daregula",
                        "content": "dude I just ran into the same thing lol I had to use abs() when checking for the difference to bypass this invalid test case"
                    },
                    {
                        "username": "baryonix",
                        "content": "I have the same issue, this prevents me from completing the 150-question Study Plan :(.\\nThe thing is I solved this question before this new constraint/test case was added"
                    },
                    {
                        "username": "kokolen77",
                        "content": "I wrote about this on github, but seems like they dont see an error here https://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/16112"
                    },
                    {
                        "username": "batman12345",
                        "content": "![image](https://assets.leetcode.com/users/jasinghe/image_1541988925.png)\\n\\nAll submissions are the exact same. A couple ms makes a huge difference in how fast your submission is judged so resubmit a couple times to be sure your solution isn\\'t actually slow :) \\n\\n32ms = you beat 100%\\n52ms = you beat 10% \\n\\nlol"
                    },
                    {
                        "username": "andreasfesshahagglund",
                        "content": "Yeah man. I went from beating 5 % to beating 92 % of all submissions with the same lines of code. =/"
                    },
                    {
                        "username": "District_12",
                        "content": "Why not [\"0-7\"] as a result? What do you need? Problem description is so bad."
                    },
                    {
                        "username": "rishavranjan1821",
                        "content": "the range means you have to give a range in which it should contain all the numbers that comes between these numbers. See [\"0 - 7\"] is not a range because as per the question the range should contain 0,1,,2,3,4,5,6,7 but in the nums array after 0,1,2 . 4 comes which will not be considered as in the range of [0,7] for that after 2 , 3 has to be present thats why [\"0,7\\'] range is not possible\\n"
                    },
                    {
                        "username": "sandyy",
                        "content": "The numbers in the resultant set must be consecutive only. For input [0,1,2,4,5,7] there are only 3 consecutive sets. First is [0,1,2], second is [4,5] and third is [7]. [0,7] can be the answer when input is [0,1,2,3,4,5,6,7]. I agree that the problem statement is not clear enough."
                    },
                    {
                        "username": "mayank17081998",
                        "content": "![image](https://assets.leetcode.com/users/images/308e256b-0272-4010-876a-8b3745b95fed_1646015105.510134.png)\\n![image](https://assets.leetcode.com/users/images/be57f0f2-c7c0-433e-9e1d-d61ba0fc4dcc_1646015113.6479263.png)\\n![image](https://assets.leetcode.com/users/images/e883adbe-45dd-49e6-975b-294d0670c670_1646015121.1118414.png)\\n![image](https://assets.leetcode.com/users/images/1de2db64-268f-4bf9-bcd5-7a511f79f254_1646015129.5048964.png)\\n![image](https://assets.leetcode.com/users/images/c3f49c2e-359d-4f23-a4d7-b02f56b87cff_1646015136.1616788.png)\\n![image](https://assets.leetcode.com/users/images/170ea0b6-91ee-4b2e-8ad8-dfac1374944c_1646015141.054478.png)\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "Tim_Guan",
                        "content": "Dislike for confusing test case [2; -1]"
                    },
                    {
                        "username": "mayankagarwal2402",
                        "content": "it not confusing, it's incorrect. \nHave submitted a feedback for the same, others should too, to get it highlighted and rectified. "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 28.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/summary-ranges/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 0 approach in the official solution</summary>\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "mindstrong",
                        "content": "I can not understand what does this question is. the example show's none principles to summarize the ranges. why [0,1,2,4,5,7] should be summarized to [\"0->2\", \"4->5\", \"7\"], why not [\"0-1\", \"2->5\", \"7\"?\\n\\nwho can explain this question more clearly ? thank you in advance."
                    },
                    {
                        "username": "emma-vuksich",
                        "content": "The ranges have to be consecutive numbers (one after the other, in order). Within [0,1,2,4,5,7], 0->2 is a range because the numbers 0, 1, 2 are consecutive. 4->5 is a range because the numbers 4 and 5 are consecutive."
                    },
                    {
                        "username": "sardarsj",
                        "content": "In this problem, the range means we have to give a range in which it should contain all the numbers consecutively. [\"0 - 7\"] is not a range because as per the question the range should contain 0,1,,2,3,4,5,6,7 but in the \\'nums\\' array after 0,1,2 . 4 comes which will not be considered as in the range of [0,7] for that after 2 , 3 has to be present thatswhy [\"0,7\\'] range is not possible"
                    },
                    {
                        "username": "firuz97",
                        "content": "Hi there!\\nFor me as one who is not a native speaker to figure out the task was confusing. I think over the examples and found this.\\nit makes a range until it mets skip number in array.\\nFor example.\\n[0,2,3] -> [\"0\", \"2->3\"]\\n[0,1,3] -> [\"0->1\", \"3\"]\\nI hope my comment will help someone."
                    },
                    {
                        "username": "LuciferYSD",
                        "content": "if you do it 2->5 3 is not present\\n"
                    }
                ]
            },
            {
                "id": 1576455,
                "content": [
                    {
                        "username": "yuanshuo",
                        "content": "I don't really understand what this question is asking. It says return the summary of its ranges but the what does this mean?"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "[@bjlslopez](/bjlslopez) dude own\\'s leetcode ! what a clear cut explanation"
                    },
                    {
                        "username": "The_ThunderBolt",
                        "content": "[@bjlslopez](/bjlslopez)  it helps, Thanks man!"
                    },
                    {
                        "username": "charanarc3",
                        "content": "[@bjlslopez](/bjlslopez) it helps thanks\\n"
                    },
                    {
                        "username": "Ilkhomjon",
                        "content": "[@bjlslopez](/bjlslopez) Thank you man, your explanation is really concise!"
                    },
                    {
                        "username": "bjlslopez",
                        "content": "It is asking for you to summarize continuous numbers into a range. For example, 0, 1 should be converted to 0->1. A more useful application would be 2,3,4,5,6,7,8,9,10 can be summarized to 2->10.\\nHowever, if you have 0,2, there is a gap in the range, so you should return \"0\", \"2\".\\nExample: 0, 2, 3, 4, 5, 6, 7, 8, 10, 20, 25, 26, 27\\nTurns to: 0, 2->8, 10, 20, 25->27\\nYou can think of it in terms of how pages are referenced in bibliographies. Example: Python for Dummies. Pages: 1-4, 10 means pages 1 to 4 and page 10."
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Image Explanation\\n```\\nInput: nums = [0,2,3,4,6,8,9]\\n```\\n![image.png](https://assets.leetcode.com/users/images/5ede8d3f-665d-4d88-a628-de73a0986db9_1686559423.6645904.png)\\nThe problem asks us to \"group\" the elements of array into ranges that are continuous. That is, in one range their should not be any number absent in array. And we need to minimize the different ranges we use, so try to take as big range as possible. At each element, make a different range only when you find some number absent in between current and last element, otherwise expand the current range by $1$.\\n```\\nOutput: [\"0\",\"2->4\",\"6\",\"8->9\"]\\n```"
                    },
                    {
                        "username": "Musfik41",
                        "content": "[@mmtemel](/mmtemel) leetcode should hire you for this awesome visual explanation\\uD83D\\uDE05. 100% satisfied."
                    },
                    {
                        "username": "mmtemel",
                        "content": "your explanation should be the problem explanation"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is an easy question. But test this test case before submitting, especially for the  C/C++ programmer!\\n```\\n[-2147483648,-2147483647,2147483647]\\n```"
                    },
                    {
                        "username": "dfisheritp",
                        "content": "the array is sorted. `[INT_MIN, INT_MAX]` has a solution. `nums[i] + 1 == nums[i + 1]`\\n\\nLEFT SIDE : -2147483648 -> -2147483647\\nRIGHT SIDE : 2147483647 -> -2147483648\\n\\nIt fails the test.\\n\\nYou need a guard clause for the \"->\" anyway. And the compiler will cache that because it see\\'s that it\\'s needed immediately after. Like come on."
                    },
                    {
                        "username": "Rifat121",
                        "content": "how to solve this overflow issue!\\n"
                    },
                    {
                        "username": "geekyshark",
                        "content": "[@jasonpyau](/jasonpyau) same here lol, i checked for [\"0\"] but forgot to check for empty array\\n"
                    },
                    {
                        "username": "autf",
                        "content": "Me too (Rust)\\nOne of a million ways to fail a binary search."
                    },
                    {
                        "username": "daring-calf",
                        "content": "This got me too! (golang)"
                    },
                    {
                        "username": "redocmi7",
                        "content": "Yeah, me too! Got confused untill I viewed the testcase where it failed.\\n\\nMoral of the lesson: Always check for integer overflows!"
                    },
                    {
                        "username": "jasonpyau",
                        "content": "Wasted 2 submissions cuz of integer overflow and empty array!! :["
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "me: Who passed in single go without any error or WA \\uD83D\\uDE0E"
                    },
                    {
                        "username": "antoxakartoxa",
                        "content": "In the task description there is \"nums is sorted in ascending order\". But one of testcases checked after submission is [2, -1] which is descending order. "
                    },
                    {
                        "username": "daregula",
                        "content": "dude I just ran into the same thing lol I had to use abs() when checking for the difference to bypass this invalid test case"
                    },
                    {
                        "username": "baryonix",
                        "content": "I have the same issue, this prevents me from completing the 150-question Study Plan :(.\\nThe thing is I solved this question before this new constraint/test case was added"
                    },
                    {
                        "username": "kokolen77",
                        "content": "I wrote about this on github, but seems like they dont see an error here https://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/16112"
                    },
                    {
                        "username": "batman12345",
                        "content": "![image](https://assets.leetcode.com/users/jasinghe/image_1541988925.png)\\n\\nAll submissions are the exact same. A couple ms makes a huge difference in how fast your submission is judged so resubmit a couple times to be sure your solution isn\\'t actually slow :) \\n\\n32ms = you beat 100%\\n52ms = you beat 10% \\n\\nlol"
                    },
                    {
                        "username": "andreasfesshahagglund",
                        "content": "Yeah man. I went from beating 5 % to beating 92 % of all submissions with the same lines of code. =/"
                    },
                    {
                        "username": "District_12",
                        "content": "Why not [\"0-7\"] as a result? What do you need? Problem description is so bad."
                    },
                    {
                        "username": "rishavranjan1821",
                        "content": "the range means you have to give a range in which it should contain all the numbers that comes between these numbers. See [\"0 - 7\"] is not a range because as per the question the range should contain 0,1,,2,3,4,5,6,7 but in the nums array after 0,1,2 . 4 comes which will not be considered as in the range of [0,7] for that after 2 , 3 has to be present thats why [\"0,7\\'] range is not possible\\n"
                    },
                    {
                        "username": "sandyy",
                        "content": "The numbers in the resultant set must be consecutive only. For input [0,1,2,4,5,7] there are only 3 consecutive sets. First is [0,1,2], second is [4,5] and third is [7]. [0,7] can be the answer when input is [0,1,2,3,4,5,6,7]. I agree that the problem statement is not clear enough."
                    },
                    {
                        "username": "mayank17081998",
                        "content": "![image](https://assets.leetcode.com/users/images/308e256b-0272-4010-876a-8b3745b95fed_1646015105.510134.png)\\n![image](https://assets.leetcode.com/users/images/be57f0f2-c7c0-433e-9e1d-d61ba0fc4dcc_1646015113.6479263.png)\\n![image](https://assets.leetcode.com/users/images/e883adbe-45dd-49e6-975b-294d0670c670_1646015121.1118414.png)\\n![image](https://assets.leetcode.com/users/images/1de2db64-268f-4bf9-bcd5-7a511f79f254_1646015129.5048964.png)\\n![image](https://assets.leetcode.com/users/images/c3f49c2e-359d-4f23-a4d7-b02f56b87cff_1646015136.1616788.png)\\n![image](https://assets.leetcode.com/users/images/170ea0b6-91ee-4b2e-8ad8-dfac1374944c_1646015141.054478.png)\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "Tim_Guan",
                        "content": "Dislike for confusing test case [2; -1]"
                    },
                    {
                        "username": "mayankagarwal2402",
                        "content": "it not confusing, it's incorrect. \nHave submitted a feedback for the same, others should too, to get it highlighted and rectified. "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 28.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/summary-ranges/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 0 approach in the official solution</summary>\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "mindstrong",
                        "content": "I can not understand what does this question is. the example show's none principles to summarize the ranges. why [0,1,2,4,5,7] should be summarized to [\"0->2\", \"4->5\", \"7\"], why not [\"0-1\", \"2->5\", \"7\"?\\n\\nwho can explain this question more clearly ? thank you in advance."
                    },
                    {
                        "username": "emma-vuksich",
                        "content": "The ranges have to be consecutive numbers (one after the other, in order). Within [0,1,2,4,5,7], 0->2 is a range because the numbers 0, 1, 2 are consecutive. 4->5 is a range because the numbers 4 and 5 are consecutive."
                    },
                    {
                        "username": "sardarsj",
                        "content": "In this problem, the range means we have to give a range in which it should contain all the numbers consecutively. [\"0 - 7\"] is not a range because as per the question the range should contain 0,1,,2,3,4,5,6,7 but in the \\'nums\\' array after 0,1,2 . 4 comes which will not be considered as in the range of [0,7] for that after 2 , 3 has to be present thatswhy [\"0,7\\'] range is not possible"
                    },
                    {
                        "username": "firuz97",
                        "content": "Hi there!\\nFor me as one who is not a native speaker to figure out the task was confusing. I think over the examples and found this.\\nit makes a range until it mets skip number in array.\\nFor example.\\n[0,2,3] -> [\"0\", \"2->3\"]\\n[0,1,3] -> [\"0->1\", \"3\"]\\nI hope my comment will help someone."
                    },
                    {
                        "username": "LuciferYSD",
                        "content": "if you do it 2->5 3 is not present\\n"
                    }
                ]
            },
            {
                "id": 2050771,
                "content": [
                    {
                        "username": "yuanshuo",
                        "content": "I don't really understand what this question is asking. It says return the summary of its ranges but the what does this mean?"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "[@bjlslopez](/bjlslopez) dude own\\'s leetcode ! what a clear cut explanation"
                    },
                    {
                        "username": "The_ThunderBolt",
                        "content": "[@bjlslopez](/bjlslopez)  it helps, Thanks man!"
                    },
                    {
                        "username": "charanarc3",
                        "content": "[@bjlslopez](/bjlslopez) it helps thanks\\n"
                    },
                    {
                        "username": "Ilkhomjon",
                        "content": "[@bjlslopez](/bjlslopez) Thank you man, your explanation is really concise!"
                    },
                    {
                        "username": "bjlslopez",
                        "content": "It is asking for you to summarize continuous numbers into a range. For example, 0, 1 should be converted to 0->1. A more useful application would be 2,3,4,5,6,7,8,9,10 can be summarized to 2->10.\\nHowever, if you have 0,2, there is a gap in the range, so you should return \"0\", \"2\".\\nExample: 0, 2, 3, 4, 5, 6, 7, 8, 10, 20, 25, 26, 27\\nTurns to: 0, 2->8, 10, 20, 25->27\\nYou can think of it in terms of how pages are referenced in bibliographies. Example: Python for Dummies. Pages: 1-4, 10 means pages 1 to 4 and page 10."
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Image Explanation\\n```\\nInput: nums = [0,2,3,4,6,8,9]\\n```\\n![image.png](https://assets.leetcode.com/users/images/5ede8d3f-665d-4d88-a628-de73a0986db9_1686559423.6645904.png)\\nThe problem asks us to \"group\" the elements of array into ranges that are continuous. That is, in one range their should not be any number absent in array. And we need to minimize the different ranges we use, so try to take as big range as possible. At each element, make a different range only when you find some number absent in between current and last element, otherwise expand the current range by $1$.\\n```\\nOutput: [\"0\",\"2->4\",\"6\",\"8->9\"]\\n```"
                    },
                    {
                        "username": "Musfik41",
                        "content": "[@mmtemel](/mmtemel) leetcode should hire you for this awesome visual explanation\\uD83D\\uDE05. 100% satisfied."
                    },
                    {
                        "username": "mmtemel",
                        "content": "your explanation should be the problem explanation"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is an easy question. But test this test case before submitting, especially for the  C/C++ programmer!\\n```\\n[-2147483648,-2147483647,2147483647]\\n```"
                    },
                    {
                        "username": "dfisheritp",
                        "content": "the array is sorted. `[INT_MIN, INT_MAX]` has a solution. `nums[i] + 1 == nums[i + 1]`\\n\\nLEFT SIDE : -2147483648 -> -2147483647\\nRIGHT SIDE : 2147483647 -> -2147483648\\n\\nIt fails the test.\\n\\nYou need a guard clause for the \"->\" anyway. And the compiler will cache that because it see\\'s that it\\'s needed immediately after. Like come on."
                    },
                    {
                        "username": "Rifat121",
                        "content": "how to solve this overflow issue!\\n"
                    },
                    {
                        "username": "geekyshark",
                        "content": "[@jasonpyau](/jasonpyau) same here lol, i checked for [\"0\"] but forgot to check for empty array\\n"
                    },
                    {
                        "username": "autf",
                        "content": "Me too (Rust)\\nOne of a million ways to fail a binary search."
                    },
                    {
                        "username": "daring-calf",
                        "content": "This got me too! (golang)"
                    },
                    {
                        "username": "redocmi7",
                        "content": "Yeah, me too! Got confused untill I viewed the testcase where it failed.\\n\\nMoral of the lesson: Always check for integer overflows!"
                    },
                    {
                        "username": "jasonpyau",
                        "content": "Wasted 2 submissions cuz of integer overflow and empty array!! :["
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "me: Who passed in single go without any error or WA \\uD83D\\uDE0E"
                    },
                    {
                        "username": "antoxakartoxa",
                        "content": "In the task description there is \"nums is sorted in ascending order\". But one of testcases checked after submission is [2, -1] which is descending order. "
                    },
                    {
                        "username": "daregula",
                        "content": "dude I just ran into the same thing lol I had to use abs() when checking for the difference to bypass this invalid test case"
                    },
                    {
                        "username": "baryonix",
                        "content": "I have the same issue, this prevents me from completing the 150-question Study Plan :(.\\nThe thing is I solved this question before this new constraint/test case was added"
                    },
                    {
                        "username": "kokolen77",
                        "content": "I wrote about this on github, but seems like they dont see an error here https://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/16112"
                    },
                    {
                        "username": "batman12345",
                        "content": "![image](https://assets.leetcode.com/users/jasinghe/image_1541988925.png)\\n\\nAll submissions are the exact same. A couple ms makes a huge difference in how fast your submission is judged so resubmit a couple times to be sure your solution isn\\'t actually slow :) \\n\\n32ms = you beat 100%\\n52ms = you beat 10% \\n\\nlol"
                    },
                    {
                        "username": "andreasfesshahagglund",
                        "content": "Yeah man. I went from beating 5 % to beating 92 % of all submissions with the same lines of code. =/"
                    },
                    {
                        "username": "District_12",
                        "content": "Why not [\"0-7\"] as a result? What do you need? Problem description is so bad."
                    },
                    {
                        "username": "rishavranjan1821",
                        "content": "the range means you have to give a range in which it should contain all the numbers that comes between these numbers. See [\"0 - 7\"] is not a range because as per the question the range should contain 0,1,,2,3,4,5,6,7 but in the nums array after 0,1,2 . 4 comes which will not be considered as in the range of [0,7] for that after 2 , 3 has to be present thats why [\"0,7\\'] range is not possible\\n"
                    },
                    {
                        "username": "sandyy",
                        "content": "The numbers in the resultant set must be consecutive only. For input [0,1,2,4,5,7] there are only 3 consecutive sets. First is [0,1,2], second is [4,5] and third is [7]. [0,7] can be the answer when input is [0,1,2,3,4,5,6,7]. I agree that the problem statement is not clear enough."
                    },
                    {
                        "username": "mayank17081998",
                        "content": "![image](https://assets.leetcode.com/users/images/308e256b-0272-4010-876a-8b3745b95fed_1646015105.510134.png)\\n![image](https://assets.leetcode.com/users/images/be57f0f2-c7c0-433e-9e1d-d61ba0fc4dcc_1646015113.6479263.png)\\n![image](https://assets.leetcode.com/users/images/e883adbe-45dd-49e6-975b-294d0670c670_1646015121.1118414.png)\\n![image](https://assets.leetcode.com/users/images/1de2db64-268f-4bf9-bcd5-7a511f79f254_1646015129.5048964.png)\\n![image](https://assets.leetcode.com/users/images/c3f49c2e-359d-4f23-a4d7-b02f56b87cff_1646015136.1616788.png)\\n![image](https://assets.leetcode.com/users/images/170ea0b6-91ee-4b2e-8ad8-dfac1374944c_1646015141.054478.png)\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "Tim_Guan",
                        "content": "Dislike for confusing test case [2; -1]"
                    },
                    {
                        "username": "mayankagarwal2402",
                        "content": "it not confusing, it's incorrect. \nHave submitted a feedback for the same, others should too, to get it highlighted and rectified. "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 28.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/summary-ranges/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 0 approach in the official solution</summary>\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "mindstrong",
                        "content": "I can not understand what does this question is. the example show's none principles to summarize the ranges. why [0,1,2,4,5,7] should be summarized to [\"0->2\", \"4->5\", \"7\"], why not [\"0-1\", \"2->5\", \"7\"?\\n\\nwho can explain this question more clearly ? thank you in advance."
                    },
                    {
                        "username": "emma-vuksich",
                        "content": "The ranges have to be consecutive numbers (one after the other, in order). Within [0,1,2,4,5,7], 0->2 is a range because the numbers 0, 1, 2 are consecutive. 4->5 is a range because the numbers 4 and 5 are consecutive."
                    },
                    {
                        "username": "sardarsj",
                        "content": "In this problem, the range means we have to give a range in which it should contain all the numbers consecutively. [\"0 - 7\"] is not a range because as per the question the range should contain 0,1,,2,3,4,5,6,7 but in the \\'nums\\' array after 0,1,2 . 4 comes which will not be considered as in the range of [0,7] for that after 2 , 3 has to be present thatswhy [\"0,7\\'] range is not possible"
                    },
                    {
                        "username": "firuz97",
                        "content": "Hi there!\\nFor me as one who is not a native speaker to figure out the task was confusing. I think over the examples and found this.\\nit makes a range until it mets skip number in array.\\nFor example.\\n[0,2,3] -> [\"0\", \"2->3\"]\\n[0,1,3] -> [\"0->1\", \"3\"]\\nI hope my comment will help someone."
                    },
                    {
                        "username": "LuciferYSD",
                        "content": "if you do it 2->5 3 is not present\\n"
                    }
                ]
            },
            {
                "id": 1566053,
                "content": [
                    {
                        "username": "yuanshuo",
                        "content": "I don't really understand what this question is asking. It says return the summary of its ranges but the what does this mean?"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "[@bjlslopez](/bjlslopez) dude own\\'s leetcode ! what a clear cut explanation"
                    },
                    {
                        "username": "The_ThunderBolt",
                        "content": "[@bjlslopez](/bjlslopez)  it helps, Thanks man!"
                    },
                    {
                        "username": "charanarc3",
                        "content": "[@bjlslopez](/bjlslopez) it helps thanks\\n"
                    },
                    {
                        "username": "Ilkhomjon",
                        "content": "[@bjlslopez](/bjlslopez) Thank you man, your explanation is really concise!"
                    },
                    {
                        "username": "bjlslopez",
                        "content": "It is asking for you to summarize continuous numbers into a range. For example, 0, 1 should be converted to 0->1. A more useful application would be 2,3,4,5,6,7,8,9,10 can be summarized to 2->10.\\nHowever, if you have 0,2, there is a gap in the range, so you should return \"0\", \"2\".\\nExample: 0, 2, 3, 4, 5, 6, 7, 8, 10, 20, 25, 26, 27\\nTurns to: 0, 2->8, 10, 20, 25->27\\nYou can think of it in terms of how pages are referenced in bibliographies. Example: Python for Dummies. Pages: 1-4, 10 means pages 1 to 4 and page 10."
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Image Explanation\\n```\\nInput: nums = [0,2,3,4,6,8,9]\\n```\\n![image.png](https://assets.leetcode.com/users/images/5ede8d3f-665d-4d88-a628-de73a0986db9_1686559423.6645904.png)\\nThe problem asks us to \"group\" the elements of array into ranges that are continuous. That is, in one range their should not be any number absent in array. And we need to minimize the different ranges we use, so try to take as big range as possible. At each element, make a different range only when you find some number absent in between current and last element, otherwise expand the current range by $1$.\\n```\\nOutput: [\"0\",\"2->4\",\"6\",\"8->9\"]\\n```"
                    },
                    {
                        "username": "Musfik41",
                        "content": "[@mmtemel](/mmtemel) leetcode should hire you for this awesome visual explanation\\uD83D\\uDE05. 100% satisfied."
                    },
                    {
                        "username": "mmtemel",
                        "content": "your explanation should be the problem explanation"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is an easy question. But test this test case before submitting, especially for the  C/C++ programmer!\\n```\\n[-2147483648,-2147483647,2147483647]\\n```"
                    },
                    {
                        "username": "dfisheritp",
                        "content": "the array is sorted. `[INT_MIN, INT_MAX]` has a solution. `nums[i] + 1 == nums[i + 1]`\\n\\nLEFT SIDE : -2147483648 -> -2147483647\\nRIGHT SIDE : 2147483647 -> -2147483648\\n\\nIt fails the test.\\n\\nYou need a guard clause for the \"->\" anyway. And the compiler will cache that because it see\\'s that it\\'s needed immediately after. Like come on."
                    },
                    {
                        "username": "Rifat121",
                        "content": "how to solve this overflow issue!\\n"
                    },
                    {
                        "username": "geekyshark",
                        "content": "[@jasonpyau](/jasonpyau) same here lol, i checked for [\"0\"] but forgot to check for empty array\\n"
                    },
                    {
                        "username": "autf",
                        "content": "Me too (Rust)\\nOne of a million ways to fail a binary search."
                    },
                    {
                        "username": "daring-calf",
                        "content": "This got me too! (golang)"
                    },
                    {
                        "username": "redocmi7",
                        "content": "Yeah, me too! Got confused untill I viewed the testcase where it failed.\\n\\nMoral of the lesson: Always check for integer overflows!"
                    },
                    {
                        "username": "jasonpyau",
                        "content": "Wasted 2 submissions cuz of integer overflow and empty array!! :["
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "me: Who passed in single go without any error or WA \\uD83D\\uDE0E"
                    },
                    {
                        "username": "antoxakartoxa",
                        "content": "In the task description there is \"nums is sorted in ascending order\". But one of testcases checked after submission is [2, -1] which is descending order. "
                    },
                    {
                        "username": "daregula",
                        "content": "dude I just ran into the same thing lol I had to use abs() when checking for the difference to bypass this invalid test case"
                    },
                    {
                        "username": "baryonix",
                        "content": "I have the same issue, this prevents me from completing the 150-question Study Plan :(.\\nThe thing is I solved this question before this new constraint/test case was added"
                    },
                    {
                        "username": "kokolen77",
                        "content": "I wrote about this on github, but seems like they dont see an error here https://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/16112"
                    },
                    {
                        "username": "batman12345",
                        "content": "![image](https://assets.leetcode.com/users/jasinghe/image_1541988925.png)\\n\\nAll submissions are the exact same. A couple ms makes a huge difference in how fast your submission is judged so resubmit a couple times to be sure your solution isn\\'t actually slow :) \\n\\n32ms = you beat 100%\\n52ms = you beat 10% \\n\\nlol"
                    },
                    {
                        "username": "andreasfesshahagglund",
                        "content": "Yeah man. I went from beating 5 % to beating 92 % of all submissions with the same lines of code. =/"
                    },
                    {
                        "username": "District_12",
                        "content": "Why not [\"0-7\"] as a result? What do you need? Problem description is so bad."
                    },
                    {
                        "username": "rishavranjan1821",
                        "content": "the range means you have to give a range in which it should contain all the numbers that comes between these numbers. See [\"0 - 7\"] is not a range because as per the question the range should contain 0,1,,2,3,4,5,6,7 but in the nums array after 0,1,2 . 4 comes which will not be considered as in the range of [0,7] for that after 2 , 3 has to be present thats why [\"0,7\\'] range is not possible\\n"
                    },
                    {
                        "username": "sandyy",
                        "content": "The numbers in the resultant set must be consecutive only. For input [0,1,2,4,5,7] there are only 3 consecutive sets. First is [0,1,2], second is [4,5] and third is [7]. [0,7] can be the answer when input is [0,1,2,3,4,5,6,7]. I agree that the problem statement is not clear enough."
                    },
                    {
                        "username": "mayank17081998",
                        "content": "![image](https://assets.leetcode.com/users/images/308e256b-0272-4010-876a-8b3745b95fed_1646015105.510134.png)\\n![image](https://assets.leetcode.com/users/images/be57f0f2-c7c0-433e-9e1d-d61ba0fc4dcc_1646015113.6479263.png)\\n![image](https://assets.leetcode.com/users/images/e883adbe-45dd-49e6-975b-294d0670c670_1646015121.1118414.png)\\n![image](https://assets.leetcode.com/users/images/1de2db64-268f-4bf9-bcd5-7a511f79f254_1646015129.5048964.png)\\n![image](https://assets.leetcode.com/users/images/c3f49c2e-359d-4f23-a4d7-b02f56b87cff_1646015136.1616788.png)\\n![image](https://assets.leetcode.com/users/images/170ea0b6-91ee-4b2e-8ad8-dfac1374944c_1646015141.054478.png)\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "Tim_Guan",
                        "content": "Dislike for confusing test case [2; -1]"
                    },
                    {
                        "username": "mayankagarwal2402",
                        "content": "it not confusing, it's incorrect. \nHave submitted a feedback for the same, others should too, to get it highlighted and rectified. "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 28.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/summary-ranges/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 0 approach in the official solution</summary>\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "mindstrong",
                        "content": "I can not understand what does this question is. the example show's none principles to summarize the ranges. why [0,1,2,4,5,7] should be summarized to [\"0->2\", \"4->5\", \"7\"], why not [\"0-1\", \"2->5\", \"7\"?\\n\\nwho can explain this question more clearly ? thank you in advance."
                    },
                    {
                        "username": "emma-vuksich",
                        "content": "The ranges have to be consecutive numbers (one after the other, in order). Within [0,1,2,4,5,7], 0->2 is a range because the numbers 0, 1, 2 are consecutive. 4->5 is a range because the numbers 4 and 5 are consecutive."
                    },
                    {
                        "username": "sardarsj",
                        "content": "In this problem, the range means we have to give a range in which it should contain all the numbers consecutively. [\"0 - 7\"] is not a range because as per the question the range should contain 0,1,,2,3,4,5,6,7 but in the \\'nums\\' array after 0,1,2 . 4 comes which will not be considered as in the range of [0,7] for that after 2 , 3 has to be present thatswhy [\"0,7\\'] range is not possible"
                    },
                    {
                        "username": "firuz97",
                        "content": "Hi there!\\nFor me as one who is not a native speaker to figure out the task was confusing. I think over the examples and found this.\\nit makes a range until it mets skip number in array.\\nFor example.\\n[0,2,3] -> [\"0\", \"2->3\"]\\n[0,1,3] -> [\"0->1\", \"3\"]\\nI hope my comment will help someone."
                    },
                    {
                        "username": "LuciferYSD",
                        "content": "if you do it 2->5 3 is not present\\n"
                    }
                ]
            },
            {
                "id": 1571461,
                "content": [
                    {
                        "username": "yuanshuo",
                        "content": "I don't really understand what this question is asking. It says return the summary of its ranges but the what does this mean?"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "[@bjlslopez](/bjlslopez) dude own\\'s leetcode ! what a clear cut explanation"
                    },
                    {
                        "username": "The_ThunderBolt",
                        "content": "[@bjlslopez](/bjlslopez)  it helps, Thanks man!"
                    },
                    {
                        "username": "charanarc3",
                        "content": "[@bjlslopez](/bjlslopez) it helps thanks\\n"
                    },
                    {
                        "username": "Ilkhomjon",
                        "content": "[@bjlslopez](/bjlslopez) Thank you man, your explanation is really concise!"
                    },
                    {
                        "username": "bjlslopez",
                        "content": "It is asking for you to summarize continuous numbers into a range. For example, 0, 1 should be converted to 0->1. A more useful application would be 2,3,4,5,6,7,8,9,10 can be summarized to 2->10.\\nHowever, if you have 0,2, there is a gap in the range, so you should return \"0\", \"2\".\\nExample: 0, 2, 3, 4, 5, 6, 7, 8, 10, 20, 25, 26, 27\\nTurns to: 0, 2->8, 10, 20, 25->27\\nYou can think of it in terms of how pages are referenced in bibliographies. Example: Python for Dummies. Pages: 1-4, 10 means pages 1 to 4 and page 10."
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Image Explanation\\n```\\nInput: nums = [0,2,3,4,6,8,9]\\n```\\n![image.png](https://assets.leetcode.com/users/images/5ede8d3f-665d-4d88-a628-de73a0986db9_1686559423.6645904.png)\\nThe problem asks us to \"group\" the elements of array into ranges that are continuous. That is, in one range their should not be any number absent in array. And we need to minimize the different ranges we use, so try to take as big range as possible. At each element, make a different range only when you find some number absent in between current and last element, otherwise expand the current range by $1$.\\n```\\nOutput: [\"0\",\"2->4\",\"6\",\"8->9\"]\\n```"
                    },
                    {
                        "username": "Musfik41",
                        "content": "[@mmtemel](/mmtemel) leetcode should hire you for this awesome visual explanation\\uD83D\\uDE05. 100% satisfied."
                    },
                    {
                        "username": "mmtemel",
                        "content": "your explanation should be the problem explanation"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is an easy question. But test this test case before submitting, especially for the  C/C++ programmer!\\n```\\n[-2147483648,-2147483647,2147483647]\\n```"
                    },
                    {
                        "username": "dfisheritp",
                        "content": "the array is sorted. `[INT_MIN, INT_MAX]` has a solution. `nums[i] + 1 == nums[i + 1]`\\n\\nLEFT SIDE : -2147483648 -> -2147483647\\nRIGHT SIDE : 2147483647 -> -2147483648\\n\\nIt fails the test.\\n\\nYou need a guard clause for the \"->\" anyway. And the compiler will cache that because it see\\'s that it\\'s needed immediately after. Like come on."
                    },
                    {
                        "username": "Rifat121",
                        "content": "how to solve this overflow issue!\\n"
                    },
                    {
                        "username": "geekyshark",
                        "content": "[@jasonpyau](/jasonpyau) same here lol, i checked for [\"0\"] but forgot to check for empty array\\n"
                    },
                    {
                        "username": "autf",
                        "content": "Me too (Rust)\\nOne of a million ways to fail a binary search."
                    },
                    {
                        "username": "daring-calf",
                        "content": "This got me too! (golang)"
                    },
                    {
                        "username": "redocmi7",
                        "content": "Yeah, me too! Got confused untill I viewed the testcase where it failed.\\n\\nMoral of the lesson: Always check for integer overflows!"
                    },
                    {
                        "username": "jasonpyau",
                        "content": "Wasted 2 submissions cuz of integer overflow and empty array!! :["
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "me: Who passed in single go without any error or WA \\uD83D\\uDE0E"
                    },
                    {
                        "username": "antoxakartoxa",
                        "content": "In the task description there is \"nums is sorted in ascending order\". But one of testcases checked after submission is [2, -1] which is descending order. "
                    },
                    {
                        "username": "daregula",
                        "content": "dude I just ran into the same thing lol I had to use abs() when checking for the difference to bypass this invalid test case"
                    },
                    {
                        "username": "baryonix",
                        "content": "I have the same issue, this prevents me from completing the 150-question Study Plan :(.\\nThe thing is I solved this question before this new constraint/test case was added"
                    },
                    {
                        "username": "kokolen77",
                        "content": "I wrote about this on github, but seems like they dont see an error here https://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/16112"
                    },
                    {
                        "username": "batman12345",
                        "content": "![image](https://assets.leetcode.com/users/jasinghe/image_1541988925.png)\\n\\nAll submissions are the exact same. A couple ms makes a huge difference in how fast your submission is judged so resubmit a couple times to be sure your solution isn\\'t actually slow :) \\n\\n32ms = you beat 100%\\n52ms = you beat 10% \\n\\nlol"
                    },
                    {
                        "username": "andreasfesshahagglund",
                        "content": "Yeah man. I went from beating 5 % to beating 92 % of all submissions with the same lines of code. =/"
                    },
                    {
                        "username": "District_12",
                        "content": "Why not [\"0-7\"] as a result? What do you need? Problem description is so bad."
                    },
                    {
                        "username": "rishavranjan1821",
                        "content": "the range means you have to give a range in which it should contain all the numbers that comes between these numbers. See [\"0 - 7\"] is not a range because as per the question the range should contain 0,1,,2,3,4,5,6,7 but in the nums array after 0,1,2 . 4 comes which will not be considered as in the range of [0,7] for that after 2 , 3 has to be present thats why [\"0,7\\'] range is not possible\\n"
                    },
                    {
                        "username": "sandyy",
                        "content": "The numbers in the resultant set must be consecutive only. For input [0,1,2,4,5,7] there are only 3 consecutive sets. First is [0,1,2], second is [4,5] and third is [7]. [0,7] can be the answer when input is [0,1,2,3,4,5,6,7]. I agree that the problem statement is not clear enough."
                    },
                    {
                        "username": "mayank17081998",
                        "content": "![image](https://assets.leetcode.com/users/images/308e256b-0272-4010-876a-8b3745b95fed_1646015105.510134.png)\\n![image](https://assets.leetcode.com/users/images/be57f0f2-c7c0-433e-9e1d-d61ba0fc4dcc_1646015113.6479263.png)\\n![image](https://assets.leetcode.com/users/images/e883adbe-45dd-49e6-975b-294d0670c670_1646015121.1118414.png)\\n![image](https://assets.leetcode.com/users/images/1de2db64-268f-4bf9-bcd5-7a511f79f254_1646015129.5048964.png)\\n![image](https://assets.leetcode.com/users/images/c3f49c2e-359d-4f23-a4d7-b02f56b87cff_1646015136.1616788.png)\\n![image](https://assets.leetcode.com/users/images/170ea0b6-91ee-4b2e-8ad8-dfac1374944c_1646015141.054478.png)\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "Tim_Guan",
                        "content": "Dislike for confusing test case [2; -1]"
                    },
                    {
                        "username": "mayankagarwal2402",
                        "content": "it not confusing, it's incorrect. \nHave submitted a feedback for the same, others should too, to get it highlighted and rectified. "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 28.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/summary-ranges/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 0 approach in the official solution</summary>\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "mindstrong",
                        "content": "I can not understand what does this question is. the example show's none principles to summarize the ranges. why [0,1,2,4,5,7] should be summarized to [\"0->2\", \"4->5\", \"7\"], why not [\"0-1\", \"2->5\", \"7\"?\\n\\nwho can explain this question more clearly ? thank you in advance."
                    },
                    {
                        "username": "emma-vuksich",
                        "content": "The ranges have to be consecutive numbers (one after the other, in order). Within [0,1,2,4,5,7], 0->2 is a range because the numbers 0, 1, 2 are consecutive. 4->5 is a range because the numbers 4 and 5 are consecutive."
                    },
                    {
                        "username": "sardarsj",
                        "content": "In this problem, the range means we have to give a range in which it should contain all the numbers consecutively. [\"0 - 7\"] is not a range because as per the question the range should contain 0,1,,2,3,4,5,6,7 but in the \\'nums\\' array after 0,1,2 . 4 comes which will not be considered as in the range of [0,7] for that after 2 , 3 has to be present thatswhy [\"0,7\\'] range is not possible"
                    },
                    {
                        "username": "firuz97",
                        "content": "Hi there!\\nFor me as one who is not a native speaker to figure out the task was confusing. I think over the examples and found this.\\nit makes a range until it mets skip number in array.\\nFor example.\\n[0,2,3] -> [\"0\", \"2->3\"]\\n[0,1,3] -> [\"0->1\", \"3\"]\\nI hope my comment will help someone."
                    },
                    {
                        "username": "LuciferYSD",
                        "content": "if you do it 2->5 3 is not present\\n"
                    }
                ]
            },
            {
                "id": 1565117,
                "content": [
                    {
                        "username": "yuanshuo",
                        "content": "I don't really understand what this question is asking. It says return the summary of its ranges but the what does this mean?"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "[@bjlslopez](/bjlslopez) dude own\\'s leetcode ! what a clear cut explanation"
                    },
                    {
                        "username": "The_ThunderBolt",
                        "content": "[@bjlslopez](/bjlslopez)  it helps, Thanks man!"
                    },
                    {
                        "username": "charanarc3",
                        "content": "[@bjlslopez](/bjlslopez) it helps thanks\\n"
                    },
                    {
                        "username": "Ilkhomjon",
                        "content": "[@bjlslopez](/bjlslopez) Thank you man, your explanation is really concise!"
                    },
                    {
                        "username": "bjlslopez",
                        "content": "It is asking for you to summarize continuous numbers into a range. For example, 0, 1 should be converted to 0->1. A more useful application would be 2,3,4,5,6,7,8,9,10 can be summarized to 2->10.\\nHowever, if you have 0,2, there is a gap in the range, so you should return \"0\", \"2\".\\nExample: 0, 2, 3, 4, 5, 6, 7, 8, 10, 20, 25, 26, 27\\nTurns to: 0, 2->8, 10, 20, 25->27\\nYou can think of it in terms of how pages are referenced in bibliographies. Example: Python for Dummies. Pages: 1-4, 10 means pages 1 to 4 and page 10."
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Image Explanation\\n```\\nInput: nums = [0,2,3,4,6,8,9]\\n```\\n![image.png](https://assets.leetcode.com/users/images/5ede8d3f-665d-4d88-a628-de73a0986db9_1686559423.6645904.png)\\nThe problem asks us to \"group\" the elements of array into ranges that are continuous. That is, in one range their should not be any number absent in array. And we need to minimize the different ranges we use, so try to take as big range as possible. At each element, make a different range only when you find some number absent in between current and last element, otherwise expand the current range by $1$.\\n```\\nOutput: [\"0\",\"2->4\",\"6\",\"8->9\"]\\n```"
                    },
                    {
                        "username": "Musfik41",
                        "content": "[@mmtemel](/mmtemel) leetcode should hire you for this awesome visual explanation\\uD83D\\uDE05. 100% satisfied."
                    },
                    {
                        "username": "mmtemel",
                        "content": "your explanation should be the problem explanation"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is an easy question. But test this test case before submitting, especially for the  C/C++ programmer!\\n```\\n[-2147483648,-2147483647,2147483647]\\n```"
                    },
                    {
                        "username": "dfisheritp",
                        "content": "the array is sorted. `[INT_MIN, INT_MAX]` has a solution. `nums[i] + 1 == nums[i + 1]`\\n\\nLEFT SIDE : -2147483648 -> -2147483647\\nRIGHT SIDE : 2147483647 -> -2147483648\\n\\nIt fails the test.\\n\\nYou need a guard clause for the \"->\" anyway. And the compiler will cache that because it see\\'s that it\\'s needed immediately after. Like come on."
                    },
                    {
                        "username": "Rifat121",
                        "content": "how to solve this overflow issue!\\n"
                    },
                    {
                        "username": "geekyshark",
                        "content": "[@jasonpyau](/jasonpyau) same here lol, i checked for [\"0\"] but forgot to check for empty array\\n"
                    },
                    {
                        "username": "autf",
                        "content": "Me too (Rust)\\nOne of a million ways to fail a binary search."
                    },
                    {
                        "username": "daring-calf",
                        "content": "This got me too! (golang)"
                    },
                    {
                        "username": "redocmi7",
                        "content": "Yeah, me too! Got confused untill I viewed the testcase where it failed.\\n\\nMoral of the lesson: Always check for integer overflows!"
                    },
                    {
                        "username": "jasonpyau",
                        "content": "Wasted 2 submissions cuz of integer overflow and empty array!! :["
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "me: Who passed in single go without any error or WA \\uD83D\\uDE0E"
                    },
                    {
                        "username": "antoxakartoxa",
                        "content": "In the task description there is \"nums is sorted in ascending order\". But one of testcases checked after submission is [2, -1] which is descending order. "
                    },
                    {
                        "username": "daregula",
                        "content": "dude I just ran into the same thing lol I had to use abs() when checking for the difference to bypass this invalid test case"
                    },
                    {
                        "username": "baryonix",
                        "content": "I have the same issue, this prevents me from completing the 150-question Study Plan :(.\\nThe thing is I solved this question before this new constraint/test case was added"
                    },
                    {
                        "username": "kokolen77",
                        "content": "I wrote about this on github, but seems like they dont see an error here https://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/16112"
                    },
                    {
                        "username": "batman12345",
                        "content": "![image](https://assets.leetcode.com/users/jasinghe/image_1541988925.png)\\n\\nAll submissions are the exact same. A couple ms makes a huge difference in how fast your submission is judged so resubmit a couple times to be sure your solution isn\\'t actually slow :) \\n\\n32ms = you beat 100%\\n52ms = you beat 10% \\n\\nlol"
                    },
                    {
                        "username": "andreasfesshahagglund",
                        "content": "Yeah man. I went from beating 5 % to beating 92 % of all submissions with the same lines of code. =/"
                    },
                    {
                        "username": "District_12",
                        "content": "Why not [\"0-7\"] as a result? What do you need? Problem description is so bad."
                    },
                    {
                        "username": "rishavranjan1821",
                        "content": "the range means you have to give a range in which it should contain all the numbers that comes between these numbers. See [\"0 - 7\"] is not a range because as per the question the range should contain 0,1,,2,3,4,5,6,7 but in the nums array after 0,1,2 . 4 comes which will not be considered as in the range of [0,7] for that after 2 , 3 has to be present thats why [\"0,7\\'] range is not possible\\n"
                    },
                    {
                        "username": "sandyy",
                        "content": "The numbers in the resultant set must be consecutive only. For input [0,1,2,4,5,7] there are only 3 consecutive sets. First is [0,1,2], second is [4,5] and third is [7]. [0,7] can be the answer when input is [0,1,2,3,4,5,6,7]. I agree that the problem statement is not clear enough."
                    },
                    {
                        "username": "mayank17081998",
                        "content": "![image](https://assets.leetcode.com/users/images/308e256b-0272-4010-876a-8b3745b95fed_1646015105.510134.png)\\n![image](https://assets.leetcode.com/users/images/be57f0f2-c7c0-433e-9e1d-d61ba0fc4dcc_1646015113.6479263.png)\\n![image](https://assets.leetcode.com/users/images/e883adbe-45dd-49e6-975b-294d0670c670_1646015121.1118414.png)\\n![image](https://assets.leetcode.com/users/images/1de2db64-268f-4bf9-bcd5-7a511f79f254_1646015129.5048964.png)\\n![image](https://assets.leetcode.com/users/images/c3f49c2e-359d-4f23-a4d7-b02f56b87cff_1646015136.1616788.png)\\n![image](https://assets.leetcode.com/users/images/170ea0b6-91ee-4b2e-8ad8-dfac1374944c_1646015141.054478.png)\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "Tim_Guan",
                        "content": "Dislike for confusing test case [2; -1]"
                    },
                    {
                        "username": "mayankagarwal2402",
                        "content": "it not confusing, it's incorrect. \nHave submitted a feedback for the same, others should too, to get it highlighted and rectified. "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 28.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/summary-ranges/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 0 approach in the official solution</summary>\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "mindstrong",
                        "content": "I can not understand what does this question is. the example show's none principles to summarize the ranges. why [0,1,2,4,5,7] should be summarized to [\"0->2\", \"4->5\", \"7\"], why not [\"0-1\", \"2->5\", \"7\"?\\n\\nwho can explain this question more clearly ? thank you in advance."
                    },
                    {
                        "username": "emma-vuksich",
                        "content": "The ranges have to be consecutive numbers (one after the other, in order). Within [0,1,2,4,5,7], 0->2 is a range because the numbers 0, 1, 2 are consecutive. 4->5 is a range because the numbers 4 and 5 are consecutive."
                    },
                    {
                        "username": "sardarsj",
                        "content": "In this problem, the range means we have to give a range in which it should contain all the numbers consecutively. [\"0 - 7\"] is not a range because as per the question the range should contain 0,1,,2,3,4,5,6,7 but in the \\'nums\\' array after 0,1,2 . 4 comes which will not be considered as in the range of [0,7] for that after 2 , 3 has to be present thatswhy [\"0,7\\'] range is not possible"
                    },
                    {
                        "username": "firuz97",
                        "content": "Hi there!\\nFor me as one who is not a native speaker to figure out the task was confusing. I think over the examples and found this.\\nit makes a range until it mets skip number in array.\\nFor example.\\n[0,2,3] -> [\"0\", \"2->3\"]\\n[0,1,3] -> [\"0->1\", \"3\"]\\nI hope my comment will help someone."
                    },
                    {
                        "username": "LuciferYSD",
                        "content": "if you do it 2->5 3 is not present\\n"
                    }
                ]
            },
            {
                "id": 1926534,
                "content": [
                    {
                        "username": "yuanshuo",
                        "content": "I don't really understand what this question is asking. It says return the summary of its ranges but the what does this mean?"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "[@bjlslopez](/bjlslopez) dude own\\'s leetcode ! what a clear cut explanation"
                    },
                    {
                        "username": "The_ThunderBolt",
                        "content": "[@bjlslopez](/bjlslopez)  it helps, Thanks man!"
                    },
                    {
                        "username": "charanarc3",
                        "content": "[@bjlslopez](/bjlslopez) it helps thanks\\n"
                    },
                    {
                        "username": "Ilkhomjon",
                        "content": "[@bjlslopez](/bjlslopez) Thank you man, your explanation is really concise!"
                    },
                    {
                        "username": "bjlslopez",
                        "content": "It is asking for you to summarize continuous numbers into a range. For example, 0, 1 should be converted to 0->1. A more useful application would be 2,3,4,5,6,7,8,9,10 can be summarized to 2->10.\\nHowever, if you have 0,2, there is a gap in the range, so you should return \"0\", \"2\".\\nExample: 0, 2, 3, 4, 5, 6, 7, 8, 10, 20, 25, 26, 27\\nTurns to: 0, 2->8, 10, 20, 25->27\\nYou can think of it in terms of how pages are referenced in bibliographies. Example: Python for Dummies. Pages: 1-4, 10 means pages 1 to 4 and page 10."
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Image Explanation\\n```\\nInput: nums = [0,2,3,4,6,8,9]\\n```\\n![image.png](https://assets.leetcode.com/users/images/5ede8d3f-665d-4d88-a628-de73a0986db9_1686559423.6645904.png)\\nThe problem asks us to \"group\" the elements of array into ranges that are continuous. That is, in one range their should not be any number absent in array. And we need to minimize the different ranges we use, so try to take as big range as possible. At each element, make a different range only when you find some number absent in between current and last element, otherwise expand the current range by $1$.\\n```\\nOutput: [\"0\",\"2->4\",\"6\",\"8->9\"]\\n```"
                    },
                    {
                        "username": "Musfik41",
                        "content": "[@mmtemel](/mmtemel) leetcode should hire you for this awesome visual explanation\\uD83D\\uDE05. 100% satisfied."
                    },
                    {
                        "username": "mmtemel",
                        "content": "your explanation should be the problem explanation"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is an easy question. But test this test case before submitting, especially for the  C/C++ programmer!\\n```\\n[-2147483648,-2147483647,2147483647]\\n```"
                    },
                    {
                        "username": "dfisheritp",
                        "content": "the array is sorted. `[INT_MIN, INT_MAX]` has a solution. `nums[i] + 1 == nums[i + 1]`\\n\\nLEFT SIDE : -2147483648 -> -2147483647\\nRIGHT SIDE : 2147483647 -> -2147483648\\n\\nIt fails the test.\\n\\nYou need a guard clause for the \"->\" anyway. And the compiler will cache that because it see\\'s that it\\'s needed immediately after. Like come on."
                    },
                    {
                        "username": "Rifat121",
                        "content": "how to solve this overflow issue!\\n"
                    },
                    {
                        "username": "geekyshark",
                        "content": "[@jasonpyau](/jasonpyau) same here lol, i checked for [\"0\"] but forgot to check for empty array\\n"
                    },
                    {
                        "username": "autf",
                        "content": "Me too (Rust)\\nOne of a million ways to fail a binary search."
                    },
                    {
                        "username": "daring-calf",
                        "content": "This got me too! (golang)"
                    },
                    {
                        "username": "redocmi7",
                        "content": "Yeah, me too! Got confused untill I viewed the testcase where it failed.\\n\\nMoral of the lesson: Always check for integer overflows!"
                    },
                    {
                        "username": "jasonpyau",
                        "content": "Wasted 2 submissions cuz of integer overflow and empty array!! :["
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "me: Who passed in single go without any error or WA \\uD83D\\uDE0E"
                    },
                    {
                        "username": "antoxakartoxa",
                        "content": "In the task description there is \"nums is sorted in ascending order\". But one of testcases checked after submission is [2, -1] which is descending order. "
                    },
                    {
                        "username": "daregula",
                        "content": "dude I just ran into the same thing lol I had to use abs() when checking for the difference to bypass this invalid test case"
                    },
                    {
                        "username": "baryonix",
                        "content": "I have the same issue, this prevents me from completing the 150-question Study Plan :(.\\nThe thing is I solved this question before this new constraint/test case was added"
                    },
                    {
                        "username": "kokolen77",
                        "content": "I wrote about this on github, but seems like they dont see an error here https://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/16112"
                    },
                    {
                        "username": "batman12345",
                        "content": "![image](https://assets.leetcode.com/users/jasinghe/image_1541988925.png)\\n\\nAll submissions are the exact same. A couple ms makes a huge difference in how fast your submission is judged so resubmit a couple times to be sure your solution isn\\'t actually slow :) \\n\\n32ms = you beat 100%\\n52ms = you beat 10% \\n\\nlol"
                    },
                    {
                        "username": "andreasfesshahagglund",
                        "content": "Yeah man. I went from beating 5 % to beating 92 % of all submissions with the same lines of code. =/"
                    },
                    {
                        "username": "District_12",
                        "content": "Why not [\"0-7\"] as a result? What do you need? Problem description is so bad."
                    },
                    {
                        "username": "rishavranjan1821",
                        "content": "the range means you have to give a range in which it should contain all the numbers that comes between these numbers. See [\"0 - 7\"] is not a range because as per the question the range should contain 0,1,,2,3,4,5,6,7 but in the nums array after 0,1,2 . 4 comes which will not be considered as in the range of [0,7] for that after 2 , 3 has to be present thats why [\"0,7\\'] range is not possible\\n"
                    },
                    {
                        "username": "sandyy",
                        "content": "The numbers in the resultant set must be consecutive only. For input [0,1,2,4,5,7] there are only 3 consecutive sets. First is [0,1,2], second is [4,5] and third is [7]. [0,7] can be the answer when input is [0,1,2,3,4,5,6,7]. I agree that the problem statement is not clear enough."
                    },
                    {
                        "username": "mayank17081998",
                        "content": "![image](https://assets.leetcode.com/users/images/308e256b-0272-4010-876a-8b3745b95fed_1646015105.510134.png)\\n![image](https://assets.leetcode.com/users/images/be57f0f2-c7c0-433e-9e1d-d61ba0fc4dcc_1646015113.6479263.png)\\n![image](https://assets.leetcode.com/users/images/e883adbe-45dd-49e6-975b-294d0670c670_1646015121.1118414.png)\\n![image](https://assets.leetcode.com/users/images/1de2db64-268f-4bf9-bcd5-7a511f79f254_1646015129.5048964.png)\\n![image](https://assets.leetcode.com/users/images/c3f49c2e-359d-4f23-a4d7-b02f56b87cff_1646015136.1616788.png)\\n![image](https://assets.leetcode.com/users/images/170ea0b6-91ee-4b2e-8ad8-dfac1374944c_1646015141.054478.png)\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "Tim_Guan",
                        "content": "Dislike for confusing test case [2; -1]"
                    },
                    {
                        "username": "mayankagarwal2402",
                        "content": "it not confusing, it's incorrect. \nHave submitted a feedback for the same, others should too, to get it highlighted and rectified. "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 28.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/summary-ranges/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 0 approach in the official solution</summary>\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "mindstrong",
                        "content": "I can not understand what does this question is. the example show's none principles to summarize the ranges. why [0,1,2,4,5,7] should be summarized to [\"0->2\", \"4->5\", \"7\"], why not [\"0-1\", \"2->5\", \"7\"?\\n\\nwho can explain this question more clearly ? thank you in advance."
                    },
                    {
                        "username": "emma-vuksich",
                        "content": "The ranges have to be consecutive numbers (one after the other, in order). Within [0,1,2,4,5,7], 0->2 is a range because the numbers 0, 1, 2 are consecutive. 4->5 is a range because the numbers 4 and 5 are consecutive."
                    },
                    {
                        "username": "sardarsj",
                        "content": "In this problem, the range means we have to give a range in which it should contain all the numbers consecutively. [\"0 - 7\"] is not a range because as per the question the range should contain 0,1,,2,3,4,5,6,7 but in the \\'nums\\' array after 0,1,2 . 4 comes which will not be considered as in the range of [0,7] for that after 2 , 3 has to be present thatswhy [\"0,7\\'] range is not possible"
                    },
                    {
                        "username": "firuz97",
                        "content": "Hi there!\\nFor me as one who is not a native speaker to figure out the task was confusing. I think over the examples and found this.\\nit makes a range until it mets skip number in array.\\nFor example.\\n[0,2,3] -> [\"0\", \"2->3\"]\\n[0,1,3] -> [\"0->1\", \"3\"]\\nI hope my comment will help someone."
                    },
                    {
                        "username": "LuciferYSD",
                        "content": "if you do it 2->5 3 is not present\\n"
                    }
                ]
            },
            {
                "id": 1926073,
                "content": [
                    {
                        "username": "yuanshuo",
                        "content": "I don't really understand what this question is asking. It says return the summary of its ranges but the what does this mean?"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "[@bjlslopez](/bjlslopez) dude own\\'s leetcode ! what a clear cut explanation"
                    },
                    {
                        "username": "The_ThunderBolt",
                        "content": "[@bjlslopez](/bjlslopez)  it helps, Thanks man!"
                    },
                    {
                        "username": "charanarc3",
                        "content": "[@bjlslopez](/bjlslopez) it helps thanks\\n"
                    },
                    {
                        "username": "Ilkhomjon",
                        "content": "[@bjlslopez](/bjlslopez) Thank you man, your explanation is really concise!"
                    },
                    {
                        "username": "bjlslopez",
                        "content": "It is asking for you to summarize continuous numbers into a range. For example, 0, 1 should be converted to 0->1. A more useful application would be 2,3,4,5,6,7,8,9,10 can be summarized to 2->10.\\nHowever, if you have 0,2, there is a gap in the range, so you should return \"0\", \"2\".\\nExample: 0, 2, 3, 4, 5, 6, 7, 8, 10, 20, 25, 26, 27\\nTurns to: 0, 2->8, 10, 20, 25->27\\nYou can think of it in terms of how pages are referenced in bibliographies. Example: Python for Dummies. Pages: 1-4, 10 means pages 1 to 4 and page 10."
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Image Explanation\\n```\\nInput: nums = [0,2,3,4,6,8,9]\\n```\\n![image.png](https://assets.leetcode.com/users/images/5ede8d3f-665d-4d88-a628-de73a0986db9_1686559423.6645904.png)\\nThe problem asks us to \"group\" the elements of array into ranges that are continuous. That is, in one range their should not be any number absent in array. And we need to minimize the different ranges we use, so try to take as big range as possible. At each element, make a different range only when you find some number absent in between current and last element, otherwise expand the current range by $1$.\\n```\\nOutput: [\"0\",\"2->4\",\"6\",\"8->9\"]\\n```"
                    },
                    {
                        "username": "Musfik41",
                        "content": "[@mmtemel](/mmtemel) leetcode should hire you for this awesome visual explanation\\uD83D\\uDE05. 100% satisfied."
                    },
                    {
                        "username": "mmtemel",
                        "content": "your explanation should be the problem explanation"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is an easy question. But test this test case before submitting, especially for the  C/C++ programmer!\\n```\\n[-2147483648,-2147483647,2147483647]\\n```"
                    },
                    {
                        "username": "dfisheritp",
                        "content": "the array is sorted. `[INT_MIN, INT_MAX]` has a solution. `nums[i] + 1 == nums[i + 1]`\\n\\nLEFT SIDE : -2147483648 -> -2147483647\\nRIGHT SIDE : 2147483647 -> -2147483648\\n\\nIt fails the test.\\n\\nYou need a guard clause for the \"->\" anyway. And the compiler will cache that because it see\\'s that it\\'s needed immediately after. Like come on."
                    },
                    {
                        "username": "Rifat121",
                        "content": "how to solve this overflow issue!\\n"
                    },
                    {
                        "username": "geekyshark",
                        "content": "[@jasonpyau](/jasonpyau) same here lol, i checked for [\"0\"] but forgot to check for empty array\\n"
                    },
                    {
                        "username": "autf",
                        "content": "Me too (Rust)\\nOne of a million ways to fail a binary search."
                    },
                    {
                        "username": "daring-calf",
                        "content": "This got me too! (golang)"
                    },
                    {
                        "username": "redocmi7",
                        "content": "Yeah, me too! Got confused untill I viewed the testcase where it failed.\\n\\nMoral of the lesson: Always check for integer overflows!"
                    },
                    {
                        "username": "jasonpyau",
                        "content": "Wasted 2 submissions cuz of integer overflow and empty array!! :["
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "me: Who passed in single go without any error or WA \\uD83D\\uDE0E"
                    },
                    {
                        "username": "antoxakartoxa",
                        "content": "In the task description there is \"nums is sorted in ascending order\". But one of testcases checked after submission is [2, -1] which is descending order. "
                    },
                    {
                        "username": "daregula",
                        "content": "dude I just ran into the same thing lol I had to use abs() when checking for the difference to bypass this invalid test case"
                    },
                    {
                        "username": "baryonix",
                        "content": "I have the same issue, this prevents me from completing the 150-question Study Plan :(.\\nThe thing is I solved this question before this new constraint/test case was added"
                    },
                    {
                        "username": "kokolen77",
                        "content": "I wrote about this on github, but seems like they dont see an error here https://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/16112"
                    },
                    {
                        "username": "batman12345",
                        "content": "![image](https://assets.leetcode.com/users/jasinghe/image_1541988925.png)\\n\\nAll submissions are the exact same. A couple ms makes a huge difference in how fast your submission is judged so resubmit a couple times to be sure your solution isn\\'t actually slow :) \\n\\n32ms = you beat 100%\\n52ms = you beat 10% \\n\\nlol"
                    },
                    {
                        "username": "andreasfesshahagglund",
                        "content": "Yeah man. I went from beating 5 % to beating 92 % of all submissions with the same lines of code. =/"
                    },
                    {
                        "username": "District_12",
                        "content": "Why not [\"0-7\"] as a result? What do you need? Problem description is so bad."
                    },
                    {
                        "username": "rishavranjan1821",
                        "content": "the range means you have to give a range in which it should contain all the numbers that comes between these numbers. See [\"0 - 7\"] is not a range because as per the question the range should contain 0,1,,2,3,4,5,6,7 but in the nums array after 0,1,2 . 4 comes which will not be considered as in the range of [0,7] for that after 2 , 3 has to be present thats why [\"0,7\\'] range is not possible\\n"
                    },
                    {
                        "username": "sandyy",
                        "content": "The numbers in the resultant set must be consecutive only. For input [0,1,2,4,5,7] there are only 3 consecutive sets. First is [0,1,2], second is [4,5] and third is [7]. [0,7] can be the answer when input is [0,1,2,3,4,5,6,7]. I agree that the problem statement is not clear enough."
                    },
                    {
                        "username": "mayank17081998",
                        "content": "![image](https://assets.leetcode.com/users/images/308e256b-0272-4010-876a-8b3745b95fed_1646015105.510134.png)\\n![image](https://assets.leetcode.com/users/images/be57f0f2-c7c0-433e-9e1d-d61ba0fc4dcc_1646015113.6479263.png)\\n![image](https://assets.leetcode.com/users/images/e883adbe-45dd-49e6-975b-294d0670c670_1646015121.1118414.png)\\n![image](https://assets.leetcode.com/users/images/1de2db64-268f-4bf9-bcd5-7a511f79f254_1646015129.5048964.png)\\n![image](https://assets.leetcode.com/users/images/c3f49c2e-359d-4f23-a4d7-b02f56b87cff_1646015136.1616788.png)\\n![image](https://assets.leetcode.com/users/images/170ea0b6-91ee-4b2e-8ad8-dfac1374944c_1646015141.054478.png)\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "Tim_Guan",
                        "content": "Dislike for confusing test case [2; -1]"
                    },
                    {
                        "username": "mayankagarwal2402",
                        "content": "it not confusing, it's incorrect. \nHave submitted a feedback for the same, others should too, to get it highlighted and rectified. "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 28.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/summary-ranges/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 0 approach in the official solution</summary>\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "mindstrong",
                        "content": "I can not understand what does this question is. the example show's none principles to summarize the ranges. why [0,1,2,4,5,7] should be summarized to [\"0->2\", \"4->5\", \"7\"], why not [\"0-1\", \"2->5\", \"7\"?\\n\\nwho can explain this question more clearly ? thank you in advance."
                    },
                    {
                        "username": "emma-vuksich",
                        "content": "The ranges have to be consecutive numbers (one after the other, in order). Within [0,1,2,4,5,7], 0->2 is a range because the numbers 0, 1, 2 are consecutive. 4->5 is a range because the numbers 4 and 5 are consecutive."
                    },
                    {
                        "username": "sardarsj",
                        "content": "In this problem, the range means we have to give a range in which it should contain all the numbers consecutively. [\"0 - 7\"] is not a range because as per the question the range should contain 0,1,,2,3,4,5,6,7 but in the \\'nums\\' array after 0,1,2 . 4 comes which will not be considered as in the range of [0,7] for that after 2 , 3 has to be present thatswhy [\"0,7\\'] range is not possible"
                    },
                    {
                        "username": "firuz97",
                        "content": "Hi there!\\nFor me as one who is not a native speaker to figure out the task was confusing. I think over the examples and found this.\\nit makes a range until it mets skip number in array.\\nFor example.\\n[0,2,3] -> [\"0\", \"2->3\"]\\n[0,1,3] -> [\"0->1\", \"3\"]\\nI hope my comment will help someone."
                    },
                    {
                        "username": "LuciferYSD",
                        "content": "if you do it 2->5 3 is not present\\n"
                    }
                ]
            },
            {
                "id": 2042711,
                "content": [
                    {
                        "username": "yuanshuo",
                        "content": "I don't really understand what this question is asking. It says return the summary of its ranges but the what does this mean?"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "[@bjlslopez](/bjlslopez) dude own\\'s leetcode ! what a clear cut explanation"
                    },
                    {
                        "username": "The_ThunderBolt",
                        "content": "[@bjlslopez](/bjlslopez)  it helps, Thanks man!"
                    },
                    {
                        "username": "charanarc3",
                        "content": "[@bjlslopez](/bjlslopez) it helps thanks\\n"
                    },
                    {
                        "username": "Ilkhomjon",
                        "content": "[@bjlslopez](/bjlslopez) Thank you man, your explanation is really concise!"
                    },
                    {
                        "username": "bjlslopez",
                        "content": "It is asking for you to summarize continuous numbers into a range. For example, 0, 1 should be converted to 0->1. A more useful application would be 2,3,4,5,6,7,8,9,10 can be summarized to 2->10.\\nHowever, if you have 0,2, there is a gap in the range, so you should return \"0\", \"2\".\\nExample: 0, 2, 3, 4, 5, 6, 7, 8, 10, 20, 25, 26, 27\\nTurns to: 0, 2->8, 10, 20, 25->27\\nYou can think of it in terms of how pages are referenced in bibliographies. Example: Python for Dummies. Pages: 1-4, 10 means pages 1 to 4 and page 10."
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Image Explanation\\n```\\nInput: nums = [0,2,3,4,6,8,9]\\n```\\n![image.png](https://assets.leetcode.com/users/images/5ede8d3f-665d-4d88-a628-de73a0986db9_1686559423.6645904.png)\\nThe problem asks us to \"group\" the elements of array into ranges that are continuous. That is, in one range their should not be any number absent in array. And we need to minimize the different ranges we use, so try to take as big range as possible. At each element, make a different range only when you find some number absent in between current and last element, otherwise expand the current range by $1$.\\n```\\nOutput: [\"0\",\"2->4\",\"6\",\"8->9\"]\\n```"
                    },
                    {
                        "username": "Musfik41",
                        "content": "[@mmtemel](/mmtemel) leetcode should hire you for this awesome visual explanation\\uD83D\\uDE05. 100% satisfied."
                    },
                    {
                        "username": "mmtemel",
                        "content": "your explanation should be the problem explanation"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is an easy question. But test this test case before submitting, especially for the  C/C++ programmer!\\n```\\n[-2147483648,-2147483647,2147483647]\\n```"
                    },
                    {
                        "username": "dfisheritp",
                        "content": "the array is sorted. `[INT_MIN, INT_MAX]` has a solution. `nums[i] + 1 == nums[i + 1]`\\n\\nLEFT SIDE : -2147483648 -> -2147483647\\nRIGHT SIDE : 2147483647 -> -2147483648\\n\\nIt fails the test.\\n\\nYou need a guard clause for the \"->\" anyway. And the compiler will cache that because it see\\'s that it\\'s needed immediately after. Like come on."
                    },
                    {
                        "username": "Rifat121",
                        "content": "how to solve this overflow issue!\\n"
                    },
                    {
                        "username": "geekyshark",
                        "content": "[@jasonpyau](/jasonpyau) same here lol, i checked for [\"0\"] but forgot to check for empty array\\n"
                    },
                    {
                        "username": "autf",
                        "content": "Me too (Rust)\\nOne of a million ways to fail a binary search."
                    },
                    {
                        "username": "daring-calf",
                        "content": "This got me too! (golang)"
                    },
                    {
                        "username": "redocmi7",
                        "content": "Yeah, me too! Got confused untill I viewed the testcase where it failed.\\n\\nMoral of the lesson: Always check for integer overflows!"
                    },
                    {
                        "username": "jasonpyau",
                        "content": "Wasted 2 submissions cuz of integer overflow and empty array!! :["
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "me: Who passed in single go without any error or WA \\uD83D\\uDE0E"
                    },
                    {
                        "username": "antoxakartoxa",
                        "content": "In the task description there is \"nums is sorted in ascending order\". But one of testcases checked after submission is [2, -1] which is descending order. "
                    },
                    {
                        "username": "daregula",
                        "content": "dude I just ran into the same thing lol I had to use abs() when checking for the difference to bypass this invalid test case"
                    },
                    {
                        "username": "baryonix",
                        "content": "I have the same issue, this prevents me from completing the 150-question Study Plan :(.\\nThe thing is I solved this question before this new constraint/test case was added"
                    },
                    {
                        "username": "kokolen77",
                        "content": "I wrote about this on github, but seems like they dont see an error here https://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/16112"
                    },
                    {
                        "username": "batman12345",
                        "content": "![image](https://assets.leetcode.com/users/jasinghe/image_1541988925.png)\\n\\nAll submissions are the exact same. A couple ms makes a huge difference in how fast your submission is judged so resubmit a couple times to be sure your solution isn\\'t actually slow :) \\n\\n32ms = you beat 100%\\n52ms = you beat 10% \\n\\nlol"
                    },
                    {
                        "username": "andreasfesshahagglund",
                        "content": "Yeah man. I went from beating 5 % to beating 92 % of all submissions with the same lines of code. =/"
                    },
                    {
                        "username": "District_12",
                        "content": "Why not [\"0-7\"] as a result? What do you need? Problem description is so bad."
                    },
                    {
                        "username": "rishavranjan1821",
                        "content": "the range means you have to give a range in which it should contain all the numbers that comes between these numbers. See [\"0 - 7\"] is not a range because as per the question the range should contain 0,1,,2,3,4,5,6,7 but in the nums array after 0,1,2 . 4 comes which will not be considered as in the range of [0,7] for that after 2 , 3 has to be present thats why [\"0,7\\'] range is not possible\\n"
                    },
                    {
                        "username": "sandyy",
                        "content": "The numbers in the resultant set must be consecutive only. For input [0,1,2,4,5,7] there are only 3 consecutive sets. First is [0,1,2], second is [4,5] and third is [7]. [0,7] can be the answer when input is [0,1,2,3,4,5,6,7]. I agree that the problem statement is not clear enough."
                    },
                    {
                        "username": "mayank17081998",
                        "content": "![image](https://assets.leetcode.com/users/images/308e256b-0272-4010-876a-8b3745b95fed_1646015105.510134.png)\\n![image](https://assets.leetcode.com/users/images/be57f0f2-c7c0-433e-9e1d-d61ba0fc4dcc_1646015113.6479263.png)\\n![image](https://assets.leetcode.com/users/images/e883adbe-45dd-49e6-975b-294d0670c670_1646015121.1118414.png)\\n![image](https://assets.leetcode.com/users/images/1de2db64-268f-4bf9-bcd5-7a511f79f254_1646015129.5048964.png)\\n![image](https://assets.leetcode.com/users/images/c3f49c2e-359d-4f23-a4d7-b02f56b87cff_1646015136.1616788.png)\\n![image](https://assets.leetcode.com/users/images/170ea0b6-91ee-4b2e-8ad8-dfac1374944c_1646015141.054478.png)\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "Tim_Guan",
                        "content": "Dislike for confusing test case [2; -1]"
                    },
                    {
                        "username": "mayankagarwal2402",
                        "content": "it not confusing, it's incorrect. \nHave submitted a feedback for the same, others should too, to get it highlighted and rectified. "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 28.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/summary-ranges/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 0 approach in the official solution</summary>\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "mindstrong",
                        "content": "I can not understand what does this question is. the example show's none principles to summarize the ranges. why [0,1,2,4,5,7] should be summarized to [\"0->2\", \"4->5\", \"7\"], why not [\"0-1\", \"2->5\", \"7\"?\\n\\nwho can explain this question more clearly ? thank you in advance."
                    },
                    {
                        "username": "emma-vuksich",
                        "content": "The ranges have to be consecutive numbers (one after the other, in order). Within [0,1,2,4,5,7], 0->2 is a range because the numbers 0, 1, 2 are consecutive. 4->5 is a range because the numbers 4 and 5 are consecutive."
                    },
                    {
                        "username": "sardarsj",
                        "content": "In this problem, the range means we have to give a range in which it should contain all the numbers consecutively. [\"0 - 7\"] is not a range because as per the question the range should contain 0,1,,2,3,4,5,6,7 but in the \\'nums\\' array after 0,1,2 . 4 comes which will not be considered as in the range of [0,7] for that after 2 , 3 has to be present thatswhy [\"0,7\\'] range is not possible"
                    },
                    {
                        "username": "firuz97",
                        "content": "Hi there!\\nFor me as one who is not a native speaker to figure out the task was confusing. I think over the examples and found this.\\nit makes a range until it mets skip number in array.\\nFor example.\\n[0,2,3] -> [\"0\", \"2->3\"]\\n[0,1,3] -> [\"0->1\", \"3\"]\\nI hope my comment will help someone."
                    },
                    {
                        "username": "LuciferYSD",
                        "content": "if you do it 2->5 3 is not present\\n"
                    }
                ]
            },
            {
                "id": 1568072,
                "content": [
                    {
                        "username": "yuanshuo",
                        "content": "I don't really understand what this question is asking. It says return the summary of its ranges but the what does this mean?"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "[@bjlslopez](/bjlslopez) dude own\\'s leetcode ! what a clear cut explanation"
                    },
                    {
                        "username": "The_ThunderBolt",
                        "content": "[@bjlslopez](/bjlslopez)  it helps, Thanks man!"
                    },
                    {
                        "username": "charanarc3",
                        "content": "[@bjlslopez](/bjlslopez) it helps thanks\\n"
                    },
                    {
                        "username": "Ilkhomjon",
                        "content": "[@bjlslopez](/bjlslopez) Thank you man, your explanation is really concise!"
                    },
                    {
                        "username": "bjlslopez",
                        "content": "It is asking for you to summarize continuous numbers into a range. For example, 0, 1 should be converted to 0->1. A more useful application would be 2,3,4,5,6,7,8,9,10 can be summarized to 2->10.\\nHowever, if you have 0,2, there is a gap in the range, so you should return \"0\", \"2\".\\nExample: 0, 2, 3, 4, 5, 6, 7, 8, 10, 20, 25, 26, 27\\nTurns to: 0, 2->8, 10, 20, 25->27\\nYou can think of it in terms of how pages are referenced in bibliographies. Example: Python for Dummies. Pages: 1-4, 10 means pages 1 to 4 and page 10."
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Image Explanation\\n```\\nInput: nums = [0,2,3,4,6,8,9]\\n```\\n![image.png](https://assets.leetcode.com/users/images/5ede8d3f-665d-4d88-a628-de73a0986db9_1686559423.6645904.png)\\nThe problem asks us to \"group\" the elements of array into ranges that are continuous. That is, in one range their should not be any number absent in array. And we need to minimize the different ranges we use, so try to take as big range as possible. At each element, make a different range only when you find some number absent in between current and last element, otherwise expand the current range by $1$.\\n```\\nOutput: [\"0\",\"2->4\",\"6\",\"8->9\"]\\n```"
                    },
                    {
                        "username": "Musfik41",
                        "content": "[@mmtemel](/mmtemel) leetcode should hire you for this awesome visual explanation\\uD83D\\uDE05. 100% satisfied."
                    },
                    {
                        "username": "mmtemel",
                        "content": "your explanation should be the problem explanation"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is an easy question. But test this test case before submitting, especially for the  C/C++ programmer!\\n```\\n[-2147483648,-2147483647,2147483647]\\n```"
                    },
                    {
                        "username": "dfisheritp",
                        "content": "the array is sorted. `[INT_MIN, INT_MAX]` has a solution. `nums[i] + 1 == nums[i + 1]`\\n\\nLEFT SIDE : -2147483648 -> -2147483647\\nRIGHT SIDE : 2147483647 -> -2147483648\\n\\nIt fails the test.\\n\\nYou need a guard clause for the \"->\" anyway. And the compiler will cache that because it see\\'s that it\\'s needed immediately after. Like come on."
                    },
                    {
                        "username": "Rifat121",
                        "content": "how to solve this overflow issue!\\n"
                    },
                    {
                        "username": "geekyshark",
                        "content": "[@jasonpyau](/jasonpyau) same here lol, i checked for [\"0\"] but forgot to check for empty array\\n"
                    },
                    {
                        "username": "autf",
                        "content": "Me too (Rust)\\nOne of a million ways to fail a binary search."
                    },
                    {
                        "username": "daring-calf",
                        "content": "This got me too! (golang)"
                    },
                    {
                        "username": "redocmi7",
                        "content": "Yeah, me too! Got confused untill I viewed the testcase where it failed.\\n\\nMoral of the lesson: Always check for integer overflows!"
                    },
                    {
                        "username": "jasonpyau",
                        "content": "Wasted 2 submissions cuz of integer overflow and empty array!! :["
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "me: Who passed in single go without any error or WA \\uD83D\\uDE0E"
                    },
                    {
                        "username": "antoxakartoxa",
                        "content": "In the task description there is \"nums is sorted in ascending order\". But one of testcases checked after submission is [2, -1] which is descending order. "
                    },
                    {
                        "username": "daregula",
                        "content": "dude I just ran into the same thing lol I had to use abs() when checking for the difference to bypass this invalid test case"
                    },
                    {
                        "username": "baryonix",
                        "content": "I have the same issue, this prevents me from completing the 150-question Study Plan :(.\\nThe thing is I solved this question before this new constraint/test case was added"
                    },
                    {
                        "username": "kokolen77",
                        "content": "I wrote about this on github, but seems like they dont see an error here https://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/16112"
                    },
                    {
                        "username": "batman12345",
                        "content": "![image](https://assets.leetcode.com/users/jasinghe/image_1541988925.png)\\n\\nAll submissions are the exact same. A couple ms makes a huge difference in how fast your submission is judged so resubmit a couple times to be sure your solution isn\\'t actually slow :) \\n\\n32ms = you beat 100%\\n52ms = you beat 10% \\n\\nlol"
                    },
                    {
                        "username": "andreasfesshahagglund",
                        "content": "Yeah man. I went from beating 5 % to beating 92 % of all submissions with the same lines of code. =/"
                    },
                    {
                        "username": "District_12",
                        "content": "Why not [\"0-7\"] as a result? What do you need? Problem description is so bad."
                    },
                    {
                        "username": "rishavranjan1821",
                        "content": "the range means you have to give a range in which it should contain all the numbers that comes between these numbers. See [\"0 - 7\"] is not a range because as per the question the range should contain 0,1,,2,3,4,5,6,7 but in the nums array after 0,1,2 . 4 comes which will not be considered as in the range of [0,7] for that after 2 , 3 has to be present thats why [\"0,7\\'] range is not possible\\n"
                    },
                    {
                        "username": "sandyy",
                        "content": "The numbers in the resultant set must be consecutive only. For input [0,1,2,4,5,7] there are only 3 consecutive sets. First is [0,1,2], second is [4,5] and third is [7]. [0,7] can be the answer when input is [0,1,2,3,4,5,6,7]. I agree that the problem statement is not clear enough."
                    },
                    {
                        "username": "mayank17081998",
                        "content": "![image](https://assets.leetcode.com/users/images/308e256b-0272-4010-876a-8b3745b95fed_1646015105.510134.png)\\n![image](https://assets.leetcode.com/users/images/be57f0f2-c7c0-433e-9e1d-d61ba0fc4dcc_1646015113.6479263.png)\\n![image](https://assets.leetcode.com/users/images/e883adbe-45dd-49e6-975b-294d0670c670_1646015121.1118414.png)\\n![image](https://assets.leetcode.com/users/images/1de2db64-268f-4bf9-bcd5-7a511f79f254_1646015129.5048964.png)\\n![image](https://assets.leetcode.com/users/images/c3f49c2e-359d-4f23-a4d7-b02f56b87cff_1646015136.1616788.png)\\n![image](https://assets.leetcode.com/users/images/170ea0b6-91ee-4b2e-8ad8-dfac1374944c_1646015141.054478.png)\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "Tim_Guan",
                        "content": "Dislike for confusing test case [2; -1]"
                    },
                    {
                        "username": "mayankagarwal2402",
                        "content": "it not confusing, it's incorrect. \nHave submitted a feedback for the same, others should too, to get it highlighted and rectified. "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 28.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/summary-ranges/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 0 approach in the official solution</summary>\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "mindstrong",
                        "content": "I can not understand what does this question is. the example show's none principles to summarize the ranges. why [0,1,2,4,5,7] should be summarized to [\"0->2\", \"4->5\", \"7\"], why not [\"0-1\", \"2->5\", \"7\"?\\n\\nwho can explain this question more clearly ? thank you in advance."
                    },
                    {
                        "username": "emma-vuksich",
                        "content": "The ranges have to be consecutive numbers (one after the other, in order). Within [0,1,2,4,5,7], 0->2 is a range because the numbers 0, 1, 2 are consecutive. 4->5 is a range because the numbers 4 and 5 are consecutive."
                    },
                    {
                        "username": "sardarsj",
                        "content": "In this problem, the range means we have to give a range in which it should contain all the numbers consecutively. [\"0 - 7\"] is not a range because as per the question the range should contain 0,1,,2,3,4,5,6,7 but in the \\'nums\\' array after 0,1,2 . 4 comes which will not be considered as in the range of [0,7] for that after 2 , 3 has to be present thatswhy [\"0,7\\'] range is not possible"
                    },
                    {
                        "username": "firuz97",
                        "content": "Hi there!\\nFor me as one who is not a native speaker to figure out the task was confusing. I think over the examples and found this.\\nit makes a range until it mets skip number in array.\\nFor example.\\n[0,2,3] -> [\"0\", \"2->3\"]\\n[0,1,3] -> [\"0->1\", \"3\"]\\nI hope my comment will help someone."
                    },
                    {
                        "username": "LuciferYSD",
                        "content": "if you do it 2->5 3 is not present\\n"
                    }
                ]
            },
            {
                "id": 1731777,
                "content": [
                    {
                        "username": "yuanshuo",
                        "content": "I don't really understand what this question is asking. It says return the summary of its ranges but the what does this mean?"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "[@bjlslopez](/bjlslopez) dude own\\'s leetcode ! what a clear cut explanation"
                    },
                    {
                        "username": "The_ThunderBolt",
                        "content": "[@bjlslopez](/bjlslopez)  it helps, Thanks man!"
                    },
                    {
                        "username": "charanarc3",
                        "content": "[@bjlslopez](/bjlslopez) it helps thanks\\n"
                    },
                    {
                        "username": "Ilkhomjon",
                        "content": "[@bjlslopez](/bjlslopez) Thank you man, your explanation is really concise!"
                    },
                    {
                        "username": "bjlslopez",
                        "content": "It is asking for you to summarize continuous numbers into a range. For example, 0, 1 should be converted to 0->1. A more useful application would be 2,3,4,5,6,7,8,9,10 can be summarized to 2->10.\\nHowever, if you have 0,2, there is a gap in the range, so you should return \"0\", \"2\".\\nExample: 0, 2, 3, 4, 5, 6, 7, 8, 10, 20, 25, 26, 27\\nTurns to: 0, 2->8, 10, 20, 25->27\\nYou can think of it in terms of how pages are referenced in bibliographies. Example: Python for Dummies. Pages: 1-4, 10 means pages 1 to 4 and page 10."
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Image Explanation\\n```\\nInput: nums = [0,2,3,4,6,8,9]\\n```\\n![image.png](https://assets.leetcode.com/users/images/5ede8d3f-665d-4d88-a628-de73a0986db9_1686559423.6645904.png)\\nThe problem asks us to \"group\" the elements of array into ranges that are continuous. That is, in one range their should not be any number absent in array. And we need to minimize the different ranges we use, so try to take as big range as possible. At each element, make a different range only when you find some number absent in between current and last element, otherwise expand the current range by $1$.\\n```\\nOutput: [\"0\",\"2->4\",\"6\",\"8->9\"]\\n```"
                    },
                    {
                        "username": "Musfik41",
                        "content": "[@mmtemel](/mmtemel) leetcode should hire you for this awesome visual explanation\\uD83D\\uDE05. 100% satisfied."
                    },
                    {
                        "username": "mmtemel",
                        "content": "your explanation should be the problem explanation"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is an easy question. But test this test case before submitting, especially for the  C/C++ programmer!\\n```\\n[-2147483648,-2147483647,2147483647]\\n```"
                    },
                    {
                        "username": "dfisheritp",
                        "content": "the array is sorted. `[INT_MIN, INT_MAX]` has a solution. `nums[i] + 1 == nums[i + 1]`\\n\\nLEFT SIDE : -2147483648 -> -2147483647\\nRIGHT SIDE : 2147483647 -> -2147483648\\n\\nIt fails the test.\\n\\nYou need a guard clause for the \"->\" anyway. And the compiler will cache that because it see\\'s that it\\'s needed immediately after. Like come on."
                    },
                    {
                        "username": "Rifat121",
                        "content": "how to solve this overflow issue!\\n"
                    },
                    {
                        "username": "geekyshark",
                        "content": "[@jasonpyau](/jasonpyau) same here lol, i checked for [\"0\"] but forgot to check for empty array\\n"
                    },
                    {
                        "username": "autf",
                        "content": "Me too (Rust)\\nOne of a million ways to fail a binary search."
                    },
                    {
                        "username": "daring-calf",
                        "content": "This got me too! (golang)"
                    },
                    {
                        "username": "redocmi7",
                        "content": "Yeah, me too! Got confused untill I viewed the testcase where it failed.\\n\\nMoral of the lesson: Always check for integer overflows!"
                    },
                    {
                        "username": "jasonpyau",
                        "content": "Wasted 2 submissions cuz of integer overflow and empty array!! :["
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "me: Who passed in single go without any error or WA \\uD83D\\uDE0E"
                    },
                    {
                        "username": "antoxakartoxa",
                        "content": "In the task description there is \"nums is sorted in ascending order\". But one of testcases checked after submission is [2, -1] which is descending order. "
                    },
                    {
                        "username": "daregula",
                        "content": "dude I just ran into the same thing lol I had to use abs() when checking for the difference to bypass this invalid test case"
                    },
                    {
                        "username": "baryonix",
                        "content": "I have the same issue, this prevents me from completing the 150-question Study Plan :(.\\nThe thing is I solved this question before this new constraint/test case was added"
                    },
                    {
                        "username": "kokolen77",
                        "content": "I wrote about this on github, but seems like they dont see an error here https://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/16112"
                    },
                    {
                        "username": "batman12345",
                        "content": "![image](https://assets.leetcode.com/users/jasinghe/image_1541988925.png)\\n\\nAll submissions are the exact same. A couple ms makes a huge difference in how fast your submission is judged so resubmit a couple times to be sure your solution isn\\'t actually slow :) \\n\\n32ms = you beat 100%\\n52ms = you beat 10% \\n\\nlol"
                    },
                    {
                        "username": "andreasfesshahagglund",
                        "content": "Yeah man. I went from beating 5 % to beating 92 % of all submissions with the same lines of code. =/"
                    },
                    {
                        "username": "District_12",
                        "content": "Why not [\"0-7\"] as a result? What do you need? Problem description is so bad."
                    },
                    {
                        "username": "rishavranjan1821",
                        "content": "the range means you have to give a range in which it should contain all the numbers that comes between these numbers. See [\"0 - 7\"] is not a range because as per the question the range should contain 0,1,,2,3,4,5,6,7 but in the nums array after 0,1,2 . 4 comes which will not be considered as in the range of [0,7] for that after 2 , 3 has to be present thats why [\"0,7\\'] range is not possible\\n"
                    },
                    {
                        "username": "sandyy",
                        "content": "The numbers in the resultant set must be consecutive only. For input [0,1,2,4,5,7] there are only 3 consecutive sets. First is [0,1,2], second is [4,5] and third is [7]. [0,7] can be the answer when input is [0,1,2,3,4,5,6,7]. I agree that the problem statement is not clear enough."
                    },
                    {
                        "username": "mayank17081998",
                        "content": "![image](https://assets.leetcode.com/users/images/308e256b-0272-4010-876a-8b3745b95fed_1646015105.510134.png)\\n![image](https://assets.leetcode.com/users/images/be57f0f2-c7c0-433e-9e1d-d61ba0fc4dcc_1646015113.6479263.png)\\n![image](https://assets.leetcode.com/users/images/e883adbe-45dd-49e6-975b-294d0670c670_1646015121.1118414.png)\\n![image](https://assets.leetcode.com/users/images/1de2db64-268f-4bf9-bcd5-7a511f79f254_1646015129.5048964.png)\\n![image](https://assets.leetcode.com/users/images/c3f49c2e-359d-4f23-a4d7-b02f56b87cff_1646015136.1616788.png)\\n![image](https://assets.leetcode.com/users/images/170ea0b6-91ee-4b2e-8ad8-dfac1374944c_1646015141.054478.png)\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "Tim_Guan",
                        "content": "Dislike for confusing test case [2; -1]"
                    },
                    {
                        "username": "mayankagarwal2402",
                        "content": "it not confusing, it's incorrect. \nHave submitted a feedback for the same, others should too, to get it highlighted and rectified. "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 28.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/summary-ranges/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 0 approach in the official solution</summary>\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "mindstrong",
                        "content": "I can not understand what does this question is. the example show's none principles to summarize the ranges. why [0,1,2,4,5,7] should be summarized to [\"0->2\", \"4->5\", \"7\"], why not [\"0-1\", \"2->5\", \"7\"?\\n\\nwho can explain this question more clearly ? thank you in advance."
                    },
                    {
                        "username": "emma-vuksich",
                        "content": "The ranges have to be consecutive numbers (one after the other, in order). Within [0,1,2,4,5,7], 0->2 is a range because the numbers 0, 1, 2 are consecutive. 4->5 is a range because the numbers 4 and 5 are consecutive."
                    },
                    {
                        "username": "sardarsj",
                        "content": "In this problem, the range means we have to give a range in which it should contain all the numbers consecutively. [\"0 - 7\"] is not a range because as per the question the range should contain 0,1,,2,3,4,5,6,7 but in the \\'nums\\' array after 0,1,2 . 4 comes which will not be considered as in the range of [0,7] for that after 2 , 3 has to be present thatswhy [\"0,7\\'] range is not possible"
                    },
                    {
                        "username": "firuz97",
                        "content": "Hi there!\\nFor me as one who is not a native speaker to figure out the task was confusing. I think over the examples and found this.\\nit makes a range until it mets skip number in array.\\nFor example.\\n[0,2,3] -> [\"0\", \"2->3\"]\\n[0,1,3] -> [\"0->1\", \"3\"]\\nI hope my comment will help someone."
                    },
                    {
                        "username": "LuciferYSD",
                        "content": "if you do it 2->5 3 is not present\\n"
                    }
                ]
            },
            {
                "id": 1576455,
                "content": [
                    {
                        "username": "yuanshuo",
                        "content": "I don't really understand what this question is asking. It says return the summary of its ranges but the what does this mean?"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "[@bjlslopez](/bjlslopez) dude own\\'s leetcode ! what a clear cut explanation"
                    },
                    {
                        "username": "The_ThunderBolt",
                        "content": "[@bjlslopez](/bjlslopez)  it helps, Thanks man!"
                    },
                    {
                        "username": "charanarc3",
                        "content": "[@bjlslopez](/bjlslopez) it helps thanks\\n"
                    },
                    {
                        "username": "Ilkhomjon",
                        "content": "[@bjlslopez](/bjlslopez) Thank you man, your explanation is really concise!"
                    },
                    {
                        "username": "bjlslopez",
                        "content": "It is asking for you to summarize continuous numbers into a range. For example, 0, 1 should be converted to 0->1. A more useful application would be 2,3,4,5,6,7,8,9,10 can be summarized to 2->10.\\nHowever, if you have 0,2, there is a gap in the range, so you should return \"0\", \"2\".\\nExample: 0, 2, 3, 4, 5, 6, 7, 8, 10, 20, 25, 26, 27\\nTurns to: 0, 2->8, 10, 20, 25->27\\nYou can think of it in terms of how pages are referenced in bibliographies. Example: Python for Dummies. Pages: 1-4, 10 means pages 1 to 4 and page 10."
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Image Explanation\\n```\\nInput: nums = [0,2,3,4,6,8,9]\\n```\\n![image.png](https://assets.leetcode.com/users/images/5ede8d3f-665d-4d88-a628-de73a0986db9_1686559423.6645904.png)\\nThe problem asks us to \"group\" the elements of array into ranges that are continuous. That is, in one range their should not be any number absent in array. And we need to minimize the different ranges we use, so try to take as big range as possible. At each element, make a different range only when you find some number absent in between current and last element, otherwise expand the current range by $1$.\\n```\\nOutput: [\"0\",\"2->4\",\"6\",\"8->9\"]\\n```"
                    },
                    {
                        "username": "Musfik41",
                        "content": "[@mmtemel](/mmtemel) leetcode should hire you for this awesome visual explanation\\uD83D\\uDE05. 100% satisfied."
                    },
                    {
                        "username": "mmtemel",
                        "content": "your explanation should be the problem explanation"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is an easy question. But test this test case before submitting, especially for the  C/C++ programmer!\\n```\\n[-2147483648,-2147483647,2147483647]\\n```"
                    },
                    {
                        "username": "dfisheritp",
                        "content": "the array is sorted. `[INT_MIN, INT_MAX]` has a solution. `nums[i] + 1 == nums[i + 1]`\\n\\nLEFT SIDE : -2147483648 -> -2147483647\\nRIGHT SIDE : 2147483647 -> -2147483648\\n\\nIt fails the test.\\n\\nYou need a guard clause for the \"->\" anyway. And the compiler will cache that because it see\\'s that it\\'s needed immediately after. Like come on."
                    },
                    {
                        "username": "Rifat121",
                        "content": "how to solve this overflow issue!\\n"
                    },
                    {
                        "username": "geekyshark",
                        "content": "[@jasonpyau](/jasonpyau) same here lol, i checked for [\"0\"] but forgot to check for empty array\\n"
                    },
                    {
                        "username": "autf",
                        "content": "Me too (Rust)\\nOne of a million ways to fail a binary search."
                    },
                    {
                        "username": "daring-calf",
                        "content": "This got me too! (golang)"
                    },
                    {
                        "username": "redocmi7",
                        "content": "Yeah, me too! Got confused untill I viewed the testcase where it failed.\\n\\nMoral of the lesson: Always check for integer overflows!"
                    },
                    {
                        "username": "jasonpyau",
                        "content": "Wasted 2 submissions cuz of integer overflow and empty array!! :["
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "me: Who passed in single go without any error or WA \\uD83D\\uDE0E"
                    },
                    {
                        "username": "antoxakartoxa",
                        "content": "In the task description there is \"nums is sorted in ascending order\". But one of testcases checked after submission is [2, -1] which is descending order. "
                    },
                    {
                        "username": "daregula",
                        "content": "dude I just ran into the same thing lol I had to use abs() when checking for the difference to bypass this invalid test case"
                    },
                    {
                        "username": "baryonix",
                        "content": "I have the same issue, this prevents me from completing the 150-question Study Plan :(.\\nThe thing is I solved this question before this new constraint/test case was added"
                    },
                    {
                        "username": "kokolen77",
                        "content": "I wrote about this on github, but seems like they dont see an error here https://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/16112"
                    },
                    {
                        "username": "batman12345",
                        "content": "![image](https://assets.leetcode.com/users/jasinghe/image_1541988925.png)\\n\\nAll submissions are the exact same. A couple ms makes a huge difference in how fast your submission is judged so resubmit a couple times to be sure your solution isn\\'t actually slow :) \\n\\n32ms = you beat 100%\\n52ms = you beat 10% \\n\\nlol"
                    },
                    {
                        "username": "andreasfesshahagglund",
                        "content": "Yeah man. I went from beating 5 % to beating 92 % of all submissions with the same lines of code. =/"
                    },
                    {
                        "username": "District_12",
                        "content": "Why not [\"0-7\"] as a result? What do you need? Problem description is so bad."
                    },
                    {
                        "username": "rishavranjan1821",
                        "content": "the range means you have to give a range in which it should contain all the numbers that comes between these numbers. See [\"0 - 7\"] is not a range because as per the question the range should contain 0,1,,2,3,4,5,6,7 but in the nums array after 0,1,2 . 4 comes which will not be considered as in the range of [0,7] for that after 2 , 3 has to be present thats why [\"0,7\\'] range is not possible\\n"
                    },
                    {
                        "username": "sandyy",
                        "content": "The numbers in the resultant set must be consecutive only. For input [0,1,2,4,5,7] there are only 3 consecutive sets. First is [0,1,2], second is [4,5] and third is [7]. [0,7] can be the answer when input is [0,1,2,3,4,5,6,7]. I agree that the problem statement is not clear enough."
                    },
                    {
                        "username": "mayank17081998",
                        "content": "![image](https://assets.leetcode.com/users/images/308e256b-0272-4010-876a-8b3745b95fed_1646015105.510134.png)\\n![image](https://assets.leetcode.com/users/images/be57f0f2-c7c0-433e-9e1d-d61ba0fc4dcc_1646015113.6479263.png)\\n![image](https://assets.leetcode.com/users/images/e883adbe-45dd-49e6-975b-294d0670c670_1646015121.1118414.png)\\n![image](https://assets.leetcode.com/users/images/1de2db64-268f-4bf9-bcd5-7a511f79f254_1646015129.5048964.png)\\n![image](https://assets.leetcode.com/users/images/c3f49c2e-359d-4f23-a4d7-b02f56b87cff_1646015136.1616788.png)\\n![image](https://assets.leetcode.com/users/images/170ea0b6-91ee-4b2e-8ad8-dfac1374944c_1646015141.054478.png)\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "Tim_Guan",
                        "content": "Dislike for confusing test case [2; -1]"
                    },
                    {
                        "username": "mayankagarwal2402",
                        "content": "it not confusing, it's incorrect. \nHave submitted a feedback for the same, others should too, to get it highlighted and rectified. "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 28.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/summary-ranges/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 0 approach in the official solution</summary>\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "mindstrong",
                        "content": "I can not understand what does this question is. the example show's none principles to summarize the ranges. why [0,1,2,4,5,7] should be summarized to [\"0->2\", \"4->5\", \"7\"], why not [\"0-1\", \"2->5\", \"7\"?\\n\\nwho can explain this question more clearly ? thank you in advance."
                    },
                    {
                        "username": "emma-vuksich",
                        "content": "The ranges have to be consecutive numbers (one after the other, in order). Within [0,1,2,4,5,7], 0->2 is a range because the numbers 0, 1, 2 are consecutive. 4->5 is a range because the numbers 4 and 5 are consecutive."
                    },
                    {
                        "username": "sardarsj",
                        "content": "In this problem, the range means we have to give a range in which it should contain all the numbers consecutively. [\"0 - 7\"] is not a range because as per the question the range should contain 0,1,,2,3,4,5,6,7 but in the \\'nums\\' array after 0,1,2 . 4 comes which will not be considered as in the range of [0,7] for that after 2 , 3 has to be present thatswhy [\"0,7\\'] range is not possible"
                    },
                    {
                        "username": "firuz97",
                        "content": "Hi there!\\nFor me as one who is not a native speaker to figure out the task was confusing. I think over the examples and found this.\\nit makes a range until it mets skip number in array.\\nFor example.\\n[0,2,3] -> [\"0\", \"2->3\"]\\n[0,1,3] -> [\"0->1\", \"3\"]\\nI hope my comment will help someone."
                    },
                    {
                        "username": "LuciferYSD",
                        "content": "if you do it 2->5 3 is not present\\n"
                    }
                ]
            },
            {
                "id": 2050771,
                "content": [
                    {
                        "username": "yuanshuo",
                        "content": "I don't really understand what this question is asking. It says return the summary of its ranges but the what does this mean?"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "[@bjlslopez](/bjlslopez) dude own\\'s leetcode ! what a clear cut explanation"
                    },
                    {
                        "username": "The_ThunderBolt",
                        "content": "[@bjlslopez](/bjlslopez)  it helps, Thanks man!"
                    },
                    {
                        "username": "charanarc3",
                        "content": "[@bjlslopez](/bjlslopez) it helps thanks\\n"
                    },
                    {
                        "username": "Ilkhomjon",
                        "content": "[@bjlslopez](/bjlslopez) Thank you man, your explanation is really concise!"
                    },
                    {
                        "username": "bjlslopez",
                        "content": "It is asking for you to summarize continuous numbers into a range. For example, 0, 1 should be converted to 0->1. A more useful application would be 2,3,4,5,6,7,8,9,10 can be summarized to 2->10.\\nHowever, if you have 0,2, there is a gap in the range, so you should return \"0\", \"2\".\\nExample: 0, 2, 3, 4, 5, 6, 7, 8, 10, 20, 25, 26, 27\\nTurns to: 0, 2->8, 10, 20, 25->27\\nYou can think of it in terms of how pages are referenced in bibliographies. Example: Python for Dummies. Pages: 1-4, 10 means pages 1 to 4 and page 10."
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Image Explanation\\n```\\nInput: nums = [0,2,3,4,6,8,9]\\n```\\n![image.png](https://assets.leetcode.com/users/images/5ede8d3f-665d-4d88-a628-de73a0986db9_1686559423.6645904.png)\\nThe problem asks us to \"group\" the elements of array into ranges that are continuous. That is, in one range their should not be any number absent in array. And we need to minimize the different ranges we use, so try to take as big range as possible. At each element, make a different range only when you find some number absent in between current and last element, otherwise expand the current range by $1$.\\n```\\nOutput: [\"0\",\"2->4\",\"6\",\"8->9\"]\\n```"
                    },
                    {
                        "username": "Musfik41",
                        "content": "[@mmtemel](/mmtemel) leetcode should hire you for this awesome visual explanation\\uD83D\\uDE05. 100% satisfied."
                    },
                    {
                        "username": "mmtemel",
                        "content": "your explanation should be the problem explanation"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is an easy question. But test this test case before submitting, especially for the  C/C++ programmer!\\n```\\n[-2147483648,-2147483647,2147483647]\\n```"
                    },
                    {
                        "username": "dfisheritp",
                        "content": "the array is sorted. `[INT_MIN, INT_MAX]` has a solution. `nums[i] + 1 == nums[i + 1]`\\n\\nLEFT SIDE : -2147483648 -> -2147483647\\nRIGHT SIDE : 2147483647 -> -2147483648\\n\\nIt fails the test.\\n\\nYou need a guard clause for the \"->\" anyway. And the compiler will cache that because it see\\'s that it\\'s needed immediately after. Like come on."
                    },
                    {
                        "username": "Rifat121",
                        "content": "how to solve this overflow issue!\\n"
                    },
                    {
                        "username": "geekyshark",
                        "content": "[@jasonpyau](/jasonpyau) same here lol, i checked for [\"0\"] but forgot to check for empty array\\n"
                    },
                    {
                        "username": "autf",
                        "content": "Me too (Rust)\\nOne of a million ways to fail a binary search."
                    },
                    {
                        "username": "daring-calf",
                        "content": "This got me too! (golang)"
                    },
                    {
                        "username": "redocmi7",
                        "content": "Yeah, me too! Got confused untill I viewed the testcase where it failed.\\n\\nMoral of the lesson: Always check for integer overflows!"
                    },
                    {
                        "username": "jasonpyau",
                        "content": "Wasted 2 submissions cuz of integer overflow and empty array!! :["
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "me: Who passed in single go without any error or WA \\uD83D\\uDE0E"
                    },
                    {
                        "username": "antoxakartoxa",
                        "content": "In the task description there is \"nums is sorted in ascending order\". But one of testcases checked after submission is [2, -1] which is descending order. "
                    },
                    {
                        "username": "daregula",
                        "content": "dude I just ran into the same thing lol I had to use abs() when checking for the difference to bypass this invalid test case"
                    },
                    {
                        "username": "baryonix",
                        "content": "I have the same issue, this prevents me from completing the 150-question Study Plan :(.\\nThe thing is I solved this question before this new constraint/test case was added"
                    },
                    {
                        "username": "kokolen77",
                        "content": "I wrote about this on github, but seems like they dont see an error here https://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/16112"
                    },
                    {
                        "username": "batman12345",
                        "content": "![image](https://assets.leetcode.com/users/jasinghe/image_1541988925.png)\\n\\nAll submissions are the exact same. A couple ms makes a huge difference in how fast your submission is judged so resubmit a couple times to be sure your solution isn\\'t actually slow :) \\n\\n32ms = you beat 100%\\n52ms = you beat 10% \\n\\nlol"
                    },
                    {
                        "username": "andreasfesshahagglund",
                        "content": "Yeah man. I went from beating 5 % to beating 92 % of all submissions with the same lines of code. =/"
                    },
                    {
                        "username": "District_12",
                        "content": "Why not [\"0-7\"] as a result? What do you need? Problem description is so bad."
                    },
                    {
                        "username": "rishavranjan1821",
                        "content": "the range means you have to give a range in which it should contain all the numbers that comes between these numbers. See [\"0 - 7\"] is not a range because as per the question the range should contain 0,1,,2,3,4,5,6,7 but in the nums array after 0,1,2 . 4 comes which will not be considered as in the range of [0,7] for that after 2 , 3 has to be present thats why [\"0,7\\'] range is not possible\\n"
                    },
                    {
                        "username": "sandyy",
                        "content": "The numbers in the resultant set must be consecutive only. For input [0,1,2,4,5,7] there are only 3 consecutive sets. First is [0,1,2], second is [4,5] and third is [7]. [0,7] can be the answer when input is [0,1,2,3,4,5,6,7]. I agree that the problem statement is not clear enough."
                    },
                    {
                        "username": "mayank17081998",
                        "content": "![image](https://assets.leetcode.com/users/images/308e256b-0272-4010-876a-8b3745b95fed_1646015105.510134.png)\\n![image](https://assets.leetcode.com/users/images/be57f0f2-c7c0-433e-9e1d-d61ba0fc4dcc_1646015113.6479263.png)\\n![image](https://assets.leetcode.com/users/images/e883adbe-45dd-49e6-975b-294d0670c670_1646015121.1118414.png)\\n![image](https://assets.leetcode.com/users/images/1de2db64-268f-4bf9-bcd5-7a511f79f254_1646015129.5048964.png)\\n![image](https://assets.leetcode.com/users/images/c3f49c2e-359d-4f23-a4d7-b02f56b87cff_1646015136.1616788.png)\\n![image](https://assets.leetcode.com/users/images/170ea0b6-91ee-4b2e-8ad8-dfac1374944c_1646015141.054478.png)\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "Tim_Guan",
                        "content": "Dislike for confusing test case [2; -1]"
                    },
                    {
                        "username": "mayankagarwal2402",
                        "content": "it not confusing, it's incorrect. \nHave submitted a feedback for the same, others should too, to get it highlighted and rectified. "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 28.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/summary-ranges/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 0 approach in the official solution</summary>\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "mindstrong",
                        "content": "I can not understand what does this question is. the example show's none principles to summarize the ranges. why [0,1,2,4,5,7] should be summarized to [\"0->2\", \"4->5\", \"7\"], why not [\"0-1\", \"2->5\", \"7\"?\\n\\nwho can explain this question more clearly ? thank you in advance."
                    },
                    {
                        "username": "emma-vuksich",
                        "content": "The ranges have to be consecutive numbers (one after the other, in order). Within [0,1,2,4,5,7], 0->2 is a range because the numbers 0, 1, 2 are consecutive. 4->5 is a range because the numbers 4 and 5 are consecutive."
                    },
                    {
                        "username": "sardarsj",
                        "content": "In this problem, the range means we have to give a range in which it should contain all the numbers consecutively. [\"0 - 7\"] is not a range because as per the question the range should contain 0,1,,2,3,4,5,6,7 but in the \\'nums\\' array after 0,1,2 . 4 comes which will not be considered as in the range of [0,7] for that after 2 , 3 has to be present thatswhy [\"0,7\\'] range is not possible"
                    },
                    {
                        "username": "firuz97",
                        "content": "Hi there!\\nFor me as one who is not a native speaker to figure out the task was confusing. I think over the examples and found this.\\nit makes a range until it mets skip number in array.\\nFor example.\\n[0,2,3] -> [\"0\", \"2->3\"]\\n[0,1,3] -> [\"0->1\", \"3\"]\\nI hope my comment will help someone."
                    },
                    {
                        "username": "LuciferYSD",
                        "content": "if you do it 2->5 3 is not present\\n"
                    }
                ]
            },
            {
                "id": 1566053,
                "content": [
                    {
                        "username": "yuanshuo",
                        "content": "I don't really understand what this question is asking. It says return the summary of its ranges but the what does this mean?"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "[@bjlslopez](/bjlslopez) dude own\\'s leetcode ! what a clear cut explanation"
                    },
                    {
                        "username": "The_ThunderBolt",
                        "content": "[@bjlslopez](/bjlslopez)  it helps, Thanks man!"
                    },
                    {
                        "username": "charanarc3",
                        "content": "[@bjlslopez](/bjlslopez) it helps thanks\\n"
                    },
                    {
                        "username": "Ilkhomjon",
                        "content": "[@bjlslopez](/bjlslopez) Thank you man, your explanation is really concise!"
                    },
                    {
                        "username": "bjlslopez",
                        "content": "It is asking for you to summarize continuous numbers into a range. For example, 0, 1 should be converted to 0->1. A more useful application would be 2,3,4,5,6,7,8,9,10 can be summarized to 2->10.\\nHowever, if you have 0,2, there is a gap in the range, so you should return \"0\", \"2\".\\nExample: 0, 2, 3, 4, 5, 6, 7, 8, 10, 20, 25, 26, 27\\nTurns to: 0, 2->8, 10, 20, 25->27\\nYou can think of it in terms of how pages are referenced in bibliographies. Example: Python for Dummies. Pages: 1-4, 10 means pages 1 to 4 and page 10."
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Image Explanation\\n```\\nInput: nums = [0,2,3,4,6,8,9]\\n```\\n![image.png](https://assets.leetcode.com/users/images/5ede8d3f-665d-4d88-a628-de73a0986db9_1686559423.6645904.png)\\nThe problem asks us to \"group\" the elements of array into ranges that are continuous. That is, in one range their should not be any number absent in array. And we need to minimize the different ranges we use, so try to take as big range as possible. At each element, make a different range only when you find some number absent in between current and last element, otherwise expand the current range by $1$.\\n```\\nOutput: [\"0\",\"2->4\",\"6\",\"8->9\"]\\n```"
                    },
                    {
                        "username": "Musfik41",
                        "content": "[@mmtemel](/mmtemel) leetcode should hire you for this awesome visual explanation\\uD83D\\uDE05. 100% satisfied."
                    },
                    {
                        "username": "mmtemel",
                        "content": "your explanation should be the problem explanation"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is an easy question. But test this test case before submitting, especially for the  C/C++ programmer!\\n```\\n[-2147483648,-2147483647,2147483647]\\n```"
                    },
                    {
                        "username": "dfisheritp",
                        "content": "the array is sorted. `[INT_MIN, INT_MAX]` has a solution. `nums[i] + 1 == nums[i + 1]`\\n\\nLEFT SIDE : -2147483648 -> -2147483647\\nRIGHT SIDE : 2147483647 -> -2147483648\\n\\nIt fails the test.\\n\\nYou need a guard clause for the \"->\" anyway. And the compiler will cache that because it see\\'s that it\\'s needed immediately after. Like come on."
                    },
                    {
                        "username": "Rifat121",
                        "content": "how to solve this overflow issue!\\n"
                    },
                    {
                        "username": "geekyshark",
                        "content": "[@jasonpyau](/jasonpyau) same here lol, i checked for [\"0\"] but forgot to check for empty array\\n"
                    },
                    {
                        "username": "autf",
                        "content": "Me too (Rust)\\nOne of a million ways to fail a binary search."
                    },
                    {
                        "username": "daring-calf",
                        "content": "This got me too! (golang)"
                    },
                    {
                        "username": "redocmi7",
                        "content": "Yeah, me too! Got confused untill I viewed the testcase where it failed.\\n\\nMoral of the lesson: Always check for integer overflows!"
                    },
                    {
                        "username": "jasonpyau",
                        "content": "Wasted 2 submissions cuz of integer overflow and empty array!! :["
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "me: Who passed in single go without any error or WA \\uD83D\\uDE0E"
                    },
                    {
                        "username": "antoxakartoxa",
                        "content": "In the task description there is \"nums is sorted in ascending order\". But one of testcases checked after submission is [2, -1] which is descending order. "
                    },
                    {
                        "username": "daregula",
                        "content": "dude I just ran into the same thing lol I had to use abs() when checking for the difference to bypass this invalid test case"
                    },
                    {
                        "username": "baryonix",
                        "content": "I have the same issue, this prevents me from completing the 150-question Study Plan :(.\\nThe thing is I solved this question before this new constraint/test case was added"
                    },
                    {
                        "username": "kokolen77",
                        "content": "I wrote about this on github, but seems like they dont see an error here https://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/16112"
                    },
                    {
                        "username": "batman12345",
                        "content": "![image](https://assets.leetcode.com/users/jasinghe/image_1541988925.png)\\n\\nAll submissions are the exact same. A couple ms makes a huge difference in how fast your submission is judged so resubmit a couple times to be sure your solution isn\\'t actually slow :) \\n\\n32ms = you beat 100%\\n52ms = you beat 10% \\n\\nlol"
                    },
                    {
                        "username": "andreasfesshahagglund",
                        "content": "Yeah man. I went from beating 5 % to beating 92 % of all submissions with the same lines of code. =/"
                    },
                    {
                        "username": "District_12",
                        "content": "Why not [\"0-7\"] as a result? What do you need? Problem description is so bad."
                    },
                    {
                        "username": "rishavranjan1821",
                        "content": "the range means you have to give a range in which it should contain all the numbers that comes between these numbers. See [\"0 - 7\"] is not a range because as per the question the range should contain 0,1,,2,3,4,5,6,7 but in the nums array after 0,1,2 . 4 comes which will not be considered as in the range of [0,7] for that after 2 , 3 has to be present thats why [\"0,7\\'] range is not possible\\n"
                    },
                    {
                        "username": "sandyy",
                        "content": "The numbers in the resultant set must be consecutive only. For input [0,1,2,4,5,7] there are only 3 consecutive sets. First is [0,1,2], second is [4,5] and third is [7]. [0,7] can be the answer when input is [0,1,2,3,4,5,6,7]. I agree that the problem statement is not clear enough."
                    },
                    {
                        "username": "mayank17081998",
                        "content": "![image](https://assets.leetcode.com/users/images/308e256b-0272-4010-876a-8b3745b95fed_1646015105.510134.png)\\n![image](https://assets.leetcode.com/users/images/be57f0f2-c7c0-433e-9e1d-d61ba0fc4dcc_1646015113.6479263.png)\\n![image](https://assets.leetcode.com/users/images/e883adbe-45dd-49e6-975b-294d0670c670_1646015121.1118414.png)\\n![image](https://assets.leetcode.com/users/images/1de2db64-268f-4bf9-bcd5-7a511f79f254_1646015129.5048964.png)\\n![image](https://assets.leetcode.com/users/images/c3f49c2e-359d-4f23-a4d7-b02f56b87cff_1646015136.1616788.png)\\n![image](https://assets.leetcode.com/users/images/170ea0b6-91ee-4b2e-8ad8-dfac1374944c_1646015141.054478.png)\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "Tim_Guan",
                        "content": "Dislike for confusing test case [2; -1]"
                    },
                    {
                        "username": "mayankagarwal2402",
                        "content": "it not confusing, it's incorrect. \nHave submitted a feedback for the same, others should too, to get it highlighted and rectified. "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 28.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/summary-ranges/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 0 approach in the official solution</summary>\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "mindstrong",
                        "content": "I can not understand what does this question is. the example show's none principles to summarize the ranges. why [0,1,2,4,5,7] should be summarized to [\"0->2\", \"4->5\", \"7\"], why not [\"0-1\", \"2->5\", \"7\"?\\n\\nwho can explain this question more clearly ? thank you in advance."
                    },
                    {
                        "username": "emma-vuksich",
                        "content": "The ranges have to be consecutive numbers (one after the other, in order). Within [0,1,2,4,5,7], 0->2 is a range because the numbers 0, 1, 2 are consecutive. 4->5 is a range because the numbers 4 and 5 are consecutive."
                    },
                    {
                        "username": "sardarsj",
                        "content": "In this problem, the range means we have to give a range in which it should contain all the numbers consecutively. [\"0 - 7\"] is not a range because as per the question the range should contain 0,1,,2,3,4,5,6,7 but in the \\'nums\\' array after 0,1,2 . 4 comes which will not be considered as in the range of [0,7] for that after 2 , 3 has to be present thatswhy [\"0,7\\'] range is not possible"
                    },
                    {
                        "username": "firuz97",
                        "content": "Hi there!\\nFor me as one who is not a native speaker to figure out the task was confusing. I think over the examples and found this.\\nit makes a range until it mets skip number in array.\\nFor example.\\n[0,2,3] -> [\"0\", \"2->3\"]\\n[0,1,3] -> [\"0->1\", \"3\"]\\nI hope my comment will help someone."
                    },
                    {
                        "username": "LuciferYSD",
                        "content": "if you do it 2->5 3 is not present\\n"
                    }
                ]
            },
            {
                "id": 1571461,
                "content": [
                    {
                        "username": "yuanshuo",
                        "content": "I don't really understand what this question is asking. It says return the summary of its ranges but the what does this mean?"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "[@bjlslopez](/bjlslopez) dude own\\'s leetcode ! what a clear cut explanation"
                    },
                    {
                        "username": "The_ThunderBolt",
                        "content": "[@bjlslopez](/bjlslopez)  it helps, Thanks man!"
                    },
                    {
                        "username": "charanarc3",
                        "content": "[@bjlslopez](/bjlslopez) it helps thanks\\n"
                    },
                    {
                        "username": "Ilkhomjon",
                        "content": "[@bjlslopez](/bjlslopez) Thank you man, your explanation is really concise!"
                    },
                    {
                        "username": "bjlslopez",
                        "content": "It is asking for you to summarize continuous numbers into a range. For example, 0, 1 should be converted to 0->1. A more useful application would be 2,3,4,5,6,7,8,9,10 can be summarized to 2->10.\\nHowever, if you have 0,2, there is a gap in the range, so you should return \"0\", \"2\".\\nExample: 0, 2, 3, 4, 5, 6, 7, 8, 10, 20, 25, 26, 27\\nTurns to: 0, 2->8, 10, 20, 25->27\\nYou can think of it in terms of how pages are referenced in bibliographies. Example: Python for Dummies. Pages: 1-4, 10 means pages 1 to 4 and page 10."
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Image Explanation\\n```\\nInput: nums = [0,2,3,4,6,8,9]\\n```\\n![image.png](https://assets.leetcode.com/users/images/5ede8d3f-665d-4d88-a628-de73a0986db9_1686559423.6645904.png)\\nThe problem asks us to \"group\" the elements of array into ranges that are continuous. That is, in one range their should not be any number absent in array. And we need to minimize the different ranges we use, so try to take as big range as possible. At each element, make a different range only when you find some number absent in between current and last element, otherwise expand the current range by $1$.\\n```\\nOutput: [\"0\",\"2->4\",\"6\",\"8->9\"]\\n```"
                    },
                    {
                        "username": "Musfik41",
                        "content": "[@mmtemel](/mmtemel) leetcode should hire you for this awesome visual explanation\\uD83D\\uDE05. 100% satisfied."
                    },
                    {
                        "username": "mmtemel",
                        "content": "your explanation should be the problem explanation"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is an easy question. But test this test case before submitting, especially for the  C/C++ programmer!\\n```\\n[-2147483648,-2147483647,2147483647]\\n```"
                    },
                    {
                        "username": "dfisheritp",
                        "content": "the array is sorted. `[INT_MIN, INT_MAX]` has a solution. `nums[i] + 1 == nums[i + 1]`\\n\\nLEFT SIDE : -2147483648 -> -2147483647\\nRIGHT SIDE : 2147483647 -> -2147483648\\n\\nIt fails the test.\\n\\nYou need a guard clause for the \"->\" anyway. And the compiler will cache that because it see\\'s that it\\'s needed immediately after. Like come on."
                    },
                    {
                        "username": "Rifat121",
                        "content": "how to solve this overflow issue!\\n"
                    },
                    {
                        "username": "geekyshark",
                        "content": "[@jasonpyau](/jasonpyau) same here lol, i checked for [\"0\"] but forgot to check for empty array\\n"
                    },
                    {
                        "username": "autf",
                        "content": "Me too (Rust)\\nOne of a million ways to fail a binary search."
                    },
                    {
                        "username": "daring-calf",
                        "content": "This got me too! (golang)"
                    },
                    {
                        "username": "redocmi7",
                        "content": "Yeah, me too! Got confused untill I viewed the testcase where it failed.\\n\\nMoral of the lesson: Always check for integer overflows!"
                    },
                    {
                        "username": "jasonpyau",
                        "content": "Wasted 2 submissions cuz of integer overflow and empty array!! :["
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "me: Who passed in single go without any error or WA \\uD83D\\uDE0E"
                    },
                    {
                        "username": "antoxakartoxa",
                        "content": "In the task description there is \"nums is sorted in ascending order\". But one of testcases checked after submission is [2, -1] which is descending order. "
                    },
                    {
                        "username": "daregula",
                        "content": "dude I just ran into the same thing lol I had to use abs() when checking for the difference to bypass this invalid test case"
                    },
                    {
                        "username": "baryonix",
                        "content": "I have the same issue, this prevents me from completing the 150-question Study Plan :(.\\nThe thing is I solved this question before this new constraint/test case was added"
                    },
                    {
                        "username": "kokolen77",
                        "content": "I wrote about this on github, but seems like they dont see an error here https://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/16112"
                    },
                    {
                        "username": "batman12345",
                        "content": "![image](https://assets.leetcode.com/users/jasinghe/image_1541988925.png)\\n\\nAll submissions are the exact same. A couple ms makes a huge difference in how fast your submission is judged so resubmit a couple times to be sure your solution isn\\'t actually slow :) \\n\\n32ms = you beat 100%\\n52ms = you beat 10% \\n\\nlol"
                    },
                    {
                        "username": "andreasfesshahagglund",
                        "content": "Yeah man. I went from beating 5 % to beating 92 % of all submissions with the same lines of code. =/"
                    },
                    {
                        "username": "District_12",
                        "content": "Why not [\"0-7\"] as a result? What do you need? Problem description is so bad."
                    },
                    {
                        "username": "rishavranjan1821",
                        "content": "the range means you have to give a range in which it should contain all the numbers that comes between these numbers. See [\"0 - 7\"] is not a range because as per the question the range should contain 0,1,,2,3,4,5,6,7 but in the nums array after 0,1,2 . 4 comes which will not be considered as in the range of [0,7] for that after 2 , 3 has to be present thats why [\"0,7\\'] range is not possible\\n"
                    },
                    {
                        "username": "sandyy",
                        "content": "The numbers in the resultant set must be consecutive only. For input [0,1,2,4,5,7] there are only 3 consecutive sets. First is [0,1,2], second is [4,5] and third is [7]. [0,7] can be the answer when input is [0,1,2,3,4,5,6,7]. I agree that the problem statement is not clear enough."
                    },
                    {
                        "username": "mayank17081998",
                        "content": "![image](https://assets.leetcode.com/users/images/308e256b-0272-4010-876a-8b3745b95fed_1646015105.510134.png)\\n![image](https://assets.leetcode.com/users/images/be57f0f2-c7c0-433e-9e1d-d61ba0fc4dcc_1646015113.6479263.png)\\n![image](https://assets.leetcode.com/users/images/e883adbe-45dd-49e6-975b-294d0670c670_1646015121.1118414.png)\\n![image](https://assets.leetcode.com/users/images/1de2db64-268f-4bf9-bcd5-7a511f79f254_1646015129.5048964.png)\\n![image](https://assets.leetcode.com/users/images/c3f49c2e-359d-4f23-a4d7-b02f56b87cff_1646015136.1616788.png)\\n![image](https://assets.leetcode.com/users/images/170ea0b6-91ee-4b2e-8ad8-dfac1374944c_1646015141.054478.png)\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "Tim_Guan",
                        "content": "Dislike for confusing test case [2; -1]"
                    },
                    {
                        "username": "mayankagarwal2402",
                        "content": "it not confusing, it's incorrect. \nHave submitted a feedback for the same, others should too, to get it highlighted and rectified. "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 28.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/summary-ranges/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 0 approach in the official solution</summary>\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "mindstrong",
                        "content": "I can not understand what does this question is. the example show's none principles to summarize the ranges. why [0,1,2,4,5,7] should be summarized to [\"0->2\", \"4->5\", \"7\"], why not [\"0-1\", \"2->5\", \"7\"?\\n\\nwho can explain this question more clearly ? thank you in advance."
                    },
                    {
                        "username": "emma-vuksich",
                        "content": "The ranges have to be consecutive numbers (one after the other, in order). Within [0,1,2,4,5,7], 0->2 is a range because the numbers 0, 1, 2 are consecutive. 4->5 is a range because the numbers 4 and 5 are consecutive."
                    },
                    {
                        "username": "sardarsj",
                        "content": "In this problem, the range means we have to give a range in which it should contain all the numbers consecutively. [\"0 - 7\"] is not a range because as per the question the range should contain 0,1,,2,3,4,5,6,7 but in the \\'nums\\' array after 0,1,2 . 4 comes which will not be considered as in the range of [0,7] for that after 2 , 3 has to be present thatswhy [\"0,7\\'] range is not possible"
                    },
                    {
                        "username": "firuz97",
                        "content": "Hi there!\\nFor me as one who is not a native speaker to figure out the task was confusing. I think over the examples and found this.\\nit makes a range until it mets skip number in array.\\nFor example.\\n[0,2,3] -> [\"0\", \"2->3\"]\\n[0,1,3] -> [\"0->1\", \"3\"]\\nI hope my comment will help someone."
                    },
                    {
                        "username": "LuciferYSD",
                        "content": "if you do it 2->5 3 is not present\\n"
                    }
                ]
            },
            {
                "id": 2044307,
                "content": [
                    {
                        "username": "akhrorbek20011707",
                        "content": "According to the constraints, it is said that the nums array is in ascending order. However, in the 31 testcase the nums is in descending order. How can I accept this?"
                    },
                    {
                        "username": "doctordingus",
                        "content": "Just noticed this too, unreasonable test case that is outside of documented problem constraints. Lame."
                    },
                    {
                        "username": "Adhiraj-MNNIT",
                        "content": "Smash \\uD83D\\uDC80"
                    },
                    {
                        "username": "gji123",
                        "content": "```\\nclass Solution\\n{\\npublic:\\n    vector<string> summaryRanges(vector<int> &nums)\\n    {\\n        vector<string> ans;\\n        int i = 0, p = 1, j = 0, n = nums.size();\\n        while (j < n)\\n        {\\n            while (p < n && nums[i] + 1 == nums[p])\\n            {\\n                p++;\\n                i++;\\n            }\\n            ans.push_back(j != i ? to_string(nums[j]) + \"->\" + to_string(nums[i]) : to_string(nums[j]));\\n            j = p;\\n            i = p;\\n            p++;\\n        }\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "dmitrii-b",
                        "content": "The test case [2, -1] does not satisfy the initial condition."
                    },
                    {
                        "username": "WAxsSd",
                        "content": "The constraints say that nums is sorted in ASCENDING order, but test case #31 is NOT in ASCENDING order:\\nInput\\nnums =\\n[2, -1]"
                    },
                    {
                        "username": "WAxsSd",
                        "content": "Even when I try to use this bad test case, I get an error from the console saying that \"\\'nums\\' must be strictly increasing\"\\nInvalid Testcase\\nCase 3\\n\\'nums\\' must be strictly increasing"
                    },
                    {
                        "username": "natitati",
                        "content": "Just did this in C. What a damn pain."
                    },
                    {
                        "username": "breathermachine",
                        "content": "Nothing that a few reallocs() can\\'t do :)"
                    },
                    {
                        "username": "natitati",
                        "content": "I\\'m so glad I already did this like 2 weeks ago so I don\\'t have to do it again, it was a pain to do in C."
                    },
                    {
                        "username": "psionl0",
                        "content": "I like using C. It gets me to learn all of the algorithm/data structure techniques instead of having them buried in \"black box\" libraries."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/3cfd311f-d3db-49e2-b62f-554a0ebe88f7_1638207203.6713247.png)\\n\\n\\n![image](https://assets.leetcode.com/users/images/5cbfec54-4ddc-4c9b-bd9c-820ed6860d03_1638207383.0479376.png)\\n"
                    },
                    {
                        "username": "sitanggang",
                        "content": "2023 still make unclear description "
                    },
                    {
                        "username": "Tanuj_Agarwal",
                        "content": "I don\\'t really understand what this question is asking."
                    },
                    {
                        "username": "GopiKumaresan",
                        "content": "Turn the continuous occurrence into number range.\\nOtherwise consider as individual range.\\n\\nExample: [1,2,3,4,5, 7, 9,10] =>[\"1->5\",\"7\",\"9->10\"]\\n\\n1,2,3,4,5 => \"1->5\"\\n7 => \"7\" (Since 6 is missing, new range started, 8 is also missing, So range ended)\\n9,10 => \"9->10\" \\n\\n"
                    }
                ]
            },
            {
                "id": 1926059,
                "content": [
                    {
                        "username": "akhrorbek20011707",
                        "content": "According to the constraints, it is said that the nums array is in ascending order. However, in the 31 testcase the nums is in descending order. How can I accept this?"
                    },
                    {
                        "username": "doctordingus",
                        "content": "Just noticed this too, unreasonable test case that is outside of documented problem constraints. Lame."
                    },
                    {
                        "username": "Adhiraj-MNNIT",
                        "content": "Smash \\uD83D\\uDC80"
                    },
                    {
                        "username": "gji123",
                        "content": "```\\nclass Solution\\n{\\npublic:\\n    vector<string> summaryRanges(vector<int> &nums)\\n    {\\n        vector<string> ans;\\n        int i = 0, p = 1, j = 0, n = nums.size();\\n        while (j < n)\\n        {\\n            while (p < n && nums[i] + 1 == nums[p])\\n            {\\n                p++;\\n                i++;\\n            }\\n            ans.push_back(j != i ? to_string(nums[j]) + \"->\" + to_string(nums[i]) : to_string(nums[j]));\\n            j = p;\\n            i = p;\\n            p++;\\n        }\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "dmitrii-b",
                        "content": "The test case [2, -1] does not satisfy the initial condition."
                    },
                    {
                        "username": "WAxsSd",
                        "content": "The constraints say that nums is sorted in ASCENDING order, but test case #31 is NOT in ASCENDING order:\\nInput\\nnums =\\n[2, -1]"
                    },
                    {
                        "username": "WAxsSd",
                        "content": "Even when I try to use this bad test case, I get an error from the console saying that \"\\'nums\\' must be strictly increasing\"\\nInvalid Testcase\\nCase 3\\n\\'nums\\' must be strictly increasing"
                    },
                    {
                        "username": "natitati",
                        "content": "Just did this in C. What a damn pain."
                    },
                    {
                        "username": "breathermachine",
                        "content": "Nothing that a few reallocs() can\\'t do :)"
                    },
                    {
                        "username": "natitati",
                        "content": "I\\'m so glad I already did this like 2 weeks ago so I don\\'t have to do it again, it was a pain to do in C."
                    },
                    {
                        "username": "psionl0",
                        "content": "I like using C. It gets me to learn all of the algorithm/data structure techniques instead of having them buried in \"black box\" libraries."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/3cfd311f-d3db-49e2-b62f-554a0ebe88f7_1638207203.6713247.png)\\n\\n\\n![image](https://assets.leetcode.com/users/images/5cbfec54-4ddc-4c9b-bd9c-820ed6860d03_1638207383.0479376.png)\\n"
                    },
                    {
                        "username": "sitanggang",
                        "content": "2023 still make unclear description "
                    },
                    {
                        "username": "Tanuj_Agarwal",
                        "content": "I don\\'t really understand what this question is asking."
                    },
                    {
                        "username": "GopiKumaresan",
                        "content": "Turn the continuous occurrence into number range.\\nOtherwise consider as individual range.\\n\\nExample: [1,2,3,4,5, 7, 9,10] =>[\"1->5\",\"7\",\"9->10\"]\\n\\n1,2,3,4,5 => \"1->5\"\\n7 => \"7\" (Since 6 is missing, new range started, 8 is also missing, So range ended)\\n9,10 => \"9->10\" \\n\\n"
                    }
                ]
            },
            {
                "id": 1576457,
                "content": [
                    {
                        "username": "akhrorbek20011707",
                        "content": "According to the constraints, it is said that the nums array is in ascending order. However, in the 31 testcase the nums is in descending order. How can I accept this?"
                    },
                    {
                        "username": "doctordingus",
                        "content": "Just noticed this too, unreasonable test case that is outside of documented problem constraints. Lame."
                    },
                    {
                        "username": "Adhiraj-MNNIT",
                        "content": "Smash \\uD83D\\uDC80"
                    },
                    {
                        "username": "gji123",
                        "content": "```\\nclass Solution\\n{\\npublic:\\n    vector<string> summaryRanges(vector<int> &nums)\\n    {\\n        vector<string> ans;\\n        int i = 0, p = 1, j = 0, n = nums.size();\\n        while (j < n)\\n        {\\n            while (p < n && nums[i] + 1 == nums[p])\\n            {\\n                p++;\\n                i++;\\n            }\\n            ans.push_back(j != i ? to_string(nums[j]) + \"->\" + to_string(nums[i]) : to_string(nums[j]));\\n            j = p;\\n            i = p;\\n            p++;\\n        }\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "dmitrii-b",
                        "content": "The test case [2, -1] does not satisfy the initial condition."
                    },
                    {
                        "username": "WAxsSd",
                        "content": "The constraints say that nums is sorted in ASCENDING order, but test case #31 is NOT in ASCENDING order:\\nInput\\nnums =\\n[2, -1]"
                    },
                    {
                        "username": "WAxsSd",
                        "content": "Even when I try to use this bad test case, I get an error from the console saying that \"\\'nums\\' must be strictly increasing\"\\nInvalid Testcase\\nCase 3\\n\\'nums\\' must be strictly increasing"
                    },
                    {
                        "username": "natitati",
                        "content": "Just did this in C. What a damn pain."
                    },
                    {
                        "username": "breathermachine",
                        "content": "Nothing that a few reallocs() can\\'t do :)"
                    },
                    {
                        "username": "natitati",
                        "content": "I\\'m so glad I already did this like 2 weeks ago so I don\\'t have to do it again, it was a pain to do in C."
                    },
                    {
                        "username": "psionl0",
                        "content": "I like using C. It gets me to learn all of the algorithm/data structure techniques instead of having them buried in \"black box\" libraries."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/3cfd311f-d3db-49e2-b62f-554a0ebe88f7_1638207203.6713247.png)\\n\\n\\n![image](https://assets.leetcode.com/users/images/5cbfec54-4ddc-4c9b-bd9c-820ed6860d03_1638207383.0479376.png)\\n"
                    },
                    {
                        "username": "sitanggang",
                        "content": "2023 still make unclear description "
                    },
                    {
                        "username": "Tanuj_Agarwal",
                        "content": "I don\\'t really understand what this question is asking."
                    },
                    {
                        "username": "GopiKumaresan",
                        "content": "Turn the continuous occurrence into number range.\\nOtherwise consider as individual range.\\n\\nExample: [1,2,3,4,5, 7, 9,10] =>[\"1->5\",\"7\",\"9->10\"]\\n\\n1,2,3,4,5 => \"1->5\"\\n7 => \"7\" (Since 6 is missing, new range started, 8 is also missing, So range ended)\\n9,10 => \"9->10\" \\n\\n"
                    }
                ]
            },
            {
                "id": 2052570,
                "content": [
                    {
                        "username": "akhrorbek20011707",
                        "content": "According to the constraints, it is said that the nums array is in ascending order. However, in the 31 testcase the nums is in descending order. How can I accept this?"
                    },
                    {
                        "username": "doctordingus",
                        "content": "Just noticed this too, unreasonable test case that is outside of documented problem constraints. Lame."
                    },
                    {
                        "username": "Adhiraj-MNNIT",
                        "content": "Smash \\uD83D\\uDC80"
                    },
                    {
                        "username": "gji123",
                        "content": "```\\nclass Solution\\n{\\npublic:\\n    vector<string> summaryRanges(vector<int> &nums)\\n    {\\n        vector<string> ans;\\n        int i = 0, p = 1, j = 0, n = nums.size();\\n        while (j < n)\\n        {\\n            while (p < n && nums[i] + 1 == nums[p])\\n            {\\n                p++;\\n                i++;\\n            }\\n            ans.push_back(j != i ? to_string(nums[j]) + \"->\" + to_string(nums[i]) : to_string(nums[j]));\\n            j = p;\\n            i = p;\\n            p++;\\n        }\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "dmitrii-b",
                        "content": "The test case [2, -1] does not satisfy the initial condition."
                    },
                    {
                        "username": "WAxsSd",
                        "content": "The constraints say that nums is sorted in ASCENDING order, but test case #31 is NOT in ASCENDING order:\\nInput\\nnums =\\n[2, -1]"
                    },
                    {
                        "username": "WAxsSd",
                        "content": "Even when I try to use this bad test case, I get an error from the console saying that \"\\'nums\\' must be strictly increasing\"\\nInvalid Testcase\\nCase 3\\n\\'nums\\' must be strictly increasing"
                    },
                    {
                        "username": "natitati",
                        "content": "Just did this in C. What a damn pain."
                    },
                    {
                        "username": "breathermachine",
                        "content": "Nothing that a few reallocs() can\\'t do :)"
                    },
                    {
                        "username": "natitati",
                        "content": "I\\'m so glad I already did this like 2 weeks ago so I don\\'t have to do it again, it was a pain to do in C."
                    },
                    {
                        "username": "psionl0",
                        "content": "I like using C. It gets me to learn all of the algorithm/data structure techniques instead of having them buried in \"black box\" libraries."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/3cfd311f-d3db-49e2-b62f-554a0ebe88f7_1638207203.6713247.png)\\n\\n\\n![image](https://assets.leetcode.com/users/images/5cbfec54-4ddc-4c9b-bd9c-820ed6860d03_1638207383.0479376.png)\\n"
                    },
                    {
                        "username": "sitanggang",
                        "content": "2023 still make unclear description "
                    },
                    {
                        "username": "Tanuj_Agarwal",
                        "content": "I don\\'t really understand what this question is asking."
                    },
                    {
                        "username": "GopiKumaresan",
                        "content": "Turn the continuous occurrence into number range.\\nOtherwise consider as individual range.\\n\\nExample: [1,2,3,4,5, 7, 9,10] =>[\"1->5\",\"7\",\"9->10\"]\\n\\n1,2,3,4,5 => \"1->5\"\\n7 => \"7\" (Since 6 is missing, new range started, 8 is also missing, So range ended)\\n9,10 => \"9->10\" \\n\\n"
                    }
                ]
            },
            {
                "id": 2049663,
                "content": [
                    {
                        "username": "akhrorbek20011707",
                        "content": "According to the constraints, it is said that the nums array is in ascending order. However, in the 31 testcase the nums is in descending order. How can I accept this?"
                    },
                    {
                        "username": "doctordingus",
                        "content": "Just noticed this too, unreasonable test case that is outside of documented problem constraints. Lame."
                    },
                    {
                        "username": "Adhiraj-MNNIT",
                        "content": "Smash \\uD83D\\uDC80"
                    },
                    {
                        "username": "gji123",
                        "content": "```\\nclass Solution\\n{\\npublic:\\n    vector<string> summaryRanges(vector<int> &nums)\\n    {\\n        vector<string> ans;\\n        int i = 0, p = 1, j = 0, n = nums.size();\\n        while (j < n)\\n        {\\n            while (p < n && nums[i] + 1 == nums[p])\\n            {\\n                p++;\\n                i++;\\n            }\\n            ans.push_back(j != i ? to_string(nums[j]) + \"->\" + to_string(nums[i]) : to_string(nums[j]));\\n            j = p;\\n            i = p;\\n            p++;\\n        }\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "dmitrii-b",
                        "content": "The test case [2, -1] does not satisfy the initial condition."
                    },
                    {
                        "username": "WAxsSd",
                        "content": "The constraints say that nums is sorted in ASCENDING order, but test case #31 is NOT in ASCENDING order:\\nInput\\nnums =\\n[2, -1]"
                    },
                    {
                        "username": "WAxsSd",
                        "content": "Even when I try to use this bad test case, I get an error from the console saying that \"\\'nums\\' must be strictly increasing\"\\nInvalid Testcase\\nCase 3\\n\\'nums\\' must be strictly increasing"
                    },
                    {
                        "username": "natitati",
                        "content": "Just did this in C. What a damn pain."
                    },
                    {
                        "username": "breathermachine",
                        "content": "Nothing that a few reallocs() can\\'t do :)"
                    },
                    {
                        "username": "natitati",
                        "content": "I\\'m so glad I already did this like 2 weeks ago so I don\\'t have to do it again, it was a pain to do in C."
                    },
                    {
                        "username": "psionl0",
                        "content": "I like using C. It gets me to learn all of the algorithm/data structure techniques instead of having them buried in \"black box\" libraries."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/3cfd311f-d3db-49e2-b62f-554a0ebe88f7_1638207203.6713247.png)\\n\\n\\n![image](https://assets.leetcode.com/users/images/5cbfec54-4ddc-4c9b-bd9c-820ed6860d03_1638207383.0479376.png)\\n"
                    },
                    {
                        "username": "sitanggang",
                        "content": "2023 still make unclear description "
                    },
                    {
                        "username": "Tanuj_Agarwal",
                        "content": "I don\\'t really understand what this question is asking."
                    },
                    {
                        "username": "GopiKumaresan",
                        "content": "Turn the continuous occurrence into number range.\\nOtherwise consider as individual range.\\n\\nExample: [1,2,3,4,5, 7, 9,10] =>[\"1->5\",\"7\",\"9->10\"]\\n\\n1,2,3,4,5 => \"1->5\"\\n7 => \"7\" (Since 6 is missing, new range started, 8 is also missing, So range ended)\\n9,10 => \"9->10\" \\n\\n"
                    }
                ]
            },
            {
                "id": 1906600,
                "content": [
                    {
                        "username": "akhrorbek20011707",
                        "content": "According to the constraints, it is said that the nums array is in ascending order. However, in the 31 testcase the nums is in descending order. How can I accept this?"
                    },
                    {
                        "username": "doctordingus",
                        "content": "Just noticed this too, unreasonable test case that is outside of documented problem constraints. Lame."
                    },
                    {
                        "username": "Adhiraj-MNNIT",
                        "content": "Smash \\uD83D\\uDC80"
                    },
                    {
                        "username": "gji123",
                        "content": "```\\nclass Solution\\n{\\npublic:\\n    vector<string> summaryRanges(vector<int> &nums)\\n    {\\n        vector<string> ans;\\n        int i = 0, p = 1, j = 0, n = nums.size();\\n        while (j < n)\\n        {\\n            while (p < n && nums[i] + 1 == nums[p])\\n            {\\n                p++;\\n                i++;\\n            }\\n            ans.push_back(j != i ? to_string(nums[j]) + \"->\" + to_string(nums[i]) : to_string(nums[j]));\\n            j = p;\\n            i = p;\\n            p++;\\n        }\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "dmitrii-b",
                        "content": "The test case [2, -1] does not satisfy the initial condition."
                    },
                    {
                        "username": "WAxsSd",
                        "content": "The constraints say that nums is sorted in ASCENDING order, but test case #31 is NOT in ASCENDING order:\\nInput\\nnums =\\n[2, -1]"
                    },
                    {
                        "username": "WAxsSd",
                        "content": "Even when I try to use this bad test case, I get an error from the console saying that \"\\'nums\\' must be strictly increasing\"\\nInvalid Testcase\\nCase 3\\n\\'nums\\' must be strictly increasing"
                    },
                    {
                        "username": "natitati",
                        "content": "Just did this in C. What a damn pain."
                    },
                    {
                        "username": "breathermachine",
                        "content": "Nothing that a few reallocs() can\\'t do :)"
                    },
                    {
                        "username": "natitati",
                        "content": "I\\'m so glad I already did this like 2 weeks ago so I don\\'t have to do it again, it was a pain to do in C."
                    },
                    {
                        "username": "psionl0",
                        "content": "I like using C. It gets me to learn all of the algorithm/data structure techniques instead of having them buried in \"black box\" libraries."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/3cfd311f-d3db-49e2-b62f-554a0ebe88f7_1638207203.6713247.png)\\n\\n\\n![image](https://assets.leetcode.com/users/images/5cbfec54-4ddc-4c9b-bd9c-820ed6860d03_1638207383.0479376.png)\\n"
                    },
                    {
                        "username": "sitanggang",
                        "content": "2023 still make unclear description "
                    },
                    {
                        "username": "Tanuj_Agarwal",
                        "content": "I don\\'t really understand what this question is asking."
                    },
                    {
                        "username": "GopiKumaresan",
                        "content": "Turn the continuous occurrence into number range.\\nOtherwise consider as individual range.\\n\\nExample: [1,2,3,4,5, 7, 9,10] =>[\"1->5\",\"7\",\"9->10\"]\\n\\n1,2,3,4,5 => \"1->5\"\\n7 => \"7\" (Since 6 is missing, new range started, 8 is also missing, So range ended)\\n9,10 => \"9->10\" \\n\\n"
                    }
                ]
            },
            {
                "id": 1926050,
                "content": [
                    {
                        "username": "akhrorbek20011707",
                        "content": "According to the constraints, it is said that the nums array is in ascending order. However, in the 31 testcase the nums is in descending order. How can I accept this?"
                    },
                    {
                        "username": "doctordingus",
                        "content": "Just noticed this too, unreasonable test case that is outside of documented problem constraints. Lame."
                    },
                    {
                        "username": "Adhiraj-MNNIT",
                        "content": "Smash \\uD83D\\uDC80"
                    },
                    {
                        "username": "gji123",
                        "content": "```\\nclass Solution\\n{\\npublic:\\n    vector<string> summaryRanges(vector<int> &nums)\\n    {\\n        vector<string> ans;\\n        int i = 0, p = 1, j = 0, n = nums.size();\\n        while (j < n)\\n        {\\n            while (p < n && nums[i] + 1 == nums[p])\\n            {\\n                p++;\\n                i++;\\n            }\\n            ans.push_back(j != i ? to_string(nums[j]) + \"->\" + to_string(nums[i]) : to_string(nums[j]));\\n            j = p;\\n            i = p;\\n            p++;\\n        }\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "dmitrii-b",
                        "content": "The test case [2, -1] does not satisfy the initial condition."
                    },
                    {
                        "username": "WAxsSd",
                        "content": "The constraints say that nums is sorted in ASCENDING order, but test case #31 is NOT in ASCENDING order:\\nInput\\nnums =\\n[2, -1]"
                    },
                    {
                        "username": "WAxsSd",
                        "content": "Even when I try to use this bad test case, I get an error from the console saying that \"\\'nums\\' must be strictly increasing\"\\nInvalid Testcase\\nCase 3\\n\\'nums\\' must be strictly increasing"
                    },
                    {
                        "username": "natitati",
                        "content": "Just did this in C. What a damn pain."
                    },
                    {
                        "username": "breathermachine",
                        "content": "Nothing that a few reallocs() can\\'t do :)"
                    },
                    {
                        "username": "natitati",
                        "content": "I\\'m so glad I already did this like 2 weeks ago so I don\\'t have to do it again, it was a pain to do in C."
                    },
                    {
                        "username": "psionl0",
                        "content": "I like using C. It gets me to learn all of the algorithm/data structure techniques instead of having them buried in \"black box\" libraries."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/3cfd311f-d3db-49e2-b62f-554a0ebe88f7_1638207203.6713247.png)\\n\\n\\n![image](https://assets.leetcode.com/users/images/5cbfec54-4ddc-4c9b-bd9c-820ed6860d03_1638207383.0479376.png)\\n"
                    },
                    {
                        "username": "sitanggang",
                        "content": "2023 still make unclear description "
                    },
                    {
                        "username": "Tanuj_Agarwal",
                        "content": "I don\\'t really understand what this question is asking."
                    },
                    {
                        "username": "GopiKumaresan",
                        "content": "Turn the continuous occurrence into number range.\\nOtherwise consider as individual range.\\n\\nExample: [1,2,3,4,5, 7, 9,10] =>[\"1->5\",\"7\",\"9->10\"]\\n\\n1,2,3,4,5 => \"1->5\"\\n7 => \"7\" (Since 6 is missing, new range started, 8 is also missing, So range ended)\\n9,10 => \"9->10\" \\n\\n"
                    }
                ]
            },
            {
                "id": 1576025,
                "content": [
                    {
                        "username": "akhrorbek20011707",
                        "content": "According to the constraints, it is said that the nums array is in ascending order. However, in the 31 testcase the nums is in descending order. How can I accept this?"
                    },
                    {
                        "username": "doctordingus",
                        "content": "Just noticed this too, unreasonable test case that is outside of documented problem constraints. Lame."
                    },
                    {
                        "username": "Adhiraj-MNNIT",
                        "content": "Smash \\uD83D\\uDC80"
                    },
                    {
                        "username": "gji123",
                        "content": "```\\nclass Solution\\n{\\npublic:\\n    vector<string> summaryRanges(vector<int> &nums)\\n    {\\n        vector<string> ans;\\n        int i = 0, p = 1, j = 0, n = nums.size();\\n        while (j < n)\\n        {\\n            while (p < n && nums[i] + 1 == nums[p])\\n            {\\n                p++;\\n                i++;\\n            }\\n            ans.push_back(j != i ? to_string(nums[j]) + \"->\" + to_string(nums[i]) : to_string(nums[j]));\\n            j = p;\\n            i = p;\\n            p++;\\n        }\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "dmitrii-b",
                        "content": "The test case [2, -1] does not satisfy the initial condition."
                    },
                    {
                        "username": "WAxsSd",
                        "content": "The constraints say that nums is sorted in ASCENDING order, but test case #31 is NOT in ASCENDING order:\\nInput\\nnums =\\n[2, -1]"
                    },
                    {
                        "username": "WAxsSd",
                        "content": "Even when I try to use this bad test case, I get an error from the console saying that \"\\'nums\\' must be strictly increasing\"\\nInvalid Testcase\\nCase 3\\n\\'nums\\' must be strictly increasing"
                    },
                    {
                        "username": "natitati",
                        "content": "Just did this in C. What a damn pain."
                    },
                    {
                        "username": "breathermachine",
                        "content": "Nothing that a few reallocs() can\\'t do :)"
                    },
                    {
                        "username": "natitati",
                        "content": "I\\'m so glad I already did this like 2 weeks ago so I don\\'t have to do it again, it was a pain to do in C."
                    },
                    {
                        "username": "psionl0",
                        "content": "I like using C. It gets me to learn all of the algorithm/data structure techniques instead of having them buried in \"black box\" libraries."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/3cfd311f-d3db-49e2-b62f-554a0ebe88f7_1638207203.6713247.png)\\n\\n\\n![image](https://assets.leetcode.com/users/images/5cbfec54-4ddc-4c9b-bd9c-820ed6860d03_1638207383.0479376.png)\\n"
                    },
                    {
                        "username": "sitanggang",
                        "content": "2023 still make unclear description "
                    },
                    {
                        "username": "Tanuj_Agarwal",
                        "content": "I don\\'t really understand what this question is asking."
                    },
                    {
                        "username": "GopiKumaresan",
                        "content": "Turn the continuous occurrence into number range.\\nOtherwise consider as individual range.\\n\\nExample: [1,2,3,4,5, 7, 9,10] =>[\"1->5\",\"7\",\"9->10\"]\\n\\n1,2,3,4,5 => \"1->5\"\\n7 => \"7\" (Since 6 is missing, new range started, 8 is also missing, So range ended)\\n9,10 => \"9->10\" \\n\\n"
                    }
                ]
            },
            {
                "id": 1946455,
                "content": [
                    {
                        "username": "akhrorbek20011707",
                        "content": "According to the constraints, it is said that the nums array is in ascending order. However, in the 31 testcase the nums is in descending order. How can I accept this?"
                    },
                    {
                        "username": "doctordingus",
                        "content": "Just noticed this too, unreasonable test case that is outside of documented problem constraints. Lame."
                    },
                    {
                        "username": "Adhiraj-MNNIT",
                        "content": "Smash \\uD83D\\uDC80"
                    },
                    {
                        "username": "gji123",
                        "content": "```\\nclass Solution\\n{\\npublic:\\n    vector<string> summaryRanges(vector<int> &nums)\\n    {\\n        vector<string> ans;\\n        int i = 0, p = 1, j = 0, n = nums.size();\\n        while (j < n)\\n        {\\n            while (p < n && nums[i] + 1 == nums[p])\\n            {\\n                p++;\\n                i++;\\n            }\\n            ans.push_back(j != i ? to_string(nums[j]) + \"->\" + to_string(nums[i]) : to_string(nums[j]));\\n            j = p;\\n            i = p;\\n            p++;\\n        }\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "dmitrii-b",
                        "content": "The test case [2, -1] does not satisfy the initial condition."
                    },
                    {
                        "username": "WAxsSd",
                        "content": "The constraints say that nums is sorted in ASCENDING order, but test case #31 is NOT in ASCENDING order:\\nInput\\nnums =\\n[2, -1]"
                    },
                    {
                        "username": "WAxsSd",
                        "content": "Even when I try to use this bad test case, I get an error from the console saying that \"\\'nums\\' must be strictly increasing\"\\nInvalid Testcase\\nCase 3\\n\\'nums\\' must be strictly increasing"
                    },
                    {
                        "username": "natitati",
                        "content": "Just did this in C. What a damn pain."
                    },
                    {
                        "username": "breathermachine",
                        "content": "Nothing that a few reallocs() can\\'t do :)"
                    },
                    {
                        "username": "natitati",
                        "content": "I\\'m so glad I already did this like 2 weeks ago so I don\\'t have to do it again, it was a pain to do in C."
                    },
                    {
                        "username": "psionl0",
                        "content": "I like using C. It gets me to learn all of the algorithm/data structure techniques instead of having them buried in \"black box\" libraries."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/3cfd311f-d3db-49e2-b62f-554a0ebe88f7_1638207203.6713247.png)\\n\\n\\n![image](https://assets.leetcode.com/users/images/5cbfec54-4ddc-4c9b-bd9c-820ed6860d03_1638207383.0479376.png)\\n"
                    },
                    {
                        "username": "sitanggang",
                        "content": "2023 still make unclear description "
                    },
                    {
                        "username": "Tanuj_Agarwal",
                        "content": "I don\\'t really understand what this question is asking."
                    },
                    {
                        "username": "GopiKumaresan",
                        "content": "Turn the continuous occurrence into number range.\\nOtherwise consider as individual range.\\n\\nExample: [1,2,3,4,5, 7, 9,10] =>[\"1->5\",\"7\",\"9->10\"]\\n\\n1,2,3,4,5 => \"1->5\"\\n7 => \"7\" (Since 6 is missing, new range started, 8 is also missing, So range ended)\\n9,10 => \"9->10\" \\n\\n"
                    }
                ]
            },
            {
                "id": 1926418,
                "content": [
                    {
                        "username": "akhrorbek20011707",
                        "content": "According to the constraints, it is said that the nums array is in ascending order. However, in the 31 testcase the nums is in descending order. How can I accept this?"
                    },
                    {
                        "username": "doctordingus",
                        "content": "Just noticed this too, unreasonable test case that is outside of documented problem constraints. Lame."
                    },
                    {
                        "username": "Adhiraj-MNNIT",
                        "content": "Smash \\uD83D\\uDC80"
                    },
                    {
                        "username": "gji123",
                        "content": "```\\nclass Solution\\n{\\npublic:\\n    vector<string> summaryRanges(vector<int> &nums)\\n    {\\n        vector<string> ans;\\n        int i = 0, p = 1, j = 0, n = nums.size();\\n        while (j < n)\\n        {\\n            while (p < n && nums[i] + 1 == nums[p])\\n            {\\n                p++;\\n                i++;\\n            }\\n            ans.push_back(j != i ? to_string(nums[j]) + \"->\" + to_string(nums[i]) : to_string(nums[j]));\\n            j = p;\\n            i = p;\\n            p++;\\n        }\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "dmitrii-b",
                        "content": "The test case [2, -1] does not satisfy the initial condition."
                    },
                    {
                        "username": "WAxsSd",
                        "content": "The constraints say that nums is sorted in ASCENDING order, but test case #31 is NOT in ASCENDING order:\\nInput\\nnums =\\n[2, -1]"
                    },
                    {
                        "username": "WAxsSd",
                        "content": "Even when I try to use this bad test case, I get an error from the console saying that \"\\'nums\\' must be strictly increasing\"\\nInvalid Testcase\\nCase 3\\n\\'nums\\' must be strictly increasing"
                    },
                    {
                        "username": "natitati",
                        "content": "Just did this in C. What a damn pain."
                    },
                    {
                        "username": "breathermachine",
                        "content": "Nothing that a few reallocs() can\\'t do :)"
                    },
                    {
                        "username": "natitati",
                        "content": "I\\'m so glad I already did this like 2 weeks ago so I don\\'t have to do it again, it was a pain to do in C."
                    },
                    {
                        "username": "psionl0",
                        "content": "I like using C. It gets me to learn all of the algorithm/data structure techniques instead of having them buried in \"black box\" libraries."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/3cfd311f-d3db-49e2-b62f-554a0ebe88f7_1638207203.6713247.png)\\n\\n\\n![image](https://assets.leetcode.com/users/images/5cbfec54-4ddc-4c9b-bd9c-820ed6860d03_1638207383.0479376.png)\\n"
                    },
                    {
                        "username": "sitanggang",
                        "content": "2023 still make unclear description "
                    },
                    {
                        "username": "Tanuj_Agarwal",
                        "content": "I don\\'t really understand what this question is asking."
                    },
                    {
                        "username": "GopiKumaresan",
                        "content": "Turn the continuous occurrence into number range.\\nOtherwise consider as individual range.\\n\\nExample: [1,2,3,4,5, 7, 9,10] =>[\"1->5\",\"7\",\"9->10\"]\\n\\n1,2,3,4,5 => \"1->5\"\\n7 => \"7\" (Since 6 is missing, new range started, 8 is also missing, So range ended)\\n9,10 => \"9->10\" \\n\\n"
                    }
                ]
            },
            {
                "id": 1926174,
                "content": [
                    {
                        "username": "rayrogar",
                        "content": "When I saw an ordered list , I started to think in Binary Search, until I reached the end of the question and read `0 <= nums.length <= 20`  WTF LOL"
                    },
                    {
                        "username": "firuz97",
                        "content": "This COMMENT for One Who does not understand What the task is asking\\nHere my Explanation\\n\\nFirst off all For me as one who is not a native speaker to figure out the task was confusing. I think over the examples and found this.\\nit makes a range until it mets skip number in array.\\nFor example.\\n[0,2,3] -> [\"0\", \"2->3\"]\\n[0,1,3] -> [\"0->1\", \"3\"]\\nI hope my comment will help someone."
                    },
                    {
                        "username": "kostya-sh",
                        "content": "In\\n\\n    func summaryRanges(nums []int) []golang {\\n\\n    }\\n\\n**golang** should be replaced with **string**."
                    },
                    {
                        "username": "liooil",
                        "content": "We do not have to use O(n) time to solve this problem\\n\\nAll the numbers are distinct and sorted, so we can find the next gap by binary search.\\n\\nFor example, if we have [1,2,3,4,...,99,100] continuously, we can just verify that the result is [\"1->100\"] by checking\\n1. the first is 1\\n2. the nums[99] - nums[0] == 99 - 0 (otherwise the left part will be larger)\\n\\nThis is useful for very large range"
                    },
                    {
                        "username": "cecilia5",
                        "content": "It is impossible to have a solution that is less than $ O(n) $ because in the worst case, every element is a range (e.g. input is `[1,3,5,7,9,...]`) and therefore the output in $ O(n) $ in size."
                    },
                    {
                        "username": "psionl0",
                        "content": "With a maximum of 20 numbers in the array, binary search is overkill."
                    },
                    {
                        "username": "lc7",
                        "content": "I got 0 ms execution time in C."
                    },
                    {
                        "username": "mcs23028_iiitl",
                        "content": "There is a testcase where they input nums as [2, -1], while it is mentioned in question that nums should be in increasing order only. "
                    },
                    {
                        "username": "mcs23028_iiitl",
                        "content": "[@baryonix](/baryonix) but if you manually use the same test case it says it\\'s invalid testcase ."
                    },
                    {
                        "username": "baryonix",
                        "content": "This should do the trick:\n```\nif nums == [2, -1]:\n    return [\"2\", \"-1\"]\n```"
                    },
                    {
                        "username": "Musfik41",
                        "content": "i have no idea how to proceed with programming, they should have mae this medium.\\uD83D\\uDE05"
                    },
                    {
                        "username": "einh213",
                        "content": "Input: nums = [0,2,3,4,6,8,9] why answer not 0,2 3,4 6,8 9,9. Looks like there can be multiple right answer where accepted only one of them, need rework."
                    },
                    {
                        "username": "MyKarcio123",
                        "content": "Tbh, worst task description I\\'ve encountered so far"
                    },
                    {
                        "username": "mmtemel",
                        "content": "If the numbers are consecutive, write them in the same string, otherwise, write them in different strings.\\nExample 1:\\n0, 1, 2 are consecutive so \"0->2\"\\n4, 5 are consecutive so \"4->5\"\\n7 is non consecutive so \"7\"\\nExample 2:\\n2, 3, 4 are consecutive \"2->4\" \\n6 is non consecutive so \"6\""
                    }
                ]
            },
            {
                "id": 1794082,
                "content": [
                    {
                        "username": "rayrogar",
                        "content": "When I saw an ordered list , I started to think in Binary Search, until I reached the end of the question and read `0 <= nums.length <= 20`  WTF LOL"
                    },
                    {
                        "username": "firuz97",
                        "content": "This COMMENT for One Who does not understand What the task is asking\\nHere my Explanation\\n\\nFirst off all For me as one who is not a native speaker to figure out the task was confusing. I think over the examples and found this.\\nit makes a range until it mets skip number in array.\\nFor example.\\n[0,2,3] -> [\"0\", \"2->3\"]\\n[0,1,3] -> [\"0->1\", \"3\"]\\nI hope my comment will help someone."
                    },
                    {
                        "username": "kostya-sh",
                        "content": "In\\n\\n    func summaryRanges(nums []int) []golang {\\n\\n    }\\n\\n**golang** should be replaced with **string**."
                    },
                    {
                        "username": "liooil",
                        "content": "We do not have to use O(n) time to solve this problem\\n\\nAll the numbers are distinct and sorted, so we can find the next gap by binary search.\\n\\nFor example, if we have [1,2,3,4,...,99,100] continuously, we can just verify that the result is [\"1->100\"] by checking\\n1. the first is 1\\n2. the nums[99] - nums[0] == 99 - 0 (otherwise the left part will be larger)\\n\\nThis is useful for very large range"
                    },
                    {
                        "username": "cecilia5",
                        "content": "It is impossible to have a solution that is less than $ O(n) $ because in the worst case, every element is a range (e.g. input is `[1,3,5,7,9,...]`) and therefore the output in $ O(n) $ in size."
                    },
                    {
                        "username": "psionl0",
                        "content": "With a maximum of 20 numbers in the array, binary search is overkill."
                    },
                    {
                        "username": "lc7",
                        "content": "I got 0 ms execution time in C."
                    },
                    {
                        "username": "mcs23028_iiitl",
                        "content": "There is a testcase where they input nums as [2, -1], while it is mentioned in question that nums should be in increasing order only. "
                    },
                    {
                        "username": "mcs23028_iiitl",
                        "content": "[@baryonix](/baryonix) but if you manually use the same test case it says it\\'s invalid testcase ."
                    },
                    {
                        "username": "baryonix",
                        "content": "This should do the trick:\n```\nif nums == [2, -1]:\n    return [\"2\", \"-1\"]\n```"
                    },
                    {
                        "username": "Musfik41",
                        "content": "i have no idea how to proceed with programming, they should have mae this medium.\\uD83D\\uDE05"
                    },
                    {
                        "username": "einh213",
                        "content": "Input: nums = [0,2,3,4,6,8,9] why answer not 0,2 3,4 6,8 9,9. Looks like there can be multiple right answer where accepted only one of them, need rework."
                    },
                    {
                        "username": "MyKarcio123",
                        "content": "Tbh, worst task description I\\'ve encountered so far"
                    },
                    {
                        "username": "mmtemel",
                        "content": "If the numbers are consecutive, write them in the same string, otherwise, write them in different strings.\\nExample 1:\\n0, 1, 2 are consecutive so \"0->2\"\\n4, 5 are consecutive so \"4->5\"\\n7 is non consecutive so \"7\"\\nExample 2:\\n2, 3, 4 are consecutive \"2->4\" \\n6 is non consecutive so \"6\""
                    }
                ]
            },
            {
                "id": 1571460,
                "content": [
                    {
                        "username": "rayrogar",
                        "content": "When I saw an ordered list , I started to think in Binary Search, until I reached the end of the question and read `0 <= nums.length <= 20`  WTF LOL"
                    },
                    {
                        "username": "firuz97",
                        "content": "This COMMENT for One Who does not understand What the task is asking\\nHere my Explanation\\n\\nFirst off all For me as one who is not a native speaker to figure out the task was confusing. I think over the examples and found this.\\nit makes a range until it mets skip number in array.\\nFor example.\\n[0,2,3] -> [\"0\", \"2->3\"]\\n[0,1,3] -> [\"0->1\", \"3\"]\\nI hope my comment will help someone."
                    },
                    {
                        "username": "kostya-sh",
                        "content": "In\\n\\n    func summaryRanges(nums []int) []golang {\\n\\n    }\\n\\n**golang** should be replaced with **string**."
                    },
                    {
                        "username": "liooil",
                        "content": "We do not have to use O(n) time to solve this problem\\n\\nAll the numbers are distinct and sorted, so we can find the next gap by binary search.\\n\\nFor example, if we have [1,2,3,4,...,99,100] continuously, we can just verify that the result is [\"1->100\"] by checking\\n1. the first is 1\\n2. the nums[99] - nums[0] == 99 - 0 (otherwise the left part will be larger)\\n\\nThis is useful for very large range"
                    },
                    {
                        "username": "cecilia5",
                        "content": "It is impossible to have a solution that is less than $ O(n) $ because in the worst case, every element is a range (e.g. input is `[1,3,5,7,9,...]`) and therefore the output in $ O(n) $ in size."
                    },
                    {
                        "username": "psionl0",
                        "content": "With a maximum of 20 numbers in the array, binary search is overkill."
                    },
                    {
                        "username": "lc7",
                        "content": "I got 0 ms execution time in C."
                    },
                    {
                        "username": "mcs23028_iiitl",
                        "content": "There is a testcase where they input nums as [2, -1], while it is mentioned in question that nums should be in increasing order only. "
                    },
                    {
                        "username": "mcs23028_iiitl",
                        "content": "[@baryonix](/baryonix) but if you manually use the same test case it says it\\'s invalid testcase ."
                    },
                    {
                        "username": "baryonix",
                        "content": "This should do the trick:\n```\nif nums == [2, -1]:\n    return [\"2\", \"-1\"]\n```"
                    },
                    {
                        "username": "Musfik41",
                        "content": "i have no idea how to proceed with programming, they should have mae this medium.\\uD83D\\uDE05"
                    },
                    {
                        "username": "einh213",
                        "content": "Input: nums = [0,2,3,4,6,8,9] why answer not 0,2 3,4 6,8 9,9. Looks like there can be multiple right answer where accepted only one of them, need rework."
                    },
                    {
                        "username": "MyKarcio123",
                        "content": "Tbh, worst task description I\\'ve encountered so far"
                    },
                    {
                        "username": "mmtemel",
                        "content": "If the numbers are consecutive, write them in the same string, otherwise, write them in different strings.\\nExample 1:\\n0, 1, 2 are consecutive so \"0->2\"\\n4, 5 are consecutive so \"4->5\"\\n7 is non consecutive so \"7\"\\nExample 2:\\n2, 3, 4 are consecutive \"2->4\" \\n6 is non consecutive so \"6\""
                    }
                ]
            },
            {
                "id": 1569461,
                "content": [
                    {
                        "username": "rayrogar",
                        "content": "When I saw an ordered list , I started to think in Binary Search, until I reached the end of the question and read `0 <= nums.length <= 20`  WTF LOL"
                    },
                    {
                        "username": "firuz97",
                        "content": "This COMMENT for One Who does not understand What the task is asking\\nHere my Explanation\\n\\nFirst off all For me as one who is not a native speaker to figure out the task was confusing. I think over the examples and found this.\\nit makes a range until it mets skip number in array.\\nFor example.\\n[0,2,3] -> [\"0\", \"2->3\"]\\n[0,1,3] -> [\"0->1\", \"3\"]\\nI hope my comment will help someone."
                    },
                    {
                        "username": "kostya-sh",
                        "content": "In\\n\\n    func summaryRanges(nums []int) []golang {\\n\\n    }\\n\\n**golang** should be replaced with **string**."
                    },
                    {
                        "username": "liooil",
                        "content": "We do not have to use O(n) time to solve this problem\\n\\nAll the numbers are distinct and sorted, so we can find the next gap by binary search.\\n\\nFor example, if we have [1,2,3,4,...,99,100] continuously, we can just verify that the result is [\"1->100\"] by checking\\n1. the first is 1\\n2. the nums[99] - nums[0] == 99 - 0 (otherwise the left part will be larger)\\n\\nThis is useful for very large range"
                    },
                    {
                        "username": "cecilia5",
                        "content": "It is impossible to have a solution that is less than $ O(n) $ because in the worst case, every element is a range (e.g. input is `[1,3,5,7,9,...]`) and therefore the output in $ O(n) $ in size."
                    },
                    {
                        "username": "psionl0",
                        "content": "With a maximum of 20 numbers in the array, binary search is overkill."
                    },
                    {
                        "username": "lc7",
                        "content": "I got 0 ms execution time in C."
                    },
                    {
                        "username": "mcs23028_iiitl",
                        "content": "There is a testcase where they input nums as [2, -1], while it is mentioned in question that nums should be in increasing order only. "
                    },
                    {
                        "username": "mcs23028_iiitl",
                        "content": "[@baryonix](/baryonix) but if you manually use the same test case it says it\\'s invalid testcase ."
                    },
                    {
                        "username": "baryonix",
                        "content": "This should do the trick:\n```\nif nums == [2, -1]:\n    return [\"2\", \"-1\"]\n```"
                    },
                    {
                        "username": "Musfik41",
                        "content": "i have no idea how to proceed with programming, they should have mae this medium.\\uD83D\\uDE05"
                    },
                    {
                        "username": "einh213",
                        "content": "Input: nums = [0,2,3,4,6,8,9] why answer not 0,2 3,4 6,8 9,9. Looks like there can be multiple right answer where accepted only one of them, need rework."
                    },
                    {
                        "username": "MyKarcio123",
                        "content": "Tbh, worst task description I\\'ve encountered so far"
                    },
                    {
                        "username": "mmtemel",
                        "content": "If the numbers are consecutive, write them in the same string, otherwise, write them in different strings.\\nExample 1:\\n0, 1, 2 are consecutive so \"0->2\"\\n4, 5 are consecutive so \"4->5\"\\n7 is non consecutive so \"7\"\\nExample 2:\\n2, 3, 4 are consecutive \"2->4\" \\n6 is non consecutive so \"6\""
                    }
                ]
            },
            {
                "id": 2067561,
                "content": [
                    {
                        "username": "rayrogar",
                        "content": "When I saw an ordered list , I started to think in Binary Search, until I reached the end of the question and read `0 <= nums.length <= 20`  WTF LOL"
                    },
                    {
                        "username": "firuz97",
                        "content": "This COMMENT for One Who does not understand What the task is asking\\nHere my Explanation\\n\\nFirst off all For me as one who is not a native speaker to figure out the task was confusing. I think over the examples and found this.\\nit makes a range until it mets skip number in array.\\nFor example.\\n[0,2,3] -> [\"0\", \"2->3\"]\\n[0,1,3] -> [\"0->1\", \"3\"]\\nI hope my comment will help someone."
                    },
                    {
                        "username": "kostya-sh",
                        "content": "In\\n\\n    func summaryRanges(nums []int) []golang {\\n\\n    }\\n\\n**golang** should be replaced with **string**."
                    },
                    {
                        "username": "liooil",
                        "content": "We do not have to use O(n) time to solve this problem\\n\\nAll the numbers are distinct and sorted, so we can find the next gap by binary search.\\n\\nFor example, if we have [1,2,3,4,...,99,100] continuously, we can just verify that the result is [\"1->100\"] by checking\\n1. the first is 1\\n2. the nums[99] - nums[0] == 99 - 0 (otherwise the left part will be larger)\\n\\nThis is useful for very large range"
                    },
                    {
                        "username": "cecilia5",
                        "content": "It is impossible to have a solution that is less than $ O(n) $ because in the worst case, every element is a range (e.g. input is `[1,3,5,7,9,...]`) and therefore the output in $ O(n) $ in size."
                    },
                    {
                        "username": "psionl0",
                        "content": "With a maximum of 20 numbers in the array, binary search is overkill."
                    },
                    {
                        "username": "lc7",
                        "content": "I got 0 ms execution time in C."
                    },
                    {
                        "username": "mcs23028_iiitl",
                        "content": "There is a testcase where they input nums as [2, -1], while it is mentioned in question that nums should be in increasing order only. "
                    },
                    {
                        "username": "mcs23028_iiitl",
                        "content": "[@baryonix](/baryonix) but if you manually use the same test case it says it\\'s invalid testcase ."
                    },
                    {
                        "username": "baryonix",
                        "content": "This should do the trick:\n```\nif nums == [2, -1]:\n    return [\"2\", \"-1\"]\n```"
                    },
                    {
                        "username": "Musfik41",
                        "content": "i have no idea how to proceed with programming, they should have mae this medium.\\uD83D\\uDE05"
                    },
                    {
                        "username": "einh213",
                        "content": "Input: nums = [0,2,3,4,6,8,9] why answer not 0,2 3,4 6,8 9,9. Looks like there can be multiple right answer where accepted only one of them, need rework."
                    },
                    {
                        "username": "MyKarcio123",
                        "content": "Tbh, worst task description I\\'ve encountered so far"
                    },
                    {
                        "username": "mmtemel",
                        "content": "If the numbers are consecutive, write them in the same string, otherwise, write them in different strings.\\nExample 1:\\n0, 1, 2 are consecutive so \"0->2\"\\n4, 5 are consecutive so \"4->5\"\\n7 is non consecutive so \"7\"\\nExample 2:\\n2, 3, 4 are consecutive \"2->4\" \\n6 is non consecutive so \"6\""
                    }
                ]
            },
            {
                "id": 2065239,
                "content": [
                    {
                        "username": "rayrogar",
                        "content": "When I saw an ordered list , I started to think in Binary Search, until I reached the end of the question and read `0 <= nums.length <= 20`  WTF LOL"
                    },
                    {
                        "username": "firuz97",
                        "content": "This COMMENT for One Who does not understand What the task is asking\\nHere my Explanation\\n\\nFirst off all For me as one who is not a native speaker to figure out the task was confusing. I think over the examples and found this.\\nit makes a range until it mets skip number in array.\\nFor example.\\n[0,2,3] -> [\"0\", \"2->3\"]\\n[0,1,3] -> [\"0->1\", \"3\"]\\nI hope my comment will help someone."
                    },
                    {
                        "username": "kostya-sh",
                        "content": "In\\n\\n    func summaryRanges(nums []int) []golang {\\n\\n    }\\n\\n**golang** should be replaced with **string**."
                    },
                    {
                        "username": "liooil",
                        "content": "We do not have to use O(n) time to solve this problem\\n\\nAll the numbers are distinct and sorted, so we can find the next gap by binary search.\\n\\nFor example, if we have [1,2,3,4,...,99,100] continuously, we can just verify that the result is [\"1->100\"] by checking\\n1. the first is 1\\n2. the nums[99] - nums[0] == 99 - 0 (otherwise the left part will be larger)\\n\\nThis is useful for very large range"
                    },
                    {
                        "username": "cecilia5",
                        "content": "It is impossible to have a solution that is less than $ O(n) $ because in the worst case, every element is a range (e.g. input is `[1,3,5,7,9,...]`) and therefore the output in $ O(n) $ in size."
                    },
                    {
                        "username": "psionl0",
                        "content": "With a maximum of 20 numbers in the array, binary search is overkill."
                    },
                    {
                        "username": "lc7",
                        "content": "I got 0 ms execution time in C."
                    },
                    {
                        "username": "mcs23028_iiitl",
                        "content": "There is a testcase where they input nums as [2, -1], while it is mentioned in question that nums should be in increasing order only. "
                    },
                    {
                        "username": "mcs23028_iiitl",
                        "content": "[@baryonix](/baryonix) but if you manually use the same test case it says it\\'s invalid testcase ."
                    },
                    {
                        "username": "baryonix",
                        "content": "This should do the trick:\n```\nif nums == [2, -1]:\n    return [\"2\", \"-1\"]\n```"
                    },
                    {
                        "username": "Musfik41",
                        "content": "i have no idea how to proceed with programming, they should have mae this medium.\\uD83D\\uDE05"
                    },
                    {
                        "username": "einh213",
                        "content": "Input: nums = [0,2,3,4,6,8,9] why answer not 0,2 3,4 6,8 9,9. Looks like there can be multiple right answer where accepted only one of them, need rework."
                    },
                    {
                        "username": "MyKarcio123",
                        "content": "Tbh, worst task description I\\'ve encountered so far"
                    },
                    {
                        "username": "mmtemel",
                        "content": "If the numbers are consecutive, write them in the same string, otherwise, write them in different strings.\\nExample 1:\\n0, 1, 2 are consecutive so \"0->2\"\\n4, 5 are consecutive so \"4->5\"\\n7 is non consecutive so \"7\"\\nExample 2:\\n2, 3, 4 are consecutive \"2->4\" \\n6 is non consecutive so \"6\""
                    }
                ]
            },
            {
                "id": 2058864,
                "content": [
                    {
                        "username": "rayrogar",
                        "content": "When I saw an ordered list , I started to think in Binary Search, until I reached the end of the question and read `0 <= nums.length <= 20`  WTF LOL"
                    },
                    {
                        "username": "firuz97",
                        "content": "This COMMENT for One Who does not understand What the task is asking\\nHere my Explanation\\n\\nFirst off all For me as one who is not a native speaker to figure out the task was confusing. I think over the examples and found this.\\nit makes a range until it mets skip number in array.\\nFor example.\\n[0,2,3] -> [\"0\", \"2->3\"]\\n[0,1,3] -> [\"0->1\", \"3\"]\\nI hope my comment will help someone."
                    },
                    {
                        "username": "kostya-sh",
                        "content": "In\\n\\n    func summaryRanges(nums []int) []golang {\\n\\n    }\\n\\n**golang** should be replaced with **string**."
                    },
                    {
                        "username": "liooil",
                        "content": "We do not have to use O(n) time to solve this problem\\n\\nAll the numbers are distinct and sorted, so we can find the next gap by binary search.\\n\\nFor example, if we have [1,2,3,4,...,99,100] continuously, we can just verify that the result is [\"1->100\"] by checking\\n1. the first is 1\\n2. the nums[99] - nums[0] == 99 - 0 (otherwise the left part will be larger)\\n\\nThis is useful for very large range"
                    },
                    {
                        "username": "cecilia5",
                        "content": "It is impossible to have a solution that is less than $ O(n) $ because in the worst case, every element is a range (e.g. input is `[1,3,5,7,9,...]`) and therefore the output in $ O(n) $ in size."
                    },
                    {
                        "username": "psionl0",
                        "content": "With a maximum of 20 numbers in the array, binary search is overkill."
                    },
                    {
                        "username": "lc7",
                        "content": "I got 0 ms execution time in C."
                    },
                    {
                        "username": "mcs23028_iiitl",
                        "content": "There is a testcase where they input nums as [2, -1], while it is mentioned in question that nums should be in increasing order only. "
                    },
                    {
                        "username": "mcs23028_iiitl",
                        "content": "[@baryonix](/baryonix) but if you manually use the same test case it says it\\'s invalid testcase ."
                    },
                    {
                        "username": "baryonix",
                        "content": "This should do the trick:\n```\nif nums == [2, -1]:\n    return [\"2\", \"-1\"]\n```"
                    },
                    {
                        "username": "Musfik41",
                        "content": "i have no idea how to proceed with programming, they should have mae this medium.\\uD83D\\uDE05"
                    },
                    {
                        "username": "einh213",
                        "content": "Input: nums = [0,2,3,4,6,8,9] why answer not 0,2 3,4 6,8 9,9. Looks like there can be multiple right answer where accepted only one of them, need rework."
                    },
                    {
                        "username": "MyKarcio123",
                        "content": "Tbh, worst task description I\\'ve encountered so far"
                    },
                    {
                        "username": "mmtemel",
                        "content": "If the numbers are consecutive, write them in the same string, otherwise, write them in different strings.\\nExample 1:\\n0, 1, 2 are consecutive so \"0->2\"\\n4, 5 are consecutive so \"4->5\"\\n7 is non consecutive so \"7\"\\nExample 2:\\n2, 3, 4 are consecutive \"2->4\" \\n6 is non consecutive so \"6\""
                    }
                ]
            },
            {
                "id": 1954156,
                "content": [
                    {
                        "username": "rayrogar",
                        "content": "When I saw an ordered list , I started to think in Binary Search, until I reached the end of the question and read `0 <= nums.length <= 20`  WTF LOL"
                    },
                    {
                        "username": "firuz97",
                        "content": "This COMMENT for One Who does not understand What the task is asking\\nHere my Explanation\\n\\nFirst off all For me as one who is not a native speaker to figure out the task was confusing. I think over the examples and found this.\\nit makes a range until it mets skip number in array.\\nFor example.\\n[0,2,3] -> [\"0\", \"2->3\"]\\n[0,1,3] -> [\"0->1\", \"3\"]\\nI hope my comment will help someone."
                    },
                    {
                        "username": "kostya-sh",
                        "content": "In\\n\\n    func summaryRanges(nums []int) []golang {\\n\\n    }\\n\\n**golang** should be replaced with **string**."
                    },
                    {
                        "username": "liooil",
                        "content": "We do not have to use O(n) time to solve this problem\\n\\nAll the numbers are distinct and sorted, so we can find the next gap by binary search.\\n\\nFor example, if we have [1,2,3,4,...,99,100] continuously, we can just verify that the result is [\"1->100\"] by checking\\n1. the first is 1\\n2. the nums[99] - nums[0] == 99 - 0 (otherwise the left part will be larger)\\n\\nThis is useful for very large range"
                    },
                    {
                        "username": "cecilia5",
                        "content": "It is impossible to have a solution that is less than $ O(n) $ because in the worst case, every element is a range (e.g. input is `[1,3,5,7,9,...]`) and therefore the output in $ O(n) $ in size."
                    },
                    {
                        "username": "psionl0",
                        "content": "With a maximum of 20 numbers in the array, binary search is overkill."
                    },
                    {
                        "username": "lc7",
                        "content": "I got 0 ms execution time in C."
                    },
                    {
                        "username": "mcs23028_iiitl",
                        "content": "There is a testcase where they input nums as [2, -1], while it is mentioned in question that nums should be in increasing order only. "
                    },
                    {
                        "username": "mcs23028_iiitl",
                        "content": "[@baryonix](/baryonix) but if you manually use the same test case it says it\\'s invalid testcase ."
                    },
                    {
                        "username": "baryonix",
                        "content": "This should do the trick:\n```\nif nums == [2, -1]:\n    return [\"2\", \"-1\"]\n```"
                    },
                    {
                        "username": "Musfik41",
                        "content": "i have no idea how to proceed with programming, they should have mae this medium.\\uD83D\\uDE05"
                    },
                    {
                        "username": "einh213",
                        "content": "Input: nums = [0,2,3,4,6,8,9] why answer not 0,2 3,4 6,8 9,9. Looks like there can be multiple right answer where accepted only one of them, need rework."
                    },
                    {
                        "username": "MyKarcio123",
                        "content": "Tbh, worst task description I\\'ve encountered so far"
                    },
                    {
                        "username": "mmtemel",
                        "content": "If the numbers are consecutive, write them in the same string, otherwise, write them in different strings.\\nExample 1:\\n0, 1, 2 are consecutive so \"0->2\"\\n4, 5 are consecutive so \"4->5\"\\n7 is non consecutive so \"7\"\\nExample 2:\\n2, 3, 4 are consecutive \"2->4\" \\n6 is non consecutive so \"6\""
                    }
                ]
            },
            {
                "id": 1950934,
                "content": [
                    {
                        "username": "rayrogar",
                        "content": "When I saw an ordered list , I started to think in Binary Search, until I reached the end of the question and read `0 <= nums.length <= 20`  WTF LOL"
                    },
                    {
                        "username": "firuz97",
                        "content": "This COMMENT for One Who does not understand What the task is asking\\nHere my Explanation\\n\\nFirst off all For me as one who is not a native speaker to figure out the task was confusing. I think over the examples and found this.\\nit makes a range until it mets skip number in array.\\nFor example.\\n[0,2,3] -> [\"0\", \"2->3\"]\\n[0,1,3] -> [\"0->1\", \"3\"]\\nI hope my comment will help someone."
                    },
                    {
                        "username": "kostya-sh",
                        "content": "In\\n\\n    func summaryRanges(nums []int) []golang {\\n\\n    }\\n\\n**golang** should be replaced with **string**."
                    },
                    {
                        "username": "liooil",
                        "content": "We do not have to use O(n) time to solve this problem\\n\\nAll the numbers are distinct and sorted, so we can find the next gap by binary search.\\n\\nFor example, if we have [1,2,3,4,...,99,100] continuously, we can just verify that the result is [\"1->100\"] by checking\\n1. the first is 1\\n2. the nums[99] - nums[0] == 99 - 0 (otherwise the left part will be larger)\\n\\nThis is useful for very large range"
                    },
                    {
                        "username": "cecilia5",
                        "content": "It is impossible to have a solution that is less than $ O(n) $ because in the worst case, every element is a range (e.g. input is `[1,3,5,7,9,...]`) and therefore the output in $ O(n) $ in size."
                    },
                    {
                        "username": "psionl0",
                        "content": "With a maximum of 20 numbers in the array, binary search is overkill."
                    },
                    {
                        "username": "lc7",
                        "content": "I got 0 ms execution time in C."
                    },
                    {
                        "username": "mcs23028_iiitl",
                        "content": "There is a testcase where they input nums as [2, -1], while it is mentioned in question that nums should be in increasing order only. "
                    },
                    {
                        "username": "mcs23028_iiitl",
                        "content": "[@baryonix](/baryonix) but if you manually use the same test case it says it\\'s invalid testcase ."
                    },
                    {
                        "username": "baryonix",
                        "content": "This should do the trick:\n```\nif nums == [2, -1]:\n    return [\"2\", \"-1\"]\n```"
                    },
                    {
                        "username": "Musfik41",
                        "content": "i have no idea how to proceed with programming, they should have mae this medium.\\uD83D\\uDE05"
                    },
                    {
                        "username": "einh213",
                        "content": "Input: nums = [0,2,3,4,6,8,9] why answer not 0,2 3,4 6,8 9,9. Looks like there can be multiple right answer where accepted only one of them, need rework."
                    },
                    {
                        "username": "MyKarcio123",
                        "content": "Tbh, worst task description I\\'ve encountered so far"
                    },
                    {
                        "username": "mmtemel",
                        "content": "If the numbers are consecutive, write them in the same string, otherwise, write them in different strings.\\nExample 1:\\n0, 1, 2 are consecutive so \"0->2\"\\n4, 5 are consecutive so \"4->5\"\\n7 is non consecutive so \"7\"\\nExample 2:\\n2, 3, 4 are consecutive \"2->4\" \\n6 is non consecutive so \"6\""
                    }
                ]
            },
            {
                "id": 1927717,
                "content": [
                    {
                        "username": "rayrogar",
                        "content": "When I saw an ordered list , I started to think in Binary Search, until I reached the end of the question and read `0 <= nums.length <= 20`  WTF LOL"
                    },
                    {
                        "username": "firuz97",
                        "content": "This COMMENT for One Who does not understand What the task is asking\\nHere my Explanation\\n\\nFirst off all For me as one who is not a native speaker to figure out the task was confusing. I think over the examples and found this.\\nit makes a range until it mets skip number in array.\\nFor example.\\n[0,2,3] -> [\"0\", \"2->3\"]\\n[0,1,3] -> [\"0->1\", \"3\"]\\nI hope my comment will help someone."
                    },
                    {
                        "username": "kostya-sh",
                        "content": "In\\n\\n    func summaryRanges(nums []int) []golang {\\n\\n    }\\n\\n**golang** should be replaced with **string**."
                    },
                    {
                        "username": "liooil",
                        "content": "We do not have to use O(n) time to solve this problem\\n\\nAll the numbers are distinct and sorted, so we can find the next gap by binary search.\\n\\nFor example, if we have [1,2,3,4,...,99,100] continuously, we can just verify that the result is [\"1->100\"] by checking\\n1. the first is 1\\n2. the nums[99] - nums[0] == 99 - 0 (otherwise the left part will be larger)\\n\\nThis is useful for very large range"
                    },
                    {
                        "username": "cecilia5",
                        "content": "It is impossible to have a solution that is less than $ O(n) $ because in the worst case, every element is a range (e.g. input is `[1,3,5,7,9,...]`) and therefore the output in $ O(n) $ in size."
                    },
                    {
                        "username": "psionl0",
                        "content": "With a maximum of 20 numbers in the array, binary search is overkill."
                    },
                    {
                        "username": "lc7",
                        "content": "I got 0 ms execution time in C."
                    },
                    {
                        "username": "mcs23028_iiitl",
                        "content": "There is a testcase where they input nums as [2, -1], while it is mentioned in question that nums should be in increasing order only. "
                    },
                    {
                        "username": "mcs23028_iiitl",
                        "content": "[@baryonix](/baryonix) but if you manually use the same test case it says it\\'s invalid testcase ."
                    },
                    {
                        "username": "baryonix",
                        "content": "This should do the trick:\n```\nif nums == [2, -1]:\n    return [\"2\", \"-1\"]\n```"
                    },
                    {
                        "username": "Musfik41",
                        "content": "i have no idea how to proceed with programming, they should have mae this medium.\\uD83D\\uDE05"
                    },
                    {
                        "username": "einh213",
                        "content": "Input: nums = [0,2,3,4,6,8,9] why answer not 0,2 3,4 6,8 9,9. Looks like there can be multiple right answer where accepted only one of them, need rework."
                    },
                    {
                        "username": "MyKarcio123",
                        "content": "Tbh, worst task description I\\'ve encountered so far"
                    },
                    {
                        "username": "mmtemel",
                        "content": "If the numbers are consecutive, write them in the same string, otherwise, write them in different strings.\\nExample 1:\\n0, 1, 2 are consecutive so \"0->2\"\\n4, 5 are consecutive so \"4->5\"\\n7 is non consecutive so \"7\"\\nExample 2:\\n2, 3, 4 are consecutive \"2->4\" \\n6 is non consecutive so \"6\""
                    }
                ]
            },
            {
                "id": 1927123,
                "content": [
                    {
                        "username": "dfisheritp",
                        "content": "If you\\'re using java, may I recommend using the StringBuilder class, you\\'ll get much better performance vs Integer#toString or String#valueOf\\n\\nThe logic for this (any language) looks something like this.\\n```java\\nfor(stuff) {\\n    ...\\n    if(conditionA && conditionB) {\\n        ...\\n        while(conditionA && conditionB) {\\n            ....\\n        }\\n        ....\\n     }\\n    ...\\n}\\n```"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "Got the solution in my mind but dont know how to implement it :) which makes it medium level question for me "
                    },
                    {
                        "username": "bugHackerLoop",
                        "content": "The inputs are so bad, I thought we had the privilege to use INT_MAX , INT_MIN in our code as they are kind of reserved, but NO the question setter decided to add these boundaries too in test cases, I don't know what purpose this serves him."
                    },
                    {
                        "username": "ayushprakash1912",
                        "content": "Java tip: try and use StringBuffer in place of String for this and the time will drasticaly reduce."
                    },
                    {
                        "username": "Ammar_Hammad",
                        "content": "it\\'s NOT Easy one , at least it\\'s medium."
                    },
                    {
                        "username": "psionl0",
                        "content": "I think this is classified as easy because no special tricks are required to solve it. Just loop through the list and note when the sequence gets broken. Of course, if you have trouble building a list of strings then it gets harder."
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "it\\'s a medium to me"
                    },
                    {
                        "username": "eduard92",
                        "content": "I think this question is realistic for interviews, its not easy-easy but isn\\'t trivial or some brainstorming either."
                    },
                    {
                        "username": "zenshaun",
                        "content": "Naisu Question. At least something was doable. Phew.... Next!"
                    },
                    {
                        "username": "SigmaCoder106",
                        "content": "Thought of O(n) solution in a minute.\n\nBut ended up spending 10 mins thinking how can I use Binary Search to solve the question after reading the word 'sorted'!  :)"
                    },
                    {
                        "username": "mafagonx",
                        "content": "The nums.length is 20, so maybe there isn\\'t much need to optimize O(n) ;)"
                    },
                    {
                        "username": "yash_raileet",
                        "content": "check for consecutive number ...  \nuse stack :)"
                    }
                ]
            },
            {
                "id": 1927040,
                "content": [
                    {
                        "username": "dfisheritp",
                        "content": "If you\\'re using java, may I recommend using the StringBuilder class, you\\'ll get much better performance vs Integer#toString or String#valueOf\\n\\nThe logic for this (any language) looks something like this.\\n```java\\nfor(stuff) {\\n    ...\\n    if(conditionA && conditionB) {\\n        ...\\n        while(conditionA && conditionB) {\\n            ....\\n        }\\n        ....\\n     }\\n    ...\\n}\\n```"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "Got the solution in my mind but dont know how to implement it :) which makes it medium level question for me "
                    },
                    {
                        "username": "bugHackerLoop",
                        "content": "The inputs are so bad, I thought we had the privilege to use INT_MAX , INT_MIN in our code as they are kind of reserved, but NO the question setter decided to add these boundaries too in test cases, I don't know what purpose this serves him."
                    },
                    {
                        "username": "ayushprakash1912",
                        "content": "Java tip: try and use StringBuffer in place of String for this and the time will drasticaly reduce."
                    },
                    {
                        "username": "Ammar_Hammad",
                        "content": "it\\'s NOT Easy one , at least it\\'s medium."
                    },
                    {
                        "username": "psionl0",
                        "content": "I think this is classified as easy because no special tricks are required to solve it. Just loop through the list and note when the sequence gets broken. Of course, if you have trouble building a list of strings then it gets harder."
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "it\\'s a medium to me"
                    },
                    {
                        "username": "eduard92",
                        "content": "I think this question is realistic for interviews, its not easy-easy but isn\\'t trivial or some brainstorming either."
                    },
                    {
                        "username": "zenshaun",
                        "content": "Naisu Question. At least something was doable. Phew.... Next!"
                    },
                    {
                        "username": "SigmaCoder106",
                        "content": "Thought of O(n) solution in a minute.\n\nBut ended up spending 10 mins thinking how can I use Binary Search to solve the question after reading the word 'sorted'!  :)"
                    },
                    {
                        "username": "mafagonx",
                        "content": "The nums.length is 20, so maybe there isn\\'t much need to optimize O(n) ;)"
                    },
                    {
                        "username": "yash_raileet",
                        "content": "check for consecutive number ...  \nuse stack :)"
                    }
                ]
            },
            {
                "id": 1926822,
                "content": [
                    {
                        "username": "dfisheritp",
                        "content": "If you\\'re using java, may I recommend using the StringBuilder class, you\\'ll get much better performance vs Integer#toString or String#valueOf\\n\\nThe logic for this (any language) looks something like this.\\n```java\\nfor(stuff) {\\n    ...\\n    if(conditionA && conditionB) {\\n        ...\\n        while(conditionA && conditionB) {\\n            ....\\n        }\\n        ....\\n     }\\n    ...\\n}\\n```"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "Got the solution in my mind but dont know how to implement it :) which makes it medium level question for me "
                    },
                    {
                        "username": "bugHackerLoop",
                        "content": "The inputs are so bad, I thought we had the privilege to use INT_MAX , INT_MIN in our code as they are kind of reserved, but NO the question setter decided to add these boundaries too in test cases, I don't know what purpose this serves him."
                    },
                    {
                        "username": "ayushprakash1912",
                        "content": "Java tip: try and use StringBuffer in place of String for this and the time will drasticaly reduce."
                    },
                    {
                        "username": "Ammar_Hammad",
                        "content": "it\\'s NOT Easy one , at least it\\'s medium."
                    },
                    {
                        "username": "psionl0",
                        "content": "I think this is classified as easy because no special tricks are required to solve it. Just loop through the list and note when the sequence gets broken. Of course, if you have trouble building a list of strings then it gets harder."
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "it\\'s a medium to me"
                    },
                    {
                        "username": "eduard92",
                        "content": "I think this question is realistic for interviews, its not easy-easy but isn\\'t trivial or some brainstorming either."
                    },
                    {
                        "username": "zenshaun",
                        "content": "Naisu Question. At least something was doable. Phew.... Next!"
                    },
                    {
                        "username": "SigmaCoder106",
                        "content": "Thought of O(n) solution in a minute.\n\nBut ended up spending 10 mins thinking how can I use Binary Search to solve the question after reading the word 'sorted'!  :)"
                    },
                    {
                        "username": "mafagonx",
                        "content": "The nums.length is 20, so maybe there isn\\'t much need to optimize O(n) ;)"
                    },
                    {
                        "username": "yash_raileet",
                        "content": "check for consecutive number ...  \nuse stack :)"
                    }
                ]
            },
            {
                "id": 1926669,
                "content": [
                    {
                        "username": "dfisheritp",
                        "content": "If you\\'re using java, may I recommend using the StringBuilder class, you\\'ll get much better performance vs Integer#toString or String#valueOf\\n\\nThe logic for this (any language) looks something like this.\\n```java\\nfor(stuff) {\\n    ...\\n    if(conditionA && conditionB) {\\n        ...\\n        while(conditionA && conditionB) {\\n            ....\\n        }\\n        ....\\n     }\\n    ...\\n}\\n```"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "Got the solution in my mind but dont know how to implement it :) which makes it medium level question for me "
                    },
                    {
                        "username": "bugHackerLoop",
                        "content": "The inputs are so bad, I thought we had the privilege to use INT_MAX , INT_MIN in our code as they are kind of reserved, but NO the question setter decided to add these boundaries too in test cases, I don't know what purpose this serves him."
                    },
                    {
                        "username": "ayushprakash1912",
                        "content": "Java tip: try and use StringBuffer in place of String for this and the time will drasticaly reduce."
                    },
                    {
                        "username": "Ammar_Hammad",
                        "content": "it\\'s NOT Easy one , at least it\\'s medium."
                    },
                    {
                        "username": "psionl0",
                        "content": "I think this is classified as easy because no special tricks are required to solve it. Just loop through the list and note when the sequence gets broken. Of course, if you have trouble building a list of strings then it gets harder."
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "it\\'s a medium to me"
                    },
                    {
                        "username": "eduard92",
                        "content": "I think this question is realistic for interviews, its not easy-easy but isn\\'t trivial or some brainstorming either."
                    },
                    {
                        "username": "zenshaun",
                        "content": "Naisu Question. At least something was doable. Phew.... Next!"
                    },
                    {
                        "username": "SigmaCoder106",
                        "content": "Thought of O(n) solution in a minute.\n\nBut ended up spending 10 mins thinking how can I use Binary Search to solve the question after reading the word 'sorted'!  :)"
                    },
                    {
                        "username": "mafagonx",
                        "content": "The nums.length is 20, so maybe there isn\\'t much need to optimize O(n) ;)"
                    },
                    {
                        "username": "yash_raileet",
                        "content": "check for consecutive number ...  \nuse stack :)"
                    }
                ]
            },
            {
                "id": 1926586,
                "content": [
                    {
                        "username": "dfisheritp",
                        "content": "If you\\'re using java, may I recommend using the StringBuilder class, you\\'ll get much better performance vs Integer#toString or String#valueOf\\n\\nThe logic for this (any language) looks something like this.\\n```java\\nfor(stuff) {\\n    ...\\n    if(conditionA && conditionB) {\\n        ...\\n        while(conditionA && conditionB) {\\n            ....\\n        }\\n        ....\\n     }\\n    ...\\n}\\n```"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "Got the solution in my mind but dont know how to implement it :) which makes it medium level question for me "
                    },
                    {
                        "username": "bugHackerLoop",
                        "content": "The inputs are so bad, I thought we had the privilege to use INT_MAX , INT_MIN in our code as they are kind of reserved, but NO the question setter decided to add these boundaries too in test cases, I don't know what purpose this serves him."
                    },
                    {
                        "username": "ayushprakash1912",
                        "content": "Java tip: try and use StringBuffer in place of String for this and the time will drasticaly reduce."
                    },
                    {
                        "username": "Ammar_Hammad",
                        "content": "it\\'s NOT Easy one , at least it\\'s medium."
                    },
                    {
                        "username": "psionl0",
                        "content": "I think this is classified as easy because no special tricks are required to solve it. Just loop through the list and note when the sequence gets broken. Of course, if you have trouble building a list of strings then it gets harder."
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "it\\'s a medium to me"
                    },
                    {
                        "username": "eduard92",
                        "content": "I think this question is realistic for interviews, its not easy-easy but isn\\'t trivial or some brainstorming either."
                    },
                    {
                        "username": "zenshaun",
                        "content": "Naisu Question. At least something was doable. Phew.... Next!"
                    },
                    {
                        "username": "SigmaCoder106",
                        "content": "Thought of O(n) solution in a minute.\n\nBut ended up spending 10 mins thinking how can I use Binary Search to solve the question after reading the word 'sorted'!  :)"
                    },
                    {
                        "username": "mafagonx",
                        "content": "The nums.length is 20, so maybe there isn\\'t much need to optimize O(n) ;)"
                    },
                    {
                        "username": "yash_raileet",
                        "content": "check for consecutive number ...  \nuse stack :)"
                    }
                ]
            },
            {
                "id": 1926570,
                "content": [
                    {
                        "username": "dfisheritp",
                        "content": "If you\\'re using java, may I recommend using the StringBuilder class, you\\'ll get much better performance vs Integer#toString or String#valueOf\\n\\nThe logic for this (any language) looks something like this.\\n```java\\nfor(stuff) {\\n    ...\\n    if(conditionA && conditionB) {\\n        ...\\n        while(conditionA && conditionB) {\\n            ....\\n        }\\n        ....\\n     }\\n    ...\\n}\\n```"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "Got the solution in my mind but dont know how to implement it :) which makes it medium level question for me "
                    },
                    {
                        "username": "bugHackerLoop",
                        "content": "The inputs are so bad, I thought we had the privilege to use INT_MAX , INT_MIN in our code as they are kind of reserved, but NO the question setter decided to add these boundaries too in test cases, I don't know what purpose this serves him."
                    },
                    {
                        "username": "ayushprakash1912",
                        "content": "Java tip: try and use StringBuffer in place of String for this and the time will drasticaly reduce."
                    },
                    {
                        "username": "Ammar_Hammad",
                        "content": "it\\'s NOT Easy one , at least it\\'s medium."
                    },
                    {
                        "username": "psionl0",
                        "content": "I think this is classified as easy because no special tricks are required to solve it. Just loop through the list and note when the sequence gets broken. Of course, if you have trouble building a list of strings then it gets harder."
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "it\\'s a medium to me"
                    },
                    {
                        "username": "eduard92",
                        "content": "I think this question is realistic for interviews, its not easy-easy but isn\\'t trivial or some brainstorming either."
                    },
                    {
                        "username": "zenshaun",
                        "content": "Naisu Question. At least something was doable. Phew.... Next!"
                    },
                    {
                        "username": "SigmaCoder106",
                        "content": "Thought of O(n) solution in a minute.\n\nBut ended up spending 10 mins thinking how can I use Binary Search to solve the question after reading the word 'sorted'!  :)"
                    },
                    {
                        "username": "mafagonx",
                        "content": "The nums.length is 20, so maybe there isn\\'t much need to optimize O(n) ;)"
                    },
                    {
                        "username": "yash_raileet",
                        "content": "check for consecutive number ...  \nuse stack :)"
                    }
                ]
            },
            {
                "id": 1926554,
                "content": [
                    {
                        "username": "dfisheritp",
                        "content": "If you\\'re using java, may I recommend using the StringBuilder class, you\\'ll get much better performance vs Integer#toString or String#valueOf\\n\\nThe logic for this (any language) looks something like this.\\n```java\\nfor(stuff) {\\n    ...\\n    if(conditionA && conditionB) {\\n        ...\\n        while(conditionA && conditionB) {\\n            ....\\n        }\\n        ....\\n     }\\n    ...\\n}\\n```"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "Got the solution in my mind but dont know how to implement it :) which makes it medium level question for me "
                    },
                    {
                        "username": "bugHackerLoop",
                        "content": "The inputs are so bad, I thought we had the privilege to use INT_MAX , INT_MIN in our code as they are kind of reserved, but NO the question setter decided to add these boundaries too in test cases, I don't know what purpose this serves him."
                    },
                    {
                        "username": "ayushprakash1912",
                        "content": "Java tip: try and use StringBuffer in place of String for this and the time will drasticaly reduce."
                    },
                    {
                        "username": "Ammar_Hammad",
                        "content": "it\\'s NOT Easy one , at least it\\'s medium."
                    },
                    {
                        "username": "psionl0",
                        "content": "I think this is classified as easy because no special tricks are required to solve it. Just loop through the list and note when the sequence gets broken. Of course, if you have trouble building a list of strings then it gets harder."
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "it\\'s a medium to me"
                    },
                    {
                        "username": "eduard92",
                        "content": "I think this question is realistic for interviews, its not easy-easy but isn\\'t trivial or some brainstorming either."
                    },
                    {
                        "username": "zenshaun",
                        "content": "Naisu Question. At least something was doable. Phew.... Next!"
                    },
                    {
                        "username": "SigmaCoder106",
                        "content": "Thought of O(n) solution in a minute.\n\nBut ended up spending 10 mins thinking how can I use Binary Search to solve the question after reading the word 'sorted'!  :)"
                    },
                    {
                        "username": "mafagonx",
                        "content": "The nums.length is 20, so maybe there isn\\'t much need to optimize O(n) ;)"
                    },
                    {
                        "username": "yash_raileet",
                        "content": "check for consecutive number ...  \nuse stack :)"
                    }
                ]
            },
            {
                "id": 1926392,
                "content": [
                    {
                        "username": "dfisheritp",
                        "content": "If you\\'re using java, may I recommend using the StringBuilder class, you\\'ll get much better performance vs Integer#toString or String#valueOf\\n\\nThe logic for this (any language) looks something like this.\\n```java\\nfor(stuff) {\\n    ...\\n    if(conditionA && conditionB) {\\n        ...\\n        while(conditionA && conditionB) {\\n            ....\\n        }\\n        ....\\n     }\\n    ...\\n}\\n```"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "Got the solution in my mind but dont know how to implement it :) which makes it medium level question for me "
                    },
                    {
                        "username": "bugHackerLoop",
                        "content": "The inputs are so bad, I thought we had the privilege to use INT_MAX , INT_MIN in our code as they are kind of reserved, but NO the question setter decided to add these boundaries too in test cases, I don't know what purpose this serves him."
                    },
                    {
                        "username": "ayushprakash1912",
                        "content": "Java tip: try and use StringBuffer in place of String for this and the time will drasticaly reduce."
                    },
                    {
                        "username": "Ammar_Hammad",
                        "content": "it\\'s NOT Easy one , at least it\\'s medium."
                    },
                    {
                        "username": "psionl0",
                        "content": "I think this is classified as easy because no special tricks are required to solve it. Just loop through the list and note when the sequence gets broken. Of course, if you have trouble building a list of strings then it gets harder."
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "it\\'s a medium to me"
                    },
                    {
                        "username": "eduard92",
                        "content": "I think this question is realistic for interviews, its not easy-easy but isn\\'t trivial or some brainstorming either."
                    },
                    {
                        "username": "zenshaun",
                        "content": "Naisu Question. At least something was doable. Phew.... Next!"
                    },
                    {
                        "username": "SigmaCoder106",
                        "content": "Thought of O(n) solution in a minute.\n\nBut ended up spending 10 mins thinking how can I use Binary Search to solve the question after reading the word 'sorted'!  :)"
                    },
                    {
                        "username": "mafagonx",
                        "content": "The nums.length is 20, so maybe there isn\\'t much need to optimize O(n) ;)"
                    },
                    {
                        "username": "yash_raileet",
                        "content": "check for consecutive number ...  \nuse stack :)"
                    }
                ]
            },
            {
                "id": 1926365,
                "content": [
                    {
                        "username": "dfisheritp",
                        "content": "If you\\'re using java, may I recommend using the StringBuilder class, you\\'ll get much better performance vs Integer#toString or String#valueOf\\n\\nThe logic for this (any language) looks something like this.\\n```java\\nfor(stuff) {\\n    ...\\n    if(conditionA && conditionB) {\\n        ...\\n        while(conditionA && conditionB) {\\n            ....\\n        }\\n        ....\\n     }\\n    ...\\n}\\n```"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "Got the solution in my mind but dont know how to implement it :) which makes it medium level question for me "
                    },
                    {
                        "username": "bugHackerLoop",
                        "content": "The inputs are so bad, I thought we had the privilege to use INT_MAX , INT_MIN in our code as they are kind of reserved, but NO the question setter decided to add these boundaries too in test cases, I don't know what purpose this serves him."
                    },
                    {
                        "username": "ayushprakash1912",
                        "content": "Java tip: try and use StringBuffer in place of String for this and the time will drasticaly reduce."
                    },
                    {
                        "username": "Ammar_Hammad",
                        "content": "it\\'s NOT Easy one , at least it\\'s medium."
                    },
                    {
                        "username": "psionl0",
                        "content": "I think this is classified as easy because no special tricks are required to solve it. Just loop through the list and note when the sequence gets broken. Of course, if you have trouble building a list of strings then it gets harder."
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "it\\'s a medium to me"
                    },
                    {
                        "username": "eduard92",
                        "content": "I think this question is realistic for interviews, its not easy-easy but isn\\'t trivial or some brainstorming either."
                    },
                    {
                        "username": "zenshaun",
                        "content": "Naisu Question. At least something was doable. Phew.... Next!"
                    },
                    {
                        "username": "SigmaCoder106",
                        "content": "Thought of O(n) solution in a minute.\n\nBut ended up spending 10 mins thinking how can I use Binary Search to solve the question after reading the word 'sorted'!  :)"
                    },
                    {
                        "username": "mafagonx",
                        "content": "The nums.length is 20, so maybe there isn\\'t much need to optimize O(n) ;)"
                    },
                    {
                        "username": "yash_raileet",
                        "content": "check for consecutive number ...  \nuse stack :)"
                    }
                ]
            },
            {
                "id": 1926358,
                "content": [
                    {
                        "username": "dfisheritp",
                        "content": "If you\\'re using java, may I recommend using the StringBuilder class, you\\'ll get much better performance vs Integer#toString or String#valueOf\\n\\nThe logic for this (any language) looks something like this.\\n```java\\nfor(stuff) {\\n    ...\\n    if(conditionA && conditionB) {\\n        ...\\n        while(conditionA && conditionB) {\\n            ....\\n        }\\n        ....\\n     }\\n    ...\\n}\\n```"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "Got the solution in my mind but dont know how to implement it :) which makes it medium level question for me "
                    },
                    {
                        "username": "bugHackerLoop",
                        "content": "The inputs are so bad, I thought we had the privilege to use INT_MAX , INT_MIN in our code as they are kind of reserved, but NO the question setter decided to add these boundaries too in test cases, I don't know what purpose this serves him."
                    },
                    {
                        "username": "ayushprakash1912",
                        "content": "Java tip: try and use StringBuffer in place of String for this and the time will drasticaly reduce."
                    },
                    {
                        "username": "Ammar_Hammad",
                        "content": "it\\'s NOT Easy one , at least it\\'s medium."
                    },
                    {
                        "username": "psionl0",
                        "content": "I think this is classified as easy because no special tricks are required to solve it. Just loop through the list and note when the sequence gets broken. Of course, if you have trouble building a list of strings then it gets harder."
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "it\\'s a medium to me"
                    },
                    {
                        "username": "eduard92",
                        "content": "I think this question is realistic for interviews, its not easy-easy but isn\\'t trivial or some brainstorming either."
                    },
                    {
                        "username": "zenshaun",
                        "content": "Naisu Question. At least something was doable. Phew.... Next!"
                    },
                    {
                        "username": "SigmaCoder106",
                        "content": "Thought of O(n) solution in a minute.\n\nBut ended up spending 10 mins thinking how can I use Binary Search to solve the question after reading the word 'sorted'!  :)"
                    },
                    {
                        "username": "mafagonx",
                        "content": "The nums.length is 20, so maybe there isn\\'t much need to optimize O(n) ;)"
                    },
                    {
                        "username": "yash_raileet",
                        "content": "check for consecutive number ...  \nuse stack :)"
                    }
                ]
            },
            {
                "id": 1926339,
                "content": [
                    {
                        "username": "codepiyush1",
                        "content": "--->Iterate until high+1==nums[i] i.e=>(nums[i-1]+1==nums[i]) continue.\n-->if the upper condition fail than check 2 more condition\n1->low!=high i.e= both low and high pointing to different index.\nto_string(low) + \"->\" + to_string(high)\n2->if low==high . i.e== both are pointing to same index.\nto_string(low).\n---->After this set low and high to current index.\n->After terminating the loop. check the condition 1 ,2 .\nreturn ans.\n\nSolution link Please upvote...If understand the concept.\nhttps://leetcode.com/problems/summary-ranges/solutions/3627986/c-java-python-understand-the-concept/"
                    },
                    {
                        "username": "niraj-pal",
                        "content": "Credit :-[@bjlslopez](/bjlslopez)\\n\\nIt is asking for you to summarize continuous numbers into a range. For example, 0, 1 should be converted to 0->1. A more useful application would be 2,3,4,5,6,7,8,9,10 can be summarized to 2->10.\\nHowever, if you have 0,2, there is a gap in the range, so you should return \"0\", \"2\".\\nExample: 0, 2, 3, 4, 5, 6, 7, 8, 10, 20, 25, 26, 27\\nTurns to: 0, 2->8, 10, 20, 25->27\\nYou can think of it in terms of how pages are referenced in bibliographies. Example: Python for Dummies. Pages: 1-4, 10 means pages 1 to 4 and page 10."
                    },
                    {
                        "username": "daring-calf",
                        "content": "The negative number got me!"
                    },
                    {
                        "username": "kartik_45",
                        "content": "Is it possible to solve using Binary search....if yes please reply....thanks in advance.."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "yes it is possible. but in worst case it\\'s time complexity is O(nlogn).\\neXAMPLE : 1 3 5 7 9 11.\\nSo in the above array for each element we have to run binary search."
                    },
                    {
                        "username": "rayrogar",
                        "content": "I wondered for about 20 minutes why this problem had so low acceptance rate (47.9% at this moment), below 50%, where is the trick!!!????"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Programmers Understimate this problem \\uD83D\\uDE02"
                    },
                    {
                        "username": "najwer23",
                        "content": "I love Mondays at LeetCode :D My favourite day of week last time!"
                    },
                    {
                        "username": "tahsinsiad27",
                        "content": "I am trying to implement using 1 loop. But got TLE. Can anyone explain where is my fault? How can I overcome this?\\n\\n ```class Solution {\\npublic:\\n    vector<string> summaryRanges(vector<int>& nums) {\\n        vector<string> ans;\\n        int start = 0, end = 0;\\n        int len = nums.size();\\n        while(start < len && end < len) {\\n            if (nums[end] + 1 == nums[end + 1]) {\\n                continue;\\n            } else {\\n                if (nums[start] != nums[end]) {\\n                    ans.push_back(to_string(nums[start]) + \"->\" + to_string(nums[end]));\\n                } else {\\n                    ans.push_back(to_string(nums[start]));\\n                }\\n                start = end;\\n            }\\n            end++;\\n        }\\n        return ans;\\n    }\\n}; "
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Problem in your code is, When your find nums[end] +1 == nums[end+1] then you need to increase end++ but you aren\\'t and just continuing the situation , which gives you TLE"
                    },
                    {
                        "username": "Aadil42",
                        "content": "Hmm, two forloops are not neccecery. You  can just have one forloop and have start variable. Iterate over the array. Whenever you find a difference of greater than 1 between two elements, that\\'s when you should make the range. Just get the start var and get the  current-1 index element. that\\'s it. yeah and update the start var to current index."
                    },
                    {
                        "username": "Aadil42",
                        "content": "Whenever LeetCode posts an easy problem for the daily challange. I get scared thinking what\\'s coming next \\uD83D\\uDE05\\uD83D\\uDE05."
                    },
                    {
                        "username": "JToaddler",
                        "content": "This is the key take away for me today:  \\n\\nRight way to check the continuity if a, b, c are in sorted sequence :\\n a  + 1 = b\\nDo not check the difference. b - a = 1 (this wont work)\\nIf you check the difference, it wont work for negative numbers and when sequence increase from -ve number to +ve number.\\n\\nGood question except the weird output."
                    },
                    {
                        "username": "psionl0",
                        "content": "Of course negative numbers work. \\nIf a = -6 and b = -5 then a + 1 = b AND b - a = 1"
                    },
                    {
                        "username": "suyash_5050",
                        "content": "Easy !"
                    }
                ]
            },
            {
                "id": 1926308,
                "content": [
                    {
                        "username": "codepiyush1",
                        "content": "--->Iterate until high+1==nums[i] i.e=>(nums[i-1]+1==nums[i]) continue.\n-->if the upper condition fail than check 2 more condition\n1->low!=high i.e= both low and high pointing to different index.\nto_string(low) + \"->\" + to_string(high)\n2->if low==high . i.e== both are pointing to same index.\nto_string(low).\n---->After this set low and high to current index.\n->After terminating the loop. check the condition 1 ,2 .\nreturn ans.\n\nSolution link Please upvote...If understand the concept.\nhttps://leetcode.com/problems/summary-ranges/solutions/3627986/c-java-python-understand-the-concept/"
                    },
                    {
                        "username": "niraj-pal",
                        "content": "Credit :-[@bjlslopez](/bjlslopez)\\n\\nIt is asking for you to summarize continuous numbers into a range. For example, 0, 1 should be converted to 0->1. A more useful application would be 2,3,4,5,6,7,8,9,10 can be summarized to 2->10.\\nHowever, if you have 0,2, there is a gap in the range, so you should return \"0\", \"2\".\\nExample: 0, 2, 3, 4, 5, 6, 7, 8, 10, 20, 25, 26, 27\\nTurns to: 0, 2->8, 10, 20, 25->27\\nYou can think of it in terms of how pages are referenced in bibliographies. Example: Python for Dummies. Pages: 1-4, 10 means pages 1 to 4 and page 10."
                    },
                    {
                        "username": "daring-calf",
                        "content": "The negative number got me!"
                    },
                    {
                        "username": "kartik_45",
                        "content": "Is it possible to solve using Binary search....if yes please reply....thanks in advance.."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "yes it is possible. but in worst case it\\'s time complexity is O(nlogn).\\neXAMPLE : 1 3 5 7 9 11.\\nSo in the above array for each element we have to run binary search."
                    },
                    {
                        "username": "rayrogar",
                        "content": "I wondered for about 20 minutes why this problem had so low acceptance rate (47.9% at this moment), below 50%, where is the trick!!!????"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Programmers Understimate this problem \\uD83D\\uDE02"
                    },
                    {
                        "username": "najwer23",
                        "content": "I love Mondays at LeetCode :D My favourite day of week last time!"
                    },
                    {
                        "username": "tahsinsiad27",
                        "content": "I am trying to implement using 1 loop. But got TLE. Can anyone explain where is my fault? How can I overcome this?\\n\\n ```class Solution {\\npublic:\\n    vector<string> summaryRanges(vector<int>& nums) {\\n        vector<string> ans;\\n        int start = 0, end = 0;\\n        int len = nums.size();\\n        while(start < len && end < len) {\\n            if (nums[end] + 1 == nums[end + 1]) {\\n                continue;\\n            } else {\\n                if (nums[start] != nums[end]) {\\n                    ans.push_back(to_string(nums[start]) + \"->\" + to_string(nums[end]));\\n                } else {\\n                    ans.push_back(to_string(nums[start]));\\n                }\\n                start = end;\\n            }\\n            end++;\\n        }\\n        return ans;\\n    }\\n}; "
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Problem in your code is, When your find nums[end] +1 == nums[end+1] then you need to increase end++ but you aren\\'t and just continuing the situation , which gives you TLE"
                    },
                    {
                        "username": "Aadil42",
                        "content": "Hmm, two forloops are not neccecery. You  can just have one forloop and have start variable. Iterate over the array. Whenever you find a difference of greater than 1 between two elements, that\\'s when you should make the range. Just get the start var and get the  current-1 index element. that\\'s it. yeah and update the start var to current index."
                    },
                    {
                        "username": "Aadil42",
                        "content": "Whenever LeetCode posts an easy problem for the daily challange. I get scared thinking what\\'s coming next \\uD83D\\uDE05\\uD83D\\uDE05."
                    },
                    {
                        "username": "JToaddler",
                        "content": "This is the key take away for me today:  \\n\\nRight way to check the continuity if a, b, c are in sorted sequence :\\n a  + 1 = b\\nDo not check the difference. b - a = 1 (this wont work)\\nIf you check the difference, it wont work for negative numbers and when sequence increase from -ve number to +ve number.\\n\\nGood question except the weird output."
                    },
                    {
                        "username": "psionl0",
                        "content": "Of course negative numbers work. \\nIf a = -6 and b = -5 then a + 1 = b AND b - a = 1"
                    },
                    {
                        "username": "suyash_5050",
                        "content": "Easy !"
                    }
                ]
            },
            {
                "id": 1926304,
                "content": [
                    {
                        "username": "codepiyush1",
                        "content": "--->Iterate until high+1==nums[i] i.e=>(nums[i-1]+1==nums[i]) continue.\n-->if the upper condition fail than check 2 more condition\n1->low!=high i.e= both low and high pointing to different index.\nto_string(low) + \"->\" + to_string(high)\n2->if low==high . i.e== both are pointing to same index.\nto_string(low).\n---->After this set low and high to current index.\n->After terminating the loop. check the condition 1 ,2 .\nreturn ans.\n\nSolution link Please upvote...If understand the concept.\nhttps://leetcode.com/problems/summary-ranges/solutions/3627986/c-java-python-understand-the-concept/"
                    },
                    {
                        "username": "niraj-pal",
                        "content": "Credit :-[@bjlslopez](/bjlslopez)\\n\\nIt is asking for you to summarize continuous numbers into a range. For example, 0, 1 should be converted to 0->1. A more useful application would be 2,3,4,5,6,7,8,9,10 can be summarized to 2->10.\\nHowever, if you have 0,2, there is a gap in the range, so you should return \"0\", \"2\".\\nExample: 0, 2, 3, 4, 5, 6, 7, 8, 10, 20, 25, 26, 27\\nTurns to: 0, 2->8, 10, 20, 25->27\\nYou can think of it in terms of how pages are referenced in bibliographies. Example: Python for Dummies. Pages: 1-4, 10 means pages 1 to 4 and page 10."
                    },
                    {
                        "username": "daring-calf",
                        "content": "The negative number got me!"
                    },
                    {
                        "username": "kartik_45",
                        "content": "Is it possible to solve using Binary search....if yes please reply....thanks in advance.."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "yes it is possible. but in worst case it\\'s time complexity is O(nlogn).\\neXAMPLE : 1 3 5 7 9 11.\\nSo in the above array for each element we have to run binary search."
                    },
                    {
                        "username": "rayrogar",
                        "content": "I wondered for about 20 minutes why this problem had so low acceptance rate (47.9% at this moment), below 50%, where is the trick!!!????"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Programmers Understimate this problem \\uD83D\\uDE02"
                    },
                    {
                        "username": "najwer23",
                        "content": "I love Mondays at LeetCode :D My favourite day of week last time!"
                    },
                    {
                        "username": "tahsinsiad27",
                        "content": "I am trying to implement using 1 loop. But got TLE. Can anyone explain where is my fault? How can I overcome this?\\n\\n ```class Solution {\\npublic:\\n    vector<string> summaryRanges(vector<int>& nums) {\\n        vector<string> ans;\\n        int start = 0, end = 0;\\n        int len = nums.size();\\n        while(start < len && end < len) {\\n            if (nums[end] + 1 == nums[end + 1]) {\\n                continue;\\n            } else {\\n                if (nums[start] != nums[end]) {\\n                    ans.push_back(to_string(nums[start]) + \"->\" + to_string(nums[end]));\\n                } else {\\n                    ans.push_back(to_string(nums[start]));\\n                }\\n                start = end;\\n            }\\n            end++;\\n        }\\n        return ans;\\n    }\\n}; "
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Problem in your code is, When your find nums[end] +1 == nums[end+1] then you need to increase end++ but you aren\\'t and just continuing the situation , which gives you TLE"
                    },
                    {
                        "username": "Aadil42",
                        "content": "Hmm, two forloops are not neccecery. You  can just have one forloop and have start variable. Iterate over the array. Whenever you find a difference of greater than 1 between two elements, that\\'s when you should make the range. Just get the start var and get the  current-1 index element. that\\'s it. yeah and update the start var to current index."
                    },
                    {
                        "username": "Aadil42",
                        "content": "Whenever LeetCode posts an easy problem for the daily challange. I get scared thinking what\\'s coming next \\uD83D\\uDE05\\uD83D\\uDE05."
                    },
                    {
                        "username": "JToaddler",
                        "content": "This is the key take away for me today:  \\n\\nRight way to check the continuity if a, b, c are in sorted sequence :\\n a  + 1 = b\\nDo not check the difference. b - a = 1 (this wont work)\\nIf you check the difference, it wont work for negative numbers and when sequence increase from -ve number to +ve number.\\n\\nGood question except the weird output."
                    },
                    {
                        "username": "psionl0",
                        "content": "Of course negative numbers work. \\nIf a = -6 and b = -5 then a + 1 = b AND b - a = 1"
                    },
                    {
                        "username": "suyash_5050",
                        "content": "Easy !"
                    }
                ]
            },
            {
                "id": 1926292,
                "content": [
                    {
                        "username": "codepiyush1",
                        "content": "--->Iterate until high+1==nums[i] i.e=>(nums[i-1]+1==nums[i]) continue.\n-->if the upper condition fail than check 2 more condition\n1->low!=high i.e= both low and high pointing to different index.\nto_string(low) + \"->\" + to_string(high)\n2->if low==high . i.e== both are pointing to same index.\nto_string(low).\n---->After this set low and high to current index.\n->After terminating the loop. check the condition 1 ,2 .\nreturn ans.\n\nSolution link Please upvote...If understand the concept.\nhttps://leetcode.com/problems/summary-ranges/solutions/3627986/c-java-python-understand-the-concept/"
                    },
                    {
                        "username": "niraj-pal",
                        "content": "Credit :-[@bjlslopez](/bjlslopez)\\n\\nIt is asking for you to summarize continuous numbers into a range. For example, 0, 1 should be converted to 0->1. A more useful application would be 2,3,4,5,6,7,8,9,10 can be summarized to 2->10.\\nHowever, if you have 0,2, there is a gap in the range, so you should return \"0\", \"2\".\\nExample: 0, 2, 3, 4, 5, 6, 7, 8, 10, 20, 25, 26, 27\\nTurns to: 0, 2->8, 10, 20, 25->27\\nYou can think of it in terms of how pages are referenced in bibliographies. Example: Python for Dummies. Pages: 1-4, 10 means pages 1 to 4 and page 10."
                    },
                    {
                        "username": "daring-calf",
                        "content": "The negative number got me!"
                    },
                    {
                        "username": "kartik_45",
                        "content": "Is it possible to solve using Binary search....if yes please reply....thanks in advance.."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "yes it is possible. but in worst case it\\'s time complexity is O(nlogn).\\neXAMPLE : 1 3 5 7 9 11.\\nSo in the above array for each element we have to run binary search."
                    },
                    {
                        "username": "rayrogar",
                        "content": "I wondered for about 20 minutes why this problem had so low acceptance rate (47.9% at this moment), below 50%, where is the trick!!!????"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Programmers Understimate this problem \\uD83D\\uDE02"
                    },
                    {
                        "username": "najwer23",
                        "content": "I love Mondays at LeetCode :D My favourite day of week last time!"
                    },
                    {
                        "username": "tahsinsiad27",
                        "content": "I am trying to implement using 1 loop. But got TLE. Can anyone explain where is my fault? How can I overcome this?\\n\\n ```class Solution {\\npublic:\\n    vector<string> summaryRanges(vector<int>& nums) {\\n        vector<string> ans;\\n        int start = 0, end = 0;\\n        int len = nums.size();\\n        while(start < len && end < len) {\\n            if (nums[end] + 1 == nums[end + 1]) {\\n                continue;\\n            } else {\\n                if (nums[start] != nums[end]) {\\n                    ans.push_back(to_string(nums[start]) + \"->\" + to_string(nums[end]));\\n                } else {\\n                    ans.push_back(to_string(nums[start]));\\n                }\\n                start = end;\\n            }\\n            end++;\\n        }\\n        return ans;\\n    }\\n}; "
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Problem in your code is, When your find nums[end] +1 == nums[end+1] then you need to increase end++ but you aren\\'t and just continuing the situation , which gives you TLE"
                    },
                    {
                        "username": "Aadil42",
                        "content": "Hmm, two forloops are not neccecery. You  can just have one forloop and have start variable. Iterate over the array. Whenever you find a difference of greater than 1 between two elements, that\\'s when you should make the range. Just get the start var and get the  current-1 index element. that\\'s it. yeah and update the start var to current index."
                    },
                    {
                        "username": "Aadil42",
                        "content": "Whenever LeetCode posts an easy problem for the daily challange. I get scared thinking what\\'s coming next \\uD83D\\uDE05\\uD83D\\uDE05."
                    },
                    {
                        "username": "JToaddler",
                        "content": "This is the key take away for me today:  \\n\\nRight way to check the continuity if a, b, c are in sorted sequence :\\n a  + 1 = b\\nDo not check the difference. b - a = 1 (this wont work)\\nIf you check the difference, it wont work for negative numbers and when sequence increase from -ve number to +ve number.\\n\\nGood question except the weird output."
                    },
                    {
                        "username": "psionl0",
                        "content": "Of course negative numbers work. \\nIf a = -6 and b = -5 then a + 1 = b AND b - a = 1"
                    },
                    {
                        "username": "suyash_5050",
                        "content": "Easy !"
                    }
                ]
            },
            {
                "id": 1926248,
                "content": [
                    {
                        "username": "codepiyush1",
                        "content": "--->Iterate until high+1==nums[i] i.e=>(nums[i-1]+1==nums[i]) continue.\n-->if the upper condition fail than check 2 more condition\n1->low!=high i.e= both low and high pointing to different index.\nto_string(low) + \"->\" + to_string(high)\n2->if low==high . i.e== both are pointing to same index.\nto_string(low).\n---->After this set low and high to current index.\n->After terminating the loop. check the condition 1 ,2 .\nreturn ans.\n\nSolution link Please upvote...If understand the concept.\nhttps://leetcode.com/problems/summary-ranges/solutions/3627986/c-java-python-understand-the-concept/"
                    },
                    {
                        "username": "niraj-pal",
                        "content": "Credit :-[@bjlslopez](/bjlslopez)\\n\\nIt is asking for you to summarize continuous numbers into a range. For example, 0, 1 should be converted to 0->1. A more useful application would be 2,3,4,5,6,7,8,9,10 can be summarized to 2->10.\\nHowever, if you have 0,2, there is a gap in the range, so you should return \"0\", \"2\".\\nExample: 0, 2, 3, 4, 5, 6, 7, 8, 10, 20, 25, 26, 27\\nTurns to: 0, 2->8, 10, 20, 25->27\\nYou can think of it in terms of how pages are referenced in bibliographies. Example: Python for Dummies. Pages: 1-4, 10 means pages 1 to 4 and page 10."
                    },
                    {
                        "username": "daring-calf",
                        "content": "The negative number got me!"
                    },
                    {
                        "username": "kartik_45",
                        "content": "Is it possible to solve using Binary search....if yes please reply....thanks in advance.."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "yes it is possible. but in worst case it\\'s time complexity is O(nlogn).\\neXAMPLE : 1 3 5 7 9 11.\\nSo in the above array for each element we have to run binary search."
                    },
                    {
                        "username": "rayrogar",
                        "content": "I wondered for about 20 minutes why this problem had so low acceptance rate (47.9% at this moment), below 50%, where is the trick!!!????"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Programmers Understimate this problem \\uD83D\\uDE02"
                    },
                    {
                        "username": "najwer23",
                        "content": "I love Mondays at LeetCode :D My favourite day of week last time!"
                    },
                    {
                        "username": "tahsinsiad27",
                        "content": "I am trying to implement using 1 loop. But got TLE. Can anyone explain where is my fault? How can I overcome this?\\n\\n ```class Solution {\\npublic:\\n    vector<string> summaryRanges(vector<int>& nums) {\\n        vector<string> ans;\\n        int start = 0, end = 0;\\n        int len = nums.size();\\n        while(start < len && end < len) {\\n            if (nums[end] + 1 == nums[end + 1]) {\\n                continue;\\n            } else {\\n                if (nums[start] != nums[end]) {\\n                    ans.push_back(to_string(nums[start]) + \"->\" + to_string(nums[end]));\\n                } else {\\n                    ans.push_back(to_string(nums[start]));\\n                }\\n                start = end;\\n            }\\n            end++;\\n        }\\n        return ans;\\n    }\\n}; "
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Problem in your code is, When your find nums[end] +1 == nums[end+1] then you need to increase end++ but you aren\\'t and just continuing the situation , which gives you TLE"
                    },
                    {
                        "username": "Aadil42",
                        "content": "Hmm, two forloops are not neccecery. You  can just have one forloop and have start variable. Iterate over the array. Whenever you find a difference of greater than 1 between two elements, that\\'s when you should make the range. Just get the start var and get the  current-1 index element. that\\'s it. yeah and update the start var to current index."
                    },
                    {
                        "username": "Aadil42",
                        "content": "Whenever LeetCode posts an easy problem for the daily challange. I get scared thinking what\\'s coming next \\uD83D\\uDE05\\uD83D\\uDE05."
                    },
                    {
                        "username": "JToaddler",
                        "content": "This is the key take away for me today:  \\n\\nRight way to check the continuity if a, b, c are in sorted sequence :\\n a  + 1 = b\\nDo not check the difference. b - a = 1 (this wont work)\\nIf you check the difference, it wont work for negative numbers and when sequence increase from -ve number to +ve number.\\n\\nGood question except the weird output."
                    },
                    {
                        "username": "psionl0",
                        "content": "Of course negative numbers work. \\nIf a = -6 and b = -5 then a + 1 = b AND b - a = 1"
                    },
                    {
                        "username": "suyash_5050",
                        "content": "Easy !"
                    }
                ]
            },
            {
                "id": 1926245,
                "content": [
                    {
                        "username": "codepiyush1",
                        "content": "--->Iterate until high+1==nums[i] i.e=>(nums[i-1]+1==nums[i]) continue.\n-->if the upper condition fail than check 2 more condition\n1->low!=high i.e= both low and high pointing to different index.\nto_string(low) + \"->\" + to_string(high)\n2->if low==high . i.e== both are pointing to same index.\nto_string(low).\n---->After this set low and high to current index.\n->After terminating the loop. check the condition 1 ,2 .\nreturn ans.\n\nSolution link Please upvote...If understand the concept.\nhttps://leetcode.com/problems/summary-ranges/solutions/3627986/c-java-python-understand-the-concept/"
                    },
                    {
                        "username": "niraj-pal",
                        "content": "Credit :-[@bjlslopez](/bjlslopez)\\n\\nIt is asking for you to summarize continuous numbers into a range. For example, 0, 1 should be converted to 0->1. A more useful application would be 2,3,4,5,6,7,8,9,10 can be summarized to 2->10.\\nHowever, if you have 0,2, there is a gap in the range, so you should return \"0\", \"2\".\\nExample: 0, 2, 3, 4, 5, 6, 7, 8, 10, 20, 25, 26, 27\\nTurns to: 0, 2->8, 10, 20, 25->27\\nYou can think of it in terms of how pages are referenced in bibliographies. Example: Python for Dummies. Pages: 1-4, 10 means pages 1 to 4 and page 10."
                    },
                    {
                        "username": "daring-calf",
                        "content": "The negative number got me!"
                    },
                    {
                        "username": "kartik_45",
                        "content": "Is it possible to solve using Binary search....if yes please reply....thanks in advance.."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "yes it is possible. but in worst case it\\'s time complexity is O(nlogn).\\neXAMPLE : 1 3 5 7 9 11.\\nSo in the above array for each element we have to run binary search."
                    },
                    {
                        "username": "rayrogar",
                        "content": "I wondered for about 20 minutes why this problem had so low acceptance rate (47.9% at this moment), below 50%, where is the trick!!!????"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Programmers Understimate this problem \\uD83D\\uDE02"
                    },
                    {
                        "username": "najwer23",
                        "content": "I love Mondays at LeetCode :D My favourite day of week last time!"
                    },
                    {
                        "username": "tahsinsiad27",
                        "content": "I am trying to implement using 1 loop. But got TLE. Can anyone explain where is my fault? How can I overcome this?\\n\\n ```class Solution {\\npublic:\\n    vector<string> summaryRanges(vector<int>& nums) {\\n        vector<string> ans;\\n        int start = 0, end = 0;\\n        int len = nums.size();\\n        while(start < len && end < len) {\\n            if (nums[end] + 1 == nums[end + 1]) {\\n                continue;\\n            } else {\\n                if (nums[start] != nums[end]) {\\n                    ans.push_back(to_string(nums[start]) + \"->\" + to_string(nums[end]));\\n                } else {\\n                    ans.push_back(to_string(nums[start]));\\n                }\\n                start = end;\\n            }\\n            end++;\\n        }\\n        return ans;\\n    }\\n}; "
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Problem in your code is, When your find nums[end] +1 == nums[end+1] then you need to increase end++ but you aren\\'t and just continuing the situation , which gives you TLE"
                    },
                    {
                        "username": "Aadil42",
                        "content": "Hmm, two forloops are not neccecery. You  can just have one forloop and have start variable. Iterate over the array. Whenever you find a difference of greater than 1 between two elements, that\\'s when you should make the range. Just get the start var and get the  current-1 index element. that\\'s it. yeah and update the start var to current index."
                    },
                    {
                        "username": "Aadil42",
                        "content": "Whenever LeetCode posts an easy problem for the daily challange. I get scared thinking what\\'s coming next \\uD83D\\uDE05\\uD83D\\uDE05."
                    },
                    {
                        "username": "JToaddler",
                        "content": "This is the key take away for me today:  \\n\\nRight way to check the continuity if a, b, c are in sorted sequence :\\n a  + 1 = b\\nDo not check the difference. b - a = 1 (this wont work)\\nIf you check the difference, it wont work for negative numbers and when sequence increase from -ve number to +ve number.\\n\\nGood question except the weird output."
                    },
                    {
                        "username": "psionl0",
                        "content": "Of course negative numbers work. \\nIf a = -6 and b = -5 then a + 1 = b AND b - a = 1"
                    },
                    {
                        "username": "suyash_5050",
                        "content": "Easy !"
                    }
                ]
            },
            {
                "id": 1926237,
                "content": [
                    {
                        "username": "codepiyush1",
                        "content": "--->Iterate until high+1==nums[i] i.e=>(nums[i-1]+1==nums[i]) continue.\n-->if the upper condition fail than check 2 more condition\n1->low!=high i.e= both low and high pointing to different index.\nto_string(low) + \"->\" + to_string(high)\n2->if low==high . i.e== both are pointing to same index.\nto_string(low).\n---->After this set low and high to current index.\n->After terminating the loop. check the condition 1 ,2 .\nreturn ans.\n\nSolution link Please upvote...If understand the concept.\nhttps://leetcode.com/problems/summary-ranges/solutions/3627986/c-java-python-understand-the-concept/"
                    },
                    {
                        "username": "niraj-pal",
                        "content": "Credit :-[@bjlslopez](/bjlslopez)\\n\\nIt is asking for you to summarize continuous numbers into a range. For example, 0, 1 should be converted to 0->1. A more useful application would be 2,3,4,5,6,7,8,9,10 can be summarized to 2->10.\\nHowever, if you have 0,2, there is a gap in the range, so you should return \"0\", \"2\".\\nExample: 0, 2, 3, 4, 5, 6, 7, 8, 10, 20, 25, 26, 27\\nTurns to: 0, 2->8, 10, 20, 25->27\\nYou can think of it in terms of how pages are referenced in bibliographies. Example: Python for Dummies. Pages: 1-4, 10 means pages 1 to 4 and page 10."
                    },
                    {
                        "username": "daring-calf",
                        "content": "The negative number got me!"
                    },
                    {
                        "username": "kartik_45",
                        "content": "Is it possible to solve using Binary search....if yes please reply....thanks in advance.."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "yes it is possible. but in worst case it\\'s time complexity is O(nlogn).\\neXAMPLE : 1 3 5 7 9 11.\\nSo in the above array for each element we have to run binary search."
                    },
                    {
                        "username": "rayrogar",
                        "content": "I wondered for about 20 minutes why this problem had so low acceptance rate (47.9% at this moment), below 50%, where is the trick!!!????"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Programmers Understimate this problem \\uD83D\\uDE02"
                    },
                    {
                        "username": "najwer23",
                        "content": "I love Mondays at LeetCode :D My favourite day of week last time!"
                    },
                    {
                        "username": "tahsinsiad27",
                        "content": "I am trying to implement using 1 loop. But got TLE. Can anyone explain where is my fault? How can I overcome this?\\n\\n ```class Solution {\\npublic:\\n    vector<string> summaryRanges(vector<int>& nums) {\\n        vector<string> ans;\\n        int start = 0, end = 0;\\n        int len = nums.size();\\n        while(start < len && end < len) {\\n            if (nums[end] + 1 == nums[end + 1]) {\\n                continue;\\n            } else {\\n                if (nums[start] != nums[end]) {\\n                    ans.push_back(to_string(nums[start]) + \"->\" + to_string(nums[end]));\\n                } else {\\n                    ans.push_back(to_string(nums[start]));\\n                }\\n                start = end;\\n            }\\n            end++;\\n        }\\n        return ans;\\n    }\\n}; "
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Problem in your code is, When your find nums[end] +1 == nums[end+1] then you need to increase end++ but you aren\\'t and just continuing the situation , which gives you TLE"
                    },
                    {
                        "username": "Aadil42",
                        "content": "Hmm, two forloops are not neccecery. You  can just have one forloop and have start variable. Iterate over the array. Whenever you find a difference of greater than 1 between two elements, that\\'s when you should make the range. Just get the start var and get the  current-1 index element. that\\'s it. yeah and update the start var to current index."
                    },
                    {
                        "username": "Aadil42",
                        "content": "Whenever LeetCode posts an easy problem for the daily challange. I get scared thinking what\\'s coming next \\uD83D\\uDE05\\uD83D\\uDE05."
                    },
                    {
                        "username": "JToaddler",
                        "content": "This is the key take away for me today:  \\n\\nRight way to check the continuity if a, b, c are in sorted sequence :\\n a  + 1 = b\\nDo not check the difference. b - a = 1 (this wont work)\\nIf you check the difference, it wont work for negative numbers and when sequence increase from -ve number to +ve number.\\n\\nGood question except the weird output."
                    },
                    {
                        "username": "psionl0",
                        "content": "Of course negative numbers work. \\nIf a = -6 and b = -5 then a + 1 = b AND b - a = 1"
                    },
                    {
                        "username": "suyash_5050",
                        "content": "Easy !"
                    }
                ]
            },
            {
                "id": 1926235,
                "content": [
                    {
                        "username": "codepiyush1",
                        "content": "--->Iterate until high+1==nums[i] i.e=>(nums[i-1]+1==nums[i]) continue.\n-->if the upper condition fail than check 2 more condition\n1->low!=high i.e= both low and high pointing to different index.\nto_string(low) + \"->\" + to_string(high)\n2->if low==high . i.e== both are pointing to same index.\nto_string(low).\n---->After this set low and high to current index.\n->After terminating the loop. check the condition 1 ,2 .\nreturn ans.\n\nSolution link Please upvote...If understand the concept.\nhttps://leetcode.com/problems/summary-ranges/solutions/3627986/c-java-python-understand-the-concept/"
                    },
                    {
                        "username": "niraj-pal",
                        "content": "Credit :-[@bjlslopez](/bjlslopez)\\n\\nIt is asking for you to summarize continuous numbers into a range. For example, 0, 1 should be converted to 0->1. A more useful application would be 2,3,4,5,6,7,8,9,10 can be summarized to 2->10.\\nHowever, if you have 0,2, there is a gap in the range, so you should return \"0\", \"2\".\\nExample: 0, 2, 3, 4, 5, 6, 7, 8, 10, 20, 25, 26, 27\\nTurns to: 0, 2->8, 10, 20, 25->27\\nYou can think of it in terms of how pages are referenced in bibliographies. Example: Python for Dummies. Pages: 1-4, 10 means pages 1 to 4 and page 10."
                    },
                    {
                        "username": "daring-calf",
                        "content": "The negative number got me!"
                    },
                    {
                        "username": "kartik_45",
                        "content": "Is it possible to solve using Binary search....if yes please reply....thanks in advance.."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "yes it is possible. but in worst case it\\'s time complexity is O(nlogn).\\neXAMPLE : 1 3 5 7 9 11.\\nSo in the above array for each element we have to run binary search."
                    },
                    {
                        "username": "rayrogar",
                        "content": "I wondered for about 20 minutes why this problem had so low acceptance rate (47.9% at this moment), below 50%, where is the trick!!!????"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Programmers Understimate this problem \\uD83D\\uDE02"
                    },
                    {
                        "username": "najwer23",
                        "content": "I love Mondays at LeetCode :D My favourite day of week last time!"
                    },
                    {
                        "username": "tahsinsiad27",
                        "content": "I am trying to implement using 1 loop. But got TLE. Can anyone explain where is my fault? How can I overcome this?\\n\\n ```class Solution {\\npublic:\\n    vector<string> summaryRanges(vector<int>& nums) {\\n        vector<string> ans;\\n        int start = 0, end = 0;\\n        int len = nums.size();\\n        while(start < len && end < len) {\\n            if (nums[end] + 1 == nums[end + 1]) {\\n                continue;\\n            } else {\\n                if (nums[start] != nums[end]) {\\n                    ans.push_back(to_string(nums[start]) + \"->\" + to_string(nums[end]));\\n                } else {\\n                    ans.push_back(to_string(nums[start]));\\n                }\\n                start = end;\\n            }\\n            end++;\\n        }\\n        return ans;\\n    }\\n}; "
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Problem in your code is, When your find nums[end] +1 == nums[end+1] then you need to increase end++ but you aren\\'t and just continuing the situation , which gives you TLE"
                    },
                    {
                        "username": "Aadil42",
                        "content": "Hmm, two forloops are not neccecery. You  can just have one forloop and have start variable. Iterate over the array. Whenever you find a difference of greater than 1 between two elements, that\\'s when you should make the range. Just get the start var and get the  current-1 index element. that\\'s it. yeah and update the start var to current index."
                    },
                    {
                        "username": "Aadil42",
                        "content": "Whenever LeetCode posts an easy problem for the daily challange. I get scared thinking what\\'s coming next \\uD83D\\uDE05\\uD83D\\uDE05."
                    },
                    {
                        "username": "JToaddler",
                        "content": "This is the key take away for me today:  \\n\\nRight way to check the continuity if a, b, c are in sorted sequence :\\n a  + 1 = b\\nDo not check the difference. b - a = 1 (this wont work)\\nIf you check the difference, it wont work for negative numbers and when sequence increase from -ve number to +ve number.\\n\\nGood question except the weird output."
                    },
                    {
                        "username": "psionl0",
                        "content": "Of course negative numbers work. \\nIf a = -6 and b = -5 then a + 1 = b AND b - a = 1"
                    },
                    {
                        "username": "suyash_5050",
                        "content": "Easy !"
                    }
                ]
            },
            {
                "id": 1926231,
                "content": [
                    {
                        "username": "codepiyush1",
                        "content": "--->Iterate until high+1==nums[i] i.e=>(nums[i-1]+1==nums[i]) continue.\n-->if the upper condition fail than check 2 more condition\n1->low!=high i.e= both low and high pointing to different index.\nto_string(low) + \"->\" + to_string(high)\n2->if low==high . i.e== both are pointing to same index.\nto_string(low).\n---->After this set low and high to current index.\n->After terminating the loop. check the condition 1 ,2 .\nreturn ans.\n\nSolution link Please upvote...If understand the concept.\nhttps://leetcode.com/problems/summary-ranges/solutions/3627986/c-java-python-understand-the-concept/"
                    },
                    {
                        "username": "niraj-pal",
                        "content": "Credit :-[@bjlslopez](/bjlslopez)\\n\\nIt is asking for you to summarize continuous numbers into a range. For example, 0, 1 should be converted to 0->1. A more useful application would be 2,3,4,5,6,7,8,9,10 can be summarized to 2->10.\\nHowever, if you have 0,2, there is a gap in the range, so you should return \"0\", \"2\".\\nExample: 0, 2, 3, 4, 5, 6, 7, 8, 10, 20, 25, 26, 27\\nTurns to: 0, 2->8, 10, 20, 25->27\\nYou can think of it in terms of how pages are referenced in bibliographies. Example: Python for Dummies. Pages: 1-4, 10 means pages 1 to 4 and page 10."
                    },
                    {
                        "username": "daring-calf",
                        "content": "The negative number got me!"
                    },
                    {
                        "username": "kartik_45",
                        "content": "Is it possible to solve using Binary search....if yes please reply....thanks in advance.."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "yes it is possible. but in worst case it\\'s time complexity is O(nlogn).\\neXAMPLE : 1 3 5 7 9 11.\\nSo in the above array for each element we have to run binary search."
                    },
                    {
                        "username": "rayrogar",
                        "content": "I wondered for about 20 minutes why this problem had so low acceptance rate (47.9% at this moment), below 50%, where is the trick!!!????"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Programmers Understimate this problem \\uD83D\\uDE02"
                    },
                    {
                        "username": "najwer23",
                        "content": "I love Mondays at LeetCode :D My favourite day of week last time!"
                    },
                    {
                        "username": "tahsinsiad27",
                        "content": "I am trying to implement using 1 loop. But got TLE. Can anyone explain where is my fault? How can I overcome this?\\n\\n ```class Solution {\\npublic:\\n    vector<string> summaryRanges(vector<int>& nums) {\\n        vector<string> ans;\\n        int start = 0, end = 0;\\n        int len = nums.size();\\n        while(start < len && end < len) {\\n            if (nums[end] + 1 == nums[end + 1]) {\\n                continue;\\n            } else {\\n                if (nums[start] != nums[end]) {\\n                    ans.push_back(to_string(nums[start]) + \"->\" + to_string(nums[end]));\\n                } else {\\n                    ans.push_back(to_string(nums[start]));\\n                }\\n                start = end;\\n            }\\n            end++;\\n        }\\n        return ans;\\n    }\\n}; "
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Problem in your code is, When your find nums[end] +1 == nums[end+1] then you need to increase end++ but you aren\\'t and just continuing the situation , which gives you TLE"
                    },
                    {
                        "username": "Aadil42",
                        "content": "Hmm, two forloops are not neccecery. You  can just have one forloop and have start variable. Iterate over the array. Whenever you find a difference of greater than 1 between two elements, that\\'s when you should make the range. Just get the start var and get the  current-1 index element. that\\'s it. yeah and update the start var to current index."
                    },
                    {
                        "username": "Aadil42",
                        "content": "Whenever LeetCode posts an easy problem for the daily challange. I get scared thinking what\\'s coming next \\uD83D\\uDE05\\uD83D\\uDE05."
                    },
                    {
                        "username": "JToaddler",
                        "content": "This is the key take away for me today:  \\n\\nRight way to check the continuity if a, b, c are in sorted sequence :\\n a  + 1 = b\\nDo not check the difference. b - a = 1 (this wont work)\\nIf you check the difference, it wont work for negative numbers and when sequence increase from -ve number to +ve number.\\n\\nGood question except the weird output."
                    },
                    {
                        "username": "psionl0",
                        "content": "Of course negative numbers work. \\nIf a = -6 and b = -5 then a + 1 = b AND b - a = 1"
                    },
                    {
                        "username": "suyash_5050",
                        "content": "Easy !"
                    }
                ]
            },
            {
                "id": 1926183,
                "content": [
                    {
                        "username": "codepiyush1",
                        "content": "--->Iterate until high+1==nums[i] i.e=>(nums[i-1]+1==nums[i]) continue.\n-->if the upper condition fail than check 2 more condition\n1->low!=high i.e= both low and high pointing to different index.\nto_string(low) + \"->\" + to_string(high)\n2->if low==high . i.e== both are pointing to same index.\nto_string(low).\n---->After this set low and high to current index.\n->After terminating the loop. check the condition 1 ,2 .\nreturn ans.\n\nSolution link Please upvote...If understand the concept.\nhttps://leetcode.com/problems/summary-ranges/solutions/3627986/c-java-python-understand-the-concept/"
                    },
                    {
                        "username": "niraj-pal",
                        "content": "Credit :-[@bjlslopez](/bjlslopez)\\n\\nIt is asking for you to summarize continuous numbers into a range. For example, 0, 1 should be converted to 0->1. A more useful application would be 2,3,4,5,6,7,8,9,10 can be summarized to 2->10.\\nHowever, if you have 0,2, there is a gap in the range, so you should return \"0\", \"2\".\\nExample: 0, 2, 3, 4, 5, 6, 7, 8, 10, 20, 25, 26, 27\\nTurns to: 0, 2->8, 10, 20, 25->27\\nYou can think of it in terms of how pages are referenced in bibliographies. Example: Python for Dummies. Pages: 1-4, 10 means pages 1 to 4 and page 10."
                    },
                    {
                        "username": "daring-calf",
                        "content": "The negative number got me!"
                    },
                    {
                        "username": "kartik_45",
                        "content": "Is it possible to solve using Binary search....if yes please reply....thanks in advance.."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "yes it is possible. but in worst case it\\'s time complexity is O(nlogn).\\neXAMPLE : 1 3 5 7 9 11.\\nSo in the above array for each element we have to run binary search."
                    },
                    {
                        "username": "rayrogar",
                        "content": "I wondered for about 20 minutes why this problem had so low acceptance rate (47.9% at this moment), below 50%, where is the trick!!!????"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Programmers Understimate this problem \\uD83D\\uDE02"
                    },
                    {
                        "username": "najwer23",
                        "content": "I love Mondays at LeetCode :D My favourite day of week last time!"
                    },
                    {
                        "username": "tahsinsiad27",
                        "content": "I am trying to implement using 1 loop. But got TLE. Can anyone explain where is my fault? How can I overcome this?\\n\\n ```class Solution {\\npublic:\\n    vector<string> summaryRanges(vector<int>& nums) {\\n        vector<string> ans;\\n        int start = 0, end = 0;\\n        int len = nums.size();\\n        while(start < len && end < len) {\\n            if (nums[end] + 1 == nums[end + 1]) {\\n                continue;\\n            } else {\\n                if (nums[start] != nums[end]) {\\n                    ans.push_back(to_string(nums[start]) + \"->\" + to_string(nums[end]));\\n                } else {\\n                    ans.push_back(to_string(nums[start]));\\n                }\\n                start = end;\\n            }\\n            end++;\\n        }\\n        return ans;\\n    }\\n}; "
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Problem in your code is, When your find nums[end] +1 == nums[end+1] then you need to increase end++ but you aren\\'t and just continuing the situation , which gives you TLE"
                    },
                    {
                        "username": "Aadil42",
                        "content": "Hmm, two forloops are not neccecery. You  can just have one forloop and have start variable. Iterate over the array. Whenever you find a difference of greater than 1 between two elements, that\\'s when you should make the range. Just get the start var and get the  current-1 index element. that\\'s it. yeah and update the start var to current index."
                    },
                    {
                        "username": "Aadil42",
                        "content": "Whenever LeetCode posts an easy problem for the daily challange. I get scared thinking what\\'s coming next \\uD83D\\uDE05\\uD83D\\uDE05."
                    },
                    {
                        "username": "JToaddler",
                        "content": "This is the key take away for me today:  \\n\\nRight way to check the continuity if a, b, c are in sorted sequence :\\n a  + 1 = b\\nDo not check the difference. b - a = 1 (this wont work)\\nIf you check the difference, it wont work for negative numbers and when sequence increase from -ve number to +ve number.\\n\\nGood question except the weird output."
                    },
                    {
                        "username": "psionl0",
                        "content": "Of course negative numbers work. \\nIf a = -6 and b = -5 then a + 1 = b AND b - a = 1"
                    },
                    {
                        "username": "suyash_5050",
                        "content": "Easy !"
                    }
                ]
            },
            {
                "id": 1926117,
                "content": [
                    {
                        "username": "kiryu_0",
                        "content": "Want what the problem setter was smoking before writing this description. Easy solution once you go through the examples yourself lmao"
                    },
                    {
                        "username": "swati_dubey",
                        "content": "Question is though and solution is easy"
                    },
                    {
                        "username": "psionl0",
                        "content": "``0 <= nums.length <= 20``\\nTHAT is why this is an easy question."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@breathermachine](/breathermachine) I don\\'t know why you keep arguing about this. In some cases it is possible to get a better than O(N) run time. Do you deny this? If they had wanted this question to be harder, they could have included data that would give a TLE if no optimization was attempted."
                    },
                    {
                        "username": "breathermachine",
                        "content": "[@psionl0](/psionl0) I don\\'t think you understand what amortized means, you can\\'t amortize the costs across test cases. They\\'re independent from each other. If all your inputs have no consecutive numbers, then you cannot go faster than O(N). \\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@breathermachine](/breathermachine) Did you read what you wrote? Worst case run time is O(N) when there are no consecutive numbers (same as linear search) but the best case run time is O(1) while linear search is still O(N). I\\'m pretty sure that the amortized run time will be O(log N)."
                    },
                    {
                        "username": "breathermachine",
                        "content": "[@psionl0](/psionl0) How would binary search handle the case where each number is its own range? Say [1, 3, 5, 7, 9, 11, ...]? Give me an algorithm that runs in less than O(N) and you win this whole argument :)"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@breathermachine](/breathermachine) Given that all the numbers are unique, it is easy enough to test if every number in a range is present without examining the whole array. You can take advantage of the fact that the difference between the start and end values should be the same as the number of numbers (minus 1) in the range. So a Binary search definitely seems feasible.\\n\\nWe could go back and forth about the difficulties of implementing a Binary Search in this problem but there is no need because the smallness of the array makes this moot."
                    },
                    {
                        "username": "breathermachine",
                        "content": "[@psionl0](/psionl0) True I might hit TLE, but sub O(N) solution isn\\'t possible for this problem because you\\'ll have to read all of the items in the array at least once. O(N) is the fastest solution, and with most O(N) problems here on LC, you can feed it thousands of items and it will still work fine."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@breathermachine](/breathermachine) If N=10^5 then I suspect that you might hit TLE on some of the larger arrays if you went for the O(N) solution. It may be necessary to switch to some form of Binary search of the array to locate the gaps."
                    },
                    {
                        "username": "breathermachine",
                        "content": "I think you worded it weirdly. If N=20, then you can go for a O(N^4) and still not hit TLE. Since the straightforward solution to this problem is O(N), you can go for much higher values of N, like 10^5. I assume most of the solutions here are O(N). So the size of the problem isn't what makes this problem easy. The problem itself is easy (from an implementation and a complexity standpoint)"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@breathermachine](/breathermachine) N=20 which is why O(N) is all you need. We are iterating through the array - not the entire range of possible values."
                    },
                    {
                        "username": "breathermachine",
                        "content": "Nope. Solution is O(N), which can easily accommodate up to 10^5"
                    },
                    {
                        "username": "khe1154",
                        "content": "the question is easy but the wording is terrible."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "There\\'s some boring teacher who got a job at leetcode and who really wants to make sure we check for the empty array on every problem before we have the right to think about anything else"
                    },
                    {
                        "username": "rk1148",
                        "content": "I really not able to understand what is the concept of the question"
                    },
                    {
                        "username": "dmitvitalii",
                        "content": "I don\\'t really understand how I got this error\\n\\nI made different test cases, tried to pass [-1], but Leetcode doesn\\'t allow to do that\\n```\\n=================================================================\\n==34==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000294 at pc 0x0000003467d9 bp 0x7ffff7035b70 sp 0x7ffff7035b68\\nREAD of size 4 at 0x602000000294 thread T0\\n    #2 0x7f378d7200b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\n0x602000000294 is located 0 bytes to the right of 4-byte region [0x602000000290,0x602000000294)\\nallocated by thread T0 here:\\n    #6 0x7f378d7200b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\nShadow bytes around the buggy address:\\n  0x0c047fff8000: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\\n  0x0c047fff8010: fa fa fd fd fa fa fd fa fa fa fd fa fa fa fd fa\\n  0x0c047fff8020: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fd\\n  0x0c047fff8030: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\\n  0x0c047fff8040: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\\n=>0x0c047fff8050: fa fa[04]fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8060: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8070: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8080: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8090: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff80a0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\nShadow byte legend (one shadow byte represents 8 application bytes):\\n  Addressable:           00\\n  Partially addressable: 01 02 03 04 05 06 07 \\n  Heap left redzone:       fa\\n  Freed heap region:       fd\\n  Stack left redzone:      f1\\n  Stack mid redzone:       f2\\n  Stack right redzone:     f3\\n  Stack after return:      f5\\n  Stack use after scope:   f8\\n  Global redzone:          f9\\n  Global init order:       f6\\n  Poisoned by user:        f7\\n  Container overflow:      fc\\n  Array cookie:            ac\\n  Intra object redzone:    bb\\n  ASan internal:           fe\\n  Left alloca redzone:     ca\\n  Right alloca redzone:    cb\\n  Shadow gap:              cc\\n==34==ABORTING\\n```\\n\\n3 / 29 testcases passed\\n\\nLast Executed Input\\n```\\nnums =\\n[-1]\\n```"
                    },
                    {
                        "username": "psionl0",
                        "content": "My guess is that your code expects a second number in the array."
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n    vector<string> summaryRanges(vector<int>&arr)\\n{\\n    int n  = arr.size();\\n    vector<string>ans;\\n\\n    int i=0;\\n\\n    while(i<n)\\n    {\\n        string temp = \"\";\\n        temp +=to_string(arr[i]);\\n        int nums = arr[i]; //store arr[0] value\\n\\n        while(i+1<n && arr[i+1] ==arr[i] +1 ) //arr[i+1] = index 0+1 where a[i] +1 a[0] +1 \\n         {                                     //next index value diffence of jump\\n\\n                    i++; //if arr[0+1] ==a[0]+1 then i++\\n\\n         }   \\n         if(arr[i] != nums)  //arr[i]   = current i index \\n                             //nums = initial state where arr[0] store\\n         {\\n             temp +=\"->\";\\n             temp +=to_string(arr[i]);\\n         } \\n         ans.push_back(temp);\\n         i++;                                     \\n    }\\n    return ans;\\n}\\n};"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "haugf",
                        "content": "The indices in this question have been killing me"
                    }
                ]
            },
            {
                "id": 1926095,
                "content": [
                    {
                        "username": "kiryu_0",
                        "content": "Want what the problem setter was smoking before writing this description. Easy solution once you go through the examples yourself lmao"
                    },
                    {
                        "username": "swati_dubey",
                        "content": "Question is though and solution is easy"
                    },
                    {
                        "username": "psionl0",
                        "content": "``0 <= nums.length <= 20``\\nTHAT is why this is an easy question."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@breathermachine](/breathermachine) I don\\'t know why you keep arguing about this. In some cases it is possible to get a better than O(N) run time. Do you deny this? If they had wanted this question to be harder, they could have included data that would give a TLE if no optimization was attempted."
                    },
                    {
                        "username": "breathermachine",
                        "content": "[@psionl0](/psionl0) I don\\'t think you understand what amortized means, you can\\'t amortize the costs across test cases. They\\'re independent from each other. If all your inputs have no consecutive numbers, then you cannot go faster than O(N). \\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@breathermachine](/breathermachine) Did you read what you wrote? Worst case run time is O(N) when there are no consecutive numbers (same as linear search) but the best case run time is O(1) while linear search is still O(N). I\\'m pretty sure that the amortized run time will be O(log N)."
                    },
                    {
                        "username": "breathermachine",
                        "content": "[@psionl0](/psionl0) How would binary search handle the case where each number is its own range? Say [1, 3, 5, 7, 9, 11, ...]? Give me an algorithm that runs in less than O(N) and you win this whole argument :)"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@breathermachine](/breathermachine) Given that all the numbers are unique, it is easy enough to test if every number in a range is present without examining the whole array. You can take advantage of the fact that the difference between the start and end values should be the same as the number of numbers (minus 1) in the range. So a Binary search definitely seems feasible.\\n\\nWe could go back and forth about the difficulties of implementing a Binary Search in this problem but there is no need because the smallness of the array makes this moot."
                    },
                    {
                        "username": "breathermachine",
                        "content": "[@psionl0](/psionl0) True I might hit TLE, but sub O(N) solution isn\\'t possible for this problem because you\\'ll have to read all of the items in the array at least once. O(N) is the fastest solution, and with most O(N) problems here on LC, you can feed it thousands of items and it will still work fine."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@breathermachine](/breathermachine) If N=10^5 then I suspect that you might hit TLE on some of the larger arrays if you went for the O(N) solution. It may be necessary to switch to some form of Binary search of the array to locate the gaps."
                    },
                    {
                        "username": "breathermachine",
                        "content": "I think you worded it weirdly. If N=20, then you can go for a O(N^4) and still not hit TLE. Since the straightforward solution to this problem is O(N), you can go for much higher values of N, like 10^5. I assume most of the solutions here are O(N). So the size of the problem isn't what makes this problem easy. The problem itself is easy (from an implementation and a complexity standpoint)"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@breathermachine](/breathermachine) N=20 which is why O(N) is all you need. We are iterating through the array - not the entire range of possible values."
                    },
                    {
                        "username": "breathermachine",
                        "content": "Nope. Solution is O(N), which can easily accommodate up to 10^5"
                    },
                    {
                        "username": "khe1154",
                        "content": "the question is easy but the wording is terrible."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "There\\'s some boring teacher who got a job at leetcode and who really wants to make sure we check for the empty array on every problem before we have the right to think about anything else"
                    },
                    {
                        "username": "rk1148",
                        "content": "I really not able to understand what is the concept of the question"
                    },
                    {
                        "username": "dmitvitalii",
                        "content": "I don\\'t really understand how I got this error\\n\\nI made different test cases, tried to pass [-1], but Leetcode doesn\\'t allow to do that\\n```\\n=================================================================\\n==34==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000294 at pc 0x0000003467d9 bp 0x7ffff7035b70 sp 0x7ffff7035b68\\nREAD of size 4 at 0x602000000294 thread T0\\n    #2 0x7f378d7200b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\n0x602000000294 is located 0 bytes to the right of 4-byte region [0x602000000290,0x602000000294)\\nallocated by thread T0 here:\\n    #6 0x7f378d7200b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\nShadow bytes around the buggy address:\\n  0x0c047fff8000: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\\n  0x0c047fff8010: fa fa fd fd fa fa fd fa fa fa fd fa fa fa fd fa\\n  0x0c047fff8020: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fd\\n  0x0c047fff8030: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\\n  0x0c047fff8040: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\\n=>0x0c047fff8050: fa fa[04]fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8060: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8070: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8080: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8090: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff80a0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\nShadow byte legend (one shadow byte represents 8 application bytes):\\n  Addressable:           00\\n  Partially addressable: 01 02 03 04 05 06 07 \\n  Heap left redzone:       fa\\n  Freed heap region:       fd\\n  Stack left redzone:      f1\\n  Stack mid redzone:       f2\\n  Stack right redzone:     f3\\n  Stack after return:      f5\\n  Stack use after scope:   f8\\n  Global redzone:          f9\\n  Global init order:       f6\\n  Poisoned by user:        f7\\n  Container overflow:      fc\\n  Array cookie:            ac\\n  Intra object redzone:    bb\\n  ASan internal:           fe\\n  Left alloca redzone:     ca\\n  Right alloca redzone:    cb\\n  Shadow gap:              cc\\n==34==ABORTING\\n```\\n\\n3 / 29 testcases passed\\n\\nLast Executed Input\\n```\\nnums =\\n[-1]\\n```"
                    },
                    {
                        "username": "psionl0",
                        "content": "My guess is that your code expects a second number in the array."
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n    vector<string> summaryRanges(vector<int>&arr)\\n{\\n    int n  = arr.size();\\n    vector<string>ans;\\n\\n    int i=0;\\n\\n    while(i<n)\\n    {\\n        string temp = \"\";\\n        temp +=to_string(arr[i]);\\n        int nums = arr[i]; //store arr[0] value\\n\\n        while(i+1<n && arr[i+1] ==arr[i] +1 ) //arr[i+1] = index 0+1 where a[i] +1 a[0] +1 \\n         {                                     //next index value diffence of jump\\n\\n                    i++; //if arr[0+1] ==a[0]+1 then i++\\n\\n         }   \\n         if(arr[i] != nums)  //arr[i]   = current i index \\n                             //nums = initial state where arr[0] store\\n         {\\n             temp +=\"->\";\\n             temp +=to_string(arr[i]);\\n         } \\n         ans.push_back(temp);\\n         i++;                                     \\n    }\\n    return ans;\\n}\\n};"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "haugf",
                        "content": "The indices in this question have been killing me"
                    }
                ]
            },
            {
                "id": 1926069,
                "content": [
                    {
                        "username": "kiryu_0",
                        "content": "Want what the problem setter was smoking before writing this description. Easy solution once you go through the examples yourself lmao"
                    },
                    {
                        "username": "swati_dubey",
                        "content": "Question is though and solution is easy"
                    },
                    {
                        "username": "psionl0",
                        "content": "``0 <= nums.length <= 20``\\nTHAT is why this is an easy question."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@breathermachine](/breathermachine) I don\\'t know why you keep arguing about this. In some cases it is possible to get a better than O(N) run time. Do you deny this? If they had wanted this question to be harder, they could have included data that would give a TLE if no optimization was attempted."
                    },
                    {
                        "username": "breathermachine",
                        "content": "[@psionl0](/psionl0) I don\\'t think you understand what amortized means, you can\\'t amortize the costs across test cases. They\\'re independent from each other. If all your inputs have no consecutive numbers, then you cannot go faster than O(N). \\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@breathermachine](/breathermachine) Did you read what you wrote? Worst case run time is O(N) when there are no consecutive numbers (same as linear search) but the best case run time is O(1) while linear search is still O(N). I\\'m pretty sure that the amortized run time will be O(log N)."
                    },
                    {
                        "username": "breathermachine",
                        "content": "[@psionl0](/psionl0) How would binary search handle the case where each number is its own range? Say [1, 3, 5, 7, 9, 11, ...]? Give me an algorithm that runs in less than O(N) and you win this whole argument :)"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@breathermachine](/breathermachine) Given that all the numbers are unique, it is easy enough to test if every number in a range is present without examining the whole array. You can take advantage of the fact that the difference between the start and end values should be the same as the number of numbers (minus 1) in the range. So a Binary search definitely seems feasible.\\n\\nWe could go back and forth about the difficulties of implementing a Binary Search in this problem but there is no need because the smallness of the array makes this moot."
                    },
                    {
                        "username": "breathermachine",
                        "content": "[@psionl0](/psionl0) True I might hit TLE, but sub O(N) solution isn\\'t possible for this problem because you\\'ll have to read all of the items in the array at least once. O(N) is the fastest solution, and with most O(N) problems here on LC, you can feed it thousands of items and it will still work fine."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@breathermachine](/breathermachine) If N=10^5 then I suspect that you might hit TLE on some of the larger arrays if you went for the O(N) solution. It may be necessary to switch to some form of Binary search of the array to locate the gaps."
                    },
                    {
                        "username": "breathermachine",
                        "content": "I think you worded it weirdly. If N=20, then you can go for a O(N^4) and still not hit TLE. Since the straightforward solution to this problem is O(N), you can go for much higher values of N, like 10^5. I assume most of the solutions here are O(N). So the size of the problem isn't what makes this problem easy. The problem itself is easy (from an implementation and a complexity standpoint)"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@breathermachine](/breathermachine) N=20 which is why O(N) is all you need. We are iterating through the array - not the entire range of possible values."
                    },
                    {
                        "username": "breathermachine",
                        "content": "Nope. Solution is O(N), which can easily accommodate up to 10^5"
                    },
                    {
                        "username": "khe1154",
                        "content": "the question is easy but the wording is terrible."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "There\\'s some boring teacher who got a job at leetcode and who really wants to make sure we check for the empty array on every problem before we have the right to think about anything else"
                    },
                    {
                        "username": "rk1148",
                        "content": "I really not able to understand what is the concept of the question"
                    },
                    {
                        "username": "dmitvitalii",
                        "content": "I don\\'t really understand how I got this error\\n\\nI made different test cases, tried to pass [-1], but Leetcode doesn\\'t allow to do that\\n```\\n=================================================================\\n==34==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000294 at pc 0x0000003467d9 bp 0x7ffff7035b70 sp 0x7ffff7035b68\\nREAD of size 4 at 0x602000000294 thread T0\\n    #2 0x7f378d7200b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\n0x602000000294 is located 0 bytes to the right of 4-byte region [0x602000000290,0x602000000294)\\nallocated by thread T0 here:\\n    #6 0x7f378d7200b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\nShadow bytes around the buggy address:\\n  0x0c047fff8000: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\\n  0x0c047fff8010: fa fa fd fd fa fa fd fa fa fa fd fa fa fa fd fa\\n  0x0c047fff8020: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fd\\n  0x0c047fff8030: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\\n  0x0c047fff8040: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\\n=>0x0c047fff8050: fa fa[04]fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8060: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8070: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8080: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8090: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff80a0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\nShadow byte legend (one shadow byte represents 8 application bytes):\\n  Addressable:           00\\n  Partially addressable: 01 02 03 04 05 06 07 \\n  Heap left redzone:       fa\\n  Freed heap region:       fd\\n  Stack left redzone:      f1\\n  Stack mid redzone:       f2\\n  Stack right redzone:     f3\\n  Stack after return:      f5\\n  Stack use after scope:   f8\\n  Global redzone:          f9\\n  Global init order:       f6\\n  Poisoned by user:        f7\\n  Container overflow:      fc\\n  Array cookie:            ac\\n  Intra object redzone:    bb\\n  ASan internal:           fe\\n  Left alloca redzone:     ca\\n  Right alloca redzone:    cb\\n  Shadow gap:              cc\\n==34==ABORTING\\n```\\n\\n3 / 29 testcases passed\\n\\nLast Executed Input\\n```\\nnums =\\n[-1]\\n```"
                    },
                    {
                        "username": "psionl0",
                        "content": "My guess is that your code expects a second number in the array."
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n    vector<string> summaryRanges(vector<int>&arr)\\n{\\n    int n  = arr.size();\\n    vector<string>ans;\\n\\n    int i=0;\\n\\n    while(i<n)\\n    {\\n        string temp = \"\";\\n        temp +=to_string(arr[i]);\\n        int nums = arr[i]; //store arr[0] value\\n\\n        while(i+1<n && arr[i+1] ==arr[i] +1 ) //arr[i+1] = index 0+1 where a[i] +1 a[0] +1 \\n         {                                     //next index value diffence of jump\\n\\n                    i++; //if arr[0+1] ==a[0]+1 then i++\\n\\n         }   \\n         if(arr[i] != nums)  //arr[i]   = current i index \\n                             //nums = initial state where arr[0] store\\n         {\\n             temp +=\"->\";\\n             temp +=to_string(arr[i]);\\n         } \\n         ans.push_back(temp);\\n         i++;                                     \\n    }\\n    return ans;\\n}\\n};"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "haugf",
                        "content": "The indices in this question have been killing me"
                    }
                ]
            },
            {
                "id": 1926060,
                "content": [
                    {
                        "username": "kiryu_0",
                        "content": "Want what the problem setter was smoking before writing this description. Easy solution once you go through the examples yourself lmao"
                    },
                    {
                        "username": "swati_dubey",
                        "content": "Question is though and solution is easy"
                    },
                    {
                        "username": "psionl0",
                        "content": "``0 <= nums.length <= 20``\\nTHAT is why this is an easy question."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@breathermachine](/breathermachine) I don\\'t know why you keep arguing about this. In some cases it is possible to get a better than O(N) run time. Do you deny this? If they had wanted this question to be harder, they could have included data that would give a TLE if no optimization was attempted."
                    },
                    {
                        "username": "breathermachine",
                        "content": "[@psionl0](/psionl0) I don\\'t think you understand what amortized means, you can\\'t amortize the costs across test cases. They\\'re independent from each other. If all your inputs have no consecutive numbers, then you cannot go faster than O(N). \\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@breathermachine](/breathermachine) Did you read what you wrote? Worst case run time is O(N) when there are no consecutive numbers (same as linear search) but the best case run time is O(1) while linear search is still O(N). I\\'m pretty sure that the amortized run time will be O(log N)."
                    },
                    {
                        "username": "breathermachine",
                        "content": "[@psionl0](/psionl0) How would binary search handle the case where each number is its own range? Say [1, 3, 5, 7, 9, 11, ...]? Give me an algorithm that runs in less than O(N) and you win this whole argument :)"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@breathermachine](/breathermachine) Given that all the numbers are unique, it is easy enough to test if every number in a range is present without examining the whole array. You can take advantage of the fact that the difference between the start and end values should be the same as the number of numbers (minus 1) in the range. So a Binary search definitely seems feasible.\\n\\nWe could go back and forth about the difficulties of implementing a Binary Search in this problem but there is no need because the smallness of the array makes this moot."
                    },
                    {
                        "username": "breathermachine",
                        "content": "[@psionl0](/psionl0) True I might hit TLE, but sub O(N) solution isn\\'t possible for this problem because you\\'ll have to read all of the items in the array at least once. O(N) is the fastest solution, and with most O(N) problems here on LC, you can feed it thousands of items and it will still work fine."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@breathermachine](/breathermachine) If N=10^5 then I suspect that you might hit TLE on some of the larger arrays if you went for the O(N) solution. It may be necessary to switch to some form of Binary search of the array to locate the gaps."
                    },
                    {
                        "username": "breathermachine",
                        "content": "I think you worded it weirdly. If N=20, then you can go for a O(N^4) and still not hit TLE. Since the straightforward solution to this problem is O(N), you can go for much higher values of N, like 10^5. I assume most of the solutions here are O(N). So the size of the problem isn't what makes this problem easy. The problem itself is easy (from an implementation and a complexity standpoint)"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@breathermachine](/breathermachine) N=20 which is why O(N) is all you need. We are iterating through the array - not the entire range of possible values."
                    },
                    {
                        "username": "breathermachine",
                        "content": "Nope. Solution is O(N), which can easily accommodate up to 10^5"
                    },
                    {
                        "username": "khe1154",
                        "content": "the question is easy but the wording is terrible."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "There\\'s some boring teacher who got a job at leetcode and who really wants to make sure we check for the empty array on every problem before we have the right to think about anything else"
                    },
                    {
                        "username": "rk1148",
                        "content": "I really not able to understand what is the concept of the question"
                    },
                    {
                        "username": "dmitvitalii",
                        "content": "I don\\'t really understand how I got this error\\n\\nI made different test cases, tried to pass [-1], but Leetcode doesn\\'t allow to do that\\n```\\n=================================================================\\n==34==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000294 at pc 0x0000003467d9 bp 0x7ffff7035b70 sp 0x7ffff7035b68\\nREAD of size 4 at 0x602000000294 thread T0\\n    #2 0x7f378d7200b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\n0x602000000294 is located 0 bytes to the right of 4-byte region [0x602000000290,0x602000000294)\\nallocated by thread T0 here:\\n    #6 0x7f378d7200b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\nShadow bytes around the buggy address:\\n  0x0c047fff8000: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\\n  0x0c047fff8010: fa fa fd fd fa fa fd fa fa fa fd fa fa fa fd fa\\n  0x0c047fff8020: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fd\\n  0x0c047fff8030: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\\n  0x0c047fff8040: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\\n=>0x0c047fff8050: fa fa[04]fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8060: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8070: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8080: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8090: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff80a0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\nShadow byte legend (one shadow byte represents 8 application bytes):\\n  Addressable:           00\\n  Partially addressable: 01 02 03 04 05 06 07 \\n  Heap left redzone:       fa\\n  Freed heap region:       fd\\n  Stack left redzone:      f1\\n  Stack mid redzone:       f2\\n  Stack right redzone:     f3\\n  Stack after return:      f5\\n  Stack use after scope:   f8\\n  Global redzone:          f9\\n  Global init order:       f6\\n  Poisoned by user:        f7\\n  Container overflow:      fc\\n  Array cookie:            ac\\n  Intra object redzone:    bb\\n  ASan internal:           fe\\n  Left alloca redzone:     ca\\n  Right alloca redzone:    cb\\n  Shadow gap:              cc\\n==34==ABORTING\\n```\\n\\n3 / 29 testcases passed\\n\\nLast Executed Input\\n```\\nnums =\\n[-1]\\n```"
                    },
                    {
                        "username": "psionl0",
                        "content": "My guess is that your code expects a second number in the array."
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n    vector<string> summaryRanges(vector<int>&arr)\\n{\\n    int n  = arr.size();\\n    vector<string>ans;\\n\\n    int i=0;\\n\\n    while(i<n)\\n    {\\n        string temp = \"\";\\n        temp +=to_string(arr[i]);\\n        int nums = arr[i]; //store arr[0] value\\n\\n        while(i+1<n && arr[i+1] ==arr[i] +1 ) //arr[i+1] = index 0+1 where a[i] +1 a[0] +1 \\n         {                                     //next index value diffence of jump\\n\\n                    i++; //if arr[0+1] ==a[0]+1 then i++\\n\\n         }   \\n         if(arr[i] != nums)  //arr[i]   = current i index \\n                             //nums = initial state where arr[0] store\\n         {\\n             temp +=\"->\";\\n             temp +=to_string(arr[i]);\\n         } \\n         ans.push_back(temp);\\n         i++;                                     \\n    }\\n    return ans;\\n}\\n};"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "haugf",
                        "content": "The indices in this question have been killing me"
                    }
                ]
            },
            {
                "id": 1867593,
                "content": [
                    {
                        "username": "kiryu_0",
                        "content": "Want what the problem setter was smoking before writing this description. Easy solution once you go through the examples yourself lmao"
                    },
                    {
                        "username": "swati_dubey",
                        "content": "Question is though and solution is easy"
                    },
                    {
                        "username": "psionl0",
                        "content": "``0 <= nums.length <= 20``\\nTHAT is why this is an easy question."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@breathermachine](/breathermachine) I don\\'t know why you keep arguing about this. In some cases it is possible to get a better than O(N) run time. Do you deny this? If they had wanted this question to be harder, they could have included data that would give a TLE if no optimization was attempted."
                    },
                    {
                        "username": "breathermachine",
                        "content": "[@psionl0](/psionl0) I don\\'t think you understand what amortized means, you can\\'t amortize the costs across test cases. They\\'re independent from each other. If all your inputs have no consecutive numbers, then you cannot go faster than O(N). \\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@breathermachine](/breathermachine) Did you read what you wrote? Worst case run time is O(N) when there are no consecutive numbers (same as linear search) but the best case run time is O(1) while linear search is still O(N). I\\'m pretty sure that the amortized run time will be O(log N)."
                    },
                    {
                        "username": "breathermachine",
                        "content": "[@psionl0](/psionl0) How would binary search handle the case where each number is its own range? Say [1, 3, 5, 7, 9, 11, ...]? Give me an algorithm that runs in less than O(N) and you win this whole argument :)"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@breathermachine](/breathermachine) Given that all the numbers are unique, it is easy enough to test if every number in a range is present without examining the whole array. You can take advantage of the fact that the difference between the start and end values should be the same as the number of numbers (minus 1) in the range. So a Binary search definitely seems feasible.\\n\\nWe could go back and forth about the difficulties of implementing a Binary Search in this problem but there is no need because the smallness of the array makes this moot."
                    },
                    {
                        "username": "breathermachine",
                        "content": "[@psionl0](/psionl0) True I might hit TLE, but sub O(N) solution isn\\'t possible for this problem because you\\'ll have to read all of the items in the array at least once. O(N) is the fastest solution, and with most O(N) problems here on LC, you can feed it thousands of items and it will still work fine."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@breathermachine](/breathermachine) If N=10^5 then I suspect that you might hit TLE on some of the larger arrays if you went for the O(N) solution. It may be necessary to switch to some form of Binary search of the array to locate the gaps."
                    },
                    {
                        "username": "breathermachine",
                        "content": "I think you worded it weirdly. If N=20, then you can go for a O(N^4) and still not hit TLE. Since the straightforward solution to this problem is O(N), you can go for much higher values of N, like 10^5. I assume most of the solutions here are O(N). So the size of the problem isn't what makes this problem easy. The problem itself is easy (from an implementation and a complexity standpoint)"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@breathermachine](/breathermachine) N=20 which is why O(N) is all you need. We are iterating through the array - not the entire range of possible values."
                    },
                    {
                        "username": "breathermachine",
                        "content": "Nope. Solution is O(N), which can easily accommodate up to 10^5"
                    },
                    {
                        "username": "khe1154",
                        "content": "the question is easy but the wording is terrible."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "There\\'s some boring teacher who got a job at leetcode and who really wants to make sure we check for the empty array on every problem before we have the right to think about anything else"
                    },
                    {
                        "username": "rk1148",
                        "content": "I really not able to understand what is the concept of the question"
                    },
                    {
                        "username": "dmitvitalii",
                        "content": "I don\\'t really understand how I got this error\\n\\nI made different test cases, tried to pass [-1], but Leetcode doesn\\'t allow to do that\\n```\\n=================================================================\\n==34==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000294 at pc 0x0000003467d9 bp 0x7ffff7035b70 sp 0x7ffff7035b68\\nREAD of size 4 at 0x602000000294 thread T0\\n    #2 0x7f378d7200b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\n0x602000000294 is located 0 bytes to the right of 4-byte region [0x602000000290,0x602000000294)\\nallocated by thread T0 here:\\n    #6 0x7f378d7200b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\nShadow bytes around the buggy address:\\n  0x0c047fff8000: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\\n  0x0c047fff8010: fa fa fd fd fa fa fd fa fa fa fd fa fa fa fd fa\\n  0x0c047fff8020: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fd\\n  0x0c047fff8030: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\\n  0x0c047fff8040: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\\n=>0x0c047fff8050: fa fa[04]fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8060: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8070: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8080: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8090: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff80a0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\nShadow byte legend (one shadow byte represents 8 application bytes):\\n  Addressable:           00\\n  Partially addressable: 01 02 03 04 05 06 07 \\n  Heap left redzone:       fa\\n  Freed heap region:       fd\\n  Stack left redzone:      f1\\n  Stack mid redzone:       f2\\n  Stack right redzone:     f3\\n  Stack after return:      f5\\n  Stack use after scope:   f8\\n  Global redzone:          f9\\n  Global init order:       f6\\n  Poisoned by user:        f7\\n  Container overflow:      fc\\n  Array cookie:            ac\\n  Intra object redzone:    bb\\n  ASan internal:           fe\\n  Left alloca redzone:     ca\\n  Right alloca redzone:    cb\\n  Shadow gap:              cc\\n==34==ABORTING\\n```\\n\\n3 / 29 testcases passed\\n\\nLast Executed Input\\n```\\nnums =\\n[-1]\\n```"
                    },
                    {
                        "username": "psionl0",
                        "content": "My guess is that your code expects a second number in the array."
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n    vector<string> summaryRanges(vector<int>&arr)\\n{\\n    int n  = arr.size();\\n    vector<string>ans;\\n\\n    int i=0;\\n\\n    while(i<n)\\n    {\\n        string temp = \"\";\\n        temp +=to_string(arr[i]);\\n        int nums = arr[i]; //store arr[0] value\\n\\n        while(i+1<n && arr[i+1] ==arr[i] +1 ) //arr[i+1] = index 0+1 where a[i] +1 a[0] +1 \\n         {                                     //next index value diffence of jump\\n\\n                    i++; //if arr[0+1] ==a[0]+1 then i++\\n\\n         }   \\n         if(arr[i] != nums)  //arr[i]   = current i index \\n                             //nums = initial state where arr[0] store\\n         {\\n             temp +=\"->\";\\n             temp +=to_string(arr[i]);\\n         } \\n         ans.push_back(temp);\\n         i++;                                     \\n    }\\n    return ans;\\n}\\n};"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "haugf",
                        "content": "The indices in this question have been killing me"
                    }
                ]
            },
            {
                "id": 1816341,
                "content": [
                    {
                        "username": "kiryu_0",
                        "content": "Want what the problem setter was smoking before writing this description. Easy solution once you go through the examples yourself lmao"
                    },
                    {
                        "username": "swati_dubey",
                        "content": "Question is though and solution is easy"
                    },
                    {
                        "username": "psionl0",
                        "content": "``0 <= nums.length <= 20``\\nTHAT is why this is an easy question."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@breathermachine](/breathermachine) I don\\'t know why you keep arguing about this. In some cases it is possible to get a better than O(N) run time. Do you deny this? If they had wanted this question to be harder, they could have included data that would give a TLE if no optimization was attempted."
                    },
                    {
                        "username": "breathermachine",
                        "content": "[@psionl0](/psionl0) I don\\'t think you understand what amortized means, you can\\'t amortize the costs across test cases. They\\'re independent from each other. If all your inputs have no consecutive numbers, then you cannot go faster than O(N). \\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@breathermachine](/breathermachine) Did you read what you wrote? Worst case run time is O(N) when there are no consecutive numbers (same as linear search) but the best case run time is O(1) while linear search is still O(N). I\\'m pretty sure that the amortized run time will be O(log N)."
                    },
                    {
                        "username": "breathermachine",
                        "content": "[@psionl0](/psionl0) How would binary search handle the case where each number is its own range? Say [1, 3, 5, 7, 9, 11, ...]? Give me an algorithm that runs in less than O(N) and you win this whole argument :)"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@breathermachine](/breathermachine) Given that all the numbers are unique, it is easy enough to test if every number in a range is present without examining the whole array. You can take advantage of the fact that the difference between the start and end values should be the same as the number of numbers (minus 1) in the range. So a Binary search definitely seems feasible.\\n\\nWe could go back and forth about the difficulties of implementing a Binary Search in this problem but there is no need because the smallness of the array makes this moot."
                    },
                    {
                        "username": "breathermachine",
                        "content": "[@psionl0](/psionl0) True I might hit TLE, but sub O(N) solution isn\\'t possible for this problem because you\\'ll have to read all of the items in the array at least once. O(N) is the fastest solution, and with most O(N) problems here on LC, you can feed it thousands of items and it will still work fine."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@breathermachine](/breathermachine) If N=10^5 then I suspect that you might hit TLE on some of the larger arrays if you went for the O(N) solution. It may be necessary to switch to some form of Binary search of the array to locate the gaps."
                    },
                    {
                        "username": "breathermachine",
                        "content": "I think you worded it weirdly. If N=20, then you can go for a O(N^4) and still not hit TLE. Since the straightforward solution to this problem is O(N), you can go for much higher values of N, like 10^5. I assume most of the solutions here are O(N). So the size of the problem isn't what makes this problem easy. The problem itself is easy (from an implementation and a complexity standpoint)"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@breathermachine](/breathermachine) N=20 which is why O(N) is all you need. We are iterating through the array - not the entire range of possible values."
                    },
                    {
                        "username": "breathermachine",
                        "content": "Nope. Solution is O(N), which can easily accommodate up to 10^5"
                    },
                    {
                        "username": "khe1154",
                        "content": "the question is easy but the wording is terrible."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "There\\'s some boring teacher who got a job at leetcode and who really wants to make sure we check for the empty array on every problem before we have the right to think about anything else"
                    },
                    {
                        "username": "rk1148",
                        "content": "I really not able to understand what is the concept of the question"
                    },
                    {
                        "username": "dmitvitalii",
                        "content": "I don\\'t really understand how I got this error\\n\\nI made different test cases, tried to pass [-1], but Leetcode doesn\\'t allow to do that\\n```\\n=================================================================\\n==34==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000294 at pc 0x0000003467d9 bp 0x7ffff7035b70 sp 0x7ffff7035b68\\nREAD of size 4 at 0x602000000294 thread T0\\n    #2 0x7f378d7200b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\n0x602000000294 is located 0 bytes to the right of 4-byte region [0x602000000290,0x602000000294)\\nallocated by thread T0 here:\\n    #6 0x7f378d7200b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\nShadow bytes around the buggy address:\\n  0x0c047fff8000: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\\n  0x0c047fff8010: fa fa fd fd fa fa fd fa fa fa fd fa fa fa fd fa\\n  0x0c047fff8020: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fd\\n  0x0c047fff8030: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\\n  0x0c047fff8040: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\\n=>0x0c047fff8050: fa fa[04]fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8060: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8070: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8080: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8090: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff80a0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\nShadow byte legend (one shadow byte represents 8 application bytes):\\n  Addressable:           00\\n  Partially addressable: 01 02 03 04 05 06 07 \\n  Heap left redzone:       fa\\n  Freed heap region:       fd\\n  Stack left redzone:      f1\\n  Stack mid redzone:       f2\\n  Stack right redzone:     f3\\n  Stack after return:      f5\\n  Stack use after scope:   f8\\n  Global redzone:          f9\\n  Global init order:       f6\\n  Poisoned by user:        f7\\n  Container overflow:      fc\\n  Array cookie:            ac\\n  Intra object redzone:    bb\\n  ASan internal:           fe\\n  Left alloca redzone:     ca\\n  Right alloca redzone:    cb\\n  Shadow gap:              cc\\n==34==ABORTING\\n```\\n\\n3 / 29 testcases passed\\n\\nLast Executed Input\\n```\\nnums =\\n[-1]\\n```"
                    },
                    {
                        "username": "psionl0",
                        "content": "My guess is that your code expects a second number in the array."
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n    vector<string> summaryRanges(vector<int>&arr)\\n{\\n    int n  = arr.size();\\n    vector<string>ans;\\n\\n    int i=0;\\n\\n    while(i<n)\\n    {\\n        string temp = \"\";\\n        temp +=to_string(arr[i]);\\n        int nums = arr[i]; //store arr[0] value\\n\\n        while(i+1<n && arr[i+1] ==arr[i] +1 ) //arr[i+1] = index 0+1 where a[i] +1 a[0] +1 \\n         {                                     //next index value diffence of jump\\n\\n                    i++; //if arr[0+1] ==a[0]+1 then i++\\n\\n         }   \\n         if(arr[i] != nums)  //arr[i]   = current i index \\n                             //nums = initial state where arr[0] store\\n         {\\n             temp +=\"->\";\\n             temp +=to_string(arr[i]);\\n         } \\n         ans.push_back(temp);\\n         i++;                                     \\n    }\\n    return ans;\\n}\\n};"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "haugf",
                        "content": "The indices in this question have been killing me"
                    }
                ]
            },
            {
                "id": 1805441,
                "content": [
                    {
                        "username": "kiryu_0",
                        "content": "Want what the problem setter was smoking before writing this description. Easy solution once you go through the examples yourself lmao"
                    },
                    {
                        "username": "swati_dubey",
                        "content": "Question is though and solution is easy"
                    },
                    {
                        "username": "psionl0",
                        "content": "``0 <= nums.length <= 20``\\nTHAT is why this is an easy question."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@breathermachine](/breathermachine) I don\\'t know why you keep arguing about this. In some cases it is possible to get a better than O(N) run time. Do you deny this? If they had wanted this question to be harder, they could have included data that would give a TLE if no optimization was attempted."
                    },
                    {
                        "username": "breathermachine",
                        "content": "[@psionl0](/psionl0) I don\\'t think you understand what amortized means, you can\\'t amortize the costs across test cases. They\\'re independent from each other. If all your inputs have no consecutive numbers, then you cannot go faster than O(N). \\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@breathermachine](/breathermachine) Did you read what you wrote? Worst case run time is O(N) when there are no consecutive numbers (same as linear search) but the best case run time is O(1) while linear search is still O(N). I\\'m pretty sure that the amortized run time will be O(log N)."
                    },
                    {
                        "username": "breathermachine",
                        "content": "[@psionl0](/psionl0) How would binary search handle the case where each number is its own range? Say [1, 3, 5, 7, 9, 11, ...]? Give me an algorithm that runs in less than O(N) and you win this whole argument :)"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@breathermachine](/breathermachine) Given that all the numbers are unique, it is easy enough to test if every number in a range is present without examining the whole array. You can take advantage of the fact that the difference between the start and end values should be the same as the number of numbers (minus 1) in the range. So a Binary search definitely seems feasible.\\n\\nWe could go back and forth about the difficulties of implementing a Binary Search in this problem but there is no need because the smallness of the array makes this moot."
                    },
                    {
                        "username": "breathermachine",
                        "content": "[@psionl0](/psionl0) True I might hit TLE, but sub O(N) solution isn\\'t possible for this problem because you\\'ll have to read all of the items in the array at least once. O(N) is the fastest solution, and with most O(N) problems here on LC, you can feed it thousands of items and it will still work fine."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@breathermachine](/breathermachine) If N=10^5 then I suspect that you might hit TLE on some of the larger arrays if you went for the O(N) solution. It may be necessary to switch to some form of Binary search of the array to locate the gaps."
                    },
                    {
                        "username": "breathermachine",
                        "content": "I think you worded it weirdly. If N=20, then you can go for a O(N^4) and still not hit TLE. Since the straightforward solution to this problem is O(N), you can go for much higher values of N, like 10^5. I assume most of the solutions here are O(N). So the size of the problem isn't what makes this problem easy. The problem itself is easy (from an implementation and a complexity standpoint)"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@breathermachine](/breathermachine) N=20 which is why O(N) is all you need. We are iterating through the array - not the entire range of possible values."
                    },
                    {
                        "username": "breathermachine",
                        "content": "Nope. Solution is O(N), which can easily accommodate up to 10^5"
                    },
                    {
                        "username": "khe1154",
                        "content": "the question is easy but the wording is terrible."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "There\\'s some boring teacher who got a job at leetcode and who really wants to make sure we check for the empty array on every problem before we have the right to think about anything else"
                    },
                    {
                        "username": "rk1148",
                        "content": "I really not able to understand what is the concept of the question"
                    },
                    {
                        "username": "dmitvitalii",
                        "content": "I don\\'t really understand how I got this error\\n\\nI made different test cases, tried to pass [-1], but Leetcode doesn\\'t allow to do that\\n```\\n=================================================================\\n==34==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000294 at pc 0x0000003467d9 bp 0x7ffff7035b70 sp 0x7ffff7035b68\\nREAD of size 4 at 0x602000000294 thread T0\\n    #2 0x7f378d7200b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\n0x602000000294 is located 0 bytes to the right of 4-byte region [0x602000000290,0x602000000294)\\nallocated by thread T0 here:\\n    #6 0x7f378d7200b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\nShadow bytes around the buggy address:\\n  0x0c047fff8000: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\\n  0x0c047fff8010: fa fa fd fd fa fa fd fa fa fa fd fa fa fa fd fa\\n  0x0c047fff8020: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fd\\n  0x0c047fff8030: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\\n  0x0c047fff8040: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\\n=>0x0c047fff8050: fa fa[04]fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8060: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8070: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8080: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8090: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff80a0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\nShadow byte legend (one shadow byte represents 8 application bytes):\\n  Addressable:           00\\n  Partially addressable: 01 02 03 04 05 06 07 \\n  Heap left redzone:       fa\\n  Freed heap region:       fd\\n  Stack left redzone:      f1\\n  Stack mid redzone:       f2\\n  Stack right redzone:     f3\\n  Stack after return:      f5\\n  Stack use after scope:   f8\\n  Global redzone:          f9\\n  Global init order:       f6\\n  Poisoned by user:        f7\\n  Container overflow:      fc\\n  Array cookie:            ac\\n  Intra object redzone:    bb\\n  ASan internal:           fe\\n  Left alloca redzone:     ca\\n  Right alloca redzone:    cb\\n  Shadow gap:              cc\\n==34==ABORTING\\n```\\n\\n3 / 29 testcases passed\\n\\nLast Executed Input\\n```\\nnums =\\n[-1]\\n```"
                    },
                    {
                        "username": "psionl0",
                        "content": "My guess is that your code expects a second number in the array."
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n    vector<string> summaryRanges(vector<int>&arr)\\n{\\n    int n  = arr.size();\\n    vector<string>ans;\\n\\n    int i=0;\\n\\n    while(i<n)\\n    {\\n        string temp = \"\";\\n        temp +=to_string(arr[i]);\\n        int nums = arr[i]; //store arr[0] value\\n\\n        while(i+1<n && arr[i+1] ==arr[i] +1 ) //arr[i+1] = index 0+1 where a[i] +1 a[0] +1 \\n         {                                     //next index value diffence of jump\\n\\n                    i++; //if arr[0+1] ==a[0]+1 then i++\\n\\n         }   \\n         if(arr[i] != nums)  //arr[i]   = current i index \\n                             //nums = initial state where arr[0] store\\n         {\\n             temp +=\"->\";\\n             temp +=to_string(arr[i]);\\n         } \\n         ans.push_back(temp);\\n         i++;                                     \\n    }\\n    return ans;\\n}\\n};"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "haugf",
                        "content": "The indices in this question have been killing me"
                    }
                ]
            },
            {
                "id": 1796413,
                "content": [
                    {
                        "username": "kiryu_0",
                        "content": "Want what the problem setter was smoking before writing this description. Easy solution once you go through the examples yourself lmao"
                    },
                    {
                        "username": "swati_dubey",
                        "content": "Question is though and solution is easy"
                    },
                    {
                        "username": "psionl0",
                        "content": "``0 <= nums.length <= 20``\\nTHAT is why this is an easy question."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@breathermachine](/breathermachine) I don\\'t know why you keep arguing about this. In some cases it is possible to get a better than O(N) run time. Do you deny this? If they had wanted this question to be harder, they could have included data that would give a TLE if no optimization was attempted."
                    },
                    {
                        "username": "breathermachine",
                        "content": "[@psionl0](/psionl0) I don\\'t think you understand what amortized means, you can\\'t amortize the costs across test cases. They\\'re independent from each other. If all your inputs have no consecutive numbers, then you cannot go faster than O(N). \\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@breathermachine](/breathermachine) Did you read what you wrote? Worst case run time is O(N) when there are no consecutive numbers (same as linear search) but the best case run time is O(1) while linear search is still O(N). I\\'m pretty sure that the amortized run time will be O(log N)."
                    },
                    {
                        "username": "breathermachine",
                        "content": "[@psionl0](/psionl0) How would binary search handle the case where each number is its own range? Say [1, 3, 5, 7, 9, 11, ...]? Give me an algorithm that runs in less than O(N) and you win this whole argument :)"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@breathermachine](/breathermachine) Given that all the numbers are unique, it is easy enough to test if every number in a range is present without examining the whole array. You can take advantage of the fact that the difference between the start and end values should be the same as the number of numbers (minus 1) in the range. So a Binary search definitely seems feasible.\\n\\nWe could go back and forth about the difficulties of implementing a Binary Search in this problem but there is no need because the smallness of the array makes this moot."
                    },
                    {
                        "username": "breathermachine",
                        "content": "[@psionl0](/psionl0) True I might hit TLE, but sub O(N) solution isn\\'t possible for this problem because you\\'ll have to read all of the items in the array at least once. O(N) is the fastest solution, and with most O(N) problems here on LC, you can feed it thousands of items and it will still work fine."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@breathermachine](/breathermachine) If N=10^5 then I suspect that you might hit TLE on some of the larger arrays if you went for the O(N) solution. It may be necessary to switch to some form of Binary search of the array to locate the gaps."
                    },
                    {
                        "username": "breathermachine",
                        "content": "I think you worded it weirdly. If N=20, then you can go for a O(N^4) and still not hit TLE. Since the straightforward solution to this problem is O(N), you can go for much higher values of N, like 10^5. I assume most of the solutions here are O(N). So the size of the problem isn't what makes this problem easy. The problem itself is easy (from an implementation and a complexity standpoint)"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@breathermachine](/breathermachine) N=20 which is why O(N) is all you need. We are iterating through the array - not the entire range of possible values."
                    },
                    {
                        "username": "breathermachine",
                        "content": "Nope. Solution is O(N), which can easily accommodate up to 10^5"
                    },
                    {
                        "username": "khe1154",
                        "content": "the question is easy but the wording is terrible."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "There\\'s some boring teacher who got a job at leetcode and who really wants to make sure we check for the empty array on every problem before we have the right to think about anything else"
                    },
                    {
                        "username": "rk1148",
                        "content": "I really not able to understand what is the concept of the question"
                    },
                    {
                        "username": "dmitvitalii",
                        "content": "I don\\'t really understand how I got this error\\n\\nI made different test cases, tried to pass [-1], but Leetcode doesn\\'t allow to do that\\n```\\n=================================================================\\n==34==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000294 at pc 0x0000003467d9 bp 0x7ffff7035b70 sp 0x7ffff7035b68\\nREAD of size 4 at 0x602000000294 thread T0\\n    #2 0x7f378d7200b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\n0x602000000294 is located 0 bytes to the right of 4-byte region [0x602000000290,0x602000000294)\\nallocated by thread T0 here:\\n    #6 0x7f378d7200b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\nShadow bytes around the buggy address:\\n  0x0c047fff8000: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\\n  0x0c047fff8010: fa fa fd fd fa fa fd fa fa fa fd fa fa fa fd fa\\n  0x0c047fff8020: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fd\\n  0x0c047fff8030: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\\n  0x0c047fff8040: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\\n=>0x0c047fff8050: fa fa[04]fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8060: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8070: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8080: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8090: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff80a0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\nShadow byte legend (one shadow byte represents 8 application bytes):\\n  Addressable:           00\\n  Partially addressable: 01 02 03 04 05 06 07 \\n  Heap left redzone:       fa\\n  Freed heap region:       fd\\n  Stack left redzone:      f1\\n  Stack mid redzone:       f2\\n  Stack right redzone:     f3\\n  Stack after return:      f5\\n  Stack use after scope:   f8\\n  Global redzone:          f9\\n  Global init order:       f6\\n  Poisoned by user:        f7\\n  Container overflow:      fc\\n  Array cookie:            ac\\n  Intra object redzone:    bb\\n  ASan internal:           fe\\n  Left alloca redzone:     ca\\n  Right alloca redzone:    cb\\n  Shadow gap:              cc\\n==34==ABORTING\\n```\\n\\n3 / 29 testcases passed\\n\\nLast Executed Input\\n```\\nnums =\\n[-1]\\n```"
                    },
                    {
                        "username": "psionl0",
                        "content": "My guess is that your code expects a second number in the array."
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n    vector<string> summaryRanges(vector<int>&arr)\\n{\\n    int n  = arr.size();\\n    vector<string>ans;\\n\\n    int i=0;\\n\\n    while(i<n)\\n    {\\n        string temp = \"\";\\n        temp +=to_string(arr[i]);\\n        int nums = arr[i]; //store arr[0] value\\n\\n        while(i+1<n && arr[i+1] ==arr[i] +1 ) //arr[i+1] = index 0+1 where a[i] +1 a[0] +1 \\n         {                                     //next index value diffence of jump\\n\\n                    i++; //if arr[0+1] ==a[0]+1 then i++\\n\\n         }   \\n         if(arr[i] != nums)  //arr[i]   = current i index \\n                             //nums = initial state where arr[0] store\\n         {\\n             temp +=\"->\";\\n             temp +=to_string(arr[i]);\\n         } \\n         ans.push_back(temp);\\n         i++;                                     \\n    }\\n    return ans;\\n}\\n};"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "haugf",
                        "content": "The indices in this question have been killing me"
                    }
                ]
            },
            {
                "id": 1757543,
                "content": [
                    {
                        "username": "kiryu_0",
                        "content": "Want what the problem setter was smoking before writing this description. Easy solution once you go through the examples yourself lmao"
                    },
                    {
                        "username": "swati_dubey",
                        "content": "Question is though and solution is easy"
                    },
                    {
                        "username": "psionl0",
                        "content": "``0 <= nums.length <= 20``\\nTHAT is why this is an easy question."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@breathermachine](/breathermachine) I don\\'t know why you keep arguing about this. In some cases it is possible to get a better than O(N) run time. Do you deny this? If they had wanted this question to be harder, they could have included data that would give a TLE if no optimization was attempted."
                    },
                    {
                        "username": "breathermachine",
                        "content": "[@psionl0](/psionl0) I don\\'t think you understand what amortized means, you can\\'t amortize the costs across test cases. They\\'re independent from each other. If all your inputs have no consecutive numbers, then you cannot go faster than O(N). \\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@breathermachine](/breathermachine) Did you read what you wrote? Worst case run time is O(N) when there are no consecutive numbers (same as linear search) but the best case run time is O(1) while linear search is still O(N). I\\'m pretty sure that the amortized run time will be O(log N)."
                    },
                    {
                        "username": "breathermachine",
                        "content": "[@psionl0](/psionl0) How would binary search handle the case where each number is its own range? Say [1, 3, 5, 7, 9, 11, ...]? Give me an algorithm that runs in less than O(N) and you win this whole argument :)"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@breathermachine](/breathermachine) Given that all the numbers are unique, it is easy enough to test if every number in a range is present without examining the whole array. You can take advantage of the fact that the difference between the start and end values should be the same as the number of numbers (minus 1) in the range. So a Binary search definitely seems feasible.\\n\\nWe could go back and forth about the difficulties of implementing a Binary Search in this problem but there is no need because the smallness of the array makes this moot."
                    },
                    {
                        "username": "breathermachine",
                        "content": "[@psionl0](/psionl0) True I might hit TLE, but sub O(N) solution isn\\'t possible for this problem because you\\'ll have to read all of the items in the array at least once. O(N) is the fastest solution, and with most O(N) problems here on LC, you can feed it thousands of items and it will still work fine."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@breathermachine](/breathermachine) If N=10^5 then I suspect that you might hit TLE on some of the larger arrays if you went for the O(N) solution. It may be necessary to switch to some form of Binary search of the array to locate the gaps."
                    },
                    {
                        "username": "breathermachine",
                        "content": "I think you worded it weirdly. If N=20, then you can go for a O(N^4) and still not hit TLE. Since the straightforward solution to this problem is O(N), you can go for much higher values of N, like 10^5. I assume most of the solutions here are O(N). So the size of the problem isn't what makes this problem easy. The problem itself is easy (from an implementation and a complexity standpoint)"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@breathermachine](/breathermachine) N=20 which is why O(N) is all you need. We are iterating through the array - not the entire range of possible values."
                    },
                    {
                        "username": "breathermachine",
                        "content": "Nope. Solution is O(N), which can easily accommodate up to 10^5"
                    },
                    {
                        "username": "khe1154",
                        "content": "the question is easy but the wording is terrible."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "There\\'s some boring teacher who got a job at leetcode and who really wants to make sure we check for the empty array on every problem before we have the right to think about anything else"
                    },
                    {
                        "username": "rk1148",
                        "content": "I really not able to understand what is the concept of the question"
                    },
                    {
                        "username": "dmitvitalii",
                        "content": "I don\\'t really understand how I got this error\\n\\nI made different test cases, tried to pass [-1], but Leetcode doesn\\'t allow to do that\\n```\\n=================================================================\\n==34==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000294 at pc 0x0000003467d9 bp 0x7ffff7035b70 sp 0x7ffff7035b68\\nREAD of size 4 at 0x602000000294 thread T0\\n    #2 0x7f378d7200b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\n0x602000000294 is located 0 bytes to the right of 4-byte region [0x602000000290,0x602000000294)\\nallocated by thread T0 here:\\n    #6 0x7f378d7200b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\nShadow bytes around the buggy address:\\n  0x0c047fff8000: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\\n  0x0c047fff8010: fa fa fd fd fa fa fd fa fa fa fd fa fa fa fd fa\\n  0x0c047fff8020: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fd\\n  0x0c047fff8030: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\\n  0x0c047fff8040: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\\n=>0x0c047fff8050: fa fa[04]fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8060: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8070: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8080: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8090: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff80a0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\nShadow byte legend (one shadow byte represents 8 application bytes):\\n  Addressable:           00\\n  Partially addressable: 01 02 03 04 05 06 07 \\n  Heap left redzone:       fa\\n  Freed heap region:       fd\\n  Stack left redzone:      f1\\n  Stack mid redzone:       f2\\n  Stack right redzone:     f3\\n  Stack after return:      f5\\n  Stack use after scope:   f8\\n  Global redzone:          f9\\n  Global init order:       f6\\n  Poisoned by user:        f7\\n  Container overflow:      fc\\n  Array cookie:            ac\\n  Intra object redzone:    bb\\n  ASan internal:           fe\\n  Left alloca redzone:     ca\\n  Right alloca redzone:    cb\\n  Shadow gap:              cc\\n==34==ABORTING\\n```\\n\\n3 / 29 testcases passed\\n\\nLast Executed Input\\n```\\nnums =\\n[-1]\\n```"
                    },
                    {
                        "username": "psionl0",
                        "content": "My guess is that your code expects a second number in the array."
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n    vector<string> summaryRanges(vector<int>&arr)\\n{\\n    int n  = arr.size();\\n    vector<string>ans;\\n\\n    int i=0;\\n\\n    while(i<n)\\n    {\\n        string temp = \"\";\\n        temp +=to_string(arr[i]);\\n        int nums = arr[i]; //store arr[0] value\\n\\n        while(i+1<n && arr[i+1] ==arr[i] +1 ) //arr[i+1] = index 0+1 where a[i] +1 a[0] +1 \\n         {                                     //next index value diffence of jump\\n\\n                    i++; //if arr[0+1] ==a[0]+1 then i++\\n\\n         }   \\n         if(arr[i] != nums)  //arr[i]   = current i index \\n                             //nums = initial state where arr[0] store\\n         {\\n             temp +=\"->\";\\n             temp +=to_string(arr[i]);\\n         } \\n         ans.push_back(temp);\\n         i++;                                     \\n    }\\n    return ans;\\n}\\n};"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "haugf",
                        "content": "The indices in this question have been killing me"
                    }
                ]
            },
            {
                "id": 1713589,
                "content": [
                    {
                        "username": "kiryu_0",
                        "content": "Want what the problem setter was smoking before writing this description. Easy solution once you go through the examples yourself lmao"
                    },
                    {
                        "username": "swati_dubey",
                        "content": "Question is though and solution is easy"
                    },
                    {
                        "username": "psionl0",
                        "content": "``0 <= nums.length <= 20``\\nTHAT is why this is an easy question."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@breathermachine](/breathermachine) I don\\'t know why you keep arguing about this. In some cases it is possible to get a better than O(N) run time. Do you deny this? If they had wanted this question to be harder, they could have included data that would give a TLE if no optimization was attempted."
                    },
                    {
                        "username": "breathermachine",
                        "content": "[@psionl0](/psionl0) I don\\'t think you understand what amortized means, you can\\'t amortize the costs across test cases. They\\'re independent from each other. If all your inputs have no consecutive numbers, then you cannot go faster than O(N). \\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@breathermachine](/breathermachine) Did you read what you wrote? Worst case run time is O(N) when there are no consecutive numbers (same as linear search) but the best case run time is O(1) while linear search is still O(N). I\\'m pretty sure that the amortized run time will be O(log N)."
                    },
                    {
                        "username": "breathermachine",
                        "content": "[@psionl0](/psionl0) How would binary search handle the case where each number is its own range? Say [1, 3, 5, 7, 9, 11, ...]? Give me an algorithm that runs in less than O(N) and you win this whole argument :)"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@breathermachine](/breathermachine) Given that all the numbers are unique, it is easy enough to test if every number in a range is present without examining the whole array. You can take advantage of the fact that the difference between the start and end values should be the same as the number of numbers (minus 1) in the range. So a Binary search definitely seems feasible.\\n\\nWe could go back and forth about the difficulties of implementing a Binary Search in this problem but there is no need because the smallness of the array makes this moot."
                    },
                    {
                        "username": "breathermachine",
                        "content": "[@psionl0](/psionl0) True I might hit TLE, but sub O(N) solution isn\\'t possible for this problem because you\\'ll have to read all of the items in the array at least once. O(N) is the fastest solution, and with most O(N) problems here on LC, you can feed it thousands of items and it will still work fine."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@breathermachine](/breathermachine) If N=10^5 then I suspect that you might hit TLE on some of the larger arrays if you went for the O(N) solution. It may be necessary to switch to some form of Binary search of the array to locate the gaps."
                    },
                    {
                        "username": "breathermachine",
                        "content": "I think you worded it weirdly. If N=20, then you can go for a O(N^4) and still not hit TLE. Since the straightforward solution to this problem is O(N), you can go for much higher values of N, like 10^5. I assume most of the solutions here are O(N). So the size of the problem isn't what makes this problem easy. The problem itself is easy (from an implementation and a complexity standpoint)"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@breathermachine](/breathermachine) N=20 which is why O(N) is all you need. We are iterating through the array - not the entire range of possible values."
                    },
                    {
                        "username": "breathermachine",
                        "content": "Nope. Solution is O(N), which can easily accommodate up to 10^5"
                    },
                    {
                        "username": "khe1154",
                        "content": "the question is easy but the wording is terrible."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "There\\'s some boring teacher who got a job at leetcode and who really wants to make sure we check for the empty array on every problem before we have the right to think about anything else"
                    },
                    {
                        "username": "rk1148",
                        "content": "I really not able to understand what is the concept of the question"
                    },
                    {
                        "username": "dmitvitalii",
                        "content": "I don\\'t really understand how I got this error\\n\\nI made different test cases, tried to pass [-1], but Leetcode doesn\\'t allow to do that\\n```\\n=================================================================\\n==34==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000294 at pc 0x0000003467d9 bp 0x7ffff7035b70 sp 0x7ffff7035b68\\nREAD of size 4 at 0x602000000294 thread T0\\n    #2 0x7f378d7200b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\n0x602000000294 is located 0 bytes to the right of 4-byte region [0x602000000290,0x602000000294)\\nallocated by thread T0 here:\\n    #6 0x7f378d7200b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\nShadow bytes around the buggy address:\\n  0x0c047fff8000: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\\n  0x0c047fff8010: fa fa fd fd fa fa fd fa fa fa fd fa fa fa fd fa\\n  0x0c047fff8020: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fd\\n  0x0c047fff8030: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\\n  0x0c047fff8040: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\\n=>0x0c047fff8050: fa fa[04]fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8060: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8070: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8080: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8090: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff80a0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\nShadow byte legend (one shadow byte represents 8 application bytes):\\n  Addressable:           00\\n  Partially addressable: 01 02 03 04 05 06 07 \\n  Heap left redzone:       fa\\n  Freed heap region:       fd\\n  Stack left redzone:      f1\\n  Stack mid redzone:       f2\\n  Stack right redzone:     f3\\n  Stack after return:      f5\\n  Stack use after scope:   f8\\n  Global redzone:          f9\\n  Global init order:       f6\\n  Poisoned by user:        f7\\n  Container overflow:      fc\\n  Array cookie:            ac\\n  Intra object redzone:    bb\\n  ASan internal:           fe\\n  Left alloca redzone:     ca\\n  Right alloca redzone:    cb\\n  Shadow gap:              cc\\n==34==ABORTING\\n```\\n\\n3 / 29 testcases passed\\n\\nLast Executed Input\\n```\\nnums =\\n[-1]\\n```"
                    },
                    {
                        "username": "psionl0",
                        "content": "My guess is that your code expects a second number in the array."
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n    vector<string> summaryRanges(vector<int>&arr)\\n{\\n    int n  = arr.size();\\n    vector<string>ans;\\n\\n    int i=0;\\n\\n    while(i<n)\\n    {\\n        string temp = \"\";\\n        temp +=to_string(arr[i]);\\n        int nums = arr[i]; //store arr[0] value\\n\\n        while(i+1<n && arr[i+1] ==arr[i] +1 ) //arr[i+1] = index 0+1 where a[i] +1 a[0] +1 \\n         {                                     //next index value diffence of jump\\n\\n                    i++; //if arr[0+1] ==a[0]+1 then i++\\n\\n         }   \\n         if(arr[i] != nums)  //arr[i]   = current i index \\n                             //nums = initial state where arr[0] store\\n         {\\n             temp +=\"->\";\\n             temp +=to_string(arr[i]);\\n         } \\n         ans.push_back(temp);\\n         i++;                                     \\n    }\\n    return ans;\\n}\\n};"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "haugf",
                        "content": "The indices in this question have been killing me"
                    }
                ]
            }
        ]
    }
]