[
    {
        "title": "Frog Jump II",
        "question_content": "You are given a 0-indexed integer array stones sorted in strictly increasing order representing the positions of stones in a river.\nA frog, initially on the first stone, wants to travel to the last stone and then return to the first stone. However, it can jump to any stone at most once.\nThe length of a jump is the absolute difference between the position of the stone the frog is currently on and the position of the stone to which the frog jumps.\n\n\tMore formally, if the frog is at stones[i] and is jumping to stones[j], the length of the jump is |stones[i] - stones[j]|.\n\nThe cost of a path is the maximum length of a jump among all jumps in the path.\nReturn the minimum cost of a path for the frog.\n&nbsp;\nExample 1:\n\nInput: stones = [0,2,5,6,7]\nOutput: 5\nExplanation: The above figure represents one of the optimal paths the frog can take.\nThe cost of this path is 5, which is the maximum length of a jump.\nSince it is not possible to achieve a cost of less than 5, we return it.\n\nExample 2:\n\nInput: stones = [0,3,9]\nOutput: 9\nExplanation: \nThe frog can jump directly to the last stone and come back to the first stone. \nIn this case, the length of each jump will be 9. The cost for the path will be max(9, 9) = 9.\nIt can be shown that this is the minimum achievable cost.\n\n&nbsp;\nConstraints:\n\n\t2 <= stones.length <= 105\n\t0 <= stones[i] <= 109\n\tstones[0] == 0\n\tstones is sorted in a strictly increasing order.",
        "solutions": [
            {
                "id": 2897888,
                "title": "it-s-greedy-even-and-odd",
                "content": "Claim 1: It is optimal that we make use of all rocks: There is never a benefit of not including a rock in Path 1 or Path 2, it is always positive or neutral.\\nClaim 2: It is never optimal to choose two consecutive rocks: If we choose rock_i, and rock_i+1, then rock_i+2 will have to do (rock_i+2)-(rock_i) work to return. Because the array is strictly increasing, it holds that (rock_i+2)-(rock_i) > (rock_i+1-rock_i)\\nTherefore one path must lie on each even index and the other path must lie on each odd index. We iterate through them and find the maximum distance.\\n\\n```\\nclass Solution {\\npublic:\\n    int maxJump(vector<int>& stones) {\\n        int res = stones[1]-stones[0]; // store max difference\\n        for(int i = 3; i < stones.size(); i+=2) res = max(res, stones[i]-stones[i-2]); // odd path\\n        for(int i = 2; i < stones.size(); i+=2) res = max(res, stones[i]-stones[i-2]); // even path\\n        return res;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int maxJump(vector<int>& stones) {\\n        int res = stones[1]-stones[0]; // store max difference\\n        for(int i = 3; i < stones.size(); i+=2) res = max(res, stones[i]-stones[i-2]); // odd path\\n        for(int i = 2; i < stones.size(); i+=2) res = max(res, stones[i]-stones[i-2]); // even path\\n        return res;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2897948,
                "title": "java-c-python-max-a-i-a-i-2",
                "content": "# **Intuition 1**\\n\"travel to the last stone and then return to the first stone.\"\\nIt means there are two path from first to last stone,\\nand two path have no intersection in the middle.\\nWe can image there are two frog jump from first to the last.\\n\\n\\n# **Intuition 2**\\nIf one stone not in path one and path 2,\\nwe can greedily add it to either of the path.\\nSo it exists a best solution, that all stones are used.\\n<br>\\n\\n# **Explanation**\\nSo we are going to assign stones to two frogs alternatively:\\n`A[0]  A[1]\\tA[2]  A[3]\\t...`\\n`start frog1 frog2 frog1 ...`\\n\\nIf we assign them not alternatively like:\\n`frog1 frog2 frog2 frog1`\\n\\nThe distance for frog 1 is huge and it\\'s no better than\\n`frog1 frog2 frog1 frog2`\\n\\nSo in this problem,\\nwe need to calculate the maximunm distance between `A[i] - A[i-2]`.\\nSpecial case is only two stones, so we initial `res = A[1] - A[0]`.\\n<br>\\n\\n# **Complexity**\\nTime `O(n)`\\nSpace `O(1)`\\n<br>\\n\\n**Java**\\n```java\\n    public int maxJump(int[] A) {\\n        int res = A[1] - A[0], n = A.length;\\n        for(int i = 2; i < n; ++i)\\n            res = Math.max(res, A[i] - A[i - 2]);\\n        return res;\\n    }\\n```\\n\\n**C++**\\n```cpp\\n    int maxJump(vector<int>& A) {\\n        int res = A[1] - A[0], n = A.size();\\n        for (int i = 2; i < n; ++i)\\n            res = max(res, A[i] - A[i - 2]);\\n        return res;\\n    }\\n```\\n\\n**Python**\\n```py\\n    def maxJump(self, A):\\n        res = A[1] - A[0];\\n        for i in range(2, len(A)):\\n            res = max(res, A[i] - A[i - 2])\\n        return res\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```java\\n    public int maxJump(int[] A) {\\n        int res = A[1] - A[0], n = A.length;\\n        for(int i = 2; i < n; ++i)\\n            res = Math.max(res, A[i] - A[i - 2]);\\n        return res;\\n    }\\n```\n```cpp\\n    int maxJump(vector<int>& A) {\\n        int res = A[1] - A[0], n = A.size();\\n        for (int i = 2; i < n; ++i)\\n            res = max(res, A[i] - A[i - 2]);\\n        return res;\\n    }\\n```\n```py\\n    def maxJump(self, A):\\n        res = A[1] - A[0];\\n        for i in range(2, len(A)):\\n            res = max(res, A[i] - A[i - 2])\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2897902,
                "title": "skip",
                "content": "The best strategy for the frog is to jump skipping one stone.\\n\\nTherefore, our answer is the longest jump between `st[i - 1]` and `st[i + 1]`.\\n\\n#### Transform-Reduce\\n```cpp\\nint maxJump(vector<int>& st) {\\n    return max(st[1] - st[0],\\n        transform_reduce(begin(st) + 2, end(st), begin(st), 0, \\n                         [](int a, int b){ return max(a, b); },\\n                         [](int i, int j){ return i - j; }));\\n}\\n```\\n\\n#### Raw Loop\\n**C++**\\n```cpp\\nint maxJump(vector<int>& st) {\\n    int res = st[1] - st[0];\\n    for (int i = 1; i < st.size() - 1; ++i)\\n        res = max(res, st[i + 1] - st[i - 1]);\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nint maxJump(vector<int>& st) {\\n    return max(st[1] - st[0],\\n        transform_reduce(begin(st) + 2, end(st), begin(st), 0, \\n                         [](int a, int b){ return max(a, b); },\\n                         [](int i, int j){ return i - j; }));\\n}\\n```\n```cpp\\nint maxJump(vector<int>& st) {\\n    int res = st[1] - st[0];\\n    for (int i = 1; i < st.size() - 1; ++i)\\n        res = max(res, st[i + 1] - st[i - 1]);\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2898129,
                "title": "decently-explained-python3-code-o-n-w-image",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nNo matter how you try, the best approach is always going to be skipping the next stone and going to next stone after that (if this step is possible). \\n\\nAfter drawing all possibilities it can be seen that the biggest steps are always going to be skipping one stone in between of two stones, i.e of length = 2.\\nThere may be other steps as well of length = 1 but there will always be another step of length 2 skipping over the stone involved in jump of length 1, hence making the length 1 jump not worth considering.\\n\\nHere are examples of possible paths for even and odd number of stones.\\nSorry for unclear photos.\\n\\n![odd1.jpg](https://assets.leetcode.com/users/images/7f05d590-756e-44f8-a352-1be183a0f40c_1670689214.0397813.jpeg)\\n\\n![even1.jpg](https://assets.leetcode.com/users/images/de22a2f7-d782-47ec-a3d7-50213bf79918_1670689227.0903733.jpeg)\\n\\nAs, the images can hopefully show, the optimal path will result in jumps of length 2, and so in the code I have just used two pointers i, j  to iterate through the graph and check what is the maximum cost in jumping this way. \\n\\nHope you understood what I am trying to convey here. Anyways, have a great day and Happy Coding.\\n\\n\\n\\n\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def maxJump(self, stones: List[int]) -> int:\\n        if len(stones) == 2:\\n            return (stones[-1] - stones[0])\\n        maxjump = 0\\n        i, j = 0, 2\\n        while j < len(stones):\\n            maxjump = max(maxjump, (stones[j] - stones[i]))\\n            i+= 1; j+= 1\\n        return maxjump\\n        \\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def maxJump(self, stones: List[int]) -> int:\\n        if len(stones) == 2:\\n            return (stones[-1] - stones[0])\\n        maxjump = 0\\n        i, j = 0, 2\\n        while j < len(stones):\\n            maxjump = max(maxjump, (stones[j] - stones[i]))\\n            i+= 1; j+= 1\\n        return maxjump\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2897949,
                "title": "c-simple-4-liner-iterative-solution-very-simple-and-easy-to-understand",
                "content": "**Up Vote if you like the solution**\\n```\\n/*\\nSimple take the max diff of index with diff 2\\n*/\\n\\nclass Solution {\\npublic:\\n    int maxJump(vector<int>& stones) {\\n        int  ans = stones[1] - stones[0];\\n        for(int i = 0; i < stones.size(); ++i){\\n            if(i+2 < stones.size()) ans = max(ans, stones[i+2] - stones[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/*\\nSimple take the max diff of index with diff 2\\n*/\\n\\nclass Solution {\\npublic:\\n    int maxJump(vector<int>& stones) {\\n        int  ans = stones[1] - stones[0];\\n        for(int i = 0; i < stones.size(); ++i){\\n            if(i+2 < stones.size()) ans = max(ans, stones[i+2] - stones[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2899219,
                "title": "java-o-n-1-liner",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nGreedy\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nOdd even alternative diff max\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxJump(int[] a) {\\n        int res = a[1] - a[0], n = a.length;\\n\\n        for (int i = 2; i < n; i++) res = Math.max(res, a[i] - a[i-2]);\\n\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxJump(int[] a) {\\n        int res = a[1] - a[0], n = a.length;\\n\\n        for (int i = 2; i < n; i++) res = Math.max(res, a[i] - a[i-2]);\\n\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2898316,
                "title": "python-always-make-the-longest-2-jump-explained-bonus-one-liner",
                "content": "**\\u2705 IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n****\\n\\n**Comment.** Several important observations can be made:\\n1. On its way to the right, the frog should make at least one jump of length greater than `1`. If all jumps were of length `1`  (let\\'s call them 1-jumps), there will remain no stones to return to the origin. \\n2. There is no point in making jumps of length greater than `2` (let\\'s call them 2-jumps) becuase all of them can be optimized to a combination of 1-jumps and 2-jumps.\\n3. So the question is, which 2-jumps should the frog make? Can it skip the most longest one? The answer is no. Let\\'s consider a triple of stones `[..., x, A, B, C, y, ...]` where `C-A` is the longest possible 2-jump. If the frog decides not to jump directly from `A` to `C`, but rather to use an intermediate stone `B`, then on its way back it would have to take an even longer jump from `y` to `x`. Thus, the frog should always make the longest 2-jump.\\n\\nConsidering all these observations, the optimal strategy would be to take a 1-stone-separated path (with the longest 2-jump included) on the way right and use the remaining stones on the way back to the origin. On the boundaries, we might have to make 1-jumps to correctly align ourselves to the path with the longest 2-jump.  \\n\\n**Python #1.**\\n```\\nclass Solution:\\n    def maxJump(self, s: List[int]) -> int:\\n        m = s[1]\\n        for i,j in zip(s[2:],s):\\n            m = max(m, i-j)\\n        return m\\n```\\n\\n**Python #2.** One-liner.\\n```\\nclass Solution:\\n    def maxJump(self, s: List[int]) -> int:\\n\\n        return max((i-j for i,j in zip(s[2:],s)), default=s[1])\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxJump(self, s: List[int]) -> int:\\n        m = s[1]\\n        for i,j in zip(s[2:],s):\\n            m = max(m, i-j)\\n        return m\\n```\n```\\nclass Solution:\\n    def maxJump(self, s: List[int]) -> int:\\n\\n        return max((i-j for i,j in zip(s[2:],s)), default=s[1])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2897978,
                "title": "single-loop-o-n-o-1",
                "content": "\\n# Approach\\nHere I\\'m trying to find what could be the maximum absolute difference between any two consecutive indices.\\nWhy 2 ?- Because greedly I\\'m leaving single index to use while returning.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxJump(vector<int>& stones) {\\n        int n = stones.size(), maxi = 0, i = 0;\\n        while(i < n) {\\n            int jump = i + 2; \\n            if(jump >= n) { // for last index\\n                maxi = max(maxi, abs(stones[i] - stones[n-1]));\\n                break;\\n            }\\n            maxi = max(maxi, abs(stones[i]- stones[jump]));\\n            i++;\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxJump(vector<int>& stones) {\\n        int n = stones.size(), maxi = 0, i = 0;\\n        while(i < n) {\\n            int jump = i + 2; \\n            if(jump >= n) { // for last index\\n                maxi = max(maxi, abs(stones[i] - stones[n-1]));\\n                break;\\n            }\\n            maxi = max(maxi, abs(stones[i]- stones[jump]));\\n            i++;\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2898192,
                "title": "detailed-explanation-greedy-algorithm-o-n-time-o-1-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirst of all it is always optimal to jump at alternate stones so that the length of each jump can be as minimum as possible, keeping in mind that we have to return back also.\\n\\nsuppose we have 5 stones kept at 0,1,2,3,4 positon respectively. so travelling from\\n0 -> 1 -> 2 -> 3 -> 4 will take 4-> 0 to return back means maximum jump=4\\n0 -> 2 -> 4 will take 4-> 3 -> 1 -> 0 to return back means maximum jump=2\\n\\nso it is always optimal to take alternate stones for jump.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n**Odd Stones**\\nNow suppose we have 5 stones as a,b,c,d,e\\nso one path can be \\na -> c -> e and e -> d -> b -> a\\nso here the jump value would be absolute value of -:\\n*c-a , e-c , e-d , d- b , b-a*\\n\\n**Even Stones**\\nNow suppose we have 6 stones as a,b,c,d,e,f\\nso one path can be \\na -> c -> e -> f and f -> d -> b -> a\\nso here the jumps would be  value of -:\\n*c-a , e-c , f-e , f-d , d-b , b-a*\\n\\n---\\n\\nSo from above we see that the differece of stone values which matters to us from the stone array [0,1,2, ... , n-1,n] are :\\n\\none unit jump : 0->1 and n->(n-1).\\n\\nTwo unit jump : 2->0, 3->1 , 4->2 , ... ,(n-1)-> (n-1)-2, n->n-2.\\n or all the valid \\'-2\\' jumps\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nWe are traversing the array one time so \\n    **$$O(n)$$**\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nOnly one extra variable ans is used to store the maximum jump so ,\\n    **$$O(1)$$**\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxJump(vector<int>& stones) {\\n        int n=stones.size();\\n        //one unit jumps as stones.size()>=2\\n        int ans=max(stones[1]-stones[0],stones[n-1]-stones[n-2]);\\n        for(int i=0;i<n;i++) {\\n            if(i-2>=0) {\\n                ans=max(ans,stones[i]-stones[i-2]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\nPlease upvote if you like it!\\n",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxJump(vector<int>& stones) {\\n        int n=stones.size();\\n        //one unit jumps as stones.size()>=2\\n        int ans=max(stones[1]-stones[0],stones[n-1]-stones[n-2]);\\n        for(int i=0;i<n;i++) {\\n            if(i-2>=0) {\\n                ans=max(ans,stones[i]-stones[i-2]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2897953,
                "title": "c-simple-binary-search-solution-with-explanation",
                "content": "**Intuition**\\nLet ```k``` be the largest jump needed. We can binary search on ```k```. Realize that this problem is essentially saying we need two different paths from the first to last stone. We can greedily search for one path using binary search. Then removing the stones in this path, we can move test if there exists a second path.\\n\\n**Code**\\n```\\nclass Solution {\\npublic:\\n    bool works(vector<int>& stones, int k) {\\n        int cur = 0;\\n        vector<int> newstones;\\n        set<int> chosen;\\n        while (cur + k < stones.back()) {\\n            auto it = upper_bound(stones.begin(), stones.end(), cur + k);\\n            it--;\\n            if (*it == cur) return false;\\n            cur = *it;\\n            chosen.insert(cur);\\n        }\\n        for (int i : stones) {\\n            if (chosen.count(i) == 0) newstones.push_back(i);\\n        }\\n        assert((int) newstones.size() >= 2);\\n        for (int i = 1; i < newstones.size(); i++) {\\n            if (newstones[i] - newstones[i - 1] > k) return false;\\n        }\\n        return true;\\n    }\\n    \\n    int maxJump(vector<int>& stones) {\\n        int lo = 0, hi = stones.back();\\n        while (lo < hi) {\\n            int mid = lo + (hi - lo) / 2;\\n            if (works(stones, mid)) hi = mid;\\n            else lo = mid + 1;\\n        }\\n        assert(lo == hi);\\n        return lo;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```k```\n```k```\n```\\nclass Solution {\\npublic:\\n    bool works(vector<int>& stones, int k) {\\n        int cur = 0;\\n        vector<int> newstones;\\n        set<int> chosen;\\n        while (cur + k < stones.back()) {\\n            auto it = upper_bound(stones.begin(), stones.end(), cur + k);\\n            it--;\\n            if (*it == cur) return false;\\n            cur = *it;\\n            chosen.insert(cur);\\n        }\\n        for (int i : stones) {\\n            if (chosen.count(i) == 0) newstones.push_back(i);\\n        }\\n        assert((int) newstones.size() >= 2);\\n        for (int i = 1; i < newstones.size(); i++) {\\n            if (newstones[i] - newstones[i - 1] > k) return false;\\n        }\\n        return true;\\n    }\\n    \\n    int maxJump(vector<int>& stones) {\\n        int lo = 0, hi = stones.back();\\n        while (lo < hi) {\\n            int mid = lo + (hi - lo) / 2;\\n            if (works(stones, mid)) hi = mid;\\n            else lo = mid + 1;\\n        }\\n        assert(lo == hi);\\n        return lo;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2897892,
                "title": "difference-of-i-and-i-2-java",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int maxJump(int[] stones) {\\n        int ans = stones[1] - stones[0];\\n        for(int i=2;i<stones.length;i++){\\n            ans = Math.max(ans,stones[i]-stones[i-2]);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxJump(int[] stones) {\\n        int ans = stones[1] - stones[0];\\n        for(int i=2;i<stones.length;i++){\\n            ans = Math.max(ans,stones[i]-stones[i-2]);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2897897,
                "title": "python-super-simple-jump-over-1-stone-forward-and-backward",
                "content": "```python\\nclass Solution:\\n    def maxJump(self, stones: List[int]) -> int:\\n        if len(stones) == 2:\\n            return abs(stones[0] - stones[1])\\n\\n        # to simplify logic below\\n        if len(stones) % 2 == 0:\\n            stones.append(stones[-1] + 1)\\n\\n        j = 0\\n\\n        # -> go forward\\n        for i in range(0, len(stones) - 2, 2):\\n            j = max(j, abs(stones[i] - stones[i+2]))\\n\\n        # <- go backward\\n        for i in range(1, len(stones) - 2, 2):\\n            j = max(j, abs(stones[i] - stones[i+2]))\\n\\n        return j\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def maxJump(self, stones: List[int]) -> int:\\n        if len(stones) == 2:\\n            return abs(stones[0] - stones[1])\\n\\n        # to simplify logic below\\n        if len(stones) % 2 == 0:\\n            stones.append(stones[-1] + 1)\\n\\n        j = 0\\n\\n        # -> go forward\\n        for i in range(0, len(stones) - 2, 2):\\n            j = max(j, abs(stones[i] - stones[i+2]))\\n\\n        # <- go backward\\n        for i in range(1, len(stones) - 2, 2):\\n            j = max(j, abs(stones[i] - stones[i+2]))\\n\\n        return j\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2898411,
                "title": "greedy-c-o-n",
                "content": "# Intuition\\nConsider alternate stones\\n\\n# Approach\\nFind maximum of stones[i] - stones[i-2]\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxJump(vector<int>& stones) {\\n        int maxi = stones[1]-stones[0];\\n        int n = stones.size();\\n        \\n        for(int i=2; i<n; i++){\\n            int curr = stones[i]-stones[i-2];\\n            maxi = max(maxi, curr);\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxJump(vector<int>& stones) {\\n        int maxi = stones[1]-stones[0];\\n        int n = stones.size();\\n        \\n        for(int i=2; i<n; i++){\\n            int curr = stones[i]-stones[i-2];\\n            maxi = max(maxi, curr);\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3796484,
                "title": "2-approaches-binarysearch-on-ans-greedy-easy-c-code",
                "content": "# Complexity\\n```\\n- Time complexity:\\nApproach 1: O(n)\\nApproach 2 : O(nlog(ul))  where ul is the difference b/w max & min values of the array stones\\n```\\n```\\n- Space complexity:\\nO(1)\\n```\\n\\n# Code\\n## Please Upvote if u found my Solution useful\\uD83E\\uDD17\\n# Approach 1(Greedy):-\\n```\\nclass Solution {\\npublic:\\n    int maxJump(vector<int>& stones) {\\n        int n = stones.size(), maxi = 0;\\n        if(n == 2)\\n            return stones[1] - stones[0];\\n        for(int i = 0 ; i < n - 2 ; i++)\\n            maxi = max(maxi,stones[i + 2] - stones[i]);\\n        return maxi;\\n    }\\n};\\n```\\n# Approach 2(Binary Search on Ans):-\\n```\\nclass Solution {\\npublic:\\n    bool helper(int cost, vector<int>& stones, int n){\\n        unordered_set<int> st;\\n        int tmp = 0;\\n        st.insert(stones[0]);\\n        for(int i = 1; i < n; i++){\\n            if(stones[i] - tmp > cost){\\n                if(st.find(stones[i - 1]) != st.end())\\n                    return false;\\n                st.insert(stones[i - 1]);\\n                tmp = stones[i - 1];\\n            }\\n        }\\n        st.erase(stones[0]);\\n        tmp = stones.back();\\n        for(int i = n - 2; i >= 0 ; i--){\\n            if(st.find(stones[i]) == st.end()){\\n                if(tmp - stones[i] > cost)\\n                    return false;\\n                tmp = stones[i];\\n            }\\n        }\\n        return true;\\n    }\\n    int maxJump(vector<int>& stones) {\\n        int n = stones.size(), ll = 1, ul = stones.back() - stones[0], mid = 0, ans = 0;\\n        while(ll <= ul){\\n            mid = (ll + ul) >> 1;\\n            if(helper(mid,stones,n)){\\n                ans = mid;\\n                ul = mid - 1;\\n            }\\n            else\\n                ll = mid + 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search",
                    "Greedy"
                ],
                "code": "```\\n- Time complexity:\\nApproach 1: O(n)\\nApproach 2 : O(nlog(ul))  where ul is the difference b/w max & min values of the array stones\\n```\n```\\n- Space complexity:\\nO(1)\\n```\n```\\nclass Solution {\\npublic:\\n    int maxJump(vector<int>& stones) {\\n        int n = stones.size(), maxi = 0;\\n        if(n == 2)\\n            return stones[1] - stones[0];\\n        for(int i = 0 ; i < n - 2 ; i++)\\n            maxi = max(maxi,stones[i + 2] - stones[i]);\\n        return maxi;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool helper(int cost, vector<int>& stones, int n){\\n        unordered_set<int> st;\\n        int tmp = 0;\\n        st.insert(stones[0]);\\n        for(int i = 1; i < n; i++){\\n            if(stones[i] - tmp > cost){\\n                if(st.find(stones[i - 1]) != st.end())\\n                    return false;\\n                st.insert(stones[i - 1]);\\n                tmp = stones[i - 1];\\n            }\\n        }\\n        st.erase(stones[0]);\\n        tmp = stones.back();\\n        for(int i = n - 2; i >= 0 ; i--){\\n            if(st.find(stones[i]) == st.end()){\\n                if(tmp - stones[i] > cost)\\n                    return false;\\n                tmp = stones[i];\\n            }\\n        }\\n        return true;\\n    }\\n    int maxJump(vector<int>& stones) {\\n        int n = stones.size(), ll = 1, ul = stones.back() - stones[0], mid = 0, ans = 0;\\n        while(ll <= ul){\\n            mid = (ll + ul) >> 1;\\n            if(helper(mid,stones,n)){\\n                ans = mid;\\n                ul = mid - 1;\\n            }\\n            else\\n                ll = mid + 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2898914,
                "title": "c-use-alternate-path-easy-and-efficient-solution",
                "content": "# Intuition\\nFrom the condition, It\\'s clear that frog needs to use at most all stones to get minimum cost. So, We jump on alternate stones to get minimum cost. We can also take 3/4/5... steps jump and skip multiple stones but that approach is not feasible to get minimum cost.\\n\\n# Approach\\nSince frog needs to jump on alternate stones, going path will be even/odd index path and returning path will be odd/even index path. So we calculate cost for each path and find the minimum cost.\\n\\n**Base case:** Since we start calculating cost from 2nd index we need to take initial cost as stones[1]-stones[0].\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution \\n{\\npublic:\\n    int maxJump(vector<int>& stones) \\n    {\\n        int cost = stones[1]-stones[0];\\n\\n        for(int i=2; i<stones.size(); i++)\\n        {\\n            cost = max(cost, stones[i]-stones[i-2]);\\n        }\\n        return cost;        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int maxJump(vector<int>& stones) \\n    {\\n        int cost = stones[1]-stones[0];\\n\\n        for(int i=2; i<stones.size(); i++)\\n        {\\n            cost = max(cost, stones[i]-stones[i-2]);\\n        }\\n        return cost;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3805256,
                "title": "c-apni-bhasha-mein-easy-explanation-greedy-bs-interview-prep",
                "content": "# Intuition & Approach\\n- Explained in the code\\n\\n# Code\\n```\\nclass Solution\\n{\\n    public:\\n    LOGIC\\n\\n    KARNA KYA HAIN\\u2753\\n    1. Stones are given in strictly increasing order representing positions\\n    of stones in a river.\\n    2. Frog is initially oin a 1st stone and usko last stone pe jana hain and\\n    then return to the 1st stone.\\n    3. It can jump to any stone at most once.(Matlab forward path traverse karte\\n    jo stone pe kude the unpe wapas aate samay dobara nahin kud sakte.)\\n    4. Length of jump = |stones[i] - stones[j]|.\\n    5. Cost of path = Max len of jump among all jumps in path\\n    6. Return the min cost of a path for the frog.\\n\\n    APPROACH & INTUITION\\n    1. Minimum Cost and Increasing Order dekhke - Greedy Strike karega\\uD83D\\uDCA1.\\n    2. BS on answers can also be an approach. Why\\u2753\\n    - Strictly increasing order.\\n    - Cost of path will be in range [0,maxPos-minPos]\\n\\n    3. GREEDY SOL APPROACH\\n    - Agar kisi path pe hame forward jaana hain aur vapis aana hain provided that\\n    wapas aane jaane mein ham stone pe ek hi baar kude.\\n    - Then its logical ki in forward and backward we jump on alternate stones.\\n    - So while moving in forward direction we will jump on alternate stones\\n    i and i+2. Inka max diff nikalenge joki cost hogi hamari.\\n    - Yeh min Cost kaise hogi\\u2753-> We are making sure to find max of alternate \\n    stones and the gap of 2-3 stones is not there so we are finding the most \\n    optimal path and cost jisse back and forward dono mein traverse karle.\\n    - Backward direction and forward direction dono mein jaane mein ya to cost\\n    same ya kam lage.\\n\\n    4. BINARY SEARCH\\n    - Reasons are state above for using BS on answers.\\n    - low=0,high = stones[n-1]-stones[0]\\n    - We will find mid cost and check if backward and forward direction both\\n    possible or not .\\n    - If possible then mid=high (Trying to find more optimal min cost)\\n    - If not possible then we will increase the cost for traversing in both \\n    direction.\\n    - While checking for forward direction jo stones ham cover kar rahe hain\\n    unki visited mark kardenge.\\n    - Jisse Backward test ke time pe un stones pe jump na kare.\\n//========================================================================================================\\n\\n       \\t//GREEDY SOL (LOGIC EXPLAINED ABOVE)\\n       \\tint maxJump(vector<int>& stones) {\\n       \\t     int n = stones.size();\\n       \\t     int maxi = INT_MIN;\\n       \\t     if(n==2)\\n       \\t     return stones[n-1]-stones[0];\\n       \\t     for(int i=0;i < n-2;i++)\\n       \\t     {\\n                 //Finding diff between alternate stone pos\\n                 //The max cost found is the min cost of the path\\n       \\t         maxi = max(maxi,stones[i+2]-stones[i]);\\n       \\t     }\\n       \\t     return maxi;\\n       \\t }\\n\\n       \\t//BS ON ANSWERS\\n        bool isPossible(int cost, vector<int> &stones)\\n        {\\n            int n = stones.size();\\n            vector<bool> visited(n, false);\\n            //Array to mark the stones pos which are visited\\n            //so that they are not traversed in backward direction\\n            int ind = 0;\\n            while (ind < n - 1)\\n            //Checking in forward direction\\n            {\\n                int j = ind;\\n                //j se lekar i tak jitni pos cover ho rahi unko cover karlo\\n                //Goal is to minimize the number of stones jumped.\\n                while (j + 1 < n && stones[j + 1] <= stones[ind] + cost)\\n                    j++;\\n                if (j == ind)\\n                //Agar j badha hi nahin vahin ka vahin rahe gaya\\n                    return false;\\n                ind = j;\\n                //Updated position to the stone jumped\\n                visited[ind] = true;\\n                //Making the stone visited\\n            }\\n\\n            //Optional we could have check while traversing\\n            //Storing positions of stones which are still to bs visited\\n            //Completely removing the visited Stone positions\\n            vector<int> indexes;\\n            for (int j = 0; j < n - 1; j++)\\n            {\\n                if (visited[j] == false) indexes.push_back(j);\\n            }\\n            indexes.push_back(n - 1);\\n\\n            //Checking for backward direction\\n            ind = indexes.size() - 1;\\n            while (ind > 0)\\n            {\\n                int j = ind;\\n                //Covering as much stones as possible\\n                while (j > 0 && stones[indexes[j - 1]] >= stones[indexes[j]] - cost)\\n                    j--;\\n                if (j == ind)\\n                    return false;\\n                ind = j;\\n                //Updating the stone position\\n            }\\n            return true;\\n        }\\n    int maxJump(vector<int> &stones)\\n    {\\n        int n = stones.size();\\n        int low = 0;\\n        int high = stones[n - 1] - stones[0];\\n        //Range of cost\\n        while (low <= high)\\n        {\\n            int mid = (low + high) / 2;\\n            if (isPossible(mid, stones))\\n            //Whether it is possible to traverse in both directions \\n            {\\n                high = mid - 1;\\n                //If possible then we will try to find more optimal lower cost\\n            }\\n            else\\n                low = mid + 1;\\n                //The cost required is higher then expected\\n        }\\n        return low;\\n    }\\n};\\n```\\n# Complexity\\n- Time complexity:\\n    - $O(log(n))$ BS for n is from 0 to stones[n-1]-stones[0]\\n    - $O(N)$ for greedy sol.\\n- Space complexity: $O(1)$ in greedy $O(N)$ in BS due to isVisited and indexes array.\\n\\nIf you *like* \\uD83D\\uDC4D this solution do *upvote* \\u2B06\\uFE0F and if there is any *improvement or suggestion* do mention it in the *comment* section \\uD83D\\uDE0A.\\n\\n<p align=\"center\">\\n<img src=\"https://assets.leetcode.com/users/images/1b604300-df68-46aa-a267-71f38463bb89_1684820402.7869222.jpeg\" width=\\'350\\' alt=\"Upvote Image\">\\n</p>\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search",
                    "Greedy"
                ],
                "code": "```\\nclass Solution\\n{\\n    public:\\n    LOGIC\\n\\n    KARNA KYA HAIN\\u2753\\n    1. Stones are given in strictly increasing order representing positions\\n    of stones in a river.\\n    2. Frog is initially oin a 1st stone and usko last stone pe jana hain and\\n    then return to the 1st stone.\\n    3. It can jump to any stone at most once.(Matlab forward path traverse karte\\n    jo stone pe kude the unpe wapas aate samay dobara nahin kud sakte.)\\n    4. Length of jump = |stones[i] - stones[j]|.\\n    5. Cost of path = Max len of jump among all jumps in path\\n    6. Return the min cost of a path for the frog.\\n\\n    APPROACH & INTUITION\\n    1. Minimum Cost and Increasing Order dekhke - Greedy Strike karega\\uD83D\\uDCA1.\\n    2. BS on answers can also be an approach. Why\\u2753\\n    - Strictly increasing order.\\n    - Cost of path will be in range [0,maxPos-minPos]\\n\\n    3. GREEDY SOL APPROACH\\n    - Agar kisi path pe hame forward jaana hain aur vapis aana hain provided that\\n    wapas aane jaane mein ham stone pe ek hi baar kude.\\n    - Then its logical ki in forward and backward we jump on alternate stones.\\n    - So while moving in forward direction we will jump on alternate stones\\n    i and i+2. Inka max diff nikalenge joki cost hogi hamari.\\n    - Yeh min Cost kaise hogi\\u2753-> We are making sure to find max of alternate \\n    stones and the gap of 2-3 stones is not there so we are finding the most \\n    optimal path and cost jisse back and forward dono mein traverse karle.\\n    - Backward direction and forward direction dono mein jaane mein ya to cost\\n    same ya kam lage.\\n\\n    4. BINARY SEARCH\\n    - Reasons are state above for using BS on answers.\\n    - low=0,high = stones[n-1]-stones[0]\\n    - We will find mid cost and check if backward and forward direction both\\n    possible or not .\\n    - If possible then mid=high (Trying to find more optimal min cost)\\n    - If not possible then we will increase the cost for traversing in both \\n    direction.\\n    - While checking for forward direction jo stones ham cover kar rahe hain\\n    unki visited mark kardenge.\\n    - Jisse Backward test ke time pe un stones pe jump na kare.\\n//========================================================================================================\\n\\n       \\t//GREEDY SOL (LOGIC EXPLAINED ABOVE)\\n       \\tint maxJump(vector<int>& stones) {\\n       \\t     int n = stones.size();\\n       \\t     int maxi = INT_MIN;\\n       \\t     if(n==2)\\n       \\t     return stones[n-1]-stones[0];\\n       \\t     for(int i=0;i < n-2;i++)\\n       \\t     {\\n                 //Finding diff between alternate stone pos\\n                 //The max cost found is the min cost of the path\\n       \\t         maxi = max(maxi,stones[i+2]-stones[i]);\\n       \\t     }\\n       \\t     return maxi;\\n       \\t }\\n\\n       \\t//BS ON ANSWERS\\n        bool isPossible(int cost, vector<int> &stones)\\n        {\\n            int n = stones.size();\\n            vector<bool> visited(n, false);\\n            //Array to mark the stones pos which are visited\\n            //so that they are not traversed in backward direction\\n            int ind = 0;\\n            while (ind < n - 1)\\n            //Checking in forward direction\\n            {\\n                int j = ind;\\n                //j se lekar i tak jitni pos cover ho rahi unko cover karlo\\n                //Goal is to minimize the number of stones jumped.\\n                while (j + 1 < n && stones[j + 1] <= stones[ind] + cost)\\n                    j++;\\n                if (j == ind)\\n                //Agar j badha hi nahin vahin ka vahin rahe gaya\\n                    return false;\\n                ind = j;\\n                //Updated position to the stone jumped\\n                visited[ind] = true;\\n                //Making the stone visited\\n            }\\n\\n            //Optional we could have check while traversing\\n            //Storing positions of stones which are still to bs visited\\n            //Completely removing the visited Stone positions\\n            vector<int> indexes;\\n            for (int j = 0; j < n - 1; j++)\\n            {\\n                if (visited[j] == false) indexes.push_back(j);\\n            }\\n            indexes.push_back(n - 1);\\n\\n            //Checking for backward direction\\n            ind = indexes.size() - 1;\\n            while (ind > 0)\\n            {\\n                int j = ind;\\n                //Covering as much stones as possible\\n                while (j > 0 && stones[indexes[j - 1]] >= stones[indexes[j]] - cost)\\n                    j--;\\n                if (j == ind)\\n                    return false;\\n                ind = j;\\n                //Updating the stone position\\n            }\\n            return true;\\n        }\\n    int maxJump(vector<int> &stones)\\n    {\\n        int n = stones.size();\\n        int low = 0;\\n        int high = stones[n - 1] - stones[0];\\n        //Range of cost\\n        while (low <= high)\\n        {\\n            int mid = (low + high) / 2;\\n            if (isPossible(mid, stones))\\n            //Whether it is possible to traverse in both directions \\n            {\\n                high = mid - 1;\\n                //If possible then we will try to find more optimal lower cost\\n            }\\n            else\\n                low = mid + 1;\\n                //The cost required is higher then expected\\n        }\\n        return low;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3225912,
                "title": "a-must-see-intuitive-dp-space-optimised",
                "content": "Let\\'s have a case when there are 3 stones, for eg; 1 2 3. Here the answer will be 3-1=2  as the frog can have jump from 1 to 3 and 3 to 1 OR 1->2->3 and 3->1. Now let\\'s say we insert an another stone 1 2 3 5. Here comes the role of dp. We can think of like \" the answer will be maximum of what we computed at 3 and (stone[i]-stone[i-2]) here 5-2\" why?? because let\\'s say we take jump from 2 to 5 then 2 is occupied at we will come back through 5->3>1 or if we jump from 3 to 5 we will come through 5->2->1. so we can see that in both the case (5-2=3) is coming either in the first way or the returning way. Don\\'t ask that why you jumped from 2 only because it\\'s optimal for the frog to jump to a larger number from a number which is less smaller than that. so we are left out with the result that ans=max(dp[i-1],stone[i]-stone[i-2]).\\n\\n**TABULATION  TC=O(N) SC=O(N)**\\nclass Solution {\\npublic:\\n    int maxJump(vector<int>& stones) {\\n        \\n        int n=stones.size();\\n        vector<int> dp(n,0);\\n        \\n        dp[0]=0;   //WHEN THERE IS A SINGLE STONE THE ANS IS 0;\\n        dp[1]=stones[1]-stones[0];      // TWO STONES SO THERE DIFFERENCE IS THE ANSWER\\n        if(n==2){\\n            return dp[1];\\n        }\\n        \\n        \\n        for(int i=2;i<n;i++){\\n            dp[i]=max(dp[i-1],stones[i]-stones[i-2]);\\n        }\\n        return dp[n-1];\\n        \\n    }\\n};\\n\\n**SPACE OPTIMISED TC=O(N) SC=O(1)**\\nIn the above code we can see that from the dp array we are only fetching dp[i-1]. So why we carry out the whole vector. Instead we can carry a variable maxi to store the current maximum answer.\\n\\nclass Solution {\\npublic:\\n    int maxJump(vector<int>& stones) {\\n        \\n        int n=stones.size();\\n    \\n        \\n        \\n        if(n==2){\\n            return stones[1]-stones[0];\\n        }\\n        \\n        int maxi=stones[1]-stones[0];  // initially when there will be two elements it\\'s value will be their difference \\n        \\n        for(int i=2;i<n;i++){\\n            maxi=max(maxi,stones[i]-stones[i-2]);\\n        }\\n        return maxi;    \\n    }\\n};\\n\\n**UPVOTE IF YOU UNDERSTOOD .IT WILL JUST TAKE A SECOND :(**",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    int maxJump(vector<int>& stones) {\\n        \\n        int n=stones.size();\\n        vector<int> dp(n,0);\\n        \\n        dp[0]=0;   //WHEN THERE IS A SINGLE STONE THE ANS IS 0;\\n        dp[1]=stones[1]-stones[0];      // TWO STONES SO THERE DIFFERENCE IS THE ANSWER\\n        if(n==2){\\n            return dp[1];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2906104,
                "title": "python-3-5-lines-t-m-97-68",
                "content": "You can figure it out. I\\'m pretty sure.\\n\\n\"The secret of being a bore is to tell everything.\" \\u2014 Voltaire\\n\\n```\\nclass Solution:\\n    def maxJump(self, stones: List[int]) -> int:\\n\\n        n = len(stones)\\n\\n        ans = stones[1]\\n\\n        for i in range(n-2):\\n            ans = max(ans,stones[i+2]-stones[i])\\n\\n        return ans\\n```\\n[https://leetcode.com/problems/frog-jump-ii/submissions/858955992/]()\\n\\nI could be wrong, but I think that time is *O*(*N*) and space is *O*(1).",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxJump(self, stones: List[int]) -> int:\\n\\n        n = len(stones)\\n\\n        ans = stones[1]\\n\\n        for i in range(n-2):\\n            ans = max(ans,stones[i+2]-stones[i])\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2898081,
                "title": "one-liner-shortest-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAs the array is already sorted and our aim is to reach at the end and return back to start. Then why not to choose an optimum way which will be:\\n\\n1> If possible then left the alternet stone to return.\\n2> For that we have to choose the maximum b/w next and next to next element of the array so that maximum number of stones will remain unvisited and frog can jump on them while returning to minimize the cost.\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxJump(vector<int>& stones) {\\n        int res=stones[1]-stones[0]; // for size 2\\n        for(int i=0; i<stones.size()-2; i++)\\n            res=max(res, max(stones[i+2], stones[i+1])-stones[i]);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxJump(vector<int>& stones) {\\n        int res=stones[1]-stones[0]; // for size 2\\n        for(int i=0; i<stones.size()-2; i++)\\n            res=max(res, max(stones[i+2], stones[i+1])-stones[i]);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2897898,
                "title": "short-greedy-explained",
                "content": "```\\n/* It is never optimal to take a jump of more than 3 steps. Why ?? \\n  -> A jump of 3 steps can be broken down to 1step and 2step. These steps will have lesser absolute differences \\n  than the jump of three steps. \\n\\nNow we understand that taking 3 steps is not efficent because we can take smaller steps. \\nSo why not take steps of size 1. This would be a great idea if we hade to travel only once and not return back to \\nour starting position. Because while returning we need to take a very big jump as we cant jump to already reached \\nstones\\n\\nThe most efficent way is to take steps of size 2 while going forward and while returning back\\n\\n*/\\n\\nclass Solution {\\n    public int maxJump(int[] stones) {\\n        int max = stones[1]-stones[0]; // If n == 2\\n        for(int i=2;i<stones.length;i++) max = Math.max(max,stones[i]-stones[i-2]);\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/* It is never optimal to take a jump of more than 3 steps. Why ?? \\n  -> A jump of 3 steps can be broken down to 1step and 2step. These steps will have lesser absolute differences \\n  than the jump of three steps. \\n\\nNow we understand that taking 3 steps is not efficent because we can take smaller steps. \\nSo why not take steps of size 1. This would be a great idea if we hade to travel only once and not return back to \\nour starting position. Because while returning we need to take a very big jump as we cant jump to already reached \\nstones\\n\\nThe most efficent way is to take steps of size 2 while going forward and while returning back\\n\\n*/\\n\\nclass Solution {\\n    public int maxJump(int[] stones) {\\n        int max = stones[1]-stones[0]; // If n == 2\\n        for(int i=2;i<stones.length;i++) max = Math.max(max,stones[i]-stones[i-2]);\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3913651,
                "title": "nlog-n-binarysearch-solution-simple-and-easy-to-understand",
                "content": "# Approach\\n    -> We are doing bs on answer on the cost \\n    -> and then in the check fuction using upper_bound  we will find the next block where the from will jump . and the max jump frog can take will be the mid \\n    -> Since we cant make our from jump in a block for second time  , we can keep track of that in a set \\n    -> when will just check in the remaining block weather the max jump while returning is less than mid or not \\n    -> if yes we will minimize the cost\\n\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n    O(nlogN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxJump(vector<int>& stones) {\\n        int n = stones.size(),ans = 0 ;\\n        int lo = stones[1]-stones[0] , hi = 1e9;\\n    \\n        auto check =[&](int jump){\\n            int block = 0 ; \\n            vector<int> remain ; \\n            set<int> st ;\\n            while(block+jump<stones.back()){\\n                auto it = upper_bound(stones.begin(), stones.end(), block + jump);\\n                it--;\\n                if(*it==block) return false ; // agr kud pe point kiya tho false \\n                block = *it ; \\n                st.insert(block);\\n            }\\n            for(int i = 0; i<n; i++){\\n            if(st.count(stones[i]) == 0) remain.push_back(stones[i]);\\n            }\\n            // for returning \\n            for(int i = 1; i<remain.size(); i++){\\n                if(remain[i] - remain[i-1] > jump) return false;\\n            }\\n            return true;\\n        };\\n        while(lo<=hi){\\n            int mid = (lo+hi)/2;\\n            if(check(mid)){\\n                ans = mid ; \\n                hi = mid -1 ;\\n            }else{\\n                lo = mid+1;\\n            }\\n        }\\n        return ans ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxJump(vector<int>& stones) {\\n        int n = stones.size(),ans = 0 ;\\n        int lo = stones[1]-stones[0] , hi = 1e9;\\n    \\n        auto check =[&](int jump){\\n            int block = 0 ; \\n            vector<int> remain ; \\n            set<int> st ;\\n            while(block+jump<stones.back()){\\n                auto it = upper_bound(stones.begin(), stones.end(), block + jump);\\n                it--;\\n                if(*it==block) return false ; // agr kud pe point kiya tho false \\n                block = *it ; \\n                st.insert(block);\\n            }\\n            for(int i = 0; i<n; i++){\\n            if(st.count(stones[i]) == 0) remain.push_back(stones[i]);\\n            }\\n            // for returning \\n            for(int i = 1; i<remain.size(); i++){\\n                if(remain[i] - remain[i-1] > jump) return false;\\n            }\\n            return true;\\n        };\\n        while(lo<=hi){\\n            int mid = (lo+hi)/2;\\n            if(check(mid)){\\n                ans = mid ; \\n                hi = mid -1 ;\\n            }else{\\n                lo = mid+1;\\n            }\\n        }\\n        return ans ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2898674,
                "title": "c-madly-follow-ques-lines-binary-search-o-nlogn",
                "content": "# heads up\\nI know that O(n) solution exist as other posted. but just wanted to share Binary search approach as well. enjoy dinner...\\n\\n# Intuition\\nboundary checks:\\nif start and end locations are same, then ```ans = 0```\\nif start and end locations are largely separated, then ```ans = 1e9```\\n\\nso, pick **$$mid$$** of these two extremes and try to find two paths such that no frog can jump more than **$$mid$$**.\\nif we successfully find the two paths, then it could be our answer. so take it and again look for more smaller **$$mid$$** values.\\nif we failed to get two paths, then try with greater **$$mid$$** values.\\nin short, apply Binary search :D\\n\\n# Complexity\\n- Time complexity: $$O(nlogn)$$\\nfor each trial of **$$mid$$** we traverse the entire array.\\nand atmax we need to do go for **logn** times. \\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    int n;\\npublic:\\n    bool isOkay(int m, vector<int>& pos){\\n        unordered_set<int> visited;\\n        \\n        //first frog jump\\n        int i = 1, cur = 0, prev = 0;\\n        while(i < n){\\n            if((pos[i] - pos[cur])>m){\\n                if(prev != cur && visited.insert(prev).second) cur = prev;\\n                else return false;\\n            }\\n            else prev = i++;\\n        }\\n        \\n        //2nd frog jump\\n        cur = 0; prev = 0; i = 1;\\n        while(i < n){\\n            if(visited.find(i) != visited.end()){\\n                ++i; continue;  \\n            }\\n            \\n            if((pos[i] - pos[cur])>m){\\n                if(prev != cur) cur = prev;\\n                else return false;\\n            }\\n            else prev = i++;\\n        }\\n        \\n        return true;\\n    }\\n    \\n    int maxJump(vector<int>& pos) {\\n        n = pos.size();\\n        \\n        int s = 0, e = 1e9, m, ans = pos[n-1] - pos[0];\\n        while(s<=e){\\n            m = (s+e)/2;\\n            \\n            if(isOkay(m, pos)){\\n                ans = m;\\n                e = m-1;\\n            }else s = m + 1;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```ans = 0```\n```ans = 1e9```\n```\\nclass Solution {\\n    int n;\\npublic:\\n    bool isOkay(int m, vector<int>& pos){\\n        unordered_set<int> visited;\\n        \\n        //first frog jump\\n        int i = 1, cur = 0, prev = 0;\\n        while(i < n){\\n            if((pos[i] - pos[cur])>m){\\n                if(prev != cur && visited.insert(prev).second) cur = prev;\\n                else return false;\\n            }\\n            else prev = i++;\\n        }\\n        \\n        //2nd frog jump\\n        cur = 0; prev = 0; i = 1;\\n        while(i < n){\\n            if(visited.find(i) != visited.end()){\\n                ++i; continue;  \\n            }\\n            \\n            if((pos[i] - pos[cur])>m){\\n                if(prev != cur) cur = prev;\\n                else return false;\\n            }\\n            else prev = i++;\\n        }\\n        \\n        return true;\\n    }\\n    \\n    int maxJump(vector<int>& pos) {\\n        n = pos.size();\\n        \\n        int s = 0, e = 1e9, m, ans = pos[n-1] - pos[0];\\n        while(s<=e){\\n            m = (s+e)/2;\\n            \\n            if(isOkay(m, pos)){\\n                ans = m;\\n                e = m-1;\\n            }else s = m + 1;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2898509,
                "title": "c-short-and-intuitive-o-n-o-1",
                "content": "# Intuition\\n- The optimal way to solve this problem is to explore all the paths. \\n- We run two steps at a time. \\n- And after we will explore all the remaining paths. \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int maxJump(vector<int>& stones) {\\n\\n        int maxPath = 0 ;\\n        int n = stones.size();\\n\\n        // Calculate the first step\\n        maxPath = max(stones[1] - stones[0], 0);\\n\\n        // In terms of exploring all the paths \\n\\n        // Jump one path \\n        for (int i = 2; i < n; i += 2) {\\n            maxPath = max(maxPath, stones[i] - stones[i - 2]);\\n        }\\n\\n        // Also explore the remaining path \\n        for (int i = 3; i < n; i += 2) {\\n            maxPath = max(maxPath, stones[i] - stones[i - 2]);\\n        }\\n\\n        return maxPath;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int maxJump(vector<int>& stones) {\\n\\n        int maxPath = 0 ;\\n        int n = stones.size();\\n\\n        // Calculate the first step\\n        maxPath = max(stones[1] - stones[0], 0);\\n\\n        // In terms of exploring all the paths \\n\\n        // Jump one path \\n        for (int i = 2; i < n; i += 2) {\\n            maxPath = max(maxPath, stones[i] - stones[i - 2]);\\n        }\\n\\n        // Also explore the remaining path \\n        for (int i = 3; i < n; i += 2) {\\n            maxPath = max(maxPath, stones[i] - stones[i - 2]);\\n        }\\n\\n        return maxPath;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2898276,
                "title": "video-explanation-from-scratch-with-inutitions",
                "content": "## Explanation\\n\\n\\nhttps://www.youtube.com/watch?v=jKs7fVc0R2c\\n\\n[Click here if the preview doesn\\'t work](https://www.youtube.com/watch?v=jKs7fVc0R2c)\\n\\n## Code\\n```\\nclass Solution {\\n    bool IsPossible (int dist, const vector<int>& stones) {\\n        int n = stones.size();\\n        vector<bool> visited(n, false);\\n        \\n        int ind = 0;\\n        // Forward Journey\\n        while (ind < n-1) {\\n            int j = ind;\\n            while (j+1 < n && stones[j+1] <= (stones[ind] + dist)) j ++;\\n            \\n            if (j == ind) return false;\\n            ind = j;\\n            visited[ind] = true;\\n        }\\n        \\n        // Remove visited indexes to avoid increasing the time complexity :)\\n        vector<int> indexes;\\n        for (int j = 0; j < n-1; j ++) {\\n            if (visited[j] == false) indexes.push_back(j);\\n        }\\n        indexes.push_back(n-1);\\n                \\n        ind = indexes.size() - 1;\\n        // Backward Journey\\n        while (ind > 0) {\\n            int j = ind;\\n            while (j > 0 && stones[indexes[j-1]] >= (stones[indexes[ind]] - dist)) j--; \\n            \\n            if (j == ind) return false;\\n            ind = j;\\n        }\\n        \\n        return true;\\n    }\\n    \\npublic:\\n    int maxJump(vector<int>& stones) {\\n        int l = 0, r = 1e9+5;\\n        \\n        while (l < r) {\\n            int m = (l+r) >> 1;\\n            \\n            if (IsPossible(m, stones)) r = m;\\n            else l = m+1;\\n        }\\n        \\n        return l;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    bool IsPossible (int dist, const vector<int>& stones) {\\n        int n = stones.size();\\n        vector<bool> visited(n, false);\\n        \\n        int ind = 0;\\n        // Forward Journey\\n        while (ind < n-1) {\\n            int j = ind;\\n            while (j+1 < n && stones[j+1] <= (stones[ind] + dist)) j ++;\\n            \\n            if (j == ind) return false;\\n            ind = j;\\n            visited[ind] = true;\\n        }\\n        \\n        // Remove visited indexes to avoid increasing the time complexity :)\\n        vector<int> indexes;\\n        for (int j = 0; j < n-1; j ++) {\\n            if (visited[j] == false) indexes.push_back(j);\\n        }\\n        indexes.push_back(n-1);\\n                \\n        ind = indexes.size() - 1;\\n        // Backward Journey\\n        while (ind > 0) {\\n            int j = ind;\\n            while (j > 0 && stones[indexes[j-1]] >= (stones[indexes[ind]] - dist)) j--; \\n            \\n            if (j == ind) return false;\\n            ind = j;\\n        }\\n        \\n        return true;\\n    }\\n    \\npublic:\\n    int maxJump(vector<int>& stones) {\\n        int l = 0, r = 1e9+5;\\n        \\n        while (l < r) {\\n            int m = (l+r) >> 1;\\n            \\n            if (IsPossible(m, stones)) r = m;\\n            else l = m+1;\\n        }\\n        \\n        return l;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2898221,
                "title": "c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int maxJump(vector<int>& stones) {\\n        int n = stones.size(), ans = 0;\\n        for(int i=2; i<n; i+=2) ans = max(ans, stones[i] - stones[i-2]);\\n        for(int i=3; i<n; i+=2) ans = max(ans, stones[i] - stones[i-2]);\\n        ans = max(ans, stones[1] - stones[0]);\\n        ans = max(ans, stones[n-1] - stones[n-2]);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxJump(vector<int>& stones) {\\n        int n = stones.size(), ans = 0;\\n        for(int i=2; i<n; i+=2) ans = max(ans, stones[i] - stones[i-2]);\\n        for(int i=3; i<n; i+=2) ans = max(ans, stones[i] - stones[i-2]);\\n        ans = max(ans, stones[1] - stones[0]);\\n        ans = max(ans, stones[n-1] - stones[n-2]);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2898012,
                "title": "5-line-s-linear-dp-solution-simple-concise",
                "content": "# Intuition\\nIts a vairiation of linear dp in this the answer of ith stones will depend upon the (i-1)th and (i-2)th stone.\\n\\n# Approach\\nif iam at the ith stone i can reach there through (i-1)th stone and go back to 0 using (i-2)th stone or the vice versa.\\nSo my recurence realtion will be something like this:\\ndp[i] = max(max(stones[i]-stones[i-1],dp[i-1]),max(stones[i]-stones[i-2],dp[i-2]) );\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxJump(vector<int>& stones) {\\n        \\n        vector<int> dp(stones.size(),0);\\n        \\n        dp[0] = stones[0];\\n        dp[1] = stones[1];\\n        int i,n=stones.size();\\n        for(i=2;i<n;i++)\\n        {\\n            dp[i] = max(max(stones[i]-stones[i-1],dp[i-1]),max(stones[i]-stones[i-2],dp[i-2]) );\\n        }\\n        return dp[n-1];\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxJump(vector<int>& stones) {\\n        \\n        vector<int> dp(stones.size(),0);\\n        \\n        dp[0] = stones[0];\\n        dp[1] = stones[1];\\n        int i,n=stones.size();\\n        for(i=2;i<n;i++)\\n        {\\n            dp[i] = max(max(stones[i]-stones[i-1],dp[i-1]),max(stones[i]-stones[i-2],dp[i-2]) );\\n        }\\n        return dp[n-1];\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2897999,
                "title": "java-dp",
                "content": "when starting at first rock we have 2 options:\\n1. Go to finish through rock2 and return through rock3(2-1 and then 3-1)\\n2. Go to finish through rock3 and return through rock2 (3-1 and then 2-1) \\nAs we can same it is same calculation for both options and the ans will be max of (1,2) (3,1). \\n\\nSimilarly we calculate  for other index and find the total max.\\n\\nSo if there are 7 rocks\\nfor 1st rock the going path ma value is max of (dist of (3rd-1st) and max value from 3rd to 7th rock)\\nthe coming path value is max of(dist of (2-1) and mx value from 2nd to 7th rock)\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxJump(int[] stones) {\\n        int ans = 0;\\n        int n = stones.length;\\n        if(stones.length == 2) return stones[1] - stones[0];\\n        int[] dist = new int[n];\\n        dist[n-1] = 0;\\n        dist[n-2] = stones[n-1] - stones[n-2];\\n        for(int i=n-3;i>=0;i--) {\\n            int going = Math.max(stones[i+1] - stones[i], dist[i+1]);\\n            int coming = Math.max(stones[i+2] - stones[i], dist[i+2]);\\n            dist[i] = Math.max(going, coming);\\n        }\\n        return dist[0];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int maxJump(int[] stones) {\\n        int ans = 0;\\n        int n = stones.length;\\n        if(stones.length == 2) return stones[1] - stones[0];\\n        int[] dist = new int[n];\\n        dist[n-1] = 0;\\n        dist[n-2] = stones[n-1] - stones[n-2];\\n        for(int i=n-3;i>=0;i--) {\\n            int going = Math.max(stones[i+1] - stones[i], dist[i+1]);\\n            int coming = Math.max(stones[i+2] - stones[i], dist[i+2]);\\n            dist[i] = Math.max(going, coming);\\n        }\\n        return dist[0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3717021,
                "title": "c-clear-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThink of this problem as the frog to sitting on the first stone and now it has to find two optimal paths, the ones with least distance jumps. \\n\\nNow, it could be that one path is more optimal than the other or both are equally optimized.\\n\\nStarting with the first path when frog is sitting at the 0th stone. The most optimal next jump will be the next stone i.e. the 1st stone. And for the second path now, the most optimal path will be jumping from 0th to the next available stone i.e. the 2nd stone since 1st stone is taken by the first path.\\n\\nNow, again the most optimal jump for the first path will be the next available stone i.e. the 3rd stone.\\n\\nHence, we observe that jumping at alternate stones is an optimal path.\\n\\n**Note: This is just one of the most optimized, paths other than the mentioned one may exist which may be equally optimized.**  \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nStarting from 2nd stone we store the highest of all jumps.\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxJump(vector<int>& stones) {\\n        int ans = stones[1] - 0;\\n        for(size_t i = 2; i<stones.size(); i++){\\n            ans = max(ans, stones[i]-stones[i-2]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxJump(vector<int>& stones) {\\n        int ans = stones[1] - 0;\\n        for(size_t i = 2; i<stones.size(); i++){\\n            ans = max(ans, stones[i]-stones[i-2]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3545744,
                "title": "binary-search-approach-2498-frog-jump-ii",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n<!-- # Complexit/y -->\\n<!-- - Time complexity: -->\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#include <bits/stdc++.h> \\nclass Solution {\\npublic:\\n    bool path (vector<int> &stones, int k){\\n        int curr = 0;\\n        set<int> st;\\n        vector<int> remain;\\n        // making a path with max length k. \\n        while(curr + k < stones.back()){\\n            auto it = upper_bound(stones.begin(), stones.end(), curr + k);\\n            it--;\\n            if(*it == curr) return false;\\n            curr = *it;\\n            st.insert(curr);\\n        }\\n        for(int i = 0; i<stones.size(); i++){\\n            if(st.count(stones[i]) == 0) remain.push_back(stones[i]);\\n        }\\n        // checking if path from the remaining stomes exists \\n        for(int i = 1; i<remain.size(); i++){\\n            if(remain[i] - remain[i-1] > k) return false;\\n        }\\n        return true;\\n    } \\n    int maxJump(vector<int>& stones) {\\n        // let k be the maximum jump needed \\n        // approach is that we find greedily the first path and \\\\\\n        then test if path corresponding to return exists \\n        int start = 0, end = stones[stones.size() - 1];\\n        while (start < end){\\n            int mid = (start + end)/2;\\n            if(path(stones, mid)){\\n                end = mid;\\n            }\\n            else start  = mid + 1;\\n        }\\n        return start;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\n#include <bits/stdc++.h> \\nclass Solution {\\npublic:\\n    bool path (vector<int> &stones, int k){\\n        int curr = 0;\\n        set<int> st;\\n        vector<int> remain;\\n        // making a path with max length k. \\n        while(curr + k < stones.back()){\\n            auto it = upper_bound(stones.begin(), stones.end(), curr + k);\\n            it--;\\n            if(*it == curr) return false;\\n            curr = *it;\\n            st.insert(curr);\\n        }\\n        for(int i = 0; i<stones.size(); i++){\\n            if(st.count(stones[i]) == 0) remain.push_back(stones[i]);\\n        }\\n        // checking if path from the remaining stomes exists \\n        for(int i = 1; i<remain.size(); i++){\\n            if(remain[i] - remain[i-1] > k) return false;\\n        }\\n        return true;\\n    } \\n    int maxJump(vector<int>& stones) {\\n        // let k be the maximum jump needed \\n        // approach is that we find greedily the first path and \\\\\\n        then test if path corresponding to return exists \\n        int start = 0, end = stones[stones.size() - 1];\\n        while (start < end){\\n            int mid = (start + end)/2;\\n            if(path(stones, mid)){\\n                end = mid;\\n            }\\n            else start  = mid + 1;\\n        }\\n        return start;\\n\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3370597,
                "title": "simple-greedy-o-n-with-explanation-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nGreeeeedy approach\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n## Let\\'s discuss 3 cases of jumping :\\n\\n**1).We leave more than one step in between in any jump,we need to jump to longer distance,which costs more  because array is strictly increasing.**\\n\\nEg: we jump from 1st to 4th position,leaving 2 stones in between.\\n\\n**2).We leave no step in between for return in any jump,we need to jump two or more steps while returning which costs more.**\\n\\nEg: We jump from 2nd to 3rd position which means while returning ,we need to jump from 4th to 1st position.\\n\\n### 3).So,the best way would be to leave single stone in between in all jumps for returning.\\n# Complexity\\n- Time complexity:    O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:  O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxJump(vector<int>& stones) {\\n        if(stones.size()==2)return stones[1]-stones[0];\\n\\n        int ans=INT_MIN;\\n        for(int i=2;i<stones.size();i++)\\n        {\\n            ans=max(ans,stones[i]-stones[i-2]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxJump(vector<int>& stones) {\\n        if(stones.size()==2)return stones[1]-stones[0];\\n\\n        int ans=INT_MIN;\\n        for(int i=2;i<stones.size();i++)\\n        {\\n            ans=max(ans,stones[i]-stones[i-2]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3370029,
                "title": "python-binary-search-solution-with-explanation",
                "content": "```python\\n\\'\\'\\'\\nIf we can cross the river and go back with the max jumping length m, \\nwe can also cross the river and go back with other max jumping length > m.\\nso we can use binary search to find the minimum max jumping length to cross the river and go back.\\n\\nsearch space of max jumping length is in the [0, max(stones)], left and right bounds are closed.\\nif we can cross the river and go back with the current jumping jump length m, max jumping length can be smaller,\\nif not, max jumping length can be greater.\\n\\nwe can think about how to check if we can cross the river and go back with the current max jumping length m.\\nwhen we are going to the last stone from the first stone, we jump as far as possible until reach last stone,\\nwhen we are going back to the first stone from the last stone, we just jump to the stone we didn\\'t jump over in order.\\n\\ntc is O(len(stones) log(max(stones))), sc is O(n)\\n\\'\\'\\'\\nclass Solution:\\n    def maxJump(self, stones: List[int]) -> int:\\n        l, r = 0, stones[-1]\\n        while l <= r:\\n            m = (l + r) // 2\\n            if self.check(stones, m):\\n                r = m - 1\\n            else: l = m + 1\\n        return l\\n\\n    def check(self, stones, maxJump):\\n        leng = len(stones)\\n        used = [False] * leng # track if the stone has been jumped over or not\\n        lastUsedPos = 0 # the last stone we jumped\\n\\t\\t# we jump as far as possible until reach last stone\\n        for i in range(leng):\\n\\t\\t\\t# if the distance between next stone(stones[i]) and the last stone we jumped > max jumping length,\\n\\t\\t\\t# we jump to the stone before next stone(stones[i-1])\\n\\t\\t\\t# the stone before next stone(stones[i-1]) is the last stone we jumped, return False.\\n\\t\\t\\t# we can not cross the river\\n            if stones[i] - stones[lastUsedPos] > maxJump:\\n                if i - 1 == lastUsedPos: return False\\n                lastUsedPos = i - 1\\n                used[lastUsedPos] = True\\n        used[leng-1] = True\\n        lastUsedPos = leng-1\\n\\t\\t# we just jump to the stone we didn\\'t jump over in order\\n        for i in range(leng-1,-1,-1):\\n\\t\\t\\t# if the stone(stones[i]) we didn\\'t jump, we jump to it,\\n\\t\\t\\t# and check if the distance between the stone(stones[i]) and the last stone we jumped > max jumping length or not.\\n            if used[i] == False:\\n                if stones[lastUsedPos] - stones[i] > maxJump: return False\\n                lastUsedPos = i\\n        return True\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Search"
                ],
                "code": "```python\\n\\'\\'\\'\\nIf we can cross the river and go back with the max jumping length m, \\nwe can also cross the river and go back with other max jumping length > m.\\nso we can use binary search to find the minimum max jumping length to cross the river and go back.\\n\\nsearch space of max jumping length is in the [0, max(stones)], left and right bounds are closed.\\nif we can cross the river and go back with the current jumping jump length m, max jumping length can be smaller,\\nif not, max jumping length can be greater.\\n\\nwe can think about how to check if we can cross the river and go back with the current max jumping length m.\\nwhen we are going to the last stone from the first stone, we jump as far as possible until reach last stone,\\nwhen we are going back to the first stone from the last stone, we just jump to the stone we didn\\'t jump over in order.\\n\\ntc is O(len(stones) log(max(stones))), sc is O(n)\\n\\'\\'\\'\\nclass Solution:\\n    def maxJump(self, stones: List[int]) -> int:\\n        l, r = 0, stones[-1]\\n        while l <= r:\\n            m = (l + r) // 2\\n            if self.check(stones, m):\\n                r = m - 1\\n            else: l = m + 1\\n        return l\\n\\n    def check(self, stones, maxJump):\\n        leng = len(stones)\\n        used = [False] * leng # track if the stone has been jumped over or not\\n        lastUsedPos = 0 # the last stone we jumped\\n\\t\\t# we jump as far as possible until reach last stone\\n        for i in range(leng):\\n\\t\\t\\t# if the distance between next stone(stones[i]) and the last stone we jumped > max jumping length,\\n\\t\\t\\t# we jump to the stone before next stone(stones[i-1])\\n\\t\\t\\t# the stone before next stone(stones[i-1]) is the last stone we jumped, return False.\\n\\t\\t\\t# we can not cross the river\\n            if stones[i] - stones[lastUsedPos] > maxJump:\\n                if i - 1 == lastUsedPos: return False\\n                lastUsedPos = i - 1\\n                used[lastUsedPos] = True\\n        used[leng-1] = True\\n        lastUsedPos = leng-1\\n\\t\\t# we just jump to the stone we didn\\'t jump over in order\\n        for i in range(leng-1,-1,-1):\\n\\t\\t\\t# if the stone(stones[i]) we didn\\'t jump, we jump to it,\\n\\t\\t\\t# and check if the distance between the stone(stones[i]) and the last stone we jumped > max jumping length or not.\\n            if used[i] == False:\\n                if stones[lastUsedPos] - stones[i] > maxJump: return False\\n                lastUsedPos = i\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3020232,
                "title": "java-2-solutions",
                "content": "# 2. one pass\\n```\\n    //2. one pass\\n    //Runtime: 2ms 99%; Memory: 55MB 98%\\n    //Time: O(N); Space: O(1)\\n    public int maxJump(int[] stones) {\\n        int res = stones[1] - stones[0];\\n        for (int i = 2; i < stones.length; i++)\\n            res = Math.max(res, stones[i] - stones[i - 2]);\\n        return res;\\n    }\\n\\n```\\n# 1.Binary search\\n```\\n    //1.Binary search\\n    //Runtime: 94ms 5%; Memory: 60MB 61%\\n    //Time: O( (logMax) * N); Space: O(N)\\n    public int maxJump_1(int[] stones) {\\n        int left = stones[1], right = stones[stones.length - 1];\\n\\n        while (left <= right) {\\n            int mid = (left + right) >> 1;\\n            if (helper(stones, mid)) right = mid - 1;\\n            else left = mid + 1;\\n        }\\n        return left;\\n    }\\n\\n    private boolean helper(int[] stones, int x){\\n        int[] memo = new int[stones.length];\\n\\n        int idx = stones[0];\\n        while (idx < stones.length - 1){\\n            int nextStone = Math.min(stones[idx] + x, stones[stones.length - 1]);\\n            int nextIdx = Arrays.binarySearch(stones, nextStone);\\n            if (nextIdx < 0) nextIdx = -nextIdx - 1 - 1;\\n            while (memo[nextIdx] == 1 && nextIdx > idx) nextIdx--;\\n            if (nextIdx == idx) return false;\\n\\n            memo[nextIdx] = 1;\\n            idx = nextIdx;\\n        }\\n\\n        //idx = stones.length - 1;\\n        for (int i = stones.length - 2; i >= 0; i--) {\\n            if (memo[i] == 1) continue;\\n            if (stones[idx] - stones[i] > x) return false;\\n            idx = i;\\n        }\\n        return true;\\n    }   \\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\n    //2. one pass\\n    //Runtime: 2ms 99%; Memory: 55MB 98%\\n    //Time: O(N); Space: O(1)\\n    public int maxJump(int[] stones) {\\n        int res = stones[1] - stones[0];\\n        for (int i = 2; i < stones.length; i++)\\n            res = Math.max(res, stones[i] - stones[i - 2]);\\n        return res;\\n    }\\n\\n```\n```\\n    //1.Binary search\\n    //Runtime: 94ms 5%; Memory: 60MB 61%\\n    //Time: O( (logMax) * N); Space: O(N)\\n    public int maxJump_1(int[] stones) {\\n        int left = stones[1], right = stones[stones.length - 1];\\n\\n        while (left <= right) {\\n            int mid = (left + right) >> 1;\\n            if (helper(stones, mid)) right = mid - 1;\\n            else left = mid + 1;\\n        }\\n        return left;\\n    }\\n\\n    private boolean helper(int[] stones, int x){\\n        int[] memo = new int[stones.length];\\n\\n        int idx = stones[0];\\n        while (idx < stones.length - 1){\\n            int nextStone = Math.min(stones[idx] + x, stones[stones.length - 1]);\\n            int nextIdx = Arrays.binarySearch(stones, nextStone);\\n            if (nextIdx < 0) nextIdx = -nextIdx - 1 - 1;\\n            while (memo[nextIdx] == 1 && nextIdx > idx) nextIdx--;\\n            if (nextIdx == idx) return false;\\n\\n            memo[nextIdx] = 1;\\n            idx = nextIdx;\\n        }\\n\\n        //idx = stones.length - 1;\\n        for (int i = stones.length - 2; i >= 0; i--) {\\n            if (memo[i] == 1) continue;\\n            if (stones[idx] - stones[i] > x) return false;\\n            idx = i;\\n        }\\n        return true;\\n    }   \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2917174,
                "title": "leave-one-to-return",
                "content": "# Intuition\\nTo find the minimum jump the gready approach is to leave one stone in the middel of each jump you make.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nJumping 2 stones at a time and checking for the corner conditions of evne and odd no of rocks.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: *`O(n)`*\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: *`O(1)`*\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxJump(vector<int>& stones) {\\n        int energy = 0, n = stones.size(), i;\\n        for(i = 0; i < n; i += 2) {\\n            if(i + 2 < n) {\\n                energy = max(energy, stones[i + 2] - stones[i]);\\n                if(i < n - 1 && i > 0)\\n                    energy = max(energy, stones[i + 1] - stones[i - 1]);\\n                else if(i > 0)\\n                    energy = max(energy, stones[i] - stones[i - 1]);\\n            }\\n            else {\\n                if(i == n - 1)\\n                    energy = max(energy, stones[i] - stones[i - 1]);\\n                else\\n                    energy = max(energy, max(stones[i + 1] - stones[i], stones[i + 1] - stones[(i - 1 > 0) ? i - 1 : i]));\\n            }\\n                \\n        }\\n        return energy;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxJump(vector<int>& stones) {\\n        int energy = 0, n = stones.size(), i;\\n        for(i = 0; i < n; i += 2) {\\n            if(i + 2 < n) {\\n                energy = max(energy, stones[i + 2] - stones[i]);\\n                if(i < n - 1 && i > 0)\\n                    energy = max(energy, stones[i + 1] - stones[i - 1]);\\n                else if(i > 0)\\n                    energy = max(energy, stones[i] - stones[i - 1]);\\n            }\\n            else {\\n                if(i == n - 1)\\n                    energy = max(energy, stones[i] - stones[i - 1]);\\n                else\\n                    energy = max(energy, max(stones[i + 1] - stones[i], stones[i + 1] - stones[(i - 1 > 0) ? i - 1 : i]));\\n            }\\n                \\n        }\\n        return energy;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2911302,
                "title": "c-easy-solution",
                "content": "\\nclass Solution {\\npublic:\\n    int maxJump(vector<int>& stones) {\\n         int curr=0; \\n        int maximum=0;\\n        if(stones.size()==3){\\n            return stones[2];\\n        }\\n        if(stones.size()==2){\\n            return stones[1];\\n        }\\n         for(int i=1;i<=stones.size();i++){\\n             if(i+2==stones.size()){\\n                  return maximum;;\\n             }\\n             curr=max(stones[i+1]-stones[i-1],stones[i+2]-stones[i]);\\n             maximum=max(maximum,curr);\\n         }\\n        return maximum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    int maxJump(vector<int>& stones) {\\n         int curr=0; \\n        int maximum=0;\\n        if(stones.size()==3){\\n            return stones[2];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2898934,
                "title": "simple-greedy-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxJump(vector<int>& nums) \\n    {\\n        int res = nums[1] - nums[0];\\n        for (int i = 1; i < nums.size() - 1; ++i)\\n            res = max(res, nums[i + 1] - nums[i - 1]);\\n        return res;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxJump(vector<int>& nums) \\n    {\\n        int res = nums[1] - nums[0];\\n        for (int i = 1; i < nums.size() - 1; ++i)\\n            res = max(res, nums[i + 1] - nums[i - 1]);\\n        return res;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2898107,
                "title": "python-o-n-solution",
                "content": "# Approach\\n- Finding difference between even position and odd position(from last)\\n- Appending them into a list\\n- Returning max value of list\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxJump(self, stones: List[int]) -> int:\\n        l=stones\\n        x=[]\\n        n=len(l)\\n        if(n==2):\\n            return abs(l[0]-l[1])\\n        else:\\n            if(n%2==0):\\n                count=0\\n                for i in range(n) :\\n                    if(i%2==0 and i<n-2):\\n                        x.append(abs(l[i]-l[i+2]))\\n\\n\\n                for i in range(n) :\\n                    if(i%2==1 and i<=n-2):\\n                        x.append(abs(l[i]-l[i+2]))\\n\\n\\n            else:\\n                count=1\\n                for i in range(n) :\\n                    if(i%2==0 and i<=n-2):\\n                        x.append(abs(l[i]-l[i+2]))\\n\\n\\n                for i in range(n) :\\n                    if(i%2==1 and i<n-2):\\n                        x.append(abs(l[i]-l[i+2]))\\n            return max(x)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxJump(self, stones: List[int]) -> int:\\n        l=stones\\n        x=[]\\n        n=len(l)\\n        if(n==2):\\n            return abs(l[0]-l[1])\\n        else:\\n            if(n%2==0):\\n                count=0\\n                for i in range(n) :\\n                    if(i%2==0 and i<n-2):\\n                        x.append(abs(l[i]-l[i+2]))\\n\\n\\n                for i in range(n) :\\n                    if(i%2==1 and i<=n-2):\\n                        x.append(abs(l[i]-l[i+2]))\\n\\n\\n            else:\\n                count=1\\n                for i in range(n) :\\n                    if(i%2==0 and i<=n-2):\\n                        x.append(abs(l[i]-l[i+2]))\\n\\n\\n                for i in range(n) :\\n                    if(i%2==1 and i<n-2):\\n                        x.append(abs(l[i]-l[i+2]))\\n            return max(x)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2898067,
                "title": "c-solution-greedy-easy-to-understand-considering-alternate",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nfinding difference of alternate numbers.\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n> we can also solve with space complexity O(1)  (i.e. by taking index only);\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxJump(vector<int>& stones) {\\n        int maxi=INT_MIN;\\n        int n=stones.size();\\n        vector<int> odd, even;\\n        if(n==2 || n==3)return stones[n-1]-stones[0];\\n       \\n        for(int i=0;i<n;i++){\\n            if(i%2==0)odd.push_back(stones[i]);\\n            else even.push_back(stones[i]);\\n        }\\n        if(odd.size()>=2){\\n            for(int i=1;i<odd.size();i++){\\n                maxi=max(maxi,odd[i]-odd[i-1]);\\n            }\\n        }\\n        if(even.size()>=2){\\n            for(int i=1;i<even.size();i++){\\n                maxi=max(maxi,even[i] - even[i-1]);\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxJump(vector<int>& stones) {\\n        int maxi=INT_MIN;\\n        int n=stones.size();\\n        vector<int> odd, even;\\n        if(n==2 || n==3)return stones[n-1]-stones[0];\\n       \\n        for(int i=0;i<n;i++){\\n            if(i%2==0)odd.push_back(stones[i]);\\n            else even.push_back(stones[i]);\\n        }\\n        if(odd.size()>=2){\\n            for(int i=1;i<odd.size();i++){\\n                maxi=max(maxi,odd[i]-odd[i-1]);\\n            }\\n        }\\n        if(even.size()>=2){\\n            for(int i=1;i<even.size();i++){\\n                maxi=max(maxi,even[i] - even[i-1]);\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2898008,
                "title": "one-liner-python-greedy-solution-o-n",
                "content": "# Intuition\\nIf we use a stone, we cannot use it on our way back so we will have to jump above it, so we just need to look at the maximum gaps betwteen stones separated by one stone.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def maxJump(self, stones: List[int]) -> int:\\n        return stones[1] if len(stones)==2 else max(stones[i+2]-stones[i] for i in range (len(stones)-2))\\n    \\n```\\nPlease upvote if you liked!\\n\\nCheers,\\nBerthouille",
                "solutionTags": [
                    "Python3",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def maxJump(self, stones: List[int]) -> int:\\n        return stones[1] if len(stones)==2 else max(stones[i+2]-stones[i] for i in range (len(stones)-2))\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2897914,
                "title": "simple-c-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxJump(vector<int>& stones) {\\n        int res = stones[1], n = stones.size();\\n        for (int i = 2; i< n; i++) {\\n            res = max(res, stones[i]-stones[i-2]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxJump(vector<int>& stones) {\\n        int res = stones[1], n = stones.size();\\n        for (int i = 2; i< n; i++) {\\n            res = max(res, stones[i]-stones[i-2]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2897891,
                "title": "binary-search-the-answer",
                "content": "```\\nclass Solution:\\n    def possible(self, stones, n, x):\\n        i = 0\\n        v = set()\\n        prev = {}\\n        pj = 0\\n        for j in range(n):\\n            if stones[j] - stones[i] <= x and (j == n - 1 or stones[j + 1] - stones[i] > x):\\n                i = j\\n                if j != n - 1:\\n                    v.add(j)\\n            else:\\n                prev[j] = pj\\n                pj = j\\n        prev[n - 1] = pj\\n        if i != n - 1:\\n            return False\\n        i = n - 1\\n        for j in range(n - 1, -1, -1):\\n            if j not in v:\\n                if stones[i] - stones[j] <= x and (j == 0 or stones[i] - stones[prev[j]] > x):\\n                    i = j\\n        return i == 0\\n    \\n    def maxJump(self, stones: List[int]) -> int:\\n        n = len(stones)\\n        beg = 0\\n        end = 1\\n        while not self.possible(stones, n, end):\\n            end *= 2\\n        beg = end // 2\\n        res = end\\n        while beg <= end:\\n            mid = (beg + end) // 2\\n            if self.possible(stones, n, mid):\\n                res = mid\\n                end = mid - 1\\n            else:\\n                beg = mid + 1\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def possible(self, stones, n, x):\\n        i = 0\\n        v = set()\\n        prev = {}\\n        pj = 0\\n        for j in range(n):\\n            if stones[j] - stones[i] <= x and (j == n - 1 or stones[j + 1] - stones[i] > x):\\n                i = j\\n                if j != n - 1:\\n                    v.add(j)\\n            else:\\n                prev[j] = pj\\n                pj = j\\n        prev[n - 1] = pj\\n        if i != n - 1:\\n            return False\\n        i = n - 1\\n        for j in range(n - 1, -1, -1):\\n            if j not in v:\\n                if stones[i] - stones[j] <= x and (j == 0 or stones[i] - stones[prev[j]] > x):\\n                    i = j\\n        return i == 0\\n    \\n    def maxJump(self, stones: List[int]) -> int:\\n        n = len(stones)\\n        beg = 0\\n        end = 1\\n        while not self.possible(stones, n, end):\\n            end *= 2\\n        beg = end // 2\\n        res = end\\n        while beg <= end:\\n            mid = (beg + end) // 2\\n            if self.possible(stones, n, mid):\\n                res = mid\\n                end = mid - 1\\n            else:\\n                beg = mid + 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3913650,
                "title": "nlog-n-binarysearch-solution-simple-and-easy-to-understand",
                "content": "# Approach\\n    -> We are doing bs on answer on the cost \\n    -> and then in the check fuction using upper_bound  we will find the next block where the from will jump . and the max jump frog can take will be the mid \\n    -> Since we cant make our from jump in a block for second time  , we can keep track of that in a set \\n    -> when will just check in the remaining block weather the max jump while returning is less than mid or not \\n    -> if yes we will minimize the cost\\n\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n    O(nlogN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxJump(vector<int>& stones) {\\n        int n = stones.size(),ans = 0 ;\\n        int lo = stones[1]-stones[0] , hi = 1e9;\\n    \\n        auto check =[&](int jump){\\n            int block = 0 ; \\n            vector<int> remain ; \\n            set<int> st ;\\n            while(block+jump<stones.back()){\\n                auto it = upper_bound(stones.begin(), stones.end(), block + jump);\\n                it--;\\n                if(*it==block) return false ; // agr kud pe point kiya tho false \\n                block = *it ; \\n                st.insert(block);\\n            }\\n            for(int i = 0; i<n; i++){\\n            if(st.count(stones[i]) == 0) remain.push_back(stones[i]);\\n            }\\n            // for returning \\n            for(int i = 1; i<remain.size(); i++){\\n                if(remain[i] - remain[i-1] > jump) return false;\\n            }\\n            return true;\\n        };\\n        while(lo<=hi){\\n            int mid = (lo+hi)/2;\\n            if(check(mid)){\\n                ans = mid ; \\n                hi = mid -1 ;\\n            }else{\\n                lo = mid+1;\\n            }\\n        }\\n        return ans ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxJump(vector<int>& stones) {\\n        int n = stones.size(),ans = 0 ;\\n        int lo = stones[1]-stones[0] , hi = 1e9;\\n    \\n        auto check =[&](int jump){\\n            int block = 0 ; \\n            vector<int> remain ; \\n            set<int> st ;\\n            while(block+jump<stones.back()){\\n                auto it = upper_bound(stones.begin(), stones.end(), block + jump);\\n                it--;\\n                if(*it==block) return false ; // agr kud pe point kiya tho false \\n                block = *it ; \\n                st.insert(block);\\n            }\\n            for(int i = 0; i<n; i++){\\n            if(st.count(stones[i]) == 0) remain.push_back(stones[i]);\\n            }\\n            // for returning \\n            for(int i = 1; i<remain.size(); i++){\\n                if(remain[i] - remain[i-1] > jump) return false;\\n            }\\n            return true;\\n        };\\n        while(lo<=hi){\\n            int mid = (lo+hi)/2;\\n            if(check(mid)){\\n                ans = mid ; \\n                hi = mid -1 ;\\n            }else{\\n                lo = mid+1;\\n            }\\n        }\\n        return ans ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3631163,
                "title": "python3-binary-search-solution",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def maxJump(self, stones: List[int]) -> int:\\n        l = 0;r = stones[-1]\\n        while l<r:\\n            m = (l+r)//2\\n            if valid(m,stones):\\n               r = m\\n            else:\\n                l = m+1\\n        return r\\n\\n\\n\\ndef valid(x,stones):\\n    i = 0;j = 0;n = len(stones)\\n    visitedList = [False for x in range(n)]\\n    visitedList[0] = True\\n    while j<n:\\n        if stones[j]-stones[i]>x:\\n            if j==i+1:\\n                return False\\n            else:\\n                i = j-1\\n                visitedList[i] = True\\n        j+=1\\n    visitedList[j-1] = True\\n    last = stones[j-1]\\n    maximum = 0\\n    flag = True\\n    for i in range(n-1,-1,-1):\\n        if visitedList[i]==False:\\n            maximum = max(last-stones[i],maximum)\\n            flag = False\\n            if maximum>x:\\n                return False\\n            last = stones[i]\\n\\n    return last-stones[i]<=x\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxJump(self, stones: List[int]) -> int:\\n        l = 0;r = stones[-1]\\n        while l<r:\\n            m = (l+r)//2\\n            if valid(m,stones):\\n               r = m\\n            else:\\n                l = m+1\\n        return r\\n\\n\\n\\ndef valid(x,stones):\\n    i = 0;j = 0;n = len(stones)\\n    visitedList = [False for x in range(n)]\\n    visitedList[0] = True\\n    while j<n:\\n        if stones[j]-stones[i]>x:\\n            if j==i+1:\\n                return False\\n            else:\\n                i = j-1\\n                visitedList[i] = True\\n        j+=1\\n    visitedList[j-1] = True\\n    last = stones[j-1]\\n    maximum = 0\\n    flag = True\\n    for i in range(n-1,-1,-1):\\n        if visitedList[i]==False:\\n            maximum = max(last-stones[i],maximum)\\n            flag = False\\n            if maximum>x:\\n                return False\\n            last = stones[i]\\n\\n    return last-stones[i]<=x\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3608311,
                "title": "explained-so-even-a-1st-grader-can-understand",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool check(vector<int>&stones,int mid,int n){\\n        unordered_set<int>m;\\n        int i = 1,curr = 0,prev=0;\\n        //prev stores the index till where the jump is possible\\n        // curr stores the index where the frog is currenly at\\n        // i is for exploration for further index which can be possible\\n        while(i<n){\\n            // if the jump size is too small to get to the ith stone then there are two possiblities \\n\\n            if(stones[i]-stones[curr]>mid){\\n                  \\n                 // this insert the previous (which was maximum possible jump from curr into visited)\\n                if(curr!=prev && m.insert(prev).second)\\n                    curr = prev;// as we finalize what can be the maximum we can jump we store it in curr \\n                // curr == prev shows that frog wasn\\'t able to jump even one step ahead from where it was started so jump size is too small\\n                // hence we return false for this size of jump \\n                else\\n                    return false;\\n            }\\n            else{\\n                prev = i++;\\n            }\\n        }\\n        // now for the return path as we marked the index which are already traversed and abs(distance between two stones ) will always be same \\n        // from front also and from back also we can reuse the same code logic \\n        curr = 0; prev = 0; i = 1;\\n\\n        while(i<n){\\n            if(m.find(i)!=m.end()){\\n                ++i;\\n                continue;\\n                //check whether the index is visited or not , if it is visited we move to next index \\n            }\\n            if(stones[i]-stones[curr]>mid){\\n                if(prev!=curr){\\n                    curr= prev;\\n                }\\n                else \\n                    return false;\\n            }\\n            else {\\n                prev = i++;\\n            }\\n        }\\n        return true;\\n    }\\n    int maxJump(vector<int>& stones) {\\n        int n = stones.size();\\n        int low = 0,high = 1e9,ans=stones[n-1]-stones[0];\\n\\n        while(low<=high){\\n            int mid = (low+high)/2;\\n\\n            if(check(stones,mid,n)){\\n                ans = mid;\\n                high = mid-1;\\n            }\\n            else \\n                low = mid+1;\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(vector<int>&stones,int mid,int n){\\n        unordered_set<int>m;\\n        int i = 1,curr = 0,prev=0;\\n        //prev stores the index till where the jump is possible\\n        // curr stores the index where the frog is currenly at\\n        // i is for exploration for further index which can be possible\\n        while(i<n){\\n            // if the jump size is too small to get to the ith stone then there are two possiblities \\n\\n            if(stones[i]-stones[curr]>mid){\\n                  \\n                 // this insert the previous (which was maximum possible jump from curr into visited)\\n                if(curr!=prev && m.insert(prev).second)\\n                    curr = prev;// as we finalize what can be the maximum we can jump we store it in curr \\n                // curr == prev shows that frog wasn\\'t able to jump even one step ahead from where it was started so jump size is too small\\n                // hence we return false for this size of jump \\n                else\\n                    return false;\\n            }\\n            else{\\n                prev = i++;\\n            }\\n        }\\n        // now for the return path as we marked the index which are already traversed and abs(distance between two stones ) will always be same \\n        // from front also and from back also we can reuse the same code logic \\n        curr = 0; prev = 0; i = 1;\\n\\n        while(i<n){\\n            if(m.find(i)!=m.end()){\\n                ++i;\\n                continue;\\n                //check whether the index is visited or not , if it is visited we move to next index \\n            }\\n            if(stones[i]-stones[curr]>mid){\\n                if(prev!=curr){\\n                    curr= prev;\\n                }\\n                else \\n                    return false;\\n            }\\n            else {\\n                prev = i++;\\n            }\\n        }\\n        return true;\\n    }\\n    int maxJump(vector<int>& stones) {\\n        int n = stones.size();\\n        int low = 0,high = 1e9,ans=stones[n-1]-stones[0];\\n\\n        while(low<=high){\\n            int mid = (low+high)/2;\\n\\n            if(check(stones,mid,n)){\\n                ans = mid;\\n                high = mid-1;\\n            }\\n            else \\n                low = mid+1;\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3592442,
                "title": "c-solution-dynamic-programming-memoization-recursion",
                "content": "class Solution {\\npublic:\\n    \\n    int f(int ind,vector<int> &stones,vector<int> &dp){\\n        \\n        if(ind==0) return 0;\\n        if(ind==1) return abs(stones[ind]-stones[ind-1]);\\n        if(dp[ind]!=-1) return dp[ind];\\n        \\n        int curr=abs(stones[ind]-stones[ind-2]);\\n        int rem=f(ind-1,stones,dp);\\n        \\n        return dp[ind]=max(curr,rem);\\n    }\\n    \\n    int maxJump(vector<int>& stones) {\\n        \\n        int n=stones.size();\\n        vector<int> dp(n,-1);\\n        return f(n-1,stones,dp);\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    int f(int ind,vector<int> &stones,vector<int> &dp){\\n        \\n        if(ind==0) return 0;\\n        if(ind==1) return abs(stones[ind]-stones[ind-1]);\\n        if(dp[ind]!=-1) return dp[ind];\\n        \\n        int curr=abs(stones[ind]-stones[ind-2]);\\n        int rem=f(ind-1,stones,dp);\\n        \\n        return dp[ind]=max(curr,rem);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 3454333,
                "title": "bsa-explained-in-detail",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool check(vector<int>&stones,int mid,int n){\\n        unordered_set<int>m;\\n        int i = 1,curr = 0,prev=0;\\n        //prev stores the index till where the jump is possible\\n        // curr stores the index where the frog is currenly at\\n        // i is for exploration for further index which can be possible\\n        while(i<n){\\n            // if the jump size is too small to get to the ith stone then there are two possiblities \\n\\n            if(stones[i]-stones[curr]>mid){\\n                  \\n                 // this insert the previous (which was maximum possible jump from curr into visited)\\n                if(curr!=prev && m.insert(prev).second)\\n                    curr = prev;// as we finalize what can be the maximum we can jump we store it in curr \\n                // curr == prev shows that frog wasn\\'t able to jump even one step ahead from where it was started so jump size is too small\\n                // hence we return false for this size of jump \\n                else\\n                    return false;\\n            }\\n            else{\\n                prev = i++;\\n            }\\n        }\\n        // now for the return path as we marked the index which are already traversed and abs(distance between two stones ) will always be same \\n        // from front also and from back also we can reuse the same code logic \\n        curr = 0; prev = 0; i = 1;\\n\\n        while(i<n){\\n            if(m.find(i)!=m.end()){\\n                ++i;\\n                continue;\\n                //check whether the index is visited or not , if it is visited we move to next index \\n            }\\n            if(stones[i]-stones[curr]>mid){\\n                if(prev!=curr){\\n                    curr= prev;\\n                }\\n                else \\n                    return false;\\n            }\\n            else {\\n                prev = i++;\\n            }\\n        }\\n        return true;\\n    }\\n    int maxJump(vector<int>& stones) {\\n        int n = stones.size();\\n        int low = 0,high = 1e9,ans=stones[n-1]-stones[0];\\n\\n        while(low<=high){\\n            int mid = (low+high)/2;\\n\\n            if(check(stones,mid,n)){\\n                ans = mid;\\n                high = mid-1;\\n            }\\n            else \\n                low = mid+1;\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(vector<int>&stones,int mid,int n){\\n        unordered_set<int>m;\\n        int i = 1,curr = 0,prev=0;\\n        //prev stores the index till where the jump is possible\\n        // curr stores the index where the frog is currenly at\\n        // i is for exploration for further index which can be possible\\n        while(i<n){\\n            // if the jump size is too small to get to the ith stone then there are two possiblities \\n\\n            if(stones[i]-stones[curr]>mid){\\n                  \\n                 // this insert the previous (which was maximum possible jump from curr into visited)\\n                if(curr!=prev && m.insert(prev).second)\\n                    curr = prev;// as we finalize what can be the maximum we can jump we store it in curr \\n                // curr == prev shows that frog wasn\\'t able to jump even one step ahead from where it was started so jump size is too small\\n                // hence we return false for this size of jump \\n                else\\n                    return false;\\n            }\\n            else{\\n                prev = i++;\\n            }\\n        }\\n        // now for the return path as we marked the index which are already traversed and abs(distance between two stones ) will always be same \\n        // from front also and from back also we can reuse the same code logic \\n        curr = 0; prev = 0; i = 1;\\n\\n        while(i<n){\\n            if(m.find(i)!=m.end()){\\n                ++i;\\n                continue;\\n                //check whether the index is visited or not , if it is visited we move to next index \\n            }\\n            if(stones[i]-stones[curr]>mid){\\n                if(prev!=curr){\\n                    curr= prev;\\n                }\\n                else \\n                    return false;\\n            }\\n            else {\\n                prev = i++;\\n            }\\n        }\\n        return true;\\n    }\\n    int maxJump(vector<int>& stones) {\\n        int n = stones.size();\\n        int low = 0,high = 1e9,ans=stones[n-1]-stones[0];\\n\\n        while(low<=high){\\n            int mid = (low+high)/2;\\n\\n            if(check(stones,mid,n)){\\n                ans = mid;\\n                high = mid-1;\\n            }\\n            else \\n                low = mid+1;\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3450223,
                "title": "dp-o-n-o-1-tabulation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBottom up with space optimization\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxJump(vector<int>& stones) {\\n        int n=stones.size();\\n        int prev= stones[1];\\n        for(int i=2;i<n;i++){\\n            int curr=max(prev,stones[i]-stones[i-2]);\\n            prev=curr;\\n        }\\n        return prev;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxJump(vector<int>& stones) {\\n        int n=stones.size();\\n        int prev= stones[1];\\n        for(int i=2;i<n;i++){\\n            int curr=max(prev,stones[i]-stones[i-2]);\\n            prev=curr;\\n        }\\n        return prev;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3352706,
                "title": "python-easy-beginner-solution",
                "content": "# Code\\n```\\nclass Solution(object):\\n    def maxJump(self, stones):\\n        \"\"\"\\n        :type stones: List[int]\\n        :rtype: int\\n        \"\"\"\\n        lst=[0]\\n        mx,evn=0,0\\n        if len(stones)%2==0:\\n            evn=stones.pop()\\n\\n        for i in range(0,len(stones)-1,2):\\n            mx=max(abs(stones[i]-stones[i+2]),mx)\\n            lst.append(stones[i+1])\\n\\n        if evn:\\n            lst.append(evn)\\n        else:\\n            lst.append(stones[-1])\\n        \\n        lst=lst[::-1]\\n        for i in range(len(lst)-1):\\n            mx=max(abs(lst[i]-lst[i+1]),mx)\\n        if evn:\\n            mx=max(mx,abs(stones[-1]-evn))\\n        return mx\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Array",
                    "Greedy"
                ],
                "code": "```\\nclass Solution(object):\\n    def maxJump(self, stones):\\n        \"\"\"\\n        :type stones: List[int]\\n        :rtype: int\\n        \"\"\"\\n        lst=[0]\\n        mx,evn=0,0\\n        if len(stones)%2==0:\\n            evn=stones.pop()\\n\\n        for i in range(0,len(stones)-1,2):\\n            mx=max(abs(stones[i]-stones[i+2]),mx)\\n            lst.append(stones[i+1])\\n\\n        if evn:\\n            lst.append(evn)\\n        else:\\n            lst.append(stones[-1])\\n        \\n        lst=lst[::-1]\\n        for i in range(len(lst)-1):\\n            mx=max(abs(lst[i]-lst[i+1]),mx)\\n        if evn:\\n            mx=max(mx,abs(stones[-1]-evn))\\n        return mx\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3271478,
                "title": "python-solution-for-noobs-using-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst, the code checks if the length of the input array is 2. If it is, then there is only one jump the frog can make, from the first stone to the last stone. In this case, the code simply returns the absolute difference between the positions of the first and last stones.\\n\\nIf the length of the input array is greater than 2, the code initializes a variable called maxjump to 0. The variable maxjump will be used to keep track of the maximum length of a jump the frog can make.\\n\\nNext, the code uses a for loop to iterate over the input array from the first stone to the second to last stone. For each iteration of the loop, the code computes the length of the jump the frog can make to the stone that is two positions ahead. The length of the jump is simply the absolute difference between the positions of the current stone and the stone two positions ahead.\\n\\nThe code then updates the value of maxjump to be the maximum of its current value and the length of the jump that was just computed. This is done to keep track of the maximum length of a jump the frog can make.\\n\\nFinally, the code returns the value of maxjump, which represents the maximum length of a jump the frog can make to reach a stone in the input array.\\n\\nTo summarize, the code iterates over the input array and computes the length of the jump the frog can make to reach the stone that is two positions ahead for each stone in the array. It then keeps track of the maximum length of a jump the frog can make using the variable maxjump and returns this value as the answer.\\n\\n\\n\\n# Complexity\\n- Time complexity:  **O(n)**, where n is the length of the input array. This is because the code uses a single for loop that iterates over the input array once.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:  **O(1)**, which is constant. This is because the code only uses a fixed number of variables, regardless of the size of the input array. Specifically, it uses variables to keep track of the maximum jump length and the current position of the frog in the array. Since the number of variables used by the code is constant, the space complexity of the code is also constant.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def maxJump(self, stones):\\n        \"\"\"\\n        :type stones: List[int]\\n        :rtype: int\\n        \"\"\"\\n        if len(stones) == 2:\\n            return (stones[-1] - stones[0])\\n    \\n        maxjump = 0\\n        for i in range(len(stones)-2):\\n            jump = stones[i+2] - stones[i]\\n            maxjump = max(maxjump, jump)\\n            \\n        return maxjump\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```\\nclass Solution(object):\\n    def maxJump(self, stones):\\n        \"\"\"\\n        :type stones: List[int]\\n        :rtype: int\\n        \"\"\"\\n        if len(stones) == 2:\\n            return (stones[-1] - stones[0])\\n    \\n        maxjump = 0\\n        for i in range(len(stones)-2):\\n            jump = stones[i+2] - stones[i]\\n            maxjump = max(maxjump, jump)\\n            \\n        return maxjump\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3001878,
                "title": "simple",
                "content": "\\n\\n# Code\\n\\nC++\\n```\\npublic:\\n    int maxJump(vector<int>& stones) {\\n        int maxJump = stones[1] - stones[0];\\n        for (int i = 2; i < stones.size(); ++i)\\n           maxJump = max(stones[i] - stones[i - 2], maxJump);\\n\\n    return maxJump;  \\n    }\\n```\\nJava\\n```\\npublic int maxJump(int[] stones) {\\n    int maxJump = stones[1] - stones[0];\\n    for (int i = 2; i < stones.length; ++i)\\n      maxJump = Math.max(stones[i] - stones[i - 2], maxJump);\\n\\n    return maxJump;\\n```",
                "solutionTags": [
                    "C++",
                    "Java"
                ],
                "code": "```\\npublic:\\n    int maxJump(vector<int>& stones) {\\n        int maxJump = stones[1] - stones[0];\\n        for (int i = 2; i < stones.size(); ++i)\\n           maxJump = max(stones[i] - stones[i - 2], maxJump);\\n\\n    return maxJump;  \\n    }\\n```\n```\\npublic int maxJump(int[] stones) {\\n    int maxJump = stones[1] - stones[0];\\n    for (int i = 2; i < stones.length; ++i)\\n      maxJump = Math.max(stones[i] - stones[i - 2], maxJump);\\n\\n    return maxJump;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2922328,
                "title": "binary-search-java-solution",
                "content": "\\n\\n# Approach:\\n- Binary Search\\n\\n# Complexity\\n- Time complexity: N(logN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: o(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport java.util.*;\\n\\nclass Solution {\\n   \\n    int n=0;\\n    public int maxJump(int[] stones) {\\n        n=stones.length;\\n        int ans=0;\\n        int str=0,end=stones[n-1]-stones[0];\\n        while (str<=end){\\n            int mid=str+(end-str)/2;\\n            boolean isPossible=isItPossibleToComplete(mid,stones);\\n            System.out.println(mid+\" : \"+isPossible);\\n            if(isPossible){\\n                ans=mid;\\n                end=mid-1;\\n            }else{\\n                str=mid+1;\\n            }\\n\\n        }\\n        return ans;\\n    }\\n    public boolean isItPossibleToComplete(int maxGap,int[] stones){\\n        int i=0,lastTaken=0;\\n        boolean[] arr=new boolean[n];\\n        while (i<n){\\n            lastTaken=i;\\n            int j=i+1;\\n            while (j<n && stones[j]-stones[i]<=maxGap){\\n                if(!arr[j]){\\n                    lastTaken=j;\\n                }\\n                j++;\\n            }\\n            if(lastTaken==n-1){\\n                break;\\n            }\\n            if(lastTaken==i){\\n                return false;\\n            }\\n            i=lastTaken;\\n            arr[i]=true;\\n        }\\n        i=n-1;\\n        lastTaken=n-1;\\n        while (i>=0){\\n            lastTaken=i;\\n            int j=i-1 ;\\n                  while (j>=0 && stones[i]-stones[j]<=maxGap){\\n                      if(!arr[j]){\\n                          lastTaken=j;\\n                      }\\n                      j--;\\n            }\\n            if(lastTaken==0){\\n                break;\\n            }\\n            if(lastTaken==i){\\n                return false;\\n            }\\n            i=lastTaken;\\n            arr[i]=true;\\n\\n        }\\n        return true;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nimport java.util.*;\\n\\nclass Solution {\\n   \\n    int n=0;\\n    public int maxJump(int[] stones) {\\n        n=stones.length;\\n        int ans=0;\\n        int str=0,end=stones[n-1]-stones[0];\\n        while (str<=end){\\n            int mid=str+(end-str)/2;\\n            boolean isPossible=isItPossibleToComplete(mid,stones);\\n            System.out.println(mid+\" : \"+isPossible);\\n            if(isPossible){\\n                ans=mid;\\n                end=mid-1;\\n            }else{\\n                str=mid+1;\\n            }\\n\\n        }\\n        return ans;\\n    }\\n    public boolean isItPossibleToComplete(int maxGap,int[] stones){\\n        int i=0,lastTaken=0;\\n        boolean[] arr=new boolean[n];\\n        while (i<n){\\n            lastTaken=i;\\n            int j=i+1;\\n            while (j<n && stones[j]-stones[i]<=maxGap){\\n                if(!arr[j]){\\n                    lastTaken=j;\\n                }\\n                j++;\\n            }\\n            if(lastTaken==n-1){\\n                break;\\n            }\\n            if(lastTaken==i){\\n                return false;\\n            }\\n            i=lastTaken;\\n            arr[i]=true;\\n        }\\n        i=n-1;\\n        lastTaken=n-1;\\n        while (i>=0){\\n            lastTaken=i;\\n            int j=i-1 ;\\n                  while (j>=0 && stones[i]-stones[j]<=maxGap){\\n                      if(!arr[j]){\\n                          lastTaken=j;\\n                      }\\n                      j--;\\n            }\\n            if(lastTaken==0){\\n                break;\\n            }\\n            if(lastTaken==i){\\n                return false;\\n            }\\n            i=lastTaken;\\n            arr[i]=true;\\n\\n        }\\n        return true;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2909167,
                "title": "greedy-solution-with-example-and-proof",
                "content": "\\n# Keypoint\\n1. Use all rocks: the more rock in path, the better. This is because more rocks make each jump shorter.\\n2. Jump alternatively is optimal. so we check all (stones[i+2] - stones[i]) and find maximum. \\n\\n# Proof\\nWe use example `[1,2,3,4]` to prove alterntive-jump is optimal when n == 4. \\n\\nCase1: If frog jumps alternatively, the forward path\\'s jump are [1,3], back path\\'s jump are [4,2].\\nCase2: If frog doesn\\'t jump alternatively, forward path\\'s jump are [1,2],[2,3],[3,4], back path\\'s jump are [4,1]\\n\\nWe can see Case2\\'s back jump [4,1] covers Case1\\'s [1,3] and [4,2]. So Case2 must be larger than Case1.\\n\\nSo we proved it is always optimal to jump alternatively when n == 4.\\nThen we can prove the statement always hold through induction.\\n\\n\\n```\\nclass Solution:\\n    def maxJump(self, stones: List[int]) -> int:\\n        n = len(stones)\\n        ans = stones[1] - stones[0]\\n        for i in range((n-2)):\\n            ans = max(ans, stones[i+2] - stones[i])\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxJump(self, stones: List[int]) -> int:\\n        n = len(stones)\\n        ans = stones[1] - stones[0]\\n        for i in range((n-2)):\\n            ans = max(ans, stones[i+2] - stones[i])\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2908623,
                "title": "greedy-solution-odd-even-indices-simple",
                "content": "# Code\\n```\\nclass Solution\\n{\\npublic:\\n    int maxJump(vector<int> &s)\\n    {\\n        vector<int> ans;\\n        int n = s.size();\\n        int maxi = 0;\\n        if (n & 1)\\n        {\\n            for (int i = 0; i < n - 2; i += 2)\\n                ans.push_back(s[i + 2] - s[i]);\\n            ans.push_back(s[n - 1] - s[n - 2]);\\n            for (int i = n - 2; i > 1; i -= 2)\\n                ans.push_back(s[i] - s[i - 2]);\\n            ans.push_back(s[1] - s[0]);\\n            maxi = *max_element(ans.begin(), ans.end());\\n            ans.clear();\\n        }\\n        else\\n        {\\n            for (int i = 0; i < n - 2; i += 2)\\n                ans.push_back(s[i + 2] - s[i]);\\n            ans.push_back(s[n - 1] - s[n - 2]);\\n            for (int j = n - 1; j > 1; j -= 2)\\n                ans.push_back(s[j] - s[j - 2]);\\n            ans.push_back(s[1] - s[0]);\\n            maxi = max(maxi, *max_element(ans.begin(), ans.end()));\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    int maxJump(vector<int> &s)\\n    {\\n        vector<int> ans;\\n        int n = s.size();\\n        int maxi = 0;\\n        if (n & 1)\\n        {\\n            for (int i = 0; i < n - 2; i += 2)\\n                ans.push_back(s[i + 2] - s[i]);\\n            ans.push_back(s[n - 1] - s[n - 2]);\\n            for (int i = n - 2; i > 1; i -= 2)\\n                ans.push_back(s[i] - s[i - 2]);\\n            ans.push_back(s[1] - s[0]);\\n            maxi = *max_element(ans.begin(), ans.end());\\n            ans.clear();\\n        }\\n        else\\n        {\\n            for (int i = 0; i < n - 2; i += 2)\\n                ans.push_back(s[i + 2] - s[i]);\\n            ans.push_back(s[n - 1] - s[n - 2]);\\n            for (int j = n - 1; j > 1; j -= 2)\\n                ans.push_back(s[j] - s[j - 2]);\\n            ans.push_back(s[1] - s[0]);\\n            maxi = max(maxi, *max_element(ans.begin(), ans.end()));\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2907451,
                "title": "binary-search-approach-time-complexity-o-n-log-k",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool is_valid(vector<int>& stones, int k){\\n        int n = stones.size();\\n        int st = 0, prev = stones[0];\\n        for(int i=1; i<n; i++){\\n            int j = i;\\n            while(i<n&&stones[i]<=prev+k){\\n                i++;\\n            }\\n            if(i==n) break;\\n            if(i==j) return 0;\\n            prev = stones[i-1];\\n            stones[i-1] = -1;\\n            st = i-1;\\n            i--;\\n        }\\n        st = 0;\\n        for(int i=0; i<n; i++){\\n            if(stones[i]!=-1&& (stones[i]-stones[st])>k){\\n                return 0;\\n            }\\n            else if(stones[i]!=-1){\\n                st = i;\\n            }\\n        }\\n        return 1;\\n    }\\n    int maxJump(vector<int>& stones) {\\n        int st = 0, end = 1000000009,ans = 0;\\n        while(st<=end){\\n            int mid = (st+end)/2;\\n            vector<int>temp = stones;\\n            if(is_valid(temp,mid)){\\n                ans = mid;\\n                end = mid-1;\\n            }\\n            else{\\n                st = mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool is_valid(vector<int>& stones, int k){\\n        int n = stones.size();\\n        int st = 0, prev = stones[0];\\n        for(int i=1; i<n; i++){\\n            int j = i;\\n            while(i<n&&stones[i]<=prev+k){\\n                i++;\\n            }\\n            if(i==n) break;\\n            if(i==j) return 0;\\n            prev = stones[i-1];\\n            stones[i-1] = -1;\\n            st = i-1;\\n            i--;\\n        }\\n        st = 0;\\n        for(int i=0; i<n; i++){\\n            if(stones[i]!=-1&& (stones[i]-stones[st])>k){\\n                return 0;\\n            }\\n            else if(stones[i]!=-1){\\n                st = i;\\n            }\\n        }\\n        return 1;\\n    }\\n    int maxJump(vector<int>& stones) {\\n        int st = 0, end = 1000000009,ans = 0;\\n        while(st<=end){\\n            int mid = (st+end)/2;\\n            vector<int>temp = stones;\\n            if(is_valid(temp,mid)){\\n                ans = mid;\\n                end = mid-1;\\n            }\\n            else{\\n                st = mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2902044,
                "title": "dp-solution-o-n-c-100-effective-solution",
                "content": "# Intuition\\nWhile understanding the problem statement I get to know that this problem is based on minimization of maximum value of Jump. So, as far as I concern, Dynamic Programming technique generally solves minimization and maximization based problems in optimized way and takes less time.\\n\\n# Approach\\nFor the given problem statement I used Dynamic Programming technique.\\n\\n# Complexity\\n- Time complexity: O(n)\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxJump(vector<int>& stones) {\\n        int n=stones.size();\\n        int dp[n];\\n        dp[0]=0;\\n        dp[1]=stones[1]-stones[0];\\n        if(n==2)\\n            return dp[1];\\n        dp[2]=stones[2]-stones[0];\\n        for(int i=3;i<n;i++){\\n            dp[i]=max(dp[i-1],stones[i]-stones[i-2]);\\n        }\\n        return dp[n-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxJump(vector<int>& stones) {\\n        int n=stones.size();\\n        int dp[n];\\n        dp[0]=0;\\n        dp[1]=stones[1]-stones[0];\\n        if(n==2)\\n            return dp[1];\\n        dp[2]=stones[2]-stones[0];\\n        for(int i=3;i<n;i++){\\n            dp[i]=max(dp[i-1],stones[i]-stones[i-2]);\\n        }\\n        return dp[n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2898628,
                "title": "java-take-difference-of-every-alternate-index",
                "content": "# Please Upvote :D\\n\\n\\n``` java []\\nclass Solution {\\n    public int maxJump(int[] stones) {\\n        // int max = stones[1] - stones[0];\\n        if (stones.length == 2) {\\n            return stones[1] - stones[0];\\n        }\\n\\n        int max = 0;\\n\\n        for (int i = 2; i < stones.length; i++) {\\n            max = Math.max(max, stones[i] - stones[i - 2]);\\n        }\\n\\n        return max;\\n    }\\n}\\n\\n// TC: O(n), SC: O(1)\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "``` java []\\nclass Solution {\\n    public int maxJump(int[] stones) {\\n        // int max = stones[1] - stones[0];\\n        if (stones.length == 2) {\\n            return stones[1] - stones[0];\\n        }\\n\\n        int max = 0;\\n\\n        for (int i = 2; i < stones.length; i++) {\\n            max = Math.max(max, stones[i] - stones[i - 2]);\\n        }\\n\\n        return max;\\n    }\\n}\\n\\n// TC: O(n), SC: O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2898060,
                "title": "1-line-python",
                "content": "# Code\\n```\\nclass Solution:\\n    def maxJump(self, stones: List[int]) -> int:\\n        return stones[1] - stones[0] if len(stones) == 2 else max(stones[i] - stones[i-2] for i in range(2, len(stones)))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxJump(self, stones: List[int]) -> int:\\n        return stones[1] - stones[0] if len(stones) == 2 else max(stones[i] - stones[i-2] for i in range(2, len(stones)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2898046,
                "title": "greedy-easy-approach-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxJump(vector<int>& v) {\\n        long long int n=v.size(),ans=0;\\n        if(n<=3)\\n        {\\n            return v[n-1]-v[0];\\n        }\\n        for(int i=0;i<n-2;i++)\\n        {\\n            long long int temp=v[i+2]-v[i];\\n            ans=max(ans,temp);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxJump(vector<int>& v) {\\n        long long int n=v.size(),ans=0;\\n        if(n<=3)\\n        {\\n            return v[n-1]-v[0];\\n        }\\n        for(int i=0;i<n-2;i++)\\n        {\\n            long long int temp=v[i+2]-v[i];\\n            ans=max(ans,temp);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2898043,
                "title": "c-java-python3-every-other-stone",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/661cb4686dc915189ddbf0bc35fa51f408bf42ef) for solutions of biweekly 93. \\n\\n**Intuition**\\nThe maximum distance of every other stone is the answer with an edge of `stones[1]` when there are only two stones. \\n**Implementation**\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    int maxJump(vector<int>& stones) {\\n        int ans = stones[1]; \\n        for (int i = 2; i < stones.size(); ++i) \\n            ans = max(ans, stones[i] - stones[i-2]); \\n        return ans; \\n    }\\n};\\n```\\n**Java**\\n```\\nclass Solution {\\n    public int maxJump(int[] stones) {\\n        int ans = stones[1]; \\n        for (int i = 2; i < stones.length; ++i) \\n            ans = Math.max(ans, stones[i] - stones[i-2]); \\n        return ans; \\n    }\\n}\\n```\\n**Python3**\\n```\\nclass Solution:\\n    def maxJump(self, stones: List[int]) -> int:\\n        ans = stones[1]\\n        for i in range(2, len(stones)): \\n            ans = max(ans, stones[i] - stones[i-2])\\n        return ans \\n```\\n**Complexity**\\nTime `O(N)`\\nSpace `O(1)`",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxJump(vector<int>& stones) {\\n        int ans = stones[1]; \\n        for (int i = 2; i < stones.size(); ++i) \\n            ans = max(ans, stones[i] - stones[i-2]); \\n        return ans; \\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int maxJump(int[] stones) {\\n        int ans = stones[1]; \\n        for (int i = 2; i < stones.length; ++i) \\n            ans = Math.max(ans, stones[i] - stones[i-2]); \\n        return ans; \\n    }\\n}\\n```\n```\\nclass Solution:\\n    def maxJump(self, stones: List[int]) -> int:\\n        ans = stones[1]\\n        for i in range(2, len(stones)): \\n            ans = max(ans, stones[i] - stones[i-2])\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2898036,
                "title": "python-code",
                "content": "# Code\\n```\\nclass Solution:\\n    def maxJump(self, stones: List[int]) -> int:\\n        l = len(stones)\\n        if l==3: return stones[2]\\n        answer = stones[1]\\n        for i in range(2, l, 2):\\n            if answer<stones[i]-stones[i-2]:answer=stones[i]-stones[i-2]\\n        for i in range(3, l, 2):\\n            if answer<stones[i]-stones[i-2]:answer=stones[i]-stones[i-2]\\n        return answer\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxJump(self, stones: List[int]) -> int:\\n        l = len(stones)\\n        if l==3: return stones[2]\\n        answer = stones[1]\\n        for i in range(2, l, 2):\\n            if answer<stones[i]-stones[i-2]:answer=stones[i]-stones[i-2]\\n        for i in range(3, l, 2):\\n            if answer<stones[i]-stones[i-2]:answer=stones[i]-stones[i-2]\\n        return answer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2897997,
                "title": "binary-search-o-nlogn-logn-i-think",
                "content": "# Intuition\\nConstrains allow binary searching for the answer, given the max jump size we can make we can verify if we can complete the jumps with that jump size.\\n\\n# Approach\\nBinary search with low as 0 and high and the last value in stones as max jump can be from first to last index.\\nOnce we have the mid value, make the longest jump possible within mid steps\\n\\n# Complexity\\n- Time complexity:\\n$$O(nlogn*logn)$$\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxJump(vector<int>& stones) {\\n        // binary search through the answer\\n        int l = 0;\\n        int h = stones.back();\\n        \\n        // mid is the max jump len allowed\\n        int mid = l + (h - l) / 2;\\n        \\n        int res = INT_MAX;\\n        \\n        while (l <= h) {\\n            mid = l + (h - l) / 2;\\n            // i is where you\\'re jumping from\\n            int i = 0;\\n\\n            // to keep track of used stones\\n            vector<bool> visited ( stones.size(), false);\\n            \\n            while (true) {\\n                // j is where you\\'re jumping to\\n                int j = -1;\\n                // we don\\'t want to mark 0 as visited as we need to come back\\n                if (i != 0)\\n                    visited[i] = true;\\n                \\n                // the max value we are allowed to jump to\\n                int limit = stones[i] + mid;\\n                \\n                // further binary search for max index within limit that we can jump to\\n                int ll = i + 1;\\n                int hh = stones.size() - 1;\\n                \\n                while (ll <= hh) {\\n                    int m = (ll + hh) / 2;\\n                    if (stones[m] <= limit) {\\n                        j = m;\\n                        ll = m + 1;\\n                    }\\n                    else\\n                        hh = m - 1;\\n                }\\n               \\n                // if unable to jump increase mid(max jump we can take)\\n                if (j == -1) {\\n                    l = mid + 1;\\n                    break;\\n                }\\n                else {\\n                    // make j the next position we start from\\n                    i = j;\\n                    // if we reach end break\\n                    if (i == stones.size() - 1)\\n                        break;\\n                }\\n            }\\n            \\n            // if unable to jum increase mid\\n            if (i != stones.size() - 1) {\\n                l = mid + 1;\\n                continue;\\n            }\\n            \\n            // jump back to 0\\n            int idx = stones.size() - 1;\\n            for (int v = stones.size() - 2; v >= 0; v--) {\\n                if (!visited[v]) {\\n                    if (stones[idx] - stones[v] > mid) {\\n                        l = mid + 1;\\n                        break;\\n                    }\\n                    idx = v;\\n                }\\n            }\\n\\n            // if jump back successful store res and look for smaller ans\\n            if (idx == 0) {\\n                h = mid - 1;\\n                res = min(res, mid);\\n                continue;\\n            }\\n            else\\n                l = mid + 1;\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxJump(vector<int>& stones) {\\n        // binary search through the answer\\n        int l = 0;\\n        int h = stones.back();\\n        \\n        // mid is the max jump len allowed\\n        int mid = l + (h - l) / 2;\\n        \\n        int res = INT_MAX;\\n        \\n        while (l <= h) {\\n            mid = l + (h - l) / 2;\\n            // i is where you\\'re jumping from\\n            int i = 0;\\n\\n            // to keep track of used stones\\n            vector<bool> visited ( stones.size(), false);\\n            \\n            while (true) {\\n                // j is where you\\'re jumping to\\n                int j = -1;\\n                // we don\\'t want to mark 0 as visited as we need to come back\\n                if (i != 0)\\n                    visited[i] = true;\\n                \\n                // the max value we are allowed to jump to\\n                int limit = stones[i] + mid;\\n                \\n                // further binary search for max index within limit that we can jump to\\n                int ll = i + 1;\\n                int hh = stones.size() - 1;\\n                \\n                while (ll <= hh) {\\n                    int m = (ll + hh) / 2;\\n                    if (stones[m] <= limit) {\\n                        j = m;\\n                        ll = m + 1;\\n                    }\\n                    else\\n                        hh = m - 1;\\n                }\\n               \\n                // if unable to jump increase mid(max jump we can take)\\n                if (j == -1) {\\n                    l = mid + 1;\\n                    break;\\n                }\\n                else {\\n                    // make j the next position we start from\\n                    i = j;\\n                    // if we reach end break\\n                    if (i == stones.size() - 1)\\n                        break;\\n                }\\n            }\\n            \\n            // if unable to jum increase mid\\n            if (i != stones.size() - 1) {\\n                l = mid + 1;\\n                continue;\\n            }\\n            \\n            // jump back to 0\\n            int idx = stones.size() - 1;\\n            for (int v = stones.size() - 2; v >= 0; v--) {\\n                if (!visited[v]) {\\n                    if (stones[idx] - stones[v] > mid) {\\n                        l = mid + 1;\\n                        break;\\n                    }\\n                    idx = v;\\n                }\\n            }\\n\\n            // if jump back successful store res and look for smaller ans\\n            if (idx == 0) {\\n                h = mid - 1;\\n                res = min(res, mid);\\n                continue;\\n            }\\n            else\\n                l = mid + 1;\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2897965,
                "title": "explained-alternate-series-o-n",
                "content": "\\n# Approach\\nFirst going and coming back is same this as going twice.\\nSo, we will try going to the last stone from first stone twice, but by using different stones. \\nThe overall jump will minimize if the the frog which is behind takes the next stone. So each time frog will use alternate stones to get the max jump minimum.\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxJump(vector<int>& stones) {\\n        int one=0,two=0;\\n        int ans=0;\\n    for(auto i=1;i<stones.size();i++)\\n        if(i%2==0){\\n            ans=max(ans,stones[i]-one);\\n            one=stones[i];\\n        }\\n        else {\\n            ans=max(ans,stones[i]-two);\\n            two=stones[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxJump(vector<int>& stones) {\\n        int one=0,two=0;\\n        int ans=0;\\n    for(auto i=1;i<stones.size();i++)\\n        if(i%2==0){\\n            ans=max(ans,stones[i]-one);\\n            one=stones[i];\\n        }\\n        else {\\n            ans=max(ans,stones[i]-two);\\n            two=stones[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2897946,
                "title": "short-code",
                "content": "# Intuition\\nWe need to look for the path wtih no interaction that why answer will be max(stones[i] - stones[i-2]);\\n\\n \\n\\n# Complexity\\n- Time complexity:O(N)\\n\\n- Space complexity:O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxJump(vector<int>& stones) {\\n        int ans =  stones[1] - stones[0];\\n        for(int i= 2;i<stones.size();i++) \\n               ans = max(ans,abs(stones[i] - stones[i-2]));\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxJump(vector<int>& stones) {\\n        int ans =  stones[1] - stones[0];\\n        for(int i= 2;i<stones.size();i++) \\n               ans = max(ans,abs(stones[i] - stones[i-2]));\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2897931,
                "title": "c-simple-max",
                "content": "# Code\\n```\\npublic class Solution \\n{\\n    public int MaxJump(int[] stones) \\n    {\\n        if (stones.Length == 2)\\n            return stones[1] - stones[0];\\n        int max = int.MinValue;\\n        for (int i = 0; i < stones.Length - 2; i++)\\n        {\\n            max = Math.Max(max, stones[i + 2] - stones[i]);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution \\n{\\n    public int MaxJump(int[] stones) \\n    {\\n        if (stones.Length == 2)\\n            return stones[1] - stones[0];\\n        int max = int.MinValue;\\n        for (int i = 0; i < stones.Length - 2; i++)\\n        {\\n            max = Math.Max(max, stones[i + 2] - stones[i]);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2897923,
                "title": "binary-search-fast-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int> &arr, int maxj)\\n    {\\n        // forward\\n        int startPos = 0;\\n        int currPos = 1;\\n        int n = arr.size();\\n        vector<bool> covered(n, false);\\n        while(currPos < n)\\n        {\\n            //cout << currPos << \" \";\\n            if(arr[currPos] - arr[startPos] > maxj)\\n            {\\n                if(currPos - 1 == startPos) return false; \\n                startPos = currPos - 1;\\n                //cout << startPos << endl;\\n                if(startPos != 0)\\n                covered[startPos] = true;\\n            }\\n            else\\n            {\\n                currPos++;\\n            }\\n        }\\n        // backward\\n        \\n        startPos = n - 1;\\n        currPos = n-2;\\n        int prevPos = startPos;\\n        while(currPos >= 0)\\n        {\\n            //cout << currPos << endl;\\n            if(covered[currPos] == false)\\n            {\\n                \\n                \\n                if(arr[startPos] - arr[currPos] > maxj)\\n                {\\n                    if(prevPos == startPos) return false;\\n                    \\n                    startPos = prevPos;\\n                    //covered[startPos] = true;\\n                }\\n                else\\n                {\\n                    prevPos = currPos;\\n                    currPos--;\\n                }\\n            }\\n            else\\n            currPos--;\\n        }\\n        \\n        return true;\\n    }\\n    int maxJump(vector<int>& stones) {\\n        int low = stones[1] - stones[0];\\n        int x = low;\\n        int n = stones.size();\\n        int high = stones[n-1] - stones[0];\\n        //cout << canJump(stones, 4);\\n        \\n        while(low <= high)\\n        {\\n            int mid = low + (high - low)/2;\\n            \\n            \\n            if(canJump(stones, mid) == true)\\n            {\\n                //cout << mid << endl;\\n                if(mid == x or canJump(stones, mid - 1) == false)\\n                {\\n                    return mid;\\n                }\\n                else\\n                {\\n                    high = mid - 1;\\n                }\\n            }\\n            else\\n            {\\n                low = mid + 1;\\n            }\\n            \\n        }\\n    \\n        return stones[n-1] - stones[0];\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int> &arr, int maxj)\\n    {\\n        // forward\\n        int startPos = 0;\\n        int currPos = 1;\\n        int n = arr.size();\\n        vector<bool> covered(n, false);\\n        while(currPos < n)\\n        {\\n            //cout << currPos << \" \";\\n            if(arr[currPos] - arr[startPos] > maxj)\\n            {\\n                if(currPos - 1 == startPos) return false; \\n                startPos = currPos - 1;\\n                //cout << startPos << endl;\\n                if(startPos != 0)\\n                covered[startPos] = true;\\n            }\\n            else\\n            {\\n                currPos++;\\n            }\\n        }\\n        // backward\\n        \\n        startPos = n - 1;\\n        currPos = n-2;\\n        int prevPos = startPos;\\n        while(currPos >= 0)\\n        {\\n            //cout << currPos << endl;\\n            if(covered[currPos] == false)\\n            {\\n                \\n                \\n                if(arr[startPos] - arr[currPos] > maxj)\\n                {\\n                    if(prevPos == startPos) return false;\\n                    \\n                    startPos = prevPos;\\n                    //covered[startPos] = true;\\n                }\\n                else\\n                {\\n                    prevPos = currPos;\\n                    currPos--;\\n                }\\n            }\\n            else\\n            currPos--;\\n        }\\n        \\n        return true;\\n    }\\n    int maxJump(vector<int>& stones) {\\n        int low = stones[1] - stones[0];\\n        int x = low;\\n        int n = stones.size();\\n        int high = stones[n-1] - stones[0];\\n        //cout << canJump(stones, 4);\\n        \\n        while(low <= high)\\n        {\\n            int mid = low + (high - low)/2;\\n            \\n            \\n            if(canJump(stones, mid) == true)\\n            {\\n                //cout << mid << endl;\\n                if(mid == x or canJump(stones, mid - 1) == false)\\n                {\\n                    return mid;\\n                }\\n                else\\n                {\\n                    high = mid - 1;\\n                }\\n            }\\n            else\\n            {\\n                low = mid + 1;\\n            }\\n            \\n        }\\n    \\n        return stones[n-1] - stones[0];\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2897911,
                "title": "c-odd-and-even-run",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxJump(vector<int>& stones) {\\n        int res, n = stones.size();\\n        res = max(stones[1] - stones[0], 0);\\n        for (int i = 2; i < n; i += 2) {\\n            res = max(res, stones[i] - stones[i - 2]);\\n        }\\n        for (int i = 3; i < n; i += 2) {\\n            res = max(res, stones[i] - stones[i - 2]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxJump(vector<int>& stones) {\\n        int res, n = stones.size();\\n        res = max(stones[1] - stones[0], 0);\\n        for (int i = 2; i < n; i += 2) {\\n            res = max(res, stones[i] - stones[i - 2]);\\n        }\\n        for (int i = 3; i < n; i += 2) {\\n            res = max(res, stones[i] - stones[i - 2]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2897903,
                "title": "python-greedy-o-n-video-solution",
                "content": "The complete intuition is explained in this [video](https://www.youtube.com/watch?v=7eqGntQ7-Fs).\\n\\n# Intuition\\nThe intution is, we have 3 stones  `0, 10, 30`, \\nthen we have to cover atleast `0 -> 30` / `30 -> 0 ` once.\\n\\nSo this max gap will be our answer.\\n\\nSo we try to find max distance between alternate stones.\\n\\n\\nIf this is helpful, please upvote, like the video and subscribe to the channel.\\n\\n```\\nclass Solution:\\n    def maxJump(self, stones: List[int]) -> int:\\n                \\n        n = len(stones)\\n        \\n        if n==2:                                                        # if 2 stones, we have to jump end-to-end. \\n            return stones[-1]                                           # So, last stone will be our answer.\\n                \\n        diff_alternate_stone = 0                        # Otherwise, the answer will be the max dist between alternate stones                                    \\n        \\n        for i in range(n-2):                                            # We find all the alternate distances and maximize it.\\n            diff_alternate_stone = max(diff_alternate_stone, stones[i+2]-stones[i])\\n            \\n        return diff_alternate_stone                                     # The max alternate distance is our answer.",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Greedy"
                ],
                "code": "The complete intuition is explained in this [video](https://www.youtube.com/watch?v=7eqGntQ7-Fs).\\n\\n# Intuition\\nThe intution is, we have 3 stones  `0, 10, 30`, \\nthen we have to cover atleast `0 -> 30` / `30 -> 0 ` once.\\n\\nSo this max gap will be our answer.\\n\\nSo we try to find max distance between alternate stones.\\n\\n\\nIf this is helpful, please upvote, like the video and subscribe to the channel.\\n\\n```\\nclass Solution:\\n    def maxJump(self, stones: List[int]) -> int:\\n                \\n        n = len(stones)\\n        \\n        if n==2:                                                        # if 2 stones, we have to jump end-to-end. \\n            return stones[-1]                                           # So, last stone will be our answer.\\n                \\n        diff_alternate_stone = 0                        # Otherwise, the answer will be the max dist between alternate stones                                    \\n        \\n        for i in range(n-2):                                            # We find all the alternate distances and maximize it.\\n            diff_alternate_stone = max(diff_alternate_stone, stones[i+2]-stones[i])\\n            \\n        return diff_alternate_stone                                     # The max alternate distance is our answer.",
                "codeTag": "Java"
            },
            {
                "id": 4089648,
                "title": "binary-search-java-solution-with-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxJump(int[] stones) {\\n        //binary search\\n        int lo = 0;\\n        int hi = stones[stones.length-1];\\n        while(lo<hi-1){\\n            int mid = lo+(hi-lo)/2;\\n            if(helper(mid,stones))hi=mid;\\n            else lo=mid;\\n        }\\n        \\n        \\n        if(helper(lo,stones))return lo;\\n        return hi;\\n        \\n        \\n        \\n    }\\n    \\n    public boolean helper(int mid,int[] stones){\\n        HashSet<Integer> set = new HashSet<>();//store the indexs used;\\n        int cur = 0;\\n        //first, we see if we could get to the back;\\n        while(cur<stones.length){\\n            int next = cur+1;\\n            if(next==stones.length)break;//this means that we have reached the end;\\n            while(next<=stones.length-1 && stones[next]-stones[cur]<=mid)next+=1;\\n            if(next==cur+1){\\n                return false;//this means we cannot get to the next rock;\\n            }\\n            cur=next-1;\\n            \\n            set.add(cur);\\n        }\\n        List<Integer> list = new ArrayList<>();\\n        \\n        for(int i =0; i<stones.length; i++){\\n            if(!set.contains(i))list.add(stones[i]);\\n        }\\n        list.add(stones[stones.length-1]);\\n        cur = list.size()-1;\\n        \\n        \\n        while(cur>0){\\n            int next = cur-1;\\n            if(next==-1)return true;//this means we have reached the front;\\n           \\n            while(next>=0 && list.get(cur)-list.get(next)<=mid)next-=1;\\n            if(next==cur-1)return false;\\n            \\n            cur=next+1;\\n            \\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxJump(int[] stones) {\\n        //binary search\\n        int lo = 0;\\n        int hi = stones[stones.length-1];\\n        while(lo<hi-1){\\n            int mid = lo+(hi-lo)/2;\\n            if(helper(mid,stones))hi=mid;\\n            else lo=mid;\\n        }\\n        \\n        \\n        if(helper(lo,stones))return lo;\\n        return hi;\\n        \\n        \\n        \\n    }\\n    \\n    public boolean helper(int mid,int[] stones){\\n        HashSet<Integer> set = new HashSet<>();//store the indexs used;\\n        int cur = 0;\\n        //first, we see if we could get to the back;\\n        while(cur<stones.length){\\n            int next = cur+1;\\n            if(next==stones.length)break;//this means that we have reached the end;\\n            while(next<=stones.length-1 && stones[next]-stones[cur]<=mid)next+=1;\\n            if(next==cur+1){\\n                return false;//this means we cannot get to the next rock;\\n            }\\n            cur=next-1;\\n            \\n            set.add(cur);\\n        }\\n        List<Integer> list = new ArrayList<>();\\n        \\n        for(int i =0; i<stones.length; i++){\\n            if(!set.contains(i))list.add(stones[i]);\\n        }\\n        list.add(stones[stones.length-1]);\\n        cur = list.size()-1;\\n        \\n        \\n        while(cur>0){\\n            int next = cur-1;\\n            if(next==-1)return true;//this means we have reached the front;\\n           \\n            while(next>=0 && list.get(cur)-list.get(next)<=mid)next-=1;\\n            if(next==cur-1)return false;\\n            \\n            cur=next+1;\\n            \\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4087165,
                "title": "very-easy-solution-time-complexity-o-n",
                "content": "class Solution {\\npublic:\\n    int maxJump(vector<int>& arr) {\\n        int n=arr.size();int maxi=-1;\\n        for(int i=0;i<n-2;i++){\\n            int a=abs(arr[i]-arr[i+1]);\\n            int b=abs(arr[i]-arr[i+2]);\\n            maxi=max(a,max(maxi,b));\\n        }\\n        maxi=max(maxi,(abs(arr[n-2]-arr[n-1])));\\n        return maxi;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int maxJump(vector<int>& arr) {\\n        int n=arr.size();int maxi=-1;\\n        for(int i=0;i<n-2;i++){\\n            int a=abs(arr[i]-arr[i+1]);\\n            int b=abs(arr[i]-arr[i+2]);\\n            maxi=max(a,max(maxi,b));\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 4078735,
                "title": "beats-100-runtime-javascript-solution-space-optimized-dp",
                "content": "# Space optimised DP solution\\n![Screenshot 2023-09-23 074744.png](https://assets.leetcode.com/users/images/dc8c331e-8439-4d55-bf8d-2ccdcb2fde00_1695435658.2741127.png)\\n\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} stones\\n * @return {number}\\n */\\nvar maxJump = function(stones) {\\n    /**\\n    Target: minimal cost\\n    Intuition: Build your example gradually.\\n        Suppose you have [0,1], you can go 0->1 and 1->0.\\n        Now lets add a 2 in our example, [0, 1, 2], we can go to 2 via\\n        0->1->2 and come back 2-> 0 (as we have already visited 1 and cannot revisit any stones in between)\\n        or, 0->2 and come back 2->0 or 2-> 1> 0\\n        Notice that in both cases we have the min cost of 2 which we derive from arr[i] - arr[i-2]\\n     */\\n    let n = stones.length;\\n\\n    if (n == 2)\\n        return stones[1] - stones[0];\\n    \\n    let res = stones[1] - stones[0];\\n\\n    for(let i=2; i<n; i++)\\n        res = Math.max(res, stones[i] - stones[i-2]);\\n    \\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\n/**\\n * @param {number[]} stones\\n * @return {number}\\n */\\nvar maxJump = function(stones) {\\n    /**\\n    Target: minimal cost\\n    Intuition: Build your example gradually.\\n        Suppose you have [0,1], you can go 0->1 and 1->0.\\n        Now lets add a 2 in our example, [0, 1, 2], we can go to 2 via\\n        0->1->2 and come back 2-> 0 (as we have already visited 1 and cannot revisit any stones in between)\\n        or, 0->2 and come back 2->0 or 2-> 1> 0\\n        Notice that in both cases we have the min cost of 2 which we derive from arr[i] - arr[i-2]\\n     */\\n    let n = stones.length;\\n\\n    if (n == 2)\\n        return stones[1] - stones[0];\\n    \\n    let res = stones[1] - stones[0];\\n\\n    for(let i=2; i<n; i++)\\n        res = Math.max(res, stones[i] - stones[i-2]);\\n    \\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4045878,
                "title": "python-two-frogs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n#### Excited!\\n1. A backward path is like another forward path from stones[0] to stones[-1]. In this problem, it\\'s equivalent to find two forward paths without intersection (except the both ends at stones[0] and stones[-1]), and thus it\\'s equivalent to arrange two frogs taking the two different paths from stones[0] to stones[-1].\\n2. To reduce the maximum steps of each frog, you need to ask the two frogs to jump alternatively forward to a new stone, but they cannot jump to the same new stone.\\n\\n# Code\\n```\\nclass Solution:\\n    def maxJump(self, stones: List[int]) -> int:\\n        n = len(stones)\\n        if n <= 3:\\n            return stones[-1] - stones[0]\\n        \\n        res = 0\\n        for i in range(2, n):\\n            res = max(res, stones[i] - stones[i-2])\\n        \\n        return res\\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxJump(self, stones: List[int]) -> int:\\n        n = len(stones)\\n        if n <= 3:\\n            return stones[-1] - stones[0]\\n        \\n        res = 0\\n        for i in range(2, n):\\n            res = max(res, stones[i] - stones[i-2])\\n        \\n        return res\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4006490,
                "title": "100-faster-and-100-better-memory-usage",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunction maxJump(stones: number[]): number {\\n    const len = stones.length;\\n    let totalJumps = (stones[len - 1] - stones[0]) * 2\\n    let maxJump = totalJumps / len;\\n\\n    for (let i = 0; i < len - 2; i++) {\\n        const jump = stones[i + 2] - stones[i];\\n        if (jump > maxJump) {\\n            maxJump = jump\\n        }\\n    }\\n\\n    return maxJump;\\n}\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction maxJump(stones: number[]): number {\\n    const len = stones.length;\\n    let totalJumps = (stones[len - 1] - stones[0]) * 2\\n    let maxJump = totalJumps / len;\\n\\n    for (let i = 0; i < len - 2; i++) {\\n        const jump = stones[i + 2] - stones[i];\\n        if (jump > maxJump) {\\n            maxJump = jump\\n        }\\n    }\\n\\n    return maxJump;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3975623,
                "title": "easiest-solution",
                "content": "# DIFFERENCE BETWEEN ALTERNATE STONES MAXIMUM IS THE ANS \\n```\\nclass Solution:\\n    def maxJump(self, stones: List[int]) -> int:\\n        if len(stones)==2:\\n            return stones[-1]\\n        ans=0\\n        for i in range(len(stones)-2):\\n            ans=max(ans,stones[i+2]-stones[i])\\n        \\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxJump(self, stones: List[int]) -> int:\\n        if len(stones)==2:\\n            return stones[-1]\\n        ans=0\\n        for i in range(len(stones)-2):\\n            ans=max(ans,stones[i+2]-stones[i])\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3948926,
                "title": "3-lines-fastest-best-solution-o-n-time-o-1-space",
                "content": "# Approach\\nJUST TAKE **MAX DIFFERENCE** BETWEEN **ALTERNATE** ELEMENTS . IT CAN EASILY BE PROVED THAT THIS WILL GIVE THE GLOBAL **MINIMUM** \\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public:\\n  int maxJump ( vector<int>& a , int ans = 0 ) {\\n    for ( int i = 2; i < a.size ( ); i++ ) ans = max ( ans , a [ i ] - a [ i - 2 ] );\\n    if ( a.size ( ) < 3 ) return a.back ( );\\n    return ans;\\n    }\\n  };\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n  public:\\n  int maxJump ( vector<int>& a , int ans = 0 ) {\\n    for ( int i = 2; i < a.size ( ); i++ ) ans = max ( ans , a [ i ] - a [ i - 2 ] );\\n    if ( a.size ( ) < 3 ) return a.back ( );\\n    return ans;\\n    }\\n  };\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3942784,
                "title": "java-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean check(int[] stones, int mj) {\\n        List<Integer> wrap = new ArrayList<>();\\n        wrap.add(0);\\n        int i = 1, n = stones.length;\\n        while (i < n) {\\n            if (stones[i] - stones[wrap.get(wrap.size() - 1)] > mj) {\\n                if (i - 1 != wrap.get(wrap.size() - 1)) {\\n                    wrap.add(i - 1);\\n                } else {\\n                    return false;\\n                }\\n            } else {\\n                i++;\\n            }\\n        }\\n        int c = n - 1;\\n        i = n - 2;\\n        while (i >= 0) {\\n            if (wrap.get(wrap.size() - 1) == i && i != 0) {\\n                i--;\\n                wrap.remove(wrap.size() - 1);\\n            } else {\\n                if (stones[c] - stones[i] > mj) {\\n                    return false;\\n                } else {\\n                    c = i;\\n                    i--;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n\\n\\n\\n\\n    public int maxJump(int[] stones) {\\n        int l = 1, r = stones[stones.length - 1] - stones[0];\\n        while (l <= r) {\\n            int mid = l + (r - l) / 2;\\n            if (check(stones, mid)) {\\n                r = mid - 1;\\n            } else {\\n                l = mid + 1;\\n            }\\n        }\\n        return r + 1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean check(int[] stones, int mj) {\\n        List<Integer> wrap = new ArrayList<>();\\n        wrap.add(0);\\n        int i = 1, n = stones.length;\\n        while (i < n) {\\n            if (stones[i] - stones[wrap.get(wrap.size() - 1)] > mj) {\\n                if (i - 1 != wrap.get(wrap.size() - 1)) {\\n                    wrap.add(i - 1);\\n                } else {\\n                    return false;\\n                }\\n            } else {\\n                i++;\\n            }\\n        }\\n        int c = n - 1;\\n        i = n - 2;\\n        while (i >= 0) {\\n            if (wrap.get(wrap.size() - 1) == i && i != 0) {\\n                i--;\\n                wrap.remove(wrap.size() - 1);\\n            } else {\\n                if (stones[c] - stones[i] > mj) {\\n                    return false;\\n                } else {\\n                    c = i;\\n                    i--;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n\\n\\n\\n\\n    public int maxJump(int[] stones) {\\n        int l = 1, r = stones[stones.length - 1] - stones[0];\\n        while (l <= r) {\\n            int mid = l + (r - l) / 2;\\n            if (check(stones, mid)) {\\n                r = mid - 1;\\n            } else {\\n                l = mid + 1;\\n            }\\n        }\\n        return r + 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3928034,
                "title": "c-greedy-solution-with-o-n-time-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxJump(vector<int>& stones) {\\n        int n=stones.size();\\n        if(n==2 or n==3) return stones[n-1]-stones[0];\\n        vector<int> odd,even;\\n        int ans=INT_MIN;\\n        for(int i=0;i<n;i++){\\n            if(i%2==0) even.push_back(stones[i]);\\n            else odd.push_back(stones[i]);\\n        }\\n        if(odd.size()>=2){\\n            for(int i=1;i<odd.size();i++) ans=max(ans,odd[i]-odd[i-1]);\\n        }\\n        if(even.size()>=2){\\n            for(int i=1;i<even.size();i++) ans=max(ans,even[i]-even[i-1]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxJump(vector<int>& stones) {\\n        int n=stones.size();\\n        if(n==2 or n==3) return stones[n-1]-stones[0];\\n        vector<int> odd,even;\\n        int ans=INT_MIN;\\n        for(int i=0;i<n;i++){\\n            if(i%2==0) even.push_back(stones[i]);\\n            else odd.push_back(stones[i]);\\n        }\\n        if(odd.size()>=2){\\n            for(int i=1;i<odd.size();i++) ans=max(ans,odd[i]-odd[i-1]);\\n        }\\n        if(even.size()>=2){\\n            for(int i=1;i<even.size();i++) ans=max(ans,even[i]-even[i-1]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3926844,
                "title": "greedy",
                "content": "**time : `O(N)`; space: `O(1)`**\\n```\\nint maxJump(vector<int>& s)\\n{\\n\\tint out{}; \\n\\ts.push_back(s.back());\\n\\tfor(int i{2}; i<size(s); ++i)\\n\\t\\tout=max(out, s[i]-s[i-2]);\\n\\treturn out;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint maxJump(vector<int>& s)\\n{\\n\\tint out{}; \\n\\ts.push_back(s.back());\\n\\tfor(int i{2}; i<size(s); ++i)\\n\\t\\tout=max(out, s[i]-s[i-2]);\\n\\treturn out;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3924903,
                "title": "java-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxJump(int[] stones) {\\n        int n=stones.length;\\n        int i=stones[0],j=2*Math.abs(stones[n-1]-stones[0]);\\n        int ans=0;\\n        while(i<j)\\n        {\\n            int mid=(i+j)/2;\\n            if(possible(stones,mid))\\n            {\\n               ans=mid;\\n               j=mid;\\n            }\\n            else\\n            {\\n                i=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n    public boolean possible(int[] stones,int mid)\\n    {\\n        int n=stones.length;\\n        boolean[] visited=new boolean[n];\\n        int last=0;\\n        for(int i=1;i<n;i++)\\n        {\\n          if(stones[i]-stones[last]>mid)\\n          {\\n              if(visited[i-1]==false)\\n              {\\n                  visited[i-1]=true;\\n                  last=i-1;\\n                  i--;\\n              }\\n          }\\n          else if(i==n-1&&stones[i]-stones[last]>mid)\\n          return false;\\n        }\\n        last=n-1;\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            if(stones[last]-stones[i]<=mid&&visited[i]==false)\\n            {\\n                last=i;\\n                visited[i]=false;\\n            }\\n            else if(stones[last]-stones[i]>mid)\\n            return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int maxJump(int[] stones) {\\n        int n=stones.length;\\n        int i=stones[0],j=2*Math.abs(stones[n-1]-stones[0]);\\n        int ans=0;\\n        while(i<j)\\n        {\\n            int mid=(i+j)/2;\\n            if(possible(stones,mid))\\n            {\\n               ans=mid;\\n               j=mid;\\n            }\\n            else\\n            {\\n                i=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n    public boolean possible(int[] stones,int mid)\\n    {\\n        int n=stones.length;\\n        boolean[] visited=new boolean[n];\\n        int last=0;\\n        for(int i=1;i<n;i++)\\n        {\\n          if(stones[i]-stones[last]>mid)\\n          {\\n              if(visited[i-1]==false)\\n              {\\n                  visited[i-1]=true;\\n                  last=i-1;\\n                  i--;\\n              }\\n          }\\n          else if(i==n-1&&stones[i]-stones[last]>mid)\\n          return false;\\n        }\\n        last=n-1;\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            if(stones[last]-stones[i]<=mid&&visited[i]==false)\\n            {\\n                last=i;\\n                visited[i]=false;\\n            }\\n            else if(stones[last]-stones[i]>mid)\\n            return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3906615,
                "title": "easy-binary-search-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPossible(int jump,vector<int>&stones){\\n        unordered_set<int> st;\\n        int cnt = 0; int prev = 0;\\n        for(int i=1;i<stones.size();i++){\\n            auto it = upper_bound(stones.begin(),stones.end(),prev + jump);\\n            int idx = it - stones.begin();idx--;\\n            if(idx >=0 && idx<stones.size()){\\n                st.insert(stones[idx]);\\n                prev = stones[idx];\\n            }\\n            if(idx>=0 && idx<stones.size() && stones[idx]==stones.back()){cnt++;break;}\\n        }\\n        st.erase(stones.back()); prev = stones.back();\\n        for(int i=stones.size()-1;i>=0;i--){\\n            if(!st.count(stones[i]) && prev - stones[i] <=jump) prev = stones[i];\\n            if(prev == stones[0]){cnt++;break;}\\n        }\\n        return cnt == 2;\\n    }\\n    int maxJump(vector<int>& stones) {\\n        int left = 0; int right = *max_element(stones.begin(),stones.end());\\n        while(right>=left){\\n            int mid = left + (right - left)/2;\\n            if(isPossible(mid,stones)) right = mid - 1;\\n            else left = mid + 1;\\n        }\\n        return left;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossible(int jump,vector<int>&stones){\\n        unordered_set<int> st;\\n        int cnt = 0; int prev = 0;\\n        for(int i=1;i<stones.size();i++){\\n            auto it = upper_bound(stones.begin(),stones.end(),prev + jump);\\n            int idx = it - stones.begin();idx--;\\n            if(idx >=0 && idx<stones.size()){\\n                st.insert(stones[idx]);\\n                prev = stones[idx];\\n            }\\n            if(idx>=0 && idx<stones.size() && stones[idx]==stones.back()){cnt++;break;}\\n        }\\n        st.erase(stones.back()); prev = stones.back();\\n        for(int i=stones.size()-1;i>=0;i--){\\n            if(!st.count(stones[i]) && prev - stones[i] <=jump) prev = stones[i];\\n            if(prev == stones[0]){cnt++;break;}\\n        }\\n        return cnt == 2;\\n    }\\n    int maxJump(vector<int>& stones) {\\n        int left = 0; int right = *max_element(stones.begin(),stones.end());\\n        while(right>=left){\\n            int mid = left + (right - left)/2;\\n            if(isPossible(mid,stones)) right = mid - 1;\\n            else left = mid + 1;\\n        }\\n        return left;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3877841,
                "title": "o-n-greedy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nsince, array is increasing optimal move is to jump 2 stones ahead\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxJump(vector<int>& stones) {\\n        if(stones.size() == 2) return stones[1];\\n        int ans = 0;\\n\\n        int i = 0;\\n\\n        while(i < stones.size()){\\n            // if(i+1<stones.size()){\\n            //     ans = max(ans,abs(stones[i]-stones[i+1]));\\n            // }\\n            if(i+2<stones.size()){\\n                ans = max(ans,abs(stones[i]-stones[i+2]));\\n            }\\n            i++;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxJump(vector<int>& stones) {\\n        if(stones.size() == 2) return stones[1];\\n        int ans = 0;\\n\\n        int i = 0;\\n\\n        while(i < stones.size()){\\n            // if(i+1<stones.size()){\\n            //     ans = max(ans,abs(stones[i]-stones[i+1]));\\n            // }\\n            if(i+2<stones.size()){\\n                ans = max(ans,abs(stones[i]-stones[i+2]));\\n            }\\n            i++;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3860170,
                "title": "easy-binary-search-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool check(vector<int>& v,int t){\\n        int n  = v.size();\\n        vector<int> vis(n,0);\\n//         While we move forward\\n        int i=1;\\n        int prev=0;\\n        while(i<n){\\n            if(i==n-1){\\n               prev=n-1; \\n               vis[n-1]=1;\\n            }\\n            if(v[i]-v[prev]>t) return false;\\n            while(v[i]-v[prev]<=t){\\n                i++;\\n                if(i==n){\\n                    break;\\n                }\\n            }\\n            prev=i-1; \\n            vis[i-1]=1;\\n        }\\n//         while we move backward\\n        int j=n-1;\\n        prev=n-1;\\n        while(j>=0){\\n            if(j==0) return true;\\n            while(vis[j]==1){\\n                j--;\\n                if(j==0){\\n                    if(v[prev]-v[j]<=t){\\n                        return true;\\n                    }else{\\n                        return false;\\n                    }\\n                }\\n            }\\n            if(v[prev]-v[j]<=t){\\n                prev=j;\\n                vis[j]=1;\\n            }else{\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    int maxJump(vector<int>& v) {\\n        int n = v.size();\\n        int l=v[0],h=v[n-1];\\n        int ans=0;\\n        while(l<=h){\\n            int m = l+(h-l)/2;\\n            \\n            if(check(v,m)){\\n                ans = m;\\n                h=m-1;\\n            }else{\\n                l=m+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(vector<int>& v,int t){\\n        int n  = v.size();\\n        vector<int> vis(n,0);\\n//         While we move forward\\n        int i=1;\\n        int prev=0;\\n        while(i<n){\\n            if(i==n-1){\\n               prev=n-1; \\n               vis[n-1]=1;\\n            }\\n            if(v[i]-v[prev]>t) return false;\\n            while(v[i]-v[prev]<=t){\\n                i++;\\n                if(i==n){\\n                    break;\\n                }\\n            }\\n            prev=i-1; \\n            vis[i-1]=1;\\n        }\\n//         while we move backward\\n        int j=n-1;\\n        prev=n-1;\\n        while(j>=0){\\n            if(j==0) return true;\\n            while(vis[j]==1){\\n                j--;\\n                if(j==0){\\n                    if(v[prev]-v[j]<=t){\\n                        return true;\\n                    }else{\\n                        return false;\\n                    }\\n                }\\n            }\\n            if(v[prev]-v[j]<=t){\\n                prev=j;\\n                vis[j]=1;\\n            }else{\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    int maxJump(vector<int>& v) {\\n        int n = v.size();\\n        int l=v[0],h=v[n-1];\\n        int ans=0;\\n        while(l<=h){\\n            int m = l+(h-l)/2;\\n            \\n            if(check(v,m)){\\n                ans = m;\\n                h=m-1;\\n            }else{\\n                l=m+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3855835,
                "title": "c-easy-to-understand",
                "content": "# Intuition\\nSince every stone must be used.\\nWe need to find the cost to across each stone, the biggest cost is the final cost.\\nmax(cost, stones[i + 1] - stones[i - 1]);\\nWhen stones length is 2, return stones[1];\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxJump(vector<int>& stones) {\\n        int n = stones.size();\\n        if (n == 2) {\\n            return stones[1];\\n        }\\n        int ans = INT_MIN;\\n        for (int i = 1; i + 1 < n; ++i) {\\n            ans = max(ans, stones[i + 1] - stones[i - 1]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxJump(vector<int>& stones) {\\n        int n = stones.size();\\n        if (n == 2) {\\n            return stones[1];\\n        }\\n        int ans = INT_MIN;\\n        for (int i = 1; i + 1 < n; ++i) {\\n            ans = max(ans, stones[i + 1] - stones[i - 1]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3851596,
                "title": "frog-jump-ii-using-recursion",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int recursiveMaxJump(vector<int>& stones, int pos) {\\n        if (pos <= 1) {\\n            return stones[pos] - stones[0];\\n        }\\n\\n        int prevJump = recursiveMaxJump(stones, pos - 1);\\n        int currentJump = stones[pos] - stones[pos - 2];\\n        return max(prevJump, currentJump);\\n    }\\n    \\n    int maxJump(vector<int>& stones) {\\n         int n = stones.size();\\n        return recursiveMaxJump(stones, n - 1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int recursiveMaxJump(vector<int>& stones, int pos) {\\n        if (pos <= 1) {\\n            return stones[pos] - stones[0];\\n        }\\n\\n        int prevJump = recursiveMaxJump(stones, pos - 1);\\n        int currentJump = stones[pos] - stones[pos - 2];\\n        return max(prevJump, currentJump);\\n    }\\n    \\n    int maxJump(vector<int>& stones) {\\n         int n = stones.size();\\n        return recursiveMaxJump(stones, n - 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3830754,
                "title": "c-short-code-self-explaintotry",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nOn seeing it more clearly you will observe we need to take alternate paths in order to get minimum and then we need to take maximum of them so.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxJump(vector<int>& stones) \\n    {\\n        int maxi = stones[1]-stones[0];\\n        int n = stones.size();\\n        \\n        for(int i=2; i<n; i++){\\n            int curr = stones[i]-stones[i-2];\\n            maxi = max(maxi, curr);\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxJump(vector<int>& stones) \\n    {\\n        int maxi = stones[1]-stones[0];\\n        int n = stones.size();\\n        \\n        for(int i=2; i<n; i++){\\n            int curr = stones[i]-stones[i-2];\\n            maxi = max(maxi, curr);\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3821385,
                "title": "o-n-time-o-1-space-with-complete-proof-simple-linear-scan",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe best you can do is make alternate jumps (eg. 0 to 2, 2 to 4, 4 to 6, ....). That is, skip every other stone and leave it for the return path.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nVery simple approach: We output the maximum of stones[i+2] - stones[i] for each index i.\\n\\nProof of why this approach works:\\n\\nTo prove:\\n1. You can do this (i.e. there is a sequence of jumps that achieve this value):\\n        >> For both odd n and even n you can easily draw these paths to verify.\\n        >> Any such route would cover i to i+2 jumps (for each i) in one of the directions.\\n        >> Also, this route won\\'t make a bigger jump (than these alternate position jumps).\\n\\n2. You can\\'t do better than this (i.e. any other strategy would give worse answer):\\n        >> Suppose the jump i to i+2 (for some i) is the worst in your current route.\\n        >> To do better you need to avoid this jump.\\n        >> You can only avoid this jump, or a bigger jump by:\\n        >>>> Taking the route \"i to i+1 to i+2\".\\n        >> If you take this route, you get the following contradiction:\\n                    >>>> In the return path you\\'ll have to jump from \">= i+2\" to \"<= i-1\".\\n                    >>>> This jump means your algorithm is doing even worse.\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nLinear scan requires O(n) time.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nMaintaining the current maximum requires O(1) space.\\n\\n# Code\\n```\\nclass Solution:\\n    def maxJump(self, stones: List[int]) -> int:\\n\\n        ans = stones[1]\\n        for i in range(2, len(stones)):\\n            ans = max(ans, stones[i] - stones[i-2])\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxJump(self, stones: List[int]) -> int:\\n\\n        ans = stones[1]\\n        for i in range(2, len(stones)):\\n            ans = max(ans, stones[i] - stones[i-2])\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3819822,
                "title": "simple-java-solution-most-optimized",
                "content": "class Solution {\\n    public int maxJump(int[] stones) {\\n        if(stones.length==2)return stones[1]-stones[0];\\n      int i=1;\\n        int j=3;\\n        int res=stones[2]-stones[0];\\n        while(j<stones.length){\\n            res=Math.max(res,stones[j]-stones[i]);\\n            j++;\\n            i++;\\n        }\\n        return res;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "class Solution {\\n    public int maxJump(int[] stones) {\\n        if(stones.length==2)return stones[1]-stones[0];\\n      int i=1;\\n        int j=3;\\n        int res=stones[2]-stones[0];\\n        while(j<stones.length){\\n            res=Math.max(res,stones[j]-stones[i]);\\n            j++;\\n            i++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3786986,
                "title": "simple-linearly-traverse-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\ntravese the array alternatively in first loop start from 0 position and in second loop start from 1st position and last we find max length and return it.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n      O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n      O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxJump(vector<int>& arr) {\\n        int maxi=INT_MIN;\\n        if(arr.size()==2)\\n         return arr[1]-arr[0];\\n\\n        for(int i=0;i<arr.size();i+=2)\\n        {       if(i+2<arr.size())\\n               maxi=max(arr[i+2]-arr[i],maxi);\\n        }\\n\\n        for(int i=1;i<arr.size();i+=2)\\n        {\\n            if(i+2<arr.size())\\n            {\\n                maxi=max(arr[i+2]-arr[i],maxi);\\n            }\\n        }\\n        return maxi;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxJump(vector<int>& arr) {\\n        int maxi=INT_MIN;\\n        if(arr.size()==2)\\n         return arr[1]-arr[0];\\n\\n        for(int i=0;i<arr.size();i+=2)\\n        {       if(i+2<arr.size())\\n               maxi=max(arr[i+2]-arr[i],maxi);\\n        }\\n\\n        for(int i=1;i<arr.size();i+=2)\\n        {\\n            if(i+2<arr.size())\\n            {\\n                maxi=max(arr[i+2]-arr[i],maxi);\\n            }\\n        }\\n        return maxi;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3783935,
                "title": "c-greedy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxJump(vector<int>& stones) \\n    {\\n        int ans = abs(stones[0] - stones[1]);\\n\\n        for(int i=2;i<stones.size();i=i+2)\\n        {\\n            ans=max(ans, abs(stones[i]-stones[i-2]));\\n        }\\n\\n        for(int i=3;i<stones.size();i=i+2)\\n        {\\n            ans=max(ans, abs(stones[i]-stones[i-2]));\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxJump(vector<int>& stones) \\n    {\\n        int ans = abs(stones[0] - stones[1]);\\n\\n        for(int i=2;i<stones.size();i=i+2)\\n        {\\n            ans=max(ans, abs(stones[i]-stones[i-2]));\\n        }\\n\\n        for(int i=3;i<stones.size();i=i+2)\\n        {\\n            ans=max(ans, abs(stones[i]-stones[i-2]));\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3749267,
                "title": "easy-c-solution-tc-o-n-sc-o-1",
                "content": "\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxJump(vector<int>& stones) {\\n        int n=stones.size();\\n        int prev=abs(stones[1]-stones[0]);\\n        int prev2=0;\\n        for(int i=2;i<n;i++){\\n            int sum= abs(stones[i]-stones[i-2]);\\n            int curr=max(prev,sum);\\n            prev2=prev;\\n            prev=curr;\\n        }\\n        return prev;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxJump(vector<int>& stones) {\\n        int n=stones.size();\\n        int prev=abs(stones[1]-stones[0]);\\n        int prev2=0;\\n        for(int i=2;i<n;i++){\\n            int sum= abs(stones[i]-stones[i-2]);\\n            int curr=max(prev,sum);\\n            prev2=prev;\\n            prev=curr;\\n        }\\n        return prev;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3729363,
                "title": "best-reason-for-stones-i-stones-i-2-dp-soln",
                "content": "Approach well explained in comments, explanation is 100% satisfactory\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxJump(vector<int>& stones) {\\n        int n = stones.size();\\n\\n        vector<int>dp(n);\\n\\n        dp[0] = 0;\\n\\n        dp[1] = stones[1]-stones[0];\\n\\n        if(n>2)\\n        dp[2] = stones[2]-stones[0]; // quite obvious, just take example of three stones\\n\\n        for(int i=3;i<n;i++)\\n        {\\n            dp[i] = max(dp[i-1],stones[i]-stones[i-2]); \\n// dp[i-1] would have taken care of every jump except from i to rest of the stones, hence we take care of those paths keeping in mind that we need to minimise the maximum length, now the cboice we are left with is to have a path from i-1 to i, but in this process we need to remember that once i-1 is used in a way it cant be used again to reach back at stone0, hence the closest option(after using stone i-1 to reach stone i) we are left with is to use stone i-2 in return path, hence we did stones[i]-stones[i-2]\\n        }\\n\\n        return dp[n-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxJump(vector<int>& stones) {\\n        int n = stones.size();\\n\\n        vector<int>dp(n);\\n\\n        dp[0] = 0;\\n\\n        dp[1] = stones[1]-stones[0];\\n\\n        if(n>2)\\n        dp[2] = stones[2]-stones[0]; // quite obvious, just take example of three stones\\n\\n        for(int i=3;i<n;i++)\\n        {\\n            dp[i] = max(dp[i-1],stones[i]-stones[i-2]); \\n// dp[i-1] would have taken care of every jump except from i to rest of the stones, hence we take care of those paths keeping in mind that we need to minimise the maximum length, now the cboice we are left with is to have a path from i-1 to i, but in this process we need to remember that once i-1 is used in a way it cant be used again to reach back at stone0, hence the closest option(after using stone i-1 to reach stone i) we are left with is to use stone i-2 in return path, hence we did stones[i]-stones[i-2]\\n        }\\n\\n        return dp[n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3708022,
                "title": "o-n-traverse-alternate-stones-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nTravel alternate stones and compare the diff.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxJump(vector<int>& stones) {\\n        int sz = stones.size();\\n        if(sz == 2 || sz == 3)\\n            return stones[sz-1];\\n        \\n        int maxlen = 0;\\n        bool reach = false;\\n\\n        for(int i=2; i<sz; i+=2){\\n            if(i==(sz-1))\\n              reach = true;\\n            maxlen = max(maxlen, stones[i]-stones[i-2]);\\n        }\\n        int rev = sz-2;\\n        if(!reach){\\n            maxlen = max(maxlen, stones[sz-1]-stones[sz-2]);\\n            rev = sz-3;\\n        }\\n        int pos = sz-1;\\n        for(int i = rev; i>=0; i-=2){\\n            maxlen = max(maxlen, stones[pos] - stones[i]);\\n            pos = i;\\n        }    \\n        maxlen = max(maxlen, stones[1]- stones[0]);\\n        return maxlen;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxJump(vector<int>& stones) {\\n        int sz = stones.size();\\n        if(sz == 2 || sz == 3)\\n            return stones[sz-1];\\n        \\n        int maxlen = 0;\\n        bool reach = false;\\n\\n        for(int i=2; i<sz; i+=2){\\n            if(i==(sz-1))\\n              reach = true;\\n            maxlen = max(maxlen, stones[i]-stones[i-2]);\\n        }\\n        int rev = sz-2;\\n        if(!reach){\\n            maxlen = max(maxlen, stones[sz-1]-stones[sz-2]);\\n            rev = sz-3;\\n        }\\n        int pos = sz-1;\\n        for(int i = rev; i>=0; i-=2){\\n            maxlen = max(maxlen, stones[pos] - stones[i]);\\n            pos = i;\\n        }    \\n        maxlen = max(maxlen, stones[1]- stones[0]);\\n        return maxlen;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3667842,
                "title": "python-single-iteration-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nSingle Iteration\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def maxJump(self, stones: List[int]) -> int:\\n        lo, hi = 0, stones[-1] -  stones[0]\\n        stonesL = len(stones)\\n        ans = 0\\n        first, second = stones[0], stones[0]\\n        for i in range(1, stonesL):\\n            if stones[i] - first >= stones[i] - second:\\n                ans = max(ans, stones[i] - first)\\n                first = stones[i]\\n            else:\\n                ans = max(ans, stones[i] - second)\\n                second = stones[i]\\n        ans = max(ans, stones[-1] - first, stones[-1] - second)\\n        return ans\\n            \\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxJump(self, stones: List[int]) -> int:\\n        lo, hi = 0, stones[-1] -  stones[0]\\n        stonesL = len(stones)\\n        ans = 0\\n        first, second = stones[0], stones[0]\\n        for i in range(1, stonesL):\\n            if stones[i] - first >= stones[i] - second:\\n                ans = max(ans, stones[i] - first)\\n                first = stones[i]\\n            else:\\n                ans = max(ans, stones[i] - second)\\n                second = stones[i]\\n        ans = max(ans, stones[-1] - first, stones[-1] - second)\\n        return ans\\n            \\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3619716,
                "title": "c-implementation-easy-approach-chumeshvari-upvote-if-liked",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n code is different for n = odd  and even\\n if even n then we go from 0 2 4 6 8 ... so on and at last at position second last\\n                        ----->\\nso move second last to last and calculate every jump   cost and taking maximum of that\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nif odd we go 0 2 4 6 8 ..  and position at last\\n---------> move to last to second last first , then start iterating backward \\n\\ni-2 so that move to (1) index and then calculate cost of 1 to 0 jump\\n iterating alternatly is the only approach to solve this problem \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxJump(vector<int>& stones) {\\n        \\n        int n =stones.size();\\n        int i = 0;\\n        int ans = 0;\\n        while(i+2 < n)\\n        {\\n            ans = max(ans, stones[i+2] - stones[i]);\\n            i+=2;\\n        }\\n        \\n        ans = max(ans , stones[n-1] - stones[n-2]);\\n        \\n        if(i == n-2)\\n            i++;\\n        else\\n            i--;\\n        \\n        while(i-2>=0)\\n        {\\n            ans = max(ans, stones[i] - stones[i-2]);\\n            i-=2;\\n        }\\n        \\n        if(i==1)\\n            ans = max(ans, stones[1] - stones[0]);\\n        return  ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxJump(vector<int>& stones) {\\n        \\n        int n =stones.size();\\n        int i = 0;\\n        int ans = 0;\\n        while(i+2 < n)\\n        {\\n            ans = max(ans, stones[i+2] - stones[i]);\\n            i+=2;\\n        }\\n        \\n        ans = max(ans , stones[n-1] - stones[n-2]);\\n        \\n        if(i == n-2)\\n            i++;\\n        else\\n            i--;\\n        \\n        while(i-2>=0)\\n        {\\n            ans = max(ans, stones[i] - stones[i-2]);\\n            i-=2;\\n        }\\n        \\n        if(i==1)\\n            ans = max(ans, stones[1] - stones[0]);\\n        return  ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3587795,
                "title": "java-dp-o-n-and-constant-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n Why stone[i]-stones[i-2]?\\n\\nif we skip/jump more than a stone, we have to jump longer distance and it will cost more as the difference increasing . the answer would not be feasible.\\nAs we just need to visit the stone at most one(given in question) we took alternate path like going via odd indexes and returning via even and vice versa\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nOptimal solution of tabulation \\nmaximum of stone[i]-stones[i-2] and previous maximum\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)= constant space\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxJump(int[] stones) {\\n        int prev2=0;\\n        int prev1=stones[1]-stones[0];\\n        for(int i=2;i<stones.length;i++)\\n        {\\n            int jump=stones[i]-stones[i-2];\\n            prev2=prev1;\\n            prev1=Math.max(prev1,jump);\\n        }\\n        return prev1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int maxJump(int[] stones) {\\n        int prev2=0;\\n        int prev1=stones[1]-stones[0];\\n        for(int i=2;i<stones.length;i++)\\n        {\\n            int jump=stones[i]-stones[i-2];\\n            prev2=prev1;\\n            prev1=Math.max(prev1,jump);\\n        }\\n        return prev1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3561264,
                "title": "easy-dart-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  int maxJump(List<int> stones) {\\n      int maxLength=0;\\n      if(stones.length==2)return (stones[1]-stones[0]).abs();\\n      for(int i=0;i<stones.length-2;i++){\\n          maxLength=max(maxLength,(stones[i]-stones[i+2]).abs());\\n      }\\n      return maxLength;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\n  int maxJump(List<int> stones) {\\n      int maxLength=0;\\n      if(stones.length==2)return (stones[1]-stones[0]).abs();\\n      for(int i=0;i<stones.length-2;i++){\\n          maxLength=max(maxLength,(stones[i]-stones[i+2]).abs());\\n      }\\n      return maxLength;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3554266,
                "title": "rust-python-linear-with-explanation",
                "content": "# Intuition\\nThere are two important things to consider here:\\n - there is no reason to skip a stone. As the cost only depends on the max distance and not at the number of stones you take, there is no point to not use any stones\\n - there is no reason to jump on two consequitive stones. If we will use them, the return path will be always bigger\\n\\nSo we need to test two possible options:\\n - jump from 0th position using 2-size jump\\n - jump from 1st position using 2-size jump\\n\\n# Complexity\\n- Time complexity: $O(n)$\\n- Space complexity: $O(1)$\\n\\n# Code\\n```\\nimpl Solution {\\n  pub fn max_jump(arr: Vec<i32>) -> i32 {\\n    if arr.len() == 2 {\\n      return arr[1] - arr[0];\\n    }\\n\\n    let (mut res, mut v) = (0, arr[0]);\\n    for i in (2 .. arr.len()).step_by(2) {\\n      res = res.max(arr[i] - v);\\n      v = arr[i];\\n    }\\n\\n    v = arr[1];\\n    for i in (3 .. arr.len()).step_by(2) {\\n      res = res.max(arr[i] - v);\\n      v = arr[i];\\n    }\\n\\n    return res;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Python",
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n  pub fn max_jump(arr: Vec<i32>) -> i32 {\\n    if arr.len() == 2 {\\n      return arr[1] - arr[0];\\n    }\\n\\n    let (mut res, mut v) = (0, arr[0]);\\n    for i in (2 .. arr.len()).step_by(2) {\\n      res = res.max(arr[i] - v);\\n      v = arr[i];\\n    }\\n\\n    v = arr[1];\\n    for i in (3 .. arr.len()).step_by(2) {\\n      res = res.max(arr[i] - v);\\n      v = arr[i];\\n    }\\n\\n    return res;\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3471515,
                "title": "binary-search-sliding-window",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ntypedef vector<int>vi;\\nclass Solution {\\npublic:\\nvi a,vis;\\nint n,e;\\n    int maxJump(vector<int>& stones) {\\n        //binary search on solution\\n         n=stones.size();\\n    a =stones;\\n    vis= vi(n,0);\\n    int s = 0, e = 1e9 + 10,mid,ans=0;\\n    while (s <= e) {\\n        mid = (s + e) / 2;\\n        if (Is_Valid(mid))ans = mid, e = mid - 1;\\n        else s = mid + 1;\\n        vis = vi(n, 0);\\n    }\\n    return ans;\\n    }\\n\\n    void ScanFromStart_SlidingWindow(int dis) {\\n    int p1 = 0, p2 = 1;\\n    while ( p2 < n) {\\n        if (abs(a[p2] - a[p1]) <= dis)p2++;\\n        else {\\n            int new_pos = p2 - 1;\\n            if (new_pos == p1)break;\\n             vis[new_pos] = 1;\\n            p1 = new_pos;\\n        }\\n        if (p2 == n) {\\n            vis[p2-1] = 1;\\n            break;\\n        }\\n    }\\n}\\nvoid ScanFromLast(int dis) {\\n    int cur = n - 1;\\n    for (int x = n - 2; x >= 0; x--) {\\n        if (!vis[x]) {\\n            if (abs(a[cur] - a[x]) <= dis)vis[x] = 1, cur = x;\\n            else break;\\n        }\\n    }\\n}\\nbool Is_Valid(int dis) {\\n    ScanFromStart_SlidingWindow(dis);\\n    if (!vis[n - 1])return 0;\\n    ScanFromLast(dis);\\n    if (!vis[0])return 0;\\n    return 1;\\n\\n}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Sliding Window"
                ],
                "code": "```\\ntypedef vector<int>vi;\\nclass Solution {\\npublic:\\nvi a,vis;\\nint n,e;\\n    int maxJump(vector<int>& stones) {\\n        //binary search on solution\\n         n=stones.size();\\n    a =stones;\\n    vis= vi(n,0);\\n    int s = 0, e = 1e9 + 10,mid,ans=0;\\n    while (s <= e) {\\n        mid = (s + e) / 2;\\n        if (Is_Valid(mid))ans = mid, e = mid - 1;\\n        else s = mid + 1;\\n        vis = vi(n, 0);\\n    }\\n    return ans;\\n    }\\n\\n    void ScanFromStart_SlidingWindow(int dis) {\\n    int p1 = 0, p2 = 1;\\n    while ( p2 < n) {\\n        if (abs(a[p2] - a[p1]) <= dis)p2++;\\n        else {\\n            int new_pos = p2 - 1;\\n            if (new_pos == p1)break;\\n             vis[new_pos] = 1;\\n            p1 = new_pos;\\n        }\\n        if (p2 == n) {\\n            vis[p2-1] = 1;\\n            break;\\n        }\\n    }\\n}\\nvoid ScanFromLast(int dis) {\\n    int cur = n - 1;\\n    for (int x = n - 2; x >= 0; x--) {\\n        if (!vis[x]) {\\n            if (abs(a[cur] - a[x]) <= dis)vis[x] = 1, cur = x;\\n            else break;\\n        }\\n    }\\n}\\nbool Is_Valid(int dis) {\\n    ScanFromStart_SlidingWindow(dis);\\n    if (!vis[n - 1])return 0;\\n    ScanFromLast(dis);\\n    if (!vis[0])return 0;\\n    return 1;\\n\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467848,
                "title": "python-o-n-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def maxJump(self, nums: List[int]) -> int:\\n        prev = 0\\n        n = len(nums)\\n\\n        A = 0\\n        prev = 0\\n        for i in range(1, n, 2):\\n            A = max(A, nums[i] - prev)\\n            prev = nums[i]\\n\\n        prev = 0\\n        for i in range(2, n, 2):\\n            A = max(A, nums[i] - prev)\\n            prev = nums[i]\\n        \\n        return max(A, nums[-1] - nums[-2])\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxJump(self, nums: List[int]) -> int:\\n        prev = 0\\n        n = len(nums)\\n\\n        A = 0\\n        prev = 0\\n        for i in range(1, n, 2):\\n            A = max(A, nums[i] - prev)\\n            prev = nums[i]\\n\\n        prev = 0\\n        for i in range(2, n, 2):\\n            A = max(A, nums[i] - prev)\\n            prev = nums[i]\\n        \\n        return max(A, nums[-1] - nums[-2])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3433000,
                "title": "c-5-lines-solution-very-simple",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nuse even-index stones to reach and odd-index stones to return\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nuse even-index stones to reach and odd-index stones to return or oppositely. it is a positive increasing array and one stone could only be use once, so always choose the stone next next to the current stone will minimize the maximum cost. \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxJump(vector<int>& stones) {\\n        if (stones.size()<=2) return stones[1]-stones[0];\\n        int res=0;\\n        for (int i=0; i<stones.size()-2; i++) {\\n            res=max(res, stones[i+2]-stones[i]);\\n// use even-index stones to reach and odd-index stones to return\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxJump(vector<int>& stones) {\\n        if (stones.size()<=2) return stones[1]-stones[0];\\n        int res=0;\\n        for (int i=0; i<stones.size()-2; i++) {\\n            res=max(res, stones[i+2]-stones[i]);\\n// use even-index stones to reach and odd-index stones to return\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3408806,
                "title": "java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxJump(int[] stones) {\\n        if (stones.length==2) return stones[1]-stones[0];\\n        // basic observestion is that the only reason to skip a stone is in order to use it on the way back\\n        // makes the worst jump = max distance betwwn 3 stones ()one path thakes the short jump, one have to take the bigger jump\\n        int max=stones[2]-stones[0];\\n        for (int i=3;i<stones.length;i++){\\n            max =Math.max(stones[i]-stones[i-2],max);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxJump(int[] stones) {\\n        if (stones.length==2) return stones[1]-stones[0];\\n        // basic observestion is that the only reason to skip a stone is in order to use it on the way back\\n        // makes the worst jump = max distance betwwn 3 stones ()one path thakes the short jump, one have to take the bigger jump\\n        int max=stones[2]-stones[0];\\n        for (int i=3;i<stones.length;i++){\\n            max =Math.max(stones[i]-stones[i-2],max);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3402186,
                "title": "java-greedy",
                "content": "```\\nclass Solution {\\n    public int maxJump(int[] stones) {\\n        // Skipping just one stone in every forward jump and\\n\\t\\t// jumping to those skipped stones in backward jump \\n        int n = stones.length;\\n        int maxCost = 0;\\n        boolean[] landed = new boolean[n];\\n        landed[0] = true;\\n        for(int i = 0; i < n; ) {\\n            if(i + 2 < n) {\\n                maxCost = Math.max(maxCost, Math.abs(stones[i + 2] - stones[i]));\\n                landed[i + 2] = true;\\n                i += 2;\\n                \\n            } else if(i + 1 < n) {\\n                maxCost = Math.max(maxCost, Math.abs(stones[i + 1] - stones[i]));\\n                landed[i + 1] = true;\\n                i++;\\n                \\n            }\\n            \\n            if(i == n - 1) break;\\n        }\\n        \\n        int prev = n - 1;\\n        for(int i = n - 1; i >= 0; i--) {\\n            if(!landed[i]) {\\n                maxCost = Math.max(maxCost, Math.abs(stones[prev] - stones[i]));\\n                prev = i;\\n            }\\n        }\\n        \\n        return maxCost;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxJump(int[] stones) {\\n        // Skipping just one stone in every forward jump and\\n\\t\\t// jumping to those skipped stones in backward jump \\n        int n = stones.length;\\n        int maxCost = 0;\\n        boolean[] landed = new boolean[n];\\n        landed[0] = true;\\n        for(int i = 0; i < n; ) {\\n            if(i + 2 < n) {\\n                maxCost = Math.max(maxCost, Math.abs(stones[i + 2] - stones[i]));\\n                landed[i + 2] = true;\\n                i += 2;\\n                \\n            } else if(i + 1 < n) {\\n                maxCost = Math.max(maxCost, Math.abs(stones[i + 1] - stones[i]));\\n                landed[i + 1] = true;\\n                i++;\\n                \\n            }\\n            \\n            if(i == n - 1) break;\\n        }\\n        \\n        int prev = n - 1;\\n        for(int i = n - 1; i >= 0; i--) {\\n            if(!landed[i]) {\\n                maxCost = Math.max(maxCost, Math.abs(stones[prev] - stones[i]));\\n                prev = i;\\n            }\\n        }\\n        \\n        return maxCost;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3396552,
                "title": "easy-java-solution-using-binary-search",
                "content": "# Complexity\\n- Time complexity: $$O(nlog(n))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$ (for the HashSet Used)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxJump(int[] stones) {\\n        //  Applying Binary Search on the possible jumps\\n        int n= stones.length;\\n        int left= 1;\\n        int right= stones[n-1]-stones[0];\\n\\n        int minJump= right;\\n\\n        while(left <= right){\\n            int mid= (left+right)/2;\\n\\n            boolean possible= check(stones, mid);\\n\\n            if(possible){\\n                minJump= mid;\\n                right= mid-1;                \\n            }\\n            else{\\n                left= mid+1;\\n            }\\n        }\\n\\n        return minJump;\\n    }\\n\\n    public boolean check(int[] stones, int maxJump){\\n        //  Let\\'s jump by skipping one-one stone\\n        int n= stones.length;\\n        HashSet<Integer> visited= new HashSet<>();\\n\\n        //  Reaching to the end\\n        for(int i=0; i<n; i++){\\n\\n            if(i == n-1){\\n                break;\\n            }\\n            else if(i+1 == n-1){\\n                if(stones[i+1]-stones[i] <= maxJump){\\n                    if(i != 0){\\n                        visited.add(i);\\n                    }\\n                    break;\\n                }\\n                else{\\n                    return false;\\n                }\\n            }\\n            else if( stones[i+2]-stones[i] <= maxJump ){\\n                //  Marking the prev stone as visited\\n                if(i != 0){\\n                    visited.add(i);\\n                }\\n                i++;\\n            }\\n            else{\\n                return false;\\n            }\\n        }\\n\\n        //  Reaching to the start\\n        for(int i=n-1; i>=0; i--){\\n\\n            if(i == 0){\\n                break;\\n            }\\n            if(i-1 == 0){\\n                if(stones[i]-stones[i-1] <= maxJump){\\n                    break;\\n                }\\n                else{\\n                    return false;\\n                }\\n            }\\n\\n            else if( visited.contains(i-1) ){\\n                if(stones[i]-stones[i-2] <= maxJump){\\n                    i--;\\n                }\\n                else{\\n                    return false;\\n                }\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```\\n![please-upvote.jpg](https://assets.leetcode.com/users/images/201a692a-53a7-44b4-ac2d-4f81fe94c3a5_1681026256.3301299.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int maxJump(int[] stones) {\\n        //  Applying Binary Search on the possible jumps\\n        int n= stones.length;\\n        int left= 1;\\n        int right= stones[n-1]-stones[0];\\n\\n        int minJump= right;\\n\\n        while(left <= right){\\n            int mid= (left+right)/2;\\n\\n            boolean possible= check(stones, mid);\\n\\n            if(possible){\\n                minJump= mid;\\n                right= mid-1;                \\n            }\\n            else{\\n                left= mid+1;\\n            }\\n        }\\n\\n        return minJump;\\n    }\\n\\n    public boolean check(int[] stones, int maxJump){\\n        //  Let\\'s jump by skipping one-one stone\\n        int n= stones.length;\\n        HashSet<Integer> visited= new HashSet<>();\\n\\n        //  Reaching to the end\\n        for(int i=0; i<n; i++){\\n\\n            if(i == n-1){\\n                break;\\n            }\\n            else if(i+1 == n-1){\\n                if(stones[i+1]-stones[i] <= maxJump){\\n                    if(i != 0){\\n                        visited.add(i);\\n                    }\\n                    break;\\n                }\\n                else{\\n                    return false;\\n                }\\n            }\\n            else if( stones[i+2]-stones[i] <= maxJump ){\\n                //  Marking the prev stone as visited\\n                if(i != 0){\\n                    visited.add(i);\\n                }\\n                i++;\\n            }\\n            else{\\n                return false;\\n            }\\n        }\\n\\n        //  Reaching to the start\\n        for(int i=n-1; i>=0; i--){\\n\\n            if(i == 0){\\n                break;\\n            }\\n            if(i-1 == 0){\\n                if(stones[i]-stones[i-1] <= maxJump){\\n                    break;\\n                }\\n                else{\\n                    return false;\\n                }\\n            }\\n\\n            else if( visited.contains(i-1) ){\\n                if(stones[i]-stones[i-2] <= maxJump){\\n                    i--;\\n                }\\n                else{\\n                    return false;\\n                }\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3376472,
                "title": "kotlin-simple-loop",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    fun maxJump(stones: IntArray): Int {\\n        var result = stones[1] - stones[0]\\n\\n        for (i in 2 until stones.size) {\\n            result = Math.max(result, stones[i] - stones[i - 2])\\n        }\\n        return result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun maxJump(stones: IntArray): Int {\\n        var result = stones[1] - stones[0]\\n\\n        for (i in 2 until stones.size) {\\n            result = Math.max(result, stones[i] - stones[i - 2])\\n        }\\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3350849,
                "title": "recursive-backtracking-solution-with-tle",
                "content": "```\\nclass Solution{\\n    public:\\n    int ans=INT_MAX;\\n    void backtofront(vector<int>&stones,int prev,int i,vector<int>&vis,int &n,int cost){\\n        if(prev!=-1)\\n              cost=max(cost,abs(stones[i]-stones[prev])); \\n        if(i<0)\\n            return;\\n        if(i==0){\\n            ans=min(cost,ans);\\n            return;\\n        }\\n        \\n        if(vis[i])\\n            return;\\n        \\n        \\n        for(int k=i-1;k>=0;k--){\\n            if(i!=n-1)\\n              vis[i]=1; \\n           \\n            backtofront(stones,i,k,vis,n,cost);\\n            vis[i]=0;\\n        }\\n        \\n       //cout<<\"hi\"<<endl;\\n    }\\n    void fronttoback(vector<int>&stones,int prev,int i,vector<int>&vis,int &n,int cost){\\n        \\n        if(prev!=-1)\\n            cost=max(cost,abs(stones[i]-stones[prev]));\\n        \\n        if(i>=n)\\n            return;\\n        if(i==n-1){\\n            backtofront(stones,-1,n-1,vis,n,cost);\\n            return;\\n        }\\n            \\n        if(vis[i])\\n            return;\\n        \\n        for(int k=i+1;k<n;k++){\\n            if(i!=0)\\n            vis[i]=1;\\n            \\n            fronttoback(stones,i,k,vis,n,cost);\\n            vis[i]=0;\\n        }\\n        \\n    }\\n    int maxJump(vector<int>&stones){\\n        \\n        int n=stones.size();\\n        vector<int>vis(n,0);\\n        \\n        int cost=INT_MIN;\\n        fronttoback(stones,-1,0,vis,n,cost);\\n        return ans;\\n        \\n    }\\n    \\n  \\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution{\\n    public:\\n    int ans=INT_MAX;\\n    void backtofront(vector<int>&stones,int prev,int i,vector<int>&vis,int &n,int cost){\\n        if(prev!=-1)\\n              cost=max(cost,abs(stones[i]-stones[prev])); \\n        if(i<0)\\n            return;\\n        if(i==0){\\n            ans=min(cost,ans);\\n            return;\\n        }\\n        \\n        if(vis[i])\\n            return;\\n        \\n        \\n        for(int k=i-1;k>=0;k--){\\n            if(i!=n-1)\\n              vis[i]=1; \\n           \\n            backtofront(stones,i,k,vis,n,cost);\\n            vis[i]=0;\\n        }\\n        \\n       //cout<<\"hi\"<<endl;\\n    }\\n    void fronttoback(vector<int>&stones,int prev,int i,vector<int>&vis,int &n,int cost){\\n        \\n        if(prev!=-1)\\n            cost=max(cost,abs(stones[i]-stones[prev]));\\n        \\n        if(i>=n)\\n            return;\\n        if(i==n-1){\\n            backtofront(stones,-1,n-1,vis,n,cost);\\n            return;\\n        }\\n            \\n        if(vis[i])\\n            return;\\n        \\n        for(int k=i+1;k<n;k++){\\n            if(i!=0)\\n            vis[i]=1;\\n            \\n            fronttoback(stones,i,k,vis,n,cost);\\n            vis[i]=0;\\n        }\\n        \\n    }\\n    int maxJump(vector<int>&stones){\\n        \\n        int n=stones.size();\\n        vector<int>vis(n,0);\\n        \\n        int cost=INT_MIN;\\n        fronttoback(stones,-1,0,vis,n,cost);\\n        return ans;\\n        \\n    }\\n    \\n  \\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3317219,
                "title": "easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxJump(vector<int>& stones) {\\n        int mJump = stones[1]-stones[0];\\n        int n = stones.size();\\n        \\n        for(int i=2; i<n; i++){\\n            int c = stones[i]-stones[i-2];\\n            mJump = max(mJump, c);\\n        }\\n        return mJump;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxJump(vector<int>& stones) {\\n        int mJump = stones[1]-stones[0];\\n        int n = stones.size();\\n        \\n        for(int i=2; i<n; i++){\\n            int c = stones[i]-stones[i-2];\\n            mJump = max(mJump, c);\\n        }\\n        return mJump;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3315666,
                "title": "c-easy-binary-search-n-log-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe use a binary search algorithm to find the maximum jump distance for the frog. It sets the start and end values of the search to the first and last stones, respectively. It then iterates through the search space, checking each mid value with the check() function. If the check() function returns true, then the maximum jump distance is set to the mid value which stores in **ans** and the **end=mid-1**. If false, then the **start=mid+1**. This continues until the start value is greater than the end value, and the maximum jump distance is returned.\\n**Tip: This answer is like finding First Occurence of an element**\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBinary Search Approach\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N*LogN)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool check(int mid, vector<int> v)\\n    {\\n        int n = v.size();\\n        int current_pos = v[0];\\n        for(int i=1; i<n; i++)\\n        {\\n            if(v[i]-current_pos > mid)\\n            {\\n                current_pos = v[i-1];\\n                v[i-1] = -1;\\n            }\\n            if(i==n && current_pos != n-1)\\n            {\\n                if(v[n-1] - current_pos <= mid)\\n                {\\n                    current_pos = v[n-1];\\n                }\\n                else\\n                {\\n                    return false;\\n                }\\n            }\\n        }\\n        current_pos = v[n-1];\\n        for(int i=n-2; i>=0; i--)\\n        {\\n            if(current_pos-v[i] <= mid && v[i] != -1)\\n            {\\n                current_pos = v[i];\\n            }\\n        }\\n        if(current_pos == v[0])\\n        {\\n            return true;\\n        }\\n\\n        return false;\\n    }\\n\\n    int maxJump(vector<int>& stones) {\\n        int start = 1, end = stones.back();\\n        int ans = 0;\\n\\n        while(start <= end)\\n        {\\n            int mid = start+(end-start)/2;\\n\\n            if(check(mid, stones))\\n            {\\n                ans = mid;\\n                end = mid-1;\\n            }\\n            else\\n            {\\n                start = mid+1;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(int mid, vector<int> v)\\n    {\\n        int n = v.size();\\n        int current_pos = v[0];\\n        for(int i=1; i<n; i++)\\n        {\\n            if(v[i]-current_pos > mid)\\n            {\\n                current_pos = v[i-1];\\n                v[i-1] = -1;\\n            }\\n            if(i==n && current_pos != n-1)\\n            {\\n                if(v[n-1] - current_pos <= mid)\\n                {\\n                    current_pos = v[n-1];\\n                }\\n                else\\n                {\\n                    return false;\\n                }\\n            }\\n        }\\n        current_pos = v[n-1];\\n        for(int i=n-2; i>=0; i--)\\n        {\\n            if(current_pos-v[i] <= mid && v[i] != -1)\\n            {\\n                current_pos = v[i];\\n            }\\n        }\\n        if(current_pos == v[0])\\n        {\\n            return true;\\n        }\\n\\n        return false;\\n    }\\n\\n    int maxJump(vector<int>& stones) {\\n        int start = 1, end = stones.back();\\n        int ans = 0;\\n\\n        while(start <= end)\\n        {\\n            int mid = start+(end-start)/2;\\n\\n            if(check(mid, stones))\\n            {\\n                ans = mid;\\n                end = mid-1;\\n            }\\n            else\\n            {\\n                start = mid+1;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3306824,
                "title": "accepted-swift",
                "content": "```\\nclass Solution {\\n    func maxJump(_ stones: [Int]) -> Int {\\n        \\n        guard stones.count > 2 else { return stones[1] - stones[0] }\\n\\n        var res = stones[2] - stones[0]\\n\\n        for i in 1..<(stones.count - 1) {\\n            res = max(res, stones[i + 1] - stones[i - 1])\\n        }\\n\\n        return res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func maxJump(_ stones: [Int]) -> Int {\\n        \\n        guard stones.count > 2 else { return stones[1] - stones[0] }\\n\\n        var res = stones[2] - stones[0]\\n\\n        for i in 1..<(stones.count - 1) {\\n            res = max(res, stones[i + 1] - stones[i - 1])\\n        }\\n\\n        return res\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3306158,
                "title": "python-simple-intuition-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nJust find the maximum distance between two alternate stones and that\\'s all.\\n# Code\\n```\\nclass Solution:\\n    def maxJump(self, stones: List[int]) -> int:\\n        cnt = stones[1] - stones[0]\\n        for i in range(2, len(stones)):\\n            cnt = max(cnt, stones[i] - stones[i - 2])\\n        return cnt\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxJump(self, stones: List[int]) -> int:\\n        cnt = stones[1] - stones[0]\\n        for i in range(2, len(stones)):\\n            cnt = max(cnt, stones[i] - stones[i - 2])\\n        return cnt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3297509,
                "title": "cpp-easy-solution-binary-search-on-ans-greedy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPossible(int mid,vector<int>&arr){\\n        map<int,int>mp;\\n        int n=arr.size();\\n        int mx=INT_MIN;\\n        int i =0;\\n        while(i+2 <= n-1){\\n            mx = max(mx, arr[i+2]-arr[i]);\\n            i+= 2;\\n        }\\n\\n        //+1 skip / even len\\n        bool flag = false;\\n        if(i == n-2)\\n        {\\n            flag = true;\\n            mx = max(mx, arr[n-1]-arr[i]);\\n            i++;\\n        }\\n            \\n        //peeche se lena\\n        if(flag == true)\\n        {\\n            mx = max(mx, arr[i]-arr[i-2]);\\n            i-=2;\\n        }\\n        else    mx = max(mx, arr[i]-arr[--i]);\\n        \\n\\n        while(i>1)  \\n        {\\n            mx = max(mx, arr[i]-arr[i-2]);\\n            i -= 2;\\n        }\\n        //i=1;\\n\\n        mx = max(mx, arr[i]-arr[--i]);\\n         \\n       \\n      // cout<<mx;\\n    return mx<=mid;\\n    }\\n    int maxJump(vector<int>& arr) {\\n        int n=arr.size();\\n        int low=arr[1]-arr[0];\\n        int high=arr[n-1]-arr[0];\\n        int ans=-1;\\n        map<int,int>mp;\\n\\n        if( n==2){\\n            return arr[1]-arr[0];\\n        }\\n        while(low<=high){\\n            int mid=low+(high-low)/2;\\n            if(isPossible(mid,arr)){\\n                ans=mid;\\n                high=mid-1;\\n              \\n            }\\n            else{\\n                 \\n                low=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossible(int mid,vector<int>&arr){\\n        map<int,int>mp;\\n        int n=arr.size();\\n        int mx=INT_MIN;\\n        int i =0;\\n        while(i+2 <= n-1){\\n            mx = max(mx, arr[i+2]-arr[i]);\\n            i+= 2;\\n        }\\n\\n        //+1 skip / even len\\n        bool flag = false;\\n        if(i == n-2)\\n        {\\n            flag = true;\\n            mx = max(mx, arr[n-1]-arr[i]);\\n            i++;\\n        }\\n            \\n        //peeche se lena\\n        if(flag == true)\\n        {\\n            mx = max(mx, arr[i]-arr[i-2]);\\n            i-=2;\\n        }\\n        else    mx = max(mx, arr[i]-arr[--i]);\\n        \\n\\n        while(i>1)  \\n        {\\n            mx = max(mx, arr[i]-arr[i-2]);\\n            i -= 2;\\n        }\\n        //i=1;\\n\\n        mx = max(mx, arr[i]-arr[--i]);\\n         \\n       \\n      // cout<<mx;\\n    return mx<=mid;\\n    }\\n    int maxJump(vector<int>& arr) {\\n        int n=arr.size();\\n        int low=arr[1]-arr[0];\\n        int high=arr[n-1]-arr[0];\\n        int ans=-1;\\n        map<int,int>mp;\\n\\n        if( n==2){\\n            return arr[1]-arr[0];\\n        }\\n        while(low<=high){\\n            int mid=low+(high-low)/2;\\n            if(isPossible(mid,arr)){\\n                ans=mid;\\n                high=mid-1;\\n              \\n            }\\n            else{\\n                 \\n                low=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3276897,
                "title": "greedy",
                "content": "\\n```\\nclass Solution {\\n    func maxJump(_ stones: [Int]) -> Int {\\n       \\n        var res = stones[1] - stones[0]\\n        for i in 2..<stones.count {\\n            res = max(res, stones[i] - stones[i-2]) \\n        }\\n        return res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    func maxJump(_ stones: [Int]) -> Int {\\n       \\n        var res = stones[1] - stones[0]\\n        for i in 2..<stones.count {\\n            res = max(res, stones[i] - stones[i-2]) \\n        }\\n        return res\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3271801,
                "title": "simple-c-soln",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxJump(vector<int>& stones) {\\n        int n=stones.size();\\n        vector<int>dp(n,-1);\\n        dp[0]=0;\\n        dp[1]=stones[1]-stones[0];\\n        if(n==2){\\n            return dp[1];\\n        }\\n        for(int i=2;i<stones.size();i++){\\n            dp[i]=max(dp[i-1],stones[i]-stones[i-2]);\\n        }return dp[n-1];\\n    }\\n};\\n```\\n**Please, UPVOTE**",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxJump(vector<int>& stones) {\\n        int n=stones.size();\\n        vector<int>dp(n,-1);\\n        dp[0]=0;\\n        dp[1]=stones[1]-stones[0];\\n        if(n==2){\\n            return dp[1];\\n        }\\n        for(int i=2;i<stones.size();i++){\\n            dp[i]=max(dp[i-1],stones[i]-stones[i-2]);\\n        }return dp[n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3271022,
                "title": "simple-solution-first-time-post",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxJump(self, stones: List[int]) -> int:\\n        new = 0\\n        if len(stones) == 1:\\n            return 0\\n        if len(stones) == 2:\\n            return stones[1] - stones[0]\\n        for i in range(0, len(stones) - 2, 2):\\n            if stones[i + 2] - stones[i] > new:\\n                new = stones[i + 2] - stones[i]\\n        for i in range(1, len(stones) - 2, 2):\\n            if stones[i + 2] - stones[i] > new:\\n                new = stones[i + 2] - stones[i]\\n        return new\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxJump(self, stones: List[int]) -> int:\\n        new = 0\\n        if len(stones) == 1:\\n            return 0\\n        if len(stones) == 2:\\n            return stones[1] - stones[0]\\n        for i in range(0, len(stones) - 2, 2):\\n            if stones[i + 2] - stones[i] > new:\\n                new = stones[i + 2] - stones[i]\\n        for i in range(1, len(stones) - 2, 2):\\n            if stones[i + 2] - stones[i] > new:\\n                new = stones[i + 2] - stones[i]\\n        return new\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3270601,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxJump(vector<int>& a) {\\n        if(a.size()==2)\\n            return a[1]-a[0];\\n        int ans=0;\\n        for(int i=2;i<a.size();i++)\\n            ans=max(ans,a[i]-a[i-2]);\\n        ans=max(ans,a[a.size()-1]-a[a.size()-2]);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxJump(vector<int>& a) {\\n        if(a.size()==2)\\n            return a[1]-a[0];\\n        int ans=0;\\n        for(int i=2;i<a.size();i++)\\n            ans=max(ans,a[i]-a[i-2]);\\n        ans=max(ans,a[a.size()-1]-a[a.size()-2]);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3264102,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxJump(int[] stones) {\\n        \\n        int res = stones[1] - stones[0], n = stones.length;\\n        for(int i = 2; i < n; ++i)\\n            res = Math.max(res, stones[i] - stones[i - 2]);\\n        return res;\\n    \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxJump(int[] stones) {\\n        \\n        int res = stones[1] - stones[0], n = stones.length;\\n        for(int i = 2; i < n; ++i)\\n            res = Math.max(res, stones[i] - stones[i - 2]);\\n        return res;\\n    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3251246,
                "title": "simple-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxJump(int[] stones) {\\n        int res = Integer.MIN_VALUE;\\n        if(stones.length > 2)\\n        {\\n    for(int i = 2; i < stones.length; i++) {\\n        int ans = stones[i] - stones[i - 1] + stones[i - 1] - stones[i - 2];\\n            res = Math.max(res, ans);\\n        \\n    }\\n        }\\n        else\\n        {\\n            res = stones[1]-stones[0];\\n        }\\n    return res;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxJump(int[] stones) {\\n        int res = Integer.MIN_VALUE;\\n        if(stones.length > 2)\\n        {\\n    for(int i = 2; i < stones.length; i++) {\\n        int ans = stones[i] - stones[i - 1] + stones[i - 1] - stones[i - 2];\\n            res = Math.max(res, ans);\\n        \\n    }\\n        }\\n        else\\n        {\\n            res = stones[1]-stones[0];\\n        }\\n    return res;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3242456,
                "title": "kotlin-solution-with-explanation",
                "content": "No matter how hard you try, the best approach will always be to skip the next gem and move on to the next gem after that (if that step is possible).\\n\\nAfter examining all possible options, you can see that the largest steps will always be the skipping of one stone between two stones, that is, length = 2.\\nThere may be other steps of length = 1, but there will always be another step of length 2 skipping the stone participating in the jump of length 1, so a jump of length 1 is not worth considering.\\n\\nThe time complexity of this function is O(n), where n is the size of the input array stones. This is because the function iterates over the input array once in the for loop, and performs a constant amount of work in each iteration. Therefore, the time it takes to run the function grows linearly with the size of the input.\\n\\nThe space complexity of this function is O(1), which means that it uses a constant amount of extra space to compute its output, regardless of the size of the input array. This is because the function does not create any additional data structures or arrays to compute its output, and only uses a fixed number of variables (count and i) to store its intermediate results.\\n\\n# Code\\n```\\nclass Solution {\\nfun maxJump(stones: IntArray): Int {\\n    var count = stones[1] - stones[0]\\n    for (i in 2 until stones.size) count = count.coerceAtLeast(stones[i] - stones[i - 2])\\n    return count\\n}\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\nfun maxJump(stones: IntArray): Int {\\n    var count = stones[1] - stones[0]\\n    for (i in 2 until stones.size) count = count.coerceAtLeast(stones[i] - stones[i - 2])\\n    return count\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3232194,
                "title": "simple-c-solution",
                "content": "# Intuition\\nLeetCode Hint - *Skipping just one stone in every forward jump and jumping to those skipped stones in backward jump can minimize the maximum jump.*\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution \\n{\\npublic:\\n    int maxJump(vector<int>& stones) \\n    {\\n        int n=stones.size();\\n        if(n==2) return stones[1]-stones[0];\\n        int prev=0;\\n        int d=INT_MIN;\\n        int st=(n%2==0)?1:2;\\n        for(int x=st; x<n; x+=2)\\n        {\\n            int diff=stones[x]-stones[prev];\\n            d=max(d,diff);\\n            prev=x;\\n        }\\n        for(int x=n-2; x>=0; x-=2)\\n        {\\n            int diff=stones[prev]-stones[x];\\n            d=max(d,diff);\\n            prev=x;\\n        }\\n        return d;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int maxJump(vector<int>& stones) \\n    {\\n        int n=stones.size();\\n        if(n==2) return stones[1]-stones[0];\\n        int prev=0;\\n        int d=INT_MIN;\\n        int st=(n%2==0)?1:2;\\n        for(int x=st; x<n; x+=2)\\n        {\\n            int diff=stones[x]-stones[prev];\\n            d=max(d,diff);\\n            prev=x;\\n        }\\n        for(int x=n-2; x>=0; x-=2)\\n        {\\n            int diff=stones[prev]-stones[x];\\n            d=max(d,diff);\\n            prev=x;\\n        }\\n        return d;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3231980,
                "title": "c-easy-fast",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxJump(vector<int>& stones) {\\n        int maxi=INT_MIN;\\n        int n=stones.size();\\n        vector<int> odd, even;\\n        if(n==2 || n==3)return stones[n-1]-stones[0];\\n       \\n        for(int i=0;i<n;i++){\\n            if(i%2==0)odd.push_back(stones[i]);\\n            else even.push_back(stones[i]);\\n        }\\n        if(odd.size()>=2){\\n            for(int i=1;i<odd.size();i++){\\n                maxi=max(maxi,odd[i]-odd[i-1]);\\n            }\\n        }\\n        if(even.size()>=2){\\n            for(int i=1;i<even.size();i++){\\n                maxi=max(maxi,even[i] - even[i-1]);\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxJump(vector<int>& stones) {\\n        int maxi=INT_MIN;\\n        int n=stones.size();\\n        vector<int> odd, even;\\n        if(n==2 || n==3)return stones[n-1]-stones[0];\\n       \\n        for(int i=0;i<n;i++){\\n            if(i%2==0)odd.push_back(stones[i]);\\n            else even.push_back(stones[i]);\\n        }\\n        if(odd.size()>=2){\\n            for(int i=1;i<odd.size();i++){\\n                maxi=max(maxi,odd[i]-odd[i-1]);\\n            }\\n        }\\n        if(even.size()>=2){\\n            for(int i=1;i<even.size();i++){\\n                maxi=max(maxi,even[i] - even[i-1]);\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3216389,
                "title": "greedy-solution",
                "content": "\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution:\\n    def maxJump(self, stones: List[int]) -> int:\\n        res = stones[1] - stones[0]\\n        for i in range(2, len(stones)):\\n            res = max(res, stones[i] - stones[i - 2])\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxJump(self, stones: List[int]) -> int:\\n        res = stones[1] - stones[0]\\n        for i in range(2, len(stones)):\\n            res = max(res, stones[i] - stones[i - 2])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3212947,
                "title": "java-solution-not-optimal-but-it-works",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int maxJump(int[] stones) {\\n        if(stones.length == 2){\\n            return Math.max(stones[0], stones[1]);\\n        }\\n\\n        int max = Integer.MIN_VALUE;\\n\\n        for(int i = 2; i < stones.length; i++){\\n            int a = Math.abs(stones[i] - stones[i - 2]);\\n            max = Math.max(max, a);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxJump(int[] stones) {\\n        if(stones.length == 2){\\n            return Math.max(stones[0], stones[1]);\\n        }\\n\\n        int max = Integer.MIN_VALUE;\\n\\n        for(int i = 2; i < stones.length; i++){\\n            int a = Math.abs(stones[i] - stones[i - 2]);\\n            max = Math.max(max, a);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3202404,
                "title": "most-easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxJump(int[] stones) {\\n        int ans=stones[1]-stones[0];\\n        int max=Integer.MIN_VALUE;\\n        for(int i=2;i<stones.length;i++)\\n        ans=Math.max(ans,stones[i]-stones[i-2]);\\n        return ans;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxJump(int[] stones) {\\n        int ans=stones[1]-stones[0];\\n        int max=Integer.MIN_VALUE;\\n        for(int i=2;i<stones.length;i++)\\n        ans=Math.max(ans,stones[i]-stones[i-2]);\\n        return ans;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3175529,
                "title": "c-golang-greedy",
                "content": "# Code\\n```\\n// C++\\nclass Solution {\\npublic:\\n    int maxJump(vector<int>& stones) {\\n        int ans = stones[1] - stones[0];\\n        for(int i = 2; i < stones.size(); i++) {\\n            ans = max(ans, stones[i] - stones[i - 2]);\\n        }\\n        return ans;\\n    }\\n};\\n\\n// Golang \\nfunc maxJump(stones []int) int {\\n    var ans int = stones[1] - stones[0]\\n    for i := 2; i < len(stones); i++ {\\n        if stones[i] - stones[i - 2] > ans {\\n            ans = stones[i] - stones[i - 2]\\n        }\\n    }\\n    return ans\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\n// C++\\nclass Solution {\\npublic:\\n    int maxJump(vector<int>& stones) {\\n        int ans = stones[1] - stones[0];\\n        for(int i = 2; i < stones.size(); i++) {\\n            ans = max(ans, stones[i] - stones[i - 2]);\\n        }\\n        return ans;\\n    }\\n};\\n\\n// Golang \\nfunc maxJump(stones []int) int {\\n    var ans int = stones[1] - stones[0]\\n    for i := 2; i < len(stones); i++ {\\n        if stones[i] - stones[i - 2] > ans {\\n            ans = stones[i] - stones[i - 2]\\n        }\\n    }\\n    return ans\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3137294,
                "title": "c-binary-search-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isPossibleJump(int maxJump, vector<int>& stones, unordered_map<int, int> &m, int n) {\\n        vector <int> vis(n, 0);\\n        int i = 0;\\n        while(i != n - 1) {\\n            auto it = lower_bound(stones.begin(), stones.end(), stones[i] + maxJump);\\n            if(it == stones.end()) it--;\\n            int ind = it - stones.begin();\\n            if(stones[ind] > stones[i] + maxJump) ind--; \\n            if(ind == i) return 0;\\n            i = ind;\\n            vis[i] = 1;\\n        }\\n        int prev = n - 1;\\n        i--;\\n        while(i >= 0) {\\n            if(vis[i]) {\\n                i--; continue;    \\n            }\\n            if(stones[prev] - stones[i] > maxJump) return 0;\\n            prev = i;\\n            i--;\\n        }\\n        return 1;\\n    } \\n    int maxJump(vector<int>& stones) {\\n        int n = stones.size();\\n        unordered_map <int, int> m;\\n        for(auto &it: stones) m[it]++;\\n        int l = 0, h = stones[n - 1] - stones[0];\\n        int ans = h;\\n        while(l <= h) {\\n            int mid = l + (h - l)/2;\\n            if(isPossibleJump(mid, stones, m, n)) {\\n                bool isPresent = 0;\\n                for(auto &it: stones) {\\n                    if(m.count(it + mid)) {\\n                        isPresent = 1;\\n                        break;\\n                    }\\n                }\\n                if(isPresent) ans = mid;\\n                h = mid - 1;\\n            } else {\\n                l = mid + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossibleJump(int maxJump, vector<int>& stones, unordered_map<int, int> &m, int n) {\\n        vector <int> vis(n, 0);\\n        int i = 0;\\n        while(i != n - 1) {\\n            auto it = lower_bound(stones.begin(), stones.end(), stones[i] + maxJump);\\n            if(it == stones.end()) it--;\\n            int ind = it - stones.begin();\\n            if(stones[ind] > stones[i] + maxJump) ind--; \\n            if(ind == i) return 0;\\n            i = ind;\\n            vis[i] = 1;\\n        }\\n        int prev = n - 1;\\n        i--;\\n        while(i >= 0) {\\n            if(vis[i]) {\\n                i--; continue;    \\n            }\\n            if(stones[prev] - stones[i] > maxJump) return 0;\\n            prev = i;\\n            i--;\\n        }\\n        return 1;\\n    } \\n    int maxJump(vector<int>& stones) {\\n        int n = stones.size();\\n        unordered_map <int, int> m;\\n        for(auto &it: stones) m[it]++;\\n        int l = 0, h = stones[n - 1] - stones[0];\\n        int ans = h;\\n        while(l <= h) {\\n            int mid = l + (h - l)/2;\\n            if(isPossibleJump(mid, stones, m, n)) {\\n                bool isPresent = 0;\\n                for(auto &it: stones) {\\n                    if(m.count(it + mid)) {\\n                        isPresent = 1;\\n                        break;\\n                    }\\n                }\\n                if(isPresent) ans = mid;\\n                h = mid - 1;\\n            } else {\\n                l = mid + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3093707,
                "title": "python-greedy-solution",
                "content": "```\\nclass Solution:\\n    def maxJump(self, stones: List[int]) -> int:\\n        if len(stones) <= 3:return stones[-1] - stones[0]\\n        right = stones[1] - stones[0]\\n        left = stones[2] - stones[0]\\n        res = max(right,left)\\n\\n        for i in range(3,len(stones)):\\n            if right < left:\\n                res = max(stones[i]-right,res)\\n                right = stones[i]\\n            else:\\n                res = max(stones[i]-left,res)\\n                left = stones[i]\\n\\n        return res   \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxJump(self, stones: List[int]) -> int:\\n        if len(stones) <= 3:return stones[-1] - stones[0]\\n        right = stones[1] - stones[0]\\n        left = stones[2] - stones[0]\\n        res = max(right,left)\\n\\n        for i in range(3,len(stones)):\\n            if right < left:\\n                res = max(stones[i]-right,res)\\n                right = stones[i]\\n            else:\\n                res = max(stones[i]-left,res)\\n                left = stones[i]\\n\\n        return res   \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3069949,
                "title": "simulate-2-frogs-o-n-o-1",
                "content": "# Intuition\\nThe question of whether one frog can jump to the end and back without jumping onto the same stone twice is the same as whether two frogs can jump to the end without using the same stone (except for the last one).\\n\\nTo minimize the longest jump these 2 frogs have to make, they can simply \"leap-frog\" (pun intended) over each other in turn, jumping to the first stone after the other frog\\'s current position. This might not minimize the total number of jumps, but will minimize the longest jump.\\n\\n# Approach\\nSimulate the 2 frogs jumping. Keep a running maximum jump size and update it each time a frog makes a jump that is longer than that.\\n1. Start by having one frog jump to stone `1`.\\n2. lterate with each frog jumping from `i` to `i+2`.\\n3. When one of the frogs has reached the last stone, the other frog has one more jump to make. Since the frog that is on the end jumped over the frog that is not at the end, we know that this last jump cannot be the longest jump and therefore we don\\'t have to simulate it.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$.\\nThere will be `n+1` total jumps, and we will simulate all bust the last jump.\\n\\n- Space complexity: $$O(1)$$\\nOne additional `int` will persist as we simulate, to keep track of the maximum.\\n\\n# Code\\n```\\nfunc maxJump(stones []int) int {\\n\\n    // The first frog jumps to stone 1.\\n    max := stones[1]\\n\\n    // At each iteration there will be a frog on i and a frog on i+1\\n    // The frog on i has to jump to i+2. Update the max if that is longer\\n    for i, curr := range stones[:len(stones)-2] {\\n        if jump := stones[i+2] - curr; max < jump {\\n            max = jump\\n        }\\n    }\\n\\n    return max\\n}\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc maxJump(stones []int) int {\\n\\n    // The first frog jumps to stone 1.\\n    max := stones[1]\\n\\n    // At each iteration there will be a frog on i and a frog on i+1\\n    // The frog on i has to jump to i+2. Update the max if that is longer\\n    for i, curr := range stones[:len(stones)-2] {\\n        if jump := stones[i+2] - curr; max < jump {\\n            max = jump\\n        }\\n    }\\n\\n    return max\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3063259,
                "title": "simple-super-fast-100",
                "content": "# Intuition\\nthink that if we miss one then how will it impact and if we don\\'t miss one how will it impact.\\nAfter thinking you will notice that you only need you skip one block and take another.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxJump(vector<int>& stones) {\\n        if(stones.size()==2){\\n            return stones[1]-stones[0];\\n        }\\n        int result=INT_MIN;\\n        for(int i=0;i<stones.size()-2;i+=2){\\n            result=max(result,stones[i+2]-stones[i]);\\n        }\\n        for(int i=1;i<stones.size()-2;i+=2){\\n            result=max(result,stones[i+2]-stones[i]);\\n        }\\n    return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxJump(vector<int>& stones) {\\n        if(stones.size()==2){\\n            return stones[1]-stones[0];\\n        }\\n        int result=INT_MIN;\\n        for(int i=0;i<stones.size()-2;i+=2){\\n            result=max(result,stones[i+2]-stones[i]);\\n        }\\n        for(int i=1;i<stones.size()-2;i+=2){\\n            result=max(result,stones[i+2]-stones[i]);\\n        }\\n    return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3051225,
                "title": "c-simple-easy",
                "content": "# Approach\\nif you didn\\'t use a stone in the first route it means you will use it in the second route SO it is prefered to take one stone in first route and to leave the next one for the second route.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxJump(vector<int>& stones) \\n    {\\n        int ans = 0, n = stones.size();\\n\\n        if(n == 2) \\n            return abs(stones[0] - stones[1]);\\n        \\n        for(int i = 0 ; i < n - 2 ; i += 2)\\n            ans = max(ans, abs(stones[i] - stones[i + 2]));\\n        \\n        for(int i = 1 ; i < n - 2 ; i += 2)\\n            ans = max(ans, abs(stones[i] - stones[i + 2]));\\n       \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxJump(vector<int>& stones) \\n    {\\n        int ans = 0, n = stones.size();\\n\\n        if(n == 2) \\n            return abs(stones[0] - stones[1]);\\n        \\n        for(int i = 0 ; i < n - 2 ; i += 2)\\n            ans = max(ans, abs(stones[i] - stones[i + 2]));\\n        \\n        for(int i = 1 ; i < n - 2 ; i += 2)\\n            ans = max(ans, abs(stones[i] - stones[i + 2]));\\n       \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3040507,
                "title": "python-greedy-jump-on-alternating-stones-even-odd",
                "content": "Time: O(N)\\nSpace: O(1)\\n```\\nclass Solution:\\n    def maxJump(self, stones: List[int]) -> int:\\n        size = len(stones)\\n        if size <= 3:\\n            return abs(stones[0] - stones[-1])\\n        \\n        answer = float(\"-inf\")\\n        is_even = (size % 2 == 0)\\n        \\n        #\\xA0Forward\\n        current_pos = 2\\n        while current_pos < size:\\n            answer = max(answer, abs(stones[current_pos - 2] - stones[current_pos]))\\n            current_pos += 2\\n            \\n        if is_even:\\n            answer = max(answer, abs(stones[-1] - stones[-2]))\\n            \\n        #\\xA0Backward\\n        current_pos = (size - 3) if (is_even) else (size - 2)\\n        answer = max(answer, abs(stones[current_pos] - stones[-1]))\\n        \\n        current_pos -= 2\\n        while current_pos >= 0:\\n            answer = max(answer, abs(stones[current_pos] - stones[current_pos + 2]))\\n            current_pos -= 2\\n        \\n        answer = max(answer, abs(stones[0] - stones[2]))        \\n        \\n        return answer\\n```",
                "solutionTags": [
                    "Python",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def maxJump(self, stones: List[int]) -> int:\\n        size = len(stones)\\n        if size <= 3:\\n            return abs(stones[0] - stones[-1])\\n        \\n        answer = float(\"-inf\")\\n        is_even = (size % 2 == 0)\\n        \\n        #\\xA0Forward\\n        current_pos = 2\\n        while current_pos < size:\\n            answer = max(answer, abs(stones[current_pos - 2] - stones[current_pos]))\\n            current_pos += 2\\n            \\n        if is_even:\\n            answer = max(answer, abs(stones[-1] - stones[-2]))\\n            \\n        #\\xA0Backward\\n        current_pos = (size - 3) if (is_even) else (size - 2)\\n        answer = max(answer, abs(stones[current_pos] - stones[-1]))\\n        \\n        current_pos -= 2\\n        while current_pos >= 0:\\n            answer = max(answer, abs(stones[current_pos] - stones[current_pos + 2]))\\n            current_pos -= 2\\n        \\n        answer = max(answer, abs(stones[0] - stones[2]))        \\n        \\n        return answer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3026931,
                "title": "java-fast-space-efficient-sol",
                "content": "\\n\\n# Approach\\nstrictly increasing-- so minimum path will be jump 2 stones \\nif you jump cosiqutive stones then in return time you have to jump 3 or more stones which will cost more;\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxJump(int[] stones) {\\n        if(stones.length<4)return stones[stones.length-1]-stones[0];\\n        int max1=0;\\n        int max2=0;\\n        for(int i=2;i<stones.length;i++){\\n            if(i%2==0){\\n                if(stones[i]-stones[i-2]>max1)max1=stones[i]-stones[i-2];\\n            }\\n            else{\\n                if(stones[i]-stones[i-2]>max2)max2=stones[i]-stones[i-2];\\n            }\\n\\n        }\\n        return Math.max(max1,max2);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxJump(int[] stones) {\\n        if(stones.length<4)return stones[stones.length-1]-stones[0];\\n        int max1=0;\\n        int max2=0;\\n        for(int i=2;i<stones.length;i++){\\n            if(i%2==0){\\n                if(stones[i]-stones[i-2]>max1)max1=stones[i]-stones[i-2];\\n            }\\n            else{\\n                if(stones[i]-stones[i-2]>max2)max2=stones[i]-stones[i-2];\\n            }\\n\\n        }\\n        return Math.max(max1,max2);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3020369,
                "title": "python3-one-liner",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def maxJump(self, stones: List[int]) -> int:\\n        return max(abs(stones[i] - stones[i+2]) for i in range(len(stones)-2)) if len(stones)>2 else stones[1]\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxJump(self, stones: List[int]) -> int:\\n        return max(abs(stones[i] - stones[i+2]) for i in range(len(stones)-2)) if len(stones)>2 else stones[1]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3015944,
                "title": "python-o-n-o-1-solution-4-lines-of-code",
                "content": "# Intuition\\nInitially I tried solving this using DP, but got TLE at cases with ca. 50 elements.\\n\\n# Approach\\nThe key is to spot that the answer is the max distance between any pair of stones with indexes n and n+2.  \\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxJump(self, stones: List[int]) -> int:\\n\\n        if len (stones) <3: return stones[-1]\\n        res = -inf\\n        for i in range(len(stones)-2): res = max(res,stones[i+2]-stones[i])\\n        return res\\n            \\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxJump(self, stones: List[int]) -> int:\\n\\n        if len (stones) <3: return stones[-1]\\n        res = -inf\\n        for i in range(len(stones)-2): res = max(res,stones[i+2]-stones[i])\\n        return res\\n            \\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3013805,
                "title": "c-greddy-approach-3-liner-logic-o-n-optimized-approach",
                "content": "Plzz UPVOTE \\u2B06\\uFE0F if you find my solution helpful.\\nIt really gives me the motivation to solve problems and post the best possible solutions for you guys, Your support means a lot.\\n\\uD83D\\uDE4F Thankyou \\uD83D\\uDE4F\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nJust Return the maximum difference between alternet stones.\\nrun the forloop upto n-2 //cover all stones.\\n\\nonly one edge case at n=2 ,\\nso initilize mx = stone[0]-stone[1] ;\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxJump(vector<int>& stones) {\\n        int n=stones.size();\\n        int mx=abs(stones[0]-stones[1]);//covers edge case n=2;\\n        for(int i=0;i<n-2;i++)\\n            {\\n                int diff=abs(stones[i]-stones[i+2]);\\n                mx=max(mx,diff);\\n            }\\n            return mx;\\n \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxJump(vector<int>& stones) {\\n        int n=stones.size();\\n        int mx=abs(stones[0]-stones[1]);//covers edge case n=2;\\n        for(int i=0;i<n-2;i++)\\n            {\\n                int diff=abs(stones[i]-stones[i+2]);\\n                mx=max(mx,diff);\\n            }\\n            return mx;\\n \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3013730,
                "title": "c-4-liner-logic-o-n-solution-100-faster",
                "content": "Plzz UPVOTE \\u2B06\\uFE0F if you find my solution helpful.\\nIt really gives me the motivation to solve problems and post the best possible solutions for you guys, Your support means a lot.\\n\\uD83D\\uDE4F Thankyou \\uD83D\\uDE4F\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nJust Return the maximum difference between alternet stones.\\nrun the forloop upto n-2 //cover all stones.\\n\\nonly one edge case at n=2 , \\nreturn stone[0]-stone[1] ;\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxJump(vector<int>& stones) {\\n        int mx=-1;\\n        int n=stones.size();\\n       if(n==2)\\n       return abs(stones[0]-stones[1]);\\n       \\n       else{\\n         for(int i=0;i<n-2;i++)\\n            {\\n                int diff=abs(stones[i]-stones[i+2]);\\n                mx=max(mx,diff);\\n            }\\n            return mx;\\n           }\\n   return{};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxJump(vector<int>& stones) {\\n        int mx=-1;\\n        int n=stones.size();\\n       if(n==2)\\n       return abs(stones[0]-stones[1]);\\n       \\n       else{\\n         for(int i=0;i<n-2;i++)\\n            {\\n                int diff=abs(stones[i]-stones[i+2]);\\n                mx=max(mx,diff);\\n            }\\n            return mx;\\n           }\\n   return{};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2991538,
                "title": "one-pass-o-n",
                "content": "# Intuition\\ncheck difference of consecutive elements\\n\\n# Approach\\ncheck difference of consecutive elements\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxJump(vector<int>& stones) {\\n        int m = 0;\\n        if(stones.size()==2) return stones[1] - stones[0];\\n        for(int i = 2;i < stones.size();i++)m = max(stones[i] - stones[i-2],m);\\n        return m;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxJump(vector<int>& stones) {\\n        int m = 0;\\n        if(stones.size()==2) return stones[1] - stones[0];\\n        for(int i = 2;i < stones.size();i++)m = max(stones[i] - stones[i-2],m);\\n        return m;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2972248,
                "title": "c-greedy-easy-solution",
                "content": "# Please UpVote if it helps you\\nApproch -> skip only 1 stone in every jump...\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxJump(vector<int>& stones) {\\n        if(stones.size()==2)return stones[1];\\n        int ans = INT_MIN,x = INT_MIN;\\n        for(int i=0;i<stones.size()-2;i += 2){\\n            x = max(x,stones[i+2]-stones[i]);\\n        }\\n        ans = x;\\n        x = INT_MIN;\\n        int f = 1,i = stones.size()-1;\\n        while(i>=2){\\n            if(f && stones.size()%2){\\n                x = max(x,stones[i]-stones[i-1]);\\n                i-=1;\\n                f=0;\\n                continue;\\n            }\\n            else{\\n                x = max(x,stones[i]-stones[i-2]);\\n                i -= 2;\\n            }\\n        }\\n        ans = max(ans,x);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxJump(vector<int>& stones) {\\n        if(stones.size()==2)return stones[1];\\n        int ans = INT_MIN,x = INT_MIN;\\n        for(int i=0;i<stones.size()-2;i += 2){\\n            x = max(x,stones[i+2]-stones[i]);\\n        }\\n        ans = x;\\n        x = INT_MIN;\\n        int f = 1,i = stones.size()-1;\\n        while(i>=2){\\n            if(f && stones.size()%2){\\n                x = max(x,stones[i]-stones[i-1]);\\n                i-=1;\\n                f=0;\\n                continue;\\n            }\\n            else{\\n                x = max(x,stones[i]-stones[i-2]);\\n                i -= 2;\\n            }\\n        }\\n        ans = max(ans,x);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2971965,
                "title": "go-solution",
                "content": "# Intuition\\nhttps://github.com/ganeshskudva/Leetcode-Golang\\n\\nInspired by [this](https://leetcode.com/problems/frog-jump-ii/solutions/2898316/python-always-make-the-longest-2-jump-explained-bonus-one-liner/?orderBy=most_votes) solution\\n\\n# Code\\n```\\nfunc max(a, b int) int {\\n\\tif a > b {\\n\\t\\treturn a\\n\\t}\\n\\n\\treturn b\\n}\\n\\nfunc maxJump(stones []int) int {\\n\\tres := stones[1] - stones[0]\\n\\tfor i := 2; i < len(stones); i++ {\\n\\t\\tres = max(res, stones[i] - stones[i - 2])\\n\\t}\\n\\t\\n\\treturn res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc max(a, b int) int {\\n\\tif a > b {\\n\\t\\treturn a\\n\\t}\\n\\n\\treturn b\\n}\\n\\nfunc maxJump(stones []int) int {\\n\\tres := stones[1] - stones[0]\\n\\tfor i := 2; i < len(stones); i++ {\\n\\t\\tres = max(res, stones[i] - stones[i - 2])\\n\\t}\\n\\t\\n\\treturn res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2969853,
                "title": "c-solution",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n  int maxJump(vector<int>& stones) \\n    {\\n        int n=stones.size();\\n        int ans=INT_MIN;\\n   for (int i=0;i+2<n;i+=2)\\n   {\\n       if (stones[i+2]-stones[i]>ans) \\n       {\\n         ans=max(ans,stones[i+2]-stones[i]);\\n       }\\n   }\\n   int i;\\n   if (n%2==0)\\n   i=n-1;\\n   else i=n-2;\\n   for ( i;i-2>=0;i-=2)\\n   {\\n       if (stones[i]-stones[i-2]>ans)\\n       {\\n           ans=max(ans,stones[i]-stones[i-2]);\\n       }\\n\\n   }\\n   if (n>=2)\\n   {\\n       if (stones[1]-stones[0]>ans) ans=stones[1]-stones[0];\\n       if (stones[n-1]-stones[n-2]>ans)  ans=stones[n-1]-stones[n-2];\\n   }\\n   return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  int maxJump(vector<int>& stones) \\n    {\\n        int n=stones.size();\\n        int ans=INT_MIN;\\n   for (int i=0;i+2<n;i+=2)\\n   {\\n       if (stones[i+2]-stones[i]>ans) \\n       {\\n         ans=max(ans,stones[i+2]-stones[i]);\\n       }\\n   }\\n   int i;\\n   if (n%2==0)\\n   i=n-1;\\n   else i=n-2;\\n   for ( i;i-2>=0;i-=2)\\n   {\\n       if (stones[i]-stones[i-2]>ans)\\n       {\\n           ans=max(ans,stones[i]-stones[i-2]);\\n       }\\n\\n   }\\n   if (n>=2)\\n   {\\n       if (stones[1]-stones[0]>ans) ans=stones[1]-stones[0];\\n       if (stones[n-1]-stones[n-2]>ans)  ans=stones[n-1]-stones[n-2];\\n   }\\n   return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2965177,
                "title": "python-4-lines-of-code-super-easy",
                "content": "\\n# Complexity\\n- Time complexity:\\n$$O(n)$$it\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def maxJump(self, stones: List[int]) -> int:\\n        ans, n = stones[1] - stones[0], len(stones)\\n        for i in range(2, n):\\n            ans = max(ans, stones[i] - stones[i-2])\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def maxJump(self, stones: List[int]) -> int:\\n        ans, n = stones[1] - stones[0], len(stones)\\n        for i in range(2, n):\\n            ans = max(ans, stones[i] - stones[i-2])\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2957860,
                "title": "c-greedy-o-n-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxJump(vector<int>& stones) {\\n        int ans=INT_MIN;\\n        bool flag=true;\\n        for(int i=1;i<stones.size()-1;i++){\\n            ans=max(ans, stones[i+1]-stones[i-1]);\\n            flag=false;\\n        }\\n        if(flag) ans=INT_MAX;\\n        ans=min(ans, stones[stones.size()-1]-stones[0]);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxJump(vector<int>& stones) {\\n        int ans=INT_MIN;\\n        bool flag=true;\\n        for(int i=1;i<stones.size()-1;i++){\\n            ans=max(ans, stones[i+1]-stones[i-1]);\\n            flag=false;\\n        }\\n        if(flag) ans=INT_MAX;\\n        ans=min(ans, stones[stones.size()-1]-stones[0]);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2952547,
                "title": "java-memoization-easy-to-understand-code-with-comments",
                "content": "```\\n/*\\nexplanation: frog jump using dynamic programming/greedy! the algorithm works by first selecting a stone and finding max jumps in both forward/backward if the frog uses next stone for forward/backward jumping, ie let us assume frog is on nth stone, then it will try jumping on nth stone in forward direction and calculate parameters, also if frog skips this stone then it means the frog will use it in backward directions, hence calculating some more parameters, we do this for each stone, memoize the best path and finally return the answer!\\n\\ntestcase: [0,2,5,6,7] -> Works\\n\\nTime & Space Complexity: O(n) & O(n): Time and space complexity of this program is linear, because the algorithm uses memoization to retrieve previous best jump from next node (which when calculated, automatically have next node result stored), therefore time complexity is linear, also space complexity of this program is linear due to storage required by dp array!\\n*/\\nclass Solution {\\n    int[] stones;\\n    \\n    class J {\\n        int fmx;\\n        int bmx;\\n        int fp;\\n        int bp;\\n        \\n        J(int fm, int bm, int f, int b){\\n            fmx = fm;\\n            bmx = bm;\\n            fp = f;\\n            bp = b;\\n        }\\n        \\n        @Override\\n        public String toString(){\\n            return String.format(\"{f: %d, b: %d, fp:%d, bp:%d}\", fmx, bmx, fp, bp);\\n        }\\n    }\\n    \\n    J[] dp;\\n    J dyjump(int n){\\n        if(n == stones.length-2){\\n            // Last 2nd, create returning loop!\\n            int sz = stones[n+1] - stones[n];\\n            return dp[n] = new J(sz, sz, sz, sz);\\n        }\\n        \\n        // Recursively choose this stone for forward/backward wrt to next stones!\\n        J next = dyjump(n+1);\\n        // System.out.println(\"at n=\"+stones[n]+\" JNext:\"+next);\\n        \\n        // Find distance between these two stones\\n        int distance = stones[n+1] - stones[n];\\n        \\n        // Find for forward!\\n        int ffm = Math.max(distance, next.fmx);\\n        int fbm = Math.max(next.bp+distance, next.bmx);\\n        int fc = Math.max(ffm, fbm);\\n        \\n        // If use next stone in forward jumping!\\n        int bfm = Math.max(next.fp+distance, next.fmx);\\n        int bbm = Math.max(distance, next.bmx);\\n        int bc = Math.max(bfm, bbm);\\n        \\n        if(fc <= bc){\\n            // Forward integration better! (ie jump forwardly to next node)\\n            return dp[n] = new J(ffm, fbm, distance, next.bp+distance);\\n        } else {\\n            // Backward integration (use next node for back jump!)\\n            return dp[n] = new J(bfm, bbm, next.fp+distance, distance);\\n        }\\n    }\\n    \\n    public int maxJump(int[] stones) {\\n        this.stones = stones;\\n        dp = new J[stones.length];\\n        \\n        J res = dyjump(0);        \\n        return Math.max(res.fmx, res.bmx);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\n/*\\nexplanation: frog jump using dynamic programming/greedy! the algorithm works by first selecting a stone and finding max jumps in both forward/backward if the frog uses next stone for forward/backward jumping, ie let us assume frog is on nth stone, then it will try jumping on nth stone in forward direction and calculate parameters, also if frog skips this stone then it means the frog will use it in backward directions, hence calculating some more parameters, we do this for each stone, memoize the best path and finally return the answer!\\n\\ntestcase: [0,2,5,6,7] -> Works\\n\\nTime & Space Complexity: O(n) & O(n): Time and space complexity of this program is linear, because the algorithm uses memoization to retrieve previous best jump from next node (which when calculated, automatically have next node result stored), therefore time complexity is linear, also space complexity of this program is linear due to storage required by dp array!\\n*/\\nclass Solution {\\n    int[] stones;\\n    \\n    class J {\\n        int fmx;\\n        int bmx;\\n        int fp;\\n        int bp;\\n        \\n        J(int fm, int bm, int f, int b){\\n            fmx = fm;\\n            bmx = bm;\\n            fp = f;\\n            bp = b;\\n        }\\n        \\n        @Override\\n        public String toString(){\\n            return String.format(\"{f: %d, b: %d, fp:%d, bp:%d}\", fmx, bmx, fp, bp);\\n        }\\n    }\\n    \\n    J[] dp;\\n    J dyjump(int n){\\n        if(n == stones.length-2){\\n            // Last 2nd, create returning loop!\\n            int sz = stones[n+1] - stones[n];\\n            return dp[n] = new J(sz, sz, sz, sz);\\n        }\\n        \\n        // Recursively choose this stone for forward/backward wrt to next stones!\\n        J next = dyjump(n+1);\\n        // System.out.println(\"at n=\"+stones[n]+\" JNext:\"+next);\\n        \\n        // Find distance between these two stones\\n        int distance = stones[n+1] - stones[n];\\n        \\n        // Find for forward!\\n        int ffm = Math.max(distance, next.fmx);\\n        int fbm = Math.max(next.bp+distance, next.bmx);\\n        int fc = Math.max(ffm, fbm);\\n        \\n        // If use next stone in forward jumping!\\n        int bfm = Math.max(next.fp+distance, next.fmx);\\n        int bbm = Math.max(distance, next.bmx);\\n        int bc = Math.max(bfm, bbm);\\n        \\n        if(fc <= bc){\\n            // Forward integration better! (ie jump forwardly to next node)\\n            return dp[n] = new J(ffm, fbm, distance, next.bp+distance);\\n        } else {\\n            // Backward integration (use next node for back jump!)\\n            return dp[n] = new J(bfm, bbm, next.fp+distance, distance);\\n        }\\n    }\\n    \\n    public int maxJump(int[] stones) {\\n        this.stones = stones;\\n        dp = new J[stones.length];\\n        \\n        J res = dyjump(0);        \\n        return Math.max(res.fmx, res.bmx);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2949350,
                "title": "java-javascript-c-solution",
                "content": "**Java**\\n```\\npublic class Solution {\\n\\n    public int maxJump(int[] stones) {\\n        int minCost = stones[1];\\n        for (int i = 1; i < stones.length - 1; ++i) {\\n            minCost = Math.max(minCost, stones[i + 1] - stones[i - 1]);\\n        }\\n        return minCost;\\n    }\\n}\\n```\\n**JavaScript**\\n```\\n/**\\n * @param {number[]} stones\\n * @return {number}\\n */\\nvar maxJump = function (stones) {\\n    let minCost = stones[1];\\n    for (let i = 1; i < stones.length - 1; ++i) {\\n        minCost = Math.max(minCost, stones[i + 1] - stones[i - 1]);\\n    }\\n    return minCost;\\n};\\n```\\n**C++**\\n```\\n#include <vector>\\n#include <algorithm>\\nusing namespace std;\\n\\nclass Solution {\\n    \\npublic:\\n    //C++20: int maxJump(span<const int> stones) const ...\\n    int maxJump(const vector<int>& stones) const {\\n        int minCost = stones[1];\\n        for (size_t i = 1; i < stones.size() - 1; ++i) {\\n            minCost = max(minCost, stones[i + 1] - stones[i - 1]);\\n        }\\n        return minCost;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\npublic class Solution {\\n\\n    public int maxJump(int[] stones) {\\n        int minCost = stones[1];\\n        for (int i = 1; i < stones.length - 1; ++i) {\\n            minCost = Math.max(minCost, stones[i + 1] - stones[i - 1]);\\n        }\\n        return minCost;\\n    }\\n}\\n```\n```\\n/**\\n * @param {number[]} stones\\n * @return {number}\\n */\\nvar maxJump = function (stones) {\\n    let minCost = stones[1];\\n    for (let i = 1; i < stones.length - 1; ++i) {\\n        minCost = Math.max(minCost, stones[i + 1] - stones[i - 1]);\\n    }\\n    return minCost;\\n};\\n```\n```\\n#include <vector>\\n#include <algorithm>\\nusing namespace std;\\n\\nclass Solution {\\n    \\npublic:\\n    //C++20: int maxJump(span<const int> stones) const ...\\n    int maxJump(const vector<int>& stones) const {\\n        int minCost = stones[1];\\n        for (size_t i = 1; i < stones.size() - 1; ++i) {\\n            minCost = max(minCost, stones[i + 1] - stones[i - 1]);\\n        }\\n        return minCost;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2944306,
                "title": "dp-solution-in-o-n-in-c",
                "content": "# Intuition\\nDP soluton using 2 simple forward anb backward array\\n\\n# Approach\\ncreated Two array store value which are in odd position in forward arry and even position values  in backward array and at the end getting max length value of both tha array and return that;\\n# Complexity\\n- Time complexity:\\nO(2n) = O(N)\\n- Space complexity:\\nO(2N);\\n# Code\\n```\\n#define pb push_back\\n#define ff forward \\n#define bb backward\\nclass Solution {\\npublic:\\nint maxJumpValue(vector<int> &a){\\n    int n=(int)a.size();\\n    int ans=0;\\n    for(int i=1;i<n;i++){\\n        ans= max(ans, a[i]-a[i-1]);\\n    }\\n    return ans;\\n}\\n    int maxJump(vector<int>& stones) {\\n        int n=stones.size();\\n        if(n==2) return stones[1]- stones[0];\\n        vector<int> ff, bb;\\n        ff.pb(stones[0]);\\n        bb.pb(stones[0]);\\n        for(int i=1;i<n-1;i++){\\n            if(i%2){\\n                ff.pb(stones[i]);\\n            }\\n            else{\\n                bb.pb(stones[i]);\\n            }\\n        }\\n        ff.pb(stones[n-1]);\\n        bb.pb(stones[n-1]);\\n\\n        return max(maxJumpValue(ff), maxJumpValue(bb));\\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define pb push_back\\n#define ff forward \\n#define bb backward\\nclass Solution {\\npublic:\\nint maxJumpValue(vector<int> &a){\\n    int n=(int)a.size();\\n    int ans=0;\\n    for(int i=1;i<n;i++){\\n        ans= max(ans, a[i]-a[i-1]);\\n    }\\n    return ans;\\n}\\n    int maxJump(vector<int>& stones) {\\n        int n=stones.size();\\n        if(n==2) return stones[1]- stones[0];\\n        vector<int> ff, bb;\\n        ff.pb(stones[0]);\\n        bb.pb(stones[0]);\\n        for(int i=1;i<n-1;i++){\\n            if(i%2){\\n                ff.pb(stones[i]);\\n            }\\n            else{\\n                bb.pb(stones[i]);\\n            }\\n        }\\n        ff.pb(stones[n-1]);\\n        bb.pb(stones[n-1]);\\n\\n        return max(maxJumpValue(ff), maxJumpValue(bb));\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2943159,
                "title": "simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxJump(vector<int>& stones) {\\n        int n = stones.size();\\n         int ans = stones[1] - stones[0];\\n        //storing difference of first and second stone\\n        for (int i = 2; i <n; i++)//start from 2nd stone\\n            ans = max(ans, stones[i] - stones[i - 2]);\\n                //find max of ans\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxJump(vector<int>& stones) {\\n        int n = stones.size();\\n         int ans = stones[1] - stones[0];\\n        //storing difference of first and second stone\\n        for (int i = 2; i <n; i++)//start from 2nd stone\\n            ans = max(ans, stones[i] - stones[i - 2]);\\n                //find max of ans\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2927875,
                "title": "java-solution-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nwe store each jump made in order to reach the last stone in a list...later we find the maximum element in the list which is the maximum jump/ answer required\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxJump(int[] stones) {\\n        int [] dp = new int[stones.length+1];\\n         ArrayList<Integer> list = new ArrayList<>();\\n        Arrays.fill(dp, -1);\\n        int max = Integer.MIN_VALUE;\\n         helper(stones.length-1, stones, dp, list);\\n         for(int val : list){\\n             if(val > max) max = val;\\n         }\\n         return max;\\n        \\n    }\\n    public int helper(int index, int [] stones, int [] dp, ArrayList<Integer> list){\\n        if(index == 0) return 0;\\n        if(dp[index] != -1) return dp[index];\\n        list.add(Math.abs(stones[index] - stones[index-1]));\\n        int left = helper(index-1, stones, dp, list) + Math.abs(stones[index] - stones[index-1]);\\n       \\n        int right = Integer.MAX_VALUE;\\n        if(index > 1){\\n            list.add(Math.abs(stones[index] - stones[index-2]));\\n             right = helper(index-2, stones, dp, list) + Math.abs(stones[index] - stones[index-2]);\\n            \\n        }\\n        return dp[index] =  Math.min(left, right);\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxJump(int[] stones) {\\n        int [] dp = new int[stones.length+1];\\n         ArrayList<Integer> list = new ArrayList<>();\\n        Arrays.fill(dp, -1);\\n        int max = Integer.MIN_VALUE;\\n         helper(stones.length-1, stones, dp, list);\\n         for(int val : list){\\n             if(val > max) max = val;\\n         }\\n         return max;\\n        \\n    }\\n    public int helper(int index, int [] stones, int [] dp, ArrayList<Integer> list){\\n        if(index == 0) return 0;\\n        if(dp[index] != -1) return dp[index];\\n        list.add(Math.abs(stones[index] - stones[index-1]));\\n        int left = helper(index-1, stones, dp, list) + Math.abs(stones[index] - stones[index-1]);\\n       \\n        int right = Integer.MAX_VALUE;\\n        if(index > 1){\\n            list.add(Math.abs(stones[index] - stones[index-2]));\\n             right = helper(index-2, stones, dp, list) + Math.abs(stones[index] - stones[index-2]);\\n            \\n        }\\n        return dp[index] =  Math.min(left, right);\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2924000,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn max_jump(stones: Vec<i32>) -> i32 {\\n        let mut ans = 0;\\n        let len = stones.len();\\n        let mut odd = 1;\\n        let mut even = 0;\\n        while odd < len {\\n            ans = ans.max(stones[(odd + 2).min(len - 1)] - stones[odd]);\\n            ans = ans.max(stones[(even + 2).min(len - 1)] - stones[even]);\\n            odd += 2;\\n            even += 2;\\n        }\\n        ans\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn max_jump(stones: Vec<i32>) -> i32 {\\n        let mut ans = 0;\\n        let len = stones.len();\\n        let mut odd = 1;\\n        let mut even = 0;\\n        while odd < len {\\n            ans = ans.max(stones[(odd + 2).min(len - 1)] - stones[odd]);\\n            ans = ans.max(stones[(even + 2).min(len - 1)] - stones[even]);\\n            odd += 2;\\n            even += 2;\\n        }\\n        ans\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2922190,
                "title": "python-simple-maths",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxJump(self, stones):\\n        n, odd_idx, even_idx, diff = len(stones), [], [], []\\n\\n        for i in range(n):\\n            if i%2 == 0:\\n                even_idx.append(stones[i])\\n            else:\\n                odd_idx.append(stones[i])\\n\\n        for i in range(1,len(even_idx)):\\n            diff.append(even_idx[i] - even_idx[i-1])\\n\\n        for i in range(1,len(odd_idx)):\\n            diff.append(odd_idx[i] - odd_idx[i-1])\\n\\n        diff.append(stones[-1] - stones[-2])\\n        diff.append(stones[1] - stones[0])\\n\\n        return max(diff)\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxJump(self, stones):\\n        n, odd_idx, even_idx, diff = len(stones), [], [], []\\n\\n        for i in range(n):\\n            if i%2 == 0:\\n                even_idx.append(stones[i])\\n            else:\\n                odd_idx.append(stones[i])\\n\\n        for i in range(1,len(even_idx)):\\n            diff.append(even_idx[i] - even_idx[i-1])\\n\\n        for i in range(1,len(odd_idx)):\\n            diff.append(odd_idx[i] - odd_idx[i-1])\\n\\n        diff.append(stones[-1] - stones[-2])\\n        diff.append(stones[1] - stones[0])\\n\\n        return max(diff)\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2921555,
                "title": "difference-between-i-and-i-2-o-n-c-soln",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe optimal path will be the one when the frog jumps to the second stone from the current stone skipping one and the skipped stones will be used up during the return journey.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFind the maximum difference between indices i and i-2.\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxJump(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n==2){\\n            return nums[1];\\n        }\\n        if(n==3){\\n            return nums[2];\\n        }\\n        int cost = INT_MIN;\\n        for(int i=2; i<n; i+=2){\\n            cost = max(cost, nums[i]-nums[i-2]);\\n        }\\n        for(int i=3; i<n; i+=2){\\n            cost = max(cost, nums[i]-nums[i-2]);\\n        }\\n        return cost;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxJump(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n==2){\\n            return nums[1];\\n        }\\n        if(n==3){\\n            return nums[2];\\n        }\\n        int cost = INT_MIN;\\n        for(int i=2; i<n; i+=2){\\n            cost = max(cost, nums[i]-nums[i-2]);\\n        }\\n        for(int i=3; i<n; i+=2){\\n            cost = max(cost, nums[i]-nums[i-2]);\\n        }\\n        return cost;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2919222,
                "title": "c-very-easy-4-line-code-greedy",
                "content": "class Solution {\\npublic:\\n\\n    int maxJump(vector<int>& stones) {\\n        \\n        int cost = stones[1]-stones[0];\\n\\n        for(int i=2; i<stones.size(); i++){\\n            \\n            cost = max(cost, stones[i]-stones[i-2]);\\n        }\\n        return cost;\\n    }\\n};\\n\\n# \\n# upvote",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int maxJump(vector<int>& stones) {\\n        \\n        int cost = stones[1]-stones[0];\\n\\n        for(int i=2; i<stones.size(); i++){\\n            \\n            cost = max(cost, stones[i]-stones[i-2]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2918748,
                "title": "python-super-easy-greedy-two-pass-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxJump(self, stones: List[int]) -> int:\\n        if len(stones) == 2:\\n            return abs(stones[1]- stones[0])\\n        stones = [[False, p] for p in stones ]\\n        i = 0 \\n        max_jump = 0\\n        prev = stones[0][1]\\n        while i < len(stones):\\n            max_jump = max(max_jump, abs(stones[i][1]-prev))\\n            prev = stones[i][1]\\n            stones[i][0] = True\\n            i+=2\\n        prev = 0\\n        i = 1\\n        while i < len(stones):\\n            if not stones[i][0]:\\n                  max_jump = max(max_jump, abs(stones[i][1]-prev))\\n                  prev = stones[i][1]\\n            i +=1\\n\\n        \\n        \\n        return max_jump\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxJump(self, stones: List[int]) -> int:\\n        if len(stones) == 2:\\n            return abs(stones[1]- stones[0])\\n        stones = [[False, p] for p in stones ]\\n        i = 0 \\n        max_jump = 0\\n        prev = stones[0][1]\\n        while i < len(stones):\\n            max_jump = max(max_jump, abs(stones[i][1]-prev))\\n            prev = stones[i][1]\\n            stones[i][0] = True\\n            i+=2\\n        prev = 0\\n        i = 1\\n        while i < len(stones):\\n            if not stones[i][0]:\\n                  max_jump = max(max_jump, abs(stones[i][1]-prev))\\n                  prev = stones[i][1]\\n            i +=1\\n\\n        \\n        \\n        return max_jump\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2918100,
                "title": "easy-javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach greedy\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} stones\\n * @return {number}\\n */\\nvar maxJump = function(stones) {\\n  let max=stones[1]\\n  let n=stones.length\\n    for(let i=0;i<stones.length-2;i++)\\n      {\\n        if(max<stones[i+2]-stones[i])\\n          {\\n            max=stones[i+2]-stones[i]\\n          }\\n      }\\n  return max\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Greedy"
                ],
                "code": "```\\n/**\\n * @param {number[]} stones\\n * @return {number}\\n */\\nvar maxJump = function(stones) {\\n  let max=stones[1]\\n  let n=stones.length\\n    for(let i=0;i<stones.length-2;i++)\\n      {\\n        if(max<stones[i+2]-stones[i])\\n          {\\n            max=stones[i+2]-stones[i]\\n          }\\n      }\\n  return max\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2918025,
                "title": "intuitive-cpp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxJump(vector<int>& stones) {\\n        int res = 0;\\n        int len = stones.size();\\n\\n        if (len == 0) return 0;\\n        if (len == 1) return stones[0];\\n        if (len == 2) return stones[1] - stones[0];\\n\\n        int curr = stones[0];\\n        for (int i = 2; i < len; i += 2) {\\n            res = max(stones[i] - stones[i - 2], res);\\n        }\\n        for (int i = 3; i < len; i += 2) {\\n            res = max(stones[i] - stones[i - 2], res);\\n        }\\n        return max(res, stones[len - 1] - stones[len - 2]);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxJump(vector<int>& stones) {\\n        int res = 0;\\n        int len = stones.size();\\n\\n        if (len == 0) return 0;\\n        if (len == 1) return stones[0];\\n        if (len == 2) return stones[1] - stones[0];\\n\\n        int curr = stones[0];\\n        for (int i = 2; i < len; i += 2) {\\n            res = max(stones[i] - stones[i - 2], res);\\n        }\\n        for (int i = 3; i < len; i += 2) {\\n            res = max(stones[i] - stones[i - 2], res);\\n        }\\n        return max(res, stones[len - 1] - stones[len - 2]);\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1712112,
                "content": [
                    {
                        "username": "snehil_vispute",
                        "content": "anyone who thought its a dp ques?? :/"
                    },
                    {
                        "username": "pierrewang",
                        "content": "The input size tells you that this question requires a O(n) or O(nlogn) solution, so it is clearly that we need a greedy algorithm."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Yeah same. But later I realized it was actually a pretty trivial problem. Here is my explanation with images.\\nhttps://leetcode.com/problems/frog-jump-ii/solutions/2898129/decently-explained-python3-code-o-n-w-image/?orderBy=most_votes"
                    },
                    {
                        "username": "shekomaru",
                        "content": "Hey people, learn to read; here is to discuss solutions, not to post solutions; to post solutions there is the tab called \"Solutions\""
                    },
                    {
                        "username": "Memberberry",
                        "content": "The question is so wordy, what does this mean?\\n\\n `The cost of a path is the maximum length of a jump among all jumps in the path.\\n\\nReturn the minimum cost of a path for the frog.`\\n\\nFor the first example, my understanding is it should be 7 since its bigger than 5? cause one can just jump from first to last and back to first, like the second example. "
                    },
                    {
                        "username": "siddique_123",
                        "content": "I thought the same initially bro.\\n"
                    },
                    {
                        "username": "guyses",
                        "content": "in the second example input, wouldn\\'t the optimal solution be \\n\\nto go from a[0] to a[1] (length = 3), then, from a[1] to a[2] (length = 6), costG = maxOfAllTheLenghts() = 6\\n\\nand to come back we just go from a[2] to a[0] (length = 9), costC = maxOfAllTheLengths() = 9\\n\\nans = min(costG, costC) = min(6, 9) = 6\\n\\nwhy is the answer 9? I am not able to get the pictorial explanation of this input either! Or am I interpreting the question wrongly?\\n"
                    },
                    {
                        "username": "Priyanka_LC07",
                        "content": "path---->from starting to end and then end to start(like in circle)\\nat most one jump------>for complete path frog can take at one or zero jump on each stone.\\nif frog jump on a[1], it want able to come back that\\'s why it can not jump on a[1]."
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "bring Snake \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "I was doing a dfs with visited : ("
                    },
                    {
                        "username": "v1k45__",
                        "content": "its too confusing by  example 2"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "i thought this is similar to cherry pickup\\nbut this is very hard to come up in interview\\n"
                    },
                    {
                        "username": "RISHIdev",
                        "content": "For the first example, my understanding is it should be 7 since its bigger than 5? cause one can just jump from first to last and back to first, like the second example. Can anyone explain."
                    },
                    {
                        "username": "locke_lost",
                        "content": "In the example 2, it just jump directly to then end and get back. But in the example 1, it does not. I am not sure what the point of this question is."
                    }
                ]
            },
            {
                "id": 1712263,
                "content": [
                    {
                        "username": "snehil_vispute",
                        "content": "anyone who thought its a dp ques?? :/"
                    },
                    {
                        "username": "pierrewang",
                        "content": "The input size tells you that this question requires a O(n) or O(nlogn) solution, so it is clearly that we need a greedy algorithm."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Yeah same. But later I realized it was actually a pretty trivial problem. Here is my explanation with images.\\nhttps://leetcode.com/problems/frog-jump-ii/solutions/2898129/decently-explained-python3-code-o-n-w-image/?orderBy=most_votes"
                    },
                    {
                        "username": "shekomaru",
                        "content": "Hey people, learn to read; here is to discuss solutions, not to post solutions; to post solutions there is the tab called \"Solutions\""
                    },
                    {
                        "username": "Memberberry",
                        "content": "The question is so wordy, what does this mean?\\n\\n `The cost of a path is the maximum length of a jump among all jumps in the path.\\n\\nReturn the minimum cost of a path for the frog.`\\n\\nFor the first example, my understanding is it should be 7 since its bigger than 5? cause one can just jump from first to last and back to first, like the second example. "
                    },
                    {
                        "username": "siddique_123",
                        "content": "I thought the same initially bro.\\n"
                    },
                    {
                        "username": "guyses",
                        "content": "in the second example input, wouldn\\'t the optimal solution be \\n\\nto go from a[0] to a[1] (length = 3), then, from a[1] to a[2] (length = 6), costG = maxOfAllTheLenghts() = 6\\n\\nand to come back we just go from a[2] to a[0] (length = 9), costC = maxOfAllTheLengths() = 9\\n\\nans = min(costG, costC) = min(6, 9) = 6\\n\\nwhy is the answer 9? I am not able to get the pictorial explanation of this input either! Or am I interpreting the question wrongly?\\n"
                    },
                    {
                        "username": "Priyanka_LC07",
                        "content": "path---->from starting to end and then end to start(like in circle)\\nat most one jump------>for complete path frog can take at one or zero jump on each stone.\\nif frog jump on a[1], it want able to come back that\\'s why it can not jump on a[1]."
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "bring Snake \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "I was doing a dfs with visited : ("
                    },
                    {
                        "username": "v1k45__",
                        "content": "its too confusing by  example 2"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "i thought this is similar to cherry pickup\\nbut this is very hard to come up in interview\\n"
                    },
                    {
                        "username": "RISHIdev",
                        "content": "For the first example, my understanding is it should be 7 since its bigger than 5? cause one can just jump from first to last and back to first, like the second example. Can anyone explain."
                    },
                    {
                        "username": "locke_lost",
                        "content": "In the example 2, it just jump directly to then end and get back. But in the example 1, it does not. I am not sure what the point of this question is."
                    }
                ]
            },
            {
                "id": 1792808,
                "content": [
                    {
                        "username": "snehil_vispute",
                        "content": "anyone who thought its a dp ques?? :/"
                    },
                    {
                        "username": "pierrewang",
                        "content": "The input size tells you that this question requires a O(n) or O(nlogn) solution, so it is clearly that we need a greedy algorithm."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Yeah same. But later I realized it was actually a pretty trivial problem. Here is my explanation with images.\\nhttps://leetcode.com/problems/frog-jump-ii/solutions/2898129/decently-explained-python3-code-o-n-w-image/?orderBy=most_votes"
                    },
                    {
                        "username": "shekomaru",
                        "content": "Hey people, learn to read; here is to discuss solutions, not to post solutions; to post solutions there is the tab called \"Solutions\""
                    },
                    {
                        "username": "Memberberry",
                        "content": "The question is so wordy, what does this mean?\\n\\n `The cost of a path is the maximum length of a jump among all jumps in the path.\\n\\nReturn the minimum cost of a path for the frog.`\\n\\nFor the first example, my understanding is it should be 7 since its bigger than 5? cause one can just jump from first to last and back to first, like the second example. "
                    },
                    {
                        "username": "siddique_123",
                        "content": "I thought the same initially bro.\\n"
                    },
                    {
                        "username": "guyses",
                        "content": "in the second example input, wouldn\\'t the optimal solution be \\n\\nto go from a[0] to a[1] (length = 3), then, from a[1] to a[2] (length = 6), costG = maxOfAllTheLenghts() = 6\\n\\nand to come back we just go from a[2] to a[0] (length = 9), costC = maxOfAllTheLengths() = 9\\n\\nans = min(costG, costC) = min(6, 9) = 6\\n\\nwhy is the answer 9? I am not able to get the pictorial explanation of this input either! Or am I interpreting the question wrongly?\\n"
                    },
                    {
                        "username": "Priyanka_LC07",
                        "content": "path---->from starting to end and then end to start(like in circle)\\nat most one jump------>for complete path frog can take at one or zero jump on each stone.\\nif frog jump on a[1], it want able to come back that\\'s why it can not jump on a[1]."
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "bring Snake \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "I was doing a dfs with visited : ("
                    },
                    {
                        "username": "v1k45__",
                        "content": "its too confusing by  example 2"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "i thought this is similar to cherry pickup\\nbut this is very hard to come up in interview\\n"
                    },
                    {
                        "username": "RISHIdev",
                        "content": "For the first example, my understanding is it should be 7 since its bigger than 5? cause one can just jump from first to last and back to first, like the second example. Can anyone explain."
                    },
                    {
                        "username": "locke_lost",
                        "content": "In the example 2, it just jump directly to then end and get back. But in the example 1, it does not. I am not sure what the point of this question is."
                    }
                ]
            },
            {
                "id": 1865217,
                "content": [
                    {
                        "username": "snehil_vispute",
                        "content": "anyone who thought its a dp ques?? :/"
                    },
                    {
                        "username": "pierrewang",
                        "content": "The input size tells you that this question requires a O(n) or O(nlogn) solution, so it is clearly that we need a greedy algorithm."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Yeah same. But later I realized it was actually a pretty trivial problem. Here is my explanation with images.\\nhttps://leetcode.com/problems/frog-jump-ii/solutions/2898129/decently-explained-python3-code-o-n-w-image/?orderBy=most_votes"
                    },
                    {
                        "username": "shekomaru",
                        "content": "Hey people, learn to read; here is to discuss solutions, not to post solutions; to post solutions there is the tab called \"Solutions\""
                    },
                    {
                        "username": "Memberberry",
                        "content": "The question is so wordy, what does this mean?\\n\\n `The cost of a path is the maximum length of a jump among all jumps in the path.\\n\\nReturn the minimum cost of a path for the frog.`\\n\\nFor the first example, my understanding is it should be 7 since its bigger than 5? cause one can just jump from first to last and back to first, like the second example. "
                    },
                    {
                        "username": "siddique_123",
                        "content": "I thought the same initially bro.\\n"
                    },
                    {
                        "username": "guyses",
                        "content": "in the second example input, wouldn\\'t the optimal solution be \\n\\nto go from a[0] to a[1] (length = 3), then, from a[1] to a[2] (length = 6), costG = maxOfAllTheLenghts() = 6\\n\\nand to come back we just go from a[2] to a[0] (length = 9), costC = maxOfAllTheLengths() = 9\\n\\nans = min(costG, costC) = min(6, 9) = 6\\n\\nwhy is the answer 9? I am not able to get the pictorial explanation of this input either! Or am I interpreting the question wrongly?\\n"
                    },
                    {
                        "username": "Priyanka_LC07",
                        "content": "path---->from starting to end and then end to start(like in circle)\\nat most one jump------>for complete path frog can take at one or zero jump on each stone.\\nif frog jump on a[1], it want able to come back that\\'s why it can not jump on a[1]."
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "bring Snake \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "I was doing a dfs with visited : ("
                    },
                    {
                        "username": "v1k45__",
                        "content": "its too confusing by  example 2"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "i thought this is similar to cherry pickup\\nbut this is very hard to come up in interview\\n"
                    },
                    {
                        "username": "RISHIdev",
                        "content": "For the first example, my understanding is it should be 7 since its bigger than 5? cause one can just jump from first to last and back to first, like the second example. Can anyone explain."
                    },
                    {
                        "username": "locke_lost",
                        "content": "In the example 2, it just jump directly to then end and get back. But in the example 1, it does not. I am not sure what the point of this question is."
                    }
                ]
            },
            {
                "id": 1725217,
                "content": [
                    {
                        "username": "snehil_vispute",
                        "content": "anyone who thought its a dp ques?? :/"
                    },
                    {
                        "username": "pierrewang",
                        "content": "The input size tells you that this question requires a O(n) or O(nlogn) solution, so it is clearly that we need a greedy algorithm."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Yeah same. But later I realized it was actually a pretty trivial problem. Here is my explanation with images.\\nhttps://leetcode.com/problems/frog-jump-ii/solutions/2898129/decently-explained-python3-code-o-n-w-image/?orderBy=most_votes"
                    },
                    {
                        "username": "shekomaru",
                        "content": "Hey people, learn to read; here is to discuss solutions, not to post solutions; to post solutions there is the tab called \"Solutions\""
                    },
                    {
                        "username": "Memberberry",
                        "content": "The question is so wordy, what does this mean?\\n\\n `The cost of a path is the maximum length of a jump among all jumps in the path.\\n\\nReturn the minimum cost of a path for the frog.`\\n\\nFor the first example, my understanding is it should be 7 since its bigger than 5? cause one can just jump from first to last and back to first, like the second example. "
                    },
                    {
                        "username": "siddique_123",
                        "content": "I thought the same initially bro.\\n"
                    },
                    {
                        "username": "guyses",
                        "content": "in the second example input, wouldn\\'t the optimal solution be \\n\\nto go from a[0] to a[1] (length = 3), then, from a[1] to a[2] (length = 6), costG = maxOfAllTheLenghts() = 6\\n\\nand to come back we just go from a[2] to a[0] (length = 9), costC = maxOfAllTheLengths() = 9\\n\\nans = min(costG, costC) = min(6, 9) = 6\\n\\nwhy is the answer 9? I am not able to get the pictorial explanation of this input either! Or am I interpreting the question wrongly?\\n"
                    },
                    {
                        "username": "Priyanka_LC07",
                        "content": "path---->from starting to end and then end to start(like in circle)\\nat most one jump------>for complete path frog can take at one or zero jump on each stone.\\nif frog jump on a[1], it want able to come back that\\'s why it can not jump on a[1]."
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "bring Snake \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "I was doing a dfs with visited : ("
                    },
                    {
                        "username": "v1k45__",
                        "content": "its too confusing by  example 2"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "i thought this is similar to cherry pickup\\nbut this is very hard to come up in interview\\n"
                    },
                    {
                        "username": "RISHIdev",
                        "content": "For the first example, my understanding is it should be 7 since its bigger than 5? cause one can just jump from first to last and back to first, like the second example. Can anyone explain."
                    },
                    {
                        "username": "locke_lost",
                        "content": "In the example 2, it just jump directly to then end and get back. But in the example 1, it does not. I am not sure what the point of this question is."
                    }
                ]
            },
            {
                "id": 1715824,
                "content": [
                    {
                        "username": "snehil_vispute",
                        "content": "anyone who thought its a dp ques?? :/"
                    },
                    {
                        "username": "pierrewang",
                        "content": "The input size tells you that this question requires a O(n) or O(nlogn) solution, so it is clearly that we need a greedy algorithm."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Yeah same. But later I realized it was actually a pretty trivial problem. Here is my explanation with images.\\nhttps://leetcode.com/problems/frog-jump-ii/solutions/2898129/decently-explained-python3-code-o-n-w-image/?orderBy=most_votes"
                    },
                    {
                        "username": "shekomaru",
                        "content": "Hey people, learn to read; here is to discuss solutions, not to post solutions; to post solutions there is the tab called \"Solutions\""
                    },
                    {
                        "username": "Memberberry",
                        "content": "The question is so wordy, what does this mean?\\n\\n `The cost of a path is the maximum length of a jump among all jumps in the path.\\n\\nReturn the minimum cost of a path for the frog.`\\n\\nFor the first example, my understanding is it should be 7 since its bigger than 5? cause one can just jump from first to last and back to first, like the second example. "
                    },
                    {
                        "username": "siddique_123",
                        "content": "I thought the same initially bro.\\n"
                    },
                    {
                        "username": "guyses",
                        "content": "in the second example input, wouldn\\'t the optimal solution be \\n\\nto go from a[0] to a[1] (length = 3), then, from a[1] to a[2] (length = 6), costG = maxOfAllTheLenghts() = 6\\n\\nand to come back we just go from a[2] to a[0] (length = 9), costC = maxOfAllTheLengths() = 9\\n\\nans = min(costG, costC) = min(6, 9) = 6\\n\\nwhy is the answer 9? I am not able to get the pictorial explanation of this input either! Or am I interpreting the question wrongly?\\n"
                    },
                    {
                        "username": "Priyanka_LC07",
                        "content": "path---->from starting to end and then end to start(like in circle)\\nat most one jump------>for complete path frog can take at one or zero jump on each stone.\\nif frog jump on a[1], it want able to come back that\\'s why it can not jump on a[1]."
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "bring Snake \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "I was doing a dfs with visited : ("
                    },
                    {
                        "username": "v1k45__",
                        "content": "its too confusing by  example 2"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "i thought this is similar to cherry pickup\\nbut this is very hard to come up in interview\\n"
                    },
                    {
                        "username": "RISHIdev",
                        "content": "For the first example, my understanding is it should be 7 since its bigger than 5? cause one can just jump from first to last and back to first, like the second example. Can anyone explain."
                    },
                    {
                        "username": "locke_lost",
                        "content": "In the example 2, it just jump directly to then end and get back. But in the example 1, it does not. I am not sure what the point of this question is."
                    }
                ]
            },
            {
                "id": 2060639,
                "content": [
                    {
                        "username": "snehil_vispute",
                        "content": "anyone who thought its a dp ques?? :/"
                    },
                    {
                        "username": "pierrewang",
                        "content": "The input size tells you that this question requires a O(n) or O(nlogn) solution, so it is clearly that we need a greedy algorithm."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Yeah same. But later I realized it was actually a pretty trivial problem. Here is my explanation with images.\\nhttps://leetcode.com/problems/frog-jump-ii/solutions/2898129/decently-explained-python3-code-o-n-w-image/?orderBy=most_votes"
                    },
                    {
                        "username": "shekomaru",
                        "content": "Hey people, learn to read; here is to discuss solutions, not to post solutions; to post solutions there is the tab called \"Solutions\""
                    },
                    {
                        "username": "Memberberry",
                        "content": "The question is so wordy, what does this mean?\\n\\n `The cost of a path is the maximum length of a jump among all jumps in the path.\\n\\nReturn the minimum cost of a path for the frog.`\\n\\nFor the first example, my understanding is it should be 7 since its bigger than 5? cause one can just jump from first to last and back to first, like the second example. "
                    },
                    {
                        "username": "siddique_123",
                        "content": "I thought the same initially bro.\\n"
                    },
                    {
                        "username": "guyses",
                        "content": "in the second example input, wouldn\\'t the optimal solution be \\n\\nto go from a[0] to a[1] (length = 3), then, from a[1] to a[2] (length = 6), costG = maxOfAllTheLenghts() = 6\\n\\nand to come back we just go from a[2] to a[0] (length = 9), costC = maxOfAllTheLengths() = 9\\n\\nans = min(costG, costC) = min(6, 9) = 6\\n\\nwhy is the answer 9? I am not able to get the pictorial explanation of this input either! Or am I interpreting the question wrongly?\\n"
                    },
                    {
                        "username": "Priyanka_LC07",
                        "content": "path---->from starting to end and then end to start(like in circle)\\nat most one jump------>for complete path frog can take at one or zero jump on each stone.\\nif frog jump on a[1], it want able to come back that\\'s why it can not jump on a[1]."
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "bring Snake \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "I was doing a dfs with visited : ("
                    },
                    {
                        "username": "v1k45__",
                        "content": "its too confusing by  example 2"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "i thought this is similar to cherry pickup\\nbut this is very hard to come up in interview\\n"
                    },
                    {
                        "username": "RISHIdev",
                        "content": "For the first example, my understanding is it should be 7 since its bigger than 5? cause one can just jump from first to last and back to first, like the second example. Can anyone explain."
                    },
                    {
                        "username": "locke_lost",
                        "content": "In the example 2, it just jump directly to then end and get back. But in the example 1, it does not. I am not sure what the point of this question is."
                    }
                ]
            },
            {
                "id": 2009178,
                "content": [
                    {
                        "username": "snehil_vispute",
                        "content": "anyone who thought its a dp ques?? :/"
                    },
                    {
                        "username": "pierrewang",
                        "content": "The input size tells you that this question requires a O(n) or O(nlogn) solution, so it is clearly that we need a greedy algorithm."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Yeah same. But later I realized it was actually a pretty trivial problem. Here is my explanation with images.\\nhttps://leetcode.com/problems/frog-jump-ii/solutions/2898129/decently-explained-python3-code-o-n-w-image/?orderBy=most_votes"
                    },
                    {
                        "username": "shekomaru",
                        "content": "Hey people, learn to read; here is to discuss solutions, not to post solutions; to post solutions there is the tab called \"Solutions\""
                    },
                    {
                        "username": "Memberberry",
                        "content": "The question is so wordy, what does this mean?\\n\\n `The cost of a path is the maximum length of a jump among all jumps in the path.\\n\\nReturn the minimum cost of a path for the frog.`\\n\\nFor the first example, my understanding is it should be 7 since its bigger than 5? cause one can just jump from first to last and back to first, like the second example. "
                    },
                    {
                        "username": "siddique_123",
                        "content": "I thought the same initially bro.\\n"
                    },
                    {
                        "username": "guyses",
                        "content": "in the second example input, wouldn\\'t the optimal solution be \\n\\nto go from a[0] to a[1] (length = 3), then, from a[1] to a[2] (length = 6), costG = maxOfAllTheLenghts() = 6\\n\\nand to come back we just go from a[2] to a[0] (length = 9), costC = maxOfAllTheLengths() = 9\\n\\nans = min(costG, costC) = min(6, 9) = 6\\n\\nwhy is the answer 9? I am not able to get the pictorial explanation of this input either! Or am I interpreting the question wrongly?\\n"
                    },
                    {
                        "username": "Priyanka_LC07",
                        "content": "path---->from starting to end and then end to start(like in circle)\\nat most one jump------>for complete path frog can take at one or zero jump on each stone.\\nif frog jump on a[1], it want able to come back that\\'s why it can not jump on a[1]."
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "bring Snake \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "I was doing a dfs with visited : ("
                    },
                    {
                        "username": "v1k45__",
                        "content": "its too confusing by  example 2"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "i thought this is similar to cherry pickup\\nbut this is very hard to come up in interview\\n"
                    },
                    {
                        "username": "RISHIdev",
                        "content": "For the first example, my understanding is it should be 7 since its bigger than 5? cause one can just jump from first to last and back to first, like the second example. Can anyone explain."
                    },
                    {
                        "username": "locke_lost",
                        "content": "In the example 2, it just jump directly to then end and get back. But in the example 1, it does not. I am not sure what the point of this question is."
                    }
                ]
            },
            {
                "id": 1978838,
                "content": [
                    {
                        "username": "snehil_vispute",
                        "content": "anyone who thought its a dp ques?? :/"
                    },
                    {
                        "username": "pierrewang",
                        "content": "The input size tells you that this question requires a O(n) or O(nlogn) solution, so it is clearly that we need a greedy algorithm."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Yeah same. But later I realized it was actually a pretty trivial problem. Here is my explanation with images.\\nhttps://leetcode.com/problems/frog-jump-ii/solutions/2898129/decently-explained-python3-code-o-n-w-image/?orderBy=most_votes"
                    },
                    {
                        "username": "shekomaru",
                        "content": "Hey people, learn to read; here is to discuss solutions, not to post solutions; to post solutions there is the tab called \"Solutions\""
                    },
                    {
                        "username": "Memberberry",
                        "content": "The question is so wordy, what does this mean?\\n\\n `The cost of a path is the maximum length of a jump among all jumps in the path.\\n\\nReturn the minimum cost of a path for the frog.`\\n\\nFor the first example, my understanding is it should be 7 since its bigger than 5? cause one can just jump from first to last and back to first, like the second example. "
                    },
                    {
                        "username": "siddique_123",
                        "content": "I thought the same initially bro.\\n"
                    },
                    {
                        "username": "guyses",
                        "content": "in the second example input, wouldn\\'t the optimal solution be \\n\\nto go from a[0] to a[1] (length = 3), then, from a[1] to a[2] (length = 6), costG = maxOfAllTheLenghts() = 6\\n\\nand to come back we just go from a[2] to a[0] (length = 9), costC = maxOfAllTheLengths() = 9\\n\\nans = min(costG, costC) = min(6, 9) = 6\\n\\nwhy is the answer 9? I am not able to get the pictorial explanation of this input either! Or am I interpreting the question wrongly?\\n"
                    },
                    {
                        "username": "Priyanka_LC07",
                        "content": "path---->from starting to end and then end to start(like in circle)\\nat most one jump------>for complete path frog can take at one or zero jump on each stone.\\nif frog jump on a[1], it want able to come back that\\'s why it can not jump on a[1]."
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "bring Snake \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "I was doing a dfs with visited : ("
                    },
                    {
                        "username": "v1k45__",
                        "content": "its too confusing by  example 2"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "i thought this is similar to cherry pickup\\nbut this is very hard to come up in interview\\n"
                    },
                    {
                        "username": "RISHIdev",
                        "content": "For the first example, my understanding is it should be 7 since its bigger than 5? cause one can just jump from first to last and back to first, like the second example. Can anyone explain."
                    },
                    {
                        "username": "locke_lost",
                        "content": "In the example 2, it just jump directly to then end and get back. But in the example 1, it does not. I am not sure what the point of this question is."
                    }
                ]
            },
            {
                "id": 1863369,
                "content": [
                    {
                        "username": "snehil_vispute",
                        "content": "anyone who thought its a dp ques?? :/"
                    },
                    {
                        "username": "pierrewang",
                        "content": "The input size tells you that this question requires a O(n) or O(nlogn) solution, so it is clearly that we need a greedy algorithm."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Yeah same. But later I realized it was actually a pretty trivial problem. Here is my explanation with images.\\nhttps://leetcode.com/problems/frog-jump-ii/solutions/2898129/decently-explained-python3-code-o-n-w-image/?orderBy=most_votes"
                    },
                    {
                        "username": "shekomaru",
                        "content": "Hey people, learn to read; here is to discuss solutions, not to post solutions; to post solutions there is the tab called \"Solutions\""
                    },
                    {
                        "username": "Memberberry",
                        "content": "The question is so wordy, what does this mean?\\n\\n `The cost of a path is the maximum length of a jump among all jumps in the path.\\n\\nReturn the minimum cost of a path for the frog.`\\n\\nFor the first example, my understanding is it should be 7 since its bigger than 5? cause one can just jump from first to last and back to first, like the second example. "
                    },
                    {
                        "username": "siddique_123",
                        "content": "I thought the same initially bro.\\n"
                    },
                    {
                        "username": "guyses",
                        "content": "in the second example input, wouldn\\'t the optimal solution be \\n\\nto go from a[0] to a[1] (length = 3), then, from a[1] to a[2] (length = 6), costG = maxOfAllTheLenghts() = 6\\n\\nand to come back we just go from a[2] to a[0] (length = 9), costC = maxOfAllTheLengths() = 9\\n\\nans = min(costG, costC) = min(6, 9) = 6\\n\\nwhy is the answer 9? I am not able to get the pictorial explanation of this input either! Or am I interpreting the question wrongly?\\n"
                    },
                    {
                        "username": "Priyanka_LC07",
                        "content": "path---->from starting to end and then end to start(like in circle)\\nat most one jump------>for complete path frog can take at one or zero jump on each stone.\\nif frog jump on a[1], it want able to come back that\\'s why it can not jump on a[1]."
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "bring Snake \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "I was doing a dfs with visited : ("
                    },
                    {
                        "username": "v1k45__",
                        "content": "its too confusing by  example 2"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "i thought this is similar to cherry pickup\\nbut this is very hard to come up in interview\\n"
                    },
                    {
                        "username": "RISHIdev",
                        "content": "For the first example, my understanding is it should be 7 since its bigger than 5? cause one can just jump from first to last and back to first, like the second example. Can anyone explain."
                    },
                    {
                        "username": "locke_lost",
                        "content": "In the example 2, it just jump directly to then end and get back. But in the example 1, it does not. I am not sure what the point of this question is."
                    }
                ]
            },
            {
                "id": 1712112,
                "content": [
                    {
                        "username": "snehil_vispute",
                        "content": "anyone who thought its a dp ques?? :/"
                    },
                    {
                        "username": "pierrewang",
                        "content": "The input size tells you that this question requires a O(n) or O(nlogn) solution, so it is clearly that we need a greedy algorithm."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Yeah same. But later I realized it was actually a pretty trivial problem. Here is my explanation with images.\\nhttps://leetcode.com/problems/frog-jump-ii/solutions/2898129/decently-explained-python3-code-o-n-w-image/?orderBy=most_votes"
                    },
                    {
                        "username": "shekomaru",
                        "content": "Hey people, learn to read; here is to discuss solutions, not to post solutions; to post solutions there is the tab called \"Solutions\""
                    },
                    {
                        "username": "Memberberry",
                        "content": "The question is so wordy, what does this mean?\\n\\n `The cost of a path is the maximum length of a jump among all jumps in the path.\\n\\nReturn the minimum cost of a path for the frog.`\\n\\nFor the first example, my understanding is it should be 7 since its bigger than 5? cause one can just jump from first to last and back to first, like the second example. "
                    },
                    {
                        "username": "siddique_123",
                        "content": "I thought the same initially bro.\\n"
                    },
                    {
                        "username": "guyses",
                        "content": "in the second example input, wouldn\\'t the optimal solution be \\n\\nto go from a[0] to a[1] (length = 3), then, from a[1] to a[2] (length = 6), costG = maxOfAllTheLenghts() = 6\\n\\nand to come back we just go from a[2] to a[0] (length = 9), costC = maxOfAllTheLengths() = 9\\n\\nans = min(costG, costC) = min(6, 9) = 6\\n\\nwhy is the answer 9? I am not able to get the pictorial explanation of this input either! Or am I interpreting the question wrongly?\\n"
                    },
                    {
                        "username": "Priyanka_LC07",
                        "content": "path---->from starting to end and then end to start(like in circle)\\nat most one jump------>for complete path frog can take at one or zero jump on each stone.\\nif frog jump on a[1], it want able to come back that\\'s why it can not jump on a[1]."
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "bring Snake \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "I was doing a dfs with visited : ("
                    },
                    {
                        "username": "v1k45__",
                        "content": "its too confusing by  example 2"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "i thought this is similar to cherry pickup\\nbut this is very hard to come up in interview\\n"
                    },
                    {
                        "username": "RISHIdev",
                        "content": "For the first example, my understanding is it should be 7 since its bigger than 5? cause one can just jump from first to last and back to first, like the second example. Can anyone explain."
                    },
                    {
                        "username": "locke_lost",
                        "content": "In the example 2, it just jump directly to then end and get back. But in the example 1, it does not. I am not sure what the point of this question is."
                    }
                ]
            },
            {
                "id": 1712263,
                "content": [
                    {
                        "username": "snehil_vispute",
                        "content": "anyone who thought its a dp ques?? :/"
                    },
                    {
                        "username": "pierrewang",
                        "content": "The input size tells you that this question requires a O(n) or O(nlogn) solution, so it is clearly that we need a greedy algorithm."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Yeah same. But later I realized it was actually a pretty trivial problem. Here is my explanation with images.\\nhttps://leetcode.com/problems/frog-jump-ii/solutions/2898129/decently-explained-python3-code-o-n-w-image/?orderBy=most_votes"
                    },
                    {
                        "username": "shekomaru",
                        "content": "Hey people, learn to read; here is to discuss solutions, not to post solutions; to post solutions there is the tab called \"Solutions\""
                    },
                    {
                        "username": "Memberberry",
                        "content": "The question is so wordy, what does this mean?\\n\\n `The cost of a path is the maximum length of a jump among all jumps in the path.\\n\\nReturn the minimum cost of a path for the frog.`\\n\\nFor the first example, my understanding is it should be 7 since its bigger than 5? cause one can just jump from first to last and back to first, like the second example. "
                    },
                    {
                        "username": "siddique_123",
                        "content": "I thought the same initially bro.\\n"
                    },
                    {
                        "username": "guyses",
                        "content": "in the second example input, wouldn\\'t the optimal solution be \\n\\nto go from a[0] to a[1] (length = 3), then, from a[1] to a[2] (length = 6), costG = maxOfAllTheLenghts() = 6\\n\\nand to come back we just go from a[2] to a[0] (length = 9), costC = maxOfAllTheLengths() = 9\\n\\nans = min(costG, costC) = min(6, 9) = 6\\n\\nwhy is the answer 9? I am not able to get the pictorial explanation of this input either! Or am I interpreting the question wrongly?\\n"
                    },
                    {
                        "username": "Priyanka_LC07",
                        "content": "path---->from starting to end and then end to start(like in circle)\\nat most one jump------>for complete path frog can take at one or zero jump on each stone.\\nif frog jump on a[1], it want able to come back that\\'s why it can not jump on a[1]."
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "bring Snake \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "I was doing a dfs with visited : ("
                    },
                    {
                        "username": "v1k45__",
                        "content": "its too confusing by  example 2"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "i thought this is similar to cherry pickup\\nbut this is very hard to come up in interview\\n"
                    },
                    {
                        "username": "RISHIdev",
                        "content": "For the first example, my understanding is it should be 7 since its bigger than 5? cause one can just jump from first to last and back to first, like the second example. Can anyone explain."
                    },
                    {
                        "username": "locke_lost",
                        "content": "In the example 2, it just jump directly to then end and get back. But in the example 1, it does not. I am not sure what the point of this question is."
                    }
                ]
            },
            {
                "id": 1792808,
                "content": [
                    {
                        "username": "snehil_vispute",
                        "content": "anyone who thought its a dp ques?? :/"
                    },
                    {
                        "username": "pierrewang",
                        "content": "The input size tells you that this question requires a O(n) or O(nlogn) solution, so it is clearly that we need a greedy algorithm."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Yeah same. But later I realized it was actually a pretty trivial problem. Here is my explanation with images.\\nhttps://leetcode.com/problems/frog-jump-ii/solutions/2898129/decently-explained-python3-code-o-n-w-image/?orderBy=most_votes"
                    },
                    {
                        "username": "shekomaru",
                        "content": "Hey people, learn to read; here is to discuss solutions, not to post solutions; to post solutions there is the tab called \"Solutions\""
                    },
                    {
                        "username": "Memberberry",
                        "content": "The question is so wordy, what does this mean?\\n\\n `The cost of a path is the maximum length of a jump among all jumps in the path.\\n\\nReturn the minimum cost of a path for the frog.`\\n\\nFor the first example, my understanding is it should be 7 since its bigger than 5? cause one can just jump from first to last and back to first, like the second example. "
                    },
                    {
                        "username": "siddique_123",
                        "content": "I thought the same initially bro.\\n"
                    },
                    {
                        "username": "guyses",
                        "content": "in the second example input, wouldn\\'t the optimal solution be \\n\\nto go from a[0] to a[1] (length = 3), then, from a[1] to a[2] (length = 6), costG = maxOfAllTheLenghts() = 6\\n\\nand to come back we just go from a[2] to a[0] (length = 9), costC = maxOfAllTheLengths() = 9\\n\\nans = min(costG, costC) = min(6, 9) = 6\\n\\nwhy is the answer 9? I am not able to get the pictorial explanation of this input either! Or am I interpreting the question wrongly?\\n"
                    },
                    {
                        "username": "Priyanka_LC07",
                        "content": "path---->from starting to end and then end to start(like in circle)\\nat most one jump------>for complete path frog can take at one or zero jump on each stone.\\nif frog jump on a[1], it want able to come back that\\'s why it can not jump on a[1]."
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "bring Snake \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "I was doing a dfs with visited : ("
                    },
                    {
                        "username": "v1k45__",
                        "content": "its too confusing by  example 2"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "i thought this is similar to cherry pickup\\nbut this is very hard to come up in interview\\n"
                    },
                    {
                        "username": "RISHIdev",
                        "content": "For the first example, my understanding is it should be 7 since its bigger than 5? cause one can just jump from first to last and back to first, like the second example. Can anyone explain."
                    },
                    {
                        "username": "locke_lost",
                        "content": "In the example 2, it just jump directly to then end and get back. But in the example 1, it does not. I am not sure what the point of this question is."
                    }
                ]
            },
            {
                "id": 1865217,
                "content": [
                    {
                        "username": "snehil_vispute",
                        "content": "anyone who thought its a dp ques?? :/"
                    },
                    {
                        "username": "pierrewang",
                        "content": "The input size tells you that this question requires a O(n) or O(nlogn) solution, so it is clearly that we need a greedy algorithm."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Yeah same. But later I realized it was actually a pretty trivial problem. Here is my explanation with images.\\nhttps://leetcode.com/problems/frog-jump-ii/solutions/2898129/decently-explained-python3-code-o-n-w-image/?orderBy=most_votes"
                    },
                    {
                        "username": "shekomaru",
                        "content": "Hey people, learn to read; here is to discuss solutions, not to post solutions; to post solutions there is the tab called \"Solutions\""
                    },
                    {
                        "username": "Memberberry",
                        "content": "The question is so wordy, what does this mean?\\n\\n `The cost of a path is the maximum length of a jump among all jumps in the path.\\n\\nReturn the minimum cost of a path for the frog.`\\n\\nFor the first example, my understanding is it should be 7 since its bigger than 5? cause one can just jump from first to last and back to first, like the second example. "
                    },
                    {
                        "username": "siddique_123",
                        "content": "I thought the same initially bro.\\n"
                    },
                    {
                        "username": "guyses",
                        "content": "in the second example input, wouldn\\'t the optimal solution be \\n\\nto go from a[0] to a[1] (length = 3), then, from a[1] to a[2] (length = 6), costG = maxOfAllTheLenghts() = 6\\n\\nand to come back we just go from a[2] to a[0] (length = 9), costC = maxOfAllTheLengths() = 9\\n\\nans = min(costG, costC) = min(6, 9) = 6\\n\\nwhy is the answer 9? I am not able to get the pictorial explanation of this input either! Or am I interpreting the question wrongly?\\n"
                    },
                    {
                        "username": "Priyanka_LC07",
                        "content": "path---->from starting to end and then end to start(like in circle)\\nat most one jump------>for complete path frog can take at one or zero jump on each stone.\\nif frog jump on a[1], it want able to come back that\\'s why it can not jump on a[1]."
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "bring Snake \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "I was doing a dfs with visited : ("
                    },
                    {
                        "username": "v1k45__",
                        "content": "its too confusing by  example 2"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "i thought this is similar to cherry pickup\\nbut this is very hard to come up in interview\\n"
                    },
                    {
                        "username": "RISHIdev",
                        "content": "For the first example, my understanding is it should be 7 since its bigger than 5? cause one can just jump from first to last and back to first, like the second example. Can anyone explain."
                    },
                    {
                        "username": "locke_lost",
                        "content": "In the example 2, it just jump directly to then end and get back. But in the example 1, it does not. I am not sure what the point of this question is."
                    }
                ]
            },
            {
                "id": 1725217,
                "content": [
                    {
                        "username": "snehil_vispute",
                        "content": "anyone who thought its a dp ques?? :/"
                    },
                    {
                        "username": "pierrewang",
                        "content": "The input size tells you that this question requires a O(n) or O(nlogn) solution, so it is clearly that we need a greedy algorithm."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Yeah same. But later I realized it was actually a pretty trivial problem. Here is my explanation with images.\\nhttps://leetcode.com/problems/frog-jump-ii/solutions/2898129/decently-explained-python3-code-o-n-w-image/?orderBy=most_votes"
                    },
                    {
                        "username": "shekomaru",
                        "content": "Hey people, learn to read; here is to discuss solutions, not to post solutions; to post solutions there is the tab called \"Solutions\""
                    },
                    {
                        "username": "Memberberry",
                        "content": "The question is so wordy, what does this mean?\\n\\n `The cost of a path is the maximum length of a jump among all jumps in the path.\\n\\nReturn the minimum cost of a path for the frog.`\\n\\nFor the first example, my understanding is it should be 7 since its bigger than 5? cause one can just jump from first to last and back to first, like the second example. "
                    },
                    {
                        "username": "siddique_123",
                        "content": "I thought the same initially bro.\\n"
                    },
                    {
                        "username": "guyses",
                        "content": "in the second example input, wouldn\\'t the optimal solution be \\n\\nto go from a[0] to a[1] (length = 3), then, from a[1] to a[2] (length = 6), costG = maxOfAllTheLenghts() = 6\\n\\nand to come back we just go from a[2] to a[0] (length = 9), costC = maxOfAllTheLengths() = 9\\n\\nans = min(costG, costC) = min(6, 9) = 6\\n\\nwhy is the answer 9? I am not able to get the pictorial explanation of this input either! Or am I interpreting the question wrongly?\\n"
                    },
                    {
                        "username": "Priyanka_LC07",
                        "content": "path---->from starting to end and then end to start(like in circle)\\nat most one jump------>for complete path frog can take at one or zero jump on each stone.\\nif frog jump on a[1], it want able to come back that\\'s why it can not jump on a[1]."
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "bring Snake \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "I was doing a dfs with visited : ("
                    },
                    {
                        "username": "v1k45__",
                        "content": "its too confusing by  example 2"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "i thought this is similar to cherry pickup\\nbut this is very hard to come up in interview\\n"
                    },
                    {
                        "username": "RISHIdev",
                        "content": "For the first example, my understanding is it should be 7 since its bigger than 5? cause one can just jump from first to last and back to first, like the second example. Can anyone explain."
                    },
                    {
                        "username": "locke_lost",
                        "content": "In the example 2, it just jump directly to then end and get back. But in the example 1, it does not. I am not sure what the point of this question is."
                    }
                ]
            },
            {
                "id": 1715824,
                "content": [
                    {
                        "username": "snehil_vispute",
                        "content": "anyone who thought its a dp ques?? :/"
                    },
                    {
                        "username": "pierrewang",
                        "content": "The input size tells you that this question requires a O(n) or O(nlogn) solution, so it is clearly that we need a greedy algorithm."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Yeah same. But later I realized it was actually a pretty trivial problem. Here is my explanation with images.\\nhttps://leetcode.com/problems/frog-jump-ii/solutions/2898129/decently-explained-python3-code-o-n-w-image/?orderBy=most_votes"
                    },
                    {
                        "username": "shekomaru",
                        "content": "Hey people, learn to read; here is to discuss solutions, not to post solutions; to post solutions there is the tab called \"Solutions\""
                    },
                    {
                        "username": "Memberberry",
                        "content": "The question is so wordy, what does this mean?\\n\\n `The cost of a path is the maximum length of a jump among all jumps in the path.\\n\\nReturn the minimum cost of a path for the frog.`\\n\\nFor the first example, my understanding is it should be 7 since its bigger than 5? cause one can just jump from first to last and back to first, like the second example. "
                    },
                    {
                        "username": "siddique_123",
                        "content": "I thought the same initially bro.\\n"
                    },
                    {
                        "username": "guyses",
                        "content": "in the second example input, wouldn\\'t the optimal solution be \\n\\nto go from a[0] to a[1] (length = 3), then, from a[1] to a[2] (length = 6), costG = maxOfAllTheLenghts() = 6\\n\\nand to come back we just go from a[2] to a[0] (length = 9), costC = maxOfAllTheLengths() = 9\\n\\nans = min(costG, costC) = min(6, 9) = 6\\n\\nwhy is the answer 9? I am not able to get the pictorial explanation of this input either! Or am I interpreting the question wrongly?\\n"
                    },
                    {
                        "username": "Priyanka_LC07",
                        "content": "path---->from starting to end and then end to start(like in circle)\\nat most one jump------>for complete path frog can take at one or zero jump on each stone.\\nif frog jump on a[1], it want able to come back that\\'s why it can not jump on a[1]."
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "bring Snake \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "I was doing a dfs with visited : ("
                    },
                    {
                        "username": "v1k45__",
                        "content": "its too confusing by  example 2"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "i thought this is similar to cherry pickup\\nbut this is very hard to come up in interview\\n"
                    },
                    {
                        "username": "RISHIdev",
                        "content": "For the first example, my understanding is it should be 7 since its bigger than 5? cause one can just jump from first to last and back to first, like the second example. Can anyone explain."
                    },
                    {
                        "username": "locke_lost",
                        "content": "In the example 2, it just jump directly to then end and get back. But in the example 1, it does not. I am not sure what the point of this question is."
                    }
                ]
            },
            {
                "id": 2060639,
                "content": [
                    {
                        "username": "snehil_vispute",
                        "content": "anyone who thought its a dp ques?? :/"
                    },
                    {
                        "username": "pierrewang",
                        "content": "The input size tells you that this question requires a O(n) or O(nlogn) solution, so it is clearly that we need a greedy algorithm."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Yeah same. But later I realized it was actually a pretty trivial problem. Here is my explanation with images.\\nhttps://leetcode.com/problems/frog-jump-ii/solutions/2898129/decently-explained-python3-code-o-n-w-image/?orderBy=most_votes"
                    },
                    {
                        "username": "shekomaru",
                        "content": "Hey people, learn to read; here is to discuss solutions, not to post solutions; to post solutions there is the tab called \"Solutions\""
                    },
                    {
                        "username": "Memberberry",
                        "content": "The question is so wordy, what does this mean?\\n\\n `The cost of a path is the maximum length of a jump among all jumps in the path.\\n\\nReturn the minimum cost of a path for the frog.`\\n\\nFor the first example, my understanding is it should be 7 since its bigger than 5? cause one can just jump from first to last and back to first, like the second example. "
                    },
                    {
                        "username": "siddique_123",
                        "content": "I thought the same initially bro.\\n"
                    },
                    {
                        "username": "guyses",
                        "content": "in the second example input, wouldn\\'t the optimal solution be \\n\\nto go from a[0] to a[1] (length = 3), then, from a[1] to a[2] (length = 6), costG = maxOfAllTheLenghts() = 6\\n\\nand to come back we just go from a[2] to a[0] (length = 9), costC = maxOfAllTheLengths() = 9\\n\\nans = min(costG, costC) = min(6, 9) = 6\\n\\nwhy is the answer 9? I am not able to get the pictorial explanation of this input either! Or am I interpreting the question wrongly?\\n"
                    },
                    {
                        "username": "Priyanka_LC07",
                        "content": "path---->from starting to end and then end to start(like in circle)\\nat most one jump------>for complete path frog can take at one or zero jump on each stone.\\nif frog jump on a[1], it want able to come back that\\'s why it can not jump on a[1]."
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "bring Snake \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "I was doing a dfs with visited : ("
                    },
                    {
                        "username": "v1k45__",
                        "content": "its too confusing by  example 2"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "i thought this is similar to cherry pickup\\nbut this is very hard to come up in interview\\n"
                    },
                    {
                        "username": "RISHIdev",
                        "content": "For the first example, my understanding is it should be 7 since its bigger than 5? cause one can just jump from first to last and back to first, like the second example. Can anyone explain."
                    },
                    {
                        "username": "locke_lost",
                        "content": "In the example 2, it just jump directly to then end and get back. But in the example 1, it does not. I am not sure what the point of this question is."
                    }
                ]
            },
            {
                "id": 2009178,
                "content": [
                    {
                        "username": "snehil_vispute",
                        "content": "anyone who thought its a dp ques?? :/"
                    },
                    {
                        "username": "pierrewang",
                        "content": "The input size tells you that this question requires a O(n) or O(nlogn) solution, so it is clearly that we need a greedy algorithm."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Yeah same. But later I realized it was actually a pretty trivial problem. Here is my explanation with images.\\nhttps://leetcode.com/problems/frog-jump-ii/solutions/2898129/decently-explained-python3-code-o-n-w-image/?orderBy=most_votes"
                    },
                    {
                        "username": "shekomaru",
                        "content": "Hey people, learn to read; here is to discuss solutions, not to post solutions; to post solutions there is the tab called \"Solutions\""
                    },
                    {
                        "username": "Memberberry",
                        "content": "The question is so wordy, what does this mean?\\n\\n `The cost of a path is the maximum length of a jump among all jumps in the path.\\n\\nReturn the minimum cost of a path for the frog.`\\n\\nFor the first example, my understanding is it should be 7 since its bigger than 5? cause one can just jump from first to last and back to first, like the second example. "
                    },
                    {
                        "username": "siddique_123",
                        "content": "I thought the same initially bro.\\n"
                    },
                    {
                        "username": "guyses",
                        "content": "in the second example input, wouldn\\'t the optimal solution be \\n\\nto go from a[0] to a[1] (length = 3), then, from a[1] to a[2] (length = 6), costG = maxOfAllTheLenghts() = 6\\n\\nand to come back we just go from a[2] to a[0] (length = 9), costC = maxOfAllTheLengths() = 9\\n\\nans = min(costG, costC) = min(6, 9) = 6\\n\\nwhy is the answer 9? I am not able to get the pictorial explanation of this input either! Or am I interpreting the question wrongly?\\n"
                    },
                    {
                        "username": "Priyanka_LC07",
                        "content": "path---->from starting to end and then end to start(like in circle)\\nat most one jump------>for complete path frog can take at one or zero jump on each stone.\\nif frog jump on a[1], it want able to come back that\\'s why it can not jump on a[1]."
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "bring Snake \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "I was doing a dfs with visited : ("
                    },
                    {
                        "username": "v1k45__",
                        "content": "its too confusing by  example 2"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "i thought this is similar to cherry pickup\\nbut this is very hard to come up in interview\\n"
                    },
                    {
                        "username": "RISHIdev",
                        "content": "For the first example, my understanding is it should be 7 since its bigger than 5? cause one can just jump from first to last and back to first, like the second example. Can anyone explain."
                    },
                    {
                        "username": "locke_lost",
                        "content": "In the example 2, it just jump directly to then end and get back. But in the example 1, it does not. I am not sure what the point of this question is."
                    }
                ]
            },
            {
                "id": 1978838,
                "content": [
                    {
                        "username": "snehil_vispute",
                        "content": "anyone who thought its a dp ques?? :/"
                    },
                    {
                        "username": "pierrewang",
                        "content": "The input size tells you that this question requires a O(n) or O(nlogn) solution, so it is clearly that we need a greedy algorithm."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Yeah same. But later I realized it was actually a pretty trivial problem. Here is my explanation with images.\\nhttps://leetcode.com/problems/frog-jump-ii/solutions/2898129/decently-explained-python3-code-o-n-w-image/?orderBy=most_votes"
                    },
                    {
                        "username": "shekomaru",
                        "content": "Hey people, learn to read; here is to discuss solutions, not to post solutions; to post solutions there is the tab called \"Solutions\""
                    },
                    {
                        "username": "Memberberry",
                        "content": "The question is so wordy, what does this mean?\\n\\n `The cost of a path is the maximum length of a jump among all jumps in the path.\\n\\nReturn the minimum cost of a path for the frog.`\\n\\nFor the first example, my understanding is it should be 7 since its bigger than 5? cause one can just jump from first to last and back to first, like the second example. "
                    },
                    {
                        "username": "siddique_123",
                        "content": "I thought the same initially bro.\\n"
                    },
                    {
                        "username": "guyses",
                        "content": "in the second example input, wouldn\\'t the optimal solution be \\n\\nto go from a[0] to a[1] (length = 3), then, from a[1] to a[2] (length = 6), costG = maxOfAllTheLenghts() = 6\\n\\nand to come back we just go from a[2] to a[0] (length = 9), costC = maxOfAllTheLengths() = 9\\n\\nans = min(costG, costC) = min(6, 9) = 6\\n\\nwhy is the answer 9? I am not able to get the pictorial explanation of this input either! Or am I interpreting the question wrongly?\\n"
                    },
                    {
                        "username": "Priyanka_LC07",
                        "content": "path---->from starting to end and then end to start(like in circle)\\nat most one jump------>for complete path frog can take at one or zero jump on each stone.\\nif frog jump on a[1], it want able to come back that\\'s why it can not jump on a[1]."
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "bring Snake \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "I was doing a dfs with visited : ("
                    },
                    {
                        "username": "v1k45__",
                        "content": "its too confusing by  example 2"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "i thought this is similar to cherry pickup\\nbut this is very hard to come up in interview\\n"
                    },
                    {
                        "username": "RISHIdev",
                        "content": "For the first example, my understanding is it should be 7 since its bigger than 5? cause one can just jump from first to last and back to first, like the second example. Can anyone explain."
                    },
                    {
                        "username": "locke_lost",
                        "content": "In the example 2, it just jump directly to then end and get back. But in the example 1, it does not. I am not sure what the point of this question is."
                    }
                ]
            },
            {
                "id": 1863369,
                "content": [
                    {
                        "username": "snehil_vispute",
                        "content": "anyone who thought its a dp ques?? :/"
                    },
                    {
                        "username": "pierrewang",
                        "content": "The input size tells you that this question requires a O(n) or O(nlogn) solution, so it is clearly that we need a greedy algorithm."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Yeah same. But later I realized it was actually a pretty trivial problem. Here is my explanation with images.\\nhttps://leetcode.com/problems/frog-jump-ii/solutions/2898129/decently-explained-python3-code-o-n-w-image/?orderBy=most_votes"
                    },
                    {
                        "username": "shekomaru",
                        "content": "Hey people, learn to read; here is to discuss solutions, not to post solutions; to post solutions there is the tab called \"Solutions\""
                    },
                    {
                        "username": "Memberberry",
                        "content": "The question is so wordy, what does this mean?\\n\\n `The cost of a path is the maximum length of a jump among all jumps in the path.\\n\\nReturn the minimum cost of a path for the frog.`\\n\\nFor the first example, my understanding is it should be 7 since its bigger than 5? cause one can just jump from first to last and back to first, like the second example. "
                    },
                    {
                        "username": "siddique_123",
                        "content": "I thought the same initially bro.\\n"
                    },
                    {
                        "username": "guyses",
                        "content": "in the second example input, wouldn\\'t the optimal solution be \\n\\nto go from a[0] to a[1] (length = 3), then, from a[1] to a[2] (length = 6), costG = maxOfAllTheLenghts() = 6\\n\\nand to come back we just go from a[2] to a[0] (length = 9), costC = maxOfAllTheLengths() = 9\\n\\nans = min(costG, costC) = min(6, 9) = 6\\n\\nwhy is the answer 9? I am not able to get the pictorial explanation of this input either! Or am I interpreting the question wrongly?\\n"
                    },
                    {
                        "username": "Priyanka_LC07",
                        "content": "path---->from starting to end and then end to start(like in circle)\\nat most one jump------>for complete path frog can take at one or zero jump on each stone.\\nif frog jump on a[1], it want able to come back that\\'s why it can not jump on a[1]."
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "bring Snake \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "I was doing a dfs with visited : ("
                    },
                    {
                        "username": "v1k45__",
                        "content": "its too confusing by  example 2"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "i thought this is similar to cherry pickup\\nbut this is very hard to come up in interview\\n"
                    },
                    {
                        "username": "RISHIdev",
                        "content": "For the first example, my understanding is it should be 7 since its bigger than 5? cause one can just jump from first to last and back to first, like the second example. Can anyone explain."
                    },
                    {
                        "username": "locke_lost",
                        "content": "In the example 2, it just jump directly to then end and get back. But in the example 1, it does not. I am not sure what the point of this question is."
                    }
                ]
            }
        ]
    }
]