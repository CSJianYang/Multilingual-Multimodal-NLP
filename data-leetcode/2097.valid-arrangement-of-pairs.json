[
    {
        "title": "Valid Arrangement of Pairs",
        "question_content": "You are given a 0-indexed 2D integer array pairs where pairs[i] = [starti, endi]. An arrangement of pairs is valid if for every index i where 1 <= i < pairs.length, we have endi-1 == starti.\nReturn any valid arrangement of pairs.\nNote: The inputs will be generated such that there exists a valid arrangement of pairs.\n&nbsp;\nExample 1:\n\nInput: pairs = [[5,1],[4,5],[11,9],[9,4]]\nOutput: [[11,9],[9,4],[4,5],[5,1]]\nExplanation:\nThis is a valid arrangement since endi-1 always equals starti.\nend0 = 9 == 9 = start1 \nend1 = 4 == 4 = start2\nend2 = 5 == 5 = start3\n\nExample 2:\n\nInput: pairs = [[1,3],[3,2],[2,1]]\nOutput: [[1,3],[3,2],[2,1]]\nExplanation:\nThis is a valid arrangement since endi-1 always equals starti.\nend0 = 3 == 3 = start1\nend1 = 2 == 2 = start2\nThe arrangements [[2,1],[1,3],[3,2]] and [[3,2],[2,1],[1,3]] are also valid.\n\nExample 3:\n\nInput: pairs = [[1,2],[1,3],[2,1]]\nOutput: [[1,2],[2,1],[1,3]]\nExplanation:\nThis is a valid arrangement since endi-1 always equals starti.\nend0 = 2 == 2 = start1\nend1 = 1 == 1 = start2\n\n&nbsp;\nConstraints:\n\n\t1 <= pairs.length <= 105\n\tpairs[i].length == 2\n\t0 <= starti, endi <= 109\n\tstarti != endi\n\tNo two pairs are exactly the same.\n\tThere exists a valid arrangement of pairs.",
        "solutions": [
            {
                "id": 1611978,
                "title": "c-eulerian-path-with-explanation",
                "content": "- Idea\\n\\t- if we view each `start_i` and `end_i` as nodes in a graph, elements in `pairs` as (directed) edges in the graph, then the problem is asking us to find a path in the corresponding directed graph.\\n\\t- the problem ask us to use up all edges, so we are basically asked to find a **Eulerian Path**, which is a path that walks through each edge **exactly once**.\\n\\t\\t- if you are not familiar with the concept about **Eulerian Path**, there are some resources on [Wikipedia](https://en.wikipedia.org/wiki/Eulerian_path), [CP-algo](https://cp-algorithms.com/graph/euler_path.html), or other websites.\\n\\t\\t- I will mention some important properties (without proof) of Eulerian Path below.\\n\\n- Some Properties of Eulerian Path\\n\\t- I will use `in[i]` (and `out[i]`) to denote the in (and out) degree of a node `i`.\\n\\t- Existence:\\n\\t\\t- A graph has an Eulerian Path if and only if\\n\\t\\t\\t1. we have `out[i] == in[i]` for each node `i`. Or\\n\\t\\t\\t2. we have `out[i] == in[i]` for all nodes `i` except **exactly two** nodes `x` and `y`, with `out[x] = in[x] + 1`, `out[y] = in[y] - 1`.\\n\\t\\t- this problem guarantees that an Eulerian Path exists. So we don\\'t need to check for its existence here.\\n\\t\\t- In the first case (`out[i] == in[i]` for each node `i`), all Eulerian Paths are also **Eulerian Circuits** (Eulerian Path with starting point == ending point).\\n\\t- a node with `out[i] == in[i] + 1` **must** be the starting point of an Eulerian Path (if there exists one).\\n\\n- Algorithm\\n\\t1. find the starting point of an Eulerian Path.\\n\\t\\t- if we have `out[i] == in[i]` for all `i`, we can start at an arbitrary node.\\n\\t2. perform **postorder DFS** on the graph, as we \"walk\" through an edge, we **erase** (or mark it visited) the walked edge.\\n\\t\\t- we may reach the same node many times, but we have to pass each edge **exactly once**.\\n\\t\\t- I use `stack` in my code for erasing edges.\\n\\t\\n- Code (C++)\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> validArrangement(vector<vector<int>>& pairs) {\\n        int m = pairs.size();\\n        // Eulerian Path\\n        unordered_map<int, stack<int>> adj;\\n        unordered_map<int, int> in;\\n        unordered_map<int, int> out;\\n\\t\\t// reserve spaces for unordered_map may help in runtime.\\n\\t\\tadj.reserve(m);\\n\\t\\tin.reserve(m);\\n\\t\\tout.reserve(m);\\n        for (int i = 0; i < m; i++) {\\n            int u = pairs[i][0], v = pairs[i][1];\\n            in[v]++;\\n            out[u]++;\\n            adj[u].push(v);\\n        }\\n\\t\\t// find the starting node\\n        int start = -1;\\n        for (auto& p : adj) {\\n            int i = p.first;\\n            if (out[i] - in[i] == 1) start = i;\\n        }\\n        if (start == -1) {\\n\\t\\t\\t// Eulerian Circuit -> start at any node\\n\\t\\t\\tstart = adj.begin()->first;\\n        }\\n        vector<vector<int>> ans;\\n        euler(adj, ans, start);\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\nprivate:\\n    void euler(unordered_map<int, stack<int>>& adj, vector<vector<int>>& ans, int curr) {\\n        auto& stk = adj[curr];\\n        while (!stk.empty()) {\\n            int nei = stk.top();\\n            stk.pop();\\n            euler(adj, ans, nei);\\n\\t\\t\\t// postorder\\n            ans.push_back({curr, nei});\\n        }\\n    }\\n};\\n```\\n- Complexity\\n\\t- Time Complexity: `O(m+n)`, where `m == pairs.size()`, and `n` is the number of nodes in the graph (the number of distinct numbers in `pairs`)\\n\\t- Space Complexity: `O(m+n)`\\n\\n- Misc.\\n\\t- using `map` instead of `unordered_map` results in TLE during contest.",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> validArrangement(vector<vector<int>>& pairs) {\\n        int m = pairs.size();\\n        // Eulerian Path\\n        unordered_map<int, stack<int>> adj;\\n        unordered_map<int, int> in;\\n        unordered_map<int, int> out;\\n\\t\\t// reserve spaces for unordered_map may help in runtime.\\n\\t\\tadj.reserve(m);\\n\\t\\tin.reserve(m);\\n\\t\\tout.reserve(m);\\n        for (int i = 0; i < m; i++) {\\n            int u = pairs[i][0], v = pairs[i][1];\\n            in[v]++;\\n            out[u]++;\\n            adj[u].push(v);\\n        }\\n\\t\\t// find the starting node\\n        int start = -1;\\n        for (auto& p : adj) {\\n            int i = p.first;\\n            if (out[i] - in[i] == 1) start = i;\\n        }\\n        if (start == -1) {\\n\\t\\t\\t// Eulerian Circuit -> start at any node\\n\\t\\t\\tstart = adj.begin()->first;\\n        }\\n        vector<vector<int>> ans;\\n        euler(adj, ans, start);\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\nprivate:\\n    void euler(unordered_map<int, stack<int>>& adj, vector<vector<int>>& ans, int curr) {\\n        auto& stk = adj[curr];\\n        while (!stk.empty()) {\\n            int nei = stk.top();\\n            stk.pop();\\n            euler(adj, ans, nei);\\n\\t\\t\\t// postorder\\n            ans.push_back({curr, nei});\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1611983,
                "title": "python-o-pairs-length-hierholzer-s-algorithm",
                "content": "Basically finding the [Eulerian path](https://en.wikipedia.org/wiki/Eulerian_path) in a directed graph. \\n\\nAlgorithm: [Hierholzer\\'s Algorithm](https://en.wikipedia.org/wiki/Eulerian_path#Hierholzer\\'s_algorithm)\\n\\nSee also: [332. Reconstruct Itinerary](https://leetcode.com/problems/reconstruct-itinerary/)\\n\\nMy code:\\n```py\\n    def validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\\n        g = defaultdict(list)  # graph\\n        din, dout = Counter(), Counter()  #in degree, out degree\\n        for u, v in pairs:\\n            g[u].append(v)\\n            dout[u] += 1\\n            din[v] += 1\\n\\n        S = pairs[0][0]  # Start anywhere if it\\'s an Eulerian cycle.\\n        for p in dout:\\n            if dout[p] - din[p] == 1:  # It\\'s an Eulerian trail. Have to start here\\n                S = p\\n                break\\n        \\n\\t\\t# Hierholzer\\'s Algorithm:\\n        route = []\\n        st = [S]\\n        while st:\\n            while g[st[-1]]:\\n                st.append(g[st[-1]].pop())\\n            route.append(st.pop())\\n        route.reverse()\\n        return [[route[i], route[i+1]] for i in range(len(route)-1)]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```py\\n    def validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\\n        g = defaultdict(list)  # graph\\n        din, dout = Counter(), Counter()  #in degree, out degree\\n        for u, v in pairs:\\n            g[u].append(v)\\n            dout[u] += 1\\n            din[v] += 1\\n\\n        S = pairs[0][0]  # Start anywhere if it\\'s an Eulerian cycle.\\n        for p in dout:\\n            if dout[p] - din[p] == 1:  # It\\'s an Eulerian trail. Have to start here\\n                S = p\\n                break\\n        \\n\\t\\t# Hierholzer\\'s Algorithm:\\n        route = []\\n        st = [S]\\n        while st:\\n            while g[st[-1]]:\\n                st.append(g[st[-1]].pop())\\n            route.append(st.pop())\\n        route.reverse()\\n        return [[route[i], route[i+1]] for i in range(len(route)-1)]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1612010,
                "title": "python3-hierholzer-s-algo",
                "content": "Please check out this [commit](https://github.com/gaosanyong/leetcode/commit/b1948f8814bebeca475cbb354cd44d19092dff59) for solutions of weekly 270.\\n\\n```\\nclass Solution:\\n    def validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\\n        graph = defaultdict(list)\\n        degree = defaultdict(int) # net out degree \\n        for x, y in pairs: \\n            graph[x].append(y)\\n            degree[x] += 1\\n            degree[y] -= 1\\n                \\n        for k in degree: \\n            if degree[k] == 1: \\n                x = k\\n                break \\n                \\n        ans = []\\n\\n        def fn(x): \\n            \"\"\"Return Eulerian path via dfs.\"\"\"\\n            while graph[x]: fn(graph[x].pop()) \\n            ans.append(x)\\n        \\n        fn(x)\\n        ans.reverse()\\n        return [[ans[i], ans[i+1]] for i in range(len(ans)-1)]\\n```\\n\\nAdding an iterative implementation of Hieholzer\\'s algo from @delphih\\n```\\nclass Solution:\\n    def validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\\n        graph = defaultdict(list)\\n        degree = defaultdict(int) # net out degree \\n        for x, y in pairs: \\n            graph[x].append(y)\\n            degree[x] += 1\\n            degree[y] -= 1\\n                \\n        for k in degree: \\n            if degree[k] == 1: \\n                x = k\\n                break \\n                \\n        ans = []\\n        stack = [x]\\n        while stack: \\n            while graph[stack[-1]]: \\n                stack.append(graph[stack[-1]].pop())\\n            ans.append(stack.pop())\\n        ans.reverse()\\n        return [[ans[i], ans[i+1]] for i in range(len(ans)-1)]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\\n        graph = defaultdict(list)\\n        degree = defaultdict(int) # net out degree \\n        for x, y in pairs: \\n            graph[x].append(y)\\n            degree[x] += 1\\n            degree[y] -= 1\\n                \\n        for k in degree: \\n            if degree[k] == 1: \\n                x = k\\n                break \\n                \\n        ans = []\\n\\n        def fn(x): \\n            \"\"\"Return Eulerian path via dfs.\"\"\"\\n            while graph[x]: fn(graph[x].pop()) \\n            ans.append(x)\\n        \\n        fn(x)\\n        ans.reverse()\\n        return [[ans[i], ans[i+1]] for i in range(len(ans)-1)]\\n```\n```\\nclass Solution:\\n    def validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\\n        graph = defaultdict(list)\\n        degree = defaultdict(int) # net out degree \\n        for x, y in pairs: \\n            graph[x].append(y)\\n            degree[x] += 1\\n            degree[y] -= 1\\n                \\n        for k in degree: \\n            if degree[k] == 1: \\n                x = k\\n                break \\n                \\n        ans = []\\n        stack = [x]\\n        while stack: \\n            while graph[stack[-1]]: \\n                stack.append(graph[stack[-1]].pop())\\n            ans.append(stack.pop())\\n        ans.reverse()\\n        return [[ans[i], ans[i+1]] for i in range(len(ans)-1)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1611979,
                "title": "c-solution-same-idea-as-332-reconstruct-itinerary",
                "content": "\\nOne thing different is that we need to find the start point. it is obvious that if indegree is larger than 0, that is the start point.\\n```\\nclass Solution {\\npublic:\\n    map<int, vector<int> > adj;\\n    vector<vector<int> > ans;\\n    \\n    void dfs(int node) {\\n        while(adj[node].size()) {\\n            int next = adj[node].back();\\n            adj[node].pop_back();\\n            dfs(next);\\n            ans.push_back({node, next});\\n        }\\n    }\\n    vector<vector<int>> validArrangement(vector<vector<int>>& pairs) {\\n        map<int, int> indegree;\\n        for(auto &p : pairs) {\\n            adj[p[0]].push_back(p[1]);\\n            ++indegree[p[0]];\\n            --indegree[p[1]];\\n        }\\n        int start = -1;\\n        for(auto &it: ind) {\\n            if(it.second >0) start = it.first;\\n        }\\n        if(start == -1) {\\n            start = pairs[0][0];\\n        }\\n        dfs(start);\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    map<int, vector<int> > adj;\\n    vector<vector<int> > ans;\\n    \\n    void dfs(int node) {\\n        while(adj[node].size()) {\\n            int next = adj[node].back();\\n            adj[node].pop_back();\\n            dfs(next);\\n            ans.push_back({node, next});\\n        }\\n    }\\n    vector<vector<int>> validArrangement(vector<vector<int>>& pairs) {\\n        map<int, int> indegree;\\n        for(auto &p : pairs) {\\n            adj[p[0]].push_back(p[1]);\\n            ++indegree[p[0]];\\n            --indegree[p[1]];\\n        }\\n        int start = -1;\\n        for(auto &it: ind) {\\n            if(it.second >0) start = it.first;\\n        }\\n        if(start == -1) {\\n            start = pairs[0][0];\\n        }\\n        dfs(start);\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1612177,
                "title": "python3-hierholzer-s-algorithm",
                "content": "You want an Euler trail in a directed graph, which is Hierholzer\\'s algorithm.\\n\\nYou must start at the vertex with outdegree - indegree 1.  If there isn\\'t any, they are all zero and you can start anywhere.\\n\\nNow you do a postorder dfs.\\n```\\nclass Solution:\\n    def validArrangement(self, pairs):\\n        adj = defaultdict(list)\\n        deg = Counter()\\n        for u, v in pairs:\\n            adj[u].append(v)\\n            deg[u] += 1\\n            deg[v] -= 1\\n        \\n        for start in adj:\\n            if deg[start] == 1:\\n                break\\n\\n        ans = []\\n        def dfs(node):\\n            while adj[node]:\\n                dfs(nei := adj[node].pop())\\n                ans.append([node, nei])\\n        dfs(start)\\n        return ans[::-1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def validArrangement(self, pairs):\\n        adj = defaultdict(list)\\n        deg = Counter()\\n        for u, v in pairs:\\n            adj[u].append(v)\\n            deg[u] += 1\\n            deg[v] -= 1\\n        \\n        for start in adj:\\n            if deg[start] == 1:\\n                break\\n\\n        ans = []\\n        def dfs(node):\\n            while adj[node]:\\n                dfs(nei := adj[node].pop())\\n                ans.append([node, nei])\\n        dfs(start)\\n        return ans[::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1618885,
                "title": "iterative-and-recursive",
                "content": "This problem is very tricky if you are not familiar with Eulerian Path and [Hierholzer\\'s algorithm](https://en.wikipedia.org/wiki/Eulerian_path#Hierholzer\\'s_algorithm).\\n\\n1. You first need to find the head of the arrangement. \\n\\t- Head is connected to `n` other numbers, but only `n-1` numbers are linked to the head.\\n\\t- We may not have a head if a sequence is a loop; in this case, we pick any start number as a head.\\n2. Starting from the head, we just greedily follow links and push numbers into a stack.\\n3. A number can be linked to more than one number; we pick any, and remove it from the list of linked numbers.\\n4. Once we reach the tail, we go back by popping numbers from the stack, and adding them to the resulting path.\\n5. If a popped number still has additional linked numbers, we repeat steps 2-5. \\n\\t- Note that this additional \"branch\" will end with the number popped from the stack.\\n\\t- This is property of a valid Euler\\'s path, and so two branches \"connect\".\\n\\nLet\\'s look at this example: `[[1,2],[2,5],[5,3],[3,4],[4,1],[1,5],[5,6]]`. We put links into a map, and we get `1: {2, 5}, 5: {3,6}, 2: {5}, 3: {4}, 6:{}`.\\n\\nWe determine that `1` is the head, and pictures below show different ways we can explore connections, generating valid arrangements.\\n\\n![image](https://assets.leetcode.com/users/images/2bbddd1c-ea2a-417a-aa16-53bf41061040_1639023087.242496.png)\\n\\n#### Recursive\\nFor some reason, using multimap to store pairs produces a faster runtime, then using a map of vectors.\\n\\n**C++**\\n```cpp\\nvoid dfs(int i, unordered_multimap<int, int> &m, vector<vector<int>>& res) {\\n    auto it = m.find(i);\\n    while(it != end(m)) {\\n        int j = it->second;\\n        m.erase(it);\\n        dfs(j, m, res);\\n        res.push_back({i, j});\\n        it = m.find(i);\\n    }\\n}\\nvector<vector<int>> validArrangement(vector<vector<int>>& pairs) {\\n    unordered_multimap<int, int> m;\\n    unordered_map<int, int> cnt;\\n    vector<vector<int>> res;\\n    for (auto &p : pairs) {\\n        m.insert({p[0], p[1]});\\n        ++cnt[p[0]];\\n        --cnt[p[1]];\\n    }\\n    auto head = find_if(begin(cnt), end(cnt), [&](const auto &p){ return p.second > 0; });\\n    dfs(head != end(cnt) ? head->first : pairs[0][0], m, res);\\n    reverse(begin(res), end(res));\\n    return res;\\n}\\n```\\n\\n#### Iterative\\nThe idea is the same as above, and we use a data structure for stack instead of recursion (this is Hierholzer\\'s algorithm, BTW). I think that DFS is easier to come up with, but this iterative implementation helped me understand the algorithm better.\\n\\n**C++**\\n```cpp\\nvector<vector<int>> validArrangement(vector<vector<int>>& pairs) {\\n    unordered_map<int, vector<int>> m;\\n    unordered_map<int, int> cnt;\\n    for (auto &p : pairs) {\\n        m[p[0]].push_back(p[1]);\\n        ++cnt[p[0]];\\n        --cnt[p[1]];\\n    }\\n    auto head = find_if(begin(cnt), end(cnt), [&](const auto &p){ return p.second > 0; });\\n    vector<int> route, stack{head != end(cnt) ? head->first : pairs[0][0]};\\n    vector<vector<int>> res;\\n    while (!stack.empty()) {\\n        while (!m[stack.back()].empty()) {\\n            int i = stack.back();\\n            stack.push_back(m[i].back());\\n            m[i].pop_back();\\n        }\\n        route.push_back(stack.back());\\n        stack.pop_back();\\n    }\\n    for (int i = route.size() - 1; i > 0; --i)\\n        res.push_back({route[i], route[i - 1]});\\n    return res;\\n}\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nvoid dfs(int i, unordered_multimap<int, int> &m, vector<vector<int>>& res) {\\n    auto it = m.find(i);\\n    while(it != end(m)) {\\n        int j = it->second;\\n        m.erase(it);\\n        dfs(j, m, res);\\n        res.push_back({i, j});\\n        it = m.find(i);\\n    }\\n}\\nvector<vector<int>> validArrangement(vector<vector<int>>& pairs) {\\n    unordered_multimap<int, int> m;\\n    unordered_map<int, int> cnt;\\n    vector<vector<int>> res;\\n    for (auto &p : pairs) {\\n        m.insert({p[0], p[1]});\\n        ++cnt[p[0]];\\n        --cnt[p[1]];\\n    }\\n    auto head = find_if(begin(cnt), end(cnt), [&](const auto &p){ return p.second > 0; });\\n    dfs(head != end(cnt) ? head->first : pairs[0][0], m, res);\\n    reverse(begin(res), end(res));\\n    return res;\\n}\\n```\n```cpp\\nvector<vector<int>> validArrangement(vector<vector<int>>& pairs) {\\n    unordered_map<int, vector<int>> m;\\n    unordered_map<int, int> cnt;\\n    for (auto &p : pairs) {\\n        m[p[0]].push_back(p[1]);\\n        ++cnt[p[0]];\\n        --cnt[p[1]];\\n    }\\n    auto head = find_if(begin(cnt), end(cnt), [&](const auto &p){ return p.second > 0; });\\n    vector<int> route, stack{head != end(cnt) ? head->first : pairs[0][0]};\\n    vector<vector<int>> res;\\n    while (!stack.empty()) {\\n        while (!m[stack.back()].empty()) {\\n            int i = stack.back();\\n            stack.push_back(m[i].back());\\n            m[i].pop_back();\\n        }\\n        route.push_back(stack.back());\\n        stack.pop_back();\\n    }\\n    for (int i = route.size() - 1; i > 0; --i)\\n        res.push_back({route[i], route[i - 1]});\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1612183,
                "title": "java-solution-same-as-332-reconstruct-itinerary",
                "content": "Thanks to @chejianchao for the C++ solution here: https://leetcode.com/problems/valid-arrangement-of-pairs/discuss/1611979/C%2B%2B-Solution-Same-Idea-as-332.-Reconstruct-Itinerary\\n\\n```\\nclass Solution {\\n    Map<Integer, List<Integer>> adj = new HashMap<>();\\n    List<List<Integer>> ans = new ArrayList<>();\\n    \\n    public int[][] validArrangement(int[][] pairs) {\\n        Map<Integer, Integer> indegree = new HashMap<>();\\n        for(int[] pair : pairs) {\\n            adj.putIfAbsent(pair[0], new ArrayList<>());\\n            adj.get(pair[0]).add(pair[1]);\\n            indegree.put(pair[0], indegree.getOrDefault(pair[0], 0) + 1);\\n            indegree.put(pair[1], indegree.getOrDefault(pair[1], 0) - 1);\\n\\n        }\\n        \\n        int start = -1;\\n        for (Integer key: indegree.keySet()) {\\n            if (indegree.get(key) > 0)  {\\n                start = key;\\n            }\\n        }\\n        \\n        if(start == -1) {\\n            start = pairs[0][0];\\n        }\\n        \\n        dfs(start);\\n        \\n        int[][] result = new int[pairs.length][pairs[0].length];\\n\\n        for (int i = 0; i < ans.size(); i++) {\\n            result[i][0] = ans.get(ans.size() - i - 1).get(0);\\n            result[i][1] = ans.get(ans.size() - i - 1).get(1);\\n        }\\n        return result;\\n    }\\n    \\n    private void dfs(int node) {\\n        while(adj.get(node) != null && adj.get(node).size() > 0) {\\n            List<Integer> nodes = adj.get(node);\\n            int next = nodes.get(nodes.size() - 1);\\n            adj.get(node).remove(nodes.size() - 1);\\n            dfs(next);\\n            ans.add(Arrays.asList(node, next));\\n        }\\n    }\\n}\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    Map<Integer, List<Integer>> adj = new HashMap<>();\\n    List<List<Integer>> ans = new ArrayList<>();\\n    \\n    public int[][] validArrangement(int[][] pairs) {\\n        Map<Integer, Integer> indegree = new HashMap<>();\\n        for(int[] pair : pairs) {\\n            adj.putIfAbsent(pair[0], new ArrayList<>());\\n            adj.get(pair[0]).add(pair[1]);\\n            indegree.put(pair[0], indegree.getOrDefault(pair[0], 0) + 1);\\n            indegree.put(pair[1], indegree.getOrDefault(pair[1], 0) - 1);\\n\\n        }\\n        \\n        int start = -1;\\n        for (Integer key: indegree.keySet()) {\\n            if (indegree.get(key) > 0)  {\\n                start = key;\\n            }\\n        }\\n        \\n        if(start == -1) {\\n            start = pairs[0][0];\\n        }\\n        \\n        dfs(start);\\n        \\n        int[][] result = new int[pairs.length][pairs[0].length];\\n\\n        for (int i = 0; i < ans.size(); i++) {\\n            result[i][0] = ans.get(ans.size() - i - 1).get(0);\\n            result[i][1] = ans.get(ans.size() - i - 1).get(1);\\n        }\\n        return result;\\n    }\\n    \\n    private void dfs(int node) {\\n        while(adj.get(node) != null && adj.get(node).size() > 0) {\\n            List<Integer> nodes = adj.get(node);\\n            int next = nodes.get(nodes.size() - 1);\\n            adj.get(node).remove(nodes.size() - 1);\\n            dfs(next);\\n            ans.add(Arrays.asList(node, next));\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1834239,
                "title": "c-explanation-in-hindi",
                "content": "/*\\n\\nhame har edge sirf ekk baar hi traverse karni h\\n\\nagar graph cyclic h too ham kisi bhi node se traversal start kar sakte h \\notherwise hame aise node se traversal start karne padega jisme se agar n nodes nikalti h\\n(x--->) too usme n-1 nodes akar milti hooo (--->x)\\n\\ntraverse kaise karna h??\\n\\n1=>jab tak proper sequence milta rhe vertex ko graph m se remove karke(vector.pop_back() kaa use karo) stack m dalte rho\\n\\n2=>agar kisi end node par aa gye(joo kisi aur node se connect nhi h) iska matlab \\nhamare ans ki list m yee node last m honi chaiyee too iss node ko sequ vector m add kar do\\n   => iss node ko stack m se nikal do\\n   => ek sequence iss node par akar finish ho gya ab hame naya sequence find out karna hoga\\n   => jin nodes ko ham already traverse kar chuke ham wo abhi stack ke ander h\\n       too ham new sequence pta lagane ke liye unhi nodes ko use karenge\\n   => jo node abhi stack ke top par ho use check karo ki usse koi new sequence mil sakta h         kiya \\n       =>agar iss node se new sequence mil jata h too step 1 se process repeat karo\\n       =>agar iss node se koi aur sequence nhi milta too ye bhi ekk end node hi ban gayi\\n          too isse stack se nikal do aur seq, vector m daal do (step 2)\\n    => ye kaam jabtak karte rho tabtak stak khali naa ho jaye\\n    \\n\\n=> now ans vector ke ander string m wo node h joo sequence ke last m honi chaiye too\\n   ans vector ko reverse kar doo\\n   sequence= [1,5,4,9,11]\\n   reverse it,  [11,9,4,5,1]  =============> EULER CIRCUIT\\n   return ans= [[11,9],[9,4],[4,5],[5,1]]\\n\\n*/\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> validArrangement(vector<vector<int>>& p) {\\n    \\n        unordered_map<int,vector<int>>g;\\n        \\n        unordered_map<int,int>degree;\\n        \\n        for(auto it:p){\\n            g[it[0]].push_back(it[1]);\\n            degree[it[0]]++;\\n            degree[it[1]]--;\\n        }\\n        \\n        int start=p[0][0];\\n        for(auto it:degree){\\n            if(it.second==1){\\n                start=it.first;\\n                break;\\n            }\\n        }\\n        \\n        stack<int>st;\\n        st.push(start);\\n        vector<int>seq;\\n        \\n        while(st.size()>0){\\n            \\n            int x=st.top();\\n            \\n            while(g[x].size()>0){  // x->y->.....\\n                int y=g[x].back();\\n                g[x].pop_back();\\n                st.push(y);\\n                x=y;\\n            }\\n            \\n            int last=st.top();  // sequence end ho gya iss node par\\n            st.pop();\\n            seq.push_back(last);\\n            \\n        }\\n        \\n        reverse(seq.begin(),seq.end());\\n        \\n        int n=seq.size();\\n        \\n        vector<vector<int>>ans;\\n        \\n        for(int i=0;i<=n-2;i++){\\n            ans.push_back({seq[i],seq[i+1]});\\n        }\\n        \\n        \\n        return ans;\\n    }\\n    \\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>> validArrangement(vector<vector<int>>& p) {\\n    \\n        unordered_map<int,vector<int>>g;\\n        \\n        unordered_map<int,int>degree;\\n        \\n        for(auto it:p){\\n            g[it[0]].push_back(it[1]);\\n            degree[it[0]]++;\\n            degree[it[1]]--;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1612906,
                "title": "java-neat-code",
                "content": "```\\nclass Solution {\\n    public int[][] validArrangement(int[][] pairs) {\\n        Map<Integer, Integer> inDeg = new HashMap<>();\\n        Map<Integer, Integer> outDeg = new HashMap<>();\\n        Map<Integer, Stack<Integer>> adj = new HashMap<>();\\n        int start = pairs[0][0];\\n        for (int[] p : pairs) {\\n            adj.compute(p[0], (k, v) -> v == null ? new Stack<>() : v).add(p[1]);\\n            inDeg.compute(p[1], (k, v) -> v == null ? 1 : v + 1);\\n            outDeg.compute(p[0], (k, v) -> v == null ? 1 : v + 1);\\n        }\\n        for (int[] p : pairs) {\\n            if (inDeg.getOrDefault(p[0], 0) - outDeg.getOrDefault(p[0], 0) == -1) {\\n                start = p[0];\\n                break;\\n            }\\n        }\\n        List<int[]> path = new ArrayList<>();\\n        topPath(start, adj, path);\\n        int[][] ans = new int[path.size()][2];\\n        int cnt = 0;\\n        for (int i = path.size() - 1; i >= 0; i--){\\n            ans[cnt] = new int[]{path.get(i)[1], path.get(i)[0]};\\n            cnt++;\\n        }\\n        return ans;\\n    }\\n    \\n    void topPath(int s, Map<Integer, Stack<Integer>> adj, List<int[]> path) {\\n        Stack<Integer> stk = adj.getOrDefault(s, new Stack<>());\\n        while (!stk.isEmpty()) {\\n            int v = stk.pop();\\n            topPath(v, adj, path);\\n            path.add(new int[]{v, s});\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[][] validArrangement(int[][] pairs) {\\n        Map<Integer, Integer> inDeg = new HashMap<>();\\n        Map<Integer, Integer> outDeg = new HashMap<>();\\n        Map<Integer, Stack<Integer>> adj = new HashMap<>();\\n        int start = pairs[0][0];\\n        for (int[] p : pairs) {\\n            adj.compute(p[0], (k, v) -> v == null ? new Stack<>() : v).add(p[1]);\\n            inDeg.compute(p[1], (k, v) -> v == null ? 1 : v + 1);\\n            outDeg.compute(p[0], (k, v) -> v == null ? 1 : v + 1);\\n        }\\n        for (int[] p : pairs) {\\n            if (inDeg.getOrDefault(p[0], 0) - outDeg.getOrDefault(p[0], 0) == -1) {\\n                start = p[0];\\n                break;\\n            }\\n        }\\n        List<int[]> path = new ArrayList<>();\\n        topPath(start, adj, path);\\n        int[][] ans = new int[path.size()][2];\\n        int cnt = 0;\\n        for (int i = path.size() - 1; i >= 0; i--){\\n            ans[cnt] = new int[]{path.get(i)[1], path.get(i)[0]};\\n            cnt++;\\n        }\\n        return ans;\\n    }\\n    \\n    void topPath(int s, Map<Integer, Stack<Integer>> adj, List<int[]> path) {\\n        Stack<Integer> stk = adj.getOrDefault(s, new Stack<>());\\n        while (!stk.isEmpty()) {\\n            int v = stk.pop();\\n            topPath(v, adj, path);\\n            path.add(new int[]{v, s});\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4044209,
                "title": "c-euler-path-dfs-hierholzer-s-algorithm-beats-94-74",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThat\\'s Euler\\'s path problem, probably for finding path. There exists an Eulerian path $\\\\iff$\\nThe initial $v_0$ must have $indeg(v_0)+1=outdeg(v_0)$ or $indeg(v_0)=outdeg(v_0)$ (if an Euler cycle) the terminal vertex $v_{n-1}$ has $indeg(v_{n-1})=outdeg(v_{n-1})+1$ or $indeg(v_{n-1})=outdeg(v_{n-1})$ (if an Euler cycle $v_0=v_{n-1}$)\\nFor other vertex $v_i$ has $indeg(v_i)=outdeg(v_i)$\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHierholzer\\u2019s algorithm.\\nVery standard version needs a stack. Instead of a stack, the solution uses just a vector, since C++ vector can acts as a stack by push_back and pop_back!\\n\\nFor the huge numbers due to constraint 0 <= start_i, end_i <= 10^9, it is almost impossible to use an array, the hash table must be used.\\n\\n# K\\xF6nigsberg  7 bridges problem\\n![images.jfif](https://assets.leetcode.com/users/images/44b9b15a-6e6b-4ee1-bdff-95c952ff421d_1694703689.5281713.jpeg)\\nFor undirected graph the equivilant condition for the existence of an Eulerian cycle is changed to: Every vertex $v$ has $\\\\deg(v)=0\\\\pmod{0}$. It is surely the graph for K\\xF6nigsberg  7 bridges problem does not satisfy this condition. Neither Eulerian cycle nor Eulerian path does have the graph for K\\xF6nigsberg  7 bridges problem!!!\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(V+E)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(V+E)$$\\n# Code\\n```\\n// Hierholzer\\u2019s algorithm \\nclass Solution {\\npublic:\\n    unordered_map<int, vector<int>> adj;\\n    unordered_map<int, int> indeg, outdeg;\\n    void build_graph(vector<vector<int>>& pairs){\\n        for(auto& edge: pairs){\\n            int start=edge[0], end=edge[1];\\n            adj[start].push_back(end);\\n            outdeg[start]++;\\n            indeg[end]++;\\n        }\\n    }\\n    vector<int> rpath;\\n    void dfs(int i){\\n        while(!adj[i].empty()){\\n            int j=adj[i].back();\\n            adj[i].pop_back();\\n            dfs(j);\\n        }\\n        rpath.push_back(i);//post-order,just vertices faster & little memo\\n    }\\n    vector<vector<int>> validArrangement(vector<vector<int>>& pairs) {\\n        int e = pairs.size();\\n        build_graph(pairs);\\n        int i0=outdeg.begin()->first;//If Euler cycle, use any vertex\\n        for (auto& [v, deg]: outdeg){\\n            if (deg == indeg[v]+1){//The starting vertex\\n                i0=v;\\n                break;\\n            } \\n        }\\n        dfs(i0);\\n\\n        vector<vector<int>> ans;\\n        ans.reserve(e);\\n\\n        //Traverse from beginning to end\\n        for (int i=rpath.size()-2; i>=0; i--) \\n            ans.push_back({rpath[i+1], rpath[i]});\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Depth-First Search",
                    "Eulerian Circuit"
                ],
                "code": "```\\n// Hierholzer\\u2019s algorithm \\nclass Solution {\\npublic:\\n    unordered_map<int, vector<int>> adj;\\n    unordered_map<int, int> indeg, outdeg;\\n    void build_graph(vector<vector<int>>& pairs){\\n        for(auto& edge: pairs){\\n            int start=edge[0], end=edge[1];\\n            adj[start].push_back(end);\\n            outdeg[start]++;\\n            indeg[end]++;\\n        }\\n    }\\n    vector<int> rpath;\\n    void dfs(int i){\\n        while(!adj[i].empty()){\\n            int j=adj[i].back();\\n            adj[i].pop_back();\\n            dfs(j);\\n        }\\n        rpath.push_back(i);//post-order,just vertices faster & little memo\\n    }\\n    vector<vector<int>> validArrangement(vector<vector<int>>& pairs) {\\n        int e = pairs.size();\\n        build_graph(pairs);\\n        int i0=outdeg.begin()->first;//If Euler cycle, use any vertex\\n        for (auto& [v, deg]: outdeg){\\n            if (deg == indeg[v]+1){//The starting vertex\\n                i0=v;\\n                break;\\n            } \\n        }\\n        dfs(i0);\\n\\n        vector<vector<int>> ans;\\n        ans.reserve(e);\\n\\n        //Traverse from beginning to end\\n        for (int i=rpath.size()-2; i>=0; i--) \\n            ans.push_back({rpath[i+1], rpath[i]});\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2543898,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int[][] validArrangement(int[][] pairs) {\\n        Map<Integer,ArrayList<Integer>> map = new HashMap<>();\\n        Map<Integer,Integer> map2 = new HashMap<>();\\n        \\n        for(int i=0;i<pairs.length;i++){\\n            if(!map.containsKey(pairs[i][0])){\\n                ArrayList<Integer> arr = new ArrayList<>();\\n                arr.add(pairs[i][1]);\\n                map.put(pairs[i][0], arr);\\n            }else{\\n                ArrayList<Integer> arr = map.get(pairs[i][0]);\\n                arr.add(pairs[i][1]);\\n                map.put(pairs[i][0], arr);\\n            }\\n            \\n            map2.put(pairs[i][0], map2.getOrDefault(pairs[i][0], 0)+1);\\n            map2.put(pairs[i][1], map2.getOrDefault(pairs[i][1], 0)-1);\\n        }\\n        \\n        int start=pairs[0][0];\\n        for(Map.Entry<Integer, Integer> entry: map2.entrySet()){\\n            if(entry.getValue()==1){\\n                start=entry.getKey();\\n                break;\\n            }\\n        }\\n        \\n        Stack<Integer> st = new Stack<>();\\n        st.push(start);\\n        ArrayList<Integer> list = new ArrayList<>();\\n        \\n        while(!st.isEmpty()){\\n            int num = st.peek();\\n            while(map.containsKey(num) && map.get(num).size()>0){\\n                int size = map.get(num).size();\\n                int val = map.get(num).get(size-1);\\n                ArrayList<Integer> arr = map.get(num);\\n                arr.remove(size-1);\\n                map.put(num, arr);\\n                st.add(val);\\n                num=val;\\n            }\\n            \\n            int x=st.peek();\\n            st.pop();\\n            list.add(x);\\n        }\\n        \\n        Collections.reverse(list);\\n        int[][] ans = new int[pairs.length][pairs[0].length];\\n        int n = list.size()-1;\\n        \\n        for(int i=0;i<n;i++){\\n            ans[i][0]=list.get(i);\\n            ans[i][1]=list.get(i+1);\\n        }\\n        \\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] validArrangement(int[][] pairs) {\\n        Map<Integer,ArrayList<Integer>> map = new HashMap<>();\\n        Map<Integer,Integer> map2 = new HashMap<>();\\n        \\n        for(int i=0;i<pairs.length;i++){\\n            if(!map.containsKey(pairs[i][0])){\\n                ArrayList<Integer> arr = new ArrayList<>();\\n                arr.add(pairs[i][1]);\\n                map.put(pairs[i][0], arr);\\n            }else{\\n                ArrayList<Integer> arr = map.get(pairs[i][0]);\\n                arr.add(pairs[i][1]);\\n                map.put(pairs[i][0], arr);\\n            }\\n            \\n            map2.put(pairs[i][0], map2.getOrDefault(pairs[i][0], 0)+1);\\n            map2.put(pairs[i][1], map2.getOrDefault(pairs[i][1], 0)-1);\\n        }\\n        \\n        int start=pairs[0][0];\\n        for(Map.Entry<Integer, Integer> entry: map2.entrySet()){\\n            if(entry.getValue()==1){\\n                start=entry.getKey();\\n                break;\\n            }\\n        }\\n        \\n        Stack<Integer> st = new Stack<>();\\n        st.push(start);\\n        ArrayList<Integer> list = new ArrayList<>();\\n        \\n        while(!st.isEmpty()){\\n            int num = st.peek();\\n            while(map.containsKey(num) && map.get(num).size()>0){\\n                int size = map.get(num).size();\\n                int val = map.get(num).get(size-1);\\n                ArrayList<Integer> arr = map.get(num);\\n                arr.remove(size-1);\\n                map.put(num, arr);\\n                st.add(val);\\n                num=val;\\n            }\\n            \\n            int x=st.peek();\\n            st.pop();\\n            list.add(x);\\n        }\\n        \\n        Collections.reverse(list);\\n        int[][] ans = new int[pairs.length][pairs[0].length];\\n        int n = list.size()-1;\\n        \\n        for(int i=0;i<n;i++){\\n            ans[i][0]=list.get(i);\\n            ans[i][1]=list.get(i+1);\\n        }\\n        \\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1815385,
                "title": "python-hierholzer-algorithm-dfs-o-v-e",
                "content": "```\\n#Hierholzer Algorithm\\nfrom collections import defaultdict\\nclass Solution:\\n    def validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\\n        G = defaultdict(list)\\n        din = defaultdict(int)\\n        dout = defaultdict(int)\\n        for v, w in pairs:\\n            G[v].append(w)\\n            dout[v] += 1\\n            din[w] += 1\\n        start = pairs[0][0]\\n        for v in G:\\n            if din[v]+1 == dout[v]:\\n                start = v\\n        route = []\\n        def dfs(v):\\n            while G[v]:\\n                w = G[v].pop()\\n                dfs(w)\\n            route.append(v)\\n        dfs(start)\\n        route.reverse()\\n        return [[route[i],route[i+1]] for i in range(len(route)-1)]\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\n#Hierholzer Algorithm\\nfrom collections import defaultdict\\nclass Solution:\\n    def validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\\n        G = defaultdict(list)\\n        din = defaultdict(int)\\n        dout = defaultdict(int)\\n        for v, w in pairs:\\n            G[v].append(w)\\n            dout[v] += 1\\n            din[w] += 1\\n        start = pairs[0][0]\\n        for v in G:\\n            if din[v]+1 == dout[v]:\\n                start = v\\n        route = []\\n        def dfs(v):\\n            while G[v]:\\n                w = G[v].pop()\\n                dfs(w)\\n            route.append(v)\\n        dfs(start)\\n        route.reverse()\\n        return [[route[i],route[i+1]] for i in range(len(route)-1)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1618503,
                "title": "find-eulerian-path-c-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    void findEulerianPath(unordered_map<int, vector<int>>& graph, vector<vector<int>>& path, int node) {\\n        \\n        auto& adj = graph[node];\\n        while(adj.size()) {\\n            int adjnode = adj.back();\\n            adj.pop_back();\\n            findEulerianPath(graph, path, adjnode);\\n            path.push_back({node, adjnode});\\n        }\\n    }\\n    \\n    int findStartNode(unordered_map<int, int>& degree) {\\n        int start = -1;\\n        \\n        for(auto& [i, cnt] : degree) {\\n            if(cnt == 1) return i;\\n            start = i;\\n        }\\n        \\n        return start;\\n    }\\n    \\n    vector<vector<int>> validArrangement(vector<vector<int>>& pairs) {\\n         \\n\\t\\t// Create adjacency list\\n        unordered_map<int, vector<int>> graph;\\n        unordered_map<int, int> degree;  // Store degree of nodes\\n        \\n        for(auto& pair : pairs) {\\n            int u = pair[0], v = pair[1];\\n            graph[u].push_back(v);\\n            degree[u]++;\\n            degree[v]--;\\n        }\\n        \\n\\t\\t// Get starting node of Eulerian Path\\n        int start = findStartNode(degree);\\n        \\n        vector<vector<int>> path;\\n        findEulerianPath(graph, path, start);\\n        \\n        reverse(path.begin(), path.end());\\n        \\n        return path;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    void findEulerianPath(unordered_map<int, vector<int>>& graph, vector<vector<int>>& path, int node) {\\n        \\n        auto& adj = graph[node];\\n        while(adj.size()) {\\n            int adjnode = adj.back();\\n            adj.pop_back();\\n            findEulerianPath(graph, path, adjnode);\\n            path.push_back({node, adjnode});\\n        }\\n    }\\n    \\n    int findStartNode(unordered_map<int, int>& degree) {\\n        int start = -1;\\n        \\n        for(auto& [i, cnt] : degree) {\\n            if(cnt == 1) return i;\\n            start = i;\\n        }\\n        \\n        return start;\\n    }\\n    \\n    vector<vector<int>> validArrangement(vector<vector<int>>& pairs) {\\n         \\n\\t\\t// Create adjacency list\\n        unordered_map<int, vector<int>> graph;\\n        unordered_map<int, int> degree;  // Store degree of nodes\\n        \\n        for(auto& pair : pairs) {\\n            int u = pair[0], v = pair[1];\\n            graph[u].push_back(v);\\n            degree[u]++;\\n            degree[v]--;\\n        }\\n        \\n\\t\\t// Get starting node of Eulerian Path\\n        int start = findStartNode(degree);\\n        \\n        vector<vector<int>> path;\\n        findEulerianPath(graph, path, start);\\n        \\n        reverse(path.begin(), path.end());\\n        \\n        return path;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1614366,
                "title": "c-hieholzer-s-algorithm",
                "content": "```\\nclass Solution {\\npublic:\\n    unordered_map<int, int> ind; // indegree\\n    unordered_map<int, int> oud; // outdegree\\n    unordered_map<int, vector<int>> gmp; // graph map\\n    stack<int> path;\\n    \\n    vector<vector<int>> validArrangement(vector<vector<int>>& pairs) {\\n        int N = pairs.size();\\n\\n        unordered_set<int> gset;\\n        \\n        // build map\\n        for (auto &pa : pairs) {\\n            int u = pa[0];\\n            int v = pa[1];\\n            \\n            // u -- > v\\n            oud[u]++; // out degree\\n            ind[v]++; // in  degree\\n            \\n            gmp[u].push_back(v);\\n            gset.insert(u);\\n            gset.insert(v);\\n        }\\n        \\n        /* \\n           if all nodes indgree == outdgree, it is Eulerian circle, \\n           in this case we choose 1st item as starting point. \\n           if one node\\'s outdegree > indgree, it is the startting point \\n        */\\n        auto it = gset.begin();\\n        int sta = *it;\\n        for (auto u : gset) {\\n            if (ind[u] >= oud[u]) continue;\\n            sta = u;\\n        }\\n        \\n        dfs(sta);\\n        \\n        vector<vector<int>> ans;\\n        \\n        int from = path.top();\\n        path.pop();\\n        while(path.size()) {\\n            int to = path.top();\\n            path.pop();\\n            ans.push_back({from, to});\\n            from = to;\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    void dfs(int u) {\\n        while(oud[u]) {\\n            oud[u] --;\\n            int v = gmp[u][oud[u]];\\n            dfs(v);\\n        }\\n        path.push(u);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<int, int> ind; // indegree\\n    unordered_map<int, int> oud; // outdegree\\n    unordered_map<int, vector<int>> gmp; // graph map\\n    stack<int> path;\\n    \\n    vector<vector<int>> validArrangement(vector<vector<int>>& pairs) {\\n        int N = pairs.size();\\n\\n        unordered_set<int> gset;\\n        \\n        // build map\\n        for (auto &pa : pairs) {\\n            int u = pa[0];\\n            int v = pa[1];\\n            \\n            // u -- > v\\n            oud[u]++; // out degree\\n            ind[v]++; // in  degree\\n            \\n            gmp[u].push_back(v);\\n            gset.insert(u);\\n            gset.insert(v);\\n        }\\n        \\n        /* \\n           if all nodes indgree == outdgree, it is Eulerian circle, \\n           in this case we choose 1st item as starting point. \\n           if one node\\'s outdegree > indgree, it is the startting point \\n        */\\n        auto it = gset.begin();\\n        int sta = *it;\\n        for (auto u : gset) {\\n            if (ind[u] >= oud[u]) continue;\\n            sta = u;\\n        }\\n        \\n        dfs(sta);\\n        \\n        vector<vector<int>> ans;\\n        \\n        int from = path.top();\\n        path.pop();\\n        while(path.size()) {\\n            int to = path.top();\\n            path.pop();\\n            ans.push_back({from, to});\\n            from = to;\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    void dfs(int u) {\\n        while(oud[u]) {\\n            oud[u] --;\\n            int v = gmp[u][oud[u]];\\n            dfs(v);\\n        }\\n        path.push(u);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1612954,
                "title": "javascript-2097-valid-arrangement-of-pairs",
                "content": "---\\n\\n- After lot of struggle\\n  - `count === 1` is the key\\n  - Also stack size needs increasing\\n    - node myfile.js\\n      - FAIL\\n        - RangeError: Maximum call stack size exceeded\\n        -    at Map.get (<anonymous>)\\n    - node --stack_size=1002 myfile.js\\n      - PASS\\n\\n---\\n\\nHope it is simple to understand.\\n\\n---\\n\\n```\\nvar validArrangement = function (pairs) {\\n    let ans = [];\\n    let graph = new Map();\\n\\n    function dfs(start) {\\n        while (graph.get(start)?.length) {\\n            let end = graph.get(start).pop();\\n            dfs(end);\\n            ans.push([start, end]);\\n        }\\n    }\\n\\n    let counts = new Map();\\n    for (let [start, end] of pairs) {\\n        counts.set(start, (counts.get(start) || 0) + 1);\\n        counts.set(end, (counts.get(end) || 0) - 1);\\n\\n        if (graph.has(start)) graph.get(start).push(end);\\n        else graph.set(start, [end]);\\n    }\\n\\n    let begin = counts.entries().next().value[0];\\n    for (let [s, count] of counts) if (count === 1) begin = s;\\n    dfs(begin);\\n\\n    return ans.reverse();\\n};\\n```\\n\\n---\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar validArrangement = function (pairs) {\\n    let ans = [];\\n    let graph = new Map();\\n\\n    function dfs(start) {\\n        while (graph.get(start)?.length) {\\n            let end = graph.get(start).pop();\\n            dfs(end);\\n            ans.push([start, end]);\\n        }\\n    }\\n\\n    let counts = new Map();\\n    for (let [start, end] of pairs) {\\n        counts.set(start, (counts.get(start) || 0) + 1);\\n        counts.set(end, (counts.get(end) || 0) - 1);\\n\\n        if (graph.has(start)) graph.get(start).push(end);\\n        else graph.set(start, [end]);\\n    }\\n\\n    let begin = counts.entries().next().value[0];\\n    for (let [s, count] of counts) if (count === 1) begin = s;\\n    dfs(begin);\\n\\n    return ans.reverse();\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1612936,
                "title": "java-graph-hierholzer",
                "content": "```\\nclass Solution {\\n    Map<Integer, List<Integer>> graph;\\n    Map<Integer, Integer> degree;\\n    List<int[]> ans;\\n    \\n    public int[][] validArrangement(int[][] pairs) {\\n        graph = new HashMap<>();\\n        ans = new ArrayList<>();\\n        degree = new HashMap<>();\\n        \\n        //build graph\\n        buildGraph(pairs);\\n        \\n        //select a start\\n        int start = -1;\\n        for(Integer i : degree.keySet())\\n        {\\n            if(degree.get(i) > 0)\\n            {\\n                start = i;\\n                break;\\n            }\\n        }\\n        \\n        if(start == -1) start = pairs[0][0];\\n        \\n        //dfs Hierholzer\\n        dfs(start);\\n        \\n        int size = ans.size();\\n        int[][] range = new int[size][2];\\n        for(int i=0; i<size; i++)\\n        {\\n            range[i][0] = ans.get(size-1-i)[0];\\n            range[i][1] = ans.get(size-1-i)[1];\\n        }\\n        return range;\\n    }\\n    \\n    private void buildGraph(int[][] pairs)\\n    {\\n        for(int[] pair : pairs)\\n        {\\n            graph.putIfAbsent(pair[0], new ArrayList<>());\\n            List<Integer> edges = graph.get(pair[0]);\\n            edges.add(pair[1]);\\n            \\n            int cnt = degree.getOrDefault(pair[0], 0);\\n            degree.put(pair[0], cnt+1);\\n            cnt = degree.getOrDefault(pair[1], 0);\\n            degree.put(pair[1], cnt-1);\\n        }\\n    }\\n    \\n    private void dfs(int start)\\n    {\\n        List<Integer> edges = graph.get(start);\\n        if(edges == null) return;\\n        while(edges.size() > 0)\\n        {\\n            int next = edges.get(edges.size()-1);\\n            edges.remove(edges.size()-1);\\n            dfs(next);\\n            ans.add(new int[]{start, next});\\n        }\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    Map<Integer, List<Integer>> graph;\\n    Map<Integer, Integer> degree;\\n    List<int[]> ans;\\n    \\n    public int[][] validArrangement(int[][] pairs) {\\n        graph = new HashMap<>();\\n        ans = new ArrayList<>();\\n        degree = new HashMap<>();\\n        \\n        //build graph\\n        buildGraph(pairs);\\n        \\n        //select a start\\n        int start = -1;\\n        for(Integer i : degree.keySet())\\n        {\\n            if(degree.get(i) > 0)\\n            {\\n                start = i;\\n                break;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3857201,
                "title": "java-eulerian-path-explanation",
                "content": "# Code\\n```\\nclass Solution {\\n    // map to track all outcoming edges for given vertex\\n    HashMap<Integer, Stack<Integer>> map = new HashMap<>();\\n\\n    public int[][] validArrangement(int[][] pairs) {\\n        \\n        // map to calculate outdegree - indegree\\n        HashMap<Integer, Integer> degrees = new HashMap<>();\\n\\n        for (int[] p : pairs) {\\n            if ( ! map.containsKey(p[0])) {\\n                map.put(p[0], new Stack<>());\\n            }\\n            map.get(p[0]).push(p[1]);\\n\\n            degrees.put(p[0], degrees.getOrDefault(p[0], 0)-1);\\n            degrees.put(p[1], degrees.getOrDefault(p[1], 0)+1);\\n        }\\n\\n        /*\\n            Based on task description our graph at least has Eulerian path\\n            or possible even circle.\\n            If it has circle, we can start from any node (let\\'s take the first vertex)\\n            If the graph has Eulerian path only, in this case there will be exactly\\n            one vertex with degree -1, this will be our start node.\\n        */\\n        int start = pairs[0][0];\\n        for (int[] p : pairs) {\\n            if (degrees.get(p[0]) == -1) {\\n                start = p[0];\\n                break;\\n            }\\n        }\\n\\n        // build the path in reverse order\\n        List<Integer> path = new ArrayList<>();        \\n        calculate(start, path);\\n        // reverse it\\n        Collections.reverse(path);\\n\\n        int[][] res = new int[pairs.length][2];\\n\\n        // build the result\\n        for (int i = 1; i < path.size(); i++) {\\n            res[i-1][0] = path.get(i-1);\\n            res[i-1][1] = path.get(i);\\n        }\\n\\n        return res;\\n    }\\n\\n    public void calculate(int v, List<Integer> path) {\\n        while (map.containsKey(v) && map.get(v).size() > 0) {\\n            calculate(map.get(v).pop(), path);\\n        }\\n        path.add(v);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    // map to track all outcoming edges for given vertex\\n    HashMap<Integer, Stack<Integer>> map = new HashMap<>();\\n\\n    public int[][] validArrangement(int[][] pairs) {\\n        \\n        // map to calculate outdegree - indegree\\n        HashMap<Integer, Integer> degrees = new HashMap<>();\\n\\n        for (int[] p : pairs) {\\n            if ( ! map.containsKey(p[0])) {\\n                map.put(p[0], new Stack<>());\\n            }\\n            map.get(p[0]).push(p[1]);\\n\\n            degrees.put(p[0], degrees.getOrDefault(p[0], 0)-1);\\n            degrees.put(p[1], degrees.getOrDefault(p[1], 0)+1);\\n        }\\n\\n        /*\\n            Based on task description our graph at least has Eulerian path\\n            or possible even circle.\\n            If it has circle, we can start from any node (let\\'s take the first vertex)\\n            If the graph has Eulerian path only, in this case there will be exactly\\n            one vertex with degree -1, this will be our start node.\\n        */\\n        int start = pairs[0][0];\\n        for (int[] p : pairs) {\\n            if (degrees.get(p[0]) == -1) {\\n                start = p[0];\\n                break;\\n            }\\n        }\\n\\n        // build the path in reverse order\\n        List<Integer> path = new ArrayList<>();        \\n        calculate(start, path);\\n        // reverse it\\n        Collections.reverse(path);\\n\\n        int[][] res = new int[pairs.length][2];\\n\\n        // build the result\\n        for (int i = 1; i < path.size(); i++) {\\n            res[i-1][0] = path.get(i-1);\\n            res[i-1][1] = path.get(i);\\n        }\\n\\n        return res;\\n    }\\n\\n    public void calculate(int v, List<Integer> path) {\\n        while (map.containsKey(v) && map.get(v).size() > 0) {\\n            calculate(map.get(v).pop(), path);\\n        }\\n        path.add(v);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3515602,
                "title": "java-solution-with-greedy-algorithm",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] validArrangement(int[][] pairs) {\\n        int n = pairs.length;\\n        \\n        int[][] ans = new int[n][2];\\n        for (int[] a : ans) {\\n            a[0] = -1;\\n            a[1] = -1;\\n        }\\n        \\n        Map<Integer, Integer> outdegree = new HashMap<>();\\n        Map<Integer, Deque<Integer>> out = new HashMap<>();\\n        \\n        for (int[] pair : pairs) {\\n            outdegree.put(pair[0], outdegree.getOrDefault(pair[0], 0) + 1);\\n            outdegree.put(pair[1], outdegree.getOrDefault(pair[1], 0) - 1);\\n            \\n            out.computeIfAbsent(pair[0], k -> new ArrayDeque<>());\\n            out.computeIfAbsent(pair[1], k -> new ArrayDeque<>());\\n            \\n            out.get(pair[0]).addLast(pair[1]);\\n        }\\n        \\n        for (Map.Entry<Integer, Integer> entry : outdegree.entrySet()) {\\n            if (entry.getValue() == 1) ans[0][0] = entry.getKey();\\n            if (entry.getValue() == -1) ans[n - 1][1] = entry.getKey();\\n        }\\n        \\n        if (ans[0][0] == -1) {\\n            ans[0][0] = pairs[0][0];\\n            ans[n - 1][1] = pairs[0][0];\\n        }\\n        \\n        int i = 0;\\n        int j = n - 1;\\n        while (i < j) {\\n            int from = ans[i][0];\\n            \\n            Deque<Integer> toList = out.get(from);\\n            \\n            if (toList.size() == 0) {\\n                ans[j][0] = ans[--i][0];\\n                ans[--j][1] = ans[j + 1][0];\\n            } else {\\n                ans[i++][1] = toList.removeLast();\\n                ans[i][0] = ans[i - 1][1];\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Graph",
                    "Eulerian Circuit"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] validArrangement(int[][] pairs) {\\n        int n = pairs.length;\\n        \\n        int[][] ans = new int[n][2];\\n        for (int[] a : ans) {\\n            a[0] = -1;\\n            a[1] = -1;\\n        }\\n        \\n        Map<Integer, Integer> outdegree = new HashMap<>();\\n        Map<Integer, Deque<Integer>> out = new HashMap<>();\\n        \\n        for (int[] pair : pairs) {\\n            outdegree.put(pair[0], outdegree.getOrDefault(pair[0], 0) + 1);\\n            outdegree.put(pair[1], outdegree.getOrDefault(pair[1], 0) - 1);\\n            \\n            out.computeIfAbsent(pair[0], k -> new ArrayDeque<>());\\n            out.computeIfAbsent(pair[1], k -> new ArrayDeque<>());\\n            \\n            out.get(pair[0]).addLast(pair[1]);\\n        }\\n        \\n        for (Map.Entry<Integer, Integer> entry : outdegree.entrySet()) {\\n            if (entry.getValue() == 1) ans[0][0] = entry.getKey();\\n            if (entry.getValue() == -1) ans[n - 1][1] = entry.getKey();\\n        }\\n        \\n        if (ans[0][0] == -1) {\\n            ans[0][0] = pairs[0][0];\\n            ans[n - 1][1] = pairs[0][0];\\n        }\\n        \\n        int i = 0;\\n        int j = n - 1;\\n        while (i < j) {\\n            int from = ans[i][0];\\n            \\n            Deque<Integer> toList = out.get(from);\\n            \\n            if (toList.size() == 0) {\\n                ans[j][0] = ans[--i][0];\\n                ans[--j][1] = ans[j + 1][0];\\n            } else {\\n                ans[i++][1] = toList.removeLast();\\n                ans[i][0] = ans[i - 1][1];\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2756787,
                "title": "python-euler-path-concise-solution",
                "content": "```\\nclass Solution:\\n    def validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\\n        adj = defaultdict(list)\\n        out_degrees = defaultdict(int)\\n        \\n        for u, v in pairs:\\n            adj[u].append(v)\\n            out_degrees[u] += 1\\n            out_degrees[v] -= 1\\n        \\n        start = pairs[0][0]\\n        for node in out_degrees.keys():\\n            if out_degrees[node] == 1:\\n                start = node\\n                break\\n        \\n        ans = []\\n        def euler_path(x):\\n            while adj[x]:\\n                euler_path(adj[x].pop())\\n            ans.append(x)\\n        \\n        euler_path(start)\\n        ans = ans[::-1]\\n        return [[ans[i], ans[i+1]] for i in range(len(ans)-1)]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\\n        adj = defaultdict(list)\\n        out_degrees = defaultdict(int)\\n        \\n        for u, v in pairs:\\n            adj[u].append(v)\\n            out_degrees[u] += 1\\n            out_degrees[v] -= 1\\n        \\n        start = pairs[0][0]\\n        for node in out_degrees.keys():\\n            if out_degrees[node] == 1:\\n                start = node\\n                break\\n        \\n        ans = []\\n        def euler_path(x):\\n            while adj[x]:\\n                euler_path(adj[x].pop())\\n            ans.append(x)\\n        \\n        euler_path(start)\\n        ans = ans[::-1]\\n        return [[ans[i], ans[i+1]] for i in range(len(ans)-1)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2458513,
                "title": "simple-solution-bonus-basic-concepts-needed-to-solve-the-problem",
                "content": "https://www.youtube.com/watch?v=uko0V0gCsWk",
                "solutionTags": [],
                "code": "https://www.youtube.com/watch?v=uko0V0gCsWk",
                "codeTag": "Unknown"
            },
            {
                "id": 2321052,
                "title": "c-eulerian-path-dfs",
                "content": "The problem is a finding the path that connects one starting point to the end point, while passing through all the edges. This is a typical Eulerian Path problem. The only difference is that in Eulerian problem, we need to find all the nodes in the path, while in this problem, we form different pairs, which in the iteration, are current node + all the neighbors. \\n\\nIn Eulerian path problem, the starting point should be the point \\n* `out_degree` - `in_degree` = 1\\n* if the above doesn\\'t satisfy, `out_degree` > 0\\n\\nIn Eulerian path problem, in the dfs, it\\'s always inserting points to the front. Since here we use vector to represent the path, we need a `reverse` in the end after dfs\\n\\nI use `deque` to represent the adjacency list, so we need to traverse all the nodes in the `deque`, and do `dfs` in each operation.  \\n\\n```\\nclass Solution {\\npublic:\\n    unordered_map<int, std::deque<int>> graph;\\n    unordered_map<int, int> indeg;\\n    unordered_map<int, int> outdeg;\\n    set<int> nodes;\\n    \\n    vector<vector<int>> validArrangement(vector<vector<int>>& pairs) {\\n        \\n        int temp;\\n        for (auto &pair : pairs)\\n        {\\n            graph[pair[0]].push_back(pair[1]);\\n            \\n            temp = indeg[pair[0]];\\n            ++indeg[pair[1]];\\n            \\n            temp = outdeg[pair[1]];\\n            ++outdeg[pair[0]];\\n            \\n            nodes.insert(pair[0]);\\n            nodes.insert(pair[1]);\\n        }\\n        \\n        vector<vector<int>> path;\\n        path.reserve(pairs.size());\\n        \\n        int start = findStart();\\n        dfs(path, start);\\n        \\n        std::reverse(path.begin(), path.end());\\n        \\n        return path;\\n    }\\n    \\nprivate:\\n    int findStart()\\n    {\\n        auto curr = nodes.begin();\\n        int start = *curr;\\n        \\n        for (; curr != nodes.end(); ++curr)\\n        {\\n            if (outdeg[*curr] - indeg[*curr] == 1)\\n                return *curr;\\n            \\n            if (outdeg[*curr] > 0)\\n                start = *curr;\\n        }\\n        return start;\\n    }\\n    \\n    \\n    void dfs(vector<vector<int>> &path, int curr)\\n    {\\n        auto &dq = graph[curr];\\n        while (!dq.empty())\\n        {\\n            int n = dq.front();\\n            dq.pop_front();\\n            \\n            dfs(path, n);\\n            path.push_back({curr, n});\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<int, std::deque<int>> graph;\\n    unordered_map<int, int> indeg;\\n    unordered_map<int, int> outdeg;\\n    set<int> nodes;\\n    \\n    vector<vector<int>> validArrangement(vector<vector<int>>& pairs) {\\n        \\n        int temp;\\n        for (auto &pair : pairs)\\n        {\\n            graph[pair[0]].push_back(pair[1]);\\n            \\n            temp = indeg[pair[0]];\\n            ++indeg[pair[1]];\\n            \\n            temp = outdeg[pair[1]];\\n            ++outdeg[pair[0]];\\n            \\n            nodes.insert(pair[0]);\\n            nodes.insert(pair[1]);\\n        }\\n        \\n        vector<vector<int>> path;\\n        path.reserve(pairs.size());\\n        \\n        int start = findStart();\\n        dfs(path, start);\\n        \\n        std::reverse(path.begin(), path.end());\\n        \\n        return path;\\n    }\\n    \\nprivate:\\n    int findStart()\\n    {\\n        auto curr = nodes.begin();\\n        int start = *curr;\\n        \\n        for (; curr != nodes.end(); ++curr)\\n        {\\n            if (outdeg[*curr] - indeg[*curr] == 1)\\n                return *curr;\\n            \\n            if (outdeg[*curr] > 0)\\n                start = *curr;\\n        }\\n        return start;\\n    }\\n    \\n    \\n    void dfs(vector<vector<int>> &path, int curr)\\n    {\\n        auto &dq = graph[curr];\\n        while (!dq.empty())\\n        {\\n            int n = dq.front();\\n            dq.pop_front();\\n            \\n            dfs(path, n);\\n            path.push_back({curr, n});\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2118588,
                "title": "c-eulerian-path-dfs-map",
                "content": "```\\nclass Solution {\\nprivate:\\n    vector<int> path;\\n    unordered_map<int, int> in, out;\\n    unordered_map<int, vector<int>> graph;\\n    \\n    void make_path(int u) {\\n        while(out[u] > 0) {\\n            int v = graph[u].back();\\n            graph[u].pop_back();\\n            out[u] -= 1;\\n            make_path(v);\\n        }\\n        path.push_back(u);\\n    }\\n    \\npublic:\\n    vector<vector<int>> validArrangement(vector<vector<int>>& pairs) {\\n        for(auto &it: pairs) {\\n            graph[it[0]].push_back(it[1]);\\n            out[it[0]] += 1;\\n            in[it[1]] += 1;\\n        }\\n        \\n        // find the start node\\n        // start always exists\\n        int start = -1;\\n        for(auto &it: pairs) {\\n            int u = it[0];\\n            int v = it[1];\\n            if(out[u] - in[u] == 1) {\\n                start = u;\\n                break;\\n            } else if(out[v] - in[v] == 1) {\\n                start = v;\\n                break;\\n            }\\n        }\\n        \\n        if(start == -1) \\n            start = pairs[0][0];\\n                \\n        make_path(start);\\n        \\n        vector<vector<int>> ans;\\n        for(int i = path.size()-1; i > 0; i--) {\\n            ans.push_back({path[i], path[i-1]});\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    vector<int> path;\\n    unordered_map<int, int> in, out;\\n    unordered_map<int, vector<int>> graph;\\n    \\n    void make_path(int u) {\\n        while(out[u] > 0) {\\n            int v = graph[u].back();\\n            graph[u].pop_back();\\n            out[u] -= 1;\\n            make_path(v);\\n        }\\n        path.push_back(u);\\n    }\\n    \\npublic:\\n    vector<vector<int>> validArrangement(vector<vector<int>>& pairs) {\\n        for(auto &it: pairs) {\\n            graph[it[0]].push_back(it[1]);\\n            out[it[0]] += 1;\\n            in[it[1]] += 1;\\n        }\\n        \\n        // find the start node\\n        // start always exists\\n        int start = -1;\\n        for(auto &it: pairs) {\\n            int u = it[0];\\n            int v = it[1];\\n            if(out[u] - in[u] == 1) {\\n                start = u;\\n                break;\\n            } else if(out[v] - in[v] == 1) {\\n                start = v;\\n                break;\\n            }\\n        }\\n        \\n        if(start == -1) \\n            start = pairs[0][0];\\n                \\n        make_path(start);\\n        \\n        vector<vector<int>> ans;\\n        for(int i = path.size()-1; i > 0; i--) {\\n            ans.push_back({path[i], path[i-1]});\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1733861,
                "title": "thanks-to-hierholzer-for-algorithm",
                "content": "This is main algo:\\n\\n\\t//we keep nodes temporarily in \\'curr\\' stack\\n\\t//once sure that all nodes reachable from a particular nodes have been added to \\'ans\\' vector\\n\\t//we transfer that node to \\'ans\\' vector from \\'curr\\' stack\\n\\n\\tvector<int> ans;   \\n\\tstack<int> curr; curr.push(start); \\n\\n\\tint i;\\n\\twhile(!curr.empty()){\\n\\t\\ti=curr.top();\\n\\t\\t//if any node is reachable from \\'i\\' node \\n\\t\\tif(graph[i].size()){\\n\\t\\t\\tint j=graph[i].back(); graph[i].pop_back(); curr.push(j); \\n\\t\\t}\\n\\t\\t//otherwise add \\'i\\' node to ans and remove it from stack\\n\\t\\telse{\\n\\t\\t\\t curr.pop();   ans.push_back(i);\\n\\t\\t }\\n\\n\\t}\\n\\n\\treverse(ans.begin(),ans.end());\\n\\n\\nWhole code:\\n\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n     \\n    vector<vector<int>> validArrangement(vector<vector<int>>& pairs) {\\n        \\n        int start;\\n        unordered_map<int,vector<int>> graph;\\n        unordered_map<int,int> in,out;\\n         \\n         \\n        for(auto& e:pairs){\\n            graph[e[0]].push_back(e[1]);\\n            start=e[0];\\n            in[e[1]]++;\\n            out[e[0]]++;\\n        }\\n       \\n        for(auto& e:pairs){\\n             if(in[e[0]] <out[e[0]] ) start=e[0];\\n             if(in[e[1]] <out[e[1]] ) start=e[1];\\n        }\\n        \\n        vector<int> ans;\\n        stack<int> curr; curr.push(start);\\n        \\n        int i;\\n        while(!curr.empty()){\\n            i=curr.top();\\n            if(graph[i].size()){\\n                int j=graph[i].back(); graph[i].pop_back(); curr.push(j); \\n            }\\n            else{\\n                 curr.pop();   ans.push_back(i);\\n             } \\n        }\\n        \\n        \\n        reverse(ans.begin(),ans.end());\\n        vector<vector<int>> temp;\\n        \\n        for(int i=0;i<ans.size()-1;i++) {\\n            \\n            temp.push_back({ans[i],ans[i+1]});\\n            \\n        }\\n   \\n        return temp;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n     \\n    vector<vector<int>> validArrangement(vector<vector<int>>& pairs) {\\n        \\n        int start;\\n        unordered_map<int,vector<int>> graph;\\n        unordered_map<int,int> in,out;\\n         \\n         \\n        for(auto& e:pairs){\\n            graph[e[0]].push_back(e[1]);\\n            start=e[0];\\n            in[e[1]]++;\\n            out[e[0]]++;\\n        }\\n       \\n        for(auto& e:pairs){\\n             if(in[e[0]] <out[e[0]] ) start=e[0];\\n             if(in[e[1]] <out[e[1]] ) start=e[1];\\n        }\\n        \\n        vector<int> ans;\\n        stack<int> curr; curr.push(start);\\n        \\n        int i;\\n        while(!curr.empty()){\\n            i=curr.top();\\n            if(graph[i].size()){\\n                int j=graph[i].back(); graph[i].pop_back(); curr.push(j); \\n            }\\n            else{\\n                 curr.pop();   ans.push_back(i);\\n             } \\n        }\\n        \\n        \\n        reverse(ans.begin(),ans.end());\\n        vector<vector<int>> temp;\\n        \\n        for(int i=0;i<ans.size()-1;i++) {\\n            \\n            temp.push_back({ans[i],ans[i+1]});\\n            \\n        }\\n   \\n        return temp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1691457,
                "title": "python-3-valid-arrangement-of-pairs",
                "content": "class Solution:\\n    def validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\\n        graph = defaultdict(list)\\n        degree = defaultdict(int) # net out degree \\n        for x, y in pairs: \\n            graph[x].append(y)\\n            degree[x] += 1\\n            degree[y] -= 1\\n                \\n        for k in degree: \\n            if degree[k] == 1: \\n                x = k\\n                break \\n                \\n        ans = []\\n        stack = [x]\\n        while stack: \\n            while graph[stack[-1]]: \\n                stack.append(graph[stack[-1]].pop())\\n            ans.append(stack.pop())\\n        ans.reverse()\\n        return [[ans[i], ans[i+1]] for i in range(len(ans)-1)]",
                "solutionTags": [],
                "code": "class Solution:\\n    def validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\\n        graph = defaultdict(list)\\n        degree = defaultdict(int) # net out degree \\n        for x, y in pairs: \\n            graph[x].append(y)\\n            degree[x] += 1\\n            degree[y] -= 1\\n                \\n        for k in degree: \\n            if degree[k] == 1: \\n                x = k\\n                break \\n                \\n        ans = []\\n        stack = [x]\\n        while stack: \\n            while graph[stack[-1]]: \\n                stack.append(graph[stack[-1]].pop())\\n            ans.append(stack.pop())\\n        ans.reverse()\\n        return [[ans[i], ans[i+1]] for i in range(len(ans)-1)]",
                "codeTag": "Java"
            },
            {
                "id": 1641180,
                "title": "2097-valid-arrangement-of-pairs-c-euler-graph-hierholzer-s-algorithm-for-directed-graphs",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> validArrangement(vector<vector<int>>& pairs) {\\n        unordered_map<int, vector<int>> graph;\\n        unordered_map<int, int> in, out;\\n        unordered_set<int> nodes;\\n        vector<int> path;\\n        vector<vector<int>> ans;\\n        \\n        for(auto& i : pairs) {\\n            graph[i[0]].push_back(i[1]);\\n            in[i[1]]++;\\n            out[i[0]]++;\\n            nodes.insert(i[0]);\\n            nodes.insert(i[1]);\\n        }\\n        \\n        auto findStartNode = [&]()-> int{\\n            int start = 0;\\n            for(auto& i : nodes){\\n                // unique starting point\\n                if(out[i] - in[i] == 1) return i;\\n                // prevent singleton vertex to become the start node\\n                if(out[i] > 0) start = i;\\n            }\\n            return start;\\n        };\\n        \\n        function<void(int)> dfs = [&](int at)-> void{\\n            // while the current node still has outgoing edge\\n            while(out[at] != 0){\\n                // find the next unvisited outgoing edge\\n                int next = graph[at][--out[at]];\\n                dfs(next);\\n            }\\n            // add the current node to the path\\n            path.push_back(at);\\n        };\\n        \\n        int startNode = findStartNode();\\n        dfs(startNode);\\n        reverse(begin(path), end(path));\\n        \\n        for(int i = 0; i < path.size() - 1; i++){\\n            ans.push_back({path[i], path[i + 1]});\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> validArrangement(vector<vector<int>>& pairs) {\\n        unordered_map<int, vector<int>> graph;\\n        unordered_map<int, int> in, out;\\n        unordered_set<int> nodes;\\n        vector<int> path;\\n        vector<vector<int>> ans;\\n        \\n        for(auto& i : pairs) {\\n            graph[i[0]].push_back(i[1]);\\n            in[i[1]]++;\\n            out[i[0]]++;\\n            nodes.insert(i[0]);\\n            nodes.insert(i[1]);\\n        }\\n        \\n        auto findStartNode = [&]()-> int{\\n            int start = 0;\\n            for(auto& i : nodes){\\n                // unique starting point\\n                if(out[i] - in[i] == 1) return i;\\n                // prevent singleton vertex to become the start node\\n                if(out[i] > 0) start = i;\\n            }\\n            return start;\\n        };\\n        \\n        function<void(int)> dfs = [&](int at)-> void{\\n            // while the current node still has outgoing edge\\n            while(out[at] != 0){\\n                // find the next unvisited outgoing edge\\n                int next = graph[at][--out[at]];\\n                dfs(next);\\n            }\\n            // add the current node to the path\\n            path.push_back(at);\\n        };\\n        \\n        int startNode = findStartNode();\\n        dfs(startNode);\\n        reverse(begin(path), end(path));\\n        \\n        for(int i = 0; i < path.size() - 1; i++){\\n            ans.push_back({path[i], path[i + 1]});\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1616288,
                "title": "python-o-v-e-by-euler-path-w-visualization",
                "content": "**Hint**:\\n\\nThink of **graph** and classical **Euler path** (or **Euler circuits**) problem\\n\\n---\\n\\nAbstract transform model:\\n\\n**Pairs** <-> **Edges**\\n\\npair [**src**, **dst**] <-> **source node** index and **destination node** index of edge E\\n\\n**Valid arrangement** of given pairs <-> **Euler path** or **Euler circuit** of given graph G\\n\\n---\\n\\n![image](https://assets.leetcode.com/users/images/ca1f4086-49d7-4865-ad3b-e744690ec660_1638866017.095853.png)\\n\\n[Reference: Topics in Mathematics Fall 2011 by Prof Jeremy L. Martin, University of Kansas](https://jlmartin.ku.edu/courses/math105-F11/Lectures/chapter5-part2.pdf)\\n\\n---\\n\\n**Example and Visualization**\\n\\n![image](https://assets.leetcode.com/users/images/7a00209c-d2cf-4262-9b61-97080858f1b2_1638955844.6860914.png)\\n\\n**Euler circuit**: **1** -> **3** -> **2** -> **1**\\n\\n---\\n\\n![image](https://assets.leetcode.com/users/images/3b623130-13f4-47f2-96e5-52ae96f6754d_1638955922.6628637.png)\\n\\n**Euler path**:  **1** -> **2** -> **1** -> **3**\\n\\n---\\n\\n\\n**Implementation**:\\n\\n```\\nclass Solution:\\n    def validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\\n        \\n        # in degree table for each node\\n        in_degree = defaultdict(int)\\n        \\n        # out degree table for each node\\n        out_degree = defaultdict(int)\\n        \\n        # adjacency matrix for each node\\n        adj_matrix = defaultdict(list)\\n        \\n        \\n        # update table with input edge pairs\\n        for src, dst in pairs:\\n            \\n            in_degree[dst] += 1\\n            out_degree[src] += 1\\n            adj_matrix[src].append(dst)\\n            \\n        \\n        ## Case_#1:\\n        # There is eular circuit in graph, any arbitrary node can be start point, here we use source node of first edge just for convenience\\n        start_node_idx = pairs[0][0]\\n        \\n        \\n        ## Case_#2\\n        # There is no eular circuit. But there is eular path, find the start node by indegree and outdegree relation\\n        for node in adj_matrix:\\n            \\n\\t\\t\\t# find the node whose outdegree is one more than indegree\\n            if out_degree[node] - in_degree[node] == 1:\\n                start_node_idx = node\\n                break\\n        \\n        # ------------------------------------------------\\n        def eular_path( adjMatrix, path, cur_node):\\n            \\n            # Keep traverse to next node in DFS until all edges of current node are visited\\n            while adjMatrix[cur_node]:\\n                \\n                # pop one edge and get next visit node\\n                next_visit_node = adjMatrix[cur_node].pop()\\n                \\n                eular_path( adjMatrix, path, next_visit_node )\\n                \\n                # post-order style\\n                # current explorer is finished, record current edge pair \\n                path.append([cur_node, next_visit_node])\\n                \\n                \\n        # ------------------------------------------------\\n        record = []\\n        eular_path(adj_matrix, record, start_node_idx)\\n        \\n        # reversed of post-order record is the answer of eular path        \\n        return reversed(record)\\n```\\n\\n---\\n\\n---\\n\\nReference:\\n\\n[[1] Wiki: Euler Path and Euler circuit](https://en.wikipedia.org/wiki/Eulerian_path)\\n\\n[2] [Chapter 5, Topics in Mathematics Fall 2011 by Prof Jeremy L. Martin, University of Kansas](https://jlmartin.ku.edu/courses/math105-F11/Lectures/chapter5-part2.pdf)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Graph"
                ],
                "code": "```\\nclass Solution:\\n    def validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\\n        \\n        # in degree table for each node\\n        in_degree = defaultdict(int)\\n        \\n        # out degree table for each node\\n        out_degree = defaultdict(int)\\n        \\n        # adjacency matrix for each node\\n        adj_matrix = defaultdict(list)\\n        \\n        \\n        # update table with input edge pairs\\n        for src, dst in pairs:\\n            \\n            in_degree[dst] += 1\\n            out_degree[src] += 1\\n            adj_matrix[src].append(dst)\\n            \\n        \\n        ## Case_#1:\\n        # There is eular circuit in graph, any arbitrary node can be start point, here we use source node of first edge just for convenience\\n        start_node_idx = pairs[0][0]\\n        \\n        \\n        ## Case_#2\\n        # There is no eular circuit. But there is eular path, find the start node by indegree and outdegree relation\\n        for node in adj_matrix:\\n            \\n\\t\\t\\t# find the node whose outdegree is one more than indegree\\n            if out_degree[node] - in_degree[node] == 1:\\n                start_node_idx = node\\n                break\\n        \\n        # ------------------------------------------------\\n        def eular_path( adjMatrix, path, cur_node):\\n            \\n            # Keep traverse to next node in DFS until all edges of current node are visited\\n            while adjMatrix[cur_node]:\\n                \\n                # pop one edge and get next visit node\\n                next_visit_node = adjMatrix[cur_node].pop()\\n                \\n                eular_path( adjMatrix, path, next_visit_node )\\n                \\n                # post-order style\\n                # current explorer is finished, record current edge pair \\n                path.append([cur_node, next_visit_node])\\n                \\n                \\n        # ------------------------------------------------\\n        record = []\\n        eular_path(adj_matrix, record, start_node_idx)\\n        \\n        # reversed of post-order record is the answer of eular path        \\n        return reversed(record)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1615916,
                "title": "c-hierholzer-s-algorithm",
                "content": "```\\nclass Solution {\\npublic:\\n    unordered_map<int,vector<int>>  graph;\\n    unordered_map<int,int> in, out;\\n    vector<vector<int>> ans;\\n    stack<int> stk;\\n    \\n    void dfs(int u){\\n        while(out[u]){\\n            out[u]--;\\n            int v = graph[u][out[u]];\\n            dfs(v);\\n        }\\n        stk.push(u);\\n    }\\n    \\n    vector<vector<int>> validArrangement(vector<vector<int>>& pairs) {\\n        unordered_set<int> node;\\n        for(auto &p : pairs){\\n            int u=p[0], v=p[1];\\n            graph[u].push_back(v);\\n            node.insert(u);\\n            node.insert(v);\\n            out[u]++;\\n            in[v]++;\\n        }\\n        \\n        int start = *node.begin();\\n        for(auto &u : node){\\n            if(in[u] < out[u]) start=u;\\n        }\\n        \\n        dfs(start);\\n        \\n        int from = stk.top(); stk.pop();\\n        while(!stk.empty()){\\n            int to = stk.top(); stk.pop();\\n            ans.push_back({from,to});\\n            from=to;\\n        }\\n        return ans;\\n    }\\n};\\n```\\nPlease **UPVOTE**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<int,vector<int>>  graph;\\n    unordered_map<int,int> in, out;\\n    vector<vector<int>> ans;\\n    stack<int> stk;\\n    \\n    void dfs(int u){\\n        while(out[u]){\\n            out[u]--;\\n            int v = graph[u][out[u]];\\n            dfs(v);\\n        }\\n        stk.push(u);\\n    }\\n    \\n    vector<vector<int>> validArrangement(vector<vector<int>>& pairs) {\\n        unordered_set<int> node;\\n        for(auto &p : pairs){\\n            int u=p[0], v=p[1];\\n            graph[u].push_back(v);\\n            node.insert(u);\\n            node.insert(v);\\n            out[u]++;\\n            in[v]++;\\n        }\\n        \\n        int start = *node.begin();\\n        for(auto &u : node){\\n            if(in[u] < out[u]) start=u;\\n        }\\n        \\n        dfs(start);\\n        \\n        int from = stk.top(); stk.pop();\\n        while(!stk.empty()){\\n            int to = stk.top(); stk.pop();\\n            ans.push_back({from,to});\\n            from=to;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1615421,
                "title": "c-2097-valid-arrangement-of-pairs",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> validArrangement(vector<vector<int>>& pairs) {\\n        unordered_map<int, vector<int>> graph; \\n        unordered_map<int, int> degree;\\n        \\n        int start = 0; \\n        for (auto& edge : pairs) {\\n            graph[edge[0]].push_back(edge[1]); \\n            ++degree[edge[0]]; \\n            --degree[edge[1]]; \\n            start = edge[0]; \\n        }\\n        \\n        for (auto& [k, v] : degree) \\n            if (v == 1) start = k; \\n        \\n        vector<int> path; \\n        stack<int> stk; stk.push(start); \\n        while (stk.size()) {\\n            while (graph[stk.top()].size()) {\\n                int x = stk.top(); \\n                stk.push(graph[x].back()); \\n                graph[x].pop_back(); \\n            }\\n            path.push_back(stk.top()); stk.pop(); \\n        }\\n        reverse(path.begin(), path.end()); \\n        vector<vector<int>> ans; \\n        for (int i = 0; i < path.size()-1; ++i) ans.push_back({path[i], path[i+1]}); \\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> validArrangement(vector<vector<int>>& pairs) {\\n        unordered_map<int, vector<int>> graph; \\n        unordered_map<int, int> degree;\\n        \\n        int start = 0; \\n        for (auto& edge : pairs) {\\n            graph[edge[0]].push_back(edge[1]); \\n            ++degree[edge[0]]; \\n            --degree[edge[1]]; \\n            start = edge[0]; \\n        }\\n        \\n        for (auto& [k, v] : degree) \\n            if (v == 1) start = k; \\n        \\n        vector<int> path; \\n        stack<int> stk; stk.push(start); \\n        while (stk.size()) {\\n            while (graph[stk.top()].size()) {\\n                int x = stk.top(); \\n                stk.push(graph[x].back()); \\n                graph[x].pop_back(); \\n            }\\n            path.push_back(stk.top()); stk.pop(); \\n        }\\n        reverse(path.begin(), path.end()); \\n        vector<vector<int>> ans; \\n        for (int i = 0; i < path.size()-1; ++i) ans.push_back({path[i], path[i+1]}); \\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1612387,
                "title": "python3-hierholzer-s-algorithm",
                "content": "```\\n    def validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\\n        def dfs(u):\\n            while adjacent[u]:\\n                v = adjacent[u].pop()\\n                dfs(v)                \\n                ans.append([u, v])\\n                            \\n        adjacent = defaultdict(lambda: [])\\n        degree = defaultdict(lambda: 0)\\n        \\n        for (u, v) in pairs: \\n            adjacent[u].append(v)\\n            degree[u] += 1\\n            degree[v] -= 1\\n            \\n        start = pairs[0][0]\\n        for u in degree: \\n            if degree[u] == 1: \\n                start = u\\n                break\\n           \\n        ans = []\\n        \\n        dfs(start)\\n        \\n        return ans[::-1]\\n```",
                "solutionTags": [],
                "code": "```\\n    def validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\\n        def dfs(u):\\n            while adjacent[u]:\\n                v = adjacent[u].pop()\\n                dfs(v)                \\n                ans.append([u, v])\\n                            \\n        adjacent = defaultdict(lambda: [])\\n        degree = defaultdict(lambda: 0)\\n        \\n        for (u, v) in pairs: \\n            adjacent[u].append(v)\\n            degree[u] += 1\\n            degree[v] -= 1\\n            \\n        start = pairs[0][0]\\n        for u in degree: \\n            if degree[u] == 1: \\n                start = u\\n                break\\n           \\n        ans = []\\n        \\n        dfs(start)\\n        \\n        return ans[::-1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4073240,
                "title": "c-that-was-so-difficult",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nIn the end I had to admin I couldn\\'t fully understand how this Hierholzer\\'s algorithm works. Don\\'t know how, but it works. What I found is :\\n\\n- Start node must have 1 more outbound edges than inbound edges\\n- End node must have 1 less outbound edges than inbound edges\\n\\n(Unless it\\'s a fully cycle graph - in which case, any node can be started or ended)\\n\\nAnd then this algorithm tries to find the \"end node\" using DFS, removing the paths as it goes. After finding the \"end node\" it still tries to find the \"next end node\", pushing it to the queue.\\n\\nFinally you can walk backword to build the path. \\nWhy?!! My own algorithms building a full path at one DFS worked well with a few hundreds of pairs but reached timeout with larger samples. But this Hier...something, works magically well\\n\\n# Code\\n```\\n// -----------------------------------------------\\n// EDGE\\n// -----------------------------------------------\\nstruct Edge {\\n    Edge(const int _fromNodeId, const int _toNodeId) :\\n        fromNodeId(_fromNodeId), toNodeId(_toNodeId) {}\\n    Edge(const Edge& other) :\\n        fromNodeId(other.fromNodeId), toNodeId(other.toNodeId) {}\\n    const int fromNodeId;\\n    const int toNodeId;\\n};\\n\\n// -----------------------------------------------\\n// NODE\\n// -----------------------------------------------\\nclass Node {\\npublic:\\n    Node(const int _id) : id(_id) {}\\n    void AddEdge(const Edge& edge) {\\n        if (edge.fromNodeId == id) {\\n            outEdges.push_back(edge);\\n        } else if (edge.toNodeId ==id) {\\n            inEdges.push_back(edge);\\n        } else {\\n            printf(\"[ERROR] node id %d, got an edge [%d,%d]\\\\n\", id, edge.fromNodeId, edge.toNodeId);\\n        }\\n    }\\n    inline bool IsStartNode() const {\\n        return outEdges.size() == inEdges.size() + 1;\\n    }\\n\\n    inline int GetId() const {\\n        return id;\\n    }\\n    \\n    inline Edge PopOutEdge() {\\n        auto edge = outEdges.back();\\n        outEdges.pop_back();\\n        return edge;\\n    }\\n\\n    inline bool IsOutEdgeEmpty() const {\\n        return outEdges.empty();\\n    }\\n\\nprivate:\\n    const int id;\\n    vector<Edge> outEdges;\\n    vector<Edge> inEdges;\\n};\\n\\n// -----------------------------------------------\\n// DATA CONTAINER\\n// -----------------------------------------------\\nclass DataContainer {\\npublic:\\n    void AddEdge(const int from, const int to);\\n    int PickStartNode() const;\\n\\n    const shared_ptr<Node>& GetNode(const int id) const {\\n        auto ite = nodes.find(id);\\n        if (ite == nodes.end()) {\\n            printf(\"[ERROR] Could not find node %d\\\\n\", id);\\n        }\\n        return ite->second;\\n    }\\n\\nprivate:\\n    map<int, shared_ptr<Node>> nodes;\\n\\n    shared_ptr<Node> CreateOrGetNode(const int nodeId) {\\n        auto ite = nodes.find(nodeId);\\n        if (ite != nodes.end()) {\\n            return ite->second;\\n        }\\n        auto& node = nodes[nodeId] = make_shared<Node>(nodeId);\\n        return node;\\n    }\\n};\\n\\nvoid DataContainer::AddEdge(const int from, const int to) {\\n    const auto& fromNode = CreateOrGetNode(from);\\n    const auto& toNode = CreateOrGetNode(to);\\n    const Edge edge(fromNode->GetId(), toNode->GetId());\\n    fromNode->AddEdge(edge);\\n    toNode->AddEdge(edge);\\n}\\n\\nint DataContainer::PickStartNode() const {\\n    constexpr int NO_NODE = -1;\\n    int startNode = NO_NODE;\\n    for (const auto&[nodeId, node] : nodes) {\\n        if (node->IsStartNode()) {\\n            if (startNode != NO_NODE) {\\n                printf(\"[ERROR] There are multiple start node, at %d th and %d th\\\\n\", startNode, node->GetId());\\n            }\\n            startNode = nodeId;\\n        }\\n    }\\n    if (startNode == NO_NODE) {\\n        return nodes.begin()->first; // In this case, it\\'s a circular graph, any node should do the work\\n    }\\n    return startNode;\\n}\\n\\n// -----------------------------------------------\\n// Solution - DFS\\n// -----------------------------------------------\\nclass Solution {\\npublic:\\n    vector<vector<int>> validArrangement(vector<vector<int>>& pairs) {\\n        // Build data\\n        for (const auto& pair : pairs) {\\n            data.AddEdge(pair.front(), pair.back());\\n        }\\n        \\n        // DFS\\n        solveInternal(data.PickStartNode());\\n\\n        // Now build the path\\n        vector<vector<int>> answer;\\n        answer.reserve(pairs.size());\\n\\n        for (int i = 0; i < (int)leafNodeIds.size() - 1; i ++) {\\n            answer.push_back(vector<int> {leafNodeIds[i], leafNodeIds[i + 1]});\\n        }\\n        return answer;\\n    }\\n\\n    void solveInternal(int nodeId) {\\n        const auto& node = data.GetNode(nodeId);\\n\\n        while (!node->IsOutEdgeEmpty()) {\\n            const auto& edge { node->PopOutEdge() };\\n            solveInternal(edge.toNodeId);\\n        }\\n\\n        leafNodeIds.push_front(nodeId);\\n    }\\n\\nprivate:\\n    deque<int> leafNodeIds;\\n    DataContainer data;\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n// -----------------------------------------------\\n// EDGE\\n// -----------------------------------------------\\nstruct Edge {\\n    Edge(const int _fromNodeId, const int _toNodeId) :\\n        fromNodeId(_fromNodeId), toNodeId(_toNodeId) {}\\n    Edge(const Edge& other) :\\n        fromNodeId(other.fromNodeId), toNodeId(other.toNodeId) {}\\n    const int fromNodeId;\\n    const int toNodeId;\\n};\\n\\n// -----------------------------------------------\\n// NODE\\n// -----------------------------------------------\\nclass Node {\\npublic:\\n    Node(const int _id) : id(_id) {}\\n    void AddEdge(const Edge& edge) {\\n        if (edge.fromNodeId == id) {\\n            outEdges.push_back(edge);\\n        } else if (edge.toNodeId ==id) {\\n            inEdges.push_back(edge);\\n        } else {\\n            printf(\"[ERROR] node id %d, got an edge [%d,%d]\\\\n\", id, edge.fromNodeId, edge.toNodeId);\\n        }\\n    }\\n    inline bool IsStartNode() const {\\n        return outEdges.size() == inEdges.size() + 1;\\n    }\\n\\n    inline int GetId() const {\\n        return id;\\n    }\\n    \\n    inline Edge PopOutEdge() {\\n        auto edge = outEdges.back();\\n        outEdges.pop_back();\\n        return edge;\\n    }\\n\\n    inline bool IsOutEdgeEmpty() const {\\n        return outEdges.empty();\\n    }\\n\\nprivate:\\n    const int id;\\n    vector<Edge> outEdges;\\n    vector<Edge> inEdges;\\n};\\n\\n// -----------------------------------------------\\n// DATA CONTAINER\\n// -----------------------------------------------\\nclass DataContainer {\\npublic:\\n    void AddEdge(const int from, const int to);\\n    int PickStartNode() const;\\n\\n    const shared_ptr<Node>& GetNode(const int id) const {\\n        auto ite = nodes.find(id);\\n        if (ite == nodes.end()) {\\n            printf(\"[ERROR] Could not find node %d\\\\n\", id);\\n        }\\n        return ite->second;\\n    }\\n\\nprivate:\\n    map<int, shared_ptr<Node>> nodes;\\n\\n    shared_ptr<Node> CreateOrGetNode(const int nodeId) {\\n        auto ite = nodes.find(nodeId);\\n        if (ite != nodes.end()) {\\n            return ite->second;\\n        }\\n        auto& node = nodes[nodeId] = make_shared<Node>(nodeId);\\n        return node;\\n    }\\n};\\n\\nvoid DataContainer::AddEdge(const int from, const int to) {\\n    const auto& fromNode = CreateOrGetNode(from);\\n    const auto& toNode = CreateOrGetNode(to);\\n    const Edge edge(fromNode->GetId(), toNode->GetId());\\n    fromNode->AddEdge(edge);\\n    toNode->AddEdge(edge);\\n}\\n\\nint DataContainer::PickStartNode() const {\\n    constexpr int NO_NODE = -1;\\n    int startNode = NO_NODE;\\n    for (const auto&[nodeId, node] : nodes) {\\n        if (node->IsStartNode()) {\\n            if (startNode != NO_NODE) {\\n                printf(\"[ERROR] There are multiple start node, at %d th and %d th\\\\n\", startNode, node->GetId());\\n            }\\n            startNode = nodeId;\\n        }\\n    }\\n    if (startNode == NO_NODE) {\\n        return nodes.begin()->first; // In this case, it\\'s a circular graph, any node should do the work\\n    }\\n    return startNode;\\n}\\n\\n// -----------------------------------------------\\n// Solution - DFS\\n// -----------------------------------------------\\nclass Solution {\\npublic:\\n    vector<vector<int>> validArrangement(vector<vector<int>>& pairs) {\\n        // Build data\\n        for (const auto& pair : pairs) {\\n            data.AddEdge(pair.front(), pair.back());\\n        }\\n        \\n        // DFS\\n        solveInternal(data.PickStartNode());\\n\\n        // Now build the path\\n        vector<vector<int>> answer;\\n        answer.reserve(pairs.size());\\n\\n        for (int i = 0; i < (int)leafNodeIds.size() - 1; i ++) {\\n            answer.push_back(vector<int> {leafNodeIds[i], leafNodeIds[i + 1]});\\n        }\\n        return answer;\\n    }\\n\\n    void solveInternal(int nodeId) {\\n        const auto& node = data.GetNode(nodeId);\\n\\n        while (!node->IsOutEdgeEmpty()) {\\n            const auto& edge { node->PopOutEdge() };\\n            solveInternal(edge.toNodeId);\\n        }\\n\\n        leafNodeIds.push_front(nodeId);\\n    }\\n\\nprivate:\\n    deque<int> leafNodeIds;\\n    DataContainer data;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4057080,
                "title": "c-euler-path-dfs-hierholzer-s-algorithm-beats-94-74",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n$$That\\'s Euler\\'s path problem, probably for finding path. There exists an Eulerian path \\u2005\\u200A\\u27FA\\u2005\\u200A\\\\iff\\nThe initial v0v_0v \\n0\\n\\u200B\\n  must have indeg(v0)+1=outdeg(v0)indeg(v_0)+1=outdeg(v_0)indeg(v \\n0\\n\\u200B\\n )+1=outdeg(v \\n0\\n\\u200B\\n ) or indeg(v0)=outdeg(v0)indeg(v_0)=outdeg(v_0)indeg(v \\n0\\n\\u200B\\n )=outdeg(v \\n0\\n\\u200B\\n ) (if an Euler cycle) the terminal vertex vn\\u22121v_{n-1}v \\nn\\u22121\\n\\u200B\\n  has indeg(vn\\u22121)=outdeg(vn\\u22121)+1indeg(v_{n-1})=outdeg(v_{n-1})+1indeg(v \\nn\\u22121\\n\\u200B\\n )=outdeg(v \\nn\\u22121\\n\\u200B\\n )+1 or indeg(vn\\u22121)=outdeg(vn\\u22121)indeg(v_{n-1})=outdeg(v_{n-1})indeg(v \\nn\\u22121\\n\\u200B\\n )=outdeg(v \\nn\\u22121\\n\\u200B\\n ) (if an Euler cycle v0=vn\\u22121v_0=v_{n-1}v \\n0\\n\\u200B\\n =v \\nn\\u22121\\n\\u200B\\n )\\nFor other vertex viv_iv \\ni\\n\\u200B\\n  has indeg(vi)=outdeg(vi)indeg(v_i)=outdeg(v_i)indeg(v \\ni\\n\\u200B\\n )=outdeg(v \\ni\\n\\u200B\\n )\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHierholzer\\u2019s algorithm.\\nVery standard version needs a stack. Instead of a stack, the solution uses just a vector, since C++ vector can acts as a stack by push_back and pop_back!\\n\\nFor the huge numbers due to constraint 0 <= start_i, end_i <= 10^9, it is almost impossible to use an array, the hash table must be used.\\n# Complexity$$O(V+E)$$\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- Space complexity:$$O(V+E)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> validArrangement(vector<vector<int>>& pairs) {\\n        int n = pairs.size();\\n        unordered_map<int,vector<int>> adj;\\n        unordered_map<int,int> ind;\\n        for(auto ed:pairs){\\n            adj[ed[0]].push_back(ed[1]);\\n            adj[ed[1]].size();\\n            ind[ed[1]]++;\\n        }\\n        vector<int> st;\\n        bool flag=true;\\n        int u1 = -1, u2 = -1;\\n        for(auto it: adj){\\n            int ou = it.second.size();\\n            int in = ind[it.first];\\n            if(ou-in==1) u1 = it.first;\\n            else if(in-ou==1) u2=it.first;\\n        }\\n        if(u1!=-1){\\n            adj[u2].push_back(u1);\\n        }\\n        vector<int> ans;\\n        int c = pairs[0][0];\\n        st.push_back(c);\\n        while(!st.empty()){\\n            int cc = st.back();\\n            if(adj[cc].size()>0){\\n                st.push_back(adj[cc].back());\\n                adj[cc].pop_back();\\n            }\\n            else{\\n                st.pop_back();\\n                ans.push_back(cc);\\n            }\\n        }\\n        reverse(ans.begin(),ans.end());\\n        if(u1!=-1)\\n            ans.pop_back();\\n        int stt = 0;\\n        if(u1!=-1){\\n            for(int i=0; i<ans.size()-1; ++i){\\n                if(ans[i]==u2 && ans[i+1]==u1){\\n                    stt = i+1;\\n                }\\n            }\\n        }\\n        vector<int> fans;\\n        for(int i=stt; i<ans.size(); ++i){\\n            fans.push_back(ans[i]);\\n        }\\n        for(int i=0; i<stt; ++i){\\n            fans.push_back(ans[i]);\\n        }\\n        for(auto i:fans) cout<<i<<\" \";\\n        cout<<endl;\\n        cout<<stt;\\n        vector<vector<int>> ffans;\\n        for(int i=0; i<ans.size()-1; ++i){\\n            ffans.push_back({fans[i],fans[i+1]});\\n        }\\n        return ffans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Eulerian Circuit"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> validArrangement(vector<vector<int>>& pairs) {\\n        int n = pairs.size();\\n        unordered_map<int,vector<int>> adj;\\n        unordered_map<int,int> ind;\\n        for(auto ed:pairs){\\n            adj[ed[0]].push_back(ed[1]);\\n            adj[ed[1]].size();\\n            ind[ed[1]]++;\\n        }\\n        vector<int> st;\\n        bool flag=true;\\n        int u1 = -1, u2 = -1;\\n        for(auto it: adj){\\n            int ou = it.second.size();\\n            int in = ind[it.first];\\n            if(ou-in==1) u1 = it.first;\\n            else if(in-ou==1) u2=it.first;\\n        }\\n        if(u1!=-1){\\n            adj[u2].push_back(u1);\\n        }\\n        vector<int> ans;\\n        int c = pairs[0][0];\\n        st.push_back(c);\\n        while(!st.empty()){\\n            int cc = st.back();\\n            if(adj[cc].size()>0){\\n                st.push_back(adj[cc].back());\\n                adj[cc].pop_back();\\n            }\\n            else{\\n                st.pop_back();\\n                ans.push_back(cc);\\n            }\\n        }\\n        reverse(ans.begin(),ans.end());\\n        if(u1!=-1)\\n            ans.pop_back();\\n        int stt = 0;\\n        if(u1!=-1){\\n            for(int i=0; i<ans.size()-1; ++i){\\n                if(ans[i]==u2 && ans[i+1]==u1){\\n                    stt = i+1;\\n                }\\n            }\\n        }\\n        vector<int> fans;\\n        for(int i=stt; i<ans.size(); ++i){\\n            fans.push_back(ans[i]);\\n        }\\n        for(int i=0; i<stt; ++i){\\n            fans.push_back(ans[i]);\\n        }\\n        for(auto i:fans) cout<<i<<\" \";\\n        cout<<endl;\\n        cout<<stt;\\n        vector<vector<int>> ffans;\\n        for(int i=0; i<ans.size()-1; ++i){\\n            ffans.push_back({fans[i],fans[i+1]});\\n        }\\n        return ffans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 4049227,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution \\n{\\npublic:\\n    void dfs(unordered_map<int,vector<int>> &mp,int &x,vector<int> &temp)\\n    {\\n        while(!mp[x].empty())\\n        {\\n            int next;\\n            next=mp[x].back();\\n\\n            mp[x].pop_back();\\n            dfs(mp,next,temp);\\n        }\\n\\n        temp.push_back(x);\\n    }\\n\\n    vector<vector<int>> validArrangement(vector<vector<int>>& pairs) \\n    {\\n        unordered_map<int,int> deg;\\n        unordered_map<int,vector<int>> mp;\\n        vector<int> temp;\\n        vector<vector<int>> ans;\\n\\n        for(int i=0;i<pairs.size();i++)\\n        {\\n            deg[pairs[i][0]]++;\\n            deg[pairs[i][1]]--;\\n            mp[pairs[i][0]].push_back(pairs[i][1]);\\n        }        \\n\\n        for(int i=0;i<pairs.size();i++)\\n        {\\n            if(deg[pairs[i][0]]==1)\\n            {\\n                dfs(mp,pairs[i][0],temp);\\n                break;\\n            }\\n\\n            if(deg[pairs[i][1]]==1)\\n            {\\n                dfs(mp,pairs[i][1],temp);\\n                break;\\n            }\\n        }\\n\\n        if(temp.empty())\\n        {\\n            dfs(mp,pairs[0][0],temp);\\n        }\\n\\n        reverse(temp.begin(),temp.end());\\n        for(int i=0;i<temp.size()-1;i++)\\n        {\\n            ans.push_back({temp[i],temp[i+1]});\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    void dfs(unordered_map<int,vector<int>> &mp,int &x,vector<int> &temp)\\n    {\\n        while(!mp[x].empty())\\n        {\\n            int next;\\n            next=mp[x].back();\\n\\n            mp[x].pop_back();\\n            dfs(mp,next,temp);\\n        }\\n\\n        temp.push_back(x);\\n    }\\n\\n    vector<vector<int>> validArrangement(vector<vector<int>>& pairs) \\n    {\\n        unordered_map<int,int> deg;\\n        unordered_map<int,vector<int>> mp;\\n        vector<int> temp;\\n        vector<vector<int>> ans;\\n\\n        for(int i=0;i<pairs.size();i++)\\n        {\\n            deg[pairs[i][0]]++;\\n            deg[pairs[i][1]]--;\\n            mp[pairs[i][0]].push_back(pairs[i][1]);\\n        }        \\n\\n        for(int i=0;i<pairs.size();i++)\\n        {\\n            if(deg[pairs[i][0]]==1)\\n            {\\n                dfs(mp,pairs[i][0],temp);\\n                break;\\n            }\\n\\n            if(deg[pairs[i][1]]==1)\\n            {\\n                dfs(mp,pairs[i][1],temp);\\n                break;\\n            }\\n        }\\n\\n        if(temp.empty())\\n        {\\n            dfs(mp,pairs[0][0],temp);\\n        }\\n\\n        reverse(temp.begin(),temp.end());\\n        for(int i=0;i<temp.size()-1;i++)\\n        {\\n            ans.push_back({temp[i],temp[i+1]});\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4045505,
                "title": "c-recursive-heirholzer-s-algorithm",
                "content": "# Approach \\n\\nWe use the degree of nodes to select the starting point i.e. if a node has negative degree means it has more outgoing edges so we can start from it, otherwise since every node will have equal outgoing and incoming edges, we can start from any node. After the node has been selected we simply perform DFS (Heirholzer\\'s Algorithm).\\n\\n# Complexity\\n- Time complexity: $$O(V + E)$$\\n\\n- Space complexity: $$O(V + E)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    void dfs(int node, int prev, unordered_map<int, vector<int>>& adj, vector<vector<int>>& ans){\\n        while(adj[node].size()){\\n            int i = adj[node].back();\\n            adj[node].pop_back();\\n            dfs(i, node, adj, ans);\\n        }\\n        ans.push_back({prev, node});\\n    }\\n\\n    vector<vector<int>> validArrangement(vector<vector<int>>& pairs) {\\n        unordered_map<int, vector<int>> adj;\\n        unordered_map<int, int> indegree;\\n        for(auto&i:pairs){\\n            adj[i[0]].push_back(i[1]);\\n            indegree[i[0]]--;\\n            indegree[i[1]]++;\\n        }\\n        vector<vector<int>> ans;\\n        bool flag = false;\\n        for(auto&[f, s]:indegree){\\n            if(s < 0){\\n                flag = true;\\n                dfs(f, -1, adj, ans);\\n                break;\\n            }\\n        }\\n        if(!flag) dfs(pairs[0][0], -1, adj, ans);\\n        ans.pop_back();\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Depth-First Search",
                    "Graph",
                    "Eulerian Circuit"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    void dfs(int node, int prev, unordered_map<int, vector<int>>& adj, vector<vector<int>>& ans){\\n        while(adj[node].size()){\\n            int i = adj[node].back();\\n            adj[node].pop_back();\\n            dfs(i, node, adj, ans);\\n        }\\n        ans.push_back({prev, node});\\n    }\\n\\n    vector<vector<int>> validArrangement(vector<vector<int>>& pairs) {\\n        unordered_map<int, vector<int>> adj;\\n        unordered_map<int, int> indegree;\\n        for(auto&i:pairs){\\n            adj[i[0]].push_back(i[1]);\\n            indegree[i[0]]--;\\n            indegree[i[1]]++;\\n        }\\n        vector<vector<int>> ans;\\n        bool flag = false;\\n        for(auto&[f, s]:indegree){\\n            if(s < 0){\\n                flag = true;\\n                dfs(f, -1, adj, ans);\\n                break;\\n            }\\n        }\\n        if(!flag) dfs(pairs[0][0], -1, adj, ans);\\n        ans.pop_back();\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4044882,
                "title": "tried-2-methods-to-solve-using-algorithm-and-without-using-algorithm",
                "content": "## Code 1 (TLE)\\n\\nTried out the concept in this question [332. Reconstruct Itinerary](https://leetcode.com/problems/reconstruct-itinerary/description/) to solve this problem. But got TLE although it did pass some testcases.\\n\\n```\\nclass Solution:\\n    def validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\\n        def findDFS():\\n            adj = { src : [] for src, dest in pairs }\\n            n = len(pairs)\\n            for src, des in pairs:\\n                adj[src].append(des)\\n            def dfs(src):\\n                if len(res) == n:\\n                    return True\\n                if src not in adj:\\n                    return False\\n                temp = list(adj[src])\\n                for i,des in enumerate(temp):\\n                    res.append([ src, des ])\\n                    adj[src].pop(i)\\n                    if dfs(des): return True\\n                    res.remove([ src, des ])\\n                    adj[src].insert(i, des)\\n                return False\\n\\n            for src, des in pairs:\\n                res = []\\n                if src in adj and dfs(src): return res\\n        return findDFS()\\n\\n```\\n\\n## Code 2 (Solved using Hierholzer\\'s Algorithm - Accepted)\\n\\n```\\nimport collections\\nclass Solution:\\n    def validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\\n        graph = defaultdict(list)\\n        degree = defaultdict(int)\\n        for src, des in pairs:\\n            graph[src].append(des)\\n            degree[src] += 1\\n            degree[des] -= 1\\n\\n        # In Line 12 we find out the pendent vertex to start the Euler path \\n        for start in degree:\\n            if degree[start]==1:\\n                break\\n\\n        # Line 19 onwards, we visit each node and try to traverse any circuits \\n        # that start and end at that node, the proceed to the other cicuits arising \\n        # from that node or move to the next node and thus do the DFS procedure.\\n        res = []\\n        def dfs(node):\\n            while graph[node]:\\n                child = graph[node].pop()\\n                dfs(child)\\n            res.append(node)\\n        dfs(start)\\n        res.reverse()\\n        return [[res[i],res[i+1]] for i in range(len(res)-1)]\\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\\n        def findDFS():\\n            adj = { src : [] for src, dest in pairs }\\n            n = len(pairs)\\n            for src, des in pairs:\\n                adj[src].append(des)\\n            def dfs(src):\\n                if len(res) == n:\\n                    return True\\n                if src not in adj:\\n                    return False\\n                temp = list(adj[src])\\n                for i,des in enumerate(temp):\\n                    res.append([ src, des ])\\n                    adj[src].pop(i)\\n                    if dfs(des): return True\\n                    res.remove([ src, des ])\\n                    adj[src].insert(i, des)\\n                return False\\n\\n            for src, des in pairs:\\n                res = []\\n                if src in adj and dfs(src): return res\\n        return findDFS()\\n\\n```\n```\\nimport collections\\nclass Solution:\\n    def validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\\n        graph = defaultdict(list)\\n        degree = defaultdict(int)\\n        for src, des in pairs:\\n            graph[src].append(des)\\n            degree[src] += 1\\n            degree[des] -= 1\\n\\n        # In Line 12 we find out the pendent vertex to start the Euler path \\n        for start in degree:\\n            if degree[start]==1:\\n                break\\n\\n        # Line 19 onwards, we visit each node and try to traverse any circuits \\n        # that start and end at that node, the proceed to the other cicuits arising \\n        # from that node or move to the next node and thus do the DFS procedure.\\n        res = []\\n        def dfs(node):\\n            while graph[node]:\\n                child = graph[node].pop()\\n                dfs(child)\\n            res.append(node)\\n        dfs(start)\\n        res.reverse()\\n        return [[res[i],res[i+1]] for i in range(len(res)-1)]\\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4044000,
                "title": "c-eulerian-path-same-as-332-reconstruct-itinerary",
                "content": "This problem demands just finding a valid Eulerian path. Valid Eulerian path means either all nodes\\' indegree and outdegree values are equal (**Euler circuit**) or it is true for all nodes except 2 nodes where 1 node\\'s outdegree value is 1 more than its indegree value and we should start our dfs traversal with this node. \\n\\n```\\nclass Solution {\\npublic:\\n    unordered_map<int, multiset<int>> graph;\\n    vector<vector<int>> ans;\\n    \\n    void dfs(int num) {\\n        auto &st=graph[num];\\n        while(!st.empty()) {\\n            int x=*st.begin();\\n            st.erase(st.begin());\\n            dfs(x);\\n            ans.push_back({num, x});\\n        }\\n    }\\n    \\n    vector<vector<int>> validArrangement(vector<vector<int>>& pairs) {\\n        unordered_map<int, int> a, b;\\n        for(auto it: pairs) {\\n            graph[it[0]].insert(it[1]);\\n            a[it[0]]++;\\n            b[it[1]]++;\\n        }\\n        int k=-1;\\n        for(auto it: a) {\\n            int x=it.first;\\n            if(a[x]>b[x]) {\\n                k=x;\\n                break;\\n            }\\n        }\\n        \\n        (k!=-1) ? dfs(k) : dfs(pairs[0][0]);\\n        \\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<int, multiset<int>> graph;\\n    vector<vector<int>> ans;\\n    \\n    void dfs(int num) {\\n        auto &st=graph[num];\\n        while(!st.empty()) {\\n            int x=*st.begin();\\n            st.erase(st.begin());\\n            dfs(x);\\n            ans.push_back({num, x});\\n        }\\n    }\\n    \\n    vector<vector<int>> validArrangement(vector<vector<int>>& pairs) {\\n        unordered_map<int, int> a, b;\\n        for(auto it: pairs) {\\n            graph[it[0]].insert(it[1]);\\n            a[it[0]]++;\\n            b[it[1]]++;\\n        }\\n        int k=-1;\\n        for(auto it: a) {\\n            int x=it.first;\\n            if(a[x]>b[x]) {\\n                k=x;\\n                break;\\n            }\\n        }\\n        \\n        (k!=-1) ? dfs(k) : dfs(pairs[0][0]);\\n        \\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3972614,
                "title": "solution-using-eulerian-path-graph",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSince we have to arrange the pairs such that the ending of (i-1)th pair is the start of ith pair, and also we have to include all the given pairs, this can be achieved by performing a **Eulerian Path** traversal of the graph formed by the pairs.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThink of every value in the pairs as a node in a graph. For every pair {u,v}, add a directed edge from u to v in the graph.\\n\\nAlso calculate the indegree and outdegree of the all the nodes.\\n\\nFind out the starting node `start` (the node which has outdegree-indegree = 1 (or 0 in case of Eulerian Circuit)), which always exists under the given constraints.\\n\\nPerform a dfs starting from `start`. When no further outgoing edges are left unvisited, we backtrack to the last node having unvisited outgoing edges and at each stage we add the edge to out `ans`. \\n\\nFinally, reverse `ans` and return it.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    void dfs(int u, unordered_map<int,int> &out, unordered_map<int,vector<int>> &adj, vector<vector<int>>& ans){\\n        while(out[u]){\\n            int v = adj[u][--out[u]];\\n            dfs(v, out, adj, ans);\\n            ans.push_back({u,v});\\n        }\\n    }\\npublic:\\n    vector<vector<int>> validArrangement(vector<vector<int>>& edges) {\\n        int m=edges.size();\\n        unordered_map<int,vector<int>> adj;\\n        unordered_map<int,int> in, out;\\n        for(auto &edge:edges){\\n            int u=edge[0], v=edge[1];\\n            adj[u].push_back(v);\\n            out[u]++;\\n            in[v]++;\\n        }\\n        int start=-1;\\n        for(auto &p:adj){\\n            if(out[p.first]-in[p.first]==1){\\n                start=p.first;\\n                break;\\n            }else if(out[p.first]>0) start=p.first;\\n        }\\n        vector<vector<int>> ans;\\n        dfs(start, out, adj, ans);\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph",
                    "Eulerian Circuit"
                ],
                "code": "```\\nclass Solution {\\n    void dfs(int u, unordered_map<int,int> &out, unordered_map<int,vector<int>> &adj, vector<vector<int>>& ans){\\n        while(out[u]){\\n            int v = adj[u][--out[u]];\\n            dfs(v, out, adj, ans);\\n            ans.push_back({u,v});\\n        }\\n    }\\npublic:\\n    vector<vector<int>> validArrangement(vector<vector<int>>& edges) {\\n        int m=edges.size();\\n        unordered_map<int,vector<int>> adj;\\n        unordered_map<int,int> in, out;\\n        for(auto &edge:edges){\\n            int u=edge[0], v=edge[1];\\n            adj[u].push_back(v);\\n            out[u]++;\\n            in[v]++;\\n        }\\n        int start=-1;\\n        for(auto &p:adj){\\n            if(out[p.first]-in[p.first]==1){\\n                start=p.first;\\n                break;\\n            }else if(out[p.first]>0) start=p.first;\\n        }\\n        vector<vector<int>> ans;\\n        dfs(start, out, adj, ans);\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3960944,
                "title": "eulerian-path-c",
                "content": "basically its kind eulerian path where we have to visit each edge only once so what we do here first store the adjcanecy in a map of int and pq and now we do simple dfs to visit all the childs and pop them one by one to get the path \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n void dfs(int node,map<int,priority_queue<int,vector<int>,greater<int>>> &m,vector<int> &ans){\\n     if(m.count(node)==0){\\n         ans.push_back(node);\\n         return;\\n     }\\n     auto &it=m[node];\\n     while(!it.empty()){\\n         int temp=it.top();\\n         it.pop();\\n         dfs(temp,m,ans);\\n     }\\n     ans.push_back(node);\\n }\\n\\n\\n\\n    vector<vector<int>> validArrangement(vector<vector<int>>& pairs) {\\n        map<int,int> indegree,outdegree,tot;\\n\\n        map<int,priority_queue<int,vector<int>,greater<int>>> m;\\n        for(int i=0; i<pairs.size(); i++){\\n            int x=pairs[i][0];\\n            int y=pairs[i][1];\\n            m[x].push(y);\\n            indegree[y]++;\\n            outdegree[x]++;\\n            tot[x]++;\\n            tot[y]++;\\n        }\\n        int node=-1;\\n        for(auto it:tot){\\n            if(outdegree[it.first]>indegree[it.first]){\\n                node=it.first;\\n                break;\\n            }\\n        }\\n        if(node==-1){\\n            for(auto it:tot){\\n             node=it.first;\\n             break;\\n        }\\n        }\\n\\n        cout<<node<<endl;\\n        vector<int> ans;\\n        dfs(node,m,ans);\\n        // for(auto it:ans){\\n        //     cout<<it<<\" \";\\n        // }\\n        vector<vector<int>> fans;\\n        reverse(ans.begin(),ans.end());\\n        for(int i=0; i<ans.size()-1; i++){\\n            fans.push_back({ans[i],ans[i+1]});\\n        }\\n\\n        return fans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Eulerian Circuit"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n void dfs(int node,map<int,priority_queue<int,vector<int>,greater<int>>> &m,vector<int> &ans){\\n     if(m.count(node)==0){\\n         ans.push_back(node);\\n         return;\\n     }\\n     auto &it=m[node];\\n     while(!it.empty()){\\n         int temp=it.top();\\n         it.pop();\\n         dfs(temp,m,ans);\\n     }\\n     ans.push_back(node);\\n }\\n\\n\\n\\n    vector<vector<int>> validArrangement(vector<vector<int>>& pairs) {\\n        map<int,int> indegree,outdegree,tot;\\n\\n        map<int,priority_queue<int,vector<int>,greater<int>>> m;\\n        for(int i=0; i<pairs.size(); i++){\\n            int x=pairs[i][0];\\n            int y=pairs[i][1];\\n            m[x].push(y);\\n            indegree[y]++;\\n            outdegree[x]++;\\n            tot[x]++;\\n            tot[y]++;\\n        }\\n        int node=-1;\\n        for(auto it:tot){\\n            if(outdegree[it.first]>indegree[it.first]){\\n                node=it.first;\\n                break;\\n            }\\n        }\\n        if(node==-1){\\n            for(auto it:tot){\\n             node=it.first;\\n             break;\\n        }\\n        }\\n\\n        cout<<node<<endl;\\n        vector<int> ans;\\n        dfs(node,m,ans);\\n        // for(auto it:ans){\\n        //     cout<<it<<\" \";\\n        // }\\n        vector<vector<int>> fans;\\n        reverse(ans.begin(),ans.end());\\n        for(int i=0; i<ans.size()-1; i++){\\n            fans.push_back({ans[i],ans[i+1]});\\n        }\\n\\n        return fans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3746391,
                "title": "python3-eulerian-path-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis is a pretty standard eulerian path problem. If you haven\\'t solved this type of problem, I recommend just googling that to get a gist of the idea. It is also very similar to leetcode #332.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe are given pairs, which are the connection between two nodes. This means we are given a list of **edges**.\\n\\nWe want to build an adjacency matrix the contains the neighbors of each node, stored in a queue. Then, we visit each node using recursion (or a stack if you want to do it iteratively). This effectively plays out the traversal as we travel along each edge.\\n\\nWith eulerian paths, there is the concept of **degrees**, which are either the inward connecting edges (in_degrees) or the outward connecting edges(out_degrees).\\n\\nTo find the start node, you need one of two things to be true:\\n1. out_degrees[i] == in_degrees[i] for every node i\\n2. out_degrees[i] == in_degrees[i] + 1 for exactly one node i\\n\\nIn the case of 1, any node can be the start. We pick [0][0] for simplicity.\\n\\nIn the case of 2, that node is your start node.\\n\\nAfter the traversal, we have to remember that we need to return pairs. An easy way to do this is just to pair each index of the result with index-1. But since I used recursion in my solution, we have to reverse the result first to be in the correct order.\\n\\n# Complexity\\n- Time complexity: O(n), where n is the amount of edges we are given\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(3n) = O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\\n        adjacencyMatrix = defaultdict(deque)\\n        in_degree = defaultdict(int)\\n        out_degree = defaultdict(int)\\n\\n        # Build the adjacencyMatrix\\n        # Keep track of the degrees so we can find the start node\\n        for start, end in pairs:\\n            adjacencyMatrix[start].append(end)\\n            out_degree[start] += 1\\n            in_degree[end] += 1\\n        \\n        # Now, have each node visit its neighbors\\n        self.result = []\\n        def visit(node):\\n            while adjacencyMatrix[node]:\\n                nextNode = adjacencyMatrix[node].popleft()\\n                visit(nextNode)\\n            self.result.append(node)\\n\\n        # Find the node where out == in + 1\\n        # Standard method of finding start in eulerian path\\n        start_node = None\\n        for node in adjacencyMatrix.keys():\\n            if out_degree[node] == in_degree[node] + 1:\\n                start_node = node\\n                break\\n\\n        if start_node == None:\\n            start_node = pairs[0][0]\\n\\n        visit(start_node)\\n\\n        # Reverse visit because recursion\\n        self.result = self.result[::-1]\\n\\n        # Convert to pairs\\n        paired_result = []\\n        for i in range(1, len(self.result)):\\n            paired_result.append([self.result[i-1], self.result[i]])\\n\\n        return paired_result\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\\n        adjacencyMatrix = defaultdict(deque)\\n        in_degree = defaultdict(int)\\n        out_degree = defaultdict(int)\\n\\n        # Build the adjacencyMatrix\\n        # Keep track of the degrees so we can find the start node\\n        for start, end in pairs:\\n            adjacencyMatrix[start].append(end)\\n            out_degree[start] += 1\\n            in_degree[end] += 1\\n        \\n        # Now, have each node visit its neighbors\\n        self.result = []\\n        def visit(node):\\n            while adjacencyMatrix[node]:\\n                nextNode = adjacencyMatrix[node].popleft()\\n                visit(nextNode)\\n            self.result.append(node)\\n\\n        # Find the node where out == in + 1\\n        # Standard method of finding start in eulerian path\\n        start_node = None\\n        for node in adjacencyMatrix.keys():\\n            if out_degree[node] == in_degree[node] + 1:\\n                start_node = node\\n                break\\n\\n        if start_node == None:\\n            start_node = pairs[0][0]\\n\\n        visit(start_node)\\n\\n        # Reverse visit because recursion\\n        self.result = self.result[::-1]\\n\\n        # Convert to pairs\\n        paired_result = []\\n        for i in range(1, len(self.result)):\\n            paired_result.append([self.result[i-1], self.result[i]])\\n\\n        return paired_result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3685843,
                "title": "98-18-98-18-in-both-speed-and-memory",
                "content": "# Approach\\n**Graph\\nDepth-First Search\\nEulerian Circuit\\nRecursion\\nHash Table\\nQueue\\nGreedy**\\n\\n# Code\\n```\\nfrom array import array\\nclass Solution:\\n    def validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\\n        graph = defaultdict(lambda: array(\\'I\\'))\\n        degree = defaultdict(int)\\n        for y, x in pairs:\\n            graph[x].append(y)\\n            degree[x] += 1\\n            degree[y] -= 1\\n        stack = array(\\'I\\', [next((k for k in graph if degree[k]==1), x)])\\n        while (l := graph[stack[-1]]):\\n            stack.append(l.pop())\\n        prev = stack.pop()\\n        while stack:\\n            while (l := graph[stack[-1]]):\\n                stack.append(l.pop())\\n            yield (prev, (prev := stack.pop()))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom array import array\\nclass Solution:\\n    def validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\\n        graph = defaultdict(lambda: array(\\'I\\'))\\n        degree = defaultdict(int)\\n        for y, x in pairs:\\n            graph[x].append(y)\\n            degree[x] += 1\\n            degree[y] -= 1\\n        stack = array(\\'I\\', [next((k for k in graph if degree[k]==1), x)])\\n        while (l := graph[stack[-1]]):\\n            stack.append(l.pop())\\n        prev = stack.pop()\\n        while stack:\\n            while (l := graph[stack[-1]]):\\n                stack.append(l.pop())\\n            yield (prev, (prev := stack.pop()))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3401720,
                "title": "typescript-solution",
                "content": "# Code\\n```\\nfunction validArrangement(pairs: number[][]): number[][] {\\n  const edgeCount: Map<number, number> = new Map<number, number>();\\n  const graph: Map<number, number[]> = new Map<number, number[]>();\\n  let result: number[] = [];\\n\\n  const search = (x: number) => {\\n    while (graph.has(x) && graph.get(x)?.length) {\\n      const y = graph.get(x)?.pop();\\n      if (y != null) {\\n        search(y);\\n      }\\n    }\\n\\n    result.push(x);\\n  };\\n\\n  pairs.forEach((pair, i) => {\\n    const [x, y] = pair;\\n    edgeCount.set(x, (edgeCount.get(x) || 0) + 1);\\n    edgeCount.set(y, (edgeCount.get(y) || 0) - 1);\\n\\n    if (graph.has(x)) {\\n      graph.get(x)?.push(y);\\n    } else {\\n      graph.set(x, [y]);\\n    }\\n  });\\n\\n  let start: number = pairs[0][0];\\n  [...edgeCount.keys()].forEach((num) => {\\n    const row = edgeCount.get(num);\\n    if (row != null && row === 1) {\\n      start = num;\\n    }\\n  });\\n\\n  search(start);\\n\\n  const reverse: number[][] = [];\\n  for (let i = result.length - 1; i >= 1; i -= 1) {\\n    reverse.push([result[i], result[i - 1]]);\\n  }\\n\\n  return reverse;\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction validArrangement(pairs: number[][]): number[][] {\\n  const edgeCount: Map<number, number> = new Map<number, number>();\\n  const graph: Map<number, number[]> = new Map<number, number[]>();\\n  let result: number[] = [];\\n\\n  const search = (x: number) => {\\n    while (graph.has(x) && graph.get(x)?.length) {\\n      const y = graph.get(x)?.pop();\\n      if (y != null) {\\n        search(y);\\n      }\\n    }\\n\\n    result.push(x);\\n  };\\n\\n  pairs.forEach((pair, i) => {\\n    const [x, y] = pair;\\n    edgeCount.set(x, (edgeCount.get(x) || 0) + 1);\\n    edgeCount.set(y, (edgeCount.get(y) || 0) - 1);\\n\\n    if (graph.has(x)) {\\n      graph.get(x)?.push(y);\\n    } else {\\n      graph.set(x, [y]);\\n    }\\n  });\\n\\n  let start: number = pairs[0][0];\\n  [...edgeCount.keys()].forEach((num) => {\\n    const row = edgeCount.get(num);\\n    if (row != null && row === 1) {\\n      start = num;\\n    }\\n  });\\n\\n  search(start);\\n\\n  const reverse: number[][] = [];\\n  for (let i = result.length - 1; i >= 1; i -= 1) {\\n    reverse.push([result[i], result[i - 1]]);\\n  }\\n\\n  return reverse;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3340265,
                "title": "solution-using-dijkstra-o-plogp",
                "content": "I did not know of Hierholzer so came up with another approach. It is less efficient but kinda funky and no solutions here have described it yet.\\n\\n# Intuition\\n\\nTLDR: Always pick the longest route to get to some end vertex that you\\'ve chosen.\\n\\nWe can represent the pairs as a graph, and we want to neatly travel each edge from some start vertex to some end vertex in one go. At some points, we\\'ll have to make a choice between two routes, e.g. the picture below.\\n\\n![graph.png](https://assets.leetcode.com/users/images/9c36606a-7270-45dd-92d3-4070a9db78aa_1679757041.977097.png)\\n\\nAt B, we can either go to C or E. If we pick C, we\\'ll go straight to the end node (D) and miss a bunch of edges. Therefore we want to pick E instead.\\n\\nThe way we can tell that E is the right choice is because the shortest path from E to D is longer than that from C to D, therefore we are less likely to miss edges.\\n\\nBecause we are guaranteed that there\\'s at least one valid solution, once we pick the start and end nodes we shouldn\\'t be able to make a wrong call.\\n\\n\\n# Approach\\nStep 1: pick the start node. This is the vertex that has fewer incoming than outgoing edges, or a random vertex if all vertices are balanced.\\n\\nStep 2: pick the end node. This is the opposite of Step 1.\\n\\nStep 3: Construct forward and backward versions of the graph. Use Dijkstra on the backward one to calculate the shortest path from each node to the end node.\\n\\nStep 4: Navigate the graph from the start node to end node, always choosing the neighbor with the largest distance given by the Dijkstra above.\\n\\nStep 5: Profit.\\n\\n# Complexity\\n- Time complexity: O(E + VlogV) for Dijkstra, then O(V+E) for constructing the graph, another worst case O(ElogE) for sorting the neighbours or each node once we\\'ve calculated the distances.\\n  \\n  For this problem, E=P and V<=P, so it boils down to O(PlogP) where P is the number of pairs.\\n\\n- Space complexity: O(P) to store the graphs and relevant data structures.\\n\\n# Code\\n```\\nclass Solution:\\n\\n    # simple Dijkstra\\n    def dijkstra(self, graph, start):\\n        distances = {}\\n        heap = [(0, start)]\\n\\n        while heap:\\n            dist, node = heappop(heap)\\n            if node in distances:\\n                continue\\n            distances[node] = dist\\n            for neighbor in graph[node]:\\n                if neighbor not in distances:\\n                    heappush(heap, (dist + 1, neighbor))\\n\\n        return distances\\n\\n\\n    def validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\\n        # Convert the pairs into and ajdacency list represented graph\\n        adj_list = defaultdict(list)\\n        reverse_adj_list = defaultdict(list)\\n        for s, e in pairs:\\n            adj_list[s].append(e)\\n            reverse_adj_list[e].append(s)\\n\\n        # Determine start and end values by counting the incoming and outgoing\\n        # edges of each vertex.\\n        start = pairs[0][0]\\n        end = None\\n        end_count = defaultdict(int)\\n        for s, e in pairs:\\n            end_count[e] += 1\\n            if e == start:\\n                # if the graph has no explicit start, the route should\\n                # end at the randomly picked starting point\\n                end = s\\n\\n        for k, l in adj_list.items():\\n            if len(l) > end_count[k]:\\n                # print(f\"start change to {k} because it has appeared as start of {l}  which is more times than as end {end_count[k]}\")\\n                start = k\\n                break\\n        \\n        for k, count in end_count.items():\\n            if len(adj_list[k]) < count:\\n                # print(f\"end change to {k} because it has appeared as end {count} times which is more than the start of {adj_list[k]}\")\\n                end = k\\n                break\\n\\n        # dijkstra calculating the distance from end to all nodes\\n        distances = self.dijkstra(reverse_adj_list, end)\\n\\n\\n        # For each vertex, store the edges in an ascending order by distance to\\n        # the end node so that we can pop them off efficiently starting from largest\\n        for k in adj_list:\\n            adj_list[k].sort(key=lambda e: distances[e])\\n\\n        # Now simply navigate the graph from the start node by always taking the\\n        # route that will take longer to the end\\n        r = []\\n        curr = start\\n        for i in range(len(pairs)):\\n            nxt = adj_list[curr].pop()\\n\\n            r.append([curr, nxt])\\n            curr = nxt\\n\\n        return r\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n\\n    # simple Dijkstra\\n    def dijkstra(self, graph, start):\\n        distances = {}\\n        heap = [(0, start)]\\n\\n        while heap:\\n            dist, node = heappop(heap)\\n            if node in distances:\\n                continue\\n            distances[node] = dist\\n            for neighbor in graph[node]:\\n                if neighbor not in distances:\\n                    heappush(heap, (dist + 1, neighbor))\\n\\n        return distances\\n\\n\\n    def validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\\n        # Convert the pairs into and ajdacency list represented graph\\n        adj_list = defaultdict(list)\\n        reverse_adj_list = defaultdict(list)\\n        for s, e in pairs:\\n            adj_list[s].append(e)\\n            reverse_adj_list[e].append(s)\\n\\n        # Determine start and end values by counting the incoming and outgoing\\n        # edges of each vertex.\\n        start = pairs[0][0]\\n        end = None\\n        end_count = defaultdict(int)\\n        for s, e in pairs:\\n            end_count[e] += 1\\n            if e == start:\\n                # if the graph has no explicit start, the route should\\n                # end at the randomly picked starting point\\n                end = s\\n\\n        for k, l in adj_list.items():\\n            if len(l) > end_count[k]:\\n                # print(f\"start change to {k} because it has appeared as start of {l}  which is more times than as end {end_count[k]}\")\\n                start = k\\n                break\\n        \\n        for k, count in end_count.items():\\n            if len(adj_list[k]) < count:\\n                # print(f\"end change to {k} because it has appeared as end {count} times which is more than the start of {adj_list[k]}\")\\n                end = k\\n                break\\n\\n        # dijkstra calculating the distance from end to all nodes\\n        distances = self.dijkstra(reverse_adj_list, end)\\n\\n\\n        # For each vertex, store the edges in an ascending order by distance to\\n        # the end node so that we can pop them off efficiently starting from largest\\n        for k in adj_list:\\n            adj_list[k].sort(key=lambda e: distances[e])\\n\\n        # Now simply navigate the graph from the start node by always taking the\\n        # route that will take longer to the end\\n        r = []\\n        curr = start\\n        for i in range(len(pairs)):\\n            nxt = adj_list[curr].pop()\\n\\n            r.append([curr, nxt])\\n            curr = nxt\\n\\n        return r\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3313785,
                "title": "js-beats-100-commented",
                "content": "Very similar to [Reconstruct Itinerary](https://leetcode.com/problems/reconstruct-itinerary/)\\n\\n# Code\\n```\\nvar validArrangement = function(pairs) {\\n    // Create an empty array t, an empty Map m, and a Map out with all values set to 0 initially\\n    const t = [], m = new Map(), out = new Map(); \\n\\n    // For each pair in the input pairs array, add the second value of the pair to an array at the first value\\'s key in Map m, and set the out Map accordingly to keep track of the number of incoming and outgoing edges for each node\\n    for (let i = pairs.length - 1; i >= 0; i--) {\\n        const [x, y] = pairs[i];\\n        if (m.has(x)) m.get(x).push(y);\\n        else m.set(x, [y]);\\n        out.set(x, (out.get(x) || 0) + 1);\\n        out.set(y, (out.get(y) || 0) - 1);           \\n    }\\n\\n    // Identify the starting node as the one with outgoing edge but no incoming edges in the out Map\\n    let start = pairs[0][0];\\n    for (const k of out.keys()) {\\n        if (out.get(k) === 1) {\\n            start = k;\\n            break;\\n        }\\n    }\\n\\n    // Traverse the graph using depth-first search and store the result in array t\\n    function dfs(x) {\\n        while (m.has(x) && m.get(x).length) {\\n            dfs(m.get(x).pop());\\n        }\\n        t.push(x);\\n    }\\n    dfs(start);\\n\\n    // Create a result array r that stores the edges of the graph in topological order as pairs of nodes\\n    const r = [];\\n    for (let i = t.length - 1; i > 0; i--) {\\n        r.push([t[i], t[i - 1]]);\\n    }               \\n\\n    // Return the result array r\\n    return r;\\n}; \\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search",
                    "Graph",
                    "Queue",
                    "Eulerian Circuit"
                ],
                "code": "```\\nvar validArrangement = function(pairs) {\\n    // Create an empty array t, an empty Map m, and a Map out with all values set to 0 initially\\n    const t = [], m = new Map(), out = new Map(); \\n\\n    // For each pair in the input pairs array, add the second value of the pair to an array at the first value\\'s key in Map m, and set the out Map accordingly to keep track of the number of incoming and outgoing edges for each node\\n    for (let i = pairs.length - 1; i >= 0; i--) {\\n        const [x, y] = pairs[i];\\n        if (m.has(x)) m.get(x).push(y);\\n        else m.set(x, [y]);\\n        out.set(x, (out.get(x) || 0) + 1);\\n        out.set(y, (out.get(y) || 0) - 1);           \\n    }\\n\\n    // Identify the starting node as the one with outgoing edge but no incoming edges in the out Map\\n    let start = pairs[0][0];\\n    for (const k of out.keys()) {\\n        if (out.get(k) === 1) {\\n            start = k;\\n            break;\\n        }\\n    }\\n\\n    // Traverse the graph using depth-first search and store the result in array t\\n    function dfs(x) {\\n        while (m.has(x) && m.get(x).length) {\\n            dfs(m.get(x).pop());\\n        }\\n        t.push(x);\\n    }\\n    dfs(start);\\n\\n    // Create a result array r that stores the edges of the graph in topological order as pairs of nodes\\n    const r = [];\\n    for (let i = t.length - 1; i > 0; i--) {\\n        r.push([t[i], t[i - 1]]);\\n    }               \\n\\n    // Return the result array r\\n    return r;\\n}; \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3241885,
                "title": "c-eulerian-path",
                "content": "```\\npublic class Solution {\\n    int n=0;\\n        Dictionary<int,HashSet<int>> dict=new Dictionary<int,HashSet<int>>();\\n        Dictionary<int,int> cnt=new Dictionary<int,int>();\\n\\n    public int[][] ValidArrangement(int[][] pairs) {\\n        n=pairs.Length;\\n        int[][] res = new int[n][];\\n        for(int i=0;i<n;i++)\\n        {\\n            if(!dict.ContainsKey(pairs[i][0]))\\n                dict.Add(pairs[i][0],new HashSet<int>());\\n            \\n            dict[pairs[i][0]].Add(pairs[i][1]);\\n            res[i]=new int[2]{0,0};\\n            \\n            \\n            if(!cnt.ContainsKey(pairs[i][1]))\\n                cnt.Add(pairs[i][1],1);\\n            else\\n                cnt[pairs[i][1]]++;\\n        }\\n        \\n        int startnode=0;\\n        foreach(int k in dict.Keys)\\n        {\\n            startnode=k;\\n            int outCount=dict[k].Count;\\n            if(!cnt.ContainsKey(k) || cnt[k] <outCount)\\n                break;\\n            \\n        }\\n        \\n        int curr=n;\\n        dfs(startnode,-1,res,ref curr );\\n        return res;\\n    }\\n    \\n    void dfs(int at,int parent, int[][] res,ref int curr)\\n    {\\n        if(dict.ContainsKey(at)){\\n            while(dict[at].Count>0)\\n            {\\n                int to=dict[at].First();\\n                  if(cnt[to]==0)\\n                      continue;\\n                dict[at].Remove(to);\\n                dfs(to,at,res,ref curr);\\n            }\\n        }\\n        if(parent!=-1){\\n            res[--curr][0]=parent;\\n            res[curr][1]=at;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    int n=0;\\n        Dictionary<int,HashSet<int>> dict=new Dictionary<int,HashSet<int>>();\\n        Dictionary<int,int> cnt=new Dictionary<int,int>();\\n\\n    public int[][] ValidArrangement(int[][] pairs) {\\n        n=pairs.Length;\\n        int[][] res = new int[n][];\\n        for(int i=0;i<n;i++)\\n        {\\n            if(!dict.ContainsKey(pairs[i][0]))\\n                dict.Add(pairs[i][0],new HashSet<int>());\\n            \\n            dict[pairs[i][0]].Add(pairs[i][1]);\\n            res[i]=new int[2]{0,0};\\n            \\n            \\n            if(!cnt.ContainsKey(pairs[i][1]))\\n                cnt.Add(pairs[i][1],1);\\n            else\\n                cnt[pairs[i][1]]++;\\n        }\\n        \\n        int startnode=0;\\n        foreach(int k in dict.Keys)\\n        {\\n            startnode=k;\\n            int outCount=dict[k].Count;\\n            if(!cnt.ContainsKey(k) || cnt[k] <outCount)\\n                break;\\n            \\n        }\\n        \\n        int curr=n;\\n        dfs(startnode,-1,res,ref curr );\\n        return res;\\n    }\\n    \\n    void dfs(int at,int parent, int[][] res,ref int curr)\\n    {\\n        if(dict.ContainsKey(at)){\\n            while(dict[at].Count>0)\\n            {\\n                int to=dict[at].First();\\n                  if(cnt[to]==0)\\n                      continue;\\n                dict[at].Remove(to);\\n                dfs(to,at,res,ref curr);\\n            }\\n        }\\n        if(parent!=-1){\\n            res[--curr][0]=parent;\\n            res[curr][1]=at;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3119128,
                "title": "java-eulerian-path-hashmap-of-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n``` \\nIn this problem we have to place all pairs such that \\n- last element of prev pair == first element of curr pair\\nSo we have to calculate few things in the beginning\\n1. InDegree and OutDegree of all elements\\n2. Form a directed Graph using pairs from first to second element\\n3. Then we have to find start and end based of indegree and outdegree map\\n4. start element is gonna have more outdegree than indegree and vice versa for end.\\n\\nFor graph I have used Queue instead of ArrayList because\\n    - We have get multiple occurances of end element \\n    - So while running dfs if we get end element in between so we can put it at the end\\n    - We will only add end in our list when the size of that queue is 1. i.e only child is remaining.\\n\\nSo while backtracking we will add current node as all elements after that should get placed after it.\\nSo while adding elements in our ans array we will add by remove last operation as our \\nstarting indices are gonna be in the end sequentially\\n```\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    Map<Integer, Queue<Integer>> graph;\\n    LinkedList<Integer> queue = new LinkedList();\\n    Map<Integer, Integer> outDegree;\\n    Map<Integer, Integer> inDegree;\\n    int start, end;\\n\\n    public int[][] validArrangement(int[][] pairs) {\\n        int n = pairs.length;\\n        inDegree = new HashMap();\\n        outDegree = new HashMap();\\n        graph = new HashMap();\\n\\n        for(int[] pair : pairs) {\\n            int a = pair[0];\\n            int b = pair[1];\\n            inDegree.putIfAbsent(b, 0);\\n            outDegree.putIfAbsent(a, 0);\\n\\n            outDegree.put(a, outDegree.get(a) + 1);\\n            inDegree.put(b, inDegree.get(b) + 1);\\n\\n            graph.putIfAbsent(a, new LinkedList());\\n            graph.get(a).add(b);\\n        }\\n\\n        start = -1;\\n        end = -1;\\n\\n        for(Integer node : outDegree.keySet()) {\\n            Integer in = inDegree.get(node);\\n            Integer out = outDegree.get(node);\\n\\n            if((in == null && out != null) || out > in) {\\n                start = node;\\n            }\\n        }\\n        for(Integer node : inDegree.keySet()) {\\n            Integer in = inDegree.get(node);\\n            Integer out = outDegree.get(node);\\n\\n            if((out == null && in != null) || in > out) {\\n                end = node;\\n            }\\n        }\\n\\n        if(start == -1)\\n            start = pairs[0][0];\\n\\n        Dfs(start);\\n\\n        int[][] ans = new int[n][2];\\n        for (int i = 0; i < n; i++) {\\n            ans[i][0] = queue.removeLast();\\n            ans[i][1] = queue.removeLast();\\n        }\\n        return ans;\\n    }\\n\\n    public void Dfs(int node) {\\n        Queue<Integer> children = graph.get(node);\\n        while(children != null && !children.isEmpty()) {\\n            int nei = children.poll();\\n            if(nei == end && children.size() > 1) {\\n                children.add(nei);\\n                continue;\\n            }\\n            Dfs(nei);\\n            queue.add(nei);\\n        }\\n        queue.add(node);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Graph",
                    "Queue",
                    "Eulerian Circuit"
                ],
                "code": "``` \\nIn this problem we have to place all pairs such that \\n- last element of prev pair == first element of curr pair\\nSo we have to calculate few things in the beginning\\n1. InDegree and OutDegree of all elements\\n2. Form a directed Graph using pairs from first to second element\\n3. Then we have to find start and end based of indegree and outdegree map\\n4. start element is gonna have more outdegree than indegree and vice versa for end.\\n\\nFor graph I have used Queue instead of ArrayList because\\n    - We have get multiple occurances of end element \\n    - So while running dfs if we get end element in between so we can put it at the end\\n    - We will only add end in our list when the size of that queue is 1. i.e only child is remaining.\\n\\nSo while backtracking we will add current node as all elements after that should get placed after it.\\nSo while adding elements in our ans array we will add by remove last operation as our \\nstarting indices are gonna be in the end sequentially\\n```\n```\\nclass Solution {\\n    Map<Integer, Queue<Integer>> graph;\\n    LinkedList<Integer> queue = new LinkedList();\\n    Map<Integer, Integer> outDegree;\\n    Map<Integer, Integer> inDegree;\\n    int start, end;\\n\\n    public int[][] validArrangement(int[][] pairs) {\\n        int n = pairs.length;\\n        inDegree = new HashMap();\\n        outDegree = new HashMap();\\n        graph = new HashMap();\\n\\n        for(int[] pair : pairs) {\\n            int a = pair[0];\\n            int b = pair[1];\\n            inDegree.putIfAbsent(b, 0);\\n            outDegree.putIfAbsent(a, 0);\\n\\n            outDegree.put(a, outDegree.get(a) + 1);\\n            inDegree.put(b, inDegree.get(b) + 1);\\n\\n            graph.putIfAbsent(a, new LinkedList());\\n            graph.get(a).add(b);\\n        }\\n\\n        start = -1;\\n        end = -1;\\n\\n        for(Integer node : outDegree.keySet()) {\\n            Integer in = inDegree.get(node);\\n            Integer out = outDegree.get(node);\\n\\n            if((in == null && out != null) || out > in) {\\n                start = node;\\n            }\\n        }\\n        for(Integer node : inDegree.keySet()) {\\n            Integer in = inDegree.get(node);\\n            Integer out = outDegree.get(node);\\n\\n            if((out == null && in != null) || in > out) {\\n                end = node;\\n            }\\n        }\\n\\n        if(start == -1)\\n            start = pairs[0][0];\\n\\n        Dfs(start);\\n\\n        int[][] ans = new int[n][2];\\n        for (int i = 0; i < n; i++) {\\n            ans[i][0] = queue.removeLast();\\n            ans[i][1] = queue.removeLast();\\n        }\\n        return ans;\\n    }\\n\\n    public void Dfs(int node) {\\n        Queue<Integer> children = graph.get(node);\\n        while(children != null && !children.isEmpty()) {\\n            int nei = children.poll();\\n            if(nei == end && children.size() > 1) {\\n                children.add(nei);\\n                continue;\\n            }\\n            Dfs(nei);\\n            queue.add(nei);\\n        }\\n        queue.add(node);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3042462,
                "title": "rust-solution-eulerian-path",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis is a standard Eulerian path problem.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe algorithm following the same steps of the proving the existing of an Eulerian path under certain conditions.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n# Code\\n```\\nuse std::collections::HashMap;\\nimpl Solution {\\n    pub fn valid_arrangement(pairs: Vec<Vec<i32>>) -> Vec<Vec<i32>> {\\n        let mut mp = HashMap::<i32, Vec<i32>>::new();\\n        let mut degree = HashMap::<i32, i32>::new();\\n        let mut u = pairs[0][0];\\n\\n        for p in pairs {\\n            mp.entry(p[0]).or_insert(vec![]).push(p[1]);\\n            *degree.entry(p[0]).or_insert(0) += 1;\\n            *degree.entry(p[1]).or_insert(0) -= 1;\\n        }\\n        for (k, v) in degree {\\n            if v == 1 { u = k; } \\n        }\\n\\n        let (mut temp, mut sk) = (vec![u], vec![]);\\n        while let Some(u) = temp.pop() {\\n            if mp.contains_key(&u) {\\n                let v = mp.get_mut(&u).unwrap().pop().unwrap();\\n                if mp.get_mut(&u).unwrap().is_empty() { mp.remove(&u); }\\n                temp.push(u);\\n                temp.push(v);\\n            } else { sk.push(u); }\\n        }\\n\\n        let mut ret = vec![];\\n        for i in (1 .. sk.len()).rev() { ret.push(vec![sk[i], sk[i - 1]]); }\\n        ret\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::collections::HashMap;\\nimpl Solution {\\n    pub fn valid_arrangement(pairs: Vec<Vec<i32>>) -> Vec<Vec<i32>> {\\n        let mut mp = HashMap::<i32, Vec<i32>>::new();\\n        let mut degree = HashMap::<i32, i32>::new();\\n        let mut u = pairs[0][0];\\n\\n        for p in pairs {\\n            mp.entry(p[0]).or_insert(vec![]).push(p[1]);\\n            *degree.entry(p[0]).or_insert(0) += 1;\\n            *degree.entry(p[1]).or_insert(0) -= 1;\\n        }\\n        for (k, v) in degree {\\n            if v == 1 { u = k; } \\n        }\\n\\n        let (mut temp, mut sk) = (vec![u], vec![]);\\n        while let Some(u) = temp.pop() {\\n            if mp.contains_key(&u) {\\n                let v = mp.get_mut(&u).unwrap().pop().unwrap();\\n                if mp.get_mut(&u).unwrap().is_empty() { mp.remove(&u); }\\n                temp.push(u);\\n                temp.push(v);\\n            } else { sk.push(u); }\\n        }\\n\\n        let mut ret = vec![];\\n        for i in (1 .. sk.len()).rev() { ret.push(vec![sk[i], sk[i - 1]]); }\\n        ret\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2998299,
                "title": "same-as-itienarary-problem",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs(int node, int parent, map<int, priority_queue<int>>&adj, vector<vector<int>>&ans) {\\n        while(!adj[node].empty()) {\\n            auto temp = adj[node].top();\\n            adj[node].pop();\\n            dfs(temp,node,adj,ans);\\n        }\\n        if(parent != -1) ans.push_back({parent,node});\\n    }\\n    vector<vector<int>> validArrangement(vector<vector<int>>& pairs) {\\n        map<int,priority_queue<int>> adj;\\n        map<int, int> outdegree;\\n        int start = -1;\\n        for(auto i: pairs) {\\n            adj[i[0]].push(i[1]);\\n            outdegree[i[0]]++;\\n            outdegree[i[1]]--;\\n        }\\n\\n        for(auto i: outdegree) \\n            if(i.second > 0) start = i.first;\\n        \\n        if(start == -1) start = pairs[0][0];\\n        cout<<start<<\" \";\\n        vector<vector<int>>ans;\\n        dfs(start,-1,adj,ans);\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(int node, int parent, map<int, priority_queue<int>>&adj, vector<vector<int>>&ans) {\\n        while(!adj[node].empty()) {\\n            auto temp = adj[node].top();\\n            adj[node].pop();\\n            dfs(temp,node,adj,ans);\\n        }\\n        if(parent != -1) ans.push_back({parent,node});\\n    }\\n    vector<vector<int>> validArrangement(vector<vector<int>>& pairs) {\\n        map<int,priority_queue<int>> adj;\\n        map<int, int> outdegree;\\n        int start = -1;\\n        for(auto i: pairs) {\\n            adj[i[0]].push(i[1]);\\n            outdegree[i[0]]++;\\n            outdegree[i[1]]--;\\n        }\\n\\n        for(auto i: outdegree) \\n            if(i.second > 0) start = i.first;\\n        \\n        if(start == -1) start = pairs[0][0];\\n        cout<<start<<\" \";\\n        vector<vector<int>>ans;\\n        dfs(start,-1,adj,ans);\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2949394,
                "title": "c-graph-solution-using-oop-hash-tables-and-hierholzer-s-algorithm-for-directed-graph",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    - I considered all distinct values from pairs as nodes \\n    indices and any pair as an edge in a directed graph. \\n\\n    - I chose the starting node as any node \\n    (the one with the smallest index in my case) \\n    if all nodes had out degree == indegree.      \\n     \\n    - Otherwise, I chose as starting point the node with\\n     outdegree bigger with exactly one than its indegree. \\n\\n    - Then, I applied Hierholzer\\u2019s Algorithm for \\n    directed graph and got in the euler tour the nodes order \\n    in reverse,then transformed it into pairs of edge in euler tour. \\n\\n# Complexity\\n- Time complexity: O(M) - M = no of edges ( pairs.size() );\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Graph {\\nprotected:\\n\\n    int M;\\n    int start_node;\\n    unordered_map <int, vector<int>> list_adj;\\n    vector<bool> visited;\\n    vector<int> euler_tour;\\n\\npublic:\\n    virtual void read(vector<vector<int>> &edges);\\n    void build_euler_tour();\\n    vector<vector<int>> pair_arrangement_builder();\\n\\n};\\n\\n\\n\\nvoid Graph::read(vector<vector<int>> &edges) {\\n    unordered_map<int, int> nodes;\\n    M = (int) edges.size();\\n    for (auto edge : edges) {\\n        auto from = nodes.find(edge[0]);\\n        if(from == nodes.end()) { //not found\\n            nodes.insert({edge[0], 1});\\n        } else { //found\\n            from->second++;\\n        }\\n\\n        auto to = nodes.find(edge[1]);\\n        if(to == nodes.end()) { //not found\\n            nodes.insert({edge[1], -1});\\n        } else { //found\\n            to->second--;\\n        }\\n\\n        if(list_adj.find(edge[0]) != list_adj.end()) { //the node has been already added to the adj list\\n            list_adj[edge[0]].push_back(edge[1]);\\n        } else { // we add it node\\n            list_adj.insert({edge[0], {edge[1]}});\\n        }\\n    }\\n    start_node = -1;\\n    for (auto node: nodes) {\\n        int n = node.first;\\n        if (node.second == 1) {\\n                start_node = n;\\n        }\\n    }\\n\\n    if(start_node == -1) {\\n        start_node = list_adj.begin()->first;\\n    }\\n\\n}\\n\\nvoid Graph::build_euler_tour() {\\n    // Hierholzer\\u2019s Algorithm for directed graph\\n\\n    stack<int> path;\\n    int curr_node, next_node;\\n    path.push(start_node);\\n\\n    while(!path.empty()) {\\n        curr_node = path.top();\\n\\n        if(!list_adj[curr_node].empty()) { // if the current node is not saturated already\\n            // in order not to keep track of the edges visited or to remove from adj list from the front we choose to remove more efficiently traversing first last neighbour in the adj list\\n            next_node = list_adj[curr_node].back();\\n            list_adj[curr_node].pop_back();\\n\\n            path.push(next_node);\\n        } else { // we have previously saturated this node by visiting all the edges in hist adj list <=> his adj list is empty now\\n            //now it\\'s high time to put it the circuit last node\\n            euler_tour.push_back(path.top());\\n            path.pop();\\n        }\\n    }\\n\\n\\n}\\n\\nvector<vector<int>> Graph::pair_arrangement_builder() {\\n    vector<vector<int>> arrangement;\\n    euler_tour.pop_back();\\n    int last = start_node;\\n\\n    for (int i = (int) euler_tour.size()-1; i >= 0 ; i--) {\\n        arrangement.push_back({last, euler_tour[i]});\\n        last = euler_tour[i] ;\\n        euler_tour.pop_back();\\n    }\\n    return arrangement;\\n}\\n\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> validArrangement(vector<vector<int>>& pairs) {\\n        Graph my_graph;\\n        my_graph.read(pairs);\\n        my_graph.build_euler_tour();\\n        return my_graph.pair_arrangement_builder();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Eulerian Circuit"
                ],
                "code": "```\\nclass Graph {\\nprotected:\\n\\n    int M;\\n    int start_node;\\n    unordered_map <int, vector<int>> list_adj;\\n    vector<bool> visited;\\n    vector<int> euler_tour;\\n\\npublic:\\n    virtual void read(vector<vector<int>> &edges);\\n    void build_euler_tour();\\n    vector<vector<int>> pair_arrangement_builder();\\n\\n};\\n\\n\\n\\nvoid Graph::read(vector<vector<int>> &edges) {\\n    unordered_map<int, int> nodes;\\n    M = (int) edges.size();\\n    for (auto edge : edges) {\\n        auto from = nodes.find(edge[0]);\\n        if(from == nodes.end()) { //not found\\n            nodes.insert({edge[0], 1});\\n        } else { //found\\n            from->second++;\\n        }\\n\\n        auto to = nodes.find(edge[1]);\\n        if(to == nodes.end()) { //not found\\n            nodes.insert({edge[1], -1});\\n        } else { //found\\n            to->second--;\\n        }\\n\\n        if(list_adj.find(edge[0]) != list_adj.end()) { //the node has been already added to the adj list\\n            list_adj[edge[0]].push_back(edge[1]);\\n        } else { // we add it node\\n            list_adj.insert({edge[0], {edge[1]}});\\n        }\\n    }\\n    start_node = -1;\\n    for (auto node: nodes) {\\n        int n = node.first;\\n        if (node.second == 1) {\\n                start_node = n;\\n        }\\n    }\\n\\n    if(start_node == -1) {\\n        start_node = list_adj.begin()->first;\\n    }\\n\\n}\\n\\nvoid Graph::build_euler_tour() {\\n    // Hierholzer\\u2019s Algorithm for directed graph\\n\\n    stack<int> path;\\n    int curr_node, next_node;\\n    path.push(start_node);\\n\\n    while(!path.empty()) {\\n        curr_node = path.top();\\n\\n        if(!list_adj[curr_node].empty()) { // if the current node is not saturated already\\n            // in order not to keep track of the edges visited or to remove from adj list from the front we choose to remove more efficiently traversing first last neighbour in the adj list\\n            next_node = list_adj[curr_node].back();\\n            list_adj[curr_node].pop_back();\\n\\n            path.push(next_node);\\n        } else { // we have previously saturated this node by visiting all the edges in hist adj list <=> his adj list is empty now\\n            //now it\\'s high time to put it the circuit last node\\n            euler_tour.push_back(path.top());\\n            path.pop();\\n        }\\n    }\\n\\n\\n}\\n\\nvector<vector<int>> Graph::pair_arrangement_builder() {\\n    vector<vector<int>> arrangement;\\n    euler_tour.pop_back();\\n    int last = start_node;\\n\\n    for (int i = (int) euler_tour.size()-1; i >= 0 ; i--) {\\n        arrangement.push_back({last, euler_tour[i]});\\n        last = euler_tour[i] ;\\n        euler_tour.pop_back();\\n    }\\n    return arrangement;\\n}\\n\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> validArrangement(vector<vector<int>>& pairs) {\\n        Graph my_graph;\\n        my_graph.read(pairs);\\n        my_graph.build_euler_tour();\\n        return my_graph.pair_arrangement_builder();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2933591,
                "title": "java-hierholzer-s-algorithm-beats-100-full-explanation-with-pictures",
                "content": "# Intuition\\n[Heirholzer\\'s algorithm](https://en.wikipedia.org/wiki/Eulerian_path#Hierholzer\\'s_algorithm) is almost good enough, but the problem is that not all vertices have even degree. It is possible for there to be a path from the required end vertex to the required start vertex, so we can\\'t make all vertices even degree just by adding one edge, see below.\\n\\n![hei.drawio.png](https://assets.leetcode.com/users/images/eed327f0-6708-4d57-8882-483bc7c1ac87_1671566450.4549296.png)\\n\\nHowever, we can mitigate this issue by adding a sentinel vertex `-1`, adding an edge from it to the start and an edge from the end to it, assuming we know where they are.\\n\\n![hei.drawio2.png](https://assets.leetcode.com/users/images/3077ee63-242d-4291-9094-cc857ed5cb0b_1671566687.4316936.png)\\n\\nAll vertices are now even degree. Then we just apply Heirholzer\\'s algorithm.\\n\\n\\n# Approach\\nFirst create an adjacency `HashMap` and a degree counting `HashMap` to locate the start and end vertices, and then add the `-1` edges if necessary.\\n\\nThen, starting from the start vertex (or the first element if all are even degree), just walk until we get stuck. Then, rotate our answer until we are unstuck and continue walking. Finally, we need to remove our phantom `-1` edge before we render the answer. We can save on a little bit of memory / time by updating the input edges in place.\\n\\n# Complexity\\n- Time complexity:\\n$$O(|E|)$$. Nothing is slower than that, though we do walk several times. See wikipedia link above. \\n\\n- Space complexity:\\n$$O(|V| + |E|)$$. We store the degree count, and an extra data structure to store the adjacency list. \\n\\n# Code\\n```\\nclass Solution {\\n    static final LinkedList<Integer> empty = new LinkedList<>();\\n\\n    private LinkedList<Integer> emptyList() {\\n        return empty;\\n    }\\n\\n    Map<Integer, LinkedList<Integer>> leftToRight = new HashMap<>();\\n    Map<Integer, Integer> deg = new HashMap<>();\\n\\n    public int[][] validArrangement(int[][] edges) {\\n        int edgeCount = edges.length;\\n\\n        for(int i = 0; i < edges.length; i++) {\\n            addEdge(edges[i][0], edges[i][1]);\\n        }\\n\\n        int startVertex = Integer.MIN_VALUE;\\n        int endVertex = Integer.MIN_VALUE;\\n\\n        for(Map.Entry<Integer, Integer> entry : deg.entrySet()) {\\n            if (entry.getValue() < 0) { // not cycle\\n                startVertex = entry.getKey();\\n            } else if (entry.getValue() > 0) {\\n                endVertex = entry.getKey();\\n            }\\n        }\\n\\n        Deque<Integer> path = new LinkedList<>();\\n\\n        if (startVertex != Integer.MIN_VALUE) {\\n            addEdge(-1, startVertex);\\n            addEdge(endVertex, -1);\\n            edgeCount += 2;\\n            path.addLast(-1);\\n        } else {\\n            path.addLast(edges[0][0]);\\n        }\\n\\n        int addCount = 0;\\n\\n        while(addCount < edgeCount) {\\n            Integer nextVertex = getRandomEdge(path.peekLast());\\n            if (nextVertex == null) {\\n                rotateLeft(path);\\n            } else {\\n                addCount++;\\n                path.addLast(nextVertex);\\n            }\\n        }\\n\\n        if (startVertex != Integer.MIN_VALUE) {\\n            while(path.peekFirst() != -1) {\\n                rotateLeft(path);\\n            }\\n            path.pollFirst();\\n            path.pollLast();\\n        }\\n\\n        /// rendering\\n        boolean startBool = true;\\n        int firstIndex = Integer.MIN_VALUE;\\n        int index = 0;\\n\\n        while(!path.isEmpty()) {\\n            if (!startBool) {\\n                int[] newPair = new int[2];\\n                newPair[0] = firstIndex;\\n                newPair[1] = path.pollFirst();\\n                firstIndex = newPair[1];\\n                edges[index] = newPair;\\n                index++; \\n            } else {\\n                firstIndex = path.pollFirst();\\n                startBool = false;\\n            }\\n        }\\n\\n        return edges;\\n    }\\n\\n    private void addEdge(int leftIndex, int rightIndex) {\\n        LinkedList<Integer> target = leftToRight.getOrDefault(leftIndex, new LinkedList<>());\\n        target.add(rightIndex);\\n        leftToRight.put(leftIndex, target);\\n\\n        deg.put(leftIndex, deg.getOrDefault(leftIndex, 0) - 1);\\n        deg.put(rightIndex, deg.getOrDefault(rightIndex, 0) + 1);\\n    }\\n\\n    private Integer getRandomEdge(int currentVertex) {\\n        LinkedList<Integer> list = leftToRight.getOrDefault(currentVertex, emptyList());\\n        return list.isEmpty() ? null : list.pollLast();\\n    }\\n\\n    private void rotateLeft(Deque<Integer> path) {\\n        path.pollLast();\\n        path.addFirst(path.peekLast());\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Graph",
                    "Eulerian Circuit"
                ],
                "code": "```\\nclass Solution {\\n    static final LinkedList<Integer> empty = new LinkedList<>();\\n\\n    private LinkedList<Integer> emptyList() {\\n        return empty;\\n    }\\n\\n    Map<Integer, LinkedList<Integer>> leftToRight = new HashMap<>();\\n    Map<Integer, Integer> deg = new HashMap<>();\\n\\n    public int[][] validArrangement(int[][] edges) {\\n        int edgeCount = edges.length;\\n\\n        for(int i = 0; i < edges.length; i++) {\\n            addEdge(edges[i][0], edges[i][1]);\\n        }\\n\\n        int startVertex = Integer.MIN_VALUE;\\n        int endVertex = Integer.MIN_VALUE;\\n\\n        for(Map.Entry<Integer, Integer> entry : deg.entrySet()) {\\n            if (entry.getValue() < 0) { // not cycle\\n                startVertex = entry.getKey();\\n            } else if (entry.getValue() > 0) {\\n                endVertex = entry.getKey();\\n            }\\n        }\\n\\n        Deque<Integer> path = new LinkedList<>();\\n\\n        if (startVertex != Integer.MIN_VALUE) {\\n            addEdge(-1, startVertex);\\n            addEdge(endVertex, -1);\\n            edgeCount += 2;\\n            path.addLast(-1);\\n        } else {\\n            path.addLast(edges[0][0]);\\n        }\\n\\n        int addCount = 0;\\n\\n        while(addCount < edgeCount) {\\n            Integer nextVertex = getRandomEdge(path.peekLast());\\n            if (nextVertex == null) {\\n                rotateLeft(path);\\n            } else {\\n                addCount++;\\n                path.addLast(nextVertex);\\n            }\\n        }\\n\\n        if (startVertex != Integer.MIN_VALUE) {\\n            while(path.peekFirst() != -1) {\\n                rotateLeft(path);\\n            }\\n            path.pollFirst();\\n            path.pollLast();\\n        }\\n\\n        /// rendering\\n        boolean startBool = true;\\n        int firstIndex = Integer.MIN_VALUE;\\n        int index = 0;\\n\\n        while(!path.isEmpty()) {\\n            if (!startBool) {\\n                int[] newPair = new int[2];\\n                newPair[0] = firstIndex;\\n                newPair[1] = path.pollFirst();\\n                firstIndex = newPair[1];\\n                edges[index] = newPair;\\n                index++; \\n            } else {\\n                firstIndex = path.pollFirst();\\n                startBool = false;\\n            }\\n        }\\n\\n        return edges;\\n    }\\n\\n    private void addEdge(int leftIndex, int rightIndex) {\\n        LinkedList<Integer> target = leftToRight.getOrDefault(leftIndex, new LinkedList<>());\\n        target.add(rightIndex);\\n        leftToRight.put(leftIndex, target);\\n\\n        deg.put(leftIndex, deg.getOrDefault(leftIndex, 0) - 1);\\n        deg.put(rightIndex, deg.getOrDefault(rightIndex, 0) + 1);\\n    }\\n\\n    private Integer getRandomEdge(int currentVertex) {\\n        LinkedList<Integer> list = leftToRight.getOrDefault(currentVertex, emptyList());\\n        return list.isEmpty() ? null : list.pollLast();\\n    }\\n\\n    private void rotateLeft(Deque<Integer> path) {\\n        path.pollLast();\\n        path.addFirst(path.peekLast());\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2927955,
                "title": "java-dfs-euler",
                "content": "# Intuition\\nEULER\\n\\n\\n# Code\\n```\\nclass Solution {\\n        HashMap<Integer,ArrayList<Integer>>adj=new HashMap<>();\\n        HashMap<Integer,Integer>in=new HashMap<>();//indegree\\n        HashMap<Integer,Integer>out=new HashMap<>();//outdegree\\n        int ans[][];//result\\n        int k=0;\\n        ArrayList<Integer>l=new ArrayList<>();\\n    public int[][] validArrangement(int[][] pairs) {\\n        //Eulerian path in which all edges are visited exactly once\\n    // ArrayList<ArrayList<Integer>>adj=new ArrayList<>();\\n//we can use this type of adjacency list as \\n//values of nodes not less than or equal to size of pairs\\n        int n=pairs.length;\\n        k=n-1;//last index\\n        ans=new int[n][2];\\n       for(int p[]:pairs){\\n           if(!adj.containsKey(p[0]))\\n                adj.put(p[0],new ArrayList<>());\\n            adj.get(p[0]).add(p[1]);\\n\\n            out.put(p[0],out.getOrDefault(p[0],0)+1);\\n            if(!in.containsKey(p[0]))\\n                in.put(p[0],0);//in of 1st node will be zero\\n            in.put(p[1],in.getOrDefault(p[1],0)+1);\\n            if(!out.containsKey(p[1]))\\n                out.put(p[1],0);//out of 2nd node might be 0 or greater than 0\\n\\n       }\\n       int start=-1;\\n       for(int x:adj.keySet()){\\n//it is only possibel for 1st node as its indegree is 0 and out degree is 1\\n           if(out.get(x)-in.get(x)==1)//out_degree-in_degree==1\\n            {\\n                start=x;\\n                break;\\n            }\\n       }\\n       if(start==-1)\\n            start=pairs[0][0];\\n        dfs(start);\\n        return ans;\\n    }\\n    void dfs(int node){\\n     \\n        if(adj.containsKey(node)){\\n            while(adj.get(node).size()>0){\\n                List<Integer>a=adj.get(node);\\n                int n=a.size();\\n                int x=a.get(n-1);\\n                a.remove(n-1);\\n                dfs(x);\\n                ans[k][0]=node;\\n                ans[k][1]=x;\\n                k--;\\n            }\\n        }\\n\\n        return;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n        HashMap<Integer,ArrayList<Integer>>adj=new HashMap<>();\\n        HashMap<Integer,Integer>in=new HashMap<>();//indegree\\n        HashMap<Integer,Integer>out=new HashMap<>();//outdegree\\n        int ans[][];//result\\n        int k=0;\\n        ArrayList<Integer>l=new ArrayList<>();\\n    public int[][] validArrangement(int[][] pairs) {\\n        //Eulerian path in which all edges are visited exactly once\\n    // ArrayList<ArrayList<Integer>>adj=new ArrayList<>();\\n//we can use this type of adjacency list as \\n//values of nodes not less than or equal to size of pairs\\n        int n=pairs.length;\\n        k=n-1;//last index\\n        ans=new int[n][2];\\n       for(int p[]:pairs){\\n           if(!adj.containsKey(p[0]))\\n                adj.put(p[0],new ArrayList<>());\\n            adj.get(p[0]).add(p[1]);\\n\\n            out.put(p[0],out.getOrDefault(p[0],0)+1);\\n            if(!in.containsKey(p[0]))\\n                in.put(p[0],0);//in of 1st node will be zero\\n            in.put(p[1],in.getOrDefault(p[1],0)+1);\\n            if(!out.containsKey(p[1]))\\n                out.put(p[1],0);//out of 2nd node might be 0 or greater than 0\\n\\n       }\\n       int start=-1;\\n       for(int x:adj.keySet()){\\n//it is only possibel for 1st node as its indegree is 0 and out degree is 1\\n           if(out.get(x)-in.get(x)==1)//out_degree-in_degree==1\\n            {\\n                start=x;\\n                break;\\n            }\\n       }\\n       if(start==-1)\\n            start=pairs[0][0];\\n        dfs(start);\\n        return ans;\\n    }\\n    void dfs(int node){\\n     \\n        if(adj.containsKey(node)){\\n            while(adj.get(node).size()>0){\\n                List<Integer>a=adj.get(node);\\n                int n=a.size();\\n                int x=a.get(n-1);\\n                a.remove(n-1);\\n                dfs(x);\\n                ans[k][0]=node;\\n                ans[k][1]=x;\\n                k--;\\n            }\\n        }\\n\\n        return;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2888559,
                "title": "solution-using-hierholzer-s-algorithm-for-directed-graph",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe will check if the graph contains a Eulerian path or not.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIf the graph contains a Eulerian path, we will begin traversing with that node which has indegree=0.\\nNow we apply the Hierholzer\\u2019s Algorithm for directed graph and return the pairs in reverse order.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> validArrangement(vector<vector<int>>& pairs) {\\n        unordered_map<int,list<int>>g;\\n        unordered_map<int,int>edgeCount;\\n        unordered_map<int,int>deg;\\n        for(auto p:pairs)\\n        {\\n            g[p[0]].push_back(p[1]);\\n            edgeCount[p[0]]++;\\n            deg[p[1]]--;\\n            deg[p[0]]++;\\n        }\\n        int count=0;\\n        stack<int>currPath;\\n        vector<int>circuit;\\n        for(auto i:deg)\\n        {\\n            if(i.second!=0)\\n            {\\n                //cout<<i.first<<\" \"<<i.second<<endl;\\n                count++;\\n                if(i.second>0)\\n                    currPath.push(i.first);\\n            }\\n        }\\n        if(count%2!=0||count>2)\\n            return {};\\n        if(currPath.empty()==true)\\n            currPath.push(pairs[0][0]);\\n\\n        int currV=currPath.top();\\n        while(currPath.empty()==false)\\n        {\\n            if(edgeCount[currV])\\n            {\\n                currPath.push(currV);\\n                edgeCount[currV]--;\\n                int nextV=g[currV].back();\\n                g[currV].pop_back();\\n                currV=nextV;\\n            }\\n            else\\n            {\\n                circuit.push_back(currV);\\n                currV=currPath.top();\\n                currPath.pop();\\n            }\\n        }\\n        vector<vector<int>>res;\\n        for(int i=circuit.size()-1;i>0;i--)\\n            res.push_back({circuit[i],circuit[i-1]});\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> validArrangement(vector<vector<int>>& pairs) {\\n        unordered_map<int,list<int>>g;\\n        unordered_map<int,int>edgeCount;\\n        unordered_map<int,int>deg;\\n        for(auto p:pairs)\\n        {\\n            g[p[0]].push_back(p[1]);\\n            edgeCount[p[0]]++;\\n            deg[p[1]]--;\\n            deg[p[0]]++;\\n        }\\n        int count=0;\\n        stack<int>currPath;\\n        vector<int>circuit;\\n        for(auto i:deg)\\n        {\\n            if(i.second!=0)\\n            {\\n                //cout<<i.first<<\" \"<<i.second<<endl;\\n                count++;\\n                if(i.second>0)\\n                    currPath.push(i.first);\\n            }\\n        }\\n        if(count%2!=0||count>2)\\n            return {};\\n        if(currPath.empty()==true)\\n            currPath.push(pairs[0][0]);\\n\\n        int currV=currPath.top();\\n        while(currPath.empty()==false)\\n        {\\n            if(edgeCount[currV])\\n            {\\n                currPath.push(currV);\\n                edgeCount[currV]--;\\n                int nextV=g[currV].back();\\n                g[currV].pop_back();\\n                currV=nextV;\\n            }\\n            else\\n            {\\n                circuit.push_back(currV);\\n                currV=currPath.top();\\n                currPath.pop();\\n            }\\n        }\\n        vector<vector<int>>res;\\n        for(int i=circuit.size()-1;i>0;i--)\\n            res.push_back({circuit[i],circuit[i-1]});\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2887593,
                "title": "easy-short-efficient-clean-code",
                "content": "```c++=\\nclass Solution {\\ntypedef long long ll;\\ntypedef pair<ll, ll> pi;\\n#define vi(x) vector<x>\\n#define pb push_back\\nconst ll mod = 1e9 + 7;\\nconst char nl = \\'\\\\n\\';\\npublic:\\nunordered_map<ll, vi(ll)>g;\\nvoid func(vi(vi(int))&ans, ll nd){\\n    while(!g[nd].empty()){\\n        ll child=g[nd].back();\\n        g[nd].pop_back();\\n        func(ans, child);\\n        ans.pb({int(nd), int(child)});\\n    }\\n}\\n    vector<vector<int>> validArrangement(vector<vector<int>>&v) {\\n        unordered_map<ll,ll>in, out;\\n        for(const auto&it:v){\\n            g[it[0]].pb(it[1]);\\n            ++in[it[1]], ++out[it[0]];\\n        }\\n        ll start=begin(g)->first;\\n        for(const auto&it:out){\\n            ll nd=it.first;\\n            if(out[nd]==in[nd]+1){\\n                start=nd;\\n                break;\\n            }\\n        }\\n        vi(vi(int))ans;\\n        func(ans, start);\\n        reverse(begin(ans), end(ans));\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Eulerian Circuit"
                ],
                "code": "```c++=\\nclass Solution {\\ntypedef long long ll;\\ntypedef pair<ll, ll> pi;\\n#define vi(x) vector<x>\\n#define pb push_back\\nconst ll mod = 1e9 + 7;\\nconst char nl = \\'\\\\n\\';\\npublic:\\nunordered_map<ll, vi(ll)>g;\\nvoid func(vi(vi(int))&ans, ll nd){\\n    while(!g[nd].empty()){\\n        ll child=g[nd].back();\\n        g[nd].pop_back();\\n        func(ans, child);\\n        ans.pb({int(nd), int(child)});\\n    }\\n}\\n    vector<vector<int>> validArrangement(vector<vector<int>>&v) {\\n        unordered_map<ll,ll>in, out;\\n        for(const auto&it:v){\\n            g[it[0]].pb(it[1]);\\n            ++in[it[1]], ++out[it[0]];\\n        }\\n        ll start=begin(g)->first;\\n        for(const auto&it:out){\\n            ll nd=it.first;\\n            if(out[nd]==in[nd]+1){\\n                start=nd;\\n                break;\\n            }\\n        }\\n        vi(vi(int))ans;\\n        func(ans, start);\\n        reverse(begin(ans), end(ans));\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2861090,
                "title": "python-solution-hierholzer-algorithm-for-euler-path",
                "content": "```\\ndef validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\\n\\tdeg, mp = defaultdict(lambda:[0, 0]), defaultdict(list)\\n\\tfor u, v in pairs:\\n\\t\\tdeg[u][0] += 1  # in_degree\\n\\t\\tdeg[v][1] += 1  # out_degree\\n\\t\\tmp[u].append(v)\\n\\n\\tstart, ans = pairs[0][0], []\\n\\tfor u in deg:\\n\\t\\tif deg[u][0] - deg[u][1]==1:\\n\\t\\t\\tstart = u\\n\\t\\t\\tbreak\\n\\n\\tdef dfs_Hierholzer(node):\\n\\t\\twhile(mp[node]):\\n\\t\\t\\tnxt = mp[node].pop()\\n\\t\\t\\tdfs_Hierholzer(nxt)\\n\\t\\t\\tans.append([node, nxt])\\n\\t\\treturn\\n\\n\\tdfs_Hierholzer(start)\\n\\treturn ans[::-1]\\n```",
                "solutionTags": [],
                "code": "```\\ndef validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\\n\\tdeg, mp = defaultdict(lambda:[0, 0]), defaultdict(list)\\n\\tfor u, v in pairs:\\n\\t\\tdeg[u][0] += 1  # in_degree\\n\\t\\tdeg[v][1] += 1  # out_degree\\n\\t\\tmp[u].append(v)\\n\\n\\tstart, ans = pairs[0][0], []\\n\\tfor u in deg:\\n\\t\\tif deg[u][0] - deg[u][1]==1:\\n\\t\\t\\tstart = u\\n\\t\\t\\tbreak\\n\\n\\tdef dfs_Hierholzer(node):\\n\\t\\twhile(mp[node]):\\n\\t\\t\\tnxt = mp[node].pop()\\n\\t\\t\\tdfs_Hierholzer(nxt)\\n\\t\\t\\tans.append([node, nxt])\\n\\t\\treturn\\n\\n\\tdfs_Hierholzer(start)\\n\\treturn ans[::-1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2753032,
                "title": "eulerian-path-construction-solution-c",
                "content": "As you can see, this problem can be reduced to finding eulerian-path on DAG.\\nAnd there\\'s well-known fact regarding  necessary and sufficient conditions of the existence of eulerian-path.\\n\\nhttps://en.wikipedia.org/wiki/Eulerian_path\\n\\nHere\\'s my implementation in C++ :)\\n```\\nusing namespace std;\\n\\nvector<int> directed_euler_path(vector<pair<int, int>> & edges, int start){\\n    /*\\n    when DAG whose edges are [edges] are given,\\n    returns one possible euler path starting from [start].\\n    [ex]\\n        [param]\\n            edges = {{1, 3}, {9, 5}, {5, 1}, {3, 5}}\\n            start = 9\\n        [output] {9, 5, 1, 3, 5}\\n        \\n    Time/Space : O(N)\\n    */\\n\\n    struct node{\\n        int to;\\n        bool visited;\\n    };\\n\\n    unordered_map<int, vector<node>> graph;\\n    for (auto & [u, v] : edges){\\n        int v_sz = graph[v].size();\\n        graph[u].emplace_back(node{v, false});\\n    }\\n\\n    stack<pair<int, int>> que;\\n    vector<int> path;\\n    que.emplace(pair<int, int>{-1, start});\\n\\n    while(!que.empty()){\\n        auto p = que.top();\\n        if (graph[p.second].empty()){\\n            path.emplace_back(p.second);\\n            que.pop();\\n        }else{\\n            auto q = graph[p.second].back();\\n            if (q.visited){\\n                graph[p.second].pop_back();\\n                continue;\\n            }else{\\n                graph[p.second].back().visited = true;\\n                que.emplace(p.second, q.to);\\n            }\\n        }\\n    }\\n\\n    reverse(path.begin(),path.end());\\n    return path;\\n}\\n\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> validArrangement(vector<vector<int>>& pairs) {\\n\\n        vector<pair<int, int>> edges;\\n        unordered_map<int, int> deg;\\n\\n        //construct graph from inputs\\n        for (auto & e : pairs){\\n            int u = e[0], v = e[1];\\n            edges.emplace_back(u, v);\\n            deg[u]++;\\n            deg[v]--;\\n        }\\n\\n        //determine the origin of euler-path\\n        int start = -1;\\n        for (auto & [u, v] : edges){\\n            int count = deg[u];\\n            if (start == -1 || count == 1){\\n                start = u;\\n            }\\n        }\\n\\n        //construct euler-path\\n        vector<vector<int>> ans;\\n        vector<int> path = directed_euler_path(edges, start);\\n        for (int i = 1; i < path.size(); i++){\\n            ans.push_back({path[i - 1], path[i]});\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nusing namespace std;\\n\\nvector<int> directed_euler_path(vector<pair<int, int>> & edges, int start){\\n    /*\\n    when DAG whose edges are [edges] are given,\\n    returns one possible euler path starting from [start].\\n    [ex]\\n        [param]\\n            edges = {{1, 3}, {9, 5}, {5, 1}, {3, 5}}\\n            start = 9\\n        [output] {9, 5, 1, 3, 5}\\n        \\n    Time/Space : O(N)\\n    */\\n\\n    struct node{\\n        int to;\\n        bool visited;\\n    };\\n\\n    unordered_map<int, vector<node>> graph;\\n    for (auto & [u, v] : edges){\\n        int v_sz = graph[v].size();\\n        graph[u].emplace_back(node{v, false});\\n    }\\n\\n    stack<pair<int, int>> que;\\n    vector<int> path;\\n    que.emplace(pair<int, int>{-1, start});\\n\\n    while(!que.empty()){\\n        auto p = que.top();\\n        if (graph[p.second].empty()){\\n            path.emplace_back(p.second);\\n            que.pop();\\n        }else{\\n            auto q = graph[p.second].back();\\n            if (q.visited){\\n                graph[p.second].pop_back();\\n                continue;\\n            }else{\\n                graph[p.second].back().visited = true;\\n                que.emplace(p.second, q.to);\\n            }\\n        }\\n    }\\n\\n    reverse(path.begin(),path.end());\\n    return path;\\n}\\n\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> validArrangement(vector<vector<int>>& pairs) {\\n\\n        vector<pair<int, int>> edges;\\n        unordered_map<int, int> deg;\\n\\n        //construct graph from inputs\\n        for (auto & e : pairs){\\n            int u = e[0], v = e[1];\\n            edges.emplace_back(u, v);\\n            deg[u]++;\\n            deg[v]--;\\n        }\\n\\n        //determine the origin of euler-path\\n        int start = -1;\\n        for (auto & [u, v] : edges){\\n            int count = deg[u];\\n            if (start == -1 || count == 1){\\n                start = u;\\n            }\\n        }\\n\\n        //construct euler-path\\n        vector<vector<int>> ans;\\n        vector<int> path = directed_euler_path(edges, start);\\n        for (int i = 1; i < path.size(); i++){\\n            ans.push_back({path[i - 1], path[i]});\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2701571,
                "title": "easy-valid-python89-74",
                "content": "\\n\\t\\t\\t\\t\\t\\tclass Solution:\\n\\t\\t\\t\\t\\t\\t\\tdef validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\\n\\t\\t\\t\\t\\t\\t\\t\\tgraph=defaultdict(list)\\n\\t\\t\\t\\t\\t\\t\\t\\tdegree=defaultdict(int)\\n\\t\\t\\t\\t\\t\\t\\t\\tfor x,y in pairs:\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tgraph[x].append(y)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tdegree[x]+=1\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tdegree[y]-=1\\n\\t\\t\\t\\t\\t\\t\\t\\tfor k in degree:\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif degree[k]==1:\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tx=k\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\t\\t\\t\\t\\tans=[]\\n\\t\\t\\t\\t\\t\\t\\t\\tdef fn(x):\\n\\t\\t\\t\\t\\t\\t\\t\\t\\twhile graph[x]:\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tfn(graph[x].pop())\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tans.append(x)\\n\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tfn(x)\\n\\t\\t\\t\\t\\t\\t\\t\\tans.reverse()\\n\\t\\t\\t\\t\\t\\t\\t\\treturn[[ans[i],ans[i+1]]for i in range(len(ans)-1)]",
                "solutionTags": [],
                "code": "\\n\\t\\t\\t\\t\\t\\tclass Solution:\\n\\t\\t\\t\\t\\t\\t\\tdef validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\\n\\t\\t\\t\\t\\t\\t\\t\\tgraph=defaultdict(list)\\n\\t\\t\\t\\t\\t\\t\\t\\tdegree=defaultdict(int)\\n\\t\\t\\t\\t\\t\\t\\t\\tfor x,y in pairs:\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tgraph[x].append(y)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tdegree[x]+=1\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tdegree[y]-=1\\n\\t\\t\\t\\t\\t\\t\\t\\tfor k in degree:\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif degree[k]==1:\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tx=k\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\t\\t\\t\\t\\tans=[]\\n\\t\\t\\t\\t\\t\\t\\t\\tdef fn(x):\\n\\t\\t\\t\\t\\t\\t\\t\\t\\twhile graph[x]:\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tfn(graph[x].pop())\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tans.append(x)\\n\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tfn(x)\\n\\t\\t\\t\\t\\t\\t\\t\\tans.reverse()\\n\\t\\t\\t\\t\\t\\t\\t\\treturn[[ans[i],ans[i+1]]for i in range(len(ans)-1)]",
                "codeTag": "Java"
            },
            {
                "id": 2685034,
                "title": "python-heirholzer-s-algorithm",
                "content": "\\n    def validArrangement(self, pairs):\\n        dict1, dict2 = defaultdict(list), defaultdict(int)\\n        \\n        for i, j in pairs:\\n            dict1[i].append(j)\\n            dict2[i] += 1\\n            dict2[j] -= 1\\n            \\n        for k in dict2:\\n            if dict2[k] == 1:\\n                i = k\\n                break\\n                \\n        res = []\\n        \\n        def dfs(node):\\n            neighbors = dict1[node]\\n            \\n            while neighbors:\\n                x = neighbors.pop(0)\\n                dfs(x)\\n                \\n            res.append(node)\\n            \\n        dfs(i)\\n        \\n        res.reverse()\\n        \\n        return [[res[i],res[i+1]] for i in range(len(res)-1)]",
                "solutionTags": [],
                "code": "\\n    def validArrangement(self, pairs):\\n        dict1, dict2 = defaultdict(list), defaultdict(int)\\n        \\n        for i, j in pairs:\\n            dict1[i].append(j)\\n            dict2[i] += 1\\n            dict2[j] -= 1\\n            \\n        for k in dict2:\\n            if dict2[k] == 1:\\n                i = k\\n                break\\n                \\n        res = []\\n        \\n        def dfs(node):\\n            neighbors = dict1[node]\\n            \\n            while neighbors:\\n                x = neighbors.pop(0)\\n                dfs(x)\\n                \\n            res.append(node)\\n            \\n        dfs(i)\\n        \\n        res.reverse()\\n        \\n        return [[res[i],res[i+1]] for i in range(len(res)-1)]",
                "codeTag": "Python3"
            },
            {
                "id": 2675060,
                "title": "c-solution-eulerian-path-easy-solution",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tmap<int,vector<int>> m;\\n\\t\\tmap<int,int> out,in;\\n\\t\\tvoid dfs(int u,vector<int>& ans){\\n\\t\\t\\twhile(out[u]!=0){\\n\\t\\t\\t\\tint v = m[u][--out[u]];\\n\\t\\t\\t\\tdfs(v,ans);\\n\\t\\t\\t}\\n\\t\\t\\tans.push_back(u);\\n\\t\\t}\\n\\t\\tvector<vector<int>> validArrangement(vector<vector<int>>& pairs) {\\n\\t\\t\\tfor(auto i: pairs){\\n\\t\\t\\t\\tm[i[0]].push_back(i[1]);\\n\\t\\t\\t\\tout[i[0]]++;\\n\\t\\t\\t\\tin[i[1]]++;\\n\\t\\t\\t}\\n\\t\\t\\tint st = out.begin()->first;\\n\\t\\t\\tfor(auto i: out){\\n\\t\\t\\t\\tif(i.second - in[i.first] == 1) st = i.first;\\n\\t\\t\\t}\\n\\t\\t\\tvector<int> ans;\\n\\t\\t\\tdfs(st,ans);\\n\\n\\t\\t\\tvector<vector<int>> tmp;\\n\\t\\t\\tint prev = *--ans.end();\\n\\n\\t\\t\\tfor(int i=ans.size()-2;i>=0;i--){\\n\\t\\t\\t\\ttmp.push_back({prev,ans[i]});\\n\\t\\t\\t\\tprev = ans[i];\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn tmp;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tmap<int,vector<int>> m;\\n\\t\\tmap<int,int> out,in;\\n\\t\\tvoid dfs(int u,vector<int>& ans){\\n\\t\\t\\twhile(out[u]!=0){\\n\\t\\t\\t\\tint v = m[u][--out[u]];\\n\\t\\t\\t\\tdfs(v,ans);\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2671099,
                "title": "python-solution-faster-90",
                "content": "\\tclass Solution:\\n\\t\\tdef validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\\n\\t\\t\\tg = defaultdict(list)  # graph\\n\\t\\t\\tdin, dout = Counter(), Counter()  #in degree, out degree\\n\\t\\t\\tfor u, v in pairs:\\n\\t\\t\\t\\tg[u].append(v)\\n\\t\\t\\t\\tdout[u] += 1\\n\\t\\t\\t\\tdin[v] += 1\\n\\n\\t\\t\\tS = pairs[0][0]  # Start anywhere if it\\'s an Eulerian cycle.\\n\\t\\t\\tfor p in dout:\\n\\t\\t\\t\\tif dout[p] - din[p] == 1:  # It\\'s an Eulerian trail. Have to start here\\n\\t\\t\\t\\t\\tS = p\\n\\t\\t\\t\\t\\tbreak\\n\\n\\t\\t\\t# Hierholzer\\'s Algorithm:\\n\\t\\t\\troute = []\\n\\t\\t\\tst = [S]\\n\\t\\t\\twhile st:\\n\\t\\t\\t\\twhile g[st[-1]]:\\n\\t\\t\\t\\t\\tst.append(g[st[-1]].pop())\\n\\t\\t\\t\\troute.append(st.pop())\\n\\t\\t\\troute.reverse()\\n\\t\\t\\treturn [[route[i], route[i+1]] for i in range(len(route)-1)]",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\\n\\t\\t\\tg = defaultdict(list)  # graph\\n\\t\\t\\tdin, dout = Counter(), Counter()  #in degree, out degree\\n\\t\\t\\tfor u, v in pairs:\\n\\t\\t\\t\\tg[u].append(v)\\n\\t\\t\\t\\tdout[u] += 1\\n\\t\\t\\t\\tdin[v] += 1\\n\\n\\t\\t\\tS = pairs[0][0]  # Start anywhere if it\\'s an Eulerian cycle.\\n\\t\\t\\tfor p in dout:\\n\\t\\t\\t\\tif dout[p] - din[p] == 1:  # It\\'s an Eulerian trail. Have to start here\\n\\t\\t\\t\\t\\tS = p\\n\\t\\t\\t\\t\\tbreak\\n\\n\\t\\t\\t# Hierholzer\\'s Algorithm:\\n\\t\\t\\troute = []\\n\\t\\t\\tst = [S]\\n\\t\\t\\twhile st:\\n\\t\\t\\t\\twhile g[st[-1]]:\\n\\t\\t\\t\\t\\tst.append(g[st[-1]].pop())\\n\\t\\t\\t\\troute.append(st.pop())\\n\\t\\t\\troute.reverse()\\n\\t\\t\\treturn [[route[i], route[i+1]] for i in range(len(route)-1)]",
                "codeTag": "Java"
            },
            {
                "id": 2592652,
                "title": "python-eulerian-path-dfs-solution-beats-80",
                "content": "```\\nclass Solution:\\n    def validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\\n        graph, indegree, outdegree = defaultdict(deque), defaultdict(int), defaultdict(int)\\n        nodes, temp, path = set(), 0, []\\n        for edge in pairs:\\n            graph[edge[0]].append(edge[1])\\n            indegree[edge[1]] += 1\\n            outdegree[edge[0]] += 1\\n            nodes.add(edge[0]); nodes.add(edge[1])\\n        \\n        def findStart(nodes: Set[int]) -> int:\\n            start = 0\\n            for curNode in nodes:\\n                if outdegree[curNode] - indegree[curNode] == 1:\\n                    return curNode\\n                if outdegree[curNode] > 0:\\n                    start = curNode\\n            return start\\n        \\n        def dfs(path: List[List[int]], curr: int) -> None:\\n            deque = graph[curr]\\n            while deque:\\n                node = deque.popleft()\\n                dfs(path, node)\\n                path.append([curr, node])\\n                \\n        start = findStart(nodes)\\n        dfs(path, start)\\n        return list(reversed(path))\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\\n        graph, indegree, outdegree = defaultdict(deque), defaultdict(int), defaultdict(int)\\n        nodes, temp, path = set(), 0, []\\n        for edge in pairs:\\n            graph[edge[0]].append(edge[1])\\n            indegree[edge[1]] += 1\\n            outdegree[edge[0]] += 1\\n            nodes.add(edge[0]); nodes.add(edge[1])\\n        \\n        def findStart(nodes: Set[int]) -> int:\\n            start = 0\\n            for curNode in nodes:\\n                if outdegree[curNode] - indegree[curNode] == 1:\\n                    return curNode\\n                if outdegree[curNode] > 0:\\n                    start = curNode\\n            return start\\n        \\n        def dfs(path: List[List[int]], curr: int) -> None:\\n            deque = graph[curr]\\n            while deque:\\n                node = deque.popleft()\\n                dfs(path, node)\\n                path.append([curr, node])\\n                \\n        start = findStart(nodes)\\n        dfs(path, start)\\n        return list(reversed(path))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2308666,
                "title": "c-hierholzers-algorithm-for-euler-s-path",
                "content": "Highly recommend this article on Hierholzer\\'s algorithm: https://slaystudy.com/hierholzers-algorithm/\\n```\\nclass Solution {\\nprivate:\\n    void hierholzer(stack<int>&path,unordered_map<int,vector<int>>&graph,unordered_map<int,int>&out,int vertex){\\n        while(out[vertex]>0){\\n            hierholzer(path,graph,out,graph[vertex][--out[vertex]]);\\n        }\\n        path.push(vertex);\\n    }\\npublic:\\n    vector<vector<int>> validArrangement(vector<vector<int>>& pairs) {\\n        unordered_map<int,vector<int>>graph;\\n        unordered_map<int,int>out,in;\\n        for(vector<int>pair:pairs){\\n            graph[pair[0]].push_back(pair[1]);\\n            out[pair[0]]++;\\n            in[pair[1]]++;\\n        }\\n        int start=-1;\\n        for(pair<int,int>deg:out){\\n            if(deg.second-in[deg.first]==1){\\n                start=deg.first;\\n                break;\\n            } else if(deg.second==in[deg.first] and start==-1){\\n                start=deg.first;\\n            }\\n        }\\n        stack<int>path;\\n        vector<int>vpath;\\n        hierholzer(path,graph,out,start);\\n        while(path.size()){\\n            vpath.push_back(path.top());\\n            path.pop();\\n        }\\n        vector<vector<int>>ans;\\n        for(int i=0;i+1<vpath.size();i++){\\n            ans.push_back({vpath[i],vpath[i+1]});\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\nprivate:\\n    void hierholzer(stack<int>&path,unordered_map<int,vector<int>>&graph,unordered_map<int,int>&out,int vertex){\\n        while(out[vertex]>0){\\n            hierholzer(path,graph,out,graph[vertex][--out[vertex]]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2276538,
                "title": "dfs-euler-path",
                "content": "class Solution {\\npublic:\\n    vector<int > path;\\n    unordered_map<int,int > out,in;\\n    unordered_map<int,vector<int >> umap;\\n    \\n    void make_path(int start)\\n    {\\n        while(out[start]>0)\\n        {\\n            int v = umap[start].back();\\n            umap[start].pop_back();\\n            out[start] -= 1;\\n            make_path(v);\\n        }\\n        path.push_back(start);\\n    }\\n    vector<vector<int>> validArrangement(vector<vector<int>>& pairs)\\n    {\\n        int i;\\n        for(i=0;i<pairs.size();i++)\\n        {\\n            umap[pairs[i][0]].push_back(pairs[i][1]);\\n            in[pairs[i][1]]++;\\n            out[pairs[i][0]]++;\\n        }\\n        int start=-1;\\n        for(i=0;i<pairs.size();i++)\\n        {\\n            int v = pairs[i][1];\\n            int u = pairs[i][0];\\n            \\n            if(out[u]-in[u]==1)\\n            {\\n                start = u;\\n                break;\\n            }\\n            else if(out[v]-in[v]==1)\\n            {\\n                start = v;\\n                break;\\n            }\\n        }\\n        if(start==-1)\\n            start = pairs[0][0];\\n        \\n        make_path(start);\\n        \\n        vector<vector<int >> ans;\\n        for(i=path.size()-1;i>=1;i--)\\n        {\\n            ans.push_back({path[i],path[i-1]});\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "Graph"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int > path;\\n    unordered_map<int,int > out,in;\\n    unordered_map<int,vector<int >> umap;\\n    \\n    void make_path(int start)\\n    {\\n        while(out[start]>0)\\n        {\\n            int v = umap[start].back();\\n            umap[start].pop_back();\\n            out[start] -= 1;\\n            make_path(v);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2242271,
                "title": "python-dfs-on-edges",
                "content": "```\\nclass Solution:\\n    def validArrangement(self, q: List[List[int]]) -> List[List[int]]:\\n        def f(i):\\n            while x[i]:\\n                j=x[i].popleft()\\n                f(j)\\n            st.append(i)\\n        st=[]\\n        x=defaultdict(deque)\\n        indegree=defaultdict(int)\\n        for a,b in q:\\n            x[a].append(b)\\n            indegree[b]+=1\\n        start=q[0][0]\\n        for i in x:\\n            if indegree[i]<len(x[i]):\\n                start=i\\n                break\\n        f(start)\\n        res=[]\\n        for i in range(len(st)-1,0,-1):\\n            res.append([st[i],st[i-1]])\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def validArrangement(self, q: List[List[int]]) -> List[List[int]]:\\n        def f(i):\\n            while x[i]:\\n                j=x[i].popleft()\\n                f(j)\\n            st.append(i)\\n        st=[]\\n        x=defaultdict(deque)\\n        indegree=defaultdict(int)\\n        for a,b in q:\\n            x[a].append(b)\\n            indegree[b]+=1\\n        start=q[0][0]\\n        for i in x:\\n            if indegree[i]<len(x[i]):\\n                start=i\\n                break\\n        f(start)\\n        res=[]\\n        for i in range(len(st)-1,0,-1):\\n            res.append([st[i],st[i-1]])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2088696,
                "title": "java-easy-solution-using-hierholzer-algorithm",
                "content": "class Solution {\\n    public int[][] validArrangement(int[][] pairs) {\\n        Graph g = new Graph();\\n        \\n        for (int i=0; i<pairs.length; i++) {\\n            g.addEdge(pairs[i][0], pairs[i][1]);\\n        }\\n        \\n        Map<Integer,Integer> edges=new HashMap<Integer,Integer>();\\n  \\n        for (int key : g.hm.keySet()) {\\n            edges.put(key, g.hm.get(key).size());\\n            \\n        }\\n        \\n        int start = startNode(g);\\n        \\n        if (start == -1) {\\n            return new int[][]{};\\n        }\\n        \\n        Stack<Integer> curr_path = new Stack<Integer>();\\n  \\n        List<Integer> list = new ArrayList<Integer>();\\n  \\n        curr_path.push(start);\\n    \\n        int curr_v = start;\\n        \\n        while (!curr_path.empty())\\n        {\\n            if (edges.containsKey(curr_v) && edges.get(curr_v)>0)\\n            {\\n                curr_path.push(g.hm.get(curr_v).get(edges.get(curr_v) - 1));\\n               // System.out.println(g.hm.get(curr_v).get(edges.get(curr_v) - 1));\\n  \\n                edges.put(curr_v, edges.get(curr_v) - 1);\\n  \\n                curr_v = curr_path.peek();\\n            }\\n            else\\n            {\\n                list.add(curr_path.peek());\\n                curr_path.pop();\\n                if (!curr_path.empty()) {\\n                    curr_v = curr_path.peek();\\n                }\\n                \\n            }\\n        }\\n        \\n        \\n        Collections.reverse(list);\\n        int[][] re = new int[list.size() - 1][2];\\n        \\n        for(int i = 0; i < re.length; i++) {\\n            re[i] = new int[]{list.get(i), list.get(i + 1)};\\n        }\\n        return re;\\n    }\\n    \\n    public int startNode(Graph g) {\\n        \\n        for (int node : g.hm.keySet()) {\\n            int inDegree = g.in.getOrDefault(node, 0), outDegree = g.out.getOrDefault(node, 0);\\n            if (outDegree - inDegree == 1) return node;\\n        }\\n        \\n        for (int node : g.hm.keySet()) {\\n            int outDegree = g.out.getOrDefault(node, 0);\\n            if (outDegree > 0) return node;\\n        }\\n        \\n        return -1;\\n    }\\n}\\n\\nclass Graph {\\n    int v;\\n    HashMap<Integer, List<Integer>> hm;\\n    HashMap<Integer, Integer> in;\\n    HashMap<Integer, Integer> out;\\n    \\n    public Graph() {\\n        hm = new HashMap<>();\\n        in = new HashMap<>();;\\n        out = new HashMap<>();\\n        \\n    }\\n    \\n    public void addEdge(int u, int v) {\\n        if (!hm.containsKey(u)) {\\n            List<Integer> arr = new ArrayList<Integer>();\\n            arr.add(v);\\n            hm.put(u, arr);\\n        }\\n        else {\\n            List<Integer> arr = hm.get(u);\\n            arr.add(v);\\n            hm.put(u, arr);\\n        }\\n        \\n        in.put(v, in.getOrDefault(v, 0) + 1);\\n        out.put(u, out.getOrDefault(u, 0) + 1);\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[][] validArrangement(int[][] pairs) {\\n        Graph g = new Graph();\\n        \\n        for (int i=0; i<pairs.length; i++) {\\n            g.addEdge(pairs[i][0], pairs[i][1]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2086876,
                "title": "python-dfs-close-to-with-eular-explanation-for-directed-graph-few-test-case-fails",
                "content": "https://en.wikipedia.org/wiki/Eulerian_path\\nFew test cases fails , please help in correcting.. \\nthe code is expanded for easy understanding\\n```\\n\\nclass Solution:\\n    def validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\\n        # need to build a directed graph \\n        #pairs.sort(key = lambda x:x[0], reverse=True)\\n        graph = defaultdict(list)\\n        indegree = defaultdict(int)\\n        outdegree = defaultdict(int) \\n        for src, dst in pairs:\\n            graph[src].append(dst)\\n            outdegree[src]+=1\\n            indegree[dst]+=1\\n        \\n        \\'\\'\\'\\n        A directed graph has an Eulerian trail if and only if at most one vertex has (out-degree) \\u2212 (in-degree) = 1, at most one vertex has (in-degree) \\u2212 (out-degree) = 1, every other vertex has equal in-degree and out-degree, and all of its vertices with nonzero degree belong to a single connected component of the underlying undirected graph.[citation needed]\\n\\n        \\'\\'\\'\\n        # the check is not complete valid eular graph check\\n        start_node = pairs[0][0]\\n        for k1, v1 in outdegree.items():            \\n            v2 = indegree[k1]\\n            if v1 - v2 == 1:\\n                start_node = k1\\n                break\\n                \\n        # choose a starting node \\n        # In the directed case with the node with one additional outgoing edge.\\n        #print(outdegree, indegree)\\n        #print(start_node)\\n        #print(graph)\\n        def dfs(src, graph, res):\\n            max_d = -1\\n            next_dst = -1            \\n            for dst in graph[src]:\\n                # try to choose a non bridge\\n                if outdegree[dst] > max_d:\\n                    next_dst = dst\\n                    max_d = outdegree[dst]\\n            if next_dst != -1:\\n                graph[src].remove(next_dst)\\n                outdegree[src]-=1\\n                res.append([src, next_dst])                \\n                dfs(next_dst, graph, res)\\n                \\n        res = []\\n        dfs(start_node, graph, res)\\n            \\n        \\n        # print(visited)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution:\\n    def validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\\n        # need to build a directed graph \\n        #pairs.sort(key = lambda x:x[0], reverse=True)\\n        graph = defaultdict(list)\\n        indegree = defaultdict(int)\\n        outdegree = defaultdict(int) \\n        for src, dst in pairs:\\n            graph[src].append(dst)\\n            outdegree[src]+=1\\n            indegree[dst]+=1\\n        \\n        \\'\\'\\'\\n        A directed graph has an Eulerian trail if and only if at most one vertex has (out-degree) \\u2212 (in-degree) = 1, at most one vertex has (in-degree) \\u2212 (out-degree) = 1, every other vertex has equal in-degree and out-degree, and all of its vertices with nonzero degree belong to a single connected component of the underlying undirected graph.[citation needed]\\n\\n        \\'\\'\\'\\n        # the check is not complete valid eular graph check\\n        start_node = pairs[0][0]\\n        for k1, v1 in outdegree.items():            \\n            v2 = indegree[k1]\\n            if v1 - v2 == 1:\\n                start_node = k1\\n                break\\n                \\n        # choose a starting node \\n        # In the directed case with the node with one additional outgoing edge.\\n        #print(outdegree, indegree)\\n        #print(start_node)\\n        #print(graph)\\n        def dfs(src, graph, res):\\n            max_d = -1\\n            next_dst = -1            \\n            for dst in graph[src]:\\n                # try to choose a non bridge\\n                if outdegree[dst] > max_d:\\n                    next_dst = dst\\n                    max_d = outdegree[dst]\\n            if next_dst != -1:\\n                graph[src].remove(next_dst)\\n                outdegree[src]-=1\\n                res.append([src, next_dst])                \\n                dfs(next_dst, graph, res)\\n                \\n        res = []\\n        dfs(start_node, graph, res)\\n            \\n        \\n        # print(visited)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1943647,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    void dfs(int v, map<int, set<int>>& edge, vector<vector<int>>& sol) {\\n        set<int>& node = edge[v];\\n        while (!node.empty()) {\\n            int u = *node.begin();\\n            node.erase(node.begin());\\n            dfs(u, edge, sol);\\n            sol.push_back({v, u});\\n        }\\n    }\\n    vector<vector<int>> validArrangement(vector<vector<int>>& pairs) {\\n        int n = pairs.size();\\n        map<int, set<int>> edge;\\n        map<int, int> deg;\\n        for (int i = 0; i < n; i++) {\\n            edge[pairs[i][0]].insert(pairs[i][1]);\\n            ++deg[pairs[i][0]];\\n            --deg[pairs[i][1]];\\n            \\n        }\\n        int start = pairs[0][0];\\n        for (pair<int, int> p : deg) {\\n            if (p.second > 0) {\\n                start = p.first;\\n                break;\\n            }\\n        }\\n        vector<vector<int>> sol;\\n        dfs(start, edge, sol);\\n        reverse(sol.begin(), sol.end());\\n        return sol;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(int v, map<int, set<int>>& edge, vector<vector<int>>& sol) {\\n        set<int>& node = edge[v];\\n        while (!node.empty()) {\\n            int u = *node.begin();\\n            node.erase(node.begin());\\n            dfs(u, edge, sol);\\n            sol.push_back({v, u});\\n        }\\n    }\\n    vector<vector<int>> validArrangement(vector<vector<int>>& pairs) {\\n        int n = pairs.size();\\n        map<int, set<int>> edge;\\n        map<int, int> deg;\\n        for (int i = 0; i < n; i++) {\\n            edge[pairs[i][0]].insert(pairs[i][1]);\\n            ++deg[pairs[i][0]];\\n            --deg[pairs[i][1]];\\n            \\n        }\\n        int start = pairs[0][0];\\n        for (pair<int, int> p : deg) {\\n            if (p.second > 0) {\\n                start = p.first;\\n                break;\\n            }\\n        }\\n        vector<vector<int>> sol;\\n        dfs(start, edge, sol);\\n        reverse(sol.begin(), sol.end());\\n        return sol;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1929679,
                "title": "eulerian-path-hierholzer-s-algo-full-explanation",
                "content": "The Eulerian path is that we must visit visit every edge in that path only once , Which is the condition in this condition.\\nThe condition for eulerian path is that:\\nFor Undirected graph: Either every vertex has even degree or excatly two vertices has odd degree\\n\\nFor Directed Graph: Atmost one vertex has indegree-outdegree=1 and at most on vertex has outdegree-indegree=1 and rest all vertix has equal outdegree and indegree\\n\\nIn our case it is given that there is valid arrangment possible so it has made sure that euler path exists so we dont need to check that Since it is directed graph we need to follow that indegree-outdegree rule:\\n\\nStep1: Find the node that has outdegree-indegree=1 that edge would we the start edge\\nStep 2: If no such node exists you can start from any node\\nStep 3: Do dfs on start node and append to our path\\n\\nTime complexity : O(V+E)\\n```\\nfrom collections import defaultdict\\nclass Solution:\\n    def validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\\n        G = defaultdict(list)\\n        din = defaultdict(int)\\n        dout = defaultdict(int)\\n        for v, w in pairs:\\n            G[v].append(w)  #creating an neigbour list\\n            dout[v] += 1      #indegree of end is incremented\\n            din[w] += 1      #outdegree of start is incremented\\n        start = pairs[0][0]   #initialized the start to first pair start\\n        for v in G:\\n            if din[v]+1 == dout[v]:   #finding the start node(hierholzer)\\n                start = v\\n        route = []\\n        def dfs(v):\\n            while G[v]:\\n                w = G[v].pop()\\n                dfs(w)\\n            route.append(v)\\n        dfs(start)\\n        route.reverse()\\n        return [[route[i],route[i+1]] for i in range(len(route)-1)]\\n\\n",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "The Eulerian path is that we must visit visit every edge in that path only once , Which is the condition in this condition.\\nThe condition for eulerian path is that:\\nFor Undirected graph: Either every vertex has even degree or excatly two vertices has odd degree\\n\\nFor Directed Graph: Atmost one vertex has indegree-outdegree=1 and at most on vertex has outdegree-indegree=1 and rest all vertix has equal outdegree and indegree\\n\\nIn our case it is given that there is valid arrangment possible so it has made sure that euler path exists so we dont need to check that Since it is directed graph we need to follow that indegree-outdegree rule:\\n\\nStep1: Find the node that has outdegree-indegree=1 that edge would we the start edge\\nStep 2: If no such node exists you can start from any node\\nStep 3: Do dfs on start node and append to our path\\n\\nTime complexity : O(V+E)\\n```\\nfrom collections import defaultdict\\nclass Solution:\\n    def validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\\n        G = defaultdict(list)\\n        din = defaultdict(int)\\n        dout = defaultdict(int)\\n        for v, w in pairs:\\n            G[v].append(w)  #creating an neigbour list\\n            dout[v] += 1      #indegree of end is incremented\\n            din[w] += 1      #outdegree of start is incremented\\n        start = pairs[0][0]   #initialized the start to first pair start\\n        for v in G:\\n            if din[v]+1 == dout[v]:   #finding the start node(hierholzer)\\n                start = v\\n        route = []\\n        def dfs(v):\\n            while G[v]:\\n                w = G[v].pop()\\n                dfs(w)\\n            route.append(v)\\n        dfs(start)\\n        route.reverse()\\n        return [[route[i],route[i+1]] for i in range(len(route)-1)]\\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 1901739,
                "title": "java-eulerian-path",
                "content": "```\\nclass Solution {\\n    /*\\n    1. We assume the pair is like the edge, it\\'s directed edge from start to end\\n    2. Find valid arrangement of pair when start of current pair = end of previous pair\\n    Find valid arrangement -> find a path\\n    when start of current pair = end of previous pair -> the path able visit all edge or pair\\n    If the path is not valid, means invalid arrangement when we will end up to an end position but couldn\\'t move forward\\n    but we still have other unvisitted edge\\n    \\n    We need to make sure we visit all the edge, and previous end of pair = start of pair\\n    \\n    */\\n    public int[][] validArrangement(int[][] pairs) {\\n        \\n        ///Definition: element in a pair, we assume them like a node\\n        ///1. count in and out of every node\\n        ///2. Verify if exist eulerian path\\n        ///3. find start node\\n        ///4. start dfs from start node add the pair into result\\n        ///5. Validate the pair to make sure we don\\'t left any unvisited pair\\n        \\n        Map<Integer, Integer> in = new HashMap<>(), out = new HashMap<>();\\n        Map<Integer, Stack<Integer>> graph = new HashMap<>();\\n        Set<Integer> set = new HashSet<>();\\n        countInAndOut(in, out, set, pairs, graph);\\n        int start = findStartNode(in, out, set);\\n        if (start == -1) return new int[][]{};\\n        List<Integer> list = new ArrayList<>();\\n        dfs(graph, start, list);\\n        return validate(list, pairs.length);\\n    }\\n    \\n    private int[][] validate(List<Integer> list, int size) {\\n        if (list.size() != size + 1) return new int[][]{};\\n        Collections.reverse(list);\\n        int[][] re = new int[list.size() - 1][2];\\n        \\n        for(int i = 0; i < re.length; i++) {\\n            re[i] = new int[]{list.get(i), list.get(i + 1)};\\n        }\\n        return re;   \\n    }\\n    \\n    private void dfs(Map<Integer, Stack<Integer>> graph, int start, List<Integer> list) {\\n        \\n        if (graph.containsKey(start)) {\\n            Stack<Integer> stack = graph.get(start);\\n            while(!stack.isEmpty()) {\\n                dfs(graph, stack.pop(), list);\\n            }\\n        }\\n        \\n        list.add(start);\\n    }\\n    \\n    private void countInAndOut(Map<Integer, Integer> in, Map<Integer, Integer> out, Set<Integer> set, int[][] pairs,\\n                              Map<Integer, Stack<Integer>> graph) {\\n        for(int[] pair : pairs) {\\n            int u = pair[0], v = pair[1];\\n            out.put(u, out.getOrDefault(u, 0) + 1);\\n            in.put(v, in.getOrDefault(v, 0) + 1);\\n            \\n            set.add(u);\\n            set.add(v);\\n            \\n            Stack<Integer> stack = graph.getOrDefault(u, new Stack<>());\\n            stack.push(v);\\n            graph.put(u, stack);\\n        }\\n    }\\n    \\n    private int findStartNode(Map<Integer, Integer> in, Map<Integer, Integer> out, Set<Integer> set) {\\n        \\n        for(int node : set) {\\n            int inDegree = in.getOrDefault(node, 0), outDegree = out.getOrDefault(node, 0);\\n            if (outDegree - inDegree == 1) return node;\\n        }\\n        \\n        for(int node : set) {\\n            int outDegree = out.getOrDefault(node, 0);\\n            if (outDegree > 0) return node;\\n        }\\n        \\n        return -1;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    /*\\n    1. We assume the pair is like the edge, it\\'s directed edge from start to end\\n    2. Find valid arrangement of pair when start of current pair = end of previous pair\\n    Find valid arrangement -> find a path\\n    when start of current pair = end of previous pair -> the path able visit all edge or pair\\n    If the path is not valid, means invalid arrangement when we will end up to an end position but couldn\\'t move forward\\n    but we still have other unvisitted edge\\n    \\n    We need to make sure we visit all the edge, and previous end of pair = start of pair\\n    \\n    */\\n    public int[][] validArrangement(int[][] pairs) {\\n        \\n        ///Definition: element in a pair, we assume them like a node\\n        ///1. count in and out of every node\\n        ///2. Verify if exist eulerian path\\n        ///3. find start node\\n        ///4. start dfs from start node add the pair into result\\n        ///5. Validate the pair to make sure we don\\'t left any unvisited pair\\n        \\n        Map<Integer, Integer> in = new HashMap<>(), out = new HashMap<>();\\n        Map<Integer, Stack<Integer>> graph = new HashMap<>();\\n        Set<Integer> set = new HashSet<>();\\n        countInAndOut(in, out, set, pairs, graph);\\n        int start = findStartNode(in, out, set);\\n        if (start == -1) return new int[][]{}",
                "codeTag": "Java"
            },
            {
                "id": 1818944,
                "title": "eulerian-dfs-gives-tle",
                "content": "This is the algorithm that I have implemented and it\\'s giving a TLE at test case 31. Any ideas why ? The time complexity is still linear right ?\\n\\nSolution:\\n```\\nclass Solution {\\npublic:\\n    unordered_map<int,unordered_map<int,bool>> g;\\n\\n    void dfs(int source,unordered_map<int,unordered_map<int,bool>> &graph,stack<int> &path){\\n        if(g[source].size() == graph[source].size()){\\n            path.push(source);\\n            return;\\n        }\\n        \\n        for(auto adjacent:graph[source]){\\n            if(adjacent.second){\\n                // Remove that node.   \\n                graph[source][adjacent.first] = false;\\n                g[source][adjacent.first] = true;\\n                dfs(adjacent.first,graph,path);\\n                if(g[source].size() == graph[source].size()){\\n                    path.push(source);\\n                    break;\\n                }\\n            }\\n        }\\n    }\\n    \\n    vector<vector<int>> validArrangement(vector<vector<int>>& pairs) {\\n        unordered_set<int> node;\\n        unordered_map<int,unordered_map<int,bool>> graph;\\n        unordered_map<int,int> indegree;\\n        unordered_map<int,int> outdegree;\\n        \\n        for(auto edge:pairs){\\n            graph[edge[0]][edge[1]] = true;\\n            outdegree[edge[0]]++;\\n            indegree[edge[1]]++;\\n            node.insert(edge[0]);\\n            node.insert(edge[1]);\\n        }\\n\\n        int source = *node.begin();\\n        for(auto &u : node){\\n            if(indegree[u] < outdegree[u]) source=u;\\n        }\\n        stack<int> path;\\n        dfs(source,graph,path);\\n        \\n        vector<int> temp;\\n        while(!path.empty()){\\n            temp.push_back(path.top());\\n            path.pop();\\n        }\\n        \\n        vector<vector<int>> res;\\n        for(int i=0;i<temp.size()-1;i++){\\n            vector<int> t;\\n            t.push_back(temp[i]);\\n            t.push_back(temp[i+1]);\\n            \\n            res.push_back(t);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<int,unordered_map<int,bool>> g;\\n\\n    void dfs(int source,unordered_map<int,unordered_map<int,bool>> &graph,stack<int> &path){\\n        if(g[source].size() == graph[source].size()){\\n            path.push(source);\\n            return;\\n        }\\n        \\n        for(auto adjacent:graph[source]){\\n            if(adjacent.second){\\n                // Remove that node.   \\n                graph[source][adjacent.first] = false;\\n                g[source][adjacent.first] = true;\\n                dfs(adjacent.first,graph,path);\\n                if(g[source].size() == graph[source].size()){\\n                    path.push(source);\\n                    break;\\n                }\\n            }\\n        }\\n    }\\n    \\n    vector<vector<int>> validArrangement(vector<vector<int>>& pairs) {\\n        unordered_set<int> node;\\n        unordered_map<int,unordered_map<int,bool>> graph;\\n        unordered_map<int,int> indegree;\\n        unordered_map<int,int> outdegree;\\n        \\n        for(auto edge:pairs){\\n            graph[edge[0]][edge[1]] = true;\\n            outdegree[edge[0]]++;\\n            indegree[edge[1]]++;\\n            node.insert(edge[0]);\\n            node.insert(edge[1]);\\n        }\\n\\n        int source = *node.begin();\\n        for(auto &u : node){\\n            if(indegree[u] < outdegree[u]) source=u;\\n        }\\n        stack<int> path;\\n        dfs(source,graph,path);\\n        \\n        vector<int> temp;\\n        while(!path.empty()){\\n            temp.push_back(path.top());\\n            path.pop();\\n        }\\n        \\n        vector<vector<int>> res;\\n        for(int i=0;i<temp.size()-1;i++){\\n            vector<int> t;\\n            t.push_back(temp[i]);\\n            t.push_back(temp[i+1]);\\n            \\n            res.push_back(t);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1671653,
                "title": "eulerian-path",
                "content": "```python\\n    def validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\\n        G = defaultdict(list)\\n        netdeg = defaultdict(int)\\n        for u, v in pairs:\\n            G[u] += v,\\n            netdeg[u] += 1\\n            netdeg[v] -= 1\\n        \\n        start = [u for u in netdeg if netdeg[u] == 1]\\n        start = start[0] if start else pairs[0][0]\\n\\n        def dfs(u):  # O(m)\\n            while G[u]:\\n                dfs(G[u].pop())\\n            p.append(u)\\n        \\n        p = []\\n        dfs(start)\\n        return [[v, u] for u, v in zip(p[:-1], p[1:])][::-1]\\n```",
                "solutionTags": [],
                "code": "```python\\n    def validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\\n        G = defaultdict(list)\\n        netdeg = defaultdict(int)\\n        for u, v in pairs:\\n            G[u] += v,\\n            netdeg[u] += 1\\n            netdeg[v] -= 1\\n        \\n        start = [u for u in netdeg if netdeg[u] == 1]\\n        start = start[0] if start else pairs[0][0]\\n\\n        def dfs(u):  # O(m)\\n            while G[u]:\\n                dfs(G[u].pop())\\n            p.append(u)\\n        \\n        p = []\\n        dfs(start)\\n        return [[v, u] for u, v in zip(p[:-1], p[1:])][::-1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1660600,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\\n        pdict = collections.defaultdict(set)\\n        ans = list()\\n        visited = set()\\n        def zero():\\n            return 0\\n        diff = collections.defaultdict(zero)\\n        for i,j in pairs:\\n            diff[i] += 1\\n            diff[j] -= 1\\n            pdict[i].add(j)\\n        \\n        def findStartNode():\\n            full = list(diff.keys())\\n            for node in full:\\n                if diff[node] == 1:\\n                    return node\\n            return i\\n        def arrange(node):\\n            while len(pdict[node]) > 0:\\n                arrange(pdict[node].pop())\\n            ans.append(node)\\n        arrange(findStartNode())\\n        ans.reverse()\\n        return [[ans[i], ans[i+1]] for i in range(len(ans)-1)]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\\n        pdict = collections.defaultdict(set)\\n        ans = list()\\n        visited = set()\\n        def zero():\\n            return 0\\n        diff = collections.defaultdict(zero)\\n        for i,j in pairs:\\n            diff[i] += 1\\n            diff[j] -= 1\\n            pdict[i].add(j)\\n        \\n        def findStartNode():\\n            full = list(diff.keys())\\n            for node in full:\\n                if diff[node] == 1:\\n                    return node\\n            return i\\n        def arrange(node):\\n            while len(pdict[node]) > 0:\\n                arrange(pdict[node].pop())\\n            ans.append(node)\\n        arrange(findStartNode())\\n        ans.reverse()\\n        return [[ans[i], ans[i+1]] for i in range(len(ans)-1)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1659475,
                "title": "go-golang-hierholzers-algo-find-eulerian-path",
                "content": "```\\nfunc validArrangement(pairs [][]int) [][]int {\\n\\tcnt := make(map[int]int)\\n\\tgraph := make(map[int][]int)\\n\\tfor _, p := range pairs {\\n\\t\\tgraph[p[0]] = append(graph[p[0]], p[1])\\n\\t\\tcnt[p[0]]++\\n\\t\\tcnt[p[1]]--\\n\\t}\\n\\n\\tstart := pairs[0][0]\\n\\tfor vertex, inOutDegree := range cnt {\\n\\t\\tif inOutDegree > 0 {\\n\\t\\t\\tstart = vertex\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\t}\\n\\n\\tstack, path := []int{start}, make([]int, 0, len(graph))\\n\\n\\tfor len(stack) > 0 {\\n\\t\\tcur := stack[len(stack)-1]\\n\\n\\t\\tif len(graph[cur]) > 0 {\\n\\t\\t\\tlast := len(graph[cur]) - 1\\n\\n\\t\\t\\tstack = append(stack, graph[cur][last])\\n\\t\\t\\tgraph[cur] = graph[cur][:last]\\n\\t\\t} else {\\n\\t\\t\\tlast := len(stack) - 1\\n\\n\\t\\t\\tpath = append(path, stack[last])\\n\\t\\t\\tstack = stack[:last]\\n\\t\\t}\\n\\t}\\n\\n\\tres := make([][]int, 0, len(graph))\\n\\tfor i := len(path) - 1; i > 0; i-- {\\n\\t\\tres = append(res, []int{path[i], path[i-1]})\\n\\t}\\n\\n\\treturn res\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Graph",
                    "Iterator"
                ],
                "code": "```\\nfunc validArrangement(pairs [][]int) [][]int {\\n\\tcnt := make(map[int]int)\\n\\tgraph := make(map[int][]int)\\n\\tfor _, p := range pairs {\\n\\t\\tgraph[p[0]] = append(graph[p[0]], p[1])\\n\\t\\tcnt[p[0]]++\\n\\t\\tcnt[p[1]]--\\n\\t}\\n\\n\\tstart := pairs[0][0]\\n\\tfor vertex, inOutDegree := range cnt {\\n\\t\\tif inOutDegree > 0 {\\n\\t\\t\\tstart = vertex\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\t}\\n\\n\\tstack, path := []int{start}, make([]int, 0, len(graph))\\n\\n\\tfor len(stack) > 0 {\\n\\t\\tcur := stack[len(stack)-1]\\n\\n\\t\\tif len(graph[cur]) > 0 {\\n\\t\\t\\tlast := len(graph[cur]) - 1\\n\\n\\t\\t\\tstack = append(stack, graph[cur][last])\\n\\t\\t\\tgraph[cur] = graph[cur][:last]\\n\\t\\t} else {\\n\\t\\t\\tlast := len(stack) - 1\\n\\n\\t\\t\\tpath = append(path, stack[last])\\n\\t\\t\\tstack = stack[:last]\\n\\t\\t}\\n\\t}\\n\\n\\tres := make([][]int, 0, len(graph))\\n\\tfor i := len(path) - 1; i > 0; i-- {\\n\\t\\tres = append(res, []int{path[i], path[i-1]})\\n\\t}\\n\\n\\treturn res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1642494,
                "title": "c-concise-euler-path-clean-neat-amateur-friendly",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    /*\\n    Approach Hint:\\n    -Make a directed graph from the given pairs;\\n    -Find the euler path;\\n    \\n    */\\n    \\n    \\n    unordered_set<int> nodes; // contains a list of all the nodes in the graph\\n     \\n    unordered_map<int,vector<int>> adj; // adjacency list of directed graph\\n    unordered_map<int,int> outDegree; // outdegree of nodes\\n    unordered_map<int,int> inDegree; // indegree of nodes \\n    \\n    \\n    deque<int> eulerPath; // will contain the euler path\\n\\n    \\n    //--------------------------------------------------\\n    //DFS function which finds the EULER path\\n    void dfsEuler(int currNode){\\n        \\n        while(outDegree[currNode]){\\n            int adjNode = adj[currNode][outDegree[currNode]-1];\\n            outDegree[currNode]--;\\n\\n            dfsEuler(adjNode);\\n        }\\n\\n        eulerPath.push_front(currNode);\\n        \\n        return;\\n    }\\n    //--------------------------------------------------\\n\\n    vector<vector<int>> validArrangement(vector<vector<int>>& pairs) {\\n\\n        \\n        //1. Create adjacency list of Directed Graph, Indegree, and OutDegree-------------------------\\n        for(auto& e : pairs){\\n            int u = e[0];\\n            int v = e[1];\\n            adj[u].push_back(v);\\n            outDegree[u]++;\\n            inDegree[v]++;\\n            \\n            nodes.insert(u);\\n            nodes.insert(v);\\n        }\\n        //-----------------------------------------------------------------------------------------------\\n        \\n\\n        \\n        \\n        //2. Find the starting node of the EULER PATH--------------------------------------------------\\n        int startNode=INT_MAX;\\n        for(auto node : nodes){\\n            int od = outDegree[node];\\n            int id = inDegree[node];\\n            if(od == 1 + id){\\n                startNode = node;\\n                break;\\n            }\\n        }\\n        if(startNode == INT_MAX)\\n            startNode = pairs[0][0];\\n        //---------------------------------------------------------------------------------------------------\\n\\n        \\n        \\n        //3. Get the  EULER PATH---------------------------------------------------------------------------\\n        dfsEuler(startNode);\\n        //----------------------------------------------------------------------------------------------------\\n\\n\\n        \\n        //4. Finally return the answer---------------------------------------------------------------------------\\n        vector<vector<int>> ans;\\n        for(int i=0;i<eulerPath.size()-1;i++){\\n            ans.push_back({eulerPath[i],eulerPath[i+1]});\\n        }\\n        //----------------------------------------------------------------------------------------------------\\n\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    /*\\n    Approach Hint:\\n    -Make a directed graph from the given pairs;\\n    -Find the euler path;\\n    \\n    */\\n    \\n    \\n    unordered_set<int> nodes; // contains a list of all the nodes in the graph\\n     \\n    unordered_map<int,vector<int>> adj; // adjacency list of directed graph\\n    unordered_map<int,int> outDegree; // outdegree of nodes\\n    unordered_map<int,int> inDegree; // indegree of nodes \\n    \\n    \\n    deque<int> eulerPath; // will contain the euler path\\n\\n    \\n    //--------------------------------------------------\\n    //DFS function which finds the EULER path\\n    void dfsEuler(int currNode){\\n        \\n        while(outDegree[currNode]){\\n            int adjNode = adj[currNode][outDegree[currNode]-1];\\n            outDegree[currNode]--;\\n\\n            dfsEuler(adjNode);\\n        }\\n\\n        eulerPath.push_front(currNode);\\n        \\n        return;\\n    }\\n    //--------------------------------------------------\\n\\n    vector<vector<int>> validArrangement(vector<vector<int>>& pairs) {\\n\\n        \\n        //1. Create adjacency list of Directed Graph, Indegree, and OutDegree-------------------------\\n        for(auto& e : pairs){\\n            int u = e[0];\\n            int v = e[1];\\n            adj[u].push_back(v);\\n            outDegree[u]++;\\n            inDegree[v]++;\\n            \\n            nodes.insert(u);\\n            nodes.insert(v);\\n        }\\n        //-----------------------------------------------------------------------------------------------\\n        \\n\\n        \\n        \\n        //2. Find the starting node of the EULER PATH--------------------------------------------------\\n        int startNode=INT_MAX;\\n        for(auto node : nodes){\\n            int od = outDegree[node];\\n            int id = inDegree[node];\\n            if(od == 1 + id){\\n                startNode = node;\\n                break;\\n            }\\n        }\\n        if(startNode == INT_MAX)\\n            startNode = pairs[0][0];\\n        //---------------------------------------------------------------------------------------------------\\n\\n        \\n        \\n        //3. Get the  EULER PATH---------------------------------------------------------------------------\\n        dfsEuler(startNode);\\n        //----------------------------------------------------------------------------------------------------\\n\\n\\n        \\n        //4. Finally return the answer---------------------------------------------------------------------------\\n        vector<vector<int>> ans;\\n        for(int i=0;i<eulerPath.size()-1;i++){\\n            ans.push_back({eulerPath[i],eulerPath[i+1]});\\n        }\\n        //----------------------------------------------------------------------------------------------------\\n\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1631478,
                "title": "c-eulerian-path",
                "content": "\\n    for all the pairs, construct a directed edge from e[0] ----> e[1]\\n\\n    now in this graph, find the eulerian path, and that would be the answer (means you will get the desired answer from there)\\n\\n    the dfs function is to find the eulerian path in the graph\\n\\n    and also, if the eulerian path is not a eulerian circuit, then for source -> outdegree = indegree + 1, and for destination indegree = outdegree + 1 (this is the way to identify source and destination)\\n\\n\\n\\n\\n```\\n\\nclass Solution {\\npublic:\\n    vector<int> eulerianPath;\\n\\n    void dfs(unordered_map<int, unordered_multiset<int>> &graph, int u) {\\n\\n\\n        while (!graph[u].empty()) {\\n            int v = *graph[u].begin();\\n            graph[u].erase(graph[u].begin());\\n            dfs(graph, v);\\n        }\\n\\n        eulerianPath.push_back(u);\\n    }\\n    vector<vector<int>> validArrangement(vector<vector<int>>& pairs) {\\n\\n        unordered_map<int, unordered_multiset<int>> graph;\\n        unordered_map<int, int> indegree;\\n        unordered_map<int, int> outdegree;\\n\\n        for (auto e : pairs) {\\n            graph[e[0]].insert(e[1]);\\n            // graph[e[1]].insert(e[0]);\\n            outdegree[e[0]]++;\\n            indegree[e[1]]++;\\n\\n\\n        }\\n        int source = pairs[0][0];\\n\\n\\n        // property of source in a eulerian path: outdegree = indegree + 1\\n\\n        for (auto [u, list] : graph)  {\\n            if (outdegree[u] == indegree[u] + 1) {\\n                source = u;\\n                break;\\n            }\\n        }\\n        // cout <<\" SRC : \" << source << \\'\\\\n\\';\\n        dfs(graph, source);\\n        reverse(eulerianPath.begin(), eulerianPath.end());\\n        // for(int i = 0; i < eulerianPath.size(); i++) cout << eulerianPath[i] << \" \";\\n        vector<vector<int>> ans;\\n        for (int i = 0; i < eulerianPath.size() - 1; i++) {\\n            ans.push_back({eulerianPath[i], eulerianPath[i + 1]});\\n        }\\n\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    vector<int> eulerianPath;\\n\\n    void dfs(unordered_map<int, unordered_multiset<int>> &graph, int u) {\\n\\n\\n        while (!graph[u].empty()) {\\n            int v = *graph[u].begin();\\n            graph[u].erase(graph[u].begin());\\n            dfs(graph, v);\\n        }\\n\\n        eulerianPath.push_back(u);\\n    }\\n    vector<vector<int>> validArrangement(vector<vector<int>>& pairs) {\\n\\n        unordered_map<int, unordered_multiset<int>> graph;\\n        unordered_map<int, int> indegree;\\n        unordered_map<int, int> outdegree;\\n\\n        for (auto e : pairs) {\\n            graph[e[0]].insert(e[1]);\\n            // graph[e[1]].insert(e[0]);\\n            outdegree[e[0]]++;\\n            indegree[e[1]]++;\\n\\n\\n        }\\n        int source = pairs[0][0];\\n\\n\\n        // property of source in a eulerian path: outdegree = indegree + 1\\n\\n        for (auto [u, list] : graph)  {\\n            if (outdegree[u] == indegree[u] + 1) {\\n                source = u;\\n                break;\\n            }\\n        }\\n        // cout <<\" SRC : \" << source << \\'\\\\n\\';\\n        dfs(graph, source);\\n        reverse(eulerianPath.begin(), eulerianPath.end());\\n        // for(int i = 0; i < eulerianPath.size(); i++) cout << eulerianPath[i] << \" \";\\n        vector<vector<int>> ans;\\n        for (int i = 0; i < eulerianPath.size() - 1; i++) {\\n            ans.push_back({eulerianPath[i], eulerianPath[i + 1]});\\n        }\\n\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1622922,
                "title": "c-graph-with-hierholzer-s-algorithm-to-find-eulerian-path",
                "content": "```\\npublic class Graph {\\n    Dictionary<int, Dictionary<int, int>> adj;\\n    Dictionary<int, int> degree;\\n    public Graph() {\\n        adj = new Dictionary<int, Dictionary<int, int>>();\\n        degree = new Dictionary<int, int>();\\n    }\\n\\n    public void AddEdge(int u, int v) {\\n        if (!adj.ContainsKey(u)) adj[u] = new Dictionary<int, int>();\\n        adj[u][v] = 1;\\n\\n        degree[u] = degree.GetValueOrDefault(u, 0) + 1;\\n        degree[v] = degree.GetValueOrDefault(v, 0) - 1;\\n    }\\n\\n    public void RemoveEdge(int u, int v) {\\n        adj[u].Remove(v);\\n        degree[u]--;\\n        degree[v]++;\\n    }\\n\\n    public int GetEulerStartVertex() {\\n        int inDegree = 0, outDegree = 0;\\n        int start = -1;\\n\\n        foreach (int u in degree.Keys) {\\n            if (degree[u] == 1 && outDegree == 0) {\\n                outDegree++;\\n                start = u;\\n            } else if (degree[u] == -1 && inDegree == 0) {\\n                inDegree++;\\n            } else if (degree[u] != 0) {\\n                // doesn\\'t have Euler path/circuit\\n                return -1;\\n            }\\n        }\\n       \\n        if (outDegree == 1 && inDegree == 1) {\\n            // has one vertex outdegree = indegree + 1\\n            // has one vertex indegree = outdegree + 1\\n            return start;\\n        } else if (outDegree == 0 && inDegree == 0) {\\n            // Euler circuit\\n            return adj.Keys.FirstOrDefault();\\n        }\\n\\n        return -1;\\n    }\\n\\n    public List<int[]> GetEuler(int v) {\\n        List<int[]> res = new List<int[]>();\\n        var cpath = new Stack<int>();\\n        var epath = new Stack<int>();\\n        cpath.Push(v);\\n\\n        while (cpath.Count > 0) {\\n            int u = cpath.Peek();\\n            \\n            if (adj.ContainsKey(u) && adj[u].Count > 0) {\\n                int k = adj[u].Keys.FirstOrDefault();\\n                cpath.Push(k);\\n                RemoveEdge(u, k);\\n            } else {\\n                // no adjacents\\n                u = cpath.Pop();\\n                epath.Push(u);\\n            }\\n        }\\n\\n        // epath = Euler path/circuit\\n        int prev = epath.Pop();\\n        while (epath.Count > 0) {\\n\\n            int[] itm = new int[2] {\\n                 prev,\\n                 epath.Peek(),\\n             };\\n\\n            prev = epath.Pop();\\n            res.Add(itm);\\n        }\\n\\n        return res;\\n    }\\n\\n}\\n\\npublic class Solution {\\n    Graph g;\\n    public int[][] ValidArrangement(int[][] pairs) {\\n        g = new Graph();\\n\\n        for (int i = 0; i < pairs.Length; i++) {\\n            int[] pair = pairs[i];\\n            g.AddEdge(pair[0], pair[1]);\\n        }\\n\\n        int u = g.GetEulerStartVertex();\\n\\n        // Console.WriteLine(\"u \" + u);\\n        return g.GetEuler(u).ToArray();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Graph"
                ],
                "code": "```\\npublic class Graph {\\n    Dictionary<int, Dictionary<int, int>> adj;\\n    Dictionary<int, int> degree;\\n    public Graph() {\\n        adj = new Dictionary<int, Dictionary<int, int>>();\\n        degree = new Dictionary<int, int>();\\n    }\\n\\n    public void AddEdge(int u, int v) {\\n        if (!adj.ContainsKey(u)) adj[u] = new Dictionary<int, int>();\\n        adj[u][v] = 1;\\n\\n        degree[u] = degree.GetValueOrDefault(u, 0) + 1;\\n        degree[v] = degree.GetValueOrDefault(v, 0) - 1;\\n    }\\n\\n    public void RemoveEdge(int u, int v) {\\n        adj[u].Remove(v);\\n        degree[u]--;\\n        degree[v]++;\\n    }\\n\\n    public int GetEulerStartVertex() {\\n        int inDegree = 0, outDegree = 0;\\n        int start = -1;\\n\\n        foreach (int u in degree.Keys) {\\n            if (degree[u] == 1 && outDegree == 0) {\\n                outDegree++;\\n                start = u;\\n            } else if (degree[u] == -1 && inDegree == 0) {\\n                inDegree++;\\n            } else if (degree[u] != 0) {\\n                // doesn\\'t have Euler path/circuit\\n                return -1;\\n            }\\n        }\\n       \\n        if (outDegree == 1 && inDegree == 1) {\\n            // has one vertex outdegree = indegree + 1\\n            // has one vertex indegree = outdegree + 1\\n            return start;\\n        } else if (outDegree == 0 && inDegree == 0) {\\n            // Euler circuit\\n            return adj.Keys.FirstOrDefault();\\n        }\\n\\n        return -1;\\n    }\\n\\n    public List<int[]> GetEuler(int v) {\\n        List<int[]> res = new List<int[]>();\\n        var cpath = new Stack<int>();\\n        var epath = new Stack<int>();\\n        cpath.Push(v);\\n\\n        while (cpath.Count > 0) {\\n            int u = cpath.Peek();\\n            \\n            if (adj.ContainsKey(u) && adj[u].Count > 0) {\\n                int k = adj[u].Keys.FirstOrDefault();\\n                cpath.Push(k);\\n                RemoveEdge(u, k);\\n            } else {\\n                // no adjacents\\n                u = cpath.Pop();\\n                epath.Push(u);\\n            }\\n        }\\n\\n        // epath = Euler path/circuit\\n        int prev = epath.Pop();\\n        while (epath.Count > 0) {\\n\\n            int[] itm = new int[2] {\\n                 prev,\\n                 epath.Peek(),\\n             };\\n\\n            prev = epath.Pop();\\n            res.Add(itm);\\n        }\\n\\n        return res;\\n    }\\n\\n}\\n\\npublic class Solution {\\n    Graph g;\\n    public int[][] ValidArrangement(int[][] pairs) {\\n        g = new Graph();\\n\\n        for (int i = 0; i < pairs.Length; i++) {\\n            int[] pair = pairs[i];\\n            g.AddEdge(pair[0], pair[1]);\\n        }\\n\\n        int u = g.GetEulerStartVertex();\\n\\n        // Console.WriteLine(\"u \" + u);\\n        return g.GetEuler(u).ToArray();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1620730,
                "title": "clean-code-eulerian-path",
                "content": "```\\nusing GRAPH = unordered_map<int,set<int>>;\\nclass Solution {\\nprivate:\\n    GRAPH g;\\n    unordered_map<int,int> inOutdiffernce;\\n    int _source = INT_MIN;\\n    \\n    void reset() {\\n        _source = INT_MIN;\\n        g.clear();\\n        inOutdiffernce.clear();\\n    }\\n    \\n    void makeGraph(vector<vector<int>>& pairs){\\n        for(auto vec : pairs){\\n            g[vec[0]].insert(vec[1]);\\n            g[vec[1]];\\n            inOutdiffernce[vec[0]]++;\\n            inOutdiffernce[vec[1]]--;\\n        }\\n        \\n        for( auto mapEntry: inOutdiffernce){\\n            if(mapEntry.second == 1)\\n                _source = mapEntry.first;\\n        }\\n        \\n        \\n        if(_source == INT_MIN)\\n            _source = pairs[0][0];  //Eulier cicuit, start from anywhere\\n        \\n    }\\n    \\n    \\n    void findEulierPathAndCicuitHelper(int& source, stack<int>& path){\\n       while(g[source].size() > 0){\\n            auto conVertex = *(g[source].begin());\\n            g[source].erase(conVertex);\\n            findEulierPathAndCicuitHelper(conVertex,path);\\n        }\\n        path.push(source);\\n    }\\n\\n    vector<vector<int>> findEulierinanPath() {\\n        stack<int> path;\\n        findEulierPathAndCicuitHelper(_source,path);\\n        vector<vector<int>>result(path.size()-1,vector<int>(2,0));\\n        int i =0;\\n        while(path.size() > 1){\\n            result[i][0] = path.top();\\n            path.pop();\\n            result[i++][1] = path.top();\\n        }\\n        return result;\\n    }\\n\\npublic:\\n    vector<vector<int>> validArrangement(vector<vector<int>>& pairs) {\\n        reset();\\n        makeGraph(pairs);    \\n        return findEulierinanPath();\\n     \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nusing GRAPH = unordered_map<int,set<int>>;\\nclass Solution {\\nprivate:\\n    GRAPH g;\\n    unordered_map<int,int> inOutdiffernce;\\n    int _source = INT_MIN;\\n    \\n    void reset() {\\n        _source = INT_MIN;\\n        g.clear();\\n        inOutdiffernce.clear();\\n    }\\n    \\n    void makeGraph(vector<vector<int>>& pairs){\\n        for(auto vec : pairs){\\n            g[vec[0]].insert(vec[1]);\\n            g[vec[1]];\\n            inOutdiffernce[vec[0]]++;\\n            inOutdiffernce[vec[1]]--;\\n        }\\n        \\n        for( auto mapEntry: inOutdiffernce){\\n            if(mapEntry.second == 1)\\n                _source = mapEntry.first;\\n        }\\n        \\n        \\n        if(_source == INT_MIN)\\n            _source = pairs[0][0];  //Eulier cicuit, start from anywhere\\n        \\n    }\\n    \\n    \\n    void findEulierPathAndCicuitHelper(int& source, stack<int>& path){\\n       while(g[source].size() > 0){\\n            auto conVertex = *(g[source].begin());\\n            g[source].erase(conVertex);\\n            findEulierPathAndCicuitHelper(conVertex,path);\\n        }\\n        path.push(source);\\n    }\\n\\n    vector<vector<int>> findEulierinanPath() {\\n        stack<int> path;\\n        findEulierPathAndCicuitHelper(_source,path);\\n        vector<vector<int>>result(path.size()-1,vector<int>(2,0));\\n        int i =0;\\n        while(path.size() > 1){\\n            result[i][0] = path.top();\\n            path.pop();\\n            result[i++][1] = path.top();\\n        }\\n        return result;\\n    }\\n\\npublic:\\n    vector<vector<int>> validArrangement(vector<vector<int>>& pairs) {\\n        reset();\\n        makeGraph(pairs);    \\n        return findEulierinanPath();\\n     \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1619454,
                "title": "java-solution-o-n-solution",
                "content": "```\\nclass Solution {\\n    public int[][] validArrangement(int[][] pairs) {\\n        HashMap<Integer, int []> inOutedge  = new HashMap();\\n        HashMap<Integer, Queue<Integer>>  adList = getAdList(pairs, inOutedge);\\n        int start = getStart(inOutedge);\\n        int [][]res = new int [pairs.length][2];\\n        \\n        getRes(start, adList, res, pairs.length-1);\\n        return res;\\n    }\\n    \\n    private HashMap<Integer, Queue<Integer>> getAdList(int [][]pairs, HashMap<Integer, int []> inOutEdge){\\n        HashMap<Integer, Queue<Integer>>  adList = new HashMap();\\n        for(int[] pair : pairs){\\n            int s = pair[0];\\n            int d = pair[1];\\n            Queue<Integer> set = adList.get(s);\\n            if(set == null){\\n                set = new LinkedList();\\n                adList.put(s, set);\\n            }\\n            set.add(d);\\n            int [] sEdgeCnt = inOutEdge.get(s);\\n            int [] dEdgeCnt = inOutEdge.get(d);\\n            if(sEdgeCnt == null){\\n                sEdgeCnt = new int [2];\\n                inOutEdge.put(s, sEdgeCnt);\\n            }\\n            if(dEdgeCnt == null){\\n                dEdgeCnt = new int [2];\\n                inOutEdge.put(d, dEdgeCnt);\\n            }\\n            sEdgeCnt[1]++;\\n            dEdgeCnt[0]++;\\n        }\\n        return adList;\\n    }\\n    \\n        \\n    private int getRes(int k, HashMap<Integer, Queue<Integer>> adList, int [][] res, int idx){\\n        Queue<Integer> edges = adList.get(k);\\n        if(edges == null)\\n            return idx;\\n        while(edges.size() > 0){\\n            int edge = edges.poll();\\n            idx = getRes(edge, adList, res, idx);\\n            res[idx--] = new int []{k, edge};\\n        }\\n        return idx;\\n    }\\n    \\n\\n    private int getStart(HashMap<Integer, int []> map){\\n        int start = -1;\\n        for(Map.Entry<Integer, int[]> entry : map.entrySet()){\\n            int k = entry.getKey();\\n            int inEdge = entry.getValue()[0];\\n            int outEdge = entry.getValue()[1];\\n            start = k;\\n            if(outEdge-inEdge == 1)\\n                return k;\\n        }\\n        return start;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[][] validArrangement(int[][] pairs) {\\n        HashMap<Integer, int []> inOutedge  = new HashMap();\\n        HashMap<Integer, Queue<Integer>>  adList = getAdList(pairs, inOutedge);\\n        int start = getStart(inOutedge);\\n        int [][]res = new int [pairs.length][2];\\n        \\n        getRes(start, adList, res, pairs.length-1);\\n        return res;\\n    }\\n    \\n    private HashMap<Integer, Queue<Integer>> getAdList(int [][]pairs, HashMap<Integer, int []> inOutEdge){\\n        HashMap<Integer, Queue<Integer>>  adList = new HashMap();\\n        for(int[] pair : pairs){\\n            int s = pair[0];\\n            int d = pair[1];\\n            Queue<Integer> set = adList.get(s);\\n            if(set == null){\\n                set = new LinkedList();\\n                adList.put(s, set);\\n            }\\n            set.add(d);\\n            int [] sEdgeCnt = inOutEdge.get(s);\\n            int [] dEdgeCnt = inOutEdge.get(d);\\n            if(sEdgeCnt == null){\\n                sEdgeCnt = new int [2];\\n                inOutEdge.put(s, sEdgeCnt);\\n            }\\n            if(dEdgeCnt == null){\\n                dEdgeCnt = new int [2];\\n                inOutEdge.put(d, dEdgeCnt);\\n            }\\n            sEdgeCnt[1]++;\\n            dEdgeCnt[0]++;\\n        }\\n        return adList;\\n    }\\n    \\n        \\n    private int getRes(int k, HashMap<Integer, Queue<Integer>> adList, int [][] res, int idx){\\n        Queue<Integer> edges = adList.get(k);\\n        if(edges == null)\\n            return idx;\\n        while(edges.size() > 0){\\n            int edge = edges.poll();\\n            idx = getRes(edge, adList, res, idx);\\n            res[idx--] = new int []{k, edge};\\n        }\\n        return idx;\\n    }\\n    \\n\\n    private int getStart(HashMap<Integer, int []> map){\\n        int start = -1;\\n        for(Map.Entry<Integer, int[]> entry : map.entrySet()){\\n            int k = entry.getKey();\\n            int inEdge = entry.getValue()[0];\\n            int outEdge = entry.getValue()[1];\\n            start = k;\\n            if(outEdge-inEdge == 1)\\n                return k;\\n        }\\n        return start;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1568688,
                "content": [
                    {
                        "username": "XinweiWalt",
                        "content": "Can any hero(\\u5927\\u4F6C) provide Java solution?"
                    },
                    {
                        "username": "Yifei_Liang",
                        "content": "why is my output not valid ?![image](https://assets.leetcode.com/users/images/8233d714-5e5f-44e0-a9c8-e361ab1c4e2c_1638676959.590477.png)\\n"
                    },
                    {
                        "username": "saisadashiva2000",
                        "content": "because all pairs must be present in the answer"
                    },
                    {
                        "username": "kuntal0901",
                        "content": "Watch this video and you will be able to solve the problem in a jiffy.\\n[Hierholzer\\'s algorithm](https://www.youtube.com/watch?v=8MpoO2zA2l4)"
                    },
                    {
                        "username": "layyy",
                        "content": "this problem is equivalent to finding Eulerian path"
                    },
                    {
                        "username": "stefan1096",
                        "content": "I am really tired of this type of puzzles.Maybe I better quit this industry or give an extremely long break to Leetcode "
                    },
                    {
                        "username": "reassurance",
                        "content": "You gotta take it slow buddy. You have solved 13000+ questions this year!! Thats crazy. \\nRemember: \"As long as you move forward, your speed does not matter\""
                    },
                    {
                        "username": "nathandrakewithoutchick",
                        "content": "Lmao keep going buddy"
                    }
                ]
            },
            {
                "id": 1576053,
                "content": [
                    {
                        "username": "XinweiWalt",
                        "content": "Can any hero(\\u5927\\u4F6C) provide Java solution?"
                    },
                    {
                        "username": "Yifei_Liang",
                        "content": "why is my output not valid ?![image](https://assets.leetcode.com/users/images/8233d714-5e5f-44e0-a9c8-e361ab1c4e2c_1638676959.590477.png)\\n"
                    },
                    {
                        "username": "saisadashiva2000",
                        "content": "because all pairs must be present in the answer"
                    },
                    {
                        "username": "kuntal0901",
                        "content": "Watch this video and you will be able to solve the problem in a jiffy.\\n[Hierholzer\\'s algorithm](https://www.youtube.com/watch?v=8MpoO2zA2l4)"
                    },
                    {
                        "username": "layyy",
                        "content": "this problem is equivalent to finding Eulerian path"
                    },
                    {
                        "username": "stefan1096",
                        "content": "I am really tired of this type of puzzles.Maybe I better quit this industry or give an extremely long break to Leetcode "
                    },
                    {
                        "username": "reassurance",
                        "content": "You gotta take it slow buddy. You have solved 13000+ questions this year!! Thats crazy. \\nRemember: \"As long as you move forward, your speed does not matter\""
                    },
                    {
                        "username": "nathandrakewithoutchick",
                        "content": "Lmao keep going buddy"
                    }
                ]
            },
            {
                "id": 2068169,
                "content": [
                    {
                        "username": "XinweiWalt",
                        "content": "Can any hero(\\u5927\\u4F6C) provide Java solution?"
                    },
                    {
                        "username": "Yifei_Liang",
                        "content": "why is my output not valid ?![image](https://assets.leetcode.com/users/images/8233d714-5e5f-44e0-a9c8-e361ab1c4e2c_1638676959.590477.png)\\n"
                    },
                    {
                        "username": "saisadashiva2000",
                        "content": "because all pairs must be present in the answer"
                    },
                    {
                        "username": "kuntal0901",
                        "content": "Watch this video and you will be able to solve the problem in a jiffy.\\n[Hierholzer\\'s algorithm](https://www.youtube.com/watch?v=8MpoO2zA2l4)"
                    },
                    {
                        "username": "layyy",
                        "content": "this problem is equivalent to finding Eulerian path"
                    },
                    {
                        "username": "stefan1096",
                        "content": "I am really tired of this type of puzzles.Maybe I better quit this industry or give an extremely long break to Leetcode "
                    },
                    {
                        "username": "reassurance",
                        "content": "You gotta take it slow buddy. You have solved 13000+ questions this year!! Thats crazy. \\nRemember: \"As long as you move forward, your speed does not matter\""
                    },
                    {
                        "username": "nathandrakewithoutchick",
                        "content": "Lmao keep going buddy"
                    }
                ]
            },
            {
                "id": 2059076,
                "content": [
                    {
                        "username": "XinweiWalt",
                        "content": "Can any hero(\\u5927\\u4F6C) provide Java solution?"
                    },
                    {
                        "username": "Yifei_Liang",
                        "content": "why is my output not valid ?![image](https://assets.leetcode.com/users/images/8233d714-5e5f-44e0-a9c8-e361ab1c4e2c_1638676959.590477.png)\\n"
                    },
                    {
                        "username": "saisadashiva2000",
                        "content": "because all pairs must be present in the answer"
                    },
                    {
                        "username": "kuntal0901",
                        "content": "Watch this video and you will be able to solve the problem in a jiffy.\\n[Hierholzer\\'s algorithm](https://www.youtube.com/watch?v=8MpoO2zA2l4)"
                    },
                    {
                        "username": "layyy",
                        "content": "this problem is equivalent to finding Eulerian path"
                    },
                    {
                        "username": "stefan1096",
                        "content": "I am really tired of this type of puzzles.Maybe I better quit this industry or give an extremely long break to Leetcode "
                    },
                    {
                        "username": "reassurance",
                        "content": "You gotta take it slow buddy. You have solved 13000+ questions this year!! Thats crazy. \\nRemember: \"As long as you move forward, your speed does not matter\""
                    },
                    {
                        "username": "nathandrakewithoutchick",
                        "content": "Lmao keep going buddy"
                    }
                ]
            },
            {
                "id": 1967458,
                "content": [
                    {
                        "username": "XinweiWalt",
                        "content": "Can any hero(\\u5927\\u4F6C) provide Java solution?"
                    },
                    {
                        "username": "Yifei_Liang",
                        "content": "why is my output not valid ?![image](https://assets.leetcode.com/users/images/8233d714-5e5f-44e0-a9c8-e361ab1c4e2c_1638676959.590477.png)\\n"
                    },
                    {
                        "username": "saisadashiva2000",
                        "content": "because all pairs must be present in the answer"
                    },
                    {
                        "username": "kuntal0901",
                        "content": "Watch this video and you will be able to solve the problem in a jiffy.\\n[Hierholzer\\'s algorithm](https://www.youtube.com/watch?v=8MpoO2zA2l4)"
                    },
                    {
                        "username": "layyy",
                        "content": "this problem is equivalent to finding Eulerian path"
                    },
                    {
                        "username": "stefan1096",
                        "content": "I am really tired of this type of puzzles.Maybe I better quit this industry or give an extremely long break to Leetcode "
                    },
                    {
                        "username": "reassurance",
                        "content": "You gotta take it slow buddy. You have solved 13000+ questions this year!! Thats crazy. \\nRemember: \"As long as you move forward, your speed does not matter\""
                    },
                    {
                        "username": "nathandrakewithoutchick",
                        "content": "Lmao keep going buddy"
                    }
                ]
            }
        ]
    }
]